{"sha": "3d67703e75912a0f58b43feae8ee8b5b20504dfe", "node_id": "C_kwDOAAsO6NoAKDNkNjc3MDNlNzU5MTJhMGY1OGI0M2ZlYWU4ZWU4YjViMjA1MDRkZmU", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-12-16T11:19:43Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-12-16T11:19:43Z"}, "message": "Merge from rustc", "tree": {"sha": "c05fb48510935410d6bea3011c5442c26bbec2ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c05fb48510935410d6bea3011c5442c26bbec2ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d67703e75912a0f58b43feae8ee8b5b20504dfe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d67703e75912a0f58b43feae8ee8b5b20504dfe", "html_url": "https://github.com/rust-lang/rust/commit/3d67703e75912a0f58b43feae8ee8b5b20504dfe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d67703e75912a0f58b43feae8ee8b5b20504dfe/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33e5b953de13307a4b4206d85b74ea55e81d38a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/33e5b953de13307a4b4206d85b74ea55e81d38a1", "html_url": "https://github.com/rust-lang/rust/commit/33e5b953de13307a4b4206d85b74ea55e81d38a1"}, {"sha": "4251289f27949cec69d8aa39d3891a4977fbc856", "url": "https://api.github.com/repos/rust-lang/rust/commits/4251289f27949cec69d8aa39d3891a4977fbc856", "html_url": "https://github.com/rust-lang/rust/commit/4251289f27949cec69d8aa39d3891a4977fbc856"}], "stats": {"total": 21521, "additions": 13065, "deletions": 8456}, "files": [{"sha": "b29b3a418038ee4407809a38b67f67b7dcf3a010", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -430,7 +430,7 @@ jobs:\n             os: windows-latest-xl\n           - name: dist-x86_64-msvc\n             env:\n-              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --host=x86_64-pc-windows-msvc --target=x86_64-pc-windows-msvc --enable-full-tools --enable-profiler\"\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --host=x86_64-pc-windows-msvc --target=x86_64-pc-windows-msvc --enable-full-tools --enable-profiler --set rust.lto=thin\"\n               SCRIPT: PGO_HOST=x86_64-pc-windows-msvc src/ci/pgo.sh python x.py dist bootstrap --include-default-paths\n               DIST_REQUIRE_ALL_TOOLS: 1\n             os: windows-latest-xl"}, {"sha": "5d05a09f038938cf4e26241a3883989ee8e4dc22", "filename": "Cargo.lock", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -809,9 +809,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.84\"\n+version = \"0.1.85\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"989b2c1ca6e90ad06fdc69d1d1862fa28d27a977be6d92ae2fa762cf61fe0b10\"\n+checksum = \"13e81c6cd7ab79f51a0c927d22858d61ad12bd0b3865f0b13ece02a4486aeabb\"\n dependencies = [\n  \"cc\",\n  \"rustc-std-workspace-core\",\n@@ -4627,9 +4627,9 @@ dependencies = [\n \n [[package]]\n name = \"rustix\"\n-version = \"0.36.3\"\n+version = \"0.36.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0b1fbb4dfc4eb1d390c02df47760bb19a84bb80b301ecc947ab5406394d8223e\"\n+checksum = \"a3807b5d10909833d3e9acd1eb5fb988f79376ff10fce42937de71a449c4c588\"\n dependencies = [\n  \"bitflags\",\n  \"errno\","}, {"sha": "770dee7b54616dfdd0483f837d412d79a9b44ee5", "filename": "RELEASES.md", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,3 +1,94 @@\n+Version 1.66.0 (2022-12-15)\n+==========================\n+\n+Language\n+--------\n+- [Permit specifying explicit discriminants on all `repr(Int)` enums](https://github.com/rust-lang/rust/pull/95710/)\n+  ```rust\n+  #[repr(u8)]\n+  enum Foo {\n+      A(u8) = 0,\n+      B(i8) = 1,\n+      C(bool) = 42,\n+  }\n+  ```\n+- [Allow transmutes between the same type differing only in lifetimes](https://github.com/rust-lang/rust/pull/101520/)\n+- [Change constant evaluation errors from a deny-by-default lint to a hard error](https://github.com/rust-lang/rust/pull/102091/)\n+- [Trigger `must_use` on `impl Trait` for supertraits](https://github.com/rust-lang/rust/pull/102287/)\n+  This makes `impl ExactSizeIterator` respect the existing `#[must_use]` annotation on `Iterator`.\n+- [Allow `..=X` in patterns](https://github.com/rust-lang/rust/pull/102275/)\n+- [Uplift `clippy::for_loops_over_fallibles` lint into rustc](https://github.com/rust-lang/rust/pull/99696/)\n+- [Stabilize `sym` operands in inline assembly](https://github.com/rust-lang/rust/pull/103168/)\n+- [Update to Unicode 15](https://github.com/rust-lang/rust/pull/101912/)\n+- [Opaque types no longer imply lifetime bounds](https://github.com/rust-lang/rust/pull/95474/)\n+  This is a soundness fix which may break code that was erroneously relying on this behavior.\n+\n+Compiler\n+--------\n+- [Add armv5te-none-eabi and thumbv5te-none-eabi tier 3 targets](https://github.com/rust-lang/rust/pull/101329/)\n+  - Refer to Rust's [platform support page][platform-support-doc] for more\n+    information on Rust's tiered platform support.\n+- [Add support for linking against macOS universal libraries](https://github.com/rust-lang/rust/pull/98736)\n+\n+Libraries\n+---------\n+- [Fix `#[derive(Default)]` on a generic `#[default]` enum adding unnecessary `Default` bounds](https://github.com/rust-lang/rust/pull/101040/)\n+- [Update to Unicode 15](https://github.com/rust-lang/rust/pull/101821/)\n+\n+Stabilized APIs\n+---------------\n+\n+- [`proc_macro::Span::source_text`](https://doc.rust-lang.org/stable/proc_macro/struct.Span.html#method.source_text)\n+- [`uX::{checked_add_signed, overflowing_add_signed, saturating_add_signed, wrapping_add_signed}`](https://doc.rust-lang.org/stable/std/primitive.u8.html#method.checked_add_signed)\n+- [`iX::{checked_add_unsigned, overflowing_add_unsigned, saturating_add_unsigned, wrapping_add_unsigned}`](https://doc.rust-lang.org/stable/std/primitive.i8.html#method.checked_add_unsigned)\n+- [`iX::{checked_sub_unsigned, overflowing_sub_unsigned, saturating_sub_unsigned, wrapping_sub_unsigned}`](https://doc.rust-lang.org/stable/std/primitive.i8.html#method.checked_sub_unsigned)\n+- [`BTreeSet::{first, last, pop_first, pop_last}`](https://doc.rust-lang.org/stable/std/collections/struct.BTreeSet.html#method.first)\n+- [`BTreeMap::{first_key_value, last_key_value, first_entry, last_entry, pop_first, pop_last}`](https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html#method.first_key_value)\n+- [Add `AsFd` implementations for stdio lock types on WASI.](https://github.com/rust-lang/rust/pull/101768/)\n+- [`impl TryFrom<Vec<T>> for Box<[T; N]>`](https://doc.rust-lang.org/stable/std/boxed/struct.Box.html#impl-TryFrom%3CVec%3CT%2C%20Global%3E%3E-for-Box%3C%5BT%3B%20N%5D%2C%20Global%3E)\n+- [`core::hint::black_box`](https://doc.rust-lang.org/stable/std/hint/fn.black_box.html)\n+- [`Duration::try_from_secs_{f32,f64}`](https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.try_from_secs_f32)\n+- [`Option::unzip`](https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.unzip)\n+- [`std::os::fd`](https://doc.rust-lang.org/stable/std/os/fd/index.html)\n+\n+\n+Rustdoc\n+-------\n+\n+- [Add Rustdoc warning for invalid HTML tags in the documentation](https://github.com/rust-lang/rust/pull/101720/)\n+\n+Cargo\n+-----\n+\n+- [Added `cargo remove` to remove dependencies from Cargo.toml](https://doc.rust-lang.org/nightly/cargo/commands/cargo-remove.html)\n+- [`cargo publish` now waits for the new version to be downloadable before exiting](https://github.com/rust-lang/cargo/pull/11062)\n+\n+See [detailed release notes](https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-166-2022-12-15) for more.\n+\n+Compatibility Notes\n+-------------------\n+\n+- [Only apply `ProceduralMasquerade` hack to older versions of `rental`](https://github.com/rust-lang/rust/pull/94063/)\n+- [Don't export `__heap_base` and `__data_end` on wasm32-wasi.](https://github.com/rust-lang/rust/pull/102385/)\n+- [Don't export `__wasm_init_memory` on WebAssembly.](https://github.com/rust-lang/rust/pull/102426/)\n+- [Only export `__tls_*` on wasm32-unknown-unknown.](https://github.com/rust-lang/rust/pull/102440/)\n+- [Don't link to `libresolv` in libstd on Darwin](https://github.com/rust-lang/rust/pull/102766/)\n+- [Update libstd's libc to 0.2.135 (to make `libstd` no longer pull in `libiconv.dylib` on Darwin)](https://github.com/rust-lang/rust/pull/103277/)\n+- [Opaque types no longer imply lifetime bounds](https://github.com/rust-lang/rust/pull/95474/)\n+  This is a soundness fix which may break code that was erroneously relying on this behavior.\n+- [Make `order_dependent_trait_objects` show up in future-breakage reports](https://github.com/rust-lang/rust/pull/102635/)\n+- [Change std::process::Command spawning to default to inheriting the parent's signal mask](https://github.com/rust-lang/rust/pull/101077/)\n+\n+Internal Changes\n+----------------\n+\n+These changes do not affect any public interfaces of Rust, but they represent\n+significant improvements to the performance or internals of rustc and related\n+tools.\n+\n+- [Enable BOLT for LLVM compilation](https://github.com/rust-lang/rust/pull/94381/)\n+- [Enable LTO for rustc_driver.so](https://github.com/rust-lang/rust/pull/101403/)\n+\n Version 1.65.0 (2022-11-03)\n ==========================\n "}, {"sha": "8c71332bfabb13d9f45813414978a05c1c9c2fcc", "filename": "compiler/rustc_abi/src/lib.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,6 +1,5 @@\n #![cfg_attr(feature = \"nightly\", feature(step_trait, rustc_attrs, min_specialization))]\n \n-use std::convert::{TryFrom, TryInto};\n use std::fmt;\n #[cfg(feature = \"nightly\")]\n use std::iter::Step;\n@@ -803,12 +802,9 @@ impl Integer {\n     pub fn for_align<C: HasDataLayout>(cx: &C, wanted: Align) -> Option<Integer> {\n         let dl = cx.data_layout();\n \n-        for candidate in [I8, I16, I32, I64, I128] {\n-            if wanted == candidate.align(dl).abi && wanted.bytes() == candidate.size().bytes() {\n-                return Some(candidate);\n-            }\n-        }\n-        None\n+        [I8, I16, I32, I64, I128].into_iter().find(|&candidate| {\n+            wanted == candidate.align(dl).abi && wanted.bytes() == candidate.size().bytes()\n+        })\n     }\n \n     /// Find the largest integer with the given alignment or less."}, {"sha": "2286712f02565974f2623901844c82328e562ff6", "filename": "compiler/rustc_apfloat/src/ieee.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_apfloat%2Fsrc%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_apfloat%2Fsrc%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_apfloat%2Fsrc%2Fieee.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -2,7 +2,6 @@ use crate::{Category, ExpInt, IEK_INF, IEK_NAN, IEK_ZERO};\n use crate::{Float, FloatConvert, ParseError, Round, Status, StatusAnd};\n \n use core::cmp::{self, Ordering};\n-use core::convert::TryFrom;\n use core::fmt::{self, Write};\n use core::marker::PhantomData;\n use core::mem;"}, {"sha": "4fae5ef845f7d95a2cfb947a25daeada6e46cdf7", "filename": "compiler/rustc_arena/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Flib.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -28,7 +28,7 @@ use smallvec::SmallVec;\n use std::alloc::Layout;\n use std::cell::{Cell, RefCell};\n use std::cmp;\n-use std::marker::{PhantomData, Send};\n+use std::marker::PhantomData;\n use std::mem::{self, MaybeUninit};\n use std::ptr::{self, NonNull};\n use std::slice;"}, {"sha": "f933b9b161ca91f56bfb0db9e3f39eaae37e4d54", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -33,7 +33,6 @@ use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use rustc_span::source_map::{respan, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n-use std::convert::TryFrom;\n use std::fmt;\n use std::mem;\n use thin_vec::{thin_vec, ThinVec};\n@@ -1735,8 +1734,10 @@ pub enum StrStyle {\n /// A literal in a meta item.\n #[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct MetaItemLit {\n-    /// The original literal token as written in source code.\n-    pub token_lit: token::Lit,\n+    /// The original literal as written in the source code.\n+    pub symbol: Symbol,\n+    /// The original suffix as written in the source code.\n+    pub suffix: Option<Symbol>,\n     /// The \"semantic\" representation of the literal lowered from the original tokens.\n     /// Strings are unescaped, hexadecimal forms are eliminated, etc.\n     pub kind: LitKind,\n@@ -1746,13 +1747,14 @@ pub struct MetaItemLit {\n /// Similar to `MetaItemLit`, but restricted to string literals.\n #[derive(Clone, Copy, Encodable, Decodable, Debug)]\n pub struct StrLit {\n-    /// The original literal token as written in source code.\n-    pub style: StrStyle,\n+    /// The original literal as written in source code.\n     pub symbol: Symbol,\n+    /// The original suffix as written in source code.\n     pub suffix: Option<Symbol>,\n-    pub span: Span,\n-    /// The unescaped \"semantic\" representation of the literal lowered from the original token.\n+    /// The semantic (unescaped) representation of the literal.\n     pub symbol_unescaped: Symbol,\n+    pub style: StrStyle,\n+    pub span: Span,\n }\n \n impl StrLit {\n@@ -1798,8 +1800,9 @@ pub enum LitKind {\n     /// A string literal (`\"foo\"`). The symbol is unescaped, and so may differ\n     /// from the original token's symbol.\n     Str(Symbol, StrStyle),\n-    /// A byte string (`b\"foo\"`).\n-    ByteStr(Lrc<[u8]>),\n+    /// A byte string (`b\"foo\"`). Not stored as a symbol because it might be\n+    /// non-utf8, and symbols only allow utf8 strings.\n+    ByteStr(Lrc<[u8]>, StrStyle),\n     /// A byte char (`b'f'`).\n     Byte(u8),\n     /// A character literal (`'a'`).\n@@ -1824,7 +1827,7 @@ impl LitKind {\n \n     /// Returns `true` if this literal is byte literal string.\n     pub fn is_bytestr(&self) -> bool {\n-        matches!(self, LitKind::ByteStr(_))\n+        matches!(self, LitKind::ByteStr(..))\n     }\n \n     /// Returns `true` if this is a numeric literal.\n@@ -2463,20 +2466,14 @@ pub enum ModKind {\n     Unloaded,\n }\n \n-#[derive(Copy, Clone, Encodable, Decodable, Debug)]\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, Default)]\n pub struct ModSpans {\n     /// `inner_span` covers the body of the module; for a file module, its the whole file.\n     /// For an inline module, its the span inside the `{ ... }`, not including the curly braces.\n     pub inner_span: Span,\n     pub inject_use_span: Span,\n }\n \n-impl Default for ModSpans {\n-    fn default() -> ModSpans {\n-        ModSpans { inner_span: Default::default(), inject_use_span: Default::default() }\n-    }\n-}\n-\n /// Foreign module declaration.\n ///\n /// E.g., `extern { .. }` or `extern \"C\" { .. }`.\n@@ -3101,7 +3098,7 @@ mod size_asserts {\n     static_assert_size!(ItemKind, 112);\n     static_assert_size!(LitKind, 24);\n     static_assert_size!(Local, 72);\n-    static_assert_size!(MetaItemLit, 48);\n+    static_assert_size!(MetaItemLit, 40);\n     static_assert_size!(Param, 40);\n     static_assert_size!(Pat, 88);\n     static_assert_size!(Path, 24);"}, {"sha": "d99f6ed2c1cd3d842964559774669b83e86dc75b", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,15 +1,15 @@\n //! Functions dealing with attributes and meta items.\n \n-use crate::ast;\n use crate::ast::{AttrArgs, AttrArgsEq, AttrId, AttrItem, AttrKind, AttrStyle, AttrVec, Attribute};\n use crate::ast::{DelimArgs, Expr, ExprKind, LitKind, MetaItemLit};\n use crate::ast::{MacDelimiter, MetaItem, MetaItemKind, NestedMetaItem, NormalAttr};\n-use crate::ast::{Path, PathSegment, StrStyle, DUMMY_NODE_ID};\n+use crate::ast::{Path, PathSegment, DUMMY_NODE_ID};\n use crate::ptr::P;\n use crate::token::{self, CommentKind, Delimiter, Token};\n use crate::tokenstream::{DelimSpan, Spacing, TokenTree};\n use crate::tokenstream::{LazyAttrTokenStream, TokenStream};\n use crate::util::comments;\n+use crate::util::literal::escape_string_symbol;\n use rustc_data_structures::sync::WorkerLocal;\n use rustc_index::bit_set::GrowableBitSet;\n use rustc_span::symbol::{sym, Ident, Symbol};\n@@ -321,18 +321,6 @@ impl Attribute {\n     }\n }\n \n-/* Constructors */\n-\n-pub fn mk_name_value_item_str(ident: Ident, str: Symbol, str_span: Span) -> MetaItem {\n-    mk_name_value_item(ident, LitKind::Str(str, ast::StrStyle::Cooked), str_span)\n-}\n-\n-pub fn mk_name_value_item(ident: Ident, kind: LitKind, lit_span: Span) -> MetaItem {\n-    let lit = MetaItemLit { token_lit: kind.to_token_lit(), kind, span: lit_span };\n-    let span = ident.span.to(lit_span);\n-    MetaItem { path: Path::from_ident(ident), kind: MetaItemKind::NameValue(lit), span }\n-}\n-\n pub struct AttrIdGenerator(WorkerLocal<Cell<u32>>);\n \n #[cfg(debug_assertions)]\n@@ -408,7 +396,7 @@ pub fn mk_attr_name_value_str(\n     val: Symbol,\n     span: Span,\n ) -> Attribute {\n-    let lit = LitKind::Str(val, StrStyle::Cooked).to_token_lit();\n+    let lit = token::Lit::new(token::Str, escape_string_symbol(val), None);\n     let expr = P(Expr {\n         id: DUMMY_NODE_ID,\n         kind: ExprKind::Lit(lit),"}, {"sha": "4b2850336a03db2479ec59804de725eb26ff23ae", "filename": "compiler/rustc_ast/src/ptr.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_ast%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_ast%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fptr.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -22,7 +22,6 @@\n //!   Moreover, a switch to, e.g., `P<'a, T>` would be easy and mostly automated.\n \n use std::fmt::{self, Debug, Display};\n-use std::iter::FromIterator;\n use std::ops::{Deref, DerefMut};\n use std::{slice, vec};\n "}, {"sha": "7b8c0d79a17e8519f3fc79a3f65149db2f2537dc", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -114,7 +114,7 @@ impl Lit {\n                 if let NtExpr(expr) | NtLiteral(expr) = &**nt\n                 && let ast::ExprKind::Lit(token_lit) = expr.kind =>\n             {\n-                Some(token_lit.clone())\n+                Some(token_lit)\n             }\n             _ => None,\n         }"}, {"sha": "29a5eb4b7c509260a9034296eec158af8abcb123", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -362,7 +362,7 @@ impl TokenStream {\n     }\n }\n \n-impl iter::FromIterator<TokenTree> for TokenStream {\n+impl FromIterator<TokenTree> for TokenStream {\n     fn from_iter<I: IntoIterator<Item = TokenTree>>(iter: I) -> Self {\n         TokenStream::new(iter.into_iter().collect::<Vec<TokenTree>>())\n     }"}, {"sha": "0daeecb53a8b9d88a1432fa05440360de7096cad", "filename": "compiler/rustc_ast/src/util/literal.rs", "status": "modified", "additions": 94, "deletions": 48, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,11 +1,31 @@\n //! Code related to parsing literals.\n \n-use crate::ast::{self, LitKind, MetaItemLit};\n+use crate::ast::{self, LitKind, MetaItemLit, StrStyle};\n use crate::token::{self, Token};\n use rustc_lexer::unescape::{byte_from_char, unescape_byte, unescape_char, unescape_literal, Mode};\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n-use std::ascii;\n+use std::{ascii, fmt, str};\n+\n+// Escapes a string, represented as a symbol. Reuses the original symbol,\n+// avoiding interning, if no changes are required.\n+pub fn escape_string_symbol(symbol: Symbol) -> Symbol {\n+    let s = symbol.as_str();\n+    let escaped = s.escape_default().to_string();\n+    if s == escaped { symbol } else { Symbol::intern(&escaped) }\n+}\n+\n+// Escapes a char.\n+pub fn escape_char_symbol(ch: char) -> Symbol {\n+    let s: String = ch.escape_default().map(Into::<char>::into).collect();\n+    Symbol::intern(&s)\n+}\n+\n+// Escapes a byte string.\n+pub fn escape_byte_str_symbol(bytes: &[u8]) -> Symbol {\n+    let s = bytes.escape_ascii().to_string();\n+    Symbol::intern(&s)\n+}\n \n #[derive(Debug)]\n pub enum LitError {\n@@ -115,9 +135,9 @@ impl LitKind {\n                     }\n                 });\n                 error?;\n-                LitKind::ByteStr(buf.into())\n+                LitKind::ByteStr(buf.into(), StrStyle::Cooked)\n             }\n-            token::ByteStrRaw(_) => {\n+            token::ByteStrRaw(n) => {\n                 let s = symbol.as_str();\n                 let bytes = if s.contains('\\r') {\n                     let mut buf = Vec::with_capacity(s.len());\n@@ -136,69 +156,95 @@ impl LitKind {\n                     symbol.to_string().into_bytes()\n                 };\n \n-                LitKind::ByteStr(bytes.into())\n+                LitKind::ByteStr(bytes.into(), StrStyle::Raw(n))\n             }\n             token::Err => LitKind::Err,\n         })\n     }\n+}\n \n-    /// Attempts to recover a token from semantic literal.\n-    /// This function is used when the original token doesn't exist (e.g. the literal is created\n-    /// by an AST-based macro) or unavailable (e.g. from HIR pretty-printing).\n-    pub fn to_token_lit(&self) -> token::Lit {\n-        let (kind, symbol, suffix) = match *self {\n-            LitKind::Str(symbol, ast::StrStyle::Cooked) => {\n-                // Don't re-intern unless the escaped string is different.\n-                let s = symbol.as_str();\n-                let escaped = s.escape_default().to_string();\n-                let symbol = if s == escaped { symbol } else { Symbol::intern(&escaped) };\n-                (token::Str, symbol, None)\n-            }\n-            LitKind::Str(symbol, ast::StrStyle::Raw(n)) => (token::StrRaw(n), symbol, None),\n-            LitKind::ByteStr(ref bytes) => {\n-                let string = bytes.escape_ascii().to_string();\n-                (token::ByteStr, Symbol::intern(&string), None)\n+impl fmt::Display for LitKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            LitKind::Byte(b) => {\n+                let b: String = ascii::escape_default(b).map(Into::<char>::into).collect();\n+                write!(f, \"b'{}'\", b)?;\n             }\n-            LitKind::Byte(byte) => {\n-                let string: String = ascii::escape_default(byte).map(Into::<char>::into).collect();\n-                (token::Byte, Symbol::intern(&string), None)\n+            LitKind::Char(ch) => write!(f, \"'{}'\", escape_char_symbol(ch))?,\n+            LitKind::Str(sym, StrStyle::Cooked) => write!(f, \"\\\"{}\\\"\", escape_string_symbol(sym))?,\n+            LitKind::Str(sym, StrStyle::Raw(n)) => write!(\n+                f,\n+                \"r{delim}\\\"{string}\\\"{delim}\",\n+                delim = \"#\".repeat(n as usize),\n+                string = sym\n+            )?,\n+            LitKind::ByteStr(ref bytes, StrStyle::Cooked) => {\n+                write!(f, \"b\\\"{}\\\"\", escape_byte_str_symbol(bytes))?\n             }\n-            LitKind::Char(ch) => {\n-                let string: String = ch.escape_default().map(Into::<char>::into).collect();\n-                (token::Char, Symbol::intern(&string), None)\n+            LitKind::ByteStr(ref bytes, StrStyle::Raw(n)) => {\n+                // Unwrap because raw byte string literals can only contain ASCII.\n+                let symbol = str::from_utf8(bytes).unwrap();\n+                write!(\n+                    f,\n+                    \"br{delim}\\\"{string}\\\"{delim}\",\n+                    delim = \"#\".repeat(n as usize),\n+                    string = symbol\n+                )?;\n             }\n             LitKind::Int(n, ty) => {\n-                let suffix = match ty {\n-                    ast::LitIntType::Unsigned(ty) => Some(ty.name()),\n-                    ast::LitIntType::Signed(ty) => Some(ty.name()),\n-                    ast::LitIntType::Unsuffixed => None,\n-                };\n-                (token::Integer, sym::integer(n), suffix)\n+                write!(f, \"{}\", n)?;\n+                match ty {\n+                    ast::LitIntType::Unsigned(ty) => write!(f, \"{}\", ty.name())?,\n+                    ast::LitIntType::Signed(ty) => write!(f, \"{}\", ty.name())?,\n+                    ast::LitIntType::Unsuffixed => {}\n+                }\n             }\n             LitKind::Float(symbol, ty) => {\n-                let suffix = match ty {\n-                    ast::LitFloatType::Suffixed(ty) => Some(ty.name()),\n-                    ast::LitFloatType::Unsuffixed => None,\n-                };\n-                (token::Float, symbol, suffix)\n+                write!(f, \"{}\", symbol)?;\n+                match ty {\n+                    ast::LitFloatType::Suffixed(ty) => write!(f, \"{}\", ty.name())?,\n+                    ast::LitFloatType::Unsuffixed => {}\n+                }\n             }\n-            LitKind::Bool(value) => {\n-                let symbol = if value { kw::True } else { kw::False };\n-                (token::Bool, symbol, None)\n+            LitKind::Bool(b) => write!(f, \"{}\", if b { \"true\" } else { \"false\" })?,\n+            LitKind::Err => {\n+                // This only shows up in places like `-Zunpretty=hir` output, so we\n+                // don't bother to produce something useful.\n+                write!(f, \"<bad-literal>\")?;\n             }\n-            // This only shows up in places like `-Zunpretty=hir` output, so we\n-            // don't bother to produce something useful.\n-            LitKind::Err => (token::Err, Symbol::intern(\"<bad-literal>\"), None),\n-        };\n+        }\n \n-        token::Lit::new(kind, symbol, suffix)\n+        Ok(())\n     }\n }\n \n impl MetaItemLit {\n-    /// Converts token literal into a meta item literal.\n+    /// Converts a token literal into a meta item literal.\n     pub fn from_token_lit(token_lit: token::Lit, span: Span) -> Result<MetaItemLit, LitError> {\n-        Ok(MetaItemLit { token_lit, kind: LitKind::from_token_lit(token_lit)?, span })\n+        Ok(MetaItemLit {\n+            symbol: token_lit.symbol,\n+            suffix: token_lit.suffix,\n+            kind: LitKind::from_token_lit(token_lit)?,\n+            span,\n+        })\n+    }\n+\n+    /// Cheaply converts a meta item literal into a token literal.\n+    pub fn as_token_lit(&self) -> token::Lit {\n+        let kind = match self.kind {\n+            LitKind::Bool(_) => token::Bool,\n+            LitKind::Str(_, ast::StrStyle::Cooked) => token::Str,\n+            LitKind::Str(_, ast::StrStyle::Raw(n)) => token::StrRaw(n),\n+            LitKind::ByteStr(_, ast::StrStyle::Cooked) => token::ByteStr,\n+            LitKind::ByteStr(_, ast::StrStyle::Raw(n)) => token::ByteStrRaw(n),\n+            LitKind::Byte(_) => token::Byte,\n+            LitKind::Char(_) => token::Char,\n+            LitKind::Int(..) => token::Integer,\n+            LitKind::Float(..) => token::Float,\n+            LitKind::Err => token::Err,\n+        };\n+\n+        token::Lit::new(kind, self.symbol, self.suffix)\n     }\n \n     /// Converts an arbitrary token into meta item literal."}, {"sha": "e86e807279d6f10157264705e42e49c8b8c872d0", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 49, "deletions": 38, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -31,6 +31,44 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     pub(super) fn lower_expr_mut(&mut self, e: &Expr) -> hir::Expr<'hir> {\n         ensure_sufficient_stack(|| {\n+            match &e.kind {\n+                // Paranthesis expression does not have a HirId and is handled specially.\n+                ExprKind::Paren(ex) => {\n+                    let mut ex = self.lower_expr_mut(ex);\n+                    // Include parens in span, but only if it is a super-span.\n+                    if e.span.contains(ex.span) {\n+                        ex.span = self.lower_span(e.span);\n+                    }\n+                    // Merge attributes into the inner expression.\n+                    if !e.attrs.is_empty() {\n+                        let old_attrs =\n+                            self.attrs.get(&ex.hir_id.local_id).map(|la| *la).unwrap_or(&[]);\n+                        self.attrs.insert(\n+                            ex.hir_id.local_id,\n+                            &*self.arena.alloc_from_iter(\n+                                e.attrs\n+                                    .iter()\n+                                    .map(|a| self.lower_attr(a))\n+                                    .chain(old_attrs.iter().cloned()),\n+                            ),\n+                        );\n+                    }\n+                    return ex;\n+                }\n+                // Desugar `ExprForLoop`\n+                // from: `[opt_ident]: for <pat> in <head> <body>`\n+                //\n+                // This also needs special handling because the HirId of the returned `hir::Expr` will not\n+                // correspond to the `e.id`, so `lower_expr_for` handles attribute lowering itself.\n+                ExprKind::ForLoop(pat, head, body, opt_label) => {\n+                    return self.lower_expr_for(e, pat, head, body, *opt_label);\n+                }\n+                _ => (),\n+            }\n+\n+            let hir_id = self.lower_node_id(e.id);\n+            self.lower_attrs(hir_id, &e.attrs);\n+\n             let kind = match &e.kind {\n                 ExprKind::Box(inner) => hir::ExprKind::Box(self.lower_expr(inner)),\n                 ExprKind::Array(exprs) => hir::ExprKind::Array(self.lower_exprs(exprs)),\n@@ -48,7 +86,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     if e.attrs.get(0).map_or(false, |a| a.has_name(sym::rustc_box)) {\n                         if let [inner] = &args[..] && e.attrs.len() == 1 {\n                             let kind = hir::ExprKind::Box(self.lower_expr(&inner));\n-                            let hir_id = self.lower_node_id(e.id);\n                             return hir::Expr { hir_id, kind, span: self.lower_span(e.span) };\n                         } else {\n                             self.tcx.sess.emit_err(RustcBoxAttributeError { span: e.span });\n@@ -97,7 +134,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 }\n                 ExprKind::IncludedBytes(bytes) => hir::ExprKind::Lit(respan(\n                     self.lower_span(e.span),\n-                    LitKind::ByteStr(bytes.clone()),\n+                    LitKind::ByteStr(bytes.clone(), StrStyle::Cooked),\n                 )),\n                 ExprKind::Cast(expr, ty) => {\n                     let expr = self.lower_expr(expr);\n@@ -147,7 +184,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ),\n                 ExprKind::Async(capture_clause, closure_node_id, block) => self.make_async_expr(\n                     *capture_clause,\n-                    None,\n+                    hir_id,\n                     *closure_node_id,\n                     None,\n                     e.span,\n@@ -184,6 +221,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             binder,\n                             *capture_clause,\n                             e.id,\n+                            hir_id,\n                             *closure_id,\n                             fn_decl,\n                             body,\n@@ -279,39 +317,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ExprKind::Yield(opt_expr) => self.lower_expr_yield(e.span, opt_expr.as_deref()),\n                 ExprKind::Err => hir::ExprKind::Err,\n                 ExprKind::Try(sub_expr) => self.lower_expr_try(e.span, sub_expr),\n-                ExprKind::Paren(ex) => {\n-                    let mut ex = self.lower_expr_mut(ex);\n-                    // Include parens in span, but only if it is a super-span.\n-                    if e.span.contains(ex.span) {\n-                        ex.span = self.lower_span(e.span);\n-                    }\n-                    // Merge attributes into the inner expression.\n-                    if !e.attrs.is_empty() {\n-                        let old_attrs =\n-                            self.attrs.get(&ex.hir_id.local_id).map(|la| *la).unwrap_or(&[]);\n-                        self.attrs.insert(\n-                            ex.hir_id.local_id,\n-                            &*self.arena.alloc_from_iter(\n-                                e.attrs\n-                                    .iter()\n-                                    .map(|a| self.lower_attr(a))\n-                                    .chain(old_attrs.iter().cloned()),\n-                            ),\n-                        );\n-                    }\n-                    return ex;\n-                }\n \n-                // Desugar `ExprForLoop`\n-                // from: `[opt_ident]: for <pat> in <head> <body>`\n-                ExprKind::ForLoop(pat, head, body, opt_label) => {\n-                    return self.lower_expr_for(e, pat, head, body, *opt_label);\n-                }\n+                ExprKind::Paren(_) | ExprKind::ForLoop(..) => unreachable!(\"already handled\"),\n+\n                 ExprKind::MacCall(_) => panic!(\"{:?} shouldn't exist here\", e.span),\n             };\n \n-            let hir_id = self.lower_node_id(e.id);\n-            self.lower_attrs(hir_id, &e.attrs);\n             hir::Expr { hir_id, kind, span: self.lower_span(e.span) }\n         })\n     }\n@@ -576,7 +587,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     pub(super) fn make_async_expr(\n         &mut self,\n         capture_clause: CaptureBy,\n-        outer_hir_id: Option<hir::HirId>,\n+        outer_hir_id: hir::HirId,\n         closure_node_id: NodeId,\n         ret_ty: Option<hir::FnRetTy<'hir>>,\n         span: Span,\n@@ -669,8 +680,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             hir::ExprKind::Closure(c)\n         };\n \n-        let track_caller = outer_hir_id\n-            .and_then(|id| self.attrs.get(&id.local_id))\n+        let track_caller = self\n+            .attrs\n+            .get(&outer_hir_id.local_id)\n             .map_or(false, |attrs| attrs.into_iter().any(|attr| attr.has_name(sym::track_caller)));\n \n         let hir_id = self.lower_node_id(closure_node_id);\n@@ -985,6 +997,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         binder: &ClosureBinder,\n         capture_clause: CaptureBy,\n         closure_id: NodeId,\n+        closure_hir_id: hir::HirId,\n         inner_closure_id: NodeId,\n         decl: &FnDecl,\n         body: &Expr,\n@@ -1018,9 +1031,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n                 let async_body = this.make_async_expr(\n                     capture_clause,\n-                    // FIXME(nbdd0121): This should also use a proper HIR id so `#[track_caller]`\n-                    // can be applied on async closures as well.\n-                    None,\n+                    closure_hir_id,\n                     inner_closure_id,\n                     async_ret_ty,\n                     body.span,"}, {"sha": "73065ab516350fe33c50fae50de39a228278340f", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1139,7 +1139,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n             let async_expr = this.make_async_expr(\n                 CaptureBy::Value,\n-                Some(fn_id),\n+                fn_id,\n                 closure_id,\n                 None,\n                 body.span,"}, {"sha": "d67ede6e1302ef731017cf5f61d9ec7ab56dc87a", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -456,8 +456,8 @@ pub fn lower_to_hir<'hir>(tcx: TyCtxt<'hir>, (): ()) -> hir::Crate<'hir> {\n     }\n \n     // Drop AST to free memory\n-    std::mem::drop(ast_index);\n-    sess.time(\"drop_ast\", || std::mem::drop(krate));\n+    drop(ast_index);\n+    sess.time(\"drop_ast\", || drop(krate));\n \n     // Discard hygiene data, which isn't required after lowering to HIR.\n     if !sess.opts.unstable_opts.keep_hygiene_data {\n@@ -958,7 +958,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     lit\n                 } else {\n                     MetaItemLit {\n-                        token_lit: token::Lit::new(token::LitKind::Err, kw::Empty, None),\n+                        symbol: kw::Empty,\n+                        suffix: None,\n                         kind: LitKind::Err,\n                         span: DUMMY_SP,\n                     }"}, {"sha": "039338f543cc591b19b88055b80f6888d47a9310", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -630,7 +630,7 @@ fn check_incompatible_features(sess: &Session) {\n             {\n                 let spans = vec![f1_span, f2_span];\n                 sess.struct_span_err(\n-                    spans.clone(),\n+                    spans,\n                     &format!(\n                         \"features `{}` and `{}` are incompatible, using them at the same time \\\n                         is not allowed\","}, {"sha": "d0e4761a10db8978519b3326d5718ead15bf29b7", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -376,7 +376,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n     }\n \n     fn print_meta_item_lit(&mut self, lit: &ast::MetaItemLit) {\n-        self.print_token_literal(lit.token_lit, lit.span)\n+        self.print_token_literal(lit.as_token_lit(), lit.span)\n     }\n \n     fn print_token_literal(&mut self, token_lit: token::Lit, span: Span) {"}, {"sha": "3b17f6dd627ebb15eeebb66b0ab4d4730b22aeaf", "filename": "compiler/rustc_ast_pretty/src/pprust/state/expr.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -2,6 +2,8 @@ use crate::pp::Breaks::Inconsistent;\n use crate::pprust::state::{AnnNode, IterDelimited, PrintState, State, INDENT_UNIT};\n \n use rustc_ast::ptr::P;\n+use rustc_ast::token;\n+use rustc_ast::util::literal::escape_byte_str_symbol;\n use rustc_ast::util::parser::{self, AssocOp, Fixity};\n use rustc_ast::{self as ast, BlockCheckMode};\n \n@@ -323,7 +325,7 @@ impl<'a> State<'a> {\n                 self.print_token_literal(*token_lit, expr.span);\n             }\n             ast::ExprKind::IncludedBytes(bytes) => {\n-                let lit = ast::LitKind::ByteStr(bytes.clone()).to_token_lit();\n+                let lit = token::Lit::new(token::ByteStr, escape_byte_str_symbol(bytes), None);\n                 self.print_token_literal(lit, expr.span)\n             }\n             ast::ExprKind::Cast(expr, ty) => {"}, {"sha": "72c0257756ef2f15d1adfdc8f47a2e143ced6ccc", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -697,8 +697,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     .map_bound(|p| p.predicates),\n                 None,\n             ),\n-            ty::Opaque(did, substs) => {\n-                find_fn_kind_from_did(tcx.bound_explicit_item_bounds(*did), Some(*substs))\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n+                find_fn_kind_from_did(tcx.bound_explicit_item_bounds(*def_id), Some(*substs))\n             }\n             ty::Closure(_, substs) => match substs.as_closure().kind() {\n                 ty::ClosureKind::Fn => Some(hir::Mutability::Not),\n@@ -745,7 +745,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             err.span_suggestion_verbose(\n                 span.shrink_to_hi(),\n                 \"consider cloning the value if the performance cost is acceptable\",\n-                \".clone()\".to_string(),\n+                \".clone()\",\n                 Applicability::MachineApplicable,\n             );\n         }"}, {"sha": "cbd590052008c14a46f3ab0b099ea517ef6f7ce9", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1059,17 +1059,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     );\n                     if self.fn_self_span_reported.insert(fn_span) {\n                         err.span_note(\n-                            // Check whether the source is accessible\n-                            if self.infcx.tcx.sess.source_map().is_span_accessible(self_arg.span) {\n-                                self_arg.span\n-                            } else {\n-                                fn_call_span\n-                            },\n+                            self_arg.span,\n                             \"calling this operator moves the left-hand side\",\n                         );\n                     }\n                 }\n-                CallKind::Normal { self_arg, desugaring, is_option_or_result } => {\n+                CallKind::Normal { self_arg, desugaring, method_did } => {\n                     let self_arg = self_arg.unwrap();\n                     if let Some((CallDesugaringKind::ForLoopIntoIter, _)) = desugaring {\n                         let ty = moved_place.ty(self.body, self.infcx.tcx).ty;\n@@ -1139,14 +1134,27 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             ),\n                         );\n                     }\n+                    let tcx = self.infcx.tcx;\n                     // Avoid pointing to the same function in multiple different\n                     // error messages.\n                     if span != DUMMY_SP && self.fn_self_span_reported.insert(self_arg.span) {\n+                        let func = tcx.def_path_str(method_did);\n                         err.span_note(\n                             self_arg.span,\n-                            &format!(\"this function takes ownership of the receiver `self`, which moves {}\", place_name)\n+                            &format!(\"`{func}` takes ownership of the receiver `self`, which moves {place_name}\")\n                         );\n                     }\n+                    let parent_did = tcx.parent(method_did);\n+                    let parent_self_ty = (tcx.def_kind(parent_did)\n+                        == rustc_hir::def::DefKind::Impl)\n+                        .then_some(parent_did)\n+                        .and_then(|did| match tcx.type_of(did).kind() {\n+                            ty::Adt(def, ..) => Some(def.did()),\n+                            _ => None,\n+                        });\n+                    let is_option_or_result = parent_self_ty.map_or(false, |def_id| {\n+                        matches!(tcx.get_diagnostic_name(def_id), Some(sym::Option | sym::Result))\n+                    });\n                     if is_option_or_result && maybe_reinitialized_locations_is_empty {\n                         err.span_label(\n                             var_span,"}, {"sha": "6db3c858ae7149b9a138dbd77c7813c3eeea298e", "filename": "compiler/rustc_borrowck/src/diagnostics/move_errors.rs", "status": "modified", "additions": 64, "deletions": 36, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -4,7 +4,7 @@ use rustc_middle::ty;\n use rustc_mir_dataflow::move_paths::{\n     IllegalMoveOrigin, IllegalMoveOriginKind, LookupResult, MoveError, MovePathIndex,\n };\n-use rustc_span::Span;\n+use rustc_span::{BytePos, Span};\n \n use crate::diagnostics::{DescribePlaceOpt, UseSpans};\n use crate::prefixes::PrefixSet;\n@@ -148,7 +148,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         match_span: Span,\n         statement_span: Span,\n     ) {\n-        debug!(\"append_binding_error(match_place={:?}, match_span={:?})\", match_place, match_span);\n+        debug!(?match_place, ?match_span, \"append_binding_error\");\n \n         let from_simple_let = match_place.is_none();\n         let match_place = match_place.unwrap_or(move_from);\n@@ -160,7 +160,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     if let GroupedMoveError::MovesFromPlace { span, binds_to, .. } = ge\n                         && match_span == *span\n                     {\n-                        debug!(\"appending local({:?}) to list\", bind_to);\n+                        debug!(\"appending local({bind_to:?}) to list\");\n                         if !binds_to.is_empty() {\n                             binds_to.push(bind_to);\n                         }\n@@ -198,7 +198,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     } = ge\n                     {\n                         if match_span == *span && mpi == *other_mpi {\n-                            debug!(\"appending local({:?}) to list\", bind_to);\n+                            debug!(\"appending local({bind_to:?}) to list\");\n                             binds_to.push(bind_to);\n                             return;\n                         }\n@@ -410,15 +410,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     fn add_move_hints(&self, error: GroupedMoveError<'tcx>, err: &mut Diagnostic, span: Span) {\n         match error {\n             GroupedMoveError::MovesFromPlace { mut binds_to, move_from, .. } => {\n-                if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n-                    err.span_suggestion(\n-                        span,\n-                        \"consider borrowing here\",\n-                        format!(\"&{snippet}\"),\n-                        Applicability::Unspecified,\n-                    );\n-                }\n-\n+                self.add_borrow_suggestions(err, span);\n                 if binds_to.is_empty() {\n                     let place_ty = move_from.ty(self.body, self.infcx.tcx).ty;\n                     let place_desc = match self.describe_place(move_from.as_ref()) {\n@@ -461,39 +453,75 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn add_borrow_suggestions(&self, err: &mut Diagnostic, span: Span) {\n+        match self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n+            Ok(snippet) if snippet.starts_with('*') => {\n+                err.span_suggestion_verbose(\n+                    span.with_hi(span.lo() + BytePos(1)),\n+                    \"consider removing the dereference here\",\n+                    String::new(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+            _ => {\n+                err.span_suggestion_verbose(\n+                    span.shrink_to_lo(),\n+                    \"consider borrowing here\",\n+                    \"&\".to_string(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+        }\n+    }\n+\n     fn add_move_error_suggestions(&self, err: &mut Diagnostic, binds_to: &[Local]) {\n-        let mut suggestions: Vec<(Span, &str, String)> = Vec::new();\n+        let mut suggestions: Vec<(Span, String, String)> = Vec::new();\n         for local in binds_to {\n             let bind_to = &self.body.local_decls[*local];\n             if let Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n                 VarBindingForm { pat_span, .. },\n             )))) = bind_to.local_info\n             {\n-                if let Ok(pat_snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(pat_span)\n+                let Ok(pat_snippet) =\n+                    self.infcx.tcx.sess.source_map().span_to_snippet(pat_span) else { continue; };\n+                let Some(stripped) = pat_snippet.strip_prefix('&') else {\n+                    suggestions.push((\n+                        bind_to.source_info.span.shrink_to_lo(),\n+                        \"consider borrowing the pattern binding\".to_string(),\n+                        \"ref \".to_string(),\n+                    ));\n+                    continue;\n+                };\n+                let inner_pat_snippet = stripped.trim_start();\n+                let (pat_span, suggestion, to_remove) = if inner_pat_snippet.starts_with(\"mut\")\n+                    && inner_pat_snippet[\"mut\".len()..].starts_with(rustc_lexer::is_whitespace)\n                 {\n-                    if let Some(stripped) = pat_snippet.strip_prefix('&') {\n-                        let pat_snippet = stripped.trim_start();\n-                        let (suggestion, to_remove) = if pat_snippet.starts_with(\"mut\")\n-                            && pat_snippet[\"mut\".len()..].starts_with(rustc_lexer::is_whitespace)\n-                        {\n-                            (pat_snippet[\"mut\".len()..].trim_start(), \"&mut\")\n-                        } else {\n-                            (pat_snippet, \"&\")\n-                        };\n-                        suggestions.push((pat_span, to_remove, suggestion.to_owned()));\n-                    }\n-                }\n+                    let inner_pat_snippet = inner_pat_snippet[\"mut\".len()..].trim_start();\n+                    let pat_span = pat_span.with_hi(\n+                        pat_span.lo()\n+                            + BytePos((pat_snippet.len() - inner_pat_snippet.len()) as u32),\n+                    );\n+                    (pat_span, String::new(), \"mutable borrow\")\n+                } else {\n+                    let pat_span = pat_span.with_hi(\n+                        pat_span.lo()\n+                            + BytePos(\n+                                (pat_snippet.len() - inner_pat_snippet.trim_start().len()) as u32,\n+                            ),\n+                    );\n+                    (pat_span, String::new(), \"borrow\")\n+                };\n+                suggestions.push((\n+                    pat_span,\n+                    format!(\"consider removing the {to_remove}\"),\n+                    suggestion.to_string(),\n+                ));\n             }\n         }\n         suggestions.sort_unstable_by_key(|&(span, _, _)| span);\n         suggestions.dedup_by_key(|&mut (span, _, _)| span);\n-        for (span, to_remove, suggestion) in suggestions {\n-            err.span_suggestion(\n-                span,\n-                &format!(\"consider removing the `{to_remove}`\"),\n-                suggestion,\n-                Applicability::MachineApplicable,\n-            );\n+        for (span, msg, suggestion) in suggestions {\n+            err.span_suggestion_verbose(span, &msg, suggestion, Applicability::MachineApplicable);\n         }\n     }\n \n@@ -521,8 +549,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n         if binds_to.len() > 1 {\n             err.note(\n-                \"move occurs because these variables have types that \\\n-                      don't implement the `Copy` trait\",\n+                \"move occurs because these variables have types that don't implement the `Copy` \\\n+                 trait\",\n             );\n         }\n     }"}, {"sha": "f8ec5e5e799149c888e001dd4ddc1b488847c8d2", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -504,7 +504,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let ErrorConstraintInfo { outlived_fr, span, .. } = errci;\n \n         let mut output_ty = self.regioncx.universal_regions().unnormalized_output_ty;\n-        if let ty::Opaque(def_id, _) = *output_ty.kind() {\n+        if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }) = *output_ty.kind() {\n             output_ty = self.infcx.tcx.type_of(def_id)\n         };\n "}, {"sha": "e9c98bdc514967a63f4f1dc39be0e6be7d1919ed", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -747,27 +747,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // Otherwise, we need to find the minimum remaining choice, if\n         // any, and take that.\n         debug!(\"choice_regions remaining are {:#?}\", choice_regions);\n-        let min = |r1: ty::RegionVid, r2: ty::RegionVid| -> Option<ty::RegionVid> {\n-            let r1_outlives_r2 = self.universal_region_relations.outlives(r1, r2);\n-            let r2_outlives_r1 = self.universal_region_relations.outlives(r2, r1);\n-            match (r1_outlives_r2, r2_outlives_r1) {\n-                (true, true) => Some(r1.min(r2)),\n-                (true, false) => Some(r2),\n-                (false, true) => Some(r1),\n-                (false, false) => None,\n-            }\n+        let Some(&min_choice) = choice_regions.iter().find(|&r1| {\n+            choice_regions.iter().all(|&r2| {\n+                self.universal_region_relations.outlives(r2, *r1)\n+            })\n+        }) else {\n+            debug!(\"no choice region outlived by all others\");\n+            return false;\n         };\n-        let mut min_choice = choice_regions[0];\n-        for &other_option in &choice_regions[1..] {\n-            debug!(?min_choice, ?other_option,);\n-            match min(min_choice, other_option) {\n-                Some(m) => min_choice = m,\n-                None => {\n-                    debug!(?min_choice, ?other_option, \"incomparable; no min choice\",);\n-                    return false;\n-                }\n-            }\n-        }\n \n         let min_choice_scc = self.constraint_sccs.scc(min_choice);\n         debug!(?min_choice, ?min_choice_scc);"}, {"sha": "dcf500ddbd3c8d9fc576d6eb8de1261a05f129b8", "filename": "compiler/rustc_builtin_macros/src/alloc_error_handler.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -32,7 +32,7 @@ pub fn expand(\n             (item, true, ecx.with_def_site_ctxt(fn_kind.sig.span))\n         } else {\n             ecx.sess.parse_sess.span_diagnostic.span_err(item.span(), \"alloc_error_handler must be a function\");\n-            return vec![orig_item.clone()];\n+            return vec![orig_item];\n         };\n \n     // Generate a bunch of new items using the AllocFnFactory"}, {"sha": "7da9bdc38a2a8cd3d0b32d031afd5d7ebbf3f3e8", "filename": "compiler/rustc_builtin_macros/src/concat.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -4,8 +4,6 @@ use rustc_expand::base::{self, DummyResult};\n use rustc_session::errors::report_lit_error;\n use rustc_span::symbol::Symbol;\n \n-use std::string::String;\n-\n pub fn expand_concat(\n     cx: &mut base::ExtCtxt<'_>,\n     sp: rustc_span::Span,"}, {"sha": "4f1a7d709ff8c276900c255977d478fa9a3bec81", "filename": "compiler/rustc_builtin_macros/src/concat_bytes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -69,7 +69,7 @@ fn invalid_type_err(\n         Ok(ast::LitKind::Int(_, _)) => {\n             cx.span_err(span, \"numeric literal is not a `u8`\");\n         }\n-        Ok(ast::LitKind::ByteStr(_) | ast::LitKind::Byte(_)) => unreachable!(),\n+        Ok(ast::LitKind::ByteStr(..) | ast::LitKind::Byte(_)) => unreachable!(),\n         Err(err) => {\n             report_lit_error(&cx.sess.parse_sess, err, token_lit, span);\n         }\n@@ -97,7 +97,7 @@ fn handle_array_element(\n             )) if val <= u8::MAX.into() => Some(val as u8),\n \n             Ok(ast::LitKind::Byte(val)) => Some(val),\n-            Ok(ast::LitKind::ByteStr(_)) => {\n+            Ok(ast::LitKind::ByteStr(..)) => {\n                 if !*has_errors {\n                     cx.struct_span_err(expr.span, \"cannot concatenate doubly nested array\")\n                         .note(\"byte strings are treated as arrays of bytes\")\n@@ -174,7 +174,7 @@ pub fn expand_concat_bytes(\n                 Ok(ast::LitKind::Byte(val)) => {\n                     accumulator.push(val);\n                 }\n-                Ok(ast::LitKind::ByteStr(ref bytes)) => {\n+                Ok(ast::LitKind::ByteStr(ref bytes, _)) => {\n                     accumulator.extend_from_slice(&bytes);\n                 }\n                 _ => {\n@@ -196,7 +196,7 @@ pub fn expand_concat_bytes(\n         }\n     }\n     if !missing_literals.is_empty() {\n-        let mut err = cx.struct_span_err(missing_literals.clone(), \"expected a byte literal\");\n+        let mut err = cx.struct_span_err(missing_literals, \"expected a byte literal\");\n         err.note(\"only byte literals (like `b\\\"foo\\\"`, `b's'`, and `[3, 4, 5]`) can be passed to `concat_bytes!()`\");\n         err.emit();\n         return base::MacEager::expr(DummyResult::raw_expr(sp, true));"}, {"sha": "2a8dc02849ea71e6a51701e7905a812966395b2c", "filename": "compiler/rustc_builtin_macros/src/derive.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,7 +1,7 @@\n use crate::cfg_eval::cfg_eval;\n \n use rustc_ast as ast;\n-use rustc_ast::{token, GenericParamKind, ItemKind, MetaItemKind, NestedMetaItem, StmtKind};\n+use rustc_ast::{GenericParamKind, ItemKind, MetaItemKind, NestedMetaItem, StmtKind};\n use rustc_errors::{struct_span_err, Applicability};\n use rustc_expand::base::{Annotatable, ExpandResult, ExtCtxt, Indeterminate, MultiItemModifier};\n use rustc_feature::AttributeTemplate;\n@@ -130,9 +130,11 @@ fn report_bad_target(sess: &Session, item: &Annotatable, span: Span) -> bool {\n }\n \n fn report_unexpected_meta_item_lit(sess: &Session, lit: &ast::MetaItemLit) {\n-    let help_msg = match lit.token_lit.kind {\n-        token::Str if rustc_lexer::is_ident(lit.token_lit.symbol.as_str()) => {\n-            format!(\"try using `#[derive({})]`\", lit.token_lit.symbol)\n+    let help_msg = match lit.kind {\n+        ast::LitKind::Str(_, ast::StrStyle::Cooked)\n+            if rustc_lexer::is_ident(lit.symbol.as_str()) =>\n+        {\n+            format!(\"try using `#[derive({})]`\", lit.symbol)\n         }\n         _ => \"for example, write `#[derive(Debug)]` for `Debug`\".to_string(),\n     };"}, {"sha": "d627c2ee09c4ef7555f820cc2a239b73c3133269", "filename": "compiler/rustc_codegen_cranelift/.cirrus.yml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2F.cirrus.yml", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2F.cirrus.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.cirrus.yml?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -12,8 +12,6 @@ task:\n     folder: target\n   prepare_script:\n     - . $HOME/.cargo/env\n-    - git config --global user.email \"user@example.com\"\n-    - git config --global user.name \"User\"\n     - ./y.rs prepare\n   test_script:\n     - . $HOME/.cargo/env"}, {"sha": "a6bb12a66a247d66441c390105655e9ff0910978", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/main.yml", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -19,6 +19,7 @@ jobs:\n     - name: Rustfmt\n       run: |\n         cargo fmt --check\n+        rustfmt --check build_system/mod.rs\n \n   build:\n     runs-on: ${{ matrix.os }}\n@@ -28,7 +29,7 @@ jobs:\n       fail-fast: false\n       matrix:\n         include:\n-          - os: ubuntu-latest\n+          - os: ubuntu-20.04 # FIXME switch to ubuntu-22.04 once #1303 is fixed\n             env:\n               TARGET_TRIPLE: x86_64-unknown-linux-gnu\n           - os: macos-latest\n@@ -41,28 +42,32 @@ jobs:\n           - os: ubuntu-latest\n             env:\n               TARGET_TRIPLE: aarch64-unknown-linux-gnu\n+          # s390x requires QEMU 6.1 or greater, we could build it from source, but ubuntu 22.04 comes with 6.2 by default\n+          - os: ubuntu-latest\n+            env:\n+              TARGET_TRIPLE: s390x-unknown-linux-gnu\n \n     steps:\n     - uses: actions/checkout@v3\n \n     - name: Cache cargo installed crates\n-      uses: actions/cache@v2\n+      uses: actions/cache@v3\n       with:\n         path: ~/.cargo/bin\n         key: ${{ runner.os }}-cargo-installed-crates\n \n     - name: Cache cargo registry and index\n-      uses: actions/cache@v2\n+      uses: actions/cache@v3\n       with:\n         path: |\n             ~/.cargo/registry\n             ~/.cargo/git\n         key: ${{ runner.os }}-cargo-registry-and-index-${{ hashFiles('**/Cargo.lock') }}\n \n     - name: Cache cargo target dir\n-      uses: actions/cache@v2\n+      uses: actions/cache@v3\n       with:\n-        path: target\n+        path: build/cg_clif\n         key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n \n     - name: Install MinGW toolchain and wine\n@@ -78,11 +83,14 @@ jobs:\n         sudo apt-get update\n         sudo apt-get install -y gcc-aarch64-linux-gnu qemu-user\n \n-    - name: Prepare dependencies\n+    - name: Install s390x toolchain and qemu\n+      if: matrix.env.TARGET_TRIPLE == 's390x-unknown-linux-gnu'\n       run: |\n-        git config --global user.email \"user@example.com\"\n-        git config --global user.name \"User\"\n-        ./y.rs prepare\n+        sudo apt-get update\n+        sudo apt-get install -y gcc-s390x-linux-gnu qemu-user\n+\n+    - name: Prepare dependencies\n+      run: ./y.rs prepare\n \n     - name: Build without unstable features\n       env:\n@@ -110,7 +118,7 @@ jobs:\n         ./y.rs test\n \n     - name: Package prebuilt cg_clif\n-      run: tar cvfJ cg_clif.tar.xz build\n+      run: tar cvfJ cg_clif.tar.xz dist\n \n     - name: Upload prebuilt cg_clif\n       if: matrix.env.TARGET_TRIPLE != 'x86_64-pc-windows-gnu'\n@@ -121,7 +129,7 @@ jobs:\n \n     - name: Upload prebuilt cg_clif (cross compile)\n       if: matrix.env.TARGET_TRIPLE == 'x86_64-pc-windows-gnu'\n-      uses: actions/upload-artifact@v2\n+      uses: actions/upload-artifact@v3\n       with:\n         name: cg_clif-${{ runner.os }}-cross-x86_64-mingw\n         path: cg_clif.tar.xz\n@@ -147,23 +155,23 @@ jobs:\n     - uses: actions/checkout@v3\n \n     - name: Cache cargo installed crates\n-      uses: actions/cache@v2\n+      uses: actions/cache@v3\n       with:\n         path: ~/.cargo/bin\n         key: ${{ runner.os }}-${{ matrix.env.TARGET_TRIPLE }}-cargo-installed-crates\n \n     - name: Cache cargo registry and index\n-      uses: actions/cache@v2\n+      uses: actions/cache@v3\n       with:\n         path: |\n             ~/.cargo/registry\n             ~/.cargo/git\n         key: ${{ runner.os }}-${{ matrix.env.TARGET_TRIPLE }}-cargo-registry-and-index-${{ hashFiles('**/Cargo.lock') }}\n \n     - name: Cache cargo target dir\n-      uses: actions/cache@v2\n+      uses: actions/cache@v3\n       with:\n-        path: target\n+        path: build/cg_clif\n         key: ${{ runner.os }}-${{ matrix.env.TARGET_TRIPLE }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n \n     - name: Set MinGW as the default toolchain\n@@ -172,8 +180,6 @@ jobs:\n \n     - name: Prepare dependencies\n       run: |\n-        git config --global user.email \"user@example.com\"\n-        git config --global user.name \"User\"\n         git config --global core.autocrlf false\n         rustc y.rs -o y.exe -g\n         ./y.exe prepare\n@@ -198,24 +204,24 @@ jobs:\n \n         # Enable extra checks\n         $Env:CG_CLIF_ENABLE_VERIFIER=1\n-        \n+\n         # WIP Disable some tests\n-        \n+\n         # This fails due to some weird argument handling by hyperfine, not an actual regression\n         # more of a build system issue\n         (Get-Content config.txt) -replace '(bench.simple-raytracer)', '# $1' |  Out-File config.txt\n-        \n-        # This fails with a different output than expected \n+\n+        # This fails with a different output than expected\n         (Get-Content config.txt) -replace '(test.regex-shootout-regex-dna)', '# $1' |  Out-File config.txt\n \n         ./y.exe test\n \n     - name: Package prebuilt cg_clif\n       # don't use compression as xzip isn't supported by tar on windows and bzip2 hangs\n-      run: tar cvf cg_clif.tar build\n+      run: tar cvf cg_clif.tar dist\n \n     - name: Upload prebuilt cg_clif\n-      uses: actions/upload-artifact@v2\n+      uses: actions/upload-artifact@v3\n       with:\n         name: cg_clif-${{ matrix.env.TARGET_TRIPLE }}\n         path: cg_clif.tar"}, {"sha": "d0d58d2a7eacbd19a07442af167bdb0e2926274a", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/nightly-cranelift.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fnightly-cranelift.yml", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fnightly-cranelift.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fnightly-cranelift.yml?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -14,7 +14,7 @@ jobs:\n     - uses: actions/checkout@v3\n \n     - name: Cache cargo installed crates\n-      uses: actions/cache@v2\n+      uses: actions/cache@v3\n       with:\n         path: ~/.cargo/bin\n         key: ubuntu-latest-cargo-installed-crates"}, {"sha": "bef806318efa836aeeb8d6df06d880b77be677fb", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/rustc.yml", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Frustc.yml", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Frustc.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Frustc.yml?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -11,23 +11,23 @@ jobs:\n     - uses: actions/checkout@v3\n \n     - name: Cache cargo installed crates\n-      uses: actions/cache@v2\n+      uses: actions/cache@v3\n       with:\n         path: ~/.cargo/bin\n         key: ${{ runner.os }}-cargo-installed-crates\n \n     - name: Cache cargo registry and index\n-      uses: actions/cache@v2\n+      uses: actions/cache@v3\n       with:\n         path: |\n             ~/.cargo/registry\n             ~/.cargo/git\n         key: ${{ runner.os }}-cargo-registry-and-index-${{ hashFiles('**/Cargo.lock') }}\n \n     - name: Cache cargo target dir\n-      uses: actions/cache@v2\n+      uses: actions/cache@v3\n       with:\n-        path: target\n+        path: build/cg_clif\n         key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n \n     - name: Prepare dependencies\n@@ -49,23 +49,23 @@ jobs:\n     - uses: actions/checkout@v3\n \n     - name: Cache cargo installed crates\n-      uses: actions/cache@v2\n+      uses: actions/cache@v3\n       with:\n         path: ~/.cargo/bin\n         key: ${{ runner.os }}-cargo-installed-crates\n \n     - name: Cache cargo registry and index\n-      uses: actions/cache@v2\n+      uses: actions/cache@v3\n       with:\n         path: |\n             ~/.cargo/registry\n             ~/.cargo/git\n         key: ${{ runner.os }}-cargo-registry-and-index-${{ hashFiles('**/Cargo.lock') }}\n \n     - name: Cache cargo target dir\n-      uses: actions/cache@v2\n+      uses: actions/cache@v3\n       with:\n-        path: target\n+        path: build/cg_clif\n         key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n \n     - name: Prepare dependencies"}, {"sha": "b443fd58a1b98344bec2720e26139b6467907d89", "filename": "compiler/rustc_codegen_cranelift/.gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.gitignore?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -14,5 +14,6 @@ perf.data.old\n /build_sysroot/sysroot_src\n /build_sysroot/compiler-builtins\n /build_sysroot/rustc_version\n+/dist\n /rust\n /download"}, {"sha": "bc914e37d2b51dda8d3a0e4ef090a4cc1399fc90", "filename": "compiler/rustc_codegen_cranelift/.vscode/settings.json", "status": "modified", "additions": 3, "deletions": 32, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -4,16 +4,10 @@\n     \"rust-analyzer.imports.granularity.enforce\": true,\n     \"rust-analyzer.imports.granularity.group\": \"module\",\n     \"rust-analyzer.imports.prefix\": \"crate\",\n-    \"rust-analyzer.cargo.features\": [\"unstable-features\"],\n+    \"rust-analyzer.cargo.features\": [\"unstable-features\", \"__check_build_system_using_ra\"],\n     \"rust-analyzer.linkedProjects\": [\n         \"./Cargo.toml\",\n-        //\"./build_sysroot/sysroot_src/library/std/Cargo.toml\",\n         {\n-            \"roots\": [\n-                \"./example/mini_core.rs\",\n-                \"./example/mini_core_hello_world.rs\",\n-                \"./example/mod_bench.rs\"\n-            ],\n             \"crates\": [\n                 {\n                     \"root_module\": \"./example/mini_core.rs\",\n@@ -36,34 +30,11 @@\n             ]\n         },\n         {\n-            \"roots\": [\"./example/std_example.rs\"],\n+            \"sysroot_src\": \"./build_sysroot/sysroot_src/library\",\n             \"crates\": [\n                 {\n                     \"root_module\": \"./example/std_example.rs\",\n-                    \"edition\": \"2018\",\n-                    \"deps\": [{ \"crate\": 1, \"name\": \"std\" }],\n-                    \"cfg\": [],\n-                },\n-                {\n-                    \"root_module\": \"./build_sysroot/sysroot_src/library/std/src/lib.rs\",\n-                    \"edition\": \"2018\",\n-                    \"deps\": [],\n-                    \"cfg\": [],\n-                },\n-            ]\n-        },\n-        {\n-            \"roots\": [\"./y.rs\"],\n-            \"crates\": [\n-                {\n-                    \"root_module\": \"./y.rs\",\n-                    \"edition\": \"2018\",\n-                    \"deps\": [{ \"crate\": 1, \"name\": \"std\" }],\n-                    \"cfg\": [],\n-                },\n-                {\n-                    \"root_module\": \"./build_sysroot/sysroot_src/library/std/src/lib.rs\",\n-                    \"edition\": \"2018\",\n+                    \"edition\": \"2015\",\n                     \"deps\": [],\n                     \"cfg\": [],\n                 },"}, {"sha": "e4d3e9ca5ae0a8676863063216c420232248a554", "filename": "compiler/rustc_codegen_cranelift/Cargo.lock", "status": "modified", "additions": 83, "deletions": 42, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.lock?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -15,9 +15,9 @@ dependencies = [\n \n [[package]]\n name = \"anyhow\"\n-version = \"1.0.60\"\n+version = \"1.0.66\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c794e162a5eff65c72ef524dfe393eb923c354e350bb78b9c7383df13f3bc142\"\n+checksum = \"216261ddc8289130e551ddcd5ce8a064710c0d064a4d2895c67151c92b5443f6\"\n \n [[package]]\n name = \"arrayvec\"\n@@ -39,9 +39,9 @@ checksum = \"bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a\"\n \n [[package]]\n name = \"bumpalo\"\n-version = \"3.11.0\"\n+version = \"3.11.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c1ad822118d20d2c234f427000d5acc36eabe1e29a348c89b63dd60b13f28e5d\"\n+checksum = \"572f695136211188308f16ad2ca5c851a712c464060ae6974944458eb83880ba\"\n \n [[package]]\n name = \"byteorder\"\n@@ -57,24 +57,25 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"cranelift-bforest\"\n-version = \"0.88.1\"\n+version = \"0.90.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"44409ccf2d0f663920cab563d2b79fcd6b2e9a2bcc6e929fef76c8f82ad6c17a\"\n+checksum = \"b62c772976416112fa4484cbd688cb6fb35fd430005c1c586224fc014018abad\"\n dependencies = [\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen\"\n-version = \"0.88.1\"\n+version = \"0.90.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"98de2018ad96eb97f621f7d6b900a0cc661aec8d02ea4a50e56ecb48e5a2fcaf\"\n+checksum = \"9b40ed2dd13c2ac7e24f88a3090c68ad3414eb1d066a95f8f1f7b3b819cb4e46\"\n dependencies = [\n  \"arrayvec\",\n  \"bumpalo\",\n  \"cranelift-bforest\",\n  \"cranelift-codegen-meta\",\n  \"cranelift-codegen-shared\",\n+ \"cranelift-egraph\",\n  \"cranelift-entity\",\n  \"cranelift-isle\",\n  \"gimli\",\n@@ -86,30 +87,44 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-codegen-meta\"\n-version = \"0.88.1\"\n+version = \"0.90.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5287ce36e6c4758fbaf298bd1a8697ad97a4f2375a3d1b61142ea538db4877e5\"\n+checksum = \"bb927a8f1c27c34ee3759b6b0ffa528d2330405d5cc4511f0cab33fe2279f4b5\"\n dependencies = [\n  \"cranelift-codegen-shared\",\n ]\n \n [[package]]\n name = \"cranelift-codegen-shared\"\n-version = \"0.88.1\"\n+version = \"0.90.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2855c24219e2f08827f3f4ffb2da92e134ae8d8ecc185b11ec8f9878cf5f588e\"\n+checksum = \"43dfa417b884a9ab488d95fd6b93b25e959321fe7bfd7a0a960ba5d7fb7ab927\"\n+\n+[[package]]\n+name = \"cranelift-egraph\"\n+version = \"0.90.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e0a66b39785efd8513d2cca967ede56d6cc57c8d7986a595c7c47d0c78de8dce\"\n+dependencies = [\n+ \"cranelift-entity\",\n+ \"fxhash\",\n+ \"hashbrown\",\n+ \"indexmap\",\n+ \"log\",\n+ \"smallvec\",\n+]\n \n [[package]]\n name = \"cranelift-entity\"\n-version = \"0.88.1\"\n+version = \"0.90.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0b65673279d75d34bf11af9660ae2dbd1c22e6d28f163f5c72f4e1dc56d56103\"\n+checksum = \"0637ffde963cb5d759bc4d454cfa364b6509e6c74cdaa21298add0ed9276f346\"\n \n [[package]]\n name = \"cranelift-frontend\"\n-version = \"0.88.1\"\n+version = \"0.90.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3ed2b3d7a4751163f6c4a349205ab1b7d9c00eecf19dcea48592ef1f7688eefc\"\n+checksum = \"fb72b8342685e850cb037350418f62cc4fc55d6c2eb9c7ca01b82f9f1a6f3d56\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"log\",\n@@ -119,15 +134,15 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-isle\"\n-version = \"0.88.1\"\n+version = \"0.90.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3be64cecea9d90105fc6a2ba2d003e98c867c1d6c4c86cc878f97ad9fb916293\"\n+checksum = \"850579cb9e4b448f7c301f1e6e6cbad99abe3f1f1d878a4994cb66e33c6db8cd\"\n \n [[package]]\n name = \"cranelift-jit\"\n-version = \"0.88.1\"\n+version = \"0.90.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f98ed42a70a0c9c388e34ec9477f57fc7300f541b1e5136a0e2ea02b1fac6015\"\n+checksum = \"9add822ad66dcbe152b5ab57de10240a2df4505099f2f6c27159acb711890bd4\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -138,24 +153,25 @@ dependencies = [\n  \"log\",\n  \"region\",\n  \"target-lexicon\",\n+ \"wasmtime-jit-icache-coherence\",\n  \"windows-sys\",\n ]\n \n [[package]]\n name = \"cranelift-module\"\n-version = \"0.88.1\"\n+version = \"0.90.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d658ac7f156708bfccb647216cc8b9387469f50d352ba4ad80150541e4ae2d49\"\n+checksum = \"406b772626fc2664864cf947f3895a23b619895c7fff635f3622e2d857f4492f\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n ]\n \n [[package]]\n name = \"cranelift-native\"\n-version = \"0.88.1\"\n+version = \"0.90.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c4a03a6ac1b063e416ca4b93f6247978c991475e8271465340caa6f92f3c16a4\"\n+checksum = \"2d0a279e5bcba3e0466c734d8d8eb6bfc1ad29e95c37f3e4955b492b5616335e\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"libc\",\n@@ -164,9 +180,9 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-object\"\n-version = \"0.88.1\"\n+version = \"0.90.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"eef0b4119b645b870a43a036d76c0ada3a076b1f82e8b8487659304c8b09049b\"\n+checksum = \"39793c550f0c1d7db96c2fc1324583670c8143befe6edbfbaf1c68aba53be983\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -185,6 +201,12 @@ dependencies = [\n  \"cfg-if\",\n ]\n \n+[[package]]\n+name = \"fallible-iterator\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4443176a9f2c162692bd3d352d745ef9413eec5782a80d8fd6f8a1ac692a07f7\"\n+\n [[package]]\n name = \"fxhash\"\n version = \"0.2.1\"\n@@ -196,9 +218,9 @@ dependencies = [\n \n [[package]]\n name = \"getrandom\"\n-version = \"0.2.7\"\n+version = \"0.2.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4eb1a864a501629691edf6c15a593b7a51eebaa1e8468e9ddc623de7c9b58ec6\"\n+checksum = \"c05aeb6a22b8f62540c194aac980f2115af067bfe15a0734d7277a768d396b31\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n@@ -211,7 +233,9 @@ version = \"0.26.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"22030e2c5a68ec659fde1e949a745124b48e6fa8b045b7ed5bd1fe4ccc5c4e5d\"\n dependencies = [\n+ \"fallible-iterator\",\n  \"indexmap\",\n+ \"stable_deref_trait\",\n ]\n \n [[package]]\n@@ -225,25 +249,25 @@ dependencies = [\n \n [[package]]\n name = \"indexmap\"\n-version = \"1.9.1\"\n+version = \"1.9.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"10a35a97730320ffe8e2d410b5d3b69279b98d2c14bdb8b70ea89ecf7888d41e\"\n+checksum = \"1885e79c1fc4b10f0e172c475f458b7f7b93061064d98c3293e98c5ba0c8b399\"\n dependencies = [\n  \"autocfg\",\n  \"hashbrown\",\n ]\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.127\"\n+version = \"0.2.138\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"505e71a4706fa491e9b1b55f51b95d4037d0821ee40131190475f692b35b009b\"\n+checksum = \"db6d7e329c562c5dfab7a46a2afabc8b987ab9a4834c9d1ca04dc54c1546cef8\"\n \n [[package]]\n name = \"libloading\"\n-version = \"0.7.3\"\n+version = \"0.7.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"efbc0f03f9a775e9f6aed295c6a1ba2253c5757a9e03d55c6caa46a681abcddd\"\n+checksum = \"b67380fd3b2fbe7527a606e18729d21c6f3951633d0500574c4dc22d2d638b9f\"\n dependencies = [\n  \"cfg-if\",\n  \"winapi\",\n@@ -287,15 +311,15 @@ dependencies = [\n \n [[package]]\n name = \"once_cell\"\n-version = \"1.13.0\"\n+version = \"1.16.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"18a6dbe30758c9f83eb00cbea4ac95966305f5a7772f3f42ebfc7fc7eddbd8e1\"\n+checksum = \"86f0b0d4bf799edbc74508c1e8bf170ff5f41238e5f8225603ca7caaae2b7860\"\n \n [[package]]\n name = \"regalloc2\"\n-version = \"0.3.2\"\n+version = \"0.4.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d43a209257d978ef079f3d446331d0f1794f5e0fc19b306a199983857833a779\"\n+checksum = \"91b2eab54204ea0117fe9a060537e0b07a4e72f7c7d182361ecc346cab2240e5\"\n dependencies = [\n  \"fxhash\",\n  \"log\",\n@@ -342,15 +366,21 @@ checksum = \"03b634d87b960ab1a38c4fe143b508576f075e7c978bfad18217645ebfdfa2ec\"\n \n [[package]]\n name = \"smallvec\"\n-version = \"1.9.0\"\n+version = \"1.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2fd0db749597d91ff862fd1d55ea87f7855a744a8425a64695b6fca237d1dad1\"\n+checksum = \"a507befe795404456341dfab10cef66ead4c041f62b8b11bbb92bffe5d0953e0\"\n+\n+[[package]]\n+name = \"stable_deref_trait\"\n+version = \"1.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3\"\n \n [[package]]\n name = \"target-lexicon\"\n-version = \"0.12.4\"\n+version = \"0.12.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c02424087780c9b71cc96799eaeddff35af2bc513278cda5c99fc1f5d026d3c1\"\n+checksum = \"9410d0f6853b1d94f0e519fb95df60f29d2c1eff2d921ffdf01a4c8a3b54f12d\"\n \n [[package]]\n name = \"version_check\"\n@@ -364,6 +394,17 @@ version = \"0.11.0+wasi-snapshot-preview1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423\"\n \n+[[package]]\n+name = \"wasmtime-jit-icache-coherence\"\n+version = \"2.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e6bbabb309c06cc238ee91b1455b748c45f0bdcab0dda2c2db85b0a1e69fcb66\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"libc\",\n+ \"windows-sys\",\n+]\n+\n [[package]]\n name = \"winapi\"\n version = \"0.3.9\""}, {"sha": "2b216ca072f0096832412085a0eae3fda4dc79ff", "filename": "compiler/rustc_codegen_cranelift/Cargo.toml", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.toml?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -3,17 +3,24 @@ name = \"rustc_codegen_cranelift\"\n version = \"0.1.0\"\n edition = \"2021\"\n \n+[[bin]]\n+# This is used just to teach rust-analyzer how to check the build system. required-features is used\n+# to disable it for regular builds.\n+name = \"y\"\n+path = \"./y.rs\"\n+required-features = [\"__check_build_system_using_ra\"]\n+\n [lib]\n crate-type = [\"dylib\"]\n \n [dependencies]\n # These have to be in sync with each other\n-cranelift-codegen = { version = \"0.88.1\", features = [\"unwind\", \"all-arch\"] }\n-cranelift-frontend = \"0.88.1\"\n-cranelift-module = \"0.88.1\"\n-cranelift-native = \"0.88.1\"\n-cranelift-jit = { version = \"0.88.1\", optional = true }\n-cranelift-object = \"0.88.1\"\n+cranelift-codegen = { version = \"0.90.1\", features = [\"unwind\", \"all-arch\"] }\n+cranelift-frontend = \"0.90.1\"\n+cranelift-module = \"0.90.1\"\n+cranelift-native = \"0.90.1\"\n+cranelift-jit = { version = \"0.90.1\", optional = true }\n+cranelift-object = \"0.90.1\"\n target-lexicon = \"0.12.0\"\n gimli = { version = \"0.26.0\", default-features = false, features = [\"write\"]}\n object = { version = \"0.29.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n@@ -39,6 +46,7 @@ smallvec = \"1.8.1\"\n unstable-features = [\"jit\", \"inline_asm\"]\n jit = [\"cranelift-jit\", \"libloading\"]\n inline_asm = []\n+__check_build_system_using_ra = []\n \n [package.metadata.rust-analyzer]\n rustc_private = true"}, {"sha": "0e9c77244d4cc85d765371e97370db5c0adebf11", "filename": "compiler/rustc_codegen_cranelift/Readme.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2FReadme.md", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2FReadme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FReadme.md?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -37,7 +37,7 @@ Assuming `$cg_clif_dir` is the directory you cloned this repo into and you follo\n In the directory with your project (where you can do the usual `cargo build`), run:\n \n ```bash\n-$ $cg_clif_dir/build/cargo-clif build\n+$ $cg_clif_dir/dist/cargo-clif build\n ```\n \n This will build your project with rustc_codegen_cranelift instead of the usual LLVM backend."}, {"sha": "bba3210536ef7832e44ba9dbb5e46c3ee036baf6", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.lock", "status": "modified", "additions": 20, "deletions": 37, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -4,9 +4,9 @@ version = 3\n \n [[package]]\n name = \"addr2line\"\n-version = \"0.16.0\"\n+version = \"0.17.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3e61f2b7f93d2c7d2b08263acaa4a363b3e276806c68af6134c44f523bf1aacd\"\n+checksum = \"b9ecd88a8c8378ca913a680cd98f0f13ac67383d35993f86c90a70e3f137816b\"\n dependencies = [\n  \"compiler_builtins\",\n  \"gimli\",\n@@ -32,27 +32,11 @@ dependencies = [\n  \"core\",\n ]\n \n-[[package]]\n-name = \"autocfg\"\n-version = \"1.1.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa\"\n-\n [[package]]\n name = \"cc\"\n-version = \"1.0.73\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2fff2a6927b3bb87f9595d67196a70493f627687a71d87a0d692242c33f58c11\"\n-\n-[[package]]\n-name = \"cfg-if\"\n-version = \"0.1.10\"\n+version = \"1.0.77\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n-dependencies = [\n- \"compiler_builtins\",\n- \"rustc-std-workspace-core\",\n-]\n+checksum = \"e9f73505338f7d905b19d18738976aae232eb46b8efc15554ffc56deb5d9ebe4\"\n \n [[package]]\n name = \"cfg-if\"\n@@ -66,9 +50,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.82\"\n+version = \"0.1.85\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"18cd7635fea7bb481ea543b392789844c1ad581299da70184c7175ce3af76603\"\n+checksum = \"13e81c6cd7ab79f51a0c927d22858d61ad12bd0b3865f0b13ece02a4486aeabb\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -111,9 +95,9 @@ dependencies = [\n \n [[package]]\n name = \"gimli\"\n-version = \"0.25.0\"\n+version = \"0.26.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f0a01e0497841a3b2db4f8afa483cce65f7e96a3498bd6c541734792aeac8fe7\"\n+checksum = \"22030e2c5a68ec659fde1e949a745124b48e6fa8b045b7ed5bd1fe4ccc5c4e5d\"\n dependencies = [\n  \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\",\n@@ -145,9 +129,9 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.135\"\n+version = \"0.2.138\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"68783febc7782c6c5cb401fbda4de5a9898be1762314da0bb2c10ced61f18b0c\"\n+checksum = \"db6d7e329c562c5dfab7a46a2afabc8b987ab9a4834c9d1ca04dc54c1546cef8\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -164,22 +148,21 @@ dependencies = [\n \n [[package]]\n name = \"miniz_oxide\"\n-version = \"0.4.4\"\n+version = \"0.5.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a92518e98c078586bc6c934028adcca4c92a53d6a958196de835170a01d84e4b\"\n+checksum = \"96590ba8f175222643a85693f33d26e9c8a015f599c216509b1a6894af675d34\"\n dependencies = [\n  \"adler\",\n- \"autocfg\",\n  \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\",\n  \"rustc-std-workspace-core\",\n ]\n \n [[package]]\n name = \"object\"\n-version = \"0.26.2\"\n+version = \"0.29.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"39f37e50073ccad23b6d09bcb5b263f4e76d3bb6038e4a3c08e52162ffa8abc2\"\n+checksum = \"21158b2c33aa6d4561f1c0a6ea283ca92bc54802a93b263e910746d679a7eb53\"\n dependencies = [\n  \"compiler_builtins\",\n  \"memchr\",\n@@ -192,7 +175,7 @@ name = \"panic_abort\"\n version = \"0.0.0\"\n dependencies = [\n  \"alloc\",\n- \"cfg-if 0.1.10\",\n+ \"cfg-if\",\n  \"compiler_builtins\",\n  \"core\",\n  \"libc\",\n@@ -203,7 +186,7 @@ name = \"panic_unwind\"\n version = \"0.0.0\"\n dependencies = [\n  \"alloc\",\n- \"cfg-if 0.1.10\",\n+ \"cfg-if\",\n  \"compiler_builtins\",\n  \"core\",\n  \"libc\",\n@@ -255,7 +238,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"addr2line\",\n  \"alloc\",\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n  \"compiler_builtins\",\n  \"core\",\n  \"dlmalloc\",\n@@ -277,7 +260,7 @@ dependencies = [\n name = \"std_detect\"\n version = \"0.1.5\"\n dependencies = [\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n  \"compiler_builtins\",\n  \"libc\",\n  \"rustc-std-workspace-alloc\",\n@@ -299,7 +282,7 @@ dependencies = [\n name = \"test\"\n version = \"0.0.0\"\n dependencies = [\n- \"cfg-if 0.1.10\",\n+ \"cfg-if\",\n  \"core\",\n  \"getopts\",\n  \"libc\",\n@@ -325,7 +308,7 @@ name = \"unwind\"\n version = \"0.0.0\"\n dependencies = [\n  \"cc\",\n- \"cfg-if 0.1.10\",\n+ \"cfg-if\",\n  \"compiler_builtins\",\n  \"core\",\n  \"libc\","}, {"sha": "a081fdaa1c7e6475a727f764c033f07090b2b87e", "filename": "compiler/rustc_codegen_cranelift/build_system/abi_cafe.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_cafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_cafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_cafe.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,16 +1,21 @@\n-use std::env;\n use std::path::Path;\n \n use super::build_sysroot;\n use super::config;\n-use super::prepare;\n-use super::utils::{cargo_command, spawn_and_wait};\n+use super::path::Dirs;\n+use super::prepare::GitRepo;\n+use super::utils::{spawn_and_wait, CargoProject, Compiler};\n use super::SysrootKind;\n \n+pub(crate) static ABI_CAFE_REPO: GitRepo =\n+    GitRepo::github(\"Gankra\", \"abi-cafe\", \"4c6dc8c9c687e2b3a760ff2176ce236872b37212\", \"abi-cafe\");\n+\n+static ABI_CAFE: CargoProject = CargoProject::new(&ABI_CAFE_REPO.source_dir(), \"abi_cafe\");\n+\n pub(crate) fn run(\n     channel: &str,\n     sysroot_kind: SysrootKind,\n-    target_dir: &Path,\n+    dirs: &Dirs,\n     cg_clif_dylib: &Path,\n     host_triple: &str,\n     target_triple: &str,\n@@ -27,26 +32,25 @@ pub(crate) fn run(\n \n     eprintln!(\"Building sysroot for abi-cafe\");\n     build_sysroot::build_sysroot(\n+        dirs,\n         channel,\n         sysroot_kind,\n-        target_dir,\n         cg_clif_dylib,\n         host_triple,\n         target_triple,\n     );\n \n     eprintln!(\"Running abi-cafe\");\n-    let abi_cafe_path = prepare::ABI_CAFE.source_dir();\n-    env::set_current_dir(abi_cafe_path.clone()).unwrap();\n \n     let pairs = [\"rustc_calls_cgclif\", \"cgclif_calls_rustc\", \"cgclif_calls_cc\", \"cc_calls_cgclif\"];\n \n-    let mut cmd = cargo_command(\"cargo\", \"run\", Some(target_triple), &abi_cafe_path);\n+    let mut cmd = ABI_CAFE.run(&Compiler::host(), dirs);\n     cmd.arg(\"--\");\n     cmd.arg(\"--pairs\");\n     cmd.args(pairs);\n     cmd.arg(\"--add-rustc-codegen-backend\");\n     cmd.arg(format!(\"cgclif:{}\", cg_clif_dylib.display()));\n+    cmd.current_dir(ABI_CAFE.source_dir(dirs));\n \n     spawn_and_wait(cmd);\n }"}, {"sha": "fde8ef424ccc5441e0198ef7b33b23c39dbe37bc", "filename": "compiler/rustc_codegen_cranelift/build_system/build_backend.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,16 +1,19 @@\n use std::env;\n use std::path::PathBuf;\n \n+use super::path::{Dirs, RelPath};\n use super::rustc_info::get_file_name;\n-use super::utils::{cargo_command, is_ci};\n+use super::utils::{is_ci, CargoProject, Compiler};\n+\n+static CG_CLIF: CargoProject = CargoProject::new(&RelPath::SOURCE, \"cg_clif\");\n \n pub(crate) fn build_backend(\n+    dirs: &Dirs,\n     channel: &str,\n     host_triple: &str,\n     use_unstable_features: bool,\n ) -> PathBuf {\n-    let source_dir = std::env::current_dir().unwrap();\n-    let mut cmd = cargo_command(\"cargo\", \"build\", Some(host_triple), &source_dir);\n+    let mut cmd = CG_CLIF.build(&Compiler::host(), dirs);\n \n     cmd.env(\"CARGO_BUILD_INCREMENTAL\", \"true\"); // Force incr comp even in release mode\n \n@@ -41,8 +44,8 @@ pub(crate) fn build_backend(\n     eprintln!(\"[BUILD] rustc_codegen_cranelift\");\n     super::utils::spawn_and_wait(cmd);\n \n-    source_dir\n-        .join(\"target\")\n+    CG_CLIF\n+        .target_dir(dirs)\n         .join(host_triple)\n         .join(channel)\n         .join(get_file_name(\"rustc_codegen_cranelift\", \"dylib\"))"}, {"sha": "cbbf09b9b97b8422ab06caff3b59b34c6352dfd4", "filename": "compiler/rustc_codegen_cranelift/build_system/build_sysroot.rs", "status": "modified", "additions": 50, "deletions": 48, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,57 +1,60 @@\n use std::fs;\n-use std::path::{Path, PathBuf};\n+use std::path::Path;\n use std::process::{self, Command};\n \n+use super::path::{Dirs, RelPath};\n use super::rustc_info::{get_file_name, get_rustc_version, get_wrapper_file_name};\n-use super::utils::{cargo_command, spawn_and_wait, try_hard_link};\n+use super::utils::{spawn_and_wait, try_hard_link, CargoProject, Compiler};\n use super::SysrootKind;\n \n+static DIST_DIR: RelPath = RelPath::DIST;\n+static BIN_DIR: RelPath = RelPath::DIST.join(\"bin\");\n+static LIB_DIR: RelPath = RelPath::DIST.join(\"lib\");\n+static RUSTLIB_DIR: RelPath = LIB_DIR.join(\"rustlib\");\n+\n pub(crate) fn build_sysroot(\n+    dirs: &Dirs,\n     channel: &str,\n     sysroot_kind: SysrootKind,\n-    target_dir: &Path,\n     cg_clif_dylib_src: &Path,\n     host_triple: &str,\n     target_triple: &str,\n ) {\n     eprintln!(\"[BUILD] sysroot {:?}\", sysroot_kind);\n \n-    if target_dir.exists() {\n-        fs::remove_dir_all(target_dir).unwrap();\n-    }\n-    fs::create_dir_all(target_dir.join(\"bin\")).unwrap();\n-    fs::create_dir_all(target_dir.join(\"lib\")).unwrap();\n+    DIST_DIR.ensure_fresh(dirs);\n+    BIN_DIR.ensure_exists(dirs);\n+    LIB_DIR.ensure_exists(dirs);\n \n     // Copy the backend\n-    let cg_clif_dylib_path = target_dir\n-        .join(if cfg!(windows) {\n-            // Windows doesn't have rpath support, so the cg_clif dylib needs to be next to the\n-            // binaries.\n-            \"bin\"\n-        } else {\n-            \"lib\"\n-        })\n-        .join(get_file_name(\"rustc_codegen_cranelift\", \"dylib\"));\n+    let cg_clif_dylib_path = if cfg!(windows) {\n+        // Windows doesn't have rpath support, so the cg_clif dylib needs to be next to the\n+        // binaries.\n+        BIN_DIR\n+    } else {\n+        LIB_DIR\n+    }\n+    .to_path(dirs)\n+    .join(get_file_name(\"rustc_codegen_cranelift\", \"dylib\"));\n     try_hard_link(cg_clif_dylib_src, &cg_clif_dylib_path);\n \n     // Build and copy rustc and cargo wrappers\n-    for wrapper in [\"rustc-clif\", \"cargo-clif\"] {\n+    for wrapper in [\"rustc-clif\", \"rustdoc-clif\", \"cargo-clif\"] {\n         let wrapper_name = get_wrapper_file_name(wrapper, \"bin\");\n \n         let mut build_cargo_wrapper_cmd = Command::new(\"rustc\");\n         build_cargo_wrapper_cmd\n-            .arg(PathBuf::from(\"scripts\").join(format!(\"{wrapper}.rs\")))\n+            .arg(RelPath::SCRIPTS.to_path(dirs).join(&format!(\"{wrapper}.rs\")))\n             .arg(\"-o\")\n-            .arg(target_dir.join(wrapper_name))\n+            .arg(DIST_DIR.to_path(dirs).join(wrapper_name))\n             .arg(\"-g\");\n         spawn_and_wait(build_cargo_wrapper_cmd);\n     }\n \n     let default_sysroot = super::rustc_info::get_default_sysroot();\n \n-    let rustlib = target_dir.join(\"lib\").join(\"rustlib\");\n-    let host_rustlib_lib = rustlib.join(host_triple).join(\"lib\");\n-    let target_rustlib_lib = rustlib.join(target_triple).join(\"lib\");\n+    let host_rustlib_lib = RUSTLIB_DIR.to_path(dirs).join(host_triple).join(\"lib\");\n+    let target_rustlib_lib = RUSTLIB_DIR.to_path(dirs).join(target_triple).join(\"lib\");\n     fs::create_dir_all(&host_rustlib_lib).unwrap();\n     fs::create_dir_all(&target_rustlib_lib).unwrap();\n \n@@ -112,24 +115,18 @@ pub(crate) fn build_sysroot(\n             }\n         }\n         SysrootKind::Clif => {\n-            build_clif_sysroot_for_triple(\n-                channel,\n-                target_dir,\n-                host_triple,\n-                &cg_clif_dylib_path,\n-                None,\n-            );\n+            build_clif_sysroot_for_triple(dirs, channel, host_triple, &cg_clif_dylib_path, None);\n \n             if host_triple != target_triple {\n                 // When cross-compiling it is often necessary to manually pick the right linker\n-                let linker = if target_triple == \"aarch64-unknown-linux-gnu\" {\n-                    Some(\"aarch64-linux-gnu-gcc\")\n-                } else {\n-                    None\n+                let linker = match target_triple {\n+                    \"aarch64-unknown-linux-gnu\" => Some(\"aarch64-linux-gnu-gcc\"),\n+                    \"s390x-unknown-linux-gnu\" => Some(\"s390x-linux-gnu-gcc\"),\n+                    _ => None,\n                 };\n                 build_clif_sysroot_for_triple(\n+                    dirs,\n                     channel,\n-                    target_dir,\n                     target_triple,\n                     &cg_clif_dylib_path,\n                     linker,\n@@ -142,21 +139,26 @@ pub(crate) fn build_sysroot(\n                 let file = file.unwrap().path();\n                 let filename = file.file_name().unwrap().to_str().unwrap();\n                 if filename.contains(\"std-\") && !filename.contains(\".rlib\") {\n-                    try_hard_link(&file, target_dir.join(\"lib\").join(file.file_name().unwrap()));\n+                    try_hard_link(&file, LIB_DIR.to_path(dirs).join(file.file_name().unwrap()));\n                 }\n             }\n         }\n     }\n }\n \n+// FIXME move to download/ or dist/\n+pub(crate) static SYSROOT_RUSTC_VERSION: RelPath = RelPath::BUILD_SYSROOT.join(\"rustc_version\");\n+pub(crate) static SYSROOT_SRC: RelPath = RelPath::BUILD_SYSROOT.join(\"sysroot_src\");\n+static STANDARD_LIBRARY: CargoProject = CargoProject::new(&RelPath::BUILD_SYSROOT, \"build_sysroot\");\n+\n fn build_clif_sysroot_for_triple(\n+    dirs: &Dirs,\n     channel: &str,\n-    target_dir: &Path,\n     triple: &str,\n     cg_clif_dylib_path: &Path,\n     linker: Option<&str>,\n ) {\n-    match fs::read_to_string(Path::new(\"build_sysroot\").join(\"rustc_version\")) {\n+    match fs::read_to_string(SYSROOT_RUSTC_VERSION.to_path(dirs)) {\n         Err(e) => {\n             eprintln!(\"Failed to get rustc version for patched sysroot source: {}\", e);\n             eprintln!(\"Hint: Try `./y.rs prepare` to patch the sysroot source\");\n@@ -174,7 +176,7 @@ fn build_clif_sysroot_for_triple(\n         }\n     }\n \n-    let build_dir = Path::new(\"build_sysroot\").join(\"target\").join(triple).join(channel);\n+    let build_dir = STANDARD_LIBRARY.target_dir(dirs).join(triple).join(channel);\n \n     if !super::config::get_bool(\"keep_sysroot\") {\n         // Cleanup the deps dir, but keep build scripts and the incremental cache for faster\n@@ -185,27 +187,27 @@ fn build_clif_sysroot_for_triple(\n     }\n \n     // Build sysroot\n-    let mut build_cmd = cargo_command(\"cargo\", \"build\", Some(triple), Path::new(\"build_sysroot\"));\n     let mut rustflags = \"-Zforce-unstable-if-unmarked -Cpanic=abort\".to_string();\n     rustflags.push_str(&format!(\" -Zcodegen-backend={}\", cg_clif_dylib_path.to_str().unwrap()));\n-    rustflags.push_str(&format!(\" --sysroot={}\", target_dir.to_str().unwrap()));\n+    rustflags.push_str(&format!(\" --sysroot={}\", DIST_DIR.to_path(dirs).to_str().unwrap()));\n     if channel == \"release\" {\n-        build_cmd.arg(\"--release\");\n         rustflags.push_str(\" -Zmir-opt-level=3\");\n     }\n     if let Some(linker) = linker {\n         use std::fmt::Write;\n         write!(rustflags, \" -Clinker={}\", linker).unwrap();\n     }\n-    build_cmd.env(\"RUSTFLAGS\", rustflags);\n+    let mut compiler = Compiler::with_triple(triple.to_owned());\n+    compiler.rustflags = rustflags;\n+    let mut build_cmd = STANDARD_LIBRARY.build(&compiler, dirs);\n+    if channel == \"release\" {\n+        build_cmd.arg(\"--release\");\n+    }\n     build_cmd.env(\"__CARGO_DEFAULT_LIB_METADATA\", \"cg_clif\");\n     spawn_and_wait(build_cmd);\n \n     // Copy all relevant files to the sysroot\n-    for entry in\n-        fs::read_dir(Path::new(\"build_sysroot/target\").join(triple).join(channel).join(\"deps\"))\n-            .unwrap()\n-    {\n+    for entry in fs::read_dir(build_dir.join(\"deps\")).unwrap() {\n         let entry = entry.unwrap();\n         if let Some(ext) = entry.path().extension() {\n             if ext == \"rmeta\" || ext == \"d\" || ext == \"dSYM\" || ext == \"clif\" {\n@@ -216,7 +218,7 @@ fn build_clif_sysroot_for_triple(\n         };\n         try_hard_link(\n             entry.path(),\n-            target_dir.join(\"lib\").join(\"rustlib\").join(triple).join(\"lib\").join(entry.file_name()),\n+            RUSTLIB_DIR.to_path(dirs).join(triple).join(\"lib\").join(entry.file_name()),\n         );\n     }\n }"}, {"sha": "1afc9a55c73b5318bbc9ed006899c4f5ab3647c3", "filename": "compiler/rustc_codegen_cranelift/build_system/mod.rs", "status": "modified", "additions": 65, "deletions": 26, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -8,20 +8,37 @@ mod abi_cafe;\n mod build_backend;\n mod build_sysroot;\n mod config;\n+mod path;\n mod prepare;\n mod rustc_info;\n mod tests;\n mod utils;\n \n+const USAGE: &str = r#\"The build system of cg_clif.\n+\n+USAGE:\n+    ./y.rs prepare [--out-dir DIR]\n+    ./y.rs build [--debug] [--sysroot none|clif|llvm] [--out-dir DIR] [--no-unstable-features]\n+    ./y.rs test [--debug] [--sysroot none|clif|llvm] [--out-dir DIR] [--no-unstable-features]\n+\n+OPTIONS:\n+    --sysroot none|clif|llvm\n+            Which sysroot libraries to use:\n+            `none` will not include any standard library in the sysroot.\n+            `clif` will build the standard library using Cranelift.\n+            `llvm` will use the pre-compiled standard library of rustc which is compiled with LLVM.\n+\n+    --out-dir DIR\n+            Specify the directory in which the download, build and dist directories are stored.\n+            By default this is the working directory.\n+\n+    --no-unstable-features\n+            fSome features are not yet ready for production usage. This option will disable these\n+            features. This includes the JIT mode and inline assembly support.\n+\"#;\n+\n fn usage() {\n-    eprintln!(\"Usage:\");\n-    eprintln!(\"  ./y.rs prepare\");\n-    eprintln!(\n-        \"  ./y.rs build [--debug] [--sysroot none|clif|llvm] [--target-dir DIR] [--no-unstable-features]\"\n-    );\n-    eprintln!(\n-        \"  ./y.rs test [--debug] [--sysroot none|clif|llvm] [--target-dir DIR] [--no-unstable-features]\"\n-    );\n+    eprintln!(\"{USAGE}\");\n }\n \n macro_rules! arg_error {\n@@ -34,6 +51,7 @@ macro_rules! arg_error {\n \n #[derive(PartialEq, Debug)]\n enum Command {\n+    Prepare,\n     Build,\n     Test,\n }\n@@ -48,8 +66,6 @@ pub(crate) enum SysrootKind {\n pub fn main() {\n     env::set_var(\"CG_CLIF_DISPLAY_CG_TIME\", \"1\");\n     env::set_var(\"CG_CLIF_DISABLE_INCR_CACHE\", \"1\");\n-    // The target dir is expected in the default location. Guard against the user changing it.\n-    env::set_var(\"CARGO_TARGET_DIR\", \"target\");\n \n     if is_ci() {\n         // Disabling incr comp reduces cache size and incr comp doesn't save as much on CI anyway\n@@ -58,13 +74,7 @@ pub fn main() {\n \n     let mut args = env::args().skip(1);\n     let command = match args.next().as_deref() {\n-        Some(\"prepare\") => {\n-            if args.next().is_some() {\n-                arg_error!(\"./y.rs prepare doesn't expect arguments\");\n-            }\n-            prepare::prepare();\n-            process::exit(0);\n-        }\n+        Some(\"prepare\") => Command::Prepare,\n         Some(\"build\") => Command::Build,\n         Some(\"test\") => Command::Test,\n         Some(flag) if flag.starts_with('-') => arg_error!(\"Expected command found flag {}\", flag),\n@@ -75,15 +85,15 @@ pub fn main() {\n         }\n     };\n \n-    let mut target_dir = PathBuf::from(\"build\");\n+    let mut out_dir = PathBuf::from(\".\");\n     let mut channel = \"release\";\n     let mut sysroot_kind = SysrootKind::Clif;\n     let mut use_unstable_features = true;\n     while let Some(arg) = args.next().as_deref() {\n         match arg {\n-            \"--target-dir\" => {\n-                target_dir = PathBuf::from(args.next().unwrap_or_else(|| {\n-                    arg_error!(\"--target-dir requires argument\");\n+            \"--out-dir\" => {\n+                out_dir = PathBuf::from(args.next().unwrap_or_else(|| {\n+                    arg_error!(\"--out-dir requires argument\");\n                 }))\n             }\n             \"--debug\" => channel = \"debug\",\n@@ -101,7 +111,6 @@ pub fn main() {\n             arg => arg_error!(\"Unexpected argument {}\", arg),\n         }\n     }\n-    target_dir = std::env::current_dir().unwrap().join(target_dir);\n \n     let host_triple = if let Ok(host_triple) = std::env::var(\"HOST_TRIPLE\") {\n         host_triple\n@@ -122,13 +131,43 @@ pub fn main() {\n         host_triple.clone()\n     };\n \n-    let cg_clif_dylib = build_backend::build_backend(channel, &host_triple, use_unstable_features);\n+    // FIXME allow changing the location of these dirs using cli arguments\n+    let current_dir = std::env::current_dir().unwrap();\n+    out_dir = current_dir.join(out_dir);\n+    let dirs = path::Dirs {\n+        source_dir: current_dir.clone(),\n+        download_dir: out_dir.join(\"download\"),\n+        build_dir: out_dir.join(\"build\"),\n+        dist_dir: out_dir.join(\"dist\"),\n+    };\n+\n+    path::RelPath::BUILD.ensure_exists(&dirs);\n+\n+    {\n+        // Make sure we always explicitly specify the target dir\n+        let target =\n+            path::RelPath::BUILD.join(\"target_dir_should_be_set_explicitly\").to_path(&dirs);\n+        env::set_var(\"CARGO_TARGET_DIR\", &target);\n+        let _ = std::fs::remove_file(&target);\n+        std::fs::File::create(target).unwrap();\n+    }\n+\n+    if command == Command::Prepare {\n+        prepare::prepare(&dirs);\n+        process::exit(0);\n+    }\n+\n+    let cg_clif_dylib =\n+        build_backend::build_backend(&dirs, channel, &host_triple, use_unstable_features);\n     match command {\n+        Command::Prepare => {\n+            // Handled above\n+        }\n         Command::Test => {\n             tests::run_tests(\n+                &dirs,\n                 channel,\n                 sysroot_kind,\n-                &target_dir,\n                 &cg_clif_dylib,\n                 &host_triple,\n                 &target_triple,\n@@ -137,17 +176,17 @@ pub fn main() {\n             abi_cafe::run(\n                 channel,\n                 sysroot_kind,\n-                &target_dir,\n+                &dirs,\n                 &cg_clif_dylib,\n                 &host_triple,\n                 &target_triple,\n             );\n         }\n         Command::Build => {\n             build_sysroot::build_sysroot(\n+                &dirs,\n                 channel,\n                 sysroot_kind,\n-                &target_dir,\n                 &cg_clif_dylib,\n                 &host_triple,\n                 &target_triple,"}, {"sha": "e93981f1d64d369b28672c0e61ff5a533c271a23", "filename": "compiler/rustc_codegen_cranelift/build_system/path.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fpath.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -0,0 +1,70 @@\n+use std::fs;\n+use std::path::PathBuf;\n+\n+#[derive(Debug, Clone)]\n+pub(crate) struct Dirs {\n+    pub(crate) source_dir: PathBuf,\n+    pub(crate) download_dir: PathBuf,\n+    pub(crate) build_dir: PathBuf,\n+    pub(crate) dist_dir: PathBuf,\n+}\n+\n+#[doc(hidden)]\n+#[derive(Debug, Copy, Clone)]\n+pub(crate) enum PathBase {\n+    Source,\n+    Download,\n+    Build,\n+    Dist,\n+}\n+\n+impl PathBase {\n+    fn to_path(self, dirs: &Dirs) -> PathBuf {\n+        match self {\n+            PathBase::Source => dirs.source_dir.clone(),\n+            PathBase::Download => dirs.download_dir.clone(),\n+            PathBase::Build => dirs.build_dir.clone(),\n+            PathBase::Dist => dirs.dist_dir.clone(),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone)]\n+pub(crate) enum RelPath {\n+    Base(PathBase),\n+    Join(&'static RelPath, &'static str),\n+}\n+\n+impl RelPath {\n+    pub(crate) const SOURCE: RelPath = RelPath::Base(PathBase::Source);\n+    pub(crate) const DOWNLOAD: RelPath = RelPath::Base(PathBase::Download);\n+    pub(crate) const BUILD: RelPath = RelPath::Base(PathBase::Build);\n+    pub(crate) const DIST: RelPath = RelPath::Base(PathBase::Dist);\n+\n+    pub(crate) const SCRIPTS: RelPath = RelPath::SOURCE.join(\"scripts\");\n+    pub(crate) const BUILD_SYSROOT: RelPath = RelPath::SOURCE.join(\"build_sysroot\");\n+    pub(crate) const PATCHES: RelPath = RelPath::SOURCE.join(\"patches\");\n+\n+    pub(crate) const fn join(&'static self, suffix: &'static str) -> RelPath {\n+        RelPath::Join(self, suffix)\n+    }\n+\n+    pub(crate) fn to_path(&self, dirs: &Dirs) -> PathBuf {\n+        match self {\n+            RelPath::Base(base) => base.to_path(dirs),\n+            RelPath::Join(base, suffix) => base.to_path(dirs).join(suffix),\n+        }\n+    }\n+\n+    pub(crate) fn ensure_exists(&self, dirs: &Dirs) {\n+        fs::create_dir_all(self.to_path(dirs)).unwrap();\n+    }\n+\n+    pub(crate) fn ensure_fresh(&self, dirs: &Dirs) {\n+        let path = self.to_path(dirs);\n+        if path.exists() {\n+            fs::remove_dir_all(&path).unwrap();\n+        }\n+        fs::create_dir_all(path).unwrap();\n+    }\n+}"}, {"sha": "8ac67e8f9422823090a97ffab654c0da5a848e12", "filename": "compiler/rustc_codegen_cranelift/build_system/prepare.rs", "status": "modified", "additions": 78, "deletions": 76, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,92 +1,75 @@\n-use std::env;\n use std::ffi::OsStr;\n use std::fs;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n \n+use super::build_sysroot::{SYSROOT_RUSTC_VERSION, SYSROOT_SRC};\n+use super::path::{Dirs, RelPath};\n use super::rustc_info::{get_file_name, get_rustc_path, get_rustc_version};\n-use super::utils::{cargo_command, copy_dir_recursively, spawn_and_wait};\n-\n-pub(crate) const ABI_CAFE: GitRepo =\n-    GitRepo::github(\"Gankra\", \"abi-cafe\", \"4c6dc8c9c687e2b3a760ff2176ce236872b37212\", \"abi-cafe\");\n-\n-pub(crate) const RAND: GitRepo =\n-    GitRepo::github(\"rust-random\", \"rand\", \"0f933f9c7176e53b2a3c7952ded484e1783f0bf1\", \"rand\");\n-\n-pub(crate) const REGEX: GitRepo =\n-    GitRepo::github(\"rust-lang\", \"regex\", \"341f207c1071f7290e3f228c710817c280c8dca1\", \"regex\");\n-\n-pub(crate) const PORTABLE_SIMD: GitRepo = GitRepo::github(\n-    \"rust-lang\",\n-    \"portable-simd\",\n-    \"d5cd4a8112d958bd3a252327e0d069a6363249bd\",\n-    \"portable-simd\",\n-);\n-\n-pub(crate) const SIMPLE_RAYTRACER: GitRepo = GitRepo::github(\n-    \"ebobby\",\n-    \"simple-raytracer\",\n-    \"804a7a21b9e673a482797aa289a18ed480e4d813\",\n-    \"<none>\",\n-);\n-\n-pub(crate) fn prepare() {\n-    if Path::new(\"download\").exists() {\n-        std::fs::remove_dir_all(Path::new(\"download\")).unwrap();\n+use super::utils::{copy_dir_recursively, spawn_and_wait, Compiler};\n+\n+pub(crate) fn prepare(dirs: &Dirs) {\n+    if RelPath::DOWNLOAD.to_path(dirs).exists() {\n+        std::fs::remove_dir_all(RelPath::DOWNLOAD.to_path(dirs)).unwrap();\n     }\n-    std::fs::create_dir_all(Path::new(\"download\")).unwrap();\n+    std::fs::create_dir_all(RelPath::DOWNLOAD.to_path(dirs)).unwrap();\n \n-    prepare_sysroot();\n+    prepare_sysroot(dirs);\n \n     // FIXME maybe install this only locally?\n     eprintln!(\"[INSTALL] hyperfine\");\n-    Command::new(\"cargo\").arg(\"install\").arg(\"hyperfine\").spawn().unwrap().wait().unwrap();\n+    Command::new(\"cargo\")\n+        .arg(\"install\")\n+        .arg(\"hyperfine\")\n+        .env_remove(\"CARGO_TARGET_DIR\")\n+        .spawn()\n+        .unwrap()\n+        .wait()\n+        .unwrap();\n \n-    ABI_CAFE.fetch();\n-    RAND.fetch();\n-    REGEX.fetch();\n-    PORTABLE_SIMD.fetch();\n-    SIMPLE_RAYTRACER.fetch();\n+    super::abi_cafe::ABI_CAFE_REPO.fetch(dirs);\n+    super::tests::RAND_REPO.fetch(dirs);\n+    super::tests::REGEX_REPO.fetch(dirs);\n+    super::tests::PORTABLE_SIMD_REPO.fetch(dirs);\n+    super::tests::SIMPLE_RAYTRACER_REPO.fetch(dirs);\n \n     eprintln!(\"[LLVM BUILD] simple-raytracer\");\n-    let build_cmd = cargo_command(\"cargo\", \"build\", None, &SIMPLE_RAYTRACER.source_dir());\n+    let host_compiler = Compiler::host();\n+    let build_cmd = super::tests::SIMPLE_RAYTRACER.build(&host_compiler, dirs);\n     spawn_and_wait(build_cmd);\n     fs::copy(\n-        SIMPLE_RAYTRACER\n-            .source_dir()\n-            .join(\"target\")\n+        super::tests::SIMPLE_RAYTRACER\n+            .target_dir(dirs)\n+            .join(&host_compiler.triple)\n             .join(\"debug\")\n             .join(get_file_name(\"main\", \"bin\")),\n-        SIMPLE_RAYTRACER.source_dir().join(get_file_name(\"raytracer_cg_llvm\", \"bin\")),\n+        RelPath::BUILD.to_path(dirs).join(get_file_name(\"raytracer_cg_llvm\", \"bin\")),\n     )\n     .unwrap();\n }\n \n-fn prepare_sysroot() {\n+fn prepare_sysroot(dirs: &Dirs) {\n     let rustc_path = get_rustc_path();\n     let sysroot_src_orig = rustc_path.parent().unwrap().join(\"../lib/rustlib/src/rust\");\n-    let sysroot_src = env::current_dir().unwrap().join(\"build_sysroot\").join(\"sysroot_src\");\n+    let sysroot_src = SYSROOT_SRC;\n \n     assert!(sysroot_src_orig.exists());\n \n-    if sysroot_src.exists() {\n-        fs::remove_dir_all(&sysroot_src).unwrap();\n-    }\n-    fs::create_dir_all(sysroot_src.join(\"library\")).unwrap();\n+    sysroot_src.ensure_fresh(dirs);\n+    fs::create_dir_all(sysroot_src.to_path(dirs).join(\"library\")).unwrap();\n     eprintln!(\"[COPY] sysroot src\");\n-    copy_dir_recursively(&sysroot_src_orig.join(\"library\"), &sysroot_src.join(\"library\"));\n+    copy_dir_recursively(\n+        &sysroot_src_orig.join(\"library\"),\n+        &sysroot_src.to_path(dirs).join(\"library\"),\n+    );\n \n     let rustc_version = get_rustc_version();\n-    fs::write(Path::new(\"build_sysroot\").join(\"rustc_version\"), &rustc_version).unwrap();\n+    fs::write(SYSROOT_RUSTC_VERSION.to_path(dirs), &rustc_version).unwrap();\n \n     eprintln!(\"[GIT] init\");\n-    let mut git_init_cmd = Command::new(\"git\");\n-    git_init_cmd.arg(\"init\").arg(\"-q\").current_dir(&sysroot_src);\n-    spawn_and_wait(git_init_cmd);\n-\n-    init_git_repo(&sysroot_src);\n+    init_git_repo(&sysroot_src.to_path(dirs));\n \n-    apply_patches(\"sysroot\", &sysroot_src);\n+    apply_patches(dirs, \"sysroot\", &sysroot_src.to_path(dirs));\n }\n \n pub(crate) struct GitRepo {\n@@ -100,7 +83,7 @@ enum GitRepoUrl {\n }\n \n impl GitRepo {\n-    const fn github(\n+    pub(crate) const fn github(\n         user: &'static str,\n         repo: &'static str,\n         rev: &'static str,\n@@ -109,21 +92,25 @@ impl GitRepo {\n         GitRepo { url: GitRepoUrl::Github { user, repo }, rev, patch_name }\n     }\n \n-    pub(crate) fn source_dir(&self) -> PathBuf {\n+    pub(crate) const fn source_dir(&self) -> RelPath {\n         match self.url {\n-            GitRepoUrl::Github { user: _, repo } => {\n-                std::env::current_dir().unwrap().join(\"download\").join(repo)\n-            }\n+            GitRepoUrl::Github { user: _, repo } => RelPath::DOWNLOAD.join(repo),\n         }\n     }\n \n-    fn fetch(&self) {\n+    fn fetch(&self, dirs: &Dirs) {\n         match self.url {\n             GitRepoUrl::Github { user, repo } => {\n-                clone_repo_shallow_github(&self.source_dir(), user, repo, self.rev);\n+                clone_repo_shallow_github(\n+                    dirs,\n+                    &self.source_dir().to_path(dirs),\n+                    user,\n+                    repo,\n+                    self.rev,\n+                );\n             }\n         }\n-        apply_patches(self.patch_name, &self.source_dir());\n+        apply_patches(dirs, self.patch_name, &self.source_dir().to_path(dirs));\n     }\n }\n \n@@ -142,18 +129,16 @@ fn clone_repo(download_dir: &Path, repo: &str, rev: &str) {\n     spawn_and_wait(checkout_cmd);\n }\n \n-fn clone_repo_shallow_github(download_dir: &Path, user: &str, repo: &str, rev: &str) {\n+fn clone_repo_shallow_github(dirs: &Dirs, download_dir: &Path, user: &str, repo: &str, rev: &str) {\n     if cfg!(windows) {\n         // Older windows doesn't have tar or curl by default. Fall back to using git.\n         clone_repo(download_dir, &format!(\"https://github.com/{}/{}.git\", user, repo), rev);\n         return;\n     }\n \n-    let downloads_dir = std::env::current_dir().unwrap().join(\"download\");\n-\n     let archive_url = format!(\"https://github.com/{}/{}/archive/{}.tar.gz\", user, repo, rev);\n-    let archive_file = downloads_dir.join(format!(\"{}.tar.gz\", rev));\n-    let archive_dir = downloads_dir.join(format!(\"{}-{}\", repo, rev));\n+    let archive_file = RelPath::DOWNLOAD.to_path(dirs).join(format!(\"{}.tar.gz\", rev));\n+    let archive_dir = RelPath::DOWNLOAD.to_path(dirs).join(format!(\"{}-{}\", repo, rev));\n \n     eprintln!(\"[DOWNLOAD] {}/{} from {}\", user, repo, archive_url);\n \n@@ -169,7 +154,7 @@ fn clone_repo_shallow_github(download_dir: &Path, user: &str, repo: &str, rev: &\n \n     // Unpack tar archive\n     let mut unpack_cmd = Command::new(\"tar\");\n-    unpack_cmd.arg(\"xf\").arg(&archive_file).current_dir(downloads_dir);\n+    unpack_cmd.arg(\"xf\").arg(&archive_file).current_dir(RelPath::DOWNLOAD.to_path(dirs));\n     spawn_and_wait(unpack_cmd);\n \n     // Rename unpacked dir to the expected name\n@@ -191,12 +176,21 @@ fn init_git_repo(repo_dir: &Path) {\n     spawn_and_wait(git_add_cmd);\n \n     let mut git_commit_cmd = Command::new(\"git\");\n-    git_commit_cmd.arg(\"commit\").arg(\"-m\").arg(\"Initial commit\").arg(\"-q\").current_dir(repo_dir);\n+    git_commit_cmd\n+        .arg(\"-c\")\n+        .arg(\"user.name=Dummy\")\n+        .arg(\"-c\")\n+        .arg(\"user.email=dummy@example.com\")\n+        .arg(\"commit\")\n+        .arg(\"-m\")\n+        .arg(\"Initial commit\")\n+        .arg(\"-q\")\n+        .current_dir(repo_dir);\n     spawn_and_wait(git_commit_cmd);\n }\n \n-fn get_patches(source_dir: &Path, crate_name: &str) -> Vec<PathBuf> {\n-    let mut patches: Vec<_> = fs::read_dir(source_dir.join(\"patches\"))\n+fn get_patches(dirs: &Dirs, crate_name: &str) -> Vec<PathBuf> {\n+    let mut patches: Vec<_> = fs::read_dir(RelPath::PATCHES.to_path(dirs))\n         .unwrap()\n         .map(|entry| entry.unwrap().path())\n         .filter(|path| path.extension() == Some(OsStr::new(\"patch\")))\n@@ -215,19 +209,27 @@ fn get_patches(source_dir: &Path, crate_name: &str) -> Vec<PathBuf> {\n     patches\n }\n \n-fn apply_patches(crate_name: &str, target_dir: &Path) {\n+fn apply_patches(dirs: &Dirs, crate_name: &str, target_dir: &Path) {\n     if crate_name == \"<none>\" {\n         return;\n     }\n \n-    for patch in get_patches(&std::env::current_dir().unwrap(), crate_name) {\n+    for patch in get_patches(dirs, crate_name) {\n         eprintln!(\n             \"[PATCH] {:?} <- {:?}\",\n             target_dir.file_name().unwrap(),\n             patch.file_name().unwrap()\n         );\n         let mut apply_patch_cmd = Command::new(\"git\");\n-        apply_patch_cmd.arg(\"am\").arg(patch).arg(\"-q\").current_dir(target_dir);\n+        apply_patch_cmd\n+            .arg(\"-c\")\n+            .arg(\"user.name=Dummy\")\n+            .arg(\"-c\")\n+            .arg(\"user.email=dummy@example.com\")\n+            .arg(\"am\")\n+            .arg(patch)\n+            .arg(\"-q\")\n+            .current_dir(target_dir);\n         spawn_and_wait(apply_patch_cmd);\n     }\n }"}, {"sha": "8e5ab688e131b35325af4fb83a3387b8c6228449", "filename": "compiler/rustc_codegen_cranelift/build_system/rustc_info.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Frustc_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Frustc_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Frustc_info.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -23,6 +23,16 @@ pub(crate) fn get_host_triple() -> String {\n         .to_owned()\n }\n \n+pub(crate) fn get_cargo_path() -> PathBuf {\n+    let cargo_path = Command::new(\"rustup\")\n+        .stderr(Stdio::inherit())\n+        .args(&[\"which\", \"cargo\"])\n+        .output()\n+        .unwrap()\n+        .stdout;\n+    Path::new(String::from_utf8(cargo_path).unwrap().trim()).to_owned()\n+}\n+\n pub(crate) fn get_rustc_path() -> PathBuf {\n     let rustc_path = Command::new(\"rustup\")\n         .stderr(Stdio::inherit())\n@@ -33,6 +43,16 @@ pub(crate) fn get_rustc_path() -> PathBuf {\n     Path::new(String::from_utf8(rustc_path).unwrap().trim()).to_owned()\n }\n \n+pub(crate) fn get_rustdoc_path() -> PathBuf {\n+    let rustc_path = Command::new(\"rustup\")\n+        .stderr(Stdio::inherit())\n+        .args(&[\"which\", \"rustdoc\"])\n+        .output()\n+        .unwrap()\n+        .stdout;\n+    Path::new(String::from_utf8(rustc_path).unwrap().trim()).to_owned()\n+}\n+\n pub(crate) fn get_default_sysroot() -> PathBuf {\n     let default_sysroot = Command::new(\"rustc\")\n         .stderr(Stdio::inherit())"}, {"sha": "1c372736ed65d9121dccf04ae5bcf504d45127bc", "filename": "compiler/rustc_codegen_cranelift/build_system/tests.rs", "status": "modified", "additions": 294, "deletions": 259, "changes": 553, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,15 +1,20 @@\n use super::build_sysroot;\n use super::config;\n-use super::prepare;\n-use super::rustc_info::get_wrapper_file_name;\n-use super::utils::{cargo_command, hyperfine_command, spawn_and_wait, spawn_and_wait_with_input};\n-use build_system::SysrootKind;\n+use super::path::{Dirs, RelPath};\n+use super::prepare::GitRepo;\n+use super::rustc_info::{get_cargo_path, get_wrapper_file_name};\n+use super::utils::{\n+    hyperfine_command, spawn_and_wait, spawn_and_wait_with_input, CargoProject, Compiler,\n+};\n+use super::SysrootKind;\n use std::env;\n use std::ffi::OsStr;\n use std::fs;\n-use std::path::{Path, PathBuf};\n+use std::path::Path;\n use std::process::Command;\n \n+static BUILD_EXAMPLE_OUT_DIR: RelPath = RelPath::BUILD.join(\"example\");\n+\n struct TestCase {\n     config: &'static str,\n     func: &'static dyn Fn(&TestRunner),\n@@ -30,7 +35,7 @@ const NO_SYSROOT_SUITE: &[TestCase] = &[\n             \"--crate-type\",\n             \"lib,dylib\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n     }),\n     TestCase::new(\"build.example\", &|runner| {\n@@ -39,7 +44,7 @@ const NO_SYSROOT_SUITE: &[TestCase] = &[\n             \"--crate-type\",\n             \"lib\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n     }),\n     TestCase::new(\"jit.mini_core_hello_world\", &|runner| {\n@@ -51,7 +56,7 @@ const NO_SYSROOT_SUITE: &[TestCase] = &[\n             \"--cfg\",\n             \"jit\",\n             \"--target\",\n-            &runner.host_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         jit_cmd.env(\"CG_CLIF_JIT_ARGS\", \"abc bcd\");\n         spawn_and_wait(jit_cmd);\n@@ -65,7 +70,7 @@ const NO_SYSROOT_SUITE: &[TestCase] = &[\n             \"--cfg\",\n             \"jit\",\n             \"--target\",\n-            &runner.host_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         jit_cmd.env(\"CG_CLIF_JIT_ARGS\", \"abc bcd\");\n         spawn_and_wait(jit_cmd);\n@@ -79,7 +84,7 @@ const NO_SYSROOT_SUITE: &[TestCase] = &[\n             \"bin\",\n             \"-g\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         runner.run_out_command(\"mini_core_hello_world\", [\"abc\", \"bcd\"]);\n     }),\n@@ -94,7 +99,7 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"--crate-type\",\n             \"bin\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         runner.run_out_command(\"arbitrary_self_types_pointers_and_wrappers\", []);\n     }),\n@@ -106,7 +111,7 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"--crate-type\",\n             \"bin\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         runner.run_out_command(\"issue_91827_extern_types\", []);\n     }),\n@@ -116,7 +121,7 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"--crate-type\",\n             \"lib\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n     }),\n     TestCase::new(\"aot.alloc_example\", &|runner| {\n@@ -125,7 +130,7 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"--crate-type\",\n             \"bin\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         runner.run_out_command(\"alloc_example\", []);\n     }),\n@@ -136,7 +141,7 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"-Cprefer-dynamic\",\n             \"example/std_example.rs\",\n             \"--target\",\n-            &runner.host_triple,\n+            &runner.target_compiler.triple,\n         ]);\n \n         eprintln!(\"[JIT-lazy] std_example\");\n@@ -146,7 +151,7 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"-Cprefer-dynamic\",\n             \"example/std_example.rs\",\n             \"--target\",\n-            &runner.host_triple,\n+            &runner.target_compiler.triple,\n         ]);\n     }),\n     TestCase::new(\"aot.std_example\", &|runner| {\n@@ -155,7 +160,7 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"--crate-type\",\n             \"bin\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         runner.run_out_command(\"std_example\", [\"arg\"]);\n     }),\n@@ -167,7 +172,7 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"--crate-type\",\n             \"bin\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         runner.run_out_command(\"dst_field_align\", []);\n     }),\n@@ -178,7 +183,7 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"bin\",\n             \"-Cpanic=abort\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         runner.run_out_command(\"subslice-patterns-const-eval\", []);\n     }),\n@@ -189,7 +194,7 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"bin\",\n             \"-Cpanic=abort\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         runner.run_out_command(\"track-caller-attribute\", []);\n     }),\n@@ -200,7 +205,7 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"bin\",\n             \"-Cpanic=abort\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         runner.run_out_command(\"float-minmax-pass\", []);\n     }),\n@@ -210,205 +215,252 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"--crate-type\",\n             \"bin\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         runner.run_out_command(\"mod_bench\", []);\n     }),\n+    TestCase::new(\"aot.issue-72793\", &|runner| {\n+        runner.run_rustc([\n+            \"example/issue-72793.rs\",\n+            \"--crate-type\",\n+            \"bin\",\n+            \"--target\",\n+            &runner.target_compiler.triple,\n+        ]);\n+        runner.run_out_command(\"issue-72793\", []);\n+    }),\n ];\n \n+pub(crate) static RAND_REPO: GitRepo =\n+    GitRepo::github(\"rust-random\", \"rand\", \"0f933f9c7176e53b2a3c7952ded484e1783f0bf1\", \"rand\");\n+\n+static RAND: CargoProject = CargoProject::new(&RAND_REPO.source_dir(), \"rand\");\n+\n+pub(crate) static REGEX_REPO: GitRepo =\n+    GitRepo::github(\"rust-lang\", \"regex\", \"341f207c1071f7290e3f228c710817c280c8dca1\", \"regex\");\n+\n+static REGEX: CargoProject = CargoProject::new(&REGEX_REPO.source_dir(), \"regex\");\n+\n+pub(crate) static PORTABLE_SIMD_REPO: GitRepo = GitRepo::github(\n+    \"rust-lang\",\n+    \"portable-simd\",\n+    \"d5cd4a8112d958bd3a252327e0d069a6363249bd\",\n+    \"portable-simd\",\n+);\n+\n+static PORTABLE_SIMD: CargoProject =\n+    CargoProject::new(&PORTABLE_SIMD_REPO.source_dir(), \"portable_simd\");\n+\n+pub(crate) static SIMPLE_RAYTRACER_REPO: GitRepo = GitRepo::github(\n+    \"ebobby\",\n+    \"simple-raytracer\",\n+    \"804a7a21b9e673a482797aa289a18ed480e4d813\",\n+    \"<none>\",\n+);\n+\n+pub(crate) static SIMPLE_RAYTRACER: CargoProject =\n+    CargoProject::new(&SIMPLE_RAYTRACER_REPO.source_dir(), \"simple_raytracer\");\n+\n+static LIBCORE_TESTS: CargoProject =\n+    CargoProject::new(&RelPath::BUILD_SYSROOT.join(\"sysroot_src/library/core/tests\"), \"core_tests\");\n+\n const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n     TestCase::new(\"test.rust-random/rand\", &|runner| {\n-        runner.in_dir(prepare::RAND.source_dir(), |runner| {\n-            runner.run_cargo(\"clean\", []);\n-\n-            if runner.host_triple == runner.target_triple {\n-                eprintln!(\"[TEST] rust-random/rand\");\n-                runner.run_cargo(\"test\", [\"--workspace\"]);\n-            } else {\n-                eprintln!(\"[AOT] rust-random/rand\");\n-                runner.run_cargo(\"build\", [\"--workspace\", \"--tests\"]);\n-            }\n-        });\n+        spawn_and_wait(RAND.clean(&runner.target_compiler.cargo, &runner.dirs));\n+\n+        if runner.is_native {\n+            eprintln!(\"[TEST] rust-random/rand\");\n+            let mut test_cmd = RAND.test(&runner.target_compiler, &runner.dirs);\n+            test_cmd.arg(\"--workspace\");\n+            spawn_and_wait(test_cmd);\n+        } else {\n+            eprintln!(\"[AOT] rust-random/rand\");\n+            let mut build_cmd = RAND.build(&runner.target_compiler, &runner.dirs);\n+            build_cmd.arg(\"--workspace\").arg(\"--tests\");\n+            spawn_and_wait(build_cmd);\n+        }\n     }),\n     TestCase::new(\"bench.simple-raytracer\", &|runner| {\n-        runner.in_dir(prepare::SIMPLE_RAYTRACER.source_dir(), |runner| {\n-            let run_runs = env::var(\"RUN_RUNS\").unwrap_or(\"10\".to_string()).parse().unwrap();\n-\n-            if runner.host_triple == runner.target_triple {\n-                eprintln!(\"[BENCH COMPILE] ebobby/simple-raytracer\");\n-                let prepare = runner.cargo_command(\"clean\", []);\n-\n-                let llvm_build_cmd = cargo_command(\"cargo\", \"build\", None, Path::new(\".\"));\n-\n-                let cargo_clif = runner\n-                    .root_dir\n-                    .clone()\n-                    .join(\"build\")\n-                    .join(get_wrapper_file_name(\"cargo-clif\", \"bin\"));\n-                let clif_build_cmd = cargo_command(cargo_clif, \"build\", None, Path::new(\".\"));\n-\n-                let bench_compile =\n-                    hyperfine_command(1, run_runs, Some(prepare), llvm_build_cmd, clif_build_cmd);\n-\n-                spawn_and_wait(bench_compile);\n-\n-                eprintln!(\"[BENCH RUN] ebobby/simple-raytracer\");\n-                fs::copy(PathBuf::from(\"./target/debug/main\"), PathBuf::from(\"raytracer_cg_clif\"))\n-                    .unwrap();\n-\n-                let bench_run = hyperfine_command(\n-                    0,\n-                    run_runs,\n-                    None,\n-                    Command::new(\"./raytracer_cg_llvm\"),\n-                    Command::new(\"./raytracer_cg_clif\"),\n-                );\n-                spawn_and_wait(bench_run);\n-            } else {\n-                runner.run_cargo(\"clean\", []);\n-                eprintln!(\"[BENCH COMPILE] ebobby/simple-raytracer (skipped)\");\n-                eprintln!(\"[COMPILE] ebobby/simple-raytracer\");\n-                runner.run_cargo(\"build\", []);\n-                eprintln!(\"[BENCH RUN] ebobby/simple-raytracer (skipped)\");\n-            }\n-        });\n+        let run_runs = env::var(\"RUN_RUNS\").unwrap_or(\"10\".to_string()).parse().unwrap();\n+\n+        if runner.is_native {\n+            eprintln!(\"[BENCH COMPILE] ebobby/simple-raytracer\");\n+            let cargo_clif = RelPath::DIST\n+                .to_path(&runner.dirs)\n+                .join(get_wrapper_file_name(\"cargo-clif\", \"bin\"));\n+            let manifest_path = SIMPLE_RAYTRACER.manifest_path(&runner.dirs);\n+            let target_dir = SIMPLE_RAYTRACER.target_dir(&runner.dirs);\n+\n+            let clean_cmd = format!(\n+                \"cargo clean --manifest-path {manifest_path} --target-dir {target_dir}\",\n+                manifest_path = manifest_path.display(),\n+                target_dir = target_dir.display(),\n+            );\n+            let llvm_build_cmd = format!(\n+                \"cargo build --manifest-path {manifest_path} --target-dir {target_dir}\",\n+                manifest_path = manifest_path.display(),\n+                target_dir = target_dir.display(),\n+            );\n+            let clif_build_cmd = format!(\n+                \"{cargo_clif} build --manifest-path {manifest_path} --target-dir {target_dir}\",\n+                cargo_clif = cargo_clif.display(),\n+                manifest_path = manifest_path.display(),\n+                target_dir = target_dir.display(),\n+            );\n+\n+            let bench_compile =\n+                hyperfine_command(1, run_runs, Some(&clean_cmd), &llvm_build_cmd, &clif_build_cmd);\n+\n+            spawn_and_wait(bench_compile);\n+\n+            eprintln!(\"[BENCH RUN] ebobby/simple-raytracer\");\n+            fs::copy(\n+                target_dir.join(\"debug\").join(\"main\"),\n+                RelPath::BUILD.to_path(&runner.dirs).join(\"raytracer_cg_clif\"),\n+            )\n+            .unwrap();\n+\n+            let mut bench_run =\n+                hyperfine_command(0, run_runs, None, \"./raytracer_cg_llvm\", \"./raytracer_cg_clif\");\n+            bench_run.current_dir(RelPath::BUILD.to_path(&runner.dirs));\n+            spawn_and_wait(bench_run);\n+        } else {\n+            spawn_and_wait(SIMPLE_RAYTRACER.clean(&runner.target_compiler.cargo, &runner.dirs));\n+            eprintln!(\"[BENCH COMPILE] ebobby/simple-raytracer (skipped)\");\n+            eprintln!(\"[COMPILE] ebobby/simple-raytracer\");\n+            spawn_and_wait(SIMPLE_RAYTRACER.build(&runner.target_compiler, &runner.dirs));\n+            eprintln!(\"[BENCH RUN] ebobby/simple-raytracer (skipped)\");\n+        }\n     }),\n     TestCase::new(\"test.libcore\", &|runner| {\n-        runner.in_dir(\n-            std::env::current_dir()\n-                .unwrap()\n-                .join(\"build_sysroot\")\n-                .join(\"sysroot_src\")\n-                .join(\"library\")\n-                .join(\"core\")\n-                .join(\"tests\"),\n-            |runner| {\n-                runner.run_cargo(\"clean\", []);\n-\n-                if runner.host_triple == runner.target_triple {\n-                    runner.run_cargo(\"test\", []);\n-                } else {\n-                    eprintln!(\"Cross-Compiling: Not running tests\");\n-                    runner.run_cargo(\"build\", [\"--tests\"]);\n-                }\n-            },\n-        );\n+        spawn_and_wait(LIBCORE_TESTS.clean(&runner.host_compiler.cargo, &runner.dirs));\n+\n+        if runner.is_native {\n+            spawn_and_wait(LIBCORE_TESTS.test(&runner.target_compiler, &runner.dirs));\n+        } else {\n+            eprintln!(\"Cross-Compiling: Not running tests\");\n+            let mut build_cmd = LIBCORE_TESTS.build(&runner.target_compiler, &runner.dirs);\n+            build_cmd.arg(\"--tests\");\n+            spawn_and_wait(build_cmd);\n+        }\n     }),\n     TestCase::new(\"test.regex-shootout-regex-dna\", &|runner| {\n-        runner.in_dir(prepare::REGEX.source_dir(), |runner| {\n-            runner.run_cargo(\"clean\", []);\n-\n-            // newer aho_corasick versions throw a deprecation warning\n-            let lint_rust_flags = format!(\"{} --cap-lints warn\", runner.rust_flags);\n-\n-            let mut build_cmd = runner.cargo_command(\"build\", [\"--example\", \"shootout-regex-dna\"]);\n-            build_cmd.env(\"RUSTFLAGS\", lint_rust_flags.clone());\n-            spawn_and_wait(build_cmd);\n-\n-            if runner.host_triple == runner.target_triple {\n-                let mut run_cmd = runner.cargo_command(\"run\", [\"--example\", \"shootout-regex-dna\"]);\n-                run_cmd.env(\"RUSTFLAGS\", lint_rust_flags);\n-\n-                let input =\n-                    fs::read_to_string(PathBuf::from(\"examples/regexdna-input.txt\")).unwrap();\n-                let expected_path = PathBuf::from(\"examples/regexdna-output.txt\");\n-                let expected = fs::read_to_string(&expected_path).unwrap();\n-\n-                let output = spawn_and_wait_with_input(run_cmd, input);\n-                // Make sure `[codegen mono items] start` doesn't poison the diff\n-                let output = output\n-                    .lines()\n-                    .filter(|line| !line.contains(\"codegen mono items\"))\n-                    .chain(Some(\"\")) // This just adds the trailing newline\n-                    .collect::<Vec<&str>>()\n-                    .join(\"\\r\\n\");\n-\n-                let output_matches = expected.lines().eq(output.lines());\n-                if !output_matches {\n-                    let res_path = PathBuf::from(\"res.txt\");\n-                    fs::write(&res_path, &output).unwrap();\n-\n-                    if cfg!(windows) {\n-                        println!(\"Output files don't match!\");\n-                        println!(\"Expected Output:\\n{}\", expected);\n-                        println!(\"Actual Output:\\n{}\", output);\n-                    } else {\n-                        let mut diff = Command::new(\"diff\");\n-                        diff.arg(\"-u\");\n-                        diff.arg(res_path);\n-                        diff.arg(expected_path);\n-                        spawn_and_wait(diff);\n-                    }\n-\n-                    std::process::exit(1);\n+        spawn_and_wait(REGEX.clean(&runner.target_compiler.cargo, &runner.dirs));\n+\n+        // newer aho_corasick versions throw a deprecation warning\n+        let lint_rust_flags = format!(\"{} --cap-lints warn\", runner.target_compiler.rustflags);\n+\n+        let mut build_cmd = REGEX.build(&runner.target_compiler, &runner.dirs);\n+        build_cmd.arg(\"--example\").arg(\"shootout-regex-dna\");\n+        build_cmd.env(\"RUSTFLAGS\", lint_rust_flags.clone());\n+        spawn_and_wait(build_cmd);\n+\n+        if runner.is_native {\n+            let mut run_cmd = REGEX.run(&runner.target_compiler, &runner.dirs);\n+            run_cmd.arg(\"--example\").arg(\"shootout-regex-dna\");\n+            run_cmd.env(\"RUSTFLAGS\", lint_rust_flags);\n+\n+            let input = fs::read_to_string(\n+                REGEX.source_dir(&runner.dirs).join(\"examples\").join(\"regexdna-input.txt\"),\n+            )\n+            .unwrap();\n+            let expected_path =\n+                REGEX.source_dir(&runner.dirs).join(\"examples\").join(\"regexdna-output.txt\");\n+            let expected = fs::read_to_string(&expected_path).unwrap();\n+\n+            let output = spawn_and_wait_with_input(run_cmd, input);\n+            // Make sure `[codegen mono items] start` doesn't poison the diff\n+            let output = output\n+                .lines()\n+                .filter(|line| !line.contains(\"codegen mono items\"))\n+                .chain(Some(\"\")) // This just adds the trailing newline\n+                .collect::<Vec<&str>>()\n+                .join(\"\\r\\n\");\n+\n+            let output_matches = expected.lines().eq(output.lines());\n+            if !output_matches {\n+                let res_path = REGEX.source_dir(&runner.dirs).join(\"res.txt\");\n+                fs::write(&res_path, &output).unwrap();\n+\n+                if cfg!(windows) {\n+                    println!(\"Output files don't match!\");\n+                    println!(\"Expected Output:\\n{}\", expected);\n+                    println!(\"Actual Output:\\n{}\", output);\n+                } else {\n+                    let mut diff = Command::new(\"diff\");\n+                    diff.arg(\"-u\");\n+                    diff.arg(res_path);\n+                    diff.arg(expected_path);\n+                    spawn_and_wait(diff);\n                 }\n+\n+                std::process::exit(1);\n             }\n-        });\n+        }\n     }),\n     TestCase::new(\"test.regex\", &|runner| {\n-        runner.in_dir(prepare::REGEX.source_dir(), |runner| {\n-            runner.run_cargo(\"clean\", []);\n-\n-            // newer aho_corasick versions throw a deprecation warning\n-            let lint_rust_flags = format!(\"{} --cap-lints warn\", runner.rust_flags);\n-\n-            if runner.host_triple == runner.target_triple {\n-                let mut run_cmd = runner.cargo_command(\n-                    \"test\",\n-                    [\n-                        \"--tests\",\n-                        \"--\",\n-                        \"--exclude-should-panic\",\n-                        \"--test-threads\",\n-                        \"1\",\n-                        \"-Zunstable-options\",\n-                        \"-q\",\n-                    ],\n-                );\n-                run_cmd.env(\"RUSTFLAGS\", lint_rust_flags);\n-                spawn_and_wait(run_cmd);\n-            } else {\n-                eprintln!(\"Cross-Compiling: Not running tests\");\n-                let mut build_cmd =\n-                    runner.cargo_command(\"build\", [\"--tests\", \"--target\", &runner.target_triple]);\n-                build_cmd.env(\"RUSTFLAGS\", lint_rust_flags.clone());\n-                spawn_and_wait(build_cmd);\n-            }\n-        });\n+        spawn_and_wait(REGEX.clean(&runner.host_compiler.cargo, &runner.dirs));\n+\n+        // newer aho_corasick versions throw a deprecation warning\n+        let lint_rust_flags = format!(\"{} --cap-lints warn\", runner.target_compiler.rustflags);\n+\n+        if runner.is_native {\n+            let mut run_cmd = REGEX.test(&runner.target_compiler, &runner.dirs);\n+            run_cmd.args([\n+                \"--tests\",\n+                \"--\",\n+                \"--exclude-should-panic\",\n+                \"--test-threads\",\n+                \"1\",\n+                \"-Zunstable-options\",\n+                \"-q\",\n+            ]);\n+            run_cmd.env(\"RUSTFLAGS\", lint_rust_flags);\n+            spawn_and_wait(run_cmd);\n+        } else {\n+            eprintln!(\"Cross-Compiling: Not running tests\");\n+            let mut build_cmd = REGEX.build(&runner.target_compiler, &runner.dirs);\n+            build_cmd.arg(\"--tests\");\n+            build_cmd.env(\"RUSTFLAGS\", lint_rust_flags.clone());\n+            spawn_and_wait(build_cmd);\n+        }\n     }),\n     TestCase::new(\"test.portable-simd\", &|runner| {\n-        runner.in_dir(prepare::PORTABLE_SIMD.source_dir(), |runner| {\n-            runner.run_cargo(\"clean\", []);\n-            runner.run_cargo(\"build\", [\"--all-targets\", \"--target\", &runner.target_triple]);\n+        spawn_and_wait(PORTABLE_SIMD.clean(&runner.host_compiler.cargo, &runner.dirs));\n \n-            if runner.host_triple == runner.target_triple {\n-                runner.run_cargo(\"test\", [\"-q\"]);\n-            }\n-        });\n+        let mut build_cmd = PORTABLE_SIMD.build(&runner.target_compiler, &runner.dirs);\n+        build_cmd.arg(\"--all-targets\");\n+        spawn_and_wait(build_cmd);\n+\n+        if runner.is_native {\n+            let mut test_cmd = PORTABLE_SIMD.test(&runner.target_compiler, &runner.dirs);\n+            test_cmd.arg(\"-q\");\n+            spawn_and_wait(test_cmd);\n+        }\n     }),\n ];\n \n pub(crate) fn run_tests(\n+    dirs: &Dirs,\n     channel: &str,\n     sysroot_kind: SysrootKind,\n-    target_dir: &Path,\n     cg_clif_dylib: &Path,\n     host_triple: &str,\n     target_triple: &str,\n ) {\n-    let runner = TestRunner::new(host_triple.to_string(), target_triple.to_string());\n+    let runner = TestRunner::new(dirs.clone(), host_triple.to_string(), target_triple.to_string());\n \n     if config::get_bool(\"testsuite.no_sysroot\") {\n         build_sysroot::build_sysroot(\n+            dirs,\n             channel,\n             SysrootKind::None,\n-            &target_dir,\n             cg_clif_dylib,\n             &host_triple,\n             &target_triple,\n         );\n \n-        let _ = fs::remove_dir_all(Path::new(\"target\").join(\"out\"));\n+        BUILD_EXAMPLE_OUT_DIR.ensure_fresh(dirs);\n         runner.run_testsuite(NO_SYSROOT_SUITE);\n     } else {\n         eprintln!(\"[SKIP] no_sysroot tests\");\n@@ -419,9 +471,9 @@ pub(crate) fn run_tests(\n \n     if run_base_sysroot || run_extended_sysroot {\n         build_sysroot::build_sysroot(\n+            dirs,\n             channel,\n             sysroot_kind,\n-            &target_dir,\n             cg_clif_dylib,\n             &host_triple,\n             &target_triple,\n@@ -442,40 +494,50 @@ pub(crate) fn run_tests(\n }\n \n struct TestRunner {\n-    root_dir: PathBuf,\n-    out_dir: PathBuf,\n+    is_native: bool,\n     jit_supported: bool,\n-    rust_flags: String,\n-    run_wrapper: Vec<String>,\n-    host_triple: String,\n-    target_triple: String,\n+    dirs: Dirs,\n+    host_compiler: Compiler,\n+    target_compiler: Compiler,\n }\n \n impl TestRunner {\n-    pub fn new(host_triple: String, target_triple: String) -> Self {\n-        let root_dir = env::current_dir().unwrap();\n-\n-        let mut out_dir = root_dir.clone();\n-        out_dir.push(\"target\");\n-        out_dir.push(\"out\");\n-\n+    pub fn new(dirs: Dirs, host_triple: String, target_triple: String) -> Self {\n         let is_native = host_triple == target_triple;\n         let jit_supported =\n             target_triple.contains(\"x86_64\") && is_native && !host_triple.contains(\"windows\");\n \n-        let mut rust_flags = env::var(\"RUSTFLAGS\").ok().unwrap_or(\"\".to_string());\n-        let mut run_wrapper = Vec::new();\n+        let rustc_clif =\n+            RelPath::DIST.to_path(&dirs).join(get_wrapper_file_name(\"rustc-clif\", \"bin\"));\n+        let rustdoc_clif =\n+            RelPath::DIST.to_path(&dirs).join(get_wrapper_file_name(\"rustdoc-clif\", \"bin\"));\n+\n+        let mut rustflags = env::var(\"RUSTFLAGS\").ok().unwrap_or(\"\".to_string());\n+        let mut runner = vec![];\n \n         if !is_native {\n             match target_triple.as_str() {\n                 \"aarch64-unknown-linux-gnu\" => {\n                     // We are cross-compiling for aarch64. Use the correct linker and run tests in qemu.\n-                    rust_flags = format!(\"-Clinker=aarch64-linux-gnu-gcc{}\", rust_flags);\n-                    run_wrapper = vec![\"qemu-aarch64\", \"-L\", \"/usr/aarch64-linux-gnu\"];\n+                    rustflags = format!(\"-Clinker=aarch64-linux-gnu-gcc{}\", rustflags);\n+                    runner = vec![\n+                        \"qemu-aarch64\".to_owned(),\n+                        \"-L\".to_owned(),\n+                        \"/usr/aarch64-linux-gnu\".to_owned(),\n+                    ];\n+                }\n+                \"s390x-unknown-linux-gnu\" => {\n+                    // We are cross-compiling for s390x. Use the correct linker and run tests in qemu.\n+                    rustflags = format!(\"-Clinker=s390x-linux-gnu-gcc{}\", rustflags);\n+                    runner = vec![\n+                        \"qemu-s390x\".to_owned(),\n+                        \"-L\".to_owned(),\n+                        \"/usr/s390x-linux-gnu\".to_owned(),\n+                    ];\n                 }\n                 \"x86_64-pc-windows-gnu\" => {\n                     // We are cross-compiling for Windows. Run tests in wine.\n-                    run_wrapper = vec![\"wine\"];\n+                    runner = vec![\"wine\".to_owned()];\n                 }\n                 _ => {\n                     println!(\"Unknown non-native platform\");\n@@ -484,19 +546,31 @@ impl TestRunner {\n         }\n \n         // FIXME fix `#[linkage = \"extern_weak\"]` without this\n-        if host_triple.contains(\"darwin\") {\n-            rust_flags = format!(\"{} -Clink-arg=-undefined -Clink-arg=dynamic_lookup\", rust_flags);\n+        if target_triple.contains(\"darwin\") {\n+            rustflags = format!(\"{} -Clink-arg=-undefined -Clink-arg=dynamic_lookup\", rustflags);\n         }\n \n-        Self {\n-            root_dir,\n-            out_dir,\n-            jit_supported,\n-            rust_flags,\n-            run_wrapper: run_wrapper.iter().map(|s| s.to_string()).collect(),\n-            host_triple,\n-            target_triple,\n-        }\n+        let host_compiler = Compiler {\n+            cargo: get_cargo_path(),\n+            rustc: rustc_clif.clone(),\n+            rustdoc: rustdoc_clif.clone(),\n+            rustflags: String::new(),\n+            rustdocflags: String::new(),\n+            triple: host_triple,\n+            runner: vec![],\n+        };\n+\n+        let target_compiler = Compiler {\n+            cargo: get_cargo_path(),\n+            rustc: rustc_clif,\n+            rustdoc: rustdoc_clif,\n+            rustflags: rustflags.clone(),\n+            rustdocflags: rustflags,\n+            triple: target_triple,\n+            runner,\n+        };\n+\n+        Self { is_native, jit_supported, dirs, host_compiler, target_compiler }\n     }\n \n     pub fn run_testsuite(&self, tests: &[TestCase]) {\n@@ -516,29 +590,18 @@ impl TestRunner {\n         }\n     }\n \n-    fn in_dir(&self, new: impl AsRef<Path>, callback: impl FnOnce(&TestRunner)) {\n-        let current = env::current_dir().unwrap();\n-\n-        env::set_current_dir(new).unwrap();\n-        callback(self);\n-        env::set_current_dir(current).unwrap();\n-    }\n-\n+    #[must_use]\n     fn rustc_command<I, S>(&self, args: I) -> Command\n     where\n         I: IntoIterator<Item = S>,\n         S: AsRef<OsStr>,\n     {\n-        let mut rustc_clif = self.root_dir.clone();\n-        rustc_clif.push(\"build\");\n-        rustc_clif.push(get_wrapper_file_name(\"rustc-clif\", \"bin\"));\n-\n-        let mut cmd = Command::new(rustc_clif);\n-        cmd.args(self.rust_flags.split_whitespace());\n+        let mut cmd = Command::new(&self.target_compiler.rustc);\n+        cmd.args(self.target_compiler.rustflags.split_whitespace());\n         cmd.arg(\"-L\");\n-        cmd.arg(format!(\"crate={}\", self.out_dir.display()));\n+        cmd.arg(format!(\"crate={}\", BUILD_EXAMPLE_OUT_DIR.to_path(&self.dirs).display()));\n         cmd.arg(\"--out-dir\");\n-        cmd.arg(format!(\"{}\", self.out_dir.display()));\n+        cmd.arg(format!(\"{}\", BUILD_EXAMPLE_OUT_DIR.to_path(&self.dirs).display()));\n         cmd.arg(\"-Cdebuginfo=2\");\n         cmd.args(args);\n         cmd\n@@ -559,15 +622,13 @@ impl TestRunner {\n         let mut full_cmd = vec![];\n \n         // Prepend the RUN_WRAPPER's\n-        if !self.run_wrapper.is_empty() {\n-            full_cmd.extend(self.run_wrapper.iter().cloned());\n+        if !self.target_compiler.runner.is_empty() {\n+            full_cmd.extend(self.target_compiler.runner.iter().cloned());\n         }\n \n-        full_cmd.push({\n-            let mut out_path = self.out_dir.clone();\n-            out_path.push(name);\n-            out_path.to_str().unwrap().to_string()\n-        });\n+        full_cmd.push(\n+            BUILD_EXAMPLE_OUT_DIR.to_path(&self.dirs).join(name).to_str().unwrap().to_string(),\n+        );\n \n         for arg in args.into_iter() {\n             full_cmd.push(arg.to_string());\n@@ -581,30 +642,4 @@ impl TestRunner {\n \n         spawn_and_wait(cmd);\n     }\n-\n-    fn cargo_command<'a, I>(&self, subcommand: &str, args: I) -> Command\n-    where\n-        I: IntoIterator<Item = &'a str>,\n-    {\n-        let mut cargo_clif = self.root_dir.clone();\n-        cargo_clif.push(\"build\");\n-        cargo_clif.push(get_wrapper_file_name(\"cargo-clif\", \"bin\"));\n-\n-        let mut cmd = cargo_command(\n-            cargo_clif,\n-            subcommand,\n-            if subcommand == \"clean\" { None } else { Some(&self.target_triple) },\n-            Path::new(\".\"),\n-        );\n-        cmd.args(args);\n-        cmd.env(\"RUSTFLAGS\", &self.rust_flags);\n-        cmd\n-    }\n-\n-    fn run_cargo<'a, I>(&self, subcommand: &str, args: I)\n-    where\n-        I: IntoIterator<Item = &'a str>,\n-    {\n-        spawn_and_wait(self.cargo_command(subcommand, args));\n-    }\n }"}, {"sha": "2be70e8e421b2961e97b53c99f38c83256940365", "filename": "compiler/rustc_codegen_cranelift/build_system/utils.rs", "status": "modified", "additions": 124, "deletions": 21, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Futils.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,35 +1,138 @@\n use std::env;\n use std::fs;\n use std::io::Write;\n-use std::path::Path;\n+use std::path::{Path, PathBuf};\n use std::process::{self, Command, Stdio};\n \n-pub(crate) fn cargo_command(\n-    cargo: impl AsRef<Path>,\n-    subcommand: &str,\n-    triple: Option<&str>,\n-    source_dir: &Path,\n-) -> Command {\n-    let mut cmd = Command::new(cargo.as_ref());\n-    cmd.arg(subcommand)\n-        .arg(\"--manifest-path\")\n-        .arg(source_dir.join(\"Cargo.toml\"))\n-        .arg(\"--target-dir\")\n-        .arg(source_dir.join(\"target\"));\n+use super::path::{Dirs, RelPath};\n+use super::rustc_info::{get_cargo_path, get_host_triple, get_rustc_path, get_rustdoc_path};\n+\n+pub(crate) struct Compiler {\n+    pub(crate) cargo: PathBuf,\n+    pub(crate) rustc: PathBuf,\n+    pub(crate) rustdoc: PathBuf,\n+    pub(crate) rustflags: String,\n+    pub(crate) rustdocflags: String,\n+    pub(crate) triple: String,\n+    pub(crate) runner: Vec<String>,\n+}\n+\n+impl Compiler {\n+    pub(crate) fn host() -> Compiler {\n+        Compiler {\n+            cargo: get_cargo_path(),\n+            rustc: get_rustc_path(),\n+            rustdoc: get_rustdoc_path(),\n+            rustflags: String::new(),\n+            rustdocflags: String::new(),\n+            triple: get_host_triple(),\n+            runner: vec![],\n+        }\n+    }\n+\n+    pub(crate) fn with_triple(triple: String) -> Compiler {\n+        Compiler {\n+            cargo: get_cargo_path(),\n+            rustc: get_rustc_path(),\n+            rustdoc: get_rustdoc_path(),\n+            rustflags: String::new(),\n+            rustdocflags: String::new(),\n+            triple,\n+            runner: vec![],\n+        }\n+    }\n+}\n+\n+pub(crate) struct CargoProject {\n+    source: &'static RelPath,\n+    target: &'static str,\n+}\n+\n+impl CargoProject {\n+    pub(crate) const fn new(path: &'static RelPath, target: &'static str) -> CargoProject {\n+        CargoProject { source: path, target }\n+    }\n+\n+    pub(crate) fn source_dir(&self, dirs: &Dirs) -> PathBuf {\n+        self.source.to_path(dirs)\n+    }\n+\n+    pub(crate) fn manifest_path(&self, dirs: &Dirs) -> PathBuf {\n+        self.source_dir(dirs).join(\"Cargo.toml\")\n+    }\n+\n+    pub(crate) fn target_dir(&self, dirs: &Dirs) -> PathBuf {\n+        RelPath::BUILD.join(self.target).to_path(dirs)\n+    }\n \n-    if let Some(triple) = triple {\n-        cmd.arg(\"--target\").arg(triple);\n+    fn base_cmd(&self, command: &str, cargo: &Path, dirs: &Dirs) -> Command {\n+        let mut cmd = Command::new(cargo);\n+\n+        cmd.arg(command)\n+            .arg(\"--manifest-path\")\n+            .arg(self.manifest_path(dirs))\n+            .arg(\"--target-dir\")\n+            .arg(self.target_dir(dirs));\n+\n+        cmd\n+    }\n+\n+    fn build_cmd(&self, command: &str, compiler: &Compiler, dirs: &Dirs) -> Command {\n+        let mut cmd = self.base_cmd(command, &compiler.cargo, dirs);\n+\n+        cmd.arg(\"--target\").arg(&compiler.triple);\n+\n+        cmd.env(\"RUSTC\", &compiler.rustc);\n+        cmd.env(\"RUSTDOC\", &compiler.rustdoc);\n+        cmd.env(\"RUSTFLAGS\", &compiler.rustflags);\n+        cmd.env(\"RUSTDOCFLAGS\", &compiler.rustdocflags);\n+        if !compiler.runner.is_empty() {\n+            cmd.env(\n+                format!(\"CARGO_TARGET_{}_RUNNER\", compiler.triple.to_uppercase().replace('-', \"_\")),\n+                compiler.runner.join(\" \"),\n+            );\n+        }\n+\n+        cmd\n     }\n \n-    cmd\n+    #[must_use]\n+    pub(crate) fn fetch(&self, cargo: impl AsRef<Path>, dirs: &Dirs) -> Command {\n+        let mut cmd = Command::new(cargo.as_ref());\n+\n+        cmd.arg(\"fetch\").arg(\"--manifest-path\").arg(self.manifest_path(dirs));\n+\n+        cmd\n+    }\n+\n+    #[must_use]\n+    pub(crate) fn clean(&self, cargo: &Path, dirs: &Dirs) -> Command {\n+        self.base_cmd(\"clean\", cargo, dirs)\n+    }\n+\n+    #[must_use]\n+    pub(crate) fn build(&self, compiler: &Compiler, dirs: &Dirs) -> Command {\n+        self.build_cmd(\"build\", compiler, dirs)\n+    }\n+\n+    #[must_use]\n+    pub(crate) fn test(&self, compiler: &Compiler, dirs: &Dirs) -> Command {\n+        self.build_cmd(\"test\", compiler, dirs)\n+    }\n+\n+    #[must_use]\n+    pub(crate) fn run(&self, compiler: &Compiler, dirs: &Dirs) -> Command {\n+        self.build_cmd(\"run\", compiler, dirs)\n+    }\n }\n \n+#[must_use]\n pub(crate) fn hyperfine_command(\n     warmup: u64,\n     runs: u64,\n-    prepare: Option<Command>,\n-    a: Command,\n-    b: Command,\n+    prepare: Option<&str>,\n+    a: &str,\n+    b: &str,\n ) -> Command {\n     let mut bench = Command::new(\"hyperfine\");\n \n@@ -42,10 +145,10 @@ pub(crate) fn hyperfine_command(\n     }\n \n     if let Some(prepare) = prepare {\n-        bench.arg(\"--prepare\").arg(format!(\"{:?}\", prepare));\n+        bench.arg(\"--prepare\").arg(prepare);\n     }\n \n-    bench.arg(format!(\"{:?}\", a)).arg(format!(\"{:?}\", b));\n+    bench.arg(a).arg(b);\n \n     bench\n }"}, {"sha": "1760e5836ecce00a48f7a0236748dfb94329fce0", "filename": "compiler/rustc_codegen_cranelift/clean_all.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -2,7 +2,7 @@\n set -e\n \n rm -rf build_sysroot/{sysroot_src/,target/,compiler-builtins/,rustc_version}\n-rm -rf target/ build/ perf.data{,.old} y.bin\n+rm -rf target/ build/ dist/ perf.data{,.old} y.bin\n rm -rf download/\n \n # Kept for now in case someone updates their checkout of cg_clif before running clean_all.sh"}, {"sha": "258b67e931476850a25cab17bbc2c3300a243821", "filename": "compiler/rustc_codegen_cranelift/config.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fconfig.txt", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fconfig.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fconfig.txt?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -40,6 +40,7 @@ aot.subslice-patterns-const-eval\n aot.track-caller-attribute\n aot.float-minmax-pass\n aot.mod_bench\n+aot.issue-72793\n \n testsuite.extended_sysroot\n test.rust-random/rand"}, {"sha": "4c2b0fa170498812b976b67041cc62ab73ff3f81", "filename": "compiler/rustc_codegen_cranelift/docs/usage.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fusage.md", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fusage.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fusage.md?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -9,7 +9,7 @@ Assuming `$cg_clif_dir` is the directory you cloned this repo into and you follo\n In the directory with your project (where you can do the usual `cargo build`), run:\n \n ```bash\n-$ $cg_clif_dir/build/cargo-clif build\n+$ $cg_clif_dir/dist/cargo-clif build\n ```\n \n This will build your project with rustc_codegen_cranelift instead of the usual LLVM backend.\n@@ -19,7 +19,7 @@ This will build your project with rustc_codegen_cranelift instead of the usual L\n > You should prefer using the Cargo method.\n \n ```bash\n-$ $cg_clif_dir/build/rustc-clif my_crate.rs\n+$ $cg_clif_dir/dist/rustc-clif my_crate.rs\n ```\n \n ## Jit mode\n@@ -32,20 +32,20 @@ In jit mode cg_clif will immediately execute your code without creating an execu\n > The jit mode will probably need cargo integration to make this possible.\n \n ```bash\n-$ $cg_clif_dir/build/cargo-clif jit\n+$ $cg_clif_dir/dist/cargo-clif jit\n ```\n \n or\n \n ```bash\n-$ $cg_clif_dir/build/rustc-clif -Zunstable-features -Cllvm-args=mode=jit -Cprefer-dynamic my_crate.rs\n+$ $cg_clif_dir/dist/rustc-clif -Zunstable-features -Cllvm-args=mode=jit -Cprefer-dynamic my_crate.rs\n ```\n \n There is also an experimental lazy jit mode. In this mode functions are only compiled once they are\n first called.\n \n ```bash\n-$ $cg_clif_dir/build/cargo-clif lazy-jit\n+$ $cg_clif_dir/dist/cargo-clif lazy-jit\n ```\n \n ## Shell\n@@ -54,7 +54,7 @@ These are a few functions that allow you to easily run rust code from the shell\n \n ```bash\n function jit_naked() {\n-    echo \"$@\" | $cg_clif_dir/build/rustc-clif - -Zunstable-features -Cllvm-args=mode=jit -Cprefer-dynamic\n+    echo \"$@\" | $cg_clif_dir/dist/rustc-clif - -Zunstable-features -Cllvm-args=mode=jit -Cprefer-dynamic\n }\n \n function jit() {"}, {"sha": "b1bb9b8e1e73034927ae8f094d1fd997baa80b3a", "filename": "compiler/rustc_codegen_cranelift/example/issue-72793.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fexample%2Fissue-72793.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fexample%2Fissue-72793.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fissue-72793.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -0,0 +1,24 @@\n+// Adapted from rustc ui test suite (ui/type-alias-impl-trait/issue-72793.rs)\n+\n+#![feature(type_alias_impl_trait)]\n+\n+trait T { type Item; }\n+\n+type Alias<'a> = impl T<Item = &'a ()>;\n+\n+struct S;\n+impl<'a> T for &'a S {\n+    type Item = &'a ();\n+}\n+\n+fn filter_positive<'a>() -> Alias<'a> {\n+    &S\n+}\n+\n+fn with_positive(fun: impl Fn(Alias<'_>)) {\n+    fun(filter_positive());\n+}\n+\n+fn main() {\n+    with_positive(|_| ());\n+}"}, {"sha": "1f9db1eb2a97affce42fe9395435a0b5cd0b8341", "filename": "compiler/rustc_codegen_cranelift/example/mini_core.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -19,6 +19,9 @@ pub trait Sized {}\n #[lang = \"destruct\"]\n pub trait Destruct {}\n \n+#[lang = \"tuple_trait\"]\n+pub trait Tuple {}\n+\n #[lang = \"unsize\"]\n pub trait Unsize<T: ?Sized> {}\n \n@@ -443,7 +446,7 @@ pub struct PhantomData<T: ?Sized>;\n \n #[lang = \"fn_once\"]\n #[rustc_paren_sugar]\n-pub trait FnOnce<Args> {\n+pub trait FnOnce<Args: Tuple> {\n     #[lang = \"fn_once_output\"]\n     type Output;\n \n@@ -452,7 +455,7 @@ pub trait FnOnce<Args> {\n \n #[lang = \"fn_mut\"]\n #[rustc_paren_sugar]\n-pub trait FnMut<Args>: FnOnce<Args> {\n+pub trait FnMut<Args: Tuple>: FnOnce<Args> {\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n }\n "}, {"sha": "c00f8a2e0cdad3229ad1362047bffeb8a4be2ad9", "filename": "compiler/rustc_codegen_cranelift/example/mini_core_hello_world.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -171,8 +171,6 @@ fn main() {\n \n     assert_eq!(slice_ptr as usize % 4, 0);\n \n-    //return;\n-\n     unsafe {\n         printf(\"Hello %s\\n\\0\" as *const str as *const i8, \"printf\\0\" as *const str as *const i8);\n "}, {"sha": "8481d9c39a3cf672e83f85b03220fabdacf61817", "filename": "compiler/rustc_codegen_cranelift/example/std_example.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -164,6 +164,8 @@ unsafe fn test_simd() {\n     let cmp_eq = _mm_cmpeq_epi8(y, y);\n     let cmp_lt = _mm_cmplt_epi8(y, y);\n \n+    let (zero0, zero1) = std::mem::transmute::<_, (u64, u64)>(x);\n+    assert_eq!((zero0, zero1), (0, 0));\n     assert_eq!(std::mem::transmute::<_, [u16; 8]>(or), [7, 7, 7, 7, 7, 7, 7, 7]);\n     assert_eq!(std::mem::transmute::<_, [u16; 8]>(cmp_eq), [0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff]);\n     assert_eq!(std::mem::transmute::<_, [u16; 8]>(cmp_lt), [0, 0, 0, 0, 0, 0, 0, 0]);"}, {"sha": "d8f28dbcc15c8c43d9631834b087f34ed547cebb", "filename": "compiler/rustc_codegen_cranelift/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Frust-toolchain?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-10-23\"\n+channel = \"nightly-2022-12-13\"\n components = [\"rust-src\", \"rustc-dev\", \"llvm-tools-preview\"]"}, {"sha": "ebeca8662a5195c6408e8707a06248c189ffab99", "filename": "compiler/rustc_codegen_cranelift/rustfmt.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Frustfmt.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Frustfmt.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Frustfmt.toml?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,3 +1,5 @@\n+ignore = [\"y.rs\"]\n+\n # Matches rustfmt.toml of rustc\n version = \"Two\"\n use_small_heuristics = \"Max\""}, {"sha": "f782671fe36f9b45fab05a5c6f335d9880211c23", "filename": "compiler/rustc_codegen_cranelift/scripts/filter_profile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ffilter_profile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ffilter_profile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ffilter_profile.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -2,7 +2,7 @@\n #![forbid(unsafe_code)]/* This line is ignored by bash\n # This block is ignored by rustc\n pushd $(dirname \"$0\")/../\n-RUSTC=\"$(pwd)/build/rustc-clif\"\n+RUSTC=\"$(pwd)/dist/rustc-clif\"\n popd\n PROFILE=$1 OUTPUT=$2 exec $RUSTC -Zunstable-options -Cllvm-args=mode=jit -Cprefer-dynamic $0\n #*/"}, {"sha": "a19d72acfa83e037ac857e1719c3ca1a988895f9", "filename": "compiler/rustc_codegen_cranelift/scripts/rustdoc-clif.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustdoc-clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustdoc-clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustdoc-clif.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -0,0 +1,36 @@\n+use std::env;\n+use std::ffi::OsString;\n+#[cfg(unix)]\n+use std::os::unix::process::CommandExt;\n+use std::path::PathBuf;\n+use std::process::Command;\n+\n+fn main() {\n+    let sysroot = PathBuf::from(env::current_exe().unwrap().parent().unwrap());\n+\n+    let cg_clif_dylib_path = sysroot.join(if cfg!(windows) { \"bin\" } else { \"lib\" }).join(\n+        env::consts::DLL_PREFIX.to_string() + \"rustc_codegen_cranelift\" + env::consts::DLL_SUFFIX,\n+    );\n+\n+    let mut args = std::env::args_os().skip(1).collect::<Vec<_>>();\n+    args.push(OsString::from(\"-Cpanic=abort\"));\n+    args.push(OsString::from(\"-Zpanic-abort-tests\"));\n+    let mut codegen_backend_arg = OsString::from(\"-Zcodegen-backend=\");\n+    codegen_backend_arg.push(cg_clif_dylib_path);\n+    args.push(codegen_backend_arg);\n+    if !args.contains(&OsString::from(\"--sysroot\")) {\n+        args.push(OsString::from(\"--sysroot\"));\n+        args.push(OsString::from(sysroot.to_str().unwrap()));\n+    }\n+\n+    // Ensure that the right toolchain is used\n+    env::set_var(\"RUSTUP_TOOLCHAIN\", env!(\"RUSTUP_TOOLCHAIN\"));\n+\n+    #[cfg(unix)]\n+    Command::new(\"rustdoc\").args(args).exec();\n+\n+    #[cfg(not(unix))]\n+    std::process::exit(\n+        Command::new(\"rustdoc\").args(args).spawn().unwrap().wait().unwrap().code().unwrap_or(1),\n+    );\n+}"}, {"sha": "6c64b7de7daa10d863a903a186e0ee9c4846aeed", "filename": "compiler/rustc_codegen_cranelift/scripts/setup_rust_fork.sh", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -27,24 +27,6 @@ index d95b5b7f17f..00b6f0e3635 100644\n  [dev-dependencies]\n  rand = \"0.7\"\n  rand_xorshift = \"0.2\"\n-diff --git a/src/tools/compiletest/src/runtest.rs b/src/tools/compiletest/src/runtest.rs\n-index 8431aa7b818..a3ff7e68ce5 100644\n---- a/src/tools/compiletest/src/runtest.rs\n-+++ b/src/tools/compiletest/src/runtest.rs\n-@@ -3489,12 +3489,7 @@ fn normalize_output(&self, output: &str, custom_rules: &[(String, String)]) -> S\n-         let compiler_src_dir = base_dir.join(\"compiler\");\n-         normalize_path(&compiler_src_dir, \"$(echo '$COMPILER_DIR')\");\n-\n--        if let Some(virtual_rust_source_base_dir) =\n--            option_env!(\"CFG_VIRTUAL_RUST_SOURCE_BASE_DIR\").map(PathBuf::from)\n--        {\n--            normalize_path(&virtual_rust_source_base_dir.join(\"library\"), \"$(echo '$SRC_DIR')\");\n--            normalize_path(&virtual_rust_source_base_dir.join(\"compiler\"), \"$(echo '$COMPILER_DIR')\");\n--        }\n-+        normalize_path(&Path::new(\"$(cd ../build_sysroot/sysroot_src/library; pwd)\"), \"$(echo '$SRC_DIR')\");\n-\n-         // Paths into the build directory\n-         let test_build_dir = &self.config.build_base;\n EOF\n \n cat > config.toml <<EOF\n@@ -54,7 +36,7 @@ changelog-seen = 2\n ninja = false\n \n [build]\n-rustc = \"$(pwd)/../build/rustc-clif\"\n+rustc = \"$(pwd)/../dist/rustc-clif\"\n cargo = \"$(rustup which cargo)\"\n full-bootstrap = true\n local-rebuild = true\n@@ -69,6 +51,8 @@ popd\n # FIXME remove once inline asm is fully supported\n export RUSTFLAGS=\"$RUSTFLAGS --cfg=rustix_use_libc\"\n \n+export CFG_VIRTUAL_RUST_SOURCE_BASE_DIR=\"$(cd build_sysroot/sysroot_src; pwd)\"\n+\n # Allow the testsuite to use llvm tools\n host_triple=$(rustc -vV | grep host | cut -d: -f2 | tr -d \" \")\n export LLVM_BIN_DIR=\"$(rustc --print sysroot)/lib/rustlib/$host_triple/bin\""}, {"sha": "04ad77ec97eac3a76d01166d875cf18bc073f76f", "filename": "compiler/rustc_codegen_cranelift/scripts/test_rustc_tests.sh", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -20,6 +20,7 @@ for test in $(rg -i --files-with-matches \"//(\\[\\w+\\])?~[^\\|]*\\s*ERR|// error-pat\n done\n \n git checkout -- src/test/ui/issues/auxiliary/issue-3136-a.rs # contains //~ERROR, but shouldn't be removed\n+git checkout -- src/test/ui/proc-macro/pretty-print-hack/\n \n # missing features\n # ================\n@@ -30,6 +31,7 @@ rm src/test/incremental/issue-80691-bad-eval-cache.rs # -Cpanic=abort causes abo\n \n # requires compiling with -Cpanic=unwind\n rm -r src/test/ui/macros/rfc-2011-nicer-assert-messages/\n+rm -r src/test/run-make/test-benches\n \n # vendor intrinsics\n rm src/test/ui/sse2.rs # cpuid not supported, so sse2 not detected\n@@ -64,6 +66,8 @@ rm src/test/ui/fn/dyn-fn-alignment.rs # wants a 256 byte alignment\n rm -r src/test/run-make/emit-named-files # requires full --emit support\n rm src/test/ui/abi/stack-probes.rs # stack probes not yet implemented\n rm src/test/ui/simd/intrinsic/ptr-cast.rs # simd_expose_addr intrinsic unimplemented\n+rm -r src/test/run-make/repr128-dwarf # debuginfo test\n+rm src/test/codegen-units/item-collection/asm-sym.rs # requires support for sym in asm!()\n \n # optimization tests\n # ==================\n@@ -82,20 +86,20 @@ rm src/test/ui/abi/stack-protector.rs # requires stack protector support\n rm src/test/ui/mir/mir_misc_casts.rs # depends on deduplication of constants\n rm src/test/ui/mir/mir_raw_fat_ptr.rs # same\n rm src/test/ui/consts/issue-33537.rs # same\n+rm src/test/ui/layout/valid_range_oob.rs # different ICE message\n \n # doesn't work due to the way the rustc test suite is invoked.\n # should work when using ./x.py test the way it is intended\n # ============================================================\n-rm -r src/test/run-make/emit-shared-files # requires the rustdoc executable in build/bin/\n+rm -r src/test/run-make/emit-shared-files # requires the rustdoc executable in dist/bin/\n rm -r src/test/run-make/unstable-flag-required # same\n rm -r src/test/run-make/rustdoc-* # same\n rm -r src/test/run-make/issue-88756-default-output # same\n rm -r src/test/run-make/remap-path-prefix-dwarf # requires llvm-dwarfdump\n+rm -r src/test/ui/consts/missing_span_in_backtrace.rs # expects sysroot source to be elsewhere\n \n # genuine bugs\n # ============\n-rm src/test/ui/allocator/no_std-alloc-error-handler-default.rs # missing rust_oom definition\n-\n rm src/test/incremental/spike-neg1.rs # errors out for some reason\n rm src/test/incremental/spike-neg2.rs # same\n rm src/test/ui/issues/issue-74564-if-expr-stack-overflow.rs # gives a stackoverflow before the backend runs\n@@ -104,13 +108,17 @@ rm src/test/ui/type-alias-impl-trait/assoc-projection-ice.rs # produces ICE\n \n rm src/test/ui/simd/intrinsic/generic-reduction-pass.rs # simd_reduce_add_unordered doesn't accept an accumulator for integer vectors\n \n+rm src/test/ui/runtime/out-of-stack.rs # SIGSEGV instead of SIGABRT for some reason (#1301)\n+\n # bugs in the test suite\n # ======================\n rm src/test/ui/backtrace.rs # TODO warning\n rm src/test/ui/simple_global_asm.rs # TODO add needs-asm-support\n rm src/test/ui/test-attrs/test-type.rs # TODO panic message on stderr. correct stdout\n # not sure if this is actually a bug in the test suite, but the symbol list shows the function without leading _ for some reason\n rm -r src/test/run-make/native-link-modifier-bundle\n+rm src/test/ui/process/nofile-limit.rs # TODO some AArch64 linking issue\n+rm src/test/ui/dyn-star/dispatch-on-pin-mut.rs # TODO failed assertion in vtable::get_ptr_and_method_ref\n \n rm src/test/ui/stdio-is-blocking.rs # really slow with unoptimized libstd\n "}, {"sha": "65cc6b4376713d8c7e855c2fca1f833894a3cd09", "filename": "compiler/rustc_codegen_cranelift/src/abi/mod.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -56,13 +56,13 @@ pub(crate) fn conv_to_call_conv(c: Conv, default_call_conv: CallConv) -> CallCon\n \n pub(crate) fn get_function_sig<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    triple: &target_lexicon::Triple,\n+    default_call_conv: CallConv,\n     inst: Instance<'tcx>,\n ) -> Signature {\n     assert!(!inst.substs.needs_infer());\n     clif_sig_from_fn_abi(\n         tcx,\n-        CallConv::triple_default(triple),\n+        default_call_conv,\n         &RevealAllLayoutCx(tcx).fn_abi_of_instance(inst, ty::List::empty()),\n     )\n }\n@@ -74,7 +74,7 @@ pub(crate) fn import_function<'tcx>(\n     inst: Instance<'tcx>,\n ) -> FuncId {\n     let name = tcx.symbol_name(inst).name;\n-    let sig = get_function_sig(tcx, module.isa().triple(), inst);\n+    let sig = get_function_sig(tcx, module.target_config().default_call_conv, inst);\n     match module.declare_function(name, Linkage::Import, &sig) {\n         Ok(func_id) => func_id,\n         Err(ModuleError::IncompatibleDeclaration(_)) => tcx.sess.fatal(&format!(\n@@ -341,18 +341,16 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n     destination: Place<'tcx>,\n     target: Option<BasicBlock>,\n ) {\n-    let fn_ty = fx.monomorphize(func.ty(fx.mir, fx.tcx));\n-    let fn_sig =\n-        fx.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), fn_ty.fn_sig(fx.tcx));\n+    let func = codegen_operand(fx, func);\n+    let fn_sig = func.layout().ty.fn_sig(fx.tcx);\n \n     let ret_place = codegen_place(fx, destination);\n \n     // Handle special calls like intrinsics and empty drop glue.\n-    let instance = if let ty::FnDef(def_id, substs) = *fn_ty.kind() {\n-        let instance = ty::Instance::resolve(fx.tcx, ty::ParamEnv::reveal_all(), def_id, substs)\n-            .unwrap()\n-            .unwrap()\n-            .polymorphize(fx.tcx);\n+    let instance = if let ty::FnDef(def_id, substs) = *func.layout().ty.kind() {\n+        let instance =\n+            ty::Instance::expect_resolve(fx.tcx, ty::ParamEnv::reveal_all(), def_id, substs)\n+                .polymorphize(fx.tcx);\n \n         if fx.tcx.symbol_name(instance).name.starts_with(\"llvm.\") {\n             crate::intrinsics::codegen_llvm_intrinsic_call(\n@@ -391,17 +389,17 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n         None\n     };\n \n-    let extra_args = &args[fn_sig.inputs().len()..];\n+    let extra_args = &args[fn_sig.inputs().skip_binder().len()..];\n     let extra_args = fx\n         .tcx\n         .mk_type_list(extra_args.iter().map(|op_arg| fx.monomorphize(op_arg.ty(fx.mir, fx.tcx))));\n     let fn_abi = if let Some(instance) = instance {\n         RevealAllLayoutCx(fx.tcx).fn_abi_of_instance(instance, extra_args)\n     } else {\n-        RevealAllLayoutCx(fx.tcx).fn_abi_of_fn_ptr(fn_ty.fn_sig(fx.tcx), extra_args)\n+        RevealAllLayoutCx(fx.tcx).fn_abi_of_fn_ptr(fn_sig, extra_args)\n     };\n \n-    let is_cold = if fn_sig.abi == Abi::RustCold {\n+    let is_cold = if fn_sig.abi() == Abi::RustCold {\n         true\n     } else {\n         instance\n@@ -418,7 +416,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n     }\n \n     // Unpack arguments tuple for closures\n-    let mut args = if fn_sig.abi == Abi::RustCall {\n+    let mut args = if fn_sig.abi() == Abi::RustCall {\n         assert_eq!(args.len(), 2, \"rust-call abi requires two arguments\");\n         let self_arg = codegen_call_argument_operand(fx, &args[0]);\n         let pack_arg = codegen_call_argument_operand(fx, &args[1]);\n@@ -486,7 +484,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                 fx.add_comment(nop_inst, \"indirect call\");\n             }\n \n-            let func = codegen_operand(fx, func).load_scalar(fx);\n+            let func = func.load_scalar(fx);\n             let sig = clif_sig_from_fn_abi(fx.tcx, fx.target_config.default_call_conv, &fn_abi);\n             let sig = fx.bcx.import_signature(sig);\n \n@@ -517,11 +515,11 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n         };\n \n         // FIXME find a cleaner way to support varargs\n-        if fn_sig.c_variadic {\n-            if !matches!(fn_sig.abi, Abi::C { .. }) {\n+        if fn_sig.c_variadic() {\n+            if !matches!(fn_sig.abi(), Abi::C { .. }) {\n                 fx.tcx.sess.span_fatal(\n                     source_info.span,\n-                    &format!(\"Variadic call for non-C abi {:?}\", fn_sig.abi),\n+                    &format!(\"Variadic call for non-C abi {:?}\", fn_sig.abi()),\n                 );\n             }\n             let sig_ref = fx.bcx.func.dfg.call_signature(call_inst).unwrap();"}, {"sha": "8508227179ac611fb77c350c541e5835e0313936", "filename": "compiler/rustc_codegen_cranelift/src/allocator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -66,7 +66,7 @@ fn codegen_inner(\n         };\n \n         let sig = Signature {\n-            call_conv: CallConv::triple_default(module.isa().triple()),\n+            call_conv: module.target_config().default_call_conv,\n             params: arg_tys.iter().cloned().map(AbiParam::new).collect(),\n             returns: output.into_iter().map(AbiParam::new).collect(),\n         };\n@@ -104,7 +104,7 @@ fn codegen_inner(\n     }\n \n     let sig = Signature {\n-        call_conv: CallConv::triple_default(module.isa().triple()),\n+        call_conv: module.target_config().default_call_conv,\n         params: vec![AbiParam::new(usize_ty), AbiParam::new(usize_ty)],\n         returns: vec![],\n     };"}, {"sha": "89d955e8bf2e1d84c1a40045d0b063140d325525", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -59,7 +59,7 @@ pub(crate) fn codegen_fn<'tcx>(\n \n     // Declare function\n     let symbol_name = tcx.symbol_name(instance).name.to_string();\n-    let sig = get_function_sig(tcx, module.isa().triple(), instance);\n+    let sig = get_function_sig(tcx, module.target_config().default_call_conv, instance);\n     let func_id = module.declare_function(&symbol_name, Linkage::Local, &sig).unwrap();\n \n     // Make the FunctionBuilder\n@@ -390,11 +390,9 @@ fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n                         _ => unreachable!(\"{:?}\", targets),\n                     };\n \n-                    let discr = crate::optimize::peephole::maybe_unwrap_bint(&mut fx.bcx, discr);\n                     let (discr, is_inverted) =\n                         crate::optimize::peephole::maybe_unwrap_bool_not(&mut fx.bcx, discr);\n                     let test_zero = if is_inverted { !test_zero } else { test_zero };\n-                    let discr = crate::optimize::peephole::maybe_unwrap_bint(&mut fx.bcx, discr);\n                     if let Some(taken) = crate::optimize::peephole::maybe_known_branch_taken(\n                         &fx.bcx, discr, test_zero,\n                     ) {\n@@ -571,20 +569,14 @@ fn codegen_stmt<'tcx>(\n                         UnOp::Not => match layout.ty.kind() {\n                             ty::Bool => {\n                                 let res = fx.bcx.ins().icmp_imm(IntCC::Equal, val, 0);\n-                                CValue::by_val(fx.bcx.ins().bint(types::I8, res), layout)\n+                                CValue::by_val(res, layout)\n                             }\n                             ty::Uint(_) | ty::Int(_) => {\n                                 CValue::by_val(fx.bcx.ins().bnot(val), layout)\n                             }\n                             _ => unreachable!(\"un op Not for {:?}\", layout.ty),\n                         },\n                         UnOp::Neg => match layout.ty.kind() {\n-                            ty::Int(IntTy::I128) => {\n-                                // FIXME remove this case once ineg.i128 works\n-                                let zero =\n-                                    CValue::const_val(fx, layout, ty::ScalarInt::null(layout.size));\n-                                crate::num::codegen_int_binop(fx, BinOp::Sub, zero, operand)\n-                            }\n                             ty::Int(_) => CValue::by_val(fx.bcx.ins().ineg(val), layout),\n                             ty::Float(_) => CValue::by_val(fx.bcx.ins().fneg(val), layout),\n                             _ => unreachable!(\"un op Neg for {:?}\", layout.ty),"}, {"sha": "5091c5a9fedacbb7f4dda7b4d5ab7f086f17d1d7", "filename": "compiler/rustc_codegen_cranelift/src/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcast.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -149,7 +149,7 @@ pub(crate) fn clif_int_or_float_cast(\n         }\n \n         let is_not_nan = fx.bcx.ins().fcmp(FloatCC::Equal, from, from);\n-        let zero = fx.bcx.ins().iconst(to_ty, 0);\n+        let zero = type_zero_value(&mut fx.bcx, to_ty);\n         fx.bcx.ins().select(is_not_nan, val, zero)\n     } else if from_ty.is_float() && to_ty.is_float() {\n         // float -> float"}, {"sha": "2dcd42fbd8f431833ac46b414c539e40c828f0e8", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -162,11 +162,20 @@ pub(crate) fn codegen_icmp_imm(\n             }\n         }\n     } else {\n-        let rhs = i64::try_from(rhs).expect(\"codegen_icmp_imm rhs out of range for <128bit int\");\n+        let rhs = rhs as i64; // Truncates on purpose in case rhs is actually an unsigned value\n         fx.bcx.ins().icmp_imm(intcc, lhs, rhs)\n     }\n }\n \n+pub(crate) fn type_zero_value(bcx: &mut FunctionBuilder<'_>, ty: Type) -> Value {\n+    if ty == types::I128 {\n+        let zero = bcx.ins().iconst(types::I64, 0);\n+        bcx.ins().iconcat(zero, zero)\n+    } else {\n+        bcx.ins().iconst(ty, 0)\n+    }\n+}\n+\n pub(crate) fn type_min_max_value(\n     bcx: &mut FunctionBuilder<'_>,\n     ty: Type,"}, {"sha": "dee6fb5b5130d1f27abaf1fda1581605a82973b5", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 50, "deletions": 32, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -28,9 +28,7 @@ impl ConstantCx {\n     }\n \n     pub(crate) fn finalize(mut self, tcx: TyCtxt<'_>, module: &mut dyn Module) {\n-        //println!(\"todo {:?}\", self.todo);\n         define_all_allocs(tcx, module, &mut self);\n-        //println!(\"done {:?}\", self.done);\n         self.done.clear();\n     }\n }\n@@ -268,16 +266,7 @@ fn data_id_for_static(\n     def_id: DefId,\n     definition: bool,\n ) -> DataId {\n-    let rlinkage = tcx.codegen_fn_attrs(def_id).linkage;\n-    let linkage = if definition {\n-        crate::linkage::get_static_linkage(tcx, def_id)\n-    } else if rlinkage == Some(rustc_middle::mir::mono::Linkage::ExternalWeak)\n-        || rlinkage == Some(rustc_middle::mir::mono::Linkage::WeakAny)\n-    {\n-        Linkage::Preemptible\n-    } else {\n-        Linkage::Import\n-    };\n+    let attrs = tcx.codegen_fn_attrs(def_id);\n \n     let instance = Instance::mono(tcx, def_id).polymorphize(tcx);\n     let symbol_name = tcx.symbol_name(instance).name;\n@@ -289,22 +278,30 @@ fn data_id_for_static(\n     };\n     let align = tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap().align.pref.bytes();\n \n-    let attrs = tcx.codegen_fn_attrs(def_id);\n+    if let Some(import_linkage) = attrs.import_linkage {\n+        assert!(!definition);\n \n-    let data_id = match module.declare_data(\n-        &*symbol_name,\n-        linkage,\n-        is_mutable,\n-        attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL),\n-    ) {\n-        Ok(data_id) => data_id,\n-        Err(ModuleError::IncompatibleDeclaration(_)) => tcx.sess.fatal(&format!(\n-            \"attempt to declare `{symbol_name}` as static, but it was already declared as function\"\n-        )),\n-        Err(err) => Err::<_, _>(err).unwrap(),\n-    };\n+        let linkage = if import_linkage == rustc_middle::mir::mono::Linkage::ExternalWeak\n+            || import_linkage == rustc_middle::mir::mono::Linkage::WeakAny\n+        {\n+            Linkage::Preemptible\n+        } else {\n+            Linkage::Import\n+        };\n+\n+        let data_id = match module.declare_data(\n+            &*symbol_name,\n+            linkage,\n+            is_mutable,\n+            attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL),\n+        ) {\n+            Ok(data_id) => data_id,\n+            Err(ModuleError::IncompatibleDeclaration(_)) => tcx.sess.fatal(&format!(\n+                \"attempt to declare `{symbol_name}` as static, but it was already declared as function\"\n+            )),\n+            Err(err) => Err::<_, _>(err).unwrap(),\n+        };\n \n-    if rlinkage.is_some() {\n         // Comment copied from https://github.com/rust-lang/rust/blob/45060c2a66dfd667f88bd8b94261b28a58d85bd5/src/librustc_codegen_llvm/consts.rs#L141\n         // Declare an internal global `extern_with_linkage_foo` which\n         // is initialized with the address of `foo`.  If `foo` is\n@@ -326,10 +323,34 @@ fn data_id_for_static(\n             Err(ModuleError::DuplicateDefinition(_)) => {}\n             res => res.unwrap(),\n         }\n-        ref_data_id\n-    } else {\n-        data_id\n+\n+        return ref_data_id;\n     }\n+\n+    let linkage = if definition {\n+        crate::linkage::get_static_linkage(tcx, def_id)\n+    } else if attrs.linkage == Some(rustc_middle::mir::mono::Linkage::ExternalWeak)\n+        || attrs.linkage == Some(rustc_middle::mir::mono::Linkage::WeakAny)\n+    {\n+        Linkage::Preemptible\n+    } else {\n+        Linkage::Import\n+    };\n+\n+    let data_id = match module.declare_data(\n+        &*symbol_name,\n+        linkage,\n+        is_mutable,\n+        attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL),\n+    ) {\n+        Ok(data_id) => data_id,\n+        Err(ModuleError::IncompatibleDeclaration(_)) => tcx.sess.fatal(&format!(\n+            \"attempt to declare `{symbol_name}` as static, but it was already declared as function\"\n+        )),\n+        Err(err) => Err::<_, _>(err).unwrap(),\n+    };\n+\n+    data_id\n }\n \n fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut ConstantCx) {\n@@ -348,8 +369,6 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n                 (data_id, alloc, None)\n             }\n             TodoItem::Static(def_id) => {\n-                //println!(\"static {:?}\", def_id);\n-\n                 let section_name = tcx.codegen_fn_attrs(def_id).link_section;\n \n                 let alloc = tcx.eval_static_initializer(def_id).unwrap();\n@@ -359,7 +378,6 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n             }\n         };\n \n-        //(\"data_id {}\", data_id);\n         if cx.done.contains(&data_id) {\n             continue;\n         }"}, {"sha": "493359c743f119d6bcee87920e595c943a009642", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/unwind.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Funwind.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -39,7 +39,9 @@ impl UnwindContext {\n     }\n \n     pub(crate) fn add_function(&mut self, func_id: FuncId, context: &Context, isa: &dyn TargetIsa) {\n-        let unwind_info = if let Some(unwind_info) = context.create_unwind_info(isa).unwrap() {\n+        let unwind_info = if let Some(unwind_info) =\n+            context.compiled_code().unwrap().create_unwind_info(isa).unwrap()\n+        {\n             unwind_info\n         } else {\n             return;"}, {"sha": "3cbf313adf0df5a69887cdb1f0516245f2b23232", "filename": "compiler/rustc_codegen_cranelift/src/discriminant.rs", "status": "modified", "additions": 161, "deletions": 46, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,6 +1,7 @@\n //! Handling of enum discriminants\n //!\n-//! Adapted from <https://github.com/rust-lang/rust/blob/d760df5aea483aae041c9a241e7acacf48f75035/src/librustc_codegen_ssa/mir/place.rs>\n+//! Adapted from <https://github.com/rust-lang/rust/blob/31c0645b9d2539f47eecb096142474b29dc542f7/compiler/rustc_codegen_ssa/src/mir/place.rs>\n+//! (<https://github.com/rust-lang/rust/pull/104535>)\n \n use rustc_target::abi::{Int, TagEncoding, Variants};\n \n@@ -47,13 +48,19 @@ pub(crate) fn codegen_set_discriminant<'tcx>(\n         } => {\n             if variant_index != untagged_variant {\n                 let niche = place.place_field(fx, mir::Field::new(tag_field));\n+                let niche_type = fx.clif_type(niche.layout().ty).unwrap();\n                 let niche_value = variant_index.as_u32() - niche_variants.start().as_u32();\n-                let niche_value = ty::ScalarInt::try_from_uint(\n-                    u128::from(niche_value).wrapping_add(niche_start),\n-                    niche.layout().size,\n-                )\n-                .unwrap();\n-                let niche_llval = CValue::const_val(fx, niche.layout(), niche_value);\n+                let niche_value = (niche_value as u128).wrapping_add(niche_start);\n+                let niche_value = match niche_type {\n+                    types::I128 => {\n+                        let lsb = fx.bcx.ins().iconst(types::I64, niche_value as u64 as i64);\n+                        let msb =\n+                            fx.bcx.ins().iconst(types::I64, (niche_value >> 64) as u64 as i64);\n+                        fx.bcx.ins().iconcat(lsb, msb)\n+                    }\n+                    ty => fx.bcx.ins().iconst(ty, niche_value as i64),\n+                };\n+                let niche_llval = CValue::by_val(niche_value, niche.layout());\n                 niche.write_cvalue(fx, niche_llval);\n             }\n         }\n@@ -96,6 +103,7 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n         }\n     };\n \n+    let cast_to_size = dest_layout.layout.size();\n     let cast_to = fx.clif_type(dest_layout.ty).unwrap();\n \n     // Read the tag/niche-encoded discriminant from memory.\n@@ -114,21 +122,128 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n             dest.write_cvalue(fx, res);\n         }\n         TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start } => {\n-            // Rebase from niche values to discriminants, and check\n-            // whether the result is in range for the niche variants.\n-\n-            // We first compute the \"relative discriminant\" (wrt `niche_variants`),\n-            // that is, if `n = niche_variants.end() - niche_variants.start()`,\n-            // we remap `niche_start..=niche_start + n` (which may wrap around)\n-            // to (non-wrap-around) `0..=n`, to be able to check whether the\n-            // discriminant corresponds to a niche variant with one comparison.\n-            // We also can't go directly to the (variant index) discriminant\n-            // and check that it is in the range `niche_variants`, because\n-            // that might not fit in the same type, on top of needing an extra\n-            // comparison (see also the comment on `let niche_discr`).\n-            let relative_discr = if niche_start == 0 {\n-                tag\n+            let tag_size = tag_scalar.size(fx);\n+            let max_unsigned = tag_size.unsigned_int_max();\n+            let max_signed = tag_size.signed_int_max() as u128;\n+            let min_signed = max_signed + 1;\n+            let relative_max = niche_variants.end().as_u32() - niche_variants.start().as_u32();\n+            let niche_end = niche_start.wrapping_add(relative_max as u128) & max_unsigned;\n+            let range = tag_scalar.valid_range(fx);\n+\n+            let sle = |lhs: u128, rhs: u128| -> bool {\n+                // Signed and unsigned comparisons give the same results,\n+                // except that in signed comparisons an integer with the\n+                // sign bit set is less than one with the sign bit clear.\n+                // Toggle the sign bit to do a signed comparison.\n+                (lhs ^ min_signed) <= (rhs ^ min_signed)\n+            };\n+\n+            // We have a subrange `niche_start..=niche_end` inside `range`.\n+            // If the value of the tag is inside this subrange, it's a\n+            // \"niche value\", an increment of the discriminant. Otherwise it\n+            // indicates the untagged variant.\n+            // A general algorithm to extract the discriminant from the tag\n+            // is:\n+            // relative_tag = tag - niche_start\n+            // is_niche = relative_tag <= (ule) relative_max\n+            // discr = if is_niche {\n+            //     cast(relative_tag) + niche_variants.start()\n+            // } else {\n+            //     untagged_variant\n+            // }\n+            // However, we will likely be able to emit simpler code.\n+\n+            // Find the least and greatest values in `range`, considered\n+            // both as signed and unsigned.\n+            let (low_unsigned, high_unsigned) =\n+                if range.start <= range.end { (range.start, range.end) } else { (0, max_unsigned) };\n+            let (low_signed, high_signed) = if sle(range.start, range.end) {\n+                (range.start, range.end)\n             } else {\n+                (min_signed, max_signed)\n+            };\n+\n+            let niches_ule = niche_start <= niche_end;\n+            let niches_sle = sle(niche_start, niche_end);\n+            let cast_smaller = cast_to_size <= tag_size;\n+\n+            // In the algorithm above, we can change\n+            // cast(relative_tag) + niche_variants.start()\n+            // into\n+            // cast(tag + (niche_variants.start() - niche_start))\n+            // if either the casted type is no larger than the original\n+            // type, or if the niche values are contiguous (in either the\n+            // signed or unsigned sense).\n+            let can_incr = cast_smaller || niches_ule || niches_sle;\n+\n+            let data_for_boundary_niche = || -> Option<(IntCC, u128)> {\n+                if !can_incr {\n+                    None\n+                } else if niche_start == low_unsigned {\n+                    Some((IntCC::UnsignedLessThanOrEqual, niche_end))\n+                } else if niche_end == high_unsigned {\n+                    Some((IntCC::UnsignedGreaterThanOrEqual, niche_start))\n+                } else if niche_start == low_signed {\n+                    Some((IntCC::SignedLessThanOrEqual, niche_end))\n+                } else if niche_end == high_signed {\n+                    Some((IntCC::SignedGreaterThanOrEqual, niche_start))\n+                } else {\n+                    None\n+                }\n+            };\n+\n+            let (is_niche, tagged_discr, delta) = if relative_max == 0 {\n+                // Best case scenario: only one tagged variant. This will\n+                // likely become just a comparison and a jump.\n+                // The algorithm is:\n+                // is_niche = tag == niche_start\n+                // discr = if is_niche {\n+                //     niche_start\n+                // } else {\n+                //     untagged_variant\n+                // }\n+                let is_niche = codegen_icmp_imm(fx, IntCC::Equal, tag, niche_start as i128);\n+                let tagged_discr =\n+                    fx.bcx.ins().iconst(cast_to, niche_variants.start().as_u32() as i64);\n+                (is_niche, tagged_discr, 0)\n+            } else if let Some((predicate, constant)) = data_for_boundary_niche() {\n+                // The niche values are either the lowest or the highest in\n+                // `range`. We can avoid the first subtraction in the\n+                // algorithm.\n+                // The algorithm is now this:\n+                // is_niche = tag <= niche_end\n+                // discr = if is_niche {\n+                //     cast(tag + (niche_variants.start() - niche_start))\n+                // } else {\n+                //     untagged_variant\n+                // }\n+                // (the first line may instead be tag >= niche_start,\n+                // and may be a signed or unsigned comparison)\n+                // The arithmetic must be done before the cast, so we can\n+                // have the correct wrapping behavior. See issue #104519 for\n+                // the consequences of getting this wrong.\n+                let is_niche = codegen_icmp_imm(fx, predicate, tag, constant as i128);\n+                let delta = (niche_variants.start().as_u32() as u128).wrapping_sub(niche_start);\n+                let incr_tag = if delta == 0 {\n+                    tag\n+                } else {\n+                    let delta = match fx.bcx.func.dfg.value_type(tag) {\n+                        types::I128 => {\n+                            let lsb = fx.bcx.ins().iconst(types::I64, delta as u64 as i64);\n+                            let msb = fx.bcx.ins().iconst(types::I64, (delta >> 64) as u64 as i64);\n+                            fx.bcx.ins().iconcat(lsb, msb)\n+                        }\n+                        ty => fx.bcx.ins().iconst(ty, delta as i64),\n+                    };\n+                    fx.bcx.ins().iadd(tag, delta)\n+                };\n+\n+                let cast_tag = clif_intcast(fx, incr_tag, cast_to, !niches_ule);\n+\n+                (is_niche, cast_tag, 0)\n+            } else {\n+                // The special cases don't apply, so we'll have to go with\n+                // the general algorithm.\n                 let niche_start = match fx.bcx.func.dfg.value_type(tag) {\n                     types::I128 => {\n                         let lsb = fx.bcx.ins().iconst(types::I64, niche_start as u64 as i64);\n@@ -138,40 +253,40 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n                     }\n                     ty => fx.bcx.ins().iconst(ty, niche_start as i64),\n                 };\n-                fx.bcx.ins().isub(tag, niche_start)\n-            };\n-            let relative_max = niche_variants.end().as_u32() - niche_variants.start().as_u32();\n-            let is_niche = {\n-                codegen_icmp_imm(\n+                let relative_discr = fx.bcx.ins().isub(tag, niche_start);\n+                let cast_tag = clif_intcast(fx, relative_discr, cast_to, false);\n+                let is_niche = crate::common::codegen_icmp_imm(\n                     fx,\n                     IntCC::UnsignedLessThanOrEqual,\n                     relative_discr,\n                     i128::from(relative_max),\n-                )\n+                );\n+                (is_niche, cast_tag, niche_variants.start().as_u32() as u128)\n             };\n \n-            // NOTE(eddyb) this addition needs to be performed on the final\n-            // type, in case the niche itself can't represent all variant\n-            // indices (e.g. `u8` niche with more than `256` variants,\n-            // but enough uninhabited variants so that the remaining variants\n-            // fit in the niche).\n-            // In other words, `niche_variants.end - niche_variants.start`\n-            // is representable in the niche, but `niche_variants.end`\n-            // might not be, in extreme cases.\n-            let niche_discr = {\n-                let relative_discr = if relative_max == 0 {\n-                    // HACK(eddyb) since we have only one niche, we know which\n-                    // one it is, and we can avoid having a dynamic value here.\n-                    fx.bcx.ins().iconst(cast_to, 0)\n-                } else {\n-                    clif_intcast(fx, relative_discr, cast_to, false)\n+            let tagged_discr = if delta == 0 {\n+                tagged_discr\n+            } else {\n+                let delta = match cast_to {\n+                    types::I128 => {\n+                        let lsb = fx.bcx.ins().iconst(types::I64, delta as u64 as i64);\n+                        let msb = fx.bcx.ins().iconst(types::I64, (delta >> 64) as u64 as i64);\n+                        fx.bcx.ins().iconcat(lsb, msb)\n+                    }\n+                    ty => fx.bcx.ins().iconst(ty, delta as i64),\n                 };\n-                fx.bcx.ins().iadd_imm(relative_discr, i64::from(niche_variants.start().as_u32()))\n+                fx.bcx.ins().iadd(tagged_discr, delta)\n             };\n \n-            let untagged_variant =\n-                fx.bcx.ins().iconst(cast_to, i64::from(untagged_variant.as_u32()));\n-            let discr = fx.bcx.ins().select(is_niche, niche_discr, untagged_variant);\n+            let untagged_variant = if cast_to == types::I128 {\n+                let zero = fx.bcx.ins().iconst(types::I64, 0);\n+                let untagged_variant =\n+                    fx.bcx.ins().iconst(types::I64, i64::from(untagged_variant.as_u32()));\n+                fx.bcx.ins().iconcat(untagged_variant, zero)\n+            } else {\n+                fx.bcx.ins().iconst(cast_to, i64::from(untagged_variant.as_u32()))\n+            };\n+            let discr = fx.bcx.ins().select(is_niche, tagged_discr, untagged_variant);\n             let res = CValue::by_val(discr, dest_layout);\n             dest.write_cvalue(fx, res);\n         }"}, {"sha": "be1b8c9ead3bf2e133d326818df523e19f201fda", "filename": "compiler/rustc_codegen_cranelift/src/driver/jit.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -159,7 +159,7 @@ pub(crate) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n \n     tcx.sess.abort_if_errors();\n \n-    jit_module.finalize_definitions();\n+    jit_module.finalize_definitions().unwrap();\n     unsafe { cx.unwind_context.register_jit(&jit_module) };\n \n     println!(\n@@ -245,7 +245,11 @@ fn jit_fn(instance_ptr: *const Instance<'static>, trampoline_ptr: *const u8) ->\n             let backend_config = lazy_jit_state.backend_config.clone();\n \n             let name = tcx.symbol_name(instance).name;\n-            let sig = crate::abi::get_function_sig(tcx, jit_module.isa().triple(), instance);\n+            let sig = crate::abi::get_function_sig(\n+                tcx,\n+                jit_module.target_config().default_call_conv,\n+                instance,\n+            );\n             let func_id = jit_module.declare_function(name, Linkage::Export, &sig).unwrap();\n \n             let current_ptr = jit_module.read_got_entry(func_id);\n@@ -278,7 +282,7 @@ fn jit_fn(instance_ptr: *const Instance<'static>, trampoline_ptr: *const u8) ->\n             });\n \n             assert!(cx.global_asm.is_empty());\n-            jit_module.finalize_definitions();\n+            jit_module.finalize_definitions().unwrap();\n             unsafe { cx.unwind_context.register_jit(&jit_module) };\n             jit_module.get_finalized_function(func_id)\n         })\n@@ -344,7 +348,7 @@ fn codegen_shim<'tcx>(\n     let pointer_type = module.target_config().pointer_type();\n \n     let name = tcx.symbol_name(inst).name;\n-    let sig = crate::abi::get_function_sig(tcx, module.isa().triple(), inst);\n+    let sig = crate::abi::get_function_sig(tcx, module.target_config().default_call_conv, inst);\n     let func_id = module.declare_function(name, Linkage::Export, &sig).unwrap();\n \n     let instance_ptr = Box::into_raw(Box::new(inst));"}, {"sha": "6e925cea277078b68ac5d03de3cc18fae0e91e71", "filename": "compiler/rustc_codegen_cranelift/src/driver/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -24,7 +24,8 @@ fn predefine_mono_items<'tcx>(\n                 MonoItem::Fn(instance) => {\n                     let name = tcx.symbol_name(instance).name;\n                     let _inst_guard = crate::PrintOnPanic(|| format!(\"{:?} {}\", instance, name));\n-                    let sig = get_function_sig(tcx, module.isa().triple(), instance);\n+                    let sig =\n+                        get_function_sig(tcx, module.target_config().default_call_conv, instance);\n                     let linkage = crate::linkage::get_clif_linkage(\n                         mono_item,\n                         linkage,"}, {"sha": "f722e52284fe8205f269103a620fec33015ef9a4", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/llvm.rs", "status": "modified", "additions": 17, "deletions": 159, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -8,135 +8,37 @@ use rustc_middle::ty::subst::SubstsRef;\n pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     intrinsic: &str,\n-    _substs: SubstsRef<'tcx>,\n+    substs: SubstsRef<'tcx>,\n     args: &[mir::Operand<'tcx>],\n     ret: CPlace<'tcx>,\n     target: Option<BasicBlock>,\n ) {\n-    match intrinsic {\n-        \"llvm.x86.sse2.pause\" | \"llvm.aarch64.isb\" => {\n-            // Spin loop hint\n-        }\n+    if intrinsic.starts_with(\"llvm.aarch64\") {\n+        return llvm_aarch64::codegen_aarch64_llvm_intrinsic_call(\n+            fx, intrinsic, substs, args, ret, target,\n+        );\n+    }\n+    if intrinsic.starts_with(\"llvm.x86\") {\n+        return llvm_x86::codegen_x86_llvm_intrinsic_call(fx, intrinsic, substs, args, ret, target);\n+    }\n \n-        // Used by `_mm_movemask_epi8` and `_mm256_movemask_epi8`\n-        \"llvm.x86.sse2.pmovmskb.128\" | \"llvm.x86.avx2.pmovmskb\" | \"llvm.x86.sse2.movmsk.pd\" => {\n+    match intrinsic {\n+        _ if intrinsic.starts_with(\"llvm.ctlz.v\") => {\n             intrinsic_args!(fx, args => (a); intrinsic);\n \n-            let (lane_count, lane_ty) = a.layout().ty.simd_size_and_type(fx.tcx);\n-            let lane_ty = fx.clif_type(lane_ty).unwrap();\n-            assert!(lane_count <= 32);\n-\n-            let mut res = fx.bcx.ins().iconst(types::I32, 0);\n-\n-            for lane in (0..lane_count).rev() {\n-                let a_lane = a.value_lane(fx, lane).load_scalar(fx);\n-\n-                // cast float to int\n-                let a_lane = match lane_ty {\n-                    types::F32 => fx.bcx.ins().bitcast(types::I32, a_lane),\n-                    types::F64 => fx.bcx.ins().bitcast(types::I64, a_lane),\n-                    _ => a_lane,\n-                };\n-\n-                // extract sign bit of an int\n-                let a_lane_sign = fx.bcx.ins().ushr_imm(a_lane, i64::from(lane_ty.bits() - 1));\n-\n-                // shift sign bit into result\n-                let a_lane_sign = clif_intcast(fx, a_lane_sign, types::I32, false);\n-                res = fx.bcx.ins().ishl_imm(res, 1);\n-                res = fx.bcx.ins().bor(res, a_lane_sign);\n-            }\n-\n-            let res = CValue::by_val(res, fx.layout_of(fx.tcx.types.i32));\n-            ret.write_cvalue(fx, res);\n-        }\n-        \"llvm.x86.sse2.cmp.ps\" | \"llvm.x86.sse2.cmp.pd\" => {\n-            let (x, y, kind) = match args {\n-                [x, y, kind] => (x, y, kind),\n-                _ => bug!(\"wrong number of args for intrinsic {intrinsic}\"),\n-            };\n-            let x = codegen_operand(fx, x);\n-            let y = codegen_operand(fx, y);\n-            let kind = crate::constant::mir_operand_get_const_val(fx, kind)\n-                .expect(\"llvm.x86.sse2.cmp.* kind not const\");\n-\n-            let flt_cc = match kind\n-                .try_to_bits(Size::from_bytes(1))\n-                .unwrap_or_else(|| panic!(\"kind not scalar: {:?}\", kind))\n-            {\n-                0 => FloatCC::Equal,\n-                1 => FloatCC::LessThan,\n-                2 => FloatCC::LessThanOrEqual,\n-                7 => FloatCC::Ordered,\n-                3 => FloatCC::Unordered,\n-                4 => FloatCC::NotEqual,\n-                5 => FloatCC::UnorderedOrGreaterThanOrEqual,\n-                6 => FloatCC::UnorderedOrGreaterThan,\n-                kind => unreachable!(\"kind {:?}\", kind),\n-            };\n-\n-            simd_pair_for_each_lane(fx, x, y, ret, &|fx, lane_ty, res_lane_ty, x_lane, y_lane| {\n-                let res_lane = match lane_ty.kind() {\n-                    ty::Float(_) => fx.bcx.ins().fcmp(flt_cc, x_lane, y_lane),\n-                    _ => unreachable!(\"{:?}\", lane_ty),\n-                };\n-                bool_to_zero_or_max_uint(fx, res_lane_ty, res_lane)\n+            simd_for_each_lane(fx, a, ret, &|fx, _lane_ty, _res_lane_ty, lane| {\n+                fx.bcx.ins().clz(lane)\n             });\n         }\n-        \"llvm.x86.sse2.psrli.d\" => {\n-            let (a, imm8) = match args {\n-                [a, imm8] => (a, imm8),\n-                _ => bug!(\"wrong number of args for intrinsic {intrinsic}\"),\n-            };\n-            let a = codegen_operand(fx, a);\n-            let imm8 = crate::constant::mir_operand_get_const_val(fx, imm8)\n-                .expect(\"llvm.x86.sse2.psrli.d imm8 not const\");\n \n-            simd_for_each_lane(fx, a, ret, &|fx, _lane_ty, _res_lane_ty, lane| match imm8\n-                .try_to_bits(Size::from_bytes(4))\n-                .unwrap_or_else(|| panic!(\"imm8 not scalar: {:?}\", imm8))\n-            {\n-                imm8 if imm8 < 32 => fx.bcx.ins().ushr_imm(lane, i64::from(imm8 as u8)),\n-                _ => fx.bcx.ins().iconst(types::I32, 0),\n-            });\n-        }\n-        \"llvm.x86.sse2.pslli.d\" => {\n-            let (a, imm8) = match args {\n-                [a, imm8] => (a, imm8),\n-                _ => bug!(\"wrong number of args for intrinsic {intrinsic}\"),\n-            };\n-            let a = codegen_operand(fx, a);\n-            let imm8 = crate::constant::mir_operand_get_const_val(fx, imm8)\n-                .expect(\"llvm.x86.sse2.psrli.d imm8 not const\");\n+        _ if intrinsic.starts_with(\"llvm.ctpop.v\") => {\n+            intrinsic_args!(fx, args => (a); intrinsic);\n \n-            simd_for_each_lane(fx, a, ret, &|fx, _lane_ty, _res_lane_ty, lane| match imm8\n-                .try_to_bits(Size::from_bytes(4))\n-                .unwrap_or_else(|| panic!(\"imm8 not scalar: {:?}\", imm8))\n-            {\n-                imm8 if imm8 < 32 => fx.bcx.ins().ishl_imm(lane, i64::from(imm8 as u8)),\n-                _ => fx.bcx.ins().iconst(types::I32, 0),\n+            simd_for_each_lane(fx, a, ret, &|fx, _lane_ty, _res_lane_ty, lane| {\n+                fx.bcx.ins().popcnt(lane)\n             });\n         }\n-        \"llvm.x86.sse2.storeu.dq\" => {\n-            intrinsic_args!(fx, args => (mem_addr, a); intrinsic);\n-            let mem_addr = mem_addr.load_scalar(fx);\n-\n-            // FIXME correctly handle the unalignment\n-            let dest = CPlace::for_ptr(Pointer::new(mem_addr), a.layout());\n-            dest.write_cvalue(fx, a);\n-        }\n-        \"llvm.x86.addcarry.64\" => {\n-            intrinsic_args!(fx, args => (c_in, a, b); intrinsic);\n-            let c_in = c_in.load_scalar(fx);\n-\n-            llvm_add_sub(fx, BinOp::Add, ret, c_in, a, b);\n-        }\n-        \"llvm.x86.subborrow.64\" => {\n-            intrinsic_args!(fx, args => (b_in, a, b); intrinsic);\n-            let b_in = b_in.load_scalar(fx);\n \n-            llvm_add_sub(fx, BinOp::Sub, ret, b_in, a, b);\n-        }\n         _ => {\n             fx.tcx\n                 .sess\n@@ -150,47 +52,3 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n     let ret_block = fx.get_block(dest);\n     fx.bcx.ins().jump(ret_block, &[]);\n }\n-\n-// llvm.x86.avx2.vperm2i128\n-// llvm.x86.ssse3.pshuf.b.128\n-// llvm.x86.avx2.pshuf.b\n-// llvm.x86.avx2.psrli.w\n-// llvm.x86.sse2.psrli.w\n-\n-fn llvm_add_sub<'tcx>(\n-    fx: &mut FunctionCx<'_, '_, 'tcx>,\n-    bin_op: BinOp,\n-    ret: CPlace<'tcx>,\n-    cb_in: Value,\n-    a: CValue<'tcx>,\n-    b: CValue<'tcx>,\n-) {\n-    assert_eq!(\n-        a.layout().ty,\n-        fx.tcx.types.u64,\n-        \"llvm.x86.addcarry.64/llvm.x86.subborrow.64 second operand must be u64\"\n-    );\n-    assert_eq!(\n-        b.layout().ty,\n-        fx.tcx.types.u64,\n-        \"llvm.x86.addcarry.64/llvm.x86.subborrow.64 third operand must be u64\"\n-    );\n-\n-    // c + carry -> c + first intermediate carry or borrow respectively\n-    let int0 = crate::num::codegen_checked_int_binop(fx, bin_op, a, b);\n-    let c = int0.value_field(fx, mir::Field::new(0));\n-    let cb0 = int0.value_field(fx, mir::Field::new(1)).load_scalar(fx);\n-\n-    // c + carry -> c + second intermediate carry or borrow respectively\n-    let cb_in_as_u64 = fx.bcx.ins().uextend(types::I64, cb_in);\n-    let cb_in_as_u64 = CValue::by_val(cb_in_as_u64, fx.layout_of(fx.tcx.types.u64));\n-    let int1 = crate::num::codegen_checked_int_binop(fx, bin_op, c, cb_in_as_u64);\n-    let (c, cb1) = int1.load_scalar_pair(fx);\n-\n-    // carry0 | carry1 -> carry or borrow respectively\n-    let cb_out = fx.bcx.ins().bor(cb0, cb1);\n-\n-    let layout = fx.layout_of(fx.tcx.mk_tup([fx.tcx.types.u8, fx.tcx.types.u64].iter()));\n-    let val = CValue::by_val_pair(cb_out, c, layout);\n-    ret.write_cvalue(fx, val);\n-}"}, {"sha": "b431158d2690f02d5f3077820ec7c1f36070f7bf", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/llvm_aarch64.rs", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm_aarch64.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -0,0 +1,222 @@\n+//! Emulate AArch64 LLVM intrinsics\n+\n+use crate::intrinsics::*;\n+use crate::prelude::*;\n+\n+use rustc_middle::ty::subst::SubstsRef;\n+\n+pub(crate) fn codegen_aarch64_llvm_intrinsic_call<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    intrinsic: &str,\n+    _substs: SubstsRef<'tcx>,\n+    args: &[mir::Operand<'tcx>],\n+    ret: CPlace<'tcx>,\n+    target: Option<BasicBlock>,\n+) {\n+    // llvm.aarch64.neon.sqshl.v*i*\n+\n+    match intrinsic {\n+        \"llvm.aarch64.isb\" => {\n+            fx.bcx.ins().fence();\n+        }\n+\n+        _ if intrinsic.starts_with(\"llvm.aarch64.neon.abs.v\") => {\n+            intrinsic_args!(fx, args => (a); intrinsic);\n+\n+            simd_for_each_lane(fx, a, ret, &|fx, _lane_ty, _res_lane_ty, lane| {\n+                fx.bcx.ins().iabs(lane)\n+            });\n+        }\n+\n+        _ if intrinsic.starts_with(\"llvm.aarch64.neon.cls.v\") => {\n+            intrinsic_args!(fx, args => (a); intrinsic);\n+\n+            simd_for_each_lane(fx, a, ret, &|fx, _lane_ty, _res_lane_ty, lane| {\n+                fx.bcx.ins().cls(lane)\n+            });\n+        }\n+\n+        _ if intrinsic.starts_with(\"llvm.aarch64.neon.rbit.v\") => {\n+            intrinsic_args!(fx, args => (a); intrinsic);\n+\n+            simd_for_each_lane(fx, a, ret, &|fx, _lane_ty, _res_lane_ty, lane| {\n+                fx.bcx.ins().bitrev(lane)\n+            });\n+        }\n+\n+        _ if intrinsic.starts_with(\"llvm.aarch64.neon.sqadd.v\") => {\n+            intrinsic_args!(fx, args => (x, y); intrinsic);\n+\n+            simd_pair_for_each_lane_typed(fx, x, y, ret, &|fx, x_lane, y_lane| {\n+                crate::num::codegen_saturating_int_binop(fx, BinOp::Add, x_lane, y_lane)\n+            });\n+        }\n+\n+        _ if intrinsic.starts_with(\"llvm.aarch64.neon.sqsub.v\") => {\n+            intrinsic_args!(fx, args => (x, y); intrinsic);\n+\n+            simd_pair_for_each_lane_typed(fx, x, y, ret, &|fx, x_lane, y_lane| {\n+                crate::num::codegen_saturating_int_binop(fx, BinOp::Sub, x_lane, y_lane)\n+            });\n+        }\n+\n+        _ if intrinsic.starts_with(\"llvm.aarch64.neon.smax.v\") => {\n+            intrinsic_args!(fx, args => (x, y); intrinsic);\n+\n+            simd_pair_for_each_lane(\n+                fx,\n+                x,\n+                y,\n+                ret,\n+                &|fx, _lane_ty, _res_lane_ty, x_lane, y_lane| {\n+                    let gt = fx.bcx.ins().icmp(IntCC::SignedGreaterThan, x_lane, y_lane);\n+                    fx.bcx.ins().select(gt, x_lane, y_lane)\n+                },\n+            );\n+        }\n+\n+        _ if intrinsic.starts_with(\"llvm.aarch64.neon.umax.v\") => {\n+            intrinsic_args!(fx, args => (x, y); intrinsic);\n+\n+            simd_pair_for_each_lane(\n+                fx,\n+                x,\n+                y,\n+                ret,\n+                &|fx, _lane_ty, _res_lane_ty, x_lane, y_lane| {\n+                    let gt = fx.bcx.ins().icmp(IntCC::UnsignedGreaterThan, x_lane, y_lane);\n+                    fx.bcx.ins().select(gt, x_lane, y_lane)\n+                },\n+            );\n+        }\n+\n+        _ if intrinsic.starts_with(\"llvm.aarch64.neon.smaxv.i\") => {\n+            intrinsic_args!(fx, args => (v); intrinsic);\n+\n+            simd_reduce(fx, v, None, ret, &|fx, _ty, a, b| {\n+                let gt = fx.bcx.ins().icmp(IntCC::SignedGreaterThan, a, b);\n+                fx.bcx.ins().select(gt, a, b)\n+            });\n+        }\n+\n+        _ if intrinsic.starts_with(\"llvm.aarch64.neon.umaxv.i\") => {\n+            intrinsic_args!(fx, args => (v); intrinsic);\n+\n+            simd_reduce(fx, v, None, ret, &|fx, _ty, a, b| {\n+                let gt = fx.bcx.ins().icmp(IntCC::UnsignedGreaterThan, a, b);\n+                fx.bcx.ins().select(gt, a, b)\n+            });\n+        }\n+\n+        _ if intrinsic.starts_with(\"llvm.aarch64.neon.smin.v\") => {\n+            intrinsic_args!(fx, args => (x, y); intrinsic);\n+\n+            simd_pair_for_each_lane(\n+                fx,\n+                x,\n+                y,\n+                ret,\n+                &|fx, _lane_ty, _res_lane_ty, x_lane, y_lane| {\n+                    let gt = fx.bcx.ins().icmp(IntCC::SignedLessThan, x_lane, y_lane);\n+                    fx.bcx.ins().select(gt, x_lane, y_lane)\n+                },\n+            );\n+        }\n+\n+        _ if intrinsic.starts_with(\"llvm.aarch64.neon.umin.v\") => {\n+            intrinsic_args!(fx, args => (x, y); intrinsic);\n+\n+            simd_pair_for_each_lane(\n+                fx,\n+                x,\n+                y,\n+                ret,\n+                &|fx, _lane_ty, _res_lane_ty, x_lane, y_lane| {\n+                    let gt = fx.bcx.ins().icmp(IntCC::UnsignedLessThan, x_lane, y_lane);\n+                    fx.bcx.ins().select(gt, x_lane, y_lane)\n+                },\n+            );\n+        }\n+\n+        _ if intrinsic.starts_with(\"llvm.aarch64.neon.sminv.i\") => {\n+            intrinsic_args!(fx, args => (v); intrinsic);\n+\n+            simd_reduce(fx, v, None, ret, &|fx, _ty, a, b| {\n+                let gt = fx.bcx.ins().icmp(IntCC::SignedLessThan, a, b);\n+                fx.bcx.ins().select(gt, a, b)\n+            });\n+        }\n+\n+        _ if intrinsic.starts_with(\"llvm.aarch64.neon.uminv.i\") => {\n+            intrinsic_args!(fx, args => (v); intrinsic);\n+\n+            simd_reduce(fx, v, None, ret, &|fx, _ty, a, b| {\n+                let gt = fx.bcx.ins().icmp(IntCC::UnsignedLessThan, a, b);\n+                fx.bcx.ins().select(gt, a, b)\n+            });\n+        }\n+\n+        /*\n+        _ if intrinsic.starts_with(\"llvm.aarch64.neon.sshl.v\")\n+            || intrinsic.starts_with(\"llvm.aarch64.neon.sqshl.v\")\n+            // FIXME split this one out once saturating is implemented\n+            || intrinsic.starts_with(\"llvm.aarch64.neon.sqshlu.v\") =>\n+        {\n+            intrinsic_args!(fx, args => (a, b); intrinsic);\n+\n+            simd_pair_for_each_lane(fx, a, b, ret, &|fx, _lane_ty, _res_lane_ty, a, b| {\n+                // FIXME saturate?\n+                fx.bcx.ins().ishl(a, b)\n+            });\n+        }\n+\n+        _ if intrinsic.starts_with(\"llvm.aarch64.neon.sqshrn.v\") => {\n+            let (a, imm32) = match args {\n+                [a, imm32] => (a, imm32),\n+                _ => bug!(\"wrong number of args for intrinsic {intrinsic}\"),\n+            };\n+            let a = codegen_operand(fx, a);\n+            let imm32 = crate::constant::mir_operand_get_const_val(fx, imm32)\n+                .expect(\"llvm.aarch64.neon.sqshrn.v* imm32 not const\");\n+\n+            simd_for_each_lane(fx, a, ret, &|fx, _lane_ty, _res_lane_ty, lane| match imm32\n+                .try_to_bits(Size::from_bytes(4))\n+                .unwrap_or_else(|| panic!(\"imm32 not scalar: {:?}\", imm32))\n+            {\n+                imm32 if imm32 < 32 => fx.bcx.ins().sshr_imm(lane, i64::from(imm32 as u8)),\n+                _ => fx.bcx.ins().iconst(types::I32, 0),\n+            });\n+        }\n+\n+        _ if intrinsic.starts_with(\"llvm.aarch64.neon.sqshrun.v\") => {\n+            let (a, imm32) = match args {\n+                [a, imm32] => (a, imm32),\n+                _ => bug!(\"wrong number of args for intrinsic {intrinsic}\"),\n+            };\n+            let a = codegen_operand(fx, a);\n+            let imm32 = crate::constant::mir_operand_get_const_val(fx, imm32)\n+                .expect(\"llvm.aarch64.neon.sqshrn.v* imm32 not const\");\n+\n+            simd_for_each_lane(fx, a, ret, &|fx, _lane_ty, _res_lane_ty, lane| match imm32\n+                .try_to_bits(Size::from_bytes(4))\n+                .unwrap_or_else(|| panic!(\"imm32 not scalar: {:?}\", imm32))\n+            {\n+                imm32 if imm32 < 32 => fx.bcx.ins().ushr_imm(lane, i64::from(imm32 as u8)),\n+                _ => fx.bcx.ins().iconst(types::I32, 0),\n+            });\n+        }\n+        */\n+        _ => {\n+            fx.tcx.sess.warn(&format!(\n+                \"unsupported AArch64 llvm intrinsic {}; replacing with trap\",\n+                intrinsic\n+            ));\n+            crate::trap::trap_unimplemented(fx, intrinsic);\n+            return;\n+        }\n+    }\n+\n+    let dest = target.expect(\"all llvm intrinsics used by stdlib should return\");\n+    let ret_block = fx.get_block(dest);\n+    fx.bcx.ins().jump(ret_block, &[]);\n+}"}, {"sha": "7bc161fbe55236a1b03ad08db5a80e274f94d7f8", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/llvm_x86.rs", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm_x86.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -0,0 +1,197 @@\n+//! Emulate x86 LLVM intrinsics\n+\n+use crate::intrinsics::*;\n+use crate::prelude::*;\n+\n+use rustc_middle::ty::subst::SubstsRef;\n+\n+pub(crate) fn codegen_x86_llvm_intrinsic_call<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    intrinsic: &str,\n+    _substs: SubstsRef<'tcx>,\n+    args: &[mir::Operand<'tcx>],\n+    ret: CPlace<'tcx>,\n+    target: Option<BasicBlock>,\n+) {\n+    match intrinsic {\n+        \"llvm.x86.sse2.pause\" | \"llvm.aarch64.isb\" => {\n+            // Spin loop hint\n+        }\n+\n+        // Used by `_mm_movemask_epi8` and `_mm256_movemask_epi8`\n+        \"llvm.x86.sse2.pmovmskb.128\" | \"llvm.x86.avx2.pmovmskb\" | \"llvm.x86.sse2.movmsk.pd\" => {\n+            intrinsic_args!(fx, args => (a); intrinsic);\n+\n+            let (lane_count, lane_ty) = a.layout().ty.simd_size_and_type(fx.tcx);\n+            let lane_ty = fx.clif_type(lane_ty).unwrap();\n+            assert!(lane_count <= 32);\n+\n+            let mut res = fx.bcx.ins().iconst(types::I32, 0);\n+\n+            for lane in (0..lane_count).rev() {\n+                let a_lane = a.value_lane(fx, lane).load_scalar(fx);\n+\n+                // cast float to int\n+                let a_lane = match lane_ty {\n+                    types::F32 => fx.bcx.ins().bitcast(types::I32, a_lane),\n+                    types::F64 => fx.bcx.ins().bitcast(types::I64, a_lane),\n+                    _ => a_lane,\n+                };\n+\n+                // extract sign bit of an int\n+                let a_lane_sign = fx.bcx.ins().ushr_imm(a_lane, i64::from(lane_ty.bits() - 1));\n+\n+                // shift sign bit into result\n+                let a_lane_sign = clif_intcast(fx, a_lane_sign, types::I32, false);\n+                res = fx.bcx.ins().ishl_imm(res, 1);\n+                res = fx.bcx.ins().bor(res, a_lane_sign);\n+            }\n+\n+            let res = CValue::by_val(res, fx.layout_of(fx.tcx.types.i32));\n+            ret.write_cvalue(fx, res);\n+        }\n+        \"llvm.x86.sse2.cmp.ps\" | \"llvm.x86.sse2.cmp.pd\" => {\n+            let (x, y, kind) = match args {\n+                [x, y, kind] => (x, y, kind),\n+                _ => bug!(\"wrong number of args for intrinsic {intrinsic}\"),\n+            };\n+            let x = codegen_operand(fx, x);\n+            let y = codegen_operand(fx, y);\n+            let kind = crate::constant::mir_operand_get_const_val(fx, kind)\n+                .expect(\"llvm.x86.sse2.cmp.* kind not const\");\n+\n+            let flt_cc = match kind\n+                .try_to_bits(Size::from_bytes(1))\n+                .unwrap_or_else(|| panic!(\"kind not scalar: {:?}\", kind))\n+            {\n+                0 => FloatCC::Equal,\n+                1 => FloatCC::LessThan,\n+                2 => FloatCC::LessThanOrEqual,\n+                7 => FloatCC::Ordered,\n+                3 => FloatCC::Unordered,\n+                4 => FloatCC::NotEqual,\n+                5 => FloatCC::UnorderedOrGreaterThanOrEqual,\n+                6 => FloatCC::UnorderedOrGreaterThan,\n+                kind => unreachable!(\"kind {:?}\", kind),\n+            };\n+\n+            simd_pair_for_each_lane(fx, x, y, ret, &|fx, lane_ty, res_lane_ty, x_lane, y_lane| {\n+                let res_lane = match lane_ty.kind() {\n+                    ty::Float(_) => fx.bcx.ins().fcmp(flt_cc, x_lane, y_lane),\n+                    _ => unreachable!(\"{:?}\", lane_ty),\n+                };\n+                bool_to_zero_or_max_uint(fx, res_lane_ty, res_lane)\n+            });\n+        }\n+        \"llvm.x86.sse2.psrli.d\" => {\n+            let (a, imm8) = match args {\n+                [a, imm8] => (a, imm8),\n+                _ => bug!(\"wrong number of args for intrinsic {intrinsic}\"),\n+            };\n+            let a = codegen_operand(fx, a);\n+            let imm8 = crate::constant::mir_operand_get_const_val(fx, imm8)\n+                .expect(\"llvm.x86.sse2.psrli.d imm8 not const\");\n+\n+            simd_for_each_lane(fx, a, ret, &|fx, _lane_ty, _res_lane_ty, lane| match imm8\n+                .try_to_bits(Size::from_bytes(4))\n+                .unwrap_or_else(|| panic!(\"imm8 not scalar: {:?}\", imm8))\n+            {\n+                imm8 if imm8 < 32 => fx.bcx.ins().ushr_imm(lane, i64::from(imm8 as u8)),\n+                _ => fx.bcx.ins().iconst(types::I32, 0),\n+            });\n+        }\n+        \"llvm.x86.sse2.pslli.d\" => {\n+            let (a, imm8) = match args {\n+                [a, imm8] => (a, imm8),\n+                _ => bug!(\"wrong number of args for intrinsic {intrinsic}\"),\n+            };\n+            let a = codegen_operand(fx, a);\n+            let imm8 = crate::constant::mir_operand_get_const_val(fx, imm8)\n+                .expect(\"llvm.x86.sse2.psrli.d imm8 not const\");\n+\n+            simd_for_each_lane(fx, a, ret, &|fx, _lane_ty, _res_lane_ty, lane| match imm8\n+                .try_to_bits(Size::from_bytes(4))\n+                .unwrap_or_else(|| panic!(\"imm8 not scalar: {:?}\", imm8))\n+            {\n+                imm8 if imm8 < 32 => fx.bcx.ins().ishl_imm(lane, i64::from(imm8 as u8)),\n+                _ => fx.bcx.ins().iconst(types::I32, 0),\n+            });\n+        }\n+        \"llvm.x86.sse2.storeu.dq\" => {\n+            intrinsic_args!(fx, args => (mem_addr, a); intrinsic);\n+            let mem_addr = mem_addr.load_scalar(fx);\n+\n+            // FIXME correctly handle the unalignment\n+            let dest = CPlace::for_ptr(Pointer::new(mem_addr), a.layout());\n+            dest.write_cvalue(fx, a);\n+        }\n+        \"llvm.x86.addcarry.64\" => {\n+            intrinsic_args!(fx, args => (c_in, a, b); intrinsic);\n+            let c_in = c_in.load_scalar(fx);\n+\n+            llvm_add_sub(fx, BinOp::Add, ret, c_in, a, b);\n+        }\n+        \"llvm.x86.subborrow.64\" => {\n+            intrinsic_args!(fx, args => (b_in, a, b); intrinsic);\n+            let b_in = b_in.load_scalar(fx);\n+\n+            llvm_add_sub(fx, BinOp::Sub, ret, b_in, a, b);\n+        }\n+        _ => {\n+            fx.tcx.sess.warn(&format!(\n+                \"unsupported x86 llvm intrinsic {}; replacing with trap\",\n+                intrinsic\n+            ));\n+            crate::trap::trap_unimplemented(fx, intrinsic);\n+            return;\n+        }\n+    }\n+\n+    let dest = target.expect(\"all llvm intrinsics used by stdlib should return\");\n+    let ret_block = fx.get_block(dest);\n+    fx.bcx.ins().jump(ret_block, &[]);\n+}\n+\n+// llvm.x86.avx2.vperm2i128\n+// llvm.x86.ssse3.pshuf.b.128\n+// llvm.x86.avx2.pshuf.b\n+// llvm.x86.avx2.psrli.w\n+// llvm.x86.sse2.psrli.w\n+\n+fn llvm_add_sub<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    bin_op: BinOp,\n+    ret: CPlace<'tcx>,\n+    cb_in: Value,\n+    a: CValue<'tcx>,\n+    b: CValue<'tcx>,\n+) {\n+    assert_eq!(\n+        a.layout().ty,\n+        fx.tcx.types.u64,\n+        \"llvm.x86.addcarry.64/llvm.x86.subborrow.64 second operand must be u64\"\n+    );\n+    assert_eq!(\n+        b.layout().ty,\n+        fx.tcx.types.u64,\n+        \"llvm.x86.addcarry.64/llvm.x86.subborrow.64 third operand must be u64\"\n+    );\n+\n+    // c + carry -> c + first intermediate carry or borrow respectively\n+    let int0 = crate::num::codegen_checked_int_binop(fx, bin_op, a, b);\n+    let c = int0.value_field(fx, mir::Field::new(0));\n+    let cb0 = int0.value_field(fx, mir::Field::new(1)).load_scalar(fx);\n+\n+    // c + carry -> c + second intermediate carry or borrow respectively\n+    let cb_in_as_u64 = fx.bcx.ins().uextend(types::I64, cb_in);\n+    let cb_in_as_u64 = CValue::by_val(cb_in_as_u64, fx.layout_of(fx.tcx.types.u64));\n+    let int1 = crate::num::codegen_checked_int_binop(fx, bin_op, c, cb_in_as_u64);\n+    let (c, cb1) = int1.load_scalar_pair(fx);\n+\n+    // carry0 | carry1 -> carry or borrow respectively\n+    let cb_out = fx.bcx.ins().bor(cb0, cb1);\n+\n+    let layout = fx.layout_of(fx.tcx.mk_tup([fx.tcx.types.u8, fx.tcx.types.u64].iter()));\n+    let val = CValue::by_val_pair(cb_out, c, layout);\n+    ret.write_cvalue(fx, val);\n+}"}, {"sha": "7a380acf798572a7606130959a7517cfecb2462b", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 12, "deletions": 84, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -14,6 +14,8 @@ macro_rules! intrinsic_args {\n \n mod cpuid;\n mod llvm;\n+mod llvm_aarch64;\n+mod llvm_x86;\n mod simd;\n \n pub(crate) use cpuid::codegen_cpuid_call;\n@@ -195,8 +197,7 @@ fn bool_to_zero_or_max_uint<'tcx>(\n         ty => ty,\n     };\n \n-    let val = fx.bcx.ins().bint(int_ty, val);\n-    let mut res = fx.bcx.ins().ineg(val);\n+    let mut res = fx.bcx.ins().bmask(int_ty, val);\n \n     if ty.is_float() {\n         res = fx.bcx.ins().bitcast(ty, res);\n@@ -632,85 +633,15 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, res);\n         }\n         sym::bswap => {\n-            // FIXME(CraneStation/cranelift#794) add bswap instruction to cranelift\n-            fn swap(bcx: &mut FunctionBuilder<'_>, v: Value) -> Value {\n-                match bcx.func.dfg.value_type(v) {\n-                    types::I8 => v,\n-\n-                    // https://code.woboq.org/gcc/include/bits/byteswap.h.html\n-                    types::I16 => {\n-                        let tmp1 = bcx.ins().ishl_imm(v, 8);\n-                        let n1 = bcx.ins().band_imm(tmp1, 0xFF00);\n-\n-                        let tmp2 = bcx.ins().ushr_imm(v, 8);\n-                        let n2 = bcx.ins().band_imm(tmp2, 0x00FF);\n-\n-                        bcx.ins().bor(n1, n2)\n-                    }\n-                    types::I32 => {\n-                        let tmp1 = bcx.ins().ishl_imm(v, 24);\n-                        let n1 = bcx.ins().band_imm(tmp1, 0xFF00_0000);\n-\n-                        let tmp2 = bcx.ins().ishl_imm(v, 8);\n-                        let n2 = bcx.ins().band_imm(tmp2, 0x00FF_0000);\n-\n-                        let tmp3 = bcx.ins().ushr_imm(v, 8);\n-                        let n3 = bcx.ins().band_imm(tmp3, 0x0000_FF00);\n-\n-                        let tmp4 = bcx.ins().ushr_imm(v, 24);\n-                        let n4 = bcx.ins().band_imm(tmp4, 0x0000_00FF);\n-\n-                        let or_tmp1 = bcx.ins().bor(n1, n2);\n-                        let or_tmp2 = bcx.ins().bor(n3, n4);\n-                        bcx.ins().bor(or_tmp1, or_tmp2)\n-                    }\n-                    types::I64 => {\n-                        let tmp1 = bcx.ins().ishl_imm(v, 56);\n-                        let n1 = bcx.ins().band_imm(tmp1, 0xFF00_0000_0000_0000u64 as i64);\n-\n-                        let tmp2 = bcx.ins().ishl_imm(v, 40);\n-                        let n2 = bcx.ins().band_imm(tmp2, 0x00FF_0000_0000_0000u64 as i64);\n-\n-                        let tmp3 = bcx.ins().ishl_imm(v, 24);\n-                        let n3 = bcx.ins().band_imm(tmp3, 0x0000_FF00_0000_0000u64 as i64);\n-\n-                        let tmp4 = bcx.ins().ishl_imm(v, 8);\n-                        let n4 = bcx.ins().band_imm(tmp4, 0x0000_00FF_0000_0000u64 as i64);\n-\n-                        let tmp5 = bcx.ins().ushr_imm(v, 8);\n-                        let n5 = bcx.ins().band_imm(tmp5, 0x0000_0000_FF00_0000u64 as i64);\n-\n-                        let tmp6 = bcx.ins().ushr_imm(v, 24);\n-                        let n6 = bcx.ins().band_imm(tmp6, 0x0000_0000_00FF_0000u64 as i64);\n-\n-                        let tmp7 = bcx.ins().ushr_imm(v, 40);\n-                        let n7 = bcx.ins().band_imm(tmp7, 0x0000_0000_0000_FF00u64 as i64);\n-\n-                        let tmp8 = bcx.ins().ushr_imm(v, 56);\n-                        let n8 = bcx.ins().band_imm(tmp8, 0x0000_0000_0000_00FFu64 as i64);\n-\n-                        let or_tmp1 = bcx.ins().bor(n1, n2);\n-                        let or_tmp2 = bcx.ins().bor(n3, n4);\n-                        let or_tmp3 = bcx.ins().bor(n5, n6);\n-                        let or_tmp4 = bcx.ins().bor(n7, n8);\n-\n-                        let or_tmp5 = bcx.ins().bor(or_tmp1, or_tmp2);\n-                        let or_tmp6 = bcx.ins().bor(or_tmp3, or_tmp4);\n-                        bcx.ins().bor(or_tmp5, or_tmp6)\n-                    }\n-                    types::I128 => {\n-                        let (lo, hi) = bcx.ins().isplit(v);\n-                        let lo = swap(bcx, lo);\n-                        let hi = swap(bcx, hi);\n-                        bcx.ins().iconcat(hi, lo)\n-                    }\n-                    ty => unreachable!(\"bswap {}\", ty),\n-                }\n-            }\n             intrinsic_args!(fx, args => (arg); intrinsic);\n             let val = arg.load_scalar(fx);\n \n-            let res = CValue::by_val(swap(&mut fx.bcx, val), arg.layout());\n+            let res = if fx.bcx.func.dfg.value_type(val) == types::I8 {\n+                val\n+            } else {\n+                fx.bcx.ins().bswap(val)\n+            };\n+            let res = CValue::by_val(res, arg.layout());\n             ret.write_cvalue(fx, res);\n         }\n         sym::assert_inhabited | sym::assert_zero_valid | sym::assert_uninit_valid => {\n@@ -936,8 +867,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             let old = fx.bcx.ins().atomic_cas(MemFlags::trusted(), ptr, test_old, new);\n             let is_eq = fx.bcx.ins().icmp(IntCC::Equal, old, test_old);\n \n-            let ret_val =\n-                CValue::by_val_pair(old, fx.bcx.ins().bint(types::I8, is_eq), ret.layout());\n+            let ret_val = CValue::by_val_pair(old, is_eq, ret.layout());\n             ret.write_cvalue(fx, ret_val)\n         }\n \n@@ -1259,8 +1189,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                 flags.set_notrap();\n                 let lhs_val = fx.bcx.ins().load(clty, flags, lhs_ref, 0);\n                 let rhs_val = fx.bcx.ins().load(clty, flags, rhs_ref, 0);\n-                let eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_val, rhs_val);\n-                fx.bcx.ins().bint(types::I8, eq)\n+                fx.bcx.ins().icmp(IntCC::Equal, lhs_val, rhs_val)\n             } else {\n                 // Just call `memcmp` (like slices do in core) when the\n                 // size is too large or it's not a power-of-two.\n@@ -1270,8 +1199,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                 let returns = vec![AbiParam::new(types::I32)];\n                 let args = &[lhs_ref, rhs_ref, bytes_val];\n                 let cmp = fx.lib_call(\"memcmp\", params, returns, args)[0];\n-                let eq = fx.bcx.ins().icmp_imm(IntCC::Equal, cmp, 0);\n-                fx.bcx.ins().bint(types::I8, eq)\n+                fx.bcx.ins().icmp_imm(IntCC::Equal, cmp, 0)\n             };\n             ret.write_cvalue(fx, CValue::by_val(is_eq_value, ret.layout()));\n         }"}, {"sha": "14f5e9187399fac76f2a64d0147f2f647a904929", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/simd.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -112,10 +112,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                     _ => unreachable!(),\n                 };\n \n-                let ty = fx.clif_type(res_lane_ty).unwrap();\n-\n-                let res_lane = fx.bcx.ins().bint(ty, res_lane);\n-                fx.bcx.ins().ineg(res_lane)\n+                bool_to_zero_or_max_uint(fx, res_lane_ty, res_lane)\n             });\n         }\n \n@@ -716,7 +713,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n \n             let res_type =\n                 Type::int_with_byte_size(u16::try_from(expected_bytes).unwrap()).unwrap();\n-            let mut res = fx.bcx.ins().iconst(res_type, 0);\n+            let mut res = type_zero_value(&mut fx.bcx, res_type);\n \n             let lanes = match fx.tcx.sess.target.endian {\n                 Endian::Big => Box::new(0..lane_count) as Box<dyn Iterator<Item = u64>>,"}, {"sha": "c10054e7f0d2c971711364aafdfe563558e3fd5d", "filename": "compiler/rustc_codegen_cranelift/src/main_shim.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -65,7 +65,7 @@ pub(crate) fn maybe_create_entry_wrapper(\n             returns: vec![AbiParam::new(m.target_config().pointer_type() /*isize*/)],\n             call_conv: crate::conv_to_call_conv(\n                 tcx.sess.target.options.entry_abi,\n-                CallConv::triple_default(m.isa().triple()),\n+                m.target_config().default_call_conv,\n             ),\n         };\n \n@@ -75,7 +75,7 @@ pub(crate) fn maybe_create_entry_wrapper(\n         let instance = Instance::mono(tcx, rust_main_def_id).polymorphize(tcx);\n \n         let main_name = tcx.symbol_name(instance).name;\n-        let main_sig = get_function_sig(tcx, m.isa().triple(), instance);\n+        let main_sig = get_function_sig(tcx, m.target_config().default_call_conv, instance);\n         let main_func_id = m.declare_function(main_name, Linkage::Import, &main_sig).unwrap();\n \n         let mut ctx = Context::new();\n@@ -119,7 +119,7 @@ pub(crate) fn maybe_create_entry_wrapper(\n                 .polymorphize(tcx);\n \n                 let report_name = tcx.symbol_name(report).name;\n-                let report_sig = get_function_sig(tcx, m.isa().triple(), report);\n+                let report_sig = get_function_sig(tcx, m.target_config().default_call_conv, report);\n                 let report_func_id =\n                     m.declare_function(report_name, Linkage::Import, &report_sig).unwrap();\n                 let report_func_ref = m.declare_func_in_func(report_func_id, &mut bcx.func);"}, {"sha": "afacbec644582195440bcb8e3e9c58d6d99b3c74", "filename": "compiler/rustc_codegen_cranelift/src/num.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -49,7 +49,6 @@ fn codegen_compare_bin_op<'tcx>(\n ) -> CValue<'tcx> {\n     let intcc = crate::num::bin_op_to_intcc(bin_op, signed).unwrap();\n     let val = fx.bcx.ins().icmp(intcc, lhs, rhs);\n-    let val = fx.bcx.ins().bint(types::I8, val);\n     CValue::by_val(val, fx.layout_of(fx.tcx.types.bool))\n }\n \n@@ -290,8 +289,6 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n         _ => bug!(\"binop {:?} on checked int/uint lhs: {:?} rhs: {:?}\", bin_op, in_lhs, in_rhs),\n     };\n \n-    let has_overflow = fx.bcx.ins().bint(types::I8, has_overflow);\n-\n     let out_layout = fx.layout_of(fx.tcx.mk_tup([in_lhs.layout().ty, fx.tcx.types.bool].iter()));\n     CValue::by_val_pair(res, has_overflow, out_layout)\n }\n@@ -368,7 +365,6 @@ pub(crate) fn codegen_float_binop<'tcx>(\n                 _ => unreachable!(),\n             };\n             let val = fx.bcx.ins().fcmp(fltcc, lhs, rhs);\n-            let val = fx.bcx.ins().bint(types::I8, val);\n             return CValue::by_val(val, fx.layout_of(fx.tcx.types.bool));\n         }\n         _ => unreachable!(\"{:?}({:?}, {:?})\", bin_op, in_lhs, in_rhs),\n@@ -440,7 +436,7 @@ pub(crate) fn codegen_ptr_binop<'tcx>(\n             _ => panic!(\"bin_op {:?} on ptr\", bin_op),\n         };\n \n-        CValue::by_val(fx.bcx.ins().bint(types::I8, res), fx.layout_of(fx.tcx.types.bool))\n+        CValue::by_val(res, fx.layout_of(fx.tcx.types.bool))\n     }\n }\n "}, {"sha": "7f45bbd8f28136a43b8271ba5f3e2755d19d522d", "filename": "compiler/rustc_codegen_cranelift/src/optimize/peephole.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fpeephole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fpeephole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fpeephole.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -3,19 +3,6 @@\n use cranelift_codegen::ir::{condcodes::IntCC, InstructionData, Opcode, Value, ValueDef};\n use cranelift_frontend::FunctionBuilder;\n \n-/// If the given value was produced by a `bint` instruction, return it's input, otherwise return the\n-/// given value.\n-pub(crate) fn maybe_unwrap_bint(bcx: &mut FunctionBuilder<'_>, arg: Value) -> Value {\n-    if let ValueDef::Result(arg_inst, 0) = bcx.func.dfg.value_def(arg) {\n-        match bcx.func.dfg[arg_inst] {\n-            InstructionData::Unary { opcode: Opcode::Bint, arg } => arg,\n-            _ => arg,\n-        }\n-    } else {\n-        arg\n-    }\n-}\n-\n /// If the given value was produced by the lowering of `Rvalue::Not` return the input and true,\n /// otherwise return the given value and false.\n pub(crate) fn maybe_unwrap_bool_not(bcx: &mut FunctionBuilder<'_>, arg: Value) -> (Value, bool) {\n@@ -48,13 +35,6 @@ pub(crate) fn maybe_known_branch_taken(\n     };\n \n     match bcx.func.dfg[arg_inst] {\n-        InstructionData::UnaryBool { opcode: Opcode::Bconst, imm } => {\n-            if test_zero {\n-                Some(!imm)\n-            } else {\n-                Some(imm)\n-            }\n-        }\n         InstructionData::UnaryImm { opcode: Opcode::Iconst, imm } => {\n             if test_zero {\n                 Some(imm.bits() == 0)"}, {"sha": "fe8af21ac6de567cff94a34ec13e625f8876fe4a", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -392,7 +392,7 @@ impl<'tcx> CPlace<'tcx> {\n         local: Local,\n         layout: TyAndLayout<'tcx>,\n     ) -> CPlace<'tcx> {\n-        let var = Variable::with_u32(fx.next_ssa_var);\n+        let var = Variable::from_u32(fx.next_ssa_var);\n         fx.next_ssa_var += 1;\n         fx.bcx.declare_var(var, fx.clif_type(layout.ty).unwrap());\n         CPlace { inner: CPlaceInner::Var(local, var), layout }\n@@ -403,9 +403,9 @@ impl<'tcx> CPlace<'tcx> {\n         local: Local,\n         layout: TyAndLayout<'tcx>,\n     ) -> CPlace<'tcx> {\n-        let var1 = Variable::with_u32(fx.next_ssa_var);\n+        let var1 = Variable::from_u32(fx.next_ssa_var);\n         fx.next_ssa_var += 1;\n-        let var2 = Variable::with_u32(fx.next_ssa_var);\n+        let var2 = Variable::from_u32(fx.next_ssa_var);\n         fx.next_ssa_var += 1;\n \n         let (ty1, ty2) = fx.clif_pair_type(layout.ty).unwrap();\n@@ -515,9 +515,7 @@ impl<'tcx> CPlace<'tcx> {\n                 | (types::F32, types::I32)\n                 | (types::I64, types::F64)\n                 | (types::F64, types::I64) => fx.bcx.ins().bitcast(dst_ty, data),\n-                _ if src_ty.is_vector() && dst_ty.is_vector() => {\n-                    fx.bcx.ins().raw_bitcast(dst_ty, data)\n-                }\n+                _ if src_ty.is_vector() && dst_ty.is_vector() => fx.bcx.ins().bitcast(dst_ty, data),\n                 _ if src_ty.is_vector() || dst_ty.is_vector() => {\n                     // FIXME do something more efficient for transmutes between vectors and integers.\n                     let stack_slot = fx.bcx.create_sized_stack_slot(StackSlotData {\n@@ -590,7 +588,10 @@ impl<'tcx> CPlace<'tcx> {\n                 return;\n             }\n             CPlaceInner::VarPair(_local, var1, var2) => {\n-                let (data1, data2) = CValue(from.0, dst_layout).load_scalar_pair(fx);\n+                let (ptr, meta) = from.force_stack(fx);\n+                assert!(meta.is_none());\n+                let (data1, data2) =\n+                    CValue(CValueInner::ByRef(ptr, None), dst_layout).load_scalar_pair(fx);\n                 let (dst_ty1, dst_ty2) = fx.clif_pair_type(self.layout().ty).unwrap();\n                 transmute_value(fx, var1, data1, dst_ty1);\n                 transmute_value(fx, var2, data2, dst_ty2);"}, {"sha": "13e7784539d5a9b9cdb3c81dd7f548afcb0c418b", "filename": "compiler/rustc_codegen_cranelift/test.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Ftest.sh", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Ftest.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Ftest.sh?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,2 +1,2 @@\n #!/usr/bin/env bash\n-exec ./y.rs test\n+exec ./y.rs test \"$@\""}, {"sha": "02e1e21ade1de98f4d72256adbe70755a3997a55", "filename": "compiler/rustc_codegen_cranelift/y.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_cranelift%2Fy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fy.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -3,7 +3,7 @@\n # This block is ignored by rustc\n set -e\n echo \"[BUILD] y.rs\" 1>&2\n-rustc $0 -o ${0/.rs/.bin} -Cdebuginfo=1\n+rustc $0 -o ${0/.rs/.bin} -Cdebuginfo=1 --edition 2021\n exec ${0/.rs/.bin} $@\n */\n "}, {"sha": "effb2de4827518c08360bed61995f5ffe3c86a58", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1119,18 +1119,18 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         // TODO(antoyo)\n     }\n \n-    fn cleanup_landing_pad(&mut self, _ty: Type<'gcc>, _pers_fn: RValue<'gcc>) -> RValue<'gcc> {\n-        let field1 = self.context.new_field(None, self.u8_type.make_pointer(), \"landing_pad_field_1\");\n-        let field2 = self.context.new_field(None, self.i32_type, \"landing_pad_field_1\");\n-        let struct_type = self.context.new_struct_type(None, \"landing_pad\", &[field1, field2]);\n-        self.current_func().new_local(None, struct_type.as_type(), \"landing_pad\")\n-            .to_rvalue()\n+    fn cleanup_landing_pad(&mut self, _pers_fn: RValue<'gcc>) -> (RValue<'gcc>, RValue<'gcc>) {\n+        (\n+            self.current_func().new_local(None, self.u8_type.make_pointer(), \"landing_pad0\")\n+                .to_rvalue(),\n+            self.current_func().new_local(None, self.i32_type, \"landing_pad1\").to_rvalue(),\n+        )\n         // TODO(antoyo): Properly implement unwinding.\n         // the above is just to make the compilation work as it seems\n         // rustc_codegen_ssa now calls the unwinding builder methods even on panic=abort.\n     }\n \n-    fn resume(&mut self, _exn: RValue<'gcc>) {\n+    fn resume(&mut self, _exn0: RValue<'gcc>, _exn1: RValue<'gcc>) {\n         // TODO(bjorn3): Properly implement unwinding.\n         self.unreachable();\n     }"}, {"sha": "36aba5bb740bd6120030c0cbf0e5d6654fa0afc8", "filename": "compiler/rustc_codegen_llvm/src/back/archive.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -15,8 +15,8 @@ use crate::errors::{\n use crate::llvm::archive_ro::{ArchiveRO, Child};\n use crate::llvm::{self, ArchiveKind, LLVMMachineType, LLVMRustCOFFShortExport};\n use rustc_codegen_ssa::back::archive::{\n-    get_native_object_symbols, try_extract_macho_fat_archive, ArArchiveBuilder,\n-    ArchiveBuildFailure, ArchiveBuilder, ArchiveBuilderBuilder, UnknownArchiveKind,\n+    get_native_object_symbols, ArArchiveBuilder, ArchiveBuildFailure, ArchiveBuilder,\n+    ArchiveBuilderBuilder, UnknownArchiveKind,\n };\n \n use rustc_session::cstore::DllImport;\n@@ -66,21 +66,15 @@ impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n         archive: &Path,\n         skip: Box<dyn FnMut(&str) -> bool + 'static>,\n     ) -> io::Result<()> {\n-        let mut archive = archive.to_path_buf();\n-        if self.sess.target.llvm_target.contains(\"-apple-macosx\") {\n-            if let Some(new_archive) = try_extract_macho_fat_archive(&self.sess, &archive)? {\n-                archive = new_archive\n-            }\n-        }\n-        let archive_ro = match ArchiveRO::open(&archive) {\n+        let archive_ro = match ArchiveRO::open(archive) {\n             Ok(ar) => ar,\n             Err(e) => return Err(io::Error::new(io::ErrorKind::Other, e)),\n         };\n         if self.additions.iter().any(|ar| ar.path() == archive) {\n             return Ok(());\n         }\n         self.additions.push(Addition::Archive {\n-            path: archive,\n+            path: archive.to_path_buf(),\n             archive: archive_ro,\n             skip: Box::new(skip),\n         });"}, {"sha": "e20dc906bce9a42bb3c639c27f33d7bfb8db56b2", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -133,6 +133,10 @@ fn prepare_lto(\n         }\n     }\n \n+    // __llvm_profile_counter_bias is pulled in at link time by an undefined reference to\n+    // __llvm_profile_runtime, therefore we won't know until link time if this symbol\n+    // should have default visibility.\n+    symbols_below_threshold.push(CString::new(\"__llvm_profile_counter_bias\").unwrap());\n     Ok((symbols_below_threshold, upstream_modules))\n }\n \n@@ -206,7 +210,7 @@ pub(crate) fn run_thin(\n }\n \n pub(crate) fn prepare_thin(module: ModuleCodegen<ModuleLlvm>) -> (String, ThinBuffer) {\n-    let name = module.name.clone();\n+    let name = module.name;\n     let buffer = ThinBuffer::new(module.module_llvm.llmod(), true);\n     (name, buffer)\n }"}, {"sha": "853a8b82853f43400a223804c629bd7b0b9c0e75", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -979,15 +979,20 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn cleanup_landing_pad(&mut self, ty: &'ll Type, pers_fn: &'ll Value) -> &'ll Value {\n+    fn cleanup_landing_pad(&mut self, pers_fn: &'ll Value) -> (&'ll Value, &'ll Value) {\n+        let ty = self.type_struct(&[self.type_i8p(), self.type_i32()], false);\n         let landing_pad = self.landing_pad(ty, pers_fn, 1 /* FIXME should this be 0? */);\n         unsafe {\n             llvm::LLVMSetCleanup(landing_pad, llvm::True);\n         }\n-        landing_pad\n+        (self.extract_value(landing_pad, 0), self.extract_value(landing_pad, 1))\n     }\n \n-    fn resume(&mut self, exn: &'ll Value) {\n+    fn resume(&mut self, exn0: &'ll Value, exn1: &'ll Value) {\n+        let ty = self.type_struct(&[self.type_i8p(), self.type_i32()], false);\n+        let mut exn = self.const_undef(ty);\n+        exn = self.insert_value(exn, exn0, 0);\n+        exn = self.insert_value(exn, exn1, 1);\n         unsafe {\n             llvm::LLVMBuildResume(self.llbuilder, exn);\n         }"}, {"sha": "907517bf6ce950b148bed7f1916c847d0b80c5bd", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -424,7 +424,9 @@ impl<'ll, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n         typeid: &'ll Value,\n     ) -> Self::Value {\n         let vtable_byte_offset = self.const_i32(vtable_byte_offset as i32);\n-        self.call_intrinsic(\"llvm.type.checked.load\", &[llvtable, vtable_byte_offset, typeid])\n+        let type_checked_load =\n+            self.call_intrinsic(\"llvm.type.checked.load\", &[llvtable, vtable_byte_offset, typeid]);\n+        self.extract_value(type_checked_load, 0)\n     }\n \n     fn va_start(&mut self, va_list: &'ll Value) -> &'ll Value {"}, {"sha": "5266d8858d47d35dcc9c12e0e935bb9327b1d4f0", "filename": "compiler/rustc_codegen_ssa/src/back/archive.rs", "status": "modified", "additions": 34, "deletions": 36, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -14,7 +14,7 @@ use tempfile::Builder as TempFileBuilder;\n \n use std::error::Error;\n use std::fs::File;\n-use std::io::{self, Write};\n+use std::io;\n use std::path::{Path, PathBuf};\n \n // Re-exporting for rustc_codegen_llvm::back::archive\n@@ -116,51 +116,42 @@ impl<'a> ArArchiveBuilder<'a> {\n     }\n }\n \n-fn try_filter_fat_archs(\n+fn try_filter_fat_archs<'a>(\n     archs: object::read::Result<&[impl FatArch]>,\n     target_arch: object::Architecture,\n-    archive_path: &Path,\n-    archive_map_data: &[u8],\n-) -> io::Result<Option<PathBuf>> {\n+    archive_map_data: &'a [u8],\n+) -> io::Result<Option<(&'a [u8], u64)>> {\n     let archs = archs.map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;\n \n     let desired = match archs.iter().filter(|a| a.architecture() == target_arch).next() {\n         Some(a) => a,\n         None => return Ok(None),\n     };\n \n-    let (mut new_f, extracted_path) = tempfile::Builder::new()\n-        .suffix(archive_path.file_name().unwrap())\n-        .tempfile()?\n-        .keep()\n-        .unwrap();\n-\n-    new_f.write_all(\n+    Ok(Some((\n         desired.data(archive_map_data).map_err(|e| io::Error::new(io::ErrorKind::Other, e))?,\n-    )?;\n-\n-    Ok(Some(extracted_path))\n+        desired.offset().into(),\n+    )))\n }\n \n-pub fn try_extract_macho_fat_archive(\n+pub fn try_extract_macho_fat_archive<'a>(\n     sess: &Session,\n-    archive_path: &Path,\n-) -> io::Result<Option<PathBuf>> {\n-    let archive_map = unsafe { Mmap::map(File::open(&archive_path)?)? };\n+    archive_bytes: &'a [u8],\n+) -> io::Result<Option<(&'a [u8], u64)>> {\n     let target_arch = match sess.target.arch.as_ref() {\n         \"aarch64\" => object::Architecture::Aarch64,\n         \"x86_64\" => object::Architecture::X86_64,\n         _ => return Ok(None),\n     };\n \n-    match object::macho::FatHeader::parse(&*archive_map) {\n+    match object::macho::FatHeader::parse(archive_bytes) {\n         Ok(h) if h.magic.get(object::endian::BigEndian) == object::macho::FAT_MAGIC => {\n-            let archs = object::macho::FatHeader::parse_arch32(&*archive_map);\n-            try_filter_fat_archs(archs, target_arch, archive_path, &*archive_map)\n+            let archs = object::macho::FatHeader::parse_arch32(archive_bytes);\n+            try_filter_fat_archs(archs, target_arch, archive_bytes)\n         }\n         Ok(h) if h.magic.get(object::endian::BigEndian) == object::macho::FAT_MAGIC_64 => {\n-            let archs = object::macho::FatHeader::parse_arch64(&*archive_map);\n-            try_filter_fat_archs(archs, target_arch, archive_path, &*archive_map)\n+            let archs = object::macho::FatHeader::parse_arch64(archive_bytes);\n+            try_filter_fat_archs(archs, target_arch, archive_bytes)\n         }\n         // Not a FatHeader at all, just return None.\n         _ => Ok(None),\n@@ -173,21 +164,24 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         archive_path: &Path,\n         mut skip: Box<dyn FnMut(&str) -> bool + 'static>,\n     ) -> io::Result<()> {\n-        let mut archive_path = archive_path.to_path_buf();\n-        if self.sess.target.llvm_target.contains(\"-apple-macosx\") {\n-            if let Some(new_archive_path) =\n-                try_extract_macho_fat_archive(&self.sess, &archive_path)?\n-            {\n-                archive_path = new_archive_path\n-            }\n-        }\n-\n+        let archive_map = unsafe { Mmap::map(File::open(&archive_path)?)? };\n         if self.src_archives.iter().any(|archive| archive.0 == archive_path) {\n             return Ok(());\n         }\n \n-        let archive_map = unsafe { Mmap::map(File::open(&archive_path)?)? };\n-        let archive = ArchiveFile::parse(&*archive_map)\n+        let (archive_bytes, offset) = if self.sess.target.llvm_target.contains(\"-apple-macosx\") {\n+            if let Some((sub_archive, archive_offset)) =\n+                try_extract_macho_fat_archive(&self.sess, &*archive_map)?\n+            {\n+                (sub_archive, Some(archive_offset))\n+            } else {\n+                (&*archive_map, None)\n+            }\n+        } else {\n+            (&*archive_map, None)\n+        };\n+\n+        let archive = ArchiveFile::parse(&*archive_bytes)\n             .map_err(|err| io::Error::new(io::ErrorKind::InvalidData, err))?;\n         let archive_index = self.src_archives.len();\n \n@@ -196,9 +190,13 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n             let file_name = String::from_utf8(entry.name().to_vec())\n                 .map_err(|err| io::Error::new(io::ErrorKind::InvalidData, err))?;\n             if !skip(&file_name) {\n+                let mut range = entry.file_range();\n+                if let Some(offset) = offset {\n+                    range.0 += offset;\n+                }\n                 self.entries.push((\n                     file_name.into_bytes(),\n-                    ArchiveEntry::FromArchive { archive_index, file_range: entry.file_range() },\n+                    ArchiveEntry::FromArchive { archive_index, file_range: range },\n                 ));\n             }\n         }"}, {"sha": "664697e0edaa406f5018d4a014fe7973730785f8", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -41,7 +41,6 @@ use rustc_span::{DebuggerVisualizerFile, DebuggerVisualizerType};\n use rustc_target::abi::{Align, Size, VariantIdx};\n \n use std::collections::BTreeSet;\n-use std::convert::TryFrom;\n use std::time::{Duration, Instant};\n \n use itertools::Itertools;"}, {"sha": "c7f2e1966c1edfb271c9ce884ebcca932c3c0827", "filename": "compiler/rustc_codegen_ssa/src/codegen_attrs.rs", "status": "added", "additions": 688, "deletions": 0, "changes": 688, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -0,0 +1,688 @@\n+use rustc_ast::{ast, MetaItemKind, NestedMetaItem};\n+use rustc_attr::{list_contains_name, InlineAttr, InstructionSetAttr, OptimizeAttr};\n+use rustc_errors::struct_span_err;\n+use rustc_hir as hir;\n+use rustc_hir::def_id::{DefId, LocalDefId, LOCAL_CRATE};\n+use rustc_hir::{lang_items, weak_lang_items::WEAK_LANG_ITEMS, LangItem};\n+use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n+use rustc_middle::mir::mono::Linkage;\n+use rustc_middle::ty::query::Providers;\n+use rustc_middle::ty::{self as ty, DefIdTree, TyCtxt};\n+use rustc_session::{lint, parse::feature_err};\n+use rustc_span::{sym, Span};\n+use rustc_target::spec::{abi, SanitizerSet};\n+\n+use crate::target_features::from_target_feature;\n+use crate::{errors::ExpectedUsedSymbol, target_features::check_target_feature_trait_unsafe};\n+\n+fn linkage_by_name(tcx: TyCtxt<'_>, def_id: LocalDefId, name: &str) -> Linkage {\n+    use rustc_middle::mir::mono::Linkage::*;\n+\n+    // Use the names from src/llvm/docs/LangRef.rst here. Most types are only\n+    // applicable to variable declarations and may not really make sense for\n+    // Rust code in the first place but allow them anyway and trust that the\n+    // user knows what they're doing. Who knows, unanticipated use cases may pop\n+    // up in the future.\n+    //\n+    // ghost, dllimport, dllexport and linkonce_odr_autohide are not supported\n+    // and don't have to be, LLVM treats them as no-ops.\n+    match name {\n+        \"appending\" => Appending,\n+        \"available_externally\" => AvailableExternally,\n+        \"common\" => Common,\n+        \"extern_weak\" => ExternalWeak,\n+        \"external\" => External,\n+        \"internal\" => Internal,\n+        \"linkonce\" => LinkOnceAny,\n+        \"linkonce_odr\" => LinkOnceODR,\n+        \"private\" => Private,\n+        \"weak\" => WeakAny,\n+        \"weak_odr\" => WeakODR,\n+        _ => tcx.sess.span_fatal(tcx.def_span(def_id), \"invalid linkage specified\"),\n+    }\n+}\n+\n+fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n+    if cfg!(debug_assertions) {\n+        let def_kind = tcx.def_kind(did);\n+        assert!(\n+            def_kind.has_codegen_attrs(),\n+            \"unexpected `def_kind` in `codegen_fn_attrs`: {def_kind:?}\",\n+        );\n+    }\n+\n+    let did = did.expect_local();\n+    let attrs = tcx.hir().attrs(tcx.hir().local_def_id_to_hir_id(did));\n+    let mut codegen_fn_attrs = CodegenFnAttrs::new();\n+    if tcx.should_inherit_track_caller(did) {\n+        codegen_fn_attrs.flags |= CodegenFnAttrFlags::TRACK_CALLER;\n+    }\n+\n+    let supported_target_features = tcx.supported_target_features(LOCAL_CRATE);\n+\n+    let mut inline_span = None;\n+    let mut link_ordinal_span = None;\n+    let mut no_sanitize_span = None;\n+    for attr in attrs.iter() {\n+        if attr.has_name(sym::cold) {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::COLD;\n+        } else if attr.has_name(sym::rustc_allocator) {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::ALLOCATOR;\n+        } else if attr.has_name(sym::ffi_returns_twice) {\n+            if tcx.is_foreign_item(did) {\n+                codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_RETURNS_TWICE;\n+            } else {\n+                // `#[ffi_returns_twice]` is only allowed `extern fn`s.\n+                struct_span_err!(\n+                    tcx.sess,\n+                    attr.span,\n+                    E0724,\n+                    \"`#[ffi_returns_twice]` may only be used on foreign functions\"\n+                )\n+                .emit();\n+            }\n+        } else if attr.has_name(sym::ffi_pure) {\n+            if tcx.is_foreign_item(did) {\n+                if attrs.iter().any(|a| a.has_name(sym::ffi_const)) {\n+                    // `#[ffi_const]` functions cannot be `#[ffi_pure]`\n+                    struct_span_err!(\n+                        tcx.sess,\n+                        attr.span,\n+                        E0757,\n+                        \"`#[ffi_const]` function cannot be `#[ffi_pure]`\"\n+                    )\n+                    .emit();\n+                } else {\n+                    codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_PURE;\n+                }\n+            } else {\n+                // `#[ffi_pure]` is only allowed on foreign functions\n+                struct_span_err!(\n+                    tcx.sess,\n+                    attr.span,\n+                    E0755,\n+                    \"`#[ffi_pure]` may only be used on foreign functions\"\n+                )\n+                .emit();\n+            }\n+        } else if attr.has_name(sym::ffi_const) {\n+            if tcx.is_foreign_item(did) {\n+                codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_CONST;\n+            } else {\n+                // `#[ffi_const]` is only allowed on foreign functions\n+                struct_span_err!(\n+                    tcx.sess,\n+                    attr.span,\n+                    E0756,\n+                    \"`#[ffi_const]` may only be used on foreign functions\"\n+                )\n+                .emit();\n+            }\n+        } else if attr.has_name(sym::rustc_nounwind) {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NEVER_UNWIND;\n+        } else if attr.has_name(sym::rustc_reallocator) {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::REALLOCATOR;\n+        } else if attr.has_name(sym::rustc_deallocator) {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::DEALLOCATOR;\n+        } else if attr.has_name(sym::rustc_allocator_zeroed) {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::ALLOCATOR_ZEROED;\n+        } else if attr.has_name(sym::naked) {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NAKED;\n+        } else if attr.has_name(sym::no_mangle) {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_MANGLE;\n+        } else if attr.has_name(sym::no_coverage) {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_COVERAGE;\n+        } else if attr.has_name(sym::rustc_std_internal_symbol) {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n+        } else if attr.has_name(sym::used) {\n+            let inner = attr.meta_item_list();\n+            match inner.as_deref() {\n+                Some([item]) if item.has_name(sym::linker) => {\n+                    if !tcx.features().used_with_arg {\n+                        feature_err(\n+                            &tcx.sess.parse_sess,\n+                            sym::used_with_arg,\n+                            attr.span,\n+                            \"`#[used(linker)]` is currently unstable\",\n+                        )\n+                        .emit();\n+                    }\n+                    codegen_fn_attrs.flags |= CodegenFnAttrFlags::USED_LINKER;\n+                }\n+                Some([item]) if item.has_name(sym::compiler) => {\n+                    if !tcx.features().used_with_arg {\n+                        feature_err(\n+                            &tcx.sess.parse_sess,\n+                            sym::used_with_arg,\n+                            attr.span,\n+                            \"`#[used(compiler)]` is currently unstable\",\n+                        )\n+                        .emit();\n+                    }\n+                    codegen_fn_attrs.flags |= CodegenFnAttrFlags::USED;\n+                }\n+                Some(_) => {\n+                    tcx.sess.emit_err(ExpectedUsedSymbol { span: attr.span });\n+                }\n+                None => {\n+                    // Unfortunately, unconditionally using `llvm.used` causes\n+                    // issues in handling `.init_array` with the gold linker,\n+                    // but using `llvm.compiler.used` caused a nontrival amount\n+                    // of unintentional ecosystem breakage -- particularly on\n+                    // Mach-O targets.\n+                    //\n+                    // As a result, we emit `llvm.compiler.used` only on ELF\n+                    // targets. This is somewhat ad-hoc, but actually follows\n+                    // our pre-LLVM 13 behavior (prior to the ecosystem\n+                    // breakage), and seems to match `clang`'s behavior as well\n+                    // (both before and after LLVM 13), possibly because they\n+                    // have similar compatibility concerns to us. See\n+                    // https://github.com/rust-lang/rust/issues/47384#issuecomment-1019080146\n+                    // and following comments for some discussion of this, as\n+                    // well as the comments in `rustc_codegen_llvm` where these\n+                    // flags are handled.\n+                    //\n+                    // Anyway, to be clear: this is still up in the air\n+                    // somewhat, and is subject to change in the future (which\n+                    // is a good thing, because this would ideally be a bit\n+                    // more firmed up).\n+                    let is_like_elf = !(tcx.sess.target.is_like_osx\n+                        || tcx.sess.target.is_like_windows\n+                        || tcx.sess.target.is_like_wasm);\n+                    codegen_fn_attrs.flags |= if is_like_elf {\n+                        CodegenFnAttrFlags::USED\n+                    } else {\n+                        CodegenFnAttrFlags::USED_LINKER\n+                    };\n+                }\n+            }\n+        } else if attr.has_name(sym::cmse_nonsecure_entry) {\n+            if !matches!(tcx.fn_sig(did).abi(), abi::Abi::C { .. }) {\n+                struct_span_err!(\n+                    tcx.sess,\n+                    attr.span,\n+                    E0776,\n+                    \"`#[cmse_nonsecure_entry]` requires C ABI\"\n+                )\n+                .emit();\n+            }\n+            if !tcx.sess.target.llvm_target.contains(\"thumbv8m\") {\n+                struct_span_err!(tcx.sess, attr.span, E0775, \"`#[cmse_nonsecure_entry]` is only valid for targets with the TrustZone-M extension\")\n+                    .emit();\n+            }\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::CMSE_NONSECURE_ENTRY;\n+        } else if attr.has_name(sym::thread_local) {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::THREAD_LOCAL;\n+        } else if attr.has_name(sym::track_caller) {\n+            if !tcx.is_closure(did.to_def_id()) && tcx.fn_sig(did).abi() != abi::Abi::Rust {\n+                struct_span_err!(tcx.sess, attr.span, E0737, \"`#[track_caller]` requires Rust ABI\")\n+                    .emit();\n+            }\n+            if tcx.is_closure(did.to_def_id()) && !tcx.features().closure_track_caller {\n+                feature_err(\n+                    &tcx.sess.parse_sess,\n+                    sym::closure_track_caller,\n+                    attr.span,\n+                    \"`#[track_caller]` on closures is currently unstable\",\n+                )\n+                .emit();\n+            }\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::TRACK_CALLER;\n+        } else if attr.has_name(sym::export_name) {\n+            if let Some(s) = attr.value_str() {\n+                if s.as_str().contains('\\0') {\n+                    // `#[export_name = ...]` will be converted to a null-terminated string,\n+                    // so it may not contain any null characters.\n+                    struct_span_err!(\n+                        tcx.sess,\n+                        attr.span,\n+                        E0648,\n+                        \"`export_name` may not contain null characters\"\n+                    )\n+                    .emit();\n+                }\n+                codegen_fn_attrs.export_name = Some(s);\n+            }\n+        } else if attr.has_name(sym::target_feature) {\n+            if !tcx.is_closure(did.to_def_id())\n+                && tcx.fn_sig(did).unsafety() == hir::Unsafety::Normal\n+            {\n+                if tcx.sess.target.is_like_wasm || tcx.sess.opts.actually_rustdoc {\n+                    // The `#[target_feature]` attribute is allowed on\n+                    // WebAssembly targets on all functions, including safe\n+                    // ones. Other targets require that `#[target_feature]` is\n+                    // only applied to unsafe functions (pending the\n+                    // `target_feature_11` feature) because on most targets\n+                    // execution of instructions that are not supported is\n+                    // considered undefined behavior. For WebAssembly which is a\n+                    // 100% safe target at execution time it's not possible to\n+                    // execute undefined instructions, and even if a future\n+                    // feature was added in some form for this it would be a\n+                    // deterministic trap. There is no undefined behavior when\n+                    // executing WebAssembly so `#[target_feature]` is allowed\n+                    // on safe functions (but again, only for WebAssembly)\n+                    //\n+                    // Note that this is also allowed if `actually_rustdoc` so\n+                    // if a target is documenting some wasm-specific code then\n+                    // it's not spuriously denied.\n+                } else if !tcx.features().target_feature_11 {\n+                    let mut err = feature_err(\n+                        &tcx.sess.parse_sess,\n+                        sym::target_feature_11,\n+                        attr.span,\n+                        \"`#[target_feature(..)]` can only be applied to `unsafe` functions\",\n+                    );\n+                    err.span_label(tcx.def_span(did), \"not an `unsafe` function\");\n+                    err.emit();\n+                } else {\n+                    check_target_feature_trait_unsafe(tcx, did, attr.span);\n+                }\n+            }\n+            from_target_feature(\n+                tcx,\n+                attr,\n+                supported_target_features,\n+                &mut codegen_fn_attrs.target_features,\n+            );\n+        } else if attr.has_name(sym::linkage) {\n+            if let Some(val) = attr.value_str() {\n+                let linkage = Some(linkage_by_name(tcx, did, val.as_str()));\n+                if tcx.is_foreign_item(did) {\n+                    codegen_fn_attrs.import_linkage = linkage;\n+                } else {\n+                    codegen_fn_attrs.linkage = linkage;\n+                }\n+            }\n+        } else if attr.has_name(sym::link_section) {\n+            if let Some(val) = attr.value_str() {\n+                if val.as_str().bytes().any(|b| b == 0) {\n+                    let msg = format!(\n+                        \"illegal null byte in link_section \\\n+                         value: `{}`\",\n+                        &val\n+                    );\n+                    tcx.sess.span_err(attr.span, &msg);\n+                } else {\n+                    codegen_fn_attrs.link_section = Some(val);\n+                }\n+            }\n+        } else if attr.has_name(sym::link_name) {\n+            codegen_fn_attrs.link_name = attr.value_str();\n+        } else if attr.has_name(sym::link_ordinal) {\n+            link_ordinal_span = Some(attr.span);\n+            if let ordinal @ Some(_) = check_link_ordinal(tcx, attr) {\n+                codegen_fn_attrs.link_ordinal = ordinal;\n+            }\n+        } else if attr.has_name(sym::no_sanitize) {\n+            no_sanitize_span = Some(attr.span);\n+            if let Some(list) = attr.meta_item_list() {\n+                for item in list.iter() {\n+                    if item.has_name(sym::address) {\n+                        codegen_fn_attrs.no_sanitize |= SanitizerSet::ADDRESS;\n+                    } else if item.has_name(sym::cfi) {\n+                        codegen_fn_attrs.no_sanitize |= SanitizerSet::CFI;\n+                    } else if item.has_name(sym::kcfi) {\n+                        codegen_fn_attrs.no_sanitize |= SanitizerSet::KCFI;\n+                    } else if item.has_name(sym::memory) {\n+                        codegen_fn_attrs.no_sanitize |= SanitizerSet::MEMORY;\n+                    } else if item.has_name(sym::memtag) {\n+                        codegen_fn_attrs.no_sanitize |= SanitizerSet::MEMTAG;\n+                    } else if item.has_name(sym::shadow_call_stack) {\n+                        codegen_fn_attrs.no_sanitize |= SanitizerSet::SHADOWCALLSTACK;\n+                    } else if item.has_name(sym::thread) {\n+                        codegen_fn_attrs.no_sanitize |= SanitizerSet::THREAD;\n+                    } else if item.has_name(sym::hwaddress) {\n+                        codegen_fn_attrs.no_sanitize |= SanitizerSet::HWADDRESS;\n+                    } else {\n+                        tcx.sess\n+                            .struct_span_err(item.span(), \"invalid argument for `no_sanitize`\")\n+                            .note(\"expected one of: `address`, `cfi`, `hwaddress`, `kcfi`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\")\n+                            .emit();\n+                    }\n+                }\n+            }\n+        } else if attr.has_name(sym::instruction_set) {\n+            codegen_fn_attrs.instruction_set = match attr.meta_kind() {\n+                Some(MetaItemKind::List(ref items)) => match items.as_slice() {\n+                    [NestedMetaItem::MetaItem(set)] => {\n+                        let segments =\n+                            set.path.segments.iter().map(|x| x.ident.name).collect::<Vec<_>>();\n+                        match segments.as_slice() {\n+                            [sym::arm, sym::a32] | [sym::arm, sym::t32] => {\n+                                if !tcx.sess.target.has_thumb_interworking {\n+                                    struct_span_err!(\n+                                        tcx.sess.diagnostic(),\n+                                        attr.span,\n+                                        E0779,\n+                                        \"target does not support `#[instruction_set]`\"\n+                                    )\n+                                    .emit();\n+                                    None\n+                                } else if segments[1] == sym::a32 {\n+                                    Some(InstructionSetAttr::ArmA32)\n+                                } else if segments[1] == sym::t32 {\n+                                    Some(InstructionSetAttr::ArmT32)\n+                                } else {\n+                                    unreachable!()\n+                                }\n+                            }\n+                            _ => {\n+                                struct_span_err!(\n+                                    tcx.sess.diagnostic(),\n+                                    attr.span,\n+                                    E0779,\n+                                    \"invalid instruction set specified\",\n+                                )\n+                                .emit();\n+                                None\n+                            }\n+                        }\n+                    }\n+                    [] => {\n+                        struct_span_err!(\n+                            tcx.sess.diagnostic(),\n+                            attr.span,\n+                            E0778,\n+                            \"`#[instruction_set]` requires an argument\"\n+                        )\n+                        .emit();\n+                        None\n+                    }\n+                    _ => {\n+                        struct_span_err!(\n+                            tcx.sess.diagnostic(),\n+                            attr.span,\n+                            E0779,\n+                            \"cannot specify more than one instruction set\"\n+                        )\n+                        .emit();\n+                        None\n+                    }\n+                },\n+                _ => {\n+                    struct_span_err!(\n+                        tcx.sess.diagnostic(),\n+                        attr.span,\n+                        E0778,\n+                        \"must specify an instruction set\"\n+                    )\n+                    .emit();\n+                    None\n+                }\n+            };\n+        } else if attr.has_name(sym::repr) {\n+            codegen_fn_attrs.alignment = match attr.meta_item_list() {\n+                Some(items) => match items.as_slice() {\n+                    [item] => match item.name_value_literal() {\n+                        Some((sym::align, literal)) => {\n+                            let alignment = rustc_attr::parse_alignment(&literal.kind);\n+\n+                            match alignment {\n+                                Ok(align) => Some(align),\n+                                Err(msg) => {\n+                                    struct_span_err!(\n+                                        tcx.sess.diagnostic(),\n+                                        attr.span,\n+                                        E0589,\n+                                        \"invalid `repr(align)` attribute: {}\",\n+                                        msg\n+                                    )\n+                                    .emit();\n+\n+                                    None\n+                                }\n+                            }\n+                        }\n+                        _ => None,\n+                    },\n+                    [] => None,\n+                    _ => None,\n+                },\n+                None => None,\n+            };\n+        }\n+    }\n+\n+    codegen_fn_attrs.inline = attrs.iter().fold(InlineAttr::None, |ia, attr| {\n+        if !attr.has_name(sym::inline) {\n+            return ia;\n+        }\n+        match attr.meta_kind() {\n+            Some(MetaItemKind::Word) => InlineAttr::Hint,\n+            Some(MetaItemKind::List(ref items)) => {\n+                inline_span = Some(attr.span);\n+                if items.len() != 1 {\n+                    struct_span_err!(\n+                        tcx.sess.diagnostic(),\n+                        attr.span,\n+                        E0534,\n+                        \"expected one argument\"\n+                    )\n+                    .emit();\n+                    InlineAttr::None\n+                } else if list_contains_name(&items, sym::always) {\n+                    InlineAttr::Always\n+                } else if list_contains_name(&items, sym::never) {\n+                    InlineAttr::Never\n+                } else {\n+                    struct_span_err!(\n+                        tcx.sess.diagnostic(),\n+                        items[0].span(),\n+                        E0535,\n+                        \"invalid argument\"\n+                    )\n+                    .help(\"valid inline arguments are `always` and `never`\")\n+                    .emit();\n+\n+                    InlineAttr::None\n+                }\n+            }\n+            Some(MetaItemKind::NameValue(_)) => ia,\n+            None => ia,\n+        }\n+    });\n+\n+    codegen_fn_attrs.optimize = attrs.iter().fold(OptimizeAttr::None, |ia, attr| {\n+        if !attr.has_name(sym::optimize) {\n+            return ia;\n+        }\n+        let err = |sp, s| struct_span_err!(tcx.sess.diagnostic(), sp, E0722, \"{}\", s).emit();\n+        match attr.meta_kind() {\n+            Some(MetaItemKind::Word) => {\n+                err(attr.span, \"expected one argument\");\n+                ia\n+            }\n+            Some(MetaItemKind::List(ref items)) => {\n+                inline_span = Some(attr.span);\n+                if items.len() != 1 {\n+                    err(attr.span, \"expected one argument\");\n+                    OptimizeAttr::None\n+                } else if list_contains_name(&items, sym::size) {\n+                    OptimizeAttr::Size\n+                } else if list_contains_name(&items, sym::speed) {\n+                    OptimizeAttr::Speed\n+                } else {\n+                    err(items[0].span(), \"invalid argument\");\n+                    OptimizeAttr::None\n+                }\n+            }\n+            Some(MetaItemKind::NameValue(_)) => ia,\n+            None => ia,\n+        }\n+    });\n+\n+    // #73631: closures inherit `#[target_feature]` annotations\n+    if tcx.features().target_feature_11 && tcx.is_closure(did.to_def_id()) {\n+        let owner_id = tcx.parent(did.to_def_id());\n+        if tcx.def_kind(owner_id).has_codegen_attrs() {\n+            codegen_fn_attrs\n+                .target_features\n+                .extend(tcx.codegen_fn_attrs(owner_id).target_features.iter().copied());\n+        }\n+    }\n+\n+    // If a function uses #[target_feature] it can't be inlined into general\n+    // purpose functions as they wouldn't have the right target features\n+    // enabled. For that reason we also forbid #[inline(always)] as it can't be\n+    // respected.\n+    if !codegen_fn_attrs.target_features.is_empty() {\n+        if codegen_fn_attrs.inline == InlineAttr::Always {\n+            if let Some(span) = inline_span {\n+                tcx.sess.span_err(\n+                    span,\n+                    \"cannot use `#[inline(always)]` with \\\n+                     `#[target_feature]`\",\n+                );\n+            }\n+        }\n+    }\n+\n+    if !codegen_fn_attrs.no_sanitize.is_empty() {\n+        if codegen_fn_attrs.inline == InlineAttr::Always {\n+            if let (Some(no_sanitize_span), Some(inline_span)) = (no_sanitize_span, inline_span) {\n+                let hir_id = tcx.hir().local_def_id_to_hir_id(did);\n+                tcx.struct_span_lint_hir(\n+                    lint::builtin::INLINE_NO_SANITIZE,\n+                    hir_id,\n+                    no_sanitize_span,\n+                    \"`no_sanitize` will have no effect after inlining\",\n+                    |lint| lint.span_note(inline_span, \"inlining requested here\"),\n+                )\n+            }\n+        }\n+    }\n+\n+    if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::NAKED) {\n+        codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_COVERAGE;\n+        codegen_fn_attrs.inline = InlineAttr::Never;\n+    }\n+\n+    // Weak lang items have the same semantics as \"std internal\" symbols in the\n+    // sense that they're preserved through all our LTO passes and only\n+    // strippable by the linker.\n+    //\n+    // Additionally weak lang items have predetermined symbol names.\n+    if WEAK_LANG_ITEMS.iter().any(|&l| tcx.lang_items().get(l) == Some(did.to_def_id())) {\n+        codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n+    }\n+    if let Some((name, _)) = lang_items::extract(attrs)\n+        && let Some(lang_item) = LangItem::from_name(name)\n+        && let Some(link_name) = lang_item.link_name()\n+    {\n+        codegen_fn_attrs.export_name = Some(link_name);\n+        codegen_fn_attrs.link_name = Some(link_name);\n+    }\n+    check_link_name_xor_ordinal(tcx, &codegen_fn_attrs, link_ordinal_span);\n+\n+    // Internal symbols to the standard library all have no_mangle semantics in\n+    // that they have defined symbol names present in the function name. This\n+    // also applies to weak symbols where they all have known symbol names.\n+    if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL) {\n+        codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_MANGLE;\n+    }\n+\n+    // Any linkage to LLVM intrinsics for now forcibly marks them all as never\n+    // unwinds since LLVM sometimes can't handle codegen which `invoke`s\n+    // intrinsic functions.\n+    if let Some(name) = &codegen_fn_attrs.link_name {\n+        if name.as_str().starts_with(\"llvm.\") {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NEVER_UNWIND;\n+        }\n+    }\n+\n+    codegen_fn_attrs\n+}\n+\n+/// Checks if the provided DefId is a method in a trait impl for a trait which has track_caller\n+/// applied to the method prototype.\n+fn should_inherit_track_caller(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+    if let Some(impl_item) = tcx.opt_associated_item(def_id)\n+        && let ty::AssocItemContainer::ImplContainer = impl_item.container\n+        && let Some(trait_item) = impl_item.trait_item_def_id\n+    {\n+        return tcx\n+            .codegen_fn_attrs(trait_item)\n+            .flags\n+            .intersects(CodegenFnAttrFlags::TRACK_CALLER);\n+    }\n+\n+    false\n+}\n+\n+fn check_link_ordinal(tcx: TyCtxt<'_>, attr: &ast::Attribute) -> Option<u16> {\n+    use rustc_ast::{LitIntType, LitKind, MetaItemLit};\n+    if !tcx.features().raw_dylib && tcx.sess.target.arch == \"x86\" {\n+        feature_err(\n+            &tcx.sess.parse_sess,\n+            sym::raw_dylib,\n+            attr.span,\n+            \"`#[link_ordinal]` is unstable on x86\",\n+        )\n+        .emit();\n+    }\n+    let meta_item_list = attr.meta_item_list();\n+    let meta_item_list = meta_item_list.as_deref();\n+    let sole_meta_list = match meta_item_list {\n+        Some([item]) => item.lit(),\n+        Some(_) => {\n+            tcx.sess\n+                .struct_span_err(attr.span, \"incorrect number of arguments to `#[link_ordinal]`\")\n+                .note(\"the attribute requires exactly one argument\")\n+                .emit();\n+            return None;\n+        }\n+        _ => None,\n+    };\n+    if let Some(MetaItemLit { kind: LitKind::Int(ordinal, LitIntType::Unsuffixed), .. }) =\n+        sole_meta_list\n+    {\n+        // According to the table at https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#import-header,\n+        // the ordinal must fit into 16 bits.  Similarly, the Ordinal field in COFFShortExport (defined\n+        // in llvm/include/llvm/Object/COFFImportFile.h), which we use to communicate import information\n+        // to LLVM for `#[link(kind = \"raw-dylib\"_])`, is also defined to be uint16_t.\n+        //\n+        // FIXME: should we allow an ordinal of 0?  The MSVC toolchain has inconsistent support for this:\n+        // both LINK.EXE and LIB.EXE signal errors and abort when given a .DEF file that specifies\n+        // a zero ordinal.  However, llvm-dlltool is perfectly happy to generate an import library\n+        // for such a .DEF file, and MSVC's LINK.EXE is also perfectly happy to consume an import\n+        // library produced by LLVM with an ordinal of 0, and it generates an .EXE.  (I don't know yet\n+        // if the resulting EXE runs, as I haven't yet built the necessary DLL -- see earlier comment\n+        // about LINK.EXE failing.)\n+        if *ordinal <= u16::MAX as u128 {\n+            Some(*ordinal as u16)\n+        } else {\n+            let msg = format!(\"ordinal value in `link_ordinal` is too large: `{}`\", &ordinal);\n+            tcx.sess\n+                .struct_span_err(attr.span, &msg)\n+                .note(\"the value may not exceed `u16::MAX`\")\n+                .emit();\n+            None\n+        }\n+    } else {\n+        tcx.sess\n+            .struct_span_err(attr.span, \"illegal ordinal format in `link_ordinal`\")\n+            .note(\"an unsuffixed integer value, e.g., `1`, is expected\")\n+            .emit();\n+        None\n+    }\n+}\n+\n+fn check_link_name_xor_ordinal(\n+    tcx: TyCtxt<'_>,\n+    codegen_fn_attrs: &CodegenFnAttrs,\n+    inline_span: Option<Span>,\n+) {\n+    if codegen_fn_attrs.link_name.is_none() || codegen_fn_attrs.link_ordinal.is_none() {\n+        return;\n+    }\n+    let msg = \"cannot use `#[link_name]` with `#[link_ordinal]`\";\n+    if let Some(span) = inline_span {\n+        tcx.sess.span_err(span, msg);\n+    } else {\n+        tcx.sess.err(msg);\n+    }\n+}\n+\n+pub fn provide(providers: &mut Providers) {\n+    *providers = Providers { codegen_fn_attrs, should_inherit_track_caller, ..*providers };\n+}"}, {"sha": "819c2678d6c4d4ccead480763760400e56cae706", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -235,7 +235,7 @@ fn push_debuginfo_type_name<'tcx>(\n                 let projection_bounds: SmallVec<[_; 4]> = trait_data\n                     .projection_bounds()\n                     .map(|bound| {\n-                        let ExistentialProjection { item_def_id, term, .. } =\n+                        let ExistentialProjection { def_id: item_def_id, term, .. } =\n                             tcx.erase_late_bound_regions(bound);\n                         // FIXME(associated_const_equality): allow for consts here\n                         (item_def_id, term.ty().unwrap())\n@@ -411,9 +411,8 @@ fn push_debuginfo_type_name<'tcx>(\n         ty::Error(_)\n         | ty::Infer(_)\n         | ty::Placeholder(..)\n-        | ty::Projection(..)\n+        | ty::Alias(..)\n         | ty::Bound(..)\n-        | ty::Opaque(..)\n         | ty::GeneratorWitness(..) => {\n             bug!(\n                 \"debuginfo: Trying to create type name for \\"}, {"sha": "0620000201f0254f81ff6dd4200876324b02fd0a", "filename": "compiler/rustc_codegen_ssa/src/errors.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -548,3 +548,10 @@ pub struct ArchiveBuildFailure {\n pub struct UnknownArchiveKind<'a> {\n     pub kind: &'a str,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_expected_used_symbol)]\n+pub struct ExpectedUsedSymbol {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "0e6596d4ba781bfd7a859a0329105f26a7a2ef60", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -42,6 +42,7 @@ use std::path::{Path, PathBuf};\n \n pub mod back;\n pub mod base;\n+pub mod codegen_attrs;\n pub mod common;\n pub mod coverageinfo;\n pub mod debuginfo;\n@@ -180,6 +181,7 @@ pub fn provide(providers: &mut Providers) {\n     crate::back::symbol_export::provide(providers);\n     crate::base::provide(providers);\n     crate::target_features::provide(providers);\n+    crate::codegen_attrs::provide(providers);\n }\n \n pub fn provide_extern(providers: &mut ExternProviders) {"}, {"sha": "d96ca921f1f4d90d931a01c5945e1c9dd584728b", "filename": "compiler/rustc_codegen_ssa/src/meth.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -31,8 +31,7 @@ impl<'a, 'tcx> VirtualIndex {\n             let typeid =\n                 bx.typeid_metadata(typeid_for_trait_ref(bx.tcx(), expect_dyn_trait_in_self(ty)));\n             let vtable_byte_offset = self.0 * bx.data_layout().pointer_size.bytes();\n-            let type_checked_load = bx.type_checked_load(llvtable, vtable_byte_offset, typeid);\n-            let func = bx.extract_value(type_checked_load, 0);\n+            let func = bx.type_checked_load(llvtable, vtable_byte_offset, typeid);\n             bx.pointercast(func, llty)\n         } else {\n             let ptr_align = bx.tcx().data_layout.pointer_align.abi;"}, {"sha": "3860138018bb14c2a69bdfe4a5cfc37bfc1e6da3", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -289,16 +289,13 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             bx.cleanup_ret(funclet, None);\n         } else {\n             let slot = self.get_personality_slot(bx);\n-            let lp0 = slot.project_field(bx, 0);\n-            let lp0 = bx.load_operand(lp0).immediate();\n-            let lp1 = slot.project_field(bx, 1);\n-            let lp1 = bx.load_operand(lp1).immediate();\n+            let exn0 = slot.project_field(bx, 0);\n+            let exn0 = bx.load_operand(exn0).immediate();\n+            let exn1 = slot.project_field(bx, 1);\n+            let exn1 = bx.load_operand(exn1).immediate();\n             slot.storage_dead(bx);\n \n-            let mut lp = bx.const_undef(self.landing_pad_type());\n-            lp = bx.insert_value(lp, lp0, 0);\n-            lp = bx.insert_value(lp, lp1, 1);\n-            bx.resume(lp);\n+            bx.resume(exn0, exn1);\n         }\n     }\n \n@@ -751,10 +748,13 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let (instance, mut llfn) = match *callee.layout.ty.kind() {\n             ty::FnDef(def_id, substs) => (\n                 Some(\n-                    ty::Instance::resolve(bx.tcx(), ty::ParamEnv::reveal_all(), def_id, substs)\n-                        .unwrap()\n-                        .unwrap()\n-                        .polymorphize(bx.tcx()),\n+                    ty::Instance::expect_resolve(\n+                        bx.tcx(),\n+                        ty::ParamEnv::reveal_all(),\n+                        def_id,\n+                        substs,\n+                    )\n+                    .polymorphize(bx.tcx()),\n                 ),\n                 None,\n             ),\n@@ -1633,24 +1633,17 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             let mut cleanup_bx = Bx::build(self.cx, cleanup_llbb);\n \n             let llpersonality = self.cx.eh_personality();\n-            let llretty = self.landing_pad_type();\n-            let lp = cleanup_bx.cleanup_landing_pad(llretty, llpersonality);\n+            let (exn0, exn1) = cleanup_bx.cleanup_landing_pad(llpersonality);\n \n             let slot = self.get_personality_slot(&mut cleanup_bx);\n             slot.storage_live(&mut cleanup_bx);\n-            Pair(cleanup_bx.extract_value(lp, 0), cleanup_bx.extract_value(lp, 1))\n-                .store(&mut cleanup_bx, slot);\n+            Pair(exn0, exn1).store(&mut cleanup_bx, slot);\n \n             cleanup_bx.br(llbb);\n             cleanup_llbb\n         }\n     }\n \n-    fn landing_pad_type(&self) -> Bx::Type {\n-        let cx = self.cx;\n-        cx.type_struct(&[cx.type_i8p(), cx.type_i32()], false)\n-    }\n-\n     fn unreachable_block(&mut self) -> Bx::BasicBlock {\n         self.unreachable_block.unwrap_or_else(|| {\n             let llbb = Bx::append_block(self.cx, self.llfn, \"unreachable\");\n@@ -1670,8 +1663,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             self.set_debug_loc(&mut bx, mir::SourceInfo::outermost(self.mir.span));\n \n             let llpersonality = self.cx.eh_personality();\n-            let llretty = self.landing_pad_type();\n-            bx.cleanup_landing_pad(llretty, llpersonality);\n+            bx.cleanup_landing_pad(llpersonality);\n \n             let (fn_abi, fn_ptr) = common::build_langcall(&bx, None, LangItem::PanicNoUnwind);\n             let fn_ty = bx.fn_decl_backend_type(&fn_abi);\n@@ -1810,15 +1802,20 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         match (src.layout.abi, dst.layout.abi) {\n             (abi::Abi::Scalar(src_scalar), abi::Abi::Scalar(dst_scalar)) => {\n                 // HACK(eddyb) LLVM doesn't like `bitcast`s between pointers and non-pointers.\n-                if (src_scalar.primitive() == abi::Pointer)\n-                    == (dst_scalar.primitive() == abi::Pointer)\n-                {\n+                let src_is_ptr = src_scalar.primitive() == abi::Pointer;\n+                let dst_is_ptr = dst_scalar.primitive() == abi::Pointer;\n+                if src_is_ptr == dst_is_ptr {\n                     assert_eq!(src.layout.size, dst.layout.size);\n \n                     // NOTE(eddyb) the `from_immediate` and `to_immediate_scalar`\n                     // conversions allow handling `bool`s the same as `u8`s.\n                     let src = bx.from_immediate(src.immediate());\n-                    let src_as_dst = bx.bitcast(src, bx.backend_type(dst.layout));\n+                    // LLVM also doesn't like `bitcast`s between pointers in different address spaces.\n+                    let src_as_dst = if src_is_ptr {\n+                        bx.pointercast(src, bx.backend_type(dst.layout))\n+                    } else {\n+                        bx.bitcast(src, bx.backend_type(dst.layout))\n+                    };\n                     Immediate(bx.to_immediate_scalar(src_as_dst, dst_scalar)).store(bx, dst);\n                     return;\n                 }"}, {"sha": "23196c8cbaea1ebf4f3d9c9e9d82ab681d9aa5b6", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -462,7 +462,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 assert!(bx.cx().tcx().is_static(def_id));\n                 let static_ = bx.get_static(def_id);\n                 let layout = bx.layout_of(bx.cx().tcx().static_ptr_ty(def_id));\n-                OperandRef::from_immediate_or_packed_pair(bx, static_, layout)\n+                OperandRef { val: OperandValue::Immediate(static_), layout }\n             }\n             mir::Rvalue::Use(ref operand) => self.codegen_operand(bx, operand),\n             mir::Rvalue::Repeat(..) | mir::Rvalue::Aggregate(..) => {"}, {"sha": "0dabe96b60277e032ad0214d2260277915f6a02d", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 154, "deletions": 10, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,8 +1,19 @@\n+use rustc_ast::ast;\n+use rustc_attr::InstructionSetAttr;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::LocalDefId;\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::ty::query::Providers;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_session::parse::feature_err;\n use rustc_session::Session;\n use rustc_span::symbol::sym;\n use rustc_span::symbol::Symbol;\n+use rustc_span::Span;\n \n /// Features that control behaviour of rustc, rather than the codegen.\n pub const RUSTC_SPECIFIC_FEATURES: &[&str] = &[\"crt-static\"];\n@@ -322,15 +333,148 @@ pub fn tied_target_features(sess: &Session) -> &'static [&'static [&'static str]\n     }\n }\n \n-pub(crate) fn provide(providers: &mut Providers) {\n-    providers.supported_target_features = |tcx, cnum| {\n-        assert_eq!(cnum, LOCAL_CRATE);\n-        if tcx.sess.opts.actually_rustdoc {\n-            // rustdoc needs to be able to document functions that use all the features, so\n-            // whitelist them all\n-            all_known_features().map(|(a, b)| (a.to_string(), b)).collect()\n-        } else {\n-            supported_target_features(tcx.sess).iter().map(|&(a, b)| (a.to_string(), b)).collect()\n-        }\n+pub fn from_target_feature(\n+    tcx: TyCtxt<'_>,\n+    attr: &ast::Attribute,\n+    supported_target_features: &FxHashMap<String, Option<Symbol>>,\n+    target_features: &mut Vec<Symbol>,\n+) {\n+    let Some(list) = attr.meta_item_list() else { return };\n+    let bad_item = |span| {\n+        let msg = \"malformed `target_feature` attribute input\";\n+        let code = \"enable = \\\"..\\\"\";\n+        tcx.sess\n+            .struct_span_err(span, msg)\n+            .span_suggestion(span, \"must be of the form\", code, Applicability::HasPlaceholders)\n+            .emit();\n     };\n+    let rust_features = tcx.features();\n+    for item in list {\n+        // Only `enable = ...` is accepted in the meta-item list.\n+        if !item.has_name(sym::enable) {\n+            bad_item(item.span());\n+            continue;\n+        }\n+\n+        // Must be of the form `enable = \"...\"` (a string).\n+        let Some(value) = item.value_str() else {\n+            bad_item(item.span());\n+            continue;\n+        };\n+\n+        // We allow comma separation to enable multiple features.\n+        target_features.extend(value.as_str().split(',').filter_map(|feature| {\n+            let Some(feature_gate) = supported_target_features.get(feature) else {\n+                let msg =\n+                    format!(\"the feature named `{}` is not valid for this target\", feature);\n+                let mut err = tcx.sess.struct_span_err(item.span(), &msg);\n+                err.span_label(\n+                    item.span(),\n+                    format!(\"`{}` is not valid for this target\", feature),\n+                );\n+                if let Some(stripped) = feature.strip_prefix('+') {\n+                    let valid = supported_target_features.contains_key(stripped);\n+                    if valid {\n+                        err.help(\"consider removing the leading `+` in the feature name\");\n+                    }\n+                }\n+                err.emit();\n+                return None;\n+            };\n+\n+            // Only allow features whose feature gates have been enabled.\n+            let allowed = match feature_gate.as_ref().copied() {\n+                Some(sym::arm_target_feature) => rust_features.arm_target_feature,\n+                Some(sym::hexagon_target_feature) => rust_features.hexagon_target_feature,\n+                Some(sym::powerpc_target_feature) => rust_features.powerpc_target_feature,\n+                Some(sym::mips_target_feature) => rust_features.mips_target_feature,\n+                Some(sym::riscv_target_feature) => rust_features.riscv_target_feature,\n+                Some(sym::avx512_target_feature) => rust_features.avx512_target_feature,\n+                Some(sym::sse4a_target_feature) => rust_features.sse4a_target_feature,\n+                Some(sym::tbm_target_feature) => rust_features.tbm_target_feature,\n+                Some(sym::wasm_target_feature) => rust_features.wasm_target_feature,\n+                Some(sym::cmpxchg16b_target_feature) => rust_features.cmpxchg16b_target_feature,\n+                Some(sym::movbe_target_feature) => rust_features.movbe_target_feature,\n+                Some(sym::rtm_target_feature) => rust_features.rtm_target_feature,\n+                Some(sym::f16c_target_feature) => rust_features.f16c_target_feature,\n+                Some(sym::ermsb_target_feature) => rust_features.ermsb_target_feature,\n+                Some(sym::bpf_target_feature) => rust_features.bpf_target_feature,\n+                Some(sym::aarch64_ver_target_feature) => rust_features.aarch64_ver_target_feature,\n+                Some(name) => bug!(\"unknown target feature gate {}\", name),\n+                None => true,\n+            };\n+            if !allowed {\n+                feature_err(\n+                    &tcx.sess.parse_sess,\n+                    feature_gate.unwrap(),\n+                    item.span(),\n+                    &format!(\"the target feature `{}` is currently unstable\", feature),\n+                )\n+                .emit();\n+            }\n+            Some(Symbol::intern(feature))\n+        }));\n+    }\n+}\n+\n+/// Computes the set of target features used in a function for the purposes of\n+/// inline assembly.\n+fn asm_target_features<'tcx>(tcx: TyCtxt<'tcx>, did: DefId) -> &'tcx FxHashSet<Symbol> {\n+    let mut target_features = tcx.sess.unstable_target_features.clone();\n+    if tcx.def_kind(did).has_codegen_attrs() {\n+        let attrs = tcx.codegen_fn_attrs(did);\n+        target_features.extend(&attrs.target_features);\n+        match attrs.instruction_set {\n+            None => {}\n+            Some(InstructionSetAttr::ArmA32) => {\n+                target_features.remove(&sym::thumb_mode);\n+            }\n+            Some(InstructionSetAttr::ArmT32) => {\n+                target_features.insert(sym::thumb_mode);\n+            }\n+        }\n+    }\n+\n+    tcx.arena.alloc(target_features)\n+}\n+\n+/// Checks the function annotated with `#[target_feature]` is not a safe\n+/// trait method implementation, reporting an error if it is.\n+pub fn check_target_feature_trait_unsafe(tcx: TyCtxt<'_>, id: LocalDefId, attr_span: Span) {\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(id);\n+    let node = tcx.hir().get(hir_id);\n+    if let hir::Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }) = node {\n+        let parent_id = tcx.hir().get_parent_item(hir_id);\n+        let parent_item = tcx.hir().expect_item(parent_id.def_id);\n+        if let hir::ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }) = parent_item.kind {\n+            tcx.sess\n+                .struct_span_err(\n+                    attr_span,\n+                    \"`#[target_feature(..)]` cannot be applied to safe trait method\",\n+                )\n+                .span_label(attr_span, \"cannot be applied to safe trait method\")\n+                .span_label(tcx.def_span(id), \"not an `unsafe` function\")\n+                .emit();\n+        }\n+    }\n+}\n+\n+pub(crate) fn provide(providers: &mut Providers) {\n+    *providers = Providers {\n+        supported_target_features: |tcx, cnum| {\n+            assert_eq!(cnum, LOCAL_CRATE);\n+            if tcx.sess.opts.actually_rustdoc {\n+                // rustdoc needs to be able to document functions that use all the features, so\n+                // whitelist them all\n+                all_known_features().map(|(a, b)| (a.to_string(), b)).collect()\n+            } else {\n+                supported_target_features(tcx.sess)\n+                    .iter()\n+                    .map(|&(a, b)| (a.to_string(), b))\n+                    .collect()\n+            }\n+        },\n+        asm_target_features,\n+        ..*providers\n+    }\n }"}, {"sha": "194768d946674e4ae28c1a1bf7abb352def8dd63", "filename": "compiler/rustc_codegen_ssa/src/traits/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -271,8 +271,8 @@ pub trait BuilderMethods<'a, 'tcx>:\n     fn set_personality_fn(&mut self, personality: Self::Value);\n \n     // These are used by everyone except msvc\n-    fn cleanup_landing_pad(&mut self, ty: Self::Type, pers_fn: Self::Value) -> Self::Value;\n-    fn resume(&mut self, exn: Self::Value);\n+    fn cleanup_landing_pad(&mut self, pers_fn: Self::Value) -> (Self::Value, Self::Value);\n+    fn resume(&mut self, exn0: Self::Value, exn1: Self::Value);\n \n     // These are used only by msvc\n     fn cleanup_pad(&mut self, parent: Option<Self::Value>, args: &[Self::Value]) -> Self::Funclet;"}, {"sha": "13472cc2bfa0a5c4b8ed7ba81baa6eb3114ac9f9", "filename": "compiler/rustc_const_eval/src/const_eval/error.rs", "status": "modified", "additions": 65, "deletions": 70, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -86,6 +86,59 @@ impl<'tcx> ConstEvalErr<'tcx> {\n         self.report_decorated(tcx, message, |_| {})\n     }\n \n+    #[instrument(level = \"trace\", skip(self, decorate))]\n+    pub(super) fn decorate(&self, err: &mut Diagnostic, decorate: impl FnOnce(&mut Diagnostic)) {\n+        trace!(\"reporting const eval failure at {:?}\", self.span);\n+        // Add some more context for select error types.\n+        match self.error {\n+            InterpError::Unsupported(\n+                UnsupportedOpInfo::ReadPointerAsBytes\n+                | UnsupportedOpInfo::PartialPointerOverwrite(_)\n+                | UnsupportedOpInfo::PartialPointerCopy(_),\n+            ) => {\n+                err.help(\"this code performed an operation that depends on the underlying bytes representing a pointer\");\n+                err.help(\"the absolute address of a pointer is not known at compile-time, so such operations are not supported\");\n+            }\n+            _ => {}\n+        }\n+        // Add spans for the stacktrace. Don't print a single-line backtrace though.\n+        if self.stacktrace.len() > 1 {\n+            // Helper closure to print duplicated lines.\n+            let mut flush_last_line = |last_frame, times| {\n+                if let Some((line, span)) = last_frame {\n+                    err.span_note(span, &line);\n+                    // Don't print [... additional calls ...] if the number of lines is small\n+                    if times < 3 {\n+                        for _ in 0..times {\n+                            err.span_note(span, &line);\n+                        }\n+                    } else {\n+                        err.span_note(\n+                            span,\n+                            format!(\"[... {} additional calls {} ...]\", times, &line),\n+                        );\n+                    }\n+                }\n+            };\n+\n+            let mut last_frame = None;\n+            let mut times = 0;\n+            for frame_info in &self.stacktrace {\n+                let frame = (frame_info.to_string(), frame_info.span);\n+                if last_frame.as_ref() == Some(&frame) {\n+                    times += 1;\n+                } else {\n+                    flush_last_line(last_frame, times);\n+                    last_frame = Some(frame);\n+                    times = 0;\n+                }\n+            }\n+            flush_last_line(last_frame, times);\n+        }\n+        // Let the caller attach any additional information it wants.\n+        decorate(err);\n+    }\n+\n     /// Create a diagnostic for this const eval error.\n     ///\n     /// Sets the message passed in via `message` and adds span labels with detailed error\n@@ -101,88 +154,30 @@ impl<'tcx> ConstEvalErr<'tcx> {\n         message: &str,\n         decorate: impl FnOnce(&mut Diagnostic),\n     ) -> ErrorHandled {\n-        let finish = |err: &mut Diagnostic, span_msg: Option<String>| {\n-            trace!(\"reporting const eval failure at {:?}\", self.span);\n-            if let Some(span_msg) = span_msg {\n-                err.span_label(self.span, span_msg);\n-            }\n-            // Add some more context for select error types.\n-            match self.error {\n-                InterpError::Unsupported(\n-                    UnsupportedOpInfo::ReadPointerAsBytes\n-                    | UnsupportedOpInfo::PartialPointerOverwrite(_)\n-                    | UnsupportedOpInfo::PartialPointerCopy(_),\n-                ) => {\n-                    err.help(\"this code performed an operation that depends on the underlying bytes representing a pointer\");\n-                    err.help(\"the absolute address of a pointer is not known at compile-time, so such operations are not supported\");\n-                }\n-                _ => {}\n-            }\n-            // Add spans for the stacktrace. Don't print a single-line backtrace though.\n-            if self.stacktrace.len() > 1 {\n-                // Helper closure to print duplicated lines.\n-                let mut flush_last_line = |last_frame, times| {\n-                    if let Some((line, span)) = last_frame {\n-                        err.span_note(span, &line);\n-                        // Don't print [... additional calls ...] if the number of lines is small\n-                        if times < 3 {\n-                            for _ in 0..times {\n-                                err.span_note(span, &line);\n-                            }\n-                        } else {\n-                            err.span_note(\n-                                span,\n-                                format!(\"[... {} additional calls {} ...]\", times, &line),\n-                            );\n-                        }\n-                    }\n-                };\n-\n-                let mut last_frame = None;\n-                let mut times = 0;\n-                for frame_info in &self.stacktrace {\n-                    let frame = (frame_info.to_string(), frame_info.span);\n-                    if last_frame.as_ref() == Some(&frame) {\n-                        times += 1;\n-                    } else {\n-                        flush_last_line(last_frame, times);\n-                        last_frame = Some(frame);\n-                        times = 0;\n-                    }\n-                }\n-                flush_last_line(last_frame, times);\n-            }\n-            // Let the caller attach any additional information it wants.\n-            decorate(err);\n-        };\n-\n         debug!(\"self.error: {:?}\", self.error);\n         // Special handling for certain errors\n         match &self.error {\n             // Don't emit a new diagnostic for these errors\n             err_inval!(Layout(LayoutError::Unknown(_))) | err_inval!(TooGeneric) => {\n-                return ErrorHandled::TooGeneric;\n-            }\n-            err_inval!(AlreadyReported(error_reported)) => {\n-                return ErrorHandled::Reported(*error_reported);\n+                ErrorHandled::TooGeneric\n             }\n+            err_inval!(AlreadyReported(error_reported)) => ErrorHandled::Reported(*error_reported),\n             err_inval!(Layout(LayoutError::SizeOverflow(_))) => {\n                 // We must *always* hard error on these, even if the caller wants just a lint.\n                 // The `message` makes little sense here, this is a more serious error than the\n                 // caller thinks anyway.\n                 // See <https://github.com/rust-lang/rust/pull/63152>.\n                 let mut err = struct_error(tcx, &self.error.to_string());\n-                finish(&mut err, None);\n-                return ErrorHandled::Reported(err.emit());\n+                self.decorate(&mut err, decorate);\n+                ErrorHandled::Reported(err.emit())\n             }\n-            _ => {}\n-        };\n-\n-        let err_msg = self.error.to_string();\n-\n-        // Report as hard error.\n-        let mut err = struct_error(tcx, message);\n-        finish(&mut err, Some(err_msg));\n-        ErrorHandled::Reported(err.emit())\n+            _ => {\n+                // Report as hard error.\n+                let mut err = struct_error(tcx, message);\n+                err.span_label(self.span, self.error.to_string());\n+                self.decorate(&mut err, decorate);\n+                ErrorHandled::Reported(err.emit())\n+            }\n+        }\n     }\n }"}, {"sha": "18e01567ca35e44888e52e19abd6bb07edca0d0e", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,5 +1,5 @@\n+use crate::const_eval::CheckAlignment;\n use std::borrow::Cow;\n-use std::convert::TryInto;\n \n use either::{Left, Right};\n \n@@ -77,7 +77,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n             None => InternKind::Constant,\n         }\n     };\n-    ecx.machine.check_alignment = false; // interning doesn't need to respect alignment\n+    ecx.machine.check_alignment = CheckAlignment::No; // interning doesn't need to respect alignment\n     intern_const_alloc_recursive(ecx, intern_kind, &ret)?;\n     // we leave alignment checks off, since this `ecx` will not be used for further evaluation anyway\n \n@@ -103,11 +103,7 @@ pub(super) fn mk_eval_cx<'mir, 'tcx>(\n         tcx,\n         root_span,\n         param_env,\n-        CompileTimeInterpreter::new(\n-            tcx.const_eval_limit(),\n-            can_access_statics,\n-            /*check_alignment:*/ false,\n-        ),\n+        CompileTimeInterpreter::new(tcx.const_eval_limit(), can_access_statics, CheckAlignment::No),\n     )\n }\n \n@@ -312,7 +308,11 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n         CompileTimeInterpreter::new(\n             tcx.const_eval_limit(),\n             /*can_access_statics:*/ is_static,\n-            /*check_alignment:*/ tcx.sess.opts.unstable_opts.extra_const_ub_checks,\n+            if tcx.sess.opts.unstable_opts.extra_const_ub_checks {\n+                CheckAlignment::Error\n+            } else {\n+                CheckAlignment::FutureIncompat\n+            },\n         ),\n     );\n "}, {"sha": "e006a62feeabd12bc568da7c5c42e76bdde1cc2f", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 55, "deletions": 4, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,9 +1,10 @@\n use rustc_hir::def::DefKind;\n-use rustc_hir::LangItem;\n+use rustc_hir::{LangItem, CRATE_HIR_ID};\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::PointerArithmetic;\n use rustc_middle::ty::layout::FnAbiOf;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_session::lint::builtin::INVALID_ALIGNMENT;\n use std::borrow::Borrow;\n use std::hash::Hash;\n use std::ops::ControlFlow;\n@@ -47,14 +48,34 @@ pub struct CompileTimeInterpreter<'mir, 'tcx> {\n     pub(super) can_access_statics: bool,\n \n     /// Whether to check alignment during evaluation.\n-    pub(super) check_alignment: bool,\n+    pub(super) check_alignment: CheckAlignment,\n+}\n+\n+#[derive(Copy, Clone)]\n+pub enum CheckAlignment {\n+    /// Ignore alignment when following relocations.\n+    /// This is mainly used in interning.\n+    No,\n+    /// Hard error when dereferencing a misaligned pointer.\n+    Error,\n+    /// Emit a future incompat lint when dereferencing a misaligned pointer.\n+    FutureIncompat,\n+}\n+\n+impl CheckAlignment {\n+    pub fn should_check(&self) -> bool {\n+        match self {\n+            CheckAlignment::No => false,\n+            CheckAlignment::Error | CheckAlignment::FutureIncompat => true,\n+        }\n+    }\n }\n \n impl<'mir, 'tcx> CompileTimeInterpreter<'mir, 'tcx> {\n     pub(crate) fn new(\n         const_eval_limit: Limit,\n         can_access_statics: bool,\n-        check_alignment: bool,\n+        check_alignment: CheckAlignment,\n     ) -> Self {\n         CompileTimeInterpreter {\n             steps_remaining: const_eval_limit.0,\n@@ -309,7 +330,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     const PANIC_ON_ALLOC_FAIL: bool = false; // will be raised as a proper error\n \n     #[inline(always)]\n-    fn enforce_alignment(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n+    fn enforce_alignment(ecx: &InterpCx<'mir, 'tcx, Self>) -> CheckAlignment {\n         ecx.machine.check_alignment\n     }\n \n@@ -318,6 +339,36 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         ecx.tcx.sess.opts.unstable_opts.extra_const_ub_checks\n     }\n \n+    fn alignment_check_failed(\n+        ecx: &InterpCx<'mir, 'tcx, Self>,\n+        has: Align,\n+        required: Align,\n+        check: CheckAlignment,\n+    ) -> InterpResult<'tcx, ()> {\n+        let err = err_ub!(AlignmentCheckFailed { has, required }).into();\n+        match check {\n+            CheckAlignment::Error => Err(err),\n+            CheckAlignment::No => span_bug!(\n+                ecx.cur_span(),\n+                \"`alignment_check_failed` called when no alignment check requested\"\n+            ),\n+            CheckAlignment::FutureIncompat => {\n+                let err = ConstEvalErr::new(ecx, err, None);\n+                ecx.tcx.struct_span_lint_hir(\n+                    INVALID_ALIGNMENT,\n+                    ecx.stack().iter().find_map(|frame| frame.lint_root()).unwrap_or(CRATE_HIR_ID),\n+                    err.span,\n+                    err.error.to_string(),\n+                    |db| {\n+                        err.decorate(db, |_| {});\n+                        db\n+                    },\n+                );\n+                Ok(())\n+            }\n+        }\n+    }\n+\n     fn load_mir(\n         ecx: &InterpCx<'mir, 'tcx, Self>,\n         instance: ty::InstanceDef<'tcx>,"}, {"sha": "498c008738793912e46e0b25afca0b8180a07d34", "filename": "compiler/rustc_const_eval/src/const_eval/valtrees.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -142,12 +142,11 @@ pub(crate) fn const_to_valtree_inner<'tcx>(\n         | ty::Foreign(..)\n         | ty::Infer(ty::FreshIntTy(_))\n         | ty::Infer(ty::FreshFloatTy(_))\n-        | ty::Projection(..)\n+        // FIXME(oli-obk): we could look behind opaque types\n+        | ty::Alias(..)\n         | ty::Param(_)\n         | ty::Bound(..)\n         | ty::Placeholder(..)\n-        // FIXME(oli-obk): we could look behind opaque types\n-        | ty::Opaque(..)\n         | ty::Infer(_)\n         // FIXME(oli-obk): we can probably encode closures just like structs\n         | ty::Closure(..)\n@@ -307,11 +306,10 @@ pub fn valtree_to_const_value<'tcx>(\n         | ty::Foreign(..)\n         | ty::Infer(ty::FreshIntTy(_))\n         | ty::Infer(ty::FreshFloatTy(_))\n-        | ty::Projection(..)\n+        | ty::Alias(..)\n         | ty::Param(_)\n         | ty::Bound(..)\n         | ty::Placeholder(..)\n-        | ty::Opaque(..)\n         | ty::Infer(_)\n         | ty::Closure(..)\n         | ty::Generator(..)"}, {"sha": "b1fdeb01b100abd58f5b0b44c678b07ffc2ebe75", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,5 +1,4 @@\n use std::assert_matches::assert_matches;\n-use std::convert::TryFrom;\n \n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::{Float, FloatConvert};"}, {"sha": "f551b5c29114d9984fcf108ceb1b9e12628db580", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -248,6 +248,15 @@ impl<'mir, 'tcx, Prov: Provenance, Extra> Frame<'mir, 'tcx, Prov, Extra> {\n             Right(span) => span,\n         }\n     }\n+\n+    pub fn lint_root(&self) -> Option<hir::HirId> {\n+        self.current_source_info().and_then(|source_info| {\n+            match &self.body.source_scopes[source_info.scope].local_data {\n+                mir::ClearCrossCrate::Set(data) => Some(data.lint_root),\n+                mir::ClearCrossCrate::Clear => None,\n+            }\n+        })\n+    }\n }\n \n impl<'tcx> fmt::Display for FrameInfo<'tcx> {\n@@ -954,12 +963,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // This deliberately does *not* honor `requires_caller_location` since it is used for much\n         // more than just panics.\n         for frame in stack.iter().rev() {\n-            let lint_root = frame.current_source_info().and_then(|source_info| {\n-                match &frame.body.source_scopes[source_info.scope].local_data {\n-                    mir::ClearCrossCrate::Set(data) => Some(data.lint_root),\n-                    mir::ClearCrossCrate::Clear => None,\n-                }\n-            });\n+            let lint_root = frame.lint_root();\n             let span = frame.current_span();\n \n             frames.push(FrameInfo { span, instance: frame.instance, lint_root });"}, {"sha": "9b56757eb3951a4ee201a538268f286f7b12edce", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -2,8 +2,6 @@\n //! looking at their MIR. Intrinsics/functions supported here are shared by CTFE\n //! and miri.\n \n-use std::convert::TryFrom;\n-\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir::{\n     self,\n@@ -84,11 +82,9 @@ pub(crate) fn eval_nullary_intrinsic<'tcx>(\n             ty::Adt(ref adt, _) => {\n                 ConstValue::from_machine_usize(adt.variants().len() as u64, &tcx)\n             }\n-            ty::Projection(_)\n-            | ty::Opaque(_, _)\n-            | ty::Param(_)\n-            | ty::Placeholder(_)\n-            | ty::Infer(_) => throw_inval!(TooGeneric),\n+            ty::Alias(..) | ty::Param(_) | ty::Placeholder(_) | ty::Infer(_) => {\n+                throw_inval!(TooGeneric)\n+            }\n             ty::Bound(_, _) => bug!(\"bound ty during ctfe\"),\n             ty::Bool\n             | ty::Char"}, {"sha": "77c7b4bacb8c8a96d68b42704478166e754d0772", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,5 +1,3 @@\n-use std::convert::TryFrom;\n-\n use rustc_ast::Mutability;\n use rustc_hir::lang_items::LangItem;\n use rustc_middle::mir::TerminatorKind;"}, {"sha": "1d4ef20d0651f7bd11d7cb466f0290d375ff27d8", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -10,9 +10,11 @@ use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_middle::mir;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::def_id::DefId;\n-use rustc_target::abi::Size;\n+use rustc_target::abi::{Align, Size};\n use rustc_target::spec::abi::Abi as CallAbi;\n \n+use crate::const_eval::CheckAlignment;\n+\n use super::{\n     AllocId, AllocRange, Allocation, ConstAllocation, Frame, ImmTy, InterpCx, InterpResult,\n     MemoryKind, OpTy, Operand, PlaceTy, Pointer, Provenance, Scalar, StackPopUnwind,\n@@ -122,14 +124,21 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     const PANIC_ON_ALLOC_FAIL: bool;\n \n     /// Whether memory accesses should be alignment-checked.\n-    fn enforce_alignment(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n+    fn enforce_alignment(ecx: &InterpCx<'mir, 'tcx, Self>) -> CheckAlignment;\n \n     /// Whether, when checking alignment, we should look at the actual address and thus support\n     /// custom alignment logic based on whatever the integer address happens to be.\n     ///\n     /// If this returns true, Provenance::OFFSET_IS_ADDR must be true.\n     fn use_addr_for_alignment_check(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n \n+    fn alignment_check_failed(\n+        ecx: &InterpCx<'mir, 'tcx, Self>,\n+        has: Align,\n+        required: Align,\n+        check: CheckAlignment,\n+    ) -> InterpResult<'tcx, ()>;\n+\n     /// Whether to enforce the validity invariant\n     fn enforce_validity(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n "}, {"sha": "5b1ac6b2f65e29f7bc7a726d3044a6fd5cb95654", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 38, "deletions": 26, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -18,6 +18,8 @@ use rustc_middle::mir::display_allocation;\n use rustc_middle::ty::{self, Instance, ParamEnv, Ty, TyCtxt};\n use rustc_target::abi::{Align, HasDataLayout, Size};\n \n+use crate::const_eval::CheckAlignment;\n+\n use super::{\n     alloc_range, AllocId, AllocMap, AllocRange, Allocation, CheckInAllocMsg, GlobalAlloc, InterpCx,\n     InterpResult, Machine, MayLeak, Pointer, PointerArithmetic, Provenance, Scalar,\n@@ -349,11 +351,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         size: Size,\n         align: Align,\n     ) -> InterpResult<'tcx, Option<(AllocId, Size, M::ProvenanceExtra)>> {\n-        let align = M::enforce_alignment(&self).then_some(align);\n         self.check_and_deref_ptr(\n             ptr,\n             size,\n             align,\n+            M::enforce_alignment(self),\n             CheckInAllocMsg::MemoryAccessTest,\n             |alloc_id, offset, prov| {\n                 let (size, align) = self.get_live_alloc_size_and_align(alloc_id)?;\n@@ -373,10 +375,17 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         align: Align,\n         msg: CheckInAllocMsg,\n     ) -> InterpResult<'tcx> {\n-        self.check_and_deref_ptr(ptr, size, Some(align), msg, |alloc_id, _, _| {\n-            let (size, align) = self.get_live_alloc_size_and_align(alloc_id)?;\n-            Ok((size, align, ()))\n-        })?;\n+        self.check_and_deref_ptr(\n+            ptr,\n+            size,\n+            align,\n+            CheckAlignment::Error,\n+            msg,\n+            |alloc_id, _, _| {\n+                let (size, align) = self.get_live_alloc_size_and_align(alloc_id)?;\n+                Ok((size, align, ()))\n+            },\n+        )?;\n         Ok(())\n     }\n \n@@ -388,27 +397,15 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         ptr: Pointer<Option<M::Provenance>>,\n         size: Size,\n-        align: Option<Align>,\n+        align: Align,\n+        check: CheckAlignment,\n         msg: CheckInAllocMsg,\n         alloc_size: impl FnOnce(\n             AllocId,\n             Size,\n             M::ProvenanceExtra,\n         ) -> InterpResult<'tcx, (Size, Align, T)>,\n     ) -> InterpResult<'tcx, Option<T>> {\n-        fn check_offset_align<'tcx>(offset: u64, align: Align) -> InterpResult<'tcx> {\n-            if offset % align.bytes() == 0 {\n-                Ok(())\n-            } else {\n-                // The biggest power of two through which `offset` is divisible.\n-                let offset_pow2 = 1 << offset.trailing_zeros();\n-                throw_ub!(AlignmentCheckFailed {\n-                    has: Align::from_bytes(offset_pow2).unwrap(),\n-                    required: align,\n-                })\n-            }\n-        }\n-\n         Ok(match self.ptr_try_get_alloc_id(ptr) {\n             Err(addr) => {\n                 // We couldn't get a proper allocation. This is only okay if the access size is 0,\n@@ -417,8 +414,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     throw_ub!(DanglingIntPointer(addr, msg));\n                 }\n                 // Must be aligned.\n-                if let Some(align) = align {\n-                    check_offset_align(addr, align)?;\n+                if check.should_check() {\n+                    self.check_offset_align(addr, align, check)?;\n                 }\n                 None\n             }\n@@ -441,16 +438,16 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n                 // Test align. Check this last; if both bounds and alignment are violated\n                 // we want the error to be about the bounds.\n-                if let Some(align) = align {\n+                if check.should_check() {\n                     if M::use_addr_for_alignment_check(self) {\n                         // `use_addr_for_alignment_check` can only be true if `OFFSET_IS_ADDR` is true.\n-                        check_offset_align(ptr.addr().bytes(), align)?;\n+                        self.check_offset_align(ptr.addr().bytes(), align, check)?;\n                     } else {\n                         // Check allocation alignment and offset alignment.\n                         if alloc_align.bytes() < align.bytes() {\n-                            throw_ub!(AlignmentCheckFailed { has: alloc_align, required: align });\n+                            M::alignment_check_failed(self, alloc_align, align, check)?;\n                         }\n-                        check_offset_align(offset.bytes(), align)?;\n+                        self.check_offset_align(offset.bytes(), align, check)?;\n                     }\n                 }\n \n@@ -460,6 +457,21 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n         })\n     }\n+\n+    fn check_offset_align(\n+        &self,\n+        offset: u64,\n+        align: Align,\n+        check: CheckAlignment,\n+    ) -> InterpResult<'tcx> {\n+        if offset % align.bytes() == 0 {\n+            Ok(())\n+        } else {\n+            // The biggest power of two through which `offset` is divisible.\n+            let offset_pow2 = 1 << offset.trailing_zeros();\n+            M::alignment_check_failed(self, Align::from_bytes(offset_pow2).unwrap(), align, check)\n+        }\n+    }\n }\n \n /// Allocation accessors\n@@ -560,11 +572,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         size: Size,\n         align: Align,\n     ) -> InterpResult<'tcx, Option<AllocRef<'a, 'tcx, M::Provenance, M::AllocExtra>>> {\n-        let align = M::enforce_alignment(self).then_some(align);\n         let ptr_and_alloc = self.check_and_deref_ptr(\n             ptr,\n             size,\n             align,\n+            M::enforce_alignment(self),\n             CheckInAllocMsg::MemoryAccessTest,\n             |alloc_id, offset, prov| {\n                 let alloc = self.get_alloc_raw(alloc_id)?;"}, {"sha": "949f95c5fa81c2a8909ac6fd353b8578946b9535", "filename": "compiler/rustc_const_eval/src/interpret/operator.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,5 +1,3 @@\n-use std::convert::TryFrom;\n-\n use rustc_apfloat::Float;\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::{InterpResult, Scalar};"}, {"sha": "905eb71bb18edde28b2eeb30f7d406defedcf4ce", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -364,13 +364,8 @@ where\n             .size_and_align_of_mplace(&mplace)?\n             .unwrap_or((mplace.layout.size, mplace.layout.align.abi));\n         assert!(mplace.align <= align, \"dynamic alignment less strict than static one?\");\n-        let align = M::enforce_alignment(self).then_some(align);\n-        self.check_ptr_access_align(\n-            mplace.ptr,\n-            size,\n-            align.unwrap_or(Align::ONE),\n-            CheckInAllocMsg::DerefTest,\n-        )?;\n+        let align = if M::enforce_alignment(self).should_check() { align } else { Align::ONE };\n+        self.check_ptr_access_align(mplace.ptr, size, align, CheckInAllocMsg::DerefTest)?;\n         Ok(())\n     }\n "}, {"sha": "e4f716c31945c68aacdfce6490c13a7116824508", "filename": "compiler/rustc_const_eval/src/interpret/util.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,6 +1,5 @@\n use rustc_middle::mir::interpret::InterpResult;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor};\n-use std::convert::TryInto;\n use std::ops::ControlFlow;\n \n /// Checks whether a type contains generic parameters which require substitution."}, {"sha": "f905d3fb479a0b7e343c7dd187239f94f3543705", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -4,7 +4,6 @@\n //! That's useful because it means other passes (e.g. promotion) can rely on `const`s\n //! to be const-safe.\n \n-use std::convert::TryFrom;\n use std::fmt::{Display, Write};\n use std::num::NonZeroUsize;\n \n@@ -602,8 +601,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             | ty::Placeholder(..)\n             | ty::Bound(..)\n             | ty::Param(..)\n-            | ty::Opaque(..)\n-            | ty::Projection(..)\n+            | ty::Alias(..)\n             | ty::GeneratorWitness(..) => bug!(\"Encountered invalid type {:?}\", ty),\n         }\n     }"}, {"sha": "bb897b95b2c53cd1122663b41945764ccd354960", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -52,7 +52,7 @@ impl<'tcx> MirPass<'tcx> for Validator {\n         };\n \n         let always_live_locals = always_storage_live_locals(body);\n-        let storage_liveness = MaybeStorageLive::new(always_live_locals)\n+        let storage_liveness = MaybeStorageLive::new(std::borrow::Cow::Owned(always_live_locals))\n             .into_engine(tcx, body)\n             .iterate_to_fixpoint()\n             .into_results_cursor(body);\n@@ -79,7 +79,7 @@ struct TypeChecker<'a, 'tcx> {\n     param_env: ParamEnv<'tcx>,\n     mir_phase: MirPhase,\n     reachable_blocks: BitSet<BasicBlock>,\n-    storage_liveness: ResultsCursor<'a, 'tcx, MaybeStorageLive>,\n+    storage_liveness: ResultsCursor<'a, 'tcx, MaybeStorageLive<'static>>,\n     place_cache: Vec<PlaceRef<'tcx>>,\n     value_cache: Vec<u128>,\n }\n@@ -241,7 +241,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 };\n \n                 let kind = match parent_ty.ty.kind() {\n-                    &ty::Opaque(def_id, substs) => {\n+                    &ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n                         self.tcx.bound_type_of(def_id).subst(self.tcx, substs).kind()\n                     }\n                     kind => kind,\n@@ -652,7 +652,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                     self.fail(location, \"`SetDiscriminant`is not allowed until deaggregation\");\n                 }\n                 let pty = place.ty(&self.body.local_decls, self.tcx).ty.kind();\n-                if !matches!(pty, ty::Adt(..) | ty::Generator(..) | ty::Opaque(..)) {\n+                if !matches!(pty, ty::Adt(..) | ty::Generator(..) | ty::Alias(ty::Opaque, ..)) {\n                     self.fail(\n                         location,\n                         format!("}, {"sha": "10783c5ed1d1cd7389fd67f5aa72e83f74763108", "filename": "compiler/rustc_const_eval/src/util/aggregate.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Faggregate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Faggregate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Faggregate.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -3,7 +3,6 @@ use rustc_middle::mir::*;\n use rustc_middle::ty::{Ty, TyCtxt};\n use rustc_target::abi::VariantIdx;\n \n-use std::convert::TryFrom;\n use std::iter::TrustedLen;\n \n /// Expand `lhs = Rvalue::Aggregate(kind, operands)` into assignments to the fields."}, {"sha": "38d9b044981cd723687c8962d06345fc226aa39a", "filename": "compiler/rustc_const_eval/src/util/call_kind.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcall_kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcall_kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcall_kind.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -5,7 +5,7 @@\n use rustc_hir::def_id::DefId;\n use rustc_hir::{lang_items, LangItem};\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, AssocItemContainer, DefIdTree, Instance, ParamEnv, Ty, TyCtxt};\n+use rustc_middle::ty::{AssocItemContainer, Instance, ParamEnv, Ty, TyCtxt};\n use rustc_span::symbol::Ident;\n use rustc_span::{sym, DesugaringKind, Span};\n \n@@ -39,9 +39,7 @@ pub enum CallKind<'tcx> {\n     Normal {\n         self_arg: Option<Ident>,\n         desugaring: Option<(CallDesugaringKind, Ty<'tcx>)>,\n-        /// Whether the self type of the method call has an `.as_ref()` method.\n-        /// Used for better diagnostics.\n-        is_option_or_result: bool,\n+        method_did: DefId,\n     },\n     /// A call to `Fn(..)::call(..)`, desugared from `my_closure(a, b, c)`\n     FnCall { fn_trait_id: DefId, self_ty: Ty<'tcx> },\n@@ -133,16 +131,6 @@ pub fn call_kind<'tcx>(\n         } else {\n             None\n         };\n-        let parent_did = tcx.parent(method_did);\n-        let parent_self_ty = (tcx.def_kind(parent_did) == rustc_hir::def::DefKind::Impl)\n-            .then_some(parent_did)\n-            .and_then(|did| match tcx.type_of(did).kind() {\n-                ty::Adt(def, ..) => Some(def.did()),\n-                _ => None,\n-            });\n-        let is_option_or_result = parent_self_ty.map_or(false, |def_id| {\n-            matches!(tcx.get_diagnostic_name(def_id), Some(sym::Option | sym::Result))\n-        });\n-        CallKind::Normal { self_arg, desugaring, is_option_or_result }\n+        CallKind::Normal { self_arg, desugaring, method_did }\n     })\n }"}, {"sha": "4ce107ea68d4f0f3869cebe3cce00c706a42f58d", "filename": "compiler/rustc_const_eval/src/util/might_permit_raw_init.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmight_permit_raw_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmight_permit_raw_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmight_permit_raw_init.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -3,7 +3,7 @@ use rustc_middle::ty::{ParamEnv, TyCtxt};\n use rustc_session::Limit;\n use rustc_target::abi::{Abi, FieldsShape, InitKind, Scalar, Variants};\n \n-use crate::const_eval::CompileTimeInterpreter;\n+use crate::const_eval::{CheckAlignment, CompileTimeInterpreter};\n use crate::interpret::{InterpCx, MemoryKind, OpTy};\n \n /// Determines if this type permits \"raw\" initialization by just transmuting some memory into an\n@@ -41,7 +41,7 @@ fn might_permit_raw_init_strict<'tcx>(\n     let machine = CompileTimeInterpreter::new(\n         Limit::new(0),\n         /*can_access_statics:*/ false,\n-        /*check_alignment:*/ true,\n+        CheckAlignment::Error,\n     );\n \n     let mut cx = InterpCx::new(tcx, rustc_span::DUMMY_SP, ParamEnv::reveal_all(), machine);"}, {"sha": "c4122f66498143a70950219d6afb696c91d58f40", "filename": "compiler/rustc_const_eval/src/util/type_name.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Ftype_name.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -58,8 +58,7 @@ impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n             // Types with identity (print the module path).\n             ty::Adt(ty::AdtDef(Interned(&ty::AdtDefData { did: def_id, .. }, _)), substs)\n             | ty::FnDef(def_id, substs)\n-            | ty::Opaque(def_id, substs)\n-            | ty::Projection(ty::ProjectionTy { item_def_id: def_id, substs })\n+            | ty::Alias(_, ty::AliasTy { def_id, substs, .. })\n             | ty::Closure(def_id, substs)\n             | ty::Generator(def_id, substs, _) => self.print_def_path(def_id, substs),\n             ty::Foreign(def_id) => self.print_def_path(def_id, &[]),"}, {"sha": "4567759c004dad7140b008d9569fc811c07fe642", "filename": "compiler/rustc_data_structures/src/base_n.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_data_structures%2Fsrc%2Fbase_n.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_data_structures%2Fsrc%2Fbase_n.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fbase_n.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -9,7 +9,7 @@ pub const MAX_BASE: usize = 64;\n pub const ALPHANUMERIC_ONLY: usize = 62;\n pub const CASE_INSENSITIVE: usize = 36;\n \n-const BASE_64: &[u8; MAX_BASE as usize] =\n+const BASE_64: &[u8; MAX_BASE] =\n     b\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ@$\";\n \n #[inline]"}, {"sha": "b6e866f15efe3c576285798a16b4d9ce9d051afb", "filename": "compiler/rustc_data_structures/src/fingerprint.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,6 +1,5 @@\n use crate::stable_hasher;\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n-use std::convert::TryInto;\n use std::hash::{Hash, Hasher};\n \n #[cfg(test)]"}, {"sha": "b31092eca9837bb0a0c5536b1be7e05c188fcbf5", "filename": "compiler/rustc_data_structures/src/graph/scc/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -9,7 +9,6 @@ use crate::fx::FxHashSet;\n use crate::graph::vec_graph::VecGraph;\n use crate::graph::{DirectedGraph, GraphSuccessors, WithNumEdges, WithNumNodes, WithSuccessors};\n use rustc_index::vec::{Idx, IndexVec};\n-use std::cmp::Ord;\n use std::ops::Range;\n \n #[cfg(test)]"}, {"sha": "94232bb7626ec885327699322d6d1357b4a9da40", "filename": "compiler/rustc_data_structures/src/graph/vec_graph/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fvec_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fvec_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fvec_graph%2Fmod.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,5 +1,3 @@\n-use std::cmp::Ord;\n-\n use crate::graph::{DirectedGraph, GraphSuccessors, WithNumEdges, WithNumNodes, WithSuccessors};\n use rustc_index::vec::{Idx, IndexVec};\n "}, {"sha": "d1d92b905b82e0b9da4db953f10c263d8bce4838", "filename": "compiler/rustc_data_structures/src/owning_ref/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Fmod.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -867,11 +867,9 @@ where\n /////////////////////////////////////////////////////////////////////////////\n \n use std::borrow::Borrow;\n-use std::cmp::{Eq, Ord, Ordering, PartialEq, PartialOrd};\n-use std::convert::From;\n+use std::cmp::Ordering;\n use std::fmt::{self, Debug};\n use std::hash::{Hash, Hasher};\n-use std::marker::{Send, Sync};\n \n impl<O, T: ?Sized> Deref for OwningRef<O, T> {\n     type Target = T;\n@@ -1096,7 +1094,6 @@ where\n // std types integration and convenience type defs\n /////////////////////////////////////////////////////////////////////////////\n \n-use std::boxed::Box;\n use std::cell::{Ref, RefCell, RefMut};\n use std::rc::Rc;\n use std::sync::Arc;"}, {"sha": "a9b187c4ce0a79f979ae4c562ebe56ab598c40bb", "filename": "compiler/rustc_data_structures/src/owning_ref/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Ftests.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -3,7 +3,7 @@\n mod owning_ref {\n     use super::super::OwningRef;\n     use super::super::{BoxRef, Erased, ErasedBoxRef, RcRef};\n-    use std::cmp::{Ord, Ordering, PartialEq, PartialOrd};\n+    use std::cmp::Ordering;\n     use std::collections::hash_map::DefaultHasher;\n     use std::collections::HashMap;\n     use std::hash::{Hash, Hasher};\n@@ -368,7 +368,7 @@ mod owning_handle {\n mod owning_ref_mut {\n     use super::super::BoxRef;\n     use super::super::{BoxRefMut, Erased, ErasedBoxRefMut, OwningRefMut};\n-    use std::cmp::{Ord, Ordering, PartialEq, PartialOrd};\n+    use std::cmp::Ordering;\n     use std::collections::hash_map::DefaultHasher;\n     use std::collections::HashMap;\n     use std::hash::{Hash, Hasher};"}, {"sha": "1d4014f05acdc3e5a208d301ebd534a504fb411c", "filename": "compiler/rustc_data_structures/src/profiling.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -86,7 +86,6 @@ use crate::fx::FxHashMap;\n \n use std::borrow::Borrow;\n use std::collections::hash_map::Entry;\n-use std::convert::Into;\n use std::error::Error;\n use std::fs;\n use std::path::Path;"}, {"sha": "05f059c89d5cd0fea01ea73e00e8d8419b4b3c9e", "filename": "compiler/rustc_data_structures/src/sorted_map.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,7 +1,6 @@\n use crate::stable_hasher::{HashStable, StableHasher, StableOrd};\n use std::borrow::Borrow;\n use std::cmp::Ordering;\n-use std::iter::FromIterator;\n use std::mem;\n use std::ops::{Bound, Index, IndexMut, RangeBounds};\n \n@@ -127,13 +126,13 @@ impl<K: Ord, V> SortedMap<K, V> {\n     /// Iterate over the keys, sorted\n     #[inline]\n     pub fn keys(&self) -> impl Iterator<Item = &K> + ExactSizeIterator + DoubleEndedIterator {\n-        self.data.iter().map(|&(ref k, _)| k)\n+        self.data.iter().map(|(k, _)| k)\n     }\n \n     /// Iterate over values, sorted by key\n     #[inline]\n     pub fn values(&self) -> impl Iterator<Item = &V> + ExactSizeIterator + DoubleEndedIterator {\n-        self.data.iter().map(|&(_, ref v)| v)\n+        self.data.iter().map(|(_, v)| v)\n     }\n \n     #[inline]\n@@ -223,7 +222,7 @@ impl<K: Ord, V> SortedMap<K, V> {\n         K: Borrow<Q>,\n         Q: Ord + ?Sized,\n     {\n-        self.data.binary_search_by(|&(ref x, _)| x.borrow().cmp(key))\n+        self.data.binary_search_by(|(x, _)| x.borrow().cmp(key))\n     }\n \n     #[inline]\n@@ -301,7 +300,7 @@ impl<K: Ord, V> FromIterator<(K, V)> for SortedMap<K, V> {\n     fn from_iter<T: IntoIterator<Item = (K, V)>>(iter: T) -> Self {\n         let mut data: Vec<(K, V)> = iter.into_iter().collect();\n \n-        data.sort_unstable_by(|&(ref k1, _), &(ref k2, _)| k1.cmp(k2));\n+        data.sort_unstable_by(|(k1, _), (k2, _)| k1.cmp(k2));\n         data.dedup_by(|&mut (ref k1, _), &mut (ref k2, _)| k1.cmp(k2) == Ordering::Equal);\n \n         SortedMap { data }"}, {"sha": "7af5c14942adf8c30ac0c0bc898655b97251a708", "filename": "compiler/rustc_data_structures/src/sorted_map/index_map.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Findex_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Findex_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Findex_map.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,7 +1,6 @@\n //! A variant of `SortedMap` that preserves insertion order.\n \n use std::hash::{Hash, Hasher};\n-use std::iter::FromIterator;\n \n use crate::stable_hasher::{HashStable, StableHasher};\n use rustc_index::vec::{Idx, IndexVec};"}, {"sha": "bca6c0955b905f8732fb72b598fc75e62d924152", "filename": "compiler/rustc_data_structures/src/sso/either_iter.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Feither_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Feither_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Feither_iter.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,7 +1,5 @@\n use std::fmt;\n-use std::iter::ExactSizeIterator;\n use std::iter::FusedIterator;\n-use std::iter::Iterator;\n \n /// Iterator which may contain instance of\n /// one of two specific implementations."}, {"sha": "7cdac58197714840081099415c7fadd866b76f75", "filename": "compiler/rustc_data_structures/src/sso/map.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -3,7 +3,6 @@ use crate::fx::FxHashMap;\n use arrayvec::ArrayVec;\n use std::fmt;\n use std::hash::Hash;\n-use std::iter::FromIterator;\n use std::ops::Index;\n \n // For pointer-sized arguments arrays"}, {"sha": "a4b40138933dedc2cf12c370df798509f1aca3f7", "filename": "compiler/rustc_data_structures/src/sso/set.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fset.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,6 +1,5 @@\n use std::fmt;\n use std::hash::Hash;\n-use std::iter::FromIterator;\n \n use super::map::SsoHashMap;\n "}, {"sha": "ed5341c40ef08b70ee2fae389ad86b949f80ba8b", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -138,7 +138,7 @@ cfg_if! {\n             }\n         }\n \n-        pub use std::iter::Iterator as ParallelIterator;\n+        pub use Iterator as ParallelIterator;\n \n         pub fn par_iter<T: IntoIterator>(t: T) -> T::IntoIter {\n             t.into_iter()"}, {"sha": "b0315c93d934d7a359266dd89ddfa86268c5d4a4", "filename": "compiler/rustc_data_structures/src/tagged_ptr/drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -76,7 +76,7 @@ where\n     fn drop(&mut self) {\n         // No need to drop the tag, as it's Copy\n         unsafe {\n-            std::mem::drop(P::from_usize(self.raw.pointer_raw()));\n+            drop(P::from_usize(self.raw.pointer_raw()));\n         }\n     }\n }"}, {"sha": "2417df66bb9d8a2b0dd0d4ac09744a0d8dba0cdc", "filename": "compiler/rustc_data_structures/src/vec_map.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,6 +1,5 @@\n use std::borrow::Borrow;\n use std::fmt::Debug;\n-use std::iter::FromIterator;\n use std::slice::Iter;\n use std::vec::IntoIter;\n "}, {"sha": "711eed2b2723118a11a64ceeb11f01ca651f30da", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -45,7 +45,6 @@ use rustc_target::json::ToJson;\n \n use std::borrow::Cow;\n use std::cmp::max;\n-use std::default::Default;\n use std::env;\n use std::ffi::OsString;\n use std::fs;"}, {"sha": "7c0719dc217d06089d726acca31a965d7a99a69f", "filename": "compiler/rustc_error_codes/src/error_codes/E0492.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0492.md", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0492.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0492.md?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -55,7 +55,6 @@ wrapper:\n \n ```\n use std::cell::Cell;\n-use std::marker::Sync;\n \n struct NotThreadSafe<T> {\n     value: Cell<T>,"}, {"sha": "db4c82b35c77822d718d16039112205dada7972c", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_ssa.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -192,3 +192,5 @@ codegen_ssa_archive_build_failure =\n \n codegen_ssa_unknown_archive_kind =\n     Don't know how to build archive of type: {$kind}\n+\n+codegen_ssa_expected_used_symbol = expected `used`, `used(compiler)` or `used(linker)`"}, {"sha": "26cdf8a58f3fb5e975342ef93f2237c095a2932d", "filename": "compiler/rustc_error_messages/locales/en-US/hir_analysis.ftl", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -20,6 +20,10 @@ hir_analysis_lifetimes_or_bounds_mismatch_on_trait =\n     .where_label = this `where` clause might not match the one in the trait\n     .bounds_label = this bound might be missing in the impl\n \n+hir_analysis_async_trait_impl_should_be_async =\n+    method `{$method_name}` should be async because the method from the trait is async\n+    .trait_item_label = required because the trait method is async\n+\n hir_analysis_drop_impl_on_wrong_item =\n     the `Drop` trait may only be implemented for local structs, enums, and unions\n     .label = must be a struct, enum, or union in the current crate\n@@ -101,8 +105,6 @@ hir_analysis_extern_crate_not_idiomatic =\n     `extern crate` is not idiomatic in the new edition\n     .suggestion = convert it to a `{$msg_code}`\n \n-hir_analysis_expected_used_symbol = expected `used`, `used(compiler)` or `used(linker)`\n-\n hir_analysis_const_impl_for_non_const_trait =\n     const `impl` for trait `{$trait_name}` which is not marked with `#[const_trait]`\n     .suggestion = mark `{$trait_name}` as const"}, {"sha": "243d10bfa062150bf9bda530541b8f235d35ceae", "filename": "compiler/rustc_error_messages/locales/en-US/monomorphize.ftl", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmonomorphize.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmonomorphize.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmonomorphize.ftl?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -21,3 +21,6 @@ monomorphize_large_assignments =\n     moving {$size} bytes\n     .label = value moved from here\n     .note = The current maximum size is {$limit}, but it can be customized with the move_size_limit attribute: `#![move_size_limit = \"...\"]`\n+\n+monomorphize_couldnt_dump_mono_stats =\n+    unexpected error occurred while dumping monomorphization stats: {$error}"}, {"sha": "585a54308c62e1c0bf07ab9c1478bd51ec0fca2c", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -370,7 +370,11 @@ impl Diagnostic {\n         self.set_span(after);\n         for span_label in before.span_labels() {\n             if let Some(label) = span_label.label {\n-                self.span.push_span_label(after, label);\n+                if span_label.is_primary {\n+                    self.span.push_span_label(after, label);\n+                } else {\n+                    self.span.push_span_label(span_label.span, label);\n+                }\n             }\n         }\n         self\n@@ -802,7 +806,7 @@ impl Diagnostic {\n         debug_assert!(\n             !(suggestions\n                 .iter()\n-                .flat_map(|suggs| suggs)\n+                .flatten()\n                 .any(|(sp, suggestion)| sp.is_empty() && suggestion.is_empty())),\n             \"Span must not be empty and have no suggestion\"\n         );"}, {"sha": "628cb90903feedebcfe049f7cfeef978e6f053e3", "filename": "compiler/rustc_errors/src/diagnostic_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -59,7 +59,7 @@ into_diagnostic_arg_using_display!(\n     i128,\n     u128,\n     std::io::Error,\n-    std::boxed::Box<dyn std::error::Error>,\n+    Box<dyn std::error::Error>,\n     std::num::NonZeroU32,\n     hir::Target,\n     Edition,"}, {"sha": "e2a0e436fd5e2677a9524066380a034907ef59b0", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 47, "deletions": 38, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1308,7 +1308,7 @@ impl EmitterWriter {\n         //                see how it *looks* with\n         //                very *weird* formats\n         //                see?\n-        for &(ref text, ref style) in msg.iter() {\n+        for (text, style) in msg.iter() {\n             let text = self.translate_message(text, args);\n             let lines = text.split('\\n').collect::<Vec<_>>();\n             if lines.len() > 1 {\n@@ -1370,7 +1370,7 @@ impl EmitterWriter {\n                 buffer.append(0, \": \", header_style);\n                 label_width += 2;\n             }\n-            for &(ref text, _) in msg.iter() {\n+            for (text, _) in msg.iter() {\n                 let text = self.translate_message(text, args);\n                 // Account for newlines to align output to its label.\n                 for (line, text) in normalize_whitespace(&text).lines().enumerate() {\n@@ -1408,49 +1408,58 @@ impl EmitterWriter {\n             if !sm.ensure_source_file_source_present(annotated_file.file.clone()) {\n                 if !self.short_message {\n                     // We'll just print an unannotated message.\n-                    for (annotation_id, line) in annotated_file.lines.into_iter().enumerate() {\n+                    for (annotation_id, line) in annotated_file.lines.iter().enumerate() {\n                         let mut annotations = line.annotations.clone();\n                         annotations.sort_by_key(|a| Reverse(a.start_col));\n                         let mut line_idx = buffer.num_lines();\n-                        buffer.append(\n-                            line_idx,\n-                            &format!(\n-                                \"{}:{}:{}\",\n-                                sm.filename_for_diagnostics(&annotated_file.file.name),\n-                                sm.doctest_offset_line(&annotated_file.file.name, line.line_index),\n-                                annotations[0].start_col + 1,\n-                            ),\n-                            Style::LineAndColumn,\n-                        );\n-                        if annotation_id == 0 {\n-                            buffer.prepend(line_idx, \"--> \", Style::LineNumber);\n+\n+                        let labels: Vec<_> = annotations\n+                            .iter()\n+                            .filter_map(|a| Some((a.label.as_ref()?, a.is_primary)))\n+                            .filter(|(l, _)| !l.is_empty())\n+                            .collect();\n+\n+                        if annotation_id == 0 || !labels.is_empty() {\n+                            buffer.append(\n+                                line_idx,\n+                                &format!(\n+                                    \"{}:{}:{}\",\n+                                    sm.filename_for_diagnostics(&annotated_file.file.name),\n+                                    sm.doctest_offset_line(\n+                                        &annotated_file.file.name,\n+                                        line.line_index\n+                                    ),\n+                                    annotations[0].start_col + 1,\n+                                ),\n+                                Style::LineAndColumn,\n+                            );\n+                            if annotation_id == 0 {\n+                                buffer.prepend(line_idx, \"--> \", Style::LineNumber);\n+                            } else {\n+                                buffer.prepend(line_idx, \"::: \", Style::LineNumber);\n+                            }\n                             for _ in 0..max_line_num_len {\n                                 buffer.prepend(line_idx, \" \", Style::NoStyle);\n                             }\n                             line_idx += 1;\n-                        };\n-                        for (i, annotation) in annotations.into_iter().enumerate() {\n-                            if let Some(label) = &annotation.label {\n-                                let style = if annotation.is_primary {\n-                                    Style::LabelPrimary\n-                                } else {\n-                                    Style::LabelSecondary\n-                                };\n-                                if annotation_id == 0 {\n-                                    buffer.prepend(line_idx, \" |\", Style::LineNumber);\n-                                    for _ in 0..max_line_num_len {\n-                                        buffer.prepend(line_idx, \" \", Style::NoStyle);\n-                                    }\n-                                    line_idx += 1;\n-                                    buffer.append(line_idx + i, \" = note: \", style);\n-                                    for _ in 0..max_line_num_len {\n-                                        buffer.prepend(line_idx, \" \", Style::NoStyle);\n-                                    }\n-                                } else {\n-                                    buffer.append(line_idx + i, \": \", style);\n-                                }\n-                                buffer.append(line_idx + i, label, style);\n+                        }\n+                        for (label, is_primary) in labels.into_iter() {\n+                            let style = if is_primary {\n+                                Style::LabelPrimary\n+                            } else {\n+                                Style::LabelSecondary\n+                            };\n+                            buffer.prepend(line_idx, \" |\", Style::LineNumber);\n+                            for _ in 0..max_line_num_len {\n+                                buffer.prepend(line_idx, \" \", Style::NoStyle);\n+                            }\n+                            line_idx += 1;\n+                            buffer.append(line_idx, \" = note: \", style);\n+                            for _ in 0..max_line_num_len {\n+                                buffer.prepend(line_idx, \" \", Style::NoStyle);\n                             }\n+                            buffer.append(line_idx, label, style);\n+                            line_idx += 1;\n                         }\n                     }\n                 }\n@@ -2304,7 +2313,7 @@ impl FileWithAnnotatedLines {\n         }\n \n         // Find overlapping multiline annotations, put them at different depths\n-        multiline_annotations.sort_by_key(|&(_, ref ml)| (ml.line_start, usize::MAX - ml.line_end));\n+        multiline_annotations.sort_by_key(|(_, ml)| (ml.line_start, usize::MAX - ml.line_end));\n         for (_, ann) in multiline_annotations.clone() {\n             for (_, a) in multiline_annotations.iter_mut() {\n                 // Move all other multiline annotations overlapping with this one"}, {"sha": "518b5ec10f8906122c4ab9fb26cc19e80231bf8a", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -324,7 +324,7 @@ impl CodeSuggestion {\n                         // Account for the difference between the width of the current code and the\n                         // snippet being suggested, so that the *later* suggestions are correctly\n                         // aligned on the screen.\n-                        acc += len as isize - (cur_hi.col.0 - cur_lo.col.0) as isize;\n+                        acc += len - (cur_hi.col.0 - cur_lo.col.0) as isize;\n                     }\n                     prev_hi = cur_hi;\n                     prev_line = sf.get_line(prev_hi.line - 1);"}, {"sha": "00453f78287efb8ab9067dbbf1fae3a27e43984e", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -34,7 +34,6 @@ use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, FileName, RealFileName, Span, DUMMY_SP};\n use smallvec::{smallvec, SmallVec};\n \n-use std::default::Default;\n use std::iter;\n use std::path::PathBuf;\n use std::rc::Rc;\n@@ -1232,7 +1231,7 @@ pub fn expr_to_spanned_string<'a>(\n     Err(match expr.kind {\n         ast::ExprKind::Lit(token_lit) => match ast::LitKind::from_token_lit(token_lit) {\n             Ok(ast::LitKind::Str(s, style)) => return Ok((s, style, expr.span)),\n-            Ok(ast::LitKind::ByteStr(_)) => {\n+            Ok(ast::LitKind::ByteStr(..)) => {\n                 let mut err = cx.struct_span_err(expr.span, err_msg);\n                 let span = expr.span.shrink_to_lo();\n                 err.span_suggestion("}, {"sha": "ef50efb81253fccd1c224c92f9a61e7d34b9471c", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,8 +1,7 @@\n use crate::base::ExtCtxt;\n-use rustc_ast::attr;\n use rustc_ast::ptr::P;\n use rustc_ast::{self as ast, AttrVec, BlockCheckMode, Expr, LocalKind, PatKind, UnOp};\n-use rustc_data_structures::sync::Lrc;\n+use rustc_ast::{attr, token, util::literal};\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n@@ -332,36 +331,36 @@ impl<'a> ExtCtxt<'a> {\n         self.expr_struct(span, self.path_ident(span, id), fields)\n     }\n \n-    fn expr_lit(&self, span: Span, lit_kind: ast::LitKind) -> P<ast::Expr> {\n-        let token_lit = lit_kind.to_token_lit();\n-        self.expr(span, ast::ExprKind::Lit(token_lit))\n+    pub fn expr_usize(&self, span: Span, n: usize) -> P<ast::Expr> {\n+        let suffix = Some(ast::UintTy::Usize.name());\n+        let lit = token::Lit::new(token::Integer, sym::integer(n), suffix);\n+        self.expr(span, ast::ExprKind::Lit(lit))\n     }\n \n-    pub fn expr_usize(&self, span: Span, i: usize) -> P<ast::Expr> {\n-        self.expr_lit(\n-            span,\n-            ast::LitKind::Int(i as u128, ast::LitIntType::Unsigned(ast::UintTy::Usize)),\n-        )\n-    }\n-\n-    pub fn expr_u32(&self, sp: Span, u: u32) -> P<ast::Expr> {\n-        self.expr_lit(sp, ast::LitKind::Int(u as u128, ast::LitIntType::Unsigned(ast::UintTy::U32)))\n+    pub fn expr_u32(&self, span: Span, n: u32) -> P<ast::Expr> {\n+        let suffix = Some(ast::UintTy::U32.name());\n+        let lit = token::Lit::new(token::Integer, sym::integer(n), suffix);\n+        self.expr(span, ast::ExprKind::Lit(lit))\n     }\n \n-    pub fn expr_bool(&self, sp: Span, value: bool) -> P<ast::Expr> {\n-        self.expr_lit(sp, ast::LitKind::Bool(value))\n+    pub fn expr_bool(&self, span: Span, value: bool) -> P<ast::Expr> {\n+        let lit = token::Lit::new(token::Bool, if value { kw::True } else { kw::False }, None);\n+        self.expr(span, ast::ExprKind::Lit(lit))\n     }\n \n-    pub fn expr_str(&self, sp: Span, s: Symbol) -> P<ast::Expr> {\n-        self.expr_lit(sp, ast::LitKind::Str(s, ast::StrStyle::Cooked))\n+    pub fn expr_str(&self, span: Span, s: Symbol) -> P<ast::Expr> {\n+        let lit = token::Lit::new(token::Str, literal::escape_string_symbol(s), None);\n+        self.expr(span, ast::ExprKind::Lit(lit))\n     }\n \n-    pub fn expr_char(&self, sp: Span, ch: char) -> P<ast::Expr> {\n-        self.expr_lit(sp, ast::LitKind::Char(ch))\n+    pub fn expr_char(&self, span: Span, ch: char) -> P<ast::Expr> {\n+        let lit = token::Lit::new(token::Char, literal::escape_char_symbol(ch), None);\n+        self.expr(span, ast::ExprKind::Lit(lit))\n     }\n \n-    pub fn expr_byte_str(&self, sp: Span, bytes: Vec<u8>) -> P<ast::Expr> {\n-        self.expr_lit(sp, ast::LitKind::ByteStr(Lrc::from(bytes)))\n+    pub fn expr_byte_str(&self, span: Span, bytes: Vec<u8>) -> P<ast::Expr> {\n+        let lit = token::Lit::new(token::ByteStr, literal::escape_byte_str_symbol(&bytes), None);\n+        self.expr(span, ast::ExprKind::Lit(lit))\n     }\n \n     /// `[expr1, expr2, ...]`"}, {"sha": "768bdab8a54199a10aec996bc8c9a6bfa897f17c", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -6,6 +6,7 @@ use pm::{Delimiter, Level, LineColumn};\n use rustc_ast as ast;\n use rustc_ast::token;\n use rustc_ast::tokenstream::{self, Spacing::*, TokenStream};\n+use rustc_ast::util::literal::escape_byte_str_symbol;\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n@@ -526,7 +527,7 @@ impl server::TokenStream for Rustc<'_, '_> {\n                 Ok(tokenstream::TokenStream::token_alone(token::Literal(*token_lit), expr.span))\n             }\n             ast::ExprKind::IncludedBytes(bytes) => {\n-                let lit = ast::LitKind::ByteStr(bytes.clone()).to_token_lit();\n+                let lit = token::Lit::new(token::ByteStr, escape_byte_str_symbol(bytes), None);\n                 Ok(tokenstream::TokenStream::token_alone(token::TokenKind::Literal(lit), expr.span))\n             }\n             ast::ExprKind::Unary(ast::UnOp::Neg, e) => match &e.kind {"}, {"sha": "91825c29258ac10bd345aedbd19fcf35faa1da72", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -548,12 +548,7 @@ impl<'hir> Generics<'hir> {\n     }\n \n     pub fn get_named(&self, name: Symbol) -> Option<&GenericParam<'hir>> {\n-        for param in self.params {\n-            if name == param.name.ident().name {\n-                return Some(param);\n-            }\n-        }\n-        None\n+        self.params.iter().find(|&param| name == param.name.ident().name)\n     }\n \n     pub fn spans(&self) -> MultiSpan {"}, {"sha": "e870aa543d0b5ce9737ae0deb2b0ae7de088714e", "filename": "compiler/rustc_hir/src/pat_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -6,7 +6,7 @@ use rustc_span::hygiene::DesugaringKind;\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n-use std::iter::{Enumerate, ExactSizeIterator};\n+use std::iter::Enumerate;\n \n pub struct EnumerateAndAdjust<I> {\n     enumerate: Enumerate<I>,"}, {"sha": "71f26eb60c9628e880f5f5b71ca4274e4fed5598", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -680,7 +680,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let assoc_bindings = self.create_assoc_bindings_for_generic_args(args);\n \n         let poly_trait_ref =\n-            ty::Binder::bind_with_vars(ty::TraitRef::new(trait_def_id, substs), bound_vars);\n+            ty::Binder::bind_with_vars(tcx.mk_trait_ref(trait_def_id, substs), bound_vars);\n \n         debug!(?poly_trait_ref, ?assoc_bindings);\n         bounds.trait_bounds.push((poly_trait_ref, span, constness));\n@@ -813,7 +813,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         if let Some(b) = trait_segment.args().bindings.first() {\n             Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n         }\n-        ty::TraitRef::new(trait_def_id, substs)\n+        self.tcx().mk_trait_ref(trait_def_id, substs)\n     }\n \n     #[instrument(level = \"debug\", skip(self, span))]\n@@ -1146,10 +1146,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n             debug!(?substs_trait_ref_and_assoc_item);\n \n-            ty::ProjectionTy {\n-                item_def_id: assoc_item.def_id,\n-                substs: substs_trait_ref_and_assoc_item,\n-            }\n+            self.tcx().mk_alias_ty(assoc_item.def_id, substs_trait_ref_and_assoc_item)\n         });\n \n         if !speculative {\n@@ -1195,7 +1192,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // the \"projection predicate\" for:\n                 //\n                 // `<T as Iterator>::Item = u32`\n-                let assoc_item_def_id = projection_ty.skip_binder().item_def_id;\n+                let assoc_item_def_id = projection_ty.skip_binder().def_id;\n                 let def_kind = tcx.def_kind(assoc_item_def_id);\n                 match (def_kind, term.unpack()) {\n                     (hir::def::DefKind::AssocTy, ty::TermKind::Ty(_))\n@@ -1244,7 +1241,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 //\n                 // Calling `skip_binder` is okay, because `add_bounds` expects the `param_ty`\n                 // parameter to have a skipped binder.\n-                let param_ty = tcx.mk_ty(ty::Projection(projection_ty.skip_binder()));\n+                let param_ty = tcx.mk_ty(ty::Alias(ty::Projection, projection_ty.skip_binder()));\n                 self.add_bounds(param_ty, ast_bounds.iter(), bounds, candidate.bound_vars());\n             }\n         }"}, {"sha": "aa01feb3a1ea4d686e5b84401d4100913088ae76", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -570,7 +570,7 @@ fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n                             assoc_item,\n                             assoc_item,\n                             default.span,\n-                            ty::TraitRef { def_id: it.owner_id.to_def_id(), substs: trait_substs },\n+                            tcx.mk_trait_ref(it.owner_id.to_def_id(), trait_substs),\n                         );\n                     }\n                     _ => {}\n@@ -1440,7 +1440,7 @@ fn opaque_type_cycle_error(tcx: TyCtxt<'_>, def_id: LocalDefId, span: Span) -> E\n                 impl<'tcx> ty::visit::TypeVisitor<'tcx> for OpaqueTypeCollector {\n                     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n                         match *t.kind() {\n-                            ty::Opaque(def, _) => {\n+                            ty::Alias(ty::Opaque, ty::AliasTy { def_id: def, .. }) => {\n                                 self.0.push(def);\n                                 ControlFlow::CONTINUE\n                             }"}, {"sha": "6b9ce9a4599e2ce45ddd8e8479ec41f32d73d6b7", "filename": "compiler/rustc_hir_analysis/src/check/compare_method.rs", "status": "modified", "additions": 41, "deletions": 12, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -67,6 +67,10 @@ pub(crate) fn compare_impl_method<'tcx>(\n         return;\n     }\n \n+    if let Err(_) = compare_asyncness(tcx, impl_m, impl_m_span, trait_m, trait_item_span) {\n+        return;\n+    }\n+\n     if let Err(_) = compare_predicate_entailment(tcx, impl_m, impl_m_span, trait_m, impl_trait_ref)\n     {\n         return;\n@@ -323,6 +327,34 @@ fn compare_predicate_entailment<'tcx>(\n     Ok(())\n }\n \n+fn compare_asyncness<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    impl_m: &ty::AssocItem,\n+    impl_m_span: Span,\n+    trait_m: &ty::AssocItem,\n+    trait_item_span: Option<Span>,\n+) -> Result<(), ErrorGuaranteed> {\n+    if tcx.asyncness(trait_m.def_id) == hir::IsAsync::Async {\n+        match tcx.fn_sig(impl_m.def_id).skip_binder().output().kind() {\n+            ty::Alias(ty::Opaque, ..) => {\n+                // allow both `async fn foo()` and `fn foo() -> impl Future`\n+            }\n+            ty::Error(rustc_errors::ErrorGuaranteed { .. }) => {\n+                // We don't know if it's ok, but at least it's already an error.\n+            }\n+            _ => {\n+                return Err(tcx.sess.emit_err(crate::errors::AsyncTraitImplShouldBeAsync {\n+                    span: impl_m_span,\n+                    method_name: trait_m.name,\n+                    trait_item_span,\n+                }));\n+            }\n+        };\n+    }\n+\n+    Ok(())\n+}\n+\n #[instrument(skip(tcx), level = \"debug\", ret)]\n pub fn collect_trait_impl_trait_tys<'tcx>(\n     tcx: TyCtxt<'tcx>,\n@@ -571,10 +603,10 @@ impl<'tcx> TypeFolder<'tcx> for ImplTraitInTraitCollector<'_, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        if let ty::Projection(proj) = ty.kind()\n-            && self.tcx().def_kind(proj.item_def_id) == DefKind::ImplTraitPlaceholder\n+        if let ty::Alias(ty::Projection, proj) = ty.kind()\n+            && self.tcx().def_kind(proj.def_id) == DefKind::ImplTraitPlaceholder\n         {\n-            if let Some((ty, _)) = self.types.get(&proj.item_def_id) {\n+            if let Some((ty, _)) = self.types.get(&proj.def_id) {\n                 return *ty;\n             }\n             //FIXME(RPITIT): Deny nested RPITIT in substs too\n@@ -586,9 +618,9 @@ impl<'tcx> TypeFolder<'tcx> for ImplTraitInTraitCollector<'_, 'tcx> {\n                 span: self.span,\n                 kind: TypeVariableOriginKind::MiscVariable,\n             });\n-            self.types.insert(proj.item_def_id, (infer_ty, proj.substs));\n+            self.types.insert(proj.def_id, (infer_ty, proj.substs));\n             // Recurse into bounds\n-            for (pred, pred_span) in self.tcx().bound_explicit_item_bounds(proj.item_def_id).subst_iter_copied(self.tcx(), proj.substs) {\n+            for (pred, pred_span) in self.tcx().bound_explicit_item_bounds(proj.def_id).subst_iter_copied(self.tcx(), proj.substs) {\n                 let pred = pred.fold_with(self);\n                 let pred = self.ocx.normalize(\n                     &ObligationCause::misc(self.span, self.body_id),\n@@ -601,7 +633,7 @@ impl<'tcx> TypeFolder<'tcx> for ImplTraitInTraitCollector<'_, 'tcx> {\n                     ObligationCause::new(\n                         self.span,\n                         self.body_id,\n-                        ObligationCauseCode::BindingObligation(proj.item_def_id, pred_span),\n+                        ObligationCauseCode::BindingObligation(proj.def_id, pred_span),\n                     ),\n                     self.param_env,\n                     pred,\n@@ -1734,8 +1766,8 @@ pub fn check_type_bounds<'tcx>(\n     let normalize_param_env = {\n         let mut predicates = param_env.caller_bounds().iter().collect::<Vec<_>>();\n         match impl_ty_value.kind() {\n-            ty::Projection(proj)\n-                if proj.item_def_id == trait_ty.def_id && proj.substs == rebased_substs =>\n+            ty::Alias(ty::Projection, proj)\n+                if proj.def_id == trait_ty.def_id && proj.substs == rebased_substs =>\n             {\n                 // Don't include this predicate if the projected type is\n                 // exactly the same as the projection. This can occur in\n@@ -1746,10 +1778,7 @@ pub fn check_type_bounds<'tcx>(\n             _ => predicates.push(\n                 ty::Binder::bind_with_vars(\n                     ty::ProjectionPredicate {\n-                        projection_ty: ty::ProjectionTy {\n-                            item_def_id: trait_ty.def_id,\n-                            substs: rebased_substs,\n-                        },\n+                        projection_ty: tcx.mk_alias_ty(trait_ty.def_id, rebased_substs),\n                         term: impl_ty_value.into(),\n                     },\n                     bound_vars,"}, {"sha": "57f0cae12bb312bb5afd14d971fed8bac0ad31a1", "filename": "compiler/rustc_hir_analysis/src/check/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -352,11 +352,7 @@ fn bounds_from_generic_predicates<'tcx>(\n         // insert the associated types where they correspond, but for now let's be \"lazy\" and\n         // propose this instead of the following valid resugaring:\n         // `T: Trait, Trait::Assoc = K` \u2192 `T: Trait<Assoc = K>`\n-        where_clauses.push(format!(\n-            \"{} = {}\",\n-            tcx.def_path_str(p.projection_ty.item_def_id),\n-            p.term,\n-        ));\n+        where_clauses.push(format!(\"{} = {}\", tcx.def_path_str(p.projection_ty.def_id), p.term));\n     }\n     let where_clauses = if where_clauses.is_empty() {\n         String::new()"}, {"sha": "94d333c336ef3f2768267d1ea3ce72147dd57e25", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -31,7 +31,6 @@ use rustc_trait_selection::traits::{\n };\n \n use std::cell::LazyCell;\n-use std::convert::TryInto;\n use std::iter;\n use std::ops::{ControlFlow, Deref};\n \n@@ -760,7 +759,7 @@ impl<'tcx> TypeVisitor<'tcx> for GATSubstCollector<'tcx> {\n \n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         match t.kind() {\n-            ty::Projection(p) if p.item_def_id == self.gat => {\n+            ty::Alias(ty::Projection, p) if p.def_id == self.gat => {\n                 for (idx, subst) in p.substs.iter().enumerate() {\n                     match subst.unpack() {\n                         GenericArgKind::Lifetime(lt) if !lt.is_late_bound() => {\n@@ -1593,12 +1592,12 @@ fn check_return_position_impl_trait_in_trait_bounds<'tcx>(\n     {\n         for arg in fn_output.walk() {\n             if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-                && let ty::Projection(proj) = ty.kind()\n-                && tcx.def_kind(proj.item_def_id) == DefKind::ImplTraitPlaceholder\n-                && tcx.impl_trait_in_trait_parent(proj.item_def_id) == fn_def_id.to_def_id()\n+                && let ty::Alias(ty::Projection, proj) = ty.kind()\n+                && tcx.def_kind(proj.def_id) == DefKind::ImplTraitPlaceholder\n+                && tcx.impl_trait_in_trait_parent(proj.def_id) == fn_def_id.to_def_id()\n             {\n-                let span = tcx.def_span(proj.item_def_id);\n-                let bounds = wfcx.tcx().explicit_item_bounds(proj.item_def_id);\n+                let span = tcx.def_span(proj.def_id);\n+                let bounds = wfcx.tcx().explicit_item_bounds(proj.def_id);\n                 let wf_obligations = bounds.iter().flat_map(|&(bound, bound_span)| {\n                     let bound = ty::EarlyBinder(bound).subst(tcx, proj.substs);\n                     let normalized_bound = wfcx.normalize(span, None, bound);"}, {"sha": "6469f389bf91b313141ce01452fe74cb68b72f98", "filename": "compiler/rustc_hir_analysis/src/coherence/inherent_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -223,7 +223,7 @@ impl<'tcx> InherentCollect<'tcx> {\n             | ty::Tuple(..) => {\n                 self.check_primitive_impl(item.owner_id.def_id, self_ty, items, ty.span)\n             }\n-            ty::Projection(..) | ty::Opaque(..) | ty::Param(_) => {\n+            ty::Alias(..) | ty::Param(_) => {\n                 let mut err = struct_span_err!(\n                     self.tcx.sess,\n                     ty.span,"}, {"sha": "0c4649cea14edda97552e175a99e877201d87690", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 5, "deletions": 810, "changes": 815, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -17,28 +17,20 @@\n use crate::astconv::AstConv;\n use crate::check::intrinsic::intrinsic_operation_unsafety;\n use crate::errors;\n-use rustc_ast as ast;\n-use rustc_ast::{MetaItemKind, NestedMetaItem};\n-use rustc_attr::{list_contains_name, InlineAttr, InstructionSetAttr, OptimizeAttr};\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed, StashKey};\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, LocalDefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::weak_lang_items::WEAK_LANG_ITEMS;\n-use rustc_hir::{lang_items, GenericParamKind, LangItem, Node};\n+use rustc_hir::{GenericParamKind, Node};\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n-use rustc_middle::mir::mono::Linkage;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::util::{Discr, IntTypeExt};\n-use rustc_middle::ty::{self, AdtKind, Const, DefIdTree, IsSuggestable, ToPredicate, Ty, TyCtxt};\n-use rustc_session::lint;\n-use rustc_session::parse::feature_err;\n+use rustc_middle::ty::{self, AdtKind, Const, IsSuggestable, ToPredicate, Ty, TyCtxt};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n-use rustc_target::spec::{abi, SanitizerSet};\n+use rustc_target::spec::abi;\n use rustc_trait_selection::traits::error_reporting::suggestions::NextTypeParamName;\n use std::iter;\n \n@@ -78,10 +70,7 @@ pub fn provide(providers: &mut Providers) {\n         impl_polarity,\n         is_foreign_item,\n         generator_kind,\n-        codegen_fn_attrs,\n-        asm_target_features,\n         collect_mod_item_types,\n-        should_inherit_track_caller,\n         ..*providers\n     };\n }\n@@ -500,7 +489,7 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n                         format!(\n                             \"{}::\",\n                             // Erase named lt, we want `<A as B<'_>::C`, not `<A as B<'a>::C`.\n-                            self.tcx.anonymize_late_bound_regions(poly_trait_ref).skip_binder(),\n+                            self.tcx.anonymize_bound_vars(poly_trait_ref).skip_binder(),\n                         ),\n                         Applicability::MaybeIncorrect,\n                     );\n@@ -1455,797 +1444,3 @@ fn generator_kind(tcx: TyCtxt<'_>, def_id: DefId) -> Option<hir::GeneratorKind>\n         _ => bug!(\"generator_kind applied to non-local def-id {:?}\", def_id),\n     }\n }\n-\n-fn from_target_feature(\n-    tcx: TyCtxt<'_>,\n-    attr: &ast::Attribute,\n-    supported_target_features: &FxHashMap<String, Option<Symbol>>,\n-    target_features: &mut Vec<Symbol>,\n-) {\n-    let Some(list) = attr.meta_item_list() else { return };\n-    let bad_item = |span| {\n-        let msg = \"malformed `target_feature` attribute input\";\n-        let code = \"enable = \\\"..\\\"\";\n-        tcx.sess\n-            .struct_span_err(span, msg)\n-            .span_suggestion(span, \"must be of the form\", code, Applicability::HasPlaceholders)\n-            .emit();\n-    };\n-    let rust_features = tcx.features();\n-    for item in list {\n-        // Only `enable = ...` is accepted in the meta-item list.\n-        if !item.has_name(sym::enable) {\n-            bad_item(item.span());\n-            continue;\n-        }\n-\n-        // Must be of the form `enable = \"...\"` (a string).\n-        let Some(value) = item.value_str() else {\n-            bad_item(item.span());\n-            continue;\n-        };\n-\n-        // We allow comma separation to enable multiple features.\n-        target_features.extend(value.as_str().split(',').filter_map(|feature| {\n-            let Some(feature_gate) = supported_target_features.get(feature) else {\n-                let msg =\n-                    format!(\"the feature named `{}` is not valid for this target\", feature);\n-                let mut err = tcx.sess.struct_span_err(item.span(), &msg);\n-                err.span_label(\n-                    item.span(),\n-                    format!(\"`{}` is not valid for this target\", feature),\n-                );\n-                if let Some(stripped) = feature.strip_prefix('+') {\n-                    let valid = supported_target_features.contains_key(stripped);\n-                    if valid {\n-                        err.help(\"consider removing the leading `+` in the feature name\");\n-                    }\n-                }\n-                err.emit();\n-                return None;\n-            };\n-\n-            // Only allow features whose feature gates have been enabled.\n-            let allowed = match feature_gate.as_ref().copied() {\n-                Some(sym::arm_target_feature) => rust_features.arm_target_feature,\n-                Some(sym::hexagon_target_feature) => rust_features.hexagon_target_feature,\n-                Some(sym::powerpc_target_feature) => rust_features.powerpc_target_feature,\n-                Some(sym::mips_target_feature) => rust_features.mips_target_feature,\n-                Some(sym::riscv_target_feature) => rust_features.riscv_target_feature,\n-                Some(sym::avx512_target_feature) => rust_features.avx512_target_feature,\n-                Some(sym::sse4a_target_feature) => rust_features.sse4a_target_feature,\n-                Some(sym::tbm_target_feature) => rust_features.tbm_target_feature,\n-                Some(sym::wasm_target_feature) => rust_features.wasm_target_feature,\n-                Some(sym::cmpxchg16b_target_feature) => rust_features.cmpxchg16b_target_feature,\n-                Some(sym::movbe_target_feature) => rust_features.movbe_target_feature,\n-                Some(sym::rtm_target_feature) => rust_features.rtm_target_feature,\n-                Some(sym::f16c_target_feature) => rust_features.f16c_target_feature,\n-                Some(sym::ermsb_target_feature) => rust_features.ermsb_target_feature,\n-                Some(sym::bpf_target_feature) => rust_features.bpf_target_feature,\n-                Some(sym::aarch64_ver_target_feature) => rust_features.aarch64_ver_target_feature,\n-                Some(name) => bug!(\"unknown target feature gate {}\", name),\n-                None => true,\n-            };\n-            if !allowed {\n-                feature_err(\n-                    &tcx.sess.parse_sess,\n-                    feature_gate.unwrap(),\n-                    item.span(),\n-                    &format!(\"the target feature `{}` is currently unstable\", feature),\n-                )\n-                .emit();\n-            }\n-            Some(Symbol::intern(feature))\n-        }));\n-    }\n-}\n-\n-fn linkage_by_name(tcx: TyCtxt<'_>, def_id: LocalDefId, name: &str) -> Linkage {\n-    use rustc_middle::mir::mono::Linkage::*;\n-\n-    // Use the names from src/llvm/docs/LangRef.rst here. Most types are only\n-    // applicable to variable declarations and may not really make sense for\n-    // Rust code in the first place but allow them anyway and trust that the\n-    // user knows what they're doing. Who knows, unanticipated use cases may pop\n-    // up in the future.\n-    //\n-    // ghost, dllimport, dllexport and linkonce_odr_autohide are not supported\n-    // and don't have to be, LLVM treats them as no-ops.\n-    match name {\n-        \"appending\" => Appending,\n-        \"available_externally\" => AvailableExternally,\n-        \"common\" => Common,\n-        \"extern_weak\" => ExternalWeak,\n-        \"external\" => External,\n-        \"internal\" => Internal,\n-        \"linkonce\" => LinkOnceAny,\n-        \"linkonce_odr\" => LinkOnceODR,\n-        \"private\" => Private,\n-        \"weak\" => WeakAny,\n-        \"weak_odr\" => WeakODR,\n-        _ => tcx.sess.span_fatal(tcx.def_span(def_id), \"invalid linkage specified\"),\n-    }\n-}\n-\n-fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n-    if cfg!(debug_assertions) {\n-        let def_kind = tcx.def_kind(did);\n-        assert!(\n-            def_kind.has_codegen_attrs(),\n-            \"unexpected `def_kind` in `codegen_fn_attrs`: {def_kind:?}\",\n-        );\n-    }\n-\n-    let did = did.expect_local();\n-    let attrs = tcx.hir().attrs(tcx.hir().local_def_id_to_hir_id(did));\n-    let mut codegen_fn_attrs = CodegenFnAttrs::new();\n-    if tcx.should_inherit_track_caller(did) {\n-        codegen_fn_attrs.flags |= CodegenFnAttrFlags::TRACK_CALLER;\n-    }\n-\n-    let supported_target_features = tcx.supported_target_features(LOCAL_CRATE);\n-\n-    let mut inline_span = None;\n-    let mut link_ordinal_span = None;\n-    let mut no_sanitize_span = None;\n-    for attr in attrs.iter() {\n-        if attr.has_name(sym::cold) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::COLD;\n-        } else if attr.has_name(sym::rustc_allocator) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::ALLOCATOR;\n-        } else if attr.has_name(sym::ffi_returns_twice) {\n-            if tcx.is_foreign_item(did) {\n-                codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_RETURNS_TWICE;\n-            } else {\n-                // `#[ffi_returns_twice]` is only allowed `extern fn`s.\n-                struct_span_err!(\n-                    tcx.sess,\n-                    attr.span,\n-                    E0724,\n-                    \"`#[ffi_returns_twice]` may only be used on foreign functions\"\n-                )\n-                .emit();\n-            }\n-        } else if attr.has_name(sym::ffi_pure) {\n-            if tcx.is_foreign_item(did) {\n-                if attrs.iter().any(|a| a.has_name(sym::ffi_const)) {\n-                    // `#[ffi_const]` functions cannot be `#[ffi_pure]`\n-                    struct_span_err!(\n-                        tcx.sess,\n-                        attr.span,\n-                        E0757,\n-                        \"`#[ffi_const]` function cannot be `#[ffi_pure]`\"\n-                    )\n-                    .emit();\n-                } else {\n-                    codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_PURE;\n-                }\n-            } else {\n-                // `#[ffi_pure]` is only allowed on foreign functions\n-                struct_span_err!(\n-                    tcx.sess,\n-                    attr.span,\n-                    E0755,\n-                    \"`#[ffi_pure]` may only be used on foreign functions\"\n-                )\n-                .emit();\n-            }\n-        } else if attr.has_name(sym::ffi_const) {\n-            if tcx.is_foreign_item(did) {\n-                codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_CONST;\n-            } else {\n-                // `#[ffi_const]` is only allowed on foreign functions\n-                struct_span_err!(\n-                    tcx.sess,\n-                    attr.span,\n-                    E0756,\n-                    \"`#[ffi_const]` may only be used on foreign functions\"\n-                )\n-                .emit();\n-            }\n-        } else if attr.has_name(sym::rustc_nounwind) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NEVER_UNWIND;\n-        } else if attr.has_name(sym::rustc_reallocator) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::REALLOCATOR;\n-        } else if attr.has_name(sym::rustc_deallocator) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::DEALLOCATOR;\n-        } else if attr.has_name(sym::rustc_allocator_zeroed) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::ALLOCATOR_ZEROED;\n-        } else if attr.has_name(sym::naked) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NAKED;\n-        } else if attr.has_name(sym::no_mangle) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_MANGLE;\n-        } else if attr.has_name(sym::no_coverage) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_COVERAGE;\n-        } else if attr.has_name(sym::rustc_std_internal_symbol) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n-        } else if attr.has_name(sym::used) {\n-            let inner = attr.meta_item_list();\n-            match inner.as_deref() {\n-                Some([item]) if item.has_name(sym::linker) => {\n-                    if !tcx.features().used_with_arg {\n-                        feature_err(\n-                            &tcx.sess.parse_sess,\n-                            sym::used_with_arg,\n-                            attr.span,\n-                            \"`#[used(linker)]` is currently unstable\",\n-                        )\n-                        .emit();\n-                    }\n-                    codegen_fn_attrs.flags |= CodegenFnAttrFlags::USED_LINKER;\n-                }\n-                Some([item]) if item.has_name(sym::compiler) => {\n-                    if !tcx.features().used_with_arg {\n-                        feature_err(\n-                            &tcx.sess.parse_sess,\n-                            sym::used_with_arg,\n-                            attr.span,\n-                            \"`#[used(compiler)]` is currently unstable\",\n-                        )\n-                        .emit();\n-                    }\n-                    codegen_fn_attrs.flags |= CodegenFnAttrFlags::USED;\n-                }\n-                Some(_) => {\n-                    tcx.sess.emit_err(errors::ExpectedUsedSymbol { span: attr.span });\n-                }\n-                None => {\n-                    // Unfortunately, unconditionally using `llvm.used` causes\n-                    // issues in handling `.init_array` with the gold linker,\n-                    // but using `llvm.compiler.used` caused a nontrival amount\n-                    // of unintentional ecosystem breakage -- particularly on\n-                    // Mach-O targets.\n-                    //\n-                    // As a result, we emit `llvm.compiler.used` only on ELF\n-                    // targets. This is somewhat ad-hoc, but actually follows\n-                    // our pre-LLVM 13 behavior (prior to the ecosystem\n-                    // breakage), and seems to match `clang`'s behavior as well\n-                    // (both before and after LLVM 13), possibly because they\n-                    // have similar compatibility concerns to us. See\n-                    // https://github.com/rust-lang/rust/issues/47384#issuecomment-1019080146\n-                    // and following comments for some discussion of this, as\n-                    // well as the comments in `rustc_codegen_llvm` where these\n-                    // flags are handled.\n-                    //\n-                    // Anyway, to be clear: this is still up in the air\n-                    // somewhat, and is subject to change in the future (which\n-                    // is a good thing, because this would ideally be a bit\n-                    // more firmed up).\n-                    let is_like_elf = !(tcx.sess.target.is_like_osx\n-                        || tcx.sess.target.is_like_windows\n-                        || tcx.sess.target.is_like_wasm);\n-                    codegen_fn_attrs.flags |= if is_like_elf {\n-                        CodegenFnAttrFlags::USED\n-                    } else {\n-                        CodegenFnAttrFlags::USED_LINKER\n-                    };\n-                }\n-            }\n-        } else if attr.has_name(sym::cmse_nonsecure_entry) {\n-            if !matches!(tcx.fn_sig(did).abi(), abi::Abi::C { .. }) {\n-                struct_span_err!(\n-                    tcx.sess,\n-                    attr.span,\n-                    E0776,\n-                    \"`#[cmse_nonsecure_entry]` requires C ABI\"\n-                )\n-                .emit();\n-            }\n-            if !tcx.sess.target.llvm_target.contains(\"thumbv8m\") {\n-                struct_span_err!(tcx.sess, attr.span, E0775, \"`#[cmse_nonsecure_entry]` is only valid for targets with the TrustZone-M extension\")\n-                    .emit();\n-            }\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::CMSE_NONSECURE_ENTRY;\n-        } else if attr.has_name(sym::thread_local) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::THREAD_LOCAL;\n-        } else if attr.has_name(sym::track_caller) {\n-            if !tcx.is_closure(did.to_def_id()) && tcx.fn_sig(did).abi() != abi::Abi::Rust {\n-                struct_span_err!(tcx.sess, attr.span, E0737, \"`#[track_caller]` requires Rust ABI\")\n-                    .emit();\n-            }\n-            if tcx.is_closure(did.to_def_id()) && !tcx.features().closure_track_caller {\n-                feature_err(\n-                    &tcx.sess.parse_sess,\n-                    sym::closure_track_caller,\n-                    attr.span,\n-                    \"`#[track_caller]` on closures is currently unstable\",\n-                )\n-                .emit();\n-            }\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::TRACK_CALLER;\n-        } else if attr.has_name(sym::export_name) {\n-            if let Some(s) = attr.value_str() {\n-                if s.as_str().contains('\\0') {\n-                    // `#[export_name = ...]` will be converted to a null-terminated string,\n-                    // so it may not contain any null characters.\n-                    struct_span_err!(\n-                        tcx.sess,\n-                        attr.span,\n-                        E0648,\n-                        \"`export_name` may not contain null characters\"\n-                    )\n-                    .emit();\n-                }\n-                codegen_fn_attrs.export_name = Some(s);\n-            }\n-        } else if attr.has_name(sym::target_feature) {\n-            if !tcx.is_closure(did.to_def_id())\n-                && tcx.fn_sig(did).unsafety() == hir::Unsafety::Normal\n-            {\n-                if tcx.sess.target.is_like_wasm || tcx.sess.opts.actually_rustdoc {\n-                    // The `#[target_feature]` attribute is allowed on\n-                    // WebAssembly targets on all functions, including safe\n-                    // ones. Other targets require that `#[target_feature]` is\n-                    // only applied to unsafe functions (pending the\n-                    // `target_feature_11` feature) because on most targets\n-                    // execution of instructions that are not supported is\n-                    // considered undefined behavior. For WebAssembly which is a\n-                    // 100% safe target at execution time it's not possible to\n-                    // execute undefined instructions, and even if a future\n-                    // feature was added in some form for this it would be a\n-                    // deterministic trap. There is no undefined behavior when\n-                    // executing WebAssembly so `#[target_feature]` is allowed\n-                    // on safe functions (but again, only for WebAssembly)\n-                    //\n-                    // Note that this is also allowed if `actually_rustdoc` so\n-                    // if a target is documenting some wasm-specific code then\n-                    // it's not spuriously denied.\n-                } else if !tcx.features().target_feature_11 {\n-                    let mut err = feature_err(\n-                        &tcx.sess.parse_sess,\n-                        sym::target_feature_11,\n-                        attr.span,\n-                        \"`#[target_feature(..)]` can only be applied to `unsafe` functions\",\n-                    );\n-                    err.span_label(tcx.def_span(did), \"not an `unsafe` function\");\n-                    err.emit();\n-                } else {\n-                    check_target_feature_trait_unsafe(tcx, did, attr.span);\n-                }\n-            }\n-            from_target_feature(\n-                tcx,\n-                attr,\n-                supported_target_features,\n-                &mut codegen_fn_attrs.target_features,\n-            );\n-        } else if attr.has_name(sym::linkage) {\n-            if let Some(val) = attr.value_str() {\n-                let linkage = Some(linkage_by_name(tcx, did, val.as_str()));\n-                if tcx.is_foreign_item(did) {\n-                    codegen_fn_attrs.import_linkage = linkage;\n-                } else {\n-                    codegen_fn_attrs.linkage = linkage;\n-                }\n-            }\n-        } else if attr.has_name(sym::link_section) {\n-            if let Some(val) = attr.value_str() {\n-                if val.as_str().bytes().any(|b| b == 0) {\n-                    let msg = format!(\n-                        \"illegal null byte in link_section \\\n-                         value: `{}`\",\n-                        &val\n-                    );\n-                    tcx.sess.span_err(attr.span, &msg);\n-                } else {\n-                    codegen_fn_attrs.link_section = Some(val);\n-                }\n-            }\n-        } else if attr.has_name(sym::link_name) {\n-            codegen_fn_attrs.link_name = attr.value_str();\n-        } else if attr.has_name(sym::link_ordinal) {\n-            link_ordinal_span = Some(attr.span);\n-            if let ordinal @ Some(_) = check_link_ordinal(tcx, attr) {\n-                codegen_fn_attrs.link_ordinal = ordinal;\n-            }\n-        } else if attr.has_name(sym::no_sanitize) {\n-            no_sanitize_span = Some(attr.span);\n-            if let Some(list) = attr.meta_item_list() {\n-                for item in list.iter() {\n-                    if item.has_name(sym::address) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::ADDRESS;\n-                    } else if item.has_name(sym::cfi) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::CFI;\n-                    } else if item.has_name(sym::kcfi) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::KCFI;\n-                    } else if item.has_name(sym::memory) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::MEMORY;\n-                    } else if item.has_name(sym::memtag) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::MEMTAG;\n-                    } else if item.has_name(sym::shadow_call_stack) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::SHADOWCALLSTACK;\n-                    } else if item.has_name(sym::thread) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::THREAD;\n-                    } else if item.has_name(sym::hwaddress) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::HWADDRESS;\n-                    } else {\n-                        tcx.sess\n-                            .struct_span_err(item.span(), \"invalid argument for `no_sanitize`\")\n-                            .note(\"expected one of: `address`, `cfi`, `hwaddress`, `kcfi`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\")\n-                            .emit();\n-                    }\n-                }\n-            }\n-        } else if attr.has_name(sym::instruction_set) {\n-            codegen_fn_attrs.instruction_set = match attr.meta_kind() {\n-                Some(MetaItemKind::List(ref items)) => match items.as_slice() {\n-                    [NestedMetaItem::MetaItem(set)] => {\n-                        let segments =\n-                            set.path.segments.iter().map(|x| x.ident.name).collect::<Vec<_>>();\n-                        match segments.as_slice() {\n-                            [sym::arm, sym::a32] | [sym::arm, sym::t32] => {\n-                                if !tcx.sess.target.has_thumb_interworking {\n-                                    struct_span_err!(\n-                                        tcx.sess.diagnostic(),\n-                                        attr.span,\n-                                        E0779,\n-                                        \"target does not support `#[instruction_set]`\"\n-                                    )\n-                                    .emit();\n-                                    None\n-                                } else if segments[1] == sym::a32 {\n-                                    Some(InstructionSetAttr::ArmA32)\n-                                } else if segments[1] == sym::t32 {\n-                                    Some(InstructionSetAttr::ArmT32)\n-                                } else {\n-                                    unreachable!()\n-                                }\n-                            }\n-                            _ => {\n-                                struct_span_err!(\n-                                    tcx.sess.diagnostic(),\n-                                    attr.span,\n-                                    E0779,\n-                                    \"invalid instruction set specified\",\n-                                )\n-                                .emit();\n-                                None\n-                            }\n-                        }\n-                    }\n-                    [] => {\n-                        struct_span_err!(\n-                            tcx.sess.diagnostic(),\n-                            attr.span,\n-                            E0778,\n-                            \"`#[instruction_set]` requires an argument\"\n-                        )\n-                        .emit();\n-                        None\n-                    }\n-                    _ => {\n-                        struct_span_err!(\n-                            tcx.sess.diagnostic(),\n-                            attr.span,\n-                            E0779,\n-                            \"cannot specify more than one instruction set\"\n-                        )\n-                        .emit();\n-                        None\n-                    }\n-                },\n-                _ => {\n-                    struct_span_err!(\n-                        tcx.sess.diagnostic(),\n-                        attr.span,\n-                        E0778,\n-                        \"must specify an instruction set\"\n-                    )\n-                    .emit();\n-                    None\n-                }\n-            };\n-        } else if attr.has_name(sym::repr) {\n-            codegen_fn_attrs.alignment = match attr.meta_item_list() {\n-                Some(items) => match items.as_slice() {\n-                    [item] => match item.name_value_literal() {\n-                        Some((sym::align, literal)) => {\n-                            let alignment = rustc_attr::parse_alignment(&literal.kind);\n-\n-                            match alignment {\n-                                Ok(align) => Some(align),\n-                                Err(msg) => {\n-                                    struct_span_err!(\n-                                        tcx.sess.diagnostic(),\n-                                        attr.span,\n-                                        E0589,\n-                                        \"invalid `repr(align)` attribute: {}\",\n-                                        msg\n-                                    )\n-                                    .emit();\n-\n-                                    None\n-                                }\n-                            }\n-                        }\n-                        _ => None,\n-                    },\n-                    [] => None,\n-                    _ => None,\n-                },\n-                None => None,\n-            };\n-        }\n-    }\n-\n-    codegen_fn_attrs.inline = attrs.iter().fold(InlineAttr::None, |ia, attr| {\n-        if !attr.has_name(sym::inline) {\n-            return ia;\n-        }\n-        match attr.meta_kind() {\n-            Some(MetaItemKind::Word) => InlineAttr::Hint,\n-            Some(MetaItemKind::List(ref items)) => {\n-                inline_span = Some(attr.span);\n-                if items.len() != 1 {\n-                    struct_span_err!(\n-                        tcx.sess.diagnostic(),\n-                        attr.span,\n-                        E0534,\n-                        \"expected one argument\"\n-                    )\n-                    .emit();\n-                    InlineAttr::None\n-                } else if list_contains_name(&items, sym::always) {\n-                    InlineAttr::Always\n-                } else if list_contains_name(&items, sym::never) {\n-                    InlineAttr::Never\n-                } else {\n-                    struct_span_err!(\n-                        tcx.sess.diagnostic(),\n-                        items[0].span(),\n-                        E0535,\n-                        \"invalid argument\"\n-                    )\n-                    .help(\"valid inline arguments are `always` and `never`\")\n-                    .emit();\n-\n-                    InlineAttr::None\n-                }\n-            }\n-            Some(MetaItemKind::NameValue(_)) => ia,\n-            None => ia,\n-        }\n-    });\n-\n-    codegen_fn_attrs.optimize = attrs.iter().fold(OptimizeAttr::None, |ia, attr| {\n-        if !attr.has_name(sym::optimize) {\n-            return ia;\n-        }\n-        let err = |sp, s| struct_span_err!(tcx.sess.diagnostic(), sp, E0722, \"{}\", s).emit();\n-        match attr.meta_kind() {\n-            Some(MetaItemKind::Word) => {\n-                err(attr.span, \"expected one argument\");\n-                ia\n-            }\n-            Some(MetaItemKind::List(ref items)) => {\n-                inline_span = Some(attr.span);\n-                if items.len() != 1 {\n-                    err(attr.span, \"expected one argument\");\n-                    OptimizeAttr::None\n-                } else if list_contains_name(&items, sym::size) {\n-                    OptimizeAttr::Size\n-                } else if list_contains_name(&items, sym::speed) {\n-                    OptimizeAttr::Speed\n-                } else {\n-                    err(items[0].span(), \"invalid argument\");\n-                    OptimizeAttr::None\n-                }\n-            }\n-            Some(MetaItemKind::NameValue(_)) => ia,\n-            None => ia,\n-        }\n-    });\n-\n-    // #73631: closures inherit `#[target_feature]` annotations\n-    if tcx.features().target_feature_11 && tcx.is_closure(did.to_def_id()) {\n-        let owner_id = tcx.parent(did.to_def_id());\n-        if tcx.def_kind(owner_id).has_codegen_attrs() {\n-            codegen_fn_attrs\n-                .target_features\n-                .extend(tcx.codegen_fn_attrs(owner_id).target_features.iter().copied());\n-        }\n-    }\n-\n-    // If a function uses #[target_feature] it can't be inlined into general\n-    // purpose functions as they wouldn't have the right target features\n-    // enabled. For that reason we also forbid #[inline(always)] as it can't be\n-    // respected.\n-    if !codegen_fn_attrs.target_features.is_empty() {\n-        if codegen_fn_attrs.inline == InlineAttr::Always {\n-            if let Some(span) = inline_span {\n-                tcx.sess.span_err(\n-                    span,\n-                    \"cannot use `#[inline(always)]` with \\\n-                     `#[target_feature]`\",\n-                );\n-            }\n-        }\n-    }\n-\n-    if !codegen_fn_attrs.no_sanitize.is_empty() {\n-        if codegen_fn_attrs.inline == InlineAttr::Always {\n-            if let (Some(no_sanitize_span), Some(inline_span)) = (no_sanitize_span, inline_span) {\n-                let hir_id = tcx.hir().local_def_id_to_hir_id(did);\n-                tcx.struct_span_lint_hir(\n-                    lint::builtin::INLINE_NO_SANITIZE,\n-                    hir_id,\n-                    no_sanitize_span,\n-                    \"`no_sanitize` will have no effect after inlining\",\n-                    |lint| lint.span_note(inline_span, \"inlining requested here\"),\n-                )\n-            }\n-        }\n-    }\n-\n-    if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::NAKED) {\n-        codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_COVERAGE;\n-        codegen_fn_attrs.inline = InlineAttr::Never;\n-    }\n-\n-    // Weak lang items have the same semantics as \"std internal\" symbols in the\n-    // sense that they're preserved through all our LTO passes and only\n-    // strippable by the linker.\n-    //\n-    // Additionally weak lang items have predetermined symbol names.\n-    if WEAK_LANG_ITEMS.iter().any(|&l| tcx.lang_items().get(l) == Some(did.to_def_id())) {\n-        codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n-    }\n-    if let Some((name, _)) = lang_items::extract(attrs)\n-        && let Some(lang_item) = LangItem::from_name(name)\n-        && let Some(link_name) = lang_item.link_name()\n-    {\n-        codegen_fn_attrs.export_name = Some(link_name);\n-        codegen_fn_attrs.link_name = Some(link_name);\n-    }\n-    check_link_name_xor_ordinal(tcx, &codegen_fn_attrs, link_ordinal_span);\n-\n-    // Internal symbols to the standard library all have no_mangle semantics in\n-    // that they have defined symbol names present in the function name. This\n-    // also applies to weak symbols where they all have known symbol names.\n-    if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL) {\n-        codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_MANGLE;\n-    }\n-\n-    // Any linkage to LLVM intrinsics for now forcibly marks them all as never\n-    // unwinds since LLVM sometimes can't handle codegen which `invoke`s\n-    // intrinsic functions.\n-    if let Some(name) = &codegen_fn_attrs.link_name {\n-        if name.as_str().starts_with(\"llvm.\") {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NEVER_UNWIND;\n-        }\n-    }\n-\n-    codegen_fn_attrs\n-}\n-\n-/// Computes the set of target features used in a function for the purposes of\n-/// inline assembly.\n-fn asm_target_features<'tcx>(tcx: TyCtxt<'tcx>, did: DefId) -> &'tcx FxHashSet<Symbol> {\n-    let mut target_features = tcx.sess.unstable_target_features.clone();\n-    if tcx.def_kind(did).has_codegen_attrs() {\n-        let attrs = tcx.codegen_fn_attrs(did);\n-        target_features.extend(&attrs.target_features);\n-        match attrs.instruction_set {\n-            None => {}\n-            Some(InstructionSetAttr::ArmA32) => {\n-                target_features.remove(&sym::thumb_mode);\n-            }\n-            Some(InstructionSetAttr::ArmT32) => {\n-                target_features.insert(sym::thumb_mode);\n-            }\n-        }\n-    }\n-\n-    tcx.arena.alloc(target_features)\n-}\n-\n-/// Checks if the provided DefId is a method in a trait impl for a trait which has track_caller\n-/// applied to the method prototype.\n-fn should_inherit_track_caller(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    if let Some(impl_item) = tcx.opt_associated_item(def_id)\n-        && let ty::AssocItemContainer::ImplContainer = impl_item.container\n-        && let Some(trait_item) = impl_item.trait_item_def_id\n-    {\n-        return tcx\n-            .codegen_fn_attrs(trait_item)\n-            .flags\n-            .intersects(CodegenFnAttrFlags::TRACK_CALLER);\n-    }\n-\n-    false\n-}\n-\n-fn check_link_ordinal(tcx: TyCtxt<'_>, attr: &ast::Attribute) -> Option<u16> {\n-    use rustc_ast::{LitIntType, LitKind, MetaItemLit};\n-    if !tcx.features().raw_dylib && tcx.sess.target.arch == \"x86\" {\n-        feature_err(\n-            &tcx.sess.parse_sess,\n-            sym::raw_dylib,\n-            attr.span,\n-            \"`#[link_ordinal]` is unstable on x86\",\n-        )\n-        .emit();\n-    }\n-    let meta_item_list = attr.meta_item_list();\n-    let meta_item_list = meta_item_list.as_deref();\n-    let sole_meta_list = match meta_item_list {\n-        Some([item]) => item.lit(),\n-        Some(_) => {\n-            tcx.sess\n-                .struct_span_err(attr.span, \"incorrect number of arguments to `#[link_ordinal]`\")\n-                .note(\"the attribute requires exactly one argument\")\n-                .emit();\n-            return None;\n-        }\n-        _ => None,\n-    };\n-    if let Some(MetaItemLit { kind: LitKind::Int(ordinal, LitIntType::Unsuffixed), .. }) =\n-        sole_meta_list\n-    {\n-        // According to the table at https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#import-header,\n-        // the ordinal must fit into 16 bits.  Similarly, the Ordinal field in COFFShortExport (defined\n-        // in llvm/include/llvm/Object/COFFImportFile.h), which we use to communicate import information\n-        // to LLVM for `#[link(kind = \"raw-dylib\"_])`, is also defined to be uint16_t.\n-        //\n-        // FIXME: should we allow an ordinal of 0?  The MSVC toolchain has inconsistent support for this:\n-        // both LINK.EXE and LIB.EXE signal errors and abort when given a .DEF file that specifies\n-        // a zero ordinal.  However, llvm-dlltool is perfectly happy to generate an import library\n-        // for such a .DEF file, and MSVC's LINK.EXE is also perfectly happy to consume an import\n-        // library produced by LLVM with an ordinal of 0, and it generates an .EXE.  (I don't know yet\n-        // if the resulting EXE runs, as I haven't yet built the necessary DLL -- see earlier comment\n-        // about LINK.EXE failing.)\n-        if *ordinal <= u16::MAX as u128 {\n-            Some(*ordinal as u16)\n-        } else {\n-            let msg = format!(\"ordinal value in `link_ordinal` is too large: `{}`\", &ordinal);\n-            tcx.sess\n-                .struct_span_err(attr.span, &msg)\n-                .note(\"the value may not exceed `u16::MAX`\")\n-                .emit();\n-            None\n-        }\n-    } else {\n-        tcx.sess\n-            .struct_span_err(attr.span, \"illegal ordinal format in `link_ordinal`\")\n-            .note(\"an unsuffixed integer value, e.g., `1`, is expected\")\n-            .emit();\n-        None\n-    }\n-}\n-\n-fn check_link_name_xor_ordinal(\n-    tcx: TyCtxt<'_>,\n-    codegen_fn_attrs: &CodegenFnAttrs,\n-    inline_span: Option<Span>,\n-) {\n-    if codegen_fn_attrs.link_name.is_none() || codegen_fn_attrs.link_ordinal.is_none() {\n-        return;\n-    }\n-    let msg = \"cannot use `#[link_name]` with `#[link_ordinal]`\";\n-    if let Some(span) = inline_span {\n-        tcx.sess.span_err(span, msg);\n-    } else {\n-        tcx.sess.err(msg);\n-    }\n-}\n-\n-/// Checks the function annotated with `#[target_feature]` is not a safe\n-/// trait method implementation, reporting an error if it is.\n-fn check_target_feature_trait_unsafe(tcx: TyCtxt<'_>, id: LocalDefId, attr_span: Span) {\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(id);\n-    let node = tcx.hir().get(hir_id);\n-    if let Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }) = node {\n-        let parent_id = tcx.hir().get_parent_item(hir_id);\n-        let parent_item = tcx.hir().expect_item(parent_id.def_id);\n-        if let hir::ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }) = parent_item.kind {\n-            tcx.sess\n-                .struct_span_err(\n-                    attr_span,\n-                    \"`#[target_feature(..)]` cannot be applied to safe trait method\",\n-                )\n-                .span_label(attr_span, \"cannot be applied to safe trait method\")\n-                .span_label(tcx.def_span(id), \"not an `unsafe` function\")\n-                .emit();\n-        }\n-    }\n-}"}, {"sha": "b4ad3467e7d87ac67cac22c7705cedb92ea5cccf", "filename": "compiler/rustc_hir_analysis/src/collect/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1749,7 +1749,7 @@ fn is_late_bound_map(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<&FxIndexSet<\n                 ty::Param(param_ty) => {\n                     self.arg_is_constrained[param_ty.index as usize] = true;\n                 }\n-                ty::Projection(_) => return ControlFlow::Continue(()),\n+                ty::Alias(ty::Projection, _) => return ControlFlow::Continue(()),\n                 _ => (),\n             }\n             t.super_visit_with(self)"}, {"sha": "79d75231e5d76d04024a44ebcc76621ea4449ecb", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -75,7 +75,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n \n     const NO_GENERICS: &hir::Generics<'_> = hir::Generics::empty();\n \n-    // We use an `IndexSet` to preserves order of insertion.\n+    // We use an `IndexSet` to preserve order of insertion.\n     // Preserving the order of insertion is important here so as not to break UI tests.\n     let mut predicates: FxIndexSet<(ty::Predicate<'_>, Span)> = FxIndexSet::default();\n \n@@ -97,11 +97,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n             | ItemKind::Struct(_, ref generics)\n             | ItemKind::Union(_, ref generics) => *generics,\n \n-            ItemKind::Trait(_, _, ref generics, ..) => {\n-                is_trait = Some(ty::TraitRef::identity(tcx, def_id));\n-                *generics\n-            }\n-            ItemKind::TraitAlias(ref generics, _) => {\n+            ItemKind::Trait(_, _, ref generics, ..) | ItemKind::TraitAlias(ref generics, _) => {\n                 is_trait = Some(ty::TraitRef::identity(tcx, def_id));\n                 *generics\n             }\n@@ -406,14 +402,15 @@ pub(super) fn explicit_predicates_of<'tcx>(\n             // For a predicate from a where clause to become a bound on an\n             // associated type:\n             // * It must use the identity substs of the item.\n-            //     * Since any generic parameters on the item are not in scope,\n-            //       this means that the item is not a GAT, and its identity\n-            //       substs are the same as the trait's.\n+            //   * We're in the scope of the trait, so we can't name any\n+            //     parameters of the GAT. That means that all we need to\n+            //     check are that the substs of the projection are the\n+            //     identity substs of the trait.\n             // * It must be an associated type for this trait (*not* a\n             //   supertrait).\n-            if let ty::Projection(projection) = ty.kind() {\n+            if let ty::Alias(ty::Projection, projection) = ty.kind() {\n                 projection.substs == trait_identity_substs\n-                    && tcx.associated_item(projection.item_def_id).container_id(tcx) == def_id\n+                    && tcx.associated_item(projection.def_id).container_id(tcx) == def_id\n             } else {\n                 false\n             }"}, {"sha": "b678990f94e918ba6f9f26ad160b9771b19366b7", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -52,7 +52,7 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n             // Using the ItemCtxt convert the HIR for the unresolved assoc type into a\n             // ty which is a fully resolved projection.\n             // For the code example above, this would mean converting Self::Assoc<3>\n-            // into a ty::Projection(<Self as Foo>::Assoc<3>)\n+            // into a ty::Alias(ty::Projection, <Self as Foo>::Assoc<3>)\n             let item_hir_id = tcx\n                 .hir()\n                 .parent_iter(hir_id)\n@@ -68,8 +68,8 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n             // the def_id that this query was called with. We filter to only type and const args here\n             // as a precaution for if it's ever allowed to elide lifetimes in GAT's. It currently isn't\n             // but it can't hurt to be safe ^^\n-            if let ty::Projection(projection) = ty.kind() {\n-                let generics = tcx.generics_of(projection.item_def_id);\n+            if let ty::Alias(ty::Projection, projection) = ty.kind() {\n+                let generics = tcx.generics_of(projection.def_id);\n \n                 let arg_index = segment\n                     .args\n@@ -666,7 +666,7 @@ fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: LocalDefId) -> T\n \n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n     let scope = tcx.hir().get_defining_scope(hir_id);\n-    let mut locator = ConstraintLocator { def_id: def_id, tcx, found: None, typeck_types: vec![] };\n+    let mut locator = ConstraintLocator { def_id, tcx, found: None, typeck_types: vec![] };\n \n     debug!(?scope);\n \n@@ -803,7 +803,7 @@ fn find_opaque_ty_constraints_for_rpit(\n     if let Some(concrete) = concrete {\n         let scope = tcx.hir().local_def_id_to_hir_id(owner_def_id);\n         debug!(?scope);\n-        let mut locator = ConstraintChecker { def_id: def_id, tcx, found: concrete };\n+        let mut locator = ConstraintChecker { def_id, tcx, found: concrete };\n \n         match tcx.hir().get(scope) {\n             Node::Item(it) => intravisit::walk_item(&mut locator, it),"}, {"sha": "95c971c0d7845eee2d63668b8527c419b67eb4e6", "filename": "compiler/rustc_hir_analysis/src/constrained_generic_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -59,7 +59,7 @@ struct ParameterCollector {\n impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         match *t.kind() {\n-            ty::Projection(..) if !self.include_nonconstraining => {\n+            ty::Alias(ty::Projection, ..) if !self.include_nonconstraining => {\n                 // projections are not injective\n                 return ControlFlow::CONTINUE;\n             }"}, {"sha": "d383fcacb3a9c914ce0b862daf1386e8b52c453e", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -51,6 +51,17 @@ pub struct LifetimesOrBoundsMismatchOnTrait {\n     pub ident: Ident,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_async_trait_impl_should_be_async)]\n+pub struct AsyncTraitImplShouldBeAsync {\n+    #[primary_span]\n+    // #[label]\n+    pub span: Span,\n+    #[label(trait_item_label)]\n+    pub trait_item_span: Option<Span>,\n+    pub method_name: Symbol,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(hir_analysis_drop_impl_on_wrong_item, code = \"E0120\")]\n pub struct DropImplOnWrongItem {\n@@ -253,13 +264,6 @@ pub struct ExternCrateNotIdiomatic {\n     pub suggestion_code: String,\n }\n \n-#[derive(Diagnostic)]\n-#[diag(hir_analysis_expected_used_symbol)]\n-pub struct ExpectedUsedSymbol {\n-    #[primary_span]\n-    pub span: Span,\n-}\n-\n #[derive(Diagnostic)]\n #[diag(hir_analysis_const_impl_for_non_const_trait)]\n pub struct ConstImplForNonConstTrait {"}, {"sha": "af8d7e8515865583d84f4769944025e7d6483ded", "filename": "compiler/rustc_hir_analysis/src/outlives/implicit_infer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -196,13 +196,13 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 }\n             }\n \n-            ty::Projection(obj) => {\n+            ty::Alias(ty::Projection, obj) => {\n                 // This corresponds to `<T as Foo<'a>>::Bar`. In this case, we should use the\n                 // explicit predicates as well.\n                 debug!(\"Projection\");\n                 check_explicit_predicates(\n                     tcx,\n-                    tcx.parent(obj.item_def_id),\n+                    tcx.parent(obj.def_id),\n                     obj.substs,\n                     required_predicates,\n                     explicit_map,"}, {"sha": "b51b740d08e2e7a2e87f7bb578205bbcc430237c", "filename": "compiler/rustc_hir_analysis/src/outlives/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Futils.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -90,7 +90,7 @@ pub(crate) fn insert_outlives_predicate<'tcx>(\n                         // ```\n                         //\n                         // Here we want to add an explicit `where <T as Iterator>::Item: 'a`.\n-                        let ty: Ty<'tcx> = tcx.mk_projection(proj_ty.item_def_id, proj_ty.substs);\n+                        let ty: Ty<'tcx> = tcx.mk_projection(proj_ty.def_id, proj_ty.substs);\n                         required_predicates\n                             .entry(ty::OutlivesPredicate(ty.into(), outlived_region))\n                             .or_insert(span);"}, {"sha": "5e4d82b6fd5697ce31b095b0431a804f67d383f5", "filename": "compiler/rustc_hir_analysis/src/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fconstraints.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -249,14 +249,10 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.add_constraints_from_substs(current, def.did(), substs, variance);\n             }\n \n-            ty::Projection(ref data) => {\n+            ty::Alias(_, ref data) => {\n                 self.add_constraints_from_invariant_substs(current, data.substs, variance);\n             }\n \n-            ty::Opaque(_, substs) => {\n-                self.add_constraints_from_invariant_substs(current, substs, variance);\n-            }\n-\n             ty::Dynamic(data, r, _) => {\n                 // The type `Foo<T+'a>` is contravariant w/r/t `'a`:\n                 let contra = self.contravariant(variance);"}, {"sha": "24008f88814339d1f343fe38c0cf368165afe994", "filename": "compiler/rustc_hir_analysis/src/variance/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -111,11 +111,13 @@ fn variance_of_opaque(tcx: TyCtxt<'_>, item_def_id: LocalDefId) -> &[ty::Varianc\n         #[instrument(level = \"trace\", skip(self), ret)]\n         fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n             match t.kind() {\n-                ty::Opaque(def_id, substs) => self.visit_opaque(*def_id, substs),\n-                ty::Projection(proj)\n-                    if self.tcx.def_kind(proj.item_def_id) == DefKind::ImplTraitPlaceholder =>\n+                ty::Alias(_, ty::AliasTy { def_id, substs, .. })\n+                    if matches!(\n+                        self.tcx.def_kind(*def_id),\n+                        DefKind::OpaqueTy | DefKind::ImplTraitPlaceholder\n+                    ) =>\n                 {\n-                    self.visit_opaque(proj.item_def_id, proj.substs)\n+                    self.visit_opaque(*def_id, substs)\n                 }\n                 _ => t.super_visit_with(self),\n             }\n@@ -158,7 +160,7 @@ fn variance_of_opaque(tcx: TyCtxt<'_>, item_def_id: LocalDefId) -> &[ty::Varianc\n         // instead of requiring an additional `+ 'a`.\n         match pred.kind().skip_binder() {\n             ty::PredicateKind::Clause(ty::Clause::Trait(ty::TraitPredicate {\n-                trait_ref: ty::TraitRef { def_id: _, substs },\n+                trait_ref: ty::TraitRef { def_id: _, substs, .. },\n                 constness: _,\n                 polarity: _,\n             })) => {\n@@ -167,7 +169,7 @@ fn variance_of_opaque(tcx: TyCtxt<'_>, item_def_id: LocalDefId) -> &[ty::Varianc\n                 }\n             }\n             ty::PredicateKind::Clause(ty::Clause::Projection(ty::ProjectionPredicate {\n-                projection_ty: ty::ProjectionTy { substs, item_def_id: _ },\n+                projection_ty: ty::AliasTy { substs, .. },\n                 term,\n             })) => {\n                 for subst in &substs[1..] {"}, {"sha": "29a6902ccb0772591f896c431ec61e9d45ce37e1", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1245,7 +1245,7 @@ impl<'a> State<'a> {\n \n     fn print_literal(&mut self, lit: &hir::Lit) {\n         self.maybe_print_comment(lit.span.lo());\n-        self.word(lit.node.to_token_lit().to_string())\n+        self.word(lit.node.to_string())\n     }\n \n     fn print_inline_asm(&mut self, asm: &hir::InlineAsm<'_>) {\n@@ -1757,7 +1757,6 @@ impl<'a> State<'a> {\n                 self.print_qpath(qpath, true);\n                 self.popen();\n                 if let Some(ddpos) = ddpos.as_opt_usize() {\n-                    let ddpos = ddpos as usize;\n                     self.commasep(Inconsistent, &elts[..ddpos], |s, p| s.print_pat(p));\n                     if ddpos != 0 {\n                         self.word_space(\",\");"}, {"sha": "ab12cae4e2b08a0b48fc57e8b687f841b7b59509", "filename": "compiler/rustc_hir_typeck/src/_match.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -212,7 +212,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.can_coerce(arm_ty, ret_ty)\n                     && prior_arm.map_or(true, |(_, ty, _)| self.can_coerce(ty, ret_ty))\n                     // The match arms need to unify for the case of `impl Trait`.\n-                    && !matches!(ret_ty.kind(), ty::Opaque(..))\n+                    && !matches!(ret_ty.kind(), ty::Alias(ty::Opaque, ..))\n             }\n             _ => false,\n         };\n@@ -518,7 +518,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 let substs = sig.output().walk().find_map(|arg| {\n                     if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-                        && let ty::Opaque(def_id, substs) = *ty.kind()\n+                        && let ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) = *ty.kind()\n                         && def_id == rpit_def_id\n                     {\n                         Some(substs)\n@@ -542,15 +542,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) => {\n                                 assert_eq!(trait_pred.trait_ref.self_ty(), opaque_ty);\n                                 ty::PredicateKind::Clause(ty::Clause::Trait(\n-                                    trait_pred.with_self_type(self.tcx, ty),\n+                                    trait_pred.with_self_ty(self.tcx, ty),\n                                 ))\n                             }\n                             ty::PredicateKind::Clause(ty::Clause::Projection(mut proj_pred)) => {\n                                 assert_eq!(proj_pred.projection_ty.self_ty(), opaque_ty);\n-                                proj_pred.projection_ty.substs = self.tcx.mk_substs_trait(\n-                                    ty,\n-                                    proj_pred.projection_ty.substs.iter().skip(1),\n-                                );\n+                                proj_pred = proj_pred.with_self_ty(self.tcx, ty);\n                                 ty::PredicateKind::Clause(ty::Clause::Projection(proj_pred))\n                             }\n                             _ => continue,"}, {"sha": "7a5191b77f1d45759a88ce6f7c6740f1b257df6d", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -521,7 +521,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 callee_expr,\n                 call_expr,\n                 callee_ty,\n-                pick,\n+                &pick,\n                 segment,\n             );\n             if pick.illegal_sized_bound.is_some() {"}, {"sha": "b050ad20afbdbcca92547e224feda97a9d8af8b8", "filename": "compiler/rustc_hir_typeck/src/cast.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -38,7 +38,6 @@ use rustc_middle::mir::Mutability;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::cast::{CastKind, CastTy};\n use rustc_middle::ty::error::TypeError;\n-use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, Ty, TypeAndMut, TypeVisitable, VariantDef};\n use rustc_session::lint;\n use rustc_session::Session;\n@@ -75,10 +74,8 @@ enum PointerKind<'tcx> {\n     VTable(Option<DefId>),\n     /// Slice\n     Length,\n-    /// The unsize info of this projection\n-    OfProjection(ty::ProjectionTy<'tcx>),\n-    /// The unsize info of this opaque ty\n-    OfOpaque(DefId, SubstsRef<'tcx>),\n+    /// The unsize info of this projection or opaque type\n+    OfAlias(ty::AliasTy<'tcx>),\n     /// The unsize info of this parameter\n     OfParam(ty::ParamTy),\n }\n@@ -118,8 +115,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Pointers to foreign types are thin, despite being unsized\n             ty::Foreign(..) => Some(PointerKind::Thin),\n             // We should really try to normalize here.\n-            ty::Projection(pi) => Some(PointerKind::OfProjection(pi)),\n-            ty::Opaque(def_id, substs) => Some(PointerKind::OfOpaque(def_id, substs)),\n+            ty::Alias(_, pi) => Some(PointerKind::OfAlias(pi)),\n             ty::Param(p) => Some(PointerKind::OfParam(p)),\n             // Insufficient type information.\n             ty::Placeholder(..) | ty::Bound(..) | ty::Infer(_) => None,\n@@ -976,11 +972,9 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n             Some(PointerKind::Thin) => Ok(CastKind::AddrPtrCast),\n             Some(PointerKind::VTable(_)) => Err(CastError::IntToFatCast(Some(\"a vtable\"))),\n             Some(PointerKind::Length) => Err(CastError::IntToFatCast(Some(\"a length\"))),\n-            Some(\n-                PointerKind::OfProjection(_)\n-                | PointerKind::OfOpaque(_, _)\n-                | PointerKind::OfParam(_),\n-            ) => Err(CastError::IntToFatCast(None)),\n+            Some(PointerKind::OfAlias(_) | PointerKind::OfParam(_)) => {\n+                Err(CastError::IntToFatCast(None))\n+            }\n         }\n     }\n "}, {"sha": "5bd02dff73bfc1f033318eff0d0568c9e382d9cb", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -167,9 +167,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected_ty: Ty<'tcx>,\n     ) -> (Option<ExpectedSig<'tcx>>, Option<ty::ClosureKind>) {\n         match *expected_ty.kind() {\n-            ty::Opaque(def_id, substs) => self.deduce_signature_from_predicates(\n-                self.tcx.bound_explicit_item_bounds(def_id).subst_iter_copied(self.tcx, substs),\n-            ),\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => self\n+                .deduce_signature_from_predicates(\n+                    self.tcx.bound_explicit_item_bounds(def_id).subst_iter_copied(self.tcx, substs),\n+                ),\n             ty::Dynamic(ref object_type, ..) => {\n                 let sig = object_type.projection_bounds().find_map(|pb| {\n                     let pb = pb.with_self_ty(self.tcx, self.tcx.types.trait_object_dummy_self);\n@@ -425,7 +426,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // `deduce_expectations_from_expected_type` introduces\n         // late-bound lifetimes defined elsewhere, which we now\n         // anonymize away, so as not to confuse the user.\n-        let bound_sig = self.tcx.anonymize_late_bound_regions(bound_sig);\n+        let bound_sig = self.tcx.anonymize_bound_vars(bound_sig);\n \n         let closure_sigs = self.closure_sigs(expr_def_id, body, bound_sig);\n \n@@ -677,17 +678,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     get_future_output(obligation.predicate, obligation.cause.span)\n                 })?\n             }\n-            ty::Opaque(def_id, substs) => self\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => self\n                 .tcx\n                 .bound_explicit_item_bounds(def_id)\n                 .subst_iter_copied(self.tcx, substs)\n                 .find_map(|(p, s)| get_future_output(p, s))?,\n             ty::Error(_) => return None,\n-            ty::Projection(proj)\n-                if self.tcx.def_kind(proj.item_def_id) == DefKind::ImplTraitPlaceholder =>\n+            ty::Alias(ty::Projection, proj)\n+                if self.tcx.def_kind(proj.def_id) == DefKind::ImplTraitPlaceholder =>\n             {\n                 self.tcx\n-                    .bound_explicit_item_bounds(proj.item_def_id)\n+                    .bound_explicit_item_bounds(proj.def_id)\n                     .subst_iter_copied(self.tcx, proj.substs)\n                     .find_map(|(p, s)| get_future_output(p, s))?\n             }\n@@ -743,11 +744,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // The `Future` trait has only one associated item, `Output`,\n         // so check that this is what we see.\n         let output_assoc_item = self.tcx.associated_item_def_ids(future_trait)[0];\n-        if output_assoc_item != predicate.projection_ty.item_def_id {\n+        if output_assoc_item != predicate.projection_ty.def_id {\n             span_bug!(\n                 cause_span,\n                 \"projecting associated item `{:?}` from future, which is not Output `{:?}`\",\n-                predicate.projection_ty.item_def_id,\n+                predicate.projection_ty.def_id,\n                 output_assoc_item,\n             );\n         }"}, {"sha": "36cf4791492dd1c8c8b36d1125289dc008cb3fed", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1805,7 +1805,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         {\n             let ty = <dyn AstConv<'_>>::ast_ty_to_ty(fcx, ty);\n             // Get the `impl Trait`'s `DefId`.\n-            if let ty::Opaque(def_id, _) = ty.kind()\n+            if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }) = ty.kind()\n                 // Get the `impl Trait`'s `Item` so that we can get its trait bounds and\n                 // get the `Trait`'s `DefId`.\n                 && let hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds, .. }) ="}, {"sha": "866090260b2723dad6ef078f500805ab69b7d46c", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -2391,7 +2391,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty::Param(param_ty) => {\n                 self.point_at_param_definition(&mut err, param_ty);\n             }\n-            ty::Opaque(_, _) => {\n+            ty::Alias(ty::Opaque, _) => {\n                 self.suggest_await_on_field_access(&mut err, ident, base, base_ty.peel_refs());\n             }\n             _ => {}"}, {"sha": "1a4e6bf763821b05ee33737dc392ef35d145eb8a", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -716,7 +716,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if formal_ret.has_infer_types() {\n             for ty in ret_ty.walk() {\n                 if let ty::subst::GenericArgKind::Type(ty) = ty.unpack()\n-                    && let ty::Opaque(def_id, _) = *ty.kind()\n+                    && let ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }) = *ty.kind()\n                     && let Some(def_id) = def_id.as_local()\n                     && self.opaque_type_origin(def_id, DUMMY_SP).is_some() {\n                     return None;"}, {"sha": "8e520e563ff630ecdeb62b0e4a1b046feb7dbe14", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1169,7 +1169,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         match lit.node {\n             ast::LitKind::Str(..) => tcx.mk_static_str(),\n-            ast::LitKind::ByteStr(ref v) => {\n+            ast::LitKind::ByteStr(ref v, _) => {\n                 tcx.mk_imm_ref(tcx.lifetimes.re_static, tcx.mk_array(tcx.types.u8, v.len() as u64))\n             }\n             ast::LitKind::Byte(_) => tcx.types.u8,\n@@ -2124,27 +2124,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n                     }\n                 }\n-                ty::Opaque(new_def_id, _)\n+                ty::Alias(ty::Opaque, ty::AliasTy { def_id: new_def_id, .. })\n                 | ty::Closure(new_def_id, _)\n                 | ty::FnDef(new_def_id, _) => {\n                     def_id = new_def_id;\n                 }\n                 _ => {\n                     // Look for a user-provided impl of a `Fn` trait, and point to it.\n                     let new_def_id = self.probe(|_| {\n-                        let trait_ref = ty::TraitRef::new(\n+                        let trait_ref = self.tcx.mk_trait_ref(\n                             call_kind.to_def_id(self.tcx),\n-                            self.tcx.mk_substs(\n-                                [\n-                                    ty::GenericArg::from(callee_ty),\n-                                    self.next_ty_var(TypeVariableOrigin {\n-                                        kind: TypeVariableOriginKind::MiscVariable,\n-                                        span: rustc_span::DUMMY_SP,\n-                                    })\n-                                    .into(),\n-                                ]\n-                                .into_iter(),\n-                            ),\n+                            [\n+                                callee_ty,\n+                                self.next_ty_var(TypeVariableOrigin {\n+                                    kind: TypeVariableOriginKind::MiscVariable,\n+                                    span: rustc_span::DUMMY_SP,\n+                                }),\n+                            ],\n                         );\n                         let obligation = traits::Obligation::new(\n                             self.tcx,\n@@ -2217,7 +2213,7 @@ fn find_param_in_ty<'tcx>(ty: Ty<'tcx>, param_to_point_at: ty::GenericArg<'tcx>)\n         if arg == param_to_point_at {\n             return true;\n         } else if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-            && let ty::Projection(..) = ty.kind()\n+            && let ty::Alias(ty::Projection, ..) = ty.kind()\n         {\n             // This logic may seem a bit strange, but typically when\n             // we have a projection type in a function signature, the"}, {"sha": "407d6ac8544c211a8cce00fa74b0cfb983bddbea", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 27, "deletions": 16, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -13,7 +13,9 @@ use rustc_hir_analysis::astconv::AstConv;\n use rustc_infer::infer;\n use rustc_infer::traits::{self, StatementAsExpression};\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, Binder, DefIdTree, IsSuggestable, ToPredicate, Ty};\n+use rustc_middle::ty::{\n+    self, suggest_constraining_type_params, Binder, DefIdTree, IsSuggestable, ToPredicate, Ty,\n+};\n use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n@@ -174,10 +176,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let fn_sig = substs.as_closure().sig();\n                     Some((DefIdOrName::DefId(def_id), fn_sig.output(), fn_sig.inputs().map_bound(|inputs| &inputs[1..])))\n                 }\n-                ty::Opaque(def_id, substs) => {\n+                ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n                     self.tcx.bound_item_bounds(def_id).subst(self.tcx, substs).iter().find_map(|pred| {\n                         if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = pred.kind().skip_binder()\n-                        && Some(proj.projection_ty.item_def_id) == self.tcx.lang_items().fn_once_output()\n+                        && Some(proj.projection_ty.def_id) == self.tcx.lang_items().fn_once_output()\n                         // args tuple will always be substs[1]\n                         && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n                         {\n@@ -194,7 +196,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 ty::Dynamic(data, _, ty::Dyn) => {\n                     data.iter().find_map(|pred| {\n                         if let ty::ExistentialPredicate::Projection(proj) = pred.skip_binder()\n-                        && Some(proj.item_def_id) == self.tcx.lang_items().fn_once_output()\n+                        && Some(proj.def_id) == self.tcx.lang_items().fn_once_output()\n                         // for existential projection, substs are shifted over by 1\n                         && let ty::Tuple(args) = proj.substs.type_at(0).kind()\n                         {\n@@ -212,7 +214,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let def_id = self.tcx.generics_of(self.body_id.owner).type_param(&param, self.tcx).def_id;\n                     self.tcx.predicates_of(self.body_id.owner).predicates.iter().find_map(|(pred, _)| {\n                         if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = pred.kind().skip_binder()\n-                        && Some(proj.projection_ty.item_def_id) == self.tcx.lang_items().fn_once_output()\n+                        && Some(proj.projection_ty.def_id) == self.tcx.lang_items().fn_once_output()\n                         && proj.projection_ty.self_ty() == found\n                         // args tuple will always be substs[1]\n                         && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n@@ -1276,25 +1278,34 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             && !results.expr_adjustments(callee_expr).iter().any(|adj| matches!(adj.kind, ty::adjustment::Adjust::Deref(..)))\n             // Check that we're in fact trying to clone into the expected type\n             && self.can_coerce(*pointee_ty, expected_ty)\n+            && let trait_ref = ty::Binder::dummy(self.tcx.mk_trait_ref(clone_trait_did, [expected_ty]))\n             // And the expected type doesn't implement `Clone`\n-            && !self.predicate_must_hold_considering_regions(&traits::Obligation {\n-                cause: traits::ObligationCause::dummy(),\n-                param_env: self.param_env,\n-                recursion_depth: 0,\n-                predicate: ty::Binder::dummy(ty::TraitRef {\n-                    def_id: clone_trait_did,\n-                    substs: self.tcx.mk_substs([expected_ty.into()].iter()),\n-                })\n-                .without_const()\n-                .to_predicate(self.tcx),\n-            })\n+            && !self.predicate_must_hold_considering_regions(&traits::Obligation::new(\n+                self.tcx,\n+                traits::ObligationCause::dummy(),\n+                self.param_env,\n+                trait_ref,\n+            ))\n         {\n             diag.span_note(\n                 callee_expr.span,\n                 &format!(\n                     \"`{expected_ty}` does not implement `Clone`, so `{found_ty}` was cloned instead\"\n                 ),\n             );\n+            let owner = self.tcx.hir().enclosing_body_owner(expr.hir_id);\n+            if let ty::Param(param) = expected_ty.kind()\n+                && let Some(generics) = self.tcx.hir().get_generics(owner)\n+            {\n+                suggest_constraining_type_params(\n+                    self.tcx,\n+                    generics,\n+                    diag,\n+                    vec![(param.name.as_str(), \"Clone\", Some(clone_trait_did))].into_iter(),\n+                );\n+            } else {\n+                self.suggest_derive(diag, &[(trait_ref.to_predicate(self.tcx), None, None)]);\n+            }\n         }\n     }\n "}, {"sha": "93f2ceed777b5be20bda25798be7d198ef998950", "filename": "compiler/rustc_hir_typeck/src/generator_interior/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -563,7 +563,7 @@ fn check_must_not_suspend_ty<'tcx>(\n         }\n         ty::Adt(def, _) => check_must_not_suspend_def(fcx.tcx, def.did(), hir_id, data),\n         // FIXME: support adding the attribute to TAITs\n-        ty::Opaque(def, _) => {\n+        ty::Alias(ty::Opaque, ty::AliasTy { def_id: def, .. }) => {\n             let mut has_emitted = false;\n             for &(predicate, _) in fcx.tcx.explicit_item_bounds(def) {\n                 // We only look at the `DefId`, so it is safe to skip the binder here."}, {"sha": "218c54688aa3e959a187f7b69aded369e9ab8a99", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -45,7 +45,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self_expr: &'tcx hir::Expr<'tcx>,\n         call_expr: &'tcx hir::Expr<'tcx>,\n         unadjusted_self_ty: Ty<'tcx>,\n-        pick: probe::Pick<'tcx>,\n+        pick: &probe::Pick<'tcx>,\n         segment: &hir::PathSegment<'_>,\n     ) -> ConfirmResult<'tcx> {\n         debug!(\n@@ -71,7 +71,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n     fn confirm(\n         &mut self,\n         unadjusted_self_ty: Ty<'tcx>,\n-        pick: probe::Pick<'tcx>,\n+        pick: &probe::Pick<'tcx>,\n         segment: &hir::PathSegment<'_>,\n     ) -> ConfirmResult<'tcx> {\n         // Adjust the self expression the user provided and obtain the adjusted type."}, {"sha": "3f3af53d199b12918512a1597a9f7b1eb34532a5", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -192,8 +192,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         self.tcx.check_stability(pick.item.def_id, Some(call_expr.hir_id), span, None);\n \n-        let result =\n-            self.confirm_method(span, self_expr, call_expr, self_ty, pick.clone(), segment);\n+        let result = self.confirm_method(span, self_expr, call_expr, self_ty, &pick, segment);\n         debug!(\"result = {:?}\", result);\n \n         if let Some(span) = result.illegal_sized_bound {\n@@ -210,7 +209,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     ProbeScope::TraitsInScope,\n                 ) {\n                     Ok(ref new_pick) if pick.differs_from(new_pick) => {\n-                        needs_mut = true;\n+                        needs_mut = new_pick.self_ty.ref_mutability() != self_ty.ref_mutability();\n                     }\n                     _ => {}\n                 }\n@@ -286,7 +285,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.var_for_def(span, param)\n         });\n \n-        let trait_ref = ty::TraitRef::new(trait_def_id, substs);\n+        let trait_ref = self.tcx.mk_trait_ref(trait_def_id, substs);\n \n         // Construct an obligation\n         let poly_trait_ref = ty::Binder::dummy(trait_ref);\n@@ -327,7 +326,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.var_for_def(span, param)\n         });\n \n-        let trait_ref = ty::TraitRef::new(trait_def_id, substs);\n+        let trait_ref = self.tcx.mk_trait_ref(trait_def_id, substs);\n \n         // Construct an obligation\n         let poly_trait_ref = ty::Binder::dummy(trait_ref);"}, {"sha": "b9e7830bf079214af2a29491fff1ab458fbee011", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 58, "deletions": 55, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -38,9 +38,9 @@ use rustc_trait_selection::traits::query::method_autoderef::{\n use rustc_trait_selection::traits::query::CanonicalTyGoal;\n use rustc_trait_selection::traits::NormalizeExt;\n use rustc_trait_selection::traits::{self, ObligationCause};\n+use std::cell::RefCell;\n use std::cmp::max;\n use std::iter;\n-use std::mem;\n use std::ops::Deref;\n \n use smallvec::{smallvec, SmallVec};\n@@ -62,28 +62,29 @@ struct ProbeContext<'a, 'tcx> {\n \n     /// This is the OriginalQueryValues for the steps queries\n     /// that are answered in steps.\n-    orig_steps_var_values: OriginalQueryValues<'tcx>,\n+    orig_steps_var_values: &'a OriginalQueryValues<'tcx>,\n     steps: &'tcx [CandidateStep<'tcx>],\n \n     inherent_candidates: Vec<Candidate<'tcx>>,\n     extension_candidates: Vec<Candidate<'tcx>>,\n     impl_dups: FxHashSet<DefId>,\n \n-    /// Collects near misses when the candidate functions are missing a `self` keyword and is only\n-    /// used for error reporting\n-    static_candidates: Vec<CandidateSource>,\n-\n     /// When probing for names, include names that are close to the\n-    /// requested name (by Levensthein distance)\n+    /// requested name (by Levenshtein distance)\n     allow_similar_names: bool,\n \n     /// Some(candidate) if there is a private candidate\n     private_candidate: Option<(DefKind, DefId)>,\n \n+    /// Collects near misses when the candidate functions are missing a `self` keyword and is only\n+    /// used for error reporting\n+    static_candidates: RefCell<Vec<CandidateSource>>,\n+\n     /// Collects near misses when trait bounds for type parameters are unsatisfied and is only used\n     /// for error reporting\n-    unsatisfied_predicates:\n+    unsatisfied_predicates: RefCell<\n         Vec<(ty::Predicate<'tcx>, Option<ty::Predicate<'tcx>>, Option<ObligationCause<'tcx>>)>,\n+    >,\n \n     scope_expr_id: hir::HirId,\n }\n@@ -334,7 +335,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         op: OP,\n     ) -> Result<R, MethodError<'tcx>>\n     where\n-        OP: FnOnce(ProbeContext<'a, 'tcx>) -> Result<R, MethodError<'tcx>>,\n+        OP: FnOnce(ProbeContext<'_, 'tcx>) -> Result<R, MethodError<'tcx>>,\n     {\n         let mut orig_values = OriginalQueryValues::default();\n         let param_env_and_self_ty = self.canonicalize_query(\n@@ -445,7 +446,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 mode,\n                 method_name,\n                 return_type,\n-                orig_values,\n+                &orig_values,\n                 steps.steps,\n                 scope_expr_id,\n             );\n@@ -539,7 +540,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         mode: Mode,\n         method_name: Option<Ident>,\n         return_type: Option<Ty<'tcx>>,\n-        orig_steps_var_values: OriginalQueryValues<'tcx>,\n+        orig_steps_var_values: &'a OriginalQueryValues<'tcx>,\n         steps: &'tcx [CandidateStep<'tcx>],\n         scope_expr_id: hir::HirId,\n     ) -> ProbeContext<'a, 'tcx> {\n@@ -554,10 +555,10 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             impl_dups: FxHashSet::default(),\n             orig_steps_var_values,\n             steps,\n-            static_candidates: Vec::new(),\n             allow_similar_names: false,\n             private_candidate: None,\n-            unsatisfied_predicates: Vec::new(),\n+            static_candidates: RefCell::new(Vec::new()),\n+            unsatisfied_predicates: RefCell::new(Vec::new()),\n             scope_expr_id,\n         }\n     }\n@@ -566,8 +567,9 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         self.inherent_candidates.clear();\n         self.extension_candidates.clear();\n         self.impl_dups.clear();\n-        self.static_candidates.clear();\n         self.private_candidate = None;\n+        self.static_candidates.borrow_mut().clear();\n+        self.unsatisfied_predicates.borrow_mut().clear();\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -918,7 +920,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     ) {\n         debug!(\"assemble_extension_candidates_for_trait(trait_def_id={:?})\", trait_def_id);\n         let trait_substs = self.fresh_item_substs(trait_def_id);\n-        let trait_ref = ty::TraitRef::new(trait_def_id, trait_substs);\n+        let trait_ref = self.tcx.mk_trait_ref(trait_def_id, trait_substs);\n \n         if self.tcx.is_trait_alias(trait_def_id) {\n             // For trait aliases, assume all supertraits are relevant.\n@@ -1003,9 +1005,9 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n         debug!(\"pick: actual search failed, assemble diagnostics\");\n \n-        let static_candidates = mem::take(&mut self.static_candidates);\n+        let static_candidates = std::mem::take(self.static_candidates.get_mut());\n         let private_candidate = self.private_candidate.take();\n-        let unsatisfied_predicates = mem::take(&mut self.unsatisfied_predicates);\n+        let unsatisfied_predicates = std::mem::take(self.unsatisfied_predicates.get_mut());\n \n         // things failed, so lets look at all traits, for diagnostic purposes now:\n         self.reset();\n@@ -1050,7 +1052,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         }))\n     }\n \n-    fn pick_core(&mut self) -> Option<PickResult<'tcx>> {\n+    fn pick_core(&self) -> Option<PickResult<'tcx>> {\n         let pick = self.pick_all_method(Some(&mut vec![]));\n \n         // In this case unstable picking is done by `pick_method`.\n@@ -1065,11 +1067,10 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     }\n \n     fn pick_all_method(\n-        &mut self,\n+        &self,\n         mut unstable_candidates: Option<&mut Vec<(Candidate<'tcx>, Symbol)>>,\n     ) -> Option<PickResult<'tcx>> {\n-        let steps = self.steps.clone();\n-        steps\n+        self.steps\n             .iter()\n             .filter(|step| {\n                 debug!(\"pick_all_method: step={:?}\", step);\n@@ -1123,7 +1124,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     /// to transparently pass `&mut` pointers, in particular, without consuming\n     /// them for their entire lifetime.\n     fn pick_by_value_method(\n-        &mut self,\n+        &self,\n         step: &CandidateStep<'tcx>,\n         self_ty: Ty<'tcx>,\n         unstable_candidates: Option<&mut Vec<(Candidate<'tcx>, Symbol)>>,\n@@ -1151,7 +1152,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     }\n \n     fn pick_autorefd_method(\n-        &mut self,\n+        &self,\n         step: &CandidateStep<'tcx>,\n         self_ty: Ty<'tcx>,\n         mutbl: hir::Mutability,\n@@ -1177,7 +1178,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     /// special case for this is because going from `*mut T` to `*const T` with autoderefs and\n     /// autorefs would require dereferencing the pointer, which is not safe.\n     fn pick_const_ptr_method(\n-        &mut self,\n+        &self,\n         step: &CandidateStep<'tcx>,\n         self_ty: Ty<'tcx>,\n         unstable_candidates: Option<&mut Vec<(Candidate<'tcx>, Symbol)>>,\n@@ -1202,7 +1203,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         })\n     }\n \n-    fn pick_method_with_unstable(&mut self, self_ty: Ty<'tcx>) -> Option<PickResult<'tcx>> {\n+    fn pick_method_with_unstable(&self, self_ty: Ty<'tcx>) -> Option<PickResult<'tcx>> {\n         debug!(\"pick_method_with_unstable(self_ty={})\", self.ty_to_string(self_ty));\n \n         let mut possibly_unsatisfied_predicates = Vec::new();\n@@ -1213,7 +1214,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             debug!(\"searching {} candidates\", kind);\n             let res = self.consider_candidates(\n                 self_ty,\n-                candidates.iter(),\n+                candidates,\n                 &mut possibly_unsatisfied_predicates,\n                 Some(&mut vec![]),\n             );\n@@ -1222,21 +1223,27 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             }\n         }\n \n-        debug!(\"searching unstable candidates\");\n-        let res = self.consider_candidates(\n-            self_ty,\n-            self.inherent_candidates.iter().chain(&self.extension_candidates),\n-            &mut possibly_unsatisfied_predicates,\n-            None,\n-        );\n-        if res.is_none() {\n-            self.unsatisfied_predicates.extend(possibly_unsatisfied_predicates);\n+        for (kind, candidates) in\n+            &[(\"inherent\", &self.inherent_candidates), (\"extension\", &self.extension_candidates)]\n+        {\n+            debug!(\"searching unstable {kind} candidates\");\n+            let res = self.consider_candidates(\n+                self_ty,\n+                candidates,\n+                &mut possibly_unsatisfied_predicates,\n+                None,\n+            );\n+            if res.is_some() {\n+                return res;\n+            }\n         }\n-        res\n+\n+        self.unsatisfied_predicates.borrow_mut().extend(possibly_unsatisfied_predicates);\n+        None\n     }\n \n     fn pick_method(\n-        &mut self,\n+        &self,\n         self_ty: Ty<'tcx>,\n         mut unstable_candidates: Option<&mut Vec<(Candidate<'tcx>, Symbol)>>,\n     ) -> Option<PickResult<'tcx>> {\n@@ -1254,7 +1261,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             debug!(\"searching {} candidates\", kind);\n             let res = self.consider_candidates(\n                 self_ty,\n-                candidates.iter(),\n+                candidates,\n                 &mut possibly_unsatisfied_predicates,\n                 unstable_candidates.as_deref_mut(),\n             );\n@@ -1266,28 +1273,24 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         // `pick_method` may be called twice for the same self_ty if no stable methods\n         // match. Only extend once.\n         if unstable_candidates.is_some() {\n-            self.unsatisfied_predicates.extend(possibly_unsatisfied_predicates);\n+            self.unsatisfied_predicates.borrow_mut().extend(possibly_unsatisfied_predicates);\n         }\n         None\n     }\n \n-    fn consider_candidates<'b, ProbesIter>(\n+    fn consider_candidates(\n         &self,\n         self_ty: Ty<'tcx>,\n-        probes: ProbesIter,\n+        candidates: &[Candidate<'tcx>],\n         possibly_unsatisfied_predicates: &mut Vec<(\n             ty::Predicate<'tcx>,\n             Option<ty::Predicate<'tcx>>,\n             Option<ObligationCause<'tcx>>,\n         )>,\n         mut unstable_candidates: Option<&mut Vec<(Candidate<'tcx>, Symbol)>>,\n-    ) -> Option<PickResult<'tcx>>\n-    where\n-        ProbesIter: Iterator<Item = &'b Candidate<'tcx>> + Clone,\n-        'tcx: 'b,\n-    {\n-        let mut applicable_candidates: Vec<_> = probes\n-            .clone()\n+    ) -> Option<PickResult<'tcx>> {\n+        let mut applicable_candidates: Vec<_> = candidates\n+            .iter()\n             .map(|probe| {\n                 (probe, self.consider_probe(self_ty, probe, possibly_unsatisfied_predicates))\n             })\n@@ -1305,19 +1308,19 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         }\n \n         if let Some(uc) = &mut unstable_candidates {\n-            applicable_candidates.retain(|&(p, _)| {\n+            applicable_candidates.retain(|&(candidate, _)| {\n                 if let stability::EvalResult::Deny { feature, .. } =\n-                    self.tcx.eval_stability(p.item.def_id, None, self.span, None)\n+                    self.tcx.eval_stability(candidate.item.def_id, None, self.span, None)\n                 {\n-                    uc.push((p.clone(), feature));\n+                    uc.push((candidate.clone(), feature));\n                     return false;\n                 }\n                 true\n             });\n         }\n \n         if applicable_candidates.len() > 1 {\n-            let sources = probes.map(|p| self.candidate_source(p, self_ty)).collect();\n+            let sources = candidates.iter().map(|p| self.candidate_source(p, self_ty)).collect();\n             return Some(Err(MethodError::Ambiguity(sources)));\n         }\n \n@@ -1701,7 +1704,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 self.mode,\n                 self.method_name,\n                 self.return_type,\n-                self.orig_steps_var_values.clone(),\n+                &self.orig_steps_var_values,\n                 steps,\n                 self.scope_expr_id,\n             );\n@@ -1763,8 +1766,8 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         // -- but this could be overcome.\n     }\n \n-    fn record_static_candidate(&mut self, source: CandidateSource) {\n-        self.static_candidates.push(source);\n+    fn record_static_candidate(&self, source: CandidateSource) {\n+        self.static_candidates.borrow_mut().push(source);\n     }\n \n     #[instrument(level = \"debug\", skip(self))]"}, {"sha": "63cec9216eb89fa70f262db6c73cb57b4eee1d6b", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 40, "deletions": 18, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -25,7 +25,7 @@ use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKin\n use rustc_middle::traits::util::supertraits;\n use rustc_middle::ty::fast_reject::DeepRejectCtxt;\n use rustc_middle::ty::fast_reject::{simplify_type, TreatParams};\n-use rustc_middle::ty::print::with_crate_prefix;\n+use rustc_middle::ty::print::{with_crate_prefix, with_forced_trimmed_paths};\n use rustc_middle::ty::{self, DefIdTree, GenericArgKind, Ty, TyCtxt, TypeVisitable};\n use rustc_middle::ty::{IsSuggestable, ToPolyTraitRef};\n use rustc_span::symbol::{kw, sym, Ident};\n@@ -270,7 +270,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let tcx = self.tcx;\n \n                 let rcvr_ty = self.resolve_vars_if_possible(rcvr_ty);\n-                let ty_str = self.ty_to_string(rcvr_ty);\n+                let ty_str = with_forced_trimmed_paths!(self.ty_to_string(rcvr_ty));\n                 let is_method = mode == Mode::MethodCall;\n                 let item_kind = if is_method {\n                     \"method\"\n@@ -557,15 +557,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                         .chain(projection_ty.substs.iter().skip(1)),\n                                 );\n \n-                                let quiet_projection_ty = ty::ProjectionTy {\n-                                    substs: substs_with_infer_self,\n-                                    item_def_id: projection_ty.item_def_id,\n-                                };\n+                                let quiet_projection_ty =\n+                                    tcx.mk_alias_ty(projection_ty.def_id, substs_with_infer_self);\n \n                                 let term = pred.skip_binder().term;\n \n                                 let obligation = format!(\"{} = {}\", projection_ty, term);\n-                                let quiet = format!(\"{} = {}\", quiet_projection_ty, term);\n+                                let quiet = with_forced_trimmed_paths!(format!(\n+                                    \"{} = {}\",\n+                                    quiet_projection_ty, term\n+                                ));\n \n                                 bound_span_label(projection_ty.self_ty(), &obligation, &quiet);\n                                 Some((obligation, projection_ty.self_ty()))\n@@ -575,7 +576,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 let self_ty = p.self_ty();\n                                 let path = p.print_only_trait_path();\n                                 let obligation = format!(\"{}: {}\", self_ty, path);\n-                                let quiet = format!(\"_: {}\", path);\n+                                let quiet = with_forced_trimmed_paths!(format!(\"_: {}\", path));\n                                 bound_span_label(self_ty, &obligation, &quiet);\n                                 Some((obligation, self_ty))\n                             }\n@@ -798,7 +799,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 (None, None)\n                             };\n                         let primary_message = primary_message.unwrap_or_else(|| format!(\n-                            \"the {item_kind} `{item_name}` exists for {actual_prefix} `{ty_str}`, but its trait bounds were not satisfied\"\n+                            \"the {item_kind} `{item_name}` exists for {actual_prefix} `{ty_str}`, \\\n+                             but its trait bounds were not satisfied\"\n                         ));\n                         err.set_primary_message(&primary_message);\n                         if let Some(label) = label {\n@@ -895,7 +897,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             }\n                         }\n                     } else {\n-                        err.span_label(span, format!(\"{item_kind} cannot be called on `{ty_str}` due to unsatisfied trait bounds\"));\n+                        let ty_str = if ty_str.len() > 50 {\n+                            String::new()\n+                        } else {\n+                            format!(\"on `{ty_str}` \")\n+                        };\n+                        err.span_label(span, format!(\n+                            \"{item_kind} cannot be called {ty_str}due to unsatisfied trait bounds\"\n+                        ));\n                     }\n                 };\n \n@@ -1843,7 +1852,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.suggest_derive(err, &preds);\n     }\n \n-    fn suggest_derive(\n+    pub fn suggest_derive(\n         &self,\n         err: &mut Diagnostic,\n         unsatisfied_predicates: &[(\n@@ -1853,7 +1862,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         )],\n     ) {\n         let mut derives = Vec::<(String, Span, Symbol)>::new();\n-        let mut traits = Vec::<Span>::new();\n+        let mut traits = Vec::new();\n         for (pred, _, _) in unsatisfied_predicates {\n             let ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) = pred.kind().skip_binder() else { continue };\n             let adt = match trait_pred.self_ty().ty_adt_def() {\n@@ -1892,10 +1901,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                     derives.push((self_name, self_span, diagnostic_name));\n                 } else {\n-                    traits.push(self.tcx.def_span(trait_pred.def_id()));\n+                    traits.push(trait_pred.def_id());\n                 }\n             } else {\n-                traits.push(self.tcx.def_span(trait_pred.def_id()));\n+                traits.push(trait_pred.def_id());\n             }\n         }\n         traits.sort();\n@@ -1918,10 +1927,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let len = traits.len();\n         if len > 0 {\n-            let span: MultiSpan = traits.into();\n+            let span =\n+                MultiSpan::from_spans(traits.iter().map(|&did| self.tcx.def_span(did)).collect());\n+            let mut names = format!(\"`{}`\", self.tcx.def_path_str(traits[0]));\n+            for (i, &did) in traits.iter().enumerate().skip(1) {\n+                if len > 2 {\n+                    names.push_str(\", \");\n+                }\n+                if i == len - 1 {\n+                    names.push_str(\" and \");\n+                }\n+                names.push('`');\n+                names.push_str(&self.tcx.def_path_str(did));\n+                names.push('`');\n+            }\n             err.span_note(\n                 span,\n-                &format!(\"the following trait{} must be implemented\", pluralize!(len),),\n+                &format!(\"the trait{} {} must be implemented\", pluralize!(len), names),\n             );\n         }\n \n@@ -1969,7 +1991,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         | ty::Float(_)\n                         | ty::Adt(_, _)\n                         | ty::Str\n-                        | ty::Projection(_)\n+                        | ty::Alias(ty::Projection, _)\n                         | ty::Param(_) => format!(\"{deref_ty}\"),\n                         // we need to test something like  <&[_]>::len or <(&[u32])>::len\n                         // and Vec::function();\n@@ -2269,7 +2291,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             t.def_id() == info.def_id\n                         }\n                         ty::PredicateKind::Clause(ty::Clause::Projection(p)) => {\n-                            p.projection_ty.item_def_id == info.def_id\n+                            p.projection_ty.def_id == info.def_id\n                         }\n                         _ => false,\n                     }"}, {"sha": "6810353f9e778bc992e43c6ee94111cdcca39aca", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -386,7 +386,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Byte string patterns behave the same way as array patterns\n         // They can denote both statically and dynamically-sized byte arrays.\n         let mut pat_ty = ty;\n-        if let hir::ExprKind::Lit(Spanned { node: ast::LitKind::ByteStr(_), .. }) = lt.kind {\n+        if let hir::ExprKind::Lit(Spanned { node: ast::LitKind::ByteStr(..), .. }) = lt.kind {\n             let expected = self.structurally_resolved_type(span, expected);\n             if let ty::Ref(_, inner_ty, _) = expected.kind()\n                 && matches!(inner_ty.kind(), ty::Slice(_))"}, {"sha": "bb956ddc780423876eca53ec2fc209aaed365aa8", "filename": "compiler/rustc_hir_typeck/src/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -546,7 +546,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             impl<'tcx> ty::TypeVisitor<'tcx> for RecursionChecker {\n                 type BreakTy = ();\n                 fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-                    if let ty::Opaque(def_id, _) = *t.kind() {\n+                    if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }) = *t.kind() {\n                         if def_id == self.def_id.to_def_id() {\n                             return ControlFlow::Break(());\n                         }"}, {"sha": "d1d328128bc15a145f7b60835cdfe62f7733beae", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -30,8 +30,6 @@ use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n-use std::iter::FromIterator;\n-use std::vec::Vec;\n \n const LOADED_FROM_DISK: Symbol = sym::loaded_from_disk;\n const EXCEPT: Symbol = sym::except;"}, {"sha": "1fd2b9b0d7b7b5a58b4d291cf039575a08715e48", "filename": "compiler/rustc_incremental/src/persist/fs.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -113,7 +113,6 @@ use rustc_span::Symbol;\n \n use std::fs as std_fs;\n use std::io::{self, ErrorKind};\n-use std::mem;\n use std::path::{Path, PathBuf};\n use std::time::{Duration, SystemTime, UNIX_EPOCH};\n \n@@ -305,7 +304,7 @@ pub fn prepare_session_directory(\n             }\n \n             delete_session_dir_lock_file(sess, &lock_file_path);\n-            mem::drop(directory_lock);\n+            drop(directory_lock);\n         }\n     }\n }\n@@ -864,7 +863,7 @@ pub fn garbage_collect_session_directories(sess: &Session) -> io::Result<()> {\n \n                     // Let's make it explicit that the file lock is released at this point,\n                     // or rather, that we held on to it until here\n-                    mem::drop(lock);\n+                    drop(lock);\n                 }\n                 Err(_) => {\n                     debug!(\n@@ -898,7 +897,7 @@ pub fn garbage_collect_session_directories(sess: &Session) -> io::Result<()> {\n \n         // Let's make it explicit that the file lock is released at this point,\n         // or rather, that we held on to it until here\n-        mem::drop(lock);\n+        drop(lock);\n     }\n \n     Ok(())"}, {"sha": "686cb6dac496224f130d3f08a2f17d685eb30a32", "filename": "compiler/rustc_index/src/bit_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -209,7 +209,7 @@ impl<T: Idx> BitSet<T> {\n             self.words[start_word_index] |= !(start_mask - 1);\n             // And all trailing bits (i.e. from 0..=end) in the end word,\n             // including the end.\n-            self.words[end_word_index] |= end_mask | end_mask - 1;\n+            self.words[end_word_index] |= end_mask | (end_mask - 1);\n         } else {\n             self.words[start_word_index] |= end_mask | (end_mask - start_mask);\n         }"}, {"sha": "c18a911b2fbcd4db06dfe417f9efbfee8579a4a2", "filename": "compiler/rustc_index/src/vec.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fvec.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -4,7 +4,6 @@ use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use std::fmt;\n use std::fmt::Debug;\n use std::hash::Hash;\n-use std::iter::FromIterator;\n use std::marker::PhantomData;\n use std::ops::{Index, IndexMut, RangeBounds};\n use std::slice;"}, {"sha": "c4f11472d55482e979acfdb41894115a7a6a4923", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -517,6 +517,6 @@ pub struct MismatchedStaticLifetime<'a> {\n     pub expl: Option<note_and_explain::RegionExplanation<'a>>,\n     #[subdiagnostic]\n     pub does_not_outlive_static_from_impl: DoesNotOutliveStaticFromImpl,\n-    #[subdiagnostic(eager)]\n+    #[subdiagnostic]\n     pub implicit_static_lifetimes: Vec<ImplicitStaticLifetimeSubdiag>,\n }"}, {"sha": "e9186540a7b7c53869366303bba18d2791432f5f", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -411,16 +411,16 @@ impl<'tcx> ToTrace<'tcx> for ty::PolyTraitRef<'tcx> {\n     }\n }\n \n-impl<'tcx> ToTrace<'tcx> for ty::ProjectionTy<'tcx> {\n+impl<'tcx> ToTrace<'tcx> for ty::AliasTy<'tcx> {\n     fn to_trace(\n         tcx: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n         b: Self,\n     ) -> TypeTrace<'tcx> {\n-        let a_ty = tcx.mk_projection(a.item_def_id, a.substs);\n-        let b_ty = tcx.mk_projection(b.item_def_id, b.substs);\n+        let a_ty = tcx.mk_projection(a.def_id, a.substs);\n+        let b_ty = tcx.mk_projection(b.def_id, b.substs);\n         TypeTrace {\n             cause: cause.clone(),\n             values: Terms(ExpectedFound::new(a_is_expected, a_ty.into(), b_ty.into())),"}, {"sha": "ec5221379d2c9314f93dedab1163b409569203e6", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -453,10 +453,9 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n             | ty::Dynamic(..)\n             | ty::Never\n             | ty::Tuple(..)\n-            | ty::Projection(..)\n+            | ty::Alias(..)\n             | ty::Foreign(..)\n-            | ty::Param(..)\n-            | ty::Opaque(..) => {\n+            | ty::Param(..) => {\n                 if t.flags().intersects(self.needs_canonical_flags) {\n                     t.super_fold_with(self)\n                 } else {"}, {"sha": "9a1c49c1aa6af24feb4625f718fc2a29acbdc2aa", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -675,7 +675,7 @@ impl<'tcx> TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                 // relatable.\n                 Ok(t)\n             }\n-            ty::Opaque(def_id, substs) => {\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n                 let s = self.relate(substs, substs)?;\n                 Ok(if s == substs { t } else { self.infcx.tcx.mk_opaque(def_id, s) })\n             }"}, {"sha": "46e7813d99e562cd1cff9b39b0224eaa75048fb1", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -100,11 +100,15 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n                 self.fields.instantiate(a, RelationDir::EqTo, b_id, self.a_is_expected)?;\n             }\n \n-            (&ty::Opaque(a_def_id, _), &ty::Opaque(b_def_id, _)) if a_def_id == b_def_id => {\n+            (\n+                &ty::Alias(ty::Opaque, ty::AliasTy { def_id: a_def_id, .. }),\n+                &ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, .. }),\n+            ) if a_def_id == b_def_id => {\n                 self.fields.infcx.super_combine_tys(self, a, b)?;\n             }\n-            (&ty::Opaque(did, ..), _) | (_, &ty::Opaque(did, ..))\n-                if self.fields.define_opaque_types && did.is_local() =>\n+            (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }), _)\n+            | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }))\n+                if self.fields.define_opaque_types && def_id.is_local() =>\n             {\n                 self.fields.obligations.extend(\n                     infcx\n@@ -178,6 +182,11 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n     where\n         T: Relate<'tcx>,\n     {\n+        // A binder is equal to itself if it's structually equal to itself\n+        if a == b {\n+            return Ok(a);\n+        }\n+\n         if a.skip_binder().has_escaping_bound_vars() || b.skip_binder().has_escaping_bound_vars() {\n             self.fields.higher_ranked_sub(a, b, self.a_is_expected)?;\n             self.fields.higher_ranked_sub(b, a, self.a_is_expected)?;"}, {"sha": "397fa43175f732b3d87e566678388b0fbcd342d8", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -339,11 +339,13 @@ pub fn unexpected_hidden_region_diagnostic<'tcx>(\n impl<'tcx> InferCtxt<'tcx> {\n     pub fn get_impl_future_output_ty(&self, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n         let (def_id, substs) = match *ty.kind() {\n-            ty::Opaque(def_id, substs) => (def_id, substs),\n-            ty::Projection(data)\n-                if self.tcx.def_kind(data.item_def_id) == DefKind::ImplTraitPlaceholder =>\n+            ty::Alias(_, ty::AliasTy { def_id, substs, .. })\n+                if matches!(\n+                    self.tcx.def_kind(def_id),\n+                    DefKind::OpaqueTy | DefKind::ImplTraitPlaceholder\n+                ) =>\n             {\n-                (data.item_def_id, data.substs)\n+                (def_id, substs)\n             }\n             _ => return None,\n         };\n@@ -357,7 +359,7 @@ impl<'tcx> InferCtxt<'tcx> {\n                     .kind()\n                     .map_bound(|kind| match kind {\n                         ty::PredicateKind::Clause(ty::Clause::Projection(projection_predicate))\n-                            if projection_predicate.projection_ty.item_def_id == item_def_id =>\n+                            if projection_predicate.projection_ty.def_id == item_def_id =>\n                         {\n                             projection_predicate.term.ty()\n                         }\n@@ -1730,7 +1732,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     let extra = expected == found;\n                     let sort_string = |ty: Ty<'tcx>, path: Option<PathBuf>| {\n                         let mut s = match (extra, ty.kind()) {\n-                            (true, ty::Opaque(def_id, _)) => {\n+                            (true, ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. })) => {\n                                 let sm = self.tcx.sess.source_map();\n                                 let pos = sm.lookup_char_pos(self.tcx.def_span(*def_id).lo());\n                                 format!(\n@@ -1740,12 +1742,12 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                                     pos.col.to_usize() + 1,\n                                 )\n                             }\n-                            (true, ty::Projection(proj))\n-                                if self.tcx.def_kind(proj.item_def_id)\n+                            (true, ty::Alias(ty::Projection, proj))\n+                                if self.tcx.def_kind(proj.def_id)\n                                     == DefKind::ImplTraitPlaceholder =>\n                             {\n                                 let sm = self.tcx.sess.source_map();\n-                                let pos = sm.lookup_char_pos(self.tcx.def_span(proj.item_def_id).lo());\n+                                let pos = sm.lookup_char_pos(self.tcx.def_span(proj.def_id).lo());\n                                 format!(\n                                     \" (trait associated opaque type at <{}:{}:{}>)\",\n                                     sm.filename_for_diagnostics(&pos.file.name),\n@@ -2383,7 +2385,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                         // fn get_later<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n                         // suggest:\n                         // fn get_later<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n-                        ty::Closure(_, _substs) | ty::Opaque(_, _substs) if return_impl_trait => {\n+                        ty::Closure(..) | ty::Alias(ty::Opaque, ..) if return_impl_trait => {\n                             new_binding_suggestion(&mut err, type_param_span);\n                         }\n                         _ => {\n@@ -2765,7 +2767,7 @@ impl TyCategory {\n     pub fn from_ty(tcx: TyCtxt<'_>, ty: Ty<'_>) -> Option<(Self, DefId)> {\n         match *ty.kind() {\n             ty::Closure(def_id, _) => Some((Self::Closure, def_id)),\n-            ty::Opaque(def_id, _) => Some((Self::Opaque, def_id)),\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }) => Some((Self::Opaque, def_id)),\n             ty::Generator(def_id, ..) => {\n                 Some((Self::Generator(tcx.generator_kind(def_id).unwrap()), def_id))\n             }"}, {"sha": "a4c36b4c9cd59db580517b60f8d887ca2bcd40eb", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 70, "deletions": 39, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -20,7 +20,7 @@ use rustc_middle::ty::print::{FmtPrinter, PrettyPrinter, Print, Printer};\n use rustc_middle::ty::{self, DefIdTree, InferConst};\n use rustc_middle::ty::{GenericArg, GenericArgKind, SubstsRef};\n use rustc_middle::ty::{IsSuggestable, Ty, TyCtxt, TypeckResults};\n-use rustc_span::symbol::{kw, Ident};\n+use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{BytePos, Span};\n use std::borrow::Cow;\n use std::iter;\n@@ -79,7 +79,7 @@ impl InferenceDiagnosticsData {\n \n     fn where_x_is_kind(&self, in_type: Ty<'_>) -> &'static str {\n         if in_type.is_ty_infer() {\n-            \"empty\"\n+            \"\"\n         } else if self.name == \"_\" {\n             // FIXME: Consider specializing this message if there is a single `_`\n             // in the type.\n@@ -183,13 +183,24 @@ fn fmt_printer<'a, 'tcx>(infcx: &'a InferCtxt<'tcx>, ns: Namespace) -> FmtPrinte\n     printer\n }\n \n-fn ty_to_string<'tcx>(infcx: &InferCtxt<'tcx>, ty: Ty<'tcx>) -> String {\n+fn ty_to_string<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+    called_method_def_id: Option<DefId>,\n+) -> String {\n     let printer = fmt_printer(infcx, Namespace::TypeNS);\n     let ty = infcx.resolve_vars_if_possible(ty);\n-    match ty.kind() {\n+    match (ty.kind(), called_method_def_id) {\n         // We don't want the regular output for `fn`s because it includes its path in\n         // invalid pseudo-syntax, we want the `fn`-pointer output instead.\n-        ty::FnDef(..) => ty.fn_sig(infcx.tcx).print(printer).unwrap().into_buffer(),\n+        (ty::FnDef(..), _) => ty.fn_sig(infcx.tcx).print(printer).unwrap().into_buffer(),\n+        (_, Some(def_id))\n+            if ty.is_ty_infer()\n+                && infcx.tcx.get_diagnostic_item(sym::iterator_collect_fn) == Some(def_id) =>\n+        {\n+            \"Vec<_>\".to_string()\n+        }\n+        _ if ty.is_ty_infer() => \"/* Type */\".to_string(),\n         // FIXME: The same thing for closures, but this only works when the closure\n         // does not capture anything.\n         //\n@@ -213,15 +224,15 @@ fn closure_as_fn_str<'tcx>(infcx: &InferCtxt<'tcx>, ty: Ty<'tcx>) -> String {\n         .map(|args| {\n             args.tuple_fields()\n                 .iter()\n-                .map(|arg| ty_to_string(infcx, arg))\n+                .map(|arg| ty_to_string(infcx, arg, None))\n                 .collect::<Vec<_>>()\n                 .join(\", \")\n         })\n         .unwrap_or_default();\n     let ret = if fn_sig.output().skip_binder().is_unit() {\n         String::new()\n     } else {\n-        format!(\" -> {}\", ty_to_string(infcx, fn_sig.output().skip_binder()))\n+        format!(\" -> {}\", ty_to_string(infcx, fn_sig.output().skip_binder(), None))\n     };\n     format!(\"fn({}){}\", args, ret)\n }\n@@ -368,6 +379,7 @@ impl<'tcx> InferCtxt<'tcx> {\n }\n \n impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n+    #[instrument(level = \"debug\", skip(self, error_code))]\n     pub fn emit_inference_failure_err(\n         &self,\n         body_id: Option<hir::BodyId>,\n@@ -406,7 +418,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         let mut infer_subdiags = Vec::new();\n         let mut multi_suggestions = Vec::new();\n         match kind {\n-            InferSourceKind::LetBinding { insert_span, pattern_name, ty } => {\n+            InferSourceKind::LetBinding { insert_span, pattern_name, ty, def_id } => {\n                 infer_subdiags.push(SourceKindSubdiag::LetLike {\n                     span: insert_span,\n                     name: pattern_name.map(|name| name.to_string()).unwrap_or_else(String::new),\n@@ -415,7 +427,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     prefix: arg_data.kind.try_get_prefix().unwrap_or_default(),\n                     arg_name: arg_data.name,\n                     kind: if pattern_name.is_some() { \"with_pattern\" } else { \"other\" },\n-                    type_name: ty_to_string(self, ty),\n+                    type_name: ty_to_string(self, ty, def_id),\n                 });\n             }\n             InferSourceKind::ClosureArg { insert_span, ty } => {\n@@ -427,7 +439,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     prefix: arg_data.kind.try_get_prefix().unwrap_or_default(),\n                     arg_name: arg_data.name,\n                     kind: \"closure\",\n-                    type_name: ty_to_string(self, ty),\n+                    type_name: ty_to_string(self, ty, None),\n                 });\n             }\n             InferSourceKind::GenericArg {\n@@ -456,33 +468,39 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     parent_name,\n                 });\n \n-                let args = fmt_printer(self, Namespace::TypeNS)\n-                    .comma_sep(generic_args.iter().copied().map(|arg| {\n-                        if arg.is_suggestable(self.tcx, true) {\n-                            return arg;\n-                        }\n+                let args = if self.infcx.tcx.get_diagnostic_item(sym::iterator_collect_fn)\n+                    == Some(generics_def_id)\n+                {\n+                    \"Vec<_>\".to_string()\n+                } else {\n+                    fmt_printer(self, Namespace::TypeNS)\n+                        .comma_sep(generic_args.iter().copied().map(|arg| {\n+                            if arg.is_suggestable(self.tcx, true) {\n+                                return arg;\n+                            }\n \n-                        match arg.unpack() {\n-                            GenericArgKind::Lifetime(_) => bug!(\"unexpected lifetime\"),\n-                            GenericArgKind::Type(_) => self\n-                                .next_ty_var(TypeVariableOrigin {\n-                                    span: rustc_span::DUMMY_SP,\n-                                    kind: TypeVariableOriginKind::MiscVariable,\n-                                })\n-                                .into(),\n-                            GenericArgKind::Const(arg) => self\n-                                .next_const_var(\n-                                    arg.ty(),\n-                                    ConstVariableOrigin {\n+                            match arg.unpack() {\n+                                GenericArgKind::Lifetime(_) => bug!(\"unexpected lifetime\"),\n+                                GenericArgKind::Type(_) => self\n+                                    .next_ty_var(TypeVariableOrigin {\n                                         span: rustc_span::DUMMY_SP,\n-                                        kind: ConstVariableOriginKind::MiscVariable,\n-                                    },\n-                                )\n-                                .into(),\n-                        }\n-                    }))\n-                    .unwrap()\n-                    .into_buffer();\n+                                        kind: TypeVariableOriginKind::MiscVariable,\n+                                    })\n+                                    .into(),\n+                                GenericArgKind::Const(arg) => self\n+                                    .next_const_var(\n+                                        arg.ty(),\n+                                        ConstVariableOrigin {\n+                                            span: rustc_span::DUMMY_SP,\n+                                            kind: ConstVariableOriginKind::MiscVariable,\n+                                        },\n+                                    )\n+                                    .into(),\n+                            }\n+                        }))\n+                        .unwrap()\n+                        .into_buffer()\n+                };\n \n                 if !have_turbofish {\n                     infer_subdiags.push(SourceKindSubdiag::GenericSuggestion {\n@@ -520,7 +538,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 ));\n             }\n             InferSourceKind::ClosureReturn { ty, data, should_wrap_expr } => {\n-                let ty_info = ty_to_string(self, ty);\n+                let ty_info = ty_to_string(self, ty, None);\n                 multi_suggestions.push(SourceKindMultiSuggestion::new_closure_return(\n                     ty_info,\n                     data,\n@@ -608,6 +626,7 @@ enum InferSourceKind<'tcx> {\n         insert_span: Span,\n         pattern_name: Option<Ident>,\n         ty: Ty<'tcx>,\n+        def_id: Option<DefId>,\n     },\n     ClosureArg {\n         insert_span: Span,\n@@ -662,7 +681,7 @@ impl<'tcx> InferSourceKind<'tcx> {\n                 if ty.is_closure() {\n                     (\"closure\", closure_as_fn_str(infcx, ty))\n                 } else if !ty.is_ty_infer() {\n-                    (\"normal\", ty_to_string(infcx, ty))\n+                    (\"normal\", ty_to_string(infcx, ty, None))\n                 } else {\n                     (\"other\", String::new())\n                 }\n@@ -788,10 +807,18 @@ impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n     /// Uses `fn source_cost` to determine whether this inference source is preferable to\n     /// previous sources. We generally prefer earlier sources.\n     #[instrument(level = \"debug\", skip(self))]\n-    fn update_infer_source(&mut self, new_source: InferSource<'tcx>) {\n+    fn update_infer_source(&mut self, mut new_source: InferSource<'tcx>) {\n         let cost = self.source_cost(&new_source) + self.attempt;\n         debug!(?cost);\n         self.attempt += 1;\n+        if let Some(InferSource { kind: InferSourceKind::GenericArg { def_id: did, ..}, .. }) = self.infer_source\n+            && let InferSourceKind::LetBinding { ref ty, ref mut def_id, ..} = new_source.kind\n+            && ty.is_ty_infer()\n+        {\n+            // Customize the output so we talk about `let x: Vec<_> = iter.collect();` instead of\n+            // `let x: _ = iter.collect();`, as this is a very common case.\n+            *def_id = Some(did);\n+        }\n         if cost < self.infer_source_cost {\n             self.infer_source_cost = cost;\n             self.infer_source = Some(new_source);\n@@ -852,7 +879,10 @@ impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n             match inner.unpack() {\n                 GenericArgKind::Lifetime(_) => {}\n                 GenericArgKind::Type(ty) => {\n-                    if matches!(ty.kind(), ty::Opaque(..) | ty::Closure(..) | ty::Generator(..)) {\n+                    if matches!(\n+                        ty.kind(),\n+                        ty::Alias(ty::Opaque, ..) | ty::Closure(..) | ty::Generator(..)\n+                    ) {\n                         // Opaque types can't be named by the user right now.\n                         //\n                         // Both the generic arguments of closures and generators can\n@@ -1089,6 +1119,7 @@ impl<'a, 'tcx> Visitor<'tcx> for FindInferSourceVisitor<'a, 'tcx> {\n                                 insert_span: local.pat.span.shrink_to_hi(),\n                                 pattern_name: local.pat.simple_ident(),\n                                 ty,\n+                                def_id: None,\n                             },\n                         })\n                     }"}, {"sha": "fed9fda74bfb33ec462dfadf8200f54432691762", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -226,13 +226,11 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n             false\n         };\n \n-        let expected_trait_ref = self.cx.resolve_vars_if_possible(ty::TraitRef {\n-            def_id: trait_def_id,\n-            substs: expected_substs,\n-        });\n-        let actual_trait_ref = self\n+        let expected_trait_ref = self\n             .cx\n-            .resolve_vars_if_possible(ty::TraitRef { def_id: trait_def_id, substs: actual_substs });\n+            .resolve_vars_if_possible(self.cx.tcx.mk_trait_ref(trait_def_id, expected_substs));\n+        let actual_trait_ref =\n+            self.cx.resolve_vars_if_possible(self.cx.tcx.mk_trait_ref(trait_def_id, actual_substs));\n \n         // Search the expected and actual trait references to see (a)\n         // whether the sub/sup placeholders appear in them (sometimes"}, {"sha": "9bd2202d2601e6f54dcb7a7bac0a5c001e2eb325", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -330,7 +330,7 @@ pub fn suggest_new_region_bound(\n                             Applicability::MaybeIncorrect,\n                         );\n                     }\n-                    if let Some((param_span, param_ty)) = param.clone() {\n+                    if let Some((param_span, ref param_ty)) = param {\n                         err.span_suggestion_verbose(\n                             param_span,\n                             add_static_bound,"}, {"sha": "30ca9f41d6e6f8d73830b5c2b98150ee61e5dd05", "filename": "compiler/rustc_infer/src/infer/error_reporting/suggest.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -486,12 +486,14 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             _ if self.same_type_modulo_infer(last_expr_ty, expected_ty) => {\n                 StatementAsExpression::CorrectType\n             }\n-            (ty::Opaque(last_def_id, _), ty::Opaque(exp_def_id, _))\n-                if last_def_id == exp_def_id =>\n-            {\n-                StatementAsExpression::CorrectType\n-            }\n-            (ty::Opaque(last_def_id, last_bounds), ty::Opaque(exp_def_id, exp_bounds)) => {\n+            (\n+                ty::Alias(ty::Opaque, ty::AliasTy { def_id: last_def_id, .. }),\n+                ty::Alias(ty::Opaque, ty::AliasTy { def_id: exp_def_id, .. }),\n+            ) if last_def_id == exp_def_id => StatementAsExpression::CorrectType,\n+            (\n+                ty::Alias(ty::Opaque, ty::AliasTy { def_id: last_def_id, substs: last_bounds, .. }),\n+                ty::Alias(ty::Opaque, ty::AliasTy { def_id: exp_def_id, substs: exp_bounds, .. }),\n+            ) => {\n                 debug!(\n                     \"both opaque, likely future {:?} {:?} {:?} {:?}\",\n                     last_def_id, last_bounds, exp_def_id, exp_bounds"}, {"sha": "8f53b1ccdf45829c758721072cf55d1063f730ff", "filename": "compiler/rustc_infer/src/infer/freshen.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -205,12 +205,11 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             | ty::Dynamic(..)\n             | ty::Never\n             | ty::Tuple(..)\n-            | ty::Projection(..)\n+            | ty::Alias(..)\n             | ty::Foreign(..)\n             | ty::Param(..)\n             | ty::Closure(..)\n-            | ty::GeneratorWitness(..)\n-            | ty::Opaque(..) => t.super_fold_with(self),\n+            | ty::GeneratorWitness(..) => t.super_fold_with(self),\n \n             ty::Placeholder(..) | ty::Bound(..) => bug!(\"unexpected type {:?}\", t),\n         }"}, {"sha": "21b68ce998997a6826645c6ad0036f2af522bb7d", "filename": "compiler/rustc_infer/src/infer/glb.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -103,6 +103,11 @@ impl<'tcx> TypeRelation<'tcx> for Glb<'_, '_, 'tcx> {\n     where\n         T: Relate<'tcx>,\n     {\n+        // GLB of a binder and itself is just itself\n+        if a == b {\n+            return Ok(a);\n+        }\n+\n         debug!(\"binders(a={:?}, b={:?})\", a, b);\n         if a.skip_binder().has_escaping_bound_vars() || b.skip_binder().has_escaping_bound_vars() {\n             // When higher-ranked types are involved, computing the GLB is"}, {"sha": "0ebc6d55bcba952678c86e6ff3c1dba91d8a11bd", "filename": "compiler/rustc_infer/src/infer/lattice.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -105,11 +105,13 @@ where\n             Ok(v)\n         }\n \n-        (&ty::Opaque(a_def_id, _), &ty::Opaque(b_def_id, _)) if a_def_id == b_def_id => {\n-            infcx.super_combine_tys(this, a, b)\n-        }\n-        (&ty::Opaque(did, ..), _) | (_, &ty::Opaque(did, ..))\n-            if this.define_opaque_types() && did.is_local() =>\n+        (\n+            &ty::Alias(ty::Opaque, ty::AliasTy { def_id: a_def_id, .. }),\n+            &ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, .. }),\n+        ) if a_def_id == b_def_id => infcx.super_combine_tys(this, a, b),\n+        (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }), _)\n+        | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }))\n+            if this.define_opaque_types() && def_id.is_local() =>\n         {\n             this.add_obligations(\n                 infcx"}, {"sha": "c07ac1d3ace92a4375b03797534a725c7b26911e", "filename": "compiler/rustc_infer/src/infer/lub.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -103,6 +103,11 @@ impl<'tcx> TypeRelation<'tcx> for Lub<'_, '_, 'tcx> {\n     where\n         T: Relate<'tcx>,\n     {\n+        // LUB of a binder and itself is just itself\n+        if a == b {\n+            return Ok(a);\n+        }\n+\n         debug!(\"binders(a={:?}, b={:?})\", a, b);\n         if a.skip_binder().has_escaping_bound_vars() || b.skip_binder().has_escaping_bound_vars() {\n             // When higher-ranked types are involved, computing the LUB is"}, {"sha": "996148a709087161775337d9945aa262c7888749", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 38, "deletions": 15, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -2014,31 +2014,54 @@ fn replace_param_and_infer_substs_with_placeholder<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     substs: SubstsRef<'tcx>,\n ) -> SubstsRef<'tcx> {\n-    tcx.mk_substs(substs.iter().enumerate().map(|(idx, arg)| {\n-        match arg.unpack() {\n-            GenericArgKind::Type(_) if arg.has_non_region_param() || arg.has_non_region_infer() => {\n-                tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n+    struct ReplaceParamAndInferWithPlaceholder<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+        idx: usize,\n+    }\n+\n+    impl<'tcx> TypeFolder<'tcx> for ReplaceParamAndInferWithPlaceholder<'tcx> {\n+        fn tcx(&self) -> TyCtxt<'tcx> {\n+            self.tcx\n+        }\n+\n+        fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+            if let ty::Infer(_) = t.kind() {\n+                self.tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n                     universe: ty::UniverseIndex::ROOT,\n-                    name: ty::BoundVar::from_usize(idx),\n+                    name: ty::BoundVar::from_usize({\n+                        let idx = self.idx;\n+                        self.idx += 1;\n+                        idx\n+                    }),\n                 }))\n-                .into()\n+            } else {\n+                t.super_fold_with(self)\n             }\n-            GenericArgKind::Const(ct) if ct.has_non_region_infer() || ct.has_non_region_param() => {\n-                let ty = ct.ty();\n-                // If the type references param or infer, replace that too...\n+        }\n+\n+        fn fold_const(&mut self, c: ty::Const<'tcx>) -> ty::Const<'tcx> {\n+            if let ty::ConstKind::Infer(_) = c.kind() {\n+                let ty = c.ty();\n+                // If the type references param or infer then ICE ICE ICE\n                 if ty.has_non_region_param() || ty.has_non_region_infer() {\n-                    bug!(\"const `{ct}`'s type should not reference params or types\");\n+                    bug!(\"const `{c}`'s type should not reference params or types\");\n                 }\n-                tcx.mk_const(\n+                self.tcx.mk_const(\n                     ty::PlaceholderConst {\n                         universe: ty::UniverseIndex::ROOT,\n-                        name: ty::BoundVar::from_usize(idx),\n+                        name: ty::BoundVar::from_usize({\n+                            let idx = self.idx;\n+                            self.idx += 1;\n+                            idx\n+                        }),\n                     },\n                     ty,\n                 )\n-                .into()\n+            } else {\n+                c.super_fold_with(self)\n             }\n-            _ => arg,\n         }\n-    }))\n+    }\n+\n+    substs.fold_with(&mut ReplaceParamAndInferWithPlaceholder { tcx, idx: 0 })\n }"}, {"sha": "1f9d86a78d6e50912f7cc3dba6e0b006391a33aa", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -275,13 +275,13 @@ where\n     ///   `ProjectionEq(projection = ?U)`, `ProjectionEq(other_projection = ?U)`.\n     fn relate_projection_ty(\n         &mut self,\n-        projection_ty: ty::ProjectionTy<'tcx>,\n+        projection_ty: ty::AliasTy<'tcx>,\n         value_ty: Ty<'tcx>,\n     ) -> Ty<'tcx> {\n         use rustc_span::DUMMY_SP;\n \n         match *value_ty.kind() {\n-            ty::Projection(other_projection_ty) => {\n+            ty::Alias(ty::Projection, other_projection_ty) => {\n                 let var = self.infcx.next_ty_var(TypeVariableOrigin {\n                     kind: TypeVariableOriginKind::MiscVariable,\n                     span: DUMMY_SP,\n@@ -335,7 +335,9 @@ where\n                 return Ok(value_ty);\n             }\n \n-            ty::Projection(projection_ty) if D::normalization() == NormalizationStrategy::Lazy => {\n+            ty::Alias(ty::Projection, projection_ty)\n+                if D::normalization() == NormalizationStrategy::Lazy =>\n+            {\n                 return Ok(self.relate_projection_ty(projection_ty, self.infcx.tcx.mk_ty_var(vid)));\n             }\n \n@@ -406,8 +408,8 @@ where\n             }\n         };\n         let (a, b) = match (a.kind(), b.kind()) {\n-            (&ty::Opaque(..), _) => (a, generalize(b, false)?),\n-            (_, &ty::Opaque(..)) => (generalize(a, true)?, b),\n+            (&ty::Alias(ty::Opaque, ..), _) => (a, generalize(b, false)?),\n+            (_, &ty::Alias(ty::Opaque, ..)) => (generalize(a, true)?, b),\n             _ => unreachable!(),\n         };\n         let cause = ObligationCause::dummy_with_span(self.delegate.span());\n@@ -608,26 +610,30 @@ where\n \n             (&ty::Infer(ty::TyVar(vid)), _) => self.relate_ty_var((vid, b)),\n \n-            (&ty::Opaque(a_def_id, _), &ty::Opaque(b_def_id, _)) if a_def_id == b_def_id => {\n-                infcx.super_combine_tys(self, a, b).or_else(|err| {\n-                    self.tcx().sess.delay_span_bug(\n-                        self.delegate.span(),\n-                        \"failure to relate an opaque to itself should result in an error later on\",\n-                    );\n-                    if a_def_id.is_local() { self.relate_opaques(a, b) } else { Err(err) }\n-                })\n-            }\n-            (&ty::Opaque(did, ..), _) | (_, &ty::Opaque(did, ..)) if did.is_local() => {\n+            (\n+                &ty::Alias(ty::Opaque, ty::AliasTy { def_id: a_def_id, .. }),\n+                &ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, .. }),\n+            ) if a_def_id == b_def_id => infcx.super_combine_tys(self, a, b).or_else(|err| {\n+                self.tcx().sess.delay_span_bug(\n+                    self.delegate.span(),\n+                    \"failure to relate an opaque to itself should result in an error later on\",\n+                );\n+                if a_def_id.is_local() { self.relate_opaques(a, b) } else { Err(err) }\n+            }),\n+            (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }), _)\n+            | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }))\n+                if def_id.is_local() =>\n+            {\n                 self.relate_opaques(a, b)\n             }\n \n-            (&ty::Projection(projection_ty), _)\n+            (&ty::Alias(ty::Projection, projection_ty), _)\n                 if D::normalization() == NormalizationStrategy::Lazy =>\n             {\n                 Ok(self.relate_projection_ty(projection_ty, b))\n             }\n \n-            (_, &ty::Projection(projection_ty))\n+            (_, &ty::Alias(ty::Projection, projection_ty))\n                 if D::normalization() == NormalizationStrategy::Lazy =>\n             {\n                 Ok(self.relate_projection_ty(projection_ty, a))"}, {"sha": "a130fde47ed5c4d7c0ccdae1536387b649f7cc1b", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -66,7 +66,9 @@ impl<'tcx> InferCtxt<'tcx> {\n             lt_op: |lt| lt,\n             ct_op: |ct| ct,\n             ty_op: |ty| match *ty.kind() {\n-                ty::Opaque(def_id, _substs) if replace_opaque_type(def_id) => {\n+                ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. })\n+                    if replace_opaque_type(def_id) =>\n+                {\n                     let def_span = self.tcx.def_span(def_id);\n                     let span = if span.contains(def_span) { def_span } else { span };\n                     let code = traits::ObligationCauseCode::OpaqueReturnType(None);\n@@ -104,7 +106,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         }\n         let (a, b) = if a_is_expected { (a, b) } else { (b, a) };\n         let process = |a: Ty<'tcx>, b: Ty<'tcx>, a_is_expected| match *a.kind() {\n-            ty::Opaque(def_id, substs) if def_id.is_local() => {\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) if def_id.is_local() => {\n                 let def_id = def_id.expect_local();\n                 let origin = match self.defining_use_anchor {\n                     DefiningAnchor::Bind(_) => {\n@@ -147,18 +149,19 @@ impl<'tcx> InferCtxt<'tcx> {\n                     DefiningAnchor::Bubble => self.opaque_ty_origin_unchecked(def_id, cause.span),\n                     DefiningAnchor::Error => return None,\n                 };\n-                if let ty::Opaque(did2, _) = *b.kind() {\n+                if let ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, .. }) = *b.kind() {\n                     // We could accept this, but there are various ways to handle this situation, and we don't\n                     // want to make a decision on it right now. Likely this case is so super rare anyway, that\n                     // no one encounters it in practice.\n                     // It does occur however in `fn fut() -> impl Future<Output = i32> { async { 42 } }`,\n                     // where it is of no concern, so we only check for TAITs.\n-                    if let Some(OpaqueTyOrigin::TyAlias) =\n-                        did2.as_local().and_then(|did2| self.opaque_type_origin(did2, cause.span))\n+                    if let Some(OpaqueTyOrigin::TyAlias) = b_def_id\n+                        .as_local()\n+                        .and_then(|b_def_id| self.opaque_type_origin(b_def_id, cause.span))\n                     {\n                         self.tcx.sess.emit_err(OpaqueHiddenTypeDiag {\n                             span: cause.span,\n-                            hidden_type: self.tcx.def_span(did2),\n+                            hidden_type: self.tcx.def_span(b_def_id),\n                             opaque_type: self.tcx.def_span(def_id),\n                         });\n                     }\n@@ -475,7 +478,7 @@ where\n                 substs.as_generator().resume_ty().visit_with(self);\n             }\n \n-            ty::Opaque(def_id, ref substs) => {\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, ref substs, .. }) => {\n                 // Skip lifetime paramters that are not captures.\n                 let variances = self.tcx.variances_of(*def_id);\n \n@@ -486,11 +489,11 @@ where\n                 }\n             }\n \n-            ty::Projection(proj)\n-                if self.tcx.def_kind(proj.item_def_id) == DefKind::ImplTraitPlaceholder =>\n+            ty::Alias(ty::Projection, proj)\n+                if self.tcx.def_kind(proj.def_id) == DefKind::ImplTraitPlaceholder =>\n             {\n                 // Skip lifetime paramters that are not captures.\n-                let variances = self.tcx.variances_of(proj.item_def_id);\n+                let variances = self.tcx.variances_of(proj.def_id);\n \n                 for (v, s) in std::iter::zip(variances, proj.substs.iter()) {\n                     if *v != ty::Variance::Bivariant {\n@@ -563,9 +566,9 @@ impl<'tcx> InferCtxt<'tcx> {\n                     // We can't normalize associated types from `rustc_infer`,\n                     // but we can eagerly register inference variables for them.\n                     // FIXME(RPITIT): Don't replace RPITITs with inference vars.\n-                    ty::Projection(projection_ty)\n+                    ty::Alias(ty::Projection, projection_ty)\n                         if !projection_ty.has_escaping_bound_vars()\n-                            && tcx.def_kind(projection_ty.item_def_id)\n+                            && tcx.def_kind(projection_ty.def_id)\n                                 != DefKind::ImplTraitPlaceholder =>\n                     {\n                         self.infer_projection(\n@@ -578,17 +581,16 @@ impl<'tcx> InferCtxt<'tcx> {\n                     }\n                     // Replace all other mentions of the same opaque type with the hidden type,\n                     // as the bounds must hold on the hidden type after all.\n-                    ty::Opaque(def_id2, substs2)\n+                    ty::Alias(ty::Opaque, ty::AliasTy { def_id: def_id2, substs: substs2, .. })\n                         if def_id.to_def_id() == def_id2 && substs == substs2 =>\n                     {\n                         hidden_ty\n                     }\n                     // FIXME(RPITIT): This can go away when we move to associated types\n-                    ty::Projection(proj)\n-                        if def_id.to_def_id() == proj.item_def_id && substs == proj.substs =>\n-                    {\n-                        hidden_ty\n-                    }\n+                    ty::Alias(\n+                        ty::Projection,\n+                        ty::AliasTy { def_id: def_id2, substs: substs2, .. },\n+                    ) if def_id.to_def_id() == def_id2 && substs == substs2 => hidden_ty,\n                     _ => ty,\n                 },\n                 lt_op: |lt| lt,"}, {"sha": "aa2b5d067d266d8742c322ea147ffe5bc4905442", "filename": "compiler/rustc_infer/src/infer/outlives/components.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -23,7 +23,7 @@ pub enum Component<'tcx> {\n     // is not in a position to judge which is the best technique, so\n     // we just product the projection as a component and leave it to\n     // the consumer to decide (but see `EscapingProjection` below).\n-    Projection(ty::ProjectionTy<'tcx>),\n+    Projection(ty::AliasTy<'tcx>),\n \n     // In the case where a projection has escaping regions -- meaning\n     // regions bound within the type itself -- we always use\n@@ -130,7 +130,7 @@ fn compute_components<'tcx>(\n             // outlives any other lifetime, which is unsound.\n             // See https://github.com/rust-lang/rust/issues/84305 for\n             // more details.\n-            ty::Opaque(def_id, substs) => {\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n                 out.push(Component::Opaque(def_id, substs));\n             },\n \n@@ -142,7 +142,7 @@ fn compute_components<'tcx>(\n             // trait-ref. Therefore, if we see any higher-ranked regions,\n             // we simply fallback to the most restrictive rule, which\n             // requires that `Pi: 'a` for all `i`.\n-            ty::Projection(ref data) => {\n+            ty::Alias(ty::Projection, ref data) => {\n                 if !data.has_escaping_bound_vars() {\n                     // best case: no escaping regions, so push the\n                     // projection and skip the subtree (thus generating no"}, {"sha": "ccae7165d80d2fac9d859c26b64031742bcbd244", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -338,7 +338,7 @@ where\n             substs,\n             true,\n             |ty| match *ty.kind() {\n-                ty::Opaque(def_id, substs) => (def_id, substs),\n+                ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => (def_id, substs),\n                 _ => bug!(\"expected only projection types from env, not {:?}\", ty),\n             },\n         );\n@@ -349,17 +349,19 @@ where\n         &mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n         region: ty::Region<'tcx>,\n-        projection_ty: ty::ProjectionTy<'tcx>,\n+        projection_ty: ty::AliasTy<'tcx>,\n     ) {\n         self.generic_must_outlive(\n             origin,\n             region,\n             GenericKind::Projection(projection_ty),\n-            projection_ty.item_def_id,\n+            projection_ty.def_id,\n             projection_ty.substs,\n             false,\n             |ty| match ty.kind() {\n-                ty::Projection(projection_ty) => (projection_ty.item_def_id, projection_ty.substs),\n+                ty::Alias(ty::Projection, projection_ty) => {\n+                    (projection_ty.def_id, projection_ty.substs)\n+                }\n                 _ => bug!(\"expected only projection types from env, not {:?}\", ty),\n             },\n         );"}, {"sha": "136da4a3cb12a110eaaffd96606370628219f855", "filename": "compiler/rustc_infer/src/infer/outlives/verify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -178,7 +178,7 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n             ),\n             Component::Projection(projection_ty) => self.projection_opaque_bounds(\n                 GenericKind::Projection(projection_ty),\n-                projection_ty.item_def_id,\n+                projection_ty.def_id,\n                 projection_ty.substs,\n                 visited,\n             ),"}, {"sha": "4667d99ff00080daacd1ad224218c596b48fb987", "filename": "compiler/rustc_infer/src/infer/projection.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fprojection.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -16,12 +16,12 @@ impl<'tcx> InferCtxt<'tcx> {\n     pub fn infer_projection(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n-        projection_ty: ty::ProjectionTy<'tcx>,\n+        projection_ty: ty::AliasTy<'tcx>,\n         cause: ObligationCause<'tcx>,\n         recursion_depth: usize,\n         obligations: &mut Vec<PredicateObligation<'tcx>>,\n     ) -> Ty<'tcx> {\n-        let def_id = projection_ty.item_def_id;\n+        let def_id = projection_ty.def_id;\n         let ty_var = self.next_ty_var(TypeVariableOrigin {\n             kind: TypeVariableOriginKind::NormalizeProjectionType,\n             span: self.tcx.def_span(def_id),"}, {"sha": "9a427ceacd0a7c63737805a2cb370adfa6788d7c", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -169,7 +169,7 @@ pub struct Verify<'tcx> {\n #[derive(Copy, Clone, PartialEq, Eq, Hash, TypeFoldable, TypeVisitable)]\n pub enum GenericKind<'tcx> {\n     Param(ty::ParamTy),\n-    Projection(ty::ProjectionTy<'tcx>),\n+    Projection(ty::AliasTy<'tcx>),\n     Opaque(DefId, SubstsRef<'tcx>),\n }\n \n@@ -773,7 +773,7 @@ impl<'tcx> GenericKind<'tcx> {\n     pub fn to_ty(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         match *self {\n             GenericKind::Param(ref p) => p.to_ty(tcx),\n-            GenericKind::Projection(ref p) => tcx.mk_projection(p.item_def_id, p.substs),\n+            GenericKind::Projection(ref p) => tcx.mk_projection(p.def_id, p.substs),\n             GenericKind::Opaque(def_id, substs) => tcx.mk_opaque(def_id, substs),\n         }\n     }"}, {"sha": "bd38b52ba34a7eab0fbcbae019d94d58dd0d2c40", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -130,12 +130,16 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n                 Ok(self.tcx().ty_error_with_guaranteed(e))\n             }\n \n-            (&ty::Opaque(a_def_id, _), &ty::Opaque(b_def_id, _)) if a_def_id == b_def_id => {\n+            (\n+                &ty::Alias(ty::Opaque, ty::AliasTy { def_id: a_def_id, .. }),\n+                &ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, .. }),\n+            ) if a_def_id == b_def_id => {\n                 self.fields.infcx.super_combine_tys(self, a, b)?;\n                 Ok(a)\n             }\n-            (&ty::Opaque(did, ..), _) | (_, &ty::Opaque(did, ..))\n-                if self.fields.define_opaque_types && did.is_local() =>\n+            (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }), _)\n+            | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }))\n+                if self.fields.define_opaque_types && def_id.is_local() =>\n             {\n                 self.fields.obligations.extend(\n                     infcx\n@@ -213,6 +217,11 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n     where\n         T: Relate<'tcx>,\n     {\n+        // A binder is always a subtype of itself if it's structually equal to itself\n+        if a == b {\n+            return Ok(a);\n+        }\n+\n         self.fields.higher_ranked_sub(a, b, self.a_is_expected)?;\n         Ok(a)\n     }"}, {"sha": "aade57be9fe6ef1f17389df22b23518193a1a243", "filename": "compiler/rustc_infer/src/traits/project.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fproject.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -77,11 +77,11 @@ pub struct ProjectionCacheStorage<'tcx> {\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub struct ProjectionCacheKey<'tcx> {\n-    ty: ty::ProjectionTy<'tcx>,\n+    ty: ty::AliasTy<'tcx>,\n }\n \n impl<'tcx> ProjectionCacheKey<'tcx> {\n-    pub fn new(ty: ty::ProjectionTy<'tcx>) -> Self {\n+    pub fn new(ty: ty::AliasTy<'tcx>) -> Self {\n         Self { ty }\n     }\n }"}, {"sha": "8f0bd3a9abe5e29ac32a3a754f3516790bd9a4c6", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -259,8 +259,7 @@ impl<'tcx> Elaborator<'tcx> {\n                             Component::Projection(projection) => {\n                                 // We might end up here if we have `Foo<<Bar as Baz>::Assoc>: 'a`.\n                                 // With this, we can deduce that `<Bar as Baz>::Assoc: 'a`.\n-                                let ty =\n-                                    tcx.mk_projection(projection.item_def_id, projection.substs);\n+                                let ty = tcx.mk_projection(projection.def_id, projection.substs);\n                                 Some(ty::PredicateKind::Clause(ty::Clause::TypeOutlives(\n                                     ty::OutlivesPredicate(ty, r_min),\n                                 )))"}, {"sha": "e903cb86dd20438a9264fcdf67bfedf6f3783cb4", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -25,7 +25,6 @@ use rustc_target::spec::{CodeModel, LinkerFlavorCli, MergeFunctions, PanicStrate\n use rustc_target::spec::{RelroLevel, SanitizerSet, SplitDebuginfo, StackProtector, TlsModel};\n \n use std::collections::{BTreeMap, BTreeSet};\n-use std::iter::FromIterator;\n use std::num::NonZeroUsize;\n use std::path::{Path, PathBuf};\n "}, {"sha": "50d6d5b9bab91a0bc08807c708ad7f02858d2842", "filename": "compiler/rustc_lexer/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Flib.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -34,7 +34,6 @@ pub use crate::cursor::Cursor;\n use self::LiteralKind::*;\n use self::TokenKind::*;\n use crate::cursor::EOF_CHAR;\n-use std::convert::TryFrom;\n \n /// Parsed token.\n /// It doesn't contain information about data that has been parsed,"}, {"sha": "87c44638a8de1918883375cd0d6357dfebd8a16b", "filename": "compiler/rustc_lexer/src/unescape.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -204,14 +204,13 @@ fn scan_escape(chars: &mut Chars<'_>, is_byte: bool) -> Result<char, EscapeError\n                         })?;\n                     }\n                     Some(c) => {\n-                        let digit =\n+                        let digit: u32 =\n                             c.to_digit(16).ok_or(EscapeError::InvalidCharInUnicodeEscape)?;\n                         n_digits += 1;\n                         if n_digits > 6 {\n                             // Stop updating value since we're sure that it's incorrect already.\n                             continue;\n                         }\n-                        let digit = digit as u32;\n                         value = value * 16 + digit;\n                     }\n                 };"}, {"sha": "43862570e80954aa8c11dbd80e4aa4e060e66ed9", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -3016,8 +3016,8 @@ impl ClashingExternDeclarations {\n                         | (Closure(..), Closure(..))\n                         | (Generator(..), Generator(..))\n                         | (GeneratorWitness(..), GeneratorWitness(..))\n-                        | (Projection(..), Projection(..))\n-                        | (Opaque(..), Opaque(..)) => false,\n+                        | (Alias(ty::Projection, ..), Alias(ty::Projection, ..))\n+                        | (Alias(ty::Opaque, ..), Alias(ty::Opaque, ..)) => false,\n \n                         // These definitely should have been caught above.\n                         (Bool, Bool) | (Char, Char) | (Never, Never) | (Str, Str) => unreachable!(),"}, {"sha": "40b2588388d66886353297cc50a5070b0bdd6069", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1258,7 +1258,7 @@ impl<'tcx> LateContext<'tcx> {\n         tcx.associated_items(trait_id)\n             .find_by_name_and_kind(tcx, Ident::from_str(name), ty::AssocKind::Type, trait_id)\n             .and_then(|assoc| {\n-                let proj = tcx.mk_projection(assoc.def_id, tcx.mk_substs_trait(self_ty, []));\n+                let proj = tcx.mk_projection(assoc.def_id, [self_ty]);\n                 tcx.try_normalize_erasing_regions(self.param_env, proj).ok()\n             })\n     }"}, {"sha": "5f84d5c8b949575394d401a287bbe1b025563376", "filename": "compiler/rustc_lint/src/early.rs", "status": "modified", "additions": 97, "deletions": 52, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fearly.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -20,23 +20,23 @@ use rustc_ast::ptr::P;\n use rustc_ast::visit::{self as ast_visit, Visitor};\n use rustc_ast::{self as ast, walk_list, HasAttrs};\n use rustc_middle::ty::RegisteredTools;\n-use rustc_session::lint::{BufferedEarlyLint, LintBuffer};\n+use rustc_session::lint::{BufferedEarlyLint, LintBuffer, LintPass};\n use rustc_session::Session;\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n-macro_rules! run_early_passes { ($cx:expr, $f:ident, $($args:expr),*) => ({\n-    for pass in $cx.passes.iter_mut() {\n-        pass.$f(&$cx.context, $($args),*);\n-    }\n+macro_rules! lint_callback { ($cx:expr, $f:ident, $($args:expr),*) => ({\n+    $cx.pass.$f(&$cx.context, $($args),*);\n }) }\n \n-pub struct EarlyContextAndPasses<'a> {\n+/// Implements the AST traversal for early lint passes. `T` provides the the\n+/// `check_*` methods.\n+pub struct EarlyContextAndPass<'a, T: EarlyLintPass> {\n     context: EarlyContext<'a>,\n-    passes: Vec<EarlyLintPassObject>,\n+    pass: T,\n }\n \n-impl<'a> EarlyContextAndPasses<'a> {\n+impl<'a, T: EarlyLintPass> EarlyContextAndPass<'a, T> {\n     // This always-inlined function is for the hot call site.\n     #[inline(always)]\n     fn inlined_check_id(&mut self, id: ast::NodeId) {\n@@ -70,27 +70,27 @@ impl<'a> EarlyContextAndPasses<'a> {\n \n         self.inlined_check_id(id);\n         debug!(\"early context: enter_attrs({:?})\", attrs);\n-        run_early_passes!(self, enter_lint_attrs, attrs);\n+        lint_callback!(self, enter_lint_attrs, attrs);\n         f(self);\n         debug!(\"early context: exit_attrs({:?})\", attrs);\n-        run_early_passes!(self, exit_lint_attrs, attrs);\n+        lint_callback!(self, exit_lint_attrs, attrs);\n         self.context.builder.pop(push);\n     }\n }\n \n-impl<'a> ast_visit::Visitor<'a> for EarlyContextAndPasses<'a> {\n+impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T> {\n     fn visit_param(&mut self, param: &'a ast::Param) {\n         self.with_lint_attrs(param.id, &param.attrs, |cx| {\n-            run_early_passes!(cx, check_param, param);\n+            lint_callback!(cx, check_param, param);\n             ast_visit::walk_param(cx, param);\n         });\n     }\n \n     fn visit_item(&mut self, it: &'a ast::Item) {\n         self.with_lint_attrs(it.id, &it.attrs, |cx| {\n-            run_early_passes!(cx, check_item, it);\n+            lint_callback!(cx, check_item, it);\n             ast_visit::walk_item(cx, it);\n-            run_early_passes!(cx, check_item_post, it);\n+            lint_callback!(cx, check_item_post, it);\n         })\n     }\n \n@@ -101,10 +101,10 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContextAndPasses<'a> {\n     }\n \n     fn visit_pat(&mut self, p: &'a ast::Pat) {\n-        run_early_passes!(self, check_pat, p);\n+        lint_callback!(self, check_pat, p);\n         self.check_id(p.id);\n         ast_visit::walk_pat(self, p);\n-        run_early_passes!(self, check_pat_post, p);\n+        lint_callback!(self, check_pat_post, p);\n     }\n \n     fn visit_pat_field(&mut self, field: &'a ast::PatField) {\n@@ -120,7 +120,7 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContextAndPasses<'a> {\n \n     fn visit_expr(&mut self, e: &'a ast::Expr) {\n         self.with_lint_attrs(e.id, &e.attrs, |cx| {\n-            run_early_passes!(cx, check_expr, e);\n+            lint_callback!(cx, check_expr, e);\n             ast_visit::walk_expr(cx, e);\n         })\n     }\n@@ -141,7 +141,7 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContextAndPasses<'a> {\n         // Note that statements get their attributes from\n         // the AST struct that they wrap (e.g. an item)\n         self.with_lint_attrs(s.id, s.attrs(), |cx| {\n-            run_early_passes!(cx, check_stmt, s);\n+            lint_callback!(cx, check_stmt, s);\n             cx.check_id(s.id);\n         });\n         // The visitor for the AST struct wrapped\n@@ -152,7 +152,7 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContextAndPasses<'a> {\n     }\n \n     fn visit_fn(&mut self, fk: ast_visit::FnKind<'a>, span: Span, id: ast::NodeId) {\n-        run_early_passes!(self, check_fn, fk, span, id);\n+        lint_callback!(self, check_fn, fk, span, id);\n         self.check_id(id);\n         ast_visit::walk_fn(self, fk);\n \n@@ -180,37 +180,37 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContextAndPasses<'a> {\n \n     fn visit_variant(&mut self, v: &'a ast::Variant) {\n         self.with_lint_attrs(v.id, &v.attrs, |cx| {\n-            run_early_passes!(cx, check_variant, v);\n+            lint_callback!(cx, check_variant, v);\n             ast_visit::walk_variant(cx, v);\n         })\n     }\n \n     fn visit_ty(&mut self, t: &'a ast::Ty) {\n-        run_early_passes!(self, check_ty, t);\n+        lint_callback!(self, check_ty, t);\n         self.check_id(t.id);\n         ast_visit::walk_ty(self, t);\n     }\n \n     fn visit_ident(&mut self, ident: Ident) {\n-        run_early_passes!(self, check_ident, ident);\n+        lint_callback!(self, check_ident, ident);\n     }\n \n     fn visit_local(&mut self, l: &'a ast::Local) {\n         self.with_lint_attrs(l.id, &l.attrs, |cx| {\n-            run_early_passes!(cx, check_local, l);\n+            lint_callback!(cx, check_local, l);\n             ast_visit::walk_local(cx, l);\n         })\n     }\n \n     fn visit_block(&mut self, b: &'a ast::Block) {\n-        run_early_passes!(self, check_block, b);\n+        lint_callback!(self, check_block, b);\n         self.check_id(b.id);\n         ast_visit::walk_block(self, b);\n     }\n \n     fn visit_arm(&mut self, a: &'a ast::Arm) {\n         self.with_lint_attrs(a.id, &a.attrs, |cx| {\n-            run_early_passes!(cx, check_arm, a);\n+            lint_callback!(cx, check_arm, a);\n             ast_visit::walk_arm(cx, a);\n         })\n     }\n@@ -229,19 +229,19 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContextAndPasses<'a> {\n     }\n \n     fn visit_generic_arg(&mut self, arg: &'a ast::GenericArg) {\n-        run_early_passes!(self, check_generic_arg, arg);\n+        lint_callback!(self, check_generic_arg, arg);\n         ast_visit::walk_generic_arg(self, arg);\n     }\n \n     fn visit_generic_param(&mut self, param: &'a ast::GenericParam) {\n         self.with_lint_attrs(param.id, &param.attrs, |cx| {\n-            run_early_passes!(cx, check_generic_param, param);\n+            lint_callback!(cx, check_generic_param, param);\n             ast_visit::walk_generic_param(cx, param);\n         });\n     }\n \n     fn visit_generics(&mut self, g: &'a ast::Generics) {\n-        run_early_passes!(self, check_generics, g);\n+        lint_callback!(self, check_generics, g);\n         ast_visit::walk_generics(self, g);\n     }\n \n@@ -250,18 +250,18 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContextAndPasses<'a> {\n     }\n \n     fn visit_poly_trait_ref(&mut self, t: &'a ast::PolyTraitRef) {\n-        run_early_passes!(self, check_poly_trait_ref, t);\n+        lint_callback!(self, check_poly_trait_ref, t);\n         ast_visit::walk_poly_trait_ref(self, t);\n     }\n \n     fn visit_assoc_item(&mut self, item: &'a ast::AssocItem, ctxt: ast_visit::AssocCtxt) {\n         self.with_lint_attrs(item.id, &item.attrs, |cx| match ctxt {\n             ast_visit::AssocCtxt::Trait => {\n-                run_early_passes!(cx, check_trait_item, item);\n+                lint_callback!(cx, check_trait_item, item);\n                 ast_visit::walk_assoc_item(cx, item, ctxt);\n             }\n             ast_visit::AssocCtxt::Impl => {\n-                run_early_passes!(cx, check_impl_item, item);\n+                lint_callback!(cx, check_impl_item, item);\n                 ast_visit::walk_assoc_item(cx, item, ctxt);\n             }\n         });\n@@ -282,28 +282,57 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContextAndPasses<'a> {\n     }\n \n     fn visit_attribute(&mut self, attr: &'a ast::Attribute) {\n-        run_early_passes!(self, check_attribute, attr);\n+        lint_callback!(self, check_attribute, attr);\n     }\n \n     fn visit_mac_def(&mut self, mac: &'a ast::MacroDef, id: ast::NodeId) {\n-        run_early_passes!(self, check_mac_def, mac);\n+        lint_callback!(self, check_mac_def, mac);\n         self.check_id(id);\n     }\n \n     fn visit_mac_call(&mut self, mac: &'a ast::MacCall) {\n-        run_early_passes!(self, check_mac, mac);\n+        lint_callback!(self, check_mac, mac);\n         ast_visit::walk_mac(self, mac);\n     }\n }\n \n+// Combines multiple lint passes into a single pass, at runtime. Each\n+// `check_foo` method in `$methods` within this pass simply calls `check_foo`\n+// once per `$pass`. Compare with `declare_combined_early_lint_pass`, which is\n+// similar, but combines lint passes at compile time.\n+struct RuntimeCombinedEarlyLintPass<'a> {\n+    passes: &'a mut [EarlyLintPassObject],\n+}\n+\n+#[allow(rustc::lint_pass_impl_without_macro)]\n+impl LintPass for RuntimeCombinedEarlyLintPass<'_> {\n+    fn name(&self) -> &'static str {\n+        panic!()\n+    }\n+}\n+\n+macro_rules! impl_early_lint_pass {\n+    ([], [$($(#[$attr:meta])* fn $f:ident($($param:ident: $arg:ty),*);)*]) => (\n+        impl EarlyLintPass for RuntimeCombinedEarlyLintPass<'_> {\n+            $(fn $f(&mut self, context: &EarlyContext<'_>, $($param: $arg),*) {\n+                for pass in self.passes.iter_mut() {\n+                    pass.$f(context, $($param),*);\n+                }\n+            })*\n+        }\n+    )\n+}\n+\n+crate::early_lint_methods!(impl_early_lint_pass, []);\n+\n /// Early lints work on different nodes - either on the crate root, or on freshly loaded modules.\n /// This trait generalizes over those nodes.\n pub trait EarlyCheckNode<'a>: Copy {\n     fn id(self) -> ast::NodeId;\n     fn attrs<'b>(self) -> &'b [ast::Attribute]\n     where\n         'a: 'b;\n-    fn check<'b>(self, cx: &mut EarlyContextAndPasses<'b>)\n+    fn check<'b, T: EarlyLintPass>(self, cx: &mut EarlyContextAndPass<'b, T>)\n     where\n         'a: 'b;\n }\n@@ -318,13 +347,13 @@ impl<'a> EarlyCheckNode<'a> for &'a ast::Crate {\n     {\n         &self.attrs\n     }\n-    fn check<'b>(self, cx: &mut EarlyContextAndPasses<'b>)\n+    fn check<'b, T: EarlyLintPass>(self, cx: &mut EarlyContextAndPass<'b, T>)\n     where\n         'a: 'b,\n     {\n-        run_early_passes!(cx, check_crate, self);\n+        lint_callback!(cx, check_crate, self);\n         ast_visit::walk_crate(cx, self);\n-        run_early_passes!(cx, check_crate_post, self);\n+        lint_callback!(cx, check_crate_post, self);\n     }\n }\n \n@@ -338,7 +367,7 @@ impl<'a> EarlyCheckNode<'a> for (ast::NodeId, &'a [ast::Attribute], &'a [P<ast::\n     {\n         self.1\n     }\n-    fn check<'b>(self, cx: &mut EarlyContextAndPasses<'b>)\n+    fn check<'b, T: EarlyLintPass>(self, cx: &mut EarlyContextAndPass<'b, T>)\n     where\n         'a: 'b,\n     {\n@@ -356,21 +385,37 @@ pub fn check_ast_node<'a>(\n     builtin_lints: impl EarlyLintPass + 'static,\n     check_node: impl EarlyCheckNode<'a>,\n ) {\n+    let context = EarlyContext::new(\n+        sess,\n+        !pre_expansion,\n+        lint_store,\n+        registered_tools,\n+        lint_buffer.unwrap_or_default(),\n+    );\n+\n+    // Note: `passes` is often empty. In that case, it's faster to run\n+    // `builtin_lints` directly rather than bundling it up into the\n+    // `RuntimeCombinedEarlyLintPass`.\n     let passes =\n         if pre_expansion { &lint_store.pre_expansion_passes } else { &lint_store.early_passes };\n-    let mut passes: Vec<EarlyLintPassObject> = passes.iter().map(|p| (p)()).collect();\n-    passes.push(Box::new(builtin_lints));\n-\n-    let mut cx = EarlyContextAndPasses {\n-        context: EarlyContext::new(\n-            sess,\n-            !pre_expansion,\n-            lint_store,\n-            registered_tools,\n-            lint_buffer.unwrap_or_default(),\n-        ),\n-        passes,\n-    };\n+    if passes.is_empty() {\n+        check_ast_node_inner(sess, check_node, context, builtin_lints);\n+    } else {\n+        let mut passes: Vec<_> = passes.iter().map(|mk_pass| (mk_pass)()).collect();\n+        passes.push(Box::new(builtin_lints));\n+        let pass = RuntimeCombinedEarlyLintPass { passes: &mut passes[..] };\n+        check_ast_node_inner(sess, check_node, context, pass);\n+    }\n+}\n+\n+pub fn check_ast_node_inner<'a, T: EarlyLintPass>(\n+    sess: &Session,\n+    check_node: impl EarlyCheckNode<'a>,\n+    context: EarlyContext<'_>,\n+    pass: T,\n+) {\n+    let mut cx = EarlyContextAndPass { context, pass };\n+\n     cx.with_lint_attrs(check_node.id(), check_node.attrs(), |cx| check_node.check(cx));\n \n     // All of the buffered lints should have been emitted at this point."}, {"sha": "e2876938d70566477329cc94541c81478a3894f1", "filename": "compiler/rustc_lint/src/late.rs", "status": "modified", "additions": 75, "deletions": 14, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flate.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -23,6 +23,7 @@ use rustc_hir::intravisit as hir_visit;\n use rustc_hir::intravisit::Visitor;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::{self, TyCtxt};\n+use rustc_session::lint::LintPass;\n use rustc_span::Span;\n \n use std::any::Any;\n@@ -36,17 +37,17 @@ pub fn unerased_lint_store(tcx: TyCtxt<'_>) -> &LintStore {\n }\n \n macro_rules! lint_callback { ($cx:expr, $f:ident, $($args:expr),*) => ({\n-    for pass in $cx.passes.iter_mut() {\n-        pass.$f(&$cx.context, $($args),*);\n-    }\n+    $cx.pass.$f(&$cx.context, $($args),*);\n }) }\n \n-struct LateContextAndPasses<'tcx> {\n+/// Implements the AST traversal for late lint passes. `T` provides the the\n+/// `check_*` methods.\n+pub struct LateContextAndPass<'tcx, T: LateLintPass<'tcx>> {\n     context: LateContext<'tcx>,\n-    passes: Vec<LateLintPassObject<'tcx>>,\n+    pass: T,\n }\n \n-impl<'tcx> LateContextAndPasses<'tcx> {\n+impl<'tcx, T: LateLintPass<'tcx>> LateContextAndPass<'tcx, T> {\n     /// Merge the lints specified by any lint attributes into the\n     /// current lint context, call the provided function, then reset the\n     /// lints in effect to their previous state.\n@@ -82,7 +83,7 @@ impl<'tcx> LateContextAndPasses<'tcx> {\n     }\n }\n \n-impl<'tcx> hir_visit::Visitor<'tcx> for LateContextAndPasses<'tcx> {\n+impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPass<'tcx, T> {\n     type NestedFilter = nested_filter::All;\n \n     /// Because lints are scoped lexically, we want to walk nested\n@@ -302,6 +303,35 @@ impl<'tcx> hir_visit::Visitor<'tcx> for LateContextAndPasses<'tcx> {\n     }\n }\n \n+// Combines multiple lint passes into a single pass, at runtime. Each\n+// `check_foo` method in `$methods` within this pass simply calls `check_foo`\n+// once per `$pass`. Compare with `declare_combined_late_lint_pass`, which is\n+// similar, but combines lint passes at compile time.\n+struct RuntimeCombinedLateLintPass<'a, 'tcx> {\n+    passes: &'a mut [LateLintPassObject<'tcx>],\n+}\n+\n+#[allow(rustc::lint_pass_impl_without_macro)]\n+impl LintPass for RuntimeCombinedLateLintPass<'_, '_> {\n+    fn name(&self) -> &'static str {\n+        panic!()\n+    }\n+}\n+\n+macro_rules! impl_late_lint_pass {\n+    ([], [$($(#[$attr:meta])* fn $f:ident($($param:ident: $arg:ty),*);)*]) => {\n+        impl<'tcx> LateLintPass<'tcx> for RuntimeCombinedLateLintPass<'_, 'tcx> {\n+            $(fn $f(&mut self, context: &LateContext<'tcx>, $($param: $arg),*) {\n+                for pass in self.passes.iter_mut() {\n+                    pass.$f(context, $($param),*);\n+                }\n+            })*\n+        }\n+    };\n+}\n+\n+crate::late_lint_methods!(impl_late_lint_pass, []);\n+\n pub(super) fn late_lint_mod<'tcx, T: LateLintPass<'tcx> + 'tcx>(\n     tcx: TyCtxt<'tcx>,\n     module_def_id: LocalDefId,\n@@ -319,11 +349,27 @@ pub(super) fn late_lint_mod<'tcx, T: LateLintPass<'tcx> + 'tcx>(\n         only_module: true,\n     };\n \n+    // Note: `passes` is often empty. In that case, it's faster to run\n+    // `builtin_lints` directly rather than bundling it up into the\n+    // `RuntimeCombinedLateLintPass`.\n     let mut passes: Vec<_> =\n-        unerased_lint_store(tcx).late_module_passes.iter().map(|pass| (pass)(tcx)).collect();\n-    passes.push(Box::new(builtin_lints));\n+        unerased_lint_store(tcx).late_module_passes.iter().map(|mk_pass| (mk_pass)(tcx)).collect();\n+    if passes.is_empty() {\n+        late_lint_mod_inner(tcx, module_def_id, context, builtin_lints);\n+    } else {\n+        passes.push(Box::new(builtin_lints));\n+        let pass = RuntimeCombinedLateLintPass { passes: &mut passes[..] };\n+        late_lint_mod_inner(tcx, module_def_id, context, pass);\n+    }\n+}\n \n-    let mut cx = LateContextAndPasses { context, passes };\n+fn late_lint_mod_inner<'tcx, T: LateLintPass<'tcx>>(\n+    tcx: TyCtxt<'tcx>,\n+    module_def_id: LocalDefId,\n+    context: LateContext<'tcx>,\n+    pass: T,\n+) {\n+    let mut cx = LateContextAndPass { context, pass };\n \n     let (module, _span, hir_id) = tcx.hir().get_module(module_def_id);\n     cx.process_mod(module, hir_id);\n@@ -349,11 +395,26 @@ fn late_lint_crate<'tcx, T: LateLintPass<'tcx> + 'tcx>(tcx: TyCtxt<'tcx>, builti\n         only_module: false,\n     };\n \n-    let mut passes =\n-        unerased_lint_store(tcx).late_passes.iter().map(|p| (p)(tcx)).collect::<Vec<_>>();\n-    passes.push(Box::new(builtin_lints));\n+    // Note: `passes` is often empty. In that case, it's faster to run\n+    // `builtin_lints` directly rather than bundling it up into the\n+    // `RuntimeCombinedLateLintPass`.\n+    let mut passes: Vec<_> =\n+        unerased_lint_store(tcx).late_passes.iter().map(|mk_pass| (mk_pass)(tcx)).collect();\n+    if passes.is_empty() {\n+        late_lint_crate_inner(tcx, context, builtin_lints);\n+    } else {\n+        passes.push(Box::new(builtin_lints));\n+        let pass = RuntimeCombinedLateLintPass { passes: &mut passes[..] };\n+        late_lint_crate_inner(tcx, context, pass);\n+    }\n+}\n \n-    let mut cx = LateContextAndPasses { context, passes };\n+fn late_lint_crate_inner<'tcx, T: LateLintPass<'tcx>>(\n+    tcx: TyCtxt<'tcx>,\n+    context: LateContext<'tcx>,\n+    pass: T,\n+) {\n+    let mut cx = LateContextAndPass { context, pass };\n \n     // Visit the whole crate.\n     cx.with_lint_attrs(hir::CRATE_HIR_ID, |cx| {"}, {"sha": "11022eb80ea5ff04bd713ee1ba29c27af2d5cc55", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -127,7 +127,6 @@ fn lint_mod(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     late::late_lint_mod(tcx, module_def_id, BuiltinCombinedModuleLateLintPass::new());\n }\n \n-// See the comment on `BuiltinCombinedEarlyLintPass`, which is similar.\n early_lint_methods!(\n     declare_combined_early_lint_pass,\n     [\n@@ -138,9 +137,6 @@ early_lint_methods!(\n     ]\n );\n \n-// Declare `BuiltinCombinedEarlyLintPass`, a lint pass that combines multiple\n-// lint passes into a single pass for maximum speed. Each `check_foo` method\n-// within this pass simply calls `check_foo` once per listed lint.\n early_lint_methods!(\n     declare_combined_early_lint_pass,\n     [\n@@ -168,7 +164,6 @@ early_lint_methods!(\n \n // FIXME: Make a separate lint type which does not require typeck tables.\n \n-// See the comment on `BuiltinCombinedEarlyLintPass`, which is similar.\n late_lint_methods!(\n     declare_combined_late_lint_pass,\n     [\n@@ -188,7 +183,6 @@ late_lint_methods!(\n     ]\n );\n \n-// See the comment on `BuiltinCombinedEarlyLintPass`, which is similar.\n late_lint_methods!(\n     declare_combined_late_lint_pass,\n     ["}, {"sha": "42442cfb1904d4ddfdd621d53b156e62ec1186f2", "filename": "compiler/rustc_lint/src/opaque_hidden_inferred_bound.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -82,7 +82,7 @@ impl<'tcx> LateLintPass<'tcx> for OpaqueHiddenInferredBound {\n             let Some(proj_term) = proj.term.ty() else { continue };\n \n             let proj_ty =\n-                cx.tcx.mk_projection(proj.projection_ty.item_def_id, proj.projection_ty.substs);\n+                cx.tcx.mk_projection(proj.projection_ty.def_id, proj.projection_ty.substs);\n             // For every instance of the projection type in the bounds,\n             // replace them with the term we're assigning to the associated\n             // type in our opaque type.\n@@ -97,7 +97,7 @@ impl<'tcx> LateLintPass<'tcx> for OpaqueHiddenInferredBound {\n             // with `impl Send: OtherTrait`.\n             for (assoc_pred, assoc_pred_span) in cx\n                 .tcx\n-                .bound_explicit_item_bounds(proj.projection_ty.item_def_id)\n+                .bound_explicit_item_bounds(proj.projection_ty.def_id)\n                 .subst_iter_copied(cx.tcx, &proj.projection_ty.substs)\n             {\n                 let assoc_pred = assoc_pred.fold_with(proj_replacer);\n@@ -117,7 +117,7 @@ impl<'tcx> LateLintPass<'tcx> for OpaqueHiddenInferredBound {\n                     // then we can emit a suggestion to add the bound.\n                     let add_bound = match (proj_term.kind(), assoc_pred.kind().skip_binder()) {\n                         (\n-                            ty::Opaque(def_id, _),\n+                            ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }),\n                             ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)),\n                         ) => Some(AddBound {\n                             suggest_span: cx.tcx.def_span(*def_id).shrink_to_hi(),"}, {"sha": "5558156a4b9ef040a07ff54271328b64f31e2ba4", "filename": "compiler/rustc_lint/src/passes.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -95,6 +95,11 @@ macro_rules! expand_combined_late_lint_pass_methods {\n     )\n }\n \n+/// Combines multiple lints passes into a single lint pass, at compile time,\n+/// for maximum speed. Each `check_foo` method in `$methods` within this pass\n+/// simply calls `check_foo` once per `$pass`. Compare with\n+/// `LateLintPassObjects`, which is similar, but combines lint passes at\n+/// runtime.\n #[macro_export]\n macro_rules! declare_combined_late_lint_pass {\n     ([$v:vis $name:ident, [$($pass:ident: $constructor:expr,)*]], $methods:tt) => (\n@@ -198,6 +203,11 @@ macro_rules! expand_combined_early_lint_pass_methods {\n     )\n }\n \n+/// Combines multiple lints passes into a single lint pass, at compile time,\n+/// for maximum speed. Each `check_foo` method in `$methods` within this pass\n+/// simply calls `check_foo` once per `$pass`. Compare with\n+/// `EarlyLintPassObjects`, which is similar, but combines lint passes at\n+/// runtime.\n #[macro_export]\n macro_rules! declare_combined_early_lint_pass {\n     ([$v:vis $name:ident, [$($pass:ident: $constructor:expr,)*]], $methods:tt) => ("}, {"sha": "8e27bc03c489aeedf8ab0b5d2cd15776c8cff157", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -16,7 +16,6 @@ use rustc_target::abi::{Abi, Size, WrappingRange};\n use rustc_target::abi::{Integer, TagEncoding, Variants};\n use rustc_target::spec::abi::Abi as SpecAbi;\n \n-use std::cmp;\n use std::iter;\n use std::ops::ControlFlow;\n \n@@ -531,7 +530,7 @@ impl<'tcx> LateLintPass<'tcx> for TypeLimits {\n             _ => {}\n         };\n \n-        fn is_valid<T: cmp::PartialOrd>(binop: hir::BinOp, v: T, min: T, max: T) -> bool {\n+        fn is_valid<T: PartialOrd>(binop: hir::BinOp, v: T, min: T, max: T) -> bool {\n             match binop.node {\n                 hir::BinOpKind::Lt => v > min && v <= max,\n                 hir::BinOpKind::Le => v >= min && v < max,\n@@ -1140,18 +1139,20 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n             // While opaque types are checked for earlier, if a projection in a struct field\n             // normalizes to an opaque type, then it will reach this branch.\n-            ty::Opaque(..) => {\n+            ty::Alias(ty::Opaque, ..) => {\n                 FfiUnsafe { ty, reason: fluent::lint_improper_ctypes_opaque, help: None }\n             }\n \n             // `extern \"C\" fn` functions can have type parameters, which may or may not be FFI-safe,\n             //  so they are currently ignored for the purposes of this lint.\n-            ty::Param(..) | ty::Projection(..) if matches!(self.mode, CItemKind::Definition) => {\n+            ty::Param(..) | ty::Alias(ty::Projection, ..)\n+                if matches!(self.mode, CItemKind::Definition) =>\n+            {\n                 FfiSafe\n             }\n \n             ty::Param(..)\n-            | ty::Projection(..)\n+            | ty::Alias(ty::Projection, ..)\n             | ty::Infer(..)\n             | ty::Bound(..)\n             | ty::Error(_)\n@@ -1206,7 +1207,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     return ControlFlow::CONTINUE;\n                 }\n \n-                if let ty::Opaque(..) = ty.kind() {\n+                if let ty::Alias(ty::Opaque, ..) = ty.kind() {\n                     ControlFlow::Break(ty)\n                 } else {\n                     ty.super_visit_with(self)"}, {"sha": "d628a18dd01c5875c36e5ad8bebb8940b8f89cc6", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -96,7 +96,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n \n         if let hir::ExprKind::Match(await_expr, _arms, hir::MatchSource::AwaitDesugar) = expr.kind\n             && let ty = cx.typeck_results().expr_ty(&await_expr)\n-            && let ty::Opaque(future_def_id, _) = ty.kind()\n+            && let ty::Alias(ty::Opaque, ty::AliasTy { def_id: future_def_id, .. }) = ty.kind()\n             && cx.tcx.ty_is_opaque_future(ty)\n             // FIXME: This also includes non-async fns that return `impl Future`.\n             && let async_fn_def_id = cx.tcx.parent(*future_def_id)\n@@ -251,7 +251,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                         .map(|inner| MustUsePath::Boxed(Box::new(inner)))\n                 }\n                 ty::Adt(def, _) => is_def_must_use(cx, def.did(), span),\n-                ty::Opaque(def, _) => {\n+                ty::Alias(ty::Opaque, ty::AliasTy { def_id: def, .. }) => {\n                     elaborate_predicates_with_span(\n                         cx.tcx,\n                         cx.tcx.explicit_item_bounds(def).iter().cloned(),"}, {"sha": "33cb35e60ebb6cfc1edf37d68a4262b57956e19b", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 55, "deletions": 14, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -911,8 +911,7 @@ declare_lint! {\n \n declare_lint! {\n     /// The `trivial_casts` lint detects trivial casts which could be replaced\n-    /// with coercion, which may require [type ascription] or a temporary\n-    /// variable.\n+    /// with coercion, which may require a temporary variable.\n     ///\n     /// ### Example\n     ///\n@@ -934,12 +933,14 @@ declare_lint! {\n     /// with FFI interfaces or complex type aliases, where it triggers\n     /// incorrectly, or in situations where it will be more difficult to\n     /// clearly express the intent. It may be possible that this will become a\n-    /// warning in the future, possibly with [type ascription] providing a\n-    /// convenient way to work around the current issues. See [RFC 401] for\n-    /// historical context.\n-    ///\n-    /// [type ascription]: https://github.com/rust-lang/rust/issues/23416\n-    /// [RFC 401]: https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md\n+    /// warning in the future, possibly with an explicit syntax for coercions\n+    /// providing a convenient way to work around the current issues.\n+    /// See [RFC 401 (coercions)][rfc-401], [RFC 803 (type ascription)][rfc-803] and\n+    /// [RFC 3307 (remove type ascription)][rfc-3307] for historical context.\n+    ///\n+    /// [rfc-401]: https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md\n+    /// [rfc-803]: https://github.com/rust-lang/rfcs/blob/master/text/0803-type-ascription.md\n+    /// [rfc-3307]: https://github.com/rust-lang/rfcs/blob/master/text/3307-de-rfc-type-ascription.md\n     pub TRIVIAL_CASTS,\n     Allow,\n     \"detects trivial casts which could be removed\"\n@@ -967,12 +968,14 @@ declare_lint! {\n     /// with FFI interfaces or complex type aliases, where it triggers\n     /// incorrectly, or in situations where it will be more difficult to\n     /// clearly express the intent. It may be possible that this will become a\n-    /// warning in the future, possibly with [type ascription] providing a\n-    /// convenient way to work around the current issues. See [RFC 401] for\n-    /// historical context.\n-    ///\n-    /// [type ascription]: https://github.com/rust-lang/rust/issues/23416\n-    /// [RFC 401]: https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md\n+    /// warning in the future, possibly with an explicit syntax for coercions\n+    /// providing a convenient way to work around the current issues.\n+    /// See [RFC 401 (coercions)][rfc-401], [RFC 803 (type ascription)][rfc-803] and\n+    /// [RFC 3307 (remove type ascription)][rfc-3307] for historical context.\n+    ///\n+    /// [rfc-401]: https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md\n+    /// [rfc-803]: https://github.com/rust-lang/rfcs/blob/master/text/0803-type-ascription.md\n+    /// [rfc-3307]: https://github.com/rust-lang/rfcs/blob/master/text/3307-de-rfc-type-ascription.md\n     pub TRIVIAL_NUMERIC_CASTS,\n     Allow,\n     \"detects trivial casts of numeric types which could be removed\"\n@@ -1016,6 +1019,44 @@ declare_lint! {\n     };\n }\n \n+declare_lint! {\n+    /// The `invalid_alignment` lint detects dereferences of misaligned pointers during\n+    /// constant evluation.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![feature(const_ptr_read)]\n+    /// const FOO: () = unsafe {\n+    ///     let x = &[0_u8; 4];\n+    ///     let y = x.as_ptr().cast::<u32>();\n+    ///     y.read(); // the address of a `u8` array is unknown and thus we don't know if\n+    ///     // it is aligned enough for reading a `u32`.\n+    /// };\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The compiler allowed dereferencing raw pointers irrespective of alignment\n+    /// during const eval due to the const evaluator at the time not making it easy\n+    /// or cheap to check. Now that it is both, this is not accepted anymore.\n+    ///\n+    /// Since it was undefined behaviour to begin with, this breakage does not violate\n+    /// Rust's stability guarantees. Using undefined behaviour can cause arbitrary\n+    /// behaviour, including failure to build.\n+    ///\n+    /// [future-incompatible]: ../index.md#future-incompatible-lints\n+    pub INVALID_ALIGNMENT,\n+    Deny,\n+    \"raw pointers must be aligned before dereferencing\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #68585 <https://github.com/rust-lang/rust/issues/104616>\",\n+        reason: FutureIncompatibilityReason::FutureReleaseErrorReportNow,\n+    };\n+}\n+\n declare_lint! {\n     /// The `exported_private_dependencies` lint detects private dependencies\n     /// that are exposed in a public interface."}, {"sha": "2865ea8927336143490193bddbeaec125dda6789", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -223,7 +223,11 @@ fromRust(LLVMRustCodeModel Model) {\n   case LLVMRustCodeModel::Large:\n     return CodeModel::Large;\n   case LLVMRustCodeModel::None:\n+#if LLVM_VERSION_LT(16, 0)\n     return None;\n+#else\n+    return std::nullopt;\n+#endif\n   default:\n     report_fatal_error(\"Bad CodeModel.\");\n   }"}, {"sha": "279b699185421982026fad27f12804d00a8e7d8d", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -322,7 +322,13 @@ extern \"C\" LLVMAttributeRef LLVMRustCreateUWTableAttr(LLVMContextRef C, bool Asy\n }\n \n extern \"C\" LLVMAttributeRef LLVMRustCreateAllocSizeAttr(LLVMContextRef C, uint32_t ElementSizeArg) {\n-  return wrap(Attribute::getWithAllocSizeArgs(*unwrap(C), ElementSizeArg, None));\n+  return wrap(Attribute::getWithAllocSizeArgs(*unwrap(C), ElementSizeArg,\n+#if LLVM_VERSION_LT(16, 0)\n+                                              None\n+#else\n+                                              std::nullopt\n+#endif\n+                                              ));\n }\n \n #if LLVM_VERSION_GE(15, 0)\n@@ -717,7 +723,11 @@ static std::optional<DIFile::ChecksumKind> fromRust(LLVMRustChecksumKind Kind) {\n #endif\n   switch (Kind) {\n   case LLVMRustChecksumKind::None:\n+#if LLVM_VERSION_LT(16, 0)\n     return None;\n+#else\n+    return std::nullopt;\n+#endif\n   case LLVMRustChecksumKind::MD5:\n     return DIFile::ChecksumKind::CSK_MD5;\n   case LLVMRustChecksumKind::SHA1:"}, {"sha": "13f06fe747349d8084b9b53d1a303c75f9b0278b", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -192,7 +192,7 @@ impl Mismatch {\n         let crate_name = std::env::var(\"CARGO_CRATE_NAME\").ok()?;\n \n         // If we're not in a \"rustc_\" crate, bail.\n-        let Some((\"rustc\", slug_prefix)) = crate_name.split_once(\"_\") else { return None };\n+        let Some((\"rustc\", slug_prefix)) = crate_name.split_once('_') else { return None };\n \n         let slug_name = slug.segments.first()?.ident.to_string();\n         if !slug_name.starts_with(slug_prefix) {"}, {"sha": "82f6812026a7d73a185a526b7390173f4602f996", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 11, "deletions": 36, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -372,46 +372,21 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                 }\n             }\n             (Meta::Path(_), \"subdiagnostic\") => {\n-                return Ok(quote! { #diag.subdiagnostic(#binding); });\n+                if FieldInnerTy::from_type(&info.binding.ast().ty).will_iterate() {\n+                    let DiagnosticDeriveKind::Diagnostic { handler } = &self.parent.kind else {\n+                        // No eager translation for lints.\n+                        return Ok(quote! { #diag.subdiagnostic(#binding); });\n+                    };\n+                    return Ok(quote! { #diag.eager_subdiagnostic(#handler, #binding); });\n+                } else {\n+                    return Ok(quote! { #diag.subdiagnostic(#binding); });\n+                }\n             }\n-            (Meta::NameValue(_), \"subdiagnostic\") => {\n+            (Meta::List(_), \"subdiagnostic\") => {\n                 throw_invalid_attr!(attr, &meta, |diag| {\n-                    diag.help(\"`eager` is the only supported nested attribute for `subdiagnostic`\")\n+                    diag.help(\"`subdiagnostic` does not support nested attributes\")\n                 })\n             }\n-            (Meta::List(MetaList { ref nested, .. }), \"subdiagnostic\") => {\n-                if nested.len() != 1 {\n-                    throw_invalid_attr!(attr, &meta, |diag| {\n-                        diag.help(\n-                            \"`eager` is the only supported nested attribute for `subdiagnostic`\",\n-                        )\n-                    })\n-                }\n-\n-                let handler = match &self.parent.kind {\n-                    DiagnosticDeriveKind::Diagnostic { handler } => handler,\n-                    DiagnosticDeriveKind::LintDiagnostic => {\n-                        throw_invalid_attr!(attr, &meta, |diag| {\n-                            diag.help(\"eager subdiagnostics are not supported on lints\")\n-                        })\n-                    }\n-                };\n-\n-                let nested_attr = nested.first().expect(\"pop failed for single element list\");\n-                match nested_attr {\n-                    NestedMeta::Meta(meta @ Meta::Path(_))\n-                        if meta.path().segments.last().unwrap().ident.to_string().as_str()\n-                            == \"eager\" =>\n-                    {\n-                        return Ok(quote! { #diag.eager_subdiagnostic(#handler, #binding); });\n-                    }\n-                    _ => {\n-                        throw_invalid_nested_attr!(attr, nested_attr, |diag| {\n-                            diag.help(\"`eager` is the only supported nested attribute for `subdiagnostic`\")\n-                        })\n-                    }\n-                }\n-            }\n             _ => (),\n         }\n "}, {"sha": "4370d4bd758d21f3112c664cd7a96f1456585243", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1527,13 +1527,15 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 if let Some(virtual_dir) = &sess.opts.unstable_opts.simulate_remapped_rust_src_base\n                 {\n                     if let Some(real_dir) = &sess.opts.real_rust_source_base_dir {\n-                        if let rustc_span::FileName::Real(ref mut old_name) = name {\n-                            if let rustc_span::RealFileName::LocalPath(local) = old_name {\n-                                if let Ok(rest) = local.strip_prefix(real_dir) {\n-                                    *old_name = rustc_span::RealFileName::Remapped {\n-                                        local_path: None,\n-                                        virtual_name: virtual_dir.join(rest),\n-                                    };\n+                        for subdir in [\"library\", \"compiler\"] {\n+                            if let rustc_span::FileName::Real(ref mut old_name) = name {\n+                                if let rustc_span::RealFileName::LocalPath(local) = old_name {\n+                                    if let Ok(rest) = local.strip_prefix(real_dir.join(subdir)) {\n+                                        *old_name = rustc_span::RealFileName::Remapped {\n+                                            local_path: None,\n+                                            virtual_name: virtual_dir.join(subdir).join(rest),\n+                                        };\n+                                    }\n                                 }\n                             }\n                         }"}, {"sha": "856f5bc4645fdd34d691e7ab3a824ef603da15d1", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1111,8 +1111,8 @@ fn should_encode_trait_impl_trait_tys<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) ->\n     // associated types.\n     tcx.fn_sig(trait_item_def_id).skip_binder().output().walk().any(|arg| {\n         if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-            && let ty::Projection(data) = ty.kind()\n-            && tcx.def_kind(data.item_def_id) == DefKind::ImplTraitPlaceholder\n+            && let ty::Alias(ty::Projection, data) = ty.kind()\n+            && tcx.def_kind(data.def_id) == DefKind::ImplTraitPlaceholder\n         {\n             true\n         } else {\n@@ -1337,24 +1337,16 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         debug!(\"EncodeContext::encode_info_for_trait_item({:?})\", def_id);\n         let tcx = self.tcx;\n \n-        let ast_item = tcx.hir().expect_trait_item(def_id.expect_local());\n-        self.tables.impl_defaultness.set(def_id.index, ast_item.defaultness);\n+        let impl_defaultness = tcx.impl_defaultness(def_id.expect_local());\n+        self.tables.impl_defaultness.set(def_id.index, impl_defaultness);\n         let trait_item = tcx.associated_item(def_id);\n         self.tables.assoc_container.set(def_id.index, trait_item.container);\n \n         match trait_item.kind {\n             ty::AssocKind::Const => {}\n             ty::AssocKind::Fn => {\n-                let hir::TraitItemKind::Fn(m_sig, m) = &ast_item.kind else { bug!() };\n-                match *m {\n-                    hir::TraitFn::Required(ref names) => {\n-                        record_array!(self.tables.fn_arg_names[def_id] <- *names)\n-                    }\n-                    hir::TraitFn::Provided(body) => {\n-                        record_array!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body))\n-                    }\n-                };\n-                self.tables.asyncness.set(def_id.index, m_sig.header.asyncness);\n+                record_array!(self.tables.fn_arg_names[def_id] <- tcx.fn_arg_names(def_id));\n+                self.tables.asyncness.set(def_id.index, tcx.asyncness(def_id));\n                 self.tables.constness.set(def_id.index, hir::Constness::NotConst);\n             }\n             ty::AssocKind::Type => {"}, {"sha": "716655c7f144d7de62e0d5c1bc64ee9a703c5b55", "filename": "compiler/rustc_metadata/src/rmeta/table.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -7,7 +7,6 @@ use rustc_middle::ty::ParameterizedOverTcx;\n use rustc_serialize::opaque::FileEncoder;\n use rustc_serialize::Encoder as _;\n use rustc_span::hygiene::MacroKind;\n-use std::convert::TryInto;\n use std::marker::PhantomData;\n use std::num::NonZeroUsize;\n "}, {"sha": "0b55757eb038298d32ee3598e9a07fe5732e0d15", "filename": "compiler/rustc_middle/src/mir/coverage.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -3,7 +3,6 @@\n use rustc_macros::HashStable;\n use rustc_span::Symbol;\n \n-use std::cmp::Ord;\n use std::fmt::{self, Debug, Formatter};\n \n rustc_index::newtype_index! {"}, {"sha": "8fe349d9640dafd776814d0feb5f9b8175a7e92f", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -95,7 +95,6 @@ mod pointer;\n mod queries;\n mod value;\n \n-use std::convert::TryFrom;\n use std::fmt;\n use std::io;\n use std::io::{Read, Write};"}, {"sha": "b0830991076206930b030985cdab10732d551744", "filename": "compiler/rustc_middle/src/mir/interpret/pointer.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -3,7 +3,6 @@ use super::{AllocId, InterpResult};\n use rustc_macros::HashStable;\n use rustc_target::abi::{HasDataLayout, Size};\n \n-use std::convert::{TryFrom, TryInto};\n use std::fmt;\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "88fb14eb359424e468ac55f953092fbc18cae2ee", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,4 +1,3 @@\n-use std::convert::{TryFrom, TryInto};\n use std::fmt;\n \n use either::{Either, Left, Right};"}, {"sha": "bdaa586c69879ca53ddea0eb5d308436341f00d5", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -36,7 +36,6 @@ use rustc_span::{Span, DUMMY_SP};\n use either::Either;\n \n use std::borrow::Cow;\n-use std::convert::TryInto;\n use std::fmt::{self, Debug, Display, Formatter, Write};\n use std::ops::{ControlFlow, Index, IndexMut};\n use std::{iter, mem};\n@@ -534,6 +533,11 @@ impl<'tcx> Body<'tcx> {\n         };\n         injection_phase > self.phase\n     }\n+\n+    #[inline]\n+    pub fn is_custom_mir(&self) -> bool {\n+        self.injection_phase.is_some()\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug, TyEncodable, TyDecodable, HashStable)]\n@@ -1848,7 +1852,7 @@ impl<'tcx> Operand<'tcx> {\n     pub fn function_handle(\n         tcx: TyCtxt<'tcx>,\n         def_id: DefId,\n-        substs: SubstsRef<'tcx>,\n+        substs: impl IntoIterator<Item = GenericArg<'tcx>>,\n         span: Span,\n     ) -> Self {\n         let ty = tcx.mk_fn_def(def_id, substs);"}, {"sha": "1e8d5f7eae87a8881edadb729794f43e43fc9a9e", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -200,6 +200,15 @@ impl<'tcx> MonoItem<'tcx> {\n             MonoItem::GlobalAsm(..) => LOCAL_CRATE,\n         }\n     }\n+\n+    /// Returns the item's `DefId`\n+    pub fn def_id(&self) -> DefId {\n+        match *self {\n+            MonoItem::Fn(Instance { def, .. }) => def.def_id(),\n+            MonoItem::Static(def_id) => def_id,\n+            MonoItem::GlobalAsm(item_id) => item_id.owner_id.to_def_id(),\n+        }\n+    }\n }\n \n impl<'tcx> fmt::Display for MonoItem<'tcx> {"}, {"sha": "d00b26a5a3d0b42baafca1d795332bbfc0ddbdcc", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -250,7 +250,7 @@ pub enum ObligationCauseCode<'tcx> {\n     TupleElem,\n \n     /// This is the trait reference from the given projection.\n-    ProjectionWf(ty::ProjectionTy<'tcx>),\n+    ProjectionWf(ty::AliasTy<'tcx>),\n \n     /// Must satisfy all of the where-clause predicates of the\n     /// given item."}, {"sha": "7380c62a6693a85166a3ed26ef4184b572c6ac39", "filename": "compiler/rustc_middle/src/traits/query.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -12,7 +12,6 @@ use crate::ty::subst::{GenericArg, SubstsRef};\n use crate::ty::{self, Ty, TyCtxt};\n use rustc_hir::def_id::DefId;\n use rustc_span::source_map::Span;\n-use std::iter::FromIterator;\n \n pub mod type_op {\n     use crate::ty::fold::TypeFoldable;\n@@ -77,8 +76,7 @@ pub mod type_op {\n     }\n }\n \n-pub type CanonicalProjectionGoal<'tcx> =\n-    Canonical<'tcx, ty::ParamEnvAnd<'tcx, ty::ProjectionTy<'tcx>>>;\n+pub type CanonicalProjectionGoal<'tcx> = Canonical<'tcx, ty::ParamEnvAnd<'tcx, ty::AliasTy<'tcx>>>;\n \n pub type CanonicalTyGoal<'tcx> = Canonical<'tcx, ty::ParamEnvAnd<'tcx, Ty<'tcx>>>;\n \n@@ -219,6 +217,6 @@ pub struct NormalizationResult<'tcx> {\n pub enum OutlivesBound<'tcx> {\n     RegionSubRegion(ty::Region<'tcx>, ty::Region<'tcx>),\n     RegionSubParam(ty::Region<'tcx>, ty::ParamTy),\n-    RegionSubProjection(ty::Region<'tcx>, ty::ProjectionTy<'tcx>),\n+    RegionSubProjection(ty::Region<'tcx>, ty::AliasTy<'tcx>),\n     RegionSubOpaque(ty::Region<'tcx>, DefId, SubstsRef<'tcx>),\n }"}, {"sha": "8ce06404de0811d64a177271ba6d4679278e007f", "filename": "compiler/rustc_middle/src/ty/adjustment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -131,7 +131,7 @@ impl<'tcx> OverloadedDeref<'tcx> {\n             .find(|m| m.kind == ty::AssocKind::Fn)\n             .unwrap()\n             .def_id;\n-        tcx.mk_fn_def(method_def_id, tcx.mk_substs_trait(source, []))\n+        tcx.mk_fn_def(method_def_id, [source])\n     }\n }\n "}, {"sha": "2a8a4d598882d0c0cd1b83abed69dd574fdc866d", "filename": "compiler/rustc_middle/src/ty/consts/int.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -2,7 +2,6 @@ use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use rustc_target::abi::Size;\n-use std::convert::{TryFrom, TryInto};\n use std::fmt;\n use std::num::NonZeroU8;\n "}, {"sha": "d9721863a58c801fa49c21594cfc26309a2dc47d", "filename": "compiler/rustc_middle/src/ty/consts/kind.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,5 +1,3 @@\n-use std::convert::TryInto;\n-\n use super::Const;\n use crate::mir;\n use crate::mir::interpret::{AllocId, ConstValue, Scalar};"}, {"sha": "173c5ed4feef0f9de96add81d3ddf7094fdacc5d", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 57, "deletions": 708, "changes": 765, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -4,8 +4,7 @@\n \n use crate::arena::Arena;\n use crate::dep_graph::{DepGraph, DepKindStruct};\n-use crate::hir::place::Place as HirPlace;\n-use crate::infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n+use crate::infer::canonical::{CanonicalVarInfo, CanonicalVarInfos};\n use crate::lint::struct_lint_level;\n use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n use crate::middle::resolve_lifetime;\n@@ -18,14 +17,13 @@ use crate::thir::Thir;\n use crate::traits;\n use crate::ty::query::{self, TyCtxtAt};\n use crate::ty::{\n-    self, AdtDef, AdtDefData, AdtKind, Binder, BindingMode, BoundVar, CanonicalPolyFnSig,\n-    ClosureSizeProfileData, Const, ConstS, DefIdTree, FloatTy, FloatVar, FloatVid,\n-    GenericParamDefKind, InferTy, IntTy, IntVar, IntVid, List, ParamConst, ParamTy,\n-    PolyExistentialPredicate, PolyFnSig, Predicate, PredicateKind, ProjectionTy, Region,\n-    RegionKind, ReprOptions, TraitObjectVisitor, Ty, TyKind, TyVar, TyVid, TypeAndMut, UintTy,\n+    self, AdtDef, AdtDefData, AdtKind, Binder, Const, ConstS, DefIdTree, FloatTy, FloatVar,\n+    FloatVid, GenericParamDefKind, ImplPolarity, InferTy, IntTy, IntVar, IntVid, List, ParamConst,\n+    ParamTy, PolyExistentialPredicate, PolyFnSig, Predicate, PredicateKind, Region, RegionKind,\n+    ReprOptions, TraitObjectVisitor, Ty, TyKind, TyVar, TyVid, TypeAndMut, TypeckResults, UintTy,\n     Visibility,\n };\n-use crate::ty::{GenericArg, GenericArgKind, InternalSubsts, SubstsRef, UserSubsts};\n+use crate::ty::{GenericArg, InternalSubsts, SubstsRef};\n use rustc_ast as ast;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -36,25 +34,20 @@ use rustc_data_structures::sharded::{IntoPointer, ShardedHashMap};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::sync::{self, Lock, Lrc, ReadGuard, WorkerLocal};\n-use rustc_data_structures::unord::UnordSet;\n-use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::{\n     DecorateLint, DiagnosticBuilder, DiagnosticMessage, ErrorGuaranteed, MultiSpan,\n };\n use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LocalDefIdMap, LOCAL_CRATE};\n+use rustc_hir::def::DefKind;\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::definitions::Definitions;\n-use rustc_hir::hir_id::OwnerId;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{\n-    Constness, ExprKind, HirId, ImplItemKind, ItemKind, ItemLocalId, ItemLocalMap, ItemLocalSet,\n-    Node, TraitCandidate, TraitItemKind,\n+    Constness, ExprKind, HirId, ImplItemKind, ItemKind, Node, TraitCandidate, TraitItemKind,\n };\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable;\n-use rustc_middle::mir::FakeReadCause;\n use rustc_query_system::dep_graph::DepNodeIndex;\n use rustc_query_system::ich::StableHashingContext;\n use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n@@ -76,16 +69,13 @@ use rustc_type_ir::{DynKind, InternAs, InternIteratorElement, Interner, TypeFlag\n use std::any::Any;\n use std::borrow::Borrow;\n use std::cmp::Ordering;\n-use std::collections::hash_map::{self, Entry};\n use std::fmt;\n use std::hash::{Hash, Hasher};\n use std::iter;\n use std::mem;\n use std::ops::{Bound, Deref};\n use std::sync::Arc;\n \n-use super::{ImplPolarity, RvalueScopes};\n-\n pub trait OnDiskCache<'tcx>: rustc_data_structures::sync::Sync {\n     /// Creates a new `OnDiskCache` instance from the serialized data in `data`.\n     fn new(sess: &'tcx Session, data: Mmap, start_pos: usize) -> Self\n@@ -116,7 +106,7 @@ impl<'tcx> Interner for TyCtxt<'tcx> {\n     type ListBinderExistentialPredicate = &'tcx List<PolyExistentialPredicate<'tcx>>;\n     type BinderListTy = Binder<'tcx, &'tcx List<Ty<'tcx>>>;\n     type ListTy = &'tcx List<Ty<'tcx>>;\n-    type ProjectionTy = ty::ProjectionTy<'tcx>;\n+    type AliasTy = ty::AliasTy<'tcx>;\n     type ParamTy = ParamTy;\n     type BoundTy = ty::BoundTy;\n     type PlaceholderType = ty::PlaceholderType;\n@@ -285,666 +275,6 @@ pub struct CommonConsts<'tcx> {\n     pub unit: Const<'tcx>,\n }\n \n-pub struct LocalTableInContext<'a, V> {\n-    hir_owner: OwnerId,\n-    data: &'a ItemLocalMap<V>,\n-}\n-\n-/// Validate that the given HirId (respectively its `local_id` part) can be\n-/// safely used as a key in the maps of a TypeckResults. For that to be\n-/// the case, the HirId must have the same `owner` as all the other IDs in\n-/// this table (signified by `hir_owner`). Otherwise the HirId\n-/// would be in a different frame of reference and using its `local_id`\n-/// would result in lookup errors, or worse, in silently wrong data being\n-/// stored/returned.\n-#[inline]\n-fn validate_hir_id_for_typeck_results(hir_owner: OwnerId, hir_id: hir::HirId) {\n-    if hir_id.owner != hir_owner {\n-        invalid_hir_id_for_typeck_results(hir_owner, hir_id);\n-    }\n-}\n-\n-#[cold]\n-#[inline(never)]\n-fn invalid_hir_id_for_typeck_results(hir_owner: OwnerId, hir_id: hir::HirId) {\n-    ty::tls::with(|tcx| {\n-        bug!(\n-            \"node {} with HirId::owner {:?} cannot be placed in TypeckResults with hir_owner {:?}\",\n-            tcx.hir().node_to_string(hir_id),\n-            hir_id.owner,\n-            hir_owner\n-        )\n-    });\n-}\n-\n-impl<'a, V> LocalTableInContext<'a, V> {\n-    pub fn contains_key(&self, id: hir::HirId) -> bool {\n-        validate_hir_id_for_typeck_results(self.hir_owner, id);\n-        self.data.contains_key(&id.local_id)\n-    }\n-\n-    pub fn get(&self, id: hir::HirId) -> Option<&V> {\n-        validate_hir_id_for_typeck_results(self.hir_owner, id);\n-        self.data.get(&id.local_id)\n-    }\n-\n-    pub fn iter(&self) -> hash_map::Iter<'_, hir::ItemLocalId, V> {\n-        self.data.iter()\n-    }\n-}\n-\n-impl<'a, V> ::std::ops::Index<hir::HirId> for LocalTableInContext<'a, V> {\n-    type Output = V;\n-\n-    fn index(&self, key: hir::HirId) -> &V {\n-        self.get(key).expect(\"LocalTableInContext: key not found\")\n-    }\n-}\n-\n-pub struct LocalTableInContextMut<'a, V> {\n-    hir_owner: OwnerId,\n-    data: &'a mut ItemLocalMap<V>,\n-}\n-\n-impl<'a, V> LocalTableInContextMut<'a, V> {\n-    pub fn get_mut(&mut self, id: hir::HirId) -> Option<&mut V> {\n-        validate_hir_id_for_typeck_results(self.hir_owner, id);\n-        self.data.get_mut(&id.local_id)\n-    }\n-\n-    pub fn entry(&mut self, id: hir::HirId) -> Entry<'_, hir::ItemLocalId, V> {\n-        validate_hir_id_for_typeck_results(self.hir_owner, id);\n-        self.data.entry(id.local_id)\n-    }\n-\n-    pub fn insert(&mut self, id: hir::HirId, val: V) -> Option<V> {\n-        validate_hir_id_for_typeck_results(self.hir_owner, id);\n-        self.data.insert(id.local_id, val)\n-    }\n-\n-    pub fn remove(&mut self, id: hir::HirId) -> Option<V> {\n-        validate_hir_id_for_typeck_results(self.hir_owner, id);\n-        self.data.remove(&id.local_id)\n-    }\n-}\n-\n-/// Whenever a value may be live across a generator yield, the type of that value winds up in the\n-/// `GeneratorInteriorTypeCause` struct. This struct adds additional information about such\n-/// captured types that can be useful for diagnostics. In particular, it stores the span that\n-/// caused a given type to be recorded, along with the scope that enclosed the value (which can\n-/// be used to find the await that the value is live across).\n-///\n-/// For example:\n-///\n-/// ```ignore (pseudo-Rust)\n-/// async move {\n-///     let x: T = expr;\n-///     foo.await\n-///     ...\n-/// }\n-/// ```\n-///\n-/// Here, we would store the type `T`, the span of the value `x`, the \"scope-span\" for\n-/// the scope that contains `x`, the expr `T` evaluated from, and the span of `foo.await`.\n-#[derive(TyEncodable, TyDecodable, Clone, Debug, Eq, Hash, PartialEq, HashStable)]\n-#[derive(TypeFoldable, TypeVisitable)]\n-pub struct GeneratorInteriorTypeCause<'tcx> {\n-    /// Type of the captured binding.\n-    pub ty: Ty<'tcx>,\n-    /// Span of the binding that was captured.\n-    pub span: Span,\n-    /// Span of the scope of the captured binding.\n-    pub scope_span: Option<Span>,\n-    /// Span of `.await` or `yield` expression.\n-    pub yield_span: Span,\n-    /// Expr which the type evaluated from.\n-    pub expr: Option<hir::HirId>,\n-}\n-\n-// This type holds diagnostic information on generators and async functions across crate boundaries\n-// and is used to provide better error messages\n-#[derive(TyEncodable, TyDecodable, Clone, Debug, HashStable)]\n-pub struct GeneratorDiagnosticData<'tcx> {\n-    pub generator_interior_types: ty::Binder<'tcx, Vec<GeneratorInteriorTypeCause<'tcx>>>,\n-    pub hir_owner: DefId,\n-    pub nodes_types: ItemLocalMap<Ty<'tcx>>,\n-    pub adjustments: ItemLocalMap<Vec<ty::adjustment::Adjustment<'tcx>>>,\n-}\n-\n-#[derive(TyEncodable, TyDecodable, Debug, HashStable)]\n-pub struct TypeckResults<'tcx> {\n-    /// The `HirId::owner` all `ItemLocalId`s in this table are relative to.\n-    pub hir_owner: OwnerId,\n-\n-    /// Resolved definitions for `<T>::X` associated paths and\n-    /// method calls, including those of overloaded operators.\n-    type_dependent_defs: ItemLocalMap<Result<(DefKind, DefId), ErrorGuaranteed>>,\n-\n-    /// Resolved field indices for field accesses in expressions (`S { field }`, `obj.field`)\n-    /// or patterns (`S { field }`). The index is often useful by itself, but to learn more\n-    /// about the field you also need definition of the variant to which the field\n-    /// belongs, but it may not exist if it's a tuple field (`tuple.0`).\n-    field_indices: ItemLocalMap<usize>,\n-\n-    /// Stores the types for various nodes in the AST. Note that this table\n-    /// is not guaranteed to be populated outside inference. See\n-    /// typeck::check::fn_ctxt for details.\n-    node_types: ItemLocalMap<Ty<'tcx>>,\n-\n-    /// Stores the type parameters which were substituted to obtain the type\n-    /// of this node. This only applies to nodes that refer to entities\n-    /// parameterized by type parameters, such as generic fns, types, or\n-    /// other items.\n-    node_substs: ItemLocalMap<SubstsRef<'tcx>>,\n-\n-    /// This will either store the canonicalized types provided by the user\n-    /// or the substitutions that the user explicitly gave (if any) attached\n-    /// to `id`. These will not include any inferred values. The canonical form\n-    /// is used to capture things like `_` or other unspecified values.\n-    ///\n-    /// For example, if the user wrote `foo.collect::<Vec<_>>()`, then the\n-    /// canonical substitutions would include only `for<X> { Vec<X> }`.\n-    ///\n-    /// See also `AscribeUserType` statement in MIR.\n-    user_provided_types: ItemLocalMap<CanonicalUserType<'tcx>>,\n-\n-    /// Stores the canonicalized types provided by the user. See also\n-    /// `AscribeUserType` statement in MIR.\n-    pub user_provided_sigs: LocalDefIdMap<CanonicalPolyFnSig<'tcx>>,\n-\n-    adjustments: ItemLocalMap<Vec<ty::adjustment::Adjustment<'tcx>>>,\n-\n-    /// Stores the actual binding mode for all instances of hir::BindingAnnotation.\n-    pat_binding_modes: ItemLocalMap<BindingMode>,\n-\n-    /// Stores the types which were implicitly dereferenced in pattern binding modes\n-    /// for later usage in THIR lowering. For example,\n-    ///\n-    /// ```\n-    /// match &&Some(5i32) {\n-    ///     Some(n) => {},\n-    ///     _ => {},\n-    /// }\n-    /// ```\n-    /// leads to a `vec![&&Option<i32>, &Option<i32>]`. Empty vectors are not stored.\n-    ///\n-    /// See:\n-    /// <https://github.com/rust-lang/rfcs/blob/master/text/2005-match-ergonomics.md#definitions>\n-    pat_adjustments: ItemLocalMap<Vec<Ty<'tcx>>>,\n-\n-    /// Records the reasons that we picked the kind of each closure;\n-    /// not all closures are present in the map.\n-    closure_kind_origins: ItemLocalMap<(Span, HirPlace<'tcx>)>,\n-\n-    /// For each fn, records the \"liberated\" types of its arguments\n-    /// and return type. Liberated means that all bound regions\n-    /// (including late-bound regions) are replaced with free\n-    /// equivalents. This table is not used in codegen (since regions\n-    /// are erased there) and hence is not serialized to metadata.\n-    ///\n-    /// This table also contains the \"revealed\" values for any `impl Trait`\n-    /// that appear in the signature and whose values are being inferred\n-    /// by this function.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// # use std::fmt::Debug;\n-    /// fn foo(x: &u32) -> impl Debug { *x }\n-    /// ```\n-    ///\n-    /// The function signature here would be:\n-    ///\n-    /// ```ignore (illustrative)\n-    /// for<'a> fn(&'a u32) -> Foo\n-    /// ```\n-    ///\n-    /// where `Foo` is an opaque type created for this function.\n-    ///\n-    ///\n-    /// The *liberated* form of this would be\n-    ///\n-    /// ```ignore (illustrative)\n-    /// fn(&'a u32) -> u32\n-    /// ```\n-    ///\n-    /// Note that `'a` is not bound (it would be an `ReFree`) and\n-    /// that the `Foo` opaque type is replaced by its hidden type.\n-    liberated_fn_sigs: ItemLocalMap<ty::FnSig<'tcx>>,\n-\n-    /// For each FRU expression, record the normalized types of the fields\n-    /// of the struct - this is needed because it is non-trivial to\n-    /// normalize while preserving regions. This table is used only in\n-    /// MIR construction and hence is not serialized to metadata.\n-    fru_field_types: ItemLocalMap<Vec<Ty<'tcx>>>,\n-\n-    /// For every coercion cast we add the HIR node ID of the cast\n-    /// expression to this set.\n-    coercion_casts: ItemLocalSet,\n-\n-    /// Set of trait imports actually used in the method resolution.\n-    /// This is used for warning unused imports. During type\n-    /// checking, this `Lrc` should not be cloned: it must have a ref-count\n-    /// of 1 so that we can insert things into the set mutably.\n-    pub used_trait_imports: Lrc<UnordSet<LocalDefId>>,\n-\n-    /// If any errors occurred while type-checking this body,\n-    /// this field will be set to `Some(ErrorGuaranteed)`.\n-    pub tainted_by_errors: Option<ErrorGuaranteed>,\n-\n-    /// All the opaque types that have hidden types set\n-    /// by this function. We also store the\n-    /// type here, so that mir-borrowck can use it as a hint for figuring out hidden types,\n-    /// even if they are only set in dead code (which doesn't show up in MIR).\n-    pub concrete_opaque_types: VecMap<LocalDefId, ty::OpaqueHiddenType<'tcx>>,\n-\n-    /// Tracks the minimum captures required for a closure;\n-    /// see `MinCaptureInformationMap` for more details.\n-    pub closure_min_captures: ty::MinCaptureInformationMap<'tcx>,\n-\n-    /// Tracks the fake reads required for a closure and the reason for the fake read.\n-    /// When performing pattern matching for closures, there are times we don't end up\n-    /// reading places that are mentioned in a closure (because of _ patterns). However,\n-    /// to ensure the places are initialized, we introduce fake reads.\n-    /// Consider these two examples:\n-    /// ``` (discriminant matching with only wildcard arm)\n-    /// let x: u8;\n-    /// let c = || match x { _ => () };\n-    /// ```\n-    /// In this example, we don't need to actually read/borrow `x` in `c`, and so we don't\n-    /// want to capture it. However, we do still want an error here, because `x` should have\n-    /// to be initialized at the point where c is created. Therefore, we add a \"fake read\"\n-    /// instead.\n-    /// ``` (destructured assignments)\n-    /// let c = || {\n-    ///     let (t1, t2) = t;\n-    /// }\n-    /// ```\n-    /// In the second example, we capture the disjoint fields of `t` (`t.0` & `t.1`), but\n-    /// we never capture `t`. This becomes an issue when we build MIR as we require\n-    /// information on `t` in order to create place `t.0` and `t.1`. We can solve this\n-    /// issue by fake reading `t`.\n-    pub closure_fake_reads: FxHashMap<LocalDefId, Vec<(HirPlace<'tcx>, FakeReadCause, hir::HirId)>>,\n-\n-    /// Tracks the rvalue scoping rules which defines finer scoping for rvalue expressions\n-    /// by applying extended parameter rules.\n-    /// Details may be find in `rustc_hir_analysis::check::rvalue_scopes`.\n-    pub rvalue_scopes: RvalueScopes,\n-\n-    /// Stores the type, expression, span and optional scope span of all types\n-    /// that are live across the yield of this generator (if a generator).\n-    pub generator_interior_types: ty::Binder<'tcx, Vec<GeneratorInteriorTypeCause<'tcx>>>,\n-\n-    /// We sometimes treat byte string literals (which are of type `&[u8; N]`)\n-    /// as `&[u8]`, depending on the pattern  in which they are used.\n-    /// This hashset records all instances where we behave\n-    /// like this to allow `const_to_pat` to reliably handle this situation.\n-    pub treat_byte_string_as_slice: ItemLocalSet,\n-\n-    /// Contains the data for evaluating the effect of feature `capture_disjoint_fields`\n-    /// on closure size.\n-    pub closure_size_eval: FxHashMap<LocalDefId, ClosureSizeProfileData<'tcx>>,\n-}\n-\n-impl<'tcx> TypeckResults<'tcx> {\n-    pub fn new(hir_owner: OwnerId) -> TypeckResults<'tcx> {\n-        TypeckResults {\n-            hir_owner,\n-            type_dependent_defs: Default::default(),\n-            field_indices: Default::default(),\n-            user_provided_types: Default::default(),\n-            user_provided_sigs: Default::default(),\n-            node_types: Default::default(),\n-            node_substs: Default::default(),\n-            adjustments: Default::default(),\n-            pat_binding_modes: Default::default(),\n-            pat_adjustments: Default::default(),\n-            closure_kind_origins: Default::default(),\n-            liberated_fn_sigs: Default::default(),\n-            fru_field_types: Default::default(),\n-            coercion_casts: Default::default(),\n-            used_trait_imports: Lrc::new(Default::default()),\n-            tainted_by_errors: None,\n-            concrete_opaque_types: Default::default(),\n-            closure_min_captures: Default::default(),\n-            closure_fake_reads: Default::default(),\n-            rvalue_scopes: Default::default(),\n-            generator_interior_types: ty::Binder::dummy(Default::default()),\n-            treat_byte_string_as_slice: Default::default(),\n-            closure_size_eval: Default::default(),\n-        }\n-    }\n-\n-    /// Returns the final resolution of a `QPath` in an `Expr` or `Pat` node.\n-    pub fn qpath_res(&self, qpath: &hir::QPath<'_>, id: hir::HirId) -> Res {\n-        match *qpath {\n-            hir::QPath::Resolved(_, ref path) => path.res,\n-            hir::QPath::TypeRelative(..) | hir::QPath::LangItem(..) => self\n-                .type_dependent_def(id)\n-                .map_or(Res::Err, |(kind, def_id)| Res::Def(kind, def_id)),\n-        }\n-    }\n-\n-    pub fn type_dependent_defs(\n-        &self,\n-    ) -> LocalTableInContext<'_, Result<(DefKind, DefId), ErrorGuaranteed>> {\n-        LocalTableInContext { hir_owner: self.hir_owner, data: &self.type_dependent_defs }\n-    }\n-\n-    pub fn type_dependent_def(&self, id: HirId) -> Option<(DefKind, DefId)> {\n-        validate_hir_id_for_typeck_results(self.hir_owner, id);\n-        self.type_dependent_defs.get(&id.local_id).cloned().and_then(|r| r.ok())\n-    }\n-\n-    pub fn type_dependent_def_id(&self, id: HirId) -> Option<DefId> {\n-        self.type_dependent_def(id).map(|(_, def_id)| def_id)\n-    }\n-\n-    pub fn type_dependent_defs_mut(\n-        &mut self,\n-    ) -> LocalTableInContextMut<'_, Result<(DefKind, DefId), ErrorGuaranteed>> {\n-        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.type_dependent_defs }\n-    }\n-\n-    pub fn field_indices(&self) -> LocalTableInContext<'_, usize> {\n-        LocalTableInContext { hir_owner: self.hir_owner, data: &self.field_indices }\n-    }\n-\n-    pub fn field_indices_mut(&mut self) -> LocalTableInContextMut<'_, usize> {\n-        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.field_indices }\n-    }\n-\n-    pub fn field_index(&self, id: hir::HirId) -> usize {\n-        self.field_indices().get(id).cloned().expect(\"no index for a field\")\n-    }\n-\n-    pub fn opt_field_index(&self, id: hir::HirId) -> Option<usize> {\n-        self.field_indices().get(id).cloned()\n-    }\n-\n-    pub fn user_provided_types(&self) -> LocalTableInContext<'_, CanonicalUserType<'tcx>> {\n-        LocalTableInContext { hir_owner: self.hir_owner, data: &self.user_provided_types }\n-    }\n-\n-    pub fn user_provided_types_mut(\n-        &mut self,\n-    ) -> LocalTableInContextMut<'_, CanonicalUserType<'tcx>> {\n-        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.user_provided_types }\n-    }\n-\n-    pub fn node_types(&self) -> LocalTableInContext<'_, Ty<'tcx>> {\n-        LocalTableInContext { hir_owner: self.hir_owner, data: &self.node_types }\n-    }\n-\n-    pub fn node_types_mut(&mut self) -> LocalTableInContextMut<'_, Ty<'tcx>> {\n-        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.node_types }\n-    }\n-\n-    pub fn get_generator_diagnostic_data(&self) -> GeneratorDiagnosticData<'tcx> {\n-        let generator_interior_type = self.generator_interior_types.map_bound_ref(|vec| {\n-            vec.iter()\n-                .map(|item| {\n-                    GeneratorInteriorTypeCause {\n-                        ty: item.ty,\n-                        span: item.span,\n-                        scope_span: item.scope_span,\n-                        yield_span: item.yield_span,\n-                        expr: None, //FIXME: Passing expression over crate boundaries is impossible at the moment\n-                    }\n-                })\n-                .collect::<Vec<_>>()\n-        });\n-        GeneratorDiagnosticData {\n-            generator_interior_types: generator_interior_type,\n-            hir_owner: self.hir_owner.to_def_id(),\n-            nodes_types: self.node_types.clone(),\n-            adjustments: self.adjustments.clone(),\n-        }\n-    }\n-\n-    pub fn node_type(&self, id: hir::HirId) -> Ty<'tcx> {\n-        self.node_type_opt(id).unwrap_or_else(|| {\n-            bug!(\"node_type: no type for node `{}`\", tls::with(|tcx| tcx.hir().node_to_string(id)))\n-        })\n-    }\n-\n-    pub fn node_type_opt(&self, id: hir::HirId) -> Option<Ty<'tcx>> {\n-        validate_hir_id_for_typeck_results(self.hir_owner, id);\n-        self.node_types.get(&id.local_id).cloned()\n-    }\n-\n-    pub fn node_substs_mut(&mut self) -> LocalTableInContextMut<'_, SubstsRef<'tcx>> {\n-        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.node_substs }\n-    }\n-\n-    pub fn node_substs(&self, id: hir::HirId) -> SubstsRef<'tcx> {\n-        validate_hir_id_for_typeck_results(self.hir_owner, id);\n-        self.node_substs.get(&id.local_id).cloned().unwrap_or_else(|| InternalSubsts::empty())\n-    }\n-\n-    pub fn node_substs_opt(&self, id: hir::HirId) -> Option<SubstsRef<'tcx>> {\n-        validate_hir_id_for_typeck_results(self.hir_owner, id);\n-        self.node_substs.get(&id.local_id).cloned()\n-    }\n-\n-    /// Returns the type of a pattern as a monotype. Like [`expr_ty`], this function\n-    /// doesn't provide type parameter substitutions.\n-    ///\n-    /// [`expr_ty`]: TypeckResults::expr_ty\n-    pub fn pat_ty(&self, pat: &hir::Pat<'_>) -> Ty<'tcx> {\n-        self.node_type(pat.hir_id)\n-    }\n-\n-    /// Returns the type of an expression as a monotype.\n-    ///\n-    /// NB (1): This is the PRE-ADJUSTMENT TYPE for the expression.  That is, in\n-    /// some cases, we insert `Adjustment` annotations such as auto-deref or\n-    /// auto-ref.  The type returned by this function does not consider such\n-    /// adjustments.  See `expr_ty_adjusted()` instead.\n-    ///\n-    /// NB (2): This type doesn't provide type parameter substitutions; e.g., if you\n-    /// ask for the type of `id` in `id(3)`, it will return `fn(&isize) -> isize`\n-    /// instead of `fn(ty) -> T with T = isize`.\n-    pub fn expr_ty(&self, expr: &hir::Expr<'_>) -> Ty<'tcx> {\n-        self.node_type(expr.hir_id)\n-    }\n-\n-    pub fn expr_ty_opt(&self, expr: &hir::Expr<'_>) -> Option<Ty<'tcx>> {\n-        self.node_type_opt(expr.hir_id)\n-    }\n-\n-    pub fn adjustments(&self) -> LocalTableInContext<'_, Vec<ty::adjustment::Adjustment<'tcx>>> {\n-        LocalTableInContext { hir_owner: self.hir_owner, data: &self.adjustments }\n-    }\n-\n-    pub fn adjustments_mut(\n-        &mut self,\n-    ) -> LocalTableInContextMut<'_, Vec<ty::adjustment::Adjustment<'tcx>>> {\n-        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.adjustments }\n-    }\n-\n-    pub fn expr_adjustments(&self, expr: &hir::Expr<'_>) -> &[ty::adjustment::Adjustment<'tcx>] {\n-        validate_hir_id_for_typeck_results(self.hir_owner, expr.hir_id);\n-        self.adjustments.get(&expr.hir_id.local_id).map_or(&[], |a| &a[..])\n-    }\n-\n-    /// Returns the type of `expr`, considering any `Adjustment`\n-    /// entry recorded for that expression.\n-    pub fn expr_ty_adjusted(&self, expr: &hir::Expr<'_>) -> Ty<'tcx> {\n-        self.expr_adjustments(expr).last().map_or_else(|| self.expr_ty(expr), |adj| adj.target)\n-    }\n-\n-    pub fn expr_ty_adjusted_opt(&self, expr: &hir::Expr<'_>) -> Option<Ty<'tcx>> {\n-        self.expr_adjustments(expr).last().map(|adj| adj.target).or_else(|| self.expr_ty_opt(expr))\n-    }\n-\n-    pub fn is_method_call(&self, expr: &hir::Expr<'_>) -> bool {\n-        // Only paths and method calls/overloaded operators have\n-        // entries in type_dependent_defs, ignore the former here.\n-        if let hir::ExprKind::Path(_) = expr.kind {\n-            return false;\n-        }\n-\n-        matches!(self.type_dependent_defs().get(expr.hir_id), Some(Ok((DefKind::AssocFn, _))))\n-    }\n-\n-    pub fn extract_binding_mode(&self, s: &Session, id: HirId, sp: Span) -> Option<BindingMode> {\n-        self.pat_binding_modes().get(id).copied().or_else(|| {\n-            s.delay_span_bug(sp, \"missing binding mode\");\n-            None\n-        })\n-    }\n-\n-    pub fn pat_binding_modes(&self) -> LocalTableInContext<'_, BindingMode> {\n-        LocalTableInContext { hir_owner: self.hir_owner, data: &self.pat_binding_modes }\n-    }\n-\n-    pub fn pat_binding_modes_mut(&mut self) -> LocalTableInContextMut<'_, BindingMode> {\n-        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.pat_binding_modes }\n-    }\n-\n-    pub fn pat_adjustments(&self) -> LocalTableInContext<'_, Vec<Ty<'tcx>>> {\n-        LocalTableInContext { hir_owner: self.hir_owner, data: &self.pat_adjustments }\n-    }\n-\n-    pub fn pat_adjustments_mut(&mut self) -> LocalTableInContextMut<'_, Vec<Ty<'tcx>>> {\n-        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.pat_adjustments }\n-    }\n-\n-    /// For a given closure, returns the iterator of `ty::CapturedPlace`s that are captured\n-    /// by the closure.\n-    pub fn closure_min_captures_flattened(\n-        &self,\n-        closure_def_id: LocalDefId,\n-    ) -> impl Iterator<Item = &ty::CapturedPlace<'tcx>> {\n-        self.closure_min_captures\n-            .get(&closure_def_id)\n-            .map(|closure_min_captures| closure_min_captures.values().flat_map(|v| v.iter()))\n-            .into_iter()\n-            .flatten()\n-    }\n-\n-    pub fn closure_kind_origins(&self) -> LocalTableInContext<'_, (Span, HirPlace<'tcx>)> {\n-        LocalTableInContext { hir_owner: self.hir_owner, data: &self.closure_kind_origins }\n-    }\n-\n-    pub fn closure_kind_origins_mut(\n-        &mut self,\n-    ) -> LocalTableInContextMut<'_, (Span, HirPlace<'tcx>)> {\n-        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.closure_kind_origins }\n-    }\n-\n-    pub fn liberated_fn_sigs(&self) -> LocalTableInContext<'_, ty::FnSig<'tcx>> {\n-        LocalTableInContext { hir_owner: self.hir_owner, data: &self.liberated_fn_sigs }\n-    }\n-\n-    pub fn liberated_fn_sigs_mut(&mut self) -> LocalTableInContextMut<'_, ty::FnSig<'tcx>> {\n-        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.liberated_fn_sigs }\n-    }\n-\n-    pub fn fru_field_types(&self) -> LocalTableInContext<'_, Vec<Ty<'tcx>>> {\n-        LocalTableInContext { hir_owner: self.hir_owner, data: &self.fru_field_types }\n-    }\n-\n-    pub fn fru_field_types_mut(&mut self) -> LocalTableInContextMut<'_, Vec<Ty<'tcx>>> {\n-        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.fru_field_types }\n-    }\n-\n-    pub fn is_coercion_cast(&self, hir_id: hir::HirId) -> bool {\n-        validate_hir_id_for_typeck_results(self.hir_owner, hir_id);\n-        self.coercion_casts.contains(&hir_id.local_id)\n-    }\n-\n-    pub fn set_coercion_cast(&mut self, id: ItemLocalId) {\n-        self.coercion_casts.insert(id);\n-    }\n-\n-    pub fn coercion_casts(&self) -> &ItemLocalSet {\n-        &self.coercion_casts\n-    }\n-}\n-\n-rustc_index::newtype_index! {\n-    pub struct UserTypeAnnotationIndex {\n-        derive [HashStable]\n-        DEBUG_FORMAT = \"UserType({})\",\n-        const START_INDEX = 0,\n-    }\n-}\n-\n-/// Mapping of type annotation indices to canonical user type annotations.\n-pub type CanonicalUserTypeAnnotations<'tcx> =\n-    IndexVec<UserTypeAnnotationIndex, CanonicalUserTypeAnnotation<'tcx>>;\n-\n-#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable, Lift)]\n-pub struct CanonicalUserTypeAnnotation<'tcx> {\n-    pub user_ty: Box<CanonicalUserType<'tcx>>,\n-    pub span: Span,\n-    pub inferred_ty: Ty<'tcx>,\n-}\n-\n-/// Canonicalized user type annotation.\n-pub type CanonicalUserType<'tcx> = Canonical<'tcx, UserType<'tcx>>;\n-\n-impl<'tcx> CanonicalUserType<'tcx> {\n-    /// Returns `true` if this represents a substitution of the form `[?0, ?1, ?2]`,\n-    /// i.e., each thing is mapped to a canonical variable with the same index.\n-    pub fn is_identity(&self) -> bool {\n-        match self.value {\n-            UserType::Ty(_) => false,\n-            UserType::TypeOf(_, user_substs) => {\n-                if user_substs.user_self_ty.is_some() {\n-                    return false;\n-                }\n-\n-                iter::zip(user_substs.substs, BoundVar::new(0)..).all(|(kind, cvar)| {\n-                    match kind.unpack() {\n-                        GenericArgKind::Type(ty) => match ty.kind() {\n-                            ty::Bound(debruijn, b) => {\n-                                // We only allow a `ty::INNERMOST` index in substitutions.\n-                                assert_eq!(*debruijn, ty::INNERMOST);\n-                                cvar == b.var\n-                            }\n-                            _ => false,\n-                        },\n-\n-                        GenericArgKind::Lifetime(r) => match *r {\n-                            ty::ReLateBound(debruijn, br) => {\n-                                // We only allow a `ty::INNERMOST` index in substitutions.\n-                                assert_eq!(debruijn, ty::INNERMOST);\n-                                cvar == br.var\n-                            }\n-                            _ => false,\n-                        },\n-\n-                        GenericArgKind::Const(ct) => match ct.kind() {\n-                            ty::ConstKind::Bound(debruijn, b) => {\n-                                // We only allow a `ty::INNERMOST` index in substitutions.\n-                                assert_eq!(debruijn, ty::INNERMOST);\n-                                cvar == b\n-                            }\n-                            _ => false,\n-                        },\n-                    }\n-                })\n-            }\n-        }\n-    }\n-}\n-\n-/// A user-given type annotation attached to a constant. These arise\n-/// from constants that are named via paths, like `Foo::<A>::new` and\n-/// so forth.\n-#[derive(Copy, Clone, Debug, PartialEq, TyEncodable, TyDecodable)]\n-#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n-pub enum UserType<'tcx> {\n-    Ty(Ty<'tcx>),\n-\n-    /// The canonical type is the result of `type_of(def_id)` with the\n-    /// given substitutions applied.\n-    TypeOf(DefId, UserSubsts<'tcx>),\n-}\n-\n impl<'tcx> CommonTypes<'tcx> {\n     fn new(\n         interners: &CtxtInterners<'tcx>,\n@@ -2145,8 +1475,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                     Bound,\n                     Param,\n                     Infer,\n-                    Projection,\n-                    Opaque,\n+                    Alias,\n                     Foreign\n                 )?;\n \n@@ -2323,7 +1652,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Given a `ty`, return whether it's an `impl Future<...>`.\n     pub fn ty_is_opaque_future(self, ty: Ty<'_>) -> bool {\n-        let ty::Opaque(def_id, _) = ty.kind() else { return false };\n+        let ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }) = ty.kind() else { return false };\n         let future_trait = self.require_lang_item(LangItem::Future, None);\n \n         self.explicit_item_bounds(def_id).iter().any(|(predicate, _)| {\n@@ -2567,15 +1896,35 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[inline]\n-    pub fn mk_fn_def(self, def_id: DefId, substs: SubstsRef<'tcx>) -> Ty<'tcx> {\n-        debug_assert_eq!(\n-            self.generics_of(def_id).count(),\n-            substs.len(),\n-            \"wrong number of generic parameters for {def_id:?}: {substs:?}\",\n-        );\n+    pub fn mk_fn_def(\n+        self,\n+        def_id: DefId,\n+        substs: impl IntoIterator<Item = impl Into<GenericArg<'tcx>>>,\n+    ) -> Ty<'tcx> {\n+        let substs = self.check_substs(def_id, substs);\n         self.mk_ty(FnDef(def_id, substs))\n     }\n \n+    #[inline(always)]\n+    fn check_substs(\n+        self,\n+        _def_id: DefId,\n+        substs: impl IntoIterator<Item = impl Into<GenericArg<'tcx>>>,\n+    ) -> SubstsRef<'tcx> {\n+        let substs = substs.into_iter().map(Into::into);\n+        #[cfg(debug_assertions)]\n+        {\n+            let n = self.generics_of(_def_id).count();\n+            assert_eq!(\n+                (n, Some(n)),\n+                substs.size_hint(),\n+                \"wrong number of generic parameters for {_def_id:?}: {:?}\",\n+                substs.collect::<Vec<_>>(),\n+            );\n+        }\n+        self.mk_substs(substs)\n+    }\n+\n     #[inline]\n     pub fn mk_fn_ptr(self, fty: PolyFnSig<'tcx>) -> Ty<'tcx> {\n         self.mk_ty(FnPtr(fty))\n@@ -2592,13 +1941,12 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[inline]\n-    pub fn mk_projection(self, item_def_id: DefId, substs: SubstsRef<'tcx>) -> Ty<'tcx> {\n-        debug_assert_eq!(\n-            self.generics_of(item_def_id).count(),\n-            substs.len(),\n-            \"wrong number of generic parameters for {item_def_id:?}: {substs:?}\",\n-        );\n-        self.mk_ty(Projection(ProjectionTy { item_def_id, substs }))\n+    pub fn mk_projection(\n+        self,\n+        item_def_id: DefId,\n+        substs: impl IntoIterator<Item = impl Into<GenericArg<'tcx>>>,\n+    ) -> Ty<'tcx> {\n+        self.mk_ty(Alias(ty::Projection, self.mk_alias_ty(item_def_id, substs)))\n     }\n \n     #[inline]\n@@ -2668,7 +2016,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn mk_opaque(self, def_id: DefId, substs: SubstsRef<'tcx>) -> Ty<'tcx> {\n-        self.mk_ty(Opaque(def_id, substs))\n+        self.mk_ty(Alias(ty::Opaque, self.mk_alias_ty(def_id, substs)))\n     }\n \n     pub fn mk_place_field(self, place: Place<'tcx>, f: Field, ty: Ty<'tcx>) -> Place<'tcx> {\n@@ -2857,16 +2205,17 @@ impl<'tcx> TyCtxt<'tcx> {\n         trait_def_id: DefId,\n         substs: impl IntoIterator<Item = impl Into<GenericArg<'tcx>>>,\n     ) -> ty::TraitRef<'tcx> {\n-        let substs = substs.into_iter().map(Into::into);\n-        let n = self.generics_of(trait_def_id).count();\n-        debug_assert_eq!(\n-            (n, Some(n)),\n-            substs.size_hint(),\n-            \"wrong number of generic parameters for {trait_def_id:?}: {:?} \\nDid you accidentally include the self-type in the params list?\",\n-            substs.collect::<Vec<_>>(),\n-        );\n-        let substs = self.mk_substs(substs);\n-        ty::TraitRef::new(trait_def_id, substs)\n+        let substs = self.check_substs(trait_def_id, substs);\n+        ty::TraitRef { def_id: trait_def_id, substs, _use_mk_trait_ref_instead: () }\n+    }\n+\n+    pub fn mk_alias_ty(\n+        self,\n+        def_id: DefId,\n+        substs: impl IntoIterator<Item = impl Into<GenericArg<'tcx>>>,\n+    ) -> ty::AliasTy<'tcx> {\n+        let substs = self.check_substs(def_id, substs);\n+        ty::AliasTy { def_id, substs, _use_mk_alias_ty_instead: () }\n     }\n \n     pub fn mk_bound_variable_kinds<"}, {"sha": "8c22df7395f1052669ad14f2e36cc7e187bf4b23", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -3,7 +3,7 @@\n use std::ops::ControlFlow;\n \n use crate::ty::{\n-    visit::TypeVisitable, Const, ConstKind, DefIdTree, ExistentialPredicate, InferConst, InferTy,\n+    visit::TypeVisitable, AliasTy, Const, ConstKind, DefIdTree, InferConst, InferTy, Opaque,\n     PolyTraitPredicate, Ty, TyCtxt, TypeSuperVisitable, TypeVisitor,\n };\n \n@@ -457,29 +457,18 @@ impl<'tcx> TypeVisitor<'tcx> for IsSuggestableVisitor<'tcx> {\n                 return ControlFlow::Break(());\n             }\n \n-            Opaque(did, _) => {\n-                let parent = self.tcx.parent(*did);\n+            Alias(Opaque, AliasTy { def_id, .. }) => {\n+                let parent = self.tcx.parent(*def_id);\n                 if let hir::def::DefKind::TyAlias | hir::def::DefKind::AssocTy = self.tcx.def_kind(parent)\n-                    && let Opaque(parent_did, _) = self.tcx.type_of(parent).kind()\n-                    && parent_did == did\n+                    && let Alias(Opaque, AliasTy { def_id: parent_opaque_def_id, .. }) = self.tcx.type_of(parent).kind()\n+                    && parent_opaque_def_id == def_id\n                 {\n                     // Okay\n                 } else {\n                     return ControlFlow::Break(());\n                 }\n             }\n \n-            Dynamic(dty, _, _) => {\n-                for pred in *dty {\n-                    match pred.skip_binder() {\n-                        ExistentialPredicate::Trait(_) | ExistentialPredicate::Projection(_) => {\n-                            // Okay\n-                        }\n-                        _ => return ControlFlow::Break(()),\n-                    }\n-                }\n-            }\n-\n             Param(param) => {\n                 // FIXME: It would be nice to make this not use string manipulation,\n                 // but it's pretty hard to do this, since `ty::ParamTy` is missing"}, {"sha": "14d07608a780e6c5b33b6dbae204401251b39088", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 53, "deletions": 39, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,6 +1,6 @@\n use crate::traits::{ObligationCause, ObligationCauseCode};\n use crate::ty::diagnostics::suggest_constraining_type_param;\n-use crate::ty::print::{FmtPrinter, Printer};\n+use crate::ty::print::{with_forced_trimmed_paths, FmtPrinter, Printer};\n use crate::ty::{self, BoundRegionKind, Region, Ty, TyCtxt};\n use hir::def::DefKind;\n use rustc_errors::Applicability::{MachineApplicable, MaybeIncorrect};\n@@ -162,17 +162,29 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n             ),\n             RegionsPlaceholderMismatch => write!(f, \"one type is more general than the other\"),\n             ArgumentSorts(values, _) | Sorts(values) => ty::tls::with(|tcx| {\n-                report_maybe_different(\n-                    f,\n-                    &values.expected.sort_string(tcx),\n-                    &values.found.sort_string(tcx),\n-                )\n+                let (mut expected, mut found) = with_forced_trimmed_paths!((\n+                    values.expected.sort_string(tcx),\n+                    values.found.sort_string(tcx),\n+                ));\n+                if expected == found {\n+                    expected = values.expected.sort_string(tcx);\n+                    found = values.found.sort_string(tcx);\n+                }\n+                report_maybe_different(f, &expected, &found)\n             }),\n             Traits(values) => ty::tls::with(|tcx| {\n+                let (mut expected, mut found) = with_forced_trimmed_paths!((\n+                    tcx.def_path_str(values.expected),\n+                    tcx.def_path_str(values.found),\n+                ));\n+                if expected == found {\n+                    expected = tcx.def_path_str(values.expected);\n+                    found = tcx.def_path_str(values.found);\n+                }\n                 report_maybe_different(\n                     f,\n-                    &format!(\"trait `{}`\", tcx.def_path_str(values.expected)),\n-                    &format!(\"trait `{}`\", tcx.def_path_str(values.found)),\n+                    &format!(\"trait `{expected}`\"),\n+                    &format!(\"trait `{found}`\"),\n                 )\n             }),\n             IntMismatch(ref values) => {\n@@ -325,9 +337,9 @@ impl<'tcx> Ty<'tcx> {\n             ty::Infer(ty::FreshTy(_)) => \"fresh type\".into(),\n             ty::Infer(ty::FreshIntTy(_)) => \"fresh integral type\".into(),\n             ty::Infer(ty::FreshFloatTy(_)) => \"fresh floating-point type\".into(),\n-            ty::Projection(_) => \"associated type\".into(),\n+            ty::Alias(ty::Projection, _) => \"associated type\".into(),\n             ty::Param(p) => format!(\"type parameter `{}`\", p).into(),\n-            ty::Opaque(..) => \"opaque type\".into(),\n+            ty::Alias(ty::Opaque, ..) => \"opaque type\".into(),\n             ty::Error(_) => \"type error\".into(),\n         }\n     }\n@@ -363,9 +375,9 @@ impl<'tcx> Ty<'tcx> {\n             ty::Tuple(..) => \"tuple\".into(),\n             ty::Placeholder(..) => \"higher-ranked type\".into(),\n             ty::Bound(..) => \"bound type variable\".into(),\n-            ty::Projection(_) => \"associated type\".into(),\n+            ty::Alias(ty::Projection, _) => \"associated type\".into(),\n             ty::Param(_) => \"type parameter\".into(),\n-            ty::Opaque(..) => \"opaque type\".into(),\n+            ty::Alias(ty::Opaque, ..) => \"opaque type\".into(),\n         }\n     }\n }\n@@ -388,7 +400,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                         diag.note(\"no two closures, even if identical, have the same type\");\n                         diag.help(\"consider boxing your closure and/or using it as a trait object\");\n                     }\n-                    (ty::Opaque(..), ty::Opaque(..)) => {\n+                    (ty::Alias(ty::Opaque, ..), ty::Alias(ty::Opaque, ..)) => {\n                         // Issue #63167\n                         diag.note(\"distinct uses of `impl Trait` result in different opaque types\");\n                     }\n@@ -427,11 +439,11 @@ impl<'tcx> TyCtxt<'tcx> {\n                              #traits-as-parameters\",\n                         );\n                     }\n-                    (ty::Projection(_), ty::Projection(_)) => {\n+                    (ty::Alias(ty::Projection, _), ty::Alias(ty::Projection, _)) => {\n                         diag.note(\"an associated type was expected, but a different one was found\");\n                     }\n-                    (ty::Param(p), ty::Projection(proj)) | (ty::Projection(proj), ty::Param(p))\n-                        if self.def_kind(proj.item_def_id) != DefKind::ImplTraitPlaceholder =>\n+                    (ty::Param(p), ty::Alias(ty::Projection, proj)) | (ty::Alias(ty::Projection, proj), ty::Param(p))\n+                        if self.def_kind(proj.def_id) != DefKind::ImplTraitPlaceholder =>\n                     {\n                         let generics = self.generics_of(body_owner_def_id);\n                         let p_span = self.def_span(generics.type_param(p, self).def_id);\n@@ -454,7 +466,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                             let (trait_ref, assoc_substs) = proj.trait_ref_and_own_substs(self);\n                             let path =\n                                 self.def_path_str_with_substs(trait_ref.def_id, trait_ref.substs);\n-                            let item_name = self.item_name(proj.item_def_id);\n+                            let item_name = self.item_name(proj.def_id);\n                             let item_args = self.format_generic_args(assoc_substs);\n \n                             let path = if path.ends_with('>') {\n@@ -481,8 +493,8 @@ impl<'tcx> TyCtxt<'tcx> {\n                             diag.note(\"you might be missing a type parameter or trait bound\");\n                         }\n                     }\n-                    (ty::Param(p), ty::Dynamic(..) | ty::Opaque(..))\n-                    | (ty::Dynamic(..) | ty::Opaque(..), ty::Param(p)) => {\n+                    (ty::Param(p), ty::Dynamic(..) | ty::Alias(ty::Opaque, ..))\n+                    | (ty::Dynamic(..) | ty::Alias(ty::Opaque, ..), ty::Param(p)) => {\n                         let generics = self.generics_of(body_owner_def_id);\n                         let p_span = self.def_span(generics.type_param(p, self).def_id);\n                         if !sp.contains(p_span) {\n@@ -541,7 +553,7 @@ impl<T> Trait<T> for X {\n                             diag.span_label(p_span, \"this type parameter\");\n                         }\n                     }\n-                    (ty::Projection(proj_ty), _) if self.def_kind(proj_ty.item_def_id) != DefKind::ImplTraitPlaceholder => {\n+                    (ty::Alias(ty::Projection, proj_ty), _) if self.def_kind(proj_ty.def_id) != DefKind::ImplTraitPlaceholder => {\n                         self.expected_projection(\n                             diag,\n                             proj_ty,\n@@ -550,7 +562,7 @@ impl<T> Trait<T> for X {\n                             cause.code(),\n                         );\n                     }\n-                    (_, ty::Projection(proj_ty)) if self.def_kind(proj_ty.item_def_id) != DefKind::ImplTraitPlaceholder => {\n+                    (_, ty::Alias(ty::Projection, proj_ty)) if self.def_kind(proj_ty.def_id) != DefKind::ImplTraitPlaceholder => {\n                         let msg = format!(\n                             \"consider constraining the associated type `{}` to `{}`\",\n                             values.found, values.expected,\n@@ -612,10 +624,10 @@ impl<T> Trait<T> for X {\n         diag: &mut Diagnostic,\n         msg: &str,\n         body_owner_def_id: DefId,\n-        proj_ty: &ty::ProjectionTy<'tcx>,\n+        proj_ty: &ty::AliasTy<'tcx>,\n         ty: Ty<'tcx>,\n     ) -> bool {\n-        let assoc = self.associated_item(proj_ty.item_def_id);\n+        let assoc = self.associated_item(proj_ty.def_id);\n         let (trait_ref, assoc_substs) = proj_ty.trait_ref_and_own_substs(self);\n         if let Some(item) = self.hir().get_if_local(body_owner_def_id) {\n             if let Some(hir_generics) = item.generics() {\n@@ -668,7 +680,7 @@ impl<T> Trait<T> for X {\n     fn expected_projection(\n         self,\n         diag: &mut Diagnostic,\n-        proj_ty: &ty::ProjectionTy<'tcx>,\n+        proj_ty: &ty::AliasTy<'tcx>,\n         values: ExpectedFound<Ty<'tcx>>,\n         body_owner_def_id: DefId,\n         cause_code: &ObligationCauseCode<'_>,\n@@ -691,7 +703,7 @@ impl<T> Trait<T> for X {\n         );\n         let impl_comparison =\n             matches!(cause_code, ObligationCauseCode::CompareImplItemObligation { .. });\n-        let assoc = self.associated_item(proj_ty.item_def_id);\n+        let assoc = self.associated_item(proj_ty.def_id);\n         if !callable_scope || impl_comparison {\n             // We do not want to suggest calling functions when the reason of the\n             // type error is a comparison of an `impl` with its `trait` or when the\n@@ -704,7 +716,7 @@ impl<T> Trait<T> for X {\n                 diag,\n                 assoc.container_id(self),\n                 current_method_ident,\n-                proj_ty.item_def_id,\n+                proj_ty.def_id,\n                 values.expected,\n             );\n             // Possibly suggest constraining the associated type to conform to the\n@@ -763,11 +775,11 @@ fn foo(&self) -> Self::T { String::new() }\n         self,\n         diag: &mut Diagnostic,\n         msg: &str,\n-        proj_ty: &ty::ProjectionTy<'tcx>,\n+        proj_ty: &ty::AliasTy<'tcx>,\n         ty: Ty<'tcx>,\n     ) -> bool {\n-        let assoc = self.associated_item(proj_ty.item_def_id);\n-        if let ty::Opaque(def_id, _) = *proj_ty.self_ty().kind() {\n+        let assoc = self.associated_item(proj_ty.def_id);\n+        if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }) = *proj_ty.self_ty().kind() {\n             let opaque_local_def_id = def_id.as_local();\n             let opaque_hir_ty = if let Some(opaque_local_def_id) = opaque_local_def_id {\n                 match &self.hir().expect_item(opaque_local_def_id).kind {\n@@ -816,7 +828,7 @@ fn foo(&self) -> Self::T { String::new() }\n             .filter_map(|(_, item)| {\n                 let method = self.fn_sig(item.def_id);\n                 match *method.output().skip_binder().kind() {\n-                    ty::Projection(ty::ProjectionTy { item_def_id, .. })\n+                    ty::Alias(ty::Projection, ty::AliasTy { def_id: item_def_id, .. })\n                         if item_def_id == proj_ty_item_def_id =>\n                     {\n                         Some((\n@@ -998,15 +1010,17 @@ fn foo(&self) -> Self::T { String::new() }\n         }\n         let mut short;\n         loop {\n-            // Look for the longest properly trimmed path that still fits in lenght_limit.\n-            short = FmtPrinter::new_with_limit(\n-                self,\n-                hir::def::Namespace::TypeNS,\n-                rustc_session::Limit(type_limit),\n-            )\n-            .pretty_print_type(ty)\n-            .expect(\"could not write to `String`\")\n-            .into_buffer();\n+            // Look for the longest properly trimmed path that still fits in length_limit.\n+            short = with_forced_trimmed_paths!(\n+                FmtPrinter::new_with_limit(\n+                    self,\n+                    hir::def::Namespace::TypeNS,\n+                    rustc_session::Limit(type_limit),\n+                )\n+                .pretty_print_type(ty)\n+                .expect(\"could not write to `String`\")\n+                .into_buffer()\n+            );\n             if short.len() <= length_limit || type_limit == 0 {\n                 break;\n             }"}, {"sha": "f785fb5c4b9be5b5c57f78104e7895b029bcbabf", "filename": "compiler/rustc_middle/src/ty/fast_reject.rs", "status": "modified", "additions": 13, "deletions": 55, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -6,28 +6,18 @@ use std::fmt::Debug;\n use std::hash::Hash;\n use std::iter;\n \n-use self::SimplifiedTypeGen::*;\n+use self::SimplifiedType::*;\n \n-pub type SimplifiedType = SimplifiedTypeGen<DefId>;\n-\n-/// See `simplify_type`\n-///\n-/// Note that we keep this type generic over the type of identifier it uses\n-/// because we sometimes need to use SimplifiedTypeGen values as stable sorting\n-/// keys (in which case we use a DefPathHash as id-type) but in the general case\n-/// the non-stable but fast to construct DefId-version is the better choice.\n+/// See `simplify_type`.\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n-pub enum SimplifiedTypeGen<D>\n-where\n-    D: Copy + Debug + Eq,\n-{\n+pub enum SimplifiedType {\n     BoolSimplifiedType,\n     CharSimplifiedType,\n     IntSimplifiedType(ty::IntTy),\n     UintSimplifiedType(ty::UintTy),\n     FloatSimplifiedType(ty::FloatTy),\n-    AdtSimplifiedType(D),\n-    ForeignSimplifiedType(D),\n+    AdtSimplifiedType(DefId),\n+    ForeignSimplifiedType(DefId),\n     StrSimplifiedType,\n     ArraySimplifiedType,\n     SliceSimplifiedType,\n@@ -38,9 +28,9 @@ where\n     /// A trait object, all of whose components are markers\n     /// (e.g., `dyn Send + Sync`).\n     MarkerTraitObjectSimplifiedType,\n-    TraitSimplifiedType(D),\n-    ClosureSimplifiedType(D),\n-    GeneratorSimplifiedType(D),\n+    TraitSimplifiedType(DefId),\n+    ClosureSimplifiedType(DefId),\n+    GeneratorSimplifiedType(DefId),\n     GeneratorWitnessSimplifiedType(usize),\n     FunctionSimplifiedType(usize),\n     PlaceholderSimplifiedType,\n@@ -126,7 +116,7 @@ pub fn simplify_type<'tcx>(\n             TreatParams::AsPlaceholder => Some(PlaceholderSimplifiedType),\n             TreatParams::AsInfer => None,\n         },\n-        ty::Opaque(..) | ty::Projection(_) => match treat_params {\n+        ty::Alias(..) => match treat_params {\n             // When treating `ty::Param` as a placeholder, projections also\n             // don't unify with anything else as long as they are fully normalized.\n             //\n@@ -142,8 +132,8 @@ pub fn simplify_type<'tcx>(\n     }\n }\n \n-impl<D: Copy + Debug + Eq> SimplifiedTypeGen<D> {\n-    pub fn def(self) -> Option<D> {\n+impl SimplifiedType {\n+    pub fn def(self) -> Option<DefId> {\n         match self {\n             AdtSimplifiedType(d)\n             | ForeignSimplifiedType(d)\n@@ -153,36 +143,6 @@ impl<D: Copy + Debug + Eq> SimplifiedTypeGen<D> {\n             _ => None,\n         }\n     }\n-\n-    pub fn map_def<U, F>(self, map: F) -> SimplifiedTypeGen<U>\n-    where\n-        F: Fn(D) -> U,\n-        U: Copy + Debug + Eq,\n-    {\n-        match self {\n-            BoolSimplifiedType => BoolSimplifiedType,\n-            CharSimplifiedType => CharSimplifiedType,\n-            IntSimplifiedType(t) => IntSimplifiedType(t),\n-            UintSimplifiedType(t) => UintSimplifiedType(t),\n-            FloatSimplifiedType(t) => FloatSimplifiedType(t),\n-            AdtSimplifiedType(d) => AdtSimplifiedType(map(d)),\n-            ForeignSimplifiedType(d) => ForeignSimplifiedType(map(d)),\n-            StrSimplifiedType => StrSimplifiedType,\n-            ArraySimplifiedType => ArraySimplifiedType,\n-            SliceSimplifiedType => SliceSimplifiedType,\n-            RefSimplifiedType(m) => RefSimplifiedType(m),\n-            PtrSimplifiedType(m) => PtrSimplifiedType(m),\n-            NeverSimplifiedType => NeverSimplifiedType,\n-            MarkerTraitObjectSimplifiedType => MarkerTraitObjectSimplifiedType,\n-            TupleSimplifiedType(n) => TupleSimplifiedType(n),\n-            TraitSimplifiedType(d) => TraitSimplifiedType(map(d)),\n-            ClosureSimplifiedType(d) => ClosureSimplifiedType(map(d)),\n-            GeneratorSimplifiedType(d) => GeneratorSimplifiedType(map(d)),\n-            GeneratorWitnessSimplifiedType(n) => GeneratorWitnessSimplifiedType(n),\n-            FunctionSimplifiedType(n) => FunctionSimplifiedType(n),\n-            PlaceholderSimplifiedType => PlaceholderSimplifiedType,\n-        }\n-    }\n }\n \n /// Given generic arguments from an obligation and an impl,\n@@ -225,7 +185,7 @@ impl DeepRejectCtxt {\n         match impl_ty.kind() {\n             // Start by checking whether the type in the impl may unify with\n             // pretty much everything. Just return `true` in that case.\n-            ty::Param(_) | ty::Projection(_) | ty::Error(_) | ty::Opaque(..) => return true,\n+            ty::Param(_) | ty::Error(_) | ty::Alias(..) => return true,\n             // These types only unify with inference variables or their own\n             // variant.\n             ty::Bool\n@@ -323,8 +283,6 @@ impl DeepRejectCtxt {\n                 _ => false,\n             },\n \n-            ty::Opaque(..) => true,\n-\n             // Impls cannot contain these types as these cannot be named directly.\n             ty::FnDef(..) | ty::Closure(..) | ty::Generator(..) => false,\n \n@@ -344,7 +302,7 @@ impl DeepRejectCtxt {\n             // projections can unify with other stuff.\n             //\n             // Looking forward to lazy normalization this is the safer strategy anyways.\n-            ty::Projection(_) => true,\n+            ty::Alias(..) => true,\n \n             ty::Error(_) => true,\n "}, {"sha": "d283ccc3ad8a29435035c2c6bc4fc1fe9b0b3454", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -155,12 +155,12 @@ impl FlagComputation {\n                 self.add_substs(substs);\n             }\n \n-            &ty::Projection(data) => {\n+            &ty::Alias(ty::Projection, data) => {\n                 self.add_flags(TypeFlags::HAS_TY_PROJECTION);\n                 self.add_projection_ty(data);\n             }\n \n-            &ty::Opaque(_, substs) => {\n+            &ty::Alias(ty::Opaque, ty::AliasTy { substs, .. }) => {\n                 self.add_flags(TypeFlags::HAS_TY_OPAQUE);\n                 self.add_substs(substs);\n             }\n@@ -345,7 +345,7 @@ impl FlagComputation {\n         }\n     }\n \n-    fn add_projection_ty(&mut self, projection_ty: ty::ProjectionTy<'_>) {\n+    fn add_projection_ty(&mut self, projection_ty: ty::AliasTy<'_>) {\n         self.add_substs(projection_ty.substs);\n     }\n "}, {"sha": "09fee0c3f7c30819138b4df81f49295aa0a6d031", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -583,36 +583,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.replace_late_bound_regions(value, |_| self.lifetimes.re_erased).0\n     }\n \n-    /// Rewrite any late-bound regions so that they are anonymous. Region numbers are\n-    /// assigned starting at 0 and increasing monotonically in the order traversed\n-    /// by the fold operation.\n-    ///\n-    /// The chief purpose of this function is to canonicalize regions so that two\n-    /// `FnSig`s or `TraitRef`s which are equivalent up to region naming will become\n-    /// structurally identical. For example, `for<'a, 'b> fn(&'a isize, &'b isize)` and\n-    /// `for<'a, 'b> fn(&'b isize, &'a isize)` will become identical after anonymization.\n-    pub fn anonymize_late_bound_regions<T>(self, sig: Binder<'tcx, T>) -> Binder<'tcx, T>\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        let mut counter = 0;\n-        let inner = self\n-            .replace_late_bound_regions(sig, |_| {\n-                let br = ty::BoundRegion {\n-                    var: ty::BoundVar::from_u32(counter),\n-                    kind: ty::BrAnon(counter, None),\n-                };\n-                let r = self.mk_region(ty::ReLateBound(ty::INNERMOST, br));\n-                counter += 1;\n-                r\n-            })\n-            .0;\n-        let bound_vars = self.mk_bound_variable_kinds(\n-            (0..counter).map(|i| ty::BoundVariableKind::Region(ty::BrAnon(i, None))),\n-        );\n-        Binder::bind_with_vars(inner, bound_vars)\n-    }\n-\n     /// Anonymize all bound variables in `value`, this is mostly used to improve caching.\n     pub fn anonymize_bound_vars<T>(self, value: Binder<'tcx, T>) -> Binder<'tcx, T>\n     where"}, {"sha": "5d5089cec82a696d105c196e45d16808e20569c5", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -112,7 +112,7 @@ impl<'tcx> Ty<'tcx> {\n                 InhabitedPredicate::True\n             }\n             Never => InhabitedPredicate::False,\n-            Param(_) | Projection(_) => InhabitedPredicate::GenericType(self),\n+            Param(_) | Alias(ty::Projection, _) => InhabitedPredicate::GenericType(self),\n             Tuple(tys) if tys.is_empty() => InhabitedPredicate::True,\n             // use a query for more complex cases\n             Adt(..) | Array(..) | Tuple(_) => tcx.inhabited_predicate_type(self),"}, {"sha": "35d369ffc891c859e035e8555a36dec60b29fda8", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -385,6 +385,21 @@ impl<'tcx> Instance<'tcx> {\n         )\n     }\n \n+    pub fn expect_resolve(\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        def_id: DefId,\n+        substs: SubstsRef<'tcx>,\n+    ) -> Instance<'tcx> {\n+        match ty::Instance::resolve(tcx, param_env, def_id, substs) {\n+            Ok(Some(instance)) => instance,\n+            _ => bug!(\n+                \"failed to resolve instance for {}\",\n+                tcx.def_path_str_with_substs(def_id, substs)\n+            ),\n+        }\n+    }\n+\n     // This should be kept up to date with `resolve`.\n     pub fn resolve_opt_const_arg(\n         tcx: TyCtxt<'tcx>,\n@@ -525,7 +540,7 @@ impl<'tcx> Instance<'tcx> {\n     pub fn resolve_drop_in_place(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> ty::Instance<'tcx> {\n         let def_id = tcx.require_lang_item(LangItem::DropInPlace, None);\n         let substs = tcx.intern_substs(&[ty.into()]);\n-        Instance::resolve(tcx, ty::ParamEnv::reveal_all(), def_id, substs).unwrap().unwrap()\n+        Instance::expect_resolve(tcx, ty::ParamEnv::reveal_all(), def_id, substs)\n     }\n \n     #[instrument(level = \"debug\", skip(tcx), ret)]"}, {"sha": "7f66b993646a32058461edd9b1063ea46a892475", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -271,7 +271,7 @@ impl<'tcx> SizeSkeleton<'tcx> {\n                 let non_zero = !ty.is_unsafe_ptr();\n                 let tail = tcx.struct_tail_erasing_lifetimes(pointee, param_env);\n                 match tail.kind() {\n-                    ty::Param(_) | ty::Projection(_) => {\n+                    ty::Param(_) | ty::Alias(ty::Projection, _) => {\n                         debug_assert!(tail.has_non_region_param());\n                         Ok(SizeSkeleton::Pointer { non_zero, tail: tcx.erase_regions(tail) })\n                     }\n@@ -349,7 +349,7 @@ impl<'tcx> SizeSkeleton<'tcx> {\n                 }\n             }\n \n-            ty::Projection(_) | ty::Opaque(..) => {\n+            ty::Alias(..) => {\n                 let normalized = tcx.normalize_erasing_regions(param_env, ty);\n                 if ty == normalized {\n                     Err(err)\n@@ -757,10 +757,9 @@ where\n                     }\n                 }\n \n-                ty::Projection(_)\n+                ty::Alias(..)\n                 | ty::Bound(..)\n                 | ty::Placeholder(..)\n-                | ty::Opaque(..)\n                 | ty::Param(_)\n                 | ty::Infer(_)\n                 | ty::Error(_) => bug!(\"TyAndLayout::field: unexpected type `{}`\", this.ty),"}, {"sha": "7290f0ae7c0350f4d34b3e08be5303af6da875d1", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -64,6 +64,7 @@ use std::ops::ControlFlow;\n use std::{fmt, str};\n \n pub use crate::ty::diagnostics::*;\n+pub use rustc_type_ir::AliasKind::*;\n pub use rustc_type_ir::DynKind::*;\n pub use rustc_type_ir::InferTy::*;\n pub use rustc_type_ir::RegionKind::*;\n@@ -82,27 +83,29 @@ pub use self::consts::{\n     Const, ConstInt, ConstKind, ConstS, Expr, InferConst, ScalarInt, UnevaluatedConst, ValTree,\n };\n pub use self::context::{\n-    tls, CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,\n-    CtxtInterners, DeducedParamAttrs, FreeRegionInfo, GeneratorDiagnosticData,\n-    GeneratorInteriorTypeCause, GlobalCtxt, Lift, OnDiskCache, TyCtxt, TyCtxtFeed, TypeckResults,\n-    UserType, UserTypeAnnotationIndex,\n+    tls, CtxtInterners, DeducedParamAttrs, FreeRegionInfo, GlobalCtxt, Lift, OnDiskCache, TyCtxt,\n+    TyCtxtFeed,\n };\n pub use self::instance::{Instance, InstanceDef, ShortInstance};\n pub use self::list::List;\n pub use self::parameterized::ParameterizedOverTcx;\n pub use self::rvalue_scopes::RvalueScopes;\n pub use self::sty::BoundRegionKind::*;\n pub use self::sty::{\n-    Article, Binder, BoundRegion, BoundRegionKind, BoundTy, BoundTyKind, BoundVar,\n+    AliasTy, Article, Binder, BoundRegion, BoundRegionKind, BoundTy, BoundTyKind, BoundVar,\n     BoundVariableKind, CanonicalPolyFnSig, ClosureSubsts, ClosureSubstsParts, ConstVid,\n     EarlyBoundRegion, ExistentialPredicate, ExistentialProjection, ExistentialTraitRef, FnSig,\n     FreeRegion, GenSig, GeneratorSubsts, GeneratorSubstsParts, InlineConstSubsts,\n     InlineConstSubstsParts, ParamConst, ParamTy, PolyExistentialPredicate,\n     PolyExistentialProjection, PolyExistentialTraitRef, PolyFnSig, PolyGenSig, PolyTraitRef,\n-    ProjectionTy, Region, RegionKind, RegionVid, TraitRef, TyKind, TypeAndMut, UpvarSubsts,\n-    VarianceDiagInfo,\n+    Region, RegionKind, RegionVid, TraitRef, TyKind, TypeAndMut, UpvarSubsts, VarianceDiagInfo,\n };\n pub use self::trait_def::TraitDef;\n+pub use self::typeck_results::{\n+    CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,\n+    GeneratorDiagnosticData, GeneratorInteriorTypeCause, TypeckResults, UserType,\n+    UserTypeAnnotationIndex,\n+};\n \n pub mod _match;\n pub mod abstract_const;\n@@ -143,6 +146,7 @@ mod parameterized;\n mod rvalue_scopes;\n mod structural_impls;\n mod sty;\n+mod typeck_results;\n \n // Data types\n \n@@ -235,7 +239,7 @@ pub struct ImplHeader<'tcx> {\n     pub predicates: Vec<Predicate<'tcx>>,\n }\n \n-#[derive(Copy, Clone, Debug, TypeFoldable, TypeVisitable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, TypeFoldable, TypeVisitable)]\n pub enum ImplSubject<'tcx> {\n     Trait(TraitRef<'tcx>),\n     Inherent(Ty<'tcx>),\n@@ -781,8 +785,8 @@ impl<'tcx> TraitPredicate<'tcx> {\n         }\n     }\n \n-    pub fn with_self_type(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self {\n-        Self { trait_ref: self.trait_ref.with_self_type(tcx, self_ty), ..self }\n+    pub fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self {\n+        Self { trait_ref: self.trait_ref.with_self_ty(tcx, self_ty), ..self }\n     }\n \n     pub fn def_id(self) -> DefId {\n@@ -1010,7 +1014,7 @@ impl<'tcx> TermKind<'tcx> {\n #[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct ProjectionPredicate<'tcx> {\n-    pub projection_ty: ProjectionTy<'tcx>,\n+    pub projection_ty: AliasTy<'tcx>,\n     pub term: Term<'tcx>,\n }\n \n@@ -1046,7 +1050,19 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n     /// associated type, which is in `tcx.associated_item(projection_def_id()).container`.\n     pub fn projection_def_id(&self) -> DefId {\n         // Ok to skip binder since trait `DefId` does not care about regions.\n-        self.skip_binder().projection_ty.item_def_id\n+        self.skip_binder().projection_ty.def_id\n+    }\n+}\n+\n+impl<'tcx> ProjectionPredicate<'tcx> {\n+    pub fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self {\n+        Self {\n+            projection_ty: tcx.mk_alias_ty(\n+                self.projection_ty.def_id,\n+                [self_ty.into()].into_iter().chain(self.projection_ty.substs.iter().skip(1)),\n+            ),\n+            ..self\n+        }\n     }\n }\n "}, {"sha": "a21e3961cb627341211579f1a8528bb3a39b34c3", "filename": "compiler/rustc_middle/src/ty/parameterized.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,15 +1,10 @@\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::def_id::{DefId, DefIndex};\n+use rustc_hir::def_id::DefIndex;\n use rustc_index::vec::{Idx, IndexVec};\n \n-use crate::middle::exported_symbols::ExportedSymbol;\n-use crate::mir::Body;\n-use crate::ty::{\n-    self, Clause, Const, FnSig, GeneratorDiagnosticData, GenericPredicates, Predicate, TraitRef, Ty,\n-};\n+use crate::ty;\n \n pub trait ParameterizedOverTcx: 'static {\n-    #[allow(unused_lifetimes)]\n     type Value<'tcx>;\n }\n \n@@ -67,7 +62,7 @@ trivially_parameterized_over_tcx! {\n     ty::TraitDef,\n     ty::Visibility<DefIndex>,\n     ty::adjustment::CoerceUnsizedInfo,\n-    ty::fast_reject::SimplifiedTypeGen<DefId>,\n+    ty::fast_reject::SimplifiedType,\n     rustc_ast::Attribute,\n     rustc_ast::DelimArgs,\n     rustc_attr::ConstStability,\n@@ -100,29 +95,28 @@ trivially_parameterized_over_tcx! {\n     rustc_type_ir::Variance,\n }\n \n-// HACK(compiler-errors): This macro rule can only take an ident,\n-// not a path, due to parsing ambiguity reasons. That means we gotta\n-// import all of these types above.\n+// HACK(compiler-errors): This macro rule can only take a fake path,\n+// not a real, due to parsing ambiguity reasons.\n #[macro_export]\n macro_rules! parameterized_over_tcx {\n-    ($($ident:ident),+ $(,)?) => {\n+    ($($($fake_path:ident)::+),+ $(,)?) => {\n         $(\n-            impl $crate::ty::ParameterizedOverTcx for $ident<'static> {\n-                type Value<'tcx> = $ident<'tcx>;\n+            impl $crate::ty::ParameterizedOverTcx for $($fake_path)::+<'static> {\n+                type Value<'tcx> = $($fake_path)::+<'tcx>;\n             }\n         )*\n     }\n }\n \n parameterized_over_tcx! {\n-    Ty,\n-    FnSig,\n-    GenericPredicates,\n-    TraitRef,\n-    Const,\n-    Predicate,\n-    Clause,\n-    GeneratorDiagnosticData,\n-    Body,\n-    ExportedSymbol,\n+    crate::middle::exported_symbols::ExportedSymbol,\n+    crate::mir::Body,\n+    ty::Ty,\n+    ty::FnSig,\n+    ty::GenericPredicates,\n+    ty::TraitRef,\n+    ty::Const,\n+    ty::Predicate,\n+    ty::Clause,\n+    ty::GeneratorDiagnosticData,\n }"}, {"sha": "29bad33e4bc0f36aa5ef8f955e1ec30da54ef19a", "filename": "compiler/rustc_middle/src/ty/print/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -169,10 +169,8 @@ pub trait Printer<'tcx>: Sized {\n                 self.path_append(\n                     |cx: Self| {\n                         if trait_qualify_parent {\n-                            let trait_ref = ty::TraitRef::new(\n-                                parent_def_id,\n-                                cx.tcx().intern_substs(parent_substs),\n-                            );\n+                            let trait_ref =\n+                                cx.tcx().mk_trait_ref(parent_def_id, parent_substs.iter().copied());\n                             cx.path_qualified(trait_ref.self_ty(), Some(trait_ref))\n                         } else {\n                             cx.print_def_path(parent_def_id, parent_substs)\n@@ -275,10 +273,9 @@ fn characteristic_def_id_of_type_cached<'a>(\n         | ty::Uint(_)\n         | ty::Str\n         | ty::FnPtr(_)\n-        | ty::Projection(_)\n+        | ty::Alias(..)\n         | ty::Placeholder(..)\n         | ty::Param(_)\n-        | ty::Opaque(..)\n         | ty::Infer(_)\n         | ty::Bound(..)\n         | ty::Error(_)"}, {"sha": "a1d53506707c9a2938749623d087c314bad761a6", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 100, "deletions": 13, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -10,20 +10,20 @@ use rustc_data_structures::sso::SsoHashSet;\n use rustc_hir as hir;\n use rustc_hir::def::{self, CtorKind, DefKind, Namespace};\n use rustc_hir::def_id::{DefId, DefIdSet, CRATE_DEF_ID, LOCAL_CRATE};\n-use rustc_hir::definitions::{DefPathData, DefPathDataName, DisambiguatedDefPathData};\n+use rustc_hir::definitions::{DefKey, DefPathData, DefPathDataName, DisambiguatedDefPathData};\n use rustc_hir::LangItem;\n use rustc_session::config::TrimmedDefPaths;\n use rustc_session::cstore::{ExternCrate, ExternCrateSource};\n use rustc_session::Limit;\n use rustc_span::symbol::{kw, Ident, Symbol};\n+use rustc_span::FileNameDisplayPreference;\n use rustc_target::abi::Size;\n use rustc_target::spec::abi::Abi;\n use smallvec::SmallVec;\n \n use std::cell::Cell;\n use std::char;\n use std::collections::BTreeMap;\n-use std::convert::TryFrom;\n use std::fmt::{self, Write as _};\n use std::iter;\n use std::ops::{ControlFlow, Deref, DerefMut};\n@@ -63,6 +63,7 @@ thread_local! {\n     static FORCE_IMPL_FILENAME_LINE: Cell<bool> = const { Cell::new(false) };\n     static SHOULD_PREFIX_WITH_CRATE: Cell<bool> = const { Cell::new(false) };\n     static NO_TRIMMED_PATH: Cell<bool> = const { Cell::new(false) };\n+    static FORCE_TRIMMED_PATH: Cell<bool> = const { Cell::new(false) };\n     static NO_QUERIES: Cell<bool> = const { Cell::new(false) };\n     static NO_VISIBLE_PATH: Cell<bool> = const { Cell::new(false) };\n }\n@@ -116,6 +117,7 @@ define_helper!(\n     /// of various rustc types, for example `std::vec::Vec` would be trimmed to `Vec`,\n     /// if no other `Vec` is found.\n     fn with_no_trimmed_paths(NoTrimmedGuard, NO_TRIMMED_PATH);\n+    fn with_forced_trimmed_paths(ForceTrimmedGuard, FORCE_TRIMMED_PATH);\n     /// Prevent selection of visible paths. `Display` impl of DefId will prefer\n     /// visible (public) reexports of types as paths.\n     fn with_no_visible_paths(NoVisibleGuard, NO_VISIBLE_PATH);\n@@ -295,11 +297,89 @@ pub trait PrettyPrinter<'tcx>:\n         self.try_print_visible_def_path_recur(def_id, &mut callers)\n     }\n \n+    // Given a `DefId`, produce a short name. For types and traits, it prints *only* its name,\n+    // For associated items on traits it prints out the trait's name and the associated item's name.\n+    // For enum variants, if they have an unique name, then we only print the name, otherwise we\n+    // print the enum name and the variant name. Otherwise, we do not print anything and let the\n+    // caller use the `print_def_path` fallback.\n+    fn force_print_trimmed_def_path(\n+        mut self,\n+        def_id: DefId,\n+    ) -> Result<(Self::Path, bool), Self::Error> {\n+        let key = self.tcx().def_key(def_id);\n+        let visible_parent_map = self.tcx().visible_parent_map(());\n+        let kind = self.tcx().def_kind(def_id);\n+\n+        let get_local_name = |this: &Self, name, def_id, key: DefKey| {\n+            if let Some(visible_parent) = visible_parent_map.get(&def_id)\n+                && let actual_parent = this.tcx().opt_parent(def_id)\n+                && let DefPathData::TypeNs(_) = key.disambiguated_data.data\n+                && Some(*visible_parent) != actual_parent\n+            {\n+                this\n+                    .tcx()\n+                    .module_children(visible_parent)\n+                    .iter()\n+                    .filter(|child| child.res.opt_def_id() == Some(def_id))\n+                    .find(|child| child.vis.is_public() && child.ident.name != kw::Underscore)\n+                    .map(|child| child.ident.name)\n+                    .unwrap_or(name)\n+            } else {\n+                name\n+            }\n+        };\n+        if let DefKind::Variant = kind\n+            && let Some(symbol) = self.tcx().trimmed_def_paths(()).get(&def_id)\n+        {\n+            // If `Assoc` is unique, we don't want to talk about `Trait::Assoc`.\n+            self.write_str(get_local_name(&self, *symbol, def_id, key).as_str())?;\n+            return Ok((self, true));\n+        }\n+        if let Some(symbol) = key.get_opt_name() {\n+            if let DefKind::AssocConst | DefKind::AssocFn | DefKind::AssocTy = kind\n+                && let Some(parent) = self.tcx().opt_parent(def_id)\n+                && let parent_key = self.tcx().def_key(parent)\n+                && let Some(symbol) = parent_key.get_opt_name()\n+            {\n+                // Trait\n+                self.write_str(get_local_name(&self, symbol, parent, parent_key).as_str())?;\n+                self.write_str(\"::\")?;\n+            } else if let DefKind::Variant = kind\n+                && let Some(parent) = self.tcx().opt_parent(def_id)\n+                && let parent_key = self.tcx().def_key(parent)\n+                && let Some(symbol) = parent_key.get_opt_name()\n+            {\n+                // Enum\n+\n+                // For associated items and variants, we want the \"full\" path, namely, include\n+                // the parent type in the path. For example, `Iterator::Item`.\n+                self.write_str(get_local_name(&self, symbol, parent, parent_key).as_str())?;\n+                self.write_str(\"::\")?;\n+            } else if let DefKind::Struct | DefKind::Union | DefKind::Enum | DefKind::Trait\n+                | DefKind::TyAlias | DefKind::Fn | DefKind::Const | DefKind::Static(_) = kind\n+            {\n+            } else {\n+                // If not covered above, like for example items out of `impl` blocks, fallback.\n+                return Ok((self, false));\n+            }\n+            self.write_str(get_local_name(&self, symbol, def_id, key).as_str())?;\n+            return Ok((self, true));\n+        }\n+        Ok((self, false))\n+    }\n+\n     /// Try to see if this path can be trimmed to a unique symbol name.\n     fn try_print_trimmed_def_path(\n         mut self,\n         def_id: DefId,\n     ) -> Result<(Self::Path, bool), Self::Error> {\n+        if FORCE_TRIMMED_PATH.with(|flag| flag.get()) {\n+            let (s, trimmed) = self.force_print_trimmed_def_path(def_id)?;\n+            if trimmed {\n+                return Ok((s, true));\n+            }\n+            self = s;\n+        }\n         if !self.tcx().sess.opts.unstable_opts.trim_diagnostic_paths\n             || matches!(self.tcx().sess.opts.trimmed_def_paths, TrimmedDefPaths::Never)\n             || NO_TRIMMED_PATH.with(|flag| flag.get())\n@@ -639,17 +719,17 @@ pub trait PrettyPrinter<'tcx>:\n             ty::Foreign(def_id) => {\n                 p!(print_def_path(def_id, &[]));\n             }\n-            ty::Projection(ref data) => {\n+            ty::Alias(ty::Projection, ref data) => {\n                 if !(self.should_print_verbose() || NO_QUERIES.with(|q| q.get()))\n-                    && self.tcx().def_kind(data.item_def_id) == DefKind::ImplTraitPlaceholder\n+                    && self.tcx().def_kind(data.def_id) == DefKind::ImplTraitPlaceholder\n                 {\n-                    return self.pretty_print_opaque_impl_type(data.item_def_id, data.substs);\n+                    return self.pretty_print_opaque_impl_type(data.def_id, data.substs);\n                 } else {\n                     p!(print(data))\n                 }\n             }\n             ty::Placeholder(placeholder) => p!(write(\"Placeholder({:?})\", placeholder)),\n-            ty::Opaque(def_id, substs) => {\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n                 // FIXME(eddyb) print this with `print_def_path`.\n                 // We use verbose printing in 'NO_QUERIES' mode, to\n                 // avoid needing to call `predicates_of`. This should\n@@ -664,7 +744,9 @@ pub trait PrettyPrinter<'tcx>:\n                 let parent = self.tcx().parent(def_id);\n                 match self.tcx().def_kind(parent) {\n                     DefKind::TyAlias | DefKind::AssocTy => {\n-                        if let ty::Opaque(d, _) = *self.tcx().type_of(parent).kind() {\n+                        if let ty::Alias(ty::Opaque, ty::AliasTy { def_id: d, .. }) =\n+                            *self.tcx().type_of(parent).kind()\n+                        {\n                             if d == def_id {\n                                 // If the type alias directly starts with the `impl` of the\n                                 // opaque type we're printing, then skip the `::{opaque#1}`.\n@@ -737,11 +819,16 @@ pub trait PrettyPrinter<'tcx>:\n                             p!(\"@\", print_def_path(did.to_def_id(), substs));\n                         } else {\n                             let span = self.tcx().def_span(did);\n+                            let preference = if FORCE_TRIMMED_PATH.with(|flag| flag.get()) {\n+                                FileNameDisplayPreference::Short\n+                            } else {\n+                                FileNameDisplayPreference::Remapped\n+                            };\n                             p!(write(\n                                 \"@{}\",\n                                 // This may end up in stderr diagnostics but it may also be emitted\n                                 // into MIR. Hence we use the remapped path if available\n-                                self.tcx().sess.source_map().span_to_embeddable_string(span)\n+                                self.tcx().sess.source_map().span_to_string(span, preference)\n                             ));\n                         }\n                     } else {\n@@ -940,8 +1027,8 @@ pub trait PrettyPrinter<'tcx>:\n                         // Skip printing `<[generator@] as Generator<_>>::Return` from async blocks,\n                         // unless we can find out what generator return type it comes from.\n                         let term = if let Some(ty) = term.skip_binder().ty()\n-                            && let ty::Projection(proj) = ty.kind()\n-                            && let Some(assoc) = tcx.opt_associated_item(proj.item_def_id)\n+                            && let ty::Alias(ty::Projection, proj) = ty.kind()\n+                            && let Some(assoc) = tcx.opt_associated_item(proj.def_id)\n                             && assoc.trait_container(tcx) == tcx.lang_items().gen_trait()\n                             && assoc.name == rustc_span::sym::Return\n                         {\n@@ -2574,7 +2661,7 @@ define_print_and_forward_display! {\n     }\n \n     ty::ExistentialProjection<'tcx> {\n-        let name = cx.tcx().associated_item(self.item_def_id).name;\n+        let name = cx.tcx().associated_item(self.def_id).name;\n         p!(write(\"{} = \", name), print(self.term))\n     }\n \n@@ -2661,8 +2748,8 @@ define_print_and_forward_display! {\n       }\n     }\n \n-    ty::ProjectionTy<'tcx> {\n-        p!(print_def_path(self.item_def_id, self.substs));\n+    ty::AliasTy<'tcx> {\n+        p!(print_def_path(self.def_id, self.substs));\n     }\n \n     ty::ClosureKind {"}, {"sha": "c4116558bd27b262b6aebdc3ccdb0ee587213d0c", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 19, "deletions": 26, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -106,7 +106,7 @@ pub trait TypeRelation<'tcx>: Sized {\n         T: Relate<'tcx>;\n }\n \n-pub trait Relate<'tcx>: TypeFoldable<'tcx> + Copy {\n+pub trait Relate<'tcx>: TypeFoldable<'tcx> + PartialEq + Copy {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: Self,\n@@ -270,21 +270,17 @@ impl<'tcx> Relate<'tcx> for abi::Abi {\n     }\n }\n \n-impl<'tcx> Relate<'tcx> for ty::ProjectionTy<'tcx> {\n+impl<'tcx> Relate<'tcx> for ty::AliasTy<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: ty::ProjectionTy<'tcx>,\n-        b: ty::ProjectionTy<'tcx>,\n-    ) -> RelateResult<'tcx, ty::ProjectionTy<'tcx>> {\n-        if a.item_def_id != b.item_def_id {\n-            Err(TypeError::ProjectionMismatched(expected_found(\n-                relation,\n-                a.item_def_id,\n-                b.item_def_id,\n-            )))\n+        a: ty::AliasTy<'tcx>,\n+        b: ty::AliasTy<'tcx>,\n+    ) -> RelateResult<'tcx, ty::AliasTy<'tcx>> {\n+        if a.def_id != b.def_id {\n+            Err(TypeError::ProjectionMismatched(expected_found(relation, a.def_id, b.def_id)))\n         } else {\n             let substs = relation.relate(a.substs, b.substs)?;\n-            Ok(ty::ProjectionTy { item_def_id: a.item_def_id, substs: &substs })\n+            Ok(relation.tcx().mk_alias_ty(a.def_id, substs))\n         }\n     }\n }\n@@ -295,12 +291,8 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialProjection<'tcx> {\n         a: ty::ExistentialProjection<'tcx>,\n         b: ty::ExistentialProjection<'tcx>,\n     ) -> RelateResult<'tcx, ty::ExistentialProjection<'tcx>> {\n-        if a.item_def_id != b.item_def_id {\n-            Err(TypeError::ProjectionMismatched(expected_found(\n-                relation,\n-                a.item_def_id,\n-                b.item_def_id,\n-            )))\n+        if a.def_id != b.def_id {\n+            Err(TypeError::ProjectionMismatched(expected_found(relation, a.def_id, b.def_id)))\n         } else {\n             let term = relation.relate_with_variance(\n                 ty::Invariant,\n@@ -314,7 +306,7 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialProjection<'tcx> {\n                 a.substs,\n                 b.substs,\n             )?;\n-            Ok(ty::ExistentialProjection { item_def_id: a.item_def_id, substs, term })\n+            Ok(ty::ExistentialProjection { def_id: a.def_id, substs, term })\n         }\n     }\n }\n@@ -330,7 +322,7 @@ impl<'tcx> Relate<'tcx> for ty::TraitRef<'tcx> {\n             Err(TypeError::Traits(expected_found(relation, a.def_id, b.def_id)))\n         } else {\n             let substs = relate_substs(relation, a.substs, b.substs)?;\n-            Ok(ty::TraitRef { def_id: a.def_id, substs })\n+            Ok(relation.tcx().mk_trait_ref(a.def_id, substs))\n         }\n     }\n }\n@@ -351,7 +343,7 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialTraitRef<'tcx> {\n     }\n }\n \n-#[derive(Copy, Debug, Clone, TypeFoldable, TypeVisitable)]\n+#[derive(PartialEq, Copy, Debug, Clone, TypeFoldable, TypeVisitable)]\n struct GeneratorWitness<'tcx>(&'tcx ty::List<Ty<'tcx>>);\n \n impl<'tcx> Relate<'tcx> for GeneratorWitness<'tcx> {\n@@ -559,14 +551,15 @@ pub fn super_relate_tys<'tcx, R: TypeRelation<'tcx>>(\n         }\n \n         // these two are already handled downstream in case of lazy normalization\n-        (&ty::Projection(a_data), &ty::Projection(b_data)) => {\n+        (&ty::Alias(ty::Projection, a_data), &ty::Alias(ty::Projection, b_data)) => {\n             let projection_ty = relation.relate(a_data, b_data)?;\n-            Ok(tcx.mk_projection(projection_ty.item_def_id, projection_ty.substs))\n+            Ok(tcx.mk_projection(projection_ty.def_id, projection_ty.substs))\n         }\n \n-        (&ty::Opaque(a_def_id, a_substs), &ty::Opaque(b_def_id, b_substs))\n-            if a_def_id == b_def_id =>\n-        {\n+        (\n+            &ty::Alias(ty::Opaque, ty::AliasTy { def_id: a_def_id, substs: a_substs, .. }),\n+            &ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, substs: b_substs, .. }),\n+        ) if a_def_id == b_def_id => {\n             if relation.intercrate() {\n                 // During coherence, opaque types should be treated as equal to each other, even if their generic params\n                 // differ, as they could resolve to the same hidden type, even for different generic params."}, {"sha": "3c6800cf293dee25e44b9b807a7c14550330f8cf", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -651,8 +651,7 @@ impl<'tcx> TypeSuperFoldable<'tcx> for Ty<'tcx> {\n             }\n             ty::GeneratorWitness(types) => ty::GeneratorWitness(types.try_fold_with(folder)?),\n             ty::Closure(did, substs) => ty::Closure(did, substs.try_fold_with(folder)?),\n-            ty::Projection(data) => ty::Projection(data.try_fold_with(folder)?),\n-            ty::Opaque(did, substs) => ty::Opaque(did, substs.try_fold_with(folder)?),\n+            ty::Alias(kind, data) => ty::Alias(kind, data.try_fold_with(folder)?),\n \n             ty::Bool\n             | ty::Char\n@@ -697,8 +696,7 @@ impl<'tcx> TypeSuperVisitable<'tcx> for Ty<'tcx> {\n             ty::Generator(_did, ref substs, _) => substs.visit_with(visitor),\n             ty::GeneratorWitness(ref types) => types.visit_with(visitor),\n             ty::Closure(_did, ref substs) => substs.visit_with(visitor),\n-            ty::Projection(ref data) => data.visit_with(visitor),\n-            ty::Opaque(_, ref substs) => substs.visit_with(visitor),\n+            ty::Alias(_, ref data) => data.visit_with(visitor),\n \n             ty::Bool\n             | ty::Char"}, {"sha": "66aeebab88ba017d24bfd90895e1d1f7b58d4d94", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 71, "deletions": 46, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -217,7 +217,7 @@ static_assert_size!(TyKind<'_>, 32);\n /// * `GR`: The \"return type\", which is the type of value returned upon\n ///   completion of the generator.\n /// * `GW`: The \"generator witness\".\n-#[derive(Copy, Clone, Debug, TypeFoldable, TypeVisitable, Lift)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, TypeFoldable, TypeVisitable, Lift)]\n pub struct ClosureSubsts<'tcx> {\n     /// Lifetime and type parameters from the enclosing function,\n     /// concatenated with a tuple containing the types of the upvars.\n@@ -348,7 +348,7 @@ impl<'tcx> ClosureSubsts<'tcx> {\n }\n \n /// Similar to `ClosureSubsts`; see the above documentation for more.\n-#[derive(Copy, Clone, Debug, TypeFoldable, TypeVisitable, Lift)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, TypeFoldable, TypeVisitable, Lift)]\n pub struct GeneratorSubsts<'tcx> {\n     pub substs: SubstsRef<'tcx>,\n }\n@@ -693,7 +693,7 @@ impl<'tcx> ExistentialPredicate<'tcx> {\n         match (*self, *other) {\n             (Trait(_), Trait(_)) => Ordering::Equal,\n             (Projection(ref a), Projection(ref b)) => {\n-                tcx.def_path_hash(a.item_def_id).cmp(&tcx.def_path_hash(b.item_def_id))\n+                tcx.def_path_hash(a.def_id).cmp(&tcx.def_path_hash(b.def_id))\n             }\n             (AutoTrait(ref a), AutoTrait(ref b)) => {\n                 tcx.def_path_hash(*a).cmp(&tcx.def_path_hash(*b))\n@@ -816,14 +816,13 @@ impl<'tcx> List<ty::PolyExistentialPredicate<'tcx>> {\n pub struct TraitRef<'tcx> {\n     pub def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n+    /// This field exists to prevent the creation of `TraitRef` without\n+    /// calling [TyCtxt::mk_trait_ref].\n+    pub(super) _use_mk_trait_ref_instead: (),\n }\n \n impl<'tcx> TraitRef<'tcx> {\n-    pub fn new(def_id: DefId, substs: SubstsRef<'tcx>) -> TraitRef<'tcx> {\n-        TraitRef { def_id, substs }\n-    }\n-\n-    pub fn with_self_type(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self {\n+    pub fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self {\n         tcx.mk_trait_ref(\n             self.def_id,\n             [self_ty.into()].into_iter().chain(self.substs.iter().skip(1)),\n@@ -833,10 +832,7 @@ impl<'tcx> TraitRef<'tcx> {\n     /// Returns a `TraitRef` of the form `P0: Foo<P1..Pn>` where `Pi`\n     /// are the parameters defined on trait.\n     pub fn identity(tcx: TyCtxt<'tcx>, def_id: DefId) -> Binder<'tcx, TraitRef<'tcx>> {\n-        ty::Binder::dummy(TraitRef {\n-            def_id,\n-            substs: InternalSubsts::identity_for_item(tcx, def_id),\n-        })\n+        ty::Binder::dummy(tcx.mk_trait_ref(def_id, InternalSubsts::identity_for_item(tcx, def_id)))\n     }\n \n     #[inline]\n@@ -850,7 +846,7 @@ impl<'tcx> TraitRef<'tcx> {\n         substs: SubstsRef<'tcx>,\n     ) -> ty::TraitRef<'tcx> {\n         let defs = tcx.generics_of(trait_id);\n-        ty::TraitRef { def_id: trait_id, substs: tcx.intern_substs(&substs[..defs.params.len()]) }\n+        tcx.mk_trait_ref(trait_id, tcx.intern_substs(&substs[..defs.params.len()]))\n     }\n }\n \n@@ -980,8 +976,12 @@ where\n     /// contain any bound vars that would be bound by the\n     /// binder. This is commonly used to 'inject' a value T into a\n     /// different binding level.\n+    #[track_caller]\n     pub fn dummy(value: T) -> Binder<'tcx, T> {\n-        assert!(!value.has_escaping_bound_vars());\n+        assert!(\n+            !value.has_escaping_bound_vars(),\n+            \"`{value:?}` has escaping bound vars, so it cannot be wrapped in a dummy binder.\"\n+        );\n         Binder(value, ty::List::empty())\n     }\n \n@@ -1128,28 +1128,52 @@ impl<'tcx, T> Binder<'tcx, Option<T>> {\n     }\n }\n \n-/// Represents the projection of an associated type. In explicit UFCS\n-/// form this would be written `<T as Trait<..>>::N`.\n+impl<'tcx, T: IntoIterator> Binder<'tcx, T> {\n+    pub fn iter(self) -> impl Iterator<Item = ty::Binder<'tcx, T::Item>> {\n+        let bound_vars = self.1;\n+        self.0.into_iter().map(|v| Binder(v, bound_vars))\n+    }\n+}\n+\n+/// Represents the projection of an associated type.\n+///\n+/// For a projection, this would be `<Ty as Trait<...>>::N`.\n+///\n+/// For an opaque type, there is no explicit syntax.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n-pub struct ProjectionTy<'tcx> {\n-    /// The parameters of the associated item.\n+pub struct AliasTy<'tcx> {\n+    /// The parameters of the associated or opaque item.\n+    ///\n+    /// For a projection, these are the substitutions for the trait and the\n+    /// GAT substitutions, if there are any.\n+    ///\n+    /// For RPIT the substitutions are for the generics of the function,\n+    /// while for TAIT it is used for the generic parameters of the alias.\n     pub substs: SubstsRef<'tcx>,\n \n-    /// The `DefId` of the `TraitItem` for the associated type `N`.\n+    /// The `DefId` of the `TraitItem` for the associated type `N` if this is a projection,\n+    /// or the `OpaqueType` item if this is an opaque.\n     ///\n-    /// Note that this is not the `DefId` of the `TraitRef` containing this\n-    /// associated type, which is in `tcx.associated_item(item_def_id).container`,\n-    /// aka. `tcx.parent(item_def_id).unwrap()`.\n-    pub item_def_id: DefId,\n+    /// During codegen, `tcx.type_of(def_id)` can be used to get the type of the\n+    /// underlying type if the type is an opaque.\n+    ///\n+    /// Note that if this is an associated type, this is not the `DefId` of the\n+    /// `TraitRef` containing this associated type, which is in `tcx.associated_item(def_id).container`,\n+    /// aka. `tcx.parent(def_id)`.\n+    pub def_id: DefId,\n+\n+    /// This field exists to prevent the creation of `ProjectionTy` without using\n+    /// [TyCtxt::mk_alias_ty].\n+    pub(super) _use_mk_alias_ty_instead: (),\n }\n \n-impl<'tcx> ProjectionTy<'tcx> {\n+impl<'tcx> AliasTy<'tcx> {\n     pub fn trait_def_id(&self, tcx: TyCtxt<'tcx>) -> DefId {\n-        match tcx.def_kind(self.item_def_id) {\n-            DefKind::AssocTy | DefKind::AssocConst => tcx.parent(self.item_def_id),\n+        match tcx.def_kind(self.def_id) {\n+            DefKind::AssocTy | DefKind::AssocConst => tcx.parent(self.def_id),\n             DefKind::ImplTraitPlaceholder => {\n-                tcx.parent(tcx.impl_trait_in_trait_parent(self.item_def_id))\n+                tcx.parent(tcx.impl_trait_in_trait_parent(self.def_id))\n             }\n             kind => bug!(\"unexpected DefKind in ProjectionTy: {kind:?}\"),\n         }\n@@ -1162,11 +1186,11 @@ impl<'tcx> ProjectionTy<'tcx> {\n         &self,\n         tcx: TyCtxt<'tcx>,\n     ) -> (ty::TraitRef<'tcx>, &'tcx [ty::GenericArg<'tcx>]) {\n-        let def_id = tcx.parent(self.item_def_id);\n-        assert_eq!(tcx.def_kind(def_id), DefKind::Trait);\n-        let trait_generics = tcx.generics_of(def_id);\n+        debug_assert!(matches!(tcx.def_kind(self.def_id), DefKind::AssocTy | DefKind::AssocConst));\n+        let trait_def_id = self.trait_def_id(tcx);\n+        let trait_generics = tcx.generics_of(trait_def_id);\n         (\n-            ty::TraitRef { def_id, substs: self.substs.truncate_to(tcx, trait_generics) },\n+            tcx.mk_trait_ref(trait_def_id, self.substs.truncate_to(tcx, trait_generics)),\n             &self.substs[trait_generics.count()..],\n         )\n     }\n@@ -1180,7 +1204,7 @@ impl<'tcx> ProjectionTy<'tcx> {\n     /// as well.\n     pub fn trait_ref(&self, tcx: TyCtxt<'tcx>) -> ty::TraitRef<'tcx> {\n         let def_id = self.trait_def_id(tcx);\n-        ty::TraitRef { def_id, substs: self.substs.truncate_to(tcx, tcx.generics_of(def_id)) }\n+        tcx.mk_trait_ref(def_id, self.substs.truncate_to(tcx, tcx.generics_of(def_id)))\n     }\n \n     pub fn self_ty(&self) -> Ty<'tcx> {\n@@ -1394,7 +1418,7 @@ impl From<BoundVar> for BoundTy {\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct ExistentialProjection<'tcx> {\n-    pub item_def_id: DefId,\n+    pub def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n     pub term: Term<'tcx>,\n }\n@@ -1407,7 +1431,7 @@ impl<'tcx> ExistentialProjection<'tcx> {\n     /// then this function would return an `exists T. T: Iterator` existential trait\n     /// reference.\n     pub fn trait_ref(&self, tcx: TyCtxt<'tcx>) -> ty::ExistentialTraitRef<'tcx> {\n-        let def_id = tcx.parent(self.item_def_id);\n+        let def_id = tcx.parent(self.def_id);\n         let subst_count = tcx.generics_of(def_id).count() - 1;\n         let substs = tcx.intern_substs(&self.substs[..subst_count]);\n         ty::ExistentialTraitRef { def_id, substs }\n@@ -1422,10 +1446,8 @@ impl<'tcx> ExistentialProjection<'tcx> {\n         debug_assert!(!self_ty.has_escaping_bound_vars());\n \n         ty::ProjectionPredicate {\n-            projection_ty: ty::ProjectionTy {\n-                item_def_id: self.item_def_id,\n-                substs: tcx.mk_substs_trait(self_ty, self.substs),\n-            },\n+            projection_ty: tcx\n+                .mk_alias_ty(self.def_id, [self_ty.into()].into_iter().chain(self.substs)),\n             term: self.term,\n         }\n     }\n@@ -1438,7 +1460,7 @@ impl<'tcx> ExistentialProjection<'tcx> {\n         projection_predicate.projection_ty.substs.type_at(0);\n \n         Self {\n-            item_def_id: projection_predicate.projection_ty.item_def_id,\n+            def_id: projection_predicate.projection_ty.def_id,\n             substs: tcx.intern_substs(&projection_predicate.projection_ty.substs[1..]),\n             term: projection_predicate.term,\n         }\n@@ -1455,7 +1477,7 @@ impl<'tcx> PolyExistentialProjection<'tcx> {\n     }\n \n     pub fn item_def_id(&self) -> DefId {\n-        self.skip_binder().item_def_id\n+        self.skip_binder().def_id\n     }\n }\n \n@@ -1962,7 +1984,7 @@ impl<'tcx> Ty<'tcx> {\n \n     #[inline]\n     pub fn is_impl_trait(self) -> bool {\n-        matches!(self.kind(), Opaque(..))\n+        matches!(self.kind(), Alias(ty::Opaque, ..))\n     }\n \n     #[inline]\n@@ -2029,7 +2051,7 @@ impl<'tcx> Ty<'tcx> {\n             ty::Adt(adt, _) if adt.is_enum() => adt.repr().discr_type().to_ty(tcx),\n             ty::Generator(_, substs, _) => substs.as_generator().discr_ty(tcx),\n \n-            ty::Param(_) | ty::Projection(_) | ty::Opaque(..) | ty::Infer(ty::TyVar(_)) => {\n+            ty::Param(_) | ty::Alias(..) | ty::Infer(ty::TyVar(_)) => {\n                 let assoc_items = tcx.associated_item_def_ids(\n                     tcx.require_lang_item(hir::LangItem::DiscriminantKind, None),\n                 );\n@@ -2109,7 +2131,7 @@ impl<'tcx> Ty<'tcx> {\n \n             // type parameters only have unit metadata if they're sized, so return true\n             // to make sure we double check this during confirmation\n-            ty::Param(_) |  ty::Projection(_) | ty::Opaque(..) => (tcx.types.unit, true),\n+            ty::Param(_) |  ty::Alias(..) => (tcx.types.unit, true),\n \n             ty::Infer(ty::TyVar(_))\n             | ty::Bound(..)\n@@ -2185,7 +2207,7 @@ impl<'tcx> Ty<'tcx> {\n \n             ty::Adt(def, _substs) => def.sized_constraint(tcx).0.is_empty(),\n \n-            ty::Projection(_) | ty::Param(_) | ty::Opaque(..) => false,\n+            ty::Alias(..) | ty::Param(_) => false,\n \n             ty::Infer(ty::TyVar(_)) => false,\n \n@@ -2241,9 +2263,12 @@ impl<'tcx> Ty<'tcx> {\n             ty::Generator(..) | ty::GeneratorWitness(..) => false,\n \n             // Might be, but not \"trivial\" so just giving the safe answer.\n-            ty::Adt(..) | ty::Closure(..) | ty::Opaque(..) => false,\n+            ty::Adt(..) | ty::Closure(..) => false,\n+\n+            // Needs normalization or revealing to determine, so no is the safe answer.\n+            ty::Alias(..) => false,\n \n-            ty::Projection(..) | ty::Param(..) | ty::Infer(..) | ty::Error(..) => false,\n+            ty::Param(..) | ty::Infer(..) | ty::Error(..) => false,\n \n             ty::Bound(..) | ty::Placeholder(..) => {\n                 bug!(\"`is_trivially_pure_clone_copy` applied to unexpected type: {:?}\", self);"}, {"sha": "f8385c4701605bcc07841ef86b7bb6d6a36c8122", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -252,7 +252,7 @@ impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for GenericArg<'tcx> {\n     }\n }\n \n-/// A substitution mapping generic parameters to new values.\n+/// List of generic arguments that are gonna be used to substitute generic parameters.\n pub type InternalSubsts<'tcx> = List<GenericArg<'tcx>>;\n \n pub type SubstsRef<'tcx> = &'tcx InternalSubsts<'tcx>;"}, {"sha": "4fe85d4366f3e3d3b1027800b906f86797a7c32a", "filename": "compiler/rustc_middle/src/ty/typeck_results.rs", "status": "added", "additions": 689, "deletions": 0, "changes": 689, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -0,0 +1,689 @@\n+use crate::{\n+    hir::place::Place as HirPlace,\n+    infer::canonical::Canonical,\n+    ty::{\n+        self, tls, BindingMode, BoundVar, CanonicalPolyFnSig, ClosureSizeProfileData,\n+        GenericArgKind, InternalSubsts, SubstsRef, Ty, UserSubsts,\n+    },\n+};\n+use rustc_data_structures::{fx::FxHashMap, sync::Lrc, unord::UnordSet, vec_map::VecMap};\n+use rustc_errors::ErrorGuaranteed;\n+use rustc_hir as hir;\n+use rustc_hir::{\n+    def::{DefKind, Res},\n+    def_id::{DefId, LocalDefId, LocalDefIdMap},\n+    hir_id::OwnerId,\n+    HirId, ItemLocalId, ItemLocalMap, ItemLocalSet,\n+};\n+use rustc_index::vec::{Idx, IndexVec};\n+use rustc_macros::HashStable;\n+use rustc_middle::mir::FakeReadCause;\n+use rustc_session::Session;\n+use rustc_span::Span;\n+use std::{\n+    collections::hash_map::{self, Entry},\n+    hash::Hash,\n+    iter,\n+};\n+\n+use super::RvalueScopes;\n+\n+#[derive(TyEncodable, TyDecodable, Debug, HashStable)]\n+pub struct TypeckResults<'tcx> {\n+    /// The `HirId::owner` all `ItemLocalId`s in this table are relative to.\n+    pub hir_owner: OwnerId,\n+\n+    /// Resolved definitions for `<T>::X` associated paths and\n+    /// method calls, including those of overloaded operators.\n+    type_dependent_defs: ItemLocalMap<Result<(DefKind, DefId), ErrorGuaranteed>>,\n+\n+    /// Resolved field indices for field accesses in expressions (`S { field }`, `obj.field`)\n+    /// or patterns (`S { field }`). The index is often useful by itself, but to learn more\n+    /// about the field you also need definition of the variant to which the field\n+    /// belongs, but it may not exist if it's a tuple field (`tuple.0`).\n+    field_indices: ItemLocalMap<usize>,\n+\n+    /// Stores the types for various nodes in the AST. Note that this table\n+    /// is not guaranteed to be populated outside inference. See\n+    /// typeck::check::fn_ctxt for details.\n+    node_types: ItemLocalMap<Ty<'tcx>>,\n+\n+    /// Stores the type parameters which were substituted to obtain the type\n+    /// of this node. This only applies to nodes that refer to entities\n+    /// parameterized by type parameters, such as generic fns, types, or\n+    /// other items.\n+    node_substs: ItemLocalMap<SubstsRef<'tcx>>,\n+\n+    /// This will either store the canonicalized types provided by the user\n+    /// or the substitutions that the user explicitly gave (if any) attached\n+    /// to `id`. These will not include any inferred values. The canonical form\n+    /// is used to capture things like `_` or other unspecified values.\n+    ///\n+    /// For example, if the user wrote `foo.collect::<Vec<_>>()`, then the\n+    /// canonical substitutions would include only `for<X> { Vec<X> }`.\n+    ///\n+    /// See also `AscribeUserType` statement in MIR.\n+    user_provided_types: ItemLocalMap<CanonicalUserType<'tcx>>,\n+\n+    /// Stores the canonicalized types provided by the user. See also\n+    /// `AscribeUserType` statement in MIR.\n+    pub user_provided_sigs: LocalDefIdMap<CanonicalPolyFnSig<'tcx>>,\n+\n+    adjustments: ItemLocalMap<Vec<ty::adjustment::Adjustment<'tcx>>>,\n+\n+    /// Stores the actual binding mode for all instances of hir::BindingAnnotation.\n+    pat_binding_modes: ItemLocalMap<BindingMode>,\n+\n+    /// Stores the types which were implicitly dereferenced in pattern binding modes\n+    /// for later usage in THIR lowering. For example,\n+    ///\n+    /// ```\n+    /// match &&Some(5i32) {\n+    ///     Some(n) => {},\n+    ///     _ => {},\n+    /// }\n+    /// ```\n+    /// leads to a `vec![&&Option<i32>, &Option<i32>]`. Empty vectors are not stored.\n+    ///\n+    /// See:\n+    /// <https://github.com/rust-lang/rfcs/blob/master/text/2005-match-ergonomics.md#definitions>\n+    pat_adjustments: ItemLocalMap<Vec<Ty<'tcx>>>,\n+\n+    /// Records the reasons that we picked the kind of each closure;\n+    /// not all closures are present in the map.\n+    closure_kind_origins: ItemLocalMap<(Span, HirPlace<'tcx>)>,\n+\n+    /// For each fn, records the \"liberated\" types of its arguments\n+    /// and return type. Liberated means that all bound regions\n+    /// (including late-bound regions) are replaced with free\n+    /// equivalents. This table is not used in codegen (since regions\n+    /// are erased there) and hence is not serialized to metadata.\n+    ///\n+    /// This table also contains the \"revealed\" values for any `impl Trait`\n+    /// that appear in the signature and whose values are being inferred\n+    /// by this function.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::fmt::Debug;\n+    /// fn foo(x: &u32) -> impl Debug { *x }\n+    /// ```\n+    ///\n+    /// The function signature here would be:\n+    ///\n+    /// ```ignore (illustrative)\n+    /// for<'a> fn(&'a u32) -> Foo\n+    /// ```\n+    ///\n+    /// where `Foo` is an opaque type created for this function.\n+    ///\n+    ///\n+    /// The *liberated* form of this would be\n+    ///\n+    /// ```ignore (illustrative)\n+    /// fn(&'a u32) -> u32\n+    /// ```\n+    ///\n+    /// Note that `'a` is not bound (it would be an `ReFree`) and\n+    /// that the `Foo` opaque type is replaced by its hidden type.\n+    liberated_fn_sigs: ItemLocalMap<ty::FnSig<'tcx>>,\n+\n+    /// For each FRU expression, record the normalized types of the fields\n+    /// of the struct - this is needed because it is non-trivial to\n+    /// normalize while preserving regions. This table is used only in\n+    /// MIR construction and hence is not serialized to metadata.\n+    fru_field_types: ItemLocalMap<Vec<Ty<'tcx>>>,\n+\n+    /// For every coercion cast we add the HIR node ID of the cast\n+    /// expression to this set.\n+    coercion_casts: ItemLocalSet,\n+\n+    /// Set of trait imports actually used in the method resolution.\n+    /// This is used for warning unused imports. During type\n+    /// checking, this `Lrc` should not be cloned: it must have a ref-count\n+    /// of 1 so that we can insert things into the set mutably.\n+    pub used_trait_imports: Lrc<UnordSet<LocalDefId>>,\n+\n+    /// If any errors occurred while type-checking this body,\n+    /// this field will be set to `Some(ErrorGuaranteed)`.\n+    pub tainted_by_errors: Option<ErrorGuaranteed>,\n+\n+    /// All the opaque types that have hidden types set\n+    /// by this function. We also store the\n+    /// type here, so that mir-borrowck can use it as a hint for figuring out hidden types,\n+    /// even if they are only set in dead code (which doesn't show up in MIR).\n+    pub concrete_opaque_types: VecMap<LocalDefId, ty::OpaqueHiddenType<'tcx>>,\n+\n+    /// Tracks the minimum captures required for a closure;\n+    /// see `MinCaptureInformationMap` for more details.\n+    pub closure_min_captures: ty::MinCaptureInformationMap<'tcx>,\n+\n+    /// Tracks the fake reads required for a closure and the reason for the fake read.\n+    /// When performing pattern matching for closures, there are times we don't end up\n+    /// reading places that are mentioned in a closure (because of _ patterns). However,\n+    /// to ensure the places are initialized, we introduce fake reads.\n+    /// Consider these two examples:\n+    /// ``` (discriminant matching with only wildcard arm)\n+    /// let x: u8;\n+    /// let c = || match x { _ => () };\n+    /// ```\n+    /// In this example, we don't need to actually read/borrow `x` in `c`, and so we don't\n+    /// want to capture it. However, we do still want an error here, because `x` should have\n+    /// to be initialized at the point where c is created. Therefore, we add a \"fake read\"\n+    /// instead.\n+    /// ``` (destructured assignments)\n+    /// let c = || {\n+    ///     let (t1, t2) = t;\n+    /// }\n+    /// ```\n+    /// In the second example, we capture the disjoint fields of `t` (`t.0` & `t.1`), but\n+    /// we never capture `t`. This becomes an issue when we build MIR as we require\n+    /// information on `t` in order to create place `t.0` and `t.1`. We can solve this\n+    /// issue by fake reading `t`.\n+    pub closure_fake_reads: FxHashMap<LocalDefId, Vec<(HirPlace<'tcx>, FakeReadCause, hir::HirId)>>,\n+\n+    /// Tracks the rvalue scoping rules which defines finer scoping for rvalue expressions\n+    /// by applying extended parameter rules.\n+    /// Details may be find in `rustc_hir_analysis::check::rvalue_scopes`.\n+    pub rvalue_scopes: RvalueScopes,\n+\n+    /// Stores the type, expression, span and optional scope span of all types\n+    /// that are live across the yield of this generator (if a generator).\n+    pub generator_interior_types: ty::Binder<'tcx, Vec<GeneratorInteriorTypeCause<'tcx>>>,\n+\n+    /// We sometimes treat byte string literals (which are of type `&[u8; N]`)\n+    /// as `&[u8]`, depending on the pattern  in which they are used.\n+    /// This hashset records all instances where we behave\n+    /// like this to allow `const_to_pat` to reliably handle this situation.\n+    pub treat_byte_string_as_slice: ItemLocalSet,\n+\n+    /// Contains the data for evaluating the effect of feature `capture_disjoint_fields`\n+    /// on closure size.\n+    pub closure_size_eval: FxHashMap<LocalDefId, ClosureSizeProfileData<'tcx>>,\n+}\n+\n+/// Whenever a value may be live across a generator yield, the type of that value winds up in the\n+/// `GeneratorInteriorTypeCause` struct. This struct adds additional information about such\n+/// captured types that can be useful for diagnostics. In particular, it stores the span that\n+/// caused a given type to be recorded, along with the scope that enclosed the value (which can\n+/// be used to find the await that the value is live across).\n+///\n+/// For example:\n+///\n+/// ```ignore (pseudo-Rust)\n+/// async move {\n+///     let x: T = expr;\n+///     foo.await\n+///     ...\n+/// }\n+/// ```\n+///\n+/// Here, we would store the type `T`, the span of the value `x`, the \"scope-span\" for\n+/// the scope that contains `x`, the expr `T` evaluated from, and the span of `foo.await`.\n+#[derive(TyEncodable, TyDecodable, Clone, Debug, Eq, Hash, PartialEq, HashStable)]\n+#[derive(TypeFoldable, TypeVisitable)]\n+pub struct GeneratorInteriorTypeCause<'tcx> {\n+    /// Type of the captured binding.\n+    pub ty: Ty<'tcx>,\n+    /// Span of the binding that was captured.\n+    pub span: Span,\n+    /// Span of the scope of the captured binding.\n+    pub scope_span: Option<Span>,\n+    /// Span of `.await` or `yield` expression.\n+    pub yield_span: Span,\n+    /// Expr which the type evaluated from.\n+    pub expr: Option<hir::HirId>,\n+}\n+\n+// This type holds diagnostic information on generators and async functions across crate boundaries\n+// and is used to provide better error messages\n+#[derive(TyEncodable, TyDecodable, Clone, Debug, HashStable)]\n+pub struct GeneratorDiagnosticData<'tcx> {\n+    pub generator_interior_types: ty::Binder<'tcx, Vec<GeneratorInteriorTypeCause<'tcx>>>,\n+    pub hir_owner: DefId,\n+    pub nodes_types: ItemLocalMap<Ty<'tcx>>,\n+    pub adjustments: ItemLocalMap<Vec<ty::adjustment::Adjustment<'tcx>>>,\n+}\n+\n+impl<'tcx> TypeckResults<'tcx> {\n+    pub fn new(hir_owner: OwnerId) -> TypeckResults<'tcx> {\n+        TypeckResults {\n+            hir_owner,\n+            type_dependent_defs: Default::default(),\n+            field_indices: Default::default(),\n+            user_provided_types: Default::default(),\n+            user_provided_sigs: Default::default(),\n+            node_types: Default::default(),\n+            node_substs: Default::default(),\n+            adjustments: Default::default(),\n+            pat_binding_modes: Default::default(),\n+            pat_adjustments: Default::default(),\n+            closure_kind_origins: Default::default(),\n+            liberated_fn_sigs: Default::default(),\n+            fru_field_types: Default::default(),\n+            coercion_casts: Default::default(),\n+            used_trait_imports: Lrc::new(Default::default()),\n+            tainted_by_errors: None,\n+            concrete_opaque_types: Default::default(),\n+            closure_min_captures: Default::default(),\n+            closure_fake_reads: Default::default(),\n+            rvalue_scopes: Default::default(),\n+            generator_interior_types: ty::Binder::dummy(Default::default()),\n+            treat_byte_string_as_slice: Default::default(),\n+            closure_size_eval: Default::default(),\n+        }\n+    }\n+\n+    /// Returns the final resolution of a `QPath` in an `Expr` or `Pat` node.\n+    pub fn qpath_res(&self, qpath: &hir::QPath<'_>, id: hir::HirId) -> Res {\n+        match *qpath {\n+            hir::QPath::Resolved(_, ref path) => path.res,\n+            hir::QPath::TypeRelative(..) | hir::QPath::LangItem(..) => self\n+                .type_dependent_def(id)\n+                .map_or(Res::Err, |(kind, def_id)| Res::Def(kind, def_id)),\n+        }\n+    }\n+\n+    pub fn type_dependent_defs(\n+        &self,\n+    ) -> LocalTableInContext<'_, Result<(DefKind, DefId), ErrorGuaranteed>> {\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.type_dependent_defs }\n+    }\n+\n+    pub fn type_dependent_def(&self, id: HirId) -> Option<(DefKind, DefId)> {\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n+        self.type_dependent_defs.get(&id.local_id).cloned().and_then(|r| r.ok())\n+    }\n+\n+    pub fn type_dependent_def_id(&self, id: HirId) -> Option<DefId> {\n+        self.type_dependent_def(id).map(|(_, def_id)| def_id)\n+    }\n+\n+    pub fn type_dependent_defs_mut(\n+        &mut self,\n+    ) -> LocalTableInContextMut<'_, Result<(DefKind, DefId), ErrorGuaranteed>> {\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.type_dependent_defs }\n+    }\n+\n+    pub fn field_indices(&self) -> LocalTableInContext<'_, usize> {\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.field_indices }\n+    }\n+\n+    pub fn field_indices_mut(&mut self) -> LocalTableInContextMut<'_, usize> {\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.field_indices }\n+    }\n+\n+    pub fn field_index(&self, id: hir::HirId) -> usize {\n+        self.field_indices().get(id).cloned().expect(\"no index for a field\")\n+    }\n+\n+    pub fn opt_field_index(&self, id: hir::HirId) -> Option<usize> {\n+        self.field_indices().get(id).cloned()\n+    }\n+\n+    pub fn user_provided_types(&self) -> LocalTableInContext<'_, CanonicalUserType<'tcx>> {\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.user_provided_types }\n+    }\n+\n+    pub fn user_provided_types_mut(\n+        &mut self,\n+    ) -> LocalTableInContextMut<'_, CanonicalUserType<'tcx>> {\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.user_provided_types }\n+    }\n+\n+    pub fn node_types(&self) -> LocalTableInContext<'_, Ty<'tcx>> {\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.node_types }\n+    }\n+\n+    pub fn node_types_mut(&mut self) -> LocalTableInContextMut<'_, Ty<'tcx>> {\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.node_types }\n+    }\n+\n+    pub fn get_generator_diagnostic_data(&self) -> GeneratorDiagnosticData<'tcx> {\n+        let generator_interior_type = self.generator_interior_types.map_bound_ref(|vec| {\n+            vec.iter()\n+                .map(|item| {\n+                    GeneratorInteriorTypeCause {\n+                        ty: item.ty,\n+                        span: item.span,\n+                        scope_span: item.scope_span,\n+                        yield_span: item.yield_span,\n+                        expr: None, //FIXME: Passing expression over crate boundaries is impossible at the moment\n+                    }\n+                })\n+                .collect::<Vec<_>>()\n+        });\n+        GeneratorDiagnosticData {\n+            generator_interior_types: generator_interior_type,\n+            hir_owner: self.hir_owner.to_def_id(),\n+            nodes_types: self.node_types.clone(),\n+            adjustments: self.adjustments.clone(),\n+        }\n+    }\n+\n+    pub fn node_type(&self, id: hir::HirId) -> Ty<'tcx> {\n+        self.node_type_opt(id).unwrap_or_else(|| {\n+            bug!(\"node_type: no type for node `{}`\", tls::with(|tcx| tcx.hir().node_to_string(id)))\n+        })\n+    }\n+\n+    pub fn node_type_opt(&self, id: hir::HirId) -> Option<Ty<'tcx>> {\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n+        self.node_types.get(&id.local_id).cloned()\n+    }\n+\n+    pub fn node_substs_mut(&mut self) -> LocalTableInContextMut<'_, SubstsRef<'tcx>> {\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.node_substs }\n+    }\n+\n+    pub fn node_substs(&self, id: hir::HirId) -> SubstsRef<'tcx> {\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n+        self.node_substs.get(&id.local_id).cloned().unwrap_or_else(|| InternalSubsts::empty())\n+    }\n+\n+    pub fn node_substs_opt(&self, id: hir::HirId) -> Option<SubstsRef<'tcx>> {\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n+        self.node_substs.get(&id.local_id).cloned()\n+    }\n+\n+    /// Returns the type of a pattern as a monotype. Like [`expr_ty`], this function\n+    /// doesn't provide type parameter substitutions.\n+    ///\n+    /// [`expr_ty`]: TypeckResults::expr_ty\n+    pub fn pat_ty(&self, pat: &hir::Pat<'_>) -> Ty<'tcx> {\n+        self.node_type(pat.hir_id)\n+    }\n+\n+    /// Returns the type of an expression as a monotype.\n+    ///\n+    /// NB (1): This is the PRE-ADJUSTMENT TYPE for the expression.  That is, in\n+    /// some cases, we insert `Adjustment` annotations such as auto-deref or\n+    /// auto-ref.  The type returned by this function does not consider such\n+    /// adjustments.  See `expr_ty_adjusted()` instead.\n+    ///\n+    /// NB (2): This type doesn't provide type parameter substitutions; e.g., if you\n+    /// ask for the type of `id` in `id(3)`, it will return `fn(&isize) -> isize`\n+    /// instead of `fn(ty) -> T with T = isize`.\n+    pub fn expr_ty(&self, expr: &hir::Expr<'_>) -> Ty<'tcx> {\n+        self.node_type(expr.hir_id)\n+    }\n+\n+    pub fn expr_ty_opt(&self, expr: &hir::Expr<'_>) -> Option<Ty<'tcx>> {\n+        self.node_type_opt(expr.hir_id)\n+    }\n+\n+    pub fn adjustments(&self) -> LocalTableInContext<'_, Vec<ty::adjustment::Adjustment<'tcx>>> {\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.adjustments }\n+    }\n+\n+    pub fn adjustments_mut(\n+        &mut self,\n+    ) -> LocalTableInContextMut<'_, Vec<ty::adjustment::Adjustment<'tcx>>> {\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.adjustments }\n+    }\n+\n+    pub fn expr_adjustments(&self, expr: &hir::Expr<'_>) -> &[ty::adjustment::Adjustment<'tcx>] {\n+        validate_hir_id_for_typeck_results(self.hir_owner, expr.hir_id);\n+        self.adjustments.get(&expr.hir_id.local_id).map_or(&[], |a| &a[..])\n+    }\n+\n+    /// Returns the type of `expr`, considering any `Adjustment`\n+    /// entry recorded for that expression.\n+    pub fn expr_ty_adjusted(&self, expr: &hir::Expr<'_>) -> Ty<'tcx> {\n+        self.expr_adjustments(expr).last().map_or_else(|| self.expr_ty(expr), |adj| adj.target)\n+    }\n+\n+    pub fn expr_ty_adjusted_opt(&self, expr: &hir::Expr<'_>) -> Option<Ty<'tcx>> {\n+        self.expr_adjustments(expr).last().map(|adj| adj.target).or_else(|| self.expr_ty_opt(expr))\n+    }\n+\n+    pub fn is_method_call(&self, expr: &hir::Expr<'_>) -> bool {\n+        // Only paths and method calls/overloaded operators have\n+        // entries in type_dependent_defs, ignore the former here.\n+        if let hir::ExprKind::Path(_) = expr.kind {\n+            return false;\n+        }\n+\n+        matches!(self.type_dependent_defs().get(expr.hir_id), Some(Ok((DefKind::AssocFn, _))))\n+    }\n+\n+    pub fn extract_binding_mode(&self, s: &Session, id: HirId, sp: Span) -> Option<BindingMode> {\n+        self.pat_binding_modes().get(id).copied().or_else(|| {\n+            s.delay_span_bug(sp, \"missing binding mode\");\n+            None\n+        })\n+    }\n+\n+    pub fn pat_binding_modes(&self) -> LocalTableInContext<'_, BindingMode> {\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.pat_binding_modes }\n+    }\n+\n+    pub fn pat_binding_modes_mut(&mut self) -> LocalTableInContextMut<'_, BindingMode> {\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.pat_binding_modes }\n+    }\n+\n+    pub fn pat_adjustments(&self) -> LocalTableInContext<'_, Vec<Ty<'tcx>>> {\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.pat_adjustments }\n+    }\n+\n+    pub fn pat_adjustments_mut(&mut self) -> LocalTableInContextMut<'_, Vec<Ty<'tcx>>> {\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.pat_adjustments }\n+    }\n+\n+    /// For a given closure, returns the iterator of `ty::CapturedPlace`s that are captured\n+    /// by the closure.\n+    pub fn closure_min_captures_flattened(\n+        &self,\n+        closure_def_id: LocalDefId,\n+    ) -> impl Iterator<Item = &ty::CapturedPlace<'tcx>> {\n+        self.closure_min_captures\n+            .get(&closure_def_id)\n+            .map(|closure_min_captures| closure_min_captures.values().flat_map(|v| v.iter()))\n+            .into_iter()\n+            .flatten()\n+    }\n+\n+    pub fn closure_kind_origins(&self) -> LocalTableInContext<'_, (Span, HirPlace<'tcx>)> {\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.closure_kind_origins }\n+    }\n+\n+    pub fn closure_kind_origins_mut(\n+        &mut self,\n+    ) -> LocalTableInContextMut<'_, (Span, HirPlace<'tcx>)> {\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.closure_kind_origins }\n+    }\n+\n+    pub fn liberated_fn_sigs(&self) -> LocalTableInContext<'_, ty::FnSig<'tcx>> {\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.liberated_fn_sigs }\n+    }\n+\n+    pub fn liberated_fn_sigs_mut(&mut self) -> LocalTableInContextMut<'_, ty::FnSig<'tcx>> {\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.liberated_fn_sigs }\n+    }\n+\n+    pub fn fru_field_types(&self) -> LocalTableInContext<'_, Vec<Ty<'tcx>>> {\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.fru_field_types }\n+    }\n+\n+    pub fn fru_field_types_mut(&mut self) -> LocalTableInContextMut<'_, Vec<Ty<'tcx>>> {\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.fru_field_types }\n+    }\n+\n+    pub fn is_coercion_cast(&self, hir_id: hir::HirId) -> bool {\n+        validate_hir_id_for_typeck_results(self.hir_owner, hir_id);\n+        self.coercion_casts.contains(&hir_id.local_id)\n+    }\n+\n+    pub fn set_coercion_cast(&mut self, id: ItemLocalId) {\n+        self.coercion_casts.insert(id);\n+    }\n+\n+    pub fn coercion_casts(&self) -> &ItemLocalSet {\n+        &self.coercion_casts\n+    }\n+}\n+\n+/// Validate that the given HirId (respectively its `local_id` part) can be\n+/// safely used as a key in the maps of a TypeckResults. For that to be\n+/// the case, the HirId must have the same `owner` as all the other IDs in\n+/// this table (signified by `hir_owner`). Otherwise the HirId\n+/// would be in a different frame of reference and using its `local_id`\n+/// would result in lookup errors, or worse, in silently wrong data being\n+/// stored/returned.\n+#[inline]\n+fn validate_hir_id_for_typeck_results(hir_owner: OwnerId, hir_id: hir::HirId) {\n+    if hir_id.owner != hir_owner {\n+        invalid_hir_id_for_typeck_results(hir_owner, hir_id);\n+    }\n+}\n+\n+#[cold]\n+#[inline(never)]\n+fn invalid_hir_id_for_typeck_results(hir_owner: OwnerId, hir_id: hir::HirId) {\n+    ty::tls::with(|tcx| {\n+        bug!(\n+            \"node {} with HirId::owner {:?} cannot be placed in TypeckResults with hir_owner {:?}\",\n+            tcx.hir().node_to_string(hir_id),\n+            hir_id.owner,\n+            hir_owner\n+        )\n+    });\n+}\n+\n+pub struct LocalTableInContext<'a, V> {\n+    hir_owner: OwnerId,\n+    data: &'a ItemLocalMap<V>,\n+}\n+\n+impl<'a, V> LocalTableInContext<'a, V> {\n+    pub fn contains_key(&self, id: hir::HirId) -> bool {\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n+        self.data.contains_key(&id.local_id)\n+    }\n+\n+    pub fn get(&self, id: hir::HirId) -> Option<&V> {\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n+        self.data.get(&id.local_id)\n+    }\n+\n+    pub fn iter(&self) -> hash_map::Iter<'_, hir::ItemLocalId, V> {\n+        self.data.iter()\n+    }\n+}\n+\n+impl<'a, V> ::std::ops::Index<hir::HirId> for LocalTableInContext<'a, V> {\n+    type Output = V;\n+\n+    fn index(&self, key: hir::HirId) -> &V {\n+        self.get(key).expect(\"LocalTableInContext: key not found\")\n+    }\n+}\n+\n+pub struct LocalTableInContextMut<'a, V> {\n+    hir_owner: OwnerId,\n+    data: &'a mut ItemLocalMap<V>,\n+}\n+\n+impl<'a, V> LocalTableInContextMut<'a, V> {\n+    pub fn get_mut(&mut self, id: hir::HirId) -> Option<&mut V> {\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n+        self.data.get_mut(&id.local_id)\n+    }\n+\n+    pub fn entry(&mut self, id: hir::HirId) -> Entry<'_, hir::ItemLocalId, V> {\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n+        self.data.entry(id.local_id)\n+    }\n+\n+    pub fn insert(&mut self, id: hir::HirId, val: V) -> Option<V> {\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n+        self.data.insert(id.local_id, val)\n+    }\n+\n+    pub fn remove(&mut self, id: hir::HirId) -> Option<V> {\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n+        self.data.remove(&id.local_id)\n+    }\n+}\n+\n+rustc_index::newtype_index! {\n+    pub struct UserTypeAnnotationIndex {\n+        derive [HashStable]\n+        DEBUG_FORMAT = \"UserType({})\",\n+        const START_INDEX = 0,\n+    }\n+}\n+\n+/// Mapping of type annotation indices to canonical user type annotations.\n+pub type CanonicalUserTypeAnnotations<'tcx> =\n+    IndexVec<UserTypeAnnotationIndex, CanonicalUserTypeAnnotation<'tcx>>;\n+\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable, Lift)]\n+pub struct CanonicalUserTypeAnnotation<'tcx> {\n+    pub user_ty: Box<CanonicalUserType<'tcx>>,\n+    pub span: Span,\n+    pub inferred_ty: Ty<'tcx>,\n+}\n+\n+/// Canonicalized user type annotation.\n+pub type CanonicalUserType<'tcx> = Canonical<'tcx, UserType<'tcx>>;\n+\n+impl<'tcx> CanonicalUserType<'tcx> {\n+    /// Returns `true` if this represents a substitution of the form `[?0, ?1, ?2]`,\n+    /// i.e., each thing is mapped to a canonical variable with the same index.\n+    pub fn is_identity(&self) -> bool {\n+        match self.value {\n+            UserType::Ty(_) => false,\n+            UserType::TypeOf(_, user_substs) => {\n+                if user_substs.user_self_ty.is_some() {\n+                    return false;\n+                }\n+\n+                iter::zip(user_substs.substs, BoundVar::new(0)..).all(|(kind, cvar)| {\n+                    match kind.unpack() {\n+                        GenericArgKind::Type(ty) => match ty.kind() {\n+                            ty::Bound(debruijn, b) => {\n+                                // We only allow a `ty::INNERMOST` index in substitutions.\n+                                assert_eq!(*debruijn, ty::INNERMOST);\n+                                cvar == b.var\n+                            }\n+                            _ => false,\n+                        },\n+\n+                        GenericArgKind::Lifetime(r) => match *r {\n+                            ty::ReLateBound(debruijn, br) => {\n+                                // We only allow a `ty::INNERMOST` index in substitutions.\n+                                assert_eq!(debruijn, ty::INNERMOST);\n+                                cvar == br.var\n+                            }\n+                            _ => false,\n+                        },\n+\n+                        GenericArgKind::Const(ct) => match ct.kind() {\n+                            ty::ConstKind::Bound(debruijn, b) => {\n+                                // We only allow a `ty::INNERMOST` index in substitutions.\n+                                assert_eq!(debruijn, ty::INNERMOST);\n+                                cvar == b\n+                            }\n+                            _ => false,\n+                        },\n+                    }\n+                })\n+            }\n+        }\n+    }\n+}\n+\n+/// A user-given type annotation attached to a constant. These arise\n+/// from constants that are named via paths, like `Foo::<A>::new` and\n+/// so forth.\n+#[derive(Copy, Clone, Debug, PartialEq, TyEncodable, TyDecodable)]\n+#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n+pub enum UserType<'tcx> {\n+    Ty(Ty<'tcx>),\n+\n+    /// The canonical type is the result of `type_of(def_id)` with the\n+    /// given substitutions applied.\n+    TypeOf(DefId, UserSubsts<'tcx>),\n+}"}, {"sha": "857f52c8a245612ddc9d164207681e8c15a7f4aa", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -259,7 +259,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n                 ty::Tuple(_) => break,\n \n-                ty::Projection(_) | ty::Opaque(..) => {\n+                ty::Alias(..) => {\n                     let normalized = normalize(ty);\n                     if ty == normalized {\n                         return ty;\n@@ -332,8 +332,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                         break;\n                     }\n                 }\n-                (ty::Projection(_) | ty::Opaque(..), _)\n-                | (_, ty::Projection(_) | ty::Opaque(..)) => {\n+                (ty::Alias(..), _) | (_, ty::Alias(..)) => {\n                     // If either side is a projection, attempt to\n                     // progress via normalization. (Should be safe to\n                     // apply to both sides as normalization is\n@@ -826,7 +825,7 @@ impl<'tcx> TypeFolder<'tcx> for OpaqueTypeExpander<'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if let ty::Opaque(def_id, substs) = *t.kind() {\n+        if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) = *t.kind() {\n             self.expand_opaque_ty(def_id, substs).unwrap_or(t)\n         } else if t.has_opaque_types() {\n             t.super_fold_with(self)\n@@ -938,10 +937,9 @@ impl<'tcx> Ty<'tcx> {\n             | ty::Generator(..)\n             | ty::GeneratorWitness(_)\n             | ty::Infer(_)\n-            | ty::Opaque(..)\n+            | ty::Alias(..)\n             | ty::Param(_)\n-            | ty::Placeholder(_)\n-            | ty::Projection(_) => false,\n+            | ty::Placeholder(_) => false,\n         }\n     }\n \n@@ -978,10 +976,9 @@ impl<'tcx> Ty<'tcx> {\n             | ty::Generator(..)\n             | ty::GeneratorWitness(_)\n             | ty::Infer(_)\n-            | ty::Opaque(..)\n+            | ty::Alias(..)\n             | ty::Param(_)\n-            | ty::Placeholder(_)\n-            | ty::Projection(_) => false,\n+            | ty::Placeholder(_) => false,\n         }\n     }\n \n@@ -1101,12 +1098,9 @@ impl<'tcx> Ty<'tcx> {\n             //\n             // FIXME(ecstaticmorse): Maybe we should `bug` here? This should probably only be\n             // called for known, fully-monomorphized types.\n-            ty::Projection(_)\n-            | ty::Opaque(..)\n-            | ty::Param(_)\n-            | ty::Bound(..)\n-            | ty::Placeholder(_)\n-            | ty::Infer(_) => false,\n+            ty::Alias(..) | ty::Param(_) | ty::Bound(..) | ty::Placeholder(_) | ty::Infer(_) => {\n+                false\n+            }\n \n             ty::Foreign(_) | ty::GeneratorWitness(..) | ty::Error(_) => false,\n         }\n@@ -1237,11 +1231,10 @@ pub fn needs_drop_components<'tcx>(\n \n         // These require checking for `Copy` bounds or `Adt` destructors.\n         ty::Adt(..)\n-        | ty::Projection(..)\n+        | ty::Alias(..)\n         | ty::Param(_)\n         | ty::Bound(..)\n         | ty::Placeholder(..)\n-        | ty::Opaque(..)\n         | ty::Infer(_)\n         | ty::Closure(..)\n         | ty::Generator(..) => Ok(smallvec![ty]),\n@@ -1265,13 +1258,12 @@ pub fn is_trivially_const_drop<'tcx>(ty: Ty<'tcx>) -> bool {\n         | ty::Never\n         | ty::Foreign(_) => true,\n \n-        ty::Opaque(..)\n+        ty::Alias(..)\n         | ty::Dynamic(..)\n         | ty::Error(_)\n         | ty::Bound(..)\n         | ty::Param(_)\n         | ty::Placeholder(_)\n-        | ty::Projection(_)\n         | ty::Infer(_) => false,\n \n         // Not trivial because they have components, and instead of looking inside,"}, {"sha": "b302572f3cabdf3db89d88a04f8d3ba38e065f2b", "filename": "compiler/rustc_middle/src/ty/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -654,7 +654,7 @@ impl<'tcx> TypeVisitor<'tcx> for LateBoundRegionsCollector {\n         // ignore the inputs to a projection, as they may not appear\n         // in the normalized form\n         if self.just_constrained {\n-            if let ty::Projection(..) | ty::Opaque(..) = t.kind() {\n+            if let ty::Alias(..) = t.kind() {\n                 return ControlFlow::CONTINUE;\n             }\n         }"}, {"sha": "802925dfb043e3eafb4f70304a50cf359f0cb78b", "filename": "compiler/rustc_middle/src/ty/vtable.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,4 +1,3 @@\n-use std::convert::TryFrom;\n use std::fmt;\n \n use crate::mir::interpret::{alloc_range, AllocId, Allocation, Pointer, Scalar};"}, {"sha": "34dbb6e9f68ea1cf6fe295448322edf3f532cea9", "filename": "compiler/rustc_middle/src/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -165,7 +165,7 @@ fn push_inner<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent: GenericArg<'tcx>)\n                 stack.push(ty.into());\n                 stack.push(lt.into());\n             }\n-            ty::Projection(data) => {\n+            ty::Alias(_, data) => {\n                 stack.extend(data.substs.iter().rev());\n             }\n             ty::Dynamic(obj, lt, _) => {\n@@ -188,7 +188,6 @@ fn push_inner<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent: GenericArg<'tcx>)\n                 }));\n             }\n             ty::Adt(_, substs)\n-            | ty::Opaque(_, substs)\n             | ty::Closure(_, substs)\n             | ty::Generator(_, substs, _)\n             | ty::FnDef(_, substs) => {"}, {"sha": "2643d33cee00abde2688faf2b4f25186ff8ccf6b", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -231,7 +231,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                         remainder_span,\n                                         pattern,\n                                         None,\n-                                        Some((None, initializer_span)),\n+                                        Some((Some(&destination), initializer_span)),\n                                     );\n                                     this.visit_primary_bindings(\n                                         pattern,\n@@ -373,7 +373,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // the case of `!`, no return value is required, as the block will never return.\n             // Opaque types of empty bodies also need this unit assignment, in order to infer that their\n             // type is actually unit. Otherwise there will be no defining use found in the MIR.\n-            if destination_ty.is_unit() || matches!(destination_ty.kind(), ty::Opaque(..)) {\n+            if destination_ty.is_unit()\n+                || matches!(destination_ty.kind(), ty::Alias(ty::Opaque, ..))\n+            {\n                 // We only want to assign an implicit `()` as the return value of the block if the\n                 // block does not diverge. (Otherwise, we may try to assign a unit to a `!`-type.)\n                 this.cfg.push_assign_unit(block, source_info, destination, this.tcx);"}, {"sha": "34fefb99e09c25c1b034a2f431ce38dafbf3e39c", "filename": "compiler/rustc_mir_build/src/build/custom/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -20,11 +20,12 @@\n use rustc_ast::Attribute;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::DefId;\n+use rustc_hir::HirId;\n use rustc_index::vec::IndexVec;\n use rustc_middle::{\n     mir::*,\n     thir::*,\n-    ty::{Ty, TyCtxt},\n+    ty::{ParamEnv, Ty, TyCtxt},\n };\n use rustc_span::Span;\n \n@@ -33,6 +34,7 @@ mod parse;\n pub(super) fn build_custom_mir<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     did: DefId,\n+    hir_id: HirId,\n     thir: &Thir<'tcx>,\n     expr: ExprId,\n     params: &IndexVec<ParamId, Param<'tcx>>,\n@@ -67,12 +69,16 @@ pub(super) fn build_custom_mir<'tcx>(\n         parent_scope: None,\n         inlined: None,\n         inlined_parent_scope: None,\n-        local_data: ClearCrossCrate::Clear,\n+        local_data: ClearCrossCrate::Set(SourceScopeLocalData {\n+            lint_root: hir_id,\n+            safety: Safety::Safe,\n+        }),\n     });\n     body.injection_phase = Some(parse_attribute(attr));\n \n     let mut pctxt = ParseCtxt {\n         tcx,\n+        param_env: tcx.param_env(did),\n         thir,\n         source_scope: OUTERMOST_SOURCE_SCOPE,\n         body: &mut body,\n@@ -127,6 +133,7 @@ fn parse_attribute(attr: &Attribute) -> MirPhase {\n \n struct ParseCtxt<'tcx, 'body> {\n     tcx: TyCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n     thir: &'body Thir<'tcx>,\n     source_scope: SourceScope,\n "}, {"sha": "2f26499a3b6e937c8acc0a1bfb2bdc48ba855b05", "filename": "compiler/rustc_mir_build/src/build/custom/parse/instruction.rs", "status": "modified", "additions": 106, "deletions": 8, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,5 +1,11 @@\n use rustc_middle::mir::interpret::{ConstValue, Scalar};\n+use rustc_middle::mir::tcx::PlaceTy;\n use rustc_middle::{mir::*, thir::*, ty};\n+use rustc_span::Span;\n+use rustc_target::abi::VariantIdx;\n+\n+use crate::build::custom::ParseError;\n+use crate::build::expr::as_constant::as_constant_inner;\n \n use super::{parse_by_kind, PResult, ParseCtxt};\n \n@@ -12,6 +18,14 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n             @call(\"mir_retag_raw\", args) => {\n                 Ok(StatementKind::Retag(RetagKind::Raw, Box::new(self.parse_place(args[0])?)))\n             },\n+            @call(\"mir_set_discriminant\", args) => {\n+                let place = self.parse_place(args[0])?;\n+                let var = self.parse_integer_literal(args[1])? as u32;\n+                Ok(StatementKind::SetDiscriminant {\n+                    place: Box::new(place),\n+                    variant_index: VariantIdx::from_u32(var),\n+                })\n+            },\n             ExprKind::Assign { lhs, rhs } => {\n                 let lhs = self.parse_place(*lhs)?;\n                 let rhs = self.parse_rvalue(*rhs)?;\n@@ -21,18 +35,60 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n     }\n \n     pub fn parse_terminator(&self, expr_id: ExprId) -> PResult<TerminatorKind<'tcx>> {\n-        parse_by_kind!(self, expr_id, _, \"terminator\",\n+        parse_by_kind!(self, expr_id, expr, \"terminator\",\n             @call(\"mir_return\", _args) => {\n                 Ok(TerminatorKind::Return)\n             },\n             @call(\"mir_goto\", args) => {\n                 Ok(TerminatorKind::Goto { target: self.parse_block(args[0])? } )\n             },\n+            ExprKind::Match { scrutinee, arms } => {\n+                let discr = self.parse_operand(*scrutinee)?;\n+                self.parse_match(arms, expr.span).map(|t| TerminatorKind::SwitchInt { discr, targets: t })\n+            },\n         )\n     }\n \n+    fn parse_match(&self, arms: &[ArmId], span: Span) -> PResult<SwitchTargets> {\n+        let Some((otherwise, rest)) = arms.split_last() else {\n+            return Err(ParseError {\n+                span,\n+                item_description: format!(\"no arms\"),\n+                expected: \"at least one arm\".to_string(),\n+            })\n+        };\n+\n+        let otherwise = &self.thir[*otherwise];\n+        let PatKind::Wild = otherwise.pattern.kind else {\n+            return Err(ParseError {\n+                span: otherwise.span,\n+                item_description: format!(\"{:?}\", otherwise.pattern.kind),\n+                expected: \"wildcard pattern\".to_string(),\n+            })\n+        };\n+        let otherwise = self.parse_block(otherwise.body)?;\n+\n+        let mut values = Vec::new();\n+        let mut targets = Vec::new();\n+        for arm in rest {\n+            let arm = &self.thir[*arm];\n+            let PatKind::Constant { value } = arm.pattern.kind else {\n+                return Err(ParseError {\n+                    span: arm.pattern.span,\n+                    item_description: format!(\"{:?}\", arm.pattern.kind),\n+                    expected: \"constant pattern\".to_string(),\n+                })\n+            };\n+            values.push(value.eval_bits(self.tcx, self.param_env, arm.pattern.ty));\n+            targets.push(self.parse_block(arm.body)?);\n+        }\n+\n+        Ok(SwitchTargets::new(values.into_iter().zip(targets), otherwise))\n+    }\n+\n     fn parse_rvalue(&self, expr_id: ExprId) -> PResult<Rvalue<'tcx>> {\n         parse_by_kind!(self, expr_id, _, \"rvalue\",\n+            @call(\"mir_discriminant\", args) => self.parse_place(args[0]).map(Rvalue::Discriminant),\n             ExprKind::Borrow { borrow_kind, arg } => Ok(\n                 Rvalue::Ref(self.tcx.lifetimes.re_erased, *borrow_kind, self.parse_place(*arg)?)\n             ),\n@@ -55,20 +111,50 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n             | ExprKind::ConstParam { .. }\n             | ExprKind::ConstBlock { .. } => {\n                 Ok(Operand::Constant(Box::new(\n-                    crate::build::expr::as_constant::as_constant_inner(expr, |_| None, self.tcx)\n+                    as_constant_inner(expr, |_| None, self.tcx)\n                 )))\n             },\n             _ => self.parse_place(expr_id).map(Operand::Copy),\n         )\n     }\n \n     fn parse_place(&self, expr_id: ExprId) -> PResult<Place<'tcx>> {\n-        parse_by_kind!(self, expr_id, _, \"place\",\n-            ExprKind::Deref { arg } => Ok(\n-                self.parse_place(*arg)?.project_deeper(&[PlaceElem::Deref], self.tcx)\n-            ),\n-            _ => self.parse_local(expr_id).map(Place::from),\n-        )\n+        self.parse_place_inner(expr_id).map(|(x, _)| x)\n+    }\n+\n+    fn parse_place_inner(&self, expr_id: ExprId) -> PResult<(Place<'tcx>, PlaceTy<'tcx>)> {\n+        let (parent, proj) = parse_by_kind!(self, expr_id, expr, \"place\",\n+            @call(\"mir_field\", args) => {\n+                let (parent, ty) = self.parse_place_inner(args[0])?;\n+                let field = Field::from_u32(self.parse_integer_literal(args[1])? as u32);\n+                let field_ty = ty.field_ty(self.tcx, field);\n+                let proj = PlaceElem::Field(field, field_ty);\n+                let place = parent.project_deeper(&[proj], self.tcx);\n+                return Ok((place, PlaceTy::from_ty(field_ty)));\n+            },\n+            @call(\"mir_variant\", args) => {\n+                (args[0], PlaceElem::Downcast(\n+                    None,\n+                    VariantIdx::from_u32(self.parse_integer_literal(args[1])? as u32)\n+                ))\n+            },\n+            ExprKind::Deref { arg } => {\n+                parse_by_kind!(self, *arg, _, \"does not matter\",\n+                    @call(\"mir_make_place\", args) => return self.parse_place_inner(args[0]),\n+                    _ => (*arg, PlaceElem::Deref),\n+                )\n+            },\n+            ExprKind::Index { lhs, index } => (*lhs, PlaceElem::Index(self.parse_local(*index)?)),\n+            ExprKind::Field { lhs, name: field, .. } => (*lhs, PlaceElem::Field(*field, expr.ty)),\n+            _ => {\n+                let place = self.parse_local(expr_id).map(Place::from)?;\n+                return Ok((place, PlaceTy::from_ty(expr.ty)))\n+            },\n+        );\n+        let (parent, ty) = self.parse_place_inner(parent)?;\n+        let place = parent.project_deeper(&[proj], self.tcx);\n+        let ty = ty.projection_ty(self.tcx, proj);\n+        Ok((place, ty))\n     }\n \n     fn parse_local(&self, expr_id: ExprId) -> PResult<Local> {\n@@ -102,4 +188,16 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n             },\n         )\n     }\n+\n+    fn parse_integer_literal(&self, expr_id: ExprId) -> PResult<u128> {\n+        parse_by_kind!(self, expr_id, expr, \"constant\",\n+            ExprKind::Literal { .. }\n+            | ExprKind::NamedConst { .. }\n+            | ExprKind::NonHirLiteral { .. }\n+            | ExprKind::ConstBlock { .. } => Ok({\n+                let value = as_constant_inner(expr, |_| None, self.tcx);\n+                value.literal.eval_bits(self.tcx, self.param_env, value.ty())\n+            }),\n+        )\n+    }\n }"}, {"sha": "3b7ed818dc9b7eb7cd88630d60e63e0fa86ad22d", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -135,14 +135,14 @@ pub(crate) fn lit_to_mir_constant<'tcx>(\n             let allocation = tcx.intern_const_alloc(allocation);\n             ConstValue::Slice { data: allocation, start: 0, end: s.len() }\n         }\n-        (ast::LitKind::ByteStr(data), ty::Ref(_, inner_ty, _))\n+        (ast::LitKind::ByteStr(data, _), ty::Ref(_, inner_ty, _))\n             if matches!(inner_ty.kind(), ty::Slice(_)) =>\n         {\n             let allocation = Allocation::from_bytes_byte_aligned_immutable(data as &[u8]);\n             let allocation = tcx.intern_const_alloc(allocation);\n             ConstValue::Slice { data: allocation, start: 0, end: data.len() }\n         }\n-        (ast::LitKind::ByteStr(data), ty::Ref(_, inner_ty, _)) if inner_ty.is_array() => {\n+        (ast::LitKind::ByteStr(data, _), ty::Ref(_, inner_ty, _)) if inner_ty.is_array() => {\n             let id = tcx.allocate_bytes(data);\n             ConstValue::Scalar(Scalar::from_pointer(id.into(), &tcx))\n         }"}, {"sha": "c7b3eb44dc5fb52318b716a2d1c53ce3ae483b10", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -142,7 +142,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let exchange_malloc = Operand::function_handle(\n                     tcx,\n                     tcx.require_lang_item(LangItem::ExchangeMalloc, Some(expr_span)),\n-                    ty::List::empty(),\n+                    [],\n                     expr_span,\n                 );\n                 let storage = this.temp(tcx.mk_mut_ptr(tcx.types.u8), expr_span);"}, {"sha": "e9f327978aab1f0ac0617bafe6f3d85af4b31251", "filename": "compiler/rustc_mir_build/src/build/expr/stmt.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -6,10 +6,8 @@ use rustc_middle::thir::*;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Builds a block of MIR statements to evaluate the THIR `expr`.\n-    /// If the original expression was an AST statement,\n-    /// (e.g., `some().code(&here());`) then `opt_stmt_span` is the\n-    /// span of that statement (including its semicolon, if any).\n-    /// The scope is used if a statement temporary must be dropped.\n+    ///\n+    /// The `statement_scope` is used if a statement temporary must be dropped.\n     pub(crate) fn stmt_expr(\n         &mut self,\n         mut block: BasicBlock,"}, {"sha": "7edcd46a34f293a542e1f2df59bc6f55f07a7bce", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -30,7 +30,6 @@ mod test;\n mod util;\n \n use std::borrow::Borrow;\n-use std::convert::TryFrom;\n use std::mem;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {"}, {"sha": "de6a48f7cc411c4c7afb830f729c5bcb95227dfe", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -838,8 +838,6 @@ fn trait_method<'tcx>(\n     method_name: Symbol,\n     substs: impl IntoIterator<Item = impl Into<GenericArg<'tcx>>>,\n ) -> ConstantKind<'tcx> {\n-    let substs = tcx.mk_substs(substs.into_iter().map(Into::into));\n-\n     // The unhygienic comparison here is acceptable because this is only\n     // used on known traits.\n     let item = tcx"}, {"sha": "cbd494862a01f09ee0debdb8d4bd0eacae39f3d9", "filename": "compiler/rustc_mir_build/src/build/matches/util.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -7,7 +7,6 @@ use rustc_middle::thir::*;\n use rustc_middle::ty;\n use rustc_middle::ty::TypeVisitable;\n use smallvec::SmallVec;\n-use std::convert::TryInto;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub(crate) fn field_match_pairs<'pat>("}, {"sha": "7af89dd472f88e9be4ccf03111f2ad525d870d7c", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -487,6 +487,7 @@ fn construct_fn<'tcx>(\n         return custom::build_custom_mir(\n             tcx,\n             fn_def.did.to_def_id(),\n+            fn_id,\n             thir,\n             expr,\n             arguments,"}, {"sha": "3bb1f51650abd5c846acad632a7e649099f4559f", "filename": "compiler/rustc_mir_build/src/check_unsafety.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -132,6 +132,18 @@ impl<'tcx> UnsafetyVisitor<'_, 'tcx> {\n     fn unsafe_op_in_unsafe_fn_allowed(&self) -> bool {\n         self.tcx.lint_level_at_node(UNSAFE_OP_IN_UNSAFE_FN, self.hir_context).0 == Level::Allow\n     }\n+\n+    /// Handle closures/generators/inline-consts, which is unsafecked with their parent body.\n+    fn visit_inner_body(&mut self, def: ty::WithOptConstParam<LocalDefId>) {\n+        if let Ok((inner_thir, expr)) = self.tcx.thir_body(def) {\n+            let inner_thir = &inner_thir.borrow();\n+            let hir_context = self.tcx.hir().local_def_id_to_hir_id(def.did);\n+            let mut inner_visitor = UnsafetyVisitor { thir: inner_thir, hir_context, ..*self };\n+            inner_visitor.visit_expr(&inner_thir[expr]);\n+            // Unsafe blocks can be used in the inner body, make sure to take it into account\n+            self.safety_context = inner_visitor.safety_context;\n+        }\n+    }\n }\n \n // Searches for accesses to layout constrained fields.\n@@ -408,16 +420,11 @@ impl<'a, 'tcx> Visitor<'a, 'tcx> for UnsafetyVisitor<'a, 'tcx> {\n                 } else {\n                     ty::WithOptConstParam::unknown(closure_id)\n                 };\n-                let (closure_thir, expr) = self.tcx.thir_body(closure_def).unwrap_or_else(|_| {\n-                    (self.tcx.alloc_steal_thir(Thir::new()), ExprId::from_u32(0))\n-                });\n-                let closure_thir = &closure_thir.borrow();\n-                let hir_context = self.tcx.hir().local_def_id_to_hir_id(closure_id);\n-                let mut closure_visitor =\n-                    UnsafetyVisitor { thir: closure_thir, hir_context, ..*self };\n-                closure_visitor.visit_expr(&closure_thir[expr]);\n-                // Unsafe blocks can be used in closures, make sure to take it into account\n-                self.safety_context = closure_visitor.safety_context;\n+                self.visit_inner_body(closure_def);\n+            }\n+            ExprKind::ConstBlock { did, substs: _ } => {\n+                let def_id = did.expect_local();\n+                self.visit_inner_body(ty::WithOptConstParam::unknown(def_id));\n             }\n             ExprKind::Field { lhs, .. } => {\n                 let lhs = &self.thir[lhs];\n@@ -612,11 +619,8 @@ pub fn check_unsafety<'tcx>(tcx: TyCtxt<'tcx>, def: ty::WithOptConstParam<LocalD\n         return;\n     }\n \n-    // Closures are handled by their owner, if it has a body\n-    if tcx.is_closure(def.did.to_def_id()) {\n-        let hir = tcx.hir();\n-        let owner = hir.enclosing_body_owner(hir.local_def_id_to_hir_id(def.did));\n-        tcx.ensure().thir_check_unsafety(owner);\n+    // Closures and inline consts are handled by their owner, if it has a body\n+    if tcx.is_typeck_child(def.did.to_def_id()) {\n         return;\n     }\n "}, {"sha": "57ae6a3652df5293116b866a65b79b5d4c1153d8", "filename": "compiler/rustc_mir_build/src/thir/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -33,13 +33,13 @@ pub(crate) fn lit_to_const<'tcx>(\n             let str_bytes = s.as_str().as_bytes();\n             ty::ValTree::from_raw_bytes(tcx, str_bytes)\n         }\n-        (ast::LitKind::ByteStr(data), ty::Ref(_, inner_ty, _))\n+        (ast::LitKind::ByteStr(data, _), ty::Ref(_, inner_ty, _))\n             if matches!(inner_ty.kind(), ty::Slice(_)) =>\n         {\n             let bytes = data as &[u8];\n             ty::ValTree::from_raw_bytes(tcx, bytes)\n         }\n-        (ast::LitKind::ByteStr(data), ty::Ref(_, inner_ty, _)) if inner_ty.is_array() => {\n+        (ast::LitKind::ByteStr(data, _), ty::Ref(_, inner_ty, _)) if inner_ty.is_array() => {\n             let bytes = data as &[u8];\n             ty::ValTree::from_raw_bytes(tcx, bytes)\n         }"}, {"sha": "7e1f708b0d6a1685f01257e69c479cb20097bbc9", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -121,7 +121,7 @@ impl<'tcx> ConstToPat<'tcx> {\n                 ty::Dynamic(..) => {\n                     \"trait objects cannot be used in patterns\".to_string()\n                 }\n-                ty::Opaque(..) => {\n+                ty::Alias(ty::Opaque, ..) => {\n                     \"opaque types cannot be used in patterns\".to_string()\n                 }\n                 ty::Closure(..) => {"}, {"sha": "18e9c69c4870e3b8796c5b01e1e2b73c3c6c0d18", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -45,7 +45,7 @@\n use std::cell::Cell;\n use std::cmp::{self, max, min, Ordering};\n use std::fmt;\n-use std::iter::{once, IntoIterator};\n+use std::iter::once;\n use std::ops::RangeInclusive;\n \n use smallvec::{smallvec, SmallVec};"}, {"sha": "8f80cb95e58e70ff3512a5c95c93977c3e3490af", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -845,7 +845,7 @@ fn is_useful<'p, 'tcx>(\n \n         // Opaque types can't get destructured/split, but the patterns can\n         // actually hint at hidden types, so we use the patterns' types instead.\n-        if let ty::Opaque(..) = ty.kind() {\n+        if let ty::Alias(ty::Opaque, ..) = ty.kind() {\n             if let Some(row) = rows.first() {\n                 ty = row.head().ty();\n             }"}, {"sha": "3224e13f7af4bfe9da8c9fd3b045edadee2b5496", "filename": "compiler/rustc_mir_dataflow/src/drop_flag_effects.rs", "status": "modified", "additions": 46, "deletions": 51, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_dataflow%2Fsrc%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_dataflow%2Fsrc%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fdrop_flag_effects.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -29,56 +29,6 @@ where\n     None\n }\n \n-/// When enumerating the child fragments of a path, don't recurse into\n-/// paths (1.) past arrays, slices, and pointers, nor (2.) into a type\n-/// that implements `Drop`.\n-///\n-/// Places behind references or arrays are not tracked by elaboration\n-/// and are always assumed to be initialized when accessible. As\n-/// references and indexes can be reseated, trying to track them can\n-/// only lead to trouble.\n-///\n-/// Places behind ADT's with a Drop impl are not tracked by\n-/// elaboration since they can never have a drop-flag state that\n-/// differs from that of the parent with the Drop impl.\n-///\n-/// In both cases, the contents can only be accessed if and only if\n-/// their parents are initialized. This implies for example that there\n-/// is no need to maintain separate drop flags to track such state.\n-//\n-// FIXME: we have to do something for moving slice patterns.\n-fn place_contents_drop_state_cannot_differ<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    body: &Body<'tcx>,\n-    place: mir::Place<'tcx>,\n-) -> bool {\n-    let ty = place.ty(body, tcx).ty;\n-    match ty.kind() {\n-        ty::Array(..) => {\n-            debug!(\n-                \"place_contents_drop_state_cannot_differ place: {:?} ty: {:?} => false\",\n-                place, ty\n-            );\n-            false\n-        }\n-        ty::Slice(..) | ty::Ref(..) | ty::RawPtr(..) => {\n-            debug!(\n-                \"place_contents_drop_state_cannot_differ place: {:?} ty: {:?} refd => true\",\n-                place, ty\n-            );\n-            true\n-        }\n-        ty::Adt(def, _) if (def.has_dtor(tcx) && !def.is_box()) || def.is_union() => {\n-            debug!(\n-                \"place_contents_drop_state_cannot_differ place: {:?} ty: {:?} Drop => true\",\n-                place, ty\n-            );\n-            true\n-        }\n-        _ => false,\n-    }\n-}\n-\n pub fn on_lookup_result_bits<'tcx, F>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n@@ -105,13 +55,58 @@ pub fn on_all_children_bits<'tcx, F>(\n ) where\n     F: FnMut(MovePathIndex),\n {\n+    #[inline]\n     fn is_terminal_path<'tcx>(\n         tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n         move_data: &MoveData<'tcx>,\n         path: MovePathIndex,\n     ) -> bool {\n-        place_contents_drop_state_cannot_differ(tcx, body, move_data.move_paths[path].place)\n+        let place = move_data.move_paths[path].place;\n+\n+        // When enumerating the child fragments of a path, don't recurse into\n+        // paths (1.) past arrays, slices, and pointers, nor (2.) into a type\n+        // that implements `Drop`.\n+        //\n+        // Places behind references or arrays are not tracked by elaboration\n+        // and are always assumed to be initialized when accessible. As\n+        // references and indexes can be reseated, trying to track them can\n+        // only lead to trouble.\n+        //\n+        // Places behind ADT's with a Drop impl are not tracked by\n+        // elaboration since they can never have a drop-flag state that\n+        // differs from that of the parent with the Drop impl.\n+        //\n+        // In both cases, the contents can only be accessed if and only if\n+        // their parents are initialized. This implies for example that there\n+        // is no need to maintain separate drop flags to track such state.\n+        //\n+        // FIXME: we have to do something for moving slice patterns.\n+        let ty = place.ty(body, tcx).ty;\n+        match ty.kind() {\n+            ty::Adt(def, _) if (def.has_dtor(tcx) && !def.is_box()) || def.is_union() => {\n+                debug!(\n+                    \"place_contents_drop_state_cannot_differ place: {:?} ty: {:?} Drop => true\",\n+                    place, ty\n+                );\n+                true\n+            }\n+            ty::Array(..) => {\n+                debug!(\n+                    \"place_contents_drop_state_cannot_differ place: {:?} ty: {:?} => false\",\n+                    place, ty\n+                );\n+                false\n+            }\n+            ty::Slice(..) | ty::Ref(..) | ty::RawPtr(..) => {\n+                debug!(\n+                    \"place_contents_drop_state_cannot_differ place: {:?} ty: {:?} refd => true\",\n+                    place, ty\n+                );\n+                true\n+            }\n+            _ => false,\n+        }\n     }\n \n     fn on_all_children_bits<'tcx, F>("}, {"sha": "7836ae2e7b76f9959107eceb12875c9da02fdd63", "filename": "compiler/rustc_mir_dataflow/src/elaborate_drops.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -614,7 +614,6 @@ where\n         let drop_trait = tcx.require_lang_item(LangItem::Drop, None);\n         let drop_fn = tcx.associated_item_def_ids(drop_trait)[0];\n         let ty = self.place_ty(self.place);\n-        let substs = tcx.mk_substs_trait(ty, []);\n \n         let ref_ty =\n             tcx.mk_ref(tcx.lifetimes.re_erased, ty::TypeAndMut { ty, mutbl: hir::Mutability::Mut });\n@@ -632,7 +631,12 @@ where\n             )],\n             terminator: Some(Terminator {\n                 kind: TerminatorKind::Call {\n-                    func: Operand::function_handle(tcx, drop_fn, substs, self.source_info.span),\n+                    func: Operand::function_handle(\n+                        tcx,\n+                        drop_fn,\n+                        [ty.into()],\n+                        self.source_info.span,\n+                    ),\n                     args: vec![Operand::Move(Place::from(ref_place))],\n                     destination: unit_temp,\n                     target: Some(succ),"}, {"sha": "8fdac7b2cf501e1540a526392a1cde97c7397216", "filename": "compiler/rustc_mir_dataflow/src/framework/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Flattice.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -26,7 +26,7 @@\n //! ## `PartialOrd`\n //!\n //! Given that they represent partially ordered sets, you may be surprised that [`JoinSemiLattice`]\n-//! and [`MeetSemiLattice`] do not have [`PartialOrd`][std::cmp::PartialOrd] as a supertrait. This\n+//! and [`MeetSemiLattice`] do not have [`PartialOrd`] as a supertrait. This\n //! is because most standard library types use lexicographic ordering instead of set inclusion for\n //! their `PartialOrd` impl. Since we do not actually need to compare lattice elements to run a\n //! dataflow analysis, there's no need for a newtype wrapper with a custom `PartialOrd` impl. The"}, {"sha": "8d379b90a86db28194b2946df68bc564b8e84961", "filename": "compiler/rustc_mir_dataflow/src/impls/storage_liveness.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fstorage_liveness.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -3,20 +3,21 @@ pub use super::*;\n use crate::{CallReturnPlaces, GenKill, Results, ResultsRefCursor};\n use rustc_middle::mir::visit::{NonMutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::*;\n+use std::borrow::Cow;\n use std::cell::RefCell;\n \n #[derive(Clone)]\n-pub struct MaybeStorageLive {\n-    always_live_locals: BitSet<Local>,\n+pub struct MaybeStorageLive<'a> {\n+    always_live_locals: Cow<'a, BitSet<Local>>,\n }\n \n-impl MaybeStorageLive {\n-    pub fn new(always_live_locals: BitSet<Local>) -> Self {\n+impl<'a> MaybeStorageLive<'a> {\n+    pub fn new(always_live_locals: Cow<'a, BitSet<Local>>) -> Self {\n         MaybeStorageLive { always_live_locals }\n     }\n }\n \n-impl<'tcx> crate::AnalysisDomain<'tcx> for MaybeStorageLive {\n+impl<'tcx, 'a> crate::AnalysisDomain<'tcx> for MaybeStorageLive<'a> {\n     type Domain = BitSet<Local>;\n \n     const NAME: &'static str = \"maybe_storage_live\";\n@@ -38,7 +39,7 @@ impl<'tcx> crate::AnalysisDomain<'tcx> for MaybeStorageLive {\n     }\n }\n \n-impl<'tcx> crate::GenKillAnalysis<'tcx> for MaybeStorageLive {\n+impl<'tcx, 'a> crate::GenKillAnalysis<'tcx> for MaybeStorageLive<'a> {\n     type Idx = Local;\n \n     fn statement_effect("}, {"sha": "9c22b5df73ce85ea2423352c4c8d55ed0ea20abe", "filename": "compiler/rustc_mir_transform/src/check_unsafety.rs", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -1,6 +1,7 @@\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::hir_id::HirId;\n use rustc_hir::intravisit;\n@@ -134,6 +135,28 @@ impl<'tcx> Visitor<'tcx> for UnsafetyChecker<'_, 'tcx> {\n         self.super_rvalue(rvalue, location);\n     }\n \n+    fn visit_operand(&mut self, op: &Operand<'tcx>, location: Location) {\n+        if let Operand::Constant(constant) = op {\n+            let maybe_uneval = match constant.literal {\n+                ConstantKind::Val(..) | ConstantKind::Ty(_) => None,\n+                ConstantKind::Unevaluated(uv, _) => Some(uv),\n+            };\n+\n+            if let Some(uv) = maybe_uneval {\n+                if uv.promoted.is_none() {\n+                    let def_id = uv.def.def_id_for_type_of();\n+                    if self.tcx.def_kind(def_id) == DefKind::InlineConst {\n+                        let local_def_id = def_id.expect_local();\n+                        let UnsafetyCheckResult { violations, used_unsafe_blocks, .. } =\n+                            self.tcx.unsafety_check_result(local_def_id);\n+                        self.register_violations(violations, used_unsafe_blocks.iter().copied());\n+                    }\n+                }\n+            }\n+        }\n+        self.super_operand(op, location);\n+    }\n+\n     fn visit_place(&mut self, place: &Place<'tcx>, context: PlaceContext, _location: Location) {\n         // On types with `scalar_valid_range`, prevent\n         // * `&mut x.field`\n@@ -410,6 +433,12 @@ impl<'tcx> intravisit::Visitor<'tcx> for UnusedUnsafeVisitor<'_, 'tcx> {\n         intravisit::walk_block(self, block);\n     }\n \n+    fn visit_anon_const(&mut self, c: &'tcx hir::AnonConst) {\n+        if matches!(self.tcx.def_kind(c.def_id), DefKind::InlineConst) {\n+            self.visit_body(self.tcx.hir().body(c.body))\n+        }\n+    }\n+\n     fn visit_fn(\n         &mut self,\n         fk: intravisit::FnKind<'tcx>,\n@@ -471,7 +500,7 @@ fn unsafety_check_result<'tcx>(\n     // `mir_built` force this.\n     let body = &tcx.mir_built(def).borrow();\n \n-    if body.should_skip() {\n+    if body.is_custom_mir() {\n         return tcx.arena.alloc(UnsafetyCheckResult {\n             violations: Vec::new(),\n             used_unsafe_blocks: FxHashSet::default(),\n@@ -484,7 +513,7 @@ fn unsafety_check_result<'tcx>(\n     let mut checker = UnsafetyChecker::new(body, def.did, tcx, param_env);\n     checker.visit_body(&body);\n \n-    let unused_unsafes = (!tcx.is_closure(def.did.to_def_id()))\n+    let unused_unsafes = (!tcx.is_typeck_child(def.did.to_def_id()))\n         .then(|| check_unused_unsafe(tcx, def.did, &checker.used_unsafe_blocks));\n \n     tcx.arena.alloc(UnsafetyCheckResult {\n@@ -516,8 +545,8 @@ fn report_unused_unsafe(tcx: TyCtxt<'_>, kind: UnusedUnsafe, id: HirId) {\n pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     debug!(\"check_unsafety({:?})\", def_id);\n \n-    // closures are handled by their parent fn.\n-    if tcx.is_closure(def_id.to_def_id()) {\n+    // closures and inline consts are handled by their parent fn.\n+    if tcx.is_typeck_child(def_id.to_def_id()) {\n         return;\n     }\n "}, {"sha": "044b7ce65bd71cd65ed54597d246e1e4efc01cac", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -6,6 +6,7 @@ use std::cell::Cell;\n use either::Right;\n \n use rustc_ast::Mutability;\n+use rustc_const_eval::const_eval::CheckAlignment;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def::DefKind;\n use rustc_index::bit_set::BitSet;\n@@ -22,7 +23,7 @@ use rustc_middle::ty::layout::{LayoutError, LayoutOf, LayoutOfHelpers, TyAndLayo\n use rustc_middle::ty::InternalSubsts;\n use rustc_middle::ty::{self, ConstKind, Instance, ParamEnv, Ty, TyCtxt, TypeVisitable};\n use rustc_span::{def_id::DefId, Span};\n-use rustc_target::abi::{self, HasDataLayout, Size, TargetDataLayout};\n+use rustc_target::abi::{self, Align, HasDataLayout, Size, TargetDataLayout};\n use rustc_target::spec::abi::Abi as CallAbi;\n use rustc_trait_selection::traits;\n \n@@ -186,16 +187,27 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n     type MemoryKind = !;\n \n     #[inline(always)]\n-    fn enforce_alignment(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n+    fn enforce_alignment(_ecx: &InterpCx<'mir, 'tcx, Self>) -> CheckAlignment {\n         // We do not check for alignment to avoid having to carry an `Align`\n         // in `ConstValue::ByRef`.\n-        false\n+        CheckAlignment::No\n     }\n \n     #[inline(always)]\n     fn enforce_validity(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n         false // for now, we don't enforce validity\n     }\n+    fn alignment_check_failed(\n+        ecx: &InterpCx<'mir, 'tcx, Self>,\n+        _has: Align,\n+        _required: Align,\n+        _check: CheckAlignment,\n+    ) -> InterpResult<'tcx, ()> {\n+        span_bug!(\n+            ecx.cur_span(),\n+            \"`alignment_check_failed` called when no alignment check requested\"\n+        )\n+    }\n \n     fn load_mir(\n         _ecx: &InterpCx<'mir, 'tcx, Self>,"}, {"sha": "c75fe2327de3eb0b52e35f0cbebfe02fc9282838", "filename": "compiler/rustc_mir_transform/src/dataflow_const_prop.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -2,6 +2,7 @@\n //!\n //! Currently, this pass only propagates scalar values.\n \n+use rustc_const_eval::const_eval::CheckAlignment;\n use rustc_const_eval::interpret::{ConstValue, ImmTy, Immediate, InterpCx, Scalar};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::mir::visit::{MutVisitor, Visitor};\n@@ -10,6 +11,7 @@ use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_mir_dataflow::value_analysis::{Map, State, TrackElem, ValueAnalysis, ValueOrPlace};\n use rustc_mir_dataflow::{lattice::FlatSet, Analysis, ResultsVisitor, SwitchIntEdgeEffects};\n use rustc_span::DUMMY_SP;\n+use rustc_target::abi::Align;\n \n use crate::MirPass;\n \n@@ -448,13 +450,21 @@ impl<'mir, 'tcx> rustc_const_eval::interpret::Machine<'mir, 'tcx> for DummyMachi\n     type MemoryKind = !;\n     const PANIC_ON_ALLOC_FAIL: bool = true;\n \n-    fn enforce_alignment(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n+    fn enforce_alignment(_ecx: &InterpCx<'mir, 'tcx, Self>) -> CheckAlignment {\n         unimplemented!()\n     }\n \n     fn enforce_validity(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n         unimplemented!()\n     }\n+    fn alignment_check_failed(\n+        _ecx: &InterpCx<'mir, 'tcx, Self>,\n+        _has: Align,\n+        _required: Align,\n+        _check: CheckAlignment,\n+    ) -> interpret::InterpResult<'tcx, ()> {\n+        unimplemented!()\n+    }\n \n     fn find_mir_or_eval_fn(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,"}, {"sha": "3e45319431cec0e9de6816ed78310c892d09d461", "filename": "compiler/rustc_mir_transform/src/dest_prop.rs", "status": "modified", "additions": 88, "deletions": 83, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -132,15 +132,12 @@ use std::collections::hash_map::{Entry, OccupiedEntry};\n use crate::MirPass;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::bit_set::BitSet;\n+use rustc_middle::mir::visit::{MutVisitor, PlaceContext, Visitor};\n use rustc_middle::mir::{dump_mir, PassWhere};\n use rustc_middle::mir::{\n     traversal, BasicBlock, Body, InlineAsmOperand, Local, LocalKind, Location, Operand, Place,\n     Rvalue, Statement, StatementKind, TerminatorKind,\n };\n-use rustc_middle::mir::{\n-    visit::{MutVisitor, PlaceContext, Visitor},\n-    ProjectionElem,\n-};\n use rustc_middle::ty::TyCtxt;\n use rustc_mir_dataflow::impls::MaybeLiveLocals;\n use rustc_mir_dataflow::{Analysis, ResultsCursor};\n@@ -359,40 +356,45 @@ struct FilterInformation<'a, 'body, 'alloc, 'tcx> {\n // through these methods, and not directly.\n impl<'alloc> Candidates<'alloc> {\n     /// Just `Vec::retain`, but the condition is inverted and we add debugging output\n-    fn vec_remove_debug(\n+    fn vec_filter_candidates(\n         src: Local,\n         v: &mut Vec<Local>,\n-        mut f: impl FnMut(Local) -> bool,\n+        mut f: impl FnMut(Local) -> CandidateFilter,\n         at: Location,\n     ) {\n         v.retain(|dest| {\n             let remove = f(*dest);\n-            if remove {\n+            if remove == CandidateFilter::Remove {\n                 trace!(\"eliminating {:?} => {:?} due to conflict at {:?}\", src, dest, at);\n             }\n-            !remove\n+            remove == CandidateFilter::Keep\n         });\n     }\n \n-    /// `vec_remove_debug` but for an `Entry`\n-    fn entry_remove(\n+    /// `vec_filter_candidates` but for an `Entry`\n+    fn entry_filter_candidates(\n         mut entry: OccupiedEntry<'_, Local, Vec<Local>>,\n         p: Local,\n-        f: impl FnMut(Local) -> bool,\n+        f: impl FnMut(Local) -> CandidateFilter,\n         at: Location,\n     ) {\n         let candidates = entry.get_mut();\n-        Self::vec_remove_debug(p, candidates, f, at);\n+        Self::vec_filter_candidates(p, candidates, f, at);\n         if candidates.len() == 0 {\n             entry.remove();\n         }\n     }\n \n-    /// Removes all candidates `(p, q)` or `(q, p)` where `p` is the indicated local and `f(q)` is true.\n-    fn remove_candidates_if(&mut self, p: Local, mut f: impl FnMut(Local) -> bool, at: Location) {\n+    /// For all candidates `(p, q)` or `(q, p)` removes the candidate if `f(q)` says to do so\n+    fn filter_candidates_by(\n+        &mut self,\n+        p: Local,\n+        mut f: impl FnMut(Local) -> CandidateFilter,\n+        at: Location,\n+    ) {\n         // Cover the cases where `p` appears as a `src`\n         if let Entry::Occupied(entry) = self.c.entry(p) {\n-            Self::entry_remove(entry, p, &mut f, at);\n+            Self::entry_filter_candidates(entry, p, &mut f, at);\n         }\n         // And the cases where `p` appears as a `dest`\n         let Some(srcs) = self.reverse.get_mut(&p) else {\n@@ -401,18 +403,31 @@ impl<'alloc> Candidates<'alloc> {\n         // We use `retain` here to remove the elements from the reverse set if we've removed the\n         // matching candidate in the forward set.\n         srcs.retain(|src| {\n-            if !f(*src) {\n+            if f(*src) == CandidateFilter::Keep {\n                 return true;\n             }\n             let Entry::Occupied(entry) = self.c.entry(*src) else {\n                 return false;\n             };\n-            Self::entry_remove(entry, *src, |dest| dest == p, at);\n+            Self::entry_filter_candidates(\n+                entry,\n+                *src,\n+                |dest| {\n+                    if dest == p { CandidateFilter::Remove } else { CandidateFilter::Keep }\n+                },\n+                at,\n+            );\n             false\n         });\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq)]\n+enum CandidateFilter {\n+    Keep,\n+    Remove,\n+}\n+\n impl<'a, 'body, 'alloc, 'tcx> FilterInformation<'a, 'body, 'alloc, 'tcx> {\n     /// Filters the set of candidates to remove those that conflict.\n     ///\n@@ -460,7 +475,7 @@ impl<'a, 'body, 'alloc, 'tcx> FilterInformation<'a, 'body, 'alloc, 'tcx> {\n             for (i, statement) in data.statements.iter().enumerate().rev() {\n                 self.at = Location { block, statement_index: i };\n                 self.live.seek_after_primary_effect(self.at);\n-                self.get_statement_write_info(&statement.kind);\n+                self.write_info.for_statement(&statement.kind, self.body);\n                 self.apply_conflicts();\n             }\n         }\n@@ -469,80 +484,59 @@ impl<'a, 'body, 'alloc, 'tcx> FilterInformation<'a, 'body, 'alloc, 'tcx> {\n     fn apply_conflicts(&mut self) {\n         let writes = &self.write_info.writes;\n         for p in writes {\n-            self.candidates.remove_candidates_if(\n+            let other_skip = self.write_info.skip_pair.and_then(|(a, b)| {\n+                if a == *p {\n+                    Some(b)\n+                } else if b == *p {\n+                    Some(a)\n+                } else {\n+                    None\n+                }\n+            });\n+            self.candidates.filter_candidates_by(\n                 *p,\n-                // It is possible that a local may be live for less than the\n-                // duration of a statement This happens in the case of function\n-                // calls or inline asm. Because of this, we also mark locals as\n-                // conflicting when both of them are written to in the same\n-                // statement.\n-                |q| self.live.contains(q) || writes.contains(&q),\n+                |q| {\n+                    if Some(q) == other_skip {\n+                        return CandidateFilter::Keep;\n+                    }\n+                    // It is possible that a local may be live for less than the\n+                    // duration of a statement This happens in the case of function\n+                    // calls or inline asm. Because of this, we also mark locals as\n+                    // conflicting when both of them are written to in the same\n+                    // statement.\n+                    if self.live.contains(q) || writes.contains(&q) {\n+                        CandidateFilter::Remove\n+                    } else {\n+                        CandidateFilter::Keep\n+                    }\n+                },\n                 self.at,\n             );\n         }\n     }\n-\n-    /// Gets the write info for the `statement`.\n-    fn get_statement_write_info(&mut self, statement: &StatementKind<'tcx>) {\n-        self.write_info.writes.clear();\n-        match statement {\n-            StatementKind::Assign(box (lhs, rhs)) => match rhs {\n-                Rvalue::Use(op) => {\n-                    if !lhs.is_indirect() {\n-                        self.get_assign_use_write_info(*lhs, op);\n-                        return;\n-                    }\n-                }\n-                _ => (),\n-            },\n-            _ => (),\n-        }\n-\n-        self.write_info.for_statement(statement);\n-    }\n-\n-    fn get_assign_use_write_info(&mut self, lhs: Place<'tcx>, rhs: &Operand<'tcx>) {\n-        // We register the writes for the operand unconditionally\n-        self.write_info.add_operand(rhs);\n-        // However, we cannot do the same thing for the `lhs` as that would always block the\n-        // optimization. Instead, we consider removing candidates manually.\n-        let Some(rhs) = rhs.place() else {\n-            self.write_info.add_place(lhs);\n-            return;\n-        };\n-        // Find out which candidate pair we should skip, if any\n-        let Some((src, dest)) = places_to_candidate_pair(lhs, rhs, self.body) else {\n-            self.write_info.add_place(lhs);\n-            return;\n-        };\n-        self.candidates.remove_candidates_if(\n-            lhs.local,\n-            |other| {\n-                // Check if this is the candidate pair that should not be removed\n-                if (lhs.local == src && other == dest) || (lhs.local == dest && other == src) {\n-                    return false;\n-                }\n-                // Otherwise, do the \"standard\" thing\n-                self.live.contains(other)\n-            },\n-            self.at,\n-        )\n-    }\n }\n \n /// Describes where a statement/terminator writes to\n #[derive(Default, Debug)]\n struct WriteInfo {\n     writes: Vec<Local>,\n+    /// If this pair of locals is a candidate pair, completely skip processing it during this\n+    /// statement. All other candidates are unaffected.\n+    skip_pair: Option<(Local, Local)>,\n }\n \n impl WriteInfo {\n-    fn for_statement<'tcx>(&mut self, statement: &StatementKind<'tcx>) {\n+    fn for_statement<'tcx>(&mut self, statement: &StatementKind<'tcx>, body: &Body<'tcx>) {\n+        self.reset();\n         match statement {\n             StatementKind::Assign(box (lhs, rhs)) => {\n                 self.add_place(*lhs);\n                 match rhs {\n-                    Rvalue::Use(op) | Rvalue::Repeat(op, _) => {\n+                    Rvalue::Use(op) => {\n+                        self.add_operand(op);\n+                        self.consider_skipping_for_assign_use(*lhs, op, body);\n+                    }\n+                    Rvalue::Repeat(op, _) => {\n                         self.add_operand(op);\n                     }\n                     Rvalue::Cast(_, op, _)\n@@ -586,8 +580,22 @@ impl WriteInfo {\n         }\n     }\n \n+    fn consider_skipping_for_assign_use<'tcx>(\n+        &mut self,\n+        lhs: Place<'tcx>,\n+        rhs: &Operand<'tcx>,\n+        body: &Body<'tcx>,\n+    ) {\n+        let Some(rhs) = rhs.place() else {\n+            return\n+        };\n+        if let Some(pair) = places_to_candidate_pair(lhs, rhs, body) {\n+            self.skip_pair = Some(pair);\n+        }\n+    }\n+\n     fn for_terminator<'tcx>(&mut self, terminator: &TerminatorKind<'tcx>) {\n-        self.writes.clear();\n+        self.reset();\n         match terminator {\n             TerminatorKind::SwitchInt { discr: op, .. }\n             | TerminatorKind::Assert { cond: op, .. } => {\n@@ -657,15 +665,16 @@ impl WriteInfo {\n             Operand::Copy(_) | Operand::Constant(_) => (),\n         }\n     }\n+\n+    fn reset(&mut self) {\n+        self.writes.clear();\n+        self.skip_pair = None;\n+    }\n }\n \n /////////////////////////////////////////////////////\n // Candidate accumulation\n \n-fn is_constant<'tcx>(place: Place<'tcx>) -> bool {\n-    place.projection.iter().all(|p| !matches!(p, ProjectionElem::Deref | ProjectionElem::Index(_)))\n-}\n-\n /// If the pair of places is being considered for merging, returns the candidate which would be\n /// merged in order to accomplish this.\n ///\n@@ -741,10 +750,6 @@ impl<'tcx> Visitor<'tcx> for FindAssignments<'_, '_, 'tcx> {\n             Rvalue::Use(Operand::Copy(rhs) | Operand::Move(rhs)),\n         )) = &statement.kind\n         {\n-            if !is_constant(*lhs) || !is_constant(*rhs) {\n-                return;\n-            }\n-\n             let Some((src, dest)) = places_to_candidate_pair(*lhs, *rhs, self.body) else {\n                 return;\n             };"}, {"sha": "c097af6161159a7fcec85b6b0bb69a3605fcb8e9", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -490,7 +490,7 @@ fn locals_live_across_suspend_points<'tcx>(\n \n     // Calculate when MIR locals have live storage. This gives us an upper bound of their\n     // lifetimes.\n-    let mut storage_live = MaybeStorageLive::new(always_live_locals.clone())\n+    let mut storage_live = MaybeStorageLive::new(std::borrow::Cow::Borrowed(always_live_locals))\n         .into_engine(tcx, body_ref)\n         .iterate_to_fixpoint()\n         .into_results_cursor(body_ref);"}, {"sha": "9d560f5c837e2d75e75f6899d65199bdef8fe710", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -849,7 +849,7 @@ impl<'tcx> Visitor<'tcx> for CostChecker<'_, 'tcx> {\n             };\n \n             let kind = match parent_ty.ty.kind() {\n-                &ty::Opaque(def_id, substs) => {\n+                &ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n                     self.tcx.bound_type_of(def_id).subst(self.tcx, substs).kind()\n                 }\n                 kind => kind,"}, {"sha": "1708b287e56f25bca285136fca3a92649a0bafd6", "filename": "compiler/rustc_mir_transform/src/normalize_array_len.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_transform%2Fsrc%2Fnormalize_array_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_transform%2Fsrc%2Fnormalize_array_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fnormalize_array_len.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -16,7 +16,8 @@ pub struct NormalizeArrayLen;\n \n impl<'tcx> MirPass<'tcx> for NormalizeArrayLen {\n     fn is_enabled(&self, sess: &rustc_session::Session) -> bool {\n-        sess.mir_opt_level() >= 4\n+        // See #105929\n+        sess.mir_opt_level() >= 4 && sess.opts.unstable_opts.unsound_mir_opts\n     }\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {"}, {"sha": "6cabef92d8c2190e7f31514eb319eee727dcc9c2", "filename": "compiler/rustc_mir_transform/src/remove_zsts.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_zsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_zsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_zsts.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -52,7 +52,11 @@ impl<'tcx> MirPass<'tcx> for RemoveZsts {\n fn maybe_zst(ty: Ty<'_>) -> bool {\n     match ty.kind() {\n         // maybe ZST (could be more precise)\n-        ty::Adt(..) | ty::Array(..) | ty::Closure(..) | ty::Tuple(..) | ty::Opaque(..) => true,\n+        ty::Adt(..)\n+        | ty::Array(..)\n+        | ty::Closure(..)\n+        | ty::Tuple(..)\n+        | ty::Alias(ty::Opaque, ..) => true,\n         // definitely ZST\n         ty::FnDef(..) | ty::Never => true,\n         // unreachable or can't be ZST"}, {"sha": "f8b55c862875e06796968c7cc1bbc0d9de190570", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -336,8 +336,7 @@ impl<'tcx> CloneShimBuilder<'tcx> {\n         // we must subst the self_ty because it's\n         // otherwise going to be TySelf and we can't index\n         // or access fields of a Place of type TySelf.\n-        let substs = tcx.mk_substs_trait(self_ty, []);\n-        let sig = tcx.bound_fn_sig(def_id).subst(tcx, substs);\n+        let sig = tcx.bound_fn_sig(def_id).subst(tcx, &[self_ty.into()]);\n         let sig = tcx.erase_late_bound_regions(sig);\n         let span = tcx.def_span(def_id);\n \n@@ -417,10 +416,8 @@ impl<'tcx> CloneShimBuilder<'tcx> {\n     ) {\n         let tcx = self.tcx;\n \n-        let substs = tcx.mk_substs_trait(ty, []);\n-\n         // `func == Clone::clone(&ty) -> ty`\n-        let func_ty = tcx.mk_fn_def(self.def_id, substs);\n+        let func_ty = tcx.mk_fn_def(self.def_id, [ty]);\n         let func = Operand::Constant(Box::new(Constant {\n             span: self.span,\n             user_ty: None,\n@@ -575,9 +572,8 @@ fn build_call_shim<'tcx>(\n \n         // Create substitutions for the `Self` and `Args` generic parameters of the shim body.\n         let arg_tup = tcx.mk_tup(untuple_args.iter());\n-        let sig_substs = tcx.mk_substs_trait(ty, [ty::subst::GenericArg::from(arg_tup)]);\n \n-        (Some(sig_substs), Some(untuple_args))\n+        (Some([ty.into(), arg_tup.into()]), Some(untuple_args))\n     } else {\n         (None, None)\n     };\n@@ -588,7 +584,7 @@ fn build_call_shim<'tcx>(\n \n     assert_eq!(sig_substs.is_some(), !instance.has_polymorphic_mir_body());\n     let mut sig =\n-        if let Some(sig_substs) = sig_substs { sig.subst(tcx, sig_substs) } else { sig.0 };\n+        if let Some(sig_substs) = sig_substs { sig.subst(tcx, &sig_substs) } else { sig.0 };\n \n     if let CallKind::Indirect(fnty) = call_kind {\n         // `sig` determines our local decls, and thus the callee type in the `Call` terminator. This"}, {"sha": "8212a7b523bbc98d5d1e4d8d76e57864432d61df", "filename": "compiler/rustc_mir_transform/src/simplify.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -35,7 +35,6 @@ use rustc_middle::mir::visit::{MutVisitor, MutatingUseContext, PlaceContext, Vis\n use rustc_middle::mir::*;\n use rustc_middle::ty::TyCtxt;\n use smallvec::SmallVec;\n-use std::convert::TryInto;\n \n pub struct SimplifyCfg {\n     label: String,"}, {"sha": "10ea4d29cfe4e3317df1500b046cb1ec2d32c67c", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -931,10 +931,13 @@ fn visit_fn_use<'tcx>(\n ) {\n     if let ty::FnDef(def_id, substs) = *ty.kind() {\n         let instance = if is_direct_call {\n-            ty::Instance::resolve(tcx, ty::ParamEnv::reveal_all(), def_id, substs).unwrap().unwrap()\n+            ty::Instance::expect_resolve(tcx, ty::ParamEnv::reveal_all(), def_id, substs)\n         } else {\n-            ty::Instance::resolve_for_fn_ptr(tcx, ty::ParamEnv::reveal_all(), def_id, substs)\n-                .unwrap()\n+            match ty::Instance::resolve_for_fn_ptr(tcx, ty::ParamEnv::reveal_all(), def_id, substs)\n+            {\n+                Some(instance) => instance,\n+                _ => bug!(\"failed to resolve instance for {ty}\"),\n+            }\n         };\n         visit_instance_use(tcx, instance, is_direct_call, source, output);\n     }\n@@ -1369,9 +1372,8 @@ fn create_mono_items_for_default_impls<'tcx>(\n                                 trait_ref.substs[param.index as usize]\n                             }\n                         });\n-                    let instance = ty::Instance::resolve(tcx, param_env, method.def_id, substs)\n-                        .unwrap()\n-                        .unwrap();\n+                    let instance =\n+                        ty::Instance::expect_resolve(tcx, param_env, method.def_id, substs);\n \n                     let mono_item = create_fn_mono_item(tcx, instance, DUMMY_SP);\n                     if mono_item.node.is_instantiable(tcx) && should_codegen_locally(tcx, &instance)"}, {"sha": "f15cf54718e2b7221bbb70fb9261f36af32fd525", "filename": "compiler/rustc_monomorphize/src/errors.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_monomorphize%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_monomorphize%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Ferrors.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -77,3 +77,9 @@ pub struct SymbolAlreadyDefined {\n     pub span: Option<Span>,\n     pub symbol: String,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(monomorphize_couldnt_dump_mono_stats)]\n+pub struct CouldntDumpMonoStats {\n+    pub error: String,\n+}"}, {"sha": "38e1d98e44e13f0d72af80666004b666fb21835c", "filename": "compiler/rustc_monomorphize/src/partitioning/mod.rs", "status": "modified", "additions": 77, "deletions": 1, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -95,6 +95,11 @@\n mod default;\n mod merging;\n \n+use std::cmp;\n+use std::fs::{self, File};\n+use std::io::{BufWriter, Write};\n+use std::path::{Path, PathBuf};\n+\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync;\n use rustc_hir::def_id::DefIdSet;\n@@ -104,11 +109,12 @@ use rustc_middle::mir::mono::{CodegenUnit, Linkage};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n+use rustc_session::config::SwitchWithOptPath;\n use rustc_span::symbol::Symbol;\n \n use crate::collector::InliningMap;\n use crate::collector::{self, MonoItemCollectionMode};\n-use crate::errors::{SymbolAlreadyDefined, UnknownPartitionStrategy};\n+use crate::errors::{CouldntDumpMonoStats, SymbolAlreadyDefined, UnknownPartitionStrategy};\n \n pub struct PartitioningCx<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n@@ -411,6 +417,15 @@ fn collect_and_partition_mono_items<'tcx>(\n         })\n         .collect();\n \n+    // Output monomorphization stats per def_id\n+    if let SwitchWithOptPath::Enabled(ref path) = tcx.sess.opts.unstable_opts.dump_mono_stats {\n+        if let Err(err) =\n+            dump_mono_items_stats(tcx, &codegen_units, path, tcx.sess.opts.crate_name.as_deref())\n+        {\n+            tcx.sess.emit_fatal(CouldntDumpMonoStats { error: err.to_string() });\n+        }\n+    }\n+\n     if tcx.sess.opts.unstable_opts.print_mono_items.is_some() {\n         let mut item_to_cgus: FxHashMap<_, Vec<_>> = Default::default();\n \n@@ -465,6 +480,67 @@ fn collect_and_partition_mono_items<'tcx>(\n     (tcx.arena.alloc(mono_items), codegen_units)\n }\n \n+/// Outputs stats about instantation counts and estimated size, per `MonoItem`'s\n+/// def, to a file in the given output directory.\n+fn dump_mono_items_stats<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    codegen_units: &[CodegenUnit<'tcx>],\n+    output_directory: &Option<PathBuf>,\n+    crate_name: Option<&str>,\n+) -> Result<(), Box<dyn std::error::Error>> {\n+    let output_directory = if let Some(ref directory) = output_directory {\n+        fs::create_dir_all(directory)?;\n+        directory\n+    } else {\n+        Path::new(\".\")\n+    };\n+\n+    let filename = format!(\"{}.mono_items.md\", crate_name.unwrap_or(\"unknown-crate\"));\n+    let output_path = output_directory.join(&filename);\n+    let file = File::create(output_path)?;\n+    let mut file = BufWriter::new(file);\n+\n+    // Gather instantiated mono items grouped by def_id\n+    let mut items_per_def_id: FxHashMap<_, Vec<_>> = Default::default();\n+    for cgu in codegen_units {\n+        for (&mono_item, _) in cgu.items() {\n+            // Avoid variable-sized compiler-generated shims\n+            if mono_item.is_user_defined() {\n+                items_per_def_id.entry(mono_item.def_id()).or_default().push(mono_item);\n+            }\n+        }\n+    }\n+\n+    // Output stats sorted by total instantiated size, from heaviest to lightest\n+    let mut stats: Vec<_> = items_per_def_id\n+        .into_iter()\n+        .map(|(def_id, items)| {\n+            let instantiation_count = items.len();\n+            let size_estimate = items[0].size_estimate(tcx);\n+            let total_estimate = instantiation_count * size_estimate;\n+            (def_id, instantiation_count, size_estimate, total_estimate)\n+        })\n+        .collect();\n+    stats.sort_unstable_by_key(|(_, _, _, total_estimate)| cmp::Reverse(*total_estimate));\n+\n+    if !stats.is_empty() {\n+        writeln!(\n+            file,\n+            \"| Item | Instantiation count | Estimated Cost Per Instantiation | Total Estimated Cost |\"\n+        )?;\n+        writeln!(file, \"| --- | ---: | ---: | ---: |\")?;\n+        for (def_id, instantiation_count, size_estimate, total_estimate) in stats {\n+            let item = with_no_trimmed_paths!(tcx.def_path_str(def_id));\n+            writeln!(\n+                file,\n+                \"| {item} | {instantiation_count} | {size_estimate} | {total_estimate} |\"\n+            )?;\n+        }\n+    }\n+\n+    Ok(())\n+}\n+\n fn codegened_and_inlined_items<'tcx>(tcx: TyCtxt<'tcx>, (): ()) -> &'tcx DefIdSet {\n     let (items, cgus) = tcx.collect_and_partition_mono_items(());\n     let mut visited = DefIdSet::default();"}, {"sha": "703ed09a254a96899d2019a1d29afba864a4bb97", "filename": "compiler/rustc_monomorphize/src/polymorphize.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -20,7 +20,6 @@ use rustc_middle::ty::{\n     Const, Ty, TyCtxt,\n };\n use rustc_span::symbol::sym;\n-use std::convert::TryInto;\n use std::ops::ControlFlow;\n \n use crate::errors::UnusedGenericParams;"}, {"sha": "686454a8f18117f1323fa6dcea384719770e604f", "filename": "compiler/rustc_parse/src/parser/attr.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -6,7 +6,6 @@ use rustc_ast::attr;\n use rustc_ast::token::{self, Delimiter, Nonterminal};\n use rustc_errors::{error_code, fluent, Diagnostic, IntoDiagnostic, PResult};\n use rustc_span::{sym, BytePos, Span};\n-use std::convert::TryInto;\n \n // Public for rustfmt usage\n #[derive(Debug)]"}, {"sha": "b97f22417cb7bdcc82482abf2a6314d4ff664c03", "filename": "compiler/rustc_parse/src/parser/attr_wrapper.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -8,7 +8,6 @@ use rustc_errors::PResult;\n use rustc_session::parse::ParseSess;\n use rustc_span::{sym, Span, DUMMY_SP};\n \n-use std::convert::TryInto;\n use std::ops::Range;\n \n /// A wrapper type to ensure that the parser handles outer attributes correctly."}, {"sha": "0191ab730c812e89e55099c5896dc4be68284e38", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 15, "deletions": 35, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -159,8 +159,6 @@ enum IsStandalone {\n     Standalone,\n     /// It's a subexpression, i.e., *not* standalone.\n     Subexpr,\n-    /// It's maybe standalone; we're not sure.\n-    Maybe,\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n@@ -213,14 +211,8 @@ impl MultiSugg {\n         err.multipart_suggestion(&self.msg, self.patches, self.applicability);\n     }\n \n-    /// Overrides individual messages and applicabilities.\n-    fn emit_many(\n-        err: &mut Diagnostic,\n-        msg: &str,\n-        applicability: Applicability,\n-        suggestions: impl Iterator<Item = Self>,\n-    ) {\n-        err.multipart_suggestions(msg, suggestions.map(|s| s.patches), applicability);\n+    fn emit_verbose(self, err: &mut Diagnostic) {\n+        err.multipart_suggestion_verbose(&self.msg, self.patches, self.applicability);\n     }\n }\n \n@@ -1267,26 +1259,24 @@ impl<'a> Parser<'a> {\n         &mut self,\n         operand_expr: P<Expr>,\n         op_span: Span,\n-        prev_is_semi: bool,\n+        start_stmt: bool,\n     ) -> PResult<'a, P<Expr>> {\n-        let standalone =\n-            if prev_is_semi { IsStandalone::Standalone } else { IsStandalone::Subexpr };\n+        let standalone = if start_stmt { IsStandalone::Standalone } else { IsStandalone::Subexpr };\n         let kind = IncDecRecovery { standalone, op: IncOrDec::Inc, fixity: UnaryFixity::Pre };\n-\n         self.recover_from_inc_dec(operand_expr, kind, op_span)\n     }\n \n     pub(super) fn recover_from_postfix_increment(\n         &mut self,\n         operand_expr: P<Expr>,\n         op_span: Span,\n+        start_stmt: bool,\n     ) -> PResult<'a, P<Expr>> {\n         let kind = IncDecRecovery {\n-            standalone: IsStandalone::Maybe,\n+            standalone: if start_stmt { IsStandalone::Standalone } else { IsStandalone::Subexpr },\n             op: IncOrDec::Inc,\n             fixity: UnaryFixity::Post,\n         };\n-\n         self.recover_from_inc_dec(operand_expr, kind, op_span)\n     }\n \n@@ -1315,34 +1305,25 @@ impl<'a> Parser<'a> {\n         };\n \n         match kind.standalone {\n-            IsStandalone::Standalone => self.inc_dec_standalone_suggest(kind, spans).emit(&mut err),\n+            IsStandalone::Standalone => {\n+                self.inc_dec_standalone_suggest(kind, spans).emit_verbose(&mut err)\n+            }\n             IsStandalone::Subexpr => {\n                 let Ok(base_src) = self.span_to_snippet(base.span)\n-                    else { return help_base_case(err, base) };\n+                else { return help_base_case(err, base) };\n                 match kind.fixity {\n                     UnaryFixity::Pre => {\n                         self.prefix_inc_dec_suggest(base_src, kind, spans).emit(&mut err)\n                     }\n                     UnaryFixity::Post => {\n-                        self.postfix_inc_dec_suggest(base_src, kind, spans).emit(&mut err)\n+                        // won't suggest since we can not handle the precedences\n+                        // for example: `a + b++` has been parsed (a + b)++ and we can not suggest here\n+                        if !matches!(base.kind, ExprKind::Binary(_, _, _)) {\n+                            self.postfix_inc_dec_suggest(base_src, kind, spans).emit(&mut err)\n+                        }\n                     }\n                 }\n             }\n-            IsStandalone::Maybe => {\n-                let Ok(base_src) = self.span_to_snippet(base.span)\n-                    else { return help_base_case(err, base) };\n-                let sugg1 = match kind.fixity {\n-                    UnaryFixity::Pre => self.prefix_inc_dec_suggest(base_src, kind, spans),\n-                    UnaryFixity::Post => self.postfix_inc_dec_suggest(base_src, kind, spans),\n-                };\n-                let sugg2 = self.inc_dec_standalone_suggest(kind, spans);\n-                MultiSugg::emit_many(\n-                    &mut err,\n-                    \"use `+= 1` instead\",\n-                    Applicability::Unspecified,\n-                    [sugg1, sugg2].into_iter(),\n-                )\n-            }\n         }\n         Err(err)\n     }\n@@ -1392,7 +1373,6 @@ impl<'a> Parser<'a> {\n         }\n \n         patches.push((post_span, format!(\" {}= 1\", kind.op.chr())));\n-\n         MultiSugg {\n             msg: format!(\"use `{}= 1` instead\", kind.op.chr()),\n             patches,"}, {"sha": "c0ed450b98508e07beed81f05c23030695d232c5", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 47, "deletions": 28, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -83,7 +83,7 @@ macro_rules! maybe_whole_expr {\n pub(super) enum LhsExpr {\n     NotYetParsed,\n     AttributesParsed(AttrWrapper),\n-    AlreadyParsed(P<Expr>),\n+    AlreadyParsed(P<Expr>, bool), // (expr, starts_statement)\n }\n \n impl From<Option<AttrWrapper>> for LhsExpr {\n@@ -101,7 +101,7 @@ impl From<P<Expr>> for LhsExpr {\n     ///\n     /// This conversion does not allocate.\n     fn from(expr: P<Expr>) -> Self {\n-        LhsExpr::AlreadyParsed(expr)\n+        LhsExpr::AlreadyParsed(expr, false)\n     }\n }\n \n@@ -173,7 +173,9 @@ impl<'a> Parser<'a> {\n         min_prec: usize,\n         lhs: LhsExpr,\n     ) -> PResult<'a, P<Expr>> {\n-        let mut lhs = if let LhsExpr::AlreadyParsed(expr) = lhs {\n+        let mut starts_stmt = false;\n+        let mut lhs = if let LhsExpr::AlreadyParsed(expr, starts_statement) = lhs {\n+            starts_stmt = starts_statement;\n             expr\n         } else {\n             let attrs = match lhs {\n@@ -292,7 +294,7 @@ impl<'a> Parser<'a> {\n                 let op_span = self.prev_token.span.to(self.token.span);\n                 // Eat the second `+`\n                 self.bump();\n-                lhs = self.recover_from_postfix_increment(lhs, op_span)?;\n+                lhs = self.recover_from_postfix_increment(lhs, op_span, starts_stmt)?;\n                 continue;\n             }\n \n@@ -590,14 +592,15 @@ impl<'a> Parser<'a> {\n             token::BinOp(token::Plus)\n                 if this.look_ahead(1, |t| *t == token::BinOp(token::Plus)) =>\n             {\n-                let prev_is_semi = this.prev_token == token::Semi;\n+                let starts_stmt = this.prev_token == token::Semi\n+                    || this.prev_token == token::CloseDelim(Delimiter::Brace);\n                 let pre_span = this.token.span.to(this.look_ahead(1, |t| t.span));\n                 // Eat both `+`s.\n                 this.bump();\n                 this.bump();\n \n                 let operand_expr = this.parse_dot_or_call_expr(Default::default())?;\n-                this.recover_from_prefix_increment(operand_expr, pre_span, prev_is_semi)\n+                this.recover_from_prefix_increment(operand_expr, pre_span, starts_stmt)\n             }\n             token::Ident(..) if this.token.is_keyword(kw::Box) => {\n                 make_it!(this, attrs, |this, _| this.parse_box_expr(lo))\n@@ -1534,15 +1537,16 @@ impl<'a> Parser<'a> {\n             && (matches!(self.token.kind, token::CloseDelim(_) | token::Comma)\n                 || self.token.is_op())\n         {\n-            let lit = self.recover_unclosed_char(label_.ident, |self_| {\n-                self_.sess.create_err(UnexpectedTokenAfterLabel {\n-                    span: self_.token.span,\n-                    remove_label: None,\n-                    enclose_in_block: None,\n-                })\n-            });\n+            let (lit, _) =\n+                self.recover_unclosed_char(label_.ident, Parser::mk_token_lit_char, |self_| {\n+                    self_.sess.create_err(UnexpectedTokenAfterLabel {\n+                        span: self_.token.span,\n+                        remove_label: None,\n+                        enclose_in_block: None,\n+                    })\n+                });\n             consume_colon = false;\n-            Ok(self.mk_expr(lo, ExprKind::Lit(lit.token_lit)))\n+            Ok(self.mk_expr(lo, ExprKind::Lit(lit)))\n         } else if !ate_colon\n             && (self.check_noexpect(&TokenKind::Comma) || self.check_noexpect(&TokenKind::Gt))\n         {\n@@ -1617,12 +1621,13 @@ impl<'a> Parser<'a> {\n         Ok(expr)\n     }\n \n-    /// Emit an error when a char is parsed as a lifetime because of a missing quote\n-    pub(super) fn recover_unclosed_char(\n+    /// Emit an error when a char is parsed as a lifetime because of a missing quote.\n+    pub(super) fn recover_unclosed_char<L>(\n         &self,\n         lifetime: Ident,\n+        mk_lit_char: impl FnOnce(Symbol, Span) -> L,\n         err: impl FnOnce(&Self) -> DiagnosticBuilder<'a, ErrorGuaranteed>,\n-    ) -> ast::MetaItemLit {\n+    ) -> L {\n         if let Some(mut diag) =\n             self.sess.span_diagnostic.steal_diagnostic(lifetime.span, StashKey::LifetimeIsChar)\n         {\n@@ -1644,11 +1649,7 @@ impl<'a> Parser<'a> {\n                 .emit();\n         }\n         let name = lifetime.without_first_quote().name;\n-        ast::MetaItemLit {\n-            token_lit: token::Lit::new(token::LitKind::Char, name, None),\n-            kind: ast::LitKind::Char(name.as_str().chars().next().unwrap_or('_')),\n-            span: lifetime.span,\n-        }\n+        mk_lit_char(name, lifetime.span)\n     }\n \n     /// Recover on the syntax `do catch { ... }` suggesting `try { ... }` instead.\n@@ -1764,8 +1765,8 @@ impl<'a> Parser<'a> {\n             Some(lit) => match lit.kind {\n                 ast::LitKind::Str(symbol_unescaped, style) => Ok(ast::StrLit {\n                     style,\n-                    symbol: lit.token_lit.symbol,\n-                    suffix: lit.token_lit.suffix,\n+                    symbol: lit.symbol,\n+                    suffix: lit.suffix,\n                     span: lit.span,\n                     symbol_unescaped,\n                 }),\n@@ -1775,7 +1776,23 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn handle_missing_lit(&mut self) -> PResult<'a, MetaItemLit> {\n+    pub(crate) fn mk_token_lit_char(name: Symbol, span: Span) -> (token::Lit, Span) {\n+        (token::Lit { symbol: name, suffix: None, kind: token::Char }, span)\n+    }\n+\n+    fn mk_meta_item_lit_char(name: Symbol, span: Span) -> MetaItemLit {\n+        ast::MetaItemLit {\n+            symbol: name,\n+            suffix: None,\n+            kind: ast::LitKind::Char(name.as_str().chars().next().unwrap_or('_')),\n+            span,\n+        }\n+    }\n+\n+    fn handle_missing_lit<L>(\n+        &mut self,\n+        mk_lit_char: impl FnOnce(Symbol, Span) -> L,\n+    ) -> PResult<'a, L> {\n         if let token::Interpolated(inner) = &self.token.kind {\n             let expr = match inner.as_ref() {\n                 token::NtExpr(expr) => Some(expr),\n@@ -1799,7 +1816,7 @@ impl<'a> Parser<'a> {\n         // On an error path, eagerly consider a lifetime to be an unclosed character lit\n         if self.token.is_lifetime() {\n             let lt = self.expect_lifetime();\n-            Ok(self.recover_unclosed_char(lt.ident, err))\n+            Ok(self.recover_unclosed_char(lt.ident, mk_lit_char, err))\n         } else {\n             Err(err(self))\n         }\n@@ -1808,11 +1825,13 @@ impl<'a> Parser<'a> {\n     pub(super) fn parse_token_lit(&mut self) -> PResult<'a, (token::Lit, Span)> {\n         self.parse_opt_token_lit()\n             .ok_or(())\n-            .or_else(|()| self.handle_missing_lit().map(|lit| (lit.token_lit, lit.span)))\n+            .or_else(|()| self.handle_missing_lit(Parser::mk_token_lit_char))\n     }\n \n     pub(super) fn parse_meta_item_lit(&mut self) -> PResult<'a, MetaItemLit> {\n-        self.parse_opt_meta_item_lit().ok_or(()).or_else(|()| self.handle_missing_lit())\n+        self.parse_opt_meta_item_lit()\n+            .ok_or(())\n+            .or_else(|()| self.handle_missing_lit(Parser::mk_meta_item_lit_char))\n     }\n \n     fn recover_after_dot(&mut self) -> Option<Token> {"}, {"sha": "7c2d01509de417b100c281abf1a6863106d05ee0", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -22,7 +22,6 @@ use rustc_span::lev_distance::lev_distance;\n use rustc_span::source_map::{self, Span};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::DUMMY_SP;\n-use std::convert::TryFrom;\n use std::mem;\n use thin_vec::ThinVec;\n use tracing::debug;\n@@ -708,9 +707,9 @@ impl<'a> Parser<'a> {\n             }\n             match parse_item(self) {\n                 Ok(None) => {\n-                    let is_unnecessary_semicolon = !items.is_empty()\n+                    let mut is_unnecessary_semicolon = !items.is_empty()\n                         // When the close delim is `)` in a case like the following, `token.kind` is expected to be `token::CloseDelim(Delimiter::Parenthesis)`,\n-                        // but the actual `token.kind` is `token::CloseDelim(Delimiter::Bracket)`.\n+                        // but the actual `token.kind` is `token::CloseDelim(Delimiter::Brace)`.\n                         // This is because the `token.kind` of the close delim is treated as the same as\n                         // that of the open delim in `TokenTreesReader::parse_token_tree`, even if the delimiters of them are different.\n                         // Therefore, `token.kind` should not be compared here.\n@@ -729,7 +728,13 @@ impl<'a> Parser<'a> {\n                             .span_to_snippet(self.prev_token.span)\n                             .map_or(false, |snippet| snippet == \"}\")\n                         && self.token.kind == token::Semi;\n-                    let semicolon_span = self.token.span;\n+                    let mut semicolon_span = self.token.span;\n+                    if !is_unnecessary_semicolon {\n+                        // #105369, Detect spurious `;` before assoc fn body\n+                        is_unnecessary_semicolon = self.token == token::OpenDelim(Delimiter::Brace)\n+                            && self.prev_token.kind == token::Semi;\n+                        semicolon_span = self.prev_token.span;\n+                    }\n                     // We have to bail or we'll potentially never make progress.\n                     let non_item_span = self.token.span;\n                     let is_let = self.token.is_keyword(kw::Let);"}, {"sha": "a1981e11477753b4506a5f2770e71570e1eb2c57", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -411,16 +411,20 @@ impl<'a> Parser<'a> {\n         {\n             // Recover a `'a` as a `'a'` literal\n             let lt = self.expect_lifetime();\n-            let lit = self.recover_unclosed_char(lt.ident, |self_| {\n-                let expected = expected.unwrap_or(\"pattern\");\n-                let msg =\n-                    format!(\"expected {}, found {}\", expected, super::token_descr(&self_.token));\n+            let (lit, _) =\n+                self.recover_unclosed_char(lt.ident, Parser::mk_token_lit_char, |self_| {\n+                    let expected = expected.unwrap_or(\"pattern\");\n+                    let msg = format!(\n+                        \"expected {}, found {}\",\n+                        expected,\n+                        super::token_descr(&self_.token)\n+                    );\n \n-                let mut err = self_.struct_span_err(self_.token.span, &msg);\n-                err.span_label(self_.token.span, format!(\"expected {}\", expected));\n-                err\n-            });\n-            PatKind::Lit(self.mk_expr(lo, ExprKind::Lit(lit.token_lit)))\n+                    let mut err = self_.struct_span_err(self_.token.span, &msg);\n+                    err.span_label(self_.token.span, format!(\"expected {}\", expected));\n+                    err\n+                });\n+            PatKind::Lit(self.mk_expr(lo, ExprKind::Lit(lit)))\n         } else {\n             // Try to parse everything else as literal with optional minus\n             match self.parse_literal_maybe_minus() {"}, {"sha": "bae7f2670cb11689866e837b411160d0cebe7552", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -164,7 +164,7 @@ impl<'a> Parser<'a> {\n             // Perform this outside of the `collect_tokens_trailing_token` closure,\n             // since our outer attributes do not apply to this part of the expression\n             let expr = self.with_res(Restrictions::STMT_EXPR, |this| {\n-                this.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(expr))\n+                this.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(expr, true))\n             })?;\n             Ok(self.mk_stmt(lo.to(self.prev_token.span), StmtKind::Expr(expr)))\n         } else {\n@@ -198,7 +198,7 @@ impl<'a> Parser<'a> {\n             let e = self.mk_expr(lo.to(hi), ExprKind::MacCall(mac));\n             let e = self.maybe_recover_from_bad_qpath(e)?;\n             let e = self.parse_dot_or_call_expr_with(e, lo, attrs)?;\n-            let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n+            let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e, false))?;\n             StmtKind::Expr(e)\n         };\n         Ok(self.mk_stmt(lo.to(hi), kind))"}, {"sha": "72d38aeac7a0c0647f176fe451143d3cc1611354", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 22, "deletions": 29, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d67703e75912a0f58b43feae8ee8b5b20504dfe/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=3d67703e75912a0f58b43feae8ee8b5b20504dfe", "patch": "@@ -88,10 +88,7 @@ trait DefIdVisitor<'tcx> {\n     fn visit_trait(&mut self, trait_ref: TraitRef<'tcx>) -> ControlFlow<Self::BreakTy> {\n         self.skeleton().visit_trait(trait_ref)\n     }\n-    fn visit_projection_ty(\n-        &mut self,\n-        projection: ty::ProjectionTy<'tcx>,\n-    ) -> ControlFlow<Self::BreakTy> {\n+    fn visit_projection_ty(&mut self, projection: ty::AliasTy<'tcx>) -> ControlFlow<Self::BreakTy> {\n         self.skeleton().visit_projection_ty(projection)\n     }\n     fn visit_predicates(\n@@ -113,29 +110,25 @@ where\n     V: DefIdVisitor<'tcx> + ?Sized,\n {\n     fn visit_trait(&mut self, trait_ref: TraitRef<'tcx>) -> ControlFlow<V::BreakTy> {\n-        let TraitRef { def_id, substs } = trait_ref;\n+        let TraitRef { def_id, substs, .. } = trait_ref;\n         self.def_id_visitor.visit_def_id(def_id, \"trait\", &trait_ref.print_only_trait_path())?;\n         if self.def_id_visitor.shallow() { ControlFlow::CONTINUE } else { substs.visit_with(self) }\n     }\n \n-    fn visit_projection_ty(\n-        &mut self,\n-        projection: ty::ProjectionTy<'tcx>,\n-    ) -> ControlFlow<V::BreakTy> {\n+    fn visit_projection_ty(&mut self, projection: ty::AliasTy<'tcx>) -> ControlFlow<V::BreakTy> {\n         let tcx = self.def_id_visitor.tcx();\n-        let (trait_ref, assoc_substs) = if tcx.def_kind(projection.item_def_id)\n-            != DefKind::ImplTraitPlaceholder\n-        {\n-            projection.trait_ref_and_own_substs(tcx)\n-        } else {\n-            // HACK(RPITIT): Remove this when RPITITs are lowered to regular assoc tys\n-            let def_id = tcx.impl_trait_in_trait_parent(projection.item_def_id);\n-            let trait_generics = tcx.generics_of(def_id);\n-            (\n-                ty::TraitRef { def_id, substs: projection.substs.truncate_to(tcx, trait_generics) },\n-                &projection.substs[trait_generics.count()..],\n-            )\n-        };\n+        let (trait_ref, assoc_substs) =\n+            if tcx.def_kind(projection.def_id) != DefKind::ImplTraitPlaceholder {\n+                projection.trait_ref_and_own_substs(tcx)\n+            } else {\n+                // HACK(RPITIT): Remove this when RPITITs are lowered to regular assoc tys\n+                let def_id = tcx.impl_trait_in_trait_parent(projection.def_id);\n+                let trait_generics = tcx.generics_of(def_id);\n+                (\n+                    tcx.mk_trait_ref(def_id, projection.substs.truncate_to(tcx, trait_generics)),\n+                    &projection.substs[trait_generics.count()..],\n+                )\n+            };\n         self.visit_trait(trait_ref)?;\n         if self.def_id_visitor.shallow() {\n             ControlFlow::CONTINUE\n@@ -214,7 +207,7 @@ where\n                     }\n                 }\n             }\n-            ty::Projection(proj) => {\n+            ty::Alias(ty::Projection, proj) => {\n                 if self.def_id_visitor.skip_assoc_tys() {\n                     // Visitors searching for minimal visibility/reachability want to\n                     // conservatively approximate associated types like `<Type as Trait>::Alias`\n@@ -241,7 +234,7 @@ where\n                     self.def_id_visitor.visit_def_id(def_id, \"trait\", &trait_ref)?;\n                 }\n             }\n-            ty::Opaque(def_id, ..) => {\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }) => {\n                 // Skip repeated `Opaque`s to avoid infinite recursion.\n                 if self.visited_opaque_tys.insert(def_id) {\n                     // The intent is to treat `impl Trait1 + Trait2` identically to\n@@ -1308,15 +1301,15 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n             let is_local_static =\n                 if let DefKind::Static(_) = kind { def_id.is_local() } else { false };\n             if !self.item_is_accessible(def_id) && !is_local_static {\n-                let sess = self.tcx.sess;\n-                let sm = sess.source_map();\n-                let name = match qpath {\n-                    hir::QPath::Resolved(..) | hir::QPath::LangItem(..) => {\n-                        sm.span_to_snippet(qpath.span()).ok()\n+                let name = match *qpath {\n+                    hir::QPath::LangItem(it, ..) => {\n+                        self.tcx.lang_items().get(it).map(|did| self.tcx.def_path_str(did))\n                     }\n+                    hir::QPath::Resolved(_, path) => Some(self.tcx.def_path_str(path.res.def_id())),\n                     hir::QPath::TypeRelative(_, segment) => Some(segment.ident.to_string()),\n                 };\n                 let kind = kind.descr(def_id);\n+                let sess = self.tcx.sess;\n                 let _ = match name {\n                     Some(name) => {\n                         sess.emit_err(ItemIsPrivate { span, kind, descr: (&name).into() })"}]}