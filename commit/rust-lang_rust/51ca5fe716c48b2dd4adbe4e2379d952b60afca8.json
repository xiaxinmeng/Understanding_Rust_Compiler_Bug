{"sha": "51ca5fe716c48b2dd4adbe4e2379d952b60afca8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxY2E1ZmU3MTZjNDhiMmRkNGFkYmU0ZTIzNzlkOTUyYjYwYWZjYTg=", "commit": {"author": {"name": "lukaramu", "email": "lukaramu@users.noreply.github.com", "date": "2017-04-17T20:37:27Z"}, "committer": {"name": "lukaramu", "email": "lukaramu@users.noreply.github.com", "date": "2017-04-17T20:37:27Z"}, "message": "Restructure and redistribute std::path's module docs\n\nPart of #29368.\n* Added a new summary paragraph about std::path's parsing facilities\n* Slightly exanded `Component`'s docs\n* removed the now redundant section on component types from the module docs\n* moved the section on path normalization during parsing to the docs on\n  `Path::components`\n* Clarified difference between `Prefix` and `PrefixComponent` in their\n  respecive summary sentences", "tree": {"sha": "0d81df50f72baf1feb80a19651e7bc21905876e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d81df50f72baf1feb80a19651e7bc21905876e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51ca5fe716c48b2dd4adbe4e2379d952b60afca8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51ca5fe716c48b2dd4adbe4e2379d952b60afca8", "html_url": "https://github.com/rust-lang/rust/commit/51ca5fe716c48b2dd4adbe4e2379d952b60afca8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51ca5fe716c48b2dd4adbe4e2379d952b60afca8/comments", "author": null, "committer": null, "parents": [{"sha": "8c21b601367c4ee8c9b1554941189fdd09c8abb2", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c21b601367c4ee8c9b1554941189fdd09c8abb2", "html_url": "https://github.com/rust-lang/rust/commit/8c21b601367c4ee8c9b1554941189fdd09c8abb2"}], "stats": {"total": 119, "additions": 55, "deletions": 64}, "files": [{"sha": "9c8eeb0c52161d87d4cf3ffdfded56badc4e884c", "filename": "src/libstd/path.rs", "status": "modified", "additions": 55, "deletions": 64, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/51ca5fe716c48b2dd4adbe4e2379d952b60afca8/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ca5fe716c48b2dd4adbe4e2379d952b60afca8/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=51ca5fe716c48b2dd4adbe4e2379d952b60afca8", "patch": "@@ -10,11 +10,18 @@\n \n //! Cross-platform path manipulation.\n //!\n-//! This module provides two types, [`PathBuf`] and [`Path`][`Path`] (akin to [`String`]\n+//! This module provides two types, [`PathBuf`] and [`Path`] (akin to [`String`]\n //! and [`str`]), for working with paths abstractly. These types are thin wrappers\n //! around [`OsString`] and [`OsStr`] respectively, meaning that they work directly\n //! on strings according to the local platform's path syntax.\n //!\n+//! Paths can be parsed into [`Component`]s by iterating over the structure\n+//! returned by the [`components`] method on [`Path`]. [`Component`]s roughly\n+//! correspond to the substrings between path separators (`/` or `\\`). You can\n+//! reconstruct an equivalent path from components with the [`push`] method on\n+//! [`PathBuf`]; note that the paths may differ syntactically by the\n+//! normalization described in the documentation for the [`components`] method.\n+//!\n //! ## Simple usage\n //!\n //! Path manipulation includes both parsing components from slices and building\n@@ -50,62 +57,11 @@\n //! path.set_extension(\"dll\");\n //! ```\n //!\n-//! ## Path components and normalization\n-//!\n-//! The path APIs are built around the notion of \"components\", which roughly\n-//! correspond to the substrings between path separators (`/` and, on Windows,\n-//! `\\`). The APIs for path parsing are largely specified in terms of the path's\n-//! components, so it's important to clearly understand how those are\n-//! determined.\n-//!\n-//! A path can always be reconstructed into an *equivalent* path by\n-//! putting together its components via `push`. Syntactically, the\n-//! paths may differ by the normalization described below.\n-//!\n-//! ### Component types\n-//!\n-//! Components come in several types:\n-//!\n-//! * Normal components are the default: standard references to files or\n-//! directories. The path `a/b` has two normal components, `a` and `b`.\n-//!\n-//! * Current directory components represent the `.` character. For example,\n-//! `./a` has a current directory component and a normal component `a`.\n-//!\n-//! * The root directory component represents a separator that designates\n-//!   starting from root. For example, `/a/b` has a root directory component\n-//!   followed by normal components `a` and `b`.\n-//!\n-//! On Windows, an additional component type comes into play:\n-//!\n-//! * Prefix components, of which there is a large variety. For example, `C:`\n-//! and `\\\\server\\share` are prefixes. The path `C:windows` has a prefix\n-//! component `C:` and a normal component `windows`; the path `C:\\windows` has a\n-//! prefix component `C:`, a root directory component, and a normal component\n-//! `windows`.\n-//!\n-//! ### Normalization\n-//!\n-//! Aside from splitting on the separator(s), there is a small amount of\n-//! \"normalization\":\n-//!\n-//! * Repeated separators are ignored: `a/b` and `a//b` both have components `a`\n-//!   and `b`.\n-//!\n-//! * Occurrences of `.` are normalized away, *except* if they are at\n-//! the beginning of the path (in which case they are often meaningful\n-//! in terms of path searching). So, for example, `a/./b`, `a/b/`,\n-//! `/a/b/.` and `a/b` all have components `a` and `b`, but `./a/b`\n-//! has a leading current directory component.\n-//!\n-//! No other normalization takes place by default. In particular,\n-//! `a/c` and `a/b/../c` are distinct, to account for the possibility\n-//! that `b` is a symbolic link (so its parent isn't `a`). Further\n-//! normalization is possible to build on top of the components APIs,\n-//! and will be included in this library in the near future.\n-//!\n+//! [`Component`]: ../../std/path/enum.Component.html\n+//! [`components`]: ../../std/path/struct.Path.html#method.components\n //! [`PathBuf`]: ../../std/path/struct.PathBuf.html\n //! [`Path`]: ../../std/path/struct.Path.html\n+//! [`push`]: ../../std/path/struct.PathBuf.html#method.push\n //! [`String`]: ../../std/string/struct.String.html\n //! [`str`]: ../../std/primitive.str.html\n //! [`OsString`]: ../../std/ffi/struct.OsString.html\n@@ -143,7 +99,7 @@ use sys::path::{is_sep_byte, is_verbatim_sep, MAIN_SEP_STR, parse_prefix};\n // Windows Prefixes\n ////////////////////////////////////////////////////////////////////////////////\n \n-/// Path prefixes (Windows only).\n+/// Windows path prefixes, e.g. `C:` or `\\\\server\\share`.\n ///\n /// Windows uses a variety of path prefix styles, including references to drive\n /// volumes (like `C:`), network shared folders (like `\\\\server\\share`), and\n@@ -415,7 +371,8 @@ enum State {\n     Done = 3,\n }\n \n-/// A Windows path prefix, e.g. `C:` or `\\\\server\\share`.\n+/// A structure wrapping a Windows path prefix as well as its unparsed string\n+/// representation.\n ///\n /// In addition to the parsed [`Prefix`] information returned by [`kind`],\n /// `PrefixComponent` also holds the raw and unparsed [`OsStr`] slice,\n@@ -511,11 +468,11 @@ impl<'a> Hash for PrefixComponent<'a> {\n \n /// A single component of a path.\n ///\n-/// See the module documentation for an in-depth explanation of components and\n-/// their role in the API.\n+/// A `Component` roughtly corresponds to a substring between path separators\n+/// (`/` or `\\`).\n ///\n-/// This `enum` is created from iterating over the [`path::Components`]\n-/// `struct`.\n+/// This `enum` is created by iterating over [`Components`], which in turn is\n+/// created by the [`components`][`Path::components`] method on [`Path`].\n ///\n /// # Examples\n ///\n@@ -532,19 +489,28 @@ impl<'a> Hash for PrefixComponent<'a> {\n /// ]);\n /// ```\n ///\n-/// [`path::Components`]: struct.Components.html\n+/// [`Components`]: struct.Components.html\n+/// [`Path`]: struct.Path.html\n+/// [`Path::components`]: struct.Path.html#method.components\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Component<'a> {\n     /// A Windows path prefix, e.g. `C:` or `\\\\server\\share`.\n     ///\n+    /// There is a large variety of prefix types, see [`Prefix`]'s documentation\n+    /// for more.\n+    ///\n     /// Does not occur on Unix.\n+    ///\n+    /// [`Prefix`]: enum.Prefix.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Prefix(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")] PrefixComponent<'a>\n     ),\n \n     /// The root directory component, appears after any prefix and before anything else.\n+    ///\n+    /// It represents a deperator that designates that a path starts from root.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     RootDir,\n \n@@ -557,6 +523,9 @@ pub enum Component<'a> {\n     ParentDir,\n \n     /// A normal component, e.g. `a` and `b` in `a/b`.\n+    ///\n+    /// This variant is the most common one, it represents references to files\n+    /// or directories.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Normal(#[stable(feature = \"rust1\", since = \"1.0.0\")] &'a OsStr),\n }\n@@ -1992,7 +1961,21 @@ impl Path {\n         buf\n     }\n \n-    /// Produces an iterator over the components of the path.\n+    /// Produces an iterator over the [`Component`]s of the path.\n+    ///\n+    /// When parsing the path, there is a small amount of normalization:\n+    ///\n+    /// * Repeated seperators are ignored, so `a/b` and `a//b` both have\n+    ///   `a` and `b` as components.\n+    ///\n+    /// * Occurentces of `.` are normalized away, exept if they are at the\n+    ///   beginning of the path. For example, `a/./b`, `a/b/`, `a/b/.` and\n+    ///   `a/b` all have `a` and `b` as components, but `./a/b` starts with\n+    ///   an additional [`CurDir`] component.\n+    ///\n+    /// Note that no other normalization takes place; in particular, `a/c`\n+    /// and `a/b/../c` are distinct, to account for the possibility that `b`\n+    /// is a symbolic link (so its parent isn't `a`).\n     ///\n     /// # Examples\n     ///\n@@ -2007,6 +1990,9 @@ impl Path {\n     /// assert_eq!(components.next(), Some(Component::Normal(OsStr::new(\"foo.txt\"))));\n     /// assert_eq!(components.next(), None)\n     /// ```\n+    ///\n+    /// [`Component`]: enum.Component.html\n+    /// [`CurDir`]: enum.Component.html#variant.CurDir\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn components(&self) -> Components {\n         let prefix = parse_prefix(self.as_os_str());\n@@ -2019,8 +2005,13 @@ impl Path {\n         }\n     }\n \n-    /// Produces an iterator over the path's components viewed as [`OsStr`] slices.\n+    /// Produces an iterator over the path's components viewed as [`OsStr`]\n+    /// slices.\n+    ///\n+    /// For more information about the particulars of how the path is separated\n+    /// into components, see [`components`].\n     ///\n+    /// [`components`]: #method.components\n     /// [`OsStr`]: ../ffi/struct.OsStr.html\n     ///\n     /// # Examples"}]}