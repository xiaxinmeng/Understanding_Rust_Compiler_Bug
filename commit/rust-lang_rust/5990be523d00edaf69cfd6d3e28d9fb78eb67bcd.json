{"sha": "5990be523d00edaf69cfd6d3e28d9fb78eb67bcd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5OTBiZTUyM2QwMGVkYWY2OWNmZDZkM2UyOGQ5ZmI3OGViNjdiY2Q=", "commit": {"author": {"name": "lukaramu", "email": "lukaramu@users.noreply.github.com", "date": "2017-08-07T15:09:43Z"}, "committer": {"name": "lukaramu", "email": "lukaramu@users.noreply.github.com", "date": "2017-08-07T21:10:16Z"}, "message": "Expand docs on `Deref` and `DerefMut`\n\nPart of #29365.\n* Expanded the explanaition sections, adapting some parts from the book,\n  the reference, as well as the API guidelines. As such, the docs now\n  explicitly state that `Deref` and `DerefMut` should only be implemented\n  for smart pointers and that they should not fail. Additionally, there\n  is now a short primer on `Deref` coercion.\n* Added links to `DerefMut` from `Deref` and vice versa\n* Added links to relevant reference sections\n* Removed \"stuttering\" in summary sentences\n* Changed summary sentences of `Deref::deref` and `Deref::deref_mut` to\n  be in 3rd person singular\n* Removed explicit uses of `fn main()` in the examples", "tree": {"sha": "e789e035dc85f97957ab7c959ba4f5825a84a8fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e789e035dc85f97957ab7c959ba4f5825a84a8fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5990be523d00edaf69cfd6d3e28d9fb78eb67bcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5990be523d00edaf69cfd6d3e28d9fb78eb67bcd", "html_url": "https://github.com/rust-lang/rust/commit/5990be523d00edaf69cfd6d3e28d9fb78eb67bcd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5990be523d00edaf69cfd6d3e28d9fb78eb67bcd/comments", "author": null, "committer": null, "parents": [{"sha": "f2ff646f5f71fd89b19ec11d7bb03128156f1af9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2ff646f5f71fd89b19ec11d7bb03128156f1af9", "html_url": "https://github.com/rust-lang/rust/commit/f2ff646f5f71fd89b19ec11d7bb03128156f1af9"}], "stats": {"total": 102, "additions": 78, "deletions": 24}, "files": [{"sha": "ac5ff1556f4debd74127462b88a8c30ce3a48548", "filename": "src/libcore/ops/deref.rs", "status": "modified", "additions": 78, "deletions": 24, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/5990be523d00edaf69cfd6d3e28d9fb78eb67bcd/src%2Flibcore%2Fops%2Fderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5990be523d00edaf69cfd6d3e28d9fb78eb67bcd/src%2Flibcore%2Fops%2Fderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fderef.rs?ref=5990be523d00edaf69cfd6d3e28d9fb78eb67bcd", "patch": "@@ -8,16 +8,44 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/// The `Deref` trait is used to specify the functionality of dereferencing\n-/// operations, like `*v`.\n+/// Used for immutable dereferencing operations, like `*v`.\n ///\n-/// `Deref` also enables ['`Deref` coercions'][coercions].\n+/// In addition to being used for explicit dereferencing operations with the\n+/// (unary) `*` operator in immutable contexts, `Deref` is also used implicitly\n+/// by the compiler in many circumstances. This mechanism is called\n+/// ['`Deref` coercion'][more]. In mutable contexts, [`DerefMut`] is used.\n ///\n-/// [coercions]: ../../book/first-edition/deref-coercions.html\n+/// Implementing `Deref` for smart pointers makes accessing the data behind them\n+/// convenient, which is why they implement `Deref`. On the other hand, the\n+/// rules regarding `Deref` and [`DerefMut`] were designed specifically to\n+/// accomodate smart pointers. Because of this, **`Deref` should only be\n+/// implemented for smart pointers** to avoid confusion.\n+///\n+/// For similar reasons, **this trait should never fail**. Failure during\n+/// dereferencing can be extremely confusing when `Deref` is invoked implicitly.\n+///\n+/// # More on `Deref` coercion\n+///\n+/// If `T` implements `Deref<Target = U>`, and `x` is a value of type `T`, then:\n+/// * In immutable contexts, `*x` on non-pointer types is equivalent to\n+///   `*Deref::deref(&x)`.\n+/// * Values of type `&T` are coerced to values of type `&U`\n+/// * `T` implicitly implements all the (immutable) methods of the type `U`.\n+///\n+/// For more details, visit [the chapter in *The Rust Programming Language*]\n+/// [book] as well as the reference sections on [the dereference operator]\n+/// [ref-deref-op], [the `Deref` trait][ref-deref-trait], and [type coercions].\n+///\n+/// [book]: ../../book/second-edition/ch15-02-deref.html\n+/// [`DerefMut`]: trait.DerefMut.html\n+/// [more]: #more-on-deref-coercion\n+/// [ref-deref-op]: ../../reference/expressions.html#the-dereference-operator\n+/// [ref-deref-trait]: ../../reference/the-deref-trait.html\n+/// [type coercions]: ../../reference/type-coercions.html\n ///\n /// # Examples\n ///\n-/// A struct with a single field which is accessible via dereferencing the\n+/// A struct with a single field which is accessible by dereferencing the\n /// struct.\n ///\n /// ```\n@@ -35,19 +63,17 @@\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     let x = DerefExample { value: 'a' };\n-///     assert_eq!('a', *x);\n-/// }\n+/// let x = DerefExample { value: 'a' };\n+/// assert_eq!('a', *x);\n /// ```\n #[lang = \"deref\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Deref {\n-    /// The resulting type after dereferencing\n+    /// The resulting type after dereferencing.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Target: ?Sized;\n \n-    /// The method called to dereference a value\n+    /// Dereferences the value.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn deref(&self) -> &Self::Target;\n }\n@@ -66,16 +92,46 @@ impl<'a, T: ?Sized> Deref for &'a mut T {\n     fn deref(&self) -> &T { *self }\n }\n \n-/// The `DerefMut` trait is used to specify the functionality of dereferencing\n-/// mutably like `*v = 1;`\n-///\n-/// `DerefMut` also enables ['`Deref` coercions'][coercions].\n-///\n-/// [coercions]: ../../book/first-edition/deref-coercions.html\n+/// Used for mutable dereferencing operations, like in `*v = 1;`.\n+///\n+/// In addition to being used for explicit dereferencing operations with the\n+/// (unary) `*` operator in mutable contexts, `DerefMut` is also used implicitly\n+/// by the compiler in many circumstances. This mechanism is called\n+/// ['`Deref` coercion'][more]. In immutable contexts, [`Deref`] is used.\n+///\n+/// Implementing `DerefMut` for smart pointers makes mutating the data behind\n+/// them convenient, which is why they implement `DerefMut`. On the other hand,\n+/// the rules regarding [`Deref`] and `DerefMut` were designed specifically to\n+/// accomodate smart pointers. Because of this, **`DerefMut` should only be\n+/// implemented for smart pointers** to avoid confusion.\n+///\n+/// For similar reasons, **this trait should never fail**. Failure during\n+/// dereferencing can be extremely confusing when `DerefMut` is invoked\n+/// implicitly.\n+///\n+/// # More on `Deref` coercion\n+///\n+/// If `T` implements `MutDeref<Target = U>`, and `x` is a value of type `T`,\n+/// then:\n+/// * In mutable contexts, `*x` on non-pointer types is equivalent to\n+///   `*Deref::deref(&x)`.\n+/// * Values of type `&mut T` are coerced to values of type `&mut U`\n+/// * `T` implicitly implements all the (mutable) methods of the type `U`.\n+///\n+/// For more details, visit [the chapter in *The Rust Programming Language*]\n+/// [book] as well as the reference sections on [the dereference operator]\n+/// [ref-deref-op], [the `Deref` trait][ref-deref-trait], and [type coercions].\n+///\n+/// [book]: ../../book/second-edition/ch15-02-deref.html\n+/// [`Deref`]: trait.Deref.html\n+/// [more]: #more-on-deref-coercion\n+/// [ref-deref-op]: ../../reference/expressions.html#the-dereference-operator\n+/// [ref-deref-trait]: ../../reference/the-deref-trait.html\n+/// [type coercions]: ../../reference/type-coercions.html\n ///\n /// # Examples\n ///\n-/// A struct with a single field which is modifiable via dereferencing the\n+/// A struct with a single field which is modifiable by dereferencing the\n /// struct.\n ///\n /// ```\n@@ -99,16 +155,14 @@ impl<'a, T: ?Sized> Deref for &'a mut T {\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     let mut x = DerefMutExample { value: 'a' };\n-///     *x = 'b';\n-///     assert_eq!('b', *x);\n-/// }\n+/// let mut x = DerefMutExample { value: 'a' };\n+/// *x = 'b';\n+/// assert_eq!('b', *x);\n /// ```\n #[lang = \"deref_mut\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait DerefMut: Deref {\n-    /// The method called to mutably dereference a value\n+    /// Mutably dereferences the value.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn deref_mut(&mut self) -> &mut Self::Target;\n }"}]}