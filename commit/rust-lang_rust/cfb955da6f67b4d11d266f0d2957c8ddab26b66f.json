{"sha": "cfb955da6f67b4d11d266f0d2957c8ddab26b66f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmYjk1NWRhNmY2N2I0ZDExZDI2NmYwZDI5NTdjOGRkYWIyNmI2NmY=", "commit": {"author": {"name": "Eric Huss", "email": "eric@huss.org", "date": "2020-08-20T18:00:41Z"}, "committer": {"name": "Eric Huss", "email": "eric@huss.org", "date": "2020-09-15T14:01:13Z"}, "message": "Consolidate wasi alloc with unix alloc.", "tree": {"sha": "7d4b3bd6a425ffd45ba342cdd5e304510ee6a97a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d4b3bd6a425ffd45ba342cdd5e304510ee6a97a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cfb955da6f67b4d11d266f0d2957c8ddab26b66f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cfb955da6f67b4d11d266f0d2957c8ddab26b66f", "html_url": "https://github.com/rust-lang/rust/commit/cfb955da6f67b4d11d266f0d2957c8ddab26b66f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cfb955da6f67b4d11d266f0d2957c8ddab26b66f/comments", "author": {"login": "ehuss", "id": 43198, "node_id": "MDQ6VXNlcjQzMTk4", "avatar_url": "https://avatars.githubusercontent.com/u/43198?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ehuss", "html_url": "https://github.com/ehuss", "followers_url": "https://api.github.com/users/ehuss/followers", "following_url": "https://api.github.com/users/ehuss/following{/other_user}", "gists_url": "https://api.github.com/users/ehuss/gists{/gist_id}", "starred_url": "https://api.github.com/users/ehuss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ehuss/subscriptions", "organizations_url": "https://api.github.com/users/ehuss/orgs", "repos_url": "https://api.github.com/users/ehuss/repos", "events_url": "https://api.github.com/users/ehuss/events{/privacy}", "received_events_url": "https://api.github.com/users/ehuss/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ehuss", "id": 43198, "node_id": "MDQ6VXNlcjQzMTk4", "avatar_url": "https://avatars.githubusercontent.com/u/43198?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ehuss", "html_url": "https://github.com/ehuss", "followers_url": "https://api.github.com/users/ehuss/followers", "following_url": "https://api.github.com/users/ehuss/following{/other_user}", "gists_url": "https://api.github.com/users/ehuss/gists{/gist_id}", "starred_url": "https://api.github.com/users/ehuss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ehuss/subscriptions", "organizations_url": "https://api.github.com/users/ehuss/orgs", "repos_url": "https://api.github.com/users/ehuss/repos", "events_url": "https://api.github.com/users/ehuss/events{/privacy}", "received_events_url": "https://api.github.com/users/ehuss/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a4098ed0fb0b8aea373a7af8ace57da98b09fec", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a4098ed0fb0b8aea373a7af8ace57da98b09fec", "html_url": "https://github.com/rust-lang/rust/commit/5a4098ed0fb0b8aea373a7af8ace57da98b09fec"}], "stats": {"total": 156, "additions": 45, "deletions": 111}, "files": [{"sha": "964abe8b8c9ea86ffe714811e897110ab488c083", "filename": "library/std/src/sys/unix/alloc.rs", "status": "modified", "additions": 44, "deletions": 42, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/cfb955da6f67b4d11d266f0d2957c8ddab26b66f/library%2Fstd%2Fsrc%2Fsys%2Funix%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfb955da6f67b4d11d266f0d2957c8ddab26b66f/library%2Fstd%2Fsrc%2Fsys%2Funix%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Falloc.rs?ref=cfb955da6f67b4d11d266f0d2957c8ddab26b66f", "patch": "@@ -52,46 +52,48 @@ unsafe impl GlobalAlloc for System {\n     }\n }\n \n-#[cfg(any(\n-    target_os = \"android\",\n-    target_os = \"illumos\",\n-    target_os = \"redox\",\n-    target_os = \"solaris\"\n-))]\n-#[inline]\n-unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n-    // On android we currently target API level 9 which unfortunately\n-    // doesn't have the `posix_memalign` API used below. Instead we use\n-    // `memalign`, but this unfortunately has the property on some systems\n-    // where the memory returned cannot be deallocated by `free`!\n-    //\n-    // Upon closer inspection, however, this appears to work just fine with\n-    // Android, so for this platform we should be fine to call `memalign`\n-    // (which is present in API level 9). Some helpful references could\n-    // possibly be chromium using memalign [1], attempts at documenting that\n-    // memalign + free is ok [2] [3], or the current source of chromium\n-    // which still uses memalign on android [4].\n-    //\n-    // [1]: https://codereview.chromium.org/10796020/\n-    // [2]: https://code.google.com/p/android/issues/detail?id=35391\n-    // [3]: https://bugs.chromium.org/p/chromium/issues/detail?id=138579\n-    // [4]: https://chromium.googlesource.com/chromium/src/base/+/master/\n-    //                                       /memory/aligned_memory.cc\n-    libc::memalign(layout.align(), layout.size()) as *mut u8\n-}\n-\n-#[cfg(not(any(\n-    target_os = \"android\",\n-    target_os = \"illumos\",\n-    target_os = \"redox\",\n-    target_os = \"solaris\"\n-)))]\n-#[inline]\n-unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n-    let mut out = ptr::null_mut();\n-    // posix_memalign requires that the alignment be a multiple of `sizeof(void*)`.\n-    // Since these are all powers of 2, we can just use max.\n-    let align = layout.align().max(crate::mem::size_of::<usize>());\n-    let ret = libc::posix_memalign(&mut out, align, layout.size());\n-    if ret != 0 { ptr::null_mut() } else { out as *mut u8 }\n+cfg_if::cfg_if! {\n+    if #[cfg(any(\n+        target_os = \"android\",\n+        target_os = \"illumos\",\n+        target_os = \"redox\",\n+        target_os = \"solaris\"\n+    ))] {\n+        #[inline]\n+        unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n+            // On android we currently target API level 9 which unfortunately\n+            // doesn't have the `posix_memalign` API used below. Instead we use\n+            // `memalign`, but this unfortunately has the property on some systems\n+            // where the memory returned cannot be deallocated by `free`!\n+            //\n+            // Upon closer inspection, however, this appears to work just fine with\n+            // Android, so for this platform we should be fine to call `memalign`\n+            // (which is present in API level 9). Some helpful references could\n+            // possibly be chromium using memalign [1], attempts at documenting that\n+            // memalign + free is ok [2] [3], or the current source of chromium\n+            // which still uses memalign on android [4].\n+            //\n+            // [1]: https://codereview.chromium.org/10796020/\n+            // [2]: https://code.google.com/p/android/issues/detail?id=35391\n+            // [3]: https://bugs.chromium.org/p/chromium/issues/detail?id=138579\n+            // [4]: https://chromium.googlesource.com/chromium/src/base/+/master/\n+            //                                       /memory/aligned_memory.cc\n+            libc::memalign(layout.align(), layout.size()) as *mut u8\n+        }\n+    } else if #[cfg(target_os = \"wasi\")] {\n+        #[inline]\n+        unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n+            libc::aligned_alloc(layout.align(), layout.size()) as *mut u8\n+        }\n+    } else {\n+        #[inline]\n+        unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n+            let mut out = ptr::null_mut();\n+            // posix_memalign requires that the alignment be a multiple of `sizeof(void*)`.\n+            // Since these are all powers of 2, we can just use max.\n+            let align = layout.align().max(crate::mem::size_of::<usize>());\n+            let ret = libc::posix_memalign(&mut out, align, layout.size());\n+            if ret != 0 { ptr::null_mut() } else { out as *mut u8 }\n+        }\n+    }\n }"}, {"sha": "4d0afe27bb8b2ed0943676ca253a180b92fae215", "filename": "library/std/src/sys/wasi/alloc.rs", "status": "removed", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/5a4098ed0fb0b8aea373a7af8ace57da98b09fec/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a4098ed0fb0b8aea373a7af8ace57da98b09fec/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Falloc.rs?ref=5a4098ed0fb0b8aea373a7af8ace57da98b09fec", "patch": "@@ -1,69 +0,0 @@\n-#![deny(unsafe_op_in_unsafe_fn)]\n-\n-use crate::alloc::{GlobalAlloc, Layout, System};\n-use crate::ptr;\n-use crate::sys_common::alloc::{realloc_fallback, MIN_ALIGN};\n-\n-// SAFETY: All methods implemented follow the contract rules defined\n-// in `GlobalAlloc`.\n-#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n-unsafe impl GlobalAlloc for System {\n-    #[inline]\n-    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n-        if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n-            // SAFETY: `libc::malloc` is guaranteed to be safe, it will allocate\n-            // `layout.size()` bytes of memory and return a pointer to it\n-            unsafe { libc::malloc(layout.size()) as *mut u8 }\n-        } else {\n-            // SAFETY: `libc::aligned_alloc` is guaranteed to be safe if\n-            // `layout.size()` is a multiple of `layout.align()`. This\n-            // constraint can be satisfied if `pad_to_align` is called,\n-            // which creates a layout by rounding the size of this layout up\n-            // to a multiple of the layout's alignment\n-            let aligned_layout = layout.pad_to_align();\n-            unsafe { libc::aligned_alloc(aligned_layout.align(), aligned_layout.size()) as *mut u8 }\n-        }\n-    }\n-\n-    #[inline]\n-    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n-        if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n-            // SAFETY: `libc::calloc` is safe as long that `layout.size() * 1`\n-            // would not result in integer overflow which cannot happen,\n-            // multiplying by one never overflows\n-            unsafe { libc::calloc(layout.size(), 1) as *mut u8 }\n-        } else {\n-            // SAFETY: The safety contract for `alloc` must be upheld by the caller\n-            let ptr = unsafe { self.alloc(layout.clone()) };\n-            if !ptr.is_null() {\n-                // SAFETY: in the case of the `ptr` being not null\n-                // it will be properly aligned and a valid ptr\n-                // which satisfies `ptr::write_bytes` safety constrains\n-                unsafe { ptr::write_bytes(ptr, 0, layout.size()) };\n-            }\n-            ptr\n-        }\n-    }\n-\n-    #[inline]\n-    unsafe fn dealloc(&self, ptr: *mut u8, _layout: Layout) {\n-        // SAFETY: `libc::free` is guaranteed to be safe if `ptr` is allocated\n-        // by this allocator or if `ptr` is NULL\n-        unsafe { libc::free(ptr as *mut libc::c_void) }\n-    }\n-\n-    #[inline]\n-    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n-        if layout.align() <= MIN_ALIGN && layout.align() <= new_size {\n-            // SAFETY: `libc::realloc` is safe if `ptr` is allocated by this\n-            // allocator or NULL\n-            // - If `new_size` is 0 and `ptr` is not NULL, it will act as `libc::free`\n-            // - If `new_size` is not 0 and `ptr` is NULL, it will act as `libc::malloc`\n-            // - Else, it will resize the block accordingly\n-            unsafe { libc::realloc(ptr as *mut libc::c_void, new_size) as *mut u8 }\n-        } else {\n-            // SAFETY: The safety contract for `realloc_fallback` must be upheld by the caller\n-            unsafe { realloc_fallback(self, ptr, layout, new_size) }\n-        }\n-    }\n-}"}, {"sha": "a379fc891a8576c891b68456381b3b17879fb2b7", "filename": "library/std/src/sys/wasi/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cfb955da6f67b4d11d266f0d2957c8ddab26b66f/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfb955da6f67b4d11d266f0d2957c8ddab26b66f/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fmod.rs?ref=cfb955da6f67b4d11d266f0d2957c8ddab26b66f", "patch": "@@ -17,6 +17,7 @@\n use crate::io as std_io;\n use crate::mem;\n \n+#[path = \"../unix/alloc.rs\"]\n pub mod alloc;\n pub mod args;\n #[path = \"../unsupported/cmath.rs\"]"}]}