{"sha": "532a08b94726a399a4203b54536e63f7b634d36d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzMmEwOGI5NDcyNmEzOTlhNDIwM2I1NDUzNmU2M2Y3YjYzNGQzNmQ=", "commit": {"author": {"name": "Taylor Cramer", "email": "cramertj@google.com", "date": "2017-06-12T04:58:12Z"}, "committer": {"name": "Taylor Cramer", "email": "cramertj@google.com", "date": "2017-06-14T07:12:59Z"}, "message": "Add CrateNum-taking ability to the provide macro", "tree": {"sha": "b5e9d5e15cf57156d1d83448e10d259ff8e214d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5e9d5e15cf57156d1d83448e10d259ff8e214d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/532a08b94726a399a4203b54536e63f7b634d36d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/532a08b94726a399a4203b54536e63f7b634d36d", "html_url": "https://github.com/rust-lang/rust/commit/532a08b94726a399a4203b54536e63f7b634d36d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/532a08b94726a399a4203b54536e63f7b634d36d/comments", "author": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f710530a7c0be1acaa099b12163ec1af8b8cf30", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f710530a7c0be1acaa099b12163ec1af8b8cf30", "html_url": "https://github.com/rust-lang/rust/commit/9f710530a7c0be1acaa099b12163ec1af8b8cf30"}], "stats": {"total": 160, "additions": 92, "deletions": 68}, "files": [{"sha": "6c4c90585b3c124fd37d5fcb4036b26ccdaf2e03", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/532a08b94726a399a4203b54536e63f7b634d36d/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/532a08b94726a399a4203b54536e63f7b634d36d/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=532a08b94726a399a4203b54536e63f7b634d36d", "patch": "@@ -305,6 +305,7 @@ define_dep_nodes!(\n     // Represents the metadata for a given HIR node, typically found\n     // in an extern crate.\n     MetaData(DefId),\n+    MetaDataByCrateNum(CrateNum),\n \n     // Represents some artifact that we save to disk. Note that these\n     // do not have a def-id as part of their identifier."}, {"sha": "6314ffd30204dec8c6468c1fccfa5b78085a1bed", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 91, "deletions": 68, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/532a08b94726a399a4203b54536e63f7b634d36d/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/532a08b94726a399a4203b54536e63f7b634d36d/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=532a08b94726a399a4203b54536e63f7b634d36d", "patch": "@@ -40,10 +40,17 @@ use rustc::hir::svh::Svh;\n use rustc::hir;\n \n macro_rules! provide {\n-    (<$lt:tt> $tcx:ident, $def_id:ident, $cdata:ident $($name:ident => $compute:block)*) => {\n+    (<$lt:tt> $tcx:ident, $def_id:ident, $cdata:ident, $cnum:ident,\n+        ByDefId {\n+            $($cdata_fn_name:ident => $cdata_fn_compute:block)*\n+        }\n+        ByCrateNum {\n+            $($cnum_fn_name:ident => $cnum_fn_compute:block)*\n+        }\n+    )=> {\n         pub fn provide<$lt>(providers: &mut Providers<$lt>) {\n-            $(fn $name<'a, $lt:$lt>($tcx: TyCtxt<'a, $lt, $lt>, $def_id: DefId)\n-                                    -> <ty::queries::$name<$lt> as\n+            $(fn $cdata_fn_name<'a, $lt:$lt>($tcx: TyCtxt<'a, $lt, $lt>, $def_id: DefId)\n+                                    -> <ty::queries::$cdata_fn_name<$lt> as\n                                         DepTrackingMapConfig>::Value {\n                 assert!(!$def_id.is_local());\n \n@@ -55,82 +62,98 @@ macro_rules! provide {\n                 let $cdata = $tcx.sess.cstore.crate_data_as_rc_any($def_id.krate);\n                 let $cdata = $cdata.downcast_ref::<cstore::CrateMetadata>()\n                     .expect(\"CrateStore crated ata is not a CrateMetadata\");\n-                $compute\n+                $cdata_fn_compute\n+            })*\n+\n+            $(fn $cnum_fn_name<'a, $lt:$lt>($tcx: TyCtxt<'a, $lt, $lt>, $cnum: CrateNum)\n+                        -> <ty::queries::$cnum_fn_name<$lt> as\n+                            DepTrackingMapConfig>::Value {\n+                let $cdata = $tcx.sess.cstore.crate_data_as_rc_any($cnum);\n+                let $cdata = $cdata.downcast_ref::<cstore::CrateMetadata>()\n+                    .expect(\"CrateStore crated ata is not a CrateMetadata\");\n+                $cnum_fn_compute\n             })*\n \n             *providers = Providers {\n-                $($name,)*\n+                $($cdata_fn_name,)*\n+                $($cnum_fn_name,)*\n                 ..*providers\n             };\n         }\n     }\n }\n \n-provide! { <'tcx> tcx, def_id, cdata\n-    type_of => { cdata.get_type(def_id.index, tcx) }\n-    generics_of => { tcx.alloc_generics(cdata.get_generics(def_id.index)) }\n-    predicates_of => { cdata.get_predicates(def_id.index, tcx) }\n-    super_predicates_of => { cdata.get_super_predicates(def_id.index, tcx) }\n-    trait_def => {\n-        tcx.alloc_trait_def(cdata.get_trait_def(def_id.index))\n-    }\n-    adt_def => { cdata.get_adt_def(def_id.index, tcx) }\n-    adt_destructor => {\n-        let _ = cdata;\n-        tcx.calculate_dtor(def_id, &mut |_,_| Ok(()))\n-    }\n-    variances_of => { Rc::new(cdata.get_item_variances(def_id.index)) }\n-    associated_item_def_ids => {\n-        let mut result = vec![];\n-        cdata.each_child_of_item(def_id.index, |child| result.push(child.def.def_id()), tcx.sess);\n-        Rc::new(result)\n-    }\n-    associated_item => { cdata.get_associated_item(def_id.index) }\n-    impl_trait_ref => { cdata.get_impl_trait(def_id.index, tcx) }\n-    impl_polarity => { cdata.get_impl_polarity(def_id.index) }\n-    coerce_unsized_info => {\n-        cdata.get_coerce_unsized_info(def_id.index).unwrap_or_else(|| {\n-            bug!(\"coerce_unsized_info: `{:?}` is missing its info\", def_id);\n-        })\n+provide! { <'tcx> tcx, def_id, cdata, cnum,\n+    ByDefId {\n+        type_of => { cdata.get_type(def_id.index, tcx) }\n+        generics_of => { tcx.alloc_generics(cdata.get_generics(def_id.index)) }\n+        predicates_of => { cdata.get_predicates(def_id.index, tcx) }\n+        super_predicates_of => { cdata.get_super_predicates(def_id.index, tcx) }\n+        trait_def => {\n+            tcx.alloc_trait_def(cdata.get_trait_def(def_id.index))\n+        }\n+        adt_def => { cdata.get_adt_def(def_id.index, tcx) }\n+        adt_destructor => {\n+            let _ = cdata;\n+            tcx.calculate_dtor(def_id, &mut |_,_| Ok(()))\n+        }\n+        variances_of => { Rc::new(cdata.get_item_variances(def_id.index)) }\n+        associated_item_def_ids => {\n+            let mut result = vec![];\n+            cdata.each_child_of_item(def_id.index,\n+              |child| result.push(child.def.def_id()), tcx.sess);\n+            Rc::new(result)\n+        }\n+        associated_item => { cdata.get_associated_item(def_id.index) }\n+        impl_trait_ref => { cdata.get_impl_trait(def_id.index, tcx) }\n+        impl_polarity => { cdata.get_impl_polarity(def_id.index) }\n+        coerce_unsized_info => {\n+            cdata.get_coerce_unsized_info(def_id.index).unwrap_or_else(|| {\n+                bug!(\"coerce_unsized_info: `{:?}` is missing its info\", def_id);\n+            })\n+        }\n+        optimized_mir => {\n+            let mir = cdata.maybe_get_optimized_mir(tcx, def_id.index).unwrap_or_else(|| {\n+                bug!(\"get_optimized_mir: missing MIR for `{:?}`\", def_id)\n+            });\n+\n+            let mir = tcx.alloc_mir(mir);\n+\n+            mir\n+        }\n+        mir_const_qualif => { cdata.mir_const_qualif(def_id.index) }\n+        typeck_tables_of => { cdata.item_body_tables(def_id.index, tcx) }\n+        closure_kind => { cdata.closure_kind(def_id.index) }\n+        closure_type => { cdata.closure_ty(def_id.index, tcx) }\n+        inherent_impls => { Rc::new(cdata.get_inherent_implementations_for_type(def_id.index)) }\n+        is_const_fn => { cdata.is_const_fn(def_id.index) }\n+        is_foreign_item => { cdata.is_foreign_item(def_id.index) }\n+        is_default_impl => { cdata.is_default_impl(def_id.index) }\n+        describe_def => { cdata.get_def(def_id.index) }\n+        def_span => { cdata.get_span(def_id.index, &tcx.sess) }\n+        stability => { cdata.get_stability(def_id.index) }\n+        deprecation => { cdata.get_deprecation(def_id.index) }\n+        item_attrs => { cdata.get_item_attrs(def_id.index, &tcx.dep_graph) }\n+        // FIXME(#38501) We've skipped a `read` on the `HirBody` of\n+        // a `fn` when encoding, so the dep-tracking wouldn't work.\n+        // This is only used by rustdoc anyway, which shouldn't have\n+        // incremental recompilation ever enabled.\n+        fn_arg_names => { cdata.get_fn_arg_names(def_id.index) }\n+        impl_parent => { cdata.get_parent_impl(def_id.index) }\n+        trait_of_item => { cdata.get_trait_of_item(def_id.index) }\n+        is_exported_symbol => {\n+            let dep_node = cdata.metadata_dep_node(GlobalMetaDataKind::ExportedSymbols);\n+            cdata.exported_symbols.get(&tcx.dep_graph, dep_node).contains(&def_id.index)\n+        }\n+        item_body_nested_bodies => { Rc::new(cdata.item_body_nested_bodies(def_id.index)) }\n+        const_is_rvalue_promotable_to_static => {\n+            cdata.const_is_rvalue_promotable_to_static(def_id.index)\n+        }\n+        is_mir_available => { cdata.is_item_mir_available(def_id.index) }\n     }\n-    optimized_mir => {\n-        let mir = cdata.maybe_get_optimized_mir(tcx, def_id.index).unwrap_or_else(|| {\n-            bug!(\"get_optimized_mir: missing MIR for `{:?}`\", def_id)\n-        });\n \n-        let mir = tcx.alloc_mir(mir);\n-\n-        mir\n-    }\n-    mir_const_qualif => { cdata.mir_const_qualif(def_id.index) }\n-    typeck_tables_of => { cdata.item_body_tables(def_id.index, tcx) }\n-    closure_kind => { cdata.closure_kind(def_id.index) }\n-    closure_type => { cdata.closure_ty(def_id.index, tcx) }\n-    inherent_impls => { Rc::new(cdata.get_inherent_implementations_for_type(def_id.index)) }\n-    is_const_fn => { cdata.is_const_fn(def_id.index) }\n-    is_foreign_item => { cdata.is_foreign_item(def_id.index) }\n-    is_default_impl => { cdata.is_default_impl(def_id.index) }\n-    describe_def => { cdata.get_def(def_id.index) }\n-    def_span => { cdata.get_span(def_id.index, &tcx.sess) }\n-    stability => { cdata.get_stability(def_id.index) }\n-    deprecation => { cdata.get_deprecation(def_id.index) }\n-    item_attrs => { cdata.get_item_attrs(def_id.index, &tcx.dep_graph) }\n-    // FIXME(#38501) We've skipped a `read` on the `HirBody` of\n-    // a `fn` when encoding, so the dep-tracking wouldn't work.\n-    // This is only used by rustdoc anyway, which shouldn't have\n-    // incremental recompilation ever enabled.\n-    fn_arg_names => { cdata.get_fn_arg_names(def_id.index) }\n-    impl_parent => { cdata.get_parent_impl(def_id.index) }\n-    trait_of_item => { cdata.get_trait_of_item(def_id.index) }\n-    is_exported_symbol => {\n-        let dep_node = cdata.metadata_dep_node(GlobalMetaDataKind::ExportedSymbols);\n-        cdata.exported_symbols.get(&tcx.dep_graph, dep_node).contains(&def_id.index)\n-    }\n-    item_body_nested_bodies => { Rc::new(cdata.item_body_nested_bodies(def_id.index)) }\n-    const_is_rvalue_promotable_to_static => {\n-        cdata.const_is_rvalue_promotable_to_static(def_id.index)\n-    }\n-    is_mir_available => { cdata.is_item_mir_available(def_id.index) }\n+    ByCrateNum {\n+    }\n }\n \n pub fn provide_local<'tcx>(providers: &mut Providers<'tcx>) {"}]}