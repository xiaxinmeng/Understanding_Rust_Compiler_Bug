{"sha": "357f66072959f494d5fa2e6a269c6100eed703c1", "node_id": "C_kwDOAAsO6NoAKDM1N2Y2NjA3Mjk1OWY0OTRkNWZhMmU2YTI2OWM2MTAwZWVkNzAzYzE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-15T09:38:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-15T09:38:05Z"}, "message": "Auto merge of #101168 - jachris:dataflow-const-prop, r=oli-obk\n\nAdd new MIR constant propagation based on dataflow analysis\n\nThe current constant propagation in `rustc_mir_transform/src/const_prop.rs` fails to handle many cases that would be expected from a constant propagation optimization. For example:\n```rust\nlet x = if true { 0 } else { 0 };\n```\nThis pull request adds a new constant propagation MIR optimization pass based on the existing dataflow analysis framework. Since most of the analysis is not unique to constant propagation, a generic framework has been extracted. It works on top of the existing framework and could be reused for other optimzations.\n\nCloses #80038. Closes #81605.\n\n## Todo\n### Essential\n- [x] [Writes to inactive enum variants](https://github.com/rust-lang/rust/pull/101168#pullrequestreview-1089493974). Resolved by rejecting the registration of places with downcast projections for now. Could be improved by flooding other variants if mutable access to a variant is observed.\n- [X] Handle [`StatementKind::CopyNonOverlapping`](https://github.com/rust-lang/rust/pull/101168#discussion_r957774914). Resolved by flooding the destination.\n- [x] Handle `UnsafeCell` / `!Freeze` correctly.\n- [X] Overflow propagation of `CheckedBinaryOp`: Decided to not propagate if overflow flag is `true` (`false` will still be propagated)\n- [x] More documentation in general.\n- [x] Arguments for correctness, documentation of necessary assumptions.\n- [x] Better performance, or alternatively, require `-Zmir-opt-level=3` for now.\n\n### Extra\n- [x]  Add explicit unreachability, i.e. upgrading the lattice from $\\mathbb{P} \\to \\mathbb{V}$ to $\\set{\\bot} \\cup (\\mathbb{P} \\to \\mathbb{V})$.\n- [x] Use storage statements to improve precision.\n- [ ] Consider opening issue for duplicate diagnostics: https://github.com/rust-lang/rust/pull/101168#issuecomment-1276609950\n- [ ] Flood moved-from places with $\\bot$ (requires some changes for places with tracked projections).\n- [ ] Add downcast projections back in.\n- [ ] [Algebraic simplifications](https://github.com/rust-lang/rust/pull/101168#discussion_r957967878) (possibly with a shared API; done by old const prop).\n- [ ] Propagation through slices / arrays.\n- [ ] Find other optimizations that are done by old `const_prop.rs`, but not by this one.", "tree": {"sha": "e3426b555151c6e2ac96f0172dcbfba3c6906728", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3426b555151c6e2ac96f0172dcbfba3c6906728"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/357f66072959f494d5fa2e6a269c6100eed703c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/357f66072959f494d5fa2e6a269c6100eed703c1", "html_url": "https://github.com/rust-lang/rust/commit/357f66072959f494d5fa2e6a269c6100eed703c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/357f66072959f494d5fa2e6a269c6100eed703c1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca92d90b5917e7176d5ff06607a2cd5352c088d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca92d90b5917e7176d5ff06607a2cd5352c088d3", "html_url": "https://github.com/rust-lang/rust/commit/ca92d90b5917e7176d5ff06607a2cd5352c088d3"}, {"sha": "24d2e903df2f0d7d66ab50f4df6d06c84254c85b", "url": "https://api.github.com/repos/rust-lang/rust/commits/24d2e903df2f0d7d66ab50f4df6d06c84254c85b", "html_url": "https://github.com/rust-lang/rust/commit/24d2e903df2f0d7d66ab50f4df6d06c84254c85b"}], "stats": {"total": 2466, "additions": 2441, "deletions": 25}, "files": [{"sha": "401d3f6689c99e7ae4cb072a0c5d35032396e0f1", "filename": "compiler/rustc_graphviz/src/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -471,7 +471,11 @@ pub trait Labeller<'a> {\n /// Escape tags in such a way that it is suitable for inclusion in a\n /// Graphviz HTML label.\n pub fn escape_html(s: &str) -> String {\n-    s.replace('&', \"&amp;\").replace('\\\"', \"&quot;\").replace('<', \"&lt;\").replace('>', \"&gt;\")\n+    s.replace('&', \"&amp;\")\n+        .replace('\\\"', \"&quot;\")\n+        .replace('<', \"&lt;\")\n+        .replace('>', \"&gt;\")\n+        .replace('\\n', \"<br align=\\\"left\\\"/>\")\n }\n \n impl<'a> LabelText<'a> {"}, {"sha": "ccae7e159b1f109dfb609d0e77970b4d065d5416", "filename": "compiler/rustc_middle/src/mir/generic_graphviz.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgeneric_graphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgeneric_graphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgeneric_graphviz.rs?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -126,7 +126,7 @@ impl<\n             write!(\n                 w,\n                 r#\"<tr><td align=\"left\" balign=\"left\">{}</td></tr>\"#,\n-                dot::escape_html(&section).replace('\\n', \"<br/>\")\n+                dot::escape_html(&section)\n             )?;\n         }\n \n@@ -147,7 +147,7 @@ impl<\n             let src = self.node(source);\n             let trg = self.node(target);\n             let escaped_edge_label = if let Some(edge_label) = edge_labels.get(index) {\n-                dot::escape_html(edge_label).replace('\\n', r#\"<br align=\"left\"/>\"#)\n+                dot::escape_html(edge_label)\n             } else {\n                 \"\".to_owned()\n             };\n@@ -162,8 +162,7 @@ impl<\n     where\n         W: Write,\n     {\n-        let lines = label.split('\\n').map(|s| dot::escape_html(s)).collect::<Vec<_>>();\n-        let escaped_label = lines.join(r#\"<br align=\"left\"/>\"#);\n+        let escaped_label = dot::escape_html(label);\n         writeln!(w, r#\"    label=<<br/><br/>{}<br align=\"left\"/><br/><br/><br/>>;\"#, escaped_label)\n     }\n "}, {"sha": "d87eb28970e4197ead01829b5bb2388fad002092", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -1320,6 +1320,15 @@ impl PlaceContext {\n         )\n     }\n \n+    /// Returns `true` if this place context represents an address-of.\n+    pub fn is_address_of(&self) -> bool {\n+        matches!(\n+            self,\n+            PlaceContext::NonMutatingUse(NonMutatingUseContext::AddressOf)\n+                | PlaceContext::MutatingUse(MutatingUseContext::AddressOf)\n+        )\n+    }\n+\n     /// Returns `true` if this place context represents a storage live or storage dead marker.\n     #[inline]\n     pub fn is_storage_marker(&self) -> bool {"}, {"sha": "c9d5601f2074c958ca160a56bd7925ae48bb94a0", "filename": "compiler/rustc_mir_dataflow/src/framework/graphviz.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fgraphviz.rs?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -475,7 +475,10 @@ where\n                 r#\"<td colspan=\"{colspan}\" {fmt} align=\"left\">{state}</td>\"#,\n                 colspan = this.style.num_state_columns(),\n                 fmt = fmt,\n-                state = format!(\"{:?}\", DebugWithAdapter { this: state, ctxt: analysis }),\n+                state = dot::escape_html(&format!(\n+                    \"{:?}\",\n+                    DebugWithAdapter { this: state, ctxt: analysis }\n+                )),\n             )\n         })\n     }"}, {"sha": "f0e75c53ea15c93e9fa6c7fcd46843c25a191f26", "filename": "compiler/rustc_mir_dataflow/src/framework/lattice.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Flattice.rs?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -73,6 +73,16 @@ pub trait MeetSemiLattice: Eq {\n     fn meet(&mut self, other: &Self) -> bool;\n }\n \n+/// A set that has a \"bottom\" element, which is less than or equal to any other element.\n+pub trait HasBottom {\n+    fn bottom() -> Self;\n+}\n+\n+/// A set that has a \"top\" element, which is greater than or equal to any other element.\n+pub trait HasTop {\n+    fn top() -> Self;\n+}\n+\n /// A `bool` is a \"two-point\" lattice with `true` as the top element and `false` as the bottom:\n ///\n /// ```text\n@@ -102,6 +112,18 @@ impl MeetSemiLattice for bool {\n     }\n }\n \n+impl HasBottom for bool {\n+    fn bottom() -> Self {\n+        false\n+    }\n+}\n+\n+impl HasTop for bool {\n+    fn top() -> Self {\n+        true\n+    }\n+}\n+\n /// A tuple (or list) of lattices is itself a lattice whose least upper bound is the concatenation\n /// of the least upper bounds of each element of the tuple (or list).\n ///\n@@ -250,3 +272,15 @@ impl<T: Clone + Eq> MeetSemiLattice for FlatSet<T> {\n         true\n     }\n }\n+\n+impl<T> HasBottom for FlatSet<T> {\n+    fn bottom() -> Self {\n+        Self::Bottom\n+    }\n+}\n+\n+impl<T> HasTop for FlatSet<T> {\n+    fn top() -> Self {\n+        Self::Top\n+    }\n+}"}, {"sha": "7f40cfca32fff3ccfb456134b80be301832d9a4b", "filename": "compiler/rustc_mir_dataflow/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/compiler%2Frustc_mir_dataflow%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/compiler%2Frustc_mir_dataflow%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Flib.rs?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -41,6 +41,7 @@ pub mod move_paths;\n pub mod rustc_peek;\n pub mod storage;\n pub mod un_derefer;\n+pub mod value_analysis;\n \n pub(crate) mod indexes {\n     pub(crate) use super::move_paths::MovePathIndex;"}, {"sha": "db4b0a3deda9dba74aea18e8e184eac255f55b70", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "added", "additions": 927, "deletions": 0, "changes": 927, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -0,0 +1,927 @@\n+//! This module provides a framework on top of the normal MIR dataflow framework to simplify the\n+//! implementation of analyses that track information about the values stored in certain places.\n+//! We are using the term \"place\" here to refer to a `mir::Place` (a place expression) instead of\n+//! an `interpret::Place` (a memory location).\n+//!\n+//! The default methods of [`ValueAnalysis`] (prefixed with `super_` instead of `handle_`)\n+//! provide some behavior that should be valid for all abstract domains that are based only on the\n+//! value stored in a certain place. On top of these default rules, an implementation should\n+//! override some of the `handle_` methods. For an example, see `ConstAnalysis`.\n+//!\n+//! An implementation must also provide a [`Map`]. Before the analysis begins, all places that\n+//! should be tracked during the analysis must be registered. During the analysis, no new places\n+//! can be registered. The [`State`] can be queried to retrieve the abstract value stored for a\n+//! certain place by passing the map.\n+//!\n+//! This framework is currently experimental. Originally, it supported shared references and enum\n+//! variants. However, it was discovered that both of these were unsound, and especially references\n+//! had subtle but serious issues. In the future, they could be added back in, but we should clarify\n+//! the rules for optimizations that rely on the aliasing model first.\n+//!\n+//!\n+//! # Notes\n+//!\n+//! - The bottom state denotes uninitialized memory. Because we are only doing a sound approximation\n+//! of the actual execution, we can also use this state for places where access would be UB.\n+//!\n+//! - The assignment logic in `State::assign_place_idx` assumes that the places are non-overlapping,\n+//! or identical. Note that this refers to place expressions, not memory locations.\n+//!\n+//! - Currently, places that have their reference taken cannot be tracked. Although this would be\n+//! possible, it has to rely on some aliasing model, which we are not ready to commit to yet.\n+//! Because of that, we can assume that the only way to change the value behind a tracked place is\n+//! by direct assignment.\n+\n+use std::fmt::{Debug, Formatter};\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_index::vec::IndexVec;\n+use rustc_middle::mir::visit::{MutatingUseContext, PlaceContext, Visitor};\n+use rustc_middle::mir::*;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_target::abi::VariantIdx;\n+\n+use crate::lattice::{HasBottom, HasTop};\n+use crate::{\n+    fmt::DebugWithContext, Analysis, AnalysisDomain, CallReturnPlaces, JoinSemiLattice,\n+    SwitchIntEdgeEffects,\n+};\n+\n+pub trait ValueAnalysis<'tcx> {\n+    /// For each place of interest, the analysis tracks a value of the given type.\n+    type Value: Clone + JoinSemiLattice + HasBottom + HasTop;\n+\n+    const NAME: &'static str;\n+\n+    fn map(&self) -> &Map;\n+\n+    fn handle_statement(&self, statement: &Statement<'tcx>, state: &mut State<Self::Value>) {\n+        self.super_statement(statement, state)\n+    }\n+\n+    fn super_statement(&self, statement: &Statement<'tcx>, state: &mut State<Self::Value>) {\n+        match &statement.kind {\n+            StatementKind::Assign(box (place, rvalue)) => {\n+                self.handle_assign(*place, rvalue, state);\n+            }\n+            StatementKind::SetDiscriminant { .. } => {\n+                // Could treat this as writing a constant to a pseudo-place.\n+                // But discriminants are currently not tracked, so we do nothing.\n+                // Related: https://github.com/rust-lang/unsafe-code-guidelines/issues/84\n+            }\n+            StatementKind::Intrinsic(box intrinsic) => {\n+                self.handle_intrinsic(intrinsic, state);\n+            }\n+            StatementKind::StorageLive(local) | StatementKind::StorageDead(local) => {\n+                // StorageLive leaves the local in an uninitialized state.\n+                // StorageDead makes it UB to access the local afterwards.\n+                state.flood_with(Place::from(*local).as_ref(), self.map(), Self::Value::bottom());\n+            }\n+            StatementKind::Deinit(box place) => {\n+                // Deinit makes the place uninitialized.\n+                state.flood_with(place.as_ref(), self.map(), Self::Value::bottom());\n+            }\n+            StatementKind::Retag(..) => {\n+                // We don't track references.\n+            }\n+            StatementKind::Nop\n+            | StatementKind::FakeRead(..)\n+            | StatementKind::Coverage(..)\n+            | StatementKind::AscribeUserType(..) => (),\n+        }\n+    }\n+\n+    fn handle_intrinsic(\n+        &self,\n+        intrinsic: &NonDivergingIntrinsic<'tcx>,\n+        state: &mut State<Self::Value>,\n+    ) {\n+        self.super_intrinsic(intrinsic, state);\n+    }\n+\n+    fn super_intrinsic(\n+        &self,\n+        intrinsic: &NonDivergingIntrinsic<'tcx>,\n+        state: &mut State<Self::Value>,\n+    ) {\n+        match intrinsic {\n+            NonDivergingIntrinsic::Assume(..) => {\n+                // Could use this, but ignoring it is sound.\n+            }\n+            NonDivergingIntrinsic::CopyNonOverlapping(CopyNonOverlapping { dst, .. }) => {\n+                if let Some(place) = dst.place() {\n+                    state.flood(place.as_ref(), self.map());\n+                }\n+            }\n+        }\n+    }\n+\n+    fn handle_assign(\n+        &self,\n+        target: Place<'tcx>,\n+        rvalue: &Rvalue<'tcx>,\n+        state: &mut State<Self::Value>,\n+    ) {\n+        self.super_assign(target, rvalue, state)\n+    }\n+\n+    fn super_assign(\n+        &self,\n+        target: Place<'tcx>,\n+        rvalue: &Rvalue<'tcx>,\n+        state: &mut State<Self::Value>,\n+    ) {\n+        let result = self.handle_rvalue(rvalue, state);\n+        state.assign(target.as_ref(), result, self.map());\n+    }\n+\n+    fn handle_rvalue(\n+        &self,\n+        rvalue: &Rvalue<'tcx>,\n+        state: &mut State<Self::Value>,\n+    ) -> ValueOrPlace<Self::Value> {\n+        self.super_rvalue(rvalue, state)\n+    }\n+\n+    fn super_rvalue(\n+        &self,\n+        rvalue: &Rvalue<'tcx>,\n+        state: &mut State<Self::Value>,\n+    ) -> ValueOrPlace<Self::Value> {\n+        match rvalue {\n+            Rvalue::Use(operand) => self.handle_operand(operand, state),\n+            Rvalue::CopyForDeref(place) => self.handle_operand(&Operand::Copy(*place), state),\n+            Rvalue::Ref(..) | Rvalue::AddressOf(..) => {\n+                // We don't track such places.\n+                ValueOrPlace::top()\n+            }\n+            Rvalue::Repeat(..)\n+            | Rvalue::ThreadLocalRef(..)\n+            | Rvalue::Len(..)\n+            | Rvalue::Cast(..)\n+            | Rvalue::BinaryOp(..)\n+            | Rvalue::CheckedBinaryOp(..)\n+            | Rvalue::NullaryOp(..)\n+            | Rvalue::UnaryOp(..)\n+            | Rvalue::Discriminant(..)\n+            | Rvalue::Aggregate(..)\n+            | Rvalue::ShallowInitBox(..) => {\n+                // No modification is possible through these r-values.\n+                ValueOrPlace::top()\n+            }\n+        }\n+    }\n+\n+    fn handle_operand(\n+        &self,\n+        operand: &Operand<'tcx>,\n+        state: &mut State<Self::Value>,\n+    ) -> ValueOrPlace<Self::Value> {\n+        self.super_operand(operand, state)\n+    }\n+\n+    fn super_operand(\n+        &self,\n+        operand: &Operand<'tcx>,\n+        state: &mut State<Self::Value>,\n+    ) -> ValueOrPlace<Self::Value> {\n+        match operand {\n+            Operand::Constant(box constant) => {\n+                ValueOrPlace::Value(self.handle_constant(constant, state))\n+            }\n+            Operand::Copy(place) | Operand::Move(place) => {\n+                // On move, we would ideally flood the place with bottom. But with the current\n+                // framework this is not possible (similar to `InterpCx::eval_operand`).\n+                self.map()\n+                    .find(place.as_ref())\n+                    .map(ValueOrPlace::Place)\n+                    .unwrap_or(ValueOrPlace::top())\n+            }\n+        }\n+    }\n+\n+    fn handle_constant(\n+        &self,\n+        constant: &Constant<'tcx>,\n+        state: &mut State<Self::Value>,\n+    ) -> Self::Value {\n+        self.super_constant(constant, state)\n+    }\n+\n+    fn super_constant(\n+        &self,\n+        _constant: &Constant<'tcx>,\n+        _state: &mut State<Self::Value>,\n+    ) -> Self::Value {\n+        Self::Value::top()\n+    }\n+\n+    /// The effect of a successful function call return should not be\n+    /// applied here, see [`Analysis::apply_terminator_effect`].\n+    fn handle_terminator(&self, terminator: &Terminator<'tcx>, state: &mut State<Self::Value>) {\n+        self.super_terminator(terminator, state)\n+    }\n+\n+    fn super_terminator(&self, terminator: &Terminator<'tcx>, _state: &mut State<Self::Value>) {\n+        match &terminator.kind {\n+            TerminatorKind::Call { .. } | TerminatorKind::InlineAsm { .. } => {\n+                // Effect is applied by `handle_call_return`.\n+            }\n+            TerminatorKind::Drop { .. } => {\n+                // We don't track dropped places.\n+            }\n+            TerminatorKind::DropAndReplace { .. } | TerminatorKind::Yield { .. } => {\n+                // They would have an effect, but are not allowed in this phase.\n+                bug!(\"encountered disallowed terminator\");\n+            }\n+            TerminatorKind::Goto { .. }\n+            | TerminatorKind::SwitchInt { .. }\n+            | TerminatorKind::Resume\n+            | TerminatorKind::Abort\n+            | TerminatorKind::Return\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::Assert { .. }\n+            | TerminatorKind::GeneratorDrop\n+            | TerminatorKind::FalseEdge { .. }\n+            | TerminatorKind::FalseUnwind { .. } => {\n+                // These terminators have no effect on the analysis.\n+            }\n+        }\n+    }\n+\n+    fn handle_call_return(\n+        &self,\n+        return_places: CallReturnPlaces<'_, 'tcx>,\n+        state: &mut State<Self::Value>,\n+    ) {\n+        self.super_call_return(return_places, state)\n+    }\n+\n+    fn super_call_return(\n+        &self,\n+        return_places: CallReturnPlaces<'_, 'tcx>,\n+        state: &mut State<Self::Value>,\n+    ) {\n+        return_places.for_each(|place| {\n+            state.flood(place.as_ref(), self.map());\n+        })\n+    }\n+\n+    fn handle_switch_int(\n+        &self,\n+        discr: &Operand<'tcx>,\n+        apply_edge_effects: &mut impl SwitchIntEdgeEffects<State<Self::Value>>,\n+    ) {\n+        self.super_switch_int(discr, apply_edge_effects)\n+    }\n+\n+    fn super_switch_int(\n+        &self,\n+        _discr: &Operand<'tcx>,\n+        _apply_edge_effects: &mut impl SwitchIntEdgeEffects<State<Self::Value>>,\n+    ) {\n+    }\n+\n+    fn wrap(self) -> ValueAnalysisWrapper<Self>\n+    where\n+        Self: Sized,\n+    {\n+        ValueAnalysisWrapper(self)\n+    }\n+}\n+\n+pub struct ValueAnalysisWrapper<T>(pub T);\n+\n+impl<'tcx, T: ValueAnalysis<'tcx>> AnalysisDomain<'tcx> for ValueAnalysisWrapper<T> {\n+    type Domain = State<T::Value>;\n+\n+    type Direction = crate::Forward;\n+\n+    const NAME: &'static str = T::NAME;\n+\n+    fn bottom_value(&self, _body: &Body<'tcx>) -> Self::Domain {\n+        State(StateData::Unreachable)\n+    }\n+\n+    fn initialize_start_block(&self, body: &Body<'tcx>, state: &mut Self::Domain) {\n+        // The initial state maps all tracked places of argument projections to \u22a4 and the rest to \u22a5.\n+        assert!(matches!(state.0, StateData::Unreachable));\n+        let values = IndexVec::from_elem_n(T::Value::bottom(), self.0.map().value_count);\n+        *state = State(StateData::Reachable(values));\n+        for arg in body.args_iter() {\n+            state.flood(PlaceRef { local: arg, projection: &[] }, self.0.map());\n+        }\n+    }\n+}\n+\n+impl<'tcx, T> Analysis<'tcx> for ValueAnalysisWrapper<T>\n+where\n+    T: ValueAnalysis<'tcx>,\n+{\n+    fn apply_statement_effect(\n+        &self,\n+        state: &mut Self::Domain,\n+        statement: &Statement<'tcx>,\n+        _location: Location,\n+    ) {\n+        if state.is_reachable() {\n+            self.0.handle_statement(statement, state);\n+        }\n+    }\n+\n+    fn apply_terminator_effect(\n+        &self,\n+        state: &mut Self::Domain,\n+        terminator: &Terminator<'tcx>,\n+        _location: Location,\n+    ) {\n+        if state.is_reachable() {\n+            self.0.handle_terminator(terminator, state);\n+        }\n+    }\n+\n+    fn apply_call_return_effect(\n+        &self,\n+        state: &mut Self::Domain,\n+        _block: BasicBlock,\n+        return_places: crate::CallReturnPlaces<'_, 'tcx>,\n+    ) {\n+        if state.is_reachable() {\n+            self.0.handle_call_return(return_places, state)\n+        }\n+    }\n+\n+    fn apply_switch_int_edge_effects(\n+        &self,\n+        _block: BasicBlock,\n+        discr: &Operand<'tcx>,\n+        apply_edge_effects: &mut impl SwitchIntEdgeEffects<Self::Domain>,\n+    ) {\n+        // FIXME: Dataflow framework provides no access to current state here.\n+        self.0.handle_switch_int(discr, apply_edge_effects)\n+    }\n+}\n+\n+rustc_index::newtype_index!(\n+    /// This index uniquely identifies a place.\n+    ///\n+    /// Not every place has a `PlaceIndex`, and not every `PlaceIndex` correspondends to a tracked\n+    /// place. However, every tracked place and all places along its projection have a `PlaceIndex`.\n+    pub struct PlaceIndex {}\n+);\n+\n+rustc_index::newtype_index!(\n+    /// This index uniquely identifies a tracked place and therefore a slot in [`State`].\n+    ///\n+    /// It is an implementation detail of this module.\n+    struct ValueIndex {}\n+);\n+\n+/// See [`State`].\n+#[derive(PartialEq, Eq, Debug)]\n+enum StateData<V> {\n+    Reachable(IndexVec<ValueIndex, V>),\n+    Unreachable,\n+}\n+\n+impl<V: Clone> Clone for StateData<V> {\n+    fn clone(&self) -> Self {\n+        match self {\n+            Self::Reachable(x) => Self::Reachable(x.clone()),\n+            Self::Unreachable => Self::Unreachable,\n+        }\n+    }\n+\n+    fn clone_from(&mut self, source: &Self) {\n+        match (&mut *self, source) {\n+            (Self::Reachable(x), Self::Reachable(y)) => {\n+                // We go through `raw` here, because `IndexVec` currently has a naive `clone_from`.\n+                x.raw.clone_from(&y.raw);\n+            }\n+            _ => *self = source.clone(),\n+        }\n+    }\n+}\n+\n+/// The dataflow state for an instance of [`ValueAnalysis`].\n+///\n+/// Every instance specifies a lattice that represents the possible values of a single tracked\n+/// place. If we call this lattice `V` and set set of tracked places `P`, then a [`State`] is an\n+/// element of `{unreachable} \u222a (P -> V)`. This again forms a lattice, where the bottom element is\n+/// `unreachable` and the top element is the mapping `p \u21a6 \u22a4`. Note that the mapping `p \u21a6 \u22a5` is not\n+/// the bottom element (because joining an unreachable and any other reachable state yields a\n+/// reachable state). All operations on unreachable states are ignored.\n+///\n+/// Flooding means assigning a value (by default `\u22a4`) to all tracked projections of a given place.\n+#[derive(PartialEq, Eq, Debug)]\n+pub struct State<V>(StateData<V>);\n+\n+impl<V: Clone> Clone for State<V> {\n+    fn clone(&self) -> Self {\n+        Self(self.0.clone())\n+    }\n+\n+    fn clone_from(&mut self, source: &Self) {\n+        self.0.clone_from(&source.0);\n+    }\n+}\n+\n+impl<V: Clone + HasTop + HasBottom> State<V> {\n+    pub fn is_reachable(&self) -> bool {\n+        matches!(&self.0, StateData::Reachable(_))\n+    }\n+\n+    pub fn mark_unreachable(&mut self) {\n+        self.0 = StateData::Unreachable;\n+    }\n+\n+    pub fn flood_all(&mut self) {\n+        self.flood_all_with(V::top())\n+    }\n+\n+    pub fn flood_all_with(&mut self, value: V) {\n+        let StateData::Reachable(values) = &mut self.0 else { return };\n+        values.raw.fill(value);\n+    }\n+\n+    pub fn flood_with(&mut self, place: PlaceRef<'_>, map: &Map, value: V) {\n+        if let Some(root) = map.find(place) {\n+            self.flood_idx_with(root, map, value);\n+        }\n+    }\n+\n+    pub fn flood(&mut self, place: PlaceRef<'_>, map: &Map) {\n+        self.flood_with(place, map, V::top())\n+    }\n+\n+    pub fn flood_idx_with(&mut self, place: PlaceIndex, map: &Map, value: V) {\n+        let StateData::Reachable(values) = &mut self.0 else { return };\n+        map.preorder_invoke(place, &mut |place| {\n+            if let Some(vi) = map.places[place].value_index {\n+                values[vi] = value.clone();\n+            }\n+        });\n+    }\n+\n+    pub fn flood_idx(&mut self, place: PlaceIndex, map: &Map) {\n+        self.flood_idx_with(place, map, V::top())\n+    }\n+\n+    /// Copies `source` to `target`, including all tracked places beneath.\n+    ///\n+    /// If `target` contains a place that is not contained in `source`, it will be overwritten with\n+    /// Top. Also, because this will copy all entries one after another, it may only be used for\n+    /// places that are non-overlapping or identical.\n+    pub fn assign_place_idx(&mut self, target: PlaceIndex, source: PlaceIndex, map: &Map) {\n+        let StateData::Reachable(values) = &mut self.0 else { return };\n+\n+        // If both places are tracked, we copy the value to the target. If the target is tracked,\n+        // but the source is not, we have to invalidate the value in target. If the target is not\n+        // tracked, then we don't have to do anything.\n+        if let Some(target_value) = map.places[target].value_index {\n+            if let Some(source_value) = map.places[source].value_index {\n+                values[target_value] = values[source_value].clone();\n+            } else {\n+                values[target_value] = V::top();\n+            }\n+        }\n+        for target_child in map.children(target) {\n+            // Try to find corresponding child and recurse. Reasoning is similar as above.\n+            let projection = map.places[target_child].proj_elem.unwrap();\n+            if let Some(source_child) = map.projections.get(&(source, projection)) {\n+                self.assign_place_idx(target_child, *source_child, map);\n+            } else {\n+                self.flood_idx(target_child, map);\n+            }\n+        }\n+    }\n+\n+    pub fn assign(&mut self, target: PlaceRef<'_>, result: ValueOrPlace<V>, map: &Map) {\n+        if let Some(target) = map.find(target) {\n+            self.assign_idx(target, result, map);\n+        } else {\n+            // We don't track this place nor any projections, assignment can be ignored.\n+        }\n+    }\n+\n+    pub fn assign_idx(&mut self, target: PlaceIndex, result: ValueOrPlace<V>, map: &Map) {\n+        match result {\n+            ValueOrPlace::Value(value) => {\n+                // First flood the target place in case we also track any projections (although\n+                // this scenario is currently not well-supported by the API).\n+                self.flood_idx(target, map);\n+                let StateData::Reachable(values) = &mut self.0 else { return };\n+                if let Some(value_index) = map.places[target].value_index {\n+                    values[value_index] = value;\n+                }\n+            }\n+            ValueOrPlace::Place(source) => self.assign_place_idx(target, source, map),\n+        }\n+    }\n+\n+    /// Retrieve the value stored for a place, or \u22a4 if it is not tracked.\n+    pub fn get(&self, place: PlaceRef<'_>, map: &Map) -> V {\n+        map.find(place).map(|place| self.get_idx(place, map)).unwrap_or(V::top())\n+    }\n+\n+    /// Retrieve the value stored for a place index, or \u22a4 if it is not tracked.\n+    pub fn get_idx(&self, place: PlaceIndex, map: &Map) -> V {\n+        match &self.0 {\n+            StateData::Reachable(values) => {\n+                map.places[place].value_index.map(|v| values[v].clone()).unwrap_or(V::top())\n+            }\n+            StateData::Unreachable => {\n+                // Because this is unreachable, we can return any value we want.\n+                V::bottom()\n+            }\n+        }\n+    }\n+}\n+\n+impl<V: JoinSemiLattice + Clone> JoinSemiLattice for State<V> {\n+    fn join(&mut self, other: &Self) -> bool {\n+        match (&mut self.0, &other.0) {\n+            (_, StateData::Unreachable) => false,\n+            (StateData::Unreachable, _) => {\n+                *self = other.clone();\n+                true\n+            }\n+            (StateData::Reachable(this), StateData::Reachable(other)) => this.join(other),\n+        }\n+    }\n+}\n+\n+/// Partial mapping from [`Place`] to [`PlaceIndex`], where some places also have a [`ValueIndex`].\n+///\n+/// This data structure essentially maintains a tree of places and their projections. Some\n+/// additional bookkeeping is done, to speed up traversal over this tree:\n+/// - For iteration, every [`PlaceInfo`] contains an intrusive linked list of its children.\n+/// - To directly get the child for a specific projection, there is a `projections` map.\n+#[derive(Debug)]\n+pub struct Map {\n+    locals: IndexVec<Local, Option<PlaceIndex>>,\n+    projections: FxHashMap<(PlaceIndex, TrackElem), PlaceIndex>,\n+    places: IndexVec<PlaceIndex, PlaceInfo>,\n+    value_count: usize,\n+}\n+\n+impl Map {\n+    fn new() -> Self {\n+        Self {\n+            locals: IndexVec::new(),\n+            projections: FxHashMap::default(),\n+            places: IndexVec::new(),\n+            value_count: 0,\n+        }\n+    }\n+\n+    /// Returns a map that only tracks places whose type passes the filter.\n+    ///\n+    /// This is currently the only way to create a [`Map`]. The way in which the tracked places are\n+    /// chosen is an implementation detail and may not be relied upon (other than that their type\n+    /// passes the filter).\n+    #[instrument(skip_all, level = \"debug\")]\n+    pub fn from_filter<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n+        body: &Body<'tcx>,\n+        filter: impl FnMut(Ty<'tcx>) -> bool,\n+    ) -> Self {\n+        let mut map = Self::new();\n+        let exclude = excluded_locals(body);\n+        map.register_with_filter(tcx, body, filter, &exclude);\n+        debug!(\"registered {} places ({} nodes in total)\", map.value_count, map.places.len());\n+        map\n+    }\n+\n+    /// Register all non-excluded places that pass the filter.\n+    fn register_with_filter<'tcx>(\n+        &mut self,\n+        tcx: TyCtxt<'tcx>,\n+        body: &Body<'tcx>,\n+        mut filter: impl FnMut(Ty<'tcx>) -> bool,\n+        exclude: &IndexVec<Local, bool>,\n+    ) {\n+        // We use this vector as stack, pushing and popping projections.\n+        let mut projection = Vec::new();\n+        for (local, decl) in body.local_decls.iter_enumerated() {\n+            if !exclude[local] {\n+                self.register_with_filter_rec(tcx, local, &mut projection, decl.ty, &mut filter);\n+            }\n+        }\n+    }\n+\n+    /// Potentially register the (local, projection) place and its fields, recursively.\n+    ///\n+    /// Invariant: The projection must only contain fields.\n+    fn register_with_filter_rec<'tcx>(\n+        &mut self,\n+        tcx: TyCtxt<'tcx>,\n+        local: Local,\n+        projection: &mut Vec<PlaceElem<'tcx>>,\n+        ty: Ty<'tcx>,\n+        filter: &mut impl FnMut(Ty<'tcx>) -> bool,\n+    ) {\n+        // Note: The framework supports only scalars for now.\n+        if filter(ty) && ty.is_scalar() {\n+            // We know that the projection only contains trackable elements.\n+            let place = self.make_place(local, projection).unwrap();\n+\n+            // Allocate a value slot if it doesn't have one.\n+            if self.places[place].value_index.is_none() {\n+                self.places[place].value_index = Some(self.value_count.into());\n+                self.value_count += 1;\n+            }\n+        }\n+\n+        // Recurse with all fields of this place.\n+        iter_fields(ty, tcx, |variant, field, ty| {\n+            if variant.is_some() {\n+                // Downcasts are currently not supported.\n+                return;\n+            }\n+            projection.push(PlaceElem::Field(field, ty));\n+            self.register_with_filter_rec(tcx, local, projection, ty, filter);\n+            projection.pop();\n+        });\n+    }\n+\n+    /// Tries to add the place to the map, without allocating a value slot.\n+    ///\n+    /// Can fail if the projection contains non-trackable elements.\n+    fn make_place<'tcx>(\n+        &mut self,\n+        local: Local,\n+        projection: &[PlaceElem<'tcx>],\n+    ) -> Result<PlaceIndex, ()> {\n+        // Get the base index of the local.\n+        let mut index =\n+            *self.locals.get_or_insert_with(local, || self.places.push(PlaceInfo::new(None)));\n+\n+        // Apply the projection.\n+        for &elem in projection {\n+            let elem = elem.try_into()?;\n+            index = *self.projections.entry((index, elem)).or_insert_with(|| {\n+                // Prepend new child to the linked list.\n+                let next = self.places.push(PlaceInfo::new(Some(elem)));\n+                self.places[next].next_sibling = self.places[index].first_child;\n+                self.places[index].first_child = Some(next);\n+                next\n+            });\n+        }\n+\n+        Ok(index)\n+    }\n+\n+    /// Returns the number of tracked places, i.e., those for which a value can be stored.\n+    pub fn tracked_places(&self) -> usize {\n+        self.value_count\n+    }\n+\n+    /// Applies a single projection element, yielding the corresponding child.\n+    pub fn apply(&self, place: PlaceIndex, elem: TrackElem) -> Option<PlaceIndex> {\n+        self.projections.get(&(place, elem)).copied()\n+    }\n+\n+    /// Locates the given place, if it exists in the tree.\n+    pub fn find(&self, place: PlaceRef<'_>) -> Option<PlaceIndex> {\n+        let mut index = *self.locals.get(place.local)?.as_ref()?;\n+\n+        for &elem in place.projection {\n+            index = self.apply(index, elem.try_into().ok()?)?;\n+        }\n+\n+        Some(index)\n+    }\n+\n+    /// Iterate over all direct children.\n+    pub fn children(&self, parent: PlaceIndex) -> impl Iterator<Item = PlaceIndex> + '_ {\n+        Children::new(self, parent)\n+    }\n+\n+    /// Invoke a function on the given place and all descendants.\n+    pub fn preorder_invoke(&self, root: PlaceIndex, f: &mut impl FnMut(PlaceIndex)) {\n+        f(root);\n+        for child in self.children(root) {\n+            self.preorder_invoke(child, f);\n+        }\n+    }\n+}\n+\n+/// This is the information tracked for every [`PlaceIndex`] and is stored by [`Map`].\n+///\n+/// Together, `first_child` and `next_sibling` form an intrusive linked list, which is used to\n+/// model a tree structure (a replacement for a member like `children: Vec<PlaceIndex>`).\n+#[derive(Debug)]\n+struct PlaceInfo {\n+    /// We store a [`ValueIndex`] if and only if the placed is tracked by the analysis.\n+    value_index: Option<ValueIndex>,\n+\n+    /// The projection used to go from parent to this node (only None for root).\n+    proj_elem: Option<TrackElem>,\n+\n+    /// The left-most child.\n+    first_child: Option<PlaceIndex>,\n+\n+    /// Index of the sibling to the right of this node.\n+    next_sibling: Option<PlaceIndex>,\n+}\n+\n+impl PlaceInfo {\n+    fn new(proj_elem: Option<TrackElem>) -> Self {\n+        Self { next_sibling: None, first_child: None, proj_elem, value_index: None }\n+    }\n+}\n+\n+struct Children<'a> {\n+    map: &'a Map,\n+    next: Option<PlaceIndex>,\n+}\n+\n+impl<'a> Children<'a> {\n+    fn new(map: &'a Map, parent: PlaceIndex) -> Self {\n+        Self { map, next: map.places[parent].first_child }\n+    }\n+}\n+\n+impl<'a> Iterator for Children<'a> {\n+    type Item = PlaceIndex;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        match self.next {\n+            Some(child) => {\n+                self.next = self.map.places[child].next_sibling;\n+                Some(child)\n+            }\n+            None => None,\n+        }\n+    }\n+}\n+\n+/// Used as the result of an operand or r-value.\n+pub enum ValueOrPlace<V> {\n+    Value(V),\n+    Place(PlaceIndex),\n+}\n+\n+impl<V: HasTop> ValueOrPlace<V> {\n+    pub fn top() -> Self {\n+        ValueOrPlace::Value(V::top())\n+    }\n+}\n+\n+/// The set of projection elements that can be used by a tracked place.\n+///\n+/// Although only field projections are currently allowed, this could change in the future.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum TrackElem {\n+    Field(Field),\n+}\n+\n+impl<V, T> TryFrom<ProjectionElem<V, T>> for TrackElem {\n+    type Error = ();\n+\n+    fn try_from(value: ProjectionElem<V, T>) -> Result<Self, Self::Error> {\n+        match value {\n+            ProjectionElem::Field(field, _) => Ok(TrackElem::Field(field)),\n+            _ => Err(()),\n+        }\n+    }\n+}\n+\n+/// Invokes `f` on all direct fields of `ty`.\n+fn iter_fields<'tcx>(\n+    ty: Ty<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+    mut f: impl FnMut(Option<VariantIdx>, Field, Ty<'tcx>),\n+) {\n+    match ty.kind() {\n+        ty::Tuple(list) => {\n+            for (field, ty) in list.iter().enumerate() {\n+                f(None, field.into(), ty);\n+            }\n+        }\n+        ty::Adt(def, substs) => {\n+            if def.is_union() {\n+                return;\n+            }\n+            for (v_index, v_def) in def.variants().iter_enumerated() {\n+                let variant = if def.is_struct() { None } else { Some(v_index) };\n+                for (f_index, f_def) in v_def.fields.iter().enumerate() {\n+                    let field_ty = f_def.ty(tcx, substs);\n+                    let field_ty = tcx\n+                        .try_normalize_erasing_regions(ty::ParamEnv::reveal_all(), field_ty)\n+                        .unwrap_or(field_ty);\n+                    f(variant, f_index.into(), field_ty);\n+                }\n+            }\n+        }\n+        ty::Closure(_, substs) => {\n+            iter_fields(substs.as_closure().tupled_upvars_ty(), tcx, f);\n+        }\n+        _ => (),\n+    }\n+}\n+\n+/// Returns all locals with projections that have their reference or address taken.\n+fn excluded_locals<'tcx>(body: &Body<'tcx>) -> IndexVec<Local, bool> {\n+    struct Collector {\n+        result: IndexVec<Local, bool>,\n+    }\n+\n+    impl<'tcx> Visitor<'tcx> for Collector {\n+        fn visit_place(&mut self, place: &Place<'tcx>, context: PlaceContext, _location: Location) {\n+            if context.is_borrow()\n+                || context.is_address_of()\n+                || context.is_drop()\n+                || context == PlaceContext::MutatingUse(MutatingUseContext::AsmOutput)\n+            {\n+                // A pointer to a place could be used to access other places with the same local,\n+                // hence we have to exclude the local completely.\n+                self.result[place.local] = true;\n+            }\n+        }\n+    }\n+\n+    let mut collector = Collector { result: IndexVec::from_elem(false, &body.local_decls) };\n+    collector.visit_body(body);\n+    collector.result\n+}\n+\n+/// This is used to visualize the dataflow analysis.\n+impl<'tcx, T> DebugWithContext<ValueAnalysisWrapper<T>> for State<T::Value>\n+where\n+    T: ValueAnalysis<'tcx>,\n+    T::Value: Debug,\n+{\n+    fn fmt_with(&self, ctxt: &ValueAnalysisWrapper<T>, f: &mut Formatter<'_>) -> std::fmt::Result {\n+        match &self.0 {\n+            StateData::Reachable(values) => debug_with_context(values, None, ctxt.0.map(), f),\n+            StateData::Unreachable => write!(f, \"unreachable\"),\n+        }\n+    }\n+\n+    fn fmt_diff_with(\n+        &self,\n+        old: &Self,\n+        ctxt: &ValueAnalysisWrapper<T>,\n+        f: &mut Formatter<'_>,\n+    ) -> std::fmt::Result {\n+        match (&self.0, &old.0) {\n+            (StateData::Reachable(this), StateData::Reachable(old)) => {\n+                debug_with_context(this, Some(old), ctxt.0.map(), f)\n+            }\n+            _ => Ok(()), // Consider printing something here.\n+        }\n+    }\n+}\n+\n+fn debug_with_context_rec<V: Debug + Eq>(\n+    place: PlaceIndex,\n+    place_str: &str,\n+    new: &IndexVec<ValueIndex, V>,\n+    old: Option<&IndexVec<ValueIndex, V>>,\n+    map: &Map,\n+    f: &mut Formatter<'_>,\n+) -> std::fmt::Result {\n+    if let Some(value) = map.places[place].value_index {\n+        match old {\n+            None => writeln!(f, \"{}: {:?}\", place_str, new[value])?,\n+            Some(old) => {\n+                if new[value] != old[value] {\n+                    writeln!(f, \"\\u{001f}-{}: {:?}\", place_str, old[value])?;\n+                    writeln!(f, \"\\u{001f}+{}: {:?}\", place_str, new[value])?;\n+                }\n+            }\n+        }\n+    }\n+\n+    for child in map.children(place) {\n+        let info_elem = map.places[child].proj_elem.unwrap();\n+        let child_place_str = match info_elem {\n+            TrackElem::Field(field) => {\n+                if place_str.starts_with(\"*\") {\n+                    format!(\"({}).{}\", place_str, field.index())\n+                } else {\n+                    format!(\"{}.{}\", place_str, field.index())\n+                }\n+            }\n+        };\n+        debug_with_context_rec(child, &child_place_str, new, old, map, f)?;\n+    }\n+\n+    Ok(())\n+}\n+\n+fn debug_with_context<V: Debug + Eq>(\n+    new: &IndexVec<ValueIndex, V>,\n+    old: Option<&IndexVec<ValueIndex, V>>,\n+    map: &Map,\n+    f: &mut Formatter<'_>,\n+) -> std::fmt::Result {\n+    for (local, place) in map.locals.iter_enumerated() {\n+        if let Some(place) = place {\n+            debug_with_context_rec(*place, &format!(\"{:?}\", local), new, old, map, f)?;\n+        }\n+    }\n+    Ok(())\n+}"}, {"sha": "e9027387413cfe1e97425a7992e74e33384fbfb3", "filename": "compiler/rustc_mir_transform/src/dataflow_const_prop.rs", "status": "added", "additions": 530, "deletions": 0, "changes": 530, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -0,0 +1,530 @@\n+//! A constant propagation optimization pass based on dataflow analysis.\n+//!\n+//! Currently, this pass only propagates scalar values.\n+\n+use rustc_const_eval::interpret::{ConstValue, ImmTy, Immediate, InterpCx, Scalar};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_middle::mir::visit::{MutVisitor, Visitor};\n+use rustc_middle::mir::*;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_mir_dataflow::value_analysis::{Map, State, TrackElem, ValueAnalysis, ValueOrPlace};\n+use rustc_mir_dataflow::{lattice::FlatSet, Analysis, ResultsVisitor, SwitchIntEdgeEffects};\n+use rustc_span::DUMMY_SP;\n+\n+use crate::MirPass;\n+\n+// These constants are somewhat random guesses and have not been optimized.\n+// If `tcx.sess.mir_opt_level() >= 4`, we ignore the limits (this can become very expensive).\n+const BLOCK_LIMIT: usize = 100;\n+const PLACE_LIMIT: usize = 100;\n+\n+pub struct DataflowConstProp;\n+\n+impl<'tcx> MirPass<'tcx> for DataflowConstProp {\n+    fn is_enabled(&self, sess: &rustc_session::Session) -> bool {\n+        sess.mir_opt_level() >= 3\n+    }\n+\n+    #[instrument(skip_all level = \"debug\")]\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        if tcx.sess.mir_opt_level() < 4 && body.basic_blocks.len() > BLOCK_LIMIT {\n+            debug!(\"aborted dataflow const prop due too many basic blocks\");\n+            return;\n+        }\n+\n+        // Decide which places to track during the analysis.\n+        let map = Map::from_filter(tcx, body, Ty::is_scalar);\n+\n+        // We want to have a somewhat linear runtime w.r.t. the number of statements/terminators.\n+        // Let's call this number `n`. Dataflow analysis has `O(h*n)` transfer function\n+        // applications, where `h` is the height of the lattice. Because the height of our lattice\n+        // is linear w.r.t. the number of tracked places, this is `O(tracked_places * n)`. However,\n+        // because every transfer function application could traverse the whole map, this becomes\n+        // `O(num_nodes * tracked_places * n)` in terms of time complexity. Since the number of\n+        // map nodes is strongly correlated to the number of tracked places, this becomes more or\n+        // less `O(n)` if we place a constant limit on the number of tracked places.\n+        if tcx.sess.mir_opt_level() < 4 && map.tracked_places() > PLACE_LIMIT {\n+            debug!(\"aborted dataflow const prop due to too many tracked places\");\n+            return;\n+        }\n+\n+        // Perform the actual dataflow analysis.\n+        let analysis = ConstAnalysis::new(tcx, body, map);\n+        let results = debug_span!(\"analyze\")\n+            .in_scope(|| analysis.wrap().into_engine(tcx, body).iterate_to_fixpoint());\n+\n+        // Collect results and patch the body afterwards.\n+        let mut visitor = CollectAndPatch::new(tcx, &results.analysis.0.map);\n+        debug_span!(\"collect\").in_scope(|| results.visit_reachable_with(body, &mut visitor));\n+        debug_span!(\"patch\").in_scope(|| visitor.visit_body(body));\n+    }\n+}\n+\n+struct ConstAnalysis<'tcx> {\n+    map: Map,\n+    tcx: TyCtxt<'tcx>,\n+    ecx: InterpCx<'tcx, 'tcx, DummyMachine>,\n+    param_env: ty::ParamEnv<'tcx>,\n+}\n+\n+impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'tcx> {\n+    type Value = FlatSet<ScalarTy<'tcx>>;\n+\n+    const NAME: &'static str = \"ConstAnalysis\";\n+\n+    fn map(&self) -> &Map {\n+        &self.map\n+    }\n+\n+    fn handle_assign(\n+        &self,\n+        target: Place<'tcx>,\n+        rvalue: &Rvalue<'tcx>,\n+        state: &mut State<Self::Value>,\n+    ) {\n+        match rvalue {\n+            Rvalue::CheckedBinaryOp(op, box (left, right)) => {\n+                let target = self.map().find(target.as_ref());\n+                if let Some(target) = target {\n+                    // We should not track any projections other than\n+                    // what is overwritten below, but just in case...\n+                    state.flood_idx(target, self.map());\n+                }\n+\n+                let value_target = target\n+                    .and_then(|target| self.map().apply(target, TrackElem::Field(0_u32.into())));\n+                let overflow_target = target\n+                    .and_then(|target| self.map().apply(target, TrackElem::Field(1_u32.into())));\n+\n+                if value_target.is_some() || overflow_target.is_some() {\n+                    let (val, overflow) = self.binary_op(state, *op, left, right);\n+\n+                    if let Some(value_target) = value_target {\n+                        state.assign_idx(value_target, ValueOrPlace::Value(val), self.map());\n+                    }\n+                    if let Some(overflow_target) = overflow_target {\n+                        let overflow = match overflow {\n+                            FlatSet::Top => FlatSet::Top,\n+                            FlatSet::Elem(overflow) => {\n+                                if overflow {\n+                                    // Overflow cannot be reliably propagated. See: https://github.com/rust-lang/rust/pull/101168#issuecomment-1288091446\n+                                    FlatSet::Top\n+                                } else {\n+                                    self.wrap_scalar(Scalar::from_bool(false), self.tcx.types.bool)\n+                                }\n+                            }\n+                            FlatSet::Bottom => FlatSet::Bottom,\n+                        };\n+                        state.assign_idx(\n+                            overflow_target,\n+                            ValueOrPlace::Value(overflow),\n+                            self.map(),\n+                        );\n+                    }\n+                }\n+            }\n+            _ => self.super_assign(target, rvalue, state),\n+        }\n+    }\n+\n+    fn handle_rvalue(\n+        &self,\n+        rvalue: &Rvalue<'tcx>,\n+        state: &mut State<Self::Value>,\n+    ) -> ValueOrPlace<Self::Value> {\n+        match rvalue {\n+            Rvalue::Cast(\n+                kind @ (CastKind::IntToInt\n+                | CastKind::FloatToInt\n+                | CastKind::FloatToFloat\n+                | CastKind::IntToFloat),\n+                operand,\n+                ty,\n+            ) => match self.eval_operand(operand, state) {\n+                FlatSet::Elem(op) => match kind {\n+                    CastKind::IntToInt | CastKind::IntToFloat => {\n+                        self.ecx.int_to_int_or_float(&op, *ty)\n+                    }\n+                    CastKind::FloatToInt | CastKind::FloatToFloat => {\n+                        self.ecx.float_to_float_or_int(&op, *ty)\n+                    }\n+                    _ => unreachable!(),\n+                }\n+                .map(|result| ValueOrPlace::Value(self.wrap_immediate(result, *ty)))\n+                .unwrap_or(ValueOrPlace::top()),\n+                _ => ValueOrPlace::top(),\n+            },\n+            Rvalue::BinaryOp(op, box (left, right)) => {\n+                // Overflows must be ignored here.\n+                let (val, _overflow) = self.binary_op(state, *op, left, right);\n+                ValueOrPlace::Value(val)\n+            }\n+            Rvalue::UnaryOp(op, operand) => match self.eval_operand(operand, state) {\n+                FlatSet::Elem(value) => self\n+                    .ecx\n+                    .unary_op(*op, &value)\n+                    .map(|val| ValueOrPlace::Value(self.wrap_immty(val)))\n+                    .unwrap_or(ValueOrPlace::Value(FlatSet::Top)),\n+                FlatSet::Bottom => ValueOrPlace::Value(FlatSet::Bottom),\n+                FlatSet::Top => ValueOrPlace::Value(FlatSet::Top),\n+            },\n+            _ => self.super_rvalue(rvalue, state),\n+        }\n+    }\n+\n+    fn handle_constant(\n+        &self,\n+        constant: &Constant<'tcx>,\n+        _state: &mut State<Self::Value>,\n+    ) -> Self::Value {\n+        constant\n+            .literal\n+            .eval(self.tcx, self.param_env)\n+            .try_to_scalar()\n+            .map(|value| FlatSet::Elem(ScalarTy(value, constant.ty())))\n+            .unwrap_or(FlatSet::Top)\n+    }\n+\n+    fn handle_switch_int(\n+        &self,\n+        discr: &Operand<'tcx>,\n+        apply_edge_effects: &mut impl SwitchIntEdgeEffects<State<Self::Value>>,\n+    ) {\n+        // FIXME: The dataflow framework only provides the state if we call `apply()`, which makes\n+        // this more inefficient than it has to be.\n+        let mut discr_value = None;\n+        let mut handled = false;\n+        apply_edge_effects.apply(|state, target| {\n+            let discr_value = match discr_value {\n+                Some(value) => value,\n+                None => {\n+                    let value = match self.handle_operand(discr, state) {\n+                        ValueOrPlace::Value(value) => value,\n+                        ValueOrPlace::Place(place) => state.get_idx(place, self.map()),\n+                    };\n+                    let result = match value {\n+                        FlatSet::Top => FlatSet::Top,\n+                        FlatSet::Elem(ScalarTy(scalar, _)) => {\n+                            let int = scalar.assert_int();\n+                            FlatSet::Elem(int.assert_bits(int.size()))\n+                        }\n+                        FlatSet::Bottom => FlatSet::Bottom,\n+                    };\n+                    discr_value = Some(result);\n+                    result\n+                }\n+            };\n+\n+            let FlatSet::Elem(choice) = discr_value else {\n+                // Do nothing if we don't know which branch will be taken.\n+                return\n+            };\n+\n+            if target.value.map(|n| n == choice).unwrap_or(!handled) {\n+                // Branch is taken. Has no effect on state.\n+                handled = true;\n+            } else {\n+                // Branch is not taken.\n+                state.mark_unreachable();\n+            }\n+        })\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq)]\n+struct ScalarTy<'tcx>(Scalar, Ty<'tcx>);\n+\n+impl<'tcx> std::fmt::Debug for ScalarTy<'tcx> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        // This is used for dataflow visualization, so we return something more concise.\n+        std::fmt::Display::fmt(&ConstantKind::Val(ConstValue::Scalar(self.0), self.1), f)\n+    }\n+}\n+\n+impl<'tcx> ConstAnalysis<'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, map: Map) -> Self {\n+        let param_env = tcx.param_env(body.source.def_id());\n+        Self {\n+            map,\n+            tcx,\n+            ecx: InterpCx::new(tcx, DUMMY_SP, param_env, DummyMachine),\n+            param_env: param_env,\n+        }\n+    }\n+\n+    fn binary_op(\n+        &self,\n+        state: &mut State<FlatSet<ScalarTy<'tcx>>>,\n+        op: BinOp,\n+        left: &Operand<'tcx>,\n+        right: &Operand<'tcx>,\n+    ) -> (FlatSet<ScalarTy<'tcx>>, FlatSet<bool>) {\n+        let left = self.eval_operand(left, state);\n+        let right = self.eval_operand(right, state);\n+        match (left, right) {\n+            (FlatSet::Elem(left), FlatSet::Elem(right)) => {\n+                match self.ecx.overflowing_binary_op(op, &left, &right) {\n+                    Ok((val, overflow, ty)) => (self.wrap_scalar(val, ty), FlatSet::Elem(overflow)),\n+                    _ => (FlatSet::Top, FlatSet::Top),\n+                }\n+            }\n+            (FlatSet::Bottom, _) | (_, FlatSet::Bottom) => (FlatSet::Bottom, FlatSet::Bottom),\n+            (_, _) => {\n+                // Could attempt some algebraic simplifcations here.\n+                (FlatSet::Top, FlatSet::Top)\n+            }\n+        }\n+    }\n+\n+    fn eval_operand(\n+        &self,\n+        op: &Operand<'tcx>,\n+        state: &mut State<FlatSet<ScalarTy<'tcx>>>,\n+    ) -> FlatSet<ImmTy<'tcx>> {\n+        let value = match self.handle_operand(op, state) {\n+            ValueOrPlace::Value(value) => value,\n+            ValueOrPlace::Place(place) => state.get_idx(place, &self.map),\n+        };\n+        match value {\n+            FlatSet::Top => FlatSet::Top,\n+            FlatSet::Elem(ScalarTy(scalar, ty)) => self\n+                .tcx\n+                .layout_of(self.param_env.and(ty))\n+                .map(|layout| FlatSet::Elem(ImmTy::from_scalar(scalar, layout)))\n+                .unwrap_or(FlatSet::Top),\n+            FlatSet::Bottom => FlatSet::Bottom,\n+        }\n+    }\n+\n+    fn wrap_scalar(&self, scalar: Scalar, ty: Ty<'tcx>) -> FlatSet<ScalarTy<'tcx>> {\n+        FlatSet::Elem(ScalarTy(scalar, ty))\n+    }\n+\n+    fn wrap_immediate(&self, imm: Immediate, ty: Ty<'tcx>) -> FlatSet<ScalarTy<'tcx>> {\n+        match imm {\n+            Immediate::Scalar(scalar) => self.wrap_scalar(scalar, ty),\n+            _ => FlatSet::Top,\n+        }\n+    }\n+\n+    fn wrap_immty(&self, val: ImmTy<'tcx>) -> FlatSet<ScalarTy<'tcx>> {\n+        self.wrap_immediate(*val, val.layout.ty)\n+    }\n+}\n+\n+struct CollectAndPatch<'tcx, 'map> {\n+    tcx: TyCtxt<'tcx>,\n+    map: &'map Map,\n+\n+    /// For a given MIR location, this stores the values of the operands used by that location. In\n+    /// particular, this is before the effect, such that the operands of `_1 = _1 + _2` are\n+    /// properly captured. (This may become UB soon, but it is currently emitted even by safe code.)\n+    before_effect: FxHashMap<(Location, Place<'tcx>), ScalarTy<'tcx>>,\n+\n+    /// Stores the assigned values for assignments where the Rvalue is constant.\n+    assignments: FxHashMap<Location, ScalarTy<'tcx>>,\n+}\n+\n+impl<'tcx, 'map> CollectAndPatch<'tcx, 'map> {\n+    fn new(tcx: TyCtxt<'tcx>, map: &'map Map) -> Self {\n+        Self { tcx, map, before_effect: FxHashMap::default(), assignments: FxHashMap::default() }\n+    }\n+\n+    fn make_operand(&self, scalar: ScalarTy<'tcx>) -> Operand<'tcx> {\n+        Operand::Constant(Box::new(Constant {\n+            span: DUMMY_SP,\n+            user_ty: None,\n+            literal: ConstantKind::Val(ConstValue::Scalar(scalar.0), scalar.1),\n+        }))\n+    }\n+}\n+\n+impl<'mir, 'tcx, 'map> ResultsVisitor<'mir, 'tcx> for CollectAndPatch<'tcx, 'map> {\n+    type FlowState = State<FlatSet<ScalarTy<'tcx>>>;\n+\n+    fn visit_statement_before_primary_effect(\n+        &mut self,\n+        state: &Self::FlowState,\n+        statement: &'mir Statement<'tcx>,\n+        location: Location,\n+    ) {\n+        match &statement.kind {\n+            StatementKind::Assign(box (_, rvalue)) => {\n+                OperandCollector { state, visitor: self }.visit_rvalue(rvalue, location);\n+            }\n+            _ => (),\n+        }\n+    }\n+\n+    fn visit_statement_after_primary_effect(\n+        &mut self,\n+        state: &Self::FlowState,\n+        statement: &'mir Statement<'tcx>,\n+        location: Location,\n+    ) {\n+        match statement.kind {\n+            StatementKind::Assign(box (_, Rvalue::Use(Operand::Constant(_)))) => {\n+                // Don't overwrite the assignment if it already uses a constant (to keep the span).\n+            }\n+            StatementKind::Assign(box (place, _)) => match state.get(place.as_ref(), self.map) {\n+                FlatSet::Top => (),\n+                FlatSet::Elem(value) => {\n+                    self.assignments.insert(location, value);\n+                }\n+                FlatSet::Bottom => {\n+                    // This assignment is either unreachable, or an uninitialized value is assigned.\n+                }\n+            },\n+            _ => (),\n+        }\n+    }\n+\n+    fn visit_terminator_before_primary_effect(\n+        &mut self,\n+        state: &Self::FlowState,\n+        terminator: &'mir Terminator<'tcx>,\n+        location: Location,\n+    ) {\n+        OperandCollector { state, visitor: self }.visit_terminator(terminator, location);\n+    }\n+}\n+\n+impl<'tcx, 'map> MutVisitor<'tcx> for CollectAndPatch<'tcx, 'map> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn visit_statement(&mut self, statement: &mut Statement<'tcx>, location: Location) {\n+        if let Some(value) = self.assignments.get(&location) {\n+            match &mut statement.kind {\n+                StatementKind::Assign(box (_, rvalue)) => {\n+                    *rvalue = Rvalue::Use(self.make_operand(value.clone()));\n+                }\n+                _ => bug!(\"found assignment info for non-assign statement\"),\n+            }\n+        } else {\n+            self.super_statement(statement, location);\n+        }\n+    }\n+\n+    fn visit_operand(&mut self, operand: &mut Operand<'tcx>, location: Location) {\n+        match operand {\n+            Operand::Copy(place) | Operand::Move(place) => {\n+                if let Some(value) = self.before_effect.get(&(location, *place)) {\n+                    *operand = self.make_operand(value.clone());\n+                }\n+            }\n+            _ => (),\n+        }\n+    }\n+}\n+\n+struct OperandCollector<'tcx, 'map, 'a> {\n+    state: &'a State<FlatSet<ScalarTy<'tcx>>>,\n+    visitor: &'a mut CollectAndPatch<'tcx, 'map>,\n+}\n+\n+impl<'tcx, 'map, 'a> Visitor<'tcx> for OperandCollector<'tcx, 'map, 'a> {\n+    fn visit_operand(&mut self, operand: &Operand<'tcx>, location: Location) {\n+        match operand {\n+            Operand::Copy(place) | Operand::Move(place) => {\n+                match self.state.get(place.as_ref(), self.visitor.map) {\n+                    FlatSet::Top => (),\n+                    FlatSet::Elem(value) => {\n+                        self.visitor.before_effect.insert((location, *place), value);\n+                    }\n+                    FlatSet::Bottom => (),\n+                }\n+            }\n+            _ => (),\n+        }\n+    }\n+}\n+\n+struct DummyMachine;\n+\n+impl<'mir, 'tcx> rustc_const_eval::interpret::Machine<'mir, 'tcx> for DummyMachine {\n+    rustc_const_eval::interpret::compile_time_machine!(<'mir, 'tcx>);\n+    type MemoryKind = !;\n+    const PANIC_ON_ALLOC_FAIL: bool = true;\n+\n+    fn enforce_alignment(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n+        unimplemented!()\n+    }\n+\n+    fn enforce_validity(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n+        unimplemented!()\n+    }\n+\n+    fn find_mir_or_eval_fn(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _instance: ty::Instance<'tcx>,\n+        _abi: rustc_target::spec::abi::Abi,\n+        _args: &[rustc_const_eval::interpret::OpTy<'tcx, Self::Provenance>],\n+        _destination: &rustc_const_eval::interpret::PlaceTy<'tcx, Self::Provenance>,\n+        _target: Option<BasicBlock>,\n+        _unwind: rustc_const_eval::interpret::StackPopUnwind,\n+    ) -> interpret::InterpResult<'tcx, Option<(&'mir Body<'tcx>, ty::Instance<'tcx>)>> {\n+        unimplemented!()\n+    }\n+\n+    fn call_intrinsic(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _instance: ty::Instance<'tcx>,\n+        _args: &[rustc_const_eval::interpret::OpTy<'tcx, Self::Provenance>],\n+        _destination: &rustc_const_eval::interpret::PlaceTy<'tcx, Self::Provenance>,\n+        _target: Option<BasicBlock>,\n+        _unwind: rustc_const_eval::interpret::StackPopUnwind,\n+    ) -> interpret::InterpResult<'tcx> {\n+        unimplemented!()\n+    }\n+\n+    fn assert_panic(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _msg: &rustc_middle::mir::AssertMessage<'tcx>,\n+        _unwind: Option<BasicBlock>,\n+    ) -> interpret::InterpResult<'tcx> {\n+        unimplemented!()\n+    }\n+\n+    fn binary_ptr_op(\n+        _ecx: &InterpCx<'mir, 'tcx, Self>,\n+        _bin_op: BinOp,\n+        _left: &rustc_const_eval::interpret::ImmTy<'tcx, Self::Provenance>,\n+        _right: &rustc_const_eval::interpret::ImmTy<'tcx, Self::Provenance>,\n+    ) -> interpret::InterpResult<'tcx, (interpret::Scalar<Self::Provenance>, bool, Ty<'tcx>)> {\n+        throw_unsup!(Unsupported(\"\".into()))\n+    }\n+\n+    fn expose_ptr(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _ptr: interpret::Pointer<Self::Provenance>,\n+    ) -> interpret::InterpResult<'tcx> {\n+        unimplemented!()\n+    }\n+\n+    fn init_frame_extra(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _frame: rustc_const_eval::interpret::Frame<'mir, 'tcx, Self::Provenance>,\n+    ) -> interpret::InterpResult<\n+        'tcx,\n+        rustc_const_eval::interpret::Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>,\n+    > {\n+        unimplemented!()\n+    }\n+\n+    fn stack<'a>(\n+        _ecx: &'a InterpCx<'mir, 'tcx, Self>,\n+    ) -> &'a [rustc_const_eval::interpret::Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>]\n+    {\n+        unimplemented!()\n+    }\n+\n+    fn stack_mut<'a>(\n+        _ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n+    ) -> &'a mut Vec<\n+        rustc_const_eval::interpret::Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>,\n+    > {\n+        unimplemented!()\n+    }\n+}"}, {"sha": "692eeddfb98578da5f02f4c1133e6b3461bfa77a", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -54,6 +54,7 @@ mod const_goto;\n mod const_prop;\n mod const_prop_lint;\n mod coverage;\n+mod dataflow_const_prop;\n mod dead_store_elimination;\n mod deaggregator;\n mod deduce_param_attrs;\n@@ -569,6 +570,7 @@ fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n             //\n             // FIXME(#70073): This pass is responsible for both optimization as well as some lints.\n             &const_prop::ConstProp,\n+            &dataflow_const_prop::DataflowConstProp,\n             //\n             // Const-prop runs unconditionally, but doesn't mutate the MIR at mir-opt-level=0.\n             &const_debuginfo::ConstDebugInfo,"}, {"sha": "03df5c9504be24875e4c5bc0a0436cc4a92153dc", "filename": "src/test/mir-opt/coverage_graphviz.bar.InstrumentCoverage.0.dot", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fcoverage_graphviz.bar.InstrumentCoverage.0.dot", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fcoverage_graphviz.bar.InstrumentCoverage.0.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fcoverage_graphviz.bar.InstrumentCoverage.0.dot?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -2,5 +2,5 @@ digraph Cov_0_4 {\n     graph [fontname=\"Courier, monospace\"];\n     node [fontname=\"Courier, monospace\"];\n     edge [fontname=\"Courier, monospace\"];\n-    bcb0__Cov_0_4 [shape=\"none\", label=<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"><tr><td bgcolor=\"gray\" align=\"center\" colspan=\"1\">bcb0</td></tr><tr><td align=\"left\" balign=\"left\"></td></tr><tr><td align=\"left\" balign=\"left\">Counter(bcb0) at 18:1-20:2<br/>    19:5-19:9: @0[0]: Coverage::Counter(1) for $DIR/coverage_graphviz.rs:18:1 - 20:2<br/>    20:2-20:2: @0.Return: return</td></tr><tr><td align=\"left\" balign=\"left\">bb0: Return</td></tr></table>>];\n+    bcb0__Cov_0_4 [shape=\"none\", label=<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"><tr><td bgcolor=\"gray\" align=\"center\" colspan=\"1\">bcb0</td></tr><tr><td align=\"left\" balign=\"left\"></td></tr><tr><td align=\"left\" balign=\"left\">Counter(bcb0) at 18:1-20:2<br align=\"left\"/>    19:5-19:9: @0[0]: Coverage::Counter(1) for $DIR/coverage_graphviz.rs:18:1 - 20:2<br align=\"left\"/>    20:2-20:2: @0.Return: return</td></tr><tr><td align=\"left\" balign=\"left\">bb0: Return</td></tr></table>>];\n }"}, {"sha": "fd21b14af25f3b8fcd1d3e1e0ef6b85d29e72c25", "filename": "src/test/mir-opt/coverage_graphviz.main.InstrumentCoverage.0.dot", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fcoverage_graphviz.main.InstrumentCoverage.0.dot", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fcoverage_graphviz.main.InstrumentCoverage.0.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fcoverage_graphviz.main.InstrumentCoverage.0.dot?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -2,10 +2,10 @@ digraph Cov_0_3 {\n     graph [fontname=\"Courier, monospace\"];\n     node [fontname=\"Courier, monospace\"];\n     edge [fontname=\"Courier, monospace\"];\n-    bcb3__Cov_0_3 [shape=\"none\", label=<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"><tr><td bgcolor=\"gray\" align=\"center\" colspan=\"1\">bcb3</td></tr><tr><td align=\"left\" balign=\"left\">Counter(bcb3) at 13:10-13:10<br/>    13:10-13:10: @5[0]: Coverage::Counter(2) for $DIR/coverage_graphviz.rs:13:10 - 13:11</td></tr><tr><td align=\"left\" balign=\"left\">bb5: Goto</td></tr></table>>];\n-    bcb2__Cov_0_3 [shape=\"none\", label=<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"><tr><td bgcolor=\"gray\" align=\"center\" colspan=\"1\">bcb2</td></tr><tr><td align=\"left\" balign=\"left\">Expression(bcb1:(bcb0 + bcb3) - bcb3) at 12:13-12:18<br/>    12:13-12:18: @4[0]: Coverage::Expression(4294967293) = 4294967294 + 0 for $DIR/coverage_graphviz.rs:15:1 - 15:2<br/>Expression(bcb2:(bcb1:(bcb0 + bcb3) - bcb3) + 0) at 15:2-15:2<br/>    15:2-15:2: @4.Return: return</td></tr><tr><td align=\"left\" balign=\"left\">bb4: Return</td></tr></table>>];\n-    bcb1__Cov_0_3 [shape=\"none\", label=<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"><tr><td bgcolor=\"gray\" align=\"center\" colspan=\"1\">bcb1</td></tr><tr><td align=\"left\" balign=\"left\">Expression(bcb0 + bcb3) at 10:5-11:17<br/>    11:12-11:17: @2.Call: _2 = bar() -&gt; [return: bb3, unwind: bb6]</td></tr><tr><td align=\"left\" balign=\"left\">bb1: FalseUnwind<br/>bb2: Call</td></tr><tr><td align=\"left\" balign=\"left\">bb3: SwitchInt</td></tr></table>>];\n-    bcb0__Cov_0_3 [shape=\"none\", label=<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"><tr><td bgcolor=\"gray\" align=\"center\" colspan=\"1\">bcb0</td></tr><tr><td align=\"left\" balign=\"left\"></td></tr><tr><td align=\"left\" balign=\"left\">Counter(bcb0) at 9:1-9:11<br/>    </td></tr><tr><td align=\"left\" balign=\"left\">bb0: Goto</td></tr></table>>];\n+    bcb3__Cov_0_3 [shape=\"none\", label=<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"><tr><td bgcolor=\"gray\" align=\"center\" colspan=\"1\">bcb3</td></tr><tr><td align=\"left\" balign=\"left\">Counter(bcb3) at 13:10-13:10<br align=\"left\"/>    13:10-13:10: @5[0]: Coverage::Counter(2) for $DIR/coverage_graphviz.rs:13:10 - 13:11</td></tr><tr><td align=\"left\" balign=\"left\">bb5: Goto</td></tr></table>>];\n+    bcb2__Cov_0_3 [shape=\"none\", label=<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"><tr><td bgcolor=\"gray\" align=\"center\" colspan=\"1\">bcb2</td></tr><tr><td align=\"left\" balign=\"left\">Expression(bcb1:(bcb0 + bcb3) - bcb3) at 12:13-12:18<br align=\"left\"/>    12:13-12:18: @4[0]: Coverage::Expression(4294967293) = 4294967294 + 0 for $DIR/coverage_graphviz.rs:15:1 - 15:2<br align=\"left\"/>Expression(bcb2:(bcb1:(bcb0 + bcb3) - bcb3) + 0) at 15:2-15:2<br align=\"left\"/>    15:2-15:2: @4.Return: return</td></tr><tr><td align=\"left\" balign=\"left\">bb4: Return</td></tr></table>>];\n+    bcb1__Cov_0_3 [shape=\"none\", label=<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"><tr><td bgcolor=\"gray\" align=\"center\" colspan=\"1\">bcb1</td></tr><tr><td align=\"left\" balign=\"left\">Expression(bcb0 + bcb3) at 10:5-11:17<br align=\"left\"/>    11:12-11:17: @2.Call: _2 = bar() -&gt; [return: bb3, unwind: bb6]</td></tr><tr><td align=\"left\" balign=\"left\">bb1: FalseUnwind<br align=\"left\"/>bb2: Call</td></tr><tr><td align=\"left\" balign=\"left\">bb3: SwitchInt</td></tr></table>>];\n+    bcb0__Cov_0_3 [shape=\"none\", label=<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"><tr><td bgcolor=\"gray\" align=\"center\" colspan=\"1\">bcb0</td></tr><tr><td align=\"left\" balign=\"left\"></td></tr><tr><td align=\"left\" balign=\"left\">Counter(bcb0) at 9:1-9:11<br align=\"left\"/>    </td></tr><tr><td align=\"left\" balign=\"left\">bb0: Goto</td></tr></table>>];\n     bcb3__Cov_0_3 -> bcb1__Cov_0_3 [label=<>];\n     bcb1__Cov_0_3 -> bcb3__Cov_0_3 [label=<false>];\n     bcb1__Cov_0_3 -> bcb2__Cov_0_3 [label=<otherwise>];"}, {"sha": "bf9ab8669380a98a4a3cf1e43e83b4a3635d3a47", "filename": "src/test/mir-opt/dataflow-const-prop/cast.main.DataflowConstProp.diff", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fcast.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fcast.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fcast.main.DataflowConstProp.diff?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -0,0 +1,37 @@\n+- // MIR for `main` before DataflowConstProp\n++ // MIR for `main` after DataflowConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/cast.rs:+0:11: +0:11\n+      let _1: i32;                         // in scope 0 at $DIR/cast.rs:+1:9: +1:10\n+      let mut _3: u8;                      // in scope 0 at $DIR/cast.rs:+2:13: +2:20\n+      let mut _4: i32;                     // in scope 0 at $DIR/cast.rs:+2:13: +2:14\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/cast.rs:+1:9: +1:10\n+          let _2: u8;                      // in scope 1 at $DIR/cast.rs:+2:9: +2:10\n+          scope 2 {\n+              debug b => _2;               // in scope 2 at $DIR/cast.rs:+2:9: +2:10\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/cast.rs:+1:9: +1:10\n+          _1 = const 257_i32;              // scope 0 at $DIR/cast.rs:+1:13: +1:16\n+          StorageLive(_2);                 // scope 1 at $DIR/cast.rs:+2:9: +2:10\n+          StorageLive(_3);                 // scope 1 at $DIR/cast.rs:+2:13: +2:20\n+          StorageLive(_4);                 // scope 1 at $DIR/cast.rs:+2:13: +2:14\n+-         _4 = _1;                         // scope 1 at $DIR/cast.rs:+2:13: +2:14\n+-         _3 = move _4 as u8 (IntToInt);   // scope 1 at $DIR/cast.rs:+2:13: +2:20\n++         _4 = const 257_i32;              // scope 1 at $DIR/cast.rs:+2:13: +2:14\n++         _3 = const 1_u8;                 // scope 1 at $DIR/cast.rs:+2:13: +2:20\n+          StorageDead(_4);                 // scope 1 at $DIR/cast.rs:+2:19: +2:20\n+-         _2 = Add(move _3, const 1_u8);   // scope 1 at $DIR/cast.rs:+2:13: +2:24\n++         _2 = const 2_u8;                 // scope 1 at $DIR/cast.rs:+2:13: +2:24\n+          StorageDead(_3);                 // scope 1 at $DIR/cast.rs:+2:23: +2:24\n+          _0 = const ();                   // scope 0 at $DIR/cast.rs:+0:11: +3:2\n+          StorageDead(_2);                 // scope 1 at $DIR/cast.rs:+3:1: +3:2\n+          StorageDead(_1);                 // scope 0 at $DIR/cast.rs:+3:1: +3:2\n+          return;                          // scope 0 at $DIR/cast.rs:+3:2: +3:2\n+      }\n+  }\n+  "}, {"sha": "484403f7f0ec41d5d4c3f1aa1ef2018cd5a6bc78", "filename": "src/test/mir-opt/dataflow-const-prop/cast.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fcast.rs?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -0,0 +1,7 @@\n+// unit-test: DataflowConstProp\n+\n+// EMIT_MIR cast.main.DataflowConstProp.diff\n+fn main() {\n+    let a = 257;\n+    let b = a as u8 + 1;\n+}"}, {"sha": "a4ebd0c8c18f0a11952c06e563021901d0429a1d", "filename": "src/test/mir-opt/dataflow-const-prop/checked.main.DataflowConstProp.diff", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fchecked.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fchecked.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fchecked.main.DataflowConstProp.diff?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -0,0 +1,80 @@\n+- // MIR for `main` before DataflowConstProp\n++ // MIR for `main` after DataflowConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/checked.rs:+0:11: +0:11\n+      let _1: i32;                         // in scope 0 at $DIR/checked.rs:+1:9: +1:10\n+      let mut _4: i32;                     // in scope 0 at $DIR/checked.rs:+3:13: +3:14\n+      let mut _5: i32;                     // in scope 0 at $DIR/checked.rs:+3:17: +3:18\n+      let mut _6: (i32, bool);             // in scope 0 at $DIR/checked.rs:+3:13: +3:18\n+      let mut _9: i32;                     // in scope 0 at $DIR/checked.rs:+6:13: +6:14\n+      let mut _10: (i32, bool);            // in scope 0 at $DIR/checked.rs:+6:13: +6:18\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/checked.rs:+1:9: +1:10\n+          let _2: i32;                     // in scope 1 at $DIR/checked.rs:+2:9: +2:10\n+          scope 2 {\n+              debug b => _2;               // in scope 2 at $DIR/checked.rs:+2:9: +2:10\n+              let _3: i32;                 // in scope 2 at $DIR/checked.rs:+3:9: +3:10\n+              scope 3 {\n+                  debug c => _3;           // in scope 3 at $DIR/checked.rs:+3:9: +3:10\n+                  let _7: i32;             // in scope 3 at $DIR/checked.rs:+5:9: +5:10\n+                  scope 4 {\n+                      debug d => _7;       // in scope 4 at $DIR/checked.rs:+5:9: +5:10\n+                      let _8: i32;         // in scope 4 at $DIR/checked.rs:+6:9: +6:10\n+                      scope 5 {\n+                          debug e => _8;   // in scope 5 at $DIR/checked.rs:+6:9: +6:10\n+                      }\n+                  }\n+              }\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/checked.rs:+1:9: +1:10\n+          _1 = const 1_i32;                // scope 0 at $DIR/checked.rs:+1:13: +1:14\n+          StorageLive(_2);                 // scope 1 at $DIR/checked.rs:+2:9: +2:10\n+          _2 = const 2_i32;                // scope 1 at $DIR/checked.rs:+2:13: +2:14\n+          StorageLive(_3);                 // scope 2 at $DIR/checked.rs:+3:9: +3:10\n+          StorageLive(_4);                 // scope 2 at $DIR/checked.rs:+3:13: +3:14\n+-         _4 = _1;                         // scope 2 at $DIR/checked.rs:+3:13: +3:14\n++         _4 = const 1_i32;                // scope 2 at $DIR/checked.rs:+3:13: +3:14\n+          StorageLive(_5);                 // scope 2 at $DIR/checked.rs:+3:17: +3:18\n+-         _5 = _2;                         // scope 2 at $DIR/checked.rs:+3:17: +3:18\n+-         _6 = CheckedAdd(_4, _5);         // scope 2 at $DIR/checked.rs:+3:13: +3:18\n+-         assert(!move (_6.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _4, move _5) -> bb1; // scope 2 at $DIR/checked.rs:+3:13: +3:18\n++         _5 = const 2_i32;                // scope 2 at $DIR/checked.rs:+3:17: +3:18\n++         _6 = CheckedAdd(const 1_i32, const 2_i32); // scope 2 at $DIR/checked.rs:+3:13: +3:18\n++         assert(!const false, \"attempt to compute `{} + {}`, which would overflow\", const 1_i32, const 2_i32) -> bb1; // scope 2 at $DIR/checked.rs:+3:13: +3:18\n+      }\n+  \n+      bb1: {\n+-         _3 = move (_6.0: i32);           // scope 2 at $DIR/checked.rs:+3:13: +3:18\n++         _3 = const 3_i32;                // scope 2 at $DIR/checked.rs:+3:13: +3:18\n+          StorageDead(_5);                 // scope 2 at $DIR/checked.rs:+3:17: +3:18\n+          StorageDead(_4);                 // scope 2 at $DIR/checked.rs:+3:17: +3:18\n+          StorageLive(_7);                 // scope 3 at $DIR/checked.rs:+5:9: +5:10\n+          _7 = const _;                    // scope 3 at $DIR/checked.rs:+5:13: +5:21\n+          StorageLive(_8);                 // scope 4 at $DIR/checked.rs:+6:9: +6:10\n+          StorageLive(_9);                 // scope 4 at $DIR/checked.rs:+6:13: +6:14\n+-         _9 = _7;                         // scope 4 at $DIR/checked.rs:+6:13: +6:14\n+-         _10 = CheckedAdd(_9, const 1_i32); // scope 4 at $DIR/checked.rs:+6:13: +6:18\n+-         assert(!move (_10.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _9, const 1_i32) -> bb2; // scope 4 at $DIR/checked.rs:+6:13: +6:18\n++         _9 = const i32::MAX;             // scope 4 at $DIR/checked.rs:+6:13: +6:14\n++         _10 = CheckedAdd(const i32::MAX, const 1_i32); // scope 4 at $DIR/checked.rs:+6:13: +6:18\n++         assert(!move (_10.1: bool), \"attempt to compute `{} + {}`, which would overflow\", const i32::MAX, const 1_i32) -> bb2; // scope 4 at $DIR/checked.rs:+6:13: +6:18\n+      }\n+  \n+      bb2: {\n+-         _8 = move (_10.0: i32);          // scope 4 at $DIR/checked.rs:+6:13: +6:18\n++         _8 = const i32::MIN;             // scope 4 at $DIR/checked.rs:+6:13: +6:18\n+          StorageDead(_9);                 // scope 4 at $DIR/checked.rs:+6:17: +6:18\n+          _0 = const ();                   // scope 0 at $DIR/checked.rs:+0:11: +7:2\n+          StorageDead(_8);                 // scope 4 at $DIR/checked.rs:+7:1: +7:2\n+          StorageDead(_7);                 // scope 3 at $DIR/checked.rs:+7:1: +7:2\n+          StorageDead(_3);                 // scope 2 at $DIR/checked.rs:+7:1: +7:2\n+          StorageDead(_2);                 // scope 1 at $DIR/checked.rs:+7:1: +7:2\n+          StorageDead(_1);                 // scope 0 at $DIR/checked.rs:+7:1: +7:2\n+          return;                          // scope 0 at $DIR/checked.rs:+7:2: +7:2\n+      }\n+  }\n+  "}, {"sha": "0738a4ee53b8649615ff8ad424b8bea56ae83810", "filename": "src/test/mir-opt/dataflow-const-prop/checked.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fchecked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fchecked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fchecked.rs?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -0,0 +1,13 @@\n+// unit-test: DataflowConstProp\n+// compile-flags: -Coverflow-checks=on\n+\n+// EMIT_MIR checked.main.DataflowConstProp.diff\n+#[allow(arithmetic_overflow)]\n+fn main() {\n+    let a = 1;\n+    let b = 2;\n+    let c = a + b;\n+\n+    let d = i32::MAX;\n+    let e = d + 1;\n+}"}, {"sha": "2ced794e628f0462813e4f0065136af076984464", "filename": "src/test/mir-opt/dataflow-const-prop/enum.main.DataflowConstProp.diff", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fenum.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fenum.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fenum.main.DataflowConstProp.diff?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -0,0 +1,61 @@\n+- // MIR for `main` before DataflowConstProp\n++ // MIR for `main` after DataflowConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/enum.rs:+0:11: +0:11\n+      let _1: E;                           // in scope 0 at $DIR/enum.rs:+1:9: +1:10\n+      let mut _3: isize;                   // in scope 0 at $DIR/enum.rs:+2:23: +2:31\n+      scope 1 {\n+          debug e => _1;                   // in scope 1 at $DIR/enum.rs:+1:9: +1:10\n+          let _2: i32;                     // in scope 1 at $DIR/enum.rs:+2:9: +2:10\n+          let _4: i32;                     // in scope 1 at $DIR/enum.rs:+2:29: +2:30\n+          let _5: i32;                     // in scope 1 at $DIR/enum.rs:+2:44: +2:45\n+          scope 2 {\n+              debug x => _2;               // in scope 2 at $DIR/enum.rs:+2:9: +2:10\n+          }\n+          scope 3 {\n+              debug x => _4;               // in scope 3 at $DIR/enum.rs:+2:29: +2:30\n+          }\n+          scope 4 {\n+              debug x => _5;               // in scope 4 at $DIR/enum.rs:+2:44: +2:45\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/enum.rs:+1:9: +1:10\n+          Deinit(_1);                      // scope 0 at $DIR/enum.rs:+1:13: +1:21\n+          ((_1 as V1).0: i32) = const 0_i32; // scope 0 at $DIR/enum.rs:+1:13: +1:21\n+          discriminant(_1) = 0;            // scope 0 at $DIR/enum.rs:+1:13: +1:21\n+          StorageLive(_2);                 // scope 1 at $DIR/enum.rs:+2:9: +2:10\n+          _3 = discriminant(_1);           // scope 1 at $DIR/enum.rs:+2:19: +2:20\n+          switchInt(move _3) -> [0_isize: bb3, 1_isize: bb1, otherwise: bb2]; // scope 1 at $DIR/enum.rs:+2:13: +2:20\n+      }\n+  \n+      bb1: {\n+          StorageLive(_5);                 // scope 1 at $DIR/enum.rs:+2:44: +2:45\n+          _5 = ((_1 as V2).0: i32);        // scope 1 at $DIR/enum.rs:+2:44: +2:45\n+          _2 = _5;                         // scope 4 at $DIR/enum.rs:+2:50: +2:51\n+          StorageDead(_5);                 // scope 1 at $DIR/enum.rs:+2:50: +2:51\n+          goto -> bb4;                     // scope 1 at $DIR/enum.rs:+2:50: +2:51\n+      }\n+  \n+      bb2: {\n+          unreachable;                     // scope 1 at $DIR/enum.rs:+2:19: +2:20\n+      }\n+  \n+      bb3: {\n+          StorageLive(_4);                 // scope 1 at $DIR/enum.rs:+2:29: +2:30\n+          _4 = ((_1 as V1).0: i32);        // scope 1 at $DIR/enum.rs:+2:29: +2:30\n+          _2 = _4;                         // scope 3 at $DIR/enum.rs:+2:35: +2:36\n+          StorageDead(_4);                 // scope 1 at $DIR/enum.rs:+2:35: +2:36\n+          goto -> bb4;                     // scope 1 at $DIR/enum.rs:+2:35: +2:36\n+      }\n+  \n+      bb4: {\n+          _0 = const ();                   // scope 0 at $DIR/enum.rs:+0:11: +3:2\n+          StorageDead(_2);                 // scope 1 at $DIR/enum.rs:+3:1: +3:2\n+          StorageDead(_1);                 // scope 0 at $DIR/enum.rs:+3:1: +3:2\n+          return;                          // scope 0 at $DIR/enum.rs:+3:2: +3:2\n+      }\n+  }\n+  "}, {"sha": "13288577dea3f4d6bcbddde2d40174fb478537b7", "filename": "src/test/mir-opt/dataflow-const-prop/enum.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fenum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fenum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fenum.rs?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -0,0 +1,13 @@\n+// unit-test: DataflowConstProp\n+\n+// Not trackable, because variants could be aliased.\n+enum E {\n+    V1(i32),\n+    V2(i32)\n+}\n+\n+// EMIT_MIR enum.main.DataflowConstProp.diff\n+fn main() {\n+    let e = E::V1(0);\n+    let x = match e { E::V1(x) => x, E::V2(x) => x };\n+}"}, {"sha": "26808c70fbf2c42a711020001ff4790f24320c1e", "filename": "src/test/mir-opt/dataflow-const-prop/if.main.DataflowConstProp.diff", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fif.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fif.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fif.main.DataflowConstProp.diff?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -0,0 +1,112 @@\n+- // MIR for `main` before DataflowConstProp\n++ // MIR for `main` after DataflowConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/if.rs:+0:11: +0:11\n+      let _1: i32;                         // in scope 0 at $DIR/if.rs:+1:9: +1:10\n+      let mut _3: bool;                    // in scope 0 at $DIR/if.rs:+2:16: +2:22\n+      let mut _4: i32;                     // in scope 0 at $DIR/if.rs:+2:16: +2:17\n+      let mut _6: i32;                     // in scope 0 at $DIR/if.rs:+3:13: +3:14\n+      let mut _8: bool;                    // in scope 0 at $DIR/if.rs:+5:16: +5:22\n+      let mut _9: i32;                     // in scope 0 at $DIR/if.rs:+5:16: +5:17\n+      let mut _10: i32;                    // in scope 0 at $DIR/if.rs:+5:36: +5:37\n+      let mut _12: i32;                    // in scope 0 at $DIR/if.rs:+6:13: +6:14\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/if.rs:+1:9: +1:10\n+          let _2: i32;                     // in scope 1 at $DIR/if.rs:+2:9: +2:10\n+          scope 2 {\n+              debug b => _2;               // in scope 2 at $DIR/if.rs:+2:9: +2:10\n+              let _5: i32;                 // in scope 2 at $DIR/if.rs:+3:9: +3:10\n+              scope 3 {\n+                  debug c => _5;           // in scope 3 at $DIR/if.rs:+3:9: +3:10\n+                  let _7: i32;             // in scope 3 at $DIR/if.rs:+5:9: +5:10\n+                  scope 4 {\n+                      debug d => _7;       // in scope 4 at $DIR/if.rs:+5:9: +5:10\n+                      let _11: i32;        // in scope 4 at $DIR/if.rs:+6:9: +6:10\n+                      scope 5 {\n+                          debug e => _11;  // in scope 5 at $DIR/if.rs:+6:9: +6:10\n+                      }\n+                  }\n+              }\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/if.rs:+1:9: +1:10\n+          _1 = const 1_i32;                // scope 0 at $DIR/if.rs:+1:13: +1:14\n+          StorageLive(_2);                 // scope 1 at $DIR/if.rs:+2:9: +2:10\n+          StorageLive(_3);                 // scope 1 at $DIR/if.rs:+2:16: +2:22\n+          StorageLive(_4);                 // scope 1 at $DIR/if.rs:+2:16: +2:17\n+-         _4 = _1;                         // scope 1 at $DIR/if.rs:+2:16: +2:17\n+-         _3 = Eq(move _4, const 1_i32);   // scope 1 at $DIR/if.rs:+2:16: +2:22\n++         _4 = const 1_i32;                // scope 1 at $DIR/if.rs:+2:16: +2:17\n++         _3 = const true;                 // scope 1 at $DIR/if.rs:+2:16: +2:22\n+          StorageDead(_4);                 // scope 1 at $DIR/if.rs:+2:21: +2:22\n+-         switchInt(move _3) -> [false: bb2, otherwise: bb1]; // scope 1 at $DIR/if.rs:+2:16: +2:22\n++         switchInt(const true) -> [false: bb2, otherwise: bb1]; // scope 1 at $DIR/if.rs:+2:16: +2:22\n+      }\n+  \n+      bb1: {\n+          _2 = const 2_i32;                // scope 1 at $DIR/if.rs:+2:25: +2:26\n+          goto -> bb3;                     // scope 1 at $DIR/if.rs:+2:13: +2:39\n+      }\n+  \n+      bb2: {\n+          _2 = const 3_i32;                // scope 1 at $DIR/if.rs:+2:36: +2:37\n+          goto -> bb3;                     // scope 1 at $DIR/if.rs:+2:13: +2:39\n+      }\n+  \n+      bb3: {\n+          StorageDead(_3);                 // scope 1 at $DIR/if.rs:+2:38: +2:39\n+          StorageLive(_5);                 // scope 2 at $DIR/if.rs:+3:9: +3:10\n+          StorageLive(_6);                 // scope 2 at $DIR/if.rs:+3:13: +3:14\n+-         _6 = _2;                         // scope 2 at $DIR/if.rs:+3:13: +3:14\n+-         _5 = Add(move _6, const 1_i32);  // scope 2 at $DIR/if.rs:+3:13: +3:18\n++         _6 = const 2_i32;                // scope 2 at $DIR/if.rs:+3:13: +3:14\n++         _5 = const 3_i32;                // scope 2 at $DIR/if.rs:+3:13: +3:18\n+          StorageDead(_6);                 // scope 2 at $DIR/if.rs:+3:17: +3:18\n+          StorageLive(_7);                 // scope 3 at $DIR/if.rs:+5:9: +5:10\n+          StorageLive(_8);                 // scope 3 at $DIR/if.rs:+5:16: +5:22\n+          StorageLive(_9);                 // scope 3 at $DIR/if.rs:+5:16: +5:17\n+-         _9 = _1;                         // scope 3 at $DIR/if.rs:+5:16: +5:17\n+-         _8 = Eq(move _9, const 1_i32);   // scope 3 at $DIR/if.rs:+5:16: +5:22\n++         _9 = const 1_i32;                // scope 3 at $DIR/if.rs:+5:16: +5:17\n++         _8 = const true;                 // scope 3 at $DIR/if.rs:+5:16: +5:22\n+          StorageDead(_9);                 // scope 3 at $DIR/if.rs:+5:21: +5:22\n+-         switchInt(move _8) -> [false: bb5, otherwise: bb4]; // scope 3 at $DIR/if.rs:+5:16: +5:22\n++         switchInt(const true) -> [false: bb5, otherwise: bb4]; // scope 3 at $DIR/if.rs:+5:16: +5:22\n+      }\n+  \n+      bb4: {\n+-         _7 = _1;                         // scope 3 at $DIR/if.rs:+5:25: +5:26\n++         _7 = const 1_i32;                // scope 3 at $DIR/if.rs:+5:25: +5:26\n+          goto -> bb6;                     // scope 3 at $DIR/if.rs:+5:13: +5:43\n+      }\n+  \n+      bb5: {\n+          StorageLive(_10);                // scope 3 at $DIR/if.rs:+5:36: +5:37\n+          _10 = _1;                        // scope 3 at $DIR/if.rs:+5:36: +5:37\n+          _7 = Add(move _10, const 1_i32); // scope 3 at $DIR/if.rs:+5:36: +5:41\n+          StorageDead(_10);                // scope 3 at $DIR/if.rs:+5:40: +5:41\n+          goto -> bb6;                     // scope 3 at $DIR/if.rs:+5:13: +5:43\n+      }\n+  \n+      bb6: {\n+          StorageDead(_8);                 // scope 3 at $DIR/if.rs:+5:42: +5:43\n+          StorageLive(_11);                // scope 4 at $DIR/if.rs:+6:9: +6:10\n+          StorageLive(_12);                // scope 4 at $DIR/if.rs:+6:13: +6:14\n+-         _12 = _7;                        // scope 4 at $DIR/if.rs:+6:13: +6:14\n+-         _11 = Add(move _12, const 1_i32); // scope 4 at $DIR/if.rs:+6:13: +6:18\n++         _12 = const 1_i32;               // scope 4 at $DIR/if.rs:+6:13: +6:14\n++         _11 = const 2_i32;               // scope 4 at $DIR/if.rs:+6:13: +6:18\n+          StorageDead(_12);                // scope 4 at $DIR/if.rs:+6:17: +6:18\n+          _0 = const ();                   // scope 0 at $DIR/if.rs:+0:11: +7:2\n+          StorageDead(_11);                // scope 4 at $DIR/if.rs:+7:1: +7:2\n+          StorageDead(_7);                 // scope 3 at $DIR/if.rs:+7:1: +7:2\n+          StorageDead(_5);                 // scope 2 at $DIR/if.rs:+7:1: +7:2\n+          StorageDead(_2);                 // scope 1 at $DIR/if.rs:+7:1: +7:2\n+          StorageDead(_1);                 // scope 0 at $DIR/if.rs:+7:1: +7:2\n+          return;                          // scope 0 at $DIR/if.rs:+7:2: +7:2\n+      }\n+  }\n+  "}, {"sha": "34fc35790c17f199cfb86d9c448da9086fae507a", "filename": "src/test/mir-opt/dataflow-const-prop/if.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fif.rs?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -0,0 +1,11 @@\n+// unit-test: DataflowConstProp\n+\n+// EMIT_MIR if.main.DataflowConstProp.diff\n+fn main() {\n+    let a = 1;\n+    let b = if a == 1 { 2 } else { 3 };\n+    let c = b + 1;\n+\n+    let d = if a == 1 { a } else { a + 1 };\n+    let e = d + 1;\n+}"}, {"sha": "bf4557ed3d92c18f586b0a58a34bb73b2b2ced3a", "filename": "src/test/mir-opt/dataflow-const-prop/inherit_overflow.main.DataflowConstProp.diff", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Finherit_overflow.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Finherit_overflow.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Finherit_overflow.main.DataflowConstProp.diff?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -0,0 +1,45 @@\n+- // MIR for `main` before DataflowConstProp\n++ // MIR for `main` after DataflowConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/inherit_overflow.rs:+0:11: +0:11\n+      let mut _1: u8;                      // in scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+      let mut _2: u8;                      // in scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+      let mut _3: u8;                      // in scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+      scope 1 {\n+      }\n+      scope 2 (inlined <u8 as Add>::add) { // at $DIR/inherit_overflow.rs:7:13: 7:47\n+          debug self => _2;                // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          debug other => _3;               // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          let mut _4: u8;                  // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          let mut _5: u8;                  // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          let mut _6: (u8, bool);          // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          StorageLive(_2);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          _2 = const u8::MAX;              // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          StorageLive(_3);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          _3 = const 1_u8;                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          StorageLive(_4);                 // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          _4 = const u8::MAX;              // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          StorageLive(_5);                 // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          _5 = const 1_u8;                 // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          _6 = CheckedAdd(const u8::MAX, const 1_u8); // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          assert(!move (_6.1: bool), \"attempt to compute `{} + {}`, which would overflow\", const u8::MAX, const 1_u8) -> bb1; // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+      }\n+  \n+      bb1: {\n+-         _1 = move (_6.0: u8);            // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n++         _1 = const 0_u8;                 // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          StorageDead(_5);                 // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          StorageDead(_4);                 // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          StorageDead(_3);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          StorageDead(_2);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          StorageDead(_1);                 // scope 0 at $DIR/inherit_overflow.rs:+3:47: +3:48\n+          nop;                             // scope 0 at $DIR/inherit_overflow.rs:+0:11: +4:2\n+          return;                          // scope 0 at $DIR/inherit_overflow.rs:+4:2: +4:2\n+      }\n+  }\n+  "}, {"sha": "2f2d9d0102d1232030ee6c2d66d4489f19ef6090", "filename": "src/test/mir-opt/dataflow-const-prop/inherit_overflow.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Finherit_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Finherit_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Finherit_overflow.rs?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -0,0 +1,8 @@\n+// compile-flags: -Zunsound-mir-opts\n+\n+// EMIT_MIR inherit_overflow.main.DataflowConstProp.diff\n+fn main() {\n+    // After inlining, this will contain a `CheckedBinaryOp`. The overflow\n+    // must be ignored by the constant propagation to avoid triggering a panic.\n+    let _ = <u8 as std::ops::Add>::add(255, 1);\n+}"}, {"sha": "881d80f7c032606fa969eddf7adc8d4db00b2e89", "filename": "src/test/mir-opt/dataflow-const-prop/issue_81605.f.DataflowConstProp.diff", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fissue_81605.f.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fissue_81605.f.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fissue_81605.f.DataflowConstProp.diff?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -0,0 +1,35 @@\n+- // MIR for `f` before DataflowConstProp\n++ // MIR for `f` after DataflowConstProp\n+  \n+  fn f() -> usize {\n+      let mut _0: usize;                   // return place in scope 0 at $DIR/issue_81605.rs:+0:11: +0:16\n+      let mut _1: usize;                   // in scope 0 at $DIR/issue_81605.rs:+1:9: +1:33\n+      let mut _2: bool;                    // in scope 0 at $DIR/issue_81605.rs:+1:12: +1:16\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/issue_81605.rs:+1:9: +1:33\n+          StorageLive(_2);                 // scope 0 at $DIR/issue_81605.rs:+1:12: +1:16\n+          _2 = const true;                 // scope 0 at $DIR/issue_81605.rs:+1:12: +1:16\n+-         switchInt(move _2) -> [false: bb2, otherwise: bb1]; // scope 0 at $DIR/issue_81605.rs:+1:12: +1:16\n++         switchInt(const true) -> [false: bb2, otherwise: bb1]; // scope 0 at $DIR/issue_81605.rs:+1:12: +1:16\n+      }\n+  \n+      bb1: {\n+          _1 = const 1_usize;              // scope 0 at $DIR/issue_81605.rs:+1:19: +1:20\n+          goto -> bb3;                     // scope 0 at $DIR/issue_81605.rs:+1:9: +1:33\n+      }\n+  \n+      bb2: {\n+          _1 = const 2_usize;              // scope 0 at $DIR/issue_81605.rs:+1:30: +1:31\n+          goto -> bb3;                     // scope 0 at $DIR/issue_81605.rs:+1:9: +1:33\n+      }\n+  \n+      bb3: {\n+          StorageDead(_2);                 // scope 0 at $DIR/issue_81605.rs:+1:32: +1:33\n+-         _0 = Add(const 1_usize, move _1); // scope 0 at $DIR/issue_81605.rs:+1:5: +1:33\n++         _0 = const 2_usize;              // scope 0 at $DIR/issue_81605.rs:+1:5: +1:33\n+          StorageDead(_1);                 // scope 0 at $DIR/issue_81605.rs:+1:32: +1:33\n+          return;                          // scope 0 at $DIR/issue_81605.rs:+2:2: +2:2\n+      }\n+  }\n+  "}, {"sha": "d75e2a28bef6b61b26ffac6675431e16079c1dfa", "filename": "src/test/mir-opt/dataflow-const-prop/issue_81605.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fissue_81605.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fissue_81605.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fissue_81605.rs?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -0,0 +1,10 @@\n+// unit-test: DataflowConstProp\n+\n+// EMIT_MIR issue_81605.f.DataflowConstProp.diff\n+fn f() -> usize {\n+    1 + if true { 1 } else { 2 }\n+}\n+\n+fn main() {\n+    f();\n+}"}, {"sha": "158f187f15769fd0db91542b08e52d979ccb1e2e", "filename": "src/test/mir-opt/dataflow-const-prop/ref_without_sb.main.DataflowConstProp.diff", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fref_without_sb.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fref_without_sb.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fref_without_sb.main.DataflowConstProp.diff?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -0,0 +1,55 @@\n+- // MIR for `main` before DataflowConstProp\n++ // MIR for `main` after DataflowConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/ref_without_sb.rs:+0:11: +0:11\n+      let mut _1: i32;                     // in scope 0 at $DIR/ref_without_sb.rs:+1:9: +1:14\n+      let _2: ();                          // in scope 0 at $DIR/ref_without_sb.rs:+2:5: +2:15\n+      let mut _3: &i32;                    // in scope 0 at $DIR/ref_without_sb.rs:+2:12: +2:14\n+      let _4: &i32;                        // in scope 0 at $DIR/ref_without_sb.rs:+2:12: +2:14\n+      let _5: ();                          // in scope 0 at $DIR/ref_without_sb.rs:+4:5: +4:20\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/ref_without_sb.rs:+1:9: +1:14\n+          let _6: i32;                     // in scope 1 at $DIR/ref_without_sb.rs:+6:9: +6:10\n+          scope 2 {\n+              debug b => _6;               // in scope 2 at $DIR/ref_without_sb.rs:+6:9: +6:10\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/ref_without_sb.rs:+1:9: +1:14\n+          _1 = const 0_i32;                // scope 0 at $DIR/ref_without_sb.rs:+1:17: +1:18\n+          StorageLive(_2);                 // scope 1 at $DIR/ref_without_sb.rs:+2:5: +2:15\n+          StorageLive(_3);                 // scope 1 at $DIR/ref_without_sb.rs:+2:12: +2:14\n+          StorageLive(_4);                 // scope 1 at $DIR/ref_without_sb.rs:+2:12: +2:14\n+          _4 = &_1;                        // scope 1 at $DIR/ref_without_sb.rs:+2:12: +2:14\n+          _3 = &(*_4);                     // scope 1 at $DIR/ref_without_sb.rs:+2:12: +2:14\n+          _2 = escape::<i32>(move _3) -> bb1; // scope 1 at $DIR/ref_without_sb.rs:+2:5: +2:15\n+                                           // mir::Constant\n+                                           // + span: $DIR/ref_without_sb.rs:12:5: 12:11\n+                                           // + literal: Const { ty: for<'a> fn(&'a i32) {escape::<i32>}, val: Value(<ZST>) }\n+      }\n+  \n+      bb1: {\n+          StorageDead(_3);                 // scope 1 at $DIR/ref_without_sb.rs:+2:14: +2:15\n+          StorageDead(_4);                 // scope 1 at $DIR/ref_without_sb.rs:+2:15: +2:16\n+          StorageDead(_2);                 // scope 1 at $DIR/ref_without_sb.rs:+2:15: +2:16\n+          _1 = const 1_i32;                // scope 1 at $DIR/ref_without_sb.rs:+3:5: +3:10\n+          StorageLive(_5);                 // scope 1 at $DIR/ref_without_sb.rs:+4:5: +4:20\n+          _5 = some_function() -> bb2;     // scope 1 at $DIR/ref_without_sb.rs:+4:5: +4:20\n+                                           // mir::Constant\n+                                           // + span: $DIR/ref_without_sb.rs:14:5: 14:18\n+                                           // + literal: Const { ty: fn() {some_function}, val: Value(<ZST>) }\n+      }\n+  \n+      bb2: {\n+          StorageDead(_5);                 // scope 1 at $DIR/ref_without_sb.rs:+4:20: +4:21\n+          StorageLive(_6);                 // scope 1 at $DIR/ref_without_sb.rs:+6:9: +6:10\n+          _6 = _1;                         // scope 1 at $DIR/ref_without_sb.rs:+6:13: +6:14\n+          _0 = const ();                   // scope 0 at $DIR/ref_without_sb.rs:+0:11: +7:2\n+          StorageDead(_6);                 // scope 1 at $DIR/ref_without_sb.rs:+7:1: +7:2\n+          StorageDead(_1);                 // scope 0 at $DIR/ref_without_sb.rs:+7:1: +7:2\n+          return;                          // scope 0 at $DIR/ref_without_sb.rs:+7:2: +7:2\n+      }\n+  }\n+  "}, {"sha": "2fd480b0968af0ccf205074979abd093efa7aace", "filename": "src/test/mir-opt/dataflow-const-prop/ref_without_sb.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fref_without_sb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fref_without_sb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fref_without_sb.rs?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -0,0 +1,17 @@\n+// unit-test: DataflowConstProp\n+\n+#[inline(never)]\n+fn escape<T>(x: &T) {}\n+\n+#[inline(never)]\n+fn some_function() {}\n+\n+// EMIT_MIR ref_without_sb.main.DataflowConstProp.diff\n+fn main() {\n+    let mut a = 0;\n+    escape(&a);\n+    a = 1;\n+    some_function();\n+    // This should currently not be propagated.\n+    let b = a;\n+}"}, {"sha": "f66b00a9a224bca8f66558e259633574588b52ec", "filename": "src/test/mir-opt/dataflow-const-prop/repr_transparent.main.DataflowConstProp.diff", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Frepr_transparent.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Frepr_transparent.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Frepr_transparent.main.DataflowConstProp.diff?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -0,0 +1,44 @@\n+- // MIR for `main` before DataflowConstProp\n++ // MIR for `main` after DataflowConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/repr_transparent.rs:+0:11: +0:11\n+      let _1: I32;                         // in scope 0 at $DIR/repr_transparent.rs:+1:9: +1:10\n+      let mut _3: i32;                     // in scope 0 at $DIR/repr_transparent.rs:+2:17: +2:26\n+      let mut _4: i32;                     // in scope 0 at $DIR/repr_transparent.rs:+2:17: +2:20\n+      let mut _5: i32;                     // in scope 0 at $DIR/repr_transparent.rs:+2:23: +2:26\n+      scope 1 {\n+          debug x => _1;                   // in scope 1 at $DIR/repr_transparent.rs:+1:9: +1:10\n+          let _2: I32;                     // in scope 1 at $DIR/repr_transparent.rs:+2:9: +2:10\n+          scope 2 {\n+              debug y => _2;               // in scope 2 at $DIR/repr_transparent.rs:+2:9: +2:10\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/repr_transparent.rs:+1:9: +1:10\n+          Deinit(_1);                      // scope 0 at $DIR/repr_transparent.rs:+1:13: +1:19\n+          (_1.0: i32) = const 0_i32;       // scope 0 at $DIR/repr_transparent.rs:+1:13: +1:19\n+          StorageLive(_2);                 // scope 1 at $DIR/repr_transparent.rs:+2:9: +2:10\n+          StorageLive(_3);                 // scope 1 at $DIR/repr_transparent.rs:+2:17: +2:26\n+          StorageLive(_4);                 // scope 1 at $DIR/repr_transparent.rs:+2:17: +2:20\n+-         _4 = (_1.0: i32);                // scope 1 at $DIR/repr_transparent.rs:+2:17: +2:20\n++         _4 = const 0_i32;                // scope 1 at $DIR/repr_transparent.rs:+2:17: +2:20\n+          StorageLive(_5);                 // scope 1 at $DIR/repr_transparent.rs:+2:23: +2:26\n+-         _5 = (_1.0: i32);                // scope 1 at $DIR/repr_transparent.rs:+2:23: +2:26\n+-         _3 = Add(move _4, move _5);      // scope 1 at $DIR/repr_transparent.rs:+2:17: +2:26\n++         _5 = const 0_i32;                // scope 1 at $DIR/repr_transparent.rs:+2:23: +2:26\n++         _3 = const 0_i32;                // scope 1 at $DIR/repr_transparent.rs:+2:17: +2:26\n+          StorageDead(_5);                 // scope 1 at $DIR/repr_transparent.rs:+2:25: +2:26\n+          StorageDead(_4);                 // scope 1 at $DIR/repr_transparent.rs:+2:25: +2:26\n+          Deinit(_2);                      // scope 1 at $DIR/repr_transparent.rs:+2:13: +2:27\n+-         (_2.0: i32) = move _3;           // scope 1 at $DIR/repr_transparent.rs:+2:13: +2:27\n++         (_2.0: i32) = const 0_i32;       // scope 1 at $DIR/repr_transparent.rs:+2:13: +2:27\n+          StorageDead(_3);                 // scope 1 at $DIR/repr_transparent.rs:+2:26: +2:27\n+          _0 = const ();                   // scope 0 at $DIR/repr_transparent.rs:+0:11: +3:2\n+          StorageDead(_2);                 // scope 1 at $DIR/repr_transparent.rs:+3:1: +3:2\n+          StorageDead(_1);                 // scope 0 at $DIR/repr_transparent.rs:+3:1: +3:2\n+          return;                          // scope 0 at $DIR/repr_transparent.rs:+3:2: +3:2\n+      }\n+  }\n+  "}, {"sha": "4ce0ca4dff46f837042332a1f31c7ca335511a2c", "filename": "src/test/mir-opt/dataflow-const-prop/repr_transparent.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Frepr_transparent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Frepr_transparent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Frepr_transparent.rs?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -0,0 +1,12 @@\n+// unit-test: DataflowConstProp\n+\n+// The struct has scalar ABI, but is not a scalar type.\n+// Make sure that we handle this correctly.\n+#[repr(transparent)]\n+struct I32(i32);\n+\n+// EMIT_MIR repr_transparent.main.DataflowConstProp.diff\n+fn main() {\n+    let x = I32(0);\n+    let y = I32(x.0 + x.0);\n+}"}, {"sha": "df08eff94cb27f8cca0ab7806512a76fc7244c43", "filename": "src/test/mir-opt/dataflow-const-prop/self_assign.main.DataflowConstProp.diff", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fself_assign.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fself_assign.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fself_assign.main.DataflowConstProp.diff?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -0,0 +1,46 @@\n+- // MIR for `main` before DataflowConstProp\n++ // MIR for `main` after DataflowConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/self_assign.rs:+0:11: +0:11\n+      let mut _1: i32;                     // in scope 0 at $DIR/self_assign.rs:+1:9: +1:14\n+      let mut _2: i32;                     // in scope 0 at $DIR/self_assign.rs:+2:9: +2:10\n+      let mut _3: i32;                     // in scope 0 at $DIR/self_assign.rs:+3:9: +3:10\n+      let mut _5: &i32;                    // in scope 0 at $DIR/self_assign.rs:+6:9: +6:10\n+      let mut _6: i32;                     // in scope 0 at $DIR/self_assign.rs:+7:9: +7:11\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/self_assign.rs:+1:9: +1:14\n+          let mut _4: &i32;                // in scope 1 at $DIR/self_assign.rs:+5:9: +5:14\n+          scope 2 {\n+              debug b => _4;               // in scope 2 at $DIR/self_assign.rs:+5:9: +5:14\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/self_assign.rs:+1:9: +1:14\n+          _1 = const 0_i32;                // scope 0 at $DIR/self_assign.rs:+1:17: +1:18\n+          StorageLive(_2);                 // scope 1 at $DIR/self_assign.rs:+2:9: +2:10\n+          _2 = _1;                         // scope 1 at $DIR/self_assign.rs:+2:9: +2:10\n+          _1 = Add(move _2, const 1_i32);  // scope 1 at $DIR/self_assign.rs:+2:5: +2:14\n+          StorageDead(_2);                 // scope 1 at $DIR/self_assign.rs:+2:13: +2:14\n+          StorageLive(_3);                 // scope 1 at $DIR/self_assign.rs:+3:9: +3:10\n+          _3 = _1;                         // scope 1 at $DIR/self_assign.rs:+3:9: +3:10\n+          _1 = move _3;                    // scope 1 at $DIR/self_assign.rs:+3:5: +3:10\n+          StorageDead(_3);                 // scope 1 at $DIR/self_assign.rs:+3:9: +3:10\n+          StorageLive(_4);                 // scope 1 at $DIR/self_assign.rs:+5:9: +5:14\n+          _4 = &_1;                        // scope 1 at $DIR/self_assign.rs:+5:17: +5:19\n+          StorageLive(_5);                 // scope 2 at $DIR/self_assign.rs:+6:9: +6:10\n+          _5 = _4;                         // scope 2 at $DIR/self_assign.rs:+6:9: +6:10\n+          _4 = move _5;                    // scope 2 at $DIR/self_assign.rs:+6:5: +6:10\n+          StorageDead(_5);                 // scope 2 at $DIR/self_assign.rs:+6:9: +6:10\n+          StorageLive(_6);                 // scope 2 at $DIR/self_assign.rs:+7:9: +7:11\n+          _6 = (*_4);                      // scope 2 at $DIR/self_assign.rs:+7:9: +7:11\n+          _1 = move _6;                    // scope 2 at $DIR/self_assign.rs:+7:5: +7:11\n+          StorageDead(_6);                 // scope 2 at $DIR/self_assign.rs:+7:10: +7:11\n+          _0 = const ();                   // scope 0 at $DIR/self_assign.rs:+0:11: +8:2\n+          StorageDead(_4);                 // scope 1 at $DIR/self_assign.rs:+8:1: +8:2\n+          StorageDead(_1);                 // scope 0 at $DIR/self_assign.rs:+8:1: +8:2\n+          return;                          // scope 0 at $DIR/self_assign.rs:+8:2: +8:2\n+      }\n+  }\n+  "}, {"sha": "8de2195f93ba4b3b3e9e94eb30c510b606377873", "filename": "src/test/mir-opt/dataflow-const-prop/self_assign.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fself_assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fself_assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fself_assign.rs?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -0,0 +1,12 @@\n+// unit-test: DataflowConstProp\n+\n+// EMIT_MIR self_assign.main.DataflowConstProp.diff\n+fn main() {\n+    let mut a = 0;\n+    a = a + 1;\n+    a = a;\n+\n+    let mut b = &a;\n+    b = b;\n+    a = *b;\n+}"}, {"sha": "c09e4061ededf488536ce86555cdb4a519818185", "filename": "src/test/mir-opt/dataflow-const-prop/self_assign_add.main.DataflowConstProp.diff", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fself_assign_add.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fself_assign_add.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fself_assign_add.main.DataflowConstProp.diff?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -0,0 +1,23 @@\n+- // MIR for `main` before DataflowConstProp\n++ // MIR for `main` after DataflowConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/self_assign_add.rs:+0:11: +0:11\n+      let mut _1: i32;                     // in scope 0 at $DIR/self_assign_add.rs:+1:9: +1:14\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/self_assign_add.rs:+1:9: +1:14\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/self_assign_add.rs:+1:9: +1:14\n+          _1 = const 0_i32;                // scope 0 at $DIR/self_assign_add.rs:+1:17: +1:18\n+-         _1 = Add(_1, const 1_i32);       // scope 1 at $DIR/self_assign_add.rs:+2:5: +2:11\n+-         _1 = Add(_1, const 1_i32);       // scope 1 at $DIR/self_assign_add.rs:+3:5: +3:11\n++         _1 = const 1_i32;                // scope 1 at $DIR/self_assign_add.rs:+2:5: +2:11\n++         _1 = const 2_i32;                // scope 1 at $DIR/self_assign_add.rs:+3:5: +3:11\n+          _0 = const ();                   // scope 0 at $DIR/self_assign_add.rs:+0:11: +4:2\n+          StorageDead(_1);                 // scope 0 at $DIR/self_assign_add.rs:+4:1: +4:2\n+          return;                          // scope 0 at $DIR/self_assign_add.rs:+4:2: +4:2\n+      }\n+  }\n+  "}, {"sha": "e3282762459a006fae285f5cb7db6daaa5aa7d5f", "filename": "src/test/mir-opt/dataflow-const-prop/self_assign_add.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fself_assign_add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fself_assign_add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fself_assign_add.rs?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -0,0 +1,8 @@\n+// unit-test: DataflowConstProp\n+\n+// EMIT_MIR self_assign_add.main.DataflowConstProp.diff\n+fn main() {\n+    let mut a = 0;\n+    a += 1;\n+    a += 1;\n+}"}, {"sha": "8126d4b8585e6573e8b9e8d684a1e99cfa4406a9", "filename": "src/test/mir-opt/dataflow-const-prop/sibling_ptr.main.DataflowConstProp.diff", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fsibling_ptr.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fsibling_ptr.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fsibling_ptr.main.DataflowConstProp.diff?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -0,0 +1,56 @@\n+- // MIR for `main` before DataflowConstProp\n++ // MIR for `main` after DataflowConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/sibling_ptr.rs:+0:11: +0:11\n+      let mut _1: (u8, u8);                // in scope 0 at $DIR/sibling_ptr.rs:+1:9: +1:14\n+      let _2: ();                          // in scope 0 at $DIR/sibling_ptr.rs:+2:5: +5:6\n+      let mut _4: *mut u8;                 // in scope 0 at $DIR/sibling_ptr.rs:+4:10: +4:18\n+      let mut _5: *mut u8;                 // in scope 0 at $DIR/sibling_ptr.rs:+4:10: +4:11\n+      scope 1 {\n+          debug x => _1;                   // in scope 1 at $DIR/sibling_ptr.rs:+1:9: +1:14\n+          let _6: u8;                      // in scope 1 at $DIR/sibling_ptr.rs:+6:9: +6:11\n+          scope 2 {\n+              let _3: *mut u8;             // in scope 2 at $DIR/sibling_ptr.rs:+3:13: +3:14\n+              scope 3 {\n+                  debug p => _3;           // in scope 3 at $DIR/sibling_ptr.rs:+3:13: +3:14\n+              }\n+          }\n+          scope 4 {\n+              debug x1 => _6;              // in scope 4 at $DIR/sibling_ptr.rs:+6:9: +6:11\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/sibling_ptr.rs:+1:9: +1:14\n+          Deinit(_1);                      // scope 0 at $DIR/sibling_ptr.rs:+1:27: +1:33\n+          (_1.0: u8) = const 0_u8;         // scope 0 at $DIR/sibling_ptr.rs:+1:27: +1:33\n+          (_1.1: u8) = const 0_u8;         // scope 0 at $DIR/sibling_ptr.rs:+1:27: +1:33\n+          StorageLive(_2);                 // scope 1 at $DIR/sibling_ptr.rs:+2:5: +5:6\n+          StorageLive(_3);                 // scope 2 at $DIR/sibling_ptr.rs:+3:13: +3:14\n+          _3 = &raw mut (_1.0: u8);        // scope 2 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+          StorageLive(_4);                 // scope 3 at $DIR/sibling_ptr.rs:+4:10: +4:18\n+          StorageLive(_5);                 // scope 3 at $DIR/sibling_ptr.rs:+4:10: +4:11\n+          _5 = _3;                         // scope 3 at $DIR/sibling_ptr.rs:+4:10: +4:11\n+          _4 = ptr::mut_ptr::<impl *mut u8>::add(move _5, const 1_usize) -> bb1; // scope 3 at $DIR/sibling_ptr.rs:+4:10: +4:18\n+                                           // mir::Constant\n+                                           // + span: $DIR/sibling_ptr.rs:8:12: 8:15\n+                                           // + literal: Const { ty: unsafe fn(*mut u8, usize) -> *mut u8 {ptr::mut_ptr::<impl *mut u8>::add}, val: Value(<ZST>) }\n+      }\n+  \n+      bb1: {\n+          StorageDead(_5);                 // scope 3 at $DIR/sibling_ptr.rs:+4:17: +4:18\n+          (*_4) = const 1_u8;              // scope 3 at $DIR/sibling_ptr.rs:+4:9: +4:22\n+          StorageDead(_4);                 // scope 3 at $DIR/sibling_ptr.rs:+4:22: +4:23\n+          _2 = const ();                   // scope 2 at $DIR/sibling_ptr.rs:+2:5: +5:6\n+          StorageDead(_3);                 // scope 2 at $DIR/sibling_ptr.rs:+5:5: +5:6\n+          StorageDead(_2);                 // scope 1 at $DIR/sibling_ptr.rs:+5:5: +5:6\n+          StorageLive(_6);                 // scope 1 at $DIR/sibling_ptr.rs:+6:9: +6:11\n+          _6 = (_1.1: u8);                 // scope 1 at $DIR/sibling_ptr.rs:+6:14: +6:17\n+          _0 = const ();                   // scope 0 at $DIR/sibling_ptr.rs:+0:11: +7:2\n+          StorageDead(_6);                 // scope 1 at $DIR/sibling_ptr.rs:+7:1: +7:2\n+          StorageDead(_1);                 // scope 0 at $DIR/sibling_ptr.rs:+7:1: +7:2\n+          return;                          // scope 0 at $DIR/sibling_ptr.rs:+7:2: +7:2\n+      }\n+  }\n+  "}, {"sha": "87ef00d18295fe1ca861d419d1f9f2b5004ad43e", "filename": "src/test/mir-opt/dataflow-const-prop/sibling_ptr.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fsibling_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fsibling_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fsibling_ptr.rs?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -0,0 +1,11 @@\n+// unit-test: DataflowConstProp\n+\n+// EMIT_MIR sibling_ptr.main.DataflowConstProp.diff\n+fn main() {\n+    let mut x: (u8, u8) = (0, 0);\n+    unsafe {\n+        let p = std::ptr::addr_of_mut!(x.0);\n+        *p.add(1) = 1;\n+    }\n+    let x1 = x.1;  // should not be propagated\n+}"}, {"sha": "cfb2706c167cdeea9d9fe67d646e91c75eaf2160", "filename": "src/test/mir-opt/dataflow-const-prop/struct.main.DataflowConstProp.diff", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fstruct.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fstruct.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fstruct.main.DataflowConstProp.diff?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -0,0 +1,52 @@\n+- // MIR for `main` before DataflowConstProp\n++ // MIR for `main` after DataflowConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/struct.rs:+0:11: +0:11\n+      let mut _1: S;                       // in scope 0 at $DIR/struct.rs:+1:9: +1:14\n+      let mut _3: i32;                     // in scope 0 at $DIR/struct.rs:+2:13: +2:16\n+      let mut _5: i32;                     // in scope 0 at $DIR/struct.rs:+4:13: +4:14\n+      let mut _6: i32;                     // in scope 0 at $DIR/struct.rs:+4:17: +4:20\n+      scope 1 {\n+          debug s => _1;                   // in scope 1 at $DIR/struct.rs:+1:9: +1:14\n+          let _2: i32;                     // in scope 1 at $DIR/struct.rs:+2:9: +2:10\n+          scope 2 {\n+              debug a => _2;               // in scope 2 at $DIR/struct.rs:+2:9: +2:10\n+              let _4: i32;                 // in scope 2 at $DIR/struct.rs:+4:9: +4:10\n+              scope 3 {\n+                  debug b => _4;           // in scope 3 at $DIR/struct.rs:+4:9: +4:10\n+              }\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/struct.rs:+1:9: +1:14\n+          Deinit(_1);                      // scope 0 at $DIR/struct.rs:+1:17: +1:21\n+          (_1.0: i32) = const 1_i32;       // scope 0 at $DIR/struct.rs:+1:17: +1:21\n+          StorageLive(_2);                 // scope 1 at $DIR/struct.rs:+2:9: +2:10\n+          StorageLive(_3);                 // scope 1 at $DIR/struct.rs:+2:13: +2:16\n+-         _3 = (_1.0: i32);                // scope 1 at $DIR/struct.rs:+2:13: +2:16\n+-         _2 = Add(move _3, const 2_i32);  // scope 1 at $DIR/struct.rs:+2:13: +2:20\n++         _3 = const 1_i32;                // scope 1 at $DIR/struct.rs:+2:13: +2:16\n++         _2 = const 3_i32;                // scope 1 at $DIR/struct.rs:+2:13: +2:20\n+          StorageDead(_3);                 // scope 1 at $DIR/struct.rs:+2:19: +2:20\n+          (_1.0: i32) = const 3_i32;       // scope 2 at $DIR/struct.rs:+3:5: +3:12\n+          StorageLive(_4);                 // scope 2 at $DIR/struct.rs:+4:9: +4:10\n+          StorageLive(_5);                 // scope 2 at $DIR/struct.rs:+4:13: +4:14\n+-         _5 = _2;                         // scope 2 at $DIR/struct.rs:+4:13: +4:14\n++         _5 = const 3_i32;                // scope 2 at $DIR/struct.rs:+4:13: +4:14\n+          StorageLive(_6);                 // scope 2 at $DIR/struct.rs:+4:17: +4:20\n+-         _6 = (_1.0: i32);                // scope 2 at $DIR/struct.rs:+4:17: +4:20\n+-         _4 = Add(move _5, move _6);      // scope 2 at $DIR/struct.rs:+4:13: +4:20\n++         _6 = const 3_i32;                // scope 2 at $DIR/struct.rs:+4:17: +4:20\n++         _4 = const 6_i32;                // scope 2 at $DIR/struct.rs:+4:13: +4:20\n+          StorageDead(_6);                 // scope 2 at $DIR/struct.rs:+4:19: +4:20\n+          StorageDead(_5);                 // scope 2 at $DIR/struct.rs:+4:19: +4:20\n+          _0 = const ();                   // scope 0 at $DIR/struct.rs:+0:11: +5:2\n+          StorageDead(_4);                 // scope 2 at $DIR/struct.rs:+5:1: +5:2\n+          StorageDead(_2);                 // scope 1 at $DIR/struct.rs:+5:1: +5:2\n+          StorageDead(_1);                 // scope 0 at $DIR/struct.rs:+5:1: +5:2\n+          return;                          // scope 0 at $DIR/struct.rs:+5:2: +5:2\n+      }\n+  }\n+  "}, {"sha": "841b279e03eee7b23195ee77ac5d67846376c691", "filename": "src/test/mir-opt/dataflow-const-prop/struct.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fstruct.rs?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -0,0 +1,11 @@\n+// unit-test: DataflowConstProp\n+\n+struct S(i32);\n+\n+// EMIT_MIR struct.main.DataflowConstProp.diff\n+fn main() {\n+    let mut s = S(1);\n+    let a = s.0 + 2;\n+    s.0 = 3;\n+    let b = a + s.0;\n+}"}, {"sha": "8018400e798a7e8c9fb391122a10d56f2d29c0da", "filename": "src/test/mir-opt/dataflow-const-prop/terminator.main.DataflowConstProp.diff", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fterminator.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fterminator.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fterminator.main.DataflowConstProp.diff?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -0,0 +1,40 @@\n+- // MIR for `main` before DataflowConstProp\n++ // MIR for `main` after DataflowConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/terminator.rs:+0:11: +0:11\n+      let _1: i32;                         // in scope 0 at $DIR/terminator.rs:+1:9: +1:10\n+      let _2: ();                          // in scope 0 at $DIR/terminator.rs:+3:5: +3:15\n+      let mut _3: i32;                     // in scope 0 at $DIR/terminator.rs:+3:9: +3:14\n+      let mut _4: i32;                     // in scope 0 at $DIR/terminator.rs:+3:9: +3:10\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/terminator.rs:+1:9: +1:10\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/terminator.rs:+1:9: +1:10\n+          _1 = const 1_i32;                // scope 0 at $DIR/terminator.rs:+1:13: +1:14\n+          StorageLive(_2);                 // scope 1 at $DIR/terminator.rs:+3:5: +3:15\n+          StorageLive(_3);                 // scope 1 at $DIR/terminator.rs:+3:9: +3:14\n+          StorageLive(_4);                 // scope 1 at $DIR/terminator.rs:+3:9: +3:10\n+-         _4 = _1;                         // scope 1 at $DIR/terminator.rs:+3:9: +3:10\n+-         _3 = Add(move _4, const 1_i32);  // scope 1 at $DIR/terminator.rs:+3:9: +3:14\n++         _4 = const 1_i32;                // scope 1 at $DIR/terminator.rs:+3:9: +3:10\n++         _3 = const 2_i32;                // scope 1 at $DIR/terminator.rs:+3:9: +3:14\n+          StorageDead(_4);                 // scope 1 at $DIR/terminator.rs:+3:13: +3:14\n+-         _2 = foo(move _3) -> bb1;        // scope 1 at $DIR/terminator.rs:+3:5: +3:15\n++         _2 = foo(const 2_i32) -> bb1;    // scope 1 at $DIR/terminator.rs:+3:5: +3:15\n+                                           // mir::Constant\n+                                           // + span: $DIR/terminator.rs:9:5: 9:8\n+                                           // + literal: Const { ty: fn(i32) {foo}, val: Value(<ZST>) }\n+      }\n+  \n+      bb1: {\n+          StorageDead(_3);                 // scope 1 at $DIR/terminator.rs:+3:14: +3:15\n+          StorageDead(_2);                 // scope 1 at $DIR/terminator.rs:+3:15: +3:16\n+          _0 = const ();                   // scope 0 at $DIR/terminator.rs:+0:11: +4:2\n+          StorageDead(_1);                 // scope 0 at $DIR/terminator.rs:+4:1: +4:2\n+          return;                          // scope 0 at $DIR/terminator.rs:+4:2: +4:2\n+      }\n+  }\n+  "}, {"sha": "d151f666a2dc2cb65aafac447c1ba5ba5b5a2ef8", "filename": "src/test/mir-opt/dataflow-const-prop/terminator.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fterminator.rs?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -0,0 +1,10 @@\n+// unit-test: DataflowConstProp\n+\n+fn foo(n: i32) {}\n+\n+// EMIT_MIR terminator.main.DataflowConstProp.diff\n+fn main() {\n+    let a = 1;\n+    // Checks that we propagate into terminators.\n+    foo(a + 1);\n+}"}, {"sha": "e028def00a116da1c3ab5b6be5830555bb299ee7", "filename": "src/test/mir-opt/dataflow-const-prop/tuple.main.DataflowConstProp.diff", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Ftuple.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Ftuple.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Ftuple.main.DataflowConstProp.diff?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -0,0 +1,75 @@\n+- // MIR for `main` before DataflowConstProp\n++ // MIR for `main` after DataflowConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/tuple.rs:+0:11: +0:11\n+      let mut _1: (i32, i32);              // in scope 0 at $DIR/tuple.rs:+1:9: +1:14\n+      let mut _3: i32;                     // in scope 0 at $DIR/tuple.rs:+2:13: +2:22\n+      let mut _4: i32;                     // in scope 0 at $DIR/tuple.rs:+2:13: +2:16\n+      let mut _5: i32;                     // in scope 0 at $DIR/tuple.rs:+2:19: +2:22\n+      let mut _7: i32;                     // in scope 0 at $DIR/tuple.rs:+4:13: +4:22\n+      let mut _8: i32;                     // in scope 0 at $DIR/tuple.rs:+4:13: +4:16\n+      let mut _9: i32;                     // in scope 0 at $DIR/tuple.rs:+4:19: +4:22\n+      let mut _10: i32;                    // in scope 0 at $DIR/tuple.rs:+4:25: +4:26\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/tuple.rs:+1:9: +1:14\n+          let _2: i32;                     // in scope 1 at $DIR/tuple.rs:+2:9: +2:10\n+          scope 2 {\n+              debug b => _2;               // in scope 2 at $DIR/tuple.rs:+2:9: +2:10\n+              let _6: i32;                 // in scope 2 at $DIR/tuple.rs:+4:9: +4:10\n+              scope 3 {\n+                  debug c => _6;           // in scope 3 at $DIR/tuple.rs:+4:9: +4:10\n+              }\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/tuple.rs:+1:9: +1:14\n+          Deinit(_1);                      // scope 0 at $DIR/tuple.rs:+1:17: +1:23\n+          (_1.0: i32) = const 1_i32;       // scope 0 at $DIR/tuple.rs:+1:17: +1:23\n+          (_1.1: i32) = const 2_i32;       // scope 0 at $DIR/tuple.rs:+1:17: +1:23\n+          StorageLive(_2);                 // scope 1 at $DIR/tuple.rs:+2:9: +2:10\n+          StorageLive(_3);                 // scope 1 at $DIR/tuple.rs:+2:13: +2:22\n+          StorageLive(_4);                 // scope 1 at $DIR/tuple.rs:+2:13: +2:16\n+-         _4 = (_1.0: i32);                // scope 1 at $DIR/tuple.rs:+2:13: +2:16\n++         _4 = const 1_i32;                // scope 1 at $DIR/tuple.rs:+2:13: +2:16\n+          StorageLive(_5);                 // scope 1 at $DIR/tuple.rs:+2:19: +2:22\n+-         _5 = (_1.1: i32);                // scope 1 at $DIR/tuple.rs:+2:19: +2:22\n+-         _3 = Add(move _4, move _5);      // scope 1 at $DIR/tuple.rs:+2:13: +2:22\n++         _5 = const 2_i32;                // scope 1 at $DIR/tuple.rs:+2:19: +2:22\n++         _3 = const 3_i32;                // scope 1 at $DIR/tuple.rs:+2:13: +2:22\n+          StorageDead(_5);                 // scope 1 at $DIR/tuple.rs:+2:21: +2:22\n+          StorageDead(_4);                 // scope 1 at $DIR/tuple.rs:+2:21: +2:22\n+-         _2 = Add(move _3, const 3_i32);  // scope 1 at $DIR/tuple.rs:+2:13: +2:26\n++         _2 = const 6_i32;                // scope 1 at $DIR/tuple.rs:+2:13: +2:26\n+          StorageDead(_3);                 // scope 1 at $DIR/tuple.rs:+2:25: +2:26\n+          Deinit(_1);                      // scope 2 at $DIR/tuple.rs:+3:5: +3:15\n+          (_1.0: i32) = const 2_i32;       // scope 2 at $DIR/tuple.rs:+3:5: +3:15\n+          (_1.1: i32) = const 3_i32;       // scope 2 at $DIR/tuple.rs:+3:5: +3:15\n+          StorageLive(_6);                 // scope 2 at $DIR/tuple.rs:+4:9: +4:10\n+          StorageLive(_7);                 // scope 2 at $DIR/tuple.rs:+4:13: +4:22\n+          StorageLive(_8);                 // scope 2 at $DIR/tuple.rs:+4:13: +4:16\n+-         _8 = (_1.0: i32);                // scope 2 at $DIR/tuple.rs:+4:13: +4:16\n++         _8 = const 2_i32;                // scope 2 at $DIR/tuple.rs:+4:13: +4:16\n+          StorageLive(_9);                 // scope 2 at $DIR/tuple.rs:+4:19: +4:22\n+-         _9 = (_1.1: i32);                // scope 2 at $DIR/tuple.rs:+4:19: +4:22\n+-         _7 = Add(move _8, move _9);      // scope 2 at $DIR/tuple.rs:+4:13: +4:22\n++         _9 = const 3_i32;                // scope 2 at $DIR/tuple.rs:+4:19: +4:22\n++         _7 = const 5_i32;                // scope 2 at $DIR/tuple.rs:+4:13: +4:22\n+          StorageDead(_9);                 // scope 2 at $DIR/tuple.rs:+4:21: +4:22\n+          StorageDead(_8);                 // scope 2 at $DIR/tuple.rs:+4:21: +4:22\n+          StorageLive(_10);                // scope 2 at $DIR/tuple.rs:+4:25: +4:26\n+-         _10 = _2;                        // scope 2 at $DIR/tuple.rs:+4:25: +4:26\n+-         _6 = Add(move _7, move _10);     // scope 2 at $DIR/tuple.rs:+4:13: +4:26\n++         _10 = const 6_i32;               // scope 2 at $DIR/tuple.rs:+4:25: +4:26\n++         _6 = const 11_i32;               // scope 2 at $DIR/tuple.rs:+4:13: +4:26\n+          StorageDead(_10);                // scope 2 at $DIR/tuple.rs:+4:25: +4:26\n+          StorageDead(_7);                 // scope 2 at $DIR/tuple.rs:+4:25: +4:26\n+          _0 = const ();                   // scope 0 at $DIR/tuple.rs:+0:11: +5:2\n+          StorageDead(_6);                 // scope 2 at $DIR/tuple.rs:+5:1: +5:2\n+          StorageDead(_2);                 // scope 1 at $DIR/tuple.rs:+5:1: +5:2\n+          StorageDead(_1);                 // scope 0 at $DIR/tuple.rs:+5:1: +5:2\n+          return;                          // scope 0 at $DIR/tuple.rs:+5:2: +5:2\n+      }\n+  }\n+  "}, {"sha": "92c70eab0ff6f67d7b4af693a6068e67384f4090", "filename": "src/test/mir-opt/dataflow-const-prop/tuple.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Ftuple.rs?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -0,0 +1,9 @@\n+// unit-test: DataflowConstProp\n+\n+// EMIT_MIR tuple.main.DataflowConstProp.diff\n+fn main() {\n+    let mut a = (1, 2);\n+    let b = a.0 + a.1 + 3;\n+    a = (2, 3);\n+    let c = a.0 + a.1 + b;\n+}"}, {"sha": "bce40f277d23b9d65c2be7f954ac8ea3aabd64d5", "filename": "src/test/mir-opt/issue_101973.inner.ConstProp.diff", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -37,7 +37,6 @@\n           StorageLive(_4);                 // scope 0 at $DIR/issue_101973.rs:+1:5: +1:17\n           StorageLive(_5);                 // scope 0 at $DIR/issue_101973.rs:+1:10: +1:16\n           _5 = _1;                         // scope 0 at $DIR/issue_101973.rs:+1:10: +1:16\n-          _4 = const 0_u32;                // scope 1 at $DIR/issue_101973.rs:6:19: 6:23\n           StorageLive(_12);                // scope 2 at $DIR/issue_101973.rs:7:12: 7:27\n           StorageLive(_13);                // scope 2 at $DIR/issue_101973.rs:7:12: 7:20\n           StorageLive(_14);                // scope 2 at $DIR/issue_101973.rs:7:13: 7:14\n@@ -73,7 +72,7 @@\n           StorageDead(_14);                // scope 2 at $DIR/issue_101973.rs:7:19: 7:20\n           _12 = BitAnd(move _13, const 255_u32); // scope 2 at $DIR/issue_101973.rs:7:12: 7:27\n           StorageDead(_13);                // scope 2 at $DIR/issue_101973.rs:7:26: 7:27\n-          _4 = BitOr(_4, move _12);        // scope 2 at $DIR/issue_101973.rs:7:5: 7:27\n+          _4 = BitOr(const 0_u32, move _12); // scope 2 at $DIR/issue_101973.rs:7:5: 7:27\n           StorageDead(_12);                // scope 2 at $DIR/issue_101973.rs:7:26: 7:27\n           StorageDead(_5);                 // scope 0 at $DIR/issue_101973.rs:+1:16: +1:17\n           StorageLive(_6);                 // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57"}, {"sha": "f6d8bdd742289413d7c58bfae64547d8974f7982", "filename": "src/test/mir-opt/lower_intrinsics_e2e.f_u64.PreCodegen.after.mir", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Flower_intrinsics_e2e.f_u64.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fmir-opt%2Flower_intrinsics_e2e.f_u64.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Flower_intrinsics_e2e.f_u64.PreCodegen.after.mir?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -6,25 +6,20 @@ fn f_u64() -> () {\n     scope 1 (inlined f_dispatch::<u64>) { // at $DIR/lower_intrinsics_e2e.rs:15:5: 15:21\n         debug t => _1;                   // in scope 1 at $DIR/lower_intrinsics_e2e.rs:19:22: 19:23\n         let _2: ();                      // in scope 1 at $DIR/lower_intrinsics_e2e.rs:23:9: 23:21\n-        let mut _3: u64;                 // in scope 1 at $DIR/lower_intrinsics_e2e.rs:23:19: 23:20\n         scope 2 (inlined std::mem::size_of::<u64>) { // at $DIR/lower_intrinsics_e2e.rs:20:8: 20:32\n         }\n     }\n \n     bb0: {\n         StorageLive(_1);                 // scope 0 at $DIR/lower_intrinsics_e2e.rs:+1:5: +1:21\n-        _1 = const 0_u64;                // scope 0 at $DIR/lower_intrinsics_e2e.rs:+1:5: +1:21\n         StorageLive(_2);                 // scope 1 at $DIR/lower_intrinsics_e2e.rs:23:9: 23:21\n-        StorageLive(_3);                 // scope 1 at $DIR/lower_intrinsics_e2e.rs:23:19: 23:20\n-        _3 = move _1;                    // scope 1 at $DIR/lower_intrinsics_e2e.rs:23:19: 23:20\n-        _2 = f_non_zst::<u64>(move _3) -> bb1; // scope 1 at $DIR/lower_intrinsics_e2e.rs:23:9: 23:21\n+        _2 = f_non_zst::<u64>(const 0_u64) -> bb1; // scope 1 at $DIR/lower_intrinsics_e2e.rs:23:9: 23:21\n                                          // mir::Constant\n                                          // + span: $DIR/lower_intrinsics_e2e.rs:23:9: 23:18\n                                          // + literal: Const { ty: fn(u64) {f_non_zst::<u64>}, val: Value(<ZST>) }\n     }\n \n     bb1: {\n-        StorageDead(_3);                 // scope 1 at $DIR/lower_intrinsics_e2e.rs:23:20: 23:21\n         StorageDead(_2);                 // scope 1 at $DIR/lower_intrinsics_e2e.rs:23:21: 23:22\n         StorageDead(_1);                 // scope 0 at $DIR/lower_intrinsics_e2e.rs:+1:5: +1:21\n         return;                          // scope 0 at $DIR/lower_intrinsics_e2e.rs:+2:2: +2:2"}, {"sha": "9c6108292b5278ac950b29f64f3bc4b29ad74374", "filename": "src/test/ui/consts/const-eval/issue-50814.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-50814.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-50814.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-50814.rs?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -9,16 +9,16 @@ impl Unsigned for U8 {\n     const MAX: u8 = 0xff;\n }\n \n-struct Sum<A,B>(A,B);\n+struct Sum<A, B>(A, B);\n \n-impl<A: Unsigned, B: Unsigned> Unsigned for Sum<A,B> {\n+impl<A: Unsigned, B: Unsigned> Unsigned for Sum<A, B> {\n     const MAX: u8 = A::MAX + B::MAX;\n     //~^ ERROR evaluation of `<Sum<U8, U8> as Unsigned>::MAX` failed\n }\n \n fn foo<T>(_: T) -> &'static u8 {\n-    &Sum::<U8,U8>::MAX\n-    //~^ ERROR E0080\n+    &Sum::<U8, U8>::MAX\n+    //~^ ERROR evaluation of `foo::<i32>` failed [E0080]\n }\n \n fn main() {"}, {"sha": "38e9dc36ee98f0e58700c97c4e7ca32acb12898f", "filename": "src/test/ui/consts/const-eval/issue-50814.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-50814.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/357f66072959f494d5fa2e6a269c6100eed703c1/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-50814.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-50814.stderr?ref=357f66072959f494d5fa2e6a269c6100eed703c1", "patch": "@@ -7,8 +7,8 @@ LL |     const MAX: u8 = A::MAX + B::MAX;\n error[E0080]: evaluation of `foo::<i32>` failed\n   --> $DIR/issue-50814.rs:20:6\n    |\n-LL |     &Sum::<U8,U8>::MAX\n-   |      ^^^^^^^^^^^^^^^^^ referenced constant has errors\n+LL |     &Sum::<U8, U8>::MAX\n+   |      ^^^^^^^^^^^^^^^^^^ referenced constant has errors\n \n note: the above error was encountered while instantiating `fn foo::<i32>`\n   --> $DIR/issue-50814.rs:25:5"}]}