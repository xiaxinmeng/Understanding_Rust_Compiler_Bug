{"sha": "a6e09a19fc20cdf9043e1b856d15170ac0f96511", "node_id": "C_kwDOAAsO6NoAKGE2ZTA5YTE5ZmMyMGNkZjkwNDNlMWI4NTZkMTUxNzBhYzBmOTY1MTE", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-11-21T00:48:25Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-11-21T03:07:39Z"}, "message": "Streamline deriving on packed structs.\n\nThe current approach to field accesses in derived code:\n- Normal case: `&self.0`\n- In a packed struct that derives `Copy`: `&{self.0}`\n- In a packed struct that doesn't derive `Copy`: `let Self(ref x) = *self`\n\nThe `let` pattern used in the third case is equivalent to the simpler\nfield access in the first case. This commit changes the third case to\nuse a field access.\n\nThe commit also combines two boolean arguments (`is_packed` and\n`always_copy`) into a single field (`copy_fields`) earlier, to save\npassing both around.", "tree": {"sha": "14e738619da822f4b4958d4fa3ba88b406d01cdb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14e738619da822f4b4958d4fa3ba88b406d01cdb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6e09a19fc20cdf9043e1b856d15170ac0f96511", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6e09a19fc20cdf9043e1b856d15170ac0f96511", "html_url": "https://github.com/rust-lang/rust/commit/a6e09a19fc20cdf9043e1b856d15170ac0f96511", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6e09a19fc20cdf9043e1b856d15170ac0f96511/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a28f3c88e50a77bc2a91889241248c4543854e61", "url": "https://api.github.com/repos/rust-lang/rust/commits/a28f3c88e50a77bc2a91889241248c4543854e61", "html_url": "https://github.com/rust-lang/rust/commit/a28f3c88e50a77bc2a91889241248c4543854e61"}], "stats": {"total": 117, "additions": 30, "deletions": 87}, "files": [{"sha": "3309fab224fb71112fac7cb5c37225f2ab26d5e8", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 24, "deletions": 70, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/a6e09a19fc20cdf9043e1b856d15170ac0f96511/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6e09a19fc20cdf9043e1b856d15170ac0f96511/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=a6e09a19fc20cdf9043e1b856d15170ac0f96511", "patch": "@@ -448,7 +448,8 @@ impl<'a> TraitDef<'a> {\n                     _ => unreachable!(),\n                 };\n                 let container_id = cx.current_expansion.id.expn_data().parent.expect_local();\n-                let always_copy = has_no_type_params && cx.resolver.has_derive_copy(container_id);\n+                let copy_fields =\n+                    is_packed && has_no_type_params && cx.resolver.has_derive_copy(container_id);\n \n                 let newitem = match item.kind {\n                     ast::ItemKind::Struct(ref struct_def, ref generics) => self.expand_struct_def(\n@@ -457,16 +458,14 @@ impl<'a> TraitDef<'a> {\n                         item.ident,\n                         generics,\n                         from_scratch,\n-                        is_packed,\n-                        always_copy,\n+                        copy_fields,\n                     ),\n                     ast::ItemKind::Enum(ref enum_def, ref generics) => {\n-                        // We ignore `is_packed`/`always_copy` here, because\n-                        // `repr(packed)` enums cause an error later on.\n+                        // We ignore `is_packed` here, because `repr(packed)`\n+                        // enums cause an error later on.\n                         //\n                         // This can only cause further compilation errors\n-                        // downstream in blatantly illegal code, so it\n-                        // is fine.\n+                        // downstream in blatantly illegal code, so it is fine.\n                         self.expand_enum_def(cx, enum_def, item.ident, generics, from_scratch)\n                     }\n                     ast::ItemKind::Union(ref struct_def, ref generics) => {\n@@ -477,8 +476,7 @@ impl<'a> TraitDef<'a> {\n                                 item.ident,\n                                 generics,\n                                 from_scratch,\n-                                is_packed,\n-                                always_copy,\n+                                copy_fields,\n                             )\n                         } else {\n                             cx.span_err(mitem.span, \"this trait cannot be derived for unions\");\n@@ -748,8 +746,7 @@ impl<'a> TraitDef<'a> {\n         type_ident: Ident,\n         generics: &Generics,\n         from_scratch: bool,\n-        is_packed: bool,\n-        always_copy: bool,\n+        copy_fields: bool,\n     ) -> P<ast::Item> {\n         let field_tys: Vec<P<ast::Ty>> =\n             struct_def.fields().iter().map(|field| field.ty.clone()).collect();\n@@ -777,8 +774,7 @@ impl<'a> TraitDef<'a> {\n                         type_ident,\n                         &selflike_args,\n                         &nonselflike_args,\n-                        is_packed,\n-                        always_copy,\n+                        copy_fields,\n                     )\n                 };\n \n@@ -1016,19 +1012,9 @@ impl<'a> MethodDef<'a> {\n     ///     }\n     /// }\n     /// ```\n-    /// If the struct doesn't impl `Copy`, we use let-destructuring with `ref`:\n-    /// ```\n-    /// # struct A { x: u8, y: u8 }\n-    /// impl PartialEq for A {\n-    ///     fn eq(&self, other: &A) -> bool {\n-    ///         let Self { x: ref __self_0_0, y: ref __self_0_1 } = *self;\n-    ///         let Self { x: ref __self_1_0, y: ref __self_1_1 } = *other;\n-    ///         *__self_0_0 == *__self_1_0 && *__self_0_1 == *__self_1_1\n-    ///     }\n-    /// }\n-    /// ```\n-    /// This latter case only works if the fields match the alignment required\n-    /// by the `packed(N)` attribute. (We'll get errors later on if not.)\n+    /// If the struct doesn't impl `Copy`, we use the normal `&self.x`. This\n+    /// only works if the fields match the alignment required by the\n+    /// `packed(N)` attribute. (We'll get errors later on if not.)\n     fn expand_struct_method_body<'b>(\n         &self,\n         cx: &mut ExtCtxt<'_>,\n@@ -1037,51 +1023,19 @@ impl<'a> MethodDef<'a> {\n         type_ident: Ident,\n         selflike_args: &[P<Expr>],\n         nonselflike_args: &[P<Expr>],\n-        is_packed: bool,\n-        always_copy: bool,\n+        copy_fields: bool,\n     ) -> BlockOrExpr {\n-        let span = trait_.span;\n         assert!(selflike_args.len() == 1 || selflike_args.len() == 2);\n \n-        let mk_body = |cx, selflike_fields| {\n-            self.call_substructure_method(\n-                cx,\n-                trait_,\n-                type_ident,\n-                nonselflike_args,\n-                &Struct(struct_def, selflike_fields),\n-            )\n-        };\n-\n-        if !is_packed {\n-            let selflike_fields =\n-                trait_.create_struct_field_access_fields(cx, selflike_args, struct_def, false);\n-            mk_body(cx, selflike_fields)\n-        } else if always_copy {\n-            let selflike_fields =\n-                trait_.create_struct_field_access_fields(cx, selflike_args, struct_def, true);\n-            mk_body(cx, selflike_fields)\n-        } else {\n-            // Packed and not copy. Need to use ref patterns.\n-            let prefixes: Vec<_> =\n-                (0..selflike_args.len()).map(|i| format!(\"__self_{}\", i)).collect();\n-            let selflike_fields = trait_.create_struct_pattern_fields(cx, struct_def, &prefixes);\n-            let mut body = mk_body(cx, selflike_fields);\n-\n-            let struct_path = cx.path(span, vec![Ident::new(kw::SelfUpper, type_ident.span)]);\n-            let patterns =\n-                trait_.create_struct_patterns(cx, struct_path, struct_def, &prefixes, ByRef::Yes);\n-\n-            // Do the let-destructuring.\n-            let mut stmts: Vec<_> = iter::zip(selflike_args, patterns)\n-                .map(|(selflike_arg_expr, pat)| {\n-                    let selflike_arg_expr = cx.expr_deref(span, selflike_arg_expr.clone());\n-                    cx.stmt_let_pat(span, pat, selflike_arg_expr)\n-                })\n-                .collect();\n-            stmts.extend(std::mem::take(&mut body.0));\n-            BlockOrExpr(stmts, body.1)\n-        }\n+        let selflike_fields =\n+            trait_.create_struct_field_access_fields(cx, selflike_args, struct_def, copy_fields);\n+        self.call_substructure_method(\n+            cx,\n+            trait_,\n+            type_ident,\n+            nonselflike_args,\n+            &Struct(struct_def, selflike_fields),\n+        )\n     }\n \n     fn expand_static_struct_method_body(\n@@ -1531,7 +1485,7 @@ impl<'a> TraitDef<'a> {\n         cx: &mut ExtCtxt<'_>,\n         selflike_args: &[P<Expr>],\n         struct_def: &'a VariantData,\n-        copy: bool,\n+        copy_fields: bool,\n     ) -> Vec<FieldInfo> {\n         self.create_fields(struct_def, |i, struct_field, sp| {\n             selflike_args\n@@ -1550,7 +1504,7 @@ impl<'a> TraitDef<'a> {\n                             }),\n                         ),\n                     );\n-                    if copy {\n+                    if copy_fields {\n                         field_expr = cx.expr_block(\n                             cx.block(struct_field.span, vec![cx.stmt_expr(field_expr)]),\n                         );"}, {"sha": "a63cbd4ca7edea3d2227db9b81300925274fe3c4", "filename": "src/test/ui/deriving/deriving-all-codegen.stdout", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a6e09a19fc20cdf9043e1b856d15170ac0f96511/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/a6e09a19fc20cdf9043e1b856d15170ac0f96511/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout?ref=a6e09a19fc20cdf9043e1b856d15170ac0f96511", "patch": "@@ -463,16 +463,14 @@ struct PackedNonCopy(u8);\n impl ::core::clone::Clone for PackedNonCopy {\n     #[inline]\n     fn clone(&self) -> PackedNonCopy {\n-        let Self(ref __self_0_0) = *self;\n-        PackedNonCopy(::core::clone::Clone::clone(__self_0_0))\n+        PackedNonCopy(::core::clone::Clone::clone(&self.0))\n     }\n }\n #[automatically_derived]\n impl ::core::fmt::Debug for PackedNonCopy {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n-        let Self(ref __self_0_0) = *self;\n         ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"PackedNonCopy\",\n-            &__self_0_0)\n+            &&self.0)\n     }\n }\n #[automatically_derived]\n@@ -485,20 +483,15 @@ impl ::core::default::Default for PackedNonCopy {\n #[automatically_derived]\n impl ::core::hash::Hash for PackedNonCopy {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n-        let Self(ref __self_0_0) = *self;\n-        ::core::hash::Hash::hash(__self_0_0, state)\n+        ::core::hash::Hash::hash(&self.0, state)\n     }\n }\n #[automatically_derived]\n impl ::core::marker::StructuralPartialEq for PackedNonCopy { }\n #[automatically_derived]\n impl ::core::cmp::PartialEq for PackedNonCopy {\n     #[inline]\n-    fn eq(&self, other: &PackedNonCopy) -> bool {\n-        let Self(ref __self_0_0) = *self;\n-        let Self(ref __self_1_0) = *other;\n-        *__self_0_0 == *__self_1_0\n-    }\n+    fn eq(&self, other: &PackedNonCopy) -> bool { self.0 == other.0 }\n }\n #[automatically_derived]\n impl ::core::marker::StructuralEq for PackedNonCopy { }\n@@ -516,18 +509,14 @@ impl ::core::cmp::PartialOrd for PackedNonCopy {\n     #[inline]\n     fn partial_cmp(&self, other: &PackedNonCopy)\n         -> ::core::option::Option<::core::cmp::Ordering> {\n-        let Self(ref __self_0_0) = *self;\n-        let Self(ref __self_1_0) = *other;\n-        ::core::cmp::PartialOrd::partial_cmp(__self_0_0, __self_1_0)\n+        ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)\n     }\n }\n #[automatically_derived]\n impl ::core::cmp::Ord for PackedNonCopy {\n     #[inline]\n     fn cmp(&self, other: &PackedNonCopy) -> ::core::cmp::Ordering {\n-        let Self(ref __self_0_0) = *self;\n-        let Self(ref __self_1_0) = *other;\n-        ::core::cmp::Ord::cmp(__self_0_0, __self_1_0)\n+        ::core::cmp::Ord::cmp(&self.0, &other.0)\n     }\n }\n "}]}