{"sha": "5328c5d1b01e41633a257692295273eb5f77e9da", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzMjhjNWQxYjAxZTQxNjMzYTI1NzY5MjI5NTI3M2ViNWY3N2U5ZGE=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-07-18T12:09:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-07-18T12:09:15Z"}, "message": "Merge pull request #245 from oli-obk/funky_allocs\n\nEnsure that it is not possible to explicitly free stack memory", "tree": {"sha": "920dc2101c8ca0236bd56405217c818273ea5e72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/920dc2101c8ca0236bd56405217c818273ea5e72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5328c5d1b01e41633a257692295273eb5f77e9da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5328c5d1b01e41633a257692295273eb5f77e9da", "html_url": "https://github.com/rust-lang/rust/commit/5328c5d1b01e41633a257692295273eb5f77e9da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5328c5d1b01e41633a257692295273eb5f77e9da/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a29ba6a2b3acab922e42c5b07776dcd22e1c785e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a29ba6a2b3acab922e42c5b07776dcd22e1c785e", "html_url": "https://github.com/rust-lang/rust/commit/a29ba6a2b3acab922e42c5b07776dcd22e1c785e"}, {"sha": "45ab975610d67f2fe6d55bc4ea0d72d80e5083ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/45ab975610d67f2fe6d55bc4ea0d72d80e5083ac", "html_url": "https://github.com/rust-lang/rust/commit/45ab975610d67f2fe6d55bc4ea0d72d80e5083ac"}], "stats": {"total": 274, "additions": 165, "deletions": 109}, "files": [{"sha": "b538d2d835786ed03993c9158ce12f75a43a607e", "filename": "src/const_eval.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5328c5d1b01e41633a257692295273eb5f77e9da/src%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5328c5d1b01e41633a257692295273eb5f77e9da/src%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconst_eval.rs?ref=5328c5d1b01e41633a257692295273eb5f77e9da", "patch": "@@ -1,5 +1,6 @@\n use rustc::traits::Reveal;\n use rustc::ty::{self, TyCtxt, Ty, Instance};\n+use syntax::ast::Mutability;\n \n use error::{EvalError, EvalResult};\n use lvalue::{Global, GlobalId, Lvalue};\n@@ -25,7 +26,12 @@ pub fn eval_body_as_primval<'a, 'tcx>(\n                 ecx.tcx,\n                 ty::ParamEnv::empty(Reveal::All),\n                 mir.span);\n-        let cleanup = StackPopCleanup::MarkStatic(mutable);\n+        let mutability = if mutable {\n+            Mutability::Mutable\n+        } else {\n+            Mutability::Immutable\n+        };\n+        let cleanup = StackPopCleanup::MarkStatic(mutability);\n         let name = ty::tls::with(|tcx| tcx.item_path_str(instance.def_id()));\n         trace!(\"pushing stack frame for global: {}\", name);\n         ecx.push_stack_frame("}, {"sha": "403ca9539e5b0db8622dd8e3a36a04d0d3e6442e", "filename": "src/error.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5328c5d1b01e41633a257692295273eb5f77e9da/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5328c5d1b01e41633a257692295273eb5f77e9da/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=5328c5d1b01e41633a257692295273eb5f77e9da", "patch": "@@ -2,7 +2,7 @@ use std::error::Error;\n use std::fmt;\n use rustc::mir;\n use rustc::ty::{FnSig, Ty, layout};\n-use memory::MemoryPointer;\n+use memory::{MemoryPointer, Kind};\n use rustc_const_math::ConstMathErr;\n use syntax::codemap::Span;\n \n@@ -12,6 +12,7 @@ pub enum EvalError<'tcx> {\n     NoMirFor(String),\n     UnterminatedCString(MemoryPointer),\n     DanglingPointerDeref,\n+    DoubleFree,\n     InvalidMemoryAccess,\n     InvalidFunctionPointer,\n     InvalidBool,\n@@ -56,8 +57,8 @@ pub enum EvalError<'tcx> {\n     AssumptionNotHeld,\n     InlineAsm,\n     TypeNotPrimitive(Ty<'tcx>),\n-    ReallocatedStaticMemory,\n-    DeallocatedStaticMemory,\n+    ReallocatedWrongMemoryKind(Kind, Kind),\n+    DeallocatedWrongMemoryKind(Kind, Kind),\n     ReallocateNonBasePtr,\n     DeallocateNonBasePtr,\n     IncorrectAllocationInformation,\n@@ -84,6 +85,8 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"tried to access memory through an invalid pointer\",\n             DanglingPointerDeref =>\n                 \"dangling pointer was dereferenced\",\n+            DoubleFree =>\n+                \"tried to deallocate dangling pointer\",\n             InvalidFunctionPointer =>\n                 \"tried to use an integer pointer or a dangling pointer as a function pointer\",\n             InvalidBool =>\n@@ -148,10 +151,10 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"miri does not support inline assembly\",\n             TypeNotPrimitive(_) =>\n                 \"expected primitive type, got nonprimitive\",\n-            ReallocatedStaticMemory =>\n-                \"tried to reallocate static memory\",\n-            DeallocatedStaticMemory =>\n-                \"tried to deallocate static memory\",\n+            ReallocatedWrongMemoryKind(_, _) =>\n+                \"tried to reallocate memory from one kind to another\",\n+            DeallocatedWrongMemoryKind(_, _) =>\n+                \"tried to deallocate memory of the wrong kind\",\n             ReallocateNonBasePtr =>\n                 \"tried to reallocate with a pointer not to the beginning of an existing object\",\n             DeallocateNonBasePtr =>\n@@ -198,6 +201,10 @@ impl<'tcx> fmt::Display for EvalError<'tcx> {\n                 write!(f, \"tried to call a function with sig {} through a function pointer of type {}\", sig, got),\n             ArrayIndexOutOfBounds(span, len, index) =>\n                 write!(f, \"index out of bounds: the len is {} but the index is {} at {:?}\", len, index, span),\n+            ReallocatedWrongMemoryKind(old, new) =>\n+                write!(f, \"tried to reallocate memory from {:?} to {:?}\", old, new),\n+            DeallocatedWrongMemoryKind(old, new) =>\n+                write!(f, \"tried to deallocate {:?} memory but gave {:?} as the kind\", old, new),\n             Math(span, ref err) =>\n                 write!(f, \"{:?} at {:?}\", err, span),\n             Intrinsic(ref err) =>"}, {"sha": "2f28063ff86ddbd2e2c6c772518c1092b1d8587e", "filename": "src/eval_context.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5328c5d1b01e41633a257692295273eb5f77e9da/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5328c5d1b01e41633a257692295273eb5f77e9da/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=5328c5d1b01e41633a257692295273eb5f77e9da", "patch": "@@ -12,7 +12,7 @@ use rustc::ty::{self, Ty, TyCtxt, TypeFoldable, Binder};\n use rustc::traits;\n use rustc_data_structures::indexed_vec::Idx;\n use syntax::codemap::{self, DUMMY_SP, Span};\n-use syntax::ast;\n+use syntax::ast::{self, Mutability};\n use syntax::abi::Abi;\n \n use error::{EvalError, EvalResult};\n@@ -98,8 +98,7 @@ pub enum StackPopCleanup {\n     /// isn't modifyable afterwards in case of constants.\n     /// In case of `static mut`, mark the memory to ensure it's never marked as immutable through\n     /// references or deallocated\n-    /// The bool decides whether the value is mutable (true) or not (false)\n-    MarkStatic(bool),\n+    MarkStatic(Mutability),\n     /// A regular stackframe added due to a function call will need to get forwarded to the next\n     /// block\n     Goto(mir::BasicBlock),\n@@ -154,7 +153,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     ) -> EvalResult<'tcx, MemoryPointer> {\n         let size = self.type_size_with_substs(ty, substs)?.expect(\"cannot alloc memory for unsized type\");\n         let align = self.type_align_with_substs(ty, substs)?;\n-        self.memory.allocate(size, align)\n+        self.memory.allocate(size, align, ::memory::Kind::Stack)\n     }\n \n     pub fn memory(&self) -> &Memory<'a, 'tcx> {\n@@ -370,7 +369,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 // see comment on `initialized` field\n                 assert!(!global_value.initialized);\n                 global_value.initialized = true;\n-                assert!(global_value.mutable);\n+                assert_eq!(global_value.mutable, Mutability::Mutable);\n                 global_value.mutable = mutable;\n             } else {\n                 bug!(\"StackPopCleanup::MarkStatic on: {:?}\", frame.return_lvalue);\n@@ -414,11 +413,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             trace!(\"deallocating local\");\n             let ptr = ptr.to_ptr()?;\n             self.memory.dump_alloc(ptr.alloc_id);\n-            match self.memory.deallocate(ptr, None) {\n-                // We could alternatively check whether the alloc_id is static before calling\n-                // deallocate, but this is much simpler and is probably the rare case.\n-                Ok(()) | Err(EvalError::DeallocatedStaticMemory) => {},\n-                other => return other,\n+            match self.memory.get(ptr.alloc_id)?.kind {\n+                // for a constant like `const FOO: &i32 = &1;` the local containing\n+                // the `1` is referred to by the global. We transitively marked everything\n+                // the global refers to as static itself, so we don't free it here\n+                ::memory::Kind::Static => {}\n+                ::memory::Kind::Stack => self.memory.deallocate(ptr, None, ::memory::Kind::Stack)?,\n+                other => bug!(\"local contained non-stack memory: {:?}\", other),\n             }\n         };\n         Ok(())\n@@ -693,11 +694,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     return Err(EvalError::NeedsRfc(\"\\\"heap\\\" allocations\".to_string()));\n                 }\n                 // FIXME: call the `exchange_malloc` lang item if available\n-                if self.type_size(ty)?.expect(\"box only works with sized types\") == 0 {\n+                let size = self.type_size(ty)?.expect(\"box only works with sized types\");\n+                if size == 0 {\n                     let align = self.type_align(ty)?;\n                     self.write_primval(dest, PrimVal::Bytes(align.into()), dest_ty)?;\n                 } else {\n-                    let ptr = self.alloc_ptr(ty)?;\n+                    let align = self.type_align(ty)?;\n+                    let ptr = self.memory.allocate(size, align, ::memory::Kind::Rust)?;\n                     self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n                 }\n             }\n@@ -1022,7 +1025,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n             Lvalue::Ptr { .. } => lvalue,\n             Lvalue::Global(cid) => {\n-                let global_val = *self.globals.get(&cid).expect(\"global not cached\");\n+                let global_val = self.globals.get(&cid).expect(\"global not cached\").clone();\n                 match global_val.value {\n                     Value::ByRef(ptr, aligned) =>\n                         Lvalue::Ptr { ptr, aligned, extra: LvalueExtra::None },\n@@ -1108,8 +1111,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         match dest {\n             Lvalue::Global(cid) => {\n-                let dest = *self.globals.get_mut(&cid).expect(\"global should be cached\");\n-                if !dest.mutable {\n+                let dest = self.globals.get_mut(&cid).expect(\"global should be cached\").clone();\n+                if dest.mutable == Mutability::Immutable {\n                     return Err(EvalError::ModifiedConstantMemory);\n                 }\n                 let write_dest = |this: &mut Self, val| {\n@@ -1594,8 +1597,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub fn modify_global<F>(&mut self, cid: GlobalId<'tcx>, f: F) -> EvalResult<'tcx>\n         where F: FnOnce(&mut Self, Value) -> EvalResult<'tcx, Value>,\n     {\n-        let mut val = *self.globals.get(&cid).expect(\"global not cached\");\n-        if !val.mutable {\n+        let mut val = self.globals.get(&cid).expect(\"global not cached\").clone();\n+        if val.mutable == Mutability::Immutable {\n             return Err(EvalError::ModifiedConstantMemory);\n         }\n         val.value = f(self, val.value)?;\n@@ -1686,7 +1689,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n             }\n \n             // Return value\n-            let ret_ptr = ecx.memory.allocate(ecx.tcx.data_layout.pointer_size.bytes(), ecx.tcx.data_layout.pointer_align.abi())?;\n+            let ret_ptr = ecx.memory.allocate(ecx.tcx.data_layout.pointer_size.bytes(), ecx.tcx.data_layout.pointer_align.abi(), ::memory::Kind::Stack)?;\n             cleanup_ptr = Some(ret_ptr);\n \n             // Push our stack frame\n@@ -1728,7 +1731,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n \n         while ecx.step()? {}\n         if let Some(cleanup_ptr) = cleanup_ptr {\n-            ecx.memory.deallocate(cleanup_ptr, None)?;\n+            ecx.memory.deallocate(cleanup_ptr, None, ::memory::Kind::Stack)?;\n         }\n         return Ok(());\n     }"}, {"sha": "f673ff060ed65643cb14fad75cbf536b61b814c7", "filename": "src/lvalue.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5328c5d1b01e41633a257692295273eb5f77e9da/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5328c5d1b01e41633a257692295273eb5f77e9da/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=5328c5d1b01e41633a257692295273eb5f77e9da", "patch": "@@ -2,6 +2,7 @@ use rustc::mir;\n use rustc::ty::layout::{Size, Align};\n use rustc::ty::{self, Ty};\n use rustc_data_structures::indexed_vec::Idx;\n+use syntax::ast::Mutability;\n \n use error::{EvalError, EvalResult};\n use eval_context::EvalContext;\n@@ -51,15 +52,15 @@ pub struct GlobalId<'tcx> {\n     pub(super) promoted: Option<mir::Promoted>,\n }\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Clone, Debug)]\n pub struct Global<'tcx> {\n     pub(super) value: Value,\n     /// Only used in `force_allocation` to ensure we don't mark the memory\n     /// before the static is initialized. It is possible to convert a\n     /// global which initially is `Value::ByVal(PrimVal::Undef)` and gets\n     /// lifted to an allocation before the static is fully initialized\n     pub(super) initialized: bool,\n-    pub(super) mutable: bool,\n+    pub(super) mutable: Mutability,\n     pub(super) ty: Ty<'tcx>,\n }\n \n@@ -113,13 +114,13 @@ impl<'tcx> Global<'tcx> {\n     pub(super) fn uninitialized(ty: Ty<'tcx>) -> Self {\n         Global {\n             value: Value::ByVal(PrimVal::Undef),\n-            mutable: true,\n+            mutable: Mutability::Mutable,\n             ty,\n             initialized: false,\n         }\n     }\n \n-    pub(super) fn initialized(ty: Ty<'tcx>, value: Value, mutable: bool) -> Self {\n+    pub(super) fn initialized(ty: Ty<'tcx>, value: Value, mutable: Mutability) -> Self {\n         Global {\n             value,\n             mutable,"}, {"sha": "6b181e31063ab5e9f833cee370ca2bbd35936d53", "filename": "src/memory.rs", "status": "modified", "additions": 82, "deletions": 55, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/5328c5d1b01e41633a257692295273eb5f77e9da/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5328c5d1b01e41633a257692295273eb5f77e9da/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=5328c5d1b01e41633a257692295273eb5f77e9da", "patch": "@@ -4,6 +4,7 @@ use std::{fmt, iter, ptr, mem, io};\n \n use rustc::ty;\n use rustc::ty::layout::{self, TargetDataLayout};\n+use syntax::ast::Mutability;\n \n use error::{EvalError, EvalResult};\n use value::{PrimVal, self, Pointer};\n@@ -35,19 +36,30 @@ pub struct Allocation {\n     /// The alignment of the allocation to detect unaligned reads.\n     pub align: u64,\n     /// Whether the allocation may be modified.\n+    pub mutable: Mutability,\n     /// Use the `mark_static_initalized` method of `Memory` to ensure that an error occurs, if the memory of this\n     /// allocation is modified or deallocated in the future.\n-    pub static_kind: StaticKind,\n+    /// Helps guarantee that stack allocations aren't deallocated via `rust_deallocate`\n+    pub kind: Kind,\n }\n \n #[derive(Debug, PartialEq, Copy, Clone)]\n-pub enum StaticKind {\n-    /// may be deallocated without breaking miri's invariants\n-    NotStatic,\n-    /// may be modified, but never deallocated\n-    Mutable,\n-    /// may neither be modified nor deallocated\n-    Immutable,\n+pub enum Kind {\n+    /// Error if deallocated any other way than `rust_deallocate`\n+    Rust,\n+    /// Error if deallocated any other way than `free`\n+    C,\n+    /// Error if deallocated except during a stack pop\n+    Stack,\n+    /// Static in the process of being initialized.\n+    /// The difference is important: An immutable static referring to a\n+    /// mutable initialized static will freeze immutably and would not\n+    /// be able to distinguish already initialized statics from uninitialized ones\n+    UninitializedStatic,\n+    /// May never be deallocated\n+    Static,\n+    /// Part of env var emulation\n+    Env,\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n@@ -181,14 +193,14 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             return Ok(MemoryPointer::new(alloc_id, 0));\n         }\n \n-        let ptr = self.allocate(bytes.len() as u64, 1)?;\n+        let ptr = self.allocate(bytes.len() as u64, 1, Kind::UninitializedStatic)?;\n         self.write_bytes(PrimVal::Ptr(ptr), bytes)?;\n-        self.mark_static_initalized(ptr.alloc_id, false)?;\n+        self.mark_static_initalized(ptr.alloc_id, Mutability::Immutable)?;\n         self.literal_alloc_cache.insert(bytes.to_vec(), ptr.alloc_id);\n         Ok(ptr)\n     }\n \n-    pub fn allocate(&mut self, size: u64, align: u64) -> EvalResult<'tcx, MemoryPointer> {\n+    pub fn allocate(&mut self, size: u64, align: u64, kind: Kind) -> EvalResult<'tcx, MemoryPointer> {\n         assert_ne!(align, 0);\n         assert!(align.is_power_of_two());\n \n@@ -206,57 +218,54 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             relocations: BTreeMap::new(),\n             undef_mask: UndefMask::new(size),\n             align,\n-            static_kind: StaticKind::NotStatic,\n+            kind,\n+            mutable: Mutability::Mutable,\n         };\n         let id = self.next_id;\n         self.next_id.0 += 1;\n         self.alloc_map.insert(id, alloc);\n         Ok(MemoryPointer::new(id, 0))\n     }\n \n-    // TODO(solson): Track which allocations were returned from __rust_allocate and report an error\n-    // when reallocating/deallocating any others.\n-    pub fn reallocate(&mut self, ptr: MemoryPointer, old_size: u64, old_align: u64, new_size: u64, new_align: u64) -> EvalResult<'tcx, MemoryPointer> {\n+    pub fn reallocate(&mut self, ptr: MemoryPointer, old_size: u64, old_align: u64, new_size: u64, new_align: u64, kind: Kind) -> EvalResult<'tcx, MemoryPointer> {\n         use std::cmp::min;\n \n-        // TODO(solson): Report error about non-__rust_allocate'd pointer.\n         if ptr.offset != 0 || self.get(ptr.alloc_id).is_err() {\n             return Err(EvalError::ReallocateNonBasePtr);\n         }\n-        if self.get(ptr.alloc_id).ok().map_or(false, |alloc| alloc.static_kind != StaticKind::NotStatic) {\n-            return Err(EvalError::ReallocatedStaticMemory);\n+        if let Ok(alloc) = self.get(ptr.alloc_id) {\n+            if alloc.kind != kind {\n+                return Err(EvalError::ReallocatedWrongMemoryKind(alloc.kind, kind));\n+            }\n         }\n \n         // For simplicities' sake, we implement reallocate as \"alloc, copy, dealloc\"\n-        let new_ptr = self.allocate(new_size, new_align)?;\n+        let new_ptr = self.allocate(new_size, new_align, kind)?;\n         self.copy(ptr.into(), new_ptr.into(), min(old_size, new_size), min(old_align, new_align), /*nonoverlapping*/true)?;\n-        self.deallocate(ptr, Some((old_size, old_align)))?;\n+        self.deallocate(ptr, Some((old_size, old_align)), kind)?;\n \n         Ok(new_ptr)\n     }\n \n-    // TODO(solson): See comment on `reallocate`.\n-    pub fn deallocate(&mut self, ptr: MemoryPointer, size_and_align: Option<(u64, u64)>) -> EvalResult<'tcx> {\n+    pub fn deallocate(&mut self, ptr: MemoryPointer, size_and_align: Option<(u64, u64)>, kind: Kind) -> EvalResult<'tcx> {\n         if ptr.offset != 0 || self.get(ptr.alloc_id).is_err() {\n-            // TODO(solson): Report error about non-__rust_allocate'd pointer.\n             return Err(EvalError::DeallocateNonBasePtr);\n         }\n \n-        {\n-            // deallocate_local in eval_context.rs relies on nothing actually having changed when this error occurs.\n-            // So we do this test in advance.\n-            let alloc = self.get(ptr.alloc_id)?;\n-            if alloc.static_kind != StaticKind::NotStatic {\n-                return Err(EvalError::DeallocatedStaticMemory);\n-            }\n-            if let Some((size, align)) = size_and_align {\n-                if size != alloc.bytes.len() as u64 || align != alloc.align {\n-                    return Err(EvalError::IncorrectAllocationInformation);\n-                }\n+        let alloc = match self.alloc_map.remove(&ptr.alloc_id) {\n+            Some(alloc) => alloc,\n+            None => return Err(EvalError::DoubleFree),\n+        };\n+\n+        if alloc.kind != kind {\n+            return Err(EvalError::DeallocatedWrongMemoryKind(alloc.kind, kind));\n+        }\n+        if let Some((size, align)) = size_and_align {\n+            if size != alloc.bytes.len() as u64 || align != alloc.align {\n+                return Err(EvalError::IncorrectAllocationInformation);\n             }\n         }\n \n-        let alloc = self.alloc_map.remove(&ptr.alloc_id).expect(\"already verified\");\n         self.memory_usage -= alloc.bytes.len() as u64;\n         debug!(\"deallocated : {}\", ptr.alloc_id);\n \n@@ -401,10 +410,10 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     pub fn get_mut(&mut self, id: AllocId) -> EvalResult<'tcx, &mut Allocation> {\n         match self.alloc_map.get_mut(&id) {\n-            Some(alloc) => match alloc.static_kind {\n-                StaticKind::Mutable |\n-                StaticKind::NotStatic => Ok(alloc),\n-                StaticKind::Immutable => Err(EvalError::ModifiedConstantMemory),\n+            Some(alloc) => if alloc.mutable == Mutability::Mutable {\n+                Ok(alloc)\n+            } else {\n+                Err(EvalError::ModifiedConstantMemory)\n             },\n             None => match self.functions.get(&id) {\n                 Some(_) => Err(EvalError::DerefFunctionPointer),\n@@ -473,10 +482,14 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n                 }\n             }\n \n-            let immutable = match alloc.static_kind {\n-                StaticKind::Mutable => \" (static mut)\",\n-                StaticKind::Immutable => \" (immutable)\",\n-                StaticKind::NotStatic => \"\",\n+            let immutable = match (alloc.kind, alloc.mutable) {\n+                (Kind::UninitializedStatic, _) => \" (static in the process of initialization)\",\n+                (Kind::Static, Mutability::Mutable) => \" (static mut)\",\n+                (Kind::Static, Mutability::Immutable) => \" (immutable)\",\n+                (Kind::Env, _) => \" (env var)\",\n+                (Kind::C, _) => \" (malloc)\",\n+                (Kind::Rust, _) => \" (heap)\",\n+                (Kind::Stack, _) => \" (stack)\",\n             };\n             trace!(\"{}({} bytes, alignment {}){}\", msg, alloc.bytes.len(), alloc.align, immutable);\n \n@@ -503,7 +516,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         let leaks: Vec<_> = self.alloc_map\n             .iter()\n             .filter_map(|(&key, val)| {\n-                if val.static_kind == StaticKind::NotStatic {\n+                if val.kind != Kind::Static {\n                     Some(key)\n                 } else {\n                     None\n@@ -578,26 +591,40 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n \n     /// mark an allocation pointed to by a static as static and initialized\n-    pub fn mark_inner_allocation(&mut self, alloc: AllocId, mutable: bool) -> EvalResult<'tcx> {\n+    pub fn mark_inner_allocation(&mut self, alloc: AllocId, mutability: Mutability) -> EvalResult<'tcx> {\n         // relocations into other statics are not \"inner allocations\"\n         if !self.static_alloc.contains(&alloc) {\n-            self.mark_static_initalized(alloc, mutable)?;\n+            self.mark_static_initalized(alloc, mutability)?;\n         }\n         Ok(())\n     }\n \n     /// mark an allocation as static and initialized, either mutable or not\n-    pub fn mark_static_initalized(&mut self, alloc_id: AllocId, mutable: bool) -> EvalResult<'tcx> {\n-        trace!(\"mark_static_initialized {:?}, mutable: {:?}\", alloc_id, mutable);\n+    pub fn mark_static_initalized(&mut self, alloc_id: AllocId, mutability: Mutability) -> EvalResult<'tcx> {\n+        trace!(\"mark_static_initalized {:?}, mutability: {:?}\", alloc_id, mutability);\n         // do not use `self.get_mut(alloc_id)` here, because we might have already marked a\n         // sub-element or have circular pointers (e.g. `Rc`-cycles)\n         let relocations = match self.alloc_map.get_mut(&alloc_id) {\n-            Some(&mut Allocation { ref mut relocations, static_kind: ref mut kind @ StaticKind::NotStatic, .. }) => {\n-                *kind = if mutable {\n-                    StaticKind::Mutable\n-                } else {\n-                    StaticKind::Immutable\n-                };\n+            Some(&mut Allocation { ref mut relocations, ref mut kind, ref mut mutable, .. }) => {\n+                match *kind {\n+                    // const eval results can refer to \"locals\".\n+                    // E.g. `const Foo: &u32 = &1;` refers to the temp local that stores the `1`\n+                    Kind::Stack |\n+                    // The entire point of this function\n+                    Kind::UninitializedStatic |\n+                    // In the future const eval will allow heap allocations so we'll need to protect them\n+                    // from deallocation, too\n+                    Kind::Rust |\n+                    Kind::C => {},\n+                    Kind::Static => {\n+                        trace!(\"mark_static_initalized: skipping already initialized static referred to by static currently being initialized\");\n+                        return Ok(());\n+                    },\n+                    // FIXME: This could be allowed, but not for env vars set during miri execution\n+                    Kind::Env => return Err(EvalError::Unimplemented(\"statics can't refer to env vars\".to_owned())),\n+                }\n+                *kind = Kind::Static;\n+                *mutable = mutability;\n                 // take out the relocations vector to free the borrow on self, so we can call\n                 // mark recursively\n                 mem::replace(relocations, Default::default())\n@@ -607,7 +634,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         };\n         // recurse into inner allocations\n         for &alloc in relocations.values() {\n-            self.mark_inner_allocation(alloc, mutable)?;\n+            self.mark_inner_allocation(alloc, mutability)?;\n         }\n         // put back the relocations\n         self.alloc_map.get_mut(&alloc_id).expect(\"checked above\").relocations = relocations;"}, {"sha": "d854218d7a90d7bcd6fab787eabc5a0d8884ffe4", "filename": "src/step.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5328c5d1b01e41633a257692295273eb5f77e9da/src%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5328c5d1b01e41633a257692295273eb5f77e9da/src%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstep.rs?ref=5328c5d1b01e41633a257692295273eb5f77e9da", "patch": "@@ -15,6 +15,7 @@ use eval_context::{EvalContext, StackPopCleanup};\n use lvalue::{Global, GlobalId, Lvalue};\n use value::{Value, PrimVal};\n use syntax::codemap::Span;\n+use syntax::ast::Mutability;\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub fn inc_step_counter_and_check_limit(&mut self, n: u64) -> EvalResult<'tcx> {\n@@ -162,7 +163,7 @@ impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n         def_id: DefId,\n         substs: &'tcx subst::Substs<'tcx>,\n         span: Span,\n-        shared: bool,\n+        mutability: Mutability,\n     ) {\n         let instance = self.ecx.resolve_associated_const(def_id, substs);\n         let cid = GlobalId { instance, promoted: None };\n@@ -171,18 +172,22 @@ impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n         }\n         if self.ecx.tcx.has_attr(def_id, \"linkage\") {\n             trace!(\"Initializing an extern global with NULL\");\n-            self.ecx.globals.insert(cid, Global::initialized(self.ecx.tcx.type_of(def_id), Value::ByVal(PrimVal::Bytes(0)), !shared));\n+            self.ecx.globals.insert(cid, Global::initialized(self.ecx.tcx.type_of(def_id), Value::ByVal(PrimVal::Bytes(0)), mutability));\n             return;\n         }\n         self.try(|this| {\n             let mir = this.ecx.load_mir(instance.def)?;\n             this.ecx.globals.insert(cid, Global::uninitialized(mir.return_ty));\n-            let mutable = !shared ||\n-                !mir.return_ty.is_freeze(\n+            let internally_mutable = !mir.return_ty.is_freeze(\n                     this.ecx.tcx,\n                     ty::ParamEnv::empty(Reveal::All),\n                     span);\n-            let cleanup = StackPopCleanup::MarkStatic(mutable);\n+            let mutability = if mutability == Mutability::Mutable || internally_mutable {\n+                Mutability::Mutable\n+            } else {\n+                Mutability::Immutable\n+            };\n+            let cleanup = StackPopCleanup::MarkStatic(mutability);\n             let name = ty::tls::with(|tcx| tcx.item_path_str(def_id));\n             trace!(\"pushing stack frame for global: {}\", name);\n             this.ecx.push_stack_frame(\n@@ -214,7 +219,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n             // already computed by rustc\n             mir::Literal::Value { .. } => {}\n             mir::Literal::Item { def_id, substs } => {\n-                self.global_item(def_id, substs, constant.span, true);\n+                self.global_item(def_id, substs, constant.span, Mutability::Immutable);\n             },\n             mir::Literal::Promoted { index } => {\n                 let cid = GlobalId {\n@@ -233,7 +238,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n                                               constant.span,\n                                               mir,\n                                               Lvalue::Global(cid),\n-                                              StackPopCleanup::MarkStatic(false),\n+                                              StackPopCleanup::MarkStatic(Mutability::Immutable),\n                     )\n                 });\n             }\n@@ -254,7 +259,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n             if let Some(node_item) = self.ecx.tcx.hir.get_if_local(def_id) {\n                 if let hir::map::Node::NodeItem(&hir::Item { ref node, .. }) = node_item {\n                     if let hir::ItemStatic(_, m, _) = *node {\n-                        self.global_item(def_id, substs, span, m == hir::MutImmutable);\n+                        self.global_item(def_id, substs, span, if m == hir::MutMutable { Mutability::Mutable } else { Mutability::Immutable });\n                         return;\n                     } else {\n                         bug!(\"static def id doesn't point to static\");\n@@ -265,7 +270,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n             } else {\n                 let def = self.ecx.tcx.describe_def(def_id).expect(\"static not found\");\n                 if let hir::def::Def::Static(_, mutable) = def {\n-                    self.global_item(def_id, substs, span, !mutable);\n+                    self.global_item(def_id, substs, span, if mutable { Mutability::Mutable } else { Mutability::Immutable });\n                 } else {\n                     bug!(\"static found but isn't a static: {:?}\", def);\n                 }"}, {"sha": "c4a8d2e73c2918d349bc9957efaf0fdfe6798b57", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5328c5d1b01e41633a257692295273eb5f77e9da/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5328c5d1b01e41633a257692295273eb5f77e9da/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=5328c5d1b01e41633a257692295273eb5f77e9da", "patch": "@@ -9,7 +9,7 @@ use syntax::abi::Abi;\n use error::{EvalError, EvalResult};\n use eval_context::{EvalContext, IntegerExt, StackPopCleanup, is_inhabited};\n use lvalue::Lvalue;\n-use memory::{MemoryPointer, TlsKey};\n+use memory::{MemoryPointer, TlsKey, Kind};\n use value::{PrimVal, Value};\n use rustc_data_structures::indexed_vec::Idx;\n \n@@ -558,7 +558,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 if !align.is_power_of_two() {\n                     return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                let ptr = self.memory.allocate(size, align)?;\n+                let ptr = self.memory.allocate(size, align, Kind::Rust)?;\n                 self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n             }\n             \"alloc::heap::::__rust_alloc_zeroed\" => {\n@@ -570,7 +570,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 if !align.is_power_of_two() {\n                     return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                let ptr = self.memory.allocate(size, align)?;\n+                let ptr = self.memory.allocate(size, align, Kind::Rust)?;\n                 self.memory.write_repeat(ptr.into(), 0, size)?;\n                 self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n             }\n@@ -584,7 +584,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 if !align.is_power_of_two() {\n                     return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                self.memory.deallocate(ptr, Some((old_size, align)))?;\n+                self.memory.deallocate(ptr, Some((old_size, align)), Kind::Rust)?;\n             }\n             \"alloc::heap::::__rust_realloc\" => {\n                 let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n@@ -601,7 +601,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 if !new_align.is_power_of_two() {\n                     return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(new_align));\n                 }\n-                let new_ptr = self.memory.reallocate(ptr, old_size, old_align, new_size, new_align)?;\n+                let new_ptr = self.memory.reallocate(ptr, old_size, old_align, new_size, new_align, Kind::Rust)?;\n                 self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n             }\n \n@@ -657,15 +657,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     self.write_null(dest, dest_ty)?;\n                 } else {\n                     let align = self.memory.pointer_size();\n-                    let ptr = self.memory.allocate(size, align)?;\n+                    let ptr = self.memory.allocate(size, align, Kind::C)?;\n                     self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n                 }\n             }\n \n             \"free\" => {\n                 let ptr = args[0].into_ptr(&mut self.memory)?;\n                 if !ptr.is_null()? {\n-                    self.memory.deallocate(ptr.to_ptr()?, None)?;\n+                    self.memory.deallocate(ptr.to_ptr()?, None, Kind::C)?;\n                 }\n             }\n \n@@ -789,7 +789,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 }\n                 if let Some(old) = success {\n                     if let Some(var) = old {\n-                        self.memory.deallocate(var, None)?;\n+                        self.memory.deallocate(var, None, Kind::Env)?;\n                     }\n                     self.write_null(dest, dest_ty)?;\n                 } else {\n@@ -812,11 +812,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 }\n                 if let Some((name, value)) = new {\n                     // +1 for the null terminator\n-                    let value_copy = self.memory.allocate((value.len() + 1) as u64, 1)?;\n+                    let value_copy = self.memory.allocate((value.len() + 1) as u64, 1, Kind::Env)?;\n                     self.memory.write_bytes(PrimVal::Ptr(value_copy), &value)?;\n                     self.memory.write_bytes(PrimVal::Ptr(value_copy.offset(value.len() as u64, self.memory.layout)?), &[0])?;\n                     if let Some(var) = self.env_vars.insert(name.to_owned(), value_copy) {\n-                        self.memory.deallocate(var, None)?;\n+                        self.memory.deallocate(var, None, Kind::Env)?;\n                     }\n                     self.write_null(dest, dest_ty)?;\n                 } else {"}, {"sha": "68d027bc63384a14fad8edf6e66e873c705ab879", "filename": "src/traits.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5328c5d1b01e41633a257692295273eb5f77e9da/src%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5328c5d1b01e41633a257692295273eb5f77e9da/src%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftraits.rs?ref=5328c5d1b01e41633a257692295273eb5f77e9da", "patch": "@@ -1,14 +1,14 @@\n use rustc::traits::{self, Reveal};\n \n use eval_context::EvalContext;\n-use memory::MemoryPointer;\n+use memory::{MemoryPointer, Kind};\n use value::{Value, PrimVal};\n \n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty};\n use syntax::codemap::DUMMY_SP;\n-use syntax::ast;\n+use syntax::ast::{self, Mutability};\n \n use error::{EvalResult, EvalError};\n \n@@ -51,7 +51,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         let ptr_size = self.memory.pointer_size();\n         let methods = ::rustc::traits::get_vtable_methods(self.tcx, trait_ref);\n-        let vtable = self.memory.allocate(ptr_size * (3 + methods.count() as u64), ptr_size)?;\n+        let vtable = self.memory.allocate(ptr_size * (3 + methods.count() as u64), ptr_size, Kind::UninitializedStatic)?;\n \n         let drop = ::eval_context::resolve_drop_in_place(self.tcx, ty);\n         let drop = self.memory.create_fn_alloc(drop);\n@@ -68,7 +68,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n         }\n \n-        self.memory.mark_static_initalized(vtable.alloc_id, false)?;\n+        self.memory.mark_static_initalized(vtable.alloc_id, Mutability::Mutable)?;\n \n         Ok(vtable)\n     }"}, {"sha": "08ff7457b76bec9b6d84ed02b5331ca7233b5cf5", "filename": "tests/compile-fail/stack_free.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5328c5d1b01e41633a257692295273eb5f77e9da/tests%2Fcompile-fail%2Fstack_free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5328c5d1b01e41633a257692295273eb5f77e9da/tests%2Fcompile-fail%2Fstack_free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstack_free.rs?ref=5328c5d1b01e41633a257692295273eb5f77e9da", "patch": "@@ -0,0 +1,7 @@\n+// error-pattern: tried to deallocate Stack memory but gave Rust as the kind\n+\n+fn main() {\n+    let x = 42;\n+    let bad_box = unsafe { std::mem::transmute::<&i32, Box<i32>>(&x) };\n+    drop(bad_box);\n+}"}]}