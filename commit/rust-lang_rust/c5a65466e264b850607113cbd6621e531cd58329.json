{"sha": "c5a65466e264b850607113cbd6621e531cd58329", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1YTY1NDY2ZTI2NGI4NTA2MDcxMTNjYmQ2NjIxZTUzMWNkNTgzMjk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-18T11:29:54Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-18T11:29:54Z"}, "message": "hide TaskResult from the public API", "tree": {"sha": "4073281c459e3efa2df90c35871e70401e114278", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4073281c459e3efa2df90c35871e70401e114278"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5a65466e264b850607113cbd6621e531cd58329", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5a65466e264b850607113cbd6621e531cd58329", "html_url": "https://github.com/rust-lang/rust/commit/c5a65466e264b850607113cbd6621e531cd58329", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5a65466e264b850607113cbd6621e531cd58329/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "062aa9723583cd6dae17b3bbe604ec7ad6c0394b", "url": "https://api.github.com/repos/rust-lang/rust/commits/062aa9723583cd6dae17b3bbe604ec7ad6c0394b", "html_url": "https://github.com/rust-lang/rust/commit/062aa9723583cd6dae17b3bbe604ec7ad6c0394b"}], "stats": {"total": 43, "additions": 28, "deletions": 15}, "files": [{"sha": "8eb148a38becdbddcfcf919d9caccbd90f5e6c79", "filename": "crates/ra_vfs/src/io.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c5a65466e264b850607113cbd6621e531cd58329/crates%2Fra_vfs%2Fsrc%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5a65466e264b850607113cbd6621e531cd58329/crates%2Fra_vfs%2Fsrc%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Fio.rs?ref=c5a65466e264b850607113cbd6621e531cd58329", "patch": "@@ -9,7 +9,7 @@ use relative_path::RelativePathBuf;\n use walkdir::WalkDir;\n use notify::{DebouncedEvent, RecommendedWatcher, RecursiveMode, Watcher as _Watcher};\n \n-use crate::{Roots, VfsRoot};\n+use crate::{Roots, VfsRoot, VfsTask};\n \n pub(crate) enum Task {\n     AddRoot { root: VfsRoot },\n@@ -18,7 +18,7 @@ pub(crate) enum Task {\n /// `TaskResult` transfers files read on the IO thread to the VFS on the main\n /// thread.\n #[derive(Debug)]\n-pub enum TaskResult {\n+pub(crate) enum TaskResult {\n     /// Emitted when we've recursively scanned a source root during the initial\n     /// load.\n     BulkLoadRoot { root: VfsRoot, files: Vec<(RelativePathBuf, String)> },\n@@ -46,7 +46,7 @@ enum ChangeKind {\n \n const WATCHER_DELAY: Duration = Duration::from_millis(250);\n \n-pub(crate) type Worker = thread_worker::Worker<Task, TaskResult>;\n+pub(crate) type Worker = thread_worker::Worker<Task, VfsTask>;\n pub(crate) fn start(roots: Arc<Roots>) -> Worker {\n     // This is a pretty elaborate setup of threads & channels! It is\n     // explained by the following concerns:\n@@ -122,7 +122,7 @@ pub(crate) fn start(roots: Arc<Roots>) -> Worker {\n \n fn watch_root(\n     watcher: Option<&mut RecommendedWatcher>,\n-    sender: &Sender<TaskResult>,\n+    sender: &Sender<VfsTask>,\n     roots: &Roots,\n     root: VfsRoot,\n ) {\n@@ -136,7 +136,8 @@ fn watch_root(\n             Some((path, text))\n         })\n         .collect();\n-    sender.send(TaskResult::BulkLoadRoot { root, files }).unwrap();\n+    let res = TaskResult::BulkLoadRoot { root, files };\n+    sender.send(VfsTask(res)).unwrap();\n     log::debug!(\"... loaded {}\", root_path.display());\n }\n \n@@ -173,7 +174,7 @@ fn convert_notify_event(event: DebouncedEvent, sender: &Sender<(PathBuf, ChangeK\n \n fn handle_change(\n     watcher: Option<&mut RecommendedWatcher>,\n-    sender: &Sender<TaskResult>,\n+    sender: &Sender<VfsTask>,\n     roots: &Roots,\n     path: PathBuf,\n     kind: ChangeKind,\n@@ -195,13 +196,15 @@ fn handle_change(\n                 .try_for_each(|rel_path| {\n                     let abs_path = rel_path.to_path(&roots.path(root));\n                     let text = read_to_string(&abs_path);\n-                    sender.send(TaskResult::SingleFile { root, path: rel_path, text })\n+                    let res = TaskResult::SingleFile { root, path: rel_path, text };\n+                    sender.send(VfsTask(res))\n                 })\n                 .unwrap()\n         }\n         ChangeKind::Write | ChangeKind::Remove => {\n             let text = read_to_string(&path);\n-            sender.send(TaskResult::SingleFile { root, path: rel_path, text }).unwrap();\n+            let res = TaskResult::SingleFile { root, path: rel_path, text };\n+            sender.send(VfsTask(res)).unwrap();\n         }\n     }\n }"}, {"sha": "3cd11c9f67a8ae5277069b6f83950fc5b6c879fa", "filename": "crates/ra_vfs/src/lib.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c5a65466e264b850607113cbd6621e531cd58329/crates%2Fra_vfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5a65466e264b850607113cbd6621e531cd58329/crates%2Fra_vfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Flib.rs?ref=c5a65466e264b850607113cbd6621e531cd58329", "patch": "@@ -33,10 +33,20 @@ use crate::{\n     roots::Roots,\n };\n \n-pub use crate::{\n-    io::TaskResult as VfsTask,\n-    roots::VfsRoot,\n-};\n+pub use crate::roots::VfsRoot;\n+\n+/// Opaque wrapper around file-system event.\n+///\n+/// Calling code is expected to just pass `VfsTask` to `handle_task` method. It\n+/// is exposed as a public API so that the caller can plug vfs events into the\n+/// main event loop and be notified when changes happen.\n+pub struct VfsTask(TaskResult);\n+\n+impl fmt::Debug for VfsTask {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.write_str(\"VfsTask { ... }\")\n+    }\n+}\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct VfsFile(pub u32);\n@@ -159,12 +169,12 @@ impl Vfs {\n         mem::replace(&mut self.pending_changes, Vec::new())\n     }\n \n-    pub fn task_receiver(&self) -> &Receiver<io::TaskResult> {\n+    pub fn task_receiver(&self) -> &Receiver<VfsTask> {\n         self.worker.receiver()\n     }\n \n-    pub fn handle_task(&mut self, task: io::TaskResult) {\n-        match task {\n+    pub fn handle_task(&mut self, task: VfsTask) {\n+        match task.0 {\n             TaskResult::BulkLoadRoot { root, files } => {\n                 let mut cur_files = Vec::new();\n                 // While we were scanning the root in the background, a file might have"}]}