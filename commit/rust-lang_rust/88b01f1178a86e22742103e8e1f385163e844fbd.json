{"sha": "88b01f1178a86e22742103e8e1f385163e844fbd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4YjAxZjExNzhhODZlMjI3NDIxMDNlOGUxZjM4NTE2M2U4NDRmYmQ=", "commit": {"author": {"name": "Adam Bratschi-Kaye", "email": "ark.email@gmail.com", "date": "2021-05-27T08:21:53Z"}, "committer": {"name": "Adam Bratschi-Kaye", "email": "ark.email@gmail.com", "date": "2021-06-17T19:48:02Z"}, "message": "Emit warnings for unused fields in custom targets.", "tree": {"sha": "a0dd56559fd768ed16b04093174e437aa0ba444c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0dd56559fd768ed16b04093174e437aa0ba444c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88b01f1178a86e22742103e8e1f385163e844fbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88b01f1178a86e22742103e8e1f385163e844fbd", "html_url": "https://github.com/rust-lang/rust/commit/88b01f1178a86e22742103e8e1f385163e844fbd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88b01f1178a86e22742103e8e1f385163e844fbd/comments", "author": {"login": "adamrk", "id": 16367467, "node_id": "MDQ6VXNlcjE2MzY3NDY3", "avatar_url": "https://avatars.githubusercontent.com/u/16367467?v=4", "gravatar_id": "", "url": "https://api.github.com/users/adamrk", "html_url": "https://github.com/adamrk", "followers_url": "https://api.github.com/users/adamrk/followers", "following_url": "https://api.github.com/users/adamrk/following{/other_user}", "gists_url": "https://api.github.com/users/adamrk/gists{/gist_id}", "starred_url": "https://api.github.com/users/adamrk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/adamrk/subscriptions", "organizations_url": "https://api.github.com/users/adamrk/orgs", "repos_url": "https://api.github.com/users/adamrk/repos", "events_url": "https://api.github.com/users/adamrk/events{/privacy}", "received_events_url": "https://api.github.com/users/adamrk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "adamrk", "id": 16367467, "node_id": "MDQ6VXNlcjE2MzY3NDY3", "avatar_url": "https://avatars.githubusercontent.com/u/16367467?v=4", "gravatar_id": "", "url": "https://api.github.com/users/adamrk", "html_url": "https://github.com/adamrk", "followers_url": "https://api.github.com/users/adamrk/followers", "following_url": "https://api.github.com/users/adamrk/following{/other_user}", "gists_url": "https://api.github.com/users/adamrk/gists{/gist_id}", "starred_url": "https://api.github.com/users/adamrk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/adamrk/subscriptions", "organizations_url": "https://api.github.com/users/adamrk/orgs", "repos_url": "https://api.github.com/users/adamrk/repos", "events_url": "https://api.github.com/users/adamrk/events{/privacy}", "received_events_url": "https://api.github.com/users/adamrk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ef2b4a29bf70e8984d0d2febb7a546856c554a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ef2b4a29bf70e8984d0d2febb7a546856c554a0", "html_url": "https://github.com/rust-lang/rust/commit/0ef2b4a29bf70e8984d0d2febb7a546856c554a0"}], "stats": {"total": 326, "additions": 235, "deletions": 91}, "files": [{"sha": "4d213207fb625265a54ea107e23eefa8bda01b80", "filename": "compiler/rustc_serialize/src/json.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/88b01f1178a86e22742103e8e1f385163e844fbd/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b01f1178a86e22742103e8e1f385163e844fbd/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs?ref=88b01f1178a86e22742103e8e1f385163e844fbd", "patch": "@@ -1114,6 +1114,15 @@ impl Json {\n         }\n     }\n \n+    /// If the Json value is an Object, deletes the value associated with the\n+    /// provided key from the Object and returns it. Otherwise, returns None.\n+    pub fn remove_key(&mut self, key: &str) -> Option<Json> {\n+        match *self {\n+            Json::Object(ref mut map) => map.remove(key),\n+            _ => None,\n+        }\n+    }\n+\n     /// Attempts to get a nested Json Object for each key in `keys`.\n     /// If any key is found not to exist, `find_path` will return `None`.\n     /// Otherwise, it will return the Json value associated with the final key."}, {"sha": "5afa8e6a09a69d62508ce278749b6c471163115c", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/88b01f1178a86e22742103e8e1f385163e844fbd/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b01f1178a86e22742103e8e1f385163e844fbd/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=88b01f1178a86e22742103e8e1f385163e844fbd", "patch": "@@ -12,7 +12,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::impl_stable_hash_via_hash;\n \n use rustc_target::abi::{Align, TargetDataLayout};\n-use rustc_target::spec::{SplitDebuginfo, Target, TargetTriple};\n+use rustc_target::spec::{SplitDebuginfo, Target, TargetTriple, TargetWarnings};\n \n use rustc_serialize::json;\n \n@@ -899,9 +899,11 @@ pub(super) fn build_target_config(\n     target_override: Option<Target>,\n     sysroot: &PathBuf,\n ) -> Target {\n-    let target_result =\n-        target_override.map_or_else(|| Target::search(&opts.target_triple, sysroot), Ok);\n-    let target = target_result.unwrap_or_else(|e| {\n+    let target_result = target_override.map_or_else(\n+        || Target::search(&opts.target_triple, sysroot),\n+        |t| Ok((t, TargetWarnings::empty())),\n+    );\n+    let (target, target_warnings) = target_result.unwrap_or_else(|e| {\n         early_error(\n             opts.error_format,\n             &format!(\n@@ -911,6 +913,9 @@ pub(super) fn build_target_config(\n             ),\n         )\n     });\n+    for warning in target_warnings.warning_messages() {\n+        early_warn(opts.error_format, &warning)\n+    }\n \n     if !matches!(target.pointer_width, 16 | 32 | 64) {\n         early_error("}, {"sha": "d8a58ee18cd8eec70762adfde30d4a353e5660d5", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/88b01f1178a86e22742103e8e1f385163e844fbd/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b01f1178a86e22742103e8e1f385163e844fbd/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=88b01f1178a86e22742103e8e1f385163e844fbd", "patch": "@@ -1284,9 +1284,12 @@ pub fn build_session(\n \n     let target_cfg = config::build_target_config(&sopts, target_override, &sysroot);\n     let host_triple = TargetTriple::from_triple(config::host_triple());\n-    let host = Target::search(&host_triple, &sysroot).unwrap_or_else(|e| {\n+    let (host, target_warnings) = Target::search(&host_triple, &sysroot).unwrap_or_else(|e| {\n         early_error(sopts.error_format, &format!(\"Error loading host specification: {}\", e))\n     });\n+    for warning in target_warnings.warning_messages() {\n+        early_warn(sopts.error_format, &warning)\n+    }\n \n     let loader = file_loader.unwrap_or_else(|| Box::new(RealFileLoader));\n     let hash_kind = sopts.debugging_opts.src_hash_algorithm.unwrap_or_else(|| {"}, {"sha": "d39e5a5aa2c3f4bed54ec4272d7e50a94e808000", "filename": "compiler/rustc_target/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/88b01f1178a86e22742103e8e1f385163e844fbd/compiler%2Frustc_target%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b01f1178a86e22742103e8e1f385163e844fbd/compiler%2Frustc_target%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Flib.rs?ref=88b01f1178a86e22742103e8e1f385163e844fbd", "patch": "@@ -27,6 +27,9 @@ pub mod abi;\n pub mod asm;\n pub mod spec;\n \n+#[cfg(test)]\n+mod tests;\n+\n /// Requirements for a `StableHashingContext` to be used in this crate.\n /// This is a hack to allow using the `HashStable_Generic` derive macro\n /// instead of implementing everything in `rustc_middle`."}, {"sha": "9183908469487f0eb6880279e595275506789fbf", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 150, "deletions": 85, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/88b01f1178a86e22742103e8e1f385163e844fbd/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b01f1178a86e22742103e8e1f385163e844fbd/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=88b01f1178a86e22742103e8e1f385163e844fbd", "patch": "@@ -905,6 +905,38 @@ supported_targets! {\n     (\"bpfel-unknown-none\", bpfel_unknown_none),\n }\n \n+/// Warnings encountered when parsing the target `json`.\n+///\n+/// Includes fields that weren't recognized and fields that don't have the expected type.\n+#[derive(Debug, PartialEq)]\n+pub struct TargetWarnings {\n+    unused_fields: Vec<String>,\n+    incorrect_type: Vec<String>,\n+}\n+\n+impl TargetWarnings {\n+    pub fn empty() -> Self {\n+        Self { unused_fields: Vec::new(), incorrect_type: Vec::new() }\n+    }\n+\n+    pub fn warning_messages(&self) -> Vec<String> {\n+        let mut warnings = vec![];\n+        if !self.unused_fields.is_empty() {\n+            warnings.push(format!(\n+                \"target json file contains unused fields: {}\",\n+                self.unused_fields.join(\", \")\n+            ));\n+        }\n+        if !self.incorrect_type.is_empty() {\n+            warnings.push(format!(\n+                \"target json file contains fields whose value doesn't have the correct json type: {}\",\n+                self.incorrect_type.join(\", \")\n+            ));\n+        }\n+        warnings\n+    }\n+}\n+\n /// Everything `rustc` knows about how to compile for a specific target.\n ///\n /// Every field here must be specified, and has no default value.\n@@ -1447,18 +1479,17 @@ impl Target {\n     }\n \n     /// Loads a target descriptor from a JSON object.\n-    pub fn from_json(obj: Json) -> Result<Target, String> {\n+    pub fn from_json(mut obj: Json) -> Result<(Target, TargetWarnings), String> {\n         // While ugly, this code must remain this way to retain\n         // compatibility with existing JSON fields and the internal\n         // expected naming of the Target and TargetOptions structs.\n         // To ensure compatibility is retained, the built-in targets\n         // are round-tripped through this code to catch cases where\n         // the JSON parser is not updated to match the structs.\n \n-        let get_req_field = |name: &str| {\n-            obj.find(name)\n-                .and_then(Json::as_string)\n-                .map(str::to_string)\n+        let mut get_req_field = |name: &str| {\n+            obj.remove_key(name)\n+                .and_then(|j| Json::as_string(&j).map(str::to_string))\n                 .ok_or_else(|| format!(\"Field {} in target specification is required\", name))\n         };\n \n@@ -1472,28 +1503,30 @@ impl Target {\n             options: Default::default(),\n         };\n \n+        let mut incorrect_type = vec![];\n+\n         macro_rules! key {\n             ($key_name:ident) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                if let Some(s) = obj.find(&name).and_then(Json::as_string) {\n-                    base.$key_name = s.to_string();\n+                if let Some(s) = obj.remove_key(&name).and_then(|j| Json::as_string(&j).map(str::to_string)) {\n+                    base.$key_name = s;\n                 }\n             } );\n             ($key_name:ident = $json_name:expr) => ( {\n                 let name = $json_name;\n-                if let Some(s) = obj.find(&name).and_then(Json::as_string) {\n-                    base.$key_name = s.to_string();\n+                if let Some(s) = obj.remove_key(&name).and_then(|j| Json::as_string(&j).map(str::to_string)) {\n+                    base.$key_name = s;\n                 }\n             } );\n             ($key_name:ident, bool) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                if let Some(s) = obj.find(&name).and_then(Json::as_boolean) {\n+                if let Some(s) = obj.remove_key(&name).and_then(|j| Json::as_boolean(&j)) {\n                     base.$key_name = s;\n                 }\n             } );\n             ($key_name:ident, Option<u32>) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                if let Some(s) = obj.find(&name).and_then(Json::as_u64) {\n+                if let Some(s) = obj.remove_key(&name).and_then(|j| Json::as_u64(&j)) {\n                     if s < 1 || s > 5 {\n                         return Err(\"Not a valid DWARF version number\".to_string());\n                     }\n@@ -1502,13 +1535,13 @@ impl Target {\n             } );\n             ($key_name:ident, Option<u64>) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                if let Some(s) = obj.find(&name).and_then(Json::as_u64) {\n+                if let Some(s) = obj.remove_key(&name).and_then(|j| Json::as_u64(&j)) {\n                     base.$key_name = Some(s);\n                 }\n             } );\n             ($key_name:ident, MergeFunctions) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n+                obj.remove_key(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n                     match s.parse::<MergeFunctions>() {\n                         Ok(mergefunc) => base.$key_name = mergefunc,\n                         _ => return Some(Err(format!(\"'{}' is not a valid value for \\\n@@ -1521,7 +1554,7 @@ impl Target {\n             } );\n             ($key_name:ident, RelocModel) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n+                obj.remove_key(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n                     match s.parse::<RelocModel>() {\n                         Ok(relocation_model) => base.$key_name = relocation_model,\n                         _ => return Some(Err(format!(\"'{}' is not a valid relocation model. \\\n@@ -1533,7 +1566,7 @@ impl Target {\n             } );\n             ($key_name:ident, CodeModel) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n+                obj.remove_key(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n                     match s.parse::<CodeModel>() {\n                         Ok(code_model) => base.$key_name = Some(code_model),\n                         _ => return Some(Err(format!(\"'{}' is not a valid code model. \\\n@@ -1545,7 +1578,7 @@ impl Target {\n             } );\n             ($key_name:ident, TlsModel) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n+                obj.remove_key(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n                     match s.parse::<TlsModel>() {\n                         Ok(tls_model) => base.$key_name = tls_model,\n                         _ => return Some(Err(format!(\"'{}' is not a valid TLS model. \\\n@@ -1557,7 +1590,7 @@ impl Target {\n             } );\n             ($key_name:ident, PanicStrategy) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n+                obj.remove_key(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n                     match s {\n                         \"unwind\" => base.$key_name = PanicStrategy::Unwind,\n                         \"abort\" => base.$key_name = PanicStrategy::Abort,\n@@ -1570,7 +1603,7 @@ impl Target {\n             } );\n             ($key_name:ident, RelroLevel) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n+                obj.remove_key(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n                     match s.parse::<RelroLevel>() {\n                         Ok(level) => base.$key_name = level,\n                         _ => return Some(Err(format!(\"'{}' is not a valid value for \\\n@@ -1582,7 +1615,7 @@ impl Target {\n             } );\n             ($key_name:ident, SplitDebuginfo) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n+                obj.remove_key(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n                     match s.parse::<SplitDebuginfo>() {\n                         Ok(level) => base.$key_name = level,\n                         _ => return Some(Err(format!(\"'{}' is not a valid value for \\\n@@ -1594,31 +1627,39 @@ impl Target {\n             } );\n             ($key_name:ident, list) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                if let Some(v) = obj.find(&name).and_then(Json::as_array) {\n-                    base.$key_name = v.iter()\n-                        .map(|a| a.as_string().unwrap().to_string())\n-                        .collect();\n+                if let Some(j) = obj.remove_key(&name){\n+                    if let Some(v) = Json::as_array(&j) {\n+                        base.$key_name = v.iter()\n+                            .map(|a| a.as_string().unwrap().to_string())\n+                            .collect();\n+                    } else {\n+                        incorrect_type.push(name)\n+                    }\n                 }\n             } );\n             ($key_name:ident, opt_list) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                if let Some(v) = obj.find(&name).and_then(Json::as_array) {\n-                    base.$key_name = Some(v.iter()\n-                        .map(|a| a.as_string().unwrap().to_string())\n-                        .collect());\n+                if let Some(j) = obj.remove_key(&name) {\n+                    if let Some(v) = Json::as_array(&j) {\n+                        base.$key_name = Some(v.iter()\n+                            .map(|a| a.as_string().unwrap().to_string())\n+                            .collect());\n+                    } else {\n+                        incorrect_type.push(name)\n+                    }\n                 }\n             } );\n             ($key_name:ident, optional) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                if let Some(o) = obj.find(&name[..]) {\n+                if let Some(o) = obj.remove_key(&name[..]) {\n                     base.$key_name = o\n                         .as_string()\n                         .map(|s| s.to_string() );\n                 }\n             } );\n             ($key_name:ident, LldFlavor) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n+                obj.remove_key(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n                     if let Some(flavor) = LldFlavor::from_str(&s) {\n                         base.$key_name = flavor;\n                     } else {\n@@ -1632,7 +1673,7 @@ impl Target {\n             } );\n             ($key_name:ident, LinkerFlavor) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n+                obj.remove_key(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n                     match LinkerFlavor::from_str(s) {\n                         Some(linker_flavor) => base.$key_name = linker_flavor,\n                         _ => return Some(Err(format!(\"'{}' is not a valid value for linker-flavor. \\\n@@ -1643,7 +1684,7 @@ impl Target {\n             } );\n             ($key_name:ident, StackProbeType) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(&name[..]).and_then(|o| match StackProbeType::from_json(o) {\n+                obj.remove_key(&name[..]).and_then(|o| match StackProbeType::from_json(&o) {\n                     Ok(v) => {\n                         base.$key_name = v;\n                         Some(Ok(()))\n@@ -1655,25 +1696,29 @@ impl Target {\n             } );\n             ($key_name:ident, SanitizerSet) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(&name[..]).and_then(|o| o.as_array()).and_then(|a| {\n-                    for s in a {\n-                        base.$key_name |= match s.as_string() {\n-                            Some(\"address\") => SanitizerSet::ADDRESS,\n-                            Some(\"leak\") => SanitizerSet::LEAK,\n-                            Some(\"memory\") => SanitizerSet::MEMORY,\n-                            Some(\"thread\") => SanitizerSet::THREAD,\n-                            Some(\"hwaddress\") => SanitizerSet::HWADDRESS,\n-                            Some(s) => return Some(Err(format!(\"unknown sanitizer {}\", s))),\n-                            _ => return Some(Err(format!(\"not a string: {:?}\", s))),\n-                        };\n+                if let Some(o) = obj.remove_key(&name[..]) {\n+                    if let Some(a) = o.as_array() {\n+                        for s in a {\n+                            base.$key_name |= match s.as_string() {\n+                                Some(\"address\") => SanitizerSet::ADDRESS,\n+                                Some(\"leak\") => SanitizerSet::LEAK,\n+                                Some(\"memory\") => SanitizerSet::MEMORY,\n+                                Some(\"thread\") => SanitizerSet::THREAD,\n+                                Some(\"hwaddress\") => SanitizerSet::HWADDRESS,\n+                                Some(s) => return Err(format!(\"unknown sanitizer {}\", s)),\n+                                _ => return Err(format!(\"not a string: {:?}\", s)),\n+                            };\n+                        }\n+                    } else {\n+                        incorrect_type.push(name)\n                     }\n-                    Some(Ok(()))\n-                }).unwrap_or(Ok(()))\n+                }\n+                Ok::<(), String>(())\n             } );\n \n             ($key_name:ident, crt_objects_fallback) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n+                obj.remove_key(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n                     match s.parse::<CrtObjectsFallback>() {\n                         Ok(fallback) => base.$key_name = Some(fallback),\n                         _ => return Some(Err(format!(\"'{}' is not a valid CRT objects fallback. \\\n@@ -1684,7 +1729,7 @@ impl Target {\n             } );\n             ($key_name:ident, link_objects) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                if let Some(val) = obj.find(&name[..]) {\n+                if let Some(val) = obj.remove_key(&name[..]) {\n                     let obj = val.as_object().ok_or_else(|| format!(\"{}: expected a \\\n                         JSON object with fields per CRT object kind.\", name))?;\n                     let mut args = CrtObjects::new();\n@@ -1712,7 +1757,7 @@ impl Target {\n             } );\n             ($key_name:ident, link_args) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                if let Some(val) = obj.find(&name[..]) {\n+                if let Some(val) = obj.remove_key(&name[..]) {\n                     let obj = val.as_object().ok_or_else(|| format!(\"{}: expected a \\\n                         JSON object with fields per linker-flavor.\", name))?;\n                     let mut args = LinkArgs::new();\n@@ -1739,22 +1784,26 @@ impl Target {\n             } );\n             ($key_name:ident, env) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                if let Some(a) = obj.find(&name[..]).and_then(|o| o.as_array()) {\n-                    for o in a {\n-                        if let Some(s) = o.as_string() {\n-                            let p = s.split('=').collect::<Vec<_>>();\n-                            if p.len() == 2 {\n-                                let k = p[0].to_string();\n-                                let v = p[1].to_string();\n-                                base.$key_name.push((k, v));\n+                if let Some(o) = obj.remove_key(&name[..]) {\n+                    if let Some(a) = o.as_array() {\n+                        for o in a {\n+                            if let Some(s) = o.as_string() {\n+                                let p = s.split('=').collect::<Vec<_>>();\n+                                if p.len() == 2 {\n+                                    let k = p[0].to_string();\n+                                    let v = p[1].to_string();\n+                                    base.$key_name.push((k, v));\n+                                }\n                             }\n                         }\n+                    } else {\n+                        incorrect_type.push(name)\n                     }\n                 }\n             } );\n             ($key_name:ident, Option<Abi>) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n+                obj.remove_key(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n                     match lookup_abi(s) {\n                         Some(abi) => base.$key_name = Some(abi),\n                         _ => return Some(Err(format!(\"'{}' is not a valid value for abi\", s))),\n@@ -1763,20 +1812,26 @@ impl Target {\n                 })).unwrap_or(Ok(()))\n             } );\n             ($key_name:ident, TargetFamilies) => ( {\n-                let value = obj.find(\"target-family\");\n-                if let Some(v) = value.and_then(Json::as_array) {\n-                    base.$key_name = v.iter()\n-                        .map(|a| a.as_string().unwrap().to_string())\n-                        .collect();\n-                } else if let Some(v) = value.and_then(Json::as_string) {\n-                    base.$key_name = vec![v.to_string()];\n+                if let Some(value) = obj.remove_key(\"target-family\") {\n+                    if let Some(v) = Json::as_array(&value) {\n+                        base.$key_name = v.iter()\n+                            .map(|a| a.as_string().unwrap().to_string())\n+                            .collect();\n+                    } else if let Some(v) = Json::as_string(&value) {\n+                        base.$key_name = vec![v.to_string()];\n+                    }\n                 }\n             } );\n         }\n \n-        if let Some(s) = obj.find(\"target-endian\").and_then(Json::as_string) {\n-            base.endian = s.parse()?;\n+        if let Some(j) = obj.remove_key(\"target-endian\") {\n+            if let Some(s) = Json::as_string(&j) {\n+                base.endian = s.parse()?;\n+            } else {\n+                incorrect_type.push(\"target-endian\".to_string())\n+            }\n         }\n+\n         key!(is_builtin, bool);\n         key!(c_int_width = \"target-c-int-width\");\n         key!(os);\n@@ -1876,32 +1931,39 @@ impl Target {\n         // NB: The old name is deprecated, but support for it is retained for\n         // compatibility.\n         for name in [\"abi-blacklist\", \"unsupported-abis\"].iter() {\n-            if let Some(array) = obj.find(name).and_then(Json::as_array) {\n-                for name in array.iter().filter_map(|abi| abi.as_string()) {\n-                    match lookup_abi(name) {\n-                        Some(abi) => {\n-                            if abi.generic() {\n+            if let Some(j) = obj.remove_key(name) {\n+                if let Some(array) = Json::as_array(&j) {\n+                    for name in array.iter().filter_map(|abi| abi.as_string()) {\n+                        match lookup_abi(name) {\n+                            Some(abi) => {\n+                                if abi.generic() {\n+                                    return Err(format!(\n+                                        \"The ABI \\\"{}\\\" is considered to be supported on all \\\n+                                        targets and cannot be marked unsupported\",\n+                                        abi\n+                                    ));\n+                                }\n+\n+                                base.unsupported_abis.push(abi)\n+                            }\n+                            None => {\n                                 return Err(format!(\n-                                    \"The ABI \\\"{}\\\" is considered to be supported on all \\\n-                                    targets and cannot be marked unsupported\",\n-                                    abi\n+                                    \"Unknown ABI \\\"{}\\\" in target specification\",\n+                                    name\n                                 ));\n                             }\n-\n-                            base.unsupported_abis.push(abi)\n-                        }\n-                        None => {\n-                            return Err(format!(\n-                                \"Unknown ABI \\\"{}\\\" in target specification\",\n-                                name\n-                            ));\n                         }\n                     }\n                 }\n             }\n         }\n \n-        Ok(base)\n+        // Each field should have been read using `Json::remove_key` so any keys remaining are unused.\n+        let remaining_keys = obj.as_object().ok_or(\"Expected JSON object for target\")?.keys();\n+        Ok((\n+            base,\n+            TargetWarnings { unused_fields: remaining_keys.cloned().collect(), incorrect_type },\n+        ))\n     }\n \n     /// Search for a JSON file specifying the given target triple.\n@@ -1913,12 +1975,15 @@ impl Target {\n     ///\n     /// The error string could come from any of the APIs called, including filesystem access and\n     /// JSON decoding.\n-    pub fn search(target_triple: &TargetTriple, sysroot: &PathBuf) -> Result<Target, String> {\n+    pub fn search(\n+        target_triple: &TargetTriple,\n+        sysroot: &PathBuf,\n+    ) -> Result<(Target, TargetWarnings), String> {\n         use rustc_serialize::json;\n         use std::env;\n         use std::fs;\n \n-        fn load_file(path: &Path) -> Result<Target, String> {\n+        fn load_file(path: &Path) -> Result<(Target, TargetWarnings), String> {\n             let contents = fs::read(path).map_err(|e| e.to_string())?;\n             let obj = json::from_reader(&mut &contents[..]).map_err(|e| e.to_string())?;\n             Target::from_json(obj)\n@@ -1928,7 +1993,7 @@ impl Target {\n             TargetTriple::TargetTriple(ref target_triple) => {\n                 // check if triple is in list of built-in targets\n                 if let Some(t) = load_builtin(target_triple) {\n-                    return Ok(t);\n+                    return Ok((t, TargetWarnings::empty()));\n                 }\n \n                 // search for a file named `target_triple`.json in RUST_TARGET_PATH"}, {"sha": "6730319dcfae24bdffee5968fc43c36bebd8bd60", "filename": "compiler/rustc_target/src/spec/tests/tests_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88b01f1178a86e22742103e8e1f385163e844fbd/compiler%2Frustc_target%2Fsrc%2Fspec%2Ftests%2Ftests_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b01f1178a86e22742103e8e1f385163e844fbd/compiler%2Frustc_target%2Fsrc%2Fspec%2Ftests%2Ftests_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Ftests%2Ftests_impl.rs?ref=88b01f1178a86e22742103e8e1f385163e844fbd", "patch": "@@ -3,7 +3,7 @@ use super::super::*;\n // Test target self-consistency and JSON encoding/decoding roundtrip.\n pub(super) fn test_target(target: Target) {\n     target.check_consistency();\n-    assert_eq!(Target::from_json(target.to_json()), Ok(target));\n+    assert_eq!(Target::from_json(target.to_json()).map(|(j, _)| j), Ok(target));\n }\n \n impl Target {"}, {"sha": "3a737b3355a68825bbf59d431f6198119d803497", "filename": "compiler/rustc_target/src/tests.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/88b01f1178a86e22742103e8e1f385163e844fbd/compiler%2Frustc_target%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b01f1178a86e22742103e8e1f385163e844fbd/compiler%2Frustc_target%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Ftests.rs?ref=88b01f1178a86e22742103e8e1f385163e844fbd", "patch": "@@ -0,0 +1,59 @@\n+use crate::spec::Target;\n+use rustc_serialize::json::Json;\n+use std::str::FromStr;\n+\n+#[test]\n+fn report_unused_fields() {\n+    let json = Json::from_str(\n+        r#\"\n+    {\n+        \"arch\": \"powerpc64\",\n+        \"data-layout\": \"e-m:e-i64:64-n32:64\",\n+        \"llvm-target\": \"powerpc64le-elf\",\n+        \"target-pointer-width\": \"64\",\n+        \"code-mode\": \"foo\"\n+    }\n+    \"#,\n+    )\n+    .unwrap();\n+    let warnings = Target::from_json(json).unwrap().1;\n+    assert_eq!(warnings.warning_messages().len(), 1);\n+    assert!(warnings.warning_messages().join(\"\\n\").contains(\"code-mode\"));\n+}\n+\n+#[test]\n+fn report_incorrect_json_type() {\n+    let json = Json::from_str(\n+        r#\"\n+    {\n+        \"arch\": \"powerpc64\",\n+        \"data-layout\": \"e-m:e-i64:64-n32:64\",\n+        \"llvm-target\": \"powerpc64le-elf\",\n+        \"target-pointer-width\": \"64\",\n+        \"link-env-remove\": \"foo\"\n+    }\n+    \"#,\n+    )\n+    .unwrap();\n+    let warnings = Target::from_json(json).unwrap().1;\n+    assert_eq!(warnings.warning_messages().len(), 1);\n+    assert!(warnings.warning_messages().join(\"\\n\").contains(\"link-env-remove\"));\n+}\n+\n+#[test]\n+fn no_warnings_for_valid_target() {\n+    let json = Json::from_str(\n+        r#\"\n+    {\n+        \"arch\": \"powerpc64\",\n+        \"data-layout\": \"e-m:e-i64:64-n32:64\",\n+        \"llvm-target\": \"powerpc64le-elf\",\n+        \"target-pointer-width\": \"64\",\n+        \"link-env-remove\": [\"foo\"]\n+    }\n+    \"#,\n+    )\n+    .unwrap();\n+    let warnings = Target::from_json(json).unwrap().1;\n+    assert_eq!(warnings.warning_messages().len(), 0);\n+}"}]}