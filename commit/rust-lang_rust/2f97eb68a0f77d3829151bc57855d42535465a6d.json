{"sha": "2f97eb68a0f77d3829151bc57855d42535465a6d", "node_id": "C_kwDOAAsO6NoAKDJmOTdlYjY4YTBmNzdkMzgyOTE1MWJjNTc4NTVkNDI1MzU0NjVhNmQ", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-03-06T20:26:15Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-03-07T14:40:23Z"}, "message": "implement simd_fmax/fmin", "tree": {"sha": "3bb22683a9e39a6ad662840b9735bbca67c67af5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3bb22683a9e39a6ad662840b9735bbca67c67af5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f97eb68a0f77d3829151bc57855d42535465a6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f97eb68a0f77d3829151bc57855d42535465a6d", "html_url": "https://github.com/rust-lang/rust/commit/2f97eb68a0f77d3829151bc57855d42535465a6d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f97eb68a0f77d3829151bc57855d42535465a6d/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9851b743c1a4a1fdb62579c2c8bb6d6f543a7028", "url": "https://api.github.com/repos/rust-lang/rust/commits/9851b743c1a4a1fdb62579c2c8bb6d6f543a7028", "html_url": "https://github.com/rust-lang/rust/commit/9851b743c1a4a1fdb62579c2c8bb6d6f543a7028"}], "stats": {"total": 162, "additions": 103, "deletions": 59}, "files": [{"sha": "7dc4a000d1e8e3554ffc31750333169391855b01", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 86, "deletions": 53, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/2f97eb68a0f77d3829151bc57855d42535465a6d/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f97eb68a0f77d3829151bc57855d42535465a6d/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=2f97eb68a0f77d3829151bc57855d42535465a6d", "patch": "@@ -371,7 +371,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"simd_lt\"\n             | \"simd_le\"\n             | \"simd_gt\"\n-            | \"simd_ge\" => {\n+            | \"simd_ge\"\n+            | \"simd_fmax\"\n+            | \"simd_fmin\" => {\n                 use mir::BinOp;\n \n                 let &[ref left, ref right] = check_arg_count(args)?;\n@@ -382,50 +384,69 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 assert_eq!(dest_len, left_len);\n                 assert_eq!(dest_len, right_len);\n \n-                let mir_op = match intrinsic_name {\n-                    \"simd_add\" => BinOp::Add,\n-                    \"simd_sub\" => BinOp::Sub,\n-                    \"simd_mul\" => BinOp::Mul,\n-                    \"simd_div\" => BinOp::Div,\n-                    \"simd_rem\" => BinOp::Rem,\n-                    \"simd_shl\" => BinOp::Shl,\n-                    \"simd_shr\" => BinOp::Shr,\n-                    \"simd_and\" => BinOp::BitAnd,\n-                    \"simd_or\" => BinOp::BitOr,\n-                    \"simd_xor\" => BinOp::BitXor,\n-                    \"simd_eq\" => BinOp::Eq,\n-                    \"simd_ne\" => BinOp::Ne,\n-                    \"simd_lt\" => BinOp::Lt,\n-                    \"simd_le\" => BinOp::Le,\n-                    \"simd_gt\" => BinOp::Gt,\n-                    \"simd_ge\" => BinOp::Ge,\n+                enum Op {\n+                    MirOp(BinOp),\n+                    FMax,\n+                    FMin,\n+                }\n+                let which = match intrinsic_name {\n+                    \"simd_add\" => Op::MirOp(BinOp::Add),\n+                    \"simd_sub\" => Op::MirOp(BinOp::Sub),\n+                    \"simd_mul\" => Op::MirOp(BinOp::Mul),\n+                    \"simd_div\" => Op::MirOp(BinOp::Div),\n+                    \"simd_rem\" => Op::MirOp(BinOp::Rem),\n+                    \"simd_shl\" => Op::MirOp(BinOp::Shl),\n+                    \"simd_shr\" => Op::MirOp(BinOp::Shr),\n+                    \"simd_and\" => Op::MirOp(BinOp::BitAnd),\n+                    \"simd_or\" => Op::MirOp(BinOp::BitOr),\n+                    \"simd_xor\" => Op::MirOp(BinOp::BitXor),\n+                    \"simd_eq\" => Op::MirOp(BinOp::Eq),\n+                    \"simd_ne\" => Op::MirOp(BinOp::Ne),\n+                    \"simd_lt\" => Op::MirOp(BinOp::Lt),\n+                    \"simd_le\" => Op::MirOp(BinOp::Le),\n+                    \"simd_gt\" => Op::MirOp(BinOp::Gt),\n+                    \"simd_ge\" => Op::MirOp(BinOp::Ge),\n+                    \"simd_fmax\" => Op::FMax,\n+                    \"simd_fmin\" => Op::FMin,\n                     _ => unreachable!(),\n                 };\n \n                 for i in 0..dest_len {\n                     let left = this.read_immediate(&this.mplace_index(&left, i)?.into())?;\n                     let right = this.read_immediate(&this.mplace_index(&right, i)?.into())?;\n                     let dest = this.mplace_index(&dest, i)?;\n-                    let (val, overflowed, ty) = this.overflowing_binary_op(mir_op, &left, &right)?;\n-                    if matches!(mir_op, BinOp::Shl | BinOp::Shr) {\n-                        // Shifts have extra UB as SIMD operations that the MIR binop does not have.\n-                        // See <https://github.com/rust-lang/rust/issues/91237>.\n-                        if overflowed {\n-                            let r_val = right.to_scalar()?.to_bits(right.layout.size)?;\n-                            throw_ub_format!(\"overflowing shift by {} in `{}` in SIMD lane {}\", r_val, intrinsic_name, i);\n+                    let val = match which {\n+                        Op::MirOp(mir_op) => {\n+                            let (val, overflowed, ty) = this.overflowing_binary_op(mir_op, &left, &right)?;\n+                            if matches!(mir_op, BinOp::Shl | BinOp::Shr) {\n+                                // Shifts have extra UB as SIMD operations that the MIR binop does not have.\n+                                // See <https://github.com/rust-lang/rust/issues/91237>.\n+                                if overflowed {\n+                                    let r_val = right.to_scalar()?.to_bits(right.layout.size)?;\n+                                    throw_ub_format!(\"overflowing shift by {} in `{}` in SIMD lane {}\", r_val, intrinsic_name, i);\n+                                }\n+                            }\n+                            if matches!(mir_op, BinOp::Eq | BinOp::Ne | BinOp::Lt | BinOp::Le | BinOp::Gt | BinOp::Ge) {\n+                                // Special handling for boolean-returning operations\n+                                assert_eq!(ty, this.tcx.types.bool);\n+                                let val = val.to_bool().unwrap();\n+                                bool_to_simd_element(val, dest.layout.size)\n+                            } else {\n+                                assert_ne!(ty, this.tcx.types.bool);\n+                                assert_eq!(ty, dest.layout.ty);\n+                                val\n+                            }\n+                        }\n+                        Op::FMax => {\n+                            assert!(matches!(dest.layout.ty.kind(), ty::Float(_)));\n+                            this.max_op(&left, &right)?.to_scalar()?\n                         }\n-                    }\n-                    if matches!(mir_op, BinOp::Eq | BinOp::Ne | BinOp::Lt | BinOp::Le | BinOp::Gt | BinOp::Ge) {\n-                        // Special handling for boolean-returning operations\n-                        assert_eq!(ty, this.tcx.types.bool);\n-                        let val = val.to_bool().unwrap();\n-                        let val = bool_to_simd_element(val, dest.layout.size);\n-                        this.write_scalar(val, &dest.into())?;\n-                    } else {\n-                        assert_ne!(ty, this.tcx.types.bool);\n-                        assert_eq!(ty, dest.layout.ty);\n-                        this.write_scalar(val, &dest.into())?;\n-                    }\n+                        Op::FMin => {\n+                            assert!(matches!(dest.layout.ty.kind(), ty::Float(_)));\n+                            this.min_op(&left, &right)?.to_scalar()?\n+                        }\n+                    };\n+                    this.write_scalar(val, &dest.into())?;\n                 }\n             }\n             #[rustfmt::skip]\n@@ -478,24 +499,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                             this.binary_op(mir_op, &res, &op)?\n                         }\n                         Op::Max => {\n-                            // if `op > res`...\n-                            if this.binary_op(BinOp::Gt, &op, &res)?.to_scalar()?.to_bool()? {\n-                                // update accumulator\n-                                op\n-                            } else {\n-                                // no change\n-                                res\n-                            }\n+                            this.max_op(&res, &op)?\n                         }\n                         Op::Min => {\n-                            // if `op < res`...\n-                            if this.binary_op(BinOp::Lt, &op, &res)?.to_scalar()?.to_bool()? {\n-                                // update accumulator\n-                                op\n-                            } else {\n-                                // no change\n-                                res\n-                            }\n+                            this.min_op(&res, &op)?\n                         }\n                     };\n                 }\n@@ -1071,4 +1078,30 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             _ => bug!(\"`float_to_int_unchecked` called with non-int output type {:?}\", dest_ty),\n         })\n     }\n+\n+    fn max_op(\n+        &self,\n+        left: &ImmTy<'tcx, Tag>,\n+        right: &ImmTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, Tag>> {\n+        let this = self.eval_context_ref();\n+        Ok(if this.binary_op(BinOp::Gt, left, right)?.to_scalar()?.to_bool()? {\n+            *left\n+        } else {\n+            *right\n+        })\n+    }\n+\n+    fn min_op(\n+        &self,\n+        left: &ImmTy<'tcx, Tag>,\n+        right: &ImmTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, Tag>> {\n+        let this = self.eval_context_ref();\n+        Ok(if this.binary_op(BinOp::Lt, left, right)?.to_scalar()?.to_bool()? {\n+            *left\n+        } else {\n+            *right\n+        })\n+    }\n }"}, {"sha": "817d18a45d4b73eae9bb6ff470581e942cf2f50d", "filename": "tests/run-pass/portable-simd.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2f97eb68a0f77d3829151bc57855d42535465a6d/tests%2Frun-pass%2Fportable-simd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f97eb68a0f77d3829151bc57855d42535465a6d/tests%2Frun-pass%2Fportable-simd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fportable-simd.rs?ref=2f97eb68a0f77d3829151bc57855d42535465a6d", "patch": "@@ -12,6 +12,8 @@ fn simd_ops_f32() {\n     assert_eq!(a / f32x4::splat(2.0), f32x4::splat(5.0));\n     assert_eq!(a % b, f32x4::from_array([0.0, 0.0, 1.0, 2.0]));\n     assert_eq!(b.abs(), f32x4::from_array([1.0, 2.0, 3.0, 4.0]));\n+    assert_eq!(a.max(b * f32x4::splat(4.0)), f32x4::from_array([10.0, 10.0, 12.0, 10.0]));\n+    assert_eq!(a.min(b * f32x4::splat(4.0)), f32x4::from_array([4.0, 8.0, 10.0, -16.0]));\n \n     assert_eq!(a.lanes_eq(f32x4::splat(5.0) * b), Mask::from_array([false, true, false, false]));\n     assert_eq!(a.lanes_ne(f32x4::splat(5.0) * b), Mask::from_array([true, false, true, true]));\n@@ -41,6 +43,8 @@ fn simd_ops_f64() {\n     assert_eq!(a / f64x4::splat(2.0), f64x4::splat(5.0));\n     assert_eq!(a % b, f64x4::from_array([0.0, 0.0, 1.0, 2.0]));\n     assert_eq!(b.abs(), f64x4::from_array([1.0, 2.0, 3.0, 4.0]));\n+    assert_eq!(a.max(b * f64x4::splat(4.0)), f64x4::from_array([10.0, 10.0, 12.0, 10.0]));\n+    assert_eq!(a.min(b * f64x4::splat(4.0)), f64x4::from_array([4.0, 8.0, 10.0, -16.0]));\n \n     assert_eq!(a.lanes_eq(f64x4::splat(5.0) * b), Mask::from_array([false, true, false, false]));\n     assert_eq!(a.lanes_ne(f64x4::splat(5.0) * b), Mask::from_array([true, false, true, true]));\n@@ -71,6 +75,12 @@ fn simd_ops_i32() {\n     assert_eq!(i32x2::splat(i32::MIN) / i32x2::splat(-1), i32x2::splat(i32::MIN));\n     assert_eq!(a % b, i32x4::from_array([0, 0, 1, 2]));\n     assert_eq!(i32x2::splat(i32::MIN) % i32x2::splat(-1), i32x2::splat(0));\n+    assert_eq!(b.abs(), i32x4::from_array([1, 2, 3, 4]));\n+    // FIXME not a per-lane method (https://github.com/rust-lang/rust/issues/94682)\n+    // assert_eq!(a.max(b * i32x4::splat(4)), i32x4::from_array([10, 10, 12, 10]));\n+    // assert_eq!(a.min(b * i32x4::splat(4)), i32x4::from_array([4, 8, 10, -16]));\n+\n+    assert_eq!(!b, i32x4::from_array([!1, !2, !3, !-4]));\n     assert_eq!(b << i32x4::splat(2), i32x4::from_array([4, 8, 12, -16]));\n     assert_eq!(b >> i32x4::splat(1), i32x4::from_array([0, 1, 1, -2]));\n     assert_eq!(b & i32x4::splat(2), i32x4::from_array([0, 2, 2, 0]));\n@@ -84,12 +94,6 @@ fn simd_ops_i32() {\n     assert_eq!(a.lanes_ge(i32x4::splat(5) * b), Mask::from_array([true, true, false, true]));\n     assert_eq!(a.lanes_gt(i32x4::splat(5) * b), Mask::from_array([true, false, false, true]));\n \n-    assert_eq!(a.horizontal_and(), 10);\n-    assert_eq!(b.horizontal_and(), 0);\n-    assert_eq!(a.horizontal_or(), 10);\n-    assert_eq!(b.horizontal_or(), -1);\n-    assert_eq!(a.horizontal_xor(), 0);\n-    assert_eq!(b.horizontal_xor(), -4);\n     assert_eq!(a.horizontal_sum(), 40);\n     assert_eq!(b.horizontal_sum(), 2);\n     assert_eq!(a.horizontal_product(), 100 * 100);\n@@ -98,6 +102,13 @@ fn simd_ops_i32() {\n     assert_eq!(b.horizontal_max(), 3);\n     assert_eq!(a.horizontal_min(), 10);\n     assert_eq!(b.horizontal_min(), -4);\n+\n+    assert_eq!(a.horizontal_and(), 10);\n+    assert_eq!(b.horizontal_and(), 0);\n+    assert_eq!(a.horizontal_or(), 10);\n+    assert_eq!(b.horizontal_or(), -1);\n+    assert_eq!(a.horizontal_xor(), 0);\n+    assert_eq!(b.horizontal_xor(), -4);\n }\n \n fn simd_mask() {"}]}