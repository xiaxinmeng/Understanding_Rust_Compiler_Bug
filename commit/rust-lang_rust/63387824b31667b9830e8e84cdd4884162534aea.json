{"sha": "63387824b31667b9830e8e84cdd4884162534aea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzMzg3ODI0YjMxNjY3Yjk4MzBlOGU4NGNkZDQ4ODQxNjI1MzRhZWE=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-09-29T22:10:31Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-09-29T23:05:45Z"}, "message": "Avoid using to_expr as much as possible", "tree": {"sha": "5b40548e687893951a355b868d8bae16d8587b74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b40548e687893951a355b868d8bae16d8587b74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63387824b31667b9830e8e84cdd4884162534aea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63387824b31667b9830e8e84cdd4884162534aea", "html_url": "https://github.com/rust-lang/rust/commit/63387824b31667b9830e8e84cdd4884162534aea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63387824b31667b9830e8e84cdd4884162534aea/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c302409f56d0d08948d5e23d336818553b26a322", "url": "https://api.github.com/repos/rust-lang/rust/commits/c302409f56d0d08948d5e23d336818553b26a322", "html_url": "https://github.com/rust-lang/rust/commit/c302409f56d0d08948d5e23d336818553b26a322"}], "stats": {"total": 92, "additions": 54, "deletions": 38}, "files": [{"sha": "bde08931d18e0aae2d93fbd6cdff86d87ddda19e", "filename": "src/closures.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/63387824b31667b9830e8e84cdd4884162534aea/src%2Fclosures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63387824b31667b9830e8e84cdd4884162534aea/src%2Fclosures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fclosures.rs?ref=63387824b31667b9830e8e84cdd4884162534aea", "patch": "@@ -361,13 +361,10 @@ pub fn rewrite_last_closure(\n /// Returns true if the given vector of arguments has more than one `ast::ExprKind::Closure`.\n pub fn args_have_many_closure(args: &[OverflowableItem]) -> bool {\n     args.iter()\n-        .filter(|arg| {\n-            arg.to_expr()\n-                .map(|e| match e.node {\n-                    ast::ExprKind::Closure(..) => true,\n-                    _ => false,\n-                })\n-                .unwrap_or(false)\n+        .filter_map(|arg| arg.to_expr())\n+        .filter(|expr| match expr.node {\n+            ast::ExprKind::Closure(..) => true,\n+            _ => false,\n         })\n         .count()\n         > 1"}, {"sha": "06c9d3559064f9953186452099f77a6904b04e7b", "filename": "src/expr.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63387824b31667b9830e8e84cdd4884162534aea/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63387824b31667b9830e8e84cdd4884162534aea/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=63387824b31667b9830e8e84cdd4884162534aea", "patch": "@@ -1337,7 +1337,7 @@ pub fn rewrite_call(\n     )\n }\n \n-fn is_simple_expr(expr: &ast::Expr) -> bool {\n+pub fn is_simple_expr(expr: &ast::Expr) -> bool {\n     match expr.node {\n         ast::ExprKind::Lit(..) => true,\n         ast::ExprKind::Path(ref qself, ref path) => qself.is_none() && path.segments.len() <= 1,\n@@ -1356,9 +1356,7 @@ fn is_simple_expr(expr: &ast::Expr) -> bool {\n }\n \n pub fn is_every_expr_simple(lists: &[OverflowableItem]) -> bool {\n-    lists\n-        .iter()\n-        .all(|arg| arg.to_expr().map_or(false, is_simple_expr))\n+    lists.iter().all(OverflowableItem::is_simple)\n }\n \n pub fn can_be_overflowed_expr(context: &RewriteContext, expr: &ast::Expr, args_len: usize) -> bool {"}, {"sha": "22b07fbc1782ffea09eae191b09e6101039d309e", "filename": "src/overflow.rs", "status": "modified", "additions": 48, "deletions": 27, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/63387824b31667b9830e8e84cdd4884162534aea/src%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63387824b31667b9830e8e84cdd4884162534aea/src%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foverflow.rs?ref=63387824b31667b9830e8e84cdd4884162534aea", "patch": "@@ -17,7 +17,7 @@ use syntax::{ast, ptr};\n \n use closures;\n use expr::{\n-    can_be_overflowed_expr, is_every_expr_simple, is_method_call, is_nested_call,\n+    can_be_overflowed_expr, is_every_expr_simple, is_method_call, is_nested_call, is_simple_expr,\n     maybe_get_args_offset,\n };\n use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, ListItem, Separator};\n@@ -70,6 +70,30 @@ impl<'a> OverflowableItem<'a> {\n         }\n     }\n \n+    pub fn is_simple(&self) -> bool {\n+        match self {\n+            OverflowableItem::Expr(expr) => is_simple_expr(expr),\n+            OverflowableItem::MacroArg(MacroArg::Expr(expr)) => is_simple_expr(expr),\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_expr(&self) -> bool {\n+        match self {\n+            OverflowableItem::Expr(..) => true,\n+            OverflowableItem::MacroArg(MacroArg::Expr(..)) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_nested_call(&self) -> bool {\n+        match self {\n+            OverflowableItem::Expr(expr) => is_nested_call(expr),\n+            OverflowableItem::MacroArg(MacroArg::Expr(expr)) => is_nested_call(expr),\n+            _ => false,\n+        }\n+    }\n+\n     pub fn to_expr(&self) -> Option<&'a ast::Expr> {\n         match self {\n             OverflowableItem::Expr(expr) => Some(expr),\n@@ -303,23 +327,24 @@ impl<'a> Context<'a> {\n         shape: Shape,\n     ) -> Option<String> {\n         let last_item = self.last_item()?;\n-        let rewrite = if let Some(expr) = last_item.to_expr() {\n-            match expr.node {\n-                // When overflowing the closure which consists of a single control flow expression,\n-                // force to use block if its condition uses multi line.\n-                ast::ExprKind::Closure(..) => {\n-                    // If the argument consists of multiple closures, we do not overflow\n-                    // the last closure.\n-                    if closures::args_have_many_closure(&self.items) {\n-                        None\n-                    } else {\n-                        closures::rewrite_last_closure(self.context, expr, shape)\n+        let rewrite = match last_item {\n+            OverflowableItem::Expr(ref expr) => {\n+                match expr.node {\n+                    // When overflowing the closure which consists of a single control flow\n+                    // expression, force to use block if its condition uses multi line.\n+                    ast::ExprKind::Closure(..) => {\n+                        // If the argument consists of multiple closures, we do not overflow\n+                        // the last closure.\n+                        if closures::args_have_many_closure(&self.items) {\n+                            None\n+                        } else {\n+                            closures::rewrite_last_closure(self.context, expr, shape)\n+                        }\n                     }\n+                    _ => expr.rewrite(self.context, shape),\n                 }\n-                _ => expr.rewrite(self.context, shape),\n             }\n-        } else {\n-            last_item.rewrite(self.context, shape)\n+            item @ _ => item.rewrite(self.context, shape),\n         };\n \n         if let Some(rewrite) = rewrite {\n@@ -343,20 +368,21 @@ impl<'a> Context<'a> {\n     fn try_overflow_last_item(&self, list_items: &mut Vec<ListItem>) -> DefinitiveListTactic {\n         // 1 = \"(\"\n         let combine_arg_with_callee = self.items.len() == 1\n-            && self.items[0].to_expr().is_some()\n+            && self.items[0].is_expr()\n             && self.ident.len() < self.context.config.tab_spaces();\n         let overflow_last = combine_arg_with_callee || can_be_overflowed(self.context, &self.items);\n \n         // Replace the last item with its first line to see if it fits with\n         // first arguments.\n         let placeholder = if overflow_last {\n             let old_value = *self.context.force_one_line_chain.borrow();\n-            if !combine_arg_with_callee {\n-                if let Some(ref expr) = self.last_item().and_then(|item| item.to_expr()) {\n-                    if is_method_call(expr) {\n-                        self.context.force_one_line_chain.replace(true);\n-                    }\n+            match self.last_item() {\n+                Some(OverflowableItem::Expr(expr))\n+                    if !combine_arg_with_callee && is_method_call(expr) =>\n+                {\n+                    self.context.force_one_line_chain.replace(true);\n                 }\n+                _ => (),\n             }\n             let result = last_item_shape(\n                 &self.items,\n@@ -596,12 +622,7 @@ fn last_item_shape(\n     shape: Shape,\n     args_max_width: usize,\n ) -> Option<Shape> {\n-    let is_nested_call = lists\n-        .iter()\n-        .next()\n-        .and_then(|item| item.to_expr())\n-        .map_or(false, is_nested_call);\n-    if items.len() == 1 && !is_nested_call {\n+    if items.len() == 1 && !lists.iter().next()?.is_nested_call() {\n         return Some(shape);\n     }\n     let offset = items.iter().rev().skip(1).fold(0, |acc, i| {"}]}