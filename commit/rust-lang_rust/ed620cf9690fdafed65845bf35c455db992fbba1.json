{"sha": "ed620cf9690fdafed65845bf35c455db992fbba1", "node_id": "C_kwDOAAsO6NoAKGVkNjIwY2Y5NjkwZmRhZmVkNjU4NDViZjM1YzQ1NWRiOTkyZmJiYTE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-13T13:09:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-13T13:09:40Z"}, "message": "Auto merge of #105612 - oli-obk:bind_rustdoc, r=GuillaumeGomez\n\nuse ty::Binder in rustdoc instead of `skip_binder`\n\nr? `@GuillaumeGomez`\n\nthis is a preliminary cleanup required to be able to normalize correctly/conveniently in rustdoc", "tree": {"sha": "2207ed09adb1647b55a716a4e02e37f140560ac9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2207ed09adb1647b55a716a4e02e37f140560ac9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed620cf9690fdafed65845bf35c455db992fbba1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed620cf9690fdafed65845bf35c455db992fbba1", "html_url": "https://github.com/rust-lang/rust/commit/ed620cf9690fdafed65845bf35c455db992fbba1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed620cf9690fdafed65845bf35c455db992fbba1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "109cccbe4f345c0f0785ce860788580c3e2a29f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/109cccbe4f345c0f0785ce860788580c3e2a29f5", "html_url": "https://github.com/rust-lang/rust/commit/109cccbe4f345c0f0785ce860788580c3e2a29f5"}, {"sha": "30754517d1e979bd4100207f1cc7202ed25d9ff5", "url": "https://api.github.com/repos/rust-lang/rust/commits/30754517d1e979bd4100207f1cc7202ed25d9ff5", "html_url": "https://github.com/rust-lang/rust/commit/30754517d1e979bd4100207f1cc7202ed25d9ff5"}], "stats": {"total": 276, "additions": 174, "deletions": 102}, "files": [{"sha": "9b9c26d6a8b1b15927f0b66495f1b74c9e1e9b8c", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ed620cf9690fdafed65845bf35c455db992fbba1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed620cf9690fdafed65845bf35c455db992fbba1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=ed620cf9690fdafed65845bf35c455db992fbba1", "patch": "@@ -980,8 +980,12 @@ where\n     /// contain any bound vars that would be bound by the\n     /// binder. This is commonly used to 'inject' a value T into a\n     /// different binding level.\n+    #[track_caller]\n     pub fn dummy(value: T) -> Binder<'tcx, T> {\n-        assert!(!value.has_escaping_bound_vars());\n+        assert!(\n+            !value.has_escaping_bound_vars(),\n+            \"`{value:?}` has escaping bound vars, so it cannot be wrapped in a dummy binder.\"\n+        );\n         Binder(value, ty::List::empty())\n     }\n \n@@ -1128,6 +1132,13 @@ impl<'tcx, T> Binder<'tcx, Option<T>> {\n     }\n }\n \n+impl<'tcx, T: IntoIterator> Binder<'tcx, T> {\n+    pub fn iter(self) -> impl Iterator<Item = ty::Binder<'tcx, T::Item>> {\n+        let bound_vars = self.1;\n+        self.0.into_iter().map(|v| Binder(v, bound_vars))\n+    }\n+}\n+\n /// Represents the projection of an associated type. In explicit UFCS\n /// form this would be written `<T as Trait<..>>::N`.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]"}, {"sha": "4d6f1524732f77453e2ce2489cd3eee1b6f848e8", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed620cf9690fdafed65845bf35c455db992fbba1/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed620cf9690fdafed65845bf35c455db992fbba1/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=ed620cf9690fdafed65845bf35c455db992fbba1", "patch": "@@ -44,7 +44,7 @@ where\n         discard_positive_impl: bool,\n     ) -> Option<Item> {\n         let tcx = self.cx.tcx;\n-        let trait_ref = tcx.mk_trait_ref(trait_def_id, [ty]);\n+        let trait_ref = ty::Binder::dummy(tcx.mk_trait_ref(trait_def_id, [ty]));\n         if !self.cx.generated_synthetics.insert((ty, trait_def_id)) {\n             debug!(\"get_auto_trait_impl_for({:?}): already generated, aborting\", trait_ref);\n             return None;\n@@ -124,7 +124,7 @@ where\n                 unsafety: hir::Unsafety::Normal,\n                 generics: new_generics,\n                 trait_: Some(clean_trait_ref_with_bindings(self.cx, trait_ref, ThinVec::new())),\n-                for_: clean_middle_ty(ty, self.cx, None),\n+                for_: clean_middle_ty(ty::Binder::dummy(ty), self.cx, None),\n                 items: Vec::new(),\n                 polarity,\n                 kind: ImplKind::Auto,"}, {"sha": "4ef5747596bb39a7d4900a393c216f84626f3447", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed620cf9690fdafed65845bf35c455db992fbba1/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed620cf9690fdafed65845bf35c455db992fbba1/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=ed620cf9690fdafed65845bf35c455db992fbba1", "patch": "@@ -105,10 +105,10 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                         // the post-inference `trait_ref`, as it's more accurate.\n                         trait_: Some(clean_trait_ref_with_bindings(\n                             cx,\n-                            trait_ref.0,\n+                            ty::Binder::dummy(trait_ref.0),\n                             ThinVec::new(),\n                         )),\n-                        for_: clean_middle_ty(ty.0, cx, None),\n+                        for_: clean_middle_ty(ty::Binder::dummy(ty.0), cx, None),\n                         items: cx\n                             .tcx\n                             .associated_items(impl_def_id)\n@@ -117,7 +117,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                             .collect::<Vec<_>>(),\n                         polarity: ty::ImplPolarity::Positive,\n                         kind: ImplKind::Blanket(Box::new(clean_middle_ty(\n-                            trait_ref.0.self_ty(),\n+                            ty::Binder::dummy(trait_ref.0.self_ty()),\n                             cx,\n                             None,\n                         ))),"}, {"sha": "50caef3553fdaf5f47d8e2248762494b06229750", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ed620cf9690fdafed65845bf35c455db992fbba1/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed620cf9690fdafed65845bf35c455db992fbba1/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=ed620cf9690fdafed65845bf35c455db992fbba1", "patch": "@@ -293,7 +293,7 @@ fn build_union(cx: &mut DocContext<'_>, did: DefId) -> clean::Union {\n \n fn build_type_alias(cx: &mut DocContext<'_>, did: DefId) -> Box<clean::Typedef> {\n     let predicates = cx.tcx.explicit_predicates_of(did);\n-    let type_ = clean_middle_ty(cx.tcx.type_of(did), cx, Some(did));\n+    let type_ = clean_middle_ty(ty::Binder::dummy(cx.tcx.type_of(did)), cx, Some(did));\n \n     Box::new(clean::Typedef {\n         type_,\n@@ -405,7 +405,7 @@ pub(crate) fn build_impl(\n \n     let for_ = match &impl_item {\n         Some(impl_) => clean_ty(impl_.self_ty, cx),\n-        None => clean_middle_ty(tcx.type_of(did), cx, Some(did)),\n+        None => clean_middle_ty(ty::Binder::dummy(tcx.type_of(did)), cx, Some(did)),\n     };\n \n     // Only inline impl if the implementing type is\n@@ -496,7 +496,8 @@ pub(crate) fn build_impl(\n         ),\n     };\n     let polarity = tcx.impl_polarity(did);\n-    let trait_ = associated_trait.map(|t| clean_trait_ref_with_bindings(cx, t, ThinVec::new()));\n+    let trait_ = associated_trait\n+        .map(|t| clean_trait_ref_with_bindings(cx, ty::Binder::dummy(t), ThinVec::new()));\n     if trait_.as_ref().map(|t| t.def_id()) == tcx.lang_items().deref_trait() {\n         super::build_deref_target_impls(cx, &trait_items, ret);\n     }\n@@ -640,14 +641,14 @@ pub(crate) fn print_inlined_const(tcx: TyCtxt<'_>, did: DefId) -> String {\n \n fn build_const(cx: &mut DocContext<'_>, def_id: DefId) -> clean::Constant {\n     clean::Constant {\n-        type_: clean_middle_ty(cx.tcx.type_of(def_id), cx, Some(def_id)),\n+        type_: clean_middle_ty(ty::Binder::dummy(cx.tcx.type_of(def_id)), cx, Some(def_id)),\n         kind: clean::ConstantKind::Extern { def_id },\n     }\n }\n \n fn build_static(cx: &mut DocContext<'_>, did: DefId, mutable: bool) -> clean::Static {\n     clean::Static {\n-        type_: clean_middle_ty(cx.tcx.type_of(did), cx, Some(did)),\n+        type_: clean_middle_ty(ty::Binder::dummy(cx.tcx.type_of(did)), cx, Some(did)),\n         mutability: if mutable { Mutability::Mut } else { Mutability::Not },\n         expr: None,\n     }"}, {"sha": "c6ab8e1a83bef786d0167c204065dccb6275951b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 127, "deletions": 80, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/ed620cf9690fdafed65845bf35c455db992fbba1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed620cf9690fdafed65845bf35c455db992fbba1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ed620cf9690fdafed65845bf35c455db992fbba1", "patch": "@@ -22,6 +22,7 @@ use rustc_infer::infer::region_constraints::{Constraint, RegionConstraintData};\n use rustc_middle::middle::resolve_lifetime as rl;\n use rustc_middle::ty::fold::TypeFolder;\n use rustc_middle::ty::InternalSubsts;\n+use rustc_middle::ty::TypeVisitable;\n use rustc_middle::ty::{self, AdtKind, DefIdTree, EarlyBinder, Ty, TyCtxt};\n use rustc_middle::{bug, span_bug};\n use rustc_span::hygiene::{AstPass, MacroKind};\n@@ -127,7 +128,7 @@ fn clean_generic_bound<'tcx>(\n         hir::GenericBound::LangItemTrait(lang_item, span, _, generic_args) => {\n             let def_id = cx.tcx.require_lang_item(lang_item, Some(span));\n \n-            let trait_ref = ty::TraitRef::identity(cx.tcx, def_id).skip_binder();\n+            let trait_ref = ty::TraitRef::identity(cx.tcx, def_id);\n \n             let generic_args = clean_generic_args(generic_args, cx);\n             let GenericArgs::AngleBracketed { bindings, .. } = generic_args\n@@ -156,17 +157,18 @@ fn clean_generic_bound<'tcx>(\n \n pub(crate) fn clean_trait_ref_with_bindings<'tcx>(\n     cx: &mut DocContext<'tcx>,\n-    trait_ref: ty::TraitRef<'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n     bindings: ThinVec<TypeBinding>,\n ) -> Path {\n-    let kind = cx.tcx.def_kind(trait_ref.def_id).into();\n+    let kind = cx.tcx.def_kind(trait_ref.def_id()).into();\n     if !matches!(kind, ItemType::Trait | ItemType::TraitAlias) {\n-        span_bug!(cx.tcx.def_span(trait_ref.def_id), \"`TraitRef` had unexpected kind {:?}\", kind);\n+        span_bug!(cx.tcx.def_span(trait_ref.def_id()), \"`TraitRef` had unexpected kind {:?}\", kind);\n     }\n-    inline::record_extern_fqn(cx, trait_ref.def_id, kind);\n-    let path = external_path(cx, trait_ref.def_id, true, bindings, trait_ref.substs);\n+    inline::record_extern_fqn(cx, trait_ref.def_id(), kind);\n+    let path =\n+        external_path(cx, trait_ref.def_id(), true, bindings, trait_ref.map_bound(|tr| tr.substs));\n \n-    debug!(\"ty::TraitRef\\n  subst: {:?}\\n\", trait_ref.substs);\n+    debug!(?trait_ref);\n \n     path\n }\n@@ -187,7 +189,7 @@ fn clean_poly_trait_ref_with_bindings<'tcx>(\n         })\n         .collect();\n \n-    let trait_ = clean_trait_ref_with_bindings(cx, poly_trait_ref.skip_binder(), bindings);\n+    let trait_ = clean_trait_ref_with_bindings(cx, poly_trait_ref, bindings);\n     GenericBound::TraitBound(\n         PolyTrait { trait_, generic_params: late_bound_regions },\n         hir::TraitBoundModifier::None,\n@@ -212,19 +214,19 @@ fn clean_lifetime<'tcx>(lifetime: &hir::Lifetime, cx: &mut DocContext<'tcx>) ->\n pub(crate) fn clean_const<'tcx>(constant: &hir::ConstArg, cx: &mut DocContext<'tcx>) -> Constant {\n     let def_id = cx.tcx.hir().body_owner_def_id(constant.value.body).to_def_id();\n     Constant {\n-        type_: clean_middle_ty(cx.tcx.type_of(def_id), cx, Some(def_id)),\n+        type_: clean_middle_ty(ty::Binder::dummy(cx.tcx.type_of(def_id)), cx, Some(def_id)),\n         kind: ConstantKind::Anonymous { body: constant.value.body },\n     }\n }\n \n pub(crate) fn clean_middle_const<'tcx>(\n-    constant: ty::Const<'tcx>,\n+    constant: ty::Binder<'tcx, ty::Const<'tcx>>,\n     cx: &mut DocContext<'tcx>,\n ) -> Constant {\n     // FIXME: instead of storing the stringified expression, store `self` directly instead.\n     Constant {\n-        type_: clean_middle_ty(constant.ty(), cx, None),\n-        kind: ConstantKind::TyConst { expr: constant.to_string().into() },\n+        type_: clean_middle_ty(constant.map_bound(|c| c.ty()), cx, None),\n+        kind: ConstantKind::TyConst { expr: constant.skip_binder().to_string().into() },\n     }\n }\n \n@@ -333,7 +335,7 @@ fn clean_poly_trait_predicate<'tcx>(\n \n     let poly_trait_ref = pred.map_bound(|pred| pred.trait_ref);\n     Some(WherePredicate::BoundPredicate {\n-        ty: clean_middle_ty(poly_trait_ref.skip_binder().self_ty(), cx, None),\n+        ty: clean_middle_ty(poly_trait_ref.self_ty(), cx, None),\n         bounds: vec![clean_poly_trait_ref_with_bindings(cx, poly_trait_ref, ThinVec::new())],\n         bound_params: Vec::new(),\n     })\n@@ -359,18 +361,21 @@ fn clean_type_outlives_predicate<'tcx>(\n     let ty::OutlivesPredicate(ty, lt) = pred;\n \n     Some(WherePredicate::BoundPredicate {\n-        ty: clean_middle_ty(ty, cx, None),\n+        ty: clean_middle_ty(ty::Binder::dummy(ty), cx, None),\n         bounds: vec![GenericBound::Outlives(\n             clean_middle_region(lt).expect(\"failed to clean lifetimes\"),\n         )],\n         bound_params: Vec::new(),\n     })\n }\n \n-fn clean_middle_term<'tcx>(term: ty::Term<'tcx>, cx: &mut DocContext<'tcx>) -> Term {\n-    match term.unpack() {\n-        ty::TermKind::Ty(ty) => Term::Type(clean_middle_ty(ty, cx, None)),\n-        ty::TermKind::Const(c) => Term::Constant(clean_middle_const(c, cx)),\n+fn clean_middle_term<'tcx>(\n+    term: ty::Binder<'tcx, ty::Term<'tcx>>,\n+    cx: &mut DocContext<'tcx>,\n+) -> Term {\n+    match term.skip_binder().unpack() {\n+        ty::TermKind::Ty(ty) => Term::Type(clean_middle_ty(term.rebind(ty), cx, None)),\n+        ty::TermKind::Const(c) => Term::Constant(clean_middle_const(term.rebind(c), cx)),\n     }\n }\n \n@@ -379,7 +384,10 @@ fn clean_hir_term<'tcx>(term: &hir::Term<'tcx>, cx: &mut DocContext<'tcx>) -> Te\n         hir::Term::Ty(ty) => Term::Type(clean_ty(ty, cx)),\n         hir::Term::Const(c) => {\n             let def_id = cx.tcx.hir().local_def_id(c.hir_id);\n-            Term::Constant(clean_middle_const(ty::Const::from_anon_const(cx.tcx, def_id), cx))\n+            Term::Constant(clean_middle_const(\n+                ty::Binder::dummy(ty::Const::from_anon_const(cx.tcx, def_id)),\n+                cx,\n+            ))\n         }\n     }\n }\n@@ -398,32 +406,31 @@ fn clean_projection_predicate<'tcx>(\n         })\n         .collect();\n \n-    let ty::ProjectionPredicate { projection_ty, term } = pred.skip_binder();\n-\n     WherePredicate::EqPredicate {\n-        lhs: Box::new(clean_projection(projection_ty, cx, None)),\n-        rhs: Box::new(clean_middle_term(term, cx)),\n+        lhs: Box::new(clean_projection(pred.map_bound(|p| p.projection_ty), cx, None)),\n+        rhs: Box::new(clean_middle_term(pred.map_bound(|p| p.term), cx)),\n         bound_params: late_bound_regions,\n     }\n }\n \n fn clean_projection<'tcx>(\n-    ty: ty::ProjectionTy<'tcx>,\n+    ty: ty::Binder<'tcx, ty::ProjectionTy<'tcx>>,\n     cx: &mut DocContext<'tcx>,\n     def_id: Option<DefId>,\n ) -> Type {\n-    if cx.tcx.def_kind(ty.item_def_id) == DefKind::ImplTraitPlaceholder {\n+    if cx.tcx.def_kind(ty.skip_binder().item_def_id) == DefKind::ImplTraitPlaceholder {\n         let bounds = cx\n             .tcx\n-            .explicit_item_bounds(ty.item_def_id)\n+            .explicit_item_bounds(ty.skip_binder().item_def_id)\n             .iter()\n-            .map(|(bound, _)| EarlyBinder(*bound).subst(cx.tcx, ty.substs))\n+            .map(|(bound, _)| EarlyBinder(*bound).subst(cx.tcx, ty.skip_binder().substs))\n             .collect::<Vec<_>>();\n         return clean_middle_opaque_bounds(cx, bounds);\n     }\n \n-    let trait_ = clean_trait_ref_with_bindings(cx, ty.trait_ref(cx.tcx), ThinVec::new());\n-    let self_type = clean_middle_ty(ty.self_ty(), cx, None);\n+    let trait_ =\n+        clean_trait_ref_with_bindings(cx, ty.map_bound(|ty| ty.trait_ref(cx.tcx)), ThinVec::new());\n+    let self_type = clean_middle_ty(ty.map_bound(|ty| ty.self_ty()), cx, None);\n     let self_def_id = if let Some(def_id) = def_id {\n         cx.tcx.opt_parent(def_id).or(Some(def_id))\n     } else {\n@@ -446,15 +453,16 @@ fn compute_should_show_cast(self_def_id: Option<DefId>, trait_: &Path, self_type\n }\n \n fn projection_to_path_segment<'tcx>(\n-    ty: ty::ProjectionTy<'tcx>,\n+    ty: ty::Binder<'tcx, ty::ProjectionTy<'tcx>>,\n     cx: &mut DocContext<'tcx>,\n ) -> PathSegment {\n-    let item = cx.tcx.associated_item(ty.item_def_id);\n-    let generics = cx.tcx.generics_of(ty.item_def_id);\n+    let item = cx.tcx.associated_item(ty.skip_binder().item_def_id);\n+    let generics = cx.tcx.generics_of(ty.skip_binder().item_def_id);\n     PathSegment {\n         name: item.name,\n         args: GenericArgs::AngleBracketed {\n-            args: substs_to_args(cx, &ty.substs[generics.parent_count..], false).into(),\n+            args: substs_to_args(cx, ty.map_bound(|ty| &ty.substs[generics.parent_count..]), false)\n+                .into(),\n             bindings: Default::default(),\n         },\n     }\n@@ -470,7 +478,11 @@ fn clean_generic_param_def<'tcx>(\n         }\n         ty::GenericParamDefKind::Type { has_default, synthetic, .. } => {\n             let default = if has_default {\n-                Some(clean_middle_ty(cx.tcx.type_of(def.def_id), cx, Some(def.def_id)))\n+                Some(clean_middle_ty(\n+                    ty::Binder::dummy(cx.tcx.type_of(def.def_id)),\n+                    cx,\n+                    Some(def.def_id),\n+                ))\n             } else {\n                 None\n             };\n@@ -488,7 +500,11 @@ fn clean_generic_param_def<'tcx>(\n             def.name,\n             GenericParamDefKind::Const {\n                 did: def.def_id,\n-                ty: Box::new(clean_middle_ty(cx.tcx.type_of(def.def_id), cx, Some(def.def_id))),\n+                ty: Box::new(clean_middle_ty(\n+                    ty::Binder::dummy(cx.tcx.type_of(def.def_id)),\n+                    cx,\n+                    Some(def.def_id),\n+                )),\n                 default: match has_default {\n                     true => Some(Box::new(cx.tcx.const_param_default(def.def_id).to_string())),\n                     false => None,\n@@ -733,8 +749,10 @@ fn clean_ty_generics<'tcx>(\n         .collect::<ThinVec<GenericParamDef>>();\n \n     // param index -> [(trait DefId, associated type name & generics, type, higher-ranked params)]\n-    let mut impl_trait_proj =\n-        FxHashMap::<u32, Vec<(DefId, PathSegment, Ty<'_>, Vec<GenericParamDef>)>>::default();\n+    let mut impl_trait_proj = FxHashMap::<\n+        u32,\n+        Vec<(DefId, PathSegment, ty::Binder<'_, Ty<'_>>, Vec<GenericParamDef>)>,\n+    >::default();\n \n     let where_predicates = preds\n         .predicates\n@@ -783,8 +801,8 @@ fn clean_ty_generics<'tcx>(\n \n                     let proj = projection.map(|p| {\n                         (\n-                            clean_projection(p.skip_binder().projection_ty, cx, None),\n-                            p.skip_binder().term,\n+                            clean_projection(p.map_bound(|p| p.projection_ty), cx, None),\n+                            p.map_bound(|p| p.term),\n                         )\n                     });\n                     if let Some(((_, trait_did, name), rhs)) = proj\n@@ -795,7 +813,7 @@ fn clean_ty_generics<'tcx>(\n                         impl_trait_proj.entry(param_idx).or_default().push((\n                             trait_did,\n                             name,\n-                            rhs.ty().unwrap(),\n+                            rhs.map_bound(|rhs| rhs.ty().unwrap()),\n                             p.get_bound_params()\n                                 .into_iter()\n                                 .flatten()\n@@ -1066,7 +1084,7 @@ fn clean_fn_decl_from_did_and_sig<'tcx>(\n \n     // We assume all empty tuples are default return type. This theoretically can discard `-> ()`,\n     // but shouldn't change any code meaning.\n-    let output = match clean_middle_ty(sig.skip_binder().output(), cx, None) {\n+    let output = match clean_middle_ty(sig.output(), cx, None) {\n         Type::Tuple(inner) if inner.is_empty() => DefaultReturn,\n         ty => Return(ty),\n     };\n@@ -1076,11 +1094,10 @@ fn clean_fn_decl_from_did_and_sig<'tcx>(\n         c_variadic: sig.skip_binder().c_variadic,\n         inputs: Arguments {\n             values: sig\n-                .skip_binder()\n                 .inputs()\n                 .iter()\n                 .map(|t| Argument {\n-                    type_: clean_middle_ty(*t, cx, None),\n+                    type_: clean_middle_ty(t.map_bound(|t| *t), cx, None),\n                     name: names\n                         .next()\n                         .map(|i| i.name)\n@@ -1134,7 +1151,8 @@ fn clean_trait_item<'tcx>(trait_item: &hir::TraitItem<'tcx>, cx: &mut DocContext\n             hir::TraitItemKind::Type(bounds, Some(default)) => {\n                 let generics = enter_impl_trait(cx, |cx| clean_generics(trait_item.generics, cx));\n                 let bounds = bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect();\n-                let item_type = clean_middle_ty(hir_ty_to_ty(cx.tcx, default), cx, None);\n+                let item_type =\n+                    clean_middle_ty(ty::Binder::dummy(hir_ty_to_ty(cx.tcx, default)), cx, None);\n                 AssocTypeItem(\n                     Box::new(Typedef {\n                         type_: clean_ty(default, cx),\n@@ -1173,7 +1191,8 @@ pub(crate) fn clean_impl_item<'tcx>(\n             hir::ImplItemKind::Type(hir_ty) => {\n                 let type_ = clean_ty(hir_ty, cx);\n                 let generics = clean_generics(impl_.generics, cx);\n-                let item_type = clean_middle_ty(hir_ty_to_ty(cx.tcx, hir_ty), cx, None);\n+                let item_type =\n+                    clean_middle_ty(ty::Binder::dummy(hir_ty_to_ty(cx.tcx, hir_ty)), cx, None);\n                 AssocTypeItem(\n                     Box::new(Typedef { type_, generics, item_type: Some(item_type) }),\n                     Vec::new(),\n@@ -1192,7 +1211,11 @@ pub(crate) fn clean_middle_assoc_item<'tcx>(\n     let tcx = cx.tcx;\n     let kind = match assoc_item.kind {\n         ty::AssocKind::Const => {\n-            let ty = clean_middle_ty(tcx.type_of(assoc_item.def_id), cx, Some(assoc_item.def_id));\n+            let ty = clean_middle_ty(\n+                ty::Binder::dummy(tcx.type_of(assoc_item.def_id)),\n+                cx,\n+                Some(assoc_item.def_id),\n+            );\n \n             let provided = match assoc_item.container {\n                 ty::ImplContainer => true,\n@@ -1375,7 +1398,7 @@ pub(crate) fn clean_middle_assoc_item<'tcx>(\n                     AssocTypeItem(\n                         Box::new(Typedef {\n                             type_: clean_middle_ty(\n-                                tcx.type_of(assoc_item.def_id),\n+                                ty::Binder::dummy(tcx.type_of(assoc_item.def_id)),\n                                 cx,\n                                 Some(assoc_item.def_id),\n                             ),\n@@ -1393,7 +1416,7 @@ pub(crate) fn clean_middle_assoc_item<'tcx>(\n                 AssocTypeItem(\n                     Box::new(Typedef {\n                         type_: clean_middle_ty(\n-                            tcx.type_of(assoc_item.def_id),\n+                            ty::Binder::dummy(tcx.type_of(assoc_item.def_id)),\n                             cx,\n                             Some(assoc_item.def_id),\n                         ),\n@@ -1437,8 +1460,11 @@ fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type\n         hir::QPath::Resolved(Some(qself), p) => {\n             // Try to normalize `<X as Y>::T` to a type\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n-            if let Some(normalized_value) = normalize(cx, ty) {\n-                return clean_middle_ty(normalized_value, cx, None);\n+            // `hir_to_ty` can return projection types with escaping vars for GATs, e.g. `<() as Trait>::Gat<'_>`\n+            if !ty.has_escaping_bound_vars() {\n+                if let Some(normalized_value) = normalize(cx, ty::Binder::dummy(ty)) {\n+                    return clean_middle_ty(normalized_value, cx, None);\n+                }\n             }\n \n             let trait_segments = &p.segments[..p.segments.len() - 1];\n@@ -1465,7 +1491,7 @@ fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type\n                 // Rustdoc handles `ty::Error`s by turning them into `Type::Infer`s.\n                 ty::Error(_) => return Type::Infer,\n                 // Otherwise, this is an inherent associated type.\n-                _ => return clean_middle_ty(ty, cx, None),\n+                _ => return clean_middle_ty(ty::Binder::dummy(ty), cx, None),\n             };\n             let trait_ = clean_path(&hir::Path { span, res, segments: &[] }, cx);\n             register_res(cx, trait_.res);\n@@ -1632,7 +1658,10 @@ pub(crate) fn clean_ty<'tcx>(ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> T\n }\n \n /// Returns `None` if the type could not be normalized\n-fn normalize<'tcx>(cx: &mut DocContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n+fn normalize<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n+    ty: ty::Binder<'tcx, Ty<'tcx>>,\n+) -> Option<ty::Binder<'tcx, Ty<'tcx>>> {\n     // HACK: low-churn fix for #79459 while we wait for a trait normalization fix\n     if !cx.tcx.sess.opts.unstable_opts.normalize_docs {\n         return None;\n@@ -1660,35 +1689,38 @@ fn normalize<'tcx>(cx: &mut DocContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>>\n     }\n }\n \n+#[instrument(level = \"trace\", skip(cx), ret)]\n pub(crate) fn clean_middle_ty<'tcx>(\n-    ty: Ty<'tcx>,\n+    bound_ty: ty::Binder<'tcx, Ty<'tcx>>,\n     cx: &mut DocContext<'tcx>,\n     def_id: Option<DefId>,\n ) -> Type {\n-    trace!(\"cleaning type: {:?}\", ty);\n-    let ty = normalize(cx, ty).unwrap_or(ty);\n-    match *ty.kind() {\n+    let bound_ty = normalize(cx, bound_ty).unwrap_or(bound_ty);\n+    match *bound_ty.skip_binder().kind() {\n         ty::Never => Primitive(PrimitiveType::Never),\n         ty::Bool => Primitive(PrimitiveType::Bool),\n         ty::Char => Primitive(PrimitiveType::Char),\n         ty::Int(int_ty) => Primitive(int_ty.into()),\n         ty::Uint(uint_ty) => Primitive(uint_ty.into()),\n         ty::Float(float_ty) => Primitive(float_ty.into()),\n         ty::Str => Primitive(PrimitiveType::Str),\n-        ty::Slice(ty) => Slice(Box::new(clean_middle_ty(ty, cx, None))),\n+        ty::Slice(ty) => Slice(Box::new(clean_middle_ty(bound_ty.rebind(ty), cx, None))),\n         ty::Array(ty, mut n) => {\n             n = n.eval(cx.tcx, ty::ParamEnv::reveal_all());\n             let n = print_const(cx, n);\n-            Array(Box::new(clean_middle_ty(ty, cx, None)), n.into())\n+            Array(Box::new(clean_middle_ty(bound_ty.rebind(ty), cx, None)), n.into())\n+        }\n+        ty::RawPtr(mt) => {\n+            RawPointer(mt.mutbl, Box::new(clean_middle_ty(bound_ty.rebind(mt.ty), cx, None)))\n         }\n-        ty::RawPtr(mt) => RawPointer(mt.mutbl, Box::new(clean_middle_ty(mt.ty, cx, None))),\n         ty::Ref(r, ty, mutbl) => BorrowedRef {\n             lifetime: clean_middle_region(r),\n             mutability: mutbl,\n-            type_: Box::new(clean_middle_ty(ty, cx, None)),\n+            type_: Box::new(clean_middle_ty(bound_ty.rebind(ty), cx, None)),\n         },\n         ty::FnDef(..) | ty::FnPtr(_) => {\n-            let sig = ty.fn_sig(cx.tcx);\n+            // FIXME: should we merge the outer and inner binders somehow?\n+            let sig = bound_ty.skip_binder().fn_sig(cx.tcx);\n             let decl = clean_fn_decl_from_did_and_sig(cx, None, sig);\n             BareFunction(Box::new(BareFunctionDecl {\n                 unsafety: sig.unsafety(),\n@@ -1705,12 +1737,18 @@ pub(crate) fn clean_middle_ty<'tcx>(\n                 AdtKind::Enum => ItemType::Enum,\n             };\n             inline::record_extern_fqn(cx, did, kind);\n-            let path = external_path(cx, did, false, ThinVec::new(), substs);\n+            let path = external_path(cx, did, false, ThinVec::new(), bound_ty.rebind(substs));\n             Type::Path { path }\n         }\n         ty::Foreign(did) => {\n             inline::record_extern_fqn(cx, did, ItemType::ForeignType);\n-            let path = external_path(cx, did, false, ThinVec::new(), InternalSubsts::empty());\n+            let path = external_path(\n+                cx,\n+                did,\n+                false,\n+                ThinVec::new(),\n+                ty::Binder::dummy(InternalSubsts::empty()),\n+            );\n             Type::Path { path }\n         }\n         ty::Dynamic(obj, ref reg, _) => {\n@@ -1721,11 +1759,11 @@ pub(crate) fn clean_middle_ty<'tcx>(\n             let did = obj\n                 .principal_def_id()\n                 .or_else(|| dids.next())\n-                .unwrap_or_else(|| panic!(\"found trait object `{:?}` with no traits?\", ty));\n+                .unwrap_or_else(|| panic!(\"found trait object `{bound_ty:?}` with no traits?\"));\n             let substs = match obj.principal() {\n-                Some(principal) => principal.skip_binder().substs,\n+                Some(principal) => principal.map_bound(|p| p.substs),\n                 // marker traits have no substs.\n-                _ => cx.tcx.intern_substs(&[]),\n+                _ => ty::Binder::dummy(InternalSubsts::empty()),\n             };\n \n             inline::record_extern_fqn(cx, did, ItemType::Trait);\n@@ -1736,7 +1774,7 @@ pub(crate) fn clean_middle_ty<'tcx>(\n             let lifetime = clean_middle_region(*reg);\n             let mut bounds = dids\n                 .map(|did| {\n-                    let empty = cx.tcx.intern_substs(&[]);\n+                    let empty = ty::Binder::dummy(InternalSubsts::empty());\n                     let path = external_path(cx, did, false, ThinVec::new(), empty);\n                     inline::record_extern_fqn(cx, did, ItemType::Trait);\n                     PolyTrait { trait_: path, generic_params: Vec::new() }\n@@ -1747,15 +1785,17 @@ pub(crate) fn clean_middle_ty<'tcx>(\n                 .projection_bounds()\n                 .map(|pb| TypeBinding {\n                     assoc: projection_to_path_segment(\n-                        pb.skip_binder()\n-                            // HACK(compiler-errors): Doesn't actually matter what self\n-                            // type we put here, because we're only using the GAT's substs.\n-                            .with_self_ty(cx.tcx, cx.tcx.types.self_param)\n-                            .projection_ty,\n+                        pb.map_bound(|pb| {\n+                            pb\n+                                // HACK(compiler-errors): Doesn't actually matter what self\n+                                // type we put here, because we're only using the GAT's substs.\n+                                .with_self_ty(cx.tcx, cx.tcx.types.self_param)\n+                                .projection_ty\n+                        }),\n                         cx,\n                     ),\n                     kind: TypeBindingKind::Equality {\n-                        term: clean_middle_term(pb.skip_binder().term, cx),\n+                        term: clean_middle_term(pb.map_bound(|pb| pb.term), cx),\n                     },\n                 })\n                 .collect();\n@@ -1779,9 +1819,11 @@ pub(crate) fn clean_middle_ty<'tcx>(\n \n             DynTrait(bounds, lifetime)\n         }\n-        ty::Tuple(t) => Tuple(t.iter().map(|t| clean_middle_ty(t, cx, None)).collect()),\n+        ty::Tuple(t) => {\n+            Tuple(t.iter().map(|t| clean_middle_ty(bound_ty.rebind(t), cx, None)).collect())\n+        }\n \n-        ty::Projection(ref data) => clean_projection(*data, cx, def_id),\n+        ty::Projection(ref data) => clean_projection(bound_ty.rebind(*data), cx, def_id),\n \n         ty::Param(ref p) => {\n             if let Some(bounds) = cx.impl_trait_bounds.remove(&p.index.into()) {\n@@ -1854,9 +1896,12 @@ fn clean_middle_opaque_bounds<'tcx>(\n                     {\n                         if proj.projection_ty.trait_ref(cx.tcx) == trait_ref.skip_binder() {\n                             Some(TypeBinding {\n-                                assoc: projection_to_path_segment(proj.projection_ty, cx),\n+                                assoc: projection_to_path_segment(\n+                                    bound.kind().rebind(proj.projection_ty),\n+                                    cx,\n+                                ),\n                                 kind: TypeBindingKind::Equality {\n-                                    term: clean_middle_term(proj.term, cx),\n+                                    term: clean_middle_term(bound.kind().rebind(proj.term), cx),\n                                 },\n                             })\n                         } else {\n@@ -1887,7 +1932,7 @@ pub(crate) fn clean_middle_field<'tcx>(field: &ty::FieldDef, cx: &mut DocContext\n     clean_field_with_def_id(\n         field.did,\n         field.name,\n-        clean_middle_ty(cx.tcx.type_of(field.did), cx, Some(field.did)),\n+        clean_middle_ty(ty::Binder::dummy(cx.tcx.type_of(field.did)), cx, Some(field.did)),\n         cx,\n     )\n }\n@@ -2100,7 +2145,7 @@ fn clean_maybe_renamed_item<'tcx>(\n             }),\n             ItemKind::TyAlias(hir_ty, generics) => {\n                 let rustdoc_ty = clean_ty(hir_ty, cx);\n-                let ty = clean_middle_ty(hir_ty_to_ty(cx.tcx, hir_ty), cx, None);\n+                let ty = clean_middle_ty(ty::Binder::dummy(hir_ty_to_ty(cx.tcx, hir_ty)), cx, None);\n                 TypedefItem(Box::new(Typedef {\n                     type_: rustdoc_ty,\n                     generics: clean_generics(generics, cx),\n@@ -2211,7 +2256,9 @@ fn clean_impl<'tcx>(\n \n     let for_ = clean_ty(impl_.self_ty, cx);\n     let type_alias = for_.def_id(&cx.cache).and_then(|did| match tcx.def_kind(did) {\n-        DefKind::TyAlias => Some(clean_middle_ty(tcx.type_of(did), cx, Some(did))),\n+        DefKind::TyAlias => {\n+            Some(clean_middle_ty(ty::Binder::dummy(tcx.type_of(did)), cx, Some(did)))\n+        }\n         _ => None,\n     });\n     let mut make_item = |trait_: Option<Path>, for_: Type, items: Vec<Item>| {"}, {"sha": "7a7313c4bc99d90e5987fa6d2864d7fedfea3a17", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed620cf9690fdafed65845bf35c455db992fbba1/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed620cf9690fdafed65845bf35c455db992fbba1/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=ed620cf9690fdafed65845bf35c455db992fbba1", "patch": "@@ -1343,7 +1343,7 @@ pub(crate) enum GenericBound {\n impl GenericBound {\n     pub(crate) fn maybe_sized(cx: &mut DocContext<'_>) -> GenericBound {\n         let did = cx.tcx.require_lang_item(LangItem::Sized, None);\n-        let empty = cx.tcx.intern_substs(&[]);\n+        let empty = ty::Binder::dummy(ty::InternalSubsts::empty());\n         let path = external_path(cx, did, false, ThinVec::new(), empty);\n         inline::record_extern_fqn(cx, did, ItemType::Trait);\n         GenericBound::TraitBound("}, {"sha": "a12f764fa8e3b739404df7937b83969a10e6bb8f", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ed620cf9690fdafed65845bf35c455db992fbba1/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed620cf9690fdafed65845bf35c455db992fbba1/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=ed620cf9690fdafed65845bf35c455db992fbba1", "patch": "@@ -78,21 +78,29 @@ pub(crate) fn krate(cx: &mut DocContext<'_>) -> Crate {\n \n pub(crate) fn substs_to_args<'tcx>(\n     cx: &mut DocContext<'tcx>,\n-    substs: &[ty::subst::GenericArg<'tcx>],\n+    substs: ty::Binder<'tcx, &[ty::subst::GenericArg<'tcx>]>,\n     mut skip_first: bool,\n ) -> Vec<GenericArg> {\n     let mut ret_val =\n-        Vec::with_capacity(substs.len().saturating_sub(if skip_first { 1 } else { 0 }));\n-    ret_val.extend(substs.iter().filter_map(|kind| match kind.unpack() {\n+        Vec::with_capacity(substs.skip_binder().len().saturating_sub(if skip_first {\n+            1\n+        } else {\n+            0\n+        }));\n+    ret_val.extend(substs.iter().filter_map(|kind| match kind.skip_binder().unpack() {\n         GenericArgKind::Lifetime(lt) => {\n             Some(GenericArg::Lifetime(clean_middle_region(lt).unwrap_or(Lifetime::elided())))\n         }\n         GenericArgKind::Type(_) if skip_first => {\n             skip_first = false;\n             None\n         }\n-        GenericArgKind::Type(ty) => Some(GenericArg::Type(clean_middle_ty(ty, cx, None))),\n-        GenericArgKind::Const(ct) => Some(GenericArg::Const(Box::new(clean_middle_const(ct, cx)))),\n+        GenericArgKind::Type(ty) => {\n+            Some(GenericArg::Type(clean_middle_ty(kind.rebind(ty), cx, None)))\n+        }\n+        GenericArgKind::Const(ct) => {\n+            Some(GenericArg::Const(Box::new(clean_middle_const(kind.rebind(ct), cx))))\n+        }\n     }));\n     ret_val\n }\n@@ -102,15 +110,20 @@ fn external_generic_args<'tcx>(\n     did: DefId,\n     has_self: bool,\n     bindings: ThinVec<TypeBinding>,\n-    substs: SubstsRef<'tcx>,\n+    substs: ty::Binder<'tcx, SubstsRef<'tcx>>,\n ) -> GenericArgs {\n-    let args = substs_to_args(cx, substs, has_self);\n+    let args = substs_to_args(cx, substs.map_bound(|substs| &substs[..]), has_self);\n \n     if cx.tcx.fn_trait_kind_from_def_id(did).is_some() {\n+        let ty = substs\n+            .iter()\n+            .nth(if has_self { 1 } else { 0 })\n+            .unwrap()\n+            .map_bound(|arg| arg.expect_ty());\n         let inputs =\n             // The trait's first substitution is the one after self, if there is one.\n-            match substs.iter().nth(if has_self { 1 } else { 0 }).unwrap().expect_ty().kind() {\n-                ty::Tuple(tys) => tys.iter().map(|t| clean_middle_ty(t, cx, None)).collect::<Vec<_>>().into(),\n+            match ty.skip_binder().kind() {\n+                ty::Tuple(tys) => tys.iter().map(|t| clean_middle_ty(ty.rebind(t), cx, None)).collect::<Vec<_>>().into(),\n                 _ => return GenericArgs::AngleBracketed { args: args.into(), bindings },\n             };\n         let output = bindings.into_iter().next().and_then(|binding| match binding.kind {\n@@ -130,7 +143,7 @@ pub(super) fn external_path<'tcx>(\n     did: DefId,\n     has_self: bool,\n     bindings: ThinVec<TypeBinding>,\n-    substs: SubstsRef<'tcx>,\n+    substs: ty::Binder<'tcx, SubstsRef<'tcx>>,\n ) -> Path {\n     let def_kind = cx.tcx.def_kind(did);\n     let name = cx.tcx.item_name(did);"}]}