{"sha": "cff59532a8145e35ef193f5f33c0c154a9764241", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmZjU5NTMyYTgxNDVlMzVlZjE5M2Y1ZjMzYzBjMTU0YTk3NjQyNDE=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-07-24T09:56:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-24T09:56:34Z"}, "message": "Rollup merge of #74666 - ssomers:btree_cleanup_1, r=Mark-Simulacrum\n\nMore BTreeMap test cases, some exposing undefined behaviour\n\nGathered from other ongoing PRs and all either blessed or ignored by Miri\n\nr? @Mark-Simulacrum", "tree": {"sha": "f1b3de706f0a0d719f4ec6fabc19c970223a5466", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1b3de706f0a0d719f4ec6fabc19c970223a5466"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cff59532a8145e35ef193f5f33c0c154a9764241", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfGrBTCRBK7hj4Ov3rIwAAdHIIAF2nCyOt8IBDr3guyomhK0Z3\n7TnR4T+5s5gFQ2mgOK9YSzaj4iPfZ7b8fwsJk77ke1aPQFJ/rOq3lRx0+mHoxRYK\npCJlC9a4MiF1PPuqAfLPUKlzGSwaqC2mY8MrPAlFn0OqfK4vPWaIa8jF8qv/vWzf\nG/hPvtYyEUpPr2Junp6O6LRLqNSai7xn5S1VRbyZHu2IF1H6SuEPQ5nE7+OEIEGw\nkS4g81MFin1eEbAFcLGXXfvQI65dR0/IxFqcU2xsYF1ytdTH9/nnZ5wWXf+LqkAC\nESegNo+IbeGY66z3KxpddWPGQy4TgD8MbRZjJWYAcw7W0MRStua4Szh7Ne3WjOQ=\n=fruU\n-----END PGP SIGNATURE-----\n", "payload": "tree f1b3de706f0a0d719f4ec6fabc19c970223a5466\nparent 1f6d5ce4ab620d2b843cd0171d0e20ee24ae8c15\nparent 2152d18f9248d376fd43a6192888664f33dfb08d\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1595584594 +0900\ncommitter GitHub <noreply@github.com> 1595584594 +0900\n\nRollup merge of #74666 - ssomers:btree_cleanup_1, r=Mark-Simulacrum\n\nMore BTreeMap test cases, some exposing undefined behaviour\n\nGathered from other ongoing PRs and all either blessed or ignored by Miri\n\nr? @Mark-Simulacrum\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cff59532a8145e35ef193f5f33c0c154a9764241", "html_url": "https://github.com/rust-lang/rust/commit/cff59532a8145e35ef193f5f33c0c154a9764241", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cff59532a8145e35ef193f5f33c0c154a9764241/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f6d5ce4ab620d2b843cd0171d0e20ee24ae8c15", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f6d5ce4ab620d2b843cd0171d0e20ee24ae8c15", "html_url": "https://github.com/rust-lang/rust/commit/1f6d5ce4ab620d2b843cd0171d0e20ee24ae8c15"}, {"sha": "2152d18f9248d376fd43a6192888664f33dfb08d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2152d18f9248d376fd43a6192888664f33dfb08d", "html_url": "https://github.com/rust-lang/rust/commit/2152d18f9248d376fd43a6192888664f33dfb08d"}], "stats": {"total": 80, "additions": 80, "deletions": 0}, "files": [{"sha": "5cd3ce0a2d80dd86a45dffc75a2a54c3542f9b48", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/cff59532a8145e35ef193f5f33c0c154a9764241/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff59532a8145e35ef193f5f33c0c154a9764241/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=cff59532a8145e35ef193f5f33c0c154a9764241", "patch": "@@ -3,6 +3,7 @@ use std::collections::BTreeMap;\n use std::convert::TryFrom;\n use std::fmt::Debug;\n use std::iter::FromIterator;\n+use std::mem;\n use std::ops::Bound::{self, Excluded, Included, Unbounded};\n use std::ops::RangeBounds;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n@@ -25,6 +26,20 @@ const MIN_INSERTS_HEIGHT_1: usize = NODE_CAPACITY + 1;\n // It's not the minimum size: removing an element from such a tree does not always reduce height.\n const MIN_INSERTS_HEIGHT_2: usize = NODE_CAPACITY + (NODE_CAPACITY + 1) * NODE_CAPACITY + 1;\n \n+// Gather all references from a mutable iterator and make sure Miri notices if\n+// using them is dangerous.\n+fn test_all_refs<'a, T: 'a>(dummy: &mut T, iter: impl Iterator<Item = &'a mut T>) {\n+    // Gather all those references.\n+    let mut refs: Vec<&mut T> = iter.collect();\n+    // Use them all. Twice, to be sure we got all interleavings.\n+    for r in refs.iter_mut() {\n+        mem::swap(dummy, r);\n+    }\n+    for r in refs {\n+        mem::swap(dummy, r);\n+    }\n+}\n+\n #[test]\n fn test_basic_large() {\n     let mut map = BTreeMap::new();\n@@ -268,7 +283,14 @@ fn test_iter_mut_mutation() {\n }\n \n #[test]\n+#[cfg_attr(miri, ignore)] // FIXME: fails in Miri <https://github.com/rust-lang/rust/issues/73915>\n fn test_values_mut() {\n+    let mut a: BTreeMap<_, _> = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i)).collect();\n+    test_all_refs(&mut 13, a.values_mut());\n+}\n+\n+#[test]\n+fn test_values_mut_mutation() {\n     let mut a = BTreeMap::new();\n     a.insert(1, String::from(\"hello\"));\n     a.insert(2, String::from(\"goodbye\"));\n@@ -281,6 +303,36 @@ fn test_values_mut() {\n     assert_eq!(values, [String::from(\"hello!\"), String::from(\"goodbye!\")]);\n }\n \n+#[test]\n+#[cfg_attr(miri, ignore)] // FIXME: fails in Miri <https://github.com/rust-lang/rust/issues/73915>\n+fn test_iter_entering_root_twice() {\n+    let mut map: BTreeMap<_, _> = (0..2).map(|i| (i, i)).collect();\n+    let mut it = map.iter_mut();\n+    let front = it.next().unwrap();\n+    let back = it.next_back().unwrap();\n+    assert_eq!(front, (&0, &mut 0));\n+    assert_eq!(back, (&1, &mut 1));\n+    *front.1 = 24;\n+    *back.1 = 42;\n+    assert_eq!(front, (&0, &mut 24));\n+    assert_eq!(back, (&1, &mut 42));\n+}\n+\n+#[test]\n+#[cfg_attr(miri, ignore)] // FIXME: fails in Miri <https://github.com/rust-lang/rust/issues/73915>\n+fn test_iter_descending_to_same_node_twice() {\n+    let mut map: BTreeMap<_, _> = (0..MIN_INSERTS_HEIGHT_1).map(|i| (i, i)).collect();\n+    let mut it = map.iter_mut();\n+    // Descend into first child.\n+    let front = it.next().unwrap();\n+    // Descend into first child again, after running through second child.\n+    while it.next_back().is_some() {}\n+    // Check immutable access.\n+    assert_eq!(front, (&0, &mut 0));\n+    // Perform mutable access.\n+    *front.1 = 42;\n+}\n+\n #[test]\n fn test_iter_mixed() {\n     // Miri is too slow\n@@ -1283,6 +1335,34 @@ fn test_split_off_empty_left() {\n     assert!(right.into_iter().eq(data));\n }\n \n+// In a tree with 3 levels, if all but a part of the first leaf node is split off,\n+// make sure fix_top eliminates both top levels.\n+#[test]\n+fn test_split_off_tiny_left_height_2() {\n+    let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n+    let mut left: BTreeMap<_, _> = pairs.clone().collect();\n+    let right = left.split_off(&1);\n+    assert_eq!(left.len(), 1);\n+    assert_eq!(right.len(), MIN_INSERTS_HEIGHT_2 - 1);\n+    assert_eq!(*left.first_key_value().unwrap().0, 0);\n+    assert_eq!(*right.first_key_value().unwrap().0, 1);\n+}\n+\n+// In a tree with 3 levels, if only part of the last leaf node is split off,\n+// make sure fix_top eliminates both top levels.\n+#[test]\n+fn test_split_off_tiny_right_height_2() {\n+    let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n+    let last = MIN_INSERTS_HEIGHT_2 - 1;\n+    let mut left: BTreeMap<_, _> = pairs.clone().collect();\n+    assert_eq!(*left.last_key_value().unwrap().0, last);\n+    let right = left.split_off(&last);\n+    assert_eq!(left.len(), MIN_INSERTS_HEIGHT_2 - 1);\n+    assert_eq!(right.len(), 1);\n+    assert_eq!(*left.last_key_value().unwrap().0, last - 1);\n+    assert_eq!(*right.last_key_value().unwrap().0, last);\n+}\n+\n #[test]\n fn test_split_off_large_random_sorted() {\n     // Miri is too slow"}]}