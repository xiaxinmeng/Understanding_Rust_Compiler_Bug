{"sha": "0d20717fab410cf1f90938d90ad4153b77b6f8b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkMjA3MTdmYWI0MTBjZjFmOTA5MzhkOTBhZDQxNTNiNzdiNmY4YjM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-06-04T14:59:02Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-06-07T01:37:07Z"}, "message": "add some purity annotations in dvec/vec, occasional accessor method", "tree": {"sha": "8368d9f947513ec48aa3ecdf5b5c05002ad97ac0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8368d9f947513ec48aa3ecdf5b5c05002ad97ac0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d20717fab410cf1f90938d90ad4153b77b6f8b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d20717fab410cf1f90938d90ad4153b77b6f8b3", "html_url": "https://github.com/rust-lang/rust/commit/0d20717fab410cf1f90938d90ad4153b77b6f8b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d20717fab410cf1f90938d90ad4153b77b6f8b3/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45680c83ab81986bbedf93878e3d24f69be02981", "url": "https://api.github.com/repos/rust-lang/rust/commits/45680c83ab81986bbedf93878e3d24f69be02981", "html_url": "https://github.com/rust-lang/rust/commit/45680c83ab81986bbedf93878e3d24f69be02981"}], "stats": {"total": 66, "additions": 39, "deletions": 27}, "files": [{"sha": "ccaab58553f792470272cb9fbc635f77022919ff", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0d20717fab410cf1f90938d90ad4153b77b6f8b3/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d20717fab410cf1f90938d90ad4153b77b6f8b3/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=0d20717fab410cf1f90938d90ad4153b77b6f8b3", "patch": "@@ -57,6 +57,11 @@ fn dvec<A>() -> dvec<A> {\n     {mut data: [mut]}\n }\n \n+#[doc = \"Creates a new dvec with a single element\"]\n+fn from_elt<A>(+e: A) -> dvec<A> {\n+    {mut data: [mut e]}\n+}\n+\n #[doc = \"Creates a new dvec with the contents of a vector\"]\n fn from_vec<A>(+v: [mut A]) -> dvec<A> {\n     {mut data: v}\n@@ -234,12 +239,19 @@ impl extensions<A:copy> for dvec<A> {\n         self.data[idx] = a;\n     }\n \n-    #[doc = \"Overwrites the contents of the element at `idx` with `a`\"]\n+    #[doc = \"Overwrites the contents of the element at `idx` with `a`,\n+    growing the vector if necessary.  New elements will be initialized\n+    with `initval`\"]\n     fn grow_set_elt(idx: uint, initval: A, val: A) {\n         self.swap { |v|\n             let mut v <- v;\n             vec::grow_set(v, idx, initval, val);\n             v\n         }\n     }\n+\n+    #[doc = \"Returns the last element, failing if the vector is empty\"]\n+    fn last() -> A {\n+        self.get_elt(self.len() - 1u)\n+    }\n }\n\\ No newline at end of file"}, {"sha": "4cfcd6b7517e90a7e0dc5e46e127754108fe441b", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0d20717fab410cf1f90938d90ad4153b77b6f8b3/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d20717fab410cf1f90938d90ad4153b77b6f8b3/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=0d20717fab410cf1f90938d90ad4153b77b6f8b3", "patch": "@@ -211,18 +211,18 @@ fn from_mut<T>(+v: [mut T]) -> [T] unsafe {\n pure fn head<T: copy>(v: [const T]/&) -> T { v[0] }\n \n #[doc = \"Returns a vector containing all but the first element of a slice\"]\n-fn tail<T: copy>(v: [const T]/&) -> [T] {\n+pure fn tail<T: copy>(v: [const T]/&) -> [T] {\n     ret slice(v, 1u, len(v));\n }\n \n #[doc = \"Returns a vector containing all but the first `n` \\\n          elements of a slice\"]\n-fn tailn<T: copy>(v: [const T]/&, n: uint) -> [T] {\n+pure fn tailn<T: copy>(v: [const T]/&, n: uint) -> [T] {\n     slice(v, n, len(v))\n }\n \n #[doc = \"Returns a vector containing all but the last element of a slice\"]\n-fn init<T: copy>(v: [const T]/&) -> [T] {\n+pure fn init<T: copy>(v: [const T]/&) -> [T] {\n     assert len(v) != 0u;\n     slice(v, 0u, len(v) - 1u)\n }\n@@ -1033,10 +1033,10 @@ pure fn unpack_mut_slice<T,U>(s: [mut T]/&,\n impl extensions/&<T> for [const T]/& {\n     #[doc = \"Returns true if a vector contains no elements\"]\n     #[inline]\n-    fn is_empty() -> bool { is_empty(self) }\n+    pure fn is_empty() -> bool { is_empty(self) }\n     #[doc = \"Returns true if a vector contains some elements\"]\n     #[inline]\n-    fn is_not_empty() -> bool { is_not_empty(self) }\n+    pure fn is_not_empty() -> bool { is_not_empty(self) }\n     #[doc = \"Returns the length of a vector\"]\n     #[inline]\n     pure fn len() -> uint { len(self) }\n@@ -1046,44 +1046,44 @@ impl extensions/&<T> for [const T]/& {\n impl extensions/&<T: copy> for [const T]/& {\n     #[doc = \"Returns the first element of a vector\"]\n     #[inline]\n-    fn head() -> T { head(self) }\n+    pure fn head() -> T { head(self) }\n     #[doc = \"Returns all but the last elemnt of a vector\"]\n     #[inline]\n-    fn init() -> [T] { init(self) }\n+    pure fn init() -> [T] { init(self) }\n     #[doc = \"\n     Returns the last element of a `v`, failing if the vector is empty.\n     \"]\n     #[inline]\n-    fn last() -> T { last(self) }\n+    pure fn last() -> T { last(self) }\n     #[doc = \"Returns a copy of the elements from [`start`..`end`) from `v`.\"]\n     #[inline]\n-    fn slice(start: uint, end: uint) -> [T] { slice(self, start, end) }\n+    pure fn slice(start: uint, end: uint) -> [T] { slice(self, start, end) }\n     #[doc = \"Returns all but the first element of a vector\"]\n     #[inline]\n-    fn tail() -> [T] { tail(self) }\n+    pure fn tail() -> [T] { tail(self) }\n }\n \n #[doc = \"Extension methods for vectors\"]\n impl extensions/&<T> for [T]/& {\n     #[doc = \"Reduce a vector from right to left\"]\n     #[inline]\n-    fn foldr<U: copy>(z: U, p: fn(T, U) -> U) -> U { foldr(self, z, p) }\n+    pure fn foldr<U: copy>(z: U, p: fn(T, U) -> U) -> U { foldr(self, z, p) }\n     #[doc = \"\n     Iterates over a vector\n \n     Iterates over vector `v` and, for each element, calls function `f` with\n     the element's value.\n     \"]\n     #[inline]\n-    fn iter(f: fn(T)) { iter(self, f) }\n+    pure fn iter(f: fn(T)) { iter(self, f) }\n     #[doc = \"\n     Iterates over a vector's elements and indexes\n \n     Iterates over vector `v` and, for each element, calls function `f` with\n     the element's value and index.\n     \"]\n     #[inline]\n-    fn iteri(f: fn(uint, T)) { iteri(self, f) }\n+    pure fn iteri(f: fn(uint, T)) { iteri(self, f) }\n     #[doc = \"\n     Find the first index matching some predicate\n \n@@ -1092,26 +1092,26 @@ impl extensions/&<T> for [T]/& {\n     elements then none is returned.\n     \"]\n     #[inline]\n-    fn position(f: fn(T) -> bool) -> option<uint> { position(self, f) }\n+    pure fn position(f: fn(T) -> bool) -> option<uint> { position(self, f) }\n     #[doc = \"Find the first index containing a matching value\"]\n     #[inline]\n-    fn position_elem(x: T) -> option<uint> { position_elem(self, x) }\n+    pure fn position_elem(x: T) -> option<uint> { position_elem(self, x) }\n     #[doc = \"\n     Iterates over a vector in reverse\n \n     Iterates over vector `v` and, for each element, calls function `f` with\n     the element's value.\n     \"]\n     #[inline]\n-    fn riter(f: fn(T)) { riter(self, f) }\n+    pure fn riter(f: fn(T)) { riter(self, f) }\n     #[doc =\"\n     Iterates over a vector's elements and indexes in reverse\n \n     Iterates over vector `v` and, for each element, calls function `f` with\n     the element's value and index.\n     \"]\n     #[inline]\n-    fn riteri(f: fn(uint, T)) { riteri(self, f) }\n+    pure fn riteri(f: fn(uint, T)) { riteri(self, f) }\n     #[doc = \"\n     Find the last index matching some predicate\n \n@@ -1120,20 +1120,20 @@ impl extensions/&<T> for [T]/& {\n     matches no elements then none is returned.\n     \"]\n     #[inline]\n-    fn rposition(f: fn(T) -> bool) -> option<uint> { rposition(self, f) }\n+    pure fn rposition(f: fn(T) -> bool) -> option<uint> { rposition(self, f) }\n     #[doc = \"Find the last index containing a matching value\"]\n     #[inline]\n-    fn rposition_elem(x: T) -> option<uint> { rposition_elem(self, x) }\n+    pure fn rposition_elem(x: T) -> option<uint> { rposition_elem(self, x) }\n     #[doc = \"\n     Apply a function to each element of a vector and return the results\n     \"]\n     #[inline]\n-    fn map<U>(f: fn(T) -> U) -> [U] { map(self, f) }\n+    pure fn map<U>(f: fn(T) -> U) -> [U] { map(self, f) }\n     #[doc = \"\n     Apply a function to the index and value of each element in the vector\n     and return the results\n     \"]\n-    fn mapi<U>(f: fn(uint, T) -> U) -> [U] {\n+    pure fn mapi<U>(f: fn(uint, T) -> U) -> [U] {\n         mapi(self, f)\n     }\n     #[doc = \"Returns true if the function returns true for all elements.\n@@ -1147,15 +1147,15 @@ impl extensions/&<T> for [T]/& {\n     of each result vector\n     \"]\n     #[inline]\n-    fn flat_map<U>(f: fn(T) -> [U]) -> [U] { flat_map(self, f) }\n+    pure fn flat_map<U>(f: fn(T) -> [U]) -> [U] { flat_map(self, f) }\n     #[doc = \"\n     Apply a function to each element of a vector and return the results\n \n     If function `f` returns `none` then that element is excluded from\n     the resulting vector.\n     \"]\n     #[inline]\n-    fn filter_map<U: copy>(f: fn(T) -> option<U>) -> [U] {\n+    pure fn filter_map<U: copy>(f: fn(T) -> option<U>) -> [U] {\n         filter_map(self, f)\n     }\n }\n@@ -1170,7 +1170,7 @@ impl extensions/&<T: copy> for [T]/& {\n     only those elements for which `f` returned true.\n     \"]\n     #[inline]\n-    fn filter(f: fn(T) -> bool) -> [T] { filter(self, f) }\n+    pure fn filter(f: fn(T) -> bool) -> [T] { filter(self, f) }\n     #[doc = \"\n     Search for the first element that matches a given predicate\n \n@@ -1179,7 +1179,7 @@ impl extensions/&<T: copy> for [T]/& {\n     is returned. If `f` matches no elements then none is returned.\n     \"]\n     #[inline]\n-    fn find(f: fn(T) -> bool) -> option<T> { find(self, f) }\n+    pure fn find(f: fn(T) -> bool) -> option<T> { find(self, f) }\n     #[doc = \"\n     Search for the last element that matches a given predicate\n \n@@ -1188,7 +1188,7 @@ impl extensions/&<T: copy> for [T]/& {\n     matches no elements then none is returned.\n     \"]\n     #[inline]\n-    fn rfind(f: fn(T) -> bool) -> option<T> { rfind(self, f) }\n+    pure fn rfind(f: fn(T) -> bool) -> option<T> { rfind(self, f) }\n }\n \n #[doc = \"Unsafe operations\"]"}]}