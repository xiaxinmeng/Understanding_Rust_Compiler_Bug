{"sha": "aad9fbf6b65137f278d74cc84e0028a8f8aeed03", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhZDlmYmY2YjY1MTM3ZjI3OGQ3NGNjODRlMDAyOGE4ZjhhZWVkMDM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-14T03:33:28Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-25T03:59:53Z"}, "message": "green: Fixing all tests from previous refactorings", "tree": {"sha": "01c5e2b2047c3bf5ab1e87d05325567183e4167e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01c5e2b2047c3bf5ab1e87d05325567183e4167e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aad9fbf6b65137f278d74cc84e0028a8f8aeed03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aad9fbf6b65137f278d74cc84e0028a8f8aeed03", "html_url": "https://github.com/rust-lang/rust/commit/aad9fbf6b65137f278d74cc84e0028a8f8aeed03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aad9fbf6b65137f278d74cc84e0028a8f8aeed03/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a6d920e3df3d48168b22879a194538ec10c951a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a6d920e3df3d48168b22879a194538ec10c951a", "html_url": "https://github.com/rust-lang/rust/commit/1a6d920e3df3d48168b22879a194538ec10c951a"}], "stats": {"total": 633, "additions": 351, "deletions": 282}, "files": [{"sha": "e1e489a2a2b6ceaa2a539d9c3806474c1415a295", "filename": "src/libgreen/basic.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/aad9fbf6b65137f278d74cc84e0028a8f8aeed03/src%2Flibgreen%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aad9fbf6b65137f278d74cc84e0028a8f8aeed03/src%2Flibgreen%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fbasic.rs?ref=aad9fbf6b65137f278d74cc84e0028a8f8aeed03", "patch": "@@ -223,3 +223,61 @@ impl Drop for BasicPausable {\n         }\n     }\n }\n+\n+#[cfg(test)]\n+mod test {\n+    use std::task::TaskOpts;\n+\n+    use basic;\n+    use PoolConfig;\n+    use SchedPool;\n+\n+    fn pool() -> SchedPool {\n+        SchedPool::new(PoolConfig {\n+            threads: 1,\n+            event_loop_factory: Some(basic::event_loop),\n+        })\n+    }\n+\n+    fn run(f: proc()) {\n+        let mut pool = pool();\n+        pool.spawn(TaskOpts::new(), f);\n+        pool.shutdown();\n+    }\n+\n+    #[test]\n+    fn smoke() {\n+        do run {}\n+    }\n+\n+    #[test]\n+    fn some_channels() {\n+        do run {\n+            let (p, c) = Chan::new();\n+            do spawn {\n+                c.send(());\n+            }\n+            p.recv();\n+        }\n+    }\n+\n+    #[test]\n+    fn multi_thread() {\n+        let mut pool = SchedPool::new(PoolConfig {\n+            threads: 2,\n+            event_loop_factory: Some(basic::event_loop),\n+        });\n+\n+        for _ in range(0, 20) {\n+            do pool.spawn(TaskOpts::new()) {\n+                let (p, c) = Chan::new();\n+                do spawn {\n+                    c.send(());\n+                }\n+                p.recv();\n+            }\n+        }\n+\n+        pool.shutdown();\n+    }\n+}"}, {"sha": "bb219936ae0893f5fa01e935b049b5b9334a22ca", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aad9fbf6b65137f278d74cc84e0028a8f8aeed03/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aad9fbf6b65137f278d74cc84e0028a8f8aeed03/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=aad9fbf6b65137f278d74cc84e0028a8f8aeed03", "patch": "@@ -58,8 +58,6 @@ pub mod sleeper_list;\n pub mod stack;\n pub mod task;\n \n-#[cfg(test)] mod tests;\n-\n #[cfg(stage0)]\n #[lang = \"start\"]\n pub fn lang_start(main: *u8, argc: int, argv: **u8) -> int {"}, {"sha": "9e26cd41cdd35e65697a2b07d9f1a52d6a385ce8", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 203, "deletions": 202, "changes": 405, "blob_url": "https://github.com/rust-lang/rust/blob/aad9fbf6b65137f278d74cc84e0028a8f8aeed03/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aad9fbf6b65137f278d74cc84e0028a8f8aeed03/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=aad9fbf6b65137f278d74cc84e0028a8f8aeed03", "patch": "@@ -951,21 +951,47 @@ fn new_sched_rng() -> XorShiftRng {\n \n #[cfg(test)]\n mod test {\n-    use borrow::to_uint;\n-    use rt::deque::BufferPool;\n-    use rt::basic;\n-    use rt::sched::{Scheduler};\n-    use rt::task::{GreenTask, Sched};\n-    use rt::thread::Thread;\n-    use rt::util;\n-    use task::TaskResult;\n-    use unstable::run_in_bare_thread;\n+    use std::task::TaskOpts;\n+    use std::rt::Runtime;\n+    use std::rt::task::Task;\n+    use std::rt::local::Local;\n+\n+    use basic;\n+    use sched::TaskFromFriend;\n+    use task::{GreenTask, HomeSched};\n+    use PoolConfig;\n+    use SchedPool;\n+\n+    fn pool() -> SchedPool {\n+        SchedPool::new(PoolConfig {\n+            threads: 1,\n+            event_loop_factory: Some(basic::event_loop),\n+        })\n+    }\n+\n+    fn run(f: proc()) {\n+        let mut pool = pool();\n+        pool.spawn(TaskOpts::new(), f);\n+        pool.shutdown();\n+    }\n+\n+    fn sched_id() -> uint {\n+        let mut task = Local::borrow(None::<Task>);\n+        match task.get().maybe_take_runtime::<GreenTask>() {\n+            Some(green) => {\n+                let ret = green.sched.get_ref().sched_id();\n+                task.get().put_runtime(green as ~Runtime);\n+                return ret;\n+            }\n+            None => fail!()\n+        }\n+    }\n \n     #[test]\n     fn trivial_run_in_newsched_task_test() {\n         let mut task_ran = false;\n         let task_ran_ptr: *mut bool = &mut task_ran;\n-        do run_in_newsched_task || {\n+        do run {\n             unsafe { *task_ran_ptr = true };\n             rtdebug!(\"executed from the new scheduler\")\n         }\n@@ -977,9 +1003,11 @@ mod test {\n         let total = 10;\n         let mut task_run_count = 0;\n         let task_run_count_ptr: *mut uint = &mut task_run_count;\n-        do run_in_newsched_task || {\n+        // with only one thread this is safe to run in without worries of\n+        // contention.\n+        do run {\n             for _ in range(0u, total) {\n-                do spawntask || {\n+                do spawn || {\n                     unsafe { *task_run_count_ptr = *task_run_count_ptr + 1};\n                 }\n             }\n@@ -991,12 +1019,12 @@ mod test {\n     fn multiple_task_nested_test() {\n         let mut task_run_count = 0;\n         let task_run_count_ptr: *mut uint = &mut task_run_count;\n-        do run_in_newsched_task || {\n-            do spawntask || {\n+        do run {\n+            do spawn {\n                 unsafe { *task_run_count_ptr = *task_run_count_ptr + 1 };\n-                do spawntask || {\n+                do spawn {\n                     unsafe { *task_run_count_ptr = *task_run_count_ptr + 1 };\n-                    do spawntask || {\n+                    do spawn {\n                         unsafe { *task_run_count_ptr = *task_run_count_ptr + 1 };\n                     }\n                 }\n@@ -1005,65 +1033,47 @@ mod test {\n         assert!(task_run_count == 3);\n     }\n \n-    // Confirm that a sched_id actually is the uint form of the\n-    // pointer to the scheduler struct.\n-    #[test]\n-    fn simple_sched_id_test() {\n-        do run_in_bare_thread {\n-            let sched = ~new_test_uv_sched();\n-            assert!(to_uint(sched) == sched.sched_id());\n-        }\n-    }\n-\n-    // Compare two scheduler ids that are different, this should never\n-    // fail but may catch a mistake someday.\n-    #[test]\n-    fn compare_sched_id_test() {\n-        do run_in_bare_thread {\n-            let sched_one = ~new_test_uv_sched();\n-            let sched_two = ~new_test_uv_sched();\n-            assert!(sched_one.sched_id() != sched_two.sched_id());\n-        }\n-    }\n-\n-\n     // A very simple test that confirms that a task executing on the\n     // home scheduler notices that it is home.\n     #[test]\n     fn test_home_sched() {\n-        do run_in_bare_thread {\n-            let mut task_ran = false;\n-            let task_ran_ptr: *mut bool = &mut task_ran;\n+        let mut pool = pool();\n \n-            let mut sched = ~new_test_uv_sched();\n-            let sched_handle = sched.make_handle();\n+        let (dport, dchan) = Chan::new();\n+        {\n+            let (port, chan) = Chan::new();\n+            let mut handle1 = pool.spawn_sched();\n+            let mut handle2 = pool.spawn_sched();\n \n-            let mut task = ~do GreenTask::new_root_homed(&mut sched.stack_pool, None,\n-                                                Sched(sched_handle)) {\n-                unsafe { *task_ran_ptr = true };\n-                assert!(GreenTask::on_appropriate_sched());\n-            };\n+            handle1.send(TaskFromFriend(do pool.task(TaskOpts::new()) {\n+                chan.send(sched_id());\n+            }));\n+            let sched1_id = port.recv();\n \n-            let on_exit: proc(TaskResult) = proc(exit_status) {\n-                rtassert!(exit_status.is_ok())\n+            let mut task = do pool.task(TaskOpts::new()) {\n+                assert_eq!(sched_id(), sched1_id);\n+                dchan.send(());\n             };\n-            task.death.on_exit = Some(on_exit);\n-\n-            sched.bootstrap(task);\n+            task.give_home(HomeSched(handle1));\n+            handle2.send(TaskFromFriend(task));\n         }\n+        dport.recv();\n+\n+        pool.shutdown();\n     }\n \n     // An advanced test that checks all four possible states that a\n     // (task,sched) can be in regarding homes.\n \n     #[test]\n     fn test_schedule_home_states() {\n-        use rt::sleeper_list::SleeperList;\n-        use rt::sched::Shutdown;\n-        use borrow;\n+        use sleeper_list::SleeperList;\n+        use super::{Shutdown, Scheduler, SchedHandle};\n+        use std::unstable::run_in_bare_thread;\n+        use std::rt::thread::Thread;\n+        use std::sync::deque::BufferPool;\n \n         do run_in_bare_thread {\n-\n             let sleepers = SleeperList::new();\n             let mut pool = BufferPool::new();\n             let (normal_worker, normal_stealer) = pool.deque();\n@@ -1072,15 +1082,18 @@ mod test {\n \n             // Our normal scheduler\n             let mut normal_sched = ~Scheduler::new(\n+                1,\n                 basic::event_loop(),\n                 normal_worker,\n                 queues.clone(),\n                 sleepers.clone());\n \n             let normal_handle = normal_sched.make_handle();\n+            let friend_handle = normal_sched.make_handle();\n \n             // Our special scheduler\n             let mut special_sched = ~Scheduler::new_special(\n+                1,\n                 basic::event_loop(),\n                 special_worker,\n                 queues.clone(),\n@@ -1099,175 +1112,168 @@ mod test {\n             //   3) task not homed, sched requeues\n             //   4) task not home, send home\n \n-            let task1 = ~do GreenTask::new_root_homed(&mut special_sched.stack_pool, None,\n-                                                 Sched(t1_handle)) || {\n-                rtassert!(GreenTask::on_appropriate_sched());\n+            // Grab both the scheduler and the task from TLS and check if the\n+            // task is executing on an appropriate scheduler.\n+            fn on_appropriate_sched() -> bool {\n+                use task::{TypeGreen, TypeSched, HomeSched};\n+                let task = GreenTask::convert(Local::take());\n+                let sched_id = task.sched.get_ref().sched_id();\n+                let run_any = task.sched.get_ref().run_anything;\n+                let ret = match task.task_type {\n+                    TypeGreen(Some(AnySched)) => {\n+                        run_any\n+                    }\n+                    TypeGreen(Some(HomeSched(SchedHandle {\n+                        sched_id: ref id,\n+                        ..\n+                    }))) => {\n+                        *id == sched_id\n+                    }\n+                    TypeGreen(None) => { fail!(\"task without home\"); }\n+                    TypeSched => { fail!(\"expected green task\"); }\n+                };\n+                task.put();\n+                ret\n+            }\n+\n+            let task1 = do GreenTask::new_homed(&mut special_sched.stack_pool,\n+                                                None, HomeSched(t1_handle)) {\n+                rtassert!(on_appropriate_sched());\n             };\n-            rtdebug!(\"task1 id: **{}**\", borrow::to_uint(task1));\n \n-            let task2 = ~do GreenTask::new_root(&mut normal_sched.stack_pool, None) {\n-                rtassert!(GreenTask::on_appropriate_sched());\n+            let task2 = do GreenTask::new(&mut normal_sched.stack_pool, None) {\n+                rtassert!(on_appropriate_sched());\n             };\n \n-            let task3 = ~do GreenTask::new_root(&mut normal_sched.stack_pool, None) {\n-                rtassert!(GreenTask::on_appropriate_sched());\n+            let task3 = do GreenTask::new(&mut normal_sched.stack_pool, None) {\n+                rtassert!(on_appropriate_sched());\n             };\n \n-            let task4 = ~do GreenTask::new_root_homed(&mut special_sched.stack_pool, None,\n-                                                 Sched(t4_handle)) {\n-                rtassert!(GreenTask::on_appropriate_sched());\n+            let task4 = do GreenTask::new_homed(&mut special_sched.stack_pool,\n+                                                None, HomeSched(t4_handle)) {\n+                rtassert!(on_appropriate_sched());\n             };\n-            rtdebug!(\"task4 id: **{}**\", borrow::to_uint(task4));\n \n             // Signal from the special task that we are done.\n             let (port, chan) = Chan::<()>::new();\n \n-            let normal_task = ~do GreenTask::new_root(&mut normal_sched.stack_pool, None) {\n-                rtdebug!(\"*about to submit task2*\");\n-                Scheduler::run_task(task2);\n-                rtdebug!(\"*about to submit task4*\");\n-                Scheduler::run_task(task4);\n-                rtdebug!(\"*normal_task done*\");\n+            fn run(next: ~GreenTask) {\n+                let mut task = GreenTask::convert(Local::take());\n+                let sched = task.sched.take_unwrap();\n+                sched.run_task(task, next)\n+            }\n+\n+            let normal_task = do GreenTask::new(&mut normal_sched.stack_pool,\n+                                                None) {\n+                run(task2);\n+                run(task4);\n                 port.recv();\n                 let mut nh = normal_handle;\n                 nh.send(Shutdown);\n                 let mut sh = special_handle;\n                 sh.send(Shutdown);\n             };\n \n-            rtdebug!(\"normal task: {}\", borrow::to_uint(normal_task));\n \n-            let special_task = ~do GreenTask::new_root(&mut special_sched.stack_pool, None) {\n-                rtdebug!(\"*about to submit task1*\");\n-                Scheduler::run_task(task1);\n-                rtdebug!(\"*about to submit task3*\");\n-                Scheduler::run_task(task3);\n-                rtdebug!(\"*done with special_task*\");\n+            let special_task = do GreenTask::new(&mut special_sched.stack_pool,\n+                                                 None) {\n+                run(task1);\n+                run(task3);\n                 chan.send(());\n             };\n \n-            rtdebug!(\"special task: {}\", borrow::to_uint(special_task));\n \n             let normal_sched = normal_sched;\n             let normal_thread = do Thread::start {\n                 normal_sched.bootstrap(normal_task);\n-                rtdebug!(\"finished with normal_thread\");\n             };\n \n             let special_sched = special_sched;\n             let special_thread = do Thread::start {\n                 special_sched.bootstrap(special_task);\n-                rtdebug!(\"finished with special_sched\");\n             };\n \n             normal_thread.join();\n             special_thread.join();\n         }\n     }\n \n-    #[test]\n-    fn test_stress_schedule_task_states() {\n-        if util::limit_thread_creation_due_to_osx_and_valgrind() { return; }\n-        let n = stress_factor() * 120;\n-        for _ in range(0, n as int) {\n-            test_schedule_home_states();\n-        }\n-    }\n+    //#[test]\n+    //fn test_stress_schedule_task_states() {\n+    //    if util::limit_thread_creation_due_to_osx_and_valgrind() { return; }\n+    //    let n = stress_factor() * 120;\n+    //    for _ in range(0, n as int) {\n+    //        test_schedule_home_states();\n+    //    }\n+    //}\n \n     #[test]\n     fn test_io_callback() {\n-        use io::timer;\n-\n-        // This is a regression test that when there are no schedulable tasks\n-        // in the work queue, but we are performing I/O, that once we do put\n-        // something in the work queue again the scheduler picks it up and doesn't\n-        // exit before emptying the work queue\n-        do run_in_uv_task {\n-            do spawntask {\n+        use std::io::timer;\n+\n+        let mut pool = SchedPool::new(PoolConfig {\n+            threads: 2,\n+            event_loop_factory: None,\n+        });\n+\n+        // This is a regression test that when there are no schedulable tasks in\n+        // the work queue, but we are performing I/O, that once we do put\n+        // something in the work queue again the scheduler picks it up and\n+        // doesn't exit before emptying the work queue\n+        do pool.spawn(TaskOpts::new()) {\n+            do spawn {\n                 timer::sleep(10);\n             }\n         }\n+\n+        pool.shutdown();\n     }\n \n     #[test]\n-    fn handle() {\n-        do run_in_bare_thread {\n-            let (port, chan) = Chan::new();\n-\n-            let thread_one = do Thread::start {\n-                let chan = chan;\n-                do run_in_newsched_task_core {\n-                    chan.send(());\n-                }\n-            };\n-\n-            let thread_two = do Thread::start {\n-                let port = port;\n-                do run_in_newsched_task_core {\n-                    port.recv();\n-                }\n-            };\n+    fn wakeup_across_scheds() {\n+        let (port1, chan1) = Chan::new();\n+        let (port2, chan2) = Chan::new();\n+\n+        let mut pool1 = pool();\n+        let mut pool2 = pool();\n+\n+        do pool1.spawn(TaskOpts::new()) {\n+            let id = sched_id();\n+            chan1.send(());\n+            port2.recv();\n+            assert_eq!(id, sched_id());\n+        }\n \n-            thread_two.join();\n-            thread_one.join();\n+        do pool2.spawn(TaskOpts::new()) {\n+            let id = sched_id();\n+            port1.recv();\n+            assert_eq!(id, sched_id());\n+            chan2.send(());\n         }\n+\n+        pool1.shutdown();\n+        pool2.shutdown();\n     }\n \n     // A regression test that the final message is always handled.\n     // Used to deadlock because Shutdown was never recvd.\n     #[test]\n     fn no_missed_messages() {\n-        use rt::sleeper_list::SleeperList;\n-        use rt::stack::StackPool;\n-        use rt::sched::{Shutdown, TaskFromFriend};\n+        let mut pool = pool();\n \n-        do run_in_bare_thread {\n-            stress_factor().times(|| {\n-                let sleepers = SleeperList::new();\n-                let mut pool = BufferPool::new();\n-                let (worker, stealer) = pool.deque();\n-\n-                let mut sched = ~Scheduler::new(\n-                    basic::event_loop(),\n-                    worker,\n-                    ~[stealer],\n-                    sleepers.clone());\n-\n-                let mut handle = sched.make_handle();\n-\n-                let sched = sched;\n-                let thread = do Thread::start {\n-                    let mut sched = sched;\n-                    let bootstrap_task =\n-                        ~GreenTask::new_root(&mut sched.stack_pool,\n-                                        None,\n-                                        proc()());\n-                    sched.bootstrap(bootstrap_task);\n-                };\n+        let task = pool.task(TaskOpts::new(), proc()());\n+        pool.spawn_sched().send(TaskFromFriend(task));\n \n-                let mut stack_pool = StackPool::new();\n-                let task = ~GreenTask::new_root(&mut stack_pool, None, proc()());\n-                handle.send(TaskFromFriend(task));\n-\n-                handle.send(Shutdown);\n-                drop(handle);\n-\n-                thread.join();\n-            })\n-        }\n+        pool.shutdown();\n     }\n \n     #[test]\n     fn multithreading() {\n-        use num::Times;\n-        use vec::OwnedVector;\n-        use container::Container;\n-\n-        do run_in_mt_newsched_task {\n+        do run {\n             let mut ports = ~[];\n             10.times(|| {\n                 let (port, chan) = Chan::new();\n-                do spawntask_later {\n+                do spawn {\n                     chan.send(());\n                 }\n                 ports.push(port);\n@@ -1281,7 +1287,7 @@ mod test {\n \n      #[test]\n     fn thread_ring() {\n-        do run_in_mt_newsched_task {\n+        do run {\n             let (end_port, end_chan) = Chan::new();\n \n             let n_tasks = 10;\n@@ -1294,14 +1300,14 @@ mod test {\n                 let (next_p, ch) = Chan::new();\n                 let imm_i = i;\n                 let imm_p = p;\n-                do spawntask_random {\n+                do spawn {\n                     roundtrip(imm_i, n_tasks, &imm_p, &ch);\n                 };\n                 p = next_p;\n                 i += 1;\n             }\n             let p = p;\n-            do spawntask_random {\n+            do spawn {\n                 roundtrip(1, n_tasks, &p, &ch1);\n             }\n \n@@ -1332,11 +1338,9 @@ mod test {\n \n     #[test]\n     fn start_closure_dtor() {\n-        use ops::Drop;\n-\n         // Regression test that the `start` task entrypoint can\n         // contain dtors that use task resources\n-        do run_in_newsched_task {\n+        do run {\n             struct S { field: () }\n \n             impl Drop for S {\n@@ -1347,7 +1351,7 @@ mod test {\n \n             let s = S { field: () };\n \n-            do spawntask {\n+            do spawn {\n                 let _ss = &s;\n             }\n         }\n@@ -1357,52 +1361,49 @@ mod test {\n     #[ignore]\n     #[test]\n     fn dont_starve_1() {\n-        stress_factor().times(|| {\n-            do run_in_mt_newsched_task {\n-                let (port, chan) = Chan::new();\n-\n-                // This task should not be able to starve the sender;\n-                // The sender should get stolen to another thread.\n-                do spawntask {\n-                    while port.try_recv().is_none() { }\n-                }\n+        let mut pool = SchedPool::new(PoolConfig {\n+            threads: 2, // this must be > 1\n+            event_loop_factory: Some(basic::event_loop),\n+        });\n+        do pool.spawn(TaskOpts::new()) {\n+            let (port, chan) = Chan::new();\n \n-                chan.send(());\n+            // This task should not be able to starve the sender;\n+            // The sender should get stolen to another thread.\n+            do spawn {\n+                while port.try_recv().is_none() { }\n             }\n-        })\n+\n+            chan.send(());\n+        }\n+        pool.shutdown();\n     }\n \n     #[test]\n     fn dont_starve_2() {\n-        stress_factor().times(|| {\n-            do run_in_newsched_task {\n-                let (port, chan) = Chan::new();\n-                let (_port2, chan2) = Chan::new();\n+        do run {\n+            let (port, chan) = Chan::new();\n+            let (_port2, chan2) = Chan::new();\n \n-                // This task should not be able to starve the other task.\n-                // The sends should eventually yield.\n-                do spawntask {\n-                    while port.try_recv().is_none() {\n-                        chan2.send(());\n-                    }\n+            // This task should not be able to starve the other task.\n+            // The sends should eventually yield.\n+            do spawn {\n+                while port.try_recv().is_none() {\n+                    chan2.send(());\n                 }\n-\n-                chan.send(());\n             }\n-        })\n+\n+            chan.send(());\n+        }\n     }\n \n-    // Regression test for a logic bug that would cause single-threaded schedulers\n-    // to sleep forever after yielding and stealing another task.\n+    // Regression test for a logic bug that would cause single-threaded\n+    // schedulers to sleep forever after yielding and stealing another task.\n     #[test]\n     fn single_threaded_yield() {\n-        use task::{spawn, spawn_sched, SingleThreaded, deschedule};\n-        use num::Times;\n-\n-        do spawn_sched(SingleThreaded) {\n-            5.times(|| { deschedule(); })\n+        use std::task::deschedule;\n+        do run {\n+            5.times(deschedule);\n         }\n-        do spawn { }\n-        do spawn { }\n     }\n }"}, {"sha": "9da9af9f50bc8ca75c288de544ca43d8adff7852", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 86, "deletions": 75, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/aad9fbf6b65137f278d74cc84e0028a8f8aeed03/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aad9fbf6b65137f278d74cc84e0028a8f8aeed03/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=aad9fbf6b65137f278d74cc84e0028a8f8aeed03", "patch": "@@ -346,7 +346,7 @@ impl Runtime for GreenTask {\n         }\n     }\n \n-    fn reawaken(mut ~self, to_wake: ~Task, can_resched: bool) {\n+    fn reawaken(mut ~self, to_wake: ~Task) {\n         self.put_task(to_wake);\n         assert!(self.sched.is_none());\n \n@@ -371,21 +371,16 @@ impl Runtime for GreenTask {\n         let mut running_task: ~Task = Local::take();\n         match running_task.maybe_take_runtime::<GreenTask>() {\n             Some(mut running_green_task) => {\n-                let mut sched = running_green_task.sched.take_unwrap();\n+                running_green_task.put_task(running_task);\n+                let sched = running_green_task.sched.take_unwrap();\n+\n                 if sched.pool_id == self.pool_id {\n-                    running_green_task.put_task(running_task);\n-                    if can_resched {\n-                        sched.run_task(running_green_task, self);\n-                    } else {\n-                        sched.enqueue_task(self);\n-                        running_green_task.put_with_sched(sched);\n-                    }\n+                    sched.run_task(running_green_task, self);\n                 } else {\n                     self.reawaken_remotely();\n \n                     // put that thing back where it came from!\n-                    running_task.put_runtime(running_green_task as ~Runtime);\n-                    Local::put(running_task);\n+                    running_green_task.put_with_sched(sched);\n                 }\n             }\n             None => {\n@@ -427,94 +422,110 @@ impl Drop for GreenTask {\n }\n \n #[cfg(test)]\n-mod test {\n+mod tests {\n+    use std::rt::Runtime;\n+    use std::rt::local::Local;\n+    use std::rt::task::Task;\n+    use std::task;\n+    use std::task::TaskOpts;\n \n-    #[test]\n-    fn local_heap() {\n-        do run_in_newsched_task() {\n-            let a = @5;\n-            let b = a;\n-            assert!(*a == 5);\n-            assert!(*b == 5);\n-        }\n+    use super::super::{PoolConfig, SchedPool};\n+    use super::GreenTask;\n+\n+    fn spawn_opts(opts: TaskOpts, f: proc()) {\n+        let mut pool = SchedPool::new(PoolConfig {\n+            threads: 1,\n+            event_loop_factory: None,\n+        });\n+        pool.spawn(opts, f);\n+        pool.shutdown();\n     }\n \n     #[test]\n-    fn tls() {\n-        use std::local_data;\n-        do run_in_newsched_task() {\n-            local_data_key!(key: @~str)\n-            local_data::set(key, @~\"data\");\n-            assert!(*local_data::get(key, |k| k.map(|k| *k)).unwrap() == ~\"data\");\n-            local_data_key!(key2: @~str)\n-            local_data::set(key2, @~\"data\");\n-            assert!(*local_data::get(key2, |k| k.map(|k| *k)).unwrap() == ~\"data\");\n+    fn smoke() {\n+        let (p, c) = Chan::new();\n+        do spawn_opts(TaskOpts::new()) {\n+            c.send(());\n         }\n+        p.recv();\n     }\n \n     #[test]\n-    fn unwind() {\n-        do run_in_newsched_task() {\n-            let result = spawntask_try(proc()());\n-            rtdebug!(\"trying first assert\");\n-            assert!(result.is_ok());\n-            let result = spawntask_try(proc() fail!());\n-            rtdebug!(\"trying second assert\");\n-            assert!(result.is_err());\n+    fn smoke_fail() {\n+        let (p, c) = Chan::<()>::new();\n+        do spawn_opts(TaskOpts::new()) {\n+            let _c = c;\n+            fail!()\n         }\n+        assert_eq!(p.recv_opt(), None);\n     }\n \n     #[test]\n-    fn rng() {\n-        do run_in_uv_task() {\n-            use std::rand::{rng, Rng};\n-            let mut r = rng();\n-            let _ = r.next_u32();\n-        }\n+    fn smoke_opts() {\n+        let mut opts = TaskOpts::new();\n+        opts.name = Some(SendStrStatic(\"test\"));\n+        opts.stack_size = Some(20 * 4096);\n+        let (p, c) = Chan::new();\n+        opts.notify_chan = Some(c);\n+        spawn_opts(opts, proc() {});\n+        assert!(p.recv().is_ok());\n     }\n \n     #[test]\n-    fn logging() {\n-        do run_in_uv_task() {\n-            info!(\"here i am. logging in a newsched task\");\n-        }\n+    fn smoke_opts_fail() {\n+        let mut opts = TaskOpts::new();\n+        let (p, c) = Chan::new();\n+        opts.notify_chan = Some(c);\n+        spawn_opts(opts, proc() { fail!() });\n+        assert!(p.recv().is_err());\n     }\n \n     #[test]\n-    fn comm_stream() {\n-        do run_in_newsched_task() {\n-            let (port, chan) = Chan::new();\n-            chan.send(10);\n-            assert!(port.recv() == 10);\n+    fn yield_test() {\n+        let (p, c) = Chan::new();\n+        do spawn_opts(TaskOpts::new()) {\n+            10.times(task::deschedule);\n+            c.send(());\n         }\n+        p.recv();\n     }\n \n     #[test]\n-    fn comm_shared_chan() {\n-        do run_in_newsched_task() {\n-            let (port, chan) = SharedChan::new();\n-            chan.send(10);\n-            assert!(port.recv() == 10);\n+    fn spawn_children() {\n+        let (p, c) = Chan::new();\n+        do spawn_opts(TaskOpts::new()) {\n+            let (p, c2) = Chan::new();\n+            do spawn {\n+                let (p, c3) = Chan::new();\n+                do spawn {\n+                    c3.send(());\n+                }\n+                p.recv();\n+                c2.send(());\n+            }\n+            p.recv();\n+            c.send(());\n         }\n+        p.recv();\n     }\n \n-    //#[test]\n-    //fn heap_cycles() {\n-    //    use std::option::{Option, Some, None};\n-\n-    //    do run_in_newsched_task {\n-    //        struct List {\n-    //            next: Option<@mut List>,\n-    //        }\n-\n-    //        let a = @mut List { next: None };\n-    //        let b = @mut List { next: Some(a) };\n-\n-    //        a.next = Some(b);\n-    //    }\n-    //}\n-\n     #[test]\n-    #[should_fail]\n-    fn test_begin_unwind() { begin_unwind(\"cause\", file!(), line!()) }\n+    fn spawn_inherits() {\n+        let (p, c) = Chan::new();\n+        do spawn_opts(TaskOpts::new()) {\n+            let c = c;\n+            do spawn {\n+                let mut task: ~Task = Local::take();\n+                match task.maybe_take_runtime::<GreenTask>() {\n+                    Some(ops) => {\n+                        task.put_runtime(ops as ~Runtime);\n+                    }\n+                    None => fail!(),\n+                }\n+                Local::put(task);\n+                c.send(());\n+            }\n+        }\n+        p.recv();\n+    }\n }"}, {"sha": "48768def067e91abbc3701495e185e7c5e77d7c2", "filename": "src/libnative/task.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aad9fbf6b65137f278d74cc84e0028a8f8aeed03/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aad9fbf6b65137f278d74cc84e0028a8f8aeed03/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=aad9fbf6b65137f278d74cc84e0028a8f8aeed03", "patch": "@@ -227,6 +227,7 @@ mod tests {\n     use std::rt::local::Local;\n     use std::rt::task::Task;\n     use std::task;\n+    use std::task::TaskOpts;\n     use super::{spawn, spawn_opts, Ops};\n \n     #[test]"}, {"sha": "9c4473ead3682261d1c3be4add242e130cbfad92", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aad9fbf6b65137f278d74cc84e0028a8f8aeed03/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aad9fbf6b65137f278d74cc84e0028a8f8aeed03/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=aad9fbf6b65137f278d74cc84e0028a8f8aeed03", "patch": "@@ -207,9 +207,9 @@ mod test {\n         let port = timer.period(1);\n         port.recv();\n         port.recv();\n-        let port = timer.period(1);\n-        port.recv();\n-        port.recv();\n+        let port2 = timer.period(1);\n+        port2.recv();\n+        port2.recv();\n     }\n \n     #[test]"}]}