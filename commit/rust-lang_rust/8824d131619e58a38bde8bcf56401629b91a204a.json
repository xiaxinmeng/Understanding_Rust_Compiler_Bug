{"sha": "8824d131619e58a38bde8bcf56401629b91a204a", "node_id": "C_kwDOAAsO6NoAKDg4MjRkMTMxNjE5ZTU4YTM4YmRlOGJjZjU2NDAxNjI5YjkxYTIwNGE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-06T22:50:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-06T22:50:29Z"}, "message": "Auto merge of #98831 - RalfJung:no-more-unsized-locals, r=oli-obk\n\ninterpret: remove support for unsized_locals\n\nI added support for unsized_locals in https://github.com/rust-lang/rust/pull/59780 but the current implementation is a crude hack and IMO definitely not the right way to have unsized locals in MIR. It also [causes problems](https://rust-lang.zulipchat.com/#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Missing.20Layout.20Check.20in.20.60interpret.2Foperand.2Ers.60.3F). and what codegen does is unsound and has been for years since clearly nobody cares (so I hope nobody actually relies on that implementation and I'll be happy if Miri ensures they do not). I think if we want to have unsized locals in Miri/MIR we should add them properly, either by having a `StorageLive` that takes metadata or by having an `alloca` that returns a pointer (making the ptr indirection explicit) or something like that.\n\nSo, this PR removes the `LocalValue::Unallocated` hack. It adds `Immediate::Uninit`, for several reasons:\n- This lets us still do fairly little work in `push_stack_frame`, in particular we do not actually have to create any allocations.\n- If/when I remove `ScalarMaybeUninit`, we will need something like this to have an \"optimized\" representation of uninitialized locals. Without this we'd have to put uninitialized integers into the heap!\n- const-prop needs some way to indicate \"I don't know the value of this local'; it used to use `LocalValue::Unallocated` for that, now it can use `Immediate::Uninit`.\n\nThere is still a fundamental difference between `LocalValue::Unallocated` and `Immediate::Uninit`: the latter is considered a regular local that you can read from and write to, it just has a more optimized representation when compared with an actual `Allocation` that is fully uninit. In contrast, `LocalValue::Unallocated`  had this really odd behavior where you would write to it but not read from it. (This is in fact what caused the problems mentioned above.)\n\nWhile at it I also did two drive-by cleanups/improvements:\n- In `pop_stack_frame`, do the return value copying and local deallocation while the frame is still on the stack. This leads to better error locations being reported. The old errors were [sometimes rather confusing](https://rust-lang.zulipchat.com/#narrow/stream/269128-miri/topic/Cron.20Job.20Failure.202022-06-24/near/287445522).\n- Deduplicate `copy_op` and `copy_op_transmute`.\n\nr? `@oli-obk`", "tree": {"sha": "c7fb16ac77a9d9664cb5e8809dd2f1fca567a1a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7fb16ac77a9d9664cb5e8809dd2f1fca567a1a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8824d131619e58a38bde8bcf56401629b91a204a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8824d131619e58a38bde8bcf56401629b91a204a", "html_url": "https://github.com/rust-lang/rust/commit/8824d131619e58a38bde8bcf56401629b91a204a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8824d131619e58a38bde8bcf56401629b91a204a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7665c3543079ebc3710b676d0fd6951bedfd4b29", "url": "https://api.github.com/repos/rust-lang/rust/commits/7665c3543079ebc3710b676d0fd6951bedfd4b29", "html_url": "https://github.com/rust-lang/rust/commit/7665c3543079ebc3710b676d0fd6951bedfd4b29"}, {"sha": "dc9e0bf7825671ff40a6d27ee1e8758f3a2a31dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc9e0bf7825671ff40a6d27ee1e8758f3a2a31dc", "html_url": "https://github.com/rust-lang/rust/commit/dc9e0bf7825671ff40a6d27ee1e8758f3a2a31dc"}], "stats": {"total": 559, "additions": 300, "deletions": 259}, "files": [{"sha": "f84dd9521ee57204e379854fb0512981eacbb641", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8824d131619e58a38bde8bcf56401629b91a204a/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8824d131619e58a38bde8bcf56401629b91a204a/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=8824d131619e58a38bde8bcf56401629b91a204a", "patch": "@@ -189,6 +189,7 @@ pub(super) fn op_to_const<'tcx>(\n                 let len: usize = len.try_into().unwrap();\n                 ConstValue::Slice { data, start, end: start + len }\n             }\n+            Immediate::Uninit => to_const_value(&op.assert_mem_place()),\n         },\n     }\n }"}, {"sha": "5d598b65c72247c6f4339dfec964a6067bb22a67", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8824d131619e58a38bde8bcf56401629b91a204a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8824d131619e58a38bde8bcf56401629b91a204a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=8824d131619e58a38bde8bcf56401629b91a204a", "patch": "@@ -153,14 +153,15 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 assert_eq!(dest_layout.size, self.pointer_size());\n                 assert!(src.layout.ty.is_unsafe_ptr());\n                 return match **src {\n-                    Immediate::ScalarPair(data, _) => Ok(data.into()),\n+                    Immediate::ScalarPair(data, _) => Ok(data.check_init()?.into()),\n                     Immediate::Scalar(..) => span_bug!(\n                         self.cur_span(),\n                         \"{:?} input to a fat-to-thin cast ({:?} -> {:?})\",\n                         *src,\n                         src.layout.ty,\n                         cast_ty\n                     ),\n+                    Immediate::Uninit => throw_ub!(InvalidUninitBytes(None)),\n                 };\n             }\n         }\n@@ -358,7 +359,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     let src_field = self.operand_field(src, i)?;\n                     let dst_field = self.place_field(dest, i)?;\n                     if src_field.layout.ty == cast_ty_field.ty {\n-                        self.copy_op(&src_field, &dst_field)?;\n+                        self.copy_op(&src_field, &dst_field, /*allow_transmute*/ false)?;\n                     } else {\n                         self.unsize_into(&src_field, cast_ty_field, &dst_field)?;\n                     }"}, {"sha": "3892d1920cef7453b37875038704f03a80c0c353", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 56, "deletions": 53, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/8824d131619e58a38bde8bcf56401629b91a204a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8824d131619e58a38bde8bcf56401629b91a204a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=8824d131619e58a38bde8bcf56401629b91a204a", "patch": "@@ -112,6 +112,8 @@ pub struct Frame<'mir, 'tcx, Tag: Provenance = AllocId, Extra = ()> {\n     /// The locals are stored as `Option<Value>`s.\n     /// `None` represents a local that is currently dead, while a live local\n     /// can either directly contain `Scalar` or refer to some part of an `Allocation`.\n+    ///\n+    /// Do *not* access this directly; always go through the machine hook!\n     pub locals: IndexVec<mir::Local, LocalState<'tcx, Tag>>,\n \n     /// The span of the `tracing` crate is stored here.\n@@ -179,10 +181,6 @@ pub struct LocalState<'tcx, Tag: Provenance = AllocId> {\n pub enum LocalValue<Tag: Provenance = AllocId> {\n     /// This local is not currently alive, and cannot be used at all.\n     Dead,\n-    /// This local is alive but not yet allocated. It cannot be read from or have its address taken,\n-    /// and will be allocated on the first write. This is to support unsized locals, where we cannot\n-    /// know their size in advance.\n-    Unallocated,\n     /// A normal, live local.\n     /// Mostly for convenience, we re-use the `Operand` type here.\n     /// This is an optimization over just always having a pointer here;\n@@ -196,12 +194,10 @@ impl<'tcx, Tag: Provenance + 'static> LocalState<'tcx, Tag> {\n     ///\n     /// Note: This may only be invoked from the `Machine::access_local` hook and not from\n     /// anywhere else. You may be invalidating machine invariants if you do!\n-    pub fn access(&self) -> InterpResult<'tcx, Operand<Tag>> {\n-        match self.value {\n-            LocalValue::Dead => throw_ub!(DeadLocal),\n-            LocalValue::Unallocated => {\n-                bug!(\"The type checker should prevent reading from a never-written local\")\n-            }\n+    #[inline]\n+    pub fn access(&self) -> InterpResult<'tcx, &Operand<Tag>> {\n+        match &self.value {\n+            LocalValue::Dead => throw_ub!(DeadLocal), // could even be \"invalid program\"?\n             LocalValue::Live(val) => Ok(val),\n         }\n     }\n@@ -211,15 +207,11 @@ impl<'tcx, Tag: Provenance + 'static> LocalState<'tcx, Tag> {\n     ///\n     /// Note: This may only be invoked from the `Machine::access_local_mut` hook and not from\n     /// anywhere else. You may be invalidating machine invariants if you do!\n-    pub fn access_mut(\n-        &mut self,\n-    ) -> InterpResult<'tcx, Result<&mut LocalValue<Tag>, MemPlace<Tag>>> {\n-        match self.value {\n-            LocalValue::Dead => throw_ub!(DeadLocal),\n-            LocalValue::Live(Operand::Indirect(mplace)) => Ok(Err(mplace)),\n-            ref mut local @ (LocalValue::Live(Operand::Immediate(_)) | LocalValue::Unallocated) => {\n-                Ok(Ok(local))\n-            }\n+    #[inline]\n+    pub fn access_mut(&mut self) -> InterpResult<'tcx, &mut Operand<Tag>> {\n+        match &mut self.value {\n+            LocalValue::Dead => throw_ub!(DeadLocal), // could even be \"invalid program\"?\n+            LocalValue::Live(val) => Ok(val),\n         }\n     }\n }\n@@ -710,16 +702,15 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             })?;\n         }\n \n-        // Locals are initially unallocated.\n-        let dummy = LocalState { value: LocalValue::Unallocated, layout: Cell::new(None) };\n+        // Most locals are initially dead.\n+        let dummy = LocalState { value: LocalValue::Dead, layout: Cell::new(None) };\n         let mut locals = IndexVec::from_elem(dummy, &body.local_decls);\n \n-        // Now mark those locals as dead that we do not want to initialize\n-        // Mark locals that use `Storage*` annotations as dead on function entry.\n+        // Now mark those locals as live that have no `Storage*` annotations.\n         let always_live = always_live_locals(self.body());\n         for local in locals.indices() {\n-            if !always_live.contains(local) {\n-                locals[local].value = LocalValue::Dead;\n+            if always_live.contains(local) {\n+                locals[local].value = LocalValue::Live(Operand::Immediate(Immediate::Uninit));\n             }\n         }\n         // done\n@@ -791,59 +782,69 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             if unwinding { \"during unwinding\" } else { \"returning from function\" }\n         );\n \n-        // Sanity check `unwinding`.\n+        // Check `unwinding`.\n         assert_eq!(\n             unwinding,\n             match self.frame().loc {\n                 Ok(loc) => self.body().basic_blocks()[loc.block].is_cleanup,\n                 Err(_) => true,\n             }\n         );\n-\n         if unwinding && self.frame_idx() == 0 {\n             throw_ub_format!(\"unwinding past the topmost frame of the stack\");\n         }\n \n-        let frame =\n-            self.stack_mut().pop().expect(\"tried to pop a stack frame, but there were none\");\n-\n-        if !unwinding {\n-            let op = self.local_to_op(&frame, mir::RETURN_PLACE, None)?;\n-            self.copy_op_transmute(&op, &frame.return_place)?;\n-            trace!(\"{:?}\", self.dump_place(*frame.return_place));\n-        }\n-\n-        let return_to_block = frame.return_to_block;\n-\n-        // Now where do we jump next?\n+        // Copy return value. Must of course happen *before* we deallocate the locals.\n+        let copy_ret_result = if !unwinding {\n+            let op = self\n+                .local_to_op(self.frame(), mir::RETURN_PLACE, None)\n+                .expect(\"return place should always be live\");\n+            let dest = self.frame().return_place;\n+            let err = self.copy_op(&op, &dest, /*allow_transmute*/ true);\n+            trace!(\"return value: {:?}\", self.dump_place(*dest));\n+            // We delay actually short-circuiting on this error until *after* the stack frame is\n+            // popped, since we want this error to be attributed to the caller, whose type defines\n+            // this transmute.\n+            err\n+        } else {\n+            Ok(())\n+        };\n \n+        // Cleanup: deallocate locals.\n         // Usually we want to clean up (deallocate locals), but in a few rare cases we don't.\n-        // In that case, we return early. We also avoid validation in that case,\n-        // because this is CTFE and the final value will be thoroughly validated anyway.\n+        // We do this while the frame is still on the stack, so errors point to the callee.\n+        let return_to_block = self.frame().return_to_block;\n         let cleanup = match return_to_block {\n             StackPopCleanup::Goto { .. } => true,\n             StackPopCleanup::Root { cleanup, .. } => cleanup,\n         };\n+        if cleanup {\n+            // We need to take the locals out, since we need to mutate while iterating.\n+            let locals = mem::take(&mut self.frame_mut().locals);\n+            for local in &locals {\n+                self.deallocate_local(local.value)?;\n+            }\n+        }\n+\n+        // All right, now it is time to actually pop the frame.\n+        // Note that its locals are gone already, but that's fine.\n+        let frame =\n+            self.stack_mut().pop().expect(\"tried to pop a stack frame, but there were none\");\n+        // Report error from return value copy, if any.\n+        copy_ret_result?;\n \n+        // If we are not doing cleanup, also skip everything else.\n         if !cleanup {\n             assert!(self.stack().is_empty(), \"only the topmost frame should ever be leaked\");\n             assert!(!unwinding, \"tried to skip cleanup during unwinding\");\n-            // Leak the locals, skip validation, skip machine hook.\n+            // Skip machine hook.\n             return Ok(());\n         }\n-\n-        trace!(\"locals: {:#?}\", frame.locals);\n-\n-        // Cleanup: deallocate all locals that are backed by an allocation.\n-        for local in &frame.locals {\n-            self.deallocate_local(local.value)?;\n-        }\n-\n         if M::after_stack_pop(self, frame, unwinding)? == StackPopJump::NoJump {\n             // The hook already did everything.\n-            // We want to skip the `info!` below, hence early return.\n             return Ok(());\n         }\n+\n         // Normal return, figure out where to jump.\n         if unwinding {\n             // Follow the unwind edge.\n@@ -874,7 +875,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         assert!(local != mir::RETURN_PLACE, \"Cannot make return place live\");\n         trace!(\"{:?} is now live\", local);\n \n-        let local_val = LocalValue::Unallocated;\n+        let local_val = LocalValue::Live(Operand::Immediate(Immediate::Uninit));\n         // StorageLive expects the local to be dead, and marks it live.\n         let old = mem::replace(&mut self.frame_mut().locals[local].value, local_val);\n         if !matches!(old, LocalValue::Dead) {\n@@ -977,7 +978,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> std::fmt::Debug\n \n                 match self.ecx.stack()[frame].locals[local].value {\n                     LocalValue::Dead => write!(fmt, \" is dead\")?,\n-                    LocalValue::Unallocated => write!(fmt, \" is unallocated\")?,\n+                    LocalValue::Live(Operand::Immediate(Immediate::Uninit)) => {\n+                        write!(fmt, \" is uninitialized\")?\n+                    }\n                     LocalValue::Live(Operand::Indirect(mplace)) => {\n                         write!(\n                             fmt,"}, {"sha": "93b64d9d37a49e30e1290de7b776c49905a6a1e4", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8824d131619e58a38bde8bcf56401629b91a204a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8824d131619e58a38bde8bcf56401629b91a204a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=8824d131619e58a38bde8bcf56401629b91a204a", "patch": "@@ -174,7 +174,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let val =\n                     self.tcx.const_eval_global_id(self.param_env, gid, Some(self.tcx.span))?;\n                 let val = self.const_val_to_op(val, ty, Some(dest.layout))?;\n-                self.copy_op(&val, dest)?;\n+                self.copy_op(&val, dest, /*allow_transmute*/ false)?;\n             }\n \n             sym::ctpop\n@@ -394,7 +394,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             sym::transmute => {\n-                self.copy_op_transmute(&args[0], dest)?;\n+                self.copy_op(&args[0], dest, /*allow_transmute*/ true)?;\n             }\n             sym::assert_inhabited | sym::assert_zero_valid | sym::assert_uninit_valid => {\n                 let ty = instance.substs.type_at(0);\n@@ -461,7 +461,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     let place = self.mplace_index(&dest, i)?;\n                     let value =\n                         if i == index { *elem } else { self.mplace_index(&input, i)?.into() };\n-                    self.copy_op(&value, &place.into())?;\n+                    self.copy_op(&value, &place.into(), /*allow_transmute*/ false)?;\n                 }\n             }\n             sym::simd_extract => {\n@@ -473,11 +473,15 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     index,\n                     input_len\n                 );\n-                self.copy_op(&self.mplace_index(&input, index)?.into(), dest)?;\n+                self.copy_op(\n+                    &self.mplace_index(&input, index)?.into(),\n+                    dest,\n+                    /*allow_transmute*/ false,\n+                )?;\n             }\n             sym::likely | sym::unlikely | sym::black_box => {\n                 // These just return their argument\n-                self.copy_op(&args[0], dest)?;\n+                self.copy_op(&args[0], dest, /*allow_transmute*/ false)?;\n             }\n             sym::assume => {\n                 let cond = self.read_scalar(&args[0])?.check_init()?.to_bool()?;"}, {"sha": "b3461b414b67c09a8ad7b964b6367087dfb7e33a", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8824d131619e58a38bde8bcf56401629b91a204a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8824d131619e58a38bde8bcf56401629b91a204a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=8824d131619e58a38bde8bcf56401629b91a204a", "patch": "@@ -14,8 +14,7 @@ use rustc_target::spec::abi::Abi;\n \n use super::{\n     AllocId, AllocRange, Allocation, ConstAllocation, Frame, ImmTy, InterpCx, InterpResult,\n-    LocalValue, MemPlace, MemoryKind, OpTy, Operand, PlaceTy, Pointer, Provenance, Scalar,\n-    StackPopUnwind,\n+    MemoryKind, OpTy, Operand, PlaceTy, Pointer, Provenance, Scalar, StackPopUnwind,\n };\n \n /// Data returned by Machine::stack_pop,\n@@ -226,11 +225,13 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Since reading a ZST is not actually accessing memory or locals, this is never invoked\n     /// for ZST reads.\n     #[inline]\n-    fn access_local(\n-        _ecx: &InterpCx<'mir, 'tcx, Self>,\n-        frame: &Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>,\n+    fn access_local<'a>(\n+        frame: &'a Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>,\n         local: mir::Local,\n-    ) -> InterpResult<'tcx, Operand<Self::PointerTag>> {\n+    ) -> InterpResult<'tcx, &'a Operand<Self::PointerTag>>\n+    where\n+        'tcx: 'mir,\n+    {\n         frame.locals[local].access()\n     }\n \n@@ -242,7 +243,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n         frame: usize,\n         local: mir::Local,\n-    ) -> InterpResult<'tcx, Result<&'a mut LocalValue<Self::PointerTag>, MemPlace<Self::PointerTag>>>\n+    ) -> InterpResult<'tcx, &'a mut Operand<Self::PointerTag>>\n     where\n         'tcx: 'mir,\n     {\n@@ -418,12 +419,14 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     }\n \n     /// Called immediately after a stack frame got popped, but before jumping back to the caller.\n+    /// The `locals` have already been destroyed!\n     fn after_stack_pop(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _frame: Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>,\n-        _unwinding: bool,\n+        unwinding: bool,\n     ) -> InterpResult<'tcx, StackPopJump> {\n         // By default, we do not support unwinding from panics\n+        assert!(!unwinding);\n         Ok(StackPopJump::Normal)\n     }\n }"}, {"sha": "805dcb388953920460af1a8d6ef5e6ad7a499c33", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8824d131619e58a38bde8bcf56401629b91a204a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8824d131619e58a38bde8bcf56401629b91a204a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=8824d131619e58a38bde8bcf56401629b91a204a", "patch": "@@ -14,7 +14,7 @@ use rustc_target::abi::{self, Abi, Align, HasDataLayout, Size, TagEncoding};\n use rustc_target::abi::{VariantIdx, Variants};\n \n use super::{\n-    alloc_range, from_known_layout, mir_assign_valid_types, AllocId, ConstValue, GlobalId,\n+    alloc_range, from_known_layout, mir_assign_valid_types, AllocId, ConstValue, Frame, GlobalId,\n     InterpCx, InterpResult, MPlaceTy, Machine, MemPlace, Place, PlaceTy, Pointer,\n     PointerArithmetic, Provenance, Scalar, ScalarMaybeUninit,\n };\n@@ -28,8 +28,15 @@ use super::{\n /// defined on `Immediate`, and do not have to work with a `Place`.\n #[derive(Copy, Clone, PartialEq, Eq, HashStable, Hash, Debug)]\n pub enum Immediate<Tag: Provenance = AllocId> {\n+    /// A single scalar value (must have *initialized* `Scalar` ABI).\n+    /// FIXME: we also currently often use this for ZST.\n+    /// `ScalarMaybeUninit` should reject ZST, and we should use `Uninit` for them instead.\n     Scalar(ScalarMaybeUninit<Tag>),\n+    /// A pair of two scalar value (must have `ScalarPair` ABI where both fields are\n+    /// `Scalar::Initialized`).\n     ScalarPair(ScalarMaybeUninit<Tag>, ScalarMaybeUninit<Tag>),\n+    /// A value of fully uninitialized memory. Can have and size and layout.\n+    Uninit,\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n@@ -75,6 +82,7 @@ impl<'tcx, Tag: Provenance> Immediate<Tag> {\n         match self {\n             Immediate::Scalar(val) => val,\n             Immediate::ScalarPair(..) => bug!(\"Got a scalar pair where a scalar was expected\"),\n+            Immediate::Uninit => ScalarMaybeUninit::Uninit,\n         }\n     }\n \n@@ -88,6 +96,7 @@ impl<'tcx, Tag: Provenance> Immediate<Tag> {\n         match self {\n             Immediate::ScalarPair(val1, val2) => (val1, val2),\n             Immediate::Scalar(..) => bug!(\"Got a scalar where a scalar pair was expected\"),\n+            Immediate::Uninit => (ScalarMaybeUninit::Uninit, ScalarMaybeUninit::Uninit),\n         }\n     }\n \n@@ -149,7 +158,10 @@ impl<Tag: Provenance> std::fmt::Display for ImmTy<'_, Tag> {\n                 }\n                 Immediate::ScalarPair(a, b) => {\n                     // FIXME(oli-obk): at least print tuples and slices nicely\n-                    write!(f, \"({:x}, {:x}): {}\", a, b, self.layout.ty,)\n+                    write!(f, \"({:x}, {:x}): {}\", a, b, self.layout.ty)\n+                }\n+                Immediate::Uninit => {\n+                    write!(f, \"uninit: {}\", self.layout.ty)\n                 }\n             }\n         })\n@@ -397,7 +409,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         self.scalar_to_ptr(self.read_scalar(op)?.check_init()?)\n     }\n \n-    // Turn the wide MPlace into a string (must already be dereferenced!)\n+    /// Turn the wide MPlace into a string (must already be dereferenced!)\n     pub fn read_str(&self, mplace: &MPlaceTy<'tcx, M::PointerTag>) -> InterpResult<'tcx, &str> {\n         let len = mplace.len(self)?;\n         let bytes = self.read_bytes_ptr(mplace.ptr, Size::from_bytes(len))?;\n@@ -528,10 +540,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Will not access memory, instead an indirect `Operand` is returned.\n     ///\n     /// This is public because it is used by [priroda](https://github.com/oli-obk/priroda) to get an\n-    /// OpTy from a local\n+    /// OpTy from a local.\n     pub fn local_to_op(\n         &self,\n-        frame: &super::Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>,\n+        frame: &Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>,\n         local: mir::Local,\n         layout: Option<TyAndLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n@@ -540,7 +552,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // Do not read from ZST, they might not be initialized\n             Operand::Immediate(Scalar::ZST.into())\n         } else {\n-            M::access_local(&self, frame, local)?\n+            *M::access_local(frame, local)?\n         };\n         Ok(OpTy { op, layout, align: Some(layout.align.abi) })\n     }"}, {"sha": "57ecad07b42b4312686e57353362ff480e215c25", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 108, "deletions": 142, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/8824d131619e58a38bde8bcf56401629b91a204a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8824d131619e58a38bde8bcf56401629b91a204a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=8824d131619e58a38bde8bcf56401629b91a204a", "patch": "@@ -10,13 +10,14 @@ use rustc_macros::HashStable;\n use rustc_middle::mir;\n use rustc_middle::ty::layout::{LayoutOf, PrimitiveExt, TyAndLayout};\n use rustc_middle::ty::{self, Ty};\n-use rustc_target::abi::{Abi, Align, FieldsShape, TagEncoding};\n-use rustc_target::abi::{HasDataLayout, Size, VariantIdx, Variants};\n+use rustc_target::abi::{\n+    Abi, Align, FieldsShape, HasDataLayout, Size, TagEncoding, VariantIdx, Variants,\n+};\n \n use super::{\n     alloc_range, mir_assign_valid_types, AllocId, AllocRef, AllocRefMut, CheckInAllocMsg,\n-    ConstAlloc, ImmTy, Immediate, InterpCx, InterpResult, LocalValue, Machine, MemoryKind, OpTy,\n-    Operand, Pointer, Provenance, Scalar, ScalarMaybeUninit,\n+    ConstAlloc, ImmTy, Immediate, InterpCx, InterpResult, Machine, MemoryKind, OpTy, Operand,\n+    Pointer, Provenance, Scalar, ScalarMaybeUninit,\n };\n \n #[derive(Copy, Clone, Hash, PartialEq, Eq, HashStable, Debug)]\n@@ -183,6 +184,18 @@ impl<Tag: Provenance> MemPlace<Tag> {\n     }\n }\n \n+impl<Tag: Provenance> Place<Tag> {\n+    /// Asserts that this points to some local variable.\n+    /// Returns the frame idx and the variable idx.\n+    #[inline]\n+    pub fn assert_local(&self) -> (usize, mir::Local) {\n+        match self {\n+            Place::Local { frame, local } => (*frame, *local),\n+            _ => bug!(\"assert_local: expected Place::Local, got {:?}\", self),\n+        }\n+    }\n+}\n+\n impl<'tcx, Tag: Provenance> MPlaceTy<'tcx, Tag> {\n     /// Produces a MemPlace that works for ZST but nothing else\n     #[inline]\n@@ -286,7 +299,7 @@ impl<'tcx, Tag: Provenance> PlaceTy<'tcx, Tag> {\n     }\n \n     #[inline]\n-    pub fn assert_mem_place(self) -> MPlaceTy<'tcx, Tag> {\n+    pub fn assert_mem_place(&self) -> MPlaceTy<'tcx, Tag> {\n         self.try_as_mplace().unwrap()\n     }\n }\n@@ -314,6 +327,7 @@ where\n         let (ptr, meta) = match **val {\n             Immediate::Scalar(ptr) => (ptr, MemPlaceMeta::None),\n             Immediate::ScalarPair(ptr, meta) => (ptr, MemPlaceMeta::Meta(meta.check_init()?)),\n+            Immediate::Uninit => throw_ub!(InvalidUninitBytes(None)),\n         };\n \n         let mplace = MemPlace { ptr: self.scalar_to_ptr(ptr.check_init()?)?, meta };\n@@ -746,64 +760,64 @@ where\n         let mplace = match dest.place {\n             Place::Local { frame, local } => {\n                 match M::access_local_mut(self, frame, local)? {\n-                    Ok(local) => {\n+                    Operand::Immediate(local) => {\n                         // Local can be updated in-place.\n-                        *local = LocalValue::Live(Operand::Immediate(src));\n+                        *local = src;\n                         return Ok(());\n                     }\n-                    Err(mplace) => {\n+                    Operand::Indirect(mplace) => {\n                         // The local is in memory, go on below.\n-                        mplace\n+                        *mplace\n                     }\n                 }\n             }\n             Place::Ptr(mplace) => mplace, // already referring to memory\n         };\n-        let dest = MPlaceTy { mplace, layout: dest.layout, align: dest.align };\n \n         // This is already in memory, write there.\n-        self.write_immediate_to_mplace_no_validate(src, &dest)\n+        self.write_immediate_to_mplace_no_validate(src, dest.layout, dest.align, mplace)\n     }\n \n     /// Write an immediate to memory.\n     /// If you use this you are responsible for validating that things got copied at the\n-    /// right type.\n+    /// right layout.\n     fn write_immediate_to_mplace_no_validate(\n         &mut self,\n         value: Immediate<M::PointerTag>,\n-        dest: &MPlaceTy<'tcx, M::PointerTag>,\n+        layout: TyAndLayout<'tcx>,\n+        align: Align,\n+        dest: MemPlace<M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         // Note that it is really important that the type here is the right one, and matches the\n         // type things are read at. In case `value` is a `ScalarPair`, we don't do any magic here\n         // to handle padding properly, which is only correct if we never look at this data with the\n         // wrong type.\n \n         let tcx = *self.tcx;\n-        let Some(mut alloc) = self.get_place_alloc_mut(dest)? else {\n+        let Some(mut alloc) = self.get_place_alloc_mut(&MPlaceTy { mplace: dest, layout, align })? else {\n             // zero-sized access\n             return Ok(());\n         };\n \n         match value {\n             Immediate::Scalar(scalar) => {\n-                let Abi::Scalar(s) = dest.layout.abi else { span_bug!(\n+                let Abi::Scalar(s) = layout.abi else { span_bug!(\n                         self.cur_span(),\n-                        \"write_immediate_to_mplace: invalid Scalar layout: {:#?}\",\n-                        dest.layout\n+                        \"write_immediate_to_mplace: invalid Scalar layout: {layout:#?}\",\n                     )\n                 };\n                 let size = s.size(&tcx);\n-                assert_eq!(size, dest.layout.size, \"abi::Scalar size does not match layout size\");\n+                assert_eq!(size, layout.size, \"abi::Scalar size does not match layout size\");\n                 alloc.write_scalar(alloc_range(Size::ZERO, size), scalar)\n             }\n             Immediate::ScalarPair(a_val, b_val) => {\n                 // We checked `ptr_align` above, so all fields will have the alignment they need.\n                 // We would anyway check against `ptr_align.restrict_for_offset(b_offset)`,\n                 // which `ptr.offset(b_offset)` cannot possibly fail to satisfy.\n-                let Abi::ScalarPair(a, b) = dest.layout.abi else { span_bug!(\n+                let Abi::ScalarPair(a, b) = layout.abi else { span_bug!(\n                         self.cur_span(),\n                         \"write_immediate_to_mplace: invalid ScalarPair layout: {:#?}\",\n-                        dest.layout\n+                        layout\n                     )\n                 };\n                 let (a_size, b_size) = (a.size(&tcx), b.size(&tcx));\n@@ -817,6 +831,7 @@ where\n                 alloc.write_scalar(alloc_range(Size::ZERO, a_size), a_val)?;\n                 alloc.write_scalar(alloc_range(b_offset, b_size), b_val)\n             }\n+            Immediate::Uninit => alloc.write_uninit(),\n         }\n     }\n \n@@ -825,25 +840,13 @@ where\n             Ok(mplace) => mplace,\n             Err((frame, local)) => {\n                 match M::access_local_mut(self, frame, local)? {\n-                    Ok(local) => match dest.layout.abi {\n-                        Abi::Scalar(_) => {\n-                            *local = LocalValue::Live(Operand::Immediate(Immediate::Scalar(\n-                                ScalarMaybeUninit::Uninit,\n-                            )));\n-                            return Ok(());\n-                        }\n-                        Abi::ScalarPair(..) => {\n-                            *local = LocalValue::Live(Operand::Immediate(Immediate::ScalarPair(\n-                                ScalarMaybeUninit::Uninit,\n-                                ScalarMaybeUninit::Uninit,\n-                            )));\n-                            return Ok(());\n-                        }\n-                        _ => self.force_allocation(dest)?,\n-                    },\n-                    Err(mplace) => {\n+                    Operand::Immediate(local) => {\n+                        *local = Immediate::Uninit;\n+                        return Ok(());\n+                    }\n+                    Operand::Indirect(mplace) => {\n                         // The local is in memory, go on below.\n-                        MPlaceTy { mplace, layout: dest.layout, align: dest.align }\n+                        MPlaceTy { mplace: *mplace, layout: dest.layout, align: dest.align }\n                     }\n                 }\n             }\n@@ -856,16 +859,17 @@ where\n         Ok(())\n     }\n \n-    /// Copies the data from an operand to a place. This does not support transmuting!\n-    /// Use `copy_op_transmute` if the layouts could disagree.\n+    /// Copies the data from an operand to a place.\n+    /// `allow_transmute` indicates whether the layouts may disagree.\n     #[inline(always)]\n     #[instrument(skip(self), level = \"debug\")]\n     pub fn copy_op(\n         &mut self,\n         src: &OpTy<'tcx, M::PointerTag>,\n         dest: &PlaceTy<'tcx, M::PointerTag>,\n+        allow_transmute: bool,\n     ) -> InterpResult<'tcx> {\n-        self.copy_op_no_validate(src, dest)?;\n+        self.copy_op_no_validate(src, dest, allow_transmute)?;\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n@@ -875,19 +879,22 @@ where\n         Ok(())\n     }\n \n-    /// Copies the data from an operand to a place. This does not support transmuting!\n-    /// Use `copy_op_transmute` if the layouts could disagree.\n+    /// Copies the data from an operand to a place.\n+    /// `allow_transmute` indicates whether the layouts may disagree.\n     /// Also, if you use this you are responsible for validating that things get copied at the\n     /// right type.\n     #[instrument(skip(self), level = \"debug\")]\n     fn copy_op_no_validate(\n         &mut self,\n         src: &OpTy<'tcx, M::PointerTag>,\n         dest: &PlaceTy<'tcx, M::PointerTag>,\n+        allow_transmute: bool,\n     ) -> InterpResult<'tcx> {\n         // We do NOT compare the types for equality, because well-typed code can\n         // actually \"transmute\" `&mut T` to `&T` in an assignment without a cast.\n-        if !mir_assign_valid_types(*self.tcx, self.param_env, src.layout, dest.layout) {\n+        let layout_compat =\n+            mir_assign_valid_types(*self.tcx, self.param_env, src.layout, dest.layout);\n+        if !allow_transmute && !layout_compat {\n             span_bug!(\n                 self.cur_span(),\n                 \"type mismatch when copying!\\nsrc: {:?},\\ndest: {:?}\",\n@@ -896,152 +903,111 @@ where\n             );\n         }\n \n-        // Let us see if the layout is simple so we take a shortcut, avoid force_allocation.\n+        // Let us see if the layout is simple so we take a shortcut,\n+        // avoid force_allocation.\n         let src = match self.read_immediate_raw(src, /*force*/ false)? {\n             Ok(src_val) => {\n                 assert!(!src.layout.is_unsized(), \"cannot have unsized immediates\");\n+                assert!(\n+                    !dest.layout.is_unsized(),\n+                    \"the src is sized, so the dest must also be sized\"\n+                );\n+                assert_eq!(src.layout.size, dest.layout.size);\n                 // Yay, we got a value that we can write directly.\n-                return self.write_immediate_no_validate(*src_val, dest);\n+                return if layout_compat {\n+                    self.write_immediate_no_validate(*src_val, dest)\n+                } else {\n+                    // This is tricky. The problematic case is `ScalarPair`: the `src_val` was\n+                    // loaded using the offsets defined by `src.layout`. When we put this back into\n+                    // the destination, we have to use the same offsets! So (a) we make sure we\n+                    // write back to memory, and (b) we use `dest` *with the source layout*.\n+                    let dest_mem = self.force_allocation(dest)?;\n+                    self.write_immediate_to_mplace_no_validate(\n+                        *src_val,\n+                        src.layout,\n+                        dest_mem.align,\n+                        *dest_mem,\n+                    )\n+                };\n             }\n             Err(mplace) => mplace,\n         };\n         // Slow path, this does not fit into an immediate. Just memcpy.\n         trace!(\"copy_op: {:?} <- {:?}: {}\", *dest, src, dest.layout.ty);\n \n-        // This interprets `src.meta` with the `dest` local's layout, if an unsized local\n-        // is being initialized!\n-        let (dest, size) = self.force_allocation_maybe_sized(dest, src.meta)?;\n-        let size = size.unwrap_or_else(|| {\n-            assert!(\n-                !dest.layout.is_unsized(),\n-                \"Cannot copy into already initialized unsized place\"\n-            );\n-            dest.layout.size\n-        });\n-        assert_eq!(src.meta, dest.meta, \"Can only copy between equally-sized instances\");\n-\n-        self.mem_copy(src.ptr, src.align, dest.ptr, dest.align, size, /*nonoverlapping*/ false)\n-    }\n-\n-    /// Copies the data from an operand to a place. The layouts may disagree, but they must\n-    /// have the same size.\n-    pub fn copy_op_transmute(\n-        &mut self,\n-        src: &OpTy<'tcx, M::PointerTag>,\n-        dest: &PlaceTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx> {\n-        if mir_assign_valid_types(*self.tcx, self.param_env, src.layout, dest.layout) {\n-            // Fast path: Just use normal `copy_op`\n-            return self.copy_op(src, dest);\n-        }\n-        // We still require the sizes to match.\n-        if src.layout.size != dest.layout.size {\n-            span_bug!(\n-                self.cur_span(),\n-                \"size-changing transmute, should have been caught by transmute checking: {:#?}\\ndest: {:#?}\",\n-                src,\n-                dest\n-            );\n-        }\n-        // Unsized copies rely on interpreting `src.meta` with `dest.layout`, we want\n-        // to avoid that here.\n-        assert!(\n-            !src.layout.is_unsized() && !dest.layout.is_unsized(),\n-            \"Cannot transmute unsized data\"\n-        );\n-\n-        // The hard case is `ScalarPair`.  `src` is already read from memory in this case,\n-        // using `src.layout` to figure out which bytes to use for the 1st and 2nd field.\n-        // We have to write them to `dest` at the offsets they were *read at*, which is\n-        // not necessarily the same as the offsets in `dest.layout`!\n-        // Hence we do the copy with the source layout on both sides.  We also make sure to write\n-        // into memory, because if `dest` is a local we would not even have a way to write\n-        // at the `src` offsets; the fact that we came from a different layout would\n-        // just be lost.\n-        let dest = self.force_allocation(dest)?;\n-        self.copy_op_no_validate(\n-            src,\n-            &PlaceTy::from(MPlaceTy { mplace: *dest, layout: src.layout, align: dest.align }),\n-        )?;\n-\n-        if M::enforce_validity(self) {\n-            // Data got changed, better make sure it matches the type!\n-            self.validate_operand(&dest.into())?;\n+        let dest = self.force_allocation(&dest)?;\n+        let Some((dest_size, _)) = self.size_and_align_of_mplace(&dest)? else {\n+            span_bug!(self.cur_span(), \"copy_op needs (dynamically) sized values\")\n+        };\n+        if cfg!(debug_assertions) {\n+            let src_size = self.size_and_align_of_mplace(&src)?.unwrap().0;\n+            assert_eq!(src_size, dest_size, \"Cannot copy differently-sized data\");\n+        } else {\n+            // As a cheap approximation, we compare the fixed parts of the size.\n+            assert_eq!(src.layout.size, dest.layout.size);\n         }\n \n-        Ok(())\n+        self.mem_copy(\n+            src.ptr, src.align, dest.ptr, dest.align, dest_size, /*nonoverlapping*/ false,\n+        )\n     }\n \n     /// Ensures that a place is in memory, and returns where it is.\n     /// If the place currently refers to a local that doesn't yet have a matching allocation,\n     /// create such an allocation.\n     /// This is essentially `force_to_memplace`.\n-    ///\n-    /// This supports unsized types and returns the computed size to avoid some\n-    /// redundant computation when copying; use `force_allocation` for a simpler, sized-only\n-    /// version.\n     #[instrument(skip(self), level = \"debug\")]\n-    pub fn force_allocation_maybe_sized(\n+    pub fn force_allocation(\n         &mut self,\n         place: &PlaceTy<'tcx, M::PointerTag>,\n-        meta: MemPlaceMeta<M::PointerTag>,\n-    ) -> InterpResult<'tcx, (MPlaceTy<'tcx, M::PointerTag>, Option<Size>)> {\n-        let (mplace, size) = match place.place {\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+        let mplace = match place.place {\n             Place::Local { frame, local } => {\n                 match M::access_local_mut(self, frame, local)? {\n-                    Ok(&mut local_val) => {\n+                    &mut Operand::Immediate(local_val) => {\n                         // We need to make an allocation.\n \n                         // We need the layout of the local.  We can NOT use the layout we got,\n                         // that might e.g., be an inner field of a struct with `Scalar` layout,\n                         // that has different alignment than the outer field.\n                         let local_layout =\n                             self.layout_of_local(&self.stack()[frame], local, None)?;\n-                        // We also need to support unsized types, and hence cannot use `allocate`.\n-                        let (size, align) = self\n-                            .size_and_align_of(&meta, &local_layout)?\n-                            .expect(\"Cannot allocate for non-dyn-sized type\");\n-                        let ptr = self.allocate_ptr(size, align, MemoryKind::Stack)?;\n-                        let mplace = MemPlace { ptr: ptr.into(), meta };\n-                        if let LocalValue::Live(Operand::Immediate(value)) = local_val {\n-                            // Preserve old value.\n+                        if local_layout.is_unsized() {\n+                            throw_unsup_format!(\"unsized locals are not supported\");\n+                        }\n+                        let mplace = *self.allocate(local_layout, MemoryKind::Stack)?;\n+                        if !matches!(local_val, Immediate::Uninit) {\n+                            // Preserve old value. (As an optimization, we can skip this if it was uninit.)\n                             // We don't have to validate as we can assume the local\n                             // was already valid for its type.\n-                            let mplace = MPlaceTy {\n+                            self.write_immediate_to_mplace_no_validate(\n+                                local_val,\n+                                local_layout,\n+                                local_layout.align.abi,\n                                 mplace,\n-                                layout: local_layout,\n-                                align: local_layout.align.abi,\n-                            };\n-                            self.write_immediate_to_mplace_no_validate(value, &mplace)?;\n+                            )?;\n                         }\n                         // Now we can call `access_mut` again, asserting it goes well,\n                         // and actually overwrite things.\n-                        *M::access_local_mut(self, frame, local).unwrap().unwrap() =\n-                            LocalValue::Live(Operand::Indirect(mplace));\n-                        (mplace, Some(size))\n+                        *M::access_local_mut(self, frame, local).unwrap() =\n+                            Operand::Indirect(mplace);\n+                        mplace\n                     }\n-                    Err(mplace) => (mplace, None), // this already was an indirect local\n+                    &mut Operand::Indirect(mplace) => mplace, // this already was an indirect local\n                 }\n             }\n-            Place::Ptr(mplace) => (mplace, None),\n+            Place::Ptr(mplace) => mplace,\n         };\n         // Return with the original layout, so that the caller can go on\n-        Ok((MPlaceTy { mplace, layout: place.layout, align: place.align }, size))\n-    }\n-\n-    #[inline(always)]\n-    pub fn force_allocation(\n-        &mut self,\n-        place: &PlaceTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n-        Ok(self.force_allocation_maybe_sized(place, MemPlaceMeta::None)?.0)\n+        Ok(MPlaceTy { mplace, layout: place.layout, align: place.align })\n     }\n \n     pub fn allocate(\n         &mut self,\n         layout: TyAndLayout<'tcx>,\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+        assert!(!layout.is_unsized());\n         let ptr = self.allocate_ptr(layout.size, layout.align.abi, kind)?;\n         Ok(MPlaceTy::from_aligned_ptr(ptr.into(), layout))\n     }"}, {"sha": "240910c08b2ed2ddf1cfa10623c693ed8e6a1377", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8824d131619e58a38bde8bcf56401629b91a204a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8824d131619e58a38bde8bcf56401629b91a204a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=8824d131619e58a38bde8bcf56401629b91a204a", "patch": "@@ -169,7 +169,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Use(ref operand) => {\n                 // Avoid recomputing the layout\n                 let op = self.eval_operand(operand, Some(dest.layout))?;\n-                self.copy_op(&op, &dest)?;\n+                self.copy_op(&op, &dest, /*allow_transmute*/ false)?;\n             }\n \n             BinaryOp(bin_op, box (ref left, ref right)) => {\n@@ -204,7 +204,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 for (field_index, operand) in operands.iter().enumerate() {\n                     let op = self.eval_operand(operand, None)?;\n                     let field_dest = self.place_field(&dest, field_index)?;\n-                    self.copy_op(&op, &field_dest)?;\n+                    self.copy_op(&op, &field_dest, /*allow_transmute*/ false)?;\n                 }\n             }\n \n@@ -220,7 +220,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 } else {\n                     // Write the src to the first element.\n                     let first = self.mplace_field(&dest, 0)?;\n-                    self.copy_op(&src, &first.into())?;\n+                    self.copy_op(&src, &first.into(), /*allow_transmute*/ false)?;\n \n                     // This is performance-sensitive code for big static/const arrays! So we\n                     // avoid writing each operand individually and instead just make many copies"}, {"sha": "515cc222dc69a21b75218e5495da73cf6d108a1b", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8824d131619e58a38bde8bcf56401629b91a204a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8824d131619e58a38bde8bcf56401629b91a204a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=8824d131619e58a38bde8bcf56401629b91a204a", "patch": "@@ -12,8 +12,8 @@ use rustc_target::abi::call::{ArgAbi, ArgAttribute, ArgAttributes, FnAbi, PassMo\n use rustc_target::spec::abi::Abi;\n \n use super::{\n-    FnVal, ImmTy, InterpCx, InterpResult, MPlaceTy, Machine, OpTy, PlaceTy, Scalar,\n-    StackPopCleanup, StackPopUnwind,\n+    FnVal, ImmTy, Immediate, InterpCx, InterpResult, MPlaceTy, Machine, MemoryKind, OpTy, Operand,\n+    PlaceTy, Scalar, StackPopCleanup, StackPopUnwind,\n };\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n@@ -185,11 +185,16 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // No question\n                 return true;\n             }\n+            if caller_abi.layout.is_unsized() || callee_abi.layout.is_unsized() {\n+                // No, no, no. We require the types to *exactly* match for unsized arguments. If\n+                // these are somehow unsized \"in a different way\" (say, `dyn Trait` vs `[i32]`),\n+                // then who knows what happens.\n+                return false;\n+            }\n             if caller_abi.layout.size != callee_abi.layout.size\n                 || caller_abi.layout.align.abi != callee_abi.layout.align.abi\n             {\n                 // This cannot go well...\n-                // FIXME: What about unsized types?\n                 return false;\n             }\n             // The rest *should* be okay, but we are extra conservative.\n@@ -287,11 +292,36 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 caller_arg.layout.ty\n             )\n         }\n+        // Special handling for unsized parameters.\n+        if caller_arg.layout.is_unsized() {\n+            // `check_argument_compat` ensures that both have the same type, so we know they will use the metadata the same way.\n+            assert_eq!(caller_arg.layout.ty, callee_arg.layout.ty);\n+            // We have to properly pre-allocate the memory for the callee.\n+            // So let's tear down some wrappers.\n+            // This all has to be in memory, there are no immediate unsized values.\n+            let src = caller_arg.assert_mem_place();\n+            // The destination cannot be one of these \"spread args\".\n+            let (dest_frame, dest_local) = callee_arg.assert_local();\n+            // We are just initializing things, so there can't be anything here yet.\n+            assert!(matches!(\n+                *self.local_to_op(&self.stack()[dest_frame], dest_local, None)?,\n+                Operand::Immediate(Immediate::Uninit)\n+            ));\n+            // Allocate enough memory to hold `src`.\n+            let Some((size, align)) = self.size_and_align_of_mplace(&src)? else {\n+                span_bug!(self.cur_span(), \"unsized fn arg with `extern` type tail should not be allowed\")\n+            };\n+            let ptr = self.allocate_ptr(size, align, MemoryKind::Stack)?;\n+            let dest_place =\n+                MPlaceTy::from_aligned_ptr_with_meta(ptr.into(), callee_arg.layout, src.meta);\n+            // Update the local to be that new place.\n+            *M::access_local_mut(self, dest_frame, dest_local)? = Operand::Indirect(*dest_place);\n+        }\n         // We allow some transmutes here.\n         // FIXME: Depending on the PassMode, this should reset some padding to uninitialized. (This\n         // is true for all `copy_op`, but there are a lot of special cases for argument passing\n         // specifically.)\n-        self.copy_op_transmute(&caller_arg, callee_arg)\n+        self.copy_op(&caller_arg, callee_arg, /*allow_transmute*/ true)\n     }\n \n     /// Call this function -- pushing the stack frame and initializing the arguments."}, {"sha": "01eda979f9ec95446c8e1c05e80ad34d541ae20a", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8824d131619e58a38bde8bcf56401629b91a204a/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8824d131619e58a38bde8bcf56401629b91a204a/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=8824d131619e58a38bde8bcf56401629b91a204a", "patch": "@@ -29,9 +29,8 @@ use rustc_trait_selection::traits;\n use crate::MirPass;\n use rustc_const_eval::interpret::{\n     self, compile_time_machine, AllocId, ConstAllocation, ConstValue, CtfeValidationMode, Frame,\n-    ImmTy, Immediate, InterpCx, InterpResult, LocalState, LocalValue, MemPlace, MemoryKind, OpTy,\n-    Operand as InterpOperand, PlaceTy, Pointer, Scalar, ScalarMaybeUninit, StackPopCleanup,\n-    StackPopUnwind,\n+    ImmTy, Immediate, InterpCx, InterpResult, LocalState, LocalValue, MemoryKind, OpTy, PlaceTy,\n+    Pointer, Scalar, ScalarMaybeUninit, StackPopCleanup, StackPopUnwind,\n };\n \n /// The maximum number of bytes that we'll allocate space for a local or the return value.\n@@ -237,15 +236,19 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         throw_machine_stop_str!(\"pointer arithmetic or comparisons aren't supported in ConstProp\")\n     }\n \n-    fn access_local(\n-        _ecx: &InterpCx<'mir, 'tcx, Self>,\n-        frame: &Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>,\n+    fn access_local<'a>(\n+        frame: &'a Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>,\n         local: Local,\n-    ) -> InterpResult<'tcx, InterpOperand<Self::PointerTag>> {\n+    ) -> InterpResult<'tcx, &'a interpret::Operand<Self::PointerTag>> {\n         let l = &frame.locals[local];\n \n-        if l.value == LocalValue::Unallocated {\n-            throw_machine_stop_str!(\"tried to access an unallocated local\")\n+        if matches!(\n+            l.value,\n+            LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit))\n+        ) {\n+            // For us \"uninit\" means \"we don't know its value, might be initiailized or not\".\n+            // So stop here.\n+            throw_machine_stop_str!(\"tried to access alocal with unknown value \")\n         }\n \n         l.access()\n@@ -255,8 +258,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n         frame: usize,\n         local: Local,\n-    ) -> InterpResult<'tcx, Result<&'a mut LocalValue<Self::PointerTag>, MemPlace<Self::PointerTag>>>\n-    {\n+    ) -> InterpResult<'tcx, &'a mut interpret::Operand<Self::PointerTag>> {\n         if ecx.machine.can_const_prop[local] == ConstPropMode::NoPropagation {\n             throw_machine_stop_str!(\"tried to write to a local that is marked as not propagatable\")\n         }\n@@ -391,7 +393,11 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             .layout_of(EarlyBinder(body.return_ty()).subst(tcx, substs))\n             .ok()\n             // Don't bother allocating memory for large values.\n-            .filter(|ret_layout| ret_layout.size < Size::from_bytes(MAX_ALLOC_LIMIT))\n+            // I don't know how return types can seem to be unsized but this happens in the\n+            // `type/type-unsatisfiable.rs` test.\n+            .filter(|ret_layout| {\n+                !ret_layout.is_unsized() && ret_layout.size < Size::from_bytes(MAX_ALLOC_LIMIT)\n+            })\n             .unwrap_or_else(|| ecx.layout_of(tcx.types.unit).unwrap());\n \n         let ret = ecx\n@@ -436,8 +442,10 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     /// Remove `local` from the pool of `Locals`. Allows writing to them,\n     /// but not reading from them anymore.\n     fn remove_const(ecx: &mut InterpCx<'mir, 'tcx, ConstPropMachine<'mir, 'tcx>>, local: Local) {\n-        ecx.frame_mut().locals[local] =\n-            LocalState { value: LocalValue::Unallocated, layout: Cell::new(None) };\n+        ecx.frame_mut().locals[local] = LocalState {\n+            value: LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit)),\n+            layout: Cell::new(None),\n+        };\n     }\n \n     fn use_ecx<F, T>(&mut self, f: F) -> Option<T>\n@@ -1042,7 +1050,9 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                     let frame = self.ecx.frame_mut();\n                     frame.locals[local].value =\n                         if let StatementKind::StorageLive(_) = statement.kind {\n-                            LocalValue::Unallocated\n+                            LocalValue::Live(interpret::Operand::Immediate(\n+                                interpret::Immediate::Uninit,\n+                            ))\n                         } else {\n                             LocalValue::Dead\n                         };"}, {"sha": "280ed17f03cf53ed7f3fb9d315d067ddea54fc97", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8824d131619e58a38bde8bcf56401629b91a204a/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8824d131619e58a38bde8bcf56401629b91a204a/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=8824d131619e58a38bde8bcf56401629b91a204a", "patch": "@@ -31,8 +31,8 @@ use crate::MirLint;\n use rustc_const_eval::const_eval::ConstEvalErr;\n use rustc_const_eval::interpret::{\n     self, compile_time_machine, AllocId, ConstAllocation, Frame, ImmTy, InterpCx, InterpResult,\n-    LocalState, LocalValue, MemPlace, MemoryKind, OpTy, Operand as InterpOperand, PlaceTy, Pointer,\n-    Scalar, ScalarMaybeUninit, StackPopCleanup, StackPopUnwind,\n+    LocalState, LocalValue, MemoryKind, OpTy, PlaceTy, Pointer, Scalar, ScalarMaybeUninit,\n+    StackPopCleanup, StackPopUnwind,\n };\n \n /// The maximum number of bytes that we'll allocate space for a local or the return value.\n@@ -229,15 +229,19 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         throw_machine_stop_str!(\"pointer arithmetic or comparisons aren't supported in ConstProp\")\n     }\n \n-    fn access_local(\n-        _ecx: &InterpCx<'mir, 'tcx, Self>,\n-        frame: &Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>,\n+    fn access_local<'a>(\n+        frame: &'a Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>,\n         local: Local,\n-    ) -> InterpResult<'tcx, InterpOperand<Self::PointerTag>> {\n+    ) -> InterpResult<'tcx, &'a interpret::Operand<Self::PointerTag>> {\n         let l = &frame.locals[local];\n \n-        if l.value == LocalValue::Unallocated {\n-            throw_machine_stop_str!(\"tried to access an uninitialized local\")\n+        if matches!(\n+            l.value,\n+            LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit))\n+        ) {\n+            // For us \"uninit\" means \"we don't know its value, might be initiailized or not\".\n+            // So stop here.\n+            throw_machine_stop_str!(\"tried to access a local with unknown value\")\n         }\n \n         l.access()\n@@ -247,8 +251,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n         frame: usize,\n         local: Local,\n-    ) -> InterpResult<'tcx, Result<&'a mut LocalValue<Self::PointerTag>, MemPlace<Self::PointerTag>>>\n-    {\n+    ) -> InterpResult<'tcx, &'a mut interpret::Operand<Self::PointerTag>> {\n         if ecx.machine.can_const_prop[local] == ConstPropMode::NoPropagation {\n             throw_machine_stop_str!(\"tried to write to a local that is marked as not propagatable\")\n         }\n@@ -384,7 +387,11 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             .layout_of(EarlyBinder(body.return_ty()).subst(tcx, substs))\n             .ok()\n             // Don't bother allocating memory for large values.\n-            .filter(|ret_layout| ret_layout.size < Size::from_bytes(MAX_ALLOC_LIMIT))\n+            // I don't know how return types can seem to be unsized but this happens in the\n+            // `type/type-unsatisfiable.rs` test.\n+            .filter(|ret_layout| {\n+                !ret_layout.is_unsized() && ret_layout.size < Size::from_bytes(MAX_ALLOC_LIMIT)\n+            })\n             .unwrap_or_else(|| ecx.layout_of(tcx.types.unit).unwrap());\n \n         let ret = ecx\n@@ -430,8 +437,10 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     /// Remove `local` from the pool of `Locals`. Allows writing to them,\n     /// but not reading from them anymore.\n     fn remove_const(ecx: &mut InterpCx<'mir, 'tcx, ConstPropMachine<'mir, 'tcx>>, local: Local) {\n-        ecx.frame_mut().locals[local] =\n-            LocalState { value: LocalValue::Unallocated, layout: Cell::new(None) };\n+        ecx.frame_mut().locals[local] = LocalState {\n+            value: LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit)),\n+            layout: Cell::new(None),\n+        };\n     }\n \n     fn lint_root(&self, source_info: SourceInfo) -> Option<HirId> {\n@@ -915,7 +924,9 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                     let frame = self.ecx.frame_mut();\n                     frame.locals[local].value =\n                         if let StatementKind::StorageLive(_) = statement.kind {\n-                            LocalValue::Unallocated\n+                            LocalValue::Live(interpret::Operand::Immediate(\n+                                interpret::Immediate::Uninit,\n+                            ))\n                         } else {\n                             LocalValue::Dead\n                         };"}, {"sha": "2cae35bc4d0ed2a4e88132fe4d3ab9d9408fd402", "filename": "src/test/ui/consts/const-eval/ub-ref-ptr.32bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8824d131619e58a38bde8bcf56401629b91a204a/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8824d131619e58a38bde8bcf56401629b91a204a/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.32bit.stderr?ref=8824d131619e58a38bde8bcf56401629b91a204a", "patch": "@@ -158,11 +158,11 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref-ptr.rs:62:1\n    |\n LL | const DATA_FN_PTR: fn() = unsafe { mem::transmute(&13) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered pointer to alloc43, but expected a function pointer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered pointer to alloc41, but expected a function pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257e\u2500alloc43\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+               \u257e\u2500alloc41\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n error: aborting due to 16 previous errors"}, {"sha": "e2cd0e64db80695f5b46bc773316a4871281bd2a", "filename": "src/test/ui/consts/const-eval/ub-ref-ptr.64bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8824d131619e58a38bde8bcf56401629b91a204a/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8824d131619e58a38bde8bcf56401629b91a204a/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr?ref=8824d131619e58a38bde8bcf56401629b91a204a", "patch": "@@ -158,11 +158,11 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref-ptr.rs:62:1\n    |\n LL | const DATA_FN_PTR: fn() = unsafe { mem::transmute(&13) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered pointer to alloc43, but expected a function pointer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered pointer to alloc41, but expected a function pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc43\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc41\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error: aborting due to 16 previous errors"}, {"sha": "94d778bc8a150578400e8e90d45f1c6f5b8c9d81", "filename": "src/test/ui/consts/offset_from_ub.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8824d131619e58a38bde8bcf56401629b91a204a/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8824d131619e58a38bde8bcf56401629b91a204a/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr?ref=8824d131619e58a38bde8bcf56401629b91a204a", "patch": "@@ -40,19 +40,19 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:52:14\n    |\n LL |     unsafe { ptr_offset_from(end_ptr, start_ptr) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc20 has size 4, so pointer to 10 bytes starting at offset 0 is out-of-bounds\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc18 has size 4, so pointer to 10 bytes starting at offset 0 is out-of-bounds\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:61:14\n    |\n LL |     unsafe { ptr_offset_from(start_ptr, end_ptr) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc23 has size 4, so pointer to 10 bytes starting at offset 0 is out-of-bounds\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc21 has size 4, so pointer to 10 bytes starting at offset 0 is out-of-bounds\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:69:14\n    |\n LL |     unsafe { ptr_offset_from(end_ptr, end_ptr) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc26 has size 4, so pointer at offset 10 is out-of-bounds\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc24 has size 4, so pointer at offset 10 is out-of-bounds\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:78:27"}]}