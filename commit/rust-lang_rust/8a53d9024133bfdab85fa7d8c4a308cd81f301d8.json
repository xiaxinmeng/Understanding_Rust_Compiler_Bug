{"sha": "8a53d9024133bfdab85fa7d8c4a308cd81f301d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhNTNkOTAyNDEzM2JmZGFiODVmYTdkOGM0YTMwOGNkODFmMzAxZDg=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2018-01-19T07:25:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-01-19T07:25:17Z"}, "message": "Merge pull request #2299 from mikerite/option_option_pr\n\nImplemented option_option lint", "tree": {"sha": "a53404235bde8cabca7f93ae99a2ff1bb5e34103", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a53404235bde8cabca7f93ae99a2ff1bb5e34103"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a53d9024133bfdab85fa7d8c4a308cd81f301d8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJaYZ1dCRBK7hj4Ov3rIwAAdHIIAEo4Mk6d7ttkojez0A2e4X7E\nJYTSLCB0d9X2vqa4bBF9JZh+gR/82WzvaUD/9H3CqFMRd3TucJxnfRr7uZg3sqqX\nTHAImODFrMdPm53EFEW+dZ9L5lRIRtn6aUcIH2KXuFvvqXTMQvg1MNea4+NYuqLD\nGrI6mPZlCltiQM2BLc2kKrQOHDbHl8f+8yG8IALsiLMNFfwR0jQ9kq/J7k0kfXzl\nFbGfu+nYj1FYDWCD8uHOImbxoq9YGGkleqcrmOkBJdSs9EcC+JOTbV25vS70KTam\nnYCc2GqkkJz48IleE/m2fsDd/KPGYj4PVK8ptiXecDEYqhoXvi08Zpu5a4aVv4M=\n=LLby\n-----END PGP SIGNATURE-----\n", "payload": "tree a53404235bde8cabca7f93ae99a2ff1bb5e34103\nparent 5a794d3ee9f413982e8f50bbd9c48e5280e6b7fd\nparent 79c6c60f511da6db0cce1707ef2923ee7038ae95\nauthor Oliver Schneider <oli-obk@users.noreply.github.com> 1516346717 +0100\ncommitter GitHub <noreply@github.com> 1516346717 +0100\n\nMerge pull request #2299 from mikerite/option_option_pr\n\nImplemented option_option lint"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a53d9024133bfdab85fa7d8c4a308cd81f301d8", "html_url": "https://github.com/rust-lang/rust/commit/8a53d9024133bfdab85fa7d8c4a308cd81f301d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a53d9024133bfdab85fa7d8c4a308cd81f301d8/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a794d3ee9f413982e8f50bbd9c48e5280e6b7fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a794d3ee9f413982e8f50bbd9c48e5280e6b7fd", "html_url": "https://github.com/rust-lang/rust/commit/5a794d3ee9f413982e8f50bbd9c48e5280e6b7fd"}, {"sha": "79c6c60f511da6db0cce1707ef2923ee7038ae95", "url": "https://api.github.com/repos/rust-lang/rust/commits/79c6c60f511da6db0cce1707ef2923ee7038ae95", "html_url": "https://github.com/rust-lang/rust/commit/79c6c60f511da6db0cce1707ef2923ee7038ae95"}], "stats": {"total": 201, "additions": 181, "deletions": 20}, "files": [{"sha": "a6ffc17bff2c9851af49be679c6c45998e2810ad", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a53d9024133bfdab85fa7d8c4a308cd81f301d8/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a53d9024133bfdab85fa7d8c4a308cd81f301d8/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=8a53d9024133bfdab85fa7d8c4a308cd81f301d8", "patch": "@@ -605,6 +605,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         types::IMPLICIT_HASHER,\n         types::LET_UNIT_VALUE,\n         types::LINKEDLIST,\n+        types::OPTION_OPTION,\n         types::TYPE_COMPLEXITY,\n         types::UNIT_CMP,\n         types::UNNECESSARY_CAST,"}, {"sha": "d10199c992d9c698c3004982ad77517dc59fb674", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 58, "deletions": 19, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/8a53d9024133bfdab85fa7d8c4a308cd81f301d8/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a53d9024133bfdab85fa7d8c4a308cd81f301d8/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=8a53d9024133bfdab85fa7d8c4a308cd81f301d8", "patch": "@@ -50,6 +50,26 @@ declare_lint! {\n     \"usage of `Box<Vec<T>>`, vector elements are already on the heap\"\n }\n \n+/// **What it does:** Checks for use of `Option<Option<_>>` in function signatures and type\n+/// definitions\n+///\n+/// **Why is this bad?** `Option<_>` represents an optional value. `Option<Option<_>>`\n+/// represents an optional optional value which is logically the same thing as an optional\n+/// value but has an unneeded extra level of wrapping.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example**\n+/// ```rust\n+/// fn x() -> Option<Option<u32>> {\n+///     None\n+/// }\n+declare_lint! {\n+    pub OPTION_OPTION,\n+    Warn,\n+    \"usage of `Option<Option<T>>`\"\n+}\n+\n /// **What it does:** Checks for usage of any `LinkedList`, suggesting to use a\n /// `Vec` or a `VecDeque` (formerly called `RingBuf`).\n ///\n@@ -111,7 +131,7 @@ declare_lint! {\n \n impl LintPass for TypePass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(BOX_VEC, LINKEDLIST, BORROWED_BOX)\n+        lint_array!(BOX_VEC, OPTION_OPTION, LINKEDLIST, BORROWED_BOX)\n     }\n }\n \n@@ -156,6 +176,23 @@ fn check_fn_decl(cx: &LateContext, decl: &FnDecl) {\n     }\n }\n \n+/// Check if `qpath` has last segment with type parameter matching `path`\n+fn match_type_parameter(cx: &LateContext, qpath: &QPath, path: &[&str]) -> bool {\n+    let last = last_path_segment(qpath);\n+    if_chain! {\n+        if let Some(ref params) = last.parameters;\n+        if !params.parenthesized;\n+        if let Some(ty) = params.types.get(0);\n+        if let TyPath(ref qpath) = ty.node;\n+        if let Some(did) = opt_def_id(cx.tables.qpath_def(qpath, cx.tcx.hir.node_to_hir_id(ty.id)));\n+        if match_def_path(cx.tcx, did, path);\n+        then {\n+            return true;\n+        }\n+    }\n+    false\n+}\n+\n /// Recursively check for `TypePass` lints in the given type. Stop at the first\n /// lint found.\n ///\n@@ -171,24 +208,26 @@ fn check_ty(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool) {\n             let def = cx.tables.qpath_def(qpath, hir_id);\n             if let Some(def_id) = opt_def_id(def) {\n                 if Some(def_id) == cx.tcx.lang_items().owned_box() {\n-                    let last = last_path_segment(qpath);\n-                    if_chain! {\n-                        if let Some(ref params) = last.parameters;\n-                        if !params.parenthesized;\n-                        if let Some(vec) = params.types.get(0);\n-                        if let TyPath(ref qpath) = vec.node;\n-                        if let Some(did) = opt_def_id(cx.tables.qpath_def(qpath, cx.tcx.hir.node_to_hir_id(vec.id)));\n-                        if match_def_path(cx.tcx, did, &paths::VEC);\n-                        then {\n-                            span_help_and_lint(\n-                                cx,\n-                                BOX_VEC,\n-                                ast_ty.span,\n-                                \"you seem to be trying to use `Box<Vec<T>>`. Consider using just `Vec<T>`\",\n-                                \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation.\",\n-                            );\n-                            return; // don't recurse into the type\n-                        }\n+                    if match_type_parameter(cx, qpath, &paths::VEC) {\n+                        span_help_and_lint(\n+                            cx,\n+                            BOX_VEC,\n+                            ast_ty.span,\n+                            \"you seem to be trying to use `Box<Vec<T>>`. Consider using just `Vec<T>`\",\n+                            \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation.\",\n+                        );\n+                        return; // don't recurse into the type\n+                    }\n+                } else if match_def_path(cx.tcx, def_id, &paths::OPTION) {\n+                    if match_type_parameter(cx, qpath, &paths::OPTION) {\n+                        span_lint(\n+                            cx,\n+                            OPTION_OPTION,\n+                            ast_ty.span,\n+                            \"consider using `Option<T>` instead of `Option<Option<T>>` or a custom \\\n+                            enum if you need to distinguish all 3 cases\",\n+                        );\n+                        return; // don't recurse into the type\n                     }\n                 } else if match_def_path(cx.tcx, def_id, &paths::LINKED_LIST) {\n                     span_help_and_lint("}, {"sha": "3459d3820b71e8d94d68e60c9490524d29d36d55", "filename": "tests/ui/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a53d9024133bfdab85fa7d8c4a308cd81f301d8/tests%2Fui%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a53d9024133bfdab85fa7d8c4a308cd81f301d8/tests%2Fui%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_pass_by_value.rs?ref=8a53d9024133bfdab85fa7d8c4a308cd81f301d8", "patch": "@@ -2,7 +2,7 @@\n \n \n #![warn(needless_pass_by_value)]\n-#![allow(dead_code, single_match, if_let_redundant_pattern_matching, many_single_char_names)]\n+#![allow(dead_code, single_match, if_let_redundant_pattern_matching, many_single_char_names, option_option)]\n \n #![feature(collections_range)]\n "}, {"sha": "249745c6a4504c68b1f2aa63ad0f8c629c2a496d", "filename": "tests/ui/option_option.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/8a53d9024133bfdab85fa7d8c4a308cd81f301d8/tests%2Fui%2Foption_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a53d9024133bfdab85fa7d8c4a308cd81f301d8/tests%2Fui%2Foption_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_option.rs?ref=8a53d9024133bfdab85fa7d8c4a308cd81f301d8", "patch": "@@ -0,0 +1,63 @@\n+fn input(_: Option<Option<u8>>) {\n+}\n+\n+fn output() -> Option<Option<u8>> {\n+    None\n+}\n+\n+fn output_nested() -> Vec<Option<Option<u8>>> {\n+    vec![None]\n+}\n+\n+// The lint only generates one warning for this\n+fn output_nested_nested() -> Option<Option<Option<u8>>> {\n+    None\n+}\n+\n+struct Struct {\n+    x: Option<Option<u8>>,\n+}\n+\n+impl Struct {\n+    fn struct_fn() -> Option<Option<u8>> {\n+        None\n+    }\n+}\n+\n+trait Trait {\n+    fn trait_fn() -> Option<Option<u8>>;\n+}\n+\n+enum Enum {\n+    Tuple(Option<Option<u8>>),\n+    Struct{x: Option<Option<u8>>},\n+}\n+\n+// The lint allows this\n+type OptionOption = Option<Option<u32>>;\n+\n+// The lint allows this\n+fn output_type_alias() -> OptionOption {\n+    None\n+}\n+\n+// The line allows this\n+impl Trait for Struct {\n+    fn trait_fn() -> Option<Option<u8>> {\n+        None\n+    }\n+}\n+\n+fn main() {\n+    input(None);\n+    output();\n+    output_nested();\n+\n+    // The lint allows this\n+    let local: Option<Option<u8>> = None;\n+\n+    // The lint allows this\n+    let expr = Some(Some(true));\n+}\n+\n+"}, {"sha": "19e00efae7188d9d2c2277d31f71aa6a05b2b0fe", "filename": "tests/ui/option_option.stderr", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/8a53d9024133bfdab85fa7d8c4a308cd81f301d8/tests%2Fui%2Foption_option.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a53d9024133bfdab85fa7d8c4a308cd81f301d8/tests%2Fui%2Foption_option.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_option.stderr?ref=8a53d9024133bfdab85fa7d8c4a308cd81f301d8", "patch": "@@ -0,0 +1,58 @@\n+error: consider using `Option<T>` instead of `Option<Option<T>>` or a custom enum if you need to distinguish all 3 cases\n+ --> $DIR/option_option.rs:1:13\n+  |\n+1 | fn input(_: Option<Option<u8>>) {\n+  |             ^^^^^^^^^^^^^^^^^^\n+  |\n+  = note: `-D option-option` implied by `-D warnings`\n+\n+error: consider using `Option<T>` instead of `Option<Option<T>>` or a custom enum if you need to distinguish all 3 cases\n+ --> $DIR/option_option.rs:4:16\n+  |\n+4 | fn output() -> Option<Option<u8>> {\n+  |                ^^^^^^^^^^^^^^^^^^\n+\n+error: consider using `Option<T>` instead of `Option<Option<T>>` or a custom enum if you need to distinguish all 3 cases\n+ --> $DIR/option_option.rs:8:27\n+  |\n+8 | fn output_nested() -> Vec<Option<Option<u8>>> {\n+  |                           ^^^^^^^^^^^^^^^^^^\n+\n+error: consider using `Option<T>` instead of `Option<Option<T>>` or a custom enum if you need to distinguish all 3 cases\n+  --> $DIR/option_option.rs:13:30\n+   |\n+13 | fn output_nested_nested() -> Option<Option<Option<u8>>> {\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: consider using `Option<T>` instead of `Option<Option<T>>` or a custom enum if you need to distinguish all 3 cases\n+  --> $DIR/option_option.rs:18:8\n+   |\n+18 |     x: Option<Option<u8>>,\n+   |        ^^^^^^^^^^^^^^^^^^\n+\n+error: consider using `Option<T>` instead of `Option<Option<T>>` or a custom enum if you need to distinguish all 3 cases\n+  --> $DIR/option_option.rs:22:23\n+   |\n+22 |     fn struct_fn() -> Option<Option<u8>> {\n+   |                       ^^^^^^^^^^^^^^^^^^\n+\n+error: consider using `Option<T>` instead of `Option<Option<T>>` or a custom enum if you need to distinguish all 3 cases\n+  --> $DIR/option_option.rs:28:22\n+   |\n+28 |     fn trait_fn() -> Option<Option<u8>>;\n+   |                      ^^^^^^^^^^^^^^^^^^\n+\n+error: consider using `Option<T>` instead of `Option<Option<T>>` or a custom enum if you need to distinguish all 3 cases\n+  --> $DIR/option_option.rs:32:11\n+   |\n+32 |     Tuple(Option<Option<u8>>),\n+   |           ^^^^^^^^^^^^^^^^^^\n+\n+error: consider using `Option<T>` instead of `Option<Option<T>>` or a custom enum if you need to distinguish all 3 cases\n+  --> $DIR/option_option.rs:33:15\n+   |\n+33 |     Struct{x: Option<Option<u8>>},\n+   |               ^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 9 previous errors\n+"}]}