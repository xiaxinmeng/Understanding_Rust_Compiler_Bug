{"sha": "030244cd4a76914af7dc2939ed1a16f394ceda48", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzMDI0NGNkNGE3NjkxNGFmN2RjMjkzOWVkMWExNmYzOTRjZWRhNDg=", "commit": {"author": {"name": "Irina Popa", "email": "irinagpopa@gmail.com", "date": "2018-04-25T13:45:29Z"}, "committer": {"name": "Irina Popa", "email": "irinagpopa@gmail.com", "date": "2018-04-26T13:50:31Z"}, "message": "rustc_target: move in cabi_* from rustc_trans.", "tree": {"sha": "24e4a255042bf0d4f82f64e3e42810a6c02382d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24e4a255042bf0d4f82f64e3e42810a6c02382d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/030244cd4a76914af7dc2939ed1a16f394ceda48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/030244cd4a76914af7dc2939ed1a16f394ceda48", "html_url": "https://github.com/rust-lang/rust/commit/030244cd4a76914af7dc2939ed1a16f394ceda48", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/030244cd4a76914af7dc2939ed1a16f394ceda48/comments", "author": {"login": "irinagpopa", "id": 32459019, "node_id": "MDQ6VXNlcjMyNDU5MDE5", "avatar_url": "https://avatars.githubusercontent.com/u/32459019?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irinagpopa", "html_url": "https://github.com/irinagpopa", "followers_url": "https://api.github.com/users/irinagpopa/followers", "following_url": "https://api.github.com/users/irinagpopa/following{/other_user}", "gists_url": "https://api.github.com/users/irinagpopa/gists{/gist_id}", "starred_url": "https://api.github.com/users/irinagpopa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irinagpopa/subscriptions", "organizations_url": "https://api.github.com/users/irinagpopa/orgs", "repos_url": "https://api.github.com/users/irinagpopa/repos", "events_url": "https://api.github.com/users/irinagpopa/events{/privacy}", "received_events_url": "https://api.github.com/users/irinagpopa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "irinagpopa", "id": 32459019, "node_id": "MDQ6VXNlcjMyNDU5MDE5", "avatar_url": "https://avatars.githubusercontent.com/u/32459019?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irinagpopa", "html_url": "https://github.com/irinagpopa", "followers_url": "https://api.github.com/users/irinagpopa/followers", "following_url": "https://api.github.com/users/irinagpopa/following{/other_user}", "gists_url": "https://api.github.com/users/irinagpopa/gists{/gist_id}", "starred_url": "https://api.github.com/users/irinagpopa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irinagpopa/subscriptions", "organizations_url": "https://api.github.com/users/irinagpopa/orgs", "repos_url": "https://api.github.com/users/irinagpopa/repos", "events_url": "https://api.github.com/users/irinagpopa/events{/privacy}", "received_events_url": "https://api.github.com/users/irinagpopa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb15d447009f7b32cf435e0ad63bbbed5961e243", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb15d447009f7b32cf435e0ad63bbbed5961e243", "html_url": "https://github.com/rust-lang/rust/commit/fb15d447009f7b32cf435e0ad63bbbed5961e243"}], "stats": {"total": 1258, "additions": 645, "deletions": 613}, "files": [{"sha": "bea705b9ece2f5ae61de49936a2ff2c0d1091026", "filename": "src/librustc_target/abi/call.rs", "status": "removed", "additions": 0, "deletions": 214, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_target%2Fabi%2Fcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_target%2Fabi%2Fcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall.rs?ref=fb15d447009f7b32cf435e0ad63bbbed5961e243", "patch": "@@ -1,214 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use abi::{Align, HasDataLayout, Size};\n-\n-#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n-pub enum PassMode {\n-    /// Ignore the argument (useful for empty struct).\n-    Ignore,\n-    /// Pass the argument directly.\n-    Direct(ArgAttributes),\n-    /// Pass a pair's elements directly in two arguments.\n-    Pair(ArgAttributes, ArgAttributes),\n-    /// Pass the argument after casting it, to either\n-    /// a single uniform or a pair of registers.\n-    Cast(CastTarget),\n-    /// Pass the argument indirectly via a hidden pointer.\n-    Indirect(ArgAttributes),\n-}\n-\n-// Hack to disable non_upper_case_globals only for the bitflags! and not for the rest\n-// of this module\n-pub use self::attr_impl::ArgAttribute;\n-\n-#[allow(non_upper_case_globals)]\n-#[allow(unused)]\n-mod attr_impl {\n-    // The subset of llvm::Attribute needed for arguments, packed into a bitfield.\n-    bitflags! {\n-        #[derive(Default)]\n-        pub struct ArgAttribute: u16 {\n-            const ByVal     = 1 << 0;\n-            const NoAlias   = 1 << 1;\n-            const NoCapture = 1 << 2;\n-            const NonNull   = 1 << 3;\n-            const ReadOnly  = 1 << 4;\n-            const SExt      = 1 << 5;\n-            const StructRet = 1 << 6;\n-            const ZExt      = 1 << 7;\n-            const InReg     = 1 << 8;\n-        }\n-    }\n-}\n-\n-/// A compact representation of LLVM attributes (at least those relevant for this module)\n-/// that can be manipulated without interacting with LLVM's Attribute machinery.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub struct ArgAttributes {\n-    pub regular: ArgAttribute,\n-    pub pointee_size: Size,\n-    pub pointee_align: Option<Align>\n-}\n-\n-impl ArgAttributes {\n-    pub fn new() -> Self {\n-        ArgAttributes {\n-            regular: ArgAttribute::default(),\n-            pointee_size: Size::from_bytes(0),\n-            pointee_align: None,\n-        }\n-    }\n-\n-    pub fn set(&mut self, attr: ArgAttribute) -> &mut Self {\n-        self.regular = self.regular | attr;\n-        self\n-    }\n-\n-    pub fn contains(&self, attr: ArgAttribute) -> bool {\n-        self.regular.contains(attr)\n-    }\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum RegKind {\n-    Integer,\n-    Float,\n-    Vector\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub struct Reg {\n-    pub kind: RegKind,\n-    pub size: Size,\n-}\n-\n-macro_rules! reg_ctor {\n-    ($name:ident, $kind:ident, $bits:expr) => {\n-        pub fn $name() -> Reg {\n-            Reg {\n-                kind: RegKind::$kind,\n-                size: Size::from_bits($bits)\n-            }\n-        }\n-    }\n-}\n-\n-impl Reg {\n-    reg_ctor!(i8, Integer, 8);\n-    reg_ctor!(i16, Integer, 16);\n-    reg_ctor!(i32, Integer, 32);\n-    reg_ctor!(i64, Integer, 64);\n-\n-    reg_ctor!(f32, Float, 32);\n-    reg_ctor!(f64, Float, 64);\n-}\n-\n-impl Reg {\n-    pub fn align<C: HasDataLayout>(&self, cx: C) -> Align {\n-        let dl = cx.data_layout();\n-        match self.kind {\n-            RegKind::Integer => {\n-                match self.size.bits() {\n-                    1 => dl.i1_align,\n-                    2...8 => dl.i8_align,\n-                    9...16 => dl.i16_align,\n-                    17...32 => dl.i32_align,\n-                    33...64 => dl.i64_align,\n-                    65...128 => dl.i128_align,\n-                    _ => panic!(\"unsupported integer: {:?}\", self)\n-                }\n-            }\n-            RegKind::Float => {\n-                match self.size.bits() {\n-                    32 => dl.f32_align,\n-                    64 => dl.f64_align,\n-                    _ => panic!(\"unsupported float: {:?}\", self)\n-                }\n-            }\n-            RegKind::Vector => dl.vector_align(self.size)\n-        }\n-    }\n-}\n-\n-/// An argument passed entirely registers with the\n-/// same kind (e.g. HFA / HVA on PPC64 and AArch64).\n-#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n-pub struct Uniform {\n-    pub unit: Reg,\n-\n-    /// The total size of the argument, which can be:\n-    /// * equal to `unit.size` (one scalar/vector)\n-    /// * a multiple of `unit.size` (an array of scalar/vectors)\n-    /// * if `unit.kind` is `Integer`, the last element\n-    ///   can be shorter, i.e. `{ i64, i64, i32 }` for\n-    ///   64-bit integers with a total size of 20 bytes\n-    pub total: Size,\n-}\n-\n-impl From<Reg> for Uniform {\n-    fn from(unit: Reg) -> Uniform {\n-        Uniform {\n-            unit,\n-            total: unit.size\n-        }\n-    }\n-}\n-\n-impl Uniform {\n-    pub fn align<C: HasDataLayout>(&self, cx: C) -> Align {\n-        self.unit.align(cx)\n-    }\n-}\n-\n-#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n-pub struct CastTarget {\n-    pub prefix: [Option<RegKind>; 8],\n-    pub prefix_chunk: Size,\n-    pub rest: Uniform,\n-}\n-\n-impl From<Reg> for CastTarget {\n-    fn from(unit: Reg) -> CastTarget {\n-        CastTarget::from(Uniform::from(unit))\n-    }\n-}\n-\n-impl From<Uniform> for CastTarget {\n-    fn from(uniform: Uniform) -> CastTarget {\n-        CastTarget {\n-            prefix: [None; 8],\n-            prefix_chunk: Size::from_bytes(0),\n-            rest: uniform\n-        }\n-    }\n-}\n-\n-impl CastTarget {\n-    pub fn pair(a: Reg, b: Reg) -> CastTarget {\n-        CastTarget {\n-            prefix: [Some(a.kind), None, None, None, None, None, None, None],\n-            prefix_chunk: a.size,\n-            rest: Uniform::from(b)\n-        }\n-    }\n-\n-    pub fn size<C: HasDataLayout>(&self, cx: C) -> Size {\n-        (self.prefix_chunk * self.prefix.iter().filter(|x| x.is_some()).count() as u64)\n-             .abi_align(self.rest.align(cx)) + self.rest.total\n-    }\n-\n-    pub fn align<C: HasDataLayout>(&self, cx: C) -> Align {\n-        self.prefix.iter()\n-            .filter_map(|x| x.map(|kind| Reg { kind: kind, size: self.prefix_chunk }.align(cx)))\n-            .fold(cx.data_layout().aggregate_align.max(self.rest.align(cx)),\n-                |acc, align| acc.max(align))\n-    }\n-}\n\\ No newline at end of file"}, {"sha": "a665f9f6fe39bd0b0bbed4d76be08ec4ba27dfc8", "filename": "src/librustc_target/abi/call/aarch64.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Faarch64.rs?ref=030244cd4a76914af7dc2939ed1a16f394ceda48", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::{FnType, ArgType, LayoutExt, Reg, RegKind, Uniform};\n-use rustc_target::abi::{HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n+use abi::call::{FnType, ArgType, Reg, RegKind, Uniform};\n+use abi::{HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n \n fn is_homogeneous_aggregate<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>)\n                                      -> Option<Uniform> ", "previous_filename": "src/librustc_trans/cabi_aarch64.rs"}, {"sha": "fb8f4aaf38e31a79656ff45e0b7fa845cee17ba0", "filename": "src/librustc_target/abi/call/arm.rs", "status": "renamed", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Farm.rs?ref=030244cd4a76914af7dc2939ed1a16f394ceda48", "patch": "@@ -8,10 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::{FnType, ArgType, LayoutExt, Reg, RegKind, Uniform};\n-use rustc_target::abi::{HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n-use rustc_target::spec::HasTargetSpec;\n-use llvm::CallConv;\n+use abi::call::{Conv, FnType, ArgType, Reg, RegKind, Uniform};\n+use abi::{HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n+use spec::HasTargetSpec;\n \n fn is_homogeneous_aggregate<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>)\n                                      -> Option<Uniform> \n@@ -109,7 +108,7 @@ pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<'a, Ty>)\n     // If this is a target with a hard-float ABI, and the function is not explicitly\n     // `extern \"aapcs\"`, then we must use the VFP registers for homogeneous aggregates.\n     let vfp = cx.target_spec().llvm_target.ends_with(\"hf\")\n-        && fty.cconv != CallConv::ArmAapcsCallConv\n+        && fty.conv != Conv::ArmAapcs\n         && !fty.variadic;\n \n     if !fty.ret.is_ignore() {", "previous_filename": "src/librustc_trans/cabi_arm.rs"}, {"sha": "15f48a31652f88bca8b27e39bf6f08a37a2ed3c3", "filename": "src/librustc_target/abi/call/asmjs.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Fasmjs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Fasmjs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fasmjs.rs?ref=030244cd4a76914af7dc2939ed1a16f394ceda48", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::{FnType, ArgType, LayoutExt, Uniform};\n-use rustc_target::abi::{HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n+use abi::call::{FnType, ArgType, Uniform};\n+use abi::{HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n \n // Data layout: e-p:32:32-i64:64-v128:32:128-n32-S128\n ", "previous_filename": "src/librustc_trans/cabi_asmjs.rs"}, {"sha": "d37d5584591c4f6dcc0d991f9ee84c69e536852d", "filename": "src/librustc_target/abi/call/hexagon.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Fhexagon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Fhexagon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fhexagon.rs?ref=030244cd4a76914af7dc2939ed1a16f394ceda48", "patch": "@@ -10,7 +10,7 @@\n \n #![allow(non_upper_case_globals)]\n \n-use abi::{FnType, ArgType, LayoutExt};\n+use abi::call::{FnType, ArgType};\n \n fn classify_ret_ty<Ty>(ret: &mut ArgType<Ty>) {\n     if ret.layout.is_aggregate() && ret.layout.size.bits() > 64 {", "previous_filename": "src/librustc_trans/cabi_hexagon.rs"}, {"sha": "39f9e7d8b7d20f1a3c2a1a54c25203646cc5477b", "filename": "src/librustc_target/abi/call/mips.rs", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips.rs?ref=030244cd4a76914af7dc2939ed1a16f394ceda48", "patch": "@@ -8,9 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::{ArgType, FnType, LayoutExt, Reg, Uniform};\n-\n-use rustc_target::abi::{HasDataLayout, LayoutOf, Size, TyLayoutMethods};\n+use abi::call::{ArgType, FnType, Reg, Uniform};\n+use abi::{HasDataLayout, LayoutOf, Size, TyLayoutMethods};\n \n fn classify_ret_ty<'a, Ty, C>(cx: C, ret: &mut ArgType<Ty>, offset: &mut Size)\n     where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout", "previous_filename": "src/librustc_trans/cabi_mips.rs"}, {"sha": "fe9b861e2030d41384b5bfd12f197defec509197", "filename": "src/librustc_target/abi/call/mips64.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips64.rs?ref=030244cd4a76914af7dc2939ed1a16f394ceda48", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::{ArgAttribute, ArgType, CastTarget, FnType, LayoutExt, PassMode, Reg, RegKind, Uniform};\n-use rustc_target::abi::{self, HasDataLayout, LayoutOf, Size, TyLayout, TyLayoutMethods};\n+use abi::call::{ArgAttribute, ArgType, CastTarget, FnType, PassMode, Reg, RegKind, Uniform};\n+use abi::{self, HasDataLayout, LayoutOf, Size, TyLayout, TyLayoutMethods};\n \n fn extend_integer_width_mips<Ty>(arg: &mut ArgType<Ty>, bits: u64) {\n     // Always sign extend u32 values on 64-bit mips", "previous_filename": "src/librustc_trans/cabi_mips64.rs"}, {"sha": "3fad7926e1face48d8d464ddca2a1f50561652af", "filename": "src/librustc_target/abi/call/mod.rs", "status": "added", "additions": 511, "deletions": 0, "changes": 511, "blob_url": "https://github.com/rust-lang/rust/blob/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs?ref=030244cd4a76914af7dc2939ed1a16f394ceda48", "patch": "@@ -0,0 +1,511 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use abi::{self, Abi, Align, FieldPlacement, Size};\n+use abi::{HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n+use spec::HasTargetSpec;\n+\n+mod aarch64;\n+mod arm;\n+mod asmjs;\n+mod hexagon;\n+mod mips;\n+mod mips64;\n+mod msp430;\n+mod nvptx;\n+mod nvptx64;\n+mod powerpc;\n+mod powerpc64;\n+mod s390x;\n+mod sparc;\n+mod sparc64;\n+mod x86;\n+mod x86_64;\n+mod x86_win64;\n+mod wasm32;\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n+pub enum PassMode {\n+    /// Ignore the argument (useful for empty struct).\n+    Ignore,\n+    /// Pass the argument directly.\n+    Direct(ArgAttributes),\n+    /// Pass a pair's elements directly in two arguments.\n+    Pair(ArgAttributes, ArgAttributes),\n+    /// Pass the argument after casting it, to either\n+    /// a single uniform or a pair of registers.\n+    Cast(CastTarget),\n+    /// Pass the argument indirectly via a hidden pointer.\n+    Indirect(ArgAttributes),\n+}\n+\n+// Hack to disable non_upper_case_globals only for the bitflags! and not for the rest\n+// of this module\n+pub use self::attr_impl::ArgAttribute;\n+\n+#[allow(non_upper_case_globals)]\n+#[allow(unused)]\n+mod attr_impl {\n+    // The subset of llvm::Attribute needed for arguments, packed into a bitfield.\n+    bitflags! {\n+        #[derive(Default)]\n+        pub struct ArgAttribute: u16 {\n+            const ByVal     = 1 << 0;\n+            const NoAlias   = 1 << 1;\n+            const NoCapture = 1 << 2;\n+            const NonNull   = 1 << 3;\n+            const ReadOnly  = 1 << 4;\n+            const SExt      = 1 << 5;\n+            const StructRet = 1 << 6;\n+            const ZExt      = 1 << 7;\n+            const InReg     = 1 << 8;\n+        }\n+    }\n+}\n+\n+/// A compact representation of LLVM attributes (at least those relevant for this module)\n+/// that can be manipulated without interacting with LLVM's Attribute machinery.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub struct ArgAttributes {\n+    pub regular: ArgAttribute,\n+    pub pointee_size: Size,\n+    pub pointee_align: Option<Align>\n+}\n+\n+impl ArgAttributes {\n+    pub fn new() -> Self {\n+        ArgAttributes {\n+            regular: ArgAttribute::default(),\n+            pointee_size: Size::from_bytes(0),\n+            pointee_align: None,\n+        }\n+    }\n+\n+    pub fn set(&mut self, attr: ArgAttribute) -> &mut Self {\n+        self.regular = self.regular | attr;\n+        self\n+    }\n+\n+    pub fn contains(&self, attr: ArgAttribute) -> bool {\n+        self.regular.contains(attr)\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum RegKind {\n+    Integer,\n+    Float,\n+    Vector\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub struct Reg {\n+    pub kind: RegKind,\n+    pub size: Size,\n+}\n+\n+macro_rules! reg_ctor {\n+    ($name:ident, $kind:ident, $bits:expr) => {\n+        pub fn $name() -> Reg {\n+            Reg {\n+                kind: RegKind::$kind,\n+                size: Size::from_bits($bits)\n+            }\n+        }\n+    }\n+}\n+\n+impl Reg {\n+    reg_ctor!(i8, Integer, 8);\n+    reg_ctor!(i16, Integer, 16);\n+    reg_ctor!(i32, Integer, 32);\n+    reg_ctor!(i64, Integer, 64);\n+\n+    reg_ctor!(f32, Float, 32);\n+    reg_ctor!(f64, Float, 64);\n+}\n+\n+impl Reg {\n+    pub fn align<C: HasDataLayout>(&self, cx: C) -> Align {\n+        let dl = cx.data_layout();\n+        match self.kind {\n+            RegKind::Integer => {\n+                match self.size.bits() {\n+                    1 => dl.i1_align,\n+                    2...8 => dl.i8_align,\n+                    9...16 => dl.i16_align,\n+                    17...32 => dl.i32_align,\n+                    33...64 => dl.i64_align,\n+                    65...128 => dl.i128_align,\n+                    _ => panic!(\"unsupported integer: {:?}\", self)\n+                }\n+            }\n+            RegKind::Float => {\n+                match self.size.bits() {\n+                    32 => dl.f32_align,\n+                    64 => dl.f64_align,\n+                    _ => panic!(\"unsupported float: {:?}\", self)\n+                }\n+            }\n+            RegKind::Vector => dl.vector_align(self.size)\n+        }\n+    }\n+}\n+\n+/// An argument passed entirely registers with the\n+/// same kind (e.g. HFA / HVA on PPC64 and AArch64).\n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n+pub struct Uniform {\n+    pub unit: Reg,\n+\n+    /// The total size of the argument, which can be:\n+    /// * equal to `unit.size` (one scalar/vector)\n+    /// * a multiple of `unit.size` (an array of scalar/vectors)\n+    /// * if `unit.kind` is `Integer`, the last element\n+    ///   can be shorter, i.e. `{ i64, i64, i32 }` for\n+    ///   64-bit integers with a total size of 20 bytes\n+    pub total: Size,\n+}\n+\n+impl From<Reg> for Uniform {\n+    fn from(unit: Reg) -> Uniform {\n+        Uniform {\n+            unit,\n+            total: unit.size\n+        }\n+    }\n+}\n+\n+impl Uniform {\n+    pub fn align<C: HasDataLayout>(&self, cx: C) -> Align {\n+        self.unit.align(cx)\n+    }\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n+pub struct CastTarget {\n+    pub prefix: [Option<RegKind>; 8],\n+    pub prefix_chunk: Size,\n+    pub rest: Uniform,\n+}\n+\n+impl From<Reg> for CastTarget {\n+    fn from(unit: Reg) -> CastTarget {\n+        CastTarget::from(Uniform::from(unit))\n+    }\n+}\n+\n+impl From<Uniform> for CastTarget {\n+    fn from(uniform: Uniform) -> CastTarget {\n+        CastTarget {\n+            prefix: [None; 8],\n+            prefix_chunk: Size::from_bytes(0),\n+            rest: uniform\n+        }\n+    }\n+}\n+\n+impl CastTarget {\n+    pub fn pair(a: Reg, b: Reg) -> CastTarget {\n+        CastTarget {\n+            prefix: [Some(a.kind), None, None, None, None, None, None, None],\n+            prefix_chunk: a.size,\n+            rest: Uniform::from(b)\n+        }\n+    }\n+\n+    pub fn size<C: HasDataLayout>(&self, cx: C) -> Size {\n+        (self.prefix_chunk * self.prefix.iter().filter(|x| x.is_some()).count() as u64)\n+             .abi_align(self.rest.align(cx)) + self.rest.total\n+    }\n+\n+    pub fn align<C: HasDataLayout>(&self, cx: C) -> Align {\n+        self.prefix.iter()\n+            .filter_map(|x| x.map(|kind| Reg { kind: kind, size: self.prefix_chunk }.align(cx)))\n+            .fold(cx.data_layout().aggregate_align.max(self.rest.align(cx)),\n+                |acc, align| acc.max(align))\n+    }\n+}\n+\n+impl<'a, Ty> TyLayout<'a, Ty> {\n+    fn is_aggregate(&self) -> bool {\n+        match self.abi {\n+            Abi::Uninhabited |\n+            Abi::Scalar(_) |\n+            Abi::Vector { .. } => false,\n+            Abi::ScalarPair(..) |\n+            Abi::Aggregate { .. } => true\n+        }\n+    }\n+\n+    fn homogeneous_aggregate<C>(&self, cx: C) -> Option<Reg> \n+        where Ty: TyLayoutMethods<'a, C> + Copy, C: LayoutOf<Ty = Ty, TyLayout = Self> + Copy\n+    {\n+        match self.abi {\n+            Abi::Uninhabited => None,\n+\n+            // The primitive for this algorithm.\n+            Abi::Scalar(ref scalar) => {\n+                let kind = match scalar.value {\n+                    abi::Int(..) |\n+                    abi::Pointer => RegKind::Integer,\n+                    abi::F32 |\n+                    abi::F64 => RegKind::Float\n+                };\n+                Some(Reg {\n+                    kind,\n+                    size: self.size\n+                })\n+            }\n+\n+            Abi::Vector { .. } => {\n+                Some(Reg {\n+                    kind: RegKind::Vector,\n+                    size: self.size\n+                })\n+            }\n+\n+            Abi::ScalarPair(..) |\n+            Abi::Aggregate { .. } => {\n+                let mut total = Size::from_bytes(0);\n+                let mut result = None;\n+\n+                let is_union = match self.fields {\n+                    FieldPlacement::Array { count, .. } => {\n+                        if count > 0 {\n+                            return self.field(cx, 0).homogeneous_aggregate(cx);\n+                        } else {\n+                            return None;\n+                        }\n+                    }\n+                    FieldPlacement::Union(_) => true,\n+                    FieldPlacement::Arbitrary { .. } => false\n+                };\n+\n+                for i in 0..self.fields.count() {\n+                    if !is_union && total != self.fields.offset(i) {\n+                        return None;\n+                    }\n+\n+                    let field = self.field(cx, i);\n+                    match (result, field.homogeneous_aggregate(cx)) {\n+                        // The field itself must be a homogeneous aggregate.\n+                        (_, None) => return None,\n+                        // If this is the first field, record the unit.\n+                        (None, Some(unit)) => {\n+                            result = Some(unit);\n+                        }\n+                        // For all following fields, the unit must be the same.\n+                        (Some(prev_unit), Some(unit)) => {\n+                            if prev_unit != unit {\n+                                return None;\n+                            }\n+                        }\n+                    }\n+\n+                    // Keep track of the offset (without padding).\n+                    let size = field.size;\n+                    if is_union {\n+                        total = total.max(size);\n+                    } else {\n+                        total += size;\n+                    }\n+                }\n+\n+                // There needs to be no padding.\n+                if total != self.size {\n+                    None\n+                } else {\n+                    result\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// Information about how to pass an argument to,\n+/// or return a value from, a function, under some ABI.\n+#[derive(Debug)]\n+pub struct ArgType<'a, Ty> {\n+    pub layout: TyLayout<'a, Ty>,\n+\n+    /// Dummy argument, which is emitted before the real argument.\n+    pub pad: Option<Reg>,\n+\n+    pub mode: PassMode,\n+}\n+\n+impl<'a, Ty> ArgType<'a, Ty> {\n+    pub fn new(layout: TyLayout<'a, Ty>) -> Self {\n+        ArgType {\n+            layout,\n+            pad: None,\n+            mode: PassMode::Direct(ArgAttributes::new()),\n+        }\n+    }\n+\n+    pub fn make_indirect(&mut self) {\n+        assert_eq!(self.mode, PassMode::Direct(ArgAttributes::new()));\n+\n+        // Start with fresh attributes for the pointer.\n+        let mut attrs = ArgAttributes::new();\n+\n+        // For non-immediate arguments the callee gets its own copy of\n+        // the value on the stack, so there are no aliases. It's also\n+        // program-invisible so can't possibly capture\n+        attrs.set(ArgAttribute::NoAlias)\n+             .set(ArgAttribute::NoCapture)\n+             .set(ArgAttribute::NonNull);\n+        attrs.pointee_size = self.layout.size;\n+        // FIXME(eddyb) We should be doing this, but at least on\n+        // i686-pc-windows-msvc, it results in wrong stack offsets.\n+        // attrs.pointee_align = Some(self.layout.align);\n+\n+        self.mode = PassMode::Indirect(attrs);\n+    }\n+\n+    pub fn make_indirect_byval(&mut self) {\n+        self.make_indirect();\n+        match self.mode {\n+            PassMode::Indirect(ref mut attrs) => {\n+                attrs.set(ArgAttribute::ByVal);\n+            }\n+            _ => unreachable!()\n+        }\n+    }\n+\n+    pub fn extend_integer_width_to(&mut self, bits: u64) {\n+        // Only integers have signedness\n+        if let Abi::Scalar(ref scalar) = self.layout.abi {\n+            if let abi::Int(i, signed) = scalar.value {\n+                if i.size().bits() < bits {\n+                    if let PassMode::Direct(ref mut attrs) = self.mode {\n+                        attrs.set(if signed {\n+                            ArgAttribute::SExt\n+                        } else {\n+                            ArgAttribute::ZExt\n+                        });\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn cast_to<T: Into<CastTarget>>(&mut self, target: T) {\n+        assert_eq!(self.mode, PassMode::Direct(ArgAttributes::new()));\n+        self.mode = PassMode::Cast(target.into());\n+    }\n+\n+    pub fn pad_with(&mut self, reg: Reg) {\n+        self.pad = Some(reg);\n+    }\n+\n+    pub fn is_indirect(&self) -> bool {\n+        match self.mode {\n+            PassMode::Indirect(_) => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn is_ignore(&self) -> bool {\n+        self.mode == PassMode::Ignore\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub enum Conv {\n+    C,\n+\n+    ArmAapcs,\n+\n+    Msp430Intr,\n+\n+    PtxKernel,\n+\n+    X86Fastcall,\n+    X86Intr,\n+    X86Stdcall,\n+    X86ThisCall,\n+    X86VectorCall,\n+\n+    X86_64SysV,\n+    X86_64Win64,\n+}\n+\n+/// Metadata describing how the arguments to a native function\n+/// should be passed in order to respect the native ABI.\n+///\n+/// I will do my best to describe this structure, but these\n+/// comments are reverse-engineered and may be inaccurate. -NDM\n+#[derive(Debug)]\n+pub struct FnType<'a, Ty> {\n+    /// The LLVM types of each argument.\n+    pub args: Vec<ArgType<'a, Ty>>,\n+\n+    /// LLVM return type.\n+    pub ret: ArgType<'a, Ty>,\n+\n+    pub variadic: bool,\n+\n+    pub conv: Conv,\n+}\n+\n+impl<'a, Ty> FnType<'a, Ty> {\n+    pub fn adjust_for_cabi<C>(&mut self, cx: C, abi: ::syntax::abi::Abi) -> Result<(), String>\n+        where Ty: TyLayoutMethods<'a, C> + Copy,\n+              C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout + HasTargetSpec\n+    {\n+        match &cx.target_spec().arch[..] {\n+            \"x86\" => {\n+                let flavor = if abi == ::syntax::abi::Abi::Fastcall {\n+                    x86::Flavor::Fastcall\n+                } else {\n+                    x86::Flavor::General\n+                };\n+                x86::compute_abi_info(cx, self, flavor);\n+            },\n+            \"x86_64\" => if abi == ::syntax::abi::Abi::SysV64 {\n+                x86_64::compute_abi_info(cx, self);\n+            } else if abi == ::syntax::abi::Abi::Win64 || cx.target_spec().options.is_like_windows {\n+                x86_win64::compute_abi_info(self);\n+            } else {\n+                x86_64::compute_abi_info(cx, self);\n+            },\n+            \"aarch64\" => aarch64::compute_abi_info(cx, self),\n+            \"arm\" => arm::compute_abi_info(cx, self),\n+            \"mips\" => mips::compute_abi_info(cx, self),\n+            \"mips64\" => mips64::compute_abi_info(cx, self),\n+            \"powerpc\" => powerpc::compute_abi_info(cx, self),\n+            \"powerpc64\" => powerpc64::compute_abi_info(cx, self),\n+            \"s390x\" => s390x::compute_abi_info(cx, self),\n+            \"asmjs\" => asmjs::compute_abi_info(cx, self),\n+            \"wasm32\" => {\n+                if cx.target_spec().llvm_target.contains(\"emscripten\") {\n+                    asmjs::compute_abi_info(cx, self)\n+                } else {\n+                    wasm32::compute_abi_info(self)\n+                }\n+            }\n+            \"msp430\" => msp430::compute_abi_info(self),\n+            \"sparc\" => sparc::compute_abi_info(cx, self),\n+            \"sparc64\" => sparc64::compute_abi_info(cx, self),\n+            \"nvptx\" => nvptx::compute_abi_info(self),\n+            \"nvptx64\" => nvptx64::compute_abi_info(self),\n+            \"hexagon\" => hexagon::compute_abi_info(self),\n+            a => return Err(format!(\"unrecognized arch \\\"{}\\\" in target specification\", a))\n+        }\n+\n+        if let PassMode::Indirect(ref mut attrs) = self.ret.mode {\n+            attrs.set(ArgAttribute::StructRet);\n+        }\n+\n+        Ok(())\n+    }\n+}"}, {"sha": "e57ca03da600753f2f424a3019093ce1b5c14e1d", "filename": "src/librustc_target/abi/call/msp430.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Fmsp430.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Fmsp430.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmsp430.rs?ref=030244cd4a76914af7dc2939ed1a16f394ceda48", "patch": "@@ -11,7 +11,7 @@\n // Reference: MSP430 Embedded Application Binary Interface\n // http://www.ti.com/lit/an/slaa534/slaa534.pdf\n \n-use abi::{ArgType, FnType, LayoutExt};\n+use abi::call::{ArgType, FnType};\n \n // 3.5 Structures or Unions Passed and Returned by Reference\n //", "previous_filename": "src/librustc_trans/cabi_msp430.rs"}, {"sha": "f23f7ddf2abcc82b0f682162a425dbfeff9b02ed", "filename": "src/librustc_target/abi/call/nvptx.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Fnvptx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Fnvptx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fnvptx.rs?ref=030244cd4a76914af7dc2939ed1a16f394ceda48", "patch": "@@ -11,7 +11,7 @@\n // Reference: PTX Writer's Guide to Interoperability\n // http://docs.nvidia.com/cuda/ptx-writers-guide-to-interoperability\n \n-use abi::{ArgType, FnType, LayoutExt};\n+use abi::call::{ArgType, FnType};\n \n fn classify_ret_ty<Ty>(ret: &mut ArgType<Ty>) {\n     if ret.layout.is_aggregate() && ret.layout.size.bits() > 32 {", "previous_filename": "src/librustc_trans/cabi_nvptx.rs"}, {"sha": "4399a2fec6caf190b89feab251bce919cf5e5097", "filename": "src/librustc_target/abi/call/nvptx64.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Fnvptx64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Fnvptx64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fnvptx64.rs?ref=030244cd4a76914af7dc2939ed1a16f394ceda48", "patch": "@@ -11,7 +11,7 @@\n // Reference: PTX Writer's Guide to Interoperability\n // http://docs.nvidia.com/cuda/ptx-writers-guide-to-interoperability\n \n-use abi::{ArgType, FnType, LayoutExt};\n+use abi::call::{ArgType, FnType};\n \n fn classify_ret_ty<Ty>(ret: &mut ArgType<Ty>) {\n     if ret.layout.is_aggregate() && ret.layout.size.bits() > 64 {", "previous_filename": "src/librustc_trans/cabi_nvptx64.rs"}, {"sha": "8c3c2422d7f41de321e4eb3a240eab877f001744", "filename": "src/librustc_target/abi/call/powerpc.rs", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc.rs?ref=030244cd4a76914af7dc2939ed1a16f394ceda48", "patch": "@@ -8,9 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::{ArgType, FnType, LayoutExt, Reg, Uniform};\n-\n-use rustc_target::abi::{HasDataLayout, LayoutOf, Size, TyLayoutMethods};\n+use abi::call::{ArgType, FnType, Reg, Uniform};\n+use abi::{HasDataLayout, LayoutOf, Size, TyLayoutMethods};\n \n fn classify_ret_ty<'a, Ty, C>(cx: C, ret: &mut ArgType<Ty>, offset: &mut Size)\n     where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout", "previous_filename": "src/librustc_trans/cabi_powerpc.rs"}, {"sha": "b0e27ebc7baaa254478405148bb1c099e5f84164", "filename": "src/librustc_target/abi/call/powerpc64.rs", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs?ref=030244cd4a76914af7dc2939ed1a16f394ceda48", "patch": "@@ -12,9 +12,8 @@\n // Alignment of 128 bit types is not currently handled, this will\n // need to be fixed when PowerPC vector support is added.\n \n-use abi::{FnType, ArgType, LayoutExt, Reg, RegKind, Uniform};\n-\n-use rustc_target::abi::{Align, Endian, HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n+use abi::call::{FnType, ArgType, Reg, RegKind, Uniform};\n+use abi::{Align, Endian, HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n \n #[derive(Debug, Clone, Copy, PartialEq)]\n enum ABI {", "previous_filename": "src/librustc_trans/cabi_powerpc64.rs"}, {"sha": "2fbe1c608d8336dbad18c6d3741b5ca5764327c1", "filename": "src/librustc_target/abi/call/s390x.rs", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Fs390x.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Fs390x.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fs390x.rs?ref=030244cd4a76914af7dc2939ed1a16f394ceda48", "patch": "@@ -11,9 +11,8 @@\n // FIXME: The assumes we're using the non-vector ABI, i.e. compiling\n // for a pre-z13 machine or using -mno-vx.\n \n-use abi::{FnType, ArgType, LayoutExt, Reg};\n-\n-use rustc_target::abi::{self, HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n+use abi::call::{FnType, ArgType, Reg};\n+use abi::{self, HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n \n fn classify_ret_ty<'a, Ty, C>(ret: &mut ArgType<Ty>) \n     where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout", "previous_filename": "src/librustc_trans/cabi_s390x.rs"}, {"sha": "1e7bd158864813abe0d82827f3c59875aa0dcef3", "filename": "src/librustc_target/abi/call/sparc.rs", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc.rs?ref=030244cd4a76914af7dc2939ed1a16f394ceda48", "patch": "@@ -8,9 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::{ArgType, FnType, LayoutExt, Reg, Uniform};\n-\n-use rustc_target::abi::{HasDataLayout, LayoutOf, Size, TyLayoutMethods};\n+use abi::call::{ArgType, FnType, Reg, Uniform};\n+use abi::{HasDataLayout, LayoutOf, Size, TyLayoutMethods};\n \n fn classify_ret_ty<'a, Ty, C>(cx: C, ret: &mut ArgType<Ty>, offset: &mut Size) \n     where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout", "previous_filename": "src/librustc_trans/cabi_sparc.rs"}, {"sha": "a583613a50120a8d4aaa18953aabafe77ab7ae96", "filename": "src/librustc_target/abi/call/sparc64.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc64.rs?ref=030244cd4a76914af7dc2939ed1a16f394ceda48", "patch": "@@ -10,8 +10,8 @@\n \n // FIXME: This needs an audit for correctness and completeness.\n \n-use abi::{FnType, ArgType, LayoutExt, Reg, RegKind, Uniform};\n-use rustc_target::abi::{HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n+use abi::call::{FnType, ArgType, Reg, RegKind, Uniform};\n+use abi::{HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n \n fn is_homogeneous_aggregate<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>)\n                                      -> Option<Uniform>", "previous_filename": "src/librustc_trans/cabi_sparc64.rs"}, {"sha": "7109eea535d4a35c968b1b8f92667b8e9b4e7c2a", "filename": "src/librustc_target/abi/call/wasm32.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Fwasm32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Fwasm32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fwasm32.rs?ref=030244cd4a76914af7dc2939ed1a16f394ceda48", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::{FnType, ArgType};\n+use abi::call::{FnType, ArgType};\n \n fn classify_ret_ty<Ty>(ret: &mut ArgType<Ty>) {\n     ret.extend_integer_width_to(32);", "previous_filename": "src/librustc_trans/cabi_wasm32.rs"}, {"sha": "dd4373de72c5349da4f49820ada32b931bde6eca", "filename": "src/librustc_target/abi/call/x86.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs?ref=030244cd4a76914af7dc2939ed1a16f394ceda48", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::{ArgAttribute, FnType, LayoutExt, PassMode, Reg, RegKind};\n-use rustc_target::abi::{self, HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n-use rustc_target::spec::HasTargetSpec;\n+use abi::call::{ArgAttribute, FnType, PassMode, Reg, RegKind};\n+use abi::{self, HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n+use spec::HasTargetSpec;\n \n #[derive(PartialEq)]\n pub enum Flavor {\n@@ -108,7 +108,7 @@ pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<'a, Ty>, flavor: Flav\n                 PassMode::Direct(ref mut attrs) => attrs,\n                 PassMode::Pair(..) |\n                 PassMode::Cast(_) => {\n-                    bug!(\"x86 shouldn't be passing arguments by {:?}\", arg.mode)\n+                    unreachable!(\"x86 shouldn't be passing arguments by {:?}\", arg.mode)\n                 }\n             };\n ", "previous_filename": "src/librustc_trans/cabi_x86.rs"}, {"sha": "388d0eca5c4e1becdef602cd706b590ec72c84aa", "filename": "src/librustc_target/abi/call/x86_64.rs", "status": "renamed", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs?ref=030244cd4a76914af7dc2939ed1a16f394ceda48", "patch": "@@ -11,8 +11,8 @@\n // The classification code for the x86_64 ABI is taken from the clay language\n // https://github.com/jckarter/clay/blob/master/compiler/src/externals.cpp\n \n-use abi::{ArgType, CastTarget, FnType, LayoutExt, Reg, RegKind};\n-use rustc_target::abi::{self, HasDataLayout, LayoutOf, Size, TyLayout, TyLayoutMethods};\n+use abi::call::{ArgType, CastTarget, FnType, Reg, RegKind};\n+use abi::{self, Abi, HasDataLayout, LayoutOf, Size, TyLayout, TyLayoutMethods};\n \n /// Classification of \"eightbyte\" components.\n // NB: the order of the variants is from general to specific,\n@@ -49,9 +49,9 @@ fn classify_arg<'a, Ty, C>(cx: C, arg: &ArgType<'a, Ty>)\n         }\n \n         let mut c = match layout.abi {\n-            abi::Abi::Uninhabited => return Ok(()),\n+            Abi::Uninhabited => return Ok(()),\n \n-            abi::Abi::Scalar(ref scalar) => {\n+            Abi::Scalar(ref scalar) => {\n                 match scalar.value {\n                     abi::Int(..) |\n                     abi::Pointer => Class::Int,\n@@ -60,10 +60,10 @@ fn classify_arg<'a, Ty, C>(cx: C, arg: &ArgType<'a, Ty>)\n                 }\n             }\n \n-            abi::Abi::Vector { .. } => Class::Sse,\n+            Abi::Vector { .. } => Class::Sse,\n \n-            abi::Abi::ScalarPair(..) |\n-            abi::Abi::Aggregate { .. } => {\n+            Abi::ScalarPair(..) |\n+            Abi::Aggregate { .. } => {\n                 match layout.variants {\n                     abi::Variants::Single { .. } => {\n                         for i in 0..layout.fields.count() {\n@@ -161,7 +161,7 @@ fn reg_component(cls: &[Option<Class>], i: &mut usize, size: Size) -> Option<Reg\n                 }\n             })\n         }\n-        Some(c) => bug!(\"reg_component: unhandled class {:?}\", c)\n+        Some(c) => unreachable!(\"reg_component: unhandled class {:?}\", c)\n     }\n }\n ", "previous_filename": "src/librustc_trans/cabi_x86_64.rs"}, {"sha": "1ee069e2bbbbf1f1a01618108c2a8b96ab2c1843", "filename": "src/librustc_target/abi/call/x86_win64.rs", "status": "renamed", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_win64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_win64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_win64.rs?ref=030244cd4a76914af7dc2939ed1a16f394ceda48", "patch": "@@ -8,18 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::{ArgType, FnType, Reg};\n-\n-use rustc_target::abi;\n+use abi::call::{ArgType, FnType, Reg};\n+use abi::Abi;\n \n // Win64 ABI: http://msdn.microsoft.com/en-us/library/zthk2dkh.aspx\n \n pub fn compute_abi_info<Ty>(fty: &mut FnType<Ty>) {\n     let fixup = |a: &mut ArgType<Ty>| {\n         match a.layout.abi {\n-            abi::Abi::Uninhabited => {}\n-            abi::Abi::ScalarPair(..) |\n-            abi::Abi::Aggregate { .. } => {\n+            Abi::Uninhabited => {}\n+            Abi::ScalarPair(..) |\n+            Abi::Aggregate { .. } => {\n                 match a.layout.size.bits() {\n                     8 => a.cast_to(Reg::i8()),\n                     16 => a.cast_to(Reg::i16()),\n@@ -28,11 +27,11 @@ pub fn compute_abi_info<Ty>(fty: &mut FnType<Ty>) {\n                     _ => a.make_indirect()\n                 }\n             }\n-            abi::Abi::Vector { .. } => {\n+            Abi::Vector { .. } => {\n                 // FIXME(eddyb) there should be a size cap here\n                 // (probably what clang calls \"illegal vectors\").\n             }\n-            abi::Abi::Scalar(_) => {\n+            Abi::Scalar(_) => {\n                 if a.layout.size.bytes() > 8 {\n                     a.make_indirect();\n                 } else {", "previous_filename": "src/librustc_trans/cabi_x86_win64.rs"}, {"sha": "73c72a15b05a30acf7b354ea441c7cbe513b1267", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 72, "deletions": 312, "changes": 384, "blob_url": "https://github.com/rust-lang/rust/blob/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=030244cd4a76914af7dc2939ed1a16f394ceda48", "patch": "@@ -13,36 +13,16 @@ use base;\n use builder::Builder;\n use common::{ty_fn_sig, C_usize};\n use context::CodegenCx;\n-use cabi_x86;\n-use cabi_x86_64;\n-use cabi_x86_win64;\n-use cabi_arm;\n-use cabi_aarch64;\n-use cabi_powerpc;\n-use cabi_powerpc64;\n-use cabi_s390x;\n-use cabi_mips;\n-use cabi_mips64;\n-use cabi_asmjs;\n-use cabi_msp430;\n-use cabi_sparc;\n-use cabi_sparc64;\n-use cabi_nvptx;\n-use cabi_nvptx64;\n-use cabi_hexagon;\n-use cabi_wasm32;\n use mir::place::PlaceRef;\n use mir::operand::OperandValue;\n use type_::Type;\n use type_of::{LayoutLlvmExt, PointerKind};\n \n-use rustc_target::abi::{HasDataLayout, LayoutOf, Size, TyLayout, TyLayoutMethods};\n-use rustc_target::spec::HasTargetSpec;\n+use rustc_target::abi::{LayoutOf, Size, TyLayout};\n use rustc::ty::{self, Ty};\n use rustc::ty::layout;\n \n use libc::c_uint;\n-use std::cmp;\n \n pub use syntax::abi::Abi;\n pub use rustc::ty::layout::{FAT_PTR_ADDR, FAT_PTR_EXTRA};\n@@ -144,108 +124,6 @@ impl LlvmType for Reg {\n     }\n }\n \n-pub trait LayoutExt<'a, Ty>: Sized {\n-    fn is_aggregate(&self) -> bool;\n-    fn homogeneous_aggregate<C>(&self, cx: C) -> Option<Reg>\n-        where Ty: TyLayoutMethods<'a, C> + Copy, C: LayoutOf<Ty = Ty, TyLayout = Self> + Copy;\n-}\n-\n-impl<'a, Ty> LayoutExt<'a, Ty> for TyLayout<'a, Ty> {\n-    fn is_aggregate(&self) -> bool {\n-        match self.abi {\n-            layout::Abi::Uninhabited |\n-            layout::Abi::Scalar(_) |\n-            layout::Abi::Vector { .. } => false,\n-            layout::Abi::ScalarPair(..) |\n-            layout::Abi::Aggregate { .. } => true\n-        }\n-    }\n-\n-    fn homogeneous_aggregate<C>(&self, cx: C) -> Option<Reg> \n-        where Ty: TyLayoutMethods<'a, C> + Copy, C: LayoutOf<Ty = Ty, TyLayout = Self> + Copy\n-    {\n-        match self.abi {\n-            layout::Abi::Uninhabited => None,\n-\n-            // The primitive for this algorithm.\n-            layout::Abi::Scalar(ref scalar) => {\n-                let kind = match scalar.value {\n-                    layout::Int(..) |\n-                    layout::Pointer => RegKind::Integer,\n-                    layout::F32 |\n-                    layout::F64 => RegKind::Float\n-                };\n-                Some(Reg {\n-                    kind,\n-                    size: self.size\n-                })\n-            }\n-\n-            layout::Abi::Vector { .. } => {\n-                Some(Reg {\n-                    kind: RegKind::Vector,\n-                    size: self.size\n-                })\n-            }\n-\n-            layout::Abi::ScalarPair(..) |\n-            layout::Abi::Aggregate { .. } => {\n-                let mut total = Size::from_bytes(0);\n-                let mut result = None;\n-\n-                let is_union = match self.fields {\n-                    layout::FieldPlacement::Array { count, .. } => {\n-                        if count > 0 {\n-                            return self.field(cx, 0).homogeneous_aggregate(cx);\n-                        } else {\n-                            return None;\n-                        }\n-                    }\n-                    layout::FieldPlacement::Union(_) => true,\n-                    layout::FieldPlacement::Arbitrary { .. } => false\n-                };\n-\n-                for i in 0..self.fields.count() {\n-                    if !is_union && total != self.fields.offset(i) {\n-                        return None;\n-                    }\n-\n-                    let field = self.field(cx, i);\n-                    match (result, field.homogeneous_aggregate(cx)) {\n-                        // The field itself must be a homogeneous aggregate.\n-                        (_, None) => return None,\n-                        // If this is the first field, record the unit.\n-                        (None, Some(unit)) => {\n-                            result = Some(unit);\n-                        }\n-                        // For all following fields, the unit must be the same.\n-                        (Some(prev_unit), Some(unit)) => {\n-                            if prev_unit != unit {\n-                                return None;\n-                            }\n-                        }\n-                    }\n-\n-                    // Keep track of the offset (without padding).\n-                    let size = field.size;\n-                    if is_union {\n-                        total = cmp::max(total, size);\n-                    } else {\n-                        total += size;\n-                    }\n-                }\n-\n-                // There needs to be no padding.\n-                if total != self.size {\n-                    None\n-                } else {\n-                    result\n-                }\n-            }\n-        }\n-    }\n-}\n-\n impl LlvmType for CastTarget {\n     fn llvm_type(&self, cx: &CodegenCx) -> Type {\n         let rest_ll_unit = self.rest.unit.llvm_type(cx);\n@@ -282,107 +160,24 @@ impl LlvmType for CastTarget {\n     }\n }\n \n-/// Information about how to pass an argument to,\n-/// or return a value from, a function, under some ABI.\n-#[derive(Debug)]\n-pub struct ArgType<'tcx, Ty = ty::Ty<'tcx>> {\n-    pub layout: TyLayout<'tcx, Ty>,\n-\n-    /// Dummy argument, which is emitted before the real argument.\n-    pub pad: Option<Reg>,\n-\n-    pub mode: PassMode,\n+pub trait ArgTypeExt<'a, 'tcx> {\n+    fn memory_ty(&self, cx: &CodegenCx<'a, 'tcx>) -> Type;\n+    fn store(&self, bx: &Builder<'a, 'tcx>, val: ValueRef, dst: PlaceRef<'tcx>);\n+    fn store_fn_arg(&self, bx: &Builder<'a, 'tcx>, idx: &mut usize, dst: PlaceRef<'tcx>);\n }\n \n-impl<'a, 'tcx, Ty> ArgType<'tcx, Ty> {\n-    fn new(layout: TyLayout<'tcx, Ty>) -> Self {\n-        ArgType {\n-            layout,\n-            pad: None,\n-            mode: PassMode::Direct(ArgAttributes::new()),\n-        }\n-    }\n-\n-    pub fn make_indirect(&mut self) {\n-        assert_eq!(self.mode, PassMode::Direct(ArgAttributes::new()));\n-\n-        // Start with fresh attributes for the pointer.\n-        let mut attrs = ArgAttributes::new();\n-\n-        // For non-immediate arguments the callee gets its own copy of\n-        // the value on the stack, so there are no aliases. It's also\n-        // program-invisible so can't possibly capture\n-        attrs.set(ArgAttribute::NoAlias)\n-             .set(ArgAttribute::NoCapture)\n-             .set(ArgAttribute::NonNull);\n-        attrs.pointee_size = self.layout.size;\n-        // FIXME(eddyb) We should be doing this, but at least on\n-        // i686-pc-windows-msvc, it results in wrong stack offsets.\n-        // attrs.pointee_align = Some(self.layout.align);\n-\n-        self.mode = PassMode::Indirect(attrs);\n-    }\n-\n-    pub fn make_indirect_byval(&mut self) {\n-        self.make_indirect();\n-        match self.mode {\n-            PassMode::Indirect(ref mut attrs) => {\n-                attrs.set(ArgAttribute::ByVal);\n-            }\n-            _ => bug!()\n-        }\n-    }\n-\n-    pub fn extend_integer_width_to(&mut self, bits: u64) {\n-        // Only integers have signedness\n-        if let layout::Abi::Scalar(ref scalar) = self.layout.abi {\n-            if let layout::Int(i, signed) = scalar.value {\n-                if i.size().bits() < bits {\n-                    if let PassMode::Direct(ref mut attrs) = self.mode {\n-                        attrs.set(if signed {\n-                            ArgAttribute::SExt\n-                        } else {\n-                            ArgAttribute::ZExt\n-                        });\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    pub fn cast_to<T: Into<CastTarget>>(&mut self, target: T) {\n-        assert_eq!(self.mode, PassMode::Direct(ArgAttributes::new()));\n-        self.mode = PassMode::Cast(target.into());\n-    }\n-\n-    pub fn pad_with(&mut self, reg: Reg) {\n-        self.pad = Some(reg);\n-    }\n-\n-    pub fn is_indirect(&self) -> bool {\n-        match self.mode {\n-            PassMode::Indirect(_) => true,\n-            _ => false\n-        }\n-    }\n-\n-    pub fn is_ignore(&self) -> bool {\n-        self.mode == PassMode::Ignore\n-    }\n-}\n-\n-impl<'a, 'tcx> ArgType<'tcx> {\n+impl<'a, 'tcx> ArgTypeExt<'a, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n     /// Get the LLVM type for a place of the original Rust type of\n     /// this argument/return, i.e. the result of `type_of::type_of`.\n-    pub fn memory_ty(&self, cx: &CodegenCx<'a, 'tcx>) -> Type {\n+    fn memory_ty(&self, cx: &CodegenCx<'a, 'tcx>) -> Type {\n         self.layout.llvm_type(cx)\n     }\n \n     /// Store a direct/indirect value described by this ArgType into a\n     /// place for the original Rust type of this argument/return.\n     /// Can be used for both storing formal arguments into Rust variables\n     /// or results of call/invoke instructions into their destinations.\n-    pub fn store(&self, bx: &Builder<'a, 'tcx>, val: ValueRef, dst: PlaceRef<'tcx>) {\n+    fn store(&self, bx: &Builder<'a, 'tcx>, val: ValueRef, dst: PlaceRef<'tcx>) {\n         if self.is_ignore() {\n             return;\n         }\n@@ -434,7 +229,7 @@ impl<'a, 'tcx> ArgType<'tcx> {\n         }\n     }\n \n-    pub fn store_fn_arg(&self, bx: &Builder<'a, 'tcx>, idx: &mut usize, dst: PlaceRef<'tcx>) {\n+    fn store_fn_arg(&self, bx: &Builder<'a, 'tcx>, idx: &mut usize, dst: PlaceRef<'tcx>) {\n         let mut next = || {\n             let val = llvm::get_param(bx.llfn(), *idx as c_uint);\n             *idx += 1;\n@@ -452,42 +247,45 @@ impl<'a, 'tcx> ArgType<'tcx> {\n     }\n }\n \n-/// Metadata describing how the arguments to a native function\n-/// should be passed in order to respect the native ABI.\n-///\n-/// I will do my best to describe this structure, but these\n-/// comments are reverse-engineered and may be inaccurate. -NDM\n-#[derive(Debug)]\n-pub struct FnType<'tcx, Ty = ty::Ty<'tcx>> {\n-    /// The LLVM types of each argument.\n-    pub args: Vec<ArgType<'tcx, Ty>>,\n-\n-    /// LLVM return type.\n-    pub ret: ArgType<'tcx, Ty>,\n-\n-    pub variadic: bool,\n-\n-    pub cconv: llvm::CallConv\n+pub trait FnTypeExt<'a, 'tcx> {\n+    fn of_instance(cx: &CodegenCx<'a, 'tcx>, instance: &ty::Instance<'tcx>)\n+                   -> Self;\n+    fn new(cx: &CodegenCx<'a, 'tcx>,\n+           sig: ty::FnSig<'tcx>,\n+           extra_args: &[Ty<'tcx>]) -> Self;\n+    fn new_vtable(cx: &CodegenCx<'a, 'tcx>,\n+                  sig: ty::FnSig<'tcx>,\n+                  extra_args: &[Ty<'tcx>]) -> Self;\n+    fn unadjusted(cx: &CodegenCx<'a, 'tcx>,\n+                  sig: ty::FnSig<'tcx>,\n+                  extra_args: &[Ty<'tcx>]) -> Self;\n+    fn adjust_for_abi(&mut self,\n+                      cx: &CodegenCx<'a, 'tcx>,\n+                      abi: Abi);\n+    fn llvm_type(&self, cx: &CodegenCx<'a, 'tcx>) -> Type;\n+    fn llvm_cconv(&self) -> llvm::CallConv;\n+    fn apply_attrs_llfn(&self, llfn: ValueRef);\n+    fn apply_attrs_callsite(&self, callsite: ValueRef);\n }\n \n-impl<'a, 'tcx> FnType<'tcx> {\n-    pub fn of_instance(cx: &CodegenCx<'a, 'tcx>, instance: &ty::Instance<'tcx>)\n+impl<'a, 'tcx> FnTypeExt<'a, 'tcx> for FnType<'tcx, Ty<'tcx>> {\n+    fn of_instance(cx: &CodegenCx<'a, 'tcx>, instance: &ty::Instance<'tcx>)\n                        -> Self {\n         let fn_ty = instance.ty(cx.tcx);\n         let sig = ty_fn_sig(cx, fn_ty);\n         let sig = cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n         FnType::new(cx, sig, &[])\n     }\n \n-    pub fn new(cx: &CodegenCx<'a, 'tcx>,\n+    fn new(cx: &CodegenCx<'a, 'tcx>,\n                sig: ty::FnSig<'tcx>,\n                extra_args: &[Ty<'tcx>]) -> Self {\n         let mut fn_ty = FnType::unadjusted(cx, sig, extra_args);\n         fn_ty.adjust_for_abi(cx, sig.abi);\n         fn_ty\n     }\n \n-    pub fn new_vtable(cx: &CodegenCx<'a, 'tcx>,\n+    fn new_vtable(cx: &CodegenCx<'a, 'tcx>,\n                       sig: ty::FnSig<'tcx>,\n                       extra_args: &[Ty<'tcx>]) -> Self {\n         let mut fn_ty = FnType::unadjusted(cx, sig, extra_args);\n@@ -512,34 +310,34 @@ impl<'a, 'tcx> FnType<'tcx> {\n         fn_ty\n     }\n \n-    pub fn unadjusted(cx: &CodegenCx<'a, 'tcx>,\n+    fn unadjusted(cx: &CodegenCx<'a, 'tcx>,\n                       sig: ty::FnSig<'tcx>,\n                       extra_args: &[Ty<'tcx>]) -> Self {\n         debug!(\"FnType::unadjusted({:?}, {:?})\", sig, extra_args);\n \n         use self::Abi::*;\n-        let cconv = match cx.sess().target.target.adjust_abi(sig.abi) {\n+        let conv = match cx.sess().target.target.adjust_abi(sig.abi) {\n             RustIntrinsic | PlatformIntrinsic |\n-            Rust | RustCall => llvm::CCallConv,\n+            Rust | RustCall => Conv::C,\n \n             // It's the ABI's job to select this, not us.\n             System => bug!(\"system abi should be selected elsewhere\"),\n \n-            Stdcall => llvm::X86StdcallCallConv,\n-            Fastcall => llvm::X86FastcallCallConv,\n-            Vectorcall => llvm::X86_VectorCall,\n-            Thiscall => llvm::X86_ThisCall,\n-            C => llvm::CCallConv,\n-            Unadjusted => llvm::CCallConv,\n-            Win64 => llvm::X86_64_Win64,\n-            SysV64 => llvm::X86_64_SysV,\n-            Aapcs => llvm::ArmAapcsCallConv,\n-            PtxKernel => llvm::PtxKernel,\n-            Msp430Interrupt => llvm::Msp430Intr,\n-            X86Interrupt => llvm::X86_Intr,\n+            Stdcall => Conv::X86Stdcall,\n+            Fastcall => Conv::X86Fastcall,\n+            Vectorcall => Conv::X86VectorCall,\n+            Thiscall => Conv::X86ThisCall,\n+            C => Conv::C,\n+            Unadjusted => Conv::C,\n+            Win64 => Conv::X86_64Win64,\n+            SysV64 => Conv::X86_64SysV,\n+            Aapcs => Conv::ArmAapcs,\n+            PtxKernel => Conv::PtxKernel,\n+            Msp430Interrupt => Conv::Msp430Intr,\n+            X86Interrupt => Conv::X86Intr,\n \n             // These API constants ought to be more specific...\n-            Cdecl => llvm::CCallConv,\n+            Cdecl => Conv::C,\n         };\n \n         let mut inputs = sig.inputs();\n@@ -682,7 +480,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n                 arg_of(ty, false)\n             }).collect(),\n             variadic: sig.variadic,\n-            cconv,\n+            conv,\n         }\n     }\n \n@@ -693,7 +491,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n \n         if abi == Abi::Rust || abi == Abi::RustCall ||\n            abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n-            let fixup = |arg: &mut ArgType<'tcx>| {\n+            let fixup = |arg: &mut ArgType<'tcx, Ty<'tcx>>| {\n                 if arg.is_ignore() { return; }\n \n                 match arg.layout.abi {\n@@ -753,63 +551,8 @@ impl<'a, 'tcx> FnType<'tcx> {\n             cx.sess().fatal(&msg);\n         }\n     }\n-}\n \n-impl<'a, Ty> FnType<'a, Ty> {\n-    fn adjust_for_cabi<C>(&mut self, cx: C, abi: Abi) -> Result<(), String>\n-        where Ty: TyLayoutMethods<'a, C> + Copy,\n-              C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout + HasTargetSpec\n-    {\n-        match &cx.target_spec().arch[..] {\n-            \"x86\" => {\n-                let flavor = if abi == Abi::Fastcall {\n-                    cabi_x86::Flavor::Fastcall\n-                } else {\n-                    cabi_x86::Flavor::General\n-                };\n-                cabi_x86::compute_abi_info(cx, self, flavor);\n-            },\n-            \"x86_64\" => if abi == Abi::SysV64 {\n-                cabi_x86_64::compute_abi_info(cx, self);\n-            } else if abi == Abi::Win64 || cx.target_spec().options.is_like_windows {\n-                cabi_x86_win64::compute_abi_info(self);\n-            } else {\n-                cabi_x86_64::compute_abi_info(cx, self);\n-            },\n-            \"aarch64\" => cabi_aarch64::compute_abi_info(cx, self),\n-            \"arm\" => cabi_arm::compute_abi_info(cx, self),\n-            \"mips\" => cabi_mips::compute_abi_info(cx, self),\n-            \"mips64\" => cabi_mips64::compute_abi_info(cx, self),\n-            \"powerpc\" => cabi_powerpc::compute_abi_info(cx, self),\n-            \"powerpc64\" => cabi_powerpc64::compute_abi_info(cx, self),\n-            \"s390x\" => cabi_s390x::compute_abi_info(cx, self),\n-            \"asmjs\" => cabi_asmjs::compute_abi_info(cx, self),\n-            \"wasm32\" => {\n-                if cx.target_spec().llvm_target.contains(\"emscripten\") {\n-                    cabi_asmjs::compute_abi_info(cx, self)\n-                } else {\n-                    cabi_wasm32::compute_abi_info(self)\n-                }\n-            }\n-            \"msp430\" => cabi_msp430::compute_abi_info(self),\n-            \"sparc\" => cabi_sparc::compute_abi_info(cx, self),\n-            \"sparc64\" => cabi_sparc64::compute_abi_info(cx, self),\n-            \"nvptx\" => cabi_nvptx::compute_abi_info(self),\n-            \"nvptx64\" => cabi_nvptx64::compute_abi_info(self),\n-            \"hexagon\" => cabi_hexagon::compute_abi_info(self),\n-            a => return Err(format!(\"unrecognized arch \\\"{}\\\" in target specification\", a))\n-        }\n-\n-        if let PassMode::Indirect(ref mut attrs) = self.ret.mode {\n-            attrs.set(ArgAttribute::StructRet);\n-        }\n-\n-        Ok(())\n-    }\n-}\n-\n-impl<'a, 'tcx> FnType<'tcx> {\n-    pub fn llvm_type(&self, cx: &CodegenCx<'a, 'tcx>) -> Type {\n+    fn llvm_type(&self, cx: &CodegenCx<'a, 'tcx>) -> Type {\n         let mut llargument_tys = Vec::new();\n \n         let llreturn_ty = match self.ret.mode {\n@@ -851,7 +594,23 @@ impl<'a, 'tcx> FnType<'tcx> {\n         }\n     }\n \n-    pub fn apply_attrs_llfn(&self, llfn: ValueRef) {\n+    fn llvm_cconv(&self) -> llvm::CallConv {\n+        match self.conv {\n+            Conv::C => llvm::CCallConv,\n+            Conv::ArmAapcs => llvm::ArmAapcsCallConv,\n+            Conv::Msp430Intr => llvm::Msp430Intr,\n+            Conv::PtxKernel => llvm::PtxKernel,\n+            Conv::X86Fastcall => llvm::X86FastcallCallConv,\n+            Conv::X86Intr => llvm::X86_Intr,\n+            Conv::X86Stdcall => llvm::X86StdcallCallConv,\n+            Conv::X86ThisCall => llvm::X86_ThisCall,\n+            Conv::X86VectorCall => llvm::X86_VectorCall,\n+            Conv::X86_64SysV => llvm::X86_64_SysV,\n+            Conv::X86_64Win64 => llvm::X86_64_Win64,\n+        }\n+    }\n+\n+    fn apply_attrs_llfn(&self, llfn: ValueRef) {\n         let mut i = 0;\n         let mut apply = |attrs: &ArgAttributes| {\n             attrs.apply_llfn(llvm::AttributePlace::Argument(i), llfn);\n@@ -881,7 +640,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n         }\n     }\n \n-    pub fn apply_attrs_callsite(&self, callsite: ValueRef) {\n+    fn apply_attrs_callsite(&self, callsite: ValueRef) {\n         let mut i = 0;\n         let mut apply = |attrs: &ArgAttributes| {\n             attrs.apply_callsite(llvm::AttributePlace::Argument(i), callsite);\n@@ -910,8 +669,9 @@ impl<'a, 'tcx> FnType<'tcx> {\n             }\n         }\n \n-        if self.cconv != llvm::CCallConv {\n-            llvm::SetInstructionCallConv(callsite, self.cconv);\n+        let cconv = self.llvm_cconv();\n+        if cconv != llvm::CCallConv {\n+            llvm::SetInstructionCallConv(callsite, cconv);\n         }\n     }\n }"}, {"sha": "bbe4e18b18cb1fd9ab3d175ad838341d36107df4", "filename": "src/librustc_trans/declare.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_trans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_trans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdeclare.rs?ref=030244cd4a76914af7dc2939ed1a16f394ceda48", "patch": "@@ -25,7 +25,7 @@ use llvm::AttributePlace::Function;\n use rustc::ty::{self, Ty};\n use rustc::session::config::Sanitizer;\n use rustc_target::spec::PanicStrategy;\n-use abi::{Abi, FnType};\n+use abi::{Abi, FnType, FnTypeExt};\n use attributes;\n use context::CodegenCx;\n use common;\n@@ -131,7 +131,7 @@ pub fn declare_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, name: &str,\n     debug!(\"declare_rust_fn (after region erasure) sig={:?}\", sig);\n \n     let fty = FnType::new(cx, sig, &[]);\n-    let llfn = declare_raw_fn(cx, name, fty.cconv, fty.llvm_type(cx));\n+    let llfn = declare_raw_fn(cx, name, fty.llvm_cconv(), fty.llvm_type(cx));\n \n     // FIXME(canndrew): This is_never should really be an is_uninhabited\n     if sig.output().is_never() {"}, {"sha": "103b04e6f135b58b1ec79b8bbf770a8338aaa6a7", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=030244cd4a76914af7dc2939ed1a16f394ceda48", "patch": "@@ -87,7 +87,7 @@ fn get_simple_intrinsic(cx: &CodegenCx, name: &str) -> Option<ValueRef> {\n /// add them to librustc_trans/trans/context.rs\n pub fn trans_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n                                       callee_ty: Ty<'tcx>,\n-                                      fn_ty: &FnType<'tcx>,\n+                                      fn_ty: &FnType<'tcx, Ty<'tcx>>,\n                                       args: &[OperandRef<'tcx>],\n                                       llresult: ValueRef,\n                                       span: Span) {"}, {"sha": "dab01abd3353a48ce7ac350a8d39661cf7990a2e", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=030244cd4a76914af7dc2939ed1a16f394ceda48", "patch": "@@ -102,24 +102,6 @@ mod asm;\n mod attributes;\n mod base;\n mod builder;\n-mod cabi_aarch64;\n-mod cabi_arm;\n-mod cabi_asmjs;\n-mod cabi_hexagon;\n-mod cabi_mips;\n-mod cabi_mips64;\n-mod cabi_msp430;\n-mod cabi_nvptx;\n-mod cabi_nvptx64;\n-mod cabi_powerpc;\n-mod cabi_powerpc64;\n-mod cabi_s390x;\n-mod cabi_sparc;\n-mod cabi_sparc64;\n-mod cabi_x86;\n-mod cabi_x86_64;\n-mod cabi_x86_win64;\n-mod cabi_wasm32;\n mod callee;\n mod common;\n mod consts;"}, {"sha": "21bbdf31dcb5200d8fa04068ad3e94fa83fec9f1", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=030244cd4a76914af7dc2939ed1a16f394ceda48", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use llvm::ValueRef;\n-use abi::FnType;\n+use abi::{FnType, FnTypeExt};\n use callee;\n use common::*;\n use builder::Builder;\n@@ -35,7 +35,7 @@ impl<'a, 'tcx> VirtualIndex {\n \n     pub fn get_fn(self, bx: &Builder<'a, 'tcx>,\n                   llvtable: ValueRef,\n-                  fn_ty: &FnType<'tcx>) -> ValueRef {\n+                  fn_ty: &FnType<'tcx, Ty<'tcx>>) -> ValueRef {\n         // Load the data pointer from the object.\n         debug!(\"get_fn({:?}, {:?})\", Value(llvtable), self);\n "}, {"sha": "36f03605feabd56fb0991426e635b2ee418d4e48", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=030244cd4a76914af7dc2939ed1a16f394ceda48", "patch": "@@ -10,10 +10,10 @@\n \n use llvm::{self, ValueRef, BasicBlockRef};\n use rustc::middle::lang_items;\n-use rustc::ty::{self, TypeFoldable};\n+use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::layout::{self, LayoutOf};\n use rustc::mir;\n-use abi::{Abi, FnType, ArgType, LlvmType, PassMode};\n+use abi::{Abi, ArgType, ArgTypeExt, FnType, FnTypeExt, LlvmType, PassMode};\n use base;\n use callee;\n use builder::Builder;\n@@ -110,7 +110,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n         let do_call = |\n             this: &mut Self,\n             bx: Builder<'a, 'tcx>,\n-            fn_ty: FnType<'tcx>,\n+            fn_ty: FnType<'tcx, Ty<'tcx>>,\n             fn_ptr: ValueRef,\n             llargs: &[ValueRef],\n             destination: Option<(ReturnDest<'tcx>, mir::BasicBlock)>,\n@@ -604,7 +604,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                       bx: &Builder<'a, 'tcx>,\n                       op: OperandRef<'tcx>,\n                       llargs: &mut Vec<ValueRef>,\n-                      arg: &ArgType<'tcx>) {\n+                      arg: &ArgType<'tcx, Ty<'tcx>>) {\n         // Fill padding with undef value, where applicable.\n         if let Some(ty) = arg.pad {\n             llargs.push(C_undef(ty.llvm_type(bx.cx)));\n@@ -683,7 +683,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                                 bx: &Builder<'a, 'tcx>,\n                                 operand: &mir::Operand<'tcx>,\n                                 llargs: &mut Vec<ValueRef>,\n-                                args: &[ArgType<'tcx>]) {\n+                                args: &[ArgType<'tcx, Ty<'tcx>>]) {\n         let tuple = self.trans_operand(bx, operand);\n \n         // Handle both by-ref and immediate tuples.\n@@ -776,7 +776,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     }\n \n     fn make_return_dest(&mut self, bx: &Builder<'a, 'tcx>,\n-                        dest: &mir::Place<'tcx>, fn_ret: &ArgType<'tcx>,\n+                        dest: &mir::Place<'tcx>, fn_ret: &ArgType<'tcx, Ty<'tcx>>,\n                         llargs: &mut Vec<ValueRef>, is_intrinsic: bool)\n                         -> ReturnDest<'tcx> {\n         // If the return is ignored, we can just return a do-nothing ReturnDest\n@@ -873,7 +873,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     fn store_return(&mut self,\n                     bx: &Builder<'a, 'tcx>,\n                     dest: ReturnDest<'tcx>,\n-                    ret_ty: &ArgType<'tcx>,\n+                    ret_ty: &ArgType<'tcx, Ty<'tcx>>,\n                     llval: ValueRef) {\n         use self::ReturnDest::*;\n "}, {"sha": "a074f25dfc9bae18cbab0917629ffda556b52085", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=030244cd4a76914af7dc2939ed1a16f394ceda48", "patch": "@@ -12,7 +12,7 @@ use common::{C_i32, C_null};\n use libc::c_uint;\n use llvm::{self, ValueRef, BasicBlockRef};\n use llvm::debuginfo::DIScope;\n-use rustc::ty::{self, TypeFoldable};\n+use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::layout::{LayoutOf, TyLayout};\n use rustc::mir::{self, Mir};\n use rustc::ty::subst::Substs;\n@@ -22,7 +22,7 @@ use builder::Builder;\n use common::{CodegenCx, Funclet};\n use debuginfo::{self, declare_local, VariableAccess, VariableKind, FunctionDebugContext};\n use monomorphize::Instance;\n-use abi::{ArgAttribute, FnType, PassMode};\n+use abi::{ArgAttribute, ArgTypeExt, FnType, FnTypeExt, PassMode};\n use type_::Type;\n \n use syntax_pos::{DUMMY_SP, NO_EXPANSION, BytePos, Span};\n@@ -53,7 +53,7 @@ pub struct FunctionCx<'a, 'tcx:'a> {\n \n     cx: &'a CodegenCx<'a, 'tcx>,\n \n-    fn_ty: FnType<'tcx>,\n+    fn_ty: FnType<'tcx, Ty<'tcx>>,\n \n     /// When unwinding is initiated, we have to store this personality\n     /// value somewhere so that we can load it and re-use it in the"}, {"sha": "5e6b276495764078c308925028e569f56b52fdaf", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030244cd4a76914af7dc2939ed1a16f394ceda48/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=030244cd4a76914af7dc2939ed1a16f394ceda48", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::FnType;\n+use abi::{FnType, FnTypeExt};\n use common::*;\n use rustc::hir;\n use rustc::ty::{self, Ty, TypeFoldable};"}]}