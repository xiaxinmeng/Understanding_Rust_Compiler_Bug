{"sha": "dee6d0f62e3b8bf8e58c4106f0f9bb54237c0807", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlZTZkMGY2MmUzYjhiZjhlNThjNDEwNmYwZjliYjU0MjM3YzA4MDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-08T23:47:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-08T23:47:16Z"}, "message": "Auto merge of #44269 - nikomatsakis:issue-43613-limit-cache-obligations, r=arielb1\n\nlimit and clear cache obligations opportunistically\n\nKeeping **all** the obligations for every projection is wasteful of\nmemory and compilation time. We only really care about those\nsubobligations that may inform the result of the projection (i.e., may\nhelp to resolve any inference variables that appear within).\nTherefore, we can clear the subobligations from the cache that don't\npotentially affect the result of the projection. On every cache hit,\nwe also take the opportunity to check if the type variables have been\nresolved *yet* and, if so, clear out the pending obligations.\n\nFixes #43613.\n\nr? @arielb1\n\nNB -- not sure how to test for this. Probably we should add the #43613 test case to perf.", "tree": {"sha": "9d6a5769637d9f38e21c687eadc05e0cf1190397", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d6a5769637d9f38e21c687eadc05e0cf1190397"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dee6d0f62e3b8bf8e58c4106f0f9bb54237c0807", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dee6d0f62e3b8bf8e58c4106f0f9bb54237c0807", "html_url": "https://github.com/rust-lang/rust/commit/dee6d0f62e3b8bf8e58c4106f0f9bb54237c0807", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dee6d0f62e3b8bf8e58c4106f0f9bb54237c0807/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dead08cb331343b84564628b139b657f93548320", "url": "https://api.github.com/repos/rust-lang/rust/commits/dead08cb331343b84564628b139b657f93548320", "html_url": "https://github.com/rust-lang/rust/commit/dead08cb331343b84564628b139b657f93548320"}, {"sha": "c1dddcec06428f5a19adb936774b31d42b57d8af", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1dddcec06428f5a19adb936774b31d42b57d8af", "html_url": "https://github.com/rust-lang/rust/commit/c1dddcec06428f5a19adb936774b31d42b57d8af"}], "stats": {"total": 164, "additions": 156, "deletions": 8}, "files": [{"sha": "3fe3a3dc58560ef0481d2fd291278a6a29d817b1", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dee6d0f62e3b8bf8e58c4106f0f9bb54237c0807/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dee6d0f62e3b8bf8e58c4106f0f9bb54237c0807/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=dee6d0f62e3b8bf8e58c4106f0f9bb54237c0807", "patch": "@@ -1160,6 +1160,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         value.fold_with(&mut r)\n     }\n \n+    /// Returns true if `T` contains unresolved type variables. In the\n+    /// process of visiting `T`, this will resolve (where possible)\n+    /// type variables in `T`, but it never constructs the final,\n+    /// resolved type, so it's more efficient than\n+    /// `resolve_type_vars_if_possible()`.\n+    pub fn any_unresolved_type_vars<T>(&self, value: &T) -> bool\n+        where T: TypeFoldable<'tcx>\n+    {\n+        let mut r = resolve::UnresolvedTypeFinder::new(self);\n+        value.visit_with(&mut r)\n+    }\n+\n     pub fn resolve_type_and_region_vars_if_possible<T>(&self, value: &T) -> T\n         where T: TypeFoldable<'tcx>\n     {"}, {"sha": "10899e42afb819b74ad124db8506ca87a939f930", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/dee6d0f62e3b8bf8e58c4106f0f9bb54237c0807/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dee6d0f62e3b8bf8e58c4106f0f9bb54237c0807/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=dee6d0f62e3b8bf8e58c4106f0f9bb54237c0807", "patch": "@@ -10,7 +10,7 @@\n \n use super::{InferCtxt, FixupError, FixupResult};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n-use ty::fold::TypeFolder;\n+use ty::fold::{TypeFolder, TypeVisitor};\n \n ///////////////////////////////////////////////////////////////////////////\n // OPPORTUNISTIC TYPE RESOLVER\n@@ -80,6 +80,43 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticTypeAndRegionResolv\n     }\n }\n \n+///////////////////////////////////////////////////////////////////////////\n+// UNRESOLVED TYPE FINDER\n+\n+/// The unresolved type **finder** walks your type and searches for\n+/// type variables that don't yet have a value. They get pushed into a\n+/// vector. It does not construct the fully resolved type (which might\n+/// involve some hashing and so forth).\n+pub struct UnresolvedTypeFinder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> UnresolvedTypeFinder<'a, 'gcx, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n+        UnresolvedTypeFinder { infcx }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeFinder<'a, 'gcx, 'tcx> {\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+        let t = self.infcx.shallow_resolve(t);\n+        if t.has_infer_types() {\n+            if let ty::TyInfer(_) = t.sty {\n+                // Since we called `shallow_resolve` above, this must\n+                // be an (as yet...) unresolved inference variable.\n+                true\n+            } else {\n+                // Otherwise, visit its contents.\n+                t.super_visit_with(self)\n+            }\n+        } else {\n+            // Micro-optimize: no inference types at all Can't have unresolved type\n+            // variables, no need to visit the contents.\n+            false\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // FULL TYPE RESOLUTION\n "}, {"sha": "9a0d76144368a61a082fcf90c0fe957283ac6b9d", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 102, "deletions": 7, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/dee6d0f62e3b8bf8e58c4106f0f9bb54237c0807/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dee6d0f62e3b8bf8e58c4106f0f9bb54237c0807/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=dee6d0f62e3b8bf8e58c4106f0f9bb54237c0807", "patch": "@@ -25,7 +25,7 @@ use super::VtableImplData;\n use super::util;\n \n use hir::def_id::DefId;\n-use infer::InferOk;\n+use infer::{InferCtxt, InferOk};\n use infer::type_variable::TypeVariableOrigin;\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n use syntax::ast;\n@@ -416,7 +416,8 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n     // bounds. It might be the case that we want two distinct caches,\n     // or else another kind of cache entry.\n \n-    match infcx.projection_cache.borrow_mut().try_start(cache_key) {\n+    let cache_result = infcx.projection_cache.borrow_mut().try_start(cache_key);\n+    match cache_result {\n         Ok(()) => { }\n         Err(ProjectionCacheEntry::Ambiguous) => {\n             // If we found ambiguity the last time, that generally\n@@ -466,7 +467,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                                                     projection_ty);\n             selcx.infcx().report_overflow_error(&obligation, false);\n         }\n-        Err(ProjectionCacheEntry::NormalizedTy(ty)) => {\n+        Err(ProjectionCacheEntry::NormalizedTy(mut ty)) => {\n             // If we find the value in the cache, then return it along\n             // with the obligations that went along with it. Note\n             // that, when using a fulfillment context, these\n@@ -479,6 +480,21 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             debug!(\"opt_normalize_projection_type: \\\n                     found normalized ty `{:?}`\",\n                    ty);\n+\n+            // Once we have inferred everything we need to know, we\n+            // can ignore the `obligations` from that point on.\n+            if !infcx.any_unresolved_type_vars(&ty.value) {\n+                infcx.projection_cache.borrow_mut().complete(cache_key);\n+                ty.obligations = vec![];\n+            }\n+\n+            push_paranoid_cache_value_obligation(infcx,\n+                                                 param_env,\n+                                                 projection_ty,\n+                                                 cause,\n+                                                 depth,\n+                                                 &mut ty);\n+\n             return Some(ty);\n         }\n         Err(ProjectionCacheEntry::Error) => {\n@@ -527,7 +543,10 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                     obligations,\n                 }\n             };\n-            infcx.projection_cache.borrow_mut().insert_ty(cache_key, &result);\n+\n+            let cache_value = prune_cache_value_obligations(infcx, &result);\n+            infcx.projection_cache.borrow_mut().insert_ty(cache_key, cache_value);\n+\n             Some(result)\n         }\n         Ok(ProjectedTy::NoProgress(projected_ty)) => {\n@@ -538,7 +557,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                 value: projected_ty,\n                 obligations: vec![]\n             };\n-            infcx.projection_cache.borrow_mut().insert_ty(cache_key, &result);\n+            infcx.projection_cache.borrow_mut().insert_ty(cache_key, result.clone());\n             Some(result)\n         }\n         Err(ProjectionTyError::TooManyCandidates) => {\n@@ -562,6 +581,82 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n     }\n }\n \n+/// If there are unresolved type variables, then we need to include\n+/// any subobligations that bind them, at least until those type\n+/// variables are fully resolved.\n+fn prune_cache_value_obligations<'a, 'gcx, 'tcx>(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+                                                 result: &NormalizedTy<'tcx>)\n+                                                 -> NormalizedTy<'tcx> {\n+    if !infcx.any_unresolved_type_vars(&result.value) {\n+        return NormalizedTy { value: result.value, obligations: vec![] };\n+    }\n+\n+    let mut obligations: Vec<_> =\n+        result.obligations\n+              .iter()\n+              .filter(|obligation| match obligation.predicate {\n+                  // We found a `T: Foo<X = U>` predicate, let's check\n+                  // if `U` references any unresolved type\n+                  // variables. In principle, we only care if this\n+                  // projection can help resolve any of the type\n+                  // variables found in `result.value` -- but we just\n+                  // check for any type variables here, for fear of\n+                  // indirect obligations (e.g., we project to `?0`,\n+                  // but we have `T: Foo<X = ?1>` and `?1: Bar<X =\n+                  // ?0>`).\n+                  ty::Predicate::Projection(ref data) =>\n+                      !infcx.any_unresolved_type_vars(&data.ty()),\n+\n+                  // We are only interested in `T: Foo<X = U>` predicates, whre\n+                  // `U` references one of `unresolved_type_vars`. =)\n+                  _ => false,\n+              })\n+              .cloned()\n+              .collect();\n+\n+    obligations.shrink_to_fit();\n+\n+    NormalizedTy { value: result.value, obligations }\n+}\n+\n+/// Whenever we give back a cache result for a projection like `<T as\n+/// Trait>::Item ==> X`, we *always* include the obligation to prove\n+/// that `T: Trait` (we may also include some other obligations). This\n+/// may or may not be necessary -- in principle, all the obligations\n+/// that must be proven to show that `T: Trait` were also returned\n+/// when the cache was first populated. But there are some vague concerns,\n+/// and so we take the precatuionary measure of including `T: Trait` in\n+/// the result:\n+///\n+/// Concern #1. The current setup is fragile. Perhaps someone could\n+/// have failed to prove the concerns from when the cache was\n+/// populated, but also not have used a snapshot, in which case the\n+/// cache could remain populated even though `T: Trait` has not been\n+/// shown. In this case, the \"other code\" is at fault -- when you\n+/// project something, you are supposed to either have a snapshot or\n+/// else prove all the resulting obligations -- but it's still easy to\n+/// get wrong.\n+///\n+/// Concern #2. Even within the snapshot, if those original\n+/// obligations are not yet proven, then we are able to do projections\n+/// that may yet turn out to be wrong.  This *may* lead to some sort\n+/// of trouble, though we don't have a concrete example of how that\n+/// can occur yet.  But it seems risky at best.\n+fn push_paranoid_cache_value_obligation<'a, 'gcx, 'tcx>(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+                                                        param_env: ty::ParamEnv<'tcx>,\n+                                                        projection_ty: ty::ProjectionTy<'tcx>,\n+                                                        cause: ObligationCause<'tcx>,\n+                                                        depth: usize,\n+                                                        result: &mut NormalizedTy<'tcx>)\n+{\n+    let trait_ref = projection_ty.trait_ref(infcx.tcx).to_poly_trait_ref();\n+    let trait_obligation = Obligation { cause,\n+                                        recursion_depth: depth,\n+                                        param_env,\n+                                        predicate: trait_ref.to_predicate() };\n+    result.obligations.push(trait_obligation);\n+}\n+\n /// If we are projecting `<T as Trait>::Item`, but `T: Trait` does not\n /// hold. In various error cases, we cannot generate a valid\n /// normalized projection. Therefore, we create an inference variable\n@@ -1493,10 +1588,10 @@ impl<'tcx> ProjectionCache<'tcx> {\n     }\n \n     /// Indicates that `key` was normalized to `value`.\n-    fn insert_ty(&mut self, key: ProjectionCacheKey<'tcx>, value: &NormalizedTy<'tcx>) {\n+    fn insert_ty(&mut self, key: ProjectionCacheKey<'tcx>, value: NormalizedTy<'tcx>) {\n         debug!(\"ProjectionCacheEntry::insert_ty: adding cache entry: key={:?}, value={:?}\",\n                key, value);\n-        let fresh_key = self.map.insert(key, ProjectionCacheEntry::NormalizedTy(value.clone()));\n+        let fresh_key = self.map.insert(key, ProjectionCacheEntry::NormalizedTy(value));\n         assert!(!fresh_key, \"never started projecting `{:?}`\", key);\n     }\n "}, {"sha": "5c29f4f24db6bf1d95cfecb6aba479df17b6e77d", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dee6d0f62e3b8bf8e58c4106f0f9bb54237c0807/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dee6d0f62e3b8bf8e58c4106f0f9bb54237c0807/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=dee6d0f62e3b8bf8e58c4106f0f9bb54237c0807", "patch": "@@ -1017,6 +1017,10 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n         // levels.\n         ty::Binder(self.0.projection_ty.trait_ref(tcx))\n     }\n+\n+    pub fn ty(&self) -> Binder<Ty<'tcx>> {\n+        Binder(self.skip_binder().ty) // preserves binding levels\n+    }\n }\n \n pub trait ToPolyTraitRef<'tcx> {"}]}