{"sha": "74621c764e737a1a430bac088b5507a8854ec460", "node_id": "C_kwDOAAsO6NoAKDc0NjIxYzc2NGU3MzdhMWE0MzBiYWMwODhiNTUwN2E4ODU0ZWM0NjA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-14T16:23:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-14T16:23:07Z"}, "message": "Auto merge of #99242 - Dylan-DPC:rollup-34bqdh8, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #98072 (Add provider API to error trait)\n - #98580 (Emit warning when named arguments are used positionally in format)\n - #99000 (Move abstract const to middle)\n - #99192 (Fix spans for asm diagnostics)\n - #99222 (Better error message for generic_const_exprs inference failure)\n - #99236 (solaris: unbreak build on native platform)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "bf1469f64d443dd475b1e71c96b5b288b53e7a7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf1469f64d443dd475b1e71c96b5b288b53e7a7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74621c764e737a1a430bac088b5507a8854ec460", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74621c764e737a1a430bac088b5507a8854ec460", "html_url": "https://github.com/rust-lang/rust/commit/74621c764e737a1a430bac088b5507a8854ec460", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74621c764e737a1a430bac088b5507a8854ec460/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24699bcbadff59693a89a5184afed87f6416cdea", "url": "https://api.github.com/repos/rust-lang/rust/commits/24699bcbadff59693a89a5184afed87f6416cdea", "html_url": "https://github.com/rust-lang/rust/commit/24699bcbadff59693a89a5184afed87f6416cdea"}, {"sha": "f74358d052a9e58238a984e12785ef6a9adcee22", "url": "https://api.github.com/repos/rust-lang/rust/commits/f74358d052a9e58238a984e12785ef6a9adcee22", "html_url": "https://github.com/rust-lang/rust/commit/f74358d052a9e58238a984e12785ef6a9adcee22"}], "stats": {"total": 2098, "additions": 1320, "deletions": 778}, "files": [{"sha": "147d47044078a9fa7e8896fac80fd788c315bb41", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -4514,6 +4514,7 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_hir\",\n+ \"rustc_index\",\n  \"rustc_infer\",\n  \"rustc_middle\",\n  \"rustc_session\","}, {"sha": "829eaa305e8c02bd063d4f71d61ebc9229d69fe3", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -534,8 +534,8 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, args: AsmArgs) -> Option<ast::Inl\n \n     let mut template_strs = Vec::with_capacity(args.templates.len());\n \n-    for template_expr in args.templates.into_iter() {\n-        if !template.is_empty() {\n+    for (i, template_expr) in args.templates.into_iter().enumerate() {\n+        if i != 0 {\n             template.push(ast::InlineAsmTemplatePiece::String(\"\\n\".to_string()));\n         }\n "}, {"sha": "4791151c7d3095e18205dd26986d5703642edf18", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 72, "deletions": 13, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -14,6 +14,9 @@ use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{InnerSpan, Span};\n use smallvec::SmallVec;\n \n+use rustc_lint_defs::builtin::NAMED_ARGUMENTS_USED_POSITIONALLY;\n+use rustc_lint_defs::{BufferedEarlyLint, BuiltinLintDiagnostics, LintId};\n+use rustc_parse_format::{Count, FormatSpec};\n use std::borrow::Cow;\n use std::collections::hash_map::Entry;\n \n@@ -57,7 +60,7 @@ struct Context<'a, 'b> {\n     /// Unique format specs seen for each argument.\n     arg_unique_types: Vec<Vec<ArgumentType>>,\n     /// Map from named arguments to their resolved indices.\n-    names: FxHashMap<Symbol, usize>,\n+    names: FxHashMap<Symbol, (usize, Span)>,\n \n     /// The latest consecutive literal strings, or empty if there weren't any.\n     literal: String,\n@@ -130,9 +133,9 @@ fn parse_args<'a>(\n     ecx: &mut ExtCtxt<'a>,\n     sp: Span,\n     tts: TokenStream,\n-) -> PResult<'a, (P<ast::Expr>, Vec<P<ast::Expr>>, FxHashMap<Symbol, usize>)> {\n+) -> PResult<'a, (P<ast::Expr>, Vec<P<ast::Expr>>, FxHashMap<Symbol, (usize, Span)>)> {\n     let mut args = Vec::<P<ast::Expr>>::new();\n-    let mut names = FxHashMap::<Symbol, usize>::default();\n+    let mut names = FxHashMap::<Symbol, (usize, Span)>::default();\n \n     let mut p = ecx.new_parser_from_tts(tts);\n \n@@ -197,7 +200,7 @@ fn parse_args<'a>(\n                 p.bump();\n                 p.expect(&token::Eq)?;\n                 let e = p.parse_expr()?;\n-                if let Some(prev) = names.get(&ident.name) {\n+                if let Some((prev, _)) = names.get(&ident.name) {\n                     ecx.struct_span_err(e.span, &format!(\"duplicate argument named `{}`\", ident))\n                         .span_label(args[*prev].span, \"previously here\")\n                         .span_label(e.span, \"duplicate argument\")\n@@ -210,7 +213,7 @@ fn parse_args<'a>(\n                 // if the input is valid, we can simply append to the positional\n                 // args. And remember the names.\n                 let slot = args.len();\n-                names.insert(ident.name, slot);\n+                names.insert(ident.name, (slot, ident.span));\n                 args.push(e);\n             }\n             _ => {\n@@ -222,7 +225,7 @@ fn parse_args<'a>(\n                     );\n                     err.span_label(e.span, \"positional arguments must be before named arguments\");\n                     for pos in names.values() {\n-                        err.span_label(args[*pos].span, \"named argument\");\n+                        err.span_label(args[pos.0].span, \"named argument\");\n                     }\n                     err.emit();\n                 }\n@@ -242,7 +245,8 @@ impl<'a, 'b> Context<'a, 'b> {\n     fn resolve_name_inplace(&self, p: &mut parse::Piece<'_>) {\n         // NOTE: the `unwrap_or` branch is needed in case of invalid format\n         // arguments, e.g., `format_args!(\"{foo}\")`.\n-        let lookup = |s: &str| *self.names.get(&Symbol::intern(s)).unwrap_or(&0);\n+        let lookup =\n+            |s: &str| self.names.get(&Symbol::intern(s)).unwrap_or(&(0, Span::default())).0;\n \n         match *p {\n             parse::String(_) => {}\n@@ -548,7 +552,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 match self.names.get(&name) {\n                     Some(&idx) => {\n                         // Treat as positional arg.\n-                        self.verify_arg_type(Capture(idx), ty)\n+                        self.verify_arg_type(Capture(idx.0), ty)\n                     }\n                     None => {\n                         // For the moment capturing variables from format strings expanded from macros is\n@@ -565,7 +569,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                             };\n                             self.num_captured_args += 1;\n                             self.args.push(self.ecx.expr_ident(span, Ident::new(name, span)));\n-                            self.names.insert(name, idx);\n+                            self.names.insert(name, (idx, span));\n                             self.verify_arg_type(Capture(idx), ty)\n                         } else {\n                             let msg = format!(\"there is no argument named `{}`\", name);\n@@ -967,14 +971,57 @@ pub fn expand_format_args_nl<'cx>(\n     expand_format_args_impl(ecx, sp, tts, true)\n }\n \n+fn lint_named_arguments_used_positionally(\n+    names: FxHashMap<Symbol, (usize, Span)>,\n+    cx: &mut Context<'_, '_>,\n+    unverified_pieces: Vec<parse::Piece<'_>>,\n+) {\n+    let mut used_argument_names = FxHashSet::<&str>::default();\n+    for piece in unverified_pieces {\n+        if let rustc_parse_format::Piece::NextArgument(a) = piece {\n+            match a.position {\n+                rustc_parse_format::Position::ArgumentNamed(arg_name, _) => {\n+                    used_argument_names.insert(arg_name);\n+                }\n+                _ => {}\n+            };\n+            match a.format {\n+                FormatSpec { width: Count::CountIsName(s, _), .. }\n+                | FormatSpec { precision: Count::CountIsName(s, _), .. } => {\n+                    used_argument_names.insert(s);\n+                }\n+                _ => {}\n+            };\n+        }\n+    }\n+\n+    for (symbol, (index, span)) in names {\n+        if !used_argument_names.contains(symbol.as_str()) {\n+            let msg = format!(\"named argument `{}` is not used by name\", symbol.as_str());\n+            let arg_span = cx.arg_spans[index];\n+            cx.ecx.buffered_early_lint.push(BufferedEarlyLint {\n+                span: MultiSpan::from_span(span),\n+                msg: msg.clone(),\n+                node_id: ast::CRATE_NODE_ID,\n+                lint_id: LintId::of(&NAMED_ARGUMENTS_USED_POSITIONALLY),\n+                diagnostic: BuiltinLintDiagnostics::NamedArgumentUsedPositionally(\n+                    arg_span,\n+                    span,\n+                    symbol.to_string(),\n+                ),\n+            });\n+        }\n+    }\n+}\n+\n /// Take the various parts of `format_args!(efmt, args..., name=names...)`\n /// and construct the appropriate formatting expression.\n pub fn expand_preparsed_format_args(\n     ecx: &mut ExtCtxt<'_>,\n     sp: Span,\n     efmt: P<ast::Expr>,\n     args: Vec<P<ast::Expr>>,\n-    names: FxHashMap<Symbol, usize>,\n+    names: FxHashMap<Symbol, (usize, Span)>,\n     append_newline: bool,\n ) -> P<ast::Expr> {\n     // NOTE: this verbose way of initializing `Vec<Vec<ArgumentType>>` is because\n@@ -1073,7 +1120,12 @@ pub fn expand_preparsed_format_args(\n         .map(|span| fmt_span.from_inner(InnerSpan::new(span.start, span.end)))\n         .collect();\n \n-    let named_pos: FxHashSet<usize> = names.values().cloned().collect();\n+    let named_pos: FxHashSet<usize> = names.values().cloned().map(|(i, _)| i).collect();\n+\n+    // Clone `names` because `names` in Context get updated by verify_piece, which includes usages\n+    // of the names of named arguments, resulting in incorrect errors if a name argument is used\n+    // but not declared, such as: `println!(\"x = {x}\");`\n+    let named_arguments = names.clone();\n \n     let mut cx = Context {\n         ecx,\n@@ -1101,9 +1153,11 @@ pub fn expand_preparsed_format_args(\n         is_literal: parser.is_literal,\n     };\n \n-    // This needs to happen *after* the Parser has consumed all pieces to create all the spans\n+    // This needs to happen *after* the Parser has consumed all pieces to create all the spans.\n+    // unverified_pieces is used later to check named argument names are used, so clone each piece.\n     let pieces = unverified_pieces\n-        .into_iter()\n+        .iter()\n+        .cloned()\n         .map(|mut piece| {\n             cx.verify_piece(&piece);\n             cx.resolve_name_inplace(&mut piece);\n@@ -1265,6 +1319,11 @@ pub fn expand_preparsed_format_args(\n         }\n \n         diag.emit();\n+    } else if cx.invalid_refs.is_empty() && !named_arguments.is_empty() {\n+        // Only check for unused named argument names if there are no other errors to avoid causing\n+        // too much noise in output errors, such as when a named argument is entirely unused.\n+        // We also only need to perform this check if there are actually named arguments.\n+        lint_named_arguments_used_positionally(named_arguments, &mut cx, unverified_pieces);\n     }\n \n     cx.into_expr()"}, {"sha": "e1f19064d522fb0cdae76e32de9871b032b88471", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -12,7 +12,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::{self, Lrc};\n use rustc_errors::{Applicability, DiagnosticBuilder, ErrorGuaranteed, MultiSpan, PResult};\n use rustc_lint_defs::builtin::PROC_MACRO_BACK_COMPAT;\n-use rustc_lint_defs::BuiltinLintDiagnostics;\n+use rustc_lint_defs::{BufferedEarlyLint, BuiltinLintDiagnostics};\n use rustc_parse::{self, parser, MACRO_ARGUMENTS};\n use rustc_session::{parse::ParseSess, Limit, Session, SessionDiagnostic};\n use rustc_span::def_id::{CrateNum, DefId, LocalDefId};\n@@ -988,6 +988,8 @@ pub struct ExtCtxt<'a> {\n     pub expansions: FxHashMap<Span, Vec<String>>,\n     /// Used for running pre-expansion lints on freshly loaded modules.\n     pub(super) lint_store: LintStoreExpandDyn<'a>,\n+    /// Used for storing lints generated during expansion, like `NAMED_ARGUMENTS_USED_POSITIONALLY`\n+    pub buffered_early_lint: Vec<BufferedEarlyLint>,\n     /// When we 'expand' an inert attribute, we leave it\n     /// in the AST, but insert it here so that we know\n     /// not to expand it again.\n@@ -1020,6 +1022,7 @@ impl<'a> ExtCtxt<'a> {\n             force_mode: false,\n             expansions: FxHashMap::default(),\n             expanded_inert_attrs: MarkedAttrs::new(),\n+            buffered_early_lint: vec![],\n         }\n     }\n "}, {"sha": "881682678dbed3c040ae3635923cb240f0f0f2fa", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -21,6 +21,7 @@ use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind, ToType};\n use rustc_middle::mir::interpret::{ErrorHandled, EvalToValTreeResult};\n use rustc_middle::traits::select;\n+use rustc_middle::ty::abstract_const::AbstractConst;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::relate::RelateResult;\n@@ -1651,14 +1652,18 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         unevaluated: ty::Unevaluated<'tcx>,\n         span: Option<Span>,\n     ) -> EvalToValTreeResult<'tcx> {\n-        let substs = self.resolve_vars_if_possible(unevaluated.substs);\n+        let mut substs = self.resolve_vars_if_possible(unevaluated.substs);\n         debug!(?substs);\n \n         // Postpone the evaluation of constants whose substs depend on inference\n         // variables\n         if substs.has_infer_types_or_consts() {\n-            debug!(\"substs have infer types or consts: {:?}\", substs);\n-            return Err(ErrorHandled::TooGeneric);\n+            let ac = AbstractConst::new(self.tcx, unevaluated.shrink());\n+            if let Ok(None) = ac {\n+                substs = InternalSubsts::identity_for_item(self.tcx, unevaluated.def.did);\n+            } else {\n+                return Err(ErrorHandled::TooGeneric);\n+            }\n         }\n \n         let param_env_erased = self.tcx.erase_regions(param_env);"}, {"sha": "0529fff5a6b47d9e5501d35e83fae7a89f926965", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -14,7 +14,7 @@ use rustc_errors::{Applicability, ErrorGuaranteed, MultiSpan, PResult};\n use rustc_expand::base::{ExtCtxt, LintStoreExpand, ResolverExpand};\n use rustc_hir::def_id::{StableCrateId, LOCAL_CRATE};\n use rustc_hir::definitions::Definitions;\n-use rustc_lint::{EarlyCheckNode, LintStore};\n+use rustc_lint::{BufferedEarlyLint, EarlyCheckNode, LintStore};\n use rustc_metadata::creader::CStore;\n use rustc_metadata::{encode_metadata, EncodedMetadata};\n use rustc_middle::arena::Arena;\n@@ -336,12 +336,15 @@ pub fn configure_and_expand(\n \n         let lint_store = LintStoreExpandImpl(lint_store);\n         let mut ecx = ExtCtxt::new(sess, cfg, resolver, Some(&lint_store));\n-\n         // Expand macros now!\n         let krate = sess.time(\"expand_crate\", || ecx.monotonic_expander().expand_crate(krate));\n \n         // The rest is error reporting\n \n+        sess.parse_sess.buffered_lints.with_lock(|buffered_lints: &mut Vec<BufferedEarlyLint>| {\n+            buffered_lints.append(&mut ecx.buffered_early_lint);\n+        });\n+\n         sess.time(\"check_unused_macros\", || {\n             ecx.check_unused_macros();\n         });"}, {"sha": "13e3bb9a36341d5c901c93076027c2010fb41f73", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -857,6 +857,18 @@ pub trait LintContext: Sized {\n                         Applicability::MachineApplicable,\n                     );\n                 },\n+                BuiltinLintDiagnostics::NamedArgumentUsedPositionally(positional_arg, named_arg, name) => {\n+                    db.span_label(named_arg, \"this named argument is only referred to by position in formatting string\");\n+                    let msg = format!(\"this formatting argument uses named argument `{}` by position\", name);\n+                    db.span_label(positional_arg, msg);\n+                    db.span_suggestion_verbose(\n+                        positional_arg,\n+                        \"use the named argument by name to avoid ambiguity\",\n+                        format!(\"{{{}}}\", name),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+\n+                }\n             }\n             // Rewrap `db`, and pass control to the user.\n             decorate(LintDiagnosticBuilder::new(db));"}, {"sha": "39690851d1ea831589a35723a5db416b1ec5da7c", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -3292,6 +3292,7 @@ declare_lint_pass! {\n         TEST_UNSTABLE_LINT,\n         FFI_UNWIND_CALLS,\n         REPR_TRANSPARENT_EXTERNAL_PRIVATE_FIELDS,\n+        NAMED_ARGUMENTS_USED_POSITIONALLY,\n     ]\n }\n \n@@ -3996,3 +3997,33 @@ declare_lint! {\n     \"call to foreign functions or function pointers with FFI-unwind ABI\",\n     @feature_gate = sym::c_unwind;\n }\n+\n+declare_lint! {\n+    /// The `named_arguments_used_positionally` lint detects cases where named arguments are only\n+    /// used positionally in format strings. This usage is valid but potentially very confusing.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(named_arguments_used_positionally)]\n+    /// fn main() {\n+    ///     let _x = 5;\n+    ///     println!(\"{}\", _x = 1); // Prints 1, will trigger lint\n+    ///\n+    ///     println!(\"{}\", _x); // Prints 5, no lint emitted\n+    ///     println!(\"{_x}\", _x = _x); // Prints 5, no lint emitted\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Rust formatting strings can refer to named arguments by their position, but this usage is\n+    /// potentially confusing. In particular, readers can incorrectly assume that the declaration\n+    /// of named arguments is an assignment (which would produce the unit type).\n+    /// For backwards compatibility, this is not a hard error.\n+    pub NAMED_ARGUMENTS_USED_POSITIONALLY,\n+    Warn,\n+    \"named arguments in format used positionally\"\n+}"}, {"sha": "1bc7e7de66040e91a528d77b6df20a5abbc98608", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -467,6 +467,7 @@ pub enum BuiltinLintDiagnostics {\n         /// If true, the lifetime will be fully elided.\n         use_span: Option<(Span, bool)>,\n     },\n+    NamedArgumentUsedPositionally(Span, Span, String),\n }\n \n /// Lints that are buffered up early on in the `Session` before the"}, {"sha": "f0874f8f2da00374f8f7fb773fbfa308329b822d", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -21,7 +21,6 @@ use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::metadata::ModChild;\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportInfo};\n use rustc_middle::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n-use rustc_middle::thir;\n use rustc_middle::ty::codec::TyDecoder;\n use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::GeneratorDiagnosticData;\n@@ -638,7 +637,7 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for Span {\n     }\n }\n \n-impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for &'tcx [thir::abstract_const::Node<'tcx>] {\n+impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for &'tcx [ty::abstract_const::Node<'tcx>] {\n     fn decode(d: &mut DecodeContext<'a, 'tcx>) -> Self {\n         ty::codec::RefDecodable::decode(d)\n     }"}, {"sha": "a5a9dbb8da2e8dc8dca2aa965361728b30ea7a87", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -17,7 +17,6 @@ use rustc_middle::metadata::ModChild;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrs;\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportInfo};\n use rustc_middle::mir;\n-use rustc_middle::thir;\n use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, ReprOptions, Ty};\n@@ -361,7 +360,7 @@ define_tables! {\n     mir_for_ctfe: Table<DefIndex, LazyValue<mir::Body<'static>>>,\n     promoted_mir: Table<DefIndex, LazyValue<IndexVec<mir::Promoted, mir::Body<'static>>>>,\n     // FIXME(compiler-errors): Why isn't this a LazyArray?\n-    thir_abstract_const: Table<DefIndex, LazyValue<&'static [thir::abstract_const::Node<'static>]>>,\n+    thir_abstract_const: Table<DefIndex, LazyValue<&'static [ty::abstract_const::Node<'static>]>>,\n     impl_parent: Table<DefIndex, RawDefId>,\n     impl_polarity: Table<DefIndex, ty::ImplPolarity>,\n     constness: Table<DefIndex, hir::Constness>,"}, {"sha": "bdae7e5fcd6b1b446204c6c5e64cc4387e53235d", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -351,7 +351,7 @@ rustc_queries! {\n     /// Try to build an abstract representation of the given constant.\n     query thir_abstract_const(\n         key: DefId\n-    ) -> Result<Option<&'tcx [thir::abstract_const::Node<'tcx>]>, ErrorGuaranteed> {\n+    ) -> Result<Option<&'tcx [ty::abstract_const::Node<'tcx>]>, ErrorGuaranteed> {\n         desc {\n             |tcx| \"building an abstract representation for {}\", tcx.def_path_str(key),\n         }\n@@ -360,7 +360,7 @@ rustc_queries! {\n     /// Try to build an abstract representation of the given constant.\n     query thir_abstract_const_of_const_arg(\n         key: (LocalDefId, DefId)\n-    ) -> Result<Option<&'tcx [thir::abstract_const::Node<'tcx>]>, ErrorGuaranteed> {\n+    ) -> Result<Option<&'tcx [ty::abstract_const::Node<'tcx>]>, ErrorGuaranteed> {\n         desc {\n             |tcx|\n             \"building an abstract representation for the const argument {}\","}, {"sha": "36db8d04918b02830088db7867b50f39a8cab027", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -30,7 +30,6 @@ use rustc_target::asm::InlineAsmRegOrRegClass;\n use std::fmt;\n use std::ops::Index;\n \n-pub mod abstract_const;\n pub mod visit;\n \n newtype_index! {"}, {"sha": "527dbd1cd090aa71ebdf677c498a3a93133903a9", "filename": "compiler/rustc_middle/src/thir/abstract_const.rs", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/24699bcbadff59693a89a5184afed87f6416cdea/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fabstract_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24699bcbadff59693a89a5184afed87f6416cdea/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fabstract_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fabstract_const.rs?ref=24699bcbadff59693a89a5184afed87f6416cdea", "patch": "@@ -1,61 +0,0 @@\n-//! A subset of a mir body used for const evaluatability checking.\n-use crate::mir;\n-use crate::ty::{self, Ty, TyCtxt};\n-use rustc_errors::ErrorGuaranteed;\n-\n-rustc_index::newtype_index! {\n-    /// An index into an `AbstractConst`.\n-    pub struct NodeId {\n-        derive [HashStable]\n-        DEBUG_FORMAT = \"n{}\",\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n-pub enum CastKind {\n-    /// thir::ExprKind::As\n-    As,\n-    /// thir::ExprKind::Use\n-    Use,\n-}\n-\n-/// A node of an `AbstractConst`.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n-pub enum Node<'tcx> {\n-    Leaf(ty::Const<'tcx>),\n-    Binop(mir::BinOp, NodeId, NodeId),\n-    UnaryOp(mir::UnOp, NodeId),\n-    FunctionCall(NodeId, &'tcx [NodeId]),\n-    Cast(CastKind, NodeId, Ty<'tcx>),\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n-pub enum NotConstEvaluatable {\n-    Error(ErrorGuaranteed),\n-    MentionsInfer,\n-    MentionsParam,\n-}\n-\n-impl From<ErrorGuaranteed> for NotConstEvaluatable {\n-    fn from(e: ErrorGuaranteed) -> NotConstEvaluatable {\n-        NotConstEvaluatable::Error(e)\n-    }\n-}\n-\n-TrivialTypeTraversalAndLiftImpls! {\n-    NotConstEvaluatable,\n-}\n-\n-impl<'tcx> TyCtxt<'tcx> {\n-    #[inline]\n-    pub fn thir_abstract_const_opt_const_arg(\n-        self,\n-        def: ty::WithOptConstParam<rustc_hir::def_id::DefId>,\n-    ) -> Result<Option<&'tcx [Node<'tcx>]>, ErrorGuaranteed> {\n-        if let Some((did, param_did)) = def.as_const_arg() {\n-            self.thir_abstract_const_of_const_arg((did, param_did))\n-        } else {\n-            self.thir_abstract_const(def.did)\n-        }\n-    }\n-}"}, {"sha": "955f2bdfa1d916561b931349defa7319fc19d071", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -10,7 +10,7 @@ mod structural_impls;\n pub mod util;\n \n use crate::infer::canonical::Canonical;\n-use crate::thir::abstract_const::NotConstEvaluatable;\n+use crate::ty::abstract_const::NotConstEvaluatable;\n use crate::ty::subst::SubstsRef;\n use crate::ty::{self, AdtKind, Ty, TyCtxt};\n "}, {"sha": "bed809930da615d61eff49b2ed099036fdfe90db", "filename": "compiler/rustc_middle/src/ty/abstract_const.rs", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -0,0 +1,194 @@\n+//! A subset of a mir body used for const evaluatability checking.\n+use crate::mir;\n+use crate::ty::visit::TypeVisitable;\n+use crate::ty::{self, subst::Subst, DelaySpanBugEmitted, EarlyBinder, SubstsRef, Ty, TyCtxt};\n+use rustc_errors::ErrorGuaranteed;\n+use rustc_hir::def_id::DefId;\n+use std::cmp;\n+use std::ops::ControlFlow;\n+\n+rustc_index::newtype_index! {\n+    /// An index into an `AbstractConst`.\n+    pub struct NodeId {\n+        derive [HashStable]\n+        DEBUG_FORMAT = \"n{}\",\n+    }\n+}\n+\n+/// A tree representing an anonymous constant.\n+///\n+/// This is only able to represent a subset of `MIR`,\n+/// and should not leak any information about desugarings.\n+#[derive(Debug, Clone, Copy)]\n+pub struct AbstractConst<'tcx> {\n+    // FIXME: Consider adding something like `IndexSlice`\n+    // and use this here.\n+    inner: &'tcx [Node<'tcx>],\n+    substs: SubstsRef<'tcx>,\n+}\n+\n+impl<'tcx> AbstractConst<'tcx> {\n+    pub fn new(\n+        tcx: TyCtxt<'tcx>,\n+        uv: ty::Unevaluated<'tcx, ()>,\n+    ) -> Result<Option<AbstractConst<'tcx>>, ErrorGuaranteed> {\n+        let inner = tcx.thir_abstract_const_opt_const_arg(uv.def)?;\n+        debug!(\"AbstractConst::new({:?}) = {:?}\", uv, inner);\n+        Ok(inner.map(|inner| AbstractConst { inner, substs: tcx.erase_regions(uv.substs) }))\n+    }\n+\n+    pub fn from_const(\n+        tcx: TyCtxt<'tcx>,\n+        ct: ty::Const<'tcx>,\n+    ) -> Result<Option<AbstractConst<'tcx>>, ErrorGuaranteed> {\n+        match ct.kind() {\n+            ty::ConstKind::Unevaluated(uv) => AbstractConst::new(tcx, uv.shrink()),\n+            ty::ConstKind::Error(DelaySpanBugEmitted { reported, .. }) => Err(reported),\n+            _ => Ok(None),\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn subtree(self, node: NodeId) -> AbstractConst<'tcx> {\n+        AbstractConst { inner: &self.inner[..=node.index()], substs: self.substs }\n+    }\n+\n+    #[inline]\n+    pub fn root(self, tcx: TyCtxt<'tcx>) -> Node<'tcx> {\n+        let node = self.inner.last().copied().unwrap();\n+        match node {\n+            Node::Leaf(leaf) => Node::Leaf(EarlyBinder(leaf).subst(tcx, self.substs)),\n+            Node::Cast(kind, operand, ty) => {\n+                Node::Cast(kind, operand, EarlyBinder(ty).subst(tcx, self.substs))\n+            }\n+            // Don't perform substitution on the following as they can't directly contain generic params\n+            Node::Binop(_, _, _) | Node::UnaryOp(_, _) | Node::FunctionCall(_, _) => node,\n+        }\n+    }\n+\n+    pub fn unify_failure_kind(self, tcx: TyCtxt<'tcx>) -> FailureKind {\n+        let mut failure_kind = FailureKind::Concrete;\n+        walk_abstract_const::<!, _>(tcx, self, |node| {\n+            match node.root(tcx) {\n+                Node::Leaf(leaf) => {\n+                    if leaf.has_infer_types_or_consts() {\n+                        failure_kind = FailureKind::MentionsInfer;\n+                    } else if leaf.has_param_types_or_consts() {\n+                        failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n+                    }\n+                }\n+                Node::Cast(_, _, ty) => {\n+                    if ty.has_infer_types_or_consts() {\n+                        failure_kind = FailureKind::MentionsInfer;\n+                    } else if ty.has_param_types_or_consts() {\n+                        failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n+                    }\n+                }\n+                Node::Binop(_, _, _) | Node::UnaryOp(_, _) | Node::FunctionCall(_, _) => {}\n+            }\n+            ControlFlow::CONTINUE\n+        });\n+        failure_kind\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n+pub enum CastKind {\n+    /// thir::ExprKind::As\n+    As,\n+    /// thir::ExprKind::Use\n+    Use,\n+}\n+\n+/// A node of an `AbstractConst`.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n+pub enum Node<'tcx> {\n+    Leaf(ty::Const<'tcx>),\n+    Binop(mir::BinOp, NodeId, NodeId),\n+    UnaryOp(mir::UnOp, NodeId),\n+    FunctionCall(NodeId, &'tcx [NodeId]),\n+    Cast(CastKind, NodeId, Ty<'tcx>),\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n+pub enum NotConstEvaluatable {\n+    Error(ErrorGuaranteed),\n+    MentionsInfer,\n+    MentionsParam,\n+}\n+\n+impl From<ErrorGuaranteed> for NotConstEvaluatable {\n+    fn from(e: ErrorGuaranteed) -> NotConstEvaluatable {\n+        NotConstEvaluatable::Error(e)\n+    }\n+}\n+\n+TrivialTypeTraversalAndLiftImpls! {\n+    NotConstEvaluatable,\n+}\n+\n+impl<'tcx> TyCtxt<'tcx> {\n+    #[inline]\n+    pub fn thir_abstract_const_opt_const_arg(\n+        self,\n+        def: ty::WithOptConstParam<DefId>,\n+    ) -> Result<Option<&'tcx [Node<'tcx>]>, ErrorGuaranteed> {\n+        if let Some((did, param_did)) = def.as_const_arg() {\n+            self.thir_abstract_const_of_const_arg((did, param_did))\n+        } else {\n+            self.thir_abstract_const(def.did)\n+        }\n+    }\n+}\n+\n+#[instrument(skip(tcx, f), level = \"debug\")]\n+pub fn walk_abstract_const<'tcx, R, F>(\n+    tcx: TyCtxt<'tcx>,\n+    ct: AbstractConst<'tcx>,\n+    mut f: F,\n+) -> ControlFlow<R>\n+where\n+    F: FnMut(AbstractConst<'tcx>) -> ControlFlow<R>,\n+{\n+    #[instrument(skip(tcx, f), level = \"debug\")]\n+    fn recurse<'tcx, R>(\n+        tcx: TyCtxt<'tcx>,\n+        ct: AbstractConst<'tcx>,\n+        f: &mut dyn FnMut(AbstractConst<'tcx>) -> ControlFlow<R>,\n+    ) -> ControlFlow<R> {\n+        f(ct)?;\n+        let root = ct.root(tcx);\n+        debug!(?root);\n+        match root {\n+            Node::Leaf(_) => ControlFlow::CONTINUE,\n+            Node::Binop(_, l, r) => {\n+                recurse(tcx, ct.subtree(l), f)?;\n+                recurse(tcx, ct.subtree(r), f)\n+            }\n+            Node::UnaryOp(_, v) => recurse(tcx, ct.subtree(v), f),\n+            Node::FunctionCall(func, args) => {\n+                recurse(tcx, ct.subtree(func), f)?;\n+                args.iter().try_for_each(|&arg| recurse(tcx, ct.subtree(arg), f))\n+            }\n+            Node::Cast(_, operand, _) => recurse(tcx, ct.subtree(operand), f),\n+        }\n+    }\n+\n+    recurse(tcx, ct, &mut f)\n+}\n+\n+// We were unable to unify the abstract constant with\n+// a constant found in the caller bounds, there are\n+// now three possible cases here.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n+pub enum FailureKind {\n+    /// The abstract const still references an inference\n+    /// variable, in this case we return `TooGeneric`.\n+    MentionsInfer,\n+    /// The abstract const references a generic parameter,\n+    /// this means that we emit an error here.\n+    MentionsParam,\n+    /// The substs are concrete enough that we can simply\n+    /// try and evaluate the given constant.\n+    Concrete,\n+}"}, {"sha": "e6ea3d88853763217b44ea5b0643ba435b64d4e1", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -12,7 +12,6 @@ use crate::mir::{\n     self,\n     interpret::{AllocId, ConstAllocation},\n };\n-use crate::thir;\n use crate::traits;\n use crate::ty::subst::SubstsRef;\n use crate::ty::{self, AdtDef, Ty};\n@@ -346,7 +345,7 @@ impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n }\n \n impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n-    for [thir::abstract_const::Node<'tcx>]\n+    for [ty::abstract_const::Node<'tcx>]\n {\n     fn decode(decoder: &mut D) -> &'tcx Self {\n         decoder.interner().arena.alloc_from_iter(\n@@ -356,7 +355,7 @@ impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n }\n \n impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n-    for [thir::abstract_const::NodeId]\n+    for [ty::abstract_const::NodeId]\n {\n     fn decode(decoder: &mut D) -> &'tcx Self {\n         decoder.interner().arena.alloc_from_iter("}, {"sha": "f0acb02933a68c895f5f3cad211af3a7db6e6d89", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -92,6 +92,7 @@ pub use self::sty::{\n pub use self::trait_def::TraitDef;\n \n pub mod _match;\n+pub mod abstract_const;\n pub mod adjustment;\n pub mod binding;\n pub mod cast;"}, {"sha": "e189ee2fc4db12023454c91fe5aa1669da6b487a", "filename": "compiler/rustc_middle/src/ty/parameterized.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -3,7 +3,7 @@ use rustc_index::vec::{Idx, IndexVec};\n \n use crate::middle::exported_symbols::ExportedSymbol;\n use crate::mir::Body;\n-use crate::thir::abstract_const::Node;\n+use crate::ty::abstract_const::Node;\n use crate::ty::{\n     self, Const, FnSig, GeneratorDiagnosticData, GenericPredicates, Predicate, TraitRef, Ty,\n };"}, {"sha": "4e73c26d35f2f250e36e1abc622e625b2b8b6f48", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -23,7 +23,7 @@ use rustc_middle::bug;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::privacy::{AccessLevel, AccessLevels};\n use rustc_middle::span_bug;\n-use rustc_middle::thir::abstract_const::Node as ACNode;\n+use rustc_middle::ty::abstract_const::{walk_abstract_const, AbstractConst, Node as ACNode};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::{self, Const, DefIdTree, GenericParamDefKind};\n@@ -32,7 +32,6 @@ use rustc_session::lint;\n use rustc_span::hygiene::Transparency;\n use rustc_span::symbol::{kw, Ident};\n use rustc_span::Span;\n-use rustc_trait_selection::traits::const_evaluatable::{self, AbstractConst};\n \n use std::marker::PhantomData;\n use std::ops::ControlFlow;\n@@ -164,7 +163,7 @@ where\n         tcx: TyCtxt<'tcx>,\n         ct: AbstractConst<'tcx>,\n     ) -> ControlFlow<V::BreakTy> {\n-        const_evaluatable::walk_abstract_const(tcx, ct, |node| match node.root(tcx) {\n+        walk_abstract_const(tcx, ct, |node| match node.root(tcx) {\n             ACNode::Leaf(leaf) => self.visit_const(leaf),\n             ACNode::Cast(_, _, ty) => self.visit_ty(ty),\n             ACNode::Binop(..) | ACNode::UnaryOp(..) | ACNode::FunctionCall(_, _) => {"}, {"sha": "56fd90c9855e0a821d44321d9ebdead35f68e0d8", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -9,7 +9,6 @@ use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::dep_graph::{DepNodeIndex, SerializedDepNodeIndex};\n use rustc_middle::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n use rustc_middle::mir::{self, interpret};\n-use rustc_middle::thir;\n use rustc_middle::ty::codec::{RefDecodable, TyDecoder, TyEncoder};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_query_system::dep_graph::DepContext;\n@@ -766,7 +765,7 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>>\n     }\n }\n \n-impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [thir::abstract_const::Node<'tcx>] {\n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [ty::abstract_const::Node<'tcx>] {\n     fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Self {\n         RefDecodable::decode(d)\n     }"}, {"sha": "e6284b1c4ace04a34776f9266752077c5a9f1067", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 141, "deletions": 641, "changes": 782, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -10,22 +10,153 @@\n //! generic constants mentioned in the `caller_bounds` of the current environment.\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::DefKind;\n-use rustc_index::vec::IndexVec;\n use rustc_infer::infer::InferCtxt;\n-use rustc_middle::mir;\n-use rustc_middle::mir::interpret::{ErrorHandled, LitToConstError, LitToConstInput};\n-use rustc_middle::thir;\n-use rustc_middle::thir::abstract_const::{self, Node, NodeId, NotConstEvaluatable};\n-use rustc_middle::ty::subst::{Subst, SubstsRef};\n-use rustc_middle::ty::{self, DelaySpanBugEmitted, EarlyBinder, TyCtxt, TypeVisitable};\n+use rustc_middle::mir::interpret::ErrorHandled;\n+use rustc_middle::ty::abstract_const::{\n+    walk_abstract_const, AbstractConst, FailureKind, Node, NotConstEvaluatable,\n+};\n+use rustc_middle::ty::{self, TyCtxt, TypeVisitable};\n use rustc_session::lint;\n-use rustc_span::def_id::LocalDefId;\n use rustc_span::Span;\n \n-use std::cmp;\n use std::iter;\n use std::ops::ControlFlow;\n \n+pub struct ConstUnifyCtxt<'tcx> {\n+    pub tcx: TyCtxt<'tcx>,\n+    pub param_env: ty::ParamEnv<'tcx>,\n+}\n+\n+impl<'tcx> ConstUnifyCtxt<'tcx> {\n+    // Substitutes generics repeatedly to allow AbstractConsts to unify where a\n+    // ConstKind::Unevaluated could be turned into an AbstractConst that would unify e.g.\n+    // Param(N) should unify with Param(T), substs: [Unevaluated(\"T2\", [Unevaluated(\"T3\", [Param(N)])])]\n+    #[inline]\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn try_replace_substs_in_root(\n+        &self,\n+        mut abstr_const: AbstractConst<'tcx>,\n+    ) -> Option<AbstractConst<'tcx>> {\n+        while let Node::Leaf(ct) = abstr_const.root(self.tcx) {\n+            match AbstractConst::from_const(self.tcx, ct) {\n+                Ok(Some(act)) => abstr_const = act,\n+                Ok(None) => break,\n+                Err(_) => return None,\n+            }\n+        }\n+\n+        Some(abstr_const)\n+    }\n+\n+    /// Tries to unify two abstract constants using structural equality.\n+    #[instrument(skip(self), level = \"debug\")]\n+    pub fn try_unify(&self, a: AbstractConst<'tcx>, b: AbstractConst<'tcx>) -> bool {\n+        let a = if let Some(a) = self.try_replace_substs_in_root(a) {\n+            a\n+        } else {\n+            return true;\n+        };\n+\n+        let b = if let Some(b) = self.try_replace_substs_in_root(b) {\n+            b\n+        } else {\n+            return true;\n+        };\n+\n+        let a_root = a.root(self.tcx);\n+        let b_root = b.root(self.tcx);\n+        debug!(?a_root, ?b_root);\n+\n+        match (a_root, b_root) {\n+            (Node::Leaf(a_ct), Node::Leaf(b_ct)) => {\n+                let a_ct = a_ct.eval(self.tcx, self.param_env);\n+                debug!(\"a_ct evaluated: {:?}\", a_ct);\n+                let b_ct = b_ct.eval(self.tcx, self.param_env);\n+                debug!(\"b_ct evaluated: {:?}\", b_ct);\n+\n+                if a_ct.ty() != b_ct.ty() {\n+                    return false;\n+                }\n+\n+                match (a_ct.kind(), b_ct.kind()) {\n+                    // We can just unify errors with everything to reduce the amount of\n+                    // emitted errors here.\n+                    (ty::ConstKind::Error(_), _) | (_, ty::ConstKind::Error(_)) => true,\n+                    (ty::ConstKind::Param(a_param), ty::ConstKind::Param(b_param)) => {\n+                        a_param == b_param\n+                    }\n+                    (ty::ConstKind::Value(a_val), ty::ConstKind::Value(b_val)) => a_val == b_val,\n+                    // If we have `fn a<const N: usize>() -> [u8; N + 1]` and `fn b<const M: usize>() -> [u8; 1 + M]`\n+                    // we do not want to use `assert_eq!(a(), b())` to infer that `N` and `M` have to be `1`. This\n+                    // means that we only allow inference variables if they are equal.\n+                    (ty::ConstKind::Infer(a_val), ty::ConstKind::Infer(b_val)) => a_val == b_val,\n+                    // We expand generic anonymous constants at the start of this function, so this\n+                    // branch should only be taking when dealing with associated constants, at\n+                    // which point directly comparing them seems like the desired behavior.\n+                    //\n+                    // FIXME(generic_const_exprs): This isn't actually the case.\n+                    // We also take this branch for concrete anonymous constants and\n+                    // expand generic anonymous constants with concrete substs.\n+                    (ty::ConstKind::Unevaluated(a_uv), ty::ConstKind::Unevaluated(b_uv)) => {\n+                        a_uv == b_uv\n+                    }\n+                    // FIXME(generic_const_exprs): We may want to either actually try\n+                    // to evaluate `a_ct` and `b_ct` if they are are fully concrete or something like\n+                    // this, for now we just return false here.\n+                    _ => false,\n+                }\n+            }\n+            (Node::Binop(a_op, al, ar), Node::Binop(b_op, bl, br)) if a_op == b_op => {\n+                self.try_unify(a.subtree(al), b.subtree(bl))\n+                    && self.try_unify(a.subtree(ar), b.subtree(br))\n+            }\n+            (Node::UnaryOp(a_op, av), Node::UnaryOp(b_op, bv)) if a_op == b_op => {\n+                self.try_unify(a.subtree(av), b.subtree(bv))\n+            }\n+            (Node::FunctionCall(a_f, a_args), Node::FunctionCall(b_f, b_args))\n+                if a_args.len() == b_args.len() =>\n+            {\n+                self.try_unify(a.subtree(a_f), b.subtree(b_f))\n+                    && iter::zip(a_args, b_args)\n+                        .all(|(&an, &bn)| self.try_unify(a.subtree(an), b.subtree(bn)))\n+            }\n+            (Node::Cast(a_kind, a_operand, a_ty), Node::Cast(b_kind, b_operand, b_ty))\n+                if (a_ty == b_ty) && (a_kind == b_kind) =>\n+            {\n+                self.try_unify(a.subtree(a_operand), b.subtree(b_operand))\n+            }\n+            // use this over `_ => false` to make adding variants to `Node` less error prone\n+            (Node::Cast(..), _)\n+            | (Node::FunctionCall(..), _)\n+            | (Node::UnaryOp(..), _)\n+            | (Node::Binop(..), _)\n+            | (Node::Leaf(..), _) => false,\n+        }\n+    }\n+}\n+\n+#[instrument(skip(tcx), level = \"debug\")]\n+pub fn try_unify_abstract_consts<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    (a, b): (ty::Unevaluated<'tcx, ()>, ty::Unevaluated<'tcx, ()>),\n+    param_env: ty::ParamEnv<'tcx>,\n+) -> bool {\n+    (|| {\n+        if let Some(a) = AbstractConst::new(tcx, a)? {\n+            if let Some(b) = AbstractConst::new(tcx, b)? {\n+                let const_unify_ctxt = ConstUnifyCtxt { tcx, param_env };\n+                return Ok(const_unify_ctxt.try_unify(a, b));\n+            }\n+        }\n+\n+        Ok(false)\n+    })()\n+    .unwrap_or_else(|_: ErrorGuaranteed| true)\n+    // FIXME(generic_const_exprs): We should instead have this\n+    // method return the resulting `ty::Const` and return `ConstKind::Error`\n+    // on `ErrorGuaranteed`.\n+}\n+\n /// Check if a given constant can be evaluated.\n #[instrument(skip(infcx), level = \"debug\")]\n pub fn is_const_evaluatable<'cx, 'tcx>(\n@@ -41,48 +172,7 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n             if satisfied_from_param_env(tcx, ct, param_env)? {\n                 return Ok(());\n             }\n-\n-            // We were unable to unify the abstract constant with\n-            // a constant found in the caller bounds, there are\n-            // now three possible cases here.\n-            #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n-            enum FailureKind {\n-                /// The abstract const still references an inference\n-                /// variable, in this case we return `TooGeneric`.\n-                MentionsInfer,\n-                /// The abstract const references a generic parameter,\n-                /// this means that we emit an error here.\n-                MentionsParam,\n-                /// The substs are concrete enough that we can simply\n-                /// try and evaluate the given constant.\n-                Concrete,\n-            }\n-            let mut failure_kind = FailureKind::Concrete;\n-            walk_abstract_const::<!, _>(tcx, ct, |node| match node.root(tcx) {\n-                Node::Leaf(leaf) => {\n-                    if leaf.has_infer_types_or_consts() {\n-                        failure_kind = FailureKind::MentionsInfer;\n-                    } else if leaf.has_param_types_or_consts() {\n-                        failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n-                    }\n-\n-                    ControlFlow::CONTINUE\n-                }\n-                Node::Cast(_, _, ty) => {\n-                    if ty.has_infer_types_or_consts() {\n-                        failure_kind = FailureKind::MentionsInfer;\n-                    } else if ty.has_param_types_or_consts() {\n-                        failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n-                    }\n-\n-                    ControlFlow::CONTINUE\n-                }\n-                Node::Binop(_, _, _) | Node::UnaryOp(_, _) | Node::FunctionCall(_, _) => {\n-                    ControlFlow::CONTINUE\n-                }\n-            });\n-\n-            match failure_kind {\n+            match ct.unify_failure_kind(tcx) {\n                 FailureKind::MentionsInfer => {\n                     return Err(NotConstEvaluatable::MentionsInfer);\n                 }\n@@ -216,593 +306,3 @@ fn satisfied_from_param_env<'tcx>(\n \n     Ok(false)\n }\n-\n-/// A tree representing an anonymous constant.\n-///\n-/// This is only able to represent a subset of `MIR`,\n-/// and should not leak any information about desugarings.\n-#[derive(Debug, Clone, Copy)]\n-pub struct AbstractConst<'tcx> {\n-    // FIXME: Consider adding something like `IndexSlice`\n-    // and use this here.\n-    inner: &'tcx [Node<'tcx>],\n-    substs: SubstsRef<'tcx>,\n-}\n-\n-impl<'tcx> AbstractConst<'tcx> {\n-    pub fn new(\n-        tcx: TyCtxt<'tcx>,\n-        uv: ty::Unevaluated<'tcx, ()>,\n-    ) -> Result<Option<AbstractConst<'tcx>>, ErrorGuaranteed> {\n-        let inner = tcx.thir_abstract_const_opt_const_arg(uv.def)?;\n-        debug!(\"AbstractConst::new({:?}) = {:?}\", uv, inner);\n-        Ok(inner.map(|inner| AbstractConst { inner, substs: tcx.erase_regions(uv.substs) }))\n-    }\n-\n-    pub fn from_const(\n-        tcx: TyCtxt<'tcx>,\n-        ct: ty::Const<'tcx>,\n-    ) -> Result<Option<AbstractConst<'tcx>>, ErrorGuaranteed> {\n-        match ct.kind() {\n-            ty::ConstKind::Unevaluated(uv) => AbstractConst::new(tcx, uv.shrink()),\n-            ty::ConstKind::Error(DelaySpanBugEmitted { reported, .. }) => Err(reported),\n-            _ => Ok(None),\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn subtree(self, node: NodeId) -> AbstractConst<'tcx> {\n-        AbstractConst { inner: &self.inner[..=node.index()], substs: self.substs }\n-    }\n-\n-    #[inline]\n-    pub fn root(self, tcx: TyCtxt<'tcx>) -> Node<'tcx> {\n-        let node = self.inner.last().copied().unwrap();\n-        match node {\n-            Node::Leaf(leaf) => Node::Leaf(EarlyBinder(leaf).subst(tcx, self.substs)),\n-            Node::Cast(kind, operand, ty) => {\n-                Node::Cast(kind, operand, EarlyBinder(ty).subst(tcx, self.substs))\n-            }\n-            // Don't perform substitution on the following as they can't directly contain generic params\n-            Node::Binop(_, _, _) | Node::UnaryOp(_, _) | Node::FunctionCall(_, _) => node,\n-        }\n-    }\n-}\n-\n-struct AbstractConstBuilder<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    body_id: thir::ExprId,\n-    body: &'a thir::Thir<'tcx>,\n-    /// The current WIP node tree.\n-    nodes: IndexVec<NodeId, Node<'tcx>>,\n-}\n-\n-impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n-    fn root_span(&self) -> Span {\n-        self.body.exprs[self.body_id].span\n-    }\n-\n-    fn error(&mut self, span: Span, msg: &str) -> Result<!, ErrorGuaranteed> {\n-        let reported = self\n-            .tcx\n-            .sess\n-            .struct_span_err(self.root_span(), \"overly complex generic constant\")\n-            .span_label(span, msg)\n-            .help(\"consider moving this anonymous constant into a `const` function\")\n-            .emit();\n-\n-        Err(reported)\n-    }\n-    fn maybe_supported_error(&mut self, span: Span, msg: &str) -> Result<!, ErrorGuaranteed> {\n-        let reported = self\n-            .tcx\n-            .sess\n-            .struct_span_err(self.root_span(), \"overly complex generic constant\")\n-            .span_label(span, msg)\n-            .help(\"consider moving this anonymous constant into a `const` function\")\n-            .note(\"this operation may be supported in the future\")\n-            .emit();\n-\n-        Err(reported)\n-    }\n-\n-    #[instrument(skip(tcx, body, body_id), level = \"debug\")]\n-    fn new(\n-        tcx: TyCtxt<'tcx>,\n-        (body, body_id): (&'a thir::Thir<'tcx>, thir::ExprId),\n-    ) -> Result<Option<AbstractConstBuilder<'a, 'tcx>>, ErrorGuaranteed> {\n-        let builder = AbstractConstBuilder { tcx, body_id, body, nodes: IndexVec::new() };\n-\n-        struct IsThirPolymorphic<'a, 'tcx> {\n-            is_poly: bool,\n-            thir: &'a thir::Thir<'tcx>,\n-        }\n-\n-        use crate::rustc_middle::thir::visit::Visitor;\n-        use thir::visit;\n-\n-        impl<'a, 'tcx> IsThirPolymorphic<'a, 'tcx> {\n-            fn expr_is_poly(&mut self, expr: &thir::Expr<'tcx>) -> bool {\n-                if expr.ty.has_param_types_or_consts() {\n-                    return true;\n-                }\n-\n-                match expr.kind {\n-                    thir::ExprKind::NamedConst { substs, .. } => substs.has_param_types_or_consts(),\n-                    thir::ExprKind::ConstParam { .. } => true,\n-                    thir::ExprKind::Repeat { value, count } => {\n-                        self.visit_expr(&self.thir()[value]);\n-                        count.has_param_types_or_consts()\n-                    }\n-                    _ => false,\n-                }\n-            }\n-\n-            fn pat_is_poly(&mut self, pat: &thir::Pat<'tcx>) -> bool {\n-                if pat.ty.has_param_types_or_consts() {\n-                    return true;\n-                }\n-\n-                match pat.kind.as_ref() {\n-                    thir::PatKind::Constant { value } => value.has_param_types_or_consts(),\n-                    thir::PatKind::Range(thir::PatRange { lo, hi, .. }) => {\n-                        lo.has_param_types_or_consts() || hi.has_param_types_or_consts()\n-                    }\n-                    _ => false,\n-                }\n-            }\n-        }\n-\n-        impl<'a, 'tcx> visit::Visitor<'a, 'tcx> for IsThirPolymorphic<'a, 'tcx> {\n-            fn thir(&self) -> &'a thir::Thir<'tcx> {\n-                &self.thir\n-            }\n-\n-            #[instrument(skip(self), level = \"debug\")]\n-            fn visit_expr(&mut self, expr: &thir::Expr<'tcx>) {\n-                self.is_poly |= self.expr_is_poly(expr);\n-                if !self.is_poly {\n-                    visit::walk_expr(self, expr)\n-                }\n-            }\n-\n-            #[instrument(skip(self), level = \"debug\")]\n-            fn visit_pat(&mut self, pat: &thir::Pat<'tcx>) {\n-                self.is_poly |= self.pat_is_poly(pat);\n-                if !self.is_poly {\n-                    visit::walk_pat(self, pat);\n-                }\n-            }\n-        }\n-\n-        let mut is_poly_vis = IsThirPolymorphic { is_poly: false, thir: body };\n-        visit::walk_expr(&mut is_poly_vis, &body[body_id]);\n-        debug!(\"AbstractConstBuilder: is_poly={}\", is_poly_vis.is_poly);\n-        if !is_poly_vis.is_poly {\n-            return Ok(None);\n-        }\n-\n-        Ok(Some(builder))\n-    }\n-\n-    /// We do not allow all binary operations in abstract consts, so filter disallowed ones.\n-    fn check_binop(op: mir::BinOp) -> bool {\n-        use mir::BinOp::*;\n-        match op {\n-            Add | Sub | Mul | Div | Rem | BitXor | BitAnd | BitOr | Shl | Shr | Eq | Lt | Le\n-            | Ne | Ge | Gt => true,\n-            Offset => false,\n-        }\n-    }\n-\n-    /// While we currently allow all unary operations, we still want to explicitly guard against\n-    /// future changes here.\n-    fn check_unop(op: mir::UnOp) -> bool {\n-        use mir::UnOp::*;\n-        match op {\n-            Not | Neg => true,\n-        }\n-    }\n-\n-    /// Builds the abstract const by walking the thir and bailing out when\n-    /// encountering an unsupported operation.\n-    fn build(mut self) -> Result<&'tcx [Node<'tcx>], ErrorGuaranteed> {\n-        debug!(\"Abstractconstbuilder::build: body={:?}\", &*self.body);\n-        self.recurse_build(self.body_id)?;\n-\n-        for n in self.nodes.iter() {\n-            if let Node::Leaf(ct) = n {\n-                if let ty::ConstKind::Unevaluated(ct) = ct.kind() {\n-                    // `AbstractConst`s should not contain any promoteds as they require references which\n-                    // are not allowed.\n-                    assert_eq!(ct.promoted, None);\n-                    assert_eq!(ct, self.tcx.erase_regions(ct));\n-                }\n-            }\n-        }\n-\n-        Ok(self.tcx.arena.alloc_from_iter(self.nodes.into_iter()))\n-    }\n-\n-    fn recurse_build(&mut self, node: thir::ExprId) -> Result<NodeId, ErrorGuaranteed> {\n-        use thir::ExprKind;\n-        let node = &self.body.exprs[node];\n-        Ok(match &node.kind {\n-            // I dont know if handling of these 3 is correct\n-            &ExprKind::Scope { value, .. } => self.recurse_build(value)?,\n-            &ExprKind::PlaceTypeAscription { source, .. }\n-            | &ExprKind::ValueTypeAscription { source, .. } => self.recurse_build(source)?,\n-            &ExprKind::Literal { lit, neg} => {\n-                let sp = node.span;\n-                let constant =\n-                    match self.tcx.at(sp).lit_to_const(LitToConstInput { lit: &lit.node, ty: node.ty, neg }) {\n-                        Ok(c) => c,\n-                        Err(LitToConstError::Reported) => {\n-                            self.tcx.const_error(node.ty)\n-                        }\n-                        Err(LitToConstError::TypeError) => {\n-                            bug!(\"encountered type error in lit_to_const\")\n-                        }\n-                    };\n-\n-                self.nodes.push(Node::Leaf(constant))\n-            }\n-            &ExprKind::NonHirLiteral { lit , user_ty: _} => {\n-                let val = ty::ValTree::from_scalar_int(lit);\n-                self.nodes.push(Node::Leaf(ty::Const::from_value(self.tcx, val, node.ty)))\n-            }\n-            &ExprKind::ZstLiteral { user_ty: _ } => {\n-                let val = ty::ValTree::zst();\n-                self.nodes.push(Node::Leaf(ty::Const::from_value(self.tcx, val, node.ty)))\n-            }\n-            &ExprKind::NamedConst { def_id, substs, user_ty: _ } => {\n-                let uneval = ty::Unevaluated::new(ty::WithOptConstParam::unknown(def_id), substs);\n-\n-                let constant = self.tcx.mk_const(ty::ConstS {\n-                                kind: ty::ConstKind::Unevaluated(uneval),\n-                                ty: node.ty,\n-                            });\n-\n-                self.nodes.push(Node::Leaf(constant))\n-            }\n-\n-            ExprKind::ConstParam {param, ..} => {\n-                let const_param = self.tcx.mk_const(ty::ConstS {\n-                        kind: ty::ConstKind::Param(*param),\n-                        ty: node.ty,\n-                    });\n-                self.nodes.push(Node::Leaf(const_param))\n-            }\n-\n-            ExprKind::Call { fun, args, .. } => {\n-                let fun = self.recurse_build(*fun)?;\n-\n-                let mut new_args = Vec::<NodeId>::with_capacity(args.len());\n-                for &id in args.iter() {\n-                    new_args.push(self.recurse_build(id)?);\n-                }\n-                let new_args = self.tcx.arena.alloc_slice(&new_args);\n-                self.nodes.push(Node::FunctionCall(fun, new_args))\n-            }\n-            &ExprKind::Binary { op, lhs, rhs } if Self::check_binop(op) => {\n-                let lhs = self.recurse_build(lhs)?;\n-                let rhs = self.recurse_build(rhs)?;\n-                self.nodes.push(Node::Binop(op, lhs, rhs))\n-            }\n-            &ExprKind::Unary { op, arg } if Self::check_unop(op) => {\n-                let arg = self.recurse_build(arg)?;\n-                self.nodes.push(Node::UnaryOp(op, arg))\n-            }\n-            // This is necessary so that the following compiles:\n-            //\n-            // ```\n-            // fn foo<const N: usize>(a: [(); N + 1]) {\n-            //     bar::<{ N + 1 }>();\n-            // }\n-            // ```\n-            ExprKind::Block { body: thir::Block { stmts: box [], expr: Some(e), .. } } => {\n-                self.recurse_build(*e)?\n-            }\n-            // `ExprKind::Use` happens when a `hir::ExprKind::Cast` is a\n-            // \"coercion cast\" i.e. using a coercion or is a no-op.\n-            // This is important so that `N as usize as usize` doesnt unify with `N as usize`. (untested)\n-            &ExprKind::Use { source } => {\n-                let arg = self.recurse_build(source)?;\n-                self.nodes.push(Node::Cast(abstract_const::CastKind::Use, arg, node.ty))\n-            }\n-            &ExprKind::Cast { source } => {\n-                let arg = self.recurse_build(source)?;\n-                self.nodes.push(Node::Cast(abstract_const::CastKind::As, arg, node.ty))\n-            }\n-            ExprKind::Borrow{ arg, ..} => {\n-                let arg_node = &self.body.exprs[*arg];\n-\n-                // Skip reborrows for now until we allow Deref/Borrow/AddressOf\n-                // expressions.\n-                // FIXME(generic_const_exprs): Verify/explain why this is sound\n-                if let ExprKind::Deref {arg} = arg_node.kind {\n-                    self.recurse_build(arg)?\n-                } else {\n-                    self.maybe_supported_error(\n-                        node.span,\n-                        \"borrowing is not supported in generic constants\",\n-                    )?\n-                }\n-            }\n-            // FIXME(generic_const_exprs): We may want to support these.\n-            ExprKind::AddressOf { .. } | ExprKind::Deref {..}=> self.maybe_supported_error(\n-                node.span,\n-                \"dereferencing or taking the address is not supported in generic constants\",\n-            )?,\n-            ExprKind::Repeat { .. } | ExprKind::Array { .. } =>  self.maybe_supported_error(\n-                node.span,\n-                \"array construction is not supported in generic constants\",\n-            )?,\n-            ExprKind::Block { .. } => self.maybe_supported_error(\n-                node.span,\n-                \"blocks are not supported in generic constant\",\n-            )?,\n-            ExprKind::NeverToAny { .. } => self.maybe_supported_error(\n-                node.span,\n-                \"converting nevers to any is not supported in generic constant\",\n-            )?,\n-            ExprKind::Tuple { .. } => self.maybe_supported_error(\n-                node.span,\n-                \"tuple construction is not supported in generic constants\",\n-            )?,\n-            ExprKind::Index { .. } => self.maybe_supported_error(\n-                node.span,\n-                \"indexing is not supported in generic constant\",\n-            )?,\n-            ExprKind::Field { .. } => self.maybe_supported_error(\n-                node.span,\n-                \"field access is not supported in generic constant\",\n-            )?,\n-            ExprKind::ConstBlock { .. } => self.maybe_supported_error(\n-                node.span,\n-                \"const blocks are not supported in generic constant\",\n-            )?,\n-            ExprKind::Adt(_) => self.maybe_supported_error(\n-                node.span,\n-                \"struct/enum construction is not supported in generic constants\",\n-            )?,\n-            // dont know if this is correct\n-            ExprKind::Pointer { .. } =>\n-                self.error(node.span, \"pointer casts are not allowed in generic constants\")?,\n-            ExprKind::Yield { .. } =>\n-                self.error(node.span, \"generator control flow is not allowed in generic constants\")?,\n-            ExprKind::Continue { .. } | ExprKind::Break { .. } | ExprKind::Loop { .. } => self\n-                .error(\n-                    node.span,\n-                    \"loops and loop control flow are not supported in generic constants\",\n-                )?,\n-            ExprKind::Box { .. } =>\n-                self.error(node.span, \"allocations are not allowed in generic constants\")?,\n-\n-            ExprKind::Unary { .. } => unreachable!(),\n-            // we handle valid unary/binary ops above\n-            ExprKind::Binary { .. } =>\n-                self.error(node.span, \"unsupported binary operation in generic constants\")?,\n-            ExprKind::LogicalOp { .. } =>\n-                self.error(node.span, \"unsupported operation in generic constants, short-circuiting operations would imply control flow\")?,\n-            ExprKind::Assign { .. } | ExprKind::AssignOp { .. } => {\n-                self.error(node.span, \"assignment is not supported in generic constants\")?\n-            }\n-            ExprKind::Closure { .. } | ExprKind::Return { .. } => self.error(\n-                node.span,\n-                \"closures and function keywords are not supported in generic constants\",\n-            )?,\n-            // let expressions imply control flow\n-            ExprKind::Match { .. } | ExprKind::If { .. } | ExprKind::Let { .. } =>\n-                self.error(node.span, \"control flow is not supported in generic constants\")?,\n-            ExprKind::InlineAsm { .. } => {\n-                self.error(node.span, \"assembly is not supported in generic constants\")?\n-            }\n-\n-            // we dont permit let stmts so `VarRef` and `UpvarRef` cant happen\n-            ExprKind::VarRef { .. }\n-            | ExprKind::UpvarRef { .. }\n-            | ExprKind::StaticRef { .. }\n-            | ExprKind::ThreadLocalRef(_) => {\n-                self.error(node.span, \"unsupported operation in generic constant\")?\n-            }\n-        })\n-    }\n-}\n-\n-/// Builds an abstract const, do not use this directly, but use `AbstractConst::new` instead.\n-pub(super) fn thir_abstract_const<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def: ty::WithOptConstParam<LocalDefId>,\n-) -> Result<Option<&'tcx [thir::abstract_const::Node<'tcx>]>, ErrorGuaranteed> {\n-    if tcx.features().generic_const_exprs {\n-        match tcx.def_kind(def.did) {\n-            // FIXME(generic_const_exprs): We currently only do this for anonymous constants,\n-            // meaning that we do not look into associated constants. I(@lcnr) am not yet sure whether\n-            // we want to look into them or treat them as opaque projections.\n-            //\n-            // Right now we do neither of that and simply always fail to unify them.\n-            DefKind::AnonConst | DefKind::InlineConst => (),\n-            _ => return Ok(None),\n-        }\n-\n-        let body = tcx.thir_body(def)?;\n-\n-        AbstractConstBuilder::new(tcx, (&*body.0.borrow(), body.1))?\n-            .map(AbstractConstBuilder::build)\n-            .transpose()\n-    } else {\n-        Ok(None)\n-    }\n-}\n-\n-#[instrument(skip(tcx), level = \"debug\")]\n-pub(super) fn try_unify_abstract_consts<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    (a, b): (ty::Unevaluated<'tcx, ()>, ty::Unevaluated<'tcx, ()>),\n-    param_env: ty::ParamEnv<'tcx>,\n-) -> bool {\n-    (|| {\n-        if let Some(a) = AbstractConst::new(tcx, a)? {\n-            if let Some(b) = AbstractConst::new(tcx, b)? {\n-                let const_unify_ctxt = ConstUnifyCtxt { tcx, param_env };\n-                return Ok(const_unify_ctxt.try_unify(a, b));\n-            }\n-        }\n-\n-        Ok(false)\n-    })()\n-    .unwrap_or_else(|_: ErrorGuaranteed| true)\n-    // FIXME(generic_const_exprs): We should instead have this\n-    // method return the resulting `ty::Const` and return `ConstKind::Error`\n-    // on `ErrorGuaranteed`.\n-}\n-\n-#[instrument(skip(tcx, f), level = \"debug\")]\n-pub fn walk_abstract_const<'tcx, R, F>(\n-    tcx: TyCtxt<'tcx>,\n-    ct: AbstractConst<'tcx>,\n-    mut f: F,\n-) -> ControlFlow<R>\n-where\n-    F: FnMut(AbstractConst<'tcx>) -> ControlFlow<R>,\n-{\n-    #[instrument(skip(tcx, f), level = \"debug\")]\n-    fn recurse<'tcx, R>(\n-        tcx: TyCtxt<'tcx>,\n-        ct: AbstractConst<'tcx>,\n-        f: &mut dyn FnMut(AbstractConst<'tcx>) -> ControlFlow<R>,\n-    ) -> ControlFlow<R> {\n-        f(ct)?;\n-        let root = ct.root(tcx);\n-        debug!(?root);\n-        match root {\n-            Node::Leaf(_) => ControlFlow::CONTINUE,\n-            Node::Binop(_, l, r) => {\n-                recurse(tcx, ct.subtree(l), f)?;\n-                recurse(tcx, ct.subtree(r), f)\n-            }\n-            Node::UnaryOp(_, v) => recurse(tcx, ct.subtree(v), f),\n-            Node::FunctionCall(func, args) => {\n-                recurse(tcx, ct.subtree(func), f)?;\n-                args.iter().try_for_each(|&arg| recurse(tcx, ct.subtree(arg), f))\n-            }\n-            Node::Cast(_, operand, _) => recurse(tcx, ct.subtree(operand), f),\n-        }\n-    }\n-\n-    recurse(tcx, ct, &mut f)\n-}\n-\n-struct ConstUnifyCtxt<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-}\n-\n-impl<'tcx> ConstUnifyCtxt<'tcx> {\n-    // Substitutes generics repeatedly to allow AbstractConsts to unify where a\n-    // ConstKind::Unevaluated could be turned into an AbstractConst that would unify e.g.\n-    // Param(N) should unify with Param(T), substs: [Unevaluated(\"T2\", [Unevaluated(\"T3\", [Param(N)])])]\n-    #[inline]\n-    #[instrument(skip(self), level = \"debug\")]\n-    fn try_replace_substs_in_root(\n-        &self,\n-        mut abstr_const: AbstractConst<'tcx>,\n-    ) -> Option<AbstractConst<'tcx>> {\n-        while let Node::Leaf(ct) = abstr_const.root(self.tcx) {\n-            match AbstractConst::from_const(self.tcx, ct) {\n-                Ok(Some(act)) => abstr_const = act,\n-                Ok(None) => break,\n-                Err(_) => return None,\n-            }\n-        }\n-\n-        Some(abstr_const)\n-    }\n-\n-    /// Tries to unify two abstract constants using structural equality.\n-    #[instrument(skip(self), level = \"debug\")]\n-    fn try_unify(&self, a: AbstractConst<'tcx>, b: AbstractConst<'tcx>) -> bool {\n-        let a = if let Some(a) = self.try_replace_substs_in_root(a) {\n-            a\n-        } else {\n-            return true;\n-        };\n-\n-        let b = if let Some(b) = self.try_replace_substs_in_root(b) {\n-            b\n-        } else {\n-            return true;\n-        };\n-\n-        let a_root = a.root(self.tcx);\n-        let b_root = b.root(self.tcx);\n-        debug!(?a_root, ?b_root);\n-\n-        match (a_root, b_root) {\n-            (Node::Leaf(a_ct), Node::Leaf(b_ct)) => {\n-                let a_ct = a_ct.eval(self.tcx, self.param_env);\n-                debug!(\"a_ct evaluated: {:?}\", a_ct);\n-                let b_ct = b_ct.eval(self.tcx, self.param_env);\n-                debug!(\"b_ct evaluated: {:?}\", b_ct);\n-\n-                if a_ct.ty() != b_ct.ty() {\n-                    return false;\n-                }\n-\n-                match (a_ct.kind(), b_ct.kind()) {\n-                    // We can just unify errors with everything to reduce the amount of\n-                    // emitted errors here.\n-                    (ty::ConstKind::Error(_), _) | (_, ty::ConstKind::Error(_)) => true,\n-                    (ty::ConstKind::Param(a_param), ty::ConstKind::Param(b_param)) => {\n-                        a_param == b_param\n-                    }\n-                    (ty::ConstKind::Value(a_val), ty::ConstKind::Value(b_val)) => a_val == b_val,\n-                    // If we have `fn a<const N: usize>() -> [u8; N + 1]` and `fn b<const M: usize>() -> [u8; 1 + M]`\n-                    // we do not want to use `assert_eq!(a(), b())` to infer that `N` and `M` have to be `1`. This\n-                    // means that we only allow inference variables if they are equal.\n-                    (ty::ConstKind::Infer(a_val), ty::ConstKind::Infer(b_val)) => a_val == b_val,\n-                    // We expand generic anonymous constants at the start of this function, so this\n-                    // branch should only be taking when dealing with associated constants, at\n-                    // which point directly comparing them seems like the desired behavior.\n-                    //\n-                    // FIXME(generic_const_exprs): This isn't actually the case.\n-                    // We also take this branch for concrete anonymous constants and\n-                    // expand generic anonymous constants with concrete substs.\n-                    (ty::ConstKind::Unevaluated(a_uv), ty::ConstKind::Unevaluated(b_uv)) => {\n-                        a_uv == b_uv\n-                    }\n-                    // FIXME(generic_const_exprs): We may want to either actually try\n-                    // to evaluate `a_ct` and `b_ct` if they are are fully concrete or something like\n-                    // this, for now we just return false here.\n-                    _ => false,\n-                }\n-            }\n-            (Node::Binop(a_op, al, ar), Node::Binop(b_op, bl, br)) if a_op == b_op => {\n-                self.try_unify(a.subtree(al), b.subtree(bl))\n-                    && self.try_unify(a.subtree(ar), b.subtree(br))\n-            }\n-            (Node::UnaryOp(a_op, av), Node::UnaryOp(b_op, bv)) if a_op == b_op => {\n-                self.try_unify(a.subtree(av), b.subtree(bv))\n-            }\n-            (Node::FunctionCall(a_f, a_args), Node::FunctionCall(b_f, b_args))\n-                if a_args.len() == b_args.len() =>\n-            {\n-                self.try_unify(a.subtree(a_f), b.subtree(b_f))\n-                    && iter::zip(a_args, b_args)\n-                        .all(|(&an, &bn)| self.try_unify(a.subtree(an), b.subtree(bn)))\n-            }\n-            (Node::Cast(a_kind, a_operand, a_ty), Node::Cast(b_kind, b_operand, b_ty))\n-                if (a_ty == b_ty) && (a_kind == b_kind) =>\n-            {\n-                self.try_unify(a.subtree(a_operand), b.subtree(b_operand))\n-            }\n-            // use this over `_ => false` to make adding variants to `Node` less error prone\n-            (Node::Cast(..), _)\n-            | (Node::FunctionCall(..), _)\n-            | (Node::UnaryOp(..), _)\n-            | (Node::Binop(..), _)\n-            | (Node::Leaf(..), _) => false,\n-        }\n-    }\n-}"}, {"sha": "02196a8f16d0b0ba3589a300195a8b13296d509e", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -24,8 +24,8 @@ use rustc_hir::Item;\n use rustc_hir::Node;\n use rustc_infer::infer::error_reporting::same_type_modulo_infer;\n use rustc_infer::traits::{AmbiguousSelection, TraitEngine};\n-use rustc_middle::thir::abstract_const::NotConstEvaluatable;\n use rustc_middle::traits::select::OverflowError;\n+use rustc_middle::ty::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::error::ExpectedFound;\n use rustc_middle::ty::fold::{TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::{\n@@ -2179,6 +2179,33 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                 }\n             }\n \n+            ty::PredicateKind::ConstEvaluatable(data) => {\n+                if predicate.references_error() || self.is_tainted_by_errors() {\n+                    return;\n+                }\n+                let subst = data.substs.iter().find(|g| g.has_infer_types_or_consts());\n+                if let Some(subst) = subst {\n+                    let err = self.emit_inference_failure_err(\n+                        body_id,\n+                        span,\n+                        subst,\n+                        ErrorCode::E0284,\n+                        true,\n+                    );\n+                    err\n+                } else {\n+                    // If we can't find a substitution, just print a generic error\n+                    let mut err = struct_span_err!(\n+                        self.tcx.sess,\n+                        span,\n+                        E0284,\n+                        \"type annotations needed: cannot satisfy `{}`\",\n+                        predicate,\n+                    );\n+                    err.span_label(span, &format!(\"cannot satisfy `{}`\", predicate));\n+                    err\n+                }\n+            }\n             _ => {\n                 if self.tcx.sess.has_errors().is_some() || self.is_tainted_by_errors() {\n                     return;"}, {"sha": "4aa62f8078d42dcd4a7d1a74772343cd6b3bc21d", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -6,7 +6,7 @@ use rustc_data_structures::obligation_forest::{ObligationForest, ObligationProce\n use rustc_infer::traits::ProjectionCacheKey;\n use rustc_infer::traits::{SelectionError, TraitEngine, TraitEngineExt as _, TraitObligation};\n use rustc_middle::mir::interpret::ErrorHandled;\n-use rustc_middle::thir::abstract_const::NotConstEvaluatable;\n+use rustc_middle::ty::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::ToPredicate;"}, {"sha": "0ad1b47a89079763509992f845d20b9d4a99859c", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -845,20 +845,6 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         vtable_entries,\n         vtable_trait_upcasting_coercion_new_vptr_slot,\n         subst_and_check_impossible_predicates,\n-        thir_abstract_const: |tcx, def_id| {\n-            let def_id = def_id.expect_local();\n-            if let Some(def) = ty::WithOptConstParam::try_lookup(def_id, tcx) {\n-                tcx.thir_abstract_const_of_const_arg(def)\n-            } else {\n-                const_evaluatable::thir_abstract_const(tcx, ty::WithOptConstParam::unknown(def_id))\n-            }\n-        },\n-        thir_abstract_const_of_const_arg: |tcx, (did, param_did)| {\n-            const_evaluatable::thir_abstract_const(\n-                tcx,\n-                ty::WithOptConstParam { did, const_param_did: Some(param_did) },\n-            )\n-        },\n         try_unify_abstract_consts: |tcx, param_env_and| {\n             let (param_env, (a, b)) = param_env_and.into_parts();\n             const_evaluatable::try_unify_abstract_consts(tcx, (a, b), param_env)"}, {"sha": "2921ce0ffefe1f3bb8ed32e6217c65140184b5ff", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -11,12 +11,12 @@\n use super::elaborate_predicates;\n \n use crate::infer::TyCtxtInferExt;\n-use crate::traits::const_evaluatable::{self, AbstractConst};\n use crate::traits::query::evaluate_obligation::InferCtxtExt;\n use crate::traits::{self, Obligation, ObligationCause};\n use rustc_errors::{FatalError, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n+use rustc_middle::ty::abstract_const::{walk_abstract_const, AbstractConst};\n use rustc_middle::ty::subst::{GenericArg, InternalSubsts, Subst};\n use rustc_middle::ty::{\n     self, EarlyBinder, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor,\n@@ -841,15 +841,13 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeVisitable<'tcx>>(\n             //\n             // This shouldn't really matter though as we can't really use any\n             // constants which are not considered const evaluatable.\n-            use rustc_middle::thir::abstract_const::Node;\n+            use rustc_middle::ty::abstract_const::Node;\n             if let Ok(Some(ct)) = AbstractConst::new(self.tcx, uv.shrink()) {\n-                const_evaluatable::walk_abstract_const(self.tcx, ct, |node| {\n-                    match node.root(self.tcx) {\n-                        Node::Leaf(leaf) => self.visit_const(leaf),\n-                        Node::Cast(_, _, ty) => self.visit_ty(ty),\n-                        Node::Binop(..) | Node::UnaryOp(..) | Node::FunctionCall(_, _) => {\n-                            ControlFlow::CONTINUE\n-                        }\n+                walk_abstract_const(self.tcx, ct, |node| match node.root(self.tcx) {\n+                    Node::Leaf(leaf) => self.visit_const(leaf),\n+                    Node::Cast(_, _, ty) => self.visit_ty(ty),\n+                    Node::Binop(..) | Node::UnaryOp(..) | Node::FunctionCall(_, _) => {\n+                        ControlFlow::CONTINUE\n                     }\n                 })\n             } else {"}, {"sha": "7c5673c8632109e5c5f41bc460427ce3672a3637", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -32,7 +32,7 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_middle::dep_graph::{DepKind, DepNodeIndex};\n use rustc_middle::mir::interpret::ErrorHandled;\n-use rustc_middle::thir::abstract_const::NotConstEvaluatable;\n+use rustc_middle::ty::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::fold::BottomUpFolder;\n use rustc_middle::ty::print::with_no_trimmed_paths;"}, {"sha": "caad2ed4274f8d13017cc92d71a3a88c403fd952", "filename": "compiler/rustc_ty_utils/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_ty_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_ty_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2FCargo.toml?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -15,3 +15,4 @@ rustc_session = { path = \"../rustc_session\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n rustc_type_ir = { path = \"../rustc_type_ir\" }\n+rustc_index = { path = \"../rustc_index\" }"}, {"sha": "7c2f4db94ff7269e7c60fd9bf9bf7db7d62bda11", "filename": "compiler/rustc_ty_utils/src/consts.rs", "status": "modified", "additions": 394, "deletions": 2, "changes": 396, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -1,4 +1,12 @@\n-use rustc_middle::ty::{self, TyCtxt};\n+use rustc_errors::ErrorGuaranteed;\n+use rustc_hir::def::DefKind;\n+use rustc_hir::def_id::LocalDefId;\n+use rustc_index::vec::IndexVec;\n+use rustc_middle::mir::interpret::{LitToConstError, LitToConstInput};\n+use rustc_middle::ty::abstract_const::{CastKind, Node, NodeId};\n+use rustc_middle::ty::{self, TyCtxt, TypeVisitable};\n+use rustc_middle::{mir, thir};\n+use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n \n use std::iter;\n@@ -72,6 +80,390 @@ pub(crate) fn destructure_const<'tcx>(\n     ty::DestructuredConst { variant, fields }\n }\n \n+pub struct AbstractConstBuilder<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    body_id: thir::ExprId,\n+    body: &'a thir::Thir<'tcx>,\n+    /// The current WIP node tree.\n+    nodes: IndexVec<NodeId, Node<'tcx>>,\n+}\n+\n+impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n+    fn root_span(&self) -> Span {\n+        self.body.exprs[self.body_id].span\n+    }\n+\n+    fn error(&mut self, span: Span, msg: &str) -> Result<!, ErrorGuaranteed> {\n+        let reported = self\n+            .tcx\n+            .sess\n+            .struct_span_err(self.root_span(), \"overly complex generic constant\")\n+            .span_label(span, msg)\n+            .help(\"consider moving this anonymous constant into a `const` function\")\n+            .emit();\n+\n+        Err(reported)\n+    }\n+    fn maybe_supported_error(&mut self, span: Span, msg: &str) -> Result<!, ErrorGuaranteed> {\n+        let reported = self\n+            .tcx\n+            .sess\n+            .struct_span_err(self.root_span(), \"overly complex generic constant\")\n+            .span_label(span, msg)\n+            .help(\"consider moving this anonymous constant into a `const` function\")\n+            .note(\"this operation may be supported in the future\")\n+            .emit();\n+\n+        Err(reported)\n+    }\n+\n+    #[instrument(skip(tcx, body, body_id), level = \"debug\")]\n+    pub fn new(\n+        tcx: TyCtxt<'tcx>,\n+        (body, body_id): (&'a thir::Thir<'tcx>, thir::ExprId),\n+    ) -> Result<Option<AbstractConstBuilder<'a, 'tcx>>, ErrorGuaranteed> {\n+        let builder = AbstractConstBuilder { tcx, body_id, body, nodes: IndexVec::new() };\n+\n+        struct IsThirPolymorphic<'a, 'tcx> {\n+            is_poly: bool,\n+            thir: &'a thir::Thir<'tcx>,\n+        }\n+\n+        use crate::rustc_middle::thir::visit::Visitor;\n+        use thir::visit;\n+\n+        impl<'a, 'tcx> IsThirPolymorphic<'a, 'tcx> {\n+            fn expr_is_poly(&mut self, expr: &thir::Expr<'tcx>) -> bool {\n+                if expr.ty.has_param_types_or_consts() {\n+                    return true;\n+                }\n+\n+                match expr.kind {\n+                    thir::ExprKind::NamedConst { substs, .. } => substs.has_param_types_or_consts(),\n+                    thir::ExprKind::ConstParam { .. } => true,\n+                    thir::ExprKind::Repeat { value, count } => {\n+                        self.visit_expr(&self.thir()[value]);\n+                        count.has_param_types_or_consts()\n+                    }\n+                    _ => false,\n+                }\n+            }\n+\n+            fn pat_is_poly(&mut self, pat: &thir::Pat<'tcx>) -> bool {\n+                if pat.ty.has_param_types_or_consts() {\n+                    return true;\n+                }\n+\n+                match pat.kind.as_ref() {\n+                    thir::PatKind::Constant { value } => value.has_param_types_or_consts(),\n+                    thir::PatKind::Range(thir::PatRange { lo, hi, .. }) => {\n+                        lo.has_param_types_or_consts() || hi.has_param_types_or_consts()\n+                    }\n+                    _ => false,\n+                }\n+            }\n+        }\n+\n+        impl<'a, 'tcx> visit::Visitor<'a, 'tcx> for IsThirPolymorphic<'a, 'tcx> {\n+            fn thir(&self) -> &'a thir::Thir<'tcx> {\n+                &self.thir\n+            }\n+\n+            #[instrument(skip(self), level = \"debug\")]\n+            fn visit_expr(&mut self, expr: &thir::Expr<'tcx>) {\n+                self.is_poly |= self.expr_is_poly(expr);\n+                if !self.is_poly {\n+                    visit::walk_expr(self, expr)\n+                }\n+            }\n+\n+            #[instrument(skip(self), level = \"debug\")]\n+            fn visit_pat(&mut self, pat: &thir::Pat<'tcx>) {\n+                self.is_poly |= self.pat_is_poly(pat);\n+                if !self.is_poly {\n+                    visit::walk_pat(self, pat);\n+                }\n+            }\n+        }\n+\n+        let mut is_poly_vis = IsThirPolymorphic { is_poly: false, thir: body };\n+        visit::walk_expr(&mut is_poly_vis, &body[body_id]);\n+        debug!(\"AbstractConstBuilder: is_poly={}\", is_poly_vis.is_poly);\n+        if !is_poly_vis.is_poly {\n+            return Ok(None);\n+        }\n+\n+        Ok(Some(builder))\n+    }\n+\n+    /// We do not allow all binary operations in abstract consts, so filter disallowed ones.\n+    fn check_binop(op: mir::BinOp) -> bool {\n+        use mir::BinOp::*;\n+        match op {\n+            Add | Sub | Mul | Div | Rem | BitXor | BitAnd | BitOr | Shl | Shr | Eq | Lt | Le\n+            | Ne | Ge | Gt => true,\n+            Offset => false,\n+        }\n+    }\n+\n+    /// While we currently allow all unary operations, we still want to explicitly guard against\n+    /// future changes here.\n+    fn check_unop(op: mir::UnOp) -> bool {\n+        use mir::UnOp::*;\n+        match op {\n+            Not | Neg => true,\n+        }\n+    }\n+\n+    /// Builds the abstract const by walking the thir and bailing out when\n+    /// encountering an unsupported operation.\n+    pub fn build(mut self) -> Result<&'tcx [Node<'tcx>], ErrorGuaranteed> {\n+        debug!(\"AbstractConstBuilder::build: body={:?}\", &*self.body);\n+        self.recurse_build(self.body_id)?;\n+\n+        for n in self.nodes.iter() {\n+            if let Node::Leaf(ct) = n {\n+                if let ty::ConstKind::Unevaluated(ct) = ct.kind() {\n+                    // `AbstractConst`s should not contain any promoteds as they require references which\n+                    // are not allowed.\n+                    assert_eq!(ct.promoted, None);\n+                    assert_eq!(ct, self.tcx.erase_regions(ct));\n+                }\n+            }\n+        }\n+\n+        Ok(self.tcx.arena.alloc_from_iter(self.nodes.into_iter()))\n+    }\n+\n+    fn recurse_build(&mut self, node: thir::ExprId) -> Result<NodeId, ErrorGuaranteed> {\n+        use thir::ExprKind;\n+        let node = &self.body.exprs[node];\n+        Ok(match &node.kind {\n+            // I dont know if handling of these 3 is correct\n+            &ExprKind::Scope { value, .. } => self.recurse_build(value)?,\n+            &ExprKind::PlaceTypeAscription { source, .. }\n+            | &ExprKind::ValueTypeAscription { source, .. } => self.recurse_build(source)?,\n+            &ExprKind::Literal { lit, neg} => {\n+                let sp = node.span;\n+                let constant =\n+                    match self.tcx.at(sp).lit_to_const(LitToConstInput { lit: &lit.node, ty: node.ty, neg }) {\n+                        Ok(c) => c,\n+                        Err(LitToConstError::Reported) => {\n+                            self.tcx.const_error(node.ty)\n+                        }\n+                        Err(LitToConstError::TypeError) => {\n+                            bug!(\"encountered type error in lit_to_const\")\n+                        }\n+                    };\n+\n+                self.nodes.push(Node::Leaf(constant))\n+            }\n+            &ExprKind::NonHirLiteral { lit , user_ty: _} => {\n+                let val = ty::ValTree::from_scalar_int(lit);\n+                self.nodes.push(Node::Leaf(ty::Const::from_value(self.tcx, val, node.ty)))\n+            }\n+            &ExprKind::ZstLiteral { user_ty: _ } => {\n+                let val = ty::ValTree::zst();\n+                self.nodes.push(Node::Leaf(ty::Const::from_value(self.tcx, val, node.ty)))\n+            }\n+            &ExprKind::NamedConst { def_id, substs, user_ty: _ } => {\n+                let uneval = ty::Unevaluated::new(ty::WithOptConstParam::unknown(def_id), substs);\n+\n+                let constant = self.tcx.mk_const(ty::ConstS {\n+                                kind: ty::ConstKind::Unevaluated(uneval),\n+                                ty: node.ty,\n+                            });\n+\n+                self.nodes.push(Node::Leaf(constant))\n+            }\n+\n+            ExprKind::ConstParam {param, ..} => {\n+                let const_param = self.tcx.mk_const(ty::ConstS {\n+                        kind: ty::ConstKind::Param(*param),\n+                        ty: node.ty,\n+                    });\n+                self.nodes.push(Node::Leaf(const_param))\n+            }\n+\n+            ExprKind::Call { fun, args, .. } => {\n+                let fun = self.recurse_build(*fun)?;\n+\n+                let mut new_args = Vec::<NodeId>::with_capacity(args.len());\n+                for &id in args.iter() {\n+                    new_args.push(self.recurse_build(id)?);\n+                }\n+                let new_args = self.tcx.arena.alloc_slice(&new_args);\n+                self.nodes.push(Node::FunctionCall(fun, new_args))\n+            }\n+            &ExprKind::Binary { op, lhs, rhs } if Self::check_binop(op) => {\n+                let lhs = self.recurse_build(lhs)?;\n+                let rhs = self.recurse_build(rhs)?;\n+                self.nodes.push(Node::Binop(op, lhs, rhs))\n+            }\n+            &ExprKind::Unary { op, arg } if Self::check_unop(op) => {\n+                let arg = self.recurse_build(arg)?;\n+                self.nodes.push(Node::UnaryOp(op, arg))\n+            }\n+            // This is necessary so that the following compiles:\n+            //\n+            // ```\n+            // fn foo<const N: usize>(a: [(); N + 1]) {\n+            //     bar::<{ N + 1 }>();\n+            // }\n+            // ```\n+            ExprKind::Block { body: thir::Block { stmts: box [], expr: Some(e), .. } } => {\n+                self.recurse_build(*e)?\n+            }\n+            // `ExprKind::Use` happens when a `hir::ExprKind::Cast` is a\n+            // \"coercion cast\" i.e. using a coercion or is a no-op.\n+            // This is important so that `N as usize as usize` doesnt unify with `N as usize`. (untested)\n+            &ExprKind::Use { source } => {\n+                let arg = self.recurse_build(source)?;\n+                self.nodes.push(Node::Cast(CastKind::Use, arg, node.ty))\n+            }\n+            &ExprKind::Cast { source } => {\n+                let arg = self.recurse_build(source)?;\n+                self.nodes.push(Node::Cast(CastKind::As, arg, node.ty))\n+            }\n+            ExprKind::Borrow{ arg, ..} => {\n+                let arg_node = &self.body.exprs[*arg];\n+\n+                // Skip reborrows for now until we allow Deref/Borrow/AddressOf\n+                // expressions.\n+                // FIXME(generic_const_exprs): Verify/explain why this is sound\n+                if let ExprKind::Deref { arg } = arg_node.kind {\n+                    self.recurse_build(arg)?\n+                } else {\n+                    self.maybe_supported_error(\n+                        node.span,\n+                        \"borrowing is not supported in generic constants\",\n+                    )?\n+                }\n+            }\n+            // FIXME(generic_const_exprs): We may want to support these.\n+            ExprKind::AddressOf { .. } | ExprKind::Deref {..}=> self.maybe_supported_error(\n+                node.span,\n+                \"dereferencing or taking the address is not supported in generic constants\",\n+            )?,\n+            ExprKind::Repeat { .. } | ExprKind::Array { .. } =>  self.maybe_supported_error(\n+                node.span,\n+                \"array construction is not supported in generic constants\",\n+            )?,\n+            ExprKind::Block { .. } => self.maybe_supported_error(\n+                node.span,\n+                \"blocks are not supported in generic constant\",\n+            )?,\n+            ExprKind::NeverToAny { .. } => self.maybe_supported_error(\n+                node.span,\n+                \"converting nevers to any is not supported in generic constant\",\n+            )?,\n+            ExprKind::Tuple { .. } => self.maybe_supported_error(\n+                node.span,\n+                \"tuple construction is not supported in generic constants\",\n+            )?,\n+            ExprKind::Index { .. } => self.maybe_supported_error(\n+                node.span,\n+                \"indexing is not supported in generic constant\",\n+            )?,\n+            ExprKind::Field { .. } => self.maybe_supported_error(\n+                node.span,\n+                \"field access is not supported in generic constant\",\n+            )?,\n+            ExprKind::ConstBlock { .. } => self.maybe_supported_error(\n+                node.span,\n+                \"const blocks are not supported in generic constant\",\n+            )?,\n+            ExprKind::Adt(_) => self.maybe_supported_error(\n+                node.span,\n+                \"struct/enum construction is not supported in generic constants\",\n+            )?,\n+            // dont know if this is correct\n+            ExprKind::Pointer { .. } =>\n+                self.error(node.span, \"pointer casts are not allowed in generic constants\")?,\n+            ExprKind::Yield { .. } =>\n+                self.error(node.span, \"generator control flow is not allowed in generic constants\")?,\n+            ExprKind::Continue { .. } | ExprKind::Break { .. } | ExprKind::Loop { .. } => self\n+                .error(\n+                    node.span,\n+                    \"loops and loop control flow are not supported in generic constants\",\n+                )?,\n+            ExprKind::Box { .. } =>\n+                self.error(node.span, \"allocations are not allowed in generic constants\")?,\n+\n+            ExprKind::Unary { .. } => unreachable!(),\n+            // we handle valid unary/binary ops above\n+            ExprKind::Binary { .. } =>\n+                self.error(node.span, \"unsupported binary operation in generic constants\")?,\n+            ExprKind::LogicalOp { .. } =>\n+                self.error(node.span, \"unsupported operation in generic constants, short-circuiting operations would imply control flow\")?,\n+            ExprKind::Assign { .. } | ExprKind::AssignOp { .. } => {\n+                self.error(node.span, \"assignment is not supported in generic constants\")?\n+            }\n+            ExprKind::Closure { .. } | ExprKind::Return { .. } => self.error(\n+                node.span,\n+                \"closures and function keywords are not supported in generic constants\",\n+            )?,\n+            // let expressions imply control flow\n+            ExprKind::Match { .. } | ExprKind::If { .. } | ExprKind::Let { .. } =>\n+                self.error(node.span, \"control flow is not supported in generic constants\")?,\n+            ExprKind::InlineAsm { .. } => {\n+                self.error(node.span, \"assembly is not supported in generic constants\")?\n+            }\n+\n+            // we dont permit let stmts so `VarRef` and `UpvarRef` cant happen\n+            ExprKind::VarRef { .. }\n+            | ExprKind::UpvarRef { .. }\n+            | ExprKind::StaticRef { .. }\n+            | ExprKind::ThreadLocalRef(_) => {\n+                self.error(node.span, \"unsupported operation in generic constant\")?\n+            }\n+        })\n+    }\n+}\n+\n+/// Builds an abstract const, do not use this directly, but use `AbstractConst::new` instead.\n+pub fn thir_abstract_const<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def: ty::WithOptConstParam<LocalDefId>,\n+) -> Result<Option<&'tcx [Node<'tcx>]>, ErrorGuaranteed> {\n+    if tcx.features().generic_const_exprs {\n+        match tcx.def_kind(def.did) {\n+            // FIXME(generic_const_exprs): We currently only do this for anonymous constants,\n+            // meaning that we do not look into associated constants. I(@lcnr) am not yet sure whether\n+            // we want to look into them or treat them as opaque projections.\n+            //\n+            // Right now we do neither of that and simply always fail to unify them.\n+            DefKind::AnonConst | DefKind::InlineConst => (),\n+            _ => return Ok(None),\n+        }\n+\n+        let body = tcx.thir_body(def)?;\n+\n+        AbstractConstBuilder::new(tcx, (&*body.0.borrow(), body.1))?\n+            .map(AbstractConstBuilder::build)\n+            .transpose()\n+    } else {\n+        Ok(None)\n+    }\n+}\n+\n pub fn provide(providers: &mut ty::query::Providers) {\n-    *providers = ty::query::Providers { destructure_const, ..*providers };\n+    *providers = ty::query::Providers {\n+        destructure_const,\n+        thir_abstract_const: |tcx, def_id| {\n+            let def_id = def_id.expect_local();\n+            if let Some(def) = ty::WithOptConstParam::try_lookup(def_id, tcx) {\n+                tcx.thir_abstract_const_of_const_arg(def)\n+            } else {\n+                thir_abstract_const(tcx, ty::WithOptConstParam::unknown(def_id))\n+            }\n+        },\n+        thir_abstract_const_of_const_arg: |tcx, (did, param_did)| {\n+            thir_abstract_const(\n+                tcx,\n+                ty::WithOptConstParam { did, const_param_did: Some(param_did) },\n+            )\n+        },\n+        ..*providers\n+    };\n }"}, {"sha": "09f5c2a11aaa808d835133a4ffdd6df86b4360c7", "filename": "compiler/rustc_ty_utils/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -7,6 +7,8 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(control_flow_enum)]\n #![feature(let_else)]\n+#![feature(never_type)]\n+#![feature(box_patterns)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "57f16f9517f201adaee0ac72c80cd0a17c1e2da8", "filename": "library/std/src/error.rs", "status": "modified", "additions": 116, "deletions": 1, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/library%2Fstd%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/library%2Fstd%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ferror.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -156,7 +156,7 @@ use core::array;\n use core::convert::Infallible;\n \n use crate::alloc::{AllocError, LayoutError};\n-use crate::any::TypeId;\n+use crate::any::{Demand, Provider, TypeId};\n use crate::backtrace::Backtrace;\n use crate::borrow::Cow;\n use crate::cell;\n@@ -295,6 +295,85 @@ pub trait Error: Debug + Display {\n     fn cause(&self) -> Option<&dyn Error> {\n         self.source()\n     }\n+\n+    /// Provides type based access to context intended for error reports.\n+    ///\n+    /// Used in conjunction with [`Demand::provide_value`] and [`Demand::provide_ref`] to extract\n+    /// references to member variables from `dyn Error` trait objects.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// #![feature(provide_any)]\n+    /// #![feature(error_generic_member_access)]\n+    /// use core::fmt;\n+    /// use core::any::Demand;\n+    ///\n+    /// #[derive(Debug)]\n+    /// struct MyBacktrace {\n+    ///     // ...\n+    /// }\n+    ///\n+    /// impl MyBacktrace {\n+    ///     fn new() -> MyBacktrace {\n+    ///         // ...\n+    ///         # MyBacktrace {}\n+    ///     }\n+    /// }\n+    ///\n+    /// #[derive(Debug)]\n+    /// struct SourceError {\n+    ///     // ...\n+    /// }\n+    ///\n+    /// impl fmt::Display for SourceError {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    ///         write!(f, \"Example Source Error\")\n+    ///     }\n+    /// }\n+    ///\n+    /// impl std::error::Error for SourceError {}\n+    ///\n+    /// #[derive(Debug)]\n+    /// struct Error {\n+    ///     source: SourceError,\n+    ///     backtrace: MyBacktrace,\n+    /// }\n+    ///\n+    /// impl fmt::Display for Error {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    ///         write!(f, \"Example Error\")\n+    ///     }\n+    /// }\n+    ///\n+    /// impl std::error::Error for Error {\n+    ///     fn provide<'a>(&'a self, req: &mut Demand<'a>) {\n+    ///         req\n+    ///             .provide_ref::<MyBacktrace>(&self.backtrace)\n+    ///             .provide_ref::<dyn std::error::Error + 'static>(&self.source);\n+    ///     }\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     let backtrace = MyBacktrace::new();\n+    ///     let source = SourceError {};\n+    ///     let error = Error { source, backtrace };\n+    ///     let dyn_error = &error as &dyn std::error::Error;\n+    ///     let backtrace_ref = dyn_error.request_ref::<MyBacktrace>().unwrap();\n+    ///\n+    ///     assert!(core::ptr::eq(&error.backtrace, backtrace_ref));\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"error_generic_member_access\", issue = \"none\")]\n+    #[allow(unused_variables)]\n+    fn provide<'a>(&'a self, req: &mut Demand<'a>) {}\n+}\n+\n+#[unstable(feature = \"error_generic_member_access\", issue = \"none\")]\n+impl Provider for dyn Error + 'static {\n+    fn provide<'a>(&'a self, req: &mut Demand<'a>) {\n+        self.provide(req)\n+    }\n }\n \n mod private {\n@@ -831,6 +910,18 @@ impl dyn Error + 'static {\n             None\n         }\n     }\n+\n+    /// Request a reference of type `T` as context about this error.\n+    #[unstable(feature = \"error_generic_member_access\", issue = \"none\")]\n+    pub fn request_ref<T: ?Sized + 'static>(&self) -> Option<&T> {\n+        core::any::request_ref(self)\n+    }\n+\n+    /// Request a value of type `T` as context about this error.\n+    #[unstable(feature = \"error_generic_member_access\", issue = \"none\")]\n+    pub fn request_value<T: 'static>(&self) -> Option<T> {\n+        core::any::request_value(self)\n+    }\n }\n \n impl dyn Error + 'static + Send {\n@@ -854,6 +945,18 @@ impl dyn Error + 'static + Send {\n     pub fn downcast_mut<T: Error + 'static>(&mut self) -> Option<&mut T> {\n         <dyn Error + 'static>::downcast_mut::<T>(self)\n     }\n+\n+    /// Request a reference of type `T` as context about this error.\n+    #[unstable(feature = \"error_generic_member_access\", issue = \"none\")]\n+    pub fn request_ref<T: ?Sized + 'static>(&self) -> Option<&T> {\n+        <dyn Error + 'static>::request_ref(self)\n+    }\n+\n+    /// Request a value of type `T` as context about this error.\n+    #[unstable(feature = \"error_generic_member_access\", issue = \"none\")]\n+    pub fn request_value<T: 'static>(&self) -> Option<T> {\n+        <dyn Error + 'static>::request_value(self)\n+    }\n }\n \n impl dyn Error + 'static + Send + Sync {\n@@ -877,6 +980,18 @@ impl dyn Error + 'static + Send + Sync {\n     pub fn downcast_mut<T: Error + 'static>(&mut self) -> Option<&mut T> {\n         <dyn Error + 'static>::downcast_mut::<T>(self)\n     }\n+\n+    /// Request a reference of type `T` as context about this error.\n+    #[unstable(feature = \"error_generic_member_access\", issue = \"none\")]\n+    pub fn request_ref<T: ?Sized + 'static>(&self) -> Option<&T> {\n+        <dyn Error + 'static>::request_ref(self)\n+    }\n+\n+    /// Request a value of type `T` as context about this error.\n+    #[unstable(feature = \"error_generic_member_access\", issue = \"none\")]\n+    pub fn request_value<T: 'static>(&self) -> Option<T> {\n+        <dyn Error + 'static>::request_value(self)\n+    }\n }\n \n impl dyn Error {"}, {"sha": "8fbc5e27d02b8f2334e049c256b56d3bb11f46e9", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -286,6 +286,7 @@\n #![feature(panic_internals)]\n #![feature(portable_simd)]\n #![feature(prelude_2024)]\n+#![feature(provide_any)]\n #![feature(ptr_as_uninit)]\n #![feature(raw_os_nonzero)]\n #![feature(slice_internals)]"}, {"sha": "1aa79f5566aa68624d29db0e5a8e6532ef2956f5", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -1764,6 +1764,7 @@ impl<'a> Builder<'a> {\n \n         if !target.contains(\"windows\") {\n             let needs_unstable_opts = target.contains(\"linux\")\n+                || target.contains(\"solaris\")\n                 || target.contains(\"windows\")\n                 || target.contains(\"bsd\")\n                 || target.contains(\"dragonfly\")"}, {"sha": "dbb6cbb9437b573e99348794bb1f96354fbe2343", "filename": "src/test/ui/asm/aarch64/srcloc.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/src%2Ftest%2Fui%2Fasm%2Faarch64%2Fsrcloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/src%2Ftest%2Fui%2Fasm%2Faarch64%2Fsrcloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Faarch64%2Fsrcloc.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -118,5 +118,12 @@ fn main() {\n         //~^^^^^^^^^^ ERROR: unrecognized instruction mnemonic\n         //~^^^^^^^ ERROR: unrecognized instruction mnemonic\n         //~^^^^^^^^ ERROR: unrecognized instruction mnemonic\n+\n+        asm!(\n+            \"\",\n+            \"\\n\",\n+            \"invalid_instruction\"\n+        );\n+        //~^^ ERROR: unrecognized instruction mnemonic\n     }\n }"}, {"sha": "2e17b60b912430b2f0b32f12e29a042a01a193d2", "filename": "src/test/ui/asm/aarch64/srcloc.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/src%2Ftest%2Fui%2Fasm%2Faarch64%2Fsrcloc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/src%2Ftest%2Fui%2Fasm%2Faarch64%2Fsrcloc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Faarch64%2Fsrcloc.stderr?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -274,5 +274,17 @@ note: instantiated into assembly here\n LL | invalid_instruction4\n    | ^\n \n-error: aborting due to 23 previous errors\n+error: unrecognized instruction mnemonic\n+  --> $DIR/srcloc.rs:125:14\n+   |\n+LL |             \"invalid_instruction\"\n+   |              ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:4:1\n+   |\n+LL | invalid_instruction\n+   | ^\n+\n+error: aborting due to 24 previous errors\n "}, {"sha": "1135ad2e1c643b643fe7c695f8f095e7e9b7d7fe", "filename": "src/test/ui/asm/x86_64/srcloc.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fsrcloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fsrcloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fsrcloc.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -120,5 +120,12 @@ fn main() {\n         //~^^^^^^^^^^ ERROR: invalid instruction mnemonic 'invalid_instruction2'\n         //~^^^^^^^ ERROR: invalid instruction mnemonic 'invalid_instruction3'\n         //~^^^^^^^^ ERROR: invalid instruction mnemonic 'invalid_instruction4'\n+\n+        asm!(\n+            \"\",\n+            \"\\n\",\n+            \"invalid_instruction\"\n+        );\n+        //~^^ ERROR: invalid instruction mnemonic 'invalid_instruction'\n     }\n }"}, {"sha": "8899c1b916bd02ecae61146b0ea3de6a972e7a07", "filename": "src/test/ui/asm/x86_64/srcloc.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fsrcloc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fsrcloc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fsrcloc.stderr?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -286,5 +286,17 @@ note: instantiated into assembly here\n LL | invalid_instruction4\n    | ^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 23 previous errors; 1 warning emitted\n+error: invalid instruction mnemonic 'invalid_instruction'\n+  --> $DIR/srcloc.rs:127:14\n+   |\n+LL |             \"invalid_instruction\"\n+   |              ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:5:1\n+   |\n+LL | invalid_instruction\n+   | ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 24 previous errors; 1 warning emitted\n "}, {"sha": "79e9834b54ed2c4b4b9b9514641a32471b7b5db2", "filename": "src/test/ui/const-generics/generic_const_exprs/object-safety-ok-infer-err.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fobject-safety-ok-infer-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fobject-safety-ok-infer-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fobject-safety-ok-infer-err.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -16,7 +16,6 @@ fn use_dyn<const N: usize>(v: &dyn Foo<N>) where [u8; N + 1]: Sized {\n }\n \n fn main() {\n-    // FIXME(generic_const_exprs): Improve the error message here.\n     use_dyn(&());\n     //~^ ERROR type annotations needed\n }"}, {"sha": "59e9fee1eaf41317d10e801fcbc8264a5d6bfc52", "filename": "src/test/ui/const-generics/generic_const_exprs/object-safety-ok-infer-err.stderr", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fobject-safety-ok-infer-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fobject-safety-ok-infer-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fobject-safety-ok-infer-err.stderr?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -1,14 +1,18 @@\n-error[E0284]: type annotations needed: cannot satisfy `the constant `use_dyn::<{_: usize}>::{constant#0}` can be evaluated`\n-  --> $DIR/object-safety-ok-infer-err.rs:20:5\n+error[E0284]: type annotations needed\n+  --> $DIR/object-safety-ok-infer-err.rs:19:5\n    |\n LL |     use_dyn(&());\n-   |     ^^^^^^^ cannot satisfy `the constant `use_dyn::<{_: usize}>::{constant#0}` can be evaluated`\n+   |     ^^^^^^^ cannot infer the value of the const parameter `N` declared on the function `use_dyn`\n    |\n note: required by a bound in `use_dyn`\n   --> $DIR/object-safety-ok-infer-err.rs:14:55\n    |\n LL | fn use_dyn<const N: usize>(v: &dyn Foo<N>) where [u8; N + 1]: Sized {\n    |                                                       ^^^^^ required by this bound in `use_dyn`\n+help: consider specifying the generic argument\n+   |\n+LL |     use_dyn::<N>(&());\n+   |            +++++\n \n error: aborting due to previous error\n "}, {"sha": "e599eadd8cf4804815436c0bc859f53cfbe3ff72", "filename": "src/test/ui/const-generics/overlapping_impls.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/src%2Ftest%2Fui%2Fconst-generics%2Foverlapping_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/src%2Ftest%2Fui%2Fconst-generics%2Foverlapping_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Foverlapping_impls.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -0,0 +1,36 @@\n+// check-pass\n+#![allow(incomplete_features)]\n+#![feature(adt_const_params)]\n+#![feature(generic_const_exprs)]\n+use std::marker::PhantomData;\n+\n+struct Foo<const I: i32, const J: i32> {}\n+\n+const ONE: i32 = 1;\n+const TWO: i32 = 2;\n+\n+impl<const I: i32> Foo<I, ONE> {\n+    pub fn foo() {}\n+}\n+\n+impl<const I: i32> Foo<I, TWO> {\n+    pub fn foo() {}\n+}\n+\n+\n+pub struct Foo2<const P: Protocol, T> {\n+    _marker: PhantomData<T>,\n+}\n+\n+#[derive(PartialEq, Eq)]\n+pub enum Protocol {\n+    Variant1,\n+    Variant2,\n+}\n+\n+pub trait Bar {}\n+\n+impl<T> Bar for Foo2<{ Protocol::Variant1 }, T> {}\n+impl<T> Bar for Foo2<{ Protocol::Variant2 }, T> {}\n+\n+fn main() {}"}, {"sha": "7a78e0f109ca74e0c8073996bbc789dfcd5fdcb5", "filename": "src/test/ui/const-generics/parent_generics_of_encoding_impl_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/src%2Ftest%2Fui%2Fconst-generics%2Fparent_generics_of_encoding_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/src%2Ftest%2Fui%2Fconst-generics%2Fparent_generics_of_encoding_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fparent_generics_of_encoding_impl_trait.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -7,5 +7,5 @@ extern crate generics_of_parent_impl_trait;\n fn main() {\n     // check for `impl Trait<{ const }>` which has a parent of a `DefKind::TyParam`\n     generics_of_parent_impl_trait::foo([()]);\n-    //~^ error: type annotations needed:\n+    //~^ error: type annotations needed\n }"}, {"sha": "87ff7babe71c09793f46f1e2a2d3069771188cb7", "filename": "src/test/ui/const-generics/parent_generics_of_encoding_impl_trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/src%2Ftest%2Fui%2Fconst-generics%2Fparent_generics_of_encoding_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/src%2Ftest%2Fui%2Fconst-generics%2Fparent_generics_of_encoding_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fparent_generics_of_encoding_impl_trait.stderr?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -1,8 +1,8 @@\n-error[E0284]: type annotations needed: cannot satisfy `the constant `foo::{opaque#0}::{constant#0}` can be evaluated`\n+error[E0284]: type annotations needed\n   --> $DIR/parent_generics_of_encoding_impl_trait.rs:9:5\n    |\n LL |     generics_of_parent_impl_trait::foo([()]);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot satisfy `the constant `foo::{opaque#0}::{constant#0}` can be evaluated`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer the value of const parameter `N` declared on the function `foo`\n    |\n note: required by a bound in `foo`\n   --> $DIR/auxiliary/generics_of_parent_impl_trait.rs:6:48"}, {"sha": "c260148c148d0c4f959de4bff80feaaab7d7e724", "filename": "src/test/ui/macros/issue-98466-allow.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/src%2Ftest%2Fui%2Fmacros%2Fissue-98466-allow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/src%2Ftest%2Fui%2Fmacros%2Fissue-98466-allow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-98466-allow.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+#![allow(named_arguments_used_positionally)]\n+\n+fn main() {\n+    let mut _x: usize;\n+    _x = 1;\n+    println!(\"_x is {}\", _x = 5);\n+    println!(\"_x is {}\", y = _x);\n+    println!(\"first positional arg {}, second positional arg {}, _x is {}\", 1, 2, y = _x);\n+\n+    let mut _x: usize;\n+    _x = 1;\n+    let _f = format!(\"_x is {}\", _x = 5);\n+    let _f = format!(\"_x is {}\", y = _x);\n+    let _f = format!(\"first positional arg {}, second positional arg {}, _x is {}\", 1, 2, y = _x);\n+}"}, {"sha": "e46e22f001fe3c7536b66bf5d133eb1538041eae", "filename": "src/test/ui/macros/issue-98466.fixed", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/src%2Ftest%2Fui%2Fmacros%2Fissue-98466.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/src%2Ftest%2Fui%2Fmacros%2Fissue-98466.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-98466.fixed?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -0,0 +1,51 @@\n+// check-pass\n+// run-rustfix\n+\n+fn main() {\n+    let mut _x: usize;\n+    _x = 1;\n+    println!(\"_x is {_x}\", _x = 5);\n+    //~^ WARNING named argument `_x` is not used by name [named_arguments_used_positionally]\n+    //~| HELP use the named argument by name to avoid ambiguity\n+    println!(\"_x is {y}\", y = _x);\n+    //~^ WARNING named argument `y` is not used by name [named_arguments_used_positionally]\n+    //~| HELP use the named argument by name to avoid ambiguity\n+    println!(\"first positional arg {}, second positional arg {}, _x is {y}\", 1, 2, y = _x);\n+    //~^ WARNING named argument `y` is not used by name [named_arguments_used_positionally]\n+    //~| HELP use the named argument by name to avoid ambiguity\n+\n+    let mut _x: usize;\n+    _x = 1;\n+    let _f = format!(\"_x is {_x}\", _x = 5);\n+    //~^ WARNING named argument `_x` is not used by name [named_arguments_used_positionally]\n+    //~| HELP use the named argument by name to avoid ambiguity\n+    let _f = format!(\"_x is {y}\", y = _x);\n+    //~^ WARNING named argument `y` is not used by name [named_arguments_used_positionally]\n+    //~| HELP use the named argument by name to avoid ambiguity\n+    let _f = format!(\"first positional arg {}, second positional arg {}, _x is {y}\", 1, 2, y = _x);\n+    //~^ WARNING named argument `y` is not used by name [named_arguments_used_positionally]\n+    //~| HELP use the named argument by name to avoid ambiguity\n+\n+    let s = \"0.009\";\n+    // Confirm that named arguments used in formatting are correctly considered.\n+    println!(\".{:0<width$}\", s, width = _x);\n+\n+    let region = \"abc\";\n+    let width = 8;\n+    let ls = \"abcde\";\n+    let full = \"abcde\";\n+    // Confirm that named arguments used in formatting are correctly considered.\n+    println!(\n+        \"| {r:rw$?} | {ui:4?} | {v}\",\n+        r = region,\n+        rw = width,\n+        ui = ls,\n+        v = full,\n+    );\n+\n+    // Confirm that named arguments used in formatting are correctly considered.\n+    println!(\"{:.a$}\", \"aaaaaaaaaaaaaaaaaa\", a = 4);\n+\n+    // Confirm that named arguments used in formatting are correctly considered.\n+    println!(\"{:._a$}\", \"aaaaaaaaaaaaaaaaaa\", _a = 4);\n+}"}, {"sha": "2c3b099afdeafeb4cef830a1a35af04b983f9eb8", "filename": "src/test/ui/macros/issue-98466.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/src%2Ftest%2Fui%2Fmacros%2Fissue-98466.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/src%2Ftest%2Fui%2Fmacros%2Fissue-98466.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-98466.rs?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -0,0 +1,51 @@\n+// check-pass\n+// run-rustfix\n+\n+fn main() {\n+    let mut _x: usize;\n+    _x = 1;\n+    println!(\"_x is {}\", _x = 5);\n+    //~^ WARNING named argument `_x` is not used by name [named_arguments_used_positionally]\n+    //~| HELP use the named argument by name to avoid ambiguity\n+    println!(\"_x is {}\", y = _x);\n+    //~^ WARNING named argument `y` is not used by name [named_arguments_used_positionally]\n+    //~| HELP use the named argument by name to avoid ambiguity\n+    println!(\"first positional arg {}, second positional arg {}, _x is {}\", 1, 2, y = _x);\n+    //~^ WARNING named argument `y` is not used by name [named_arguments_used_positionally]\n+    //~| HELP use the named argument by name to avoid ambiguity\n+\n+    let mut _x: usize;\n+    _x = 1;\n+    let _f = format!(\"_x is {}\", _x = 5);\n+    //~^ WARNING named argument `_x` is not used by name [named_arguments_used_positionally]\n+    //~| HELP use the named argument by name to avoid ambiguity\n+    let _f = format!(\"_x is {}\", y = _x);\n+    //~^ WARNING named argument `y` is not used by name [named_arguments_used_positionally]\n+    //~| HELP use the named argument by name to avoid ambiguity\n+    let _f = format!(\"first positional arg {}, second positional arg {}, _x is {}\", 1, 2, y = _x);\n+    //~^ WARNING named argument `y` is not used by name [named_arguments_used_positionally]\n+    //~| HELP use the named argument by name to avoid ambiguity\n+\n+    let s = \"0.009\";\n+    // Confirm that named arguments used in formatting are correctly considered.\n+    println!(\".{:0<width$}\", s, width = _x);\n+\n+    let region = \"abc\";\n+    let width = 8;\n+    let ls = \"abcde\";\n+    let full = \"abcde\";\n+    // Confirm that named arguments used in formatting are correctly considered.\n+    println!(\n+        \"| {r:rw$?} | {ui:4?} | {v}\",\n+        r = region,\n+        rw = width,\n+        ui = ls,\n+        v = full,\n+    );\n+\n+    // Confirm that named arguments used in formatting are correctly considered.\n+    println!(\"{:.a$}\", \"aaaaaaaaaaaaaaaaaa\", a = 4);\n+\n+    // Confirm that named arguments used in formatting are correctly considered.\n+    println!(\"{:._a$}\", \"aaaaaaaaaaaaaaaaaa\", _a = 4);\n+}"}, {"sha": "ad11d181b6218608049f9cfc581136e257a6f211", "filename": "src/test/ui/macros/issue-98466.stderr", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/74621c764e737a1a430bac088b5507a8854ec460/src%2Ftest%2Fui%2Fmacros%2Fissue-98466.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74621c764e737a1a430bac088b5507a8854ec460/src%2Ftest%2Fui%2Fmacros%2Fissue-98466.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-98466.stderr?ref=74621c764e737a1a430bac088b5507a8854ec460", "patch": "@@ -0,0 +1,81 @@\n+warning: named argument `_x` is not used by name\n+  --> $DIR/issue-98466.rs:7:26\n+   |\n+LL |     println!(\"_x is {}\", _x = 5);\n+   |                     --   ^^ this named argument is only referred to by position in formatting string\n+   |                     |\n+   |                     this formatting argument uses named argument `_x` by position\n+   |\n+   = note: `#[warn(named_arguments_used_positionally)]` on by default\n+help: use the named argument by name to avoid ambiguity\n+   |\n+LL |     println!(\"_x is {_x}\", _x = 5);\n+   |                     ~~~~\n+\n+warning: named argument `y` is not used by name\n+  --> $DIR/issue-98466.rs:10:26\n+   |\n+LL |     println!(\"_x is {}\", y = _x);\n+   |                     --   ^ this named argument is only referred to by position in formatting string\n+   |                     |\n+   |                     this formatting argument uses named argument `y` by position\n+   |\n+help: use the named argument by name to avoid ambiguity\n+   |\n+LL |     println!(\"_x is {y}\", y = _x);\n+   |                     ~~~\n+\n+warning: named argument `y` is not used by name\n+  --> $DIR/issue-98466.rs:13:83\n+   |\n+LL |     println!(\"first positional arg {}, second positional arg {}, _x is {}\", 1, 2, y = _x);\n+   |                                                                        --         ^ this named argument is only referred to by position in formatting string\n+   |                                                                        |\n+   |                                                                        this formatting argument uses named argument `y` by position\n+   |\n+help: use the named argument by name to avoid ambiguity\n+   |\n+LL |     println!(\"first positional arg {}, second positional arg {}, _x is {y}\", 1, 2, y = _x);\n+   |                                                                        ~~~\n+\n+warning: named argument `_x` is not used by name\n+  --> $DIR/issue-98466.rs:19:34\n+   |\n+LL |     let _f = format!(\"_x is {}\", _x = 5);\n+   |                             --   ^^ this named argument is only referred to by position in formatting string\n+   |                             |\n+   |                             this formatting argument uses named argument `_x` by position\n+   |\n+help: use the named argument by name to avoid ambiguity\n+   |\n+LL |     let _f = format!(\"_x is {_x}\", _x = 5);\n+   |                             ~~~~\n+\n+warning: named argument `y` is not used by name\n+  --> $DIR/issue-98466.rs:22:34\n+   |\n+LL |     let _f = format!(\"_x is {}\", y = _x);\n+   |                             --   ^ this named argument is only referred to by position in formatting string\n+   |                             |\n+   |                             this formatting argument uses named argument `y` by position\n+   |\n+help: use the named argument by name to avoid ambiguity\n+   |\n+LL |     let _f = format!(\"_x is {y}\", y = _x);\n+   |                             ~~~\n+\n+warning: named argument `y` is not used by name\n+  --> $DIR/issue-98466.rs:25:91\n+   |\n+LL |     let _f = format!(\"first positional arg {}, second positional arg {}, _x is {}\", 1, 2, y = _x);\n+   |                                                                                --         ^ this named argument is only referred to by position in formatting string\n+   |                                                                                |\n+   |                                                                                this formatting argument uses named argument `y` by position\n+   |\n+help: use the named argument by name to avoid ambiguity\n+   |\n+LL |     let _f = format!(\"first positional arg {}, second positional arg {}, _x is {y}\", 1, 2, y = _x);\n+   |                                                                                ~~~\n+\n+warning: 6 warnings emitted\n+"}]}