{"sha": "45d033b21cdd009961860e62e1d1c785ecb2af41", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1ZDAzM2IyMWNkZDAwOTk2MTg2MGU2MmUxZDFjNzg1ZWNiMmFmNDE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-06-18T22:20:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-18T22:20:33Z"}, "message": "Rollup merge of #71338 - estebank:recursive-impl-trait, r=nikomatsakis\n\nExpand \"recursive opaque type\" diagnostic\n\nFix #70968, partially address #66523.", "tree": {"sha": "e74f474e529fdba072b79a5369dd8e9d77c6c998", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e74f474e529fdba072b79a5369dd8e9d77c6c998"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45d033b21cdd009961860e62e1d1c785ecb2af41", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe6+iyCRBK7hj4Ov3rIwAAdHIIAGSgDx1kEmx/C6oPc5AsW0Hj\nI9IgkyeRSSM7v/ZMXj8n19+01p2YjcPIzGp20BKr7cArrP+0TOl+homSu5JAo4h4\n+7ITZPY7FeU0qK2sXD42Yb2IwFD1P2KTEUmQjZgWvmwcNyM+Sl0gkQoP0d/u547p\nbVeSrAJUL7k5LdLAmaajAxQulfC0EbtVjcqvpuAexL4zAVa571JIkdJmw4spHCvR\n27imKw3UnnyZYS4ngEqj2N/Tsr8+abU5XXIawrVzLfw+9e2xENM7eIYBoUOCSdnH\nefsdghkA8rm9lhOd8GwDeV8kYLfywp234GX0YehFRL+/rRaGUBsCyIvG0tZBcnY=\n=UOFu\n-----END PGP SIGNATURE-----\n", "payload": "tree e74f474e529fdba072b79a5369dd8e9d77c6c998\nparent 9d388d465d3ecab18843ae356256060a3612fce4\nparent 8f12485335f506f4c9633305f323e55cdc3c8c2b\nauthor Manish Goregaokar <manishsmail@gmail.com> 1592518833 -0700\ncommitter GitHub <noreply@github.com> 1592518833 -0700\n\nRollup merge of #71338 - estebank:recursive-impl-trait, r=nikomatsakis\n\nExpand \"recursive opaque type\" diagnostic\n\nFix #70968, partially address #66523.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45d033b21cdd009961860e62e1d1c785ecb2af41", "html_url": "https://github.com/rust-lang/rust/commit/45d033b21cdd009961860e62e1d1c785ecb2af41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45d033b21cdd009961860e62e1d1c785ecb2af41/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d388d465d3ecab18843ae356256060a3612fce4", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d388d465d3ecab18843ae356256060a3612fce4", "html_url": "https://github.com/rust-lang/rust/commit/9d388d465d3ecab18843ae356256060a3612fce4"}, {"sha": "8f12485335f506f4c9633305f323e55cdc3c8c2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f12485335f506f4c9633305f323e55cdc3c8c2b", "html_url": "https://github.com/rust-lang/rust/commit/8f12485335f506f4c9633305f323e55cdc3c8c2b"}], "stats": {"total": 481, "additions": 366, "deletions": 115}, "files": [{"sha": "bed2044c7085515dbef5371c87dd9e176334ae6a", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/45d033b21cdd009961860e62e1d1c785ecb2af41/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d033b21cdd009961860e62e1d1c785ecb2af41/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=45d033b21cdd009961860e62e1d1c785ecb2af41", "patch": "@@ -2726,6 +2726,18 @@ impl Node<'_> {\n         }\n     }\n \n+    pub fn body_id(&self) -> Option<BodyId> {\n+        match self {\n+            Node::TraitItem(TraitItem {\n+                kind: TraitItemKind::Fn(_, TraitFn::Provided(body_id)),\n+                ..\n+            })\n+            | Node::ImplItem(ImplItem { kind: ImplItemKind::Fn(_, body_id), .. })\n+            | Node::Item(Item { kind: ItemKind::Fn(.., body_id), .. }) => Some(*body_id),\n+            _ => None,\n+        }\n+    }\n+\n     pub fn generics(&self) -> Option<&Generics<'_>> {\n         match self {\n             Node::TraitItem(TraitItem { generics, .. })"}, {"sha": "dfd7dac72d8e1702996d1cec1954a39415d038d7", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45d033b21cdd009961860e62e1d1c785ecb2af41/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d033b21cdd009961860e62e1d1c785ecb2af41/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=45d033b21cdd009961860e62e1d1c785ecb2af41", "patch": "@@ -1992,8 +1992,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n /// Collect all the returned expressions within the input expression.\n /// Used to point at the return spans when we want to suggest some change to them.\n #[derive(Default)]\n-struct ReturnsVisitor<'v> {\n-    returns: Vec<&'v hir::Expr<'v>>,\n+pub struct ReturnsVisitor<'v> {\n+    pub returns: Vec<&'v hir::Expr<'v>>,\n     in_block_tail: bool,\n }\n "}, {"sha": "b60b06567d6fa1c9e6ddfc1145808b5ea366993c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 173, "deletions": 14, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/45d033b21cdd009961860e62e1d1c785ecb2af41/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d033b21cdd009961860e62e1d1c785ecb2af41/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=45d033b21cdd009961860e62e1d1c785ecb2af41", "patch": "@@ -138,6 +138,7 @@ use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::opaque_types::{InferCtxtExt as _, OpaqueTypeDecl};\n use rustc_trait_selection::traits::error_reporting::recursive_type_with_infinite_size_error;\n+use rustc_trait_selection::traits::error_reporting::suggestions::ReturnsVisitor;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n use rustc_trait_selection::traits::{\n@@ -1710,6 +1711,173 @@ fn check_opaque_for_inheriting_lifetimes(tcx: TyCtxt<'tcx>, def_id: LocalDefId,\n     }\n }\n \n+/// Given a `DefId` for an opaque type in return position, find its parent item's return\n+/// expressions.\n+fn get_owner_return_paths(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: LocalDefId,\n+) -> Option<(hir::HirId, ReturnsVisitor<'tcx>)> {\n+    let hir_id = tcx.hir().as_local_hir_id(def_id);\n+    let id = tcx.hir().get_parent_item(hir_id);\n+    tcx.hir()\n+        .find(id)\n+        .map(|n| (id, n))\n+        .and_then(|(hir_id, node)| node.body_id().map(|b| (hir_id, b)))\n+        .map(|(hir_id, body_id)| {\n+            let body = tcx.hir().body(body_id);\n+            let mut visitor = ReturnsVisitor::default();\n+            visitor.visit_body(body);\n+            (hir_id, visitor)\n+        })\n+}\n+\n+/// Emit an error for recursive opaque types.\n+///\n+/// If this is a return `impl Trait`, find the item's return expressions and point at them. For\n+/// direct recursion this is enough, but for indirect recursion also point at the last intermediary\n+/// `impl Trait`.\n+///\n+/// If all the return expressions evaluate to `!`, then we explain that the error will go away\n+/// after changing it. This can happen when a user uses `panic!()` or similar as a placeholder.\n+fn opaque_type_cycle_error(tcx: TyCtxt<'tcx>, def_id: LocalDefId, span: Span) {\n+    let mut err = struct_span_err!(tcx.sess, span, E0720, \"cannot resolve opaque type\");\n+\n+    let mut label = false;\n+    if let Some((hir_id, visitor)) = get_owner_return_paths(tcx, def_id) {\n+        let tables = tcx.typeck_tables_of(tcx.hir().local_def_id(hir_id));\n+        if visitor\n+            .returns\n+            .iter()\n+            .filter_map(|expr| tables.node_type_opt(expr.hir_id))\n+            .all(|ty| matches!(ty.kind, ty::Never))\n+        {\n+            let spans = visitor\n+                .returns\n+                .iter()\n+                .filter(|expr| tables.node_type_opt(expr.hir_id).is_some())\n+                .map(|expr| expr.span)\n+                .collect::<Vec<Span>>();\n+            let span_len = spans.len();\n+            if span_len == 1 {\n+                err.span_label(spans[0], \"this returned value is of `!` type\");\n+            } else {\n+                let mut multispan: MultiSpan = spans.clone().into();\n+                for span in spans {\n+                    multispan\n+                        .push_span_label(span, \"this returned value is of `!` type\".to_string());\n+                }\n+                err.span_note(multispan, \"these returned values have a concrete \\\"never\\\" type\");\n+            }\n+            err.help(\"this error will resolve once the item's body returns a concrete type\");\n+        } else {\n+            let mut seen = FxHashSet::default();\n+            seen.insert(span);\n+            err.span_label(span, \"recursive opaque type\");\n+            label = true;\n+            for (sp, ty) in visitor\n+                .returns\n+                .iter()\n+                .filter_map(|e| tables.node_type_opt(e.hir_id).map(|t| (e.span, t)))\n+                .filter(|(_, ty)| !matches!(ty.kind, ty::Never))\n+            {\n+                struct VisitTypes(Vec<DefId>);\n+                impl<'tcx> ty::fold::TypeVisitor<'tcx> for VisitTypes {\n+                    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+                        match t.kind {\n+                            ty::Opaque(def, _) => {\n+                                self.0.push(def);\n+                                false\n+                            }\n+                            _ => t.super_visit_with(self),\n+                        }\n+                    }\n+                }\n+                let mut visitor = VisitTypes(vec![]);\n+                ty.visit_with(&mut visitor);\n+                for def_id in visitor.0 {\n+                    let ty_span = tcx.def_span(def_id);\n+                    if !seen.contains(&ty_span) {\n+                        err.span_label(ty_span, &format!(\"returning this opaque type `{}`\", ty));\n+                        seen.insert(ty_span);\n+                    }\n+                    err.span_label(sp, &format!(\"returning here with type `{}`\", ty));\n+                }\n+            }\n+        }\n+    }\n+    if !label {\n+        err.span_label(span, \"cannot resolve opaque type\");\n+    }\n+    err.emit();\n+}\n+\n+/// Emit an error for recursive opaque types in a `let` binding.\n+fn binding_opaque_type_cycle_error(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: LocalDefId,\n+    span: Span,\n+    partially_expanded_type: Ty<'tcx>,\n+) {\n+    let mut err = struct_span_err!(tcx.sess, span, E0720, \"cannot resolve opaque type\");\n+    err.span_label(span, \"cannot resolve opaque type\");\n+    // Find the the owner that declared this `impl Trait` type.\n+    let hir_id = tcx.hir().as_local_hir_id(def_id);\n+    let mut prev_hir_id = hir_id;\n+    let mut hir_id = tcx.hir().get_parent_node(hir_id);\n+    while let Some(node) = tcx.hir().find(hir_id) {\n+        match node {\n+            hir::Node::Local(hir::Local {\n+                pat,\n+                init: None,\n+                ty: Some(ty),\n+                source: hir::LocalSource::Normal,\n+                ..\n+            }) => {\n+                err.span_label(pat.span, \"this binding might not have a concrete type\");\n+                err.span_suggestion_verbose(\n+                    ty.span.shrink_to_hi(),\n+                    \"set the binding to a value for a concrete type to be resolved\",\n+                    \" = /* value */\".to_string(),\n+                    Applicability::HasPlaceholders,\n+                );\n+            }\n+            hir::Node::Local(hir::Local {\n+                init: Some(expr),\n+                source: hir::LocalSource::Normal,\n+                ..\n+            }) => {\n+                let hir_id = tcx.hir().as_local_hir_id(def_id);\n+                let tables =\n+                    tcx.typeck_tables_of(tcx.hir().local_def_id(tcx.hir().get_parent_item(hir_id)));\n+                if let Some(ty) = tables.node_type_opt(expr.hir_id) {\n+                    err.span_label(\n+                        expr.span,\n+                        &format!(\n+                            \"this is of type `{}`, which doesn't constrain \\\n+                             `{}` enough to arrive to a concrete type\",\n+                            ty, partially_expanded_type\n+                        ),\n+                    );\n+                }\n+            }\n+            _ => {}\n+        }\n+        if prev_hir_id == hir_id {\n+            break;\n+        }\n+        prev_hir_id = hir_id;\n+        hir_id = tcx.hir().get_parent_node(hir_id);\n+    }\n+    err.emit();\n+}\n+\n+fn async_opaque_type_cycle_error(tcx: TyCtxt<'tcx>, span: Span) {\n+    struct_span_err!(tcx.sess, span, E0733, \"recursion in an `async fn` requires boxing\")\n+        .span_label(span, \"recursive `async fn`\")\n+        .note(\"a recursive `async fn` must be rewritten to return a boxed `dyn Future`\")\n+        .emit();\n+}\n+\n /// Checks that an opaque type does not contain cycles.\n fn check_opaque_for_cycles<'tcx>(\n     tcx: TyCtxt<'tcx>,\n@@ -1720,21 +1888,12 @@ fn check_opaque_for_cycles<'tcx>(\n ) {\n     if let Err(partially_expanded_type) = tcx.try_expand_impl_trait_type(def_id.to_def_id(), substs)\n     {\n-        if let hir::OpaqueTyOrigin::AsyncFn = origin {\n-            struct_span_err!(tcx.sess, span, E0733, \"recursion in an `async fn` requires boxing\",)\n-                .span_label(span, \"recursive `async fn`\")\n-                .note(\"a recursive `async fn` must be rewritten to return a boxed `dyn Future`\")\n-                .emit();\n-        } else {\n-            let mut err =\n-                struct_span_err!(tcx.sess, span, E0720, \"opaque type expands to a recursive type\",);\n-            err.span_label(span, \"expands to a recursive type\");\n-            if let ty::Opaque(..) = partially_expanded_type.kind {\n-                err.note(\"type resolves to itself\");\n-            } else {\n-                err.note(&format!(\"expanded type is `{}`\", partially_expanded_type));\n+        match origin {\n+            hir::OpaqueTyOrigin::AsyncFn => async_opaque_type_cycle_error(tcx, span),\n+            hir::OpaqueTyOrigin::Binding => {\n+                binding_opaque_type_cycle_error(tcx, def_id, span, partially_expanded_type)\n             }\n-            err.emit();\n+            _ => opaque_type_cycle_error(tcx, def_id, span),\n         }\n     }\n }"}, {"sha": "6a97f28ff552b3a76c5f4743b8d980dcddaf97b1", "filename": "src/test/ui/impl-trait/binding-without-value.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/45d033b21cdd009961860e62e1d1c785ecb2af41/src%2Ftest%2Fui%2Fimpl-trait%2Fbinding-without-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d033b21cdd009961860e62e1d1c785ecb2af41/src%2Ftest%2Fui%2Fimpl-trait%2Fbinding-without-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fbinding-without-value.rs?ref=45d033b21cdd009961860e62e1d1c785ecb2af41", "patch": "@@ -0,0 +1,9 @@\n+#![allow(incomplete_features)]\n+#![feature(impl_trait_in_bindings)]\n+\n+fn foo() {\n+    let _ : impl Copy;\n+    //~^ ERROR cannot resolve opaque type\n+}\n+\n+fn main() {}"}, {"sha": "0d2faeaf85d10be60785746009a2de1eed8ac1ce", "filename": "src/test/ui/impl-trait/binding-without-value.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/45d033b21cdd009961860e62e1d1c785ecb2af41/src%2Ftest%2Fui%2Fimpl-trait%2Fbinding-without-value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45d033b21cdd009961860e62e1d1c785ecb2af41/src%2Ftest%2Fui%2Fimpl-trait%2Fbinding-without-value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fbinding-without-value.stderr?ref=45d033b21cdd009961860e62e1d1c785ecb2af41", "patch": "@@ -0,0 +1,16 @@\n+error[E0720]: cannot resolve opaque type\n+  --> $DIR/binding-without-value.rs:5:13\n+   |\n+LL |     let _ : impl Copy;\n+   |         -   ^^^^^^^^^ cannot resolve opaque type\n+   |         |\n+   |         this binding might not have a concrete type\n+   |\n+help: set the binding to a value for a concrete type to be resolved\n+   |\n+LL |     let _ : impl Copy = /* value */;\n+   |                       ^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0720`."}, {"sha": "451ddb3cce0e01c1bd9bc6d6034f055c5901f2d1", "filename": "src/test/ui/impl-trait/issues/infinite-impl-trait-issue-38064.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45d033b21cdd009961860e62e1d1c785ecb2af41/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Finfinite-impl-trait-issue-38064.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d033b21cdd009961860e62e1d1c785ecb2af41/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Finfinite-impl-trait-issue-38064.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Finfinite-impl-trait-issue-38064.rs?ref=45d033b21cdd009961860e62e1d1c785ecb2af41", "patch": "@@ -5,13 +5,13 @@\n \n trait Quux {}\n \n-fn foo() -> impl Quux { //~ opaque type expands to a recursive type\n+fn foo() -> impl Quux { //~ ERROR cannot resolve opaque type\n     struct Foo<T>(T);\n     impl<T> Quux for Foo<T> {}\n     Foo(bar())\n }\n \n-fn bar() -> impl Quux { //~ opaque type expands to a recursive type\n+fn bar() -> impl Quux { //~ ERROR cannot resolve opaque type\n     struct Bar<T>(T);\n     impl<T> Quux for Bar<T> {}\n     Bar(foo())"}, {"sha": "c538b77098a2d23a133667a96d30897926a1c4f5", "filename": "src/test/ui/impl-trait/issues/infinite-impl-trait-issue-38064.stderr", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/45d033b21cdd009961860e62e1d1c785ecb2af41/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Finfinite-impl-trait-issue-38064.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45d033b21cdd009961860e62e1d1c785ecb2af41/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Finfinite-impl-trait-issue-38064.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Finfinite-impl-trait-issue-38064.stderr?ref=45d033b21cdd009961860e62e1d1c785ecb2af41", "patch": "@@ -1,18 +1,26 @@\n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/infinite-impl-trait-issue-38064.rs:8:13\n    |\n LL | fn foo() -> impl Quux {\n-   |             ^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `foo::Foo<bar::Bar<impl Quux>>`\n+   |             ^^^^^^^^^ recursive opaque type\n+...\n+LL |     Foo(bar())\n+   |     ---------- returning here with type `foo::Foo<impl Quux>`\n+...\n+LL | fn bar() -> impl Quux {\n+   |             --------- returning this opaque type `foo::Foo<impl Quux>`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/infinite-impl-trait-issue-38064.rs:14:13\n    |\n+LL | fn foo() -> impl Quux {\n+   |             --------- returning this opaque type `bar::Bar<impl Quux>`\n+...\n LL | fn bar() -> impl Quux {\n-   |             ^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `bar::Bar<foo::Foo<impl Quux>>`\n+   |             ^^^^^^^^^ recursive opaque type\n+...\n+LL |     Bar(foo())\n+   |     ---------- returning here with type `bar::Bar<impl Quux>`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "5a3027ec751a91126268ddd7bc3eb8691c248246", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type-direct.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/45d033b21cdd009961860e62e1d1c785ecb2af41/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45d033b21cdd009961860e62e1d1c785ecb2af41/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.stderr?ref=45d033b21cdd009961860e62e1d1c785ecb2af41", "patch": "@@ -1,10 +1,11 @@\n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-direct.rs:5:14\n    |\n LL | fn test() -> impl Sized {\n-   |              ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: type resolves to itself\n+   |              ^^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     test()\n+   |     ------ returning here with type `impl Sized`\n \n error: aborting due to previous error\n "}, {"sha": "75ff9e078cc2ca7fe96b51e61d66bb1c25d8ad22", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type-indirect.stderr", "status": "modified", "additions": 93, "deletions": 60, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/45d033b21cdd009961860e62e1d1c785ecb2af41/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45d033b21cdd009961860e62e1d1c785ecb2af41/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.stderr?ref=45d033b21cdd009961860e62e1d1c785ecb2af41", "patch": "@@ -1,114 +1,147 @@\n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:7:22\n    |\n LL | fn option(i: i32) -> impl Sized {\n-   |                      ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `std::option::Option<(impl Sized, i32)>`\n+   |                      ^^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     if i < 0 { None } else { Some((option(i - 1), i)) }\n+   |                ----          ------------------------ returning here with type `std::option::Option<(impl Sized, i32)>`\n+   |                |\n+   |                returning here with type `std::option::Option<(impl Sized, i32)>`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:12:15\n    |\n LL | fn tuple() -> impl Sized {\n-   |               ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `(impl Sized,)`\n+   |               ^^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     (tuple(),)\n+   |     ---------- returning here with type `(impl Sized,)`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:17:15\n    |\n LL | fn array() -> impl Sized {\n-   |               ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `[impl Sized; 1]`\n+   |               ^^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     [array()]\n+   |     --------- returning here with type `[impl Sized; 1]`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:22:13\n    |\n LL | fn ptr() -> impl Sized {\n-   |             ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `*const impl Sized`\n+   |             ^^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     &ptr() as *const _\n+   |     ------------------ returning here with type `*const impl Sized`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:27:16\n    |\n LL | fn fn_ptr() -> impl Sized {\n-   |                ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `fn() -> impl Sized`\n+   |                ^^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     fn_ptr as fn() -> _\n+   |     ------------------- returning here with type `fn() -> impl Sized`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:32:25\n    |\n-LL | fn closure_capture() -> impl Sized {\n-   |                         ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `[closure@$DIR/recursive-impl-trait-type-indirect.rs:35:5: 37:6 x:impl Sized]`\n+LL |   fn closure_capture() -> impl Sized {\n+   |                           ^^^^^^^^^^ recursive opaque type\n+...\n+LL | /     move || {\n+LL | |         x;\n+LL | |     }\n+   | |_____- returning here with type `[closure@$DIR/recursive-impl-trait-type-indirect.rs:35:5: 37:6 x:impl Sized]`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:40:29\n    |\n-LL | fn closure_ref_capture() -> impl Sized {\n-   |                             ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `[closure@$DIR/recursive-impl-trait-type-indirect.rs:43:5: 45:6 x:impl Sized]`\n+LL |   fn closure_ref_capture() -> impl Sized {\n+   |                               ^^^^^^^^^^ recursive opaque type\n+...\n+LL | /     move || {\n+LL | |         &x;\n+LL | |     }\n+   | |_____- returning here with type `[closure@$DIR/recursive-impl-trait-type-indirect.rs:43:5: 45:6 x:impl Sized]`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:48:21\n    |\n LL | fn closure_sig() -> impl Sized {\n-   |                     ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `[closure@$DIR/recursive-impl-trait-type-indirect.rs:50:5: 50:21]`\n+   |                     ^^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     || closure_sig()\n+   |     ---------------- returning here with type `[closure@$DIR/recursive-impl-trait-type-indirect.rs:50:5: 50:21]`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:53:23\n    |\n LL | fn generator_sig() -> impl Sized {\n-   |                       ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `[closure@$DIR/recursive-impl-trait-type-indirect.rs:55:5: 55:23]`\n+   |                       ^^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     || generator_sig()\n+   |     ------------------ returning here with type `[closure@$DIR/recursive-impl-trait-type-indirect.rs:55:5: 55:23]`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:58:27\n    |\n-LL | fn generator_capture() -> impl Sized {\n-   |                           ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `[generator@$DIR/recursive-impl-trait-type-indirect.rs:61:5: 64:6 x:impl Sized {()}]`\n+LL |   fn generator_capture() -> impl Sized {\n+   |                             ^^^^^^^^^^ recursive opaque type\n+...\n+LL | /     move || {\n+LL | |         yield;\n+LL | |         x;\n+LL | |     }\n+   | |_____- returning here with type `[generator@$DIR/recursive-impl-trait-type-indirect.rs:61:5: 64:6 x:impl Sized {()}]`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:67:35\n    |\n LL | fn substs_change<T: 'static>() -> impl Sized {\n-   |                                   ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `(impl Sized,)`\n+   |                                   ^^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     (substs_change::<&T>(),)\n+   |     ------------------------ returning here with type `(impl Sized,)`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:72:24\n    |\n-LL | fn generator_hold() -> impl Sized {\n-   |                        ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `[generator@$DIR/recursive-impl-trait-type-indirect.rs:74:5: 78:6 {impl Sized, ()}]`\n+LL |   fn generator_hold() -> impl Sized {\n+   |                          ^^^^^^^^^^ recursive opaque type\n+LL |\n+LL | /     move || {\n+LL | |         let x = generator_hold();\n+LL | |         yield;\n+LL | |         x;\n+LL | |     }\n+   | |_____- returning here with type `[generator@$DIR/recursive-impl-trait-type-indirect.rs:74:5: 78:6 {impl Sized, ()}]`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:86:26\n    |\n LL | fn mutual_recursion() -> impl Sync {\n-   |                          ^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: type resolves to itself\n+   |                          ^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     mutual_recursion_b()\n+   |     -------------------- returning here with type `impl Sized`\n+...\n+LL | fn mutual_recursion_b() -> impl Sized {\n+   |                            ---------- returning this opaque type `impl Sized`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:91:28\n    |\n+LL | fn mutual_recursion() -> impl Sync {\n+   |                          --------- returning this opaque type `impl std::marker::Sync`\n+...\n LL | fn mutual_recursion_b() -> impl Sized {\n-   |                            ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: type resolves to itself\n+   |                            ^^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     mutual_recursion()\n+   |     ------------------ returning here with type `impl std::marker::Sync`\n \n error: aborting due to 14 previous errors\n "}, {"sha": "818e40365394dea65b44fe652d41be64aae4071e", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type-through-non-recursive.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/45d033b21cdd009961860e62e1d1c785ecb2af41/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-through-non-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d033b21cdd009961860e62e1d1c785ecb2af41/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-through-non-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-through-non-recursive.rs?ref=45d033b21cdd009961860e62e1d1c785ecb2af41", "patch": "@@ -4,21 +4,21 @@\n \n fn id<T>(t: T) -> impl Sized { t }\n \n-fn recursive_id() -> impl Sized { //~ ERROR opaque type expands to a recursive type\n+fn recursive_id() -> impl Sized { //~ ERROR cannot resolve opaque type\n     id(recursive_id2())\n }\n \n-fn recursive_id2() -> impl Sized { //~ ERROR opaque type expands to a recursive type\n+fn recursive_id2() -> impl Sized { //~ ERROR cannot resolve opaque type\n     id(recursive_id())\n }\n \n fn wrap<T>(t: T) -> impl Sized { (t,) }\n \n-fn recursive_wrap() -> impl Sized { //~ ERROR opaque type expands to a recursive type\n+fn recursive_wrap() -> impl Sized { //~ ERROR cannot resolve opaque type\n     wrap(recursive_wrap2())\n }\n \n-fn recursive_wrap2() -> impl Sized { //~ ERROR opaque type expands to a recursive type\n+fn recursive_wrap2() -> impl Sized { //~ ERROR cannot resolve opaque type\n     wrap(recursive_wrap())\n }\n "}, {"sha": "fbc58837a8e946dc45cd62490a2dc6442c83f4ae", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type-through-non-recursive.stderr", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/45d033b21cdd009961860e62e1d1c785ecb2af41/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-through-non-recursive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45d033b21cdd009961860e62e1d1c785ecb2af41/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-through-non-recursive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-through-non-recursive.stderr?ref=45d033b21cdd009961860e62e1d1c785ecb2af41", "patch": "@@ -1,34 +1,46 @@\n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-through-non-recursive.rs:7:22\n    |\n+LL | fn id<T>(t: T) -> impl Sized { t }\n+   |                   ---------- returning this opaque type `impl Sized`\n+LL | \n LL | fn recursive_id() -> impl Sized {\n-   |                      ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: type resolves to itself\n+   |                      ^^^^^^^^^^ recursive opaque type\n+LL |     id(recursive_id2())\n+   |     ------------------- returning here with type `impl Sized`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-through-non-recursive.rs:11:23\n    |\n+LL | fn id<T>(t: T) -> impl Sized { t }\n+   |                   ---------- returning this opaque type `impl Sized`\n+...\n LL | fn recursive_id2() -> impl Sized {\n-   |                       ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: type resolves to itself\n+   |                       ^^^^^^^^^^ recursive opaque type\n+LL |     id(recursive_id())\n+   |     ------------------ returning here with type `impl Sized`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-through-non-recursive.rs:17:24\n    |\n+LL | fn wrap<T>(t: T) -> impl Sized { (t,) }\n+   |                     ---------- returning this opaque type `impl Sized`\n+LL | \n LL | fn recursive_wrap() -> impl Sized {\n-   |                        ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `((impl Sized,),)`\n+   |                        ^^^^^^^^^^ recursive opaque type\n+LL |     wrap(recursive_wrap2())\n+   |     ----------------------- returning here with type `impl Sized`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-through-non-recursive.rs:21:25\n    |\n+LL | fn wrap<T>(t: T) -> impl Sized { (t,) }\n+   |                     ---------- returning this opaque type `impl Sized`\n+...\n LL | fn recursive_wrap2() -> impl Sized {\n-   |                         ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `((impl Sized,),)`\n+   |                         ^^^^^^^^^^ recursive opaque type\n+LL |     wrap(recursive_wrap())\n+   |     ---------------------- returning here with type `impl Sized`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "462508f306ef34f4b1f3de692f996a79a3d894e8", "filename": "src/test/ui/impl-trait/where-allowed-2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/45d033b21cdd009961860e62e1d1c785ecb2af41/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d033b21cdd009961860e62e1d1c785ecb2af41/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.rs?ref=45d033b21cdd009961860e62e1d1c785ecb2af41", "patch": "@@ -3,7 +3,6 @@\n use std::fmt::Debug;\n \n // Disallowed\n-fn in_adt_in_return() -> Vec<impl Debug> { panic!() }\n-//~^ ERROR opaque type expands to a recursive type\n+fn in_adt_in_return() -> Vec<impl Debug> { panic!() } //~ ERROR cannot resolve opaque type\n \n fn main() {}"}, {"sha": "b8e06725cbcdd6493683dc2ca34fd4d775d5cc27", "filename": "src/test/ui/impl-trait/where-allowed-2.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/45d033b21cdd009961860e62e1d1c785ecb2af41/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45d033b21cdd009961860e62e1d1c785ecb2af41/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.stderr?ref=45d033b21cdd009961860e62e1d1c785ecb2af41", "patch": "@@ -1,10 +1,12 @@\n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/where-allowed-2.rs:6:30\n    |\n LL | fn in_adt_in_return() -> Vec<impl Debug> { panic!() }\n-   |                              ^^^^^^^^^^ expands to a recursive type\n+   |                              ^^^^^^^^^^    -------- this returned value is of `!` type\n+   |                              |\n+   |                              cannot resolve opaque type\n    |\n-   = note: type resolves to itself\n+   = help: this error will resolve once the item's body returns a concrete type\n \n error: aborting due to previous error\n "}]}