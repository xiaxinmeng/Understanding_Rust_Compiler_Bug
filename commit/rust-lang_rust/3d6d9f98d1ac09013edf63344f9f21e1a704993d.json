{"sha": "3d6d9f98d1ac09013edf63344f9f21e1a704993d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkNmQ5Zjk4ZDFhYzA5MDEzZWRmNjMzNDRmOWYyMWUxYTcwNDk5M2Q=", "commit": {"author": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2018-04-13T20:58:16Z"}, "committer": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2018-04-17T15:52:33Z"}, "message": "Run rustfmt", "tree": {"sha": "d43cbcd1ad89c8f897369d3bda0002dda1a9579f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d43cbcd1ad89c8f897369d3bda0002dda1a9579f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d6d9f98d1ac09013edf63344f9f21e1a704993d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d6d9f98d1ac09013edf63344f9f21e1a704993d", "html_url": "https://github.com/rust-lang/rust/commit/3d6d9f98d1ac09013edf63344f9f21e1a704993d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d6d9f98d1ac09013edf63344f9f21e1a704993d/comments", "author": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d703622ce08d51eb91a909278f7917762e743438", "url": "https://api.github.com/repos/rust-lang/rust/commits/d703622ce08d51eb91a909278f7917762e743438", "html_url": "https://github.com/rust-lang/rust/commit/d703622ce08d51eb91a909278f7917762e743438"}], "stats": {"total": 148, "additions": 79, "deletions": 69}, "files": [{"sha": "ffd02108c270e4352ba97ecb342cc85038c59030", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 79, "deletions": 69, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/3d6d9f98d1ac09013edf63344f9f21e1a704993d/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d6d9f98d1ac09013edf63344f9f21e1a704993d/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=3d6d9f98d1ac09013edf63344f9f21e1a704993d", "patch": "@@ -11,12 +11,12 @@\n use rustc::middle::allocator::AllocatorKind;\n use rustc_errors;\n use syntax::abi::Abi;\n-use syntax::ast::{Crate, Attribute, LitKind, StrStyle};\n-use syntax::ast::{Unsafety, Constness, Generics, Mutability, Ty, Mac, Arg};\n-use syntax::ast::{self, Ident, Item, ItemKind, TyKind, VisibilityKind, Expr};\n+use syntax::ast::{Attribute, Crate, LitKind, StrStyle};\n+use syntax::ast::{Arg, Constness, Generics, Mac, Mutability, Ty, Unsafety};\n+use syntax::ast::{self, Expr, Ident, Item, ItemKind, TyKind, VisibilityKind};\n use syntax::attr;\n use syntax::codemap::{dummy_spanned, respan};\n-use syntax::codemap::{ExpnInfo, NameAndSpan, MacroAttribute};\n+use syntax::codemap::{ExpnInfo, MacroAttribute, NameAndSpan};\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::base::Resolver;\n use syntax::ext::build::AstBuilder;\n@@ -31,10 +31,12 @@ use syntax_pos::{Span, DUMMY_SP};\n \n use {AllocatorMethod, AllocatorTy, ALLOCATOR_METHODS};\n \n-pub fn modify(sess: &ParseSess,\n-              resolver: &mut Resolver,\n-              krate: Crate,\n-              handler: &rustc_errors::Handler) -> ast::Crate {\n+pub fn modify(\n+    sess: &ParseSess,\n+    resolver: &mut Resolver,\n+    krate: Crate,\n+    handler: &rustc_errors::Handler,\n+) -> ast::Crate {\n     ExpandAllocatorDirectives {\n         handler,\n         sess,\n@@ -55,20 +57,24 @@ impl<'a> Folder for ExpandAllocatorDirectives<'a> {\n         let name = if attr::contains_name(&item.attrs, \"global_allocator\") {\n             \"global_allocator\"\n         } else {\n-            return fold::noop_fold_item(item, self)\n+            return fold::noop_fold_item(item, self);\n         };\n         match item.node {\n             ItemKind::Static(..) => {}\n             _ => {\n-                self.handler.span_err(item.span, \"allocators must be statics\");\n-                return SmallVector::one(item)\n+                self.handler\n+                    .span_err(item.span, \"allocators must be statics\");\n+                return SmallVector::one(item);\n             }\n         }\n \n         if self.found {\n-            self.handler.span_err(item.span, \"cannot define more than one \\\n-                                              #[global_allocator]\");\n-            return SmallVector::one(item)\n+            self.handler.span_err(\n+                item.span,\n+                \"cannot define more than one \\\n+                 #[global_allocator]\",\n+            );\n+            return SmallVector::one(item);\n         }\n         self.found = true;\n \n@@ -80,7 +86,7 @@ impl<'a> Folder for ExpandAllocatorDirectives<'a> {\n                 span: None,\n                 allow_internal_unstable: true,\n                 allow_internal_unsafe: false,\n-            }\n+            },\n         });\n         let span = item.span.with_ctxt(SyntaxContext::empty().apply_mark(mark));\n         let ecfg = ExpansionConfig::default(name.to_string());\n@@ -91,10 +97,7 @@ impl<'a> Folder for ExpandAllocatorDirectives<'a> {\n             core: Ident::from_str(\"core\"),\n             cx: ExtCtxt::new(self.sess, ecfg, self.resolver),\n         };\n-        let super_path = f.cx.path(f.span, vec![\n-            Ident::from_str(\"super\"),\n-            f.global,\n-        ]);\n+        let super_path = f.cx.path(f.span, vec![Ident::from_str(\"super\"), f.global]);\n         let mut items = vec![\n             f.cx.item_extern_crate(f.span, f.core),\n             f.cx.item_use_simple(\n@@ -114,7 +117,7 @@ impl<'a> Folder for ExpandAllocatorDirectives<'a> {\n         let mut ret = SmallVector::new();\n         ret.push(item);\n         ret.push(module);\n-        return ret\n+        return ret;\n     }\n \n     fn fold_mac(&mut self, mac: Mac) -> Mac {\n@@ -139,30 +142,39 @@ impl<'a> AllocFnFactory<'a> {\n             i += 1;\n             name\n         };\n-        let args = method.inputs.iter().map(|ty| {\n-            self.arg_ty(ty, &mut abi_args, mk)\n-        }).collect();\n+        let args = method\n+            .inputs\n+            .iter()\n+            .map(|ty| self.arg_ty(ty, &mut abi_args, mk))\n+            .collect();\n         let result = self.call_allocator(method.name, args);\n         let (output_ty, output_expr) = self.ret_ty(&method.output, result);\n-        let kind = ItemKind::Fn(self.cx.fn_decl(abi_args, ast::FunctionRetTy::Ty(output_ty)),\n-                                Unsafety::Unsafe,\n-                                dummy_spanned(Constness::NotConst),\n-                                Abi::Rust,\n-                                Generics::default(),\n-                                self.cx.block_expr(output_expr));\n-        self.cx.item(self.span,\n-                     Ident::from_str(&self.kind.fn_name(method.name)),\n-                     self.attrs(),\n-                     kind)\n+        let kind = ItemKind::Fn(\n+            self.cx.fn_decl(abi_args, ast::FunctionRetTy::Ty(output_ty)),\n+            Unsafety::Unsafe,\n+            dummy_spanned(Constness::NotConst),\n+            Abi::Rust,\n+            Generics::default(),\n+            self.cx.block_expr(output_expr),\n+        );\n+        self.cx.item(\n+            self.span,\n+            Ident::from_str(&self.kind.fn_name(method.name)),\n+            self.attrs(),\n+            kind,\n+        )\n     }\n \n     fn call_allocator(&self, method: &str, mut args: Vec<P<Expr>>) -> P<Expr> {\n-        let method = self.cx.path(self.span, vec![\n-            self.core,\n-            Ident::from_str(\"alloc\"),\n-            Ident::from_str(\"GlobalAlloc\"),\n-            Ident::from_str(method),\n-        ]);\n+        let method = self.cx.path(\n+            self.span,\n+            vec![\n+                self.core,\n+                Ident::from_str(\"alloc\"),\n+                Ident::from_str(\"GlobalAlloc\"),\n+                Ident::from_str(method),\n+            ],\n+        );\n         let method = self.cx.expr_path(method);\n         let allocator = self.cx.path_ident(self.span, self.global);\n         let allocator = self.cx.expr_path(allocator);\n@@ -189,10 +201,12 @@ impl<'a> AllocFnFactory<'a> {\n         ]\n     }\n \n-    fn arg_ty(&self,\n-              ty: &AllocatorTy,\n-              args: &mut Vec<Arg>,\n-              ident: &mut FnMut() -> Ident) -> P<Expr> {\n+    fn arg_ty(\n+        &self,\n+        ty: &AllocatorTy,\n+        args: &mut Vec<Arg>,\n+        ident: &mut FnMut() -> Ident,\n+    ) -> P<Expr> {\n         match *ty {\n             AllocatorTy::Layout => {\n                 let usize = self.cx.path_ident(self.span, Ident::from_str(\"usize\"));\n@@ -202,18 +216,19 @@ impl<'a> AllocFnFactory<'a> {\n                 args.push(self.cx.arg(self.span, size, ty_usize.clone()));\n                 args.push(self.cx.arg(self.span, align, ty_usize));\n \n-                let layout_new = self.cx.path(self.span, vec![\n-                    self.core,\n-                    Ident::from_str(\"alloc\"),\n-                    Ident::from_str(\"Layout\"),\n-                    Ident::from_str(\"from_size_align_unchecked\"),\n-                ]);\n+                let layout_new = self.cx.path(\n+                    self.span,\n+                    vec![\n+                        self.core,\n+                        Ident::from_str(\"alloc\"),\n+                        Ident::from_str(\"Layout\"),\n+                        Ident::from_str(\"from_size_align_unchecked\"),\n+                    ],\n+                );\n                 let layout_new = self.cx.expr_path(layout_new);\n                 let size = self.cx.expr_ident(self.span, size);\n                 let align = self.cx.expr_ident(self.span, align);\n-                let layout = self.cx.expr_call(self.span,\n-                                               layout_new,\n-                                               vec![size, align]);\n+                let layout = self.cx.expr_call(self.span, layout_new, vec![size, align]);\n                 layout\n             }\n \n@@ -230,9 +245,7 @@ impl<'a> AllocFnFactory<'a> {\n                 self.cx.expr_ident(self.span, ident)\n             }\n \n-            AllocatorTy::ResultPtr |\n-            AllocatorTy::Bang |\n-            AllocatorTy::Unit => {\n+            AllocatorTy::ResultPtr | AllocatorTy::Bang | AllocatorTy::Unit => {\n                 panic!(\"can't convert AllocatorTy to an argument\")\n             }\n         }\n@@ -249,17 +262,11 @@ impl<'a> AllocFnFactory<'a> {\n                 (self.ptr_u8(), expr)\n             }\n \n-            AllocatorTy::Bang => {\n-                (self.cx.ty(self.span, TyKind::Never), expr)\n-            }\n+            AllocatorTy::Bang => (self.cx.ty(self.span, TyKind::Never), expr),\n \n-            AllocatorTy::Unit => {\n-                (self.cx.ty(self.span, TyKind::Tup(Vec::new())), expr)\n-            }\n+            AllocatorTy::Unit => (self.cx.ty(self.span, TyKind::Tup(Vec::new())), expr),\n \n-            AllocatorTy::Layout |\n-            AllocatorTy::Usize |\n-            AllocatorTy::Ptr => {\n+            AllocatorTy::Layout | AllocatorTy::Usize | AllocatorTy::Ptr => {\n                 panic!(\"can't convert AllocatorTy to an output\")\n             }\n         }\n@@ -277,11 +284,14 @@ impl<'a> AllocFnFactory<'a> {\n     }\n \n     fn ptr_opaque(&self) -> P<Ty> {\n-        let opaque = self.cx.path(self.span, vec![\n-            self.core,\n-            Ident::from_str(\"alloc\"),\n-            Ident::from_str(\"Opaque\"),\n-        ]);\n+        let opaque = self.cx.path(\n+            self.span,\n+            vec![\n+                self.core,\n+                Ident::from_str(\"alloc\"),\n+                Ident::from_str(\"Opaque\"),\n+            ],\n+        );\n         let ty_opaque = self.cx.ty_path(opaque);\n         self.cx.ty_ptr(self.span, ty_opaque, Mutability::Mutable)\n     }"}]}