{"sha": "b37317b028cd0d4b60126e0bcf1402e60018f891", "node_id": "C_kwDOAAsO6NoAKGIzNzMxN2IwMjhjZDBkNGI2MDEyNmUwYmNmMTQwMmU2MDAxOGY4OTE", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-01-06T07:54:35Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-03-16T17:18:29Z"}, "message": "Check if there are any overlapping patterns between equal arm bodies in `match_same_arm`", "tree": {"sha": "4fb2b5eb4dc31f4e72f45091a81e05e2c3adfa10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4fb2b5eb4dc31f4e72f45091a81e05e2c3adfa10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b37317b028cd0d4b60126e0bcf1402e60018f891", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b37317b028cd0d4b60126e0bcf1402e60018f891", "html_url": "https://github.com/rust-lang/rust/commit/b37317b028cd0d4b60126e0bcf1402e60018f891", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b37317b028cd0d4b60126e0bcf1402e60018f891/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d23ddab82d74cf6bfd72d282254a5c19c9631ef2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d23ddab82d74cf6bfd72d282254a5c19c9631ef2", "html_url": "https://github.com/rust-lang/rust/commit/d23ddab82d74cf6bfd72d282254a5c19c9631ef2"}], "stats": {"total": 266, "additions": 256, "deletions": 10}, "files": [{"sha": "6617cf4e47f829a1aa97c3137e690171b5dc1e46", "filename": "clippy_lints/src/matches/match_same_arms.rs", "status": "modified", "additions": 243, "deletions": 10, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/b37317b028cd0d4b60126e0bcf1402e60018f891/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b37317b028cd0d4b60126e0bcf1402e60018f891/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs?ref=b37317b028cd0d4b60126e0bcf1402e60018f891", "patch": "@@ -1,19 +1,53 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet;\n use clippy_utils::{path_to_local, search_same, SpanlessEq, SpanlessHash};\n-use rustc_hir::{Arm, Expr, HirId, HirIdMap, HirIdSet, Pat, PatKind};\n+use rustc_ast::ast::LitKind;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::{Arm, Expr, ExprKind, HirId, HirIdMap, HirIdSet, Pat, PatKind, RangeEnd};\n use rustc_lint::LateContext;\n+use rustc_span::Symbol;\n use std::collections::hash_map::Entry;\n \n use super::MATCH_SAME_ARMS;\n \n-pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>]) {\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>]) {\n     let hash = |&(_, arm): &(usize, &Arm<'_>)| -> u64 {\n         let mut h = SpanlessHash::new(cx);\n         h.hash_expr(arm.body);\n         h.finish()\n     };\n \n+    let resolved_pats: Vec<_> = arms.iter().map(|a| ResolvedPat::from_pat(cx, a.pat)).collect();\n+\n+    // The furthast forwards a pattern can move without semantic changes\n+    let forwards_blocking_idxs: Vec<_> = resolved_pats\n+        .iter()\n+        .enumerate()\n+        .map(|(i, pat)| {\n+            resolved_pats[i + 1..]\n+                .iter()\n+                .enumerate()\n+                .find_map(|(j, other)| pat.can_also_match(other).then(|| i + 1 + j))\n+                .unwrap_or(resolved_pats.len())\n+        })\n+        .collect();\n+\n+    // The furthast backwards a pattern can move without semantic changes\n+    let backwards_blocking_idxs: Vec<_> = resolved_pats\n+        .iter()\n+        .enumerate()\n+        .map(|(i, pat)| {\n+            resolved_pats[..i]\n+                .iter()\n+                .enumerate()\n+                .rev()\n+                .zip(forwards_blocking_idxs[..i].iter().copied().rev())\n+                .skip_while(|&(_, forward_block)| forward_block > i)\n+                .find_map(|((j, other), forward_block)| (forward_block == i || pat.can_also_match(other)).then(|| j))\n+                .unwrap_or(0)\n+        })\n+        .collect();\n+\n     let eq = |&(lindex, lhs): &(usize, &Arm<'_>), &(rindex, rhs): &(usize, &Arm<'_>)| -> bool {\n         let min_index = usize::min(lindex, rindex);\n         let max_index = usize::max(lindex, rindex);\n@@ -42,14 +76,16 @@ pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>]) {\n             }\n         };\n         // Arms with a guard are ignored, those can\u2019t always be merged together\n-        // This is also the case for arms in-between each there is an arm with a guard\n-        (min_index..=max_index).all(|index| arms[index].guard.is_none())\n-            && SpanlessEq::new(cx)\n-                .expr_fallback(eq_fallback)\n-                .eq_expr(lhs.body, rhs.body)\n-            // these checks could be removed to allow unused bindings\n-            && bindings_eq(lhs.pat, local_map.keys().copied().collect())\n-            && bindings_eq(rhs.pat, local_map.values().copied().collect())\n+        // If both arms overlap with an arm in between then these can't be merged either.\n+        !(backwards_blocking_idxs[max_index] > min_index && forwards_blocking_idxs[min_index] < max_index)\n+                && lhs.guard.is_none()\n+                && rhs.guard.is_none()\n+                && SpanlessEq::new(cx)\n+                    .expr_fallback(eq_fallback)\n+                    .eq_expr(lhs.body, rhs.body)\n+                // these checks could be removed to allow unused bindings\n+                && bindings_eq(lhs.pat, local_map.keys().copied().collect())\n+                && bindings_eq(rhs.pat, local_map.values().copied().collect())\n     };\n \n     let indexed_arms: Vec<(usize, &Arm<'_>)> = arms.iter().enumerate().collect();\n@@ -92,6 +128,203 @@ pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>]) {\n     }\n }\n \n+#[derive(Debug)]\n+enum ResolvedPat<'hir> {\n+    Wild,\n+    Struct(Option<DefId>, Vec<(Symbol, ResolvedPat<'hir>)>),\n+    Sequence(Option<DefId>, Vec<ResolvedPat<'hir>>, Option<usize>),\n+    Or(Vec<ResolvedPat<'hir>>),\n+    Path(Option<DefId>),\n+    LitStr(Symbol),\n+    LitBytes(&'hir [u8]),\n+    LitInt(u128),\n+    LitBool(bool),\n+    Range(PatRange),\n+}\n+\n+#[derive(Debug)]\n+struct PatRange {\n+    start: u128,\n+    end: u128,\n+    bounds: RangeEnd,\n+}\n+impl PatRange {\n+    fn contains(&self, x: u128) -> bool {\n+        x >= self.start\n+            && match self.bounds {\n+                RangeEnd::Included => x <= self.end,\n+                RangeEnd::Excluded => x < self.end,\n+            }\n+    }\n+\n+    fn overlaps(&self, other: &Self) -> bool {\n+        !(self.is_empty() || other.is_empty())\n+            && match self.bounds {\n+                RangeEnd::Included => self.end >= other.start,\n+                RangeEnd::Excluded => self.end > other.start,\n+            }\n+            && match other.bounds {\n+                RangeEnd::Included => self.start <= other.end,\n+                RangeEnd::Excluded => self.start < other.end,\n+            }\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        match self.bounds {\n+            RangeEnd::Included => false,\n+            RangeEnd::Excluded => self.start == self.end,\n+        }\n+    }\n+}\n+\n+impl<'hir> ResolvedPat<'hir> {\n+    fn from_pat(cx: &LateContext<'_>, pat: &'hir Pat<'_>) -> Self {\n+        match pat.kind {\n+            PatKind::Wild | PatKind::Binding(.., None) => Self::Wild,\n+            PatKind::Binding(.., Some(pat)) | PatKind::Box(pat) | PatKind::Ref(pat, _) => Self::from_pat(cx, pat),\n+            PatKind::Struct(ref path, fields, _) => {\n+                let mut fields: Vec<_> = fields\n+                    .iter()\n+                    .map(|f| (f.ident.name, Self::from_pat(cx, f.pat)))\n+                    .collect();\n+                fields.sort_by_key(|&(name, _)| name);\n+                Self::Struct(cx.qpath_res(path, pat.hir_id).opt_def_id(), fields)\n+            },\n+            PatKind::TupleStruct(ref path, pats, wild_idx) => Self::Sequence(\n+                cx.qpath_res(path, pat.hir_id).opt_def_id(),\n+                pats.iter().map(|pat| Self::from_pat(cx, pat)).collect(),\n+                wild_idx,\n+            ),\n+            PatKind::Or(pats) => Self::Or(pats.iter().map(|pat| Self::from_pat(cx, pat)).collect()),\n+            PatKind::Path(ref path) => Self::Path(cx.qpath_res(path, pat.hir_id).opt_def_id()),\n+            PatKind::Tuple(pats, wild_idx) => {\n+                Self::Sequence(None, pats.iter().map(|pat| Self::from_pat(cx, pat)).collect(), wild_idx)\n+            },\n+            PatKind::Lit(e) => match &e.kind {\n+                ExprKind::Lit(lit) => match lit.node {\n+                    LitKind::Str(sym, _) => Self::LitStr(sym),\n+                    LitKind::ByteStr(ref bytes) => Self::LitBytes(&**bytes),\n+                    LitKind::Byte(val) => Self::LitInt(val.into()),\n+                    LitKind::Char(val) => Self::LitInt(val.into()),\n+                    LitKind::Int(val, _) => Self::LitInt(val),\n+                    LitKind::Bool(val) => Self::LitBool(val),\n+                    LitKind::Float(..) | LitKind::Err(_) => Self::Wild,\n+                },\n+                _ => Self::Wild,\n+            },\n+            PatKind::Range(start, end, bounds) => {\n+                let start = match start {\n+                    None => 0,\n+                    Some(e) => match &e.kind {\n+                        ExprKind::Lit(lit) => match lit.node {\n+                            LitKind::Int(val, _) => val,\n+                            LitKind::Char(val) => val.into(),\n+                            LitKind::Byte(val) => val.into(),\n+                            _ => return Self::Wild,\n+                        },\n+                        _ => return Self::Wild,\n+                    },\n+                };\n+                let (end, bounds) = match end {\n+                    None => (u128::MAX, RangeEnd::Included),\n+                    Some(e) => match &e.kind {\n+                        ExprKind::Lit(lit) => match lit.node {\n+                            LitKind::Int(val, _) => (val, bounds),\n+                            LitKind::Char(val) => (val.into(), bounds),\n+                            LitKind::Byte(val) => (val.into(), bounds),\n+                            _ => return Self::Wild,\n+                        },\n+                        _ => return Self::Wild,\n+                    },\n+                };\n+                Self::Range(PatRange { start, end, bounds })\n+            },\n+            PatKind::Slice(pats, wild, pats2) => Self::Sequence(\n+                None,\n+                pats.iter()\n+                    .chain(pats2.iter())\n+                    .map(|pat| Self::from_pat(cx, pat))\n+                    .collect(),\n+                wild.map(|_| pats.len()),\n+            ),\n+        }\n+    }\n+\n+    /// Checks if two patterns overlap in the values they can match assuming they are for the same\n+    /// type.\n+    fn can_also_match(&self, other: &Self) -> bool {\n+        match (self, other) {\n+            (Self::Wild, _) | (_, Self::Wild) => true,\n+            (Self::Or(pats), other) | (other, Self::Or(pats)) => pats.iter().any(|pat| pat.can_also_match(other)),\n+            (Self::Struct(lpath, lfields), Self::Struct(rpath, rfields)) => {\n+                if lpath != rpath {\n+                    return false;\n+                }\n+                let mut rfields = rfields.iter();\n+                let mut rfield = match rfields.next() {\n+                    Some(x) => x,\n+                    None => return true,\n+                };\n+                'outer: for lfield in lfields {\n+                    loop {\n+                        if lfield.0 < rfield.0 {\n+                            continue 'outer;\n+                        } else if lfield.0 > rfield.0 {\n+                            rfield = match rfields.next() {\n+                                Some(x) => x,\n+                                None => return true,\n+                            };\n+                        } else if !lfield.1.can_also_match(&rfield.1) {\n+                            return false;\n+                        } else {\n+                            rfield = match rfields.next() {\n+                                Some(x) => x,\n+                                None => return true,\n+                            };\n+                            continue 'outer;\n+                        }\n+                    }\n+                }\n+                true\n+            },\n+            (Self::Sequence(lpath, lpats, lwild_idx), Self::Sequence(rpath, rpats, rwild_idx)) => {\n+                if lpath != rpath {\n+                    return false;\n+                }\n+\n+                let (lpats_start, lpats_end) = lwild_idx\n+                    .or(*rwild_idx)\n+                    .map_or((&**lpats, [].as_slice()), |idx| lpats.split_at(idx));\n+                let (rpats_start, rpats_end) = rwild_idx\n+                    .or(*lwild_idx)\n+                    .map_or((&**rpats, [].as_slice()), |idx| rpats.split_at(idx));\n+\n+                lpats_start\n+                    .iter()\n+                    .zip(rpats_start.iter())\n+                    .all(|(lpat, rpat)| lpat.can_also_match(rpat))\n+                    // `lpats_end` and `rpats_end` lengths may be disjointed, so start from the end and ignore any\n+                    // extras.\n+                    && lpats_end\n+                    .iter()\n+                    .rev()\n+                    .zip(rpats_end.iter().rev())\n+                    .all(|(lpat, rpat)| lpat.can_also_match(rpat))\n+            },\n+            (Self::Path(x), Self::Path(y)) => x == y,\n+            (Self::LitStr(x), Self::LitStr(y)) => x == y,\n+            (Self::LitBytes(x), Self::LitBytes(y)) => x == y,\n+            (Self::LitInt(x), Self::LitInt(y)) => x == y,\n+            (Self::LitBool(x), Self::LitBool(y)) => x == y,\n+            (Self::Range(x), Self::Range(y)) => x.overlaps(y),\n+            (Self::Range(range), Self::LitInt(x)) | (Self::LitInt(x), Self::Range(range)) => range.contains(*x),\n+\n+            // Todo: Lit* with Path, Range with Path, LitBytes with Sequence\n+            _ => true,\n+        }\n+    }\n+}\n+\n fn pat_contains_local(pat: &Pat<'_>, id: HirId) -> bool {\n     let mut result = false;\n     pat.walk_short(|p| {"}, {"sha": "6dc6c4172ee0939e36a6e36b76f69cfce4674c4e", "filename": "tests/ui/match_same_arms2.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b37317b028cd0d4b60126e0bcf1402e60018f891/tests%2Fui%2Fmatch_same_arms2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b37317b028cd0d4b60126e0bcf1402e60018f891/tests%2Fui%2Fmatch_same_arms2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_same_arms2.rs?ref=b37317b028cd0d4b60126e0bcf1402e60018f891", "patch": "@@ -174,4 +174,17 @@ fn main() {\n         Some(2) => 2,\n         _ => 1,\n     };\n+\n+    enum Foo {\n+        X(u32),\n+        Y(u32),\n+        Z(u32),\n+    }\n+\n+    let _ = match Foo::X(0) {\n+        Foo::X(0) => 1,\n+        Foo::X(_) | Foo::Y(_) | Foo::Z(0) => 2,\n+        Foo::Z(_) => 1,\n+        _ => 0,\n+    };\n }"}]}