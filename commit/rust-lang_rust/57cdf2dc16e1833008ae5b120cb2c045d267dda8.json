{"sha": "57cdf2dc16e1833008ae5b120cb2c045d267dda8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3Y2RmMmRjMTZlMTgzMzAwOGFlNWIxMjBjYjJjMDQ1ZDI2N2RkYTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-03T16:41:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-03T16:41:26Z"}, "message": "Auto merge of #4841 - phaylon:pattern-type-mismatch, r=flip1995\n\nAdded restriction lint: pattern-type-mismatch\n\nchangelog: Added a new restriction lint `pattern-type-mismatch`. This lint is especially helpful for beginners learning about the magic behind pattern matching. (This explanation might be worth to include in the next changelog.)", "tree": {"sha": "fc61082fd0ccea7433ff7a7e43d07853d08629de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc61082fd0ccea7433ff7a7e43d07853d08629de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57cdf2dc16e1833008ae5b120cb2c045d267dda8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57cdf2dc16e1833008ae5b120cb2c045d267dda8", "html_url": "https://github.com/rust-lang/rust/commit/57cdf2dc16e1833008ae5b120cb2c045d267dda8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57cdf2dc16e1833008ae5b120cb2c045d267dda8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fff8e7291381327f5106120b98d7f9585a493cad", "url": "https://api.github.com/repos/rust-lang/rust/commits/fff8e7291381327f5106120b98d7f9585a493cad", "html_url": "https://github.com/rust-lang/rust/commit/fff8e7291381327f5106120b98d7f9585a493cad"}, {"sha": "c0fd452840c7cc53b3396268f62ed2a0a2e8fef7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0fd452840c7cc53b3396268f62ed2a0a2e8fef7", "html_url": "https://github.com/rust-lang/rust/commit/c0fd452840c7cc53b3396268f62ed2a0a2e8fef7"}], "stats": {"total": 910, "additions": 910, "deletions": 0}, "files": [{"sha": "ed8f16e65bb9a8e1a2372c7ee7b6098ef1feddc0", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/57cdf2dc16e1833008ae5b120cb2c045d267dda8/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/57cdf2dc16e1833008ae5b120cb2c045d267dda8/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=57cdf2dc16e1833008ae5b120cb2c045d267dda8", "patch": "@@ -1588,6 +1588,7 @@ Released 2018-09-13\n [`panicking_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#panicking_unwrap\n [`partialeq_ne_impl`]: https://rust-lang.github.io/rust-clippy/master/index.html#partialeq_ne_impl\n [`path_buf_push_overwrite`]: https://rust-lang.github.io/rust-clippy/master/index.html#path_buf_push_overwrite\n+[`pattern_type_mismatch`]: https://rust-lang.github.io/rust-clippy/master/index.html#pattern_type_mismatch\n [`possible_missing_comma`]: https://rust-lang.github.io/rust-clippy/master/index.html#possible_missing_comma\n [`precedence`]: https://rust-lang.github.io/rust-clippy/master/index.html#precedence\n [`print_literal`]: https://rust-lang.github.io/rust-clippy/master/index.html#print_literal"}, {"sha": "1d5be893ffba2565341d9df10f2a8fca7301c5c4", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/57cdf2dc16e1833008ae5b120cb2c045d267dda8/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57cdf2dc16e1833008ae5b120cb2c045d267dda8/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=57cdf2dc16e1833008ae5b120cb2c045d267dda8", "patch": "@@ -268,6 +268,7 @@ mod overflow_check_conditional;\n mod panic_unimplemented;\n mod partialeq_ne_impl;\n mod path_buf_push_overwrite;\n+mod pattern_type_mismatch;\n mod precedence;\n mod ptr;\n mod ptr_offset_with_cast;\n@@ -741,6 +742,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &panic_unimplemented::UNREACHABLE,\n         &partialeq_ne_impl::PARTIALEQ_NE_IMPL,\n         &path_buf_push_overwrite::PATH_BUF_PUSH_OVERWRITE,\n+        &pattern_type_mismatch::PATTERN_TYPE_MISMATCH,\n         &precedence::PRECEDENCE,\n         &ptr::CMP_NULL,\n         &ptr::MUT_FROM_REF,\n@@ -1065,6 +1067,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(|| box unnested_or_patterns::UnnestedOrPatterns);\n     store.register_late_pass(|| box macro_use::MacroUseImports::default());\n     store.register_late_pass(|| box map_identity::MapIdentity);\n+    store.register_late_pass(|| box pattern_type_mismatch::PatternTypeMismatch);\n \n     store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         LintId::of(&arithmetic::FLOAT_ARITHMETIC),\n@@ -1098,6 +1101,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&panic_unimplemented::TODO),\n         LintId::of(&panic_unimplemented::UNIMPLEMENTED),\n         LintId::of(&panic_unimplemented::UNREACHABLE),\n+        LintId::of(&pattern_type_mismatch::PATTERN_TYPE_MISMATCH),\n         LintId::of(&shadow::SHADOW_REUSE),\n         LintId::of(&shadow::SHADOW_SAME),\n         LintId::of(&strings::STRING_ADD),"}, {"sha": "a49dc87c0b47f5697b2d5c28bbc58714aad030b5", "filename": "clippy_lints/src/pattern_type_mismatch.rs", "status": "added", "additions": 311, "deletions": 0, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/57cdf2dc16e1833008ae5b120cb2c045d267dda8/clippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57cdf2dc16e1833008ae5b120cb2c045d267dda8/clippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpattern_type_mismatch.rs?ref=57cdf2dc16e1833008ae5b120cb2c045d267dda8", "patch": "@@ -0,0 +1,311 @@\n+use crate::utils::{last_path_segment, span_lint_and_help};\n+use rustc_hir::{\n+    intravisit, Body, Expr, ExprKind, FieldPat, FnDecl, HirId, LocalSource, MatchSource, Mutability, Pat, PatKind,\n+    QPath, Stmt, StmtKind,\n+};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty::subst::SubstsRef;\n+use rustc_middle::ty::{AdtDef, FieldDef, Ty, TyKind, VariantDef};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for patterns that aren't exact representations of the types\n+    /// they are applied to.\n+    ///\n+    /// To satisfy this lint, you will have to adjust either the expression that is matched\n+    /// against or the pattern itself, as well as the bindings that are introduced by the\n+    /// adjusted patterns. For matching you will have to either dereference the expression\n+    /// with the `*` operator, or amend the patterns to explicitly match against `&<pattern>`\n+    /// or `&mut <pattern>` depending on the reference mutability. For the bindings you need\n+    /// to use the inverse. You can leave them as plain bindings if you wish for the value\n+    /// to be copied, but you must use `ref mut <variable>` or `ref <variable>` to construct\n+    /// a reference into the matched structure.\n+    ///\n+    /// If you are looking for a way to learn about ownership semantics in more detail, it\n+    /// is recommended to look at IDE options available to you to highlight types, lifetimes\n+    /// and reference semantics in your code. The available tooling would expose these things\n+    /// in a general way even outside of the various pattern matching mechanics. Of course\n+    /// this lint can still be used to highlight areas of interest and ensure a good understanding\n+    /// of ownership semantics.\n+    ///\n+    /// **Why is this bad?** It isn't bad in general. But in some contexts it can be desirable\n+    /// because it increases ownership hints in the code, and will guard against some changes\n+    /// in ownership.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// This example shows the basic adjustments necessary to satisfy the lint. Note how\n+    /// the matched expression is explicitly dereferenced with `*` and the `inner` variable\n+    /// is bound to a shared borrow via `ref inner`.\n+    ///\n+    /// ```rust,ignore\n+    /// // Bad\n+    /// let value = &Some(Box::new(23));\n+    /// match value {\n+    ///     Some(inner) => println!(\"{}\", inner),\n+    ///     None => println!(\"none\"),\n+    /// }\n+    ///\n+    /// // Good\n+    /// let value = &Some(Box::new(23));\n+    /// match *value {\n+    ///     Some(ref inner) => println!(\"{}\", inner),\n+    ///     None => println!(\"none\"),\n+    /// }\n+    /// ```\n+    ///\n+    /// The following example demonstrates one of the advantages of the more verbose style.\n+    /// Note how the second version uses `ref mut a` to explicitly declare `a` a shared mutable\n+    /// borrow, while `b` is simply taken by value. This ensures that the loop body cannot\n+    /// accidentally modify the wrong part of the structure.\n+    ///\n+    /// ```rust,ignore\n+    /// // Bad\n+    /// let mut values = vec![(2, 3), (3, 4)];\n+    /// for (a, b) in &mut values {\n+    ///     *a += *b;\n+    /// }\n+    ///\n+    /// // Good\n+    /// let mut values = vec![(2, 3), (3, 4)];\n+    /// for &mut (ref mut a, b) in &mut values {\n+    ///     *a += b;\n+    /// }\n+    /// ```\n+    pub PATTERN_TYPE_MISMATCH,\n+    restriction,\n+    \"type of pattern does not match the expression type\"\n+}\n+\n+declare_lint_pass!(PatternTypeMismatch => [PATTERN_TYPE_MISMATCH]);\n+\n+impl<'tcx> LateLintPass<'tcx> for PatternTypeMismatch {\n+    fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n+        if let StmtKind::Local(ref local) = stmt.kind {\n+            if let Some(init) = &local.init {\n+                if let Some(init_ty) = cx.tables().node_type_opt(init.hir_id) {\n+                    let pat = &local.pat;\n+                    if in_external_macro(cx.sess(), pat.span) {\n+                        return;\n+                    }\n+                    let deref_possible = match local.source {\n+                        LocalSource::Normal => DerefPossible::Possible,\n+                        _ => DerefPossible::Impossible,\n+                    };\n+                    apply_lint(cx, pat, init_ty, deref_possible);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if let ExprKind::Match(ref expr, arms, source) = expr.kind {\n+            match source {\n+                MatchSource::Normal | MatchSource::IfLetDesugar { .. } | MatchSource::WhileLetDesugar => {\n+                    if let Some(expr_ty) = cx.tables().node_type_opt(expr.hir_id) {\n+                        'pattern_checks: for arm in arms {\n+                            let pat = &arm.pat;\n+                            if in_external_macro(cx.sess(), pat.span) {\n+                                continue 'pattern_checks;\n+                            }\n+                            if apply_lint(cx, pat, expr_ty, DerefPossible::Possible) {\n+                                break 'pattern_checks;\n+                            }\n+                        }\n+                    }\n+                },\n+                _ => (),\n+            }\n+        }\n+    }\n+\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'tcx>,\n+        _: intravisit::FnKind<'tcx>,\n+        _: &'tcx FnDecl<'_>,\n+        body: &'tcx Body<'_>,\n+        _: Span,\n+        hir_id: HirId,\n+    ) {\n+        if let Some(fn_sig) = cx.tables().liberated_fn_sigs().get(hir_id) {\n+            for (param, ty) in body.params.iter().zip(fn_sig.inputs().iter()) {\n+                apply_lint(cx, &param.pat, ty, DerefPossible::Impossible);\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n+enum DerefPossible {\n+    Possible,\n+    Impossible,\n+}\n+\n+fn apply_lint<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'_>, expr_ty: Ty<'tcx>, deref_possible: DerefPossible) -> bool {\n+    let maybe_mismatch = find_first_mismatch(cx, pat, expr_ty, Level::Top);\n+    if let Some((span, mutability, level)) = maybe_mismatch {\n+        span_lint_and_help(\n+            cx,\n+            PATTERN_TYPE_MISMATCH,\n+            span,\n+            \"type of pattern does not match the expression type\",\n+            None,\n+            &format!(\n+                \"{}explicitly match against a `{}` pattern and adjust the enclosed variable bindings\",\n+                match (deref_possible, level) {\n+                    (DerefPossible::Possible, Level::Top) => \"use `*` to dereference the match expression or \",\n+                    _ => \"\",\n+                },\n+                match mutability {\n+                    Mutability::Mut => \"&mut _\",\n+                    Mutability::Not => \"&_\",\n+                },\n+            ),\n+        );\n+        true\n+    } else {\n+        false\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone)]\n+enum Level {\n+    Top,\n+    Lower,\n+}\n+\n+#[allow(rustc::usage_of_ty_tykind)]\n+fn find_first_mismatch<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &Pat<'_>,\n+    ty: Ty<'tcx>,\n+    level: Level,\n+) -> Option<(Span, Mutability, Level)> {\n+    if let PatKind::Ref(ref sub_pat, _) = pat.kind {\n+        if let TyKind::Ref(_, sub_ty, _) = ty.kind {\n+            return find_first_mismatch(cx, sub_pat, sub_ty, Level::Lower);\n+        }\n+    }\n+\n+    if let TyKind::Ref(_, _, mutability) = ty.kind {\n+        if is_non_ref_pattern(&pat.kind) {\n+            return Some((pat.span, mutability, level));\n+        }\n+    }\n+\n+    if let PatKind::Struct(ref qpath, ref field_pats, _) = pat.kind {\n+        if let TyKind::Adt(ref adt_def, ref substs_ref) = ty.kind {\n+            if let Some(variant) = get_variant(adt_def, qpath) {\n+                let field_defs = &variant.fields;\n+                return find_first_mismatch_in_struct(cx, field_pats, field_defs, substs_ref);\n+            }\n+        }\n+    }\n+\n+    if let PatKind::TupleStruct(ref qpath, ref pats, _) = pat.kind {\n+        if let TyKind::Adt(ref adt_def, ref substs_ref) = ty.kind {\n+            if let Some(variant) = get_variant(adt_def, qpath) {\n+                let field_defs = &variant.fields;\n+                let ty_iter = field_defs.iter().map(|field_def| field_def.ty(cx.tcx, substs_ref));\n+                return find_first_mismatch_in_tuple(cx, pats, ty_iter);\n+            }\n+        }\n+    }\n+\n+    if let PatKind::Tuple(ref pats, _) = pat.kind {\n+        if let TyKind::Tuple(..) = ty.kind {\n+            return find_first_mismatch_in_tuple(cx, pats, ty.tuple_fields());\n+        }\n+    }\n+\n+    if let PatKind::Or(sub_pats) = pat.kind {\n+        for pat in sub_pats {\n+            let maybe_mismatch = find_first_mismatch(cx, pat, ty, level);\n+            if let Some(mismatch) = maybe_mismatch {\n+                return Some(mismatch);\n+            }\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn get_variant<'a>(adt_def: &'a AdtDef, qpath: &QPath<'_>) -> Option<&'a VariantDef> {\n+    if adt_def.is_struct() {\n+        if let Some(variant) = adt_def.variants.iter().next() {\n+            return Some(variant);\n+        }\n+    }\n+\n+    if adt_def.is_enum() {\n+        let pat_ident = last_path_segment(qpath).ident;\n+        for variant in &adt_def.variants {\n+            if variant.ident == pat_ident {\n+                return Some(variant);\n+            }\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn find_first_mismatch_in_tuple<'tcx, I>(\n+    cx: &LateContext<'tcx>,\n+    pats: &[&Pat<'_>],\n+    ty_iter_src: I,\n+) -> Option<(Span, Mutability, Level)>\n+where\n+    I: IntoIterator<Item = Ty<'tcx>>,\n+{\n+    let mut field_tys = ty_iter_src.into_iter();\n+    'fields: for pat in pats {\n+        let field_ty = if let Some(ty) = field_tys.next() {\n+            ty\n+        } else {\n+            break 'fields;\n+        };\n+\n+        let maybe_mismatch = find_first_mismatch(cx, pat, field_ty, Level::Lower);\n+        if let Some(mismatch) = maybe_mismatch {\n+            return Some(mismatch);\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn find_first_mismatch_in_struct<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    field_pats: &[FieldPat<'_>],\n+    field_defs: &[FieldDef],\n+    substs_ref: SubstsRef<'tcx>,\n+) -> Option<(Span, Mutability, Level)> {\n+    for field_pat in field_pats {\n+        'definitions: for field_def in field_defs {\n+            if field_pat.ident == field_def.ident {\n+                let field_ty = field_def.ty(cx.tcx, substs_ref);\n+                let pat = &field_pat.pat;\n+                let maybe_mismatch = find_first_mismatch(cx, pat, field_ty, Level::Lower);\n+                if let Some(mismatch) = maybe_mismatch {\n+                    return Some(mismatch);\n+                }\n+                break 'definitions;\n+            }\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn is_non_ref_pattern(pat_kind: &PatKind<'_>) -> bool {\n+    match pat_kind {\n+        PatKind::Struct(..) | PatKind::Tuple(..) | PatKind::TupleStruct(..) | PatKind::Path(..) => true,\n+        PatKind::Or(sub_pats) => sub_pats.iter().any(|pat| is_non_ref_pattern(&pat.kind)),\n+        _ => false,\n+    }\n+}"}, {"sha": "6402efc252121b7cb09f5eb038498f7b7cdbbb59", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/57cdf2dc16e1833008ae5b120cb2c045d267dda8/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57cdf2dc16e1833008ae5b120cb2c045d267dda8/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=57cdf2dc16e1833008ae5b120cb2c045d267dda8", "patch": "@@ -1697,6 +1697,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"path_buf_push_overwrite\",\n     },\n+    Lint {\n+        name: \"pattern_type_mismatch\",\n+        group: \"restriction\",\n+        desc: \"type of pattern does not match the expression type\",\n+        deprecation: None,\n+        module: \"pattern_type_mismatch\",\n+    },\n     Lint {\n         name: \"possible_missing_comma\",\n         group: \"correctness\","}, {"sha": "9b4f2f1f57934dbd8332c2932bfed5f30836626a", "filename": "tests/ui/pattern_type_mismatch/mutability.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/57cdf2dc16e1833008ae5b120cb2c045d267dda8/tests%2Fui%2Fpattern_type_mismatch%2Fmutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57cdf2dc16e1833008ae5b120cb2c045d267dda8/tests%2Fui%2Fpattern_type_mismatch%2Fmutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern_type_mismatch%2Fmutability.rs?ref=57cdf2dc16e1833008ae5b120cb2c045d267dda8", "patch": "@@ -0,0 +1,40 @@\n+#![allow(clippy::all)]\n+#![warn(clippy::pattern_type_mismatch)]\n+\n+fn main() {}\n+\n+fn should_lint() {\n+    let value = &Some(23);\n+    match value {\n+        Some(_) => (),\n+        _ => (),\n+    }\n+\n+    let value = &mut Some(23);\n+    match value {\n+        Some(_) => (),\n+        _ => (),\n+    }\n+}\n+\n+fn should_not_lint() {\n+    let value = &Some(23);\n+    match value {\n+        &Some(_) => (),\n+        _ => (),\n+    }\n+    match *value {\n+        Some(_) => (),\n+        _ => (),\n+    }\n+\n+    let value = &mut Some(23);\n+    match value {\n+        &mut Some(_) => (),\n+        _ => (),\n+    }\n+    match *value {\n+        Some(_) => (),\n+        _ => (),\n+    }\n+}"}, {"sha": "3421d568365cc98b01afd8189aa6e3d7206752aa", "filename": "tests/ui/pattern_type_mismatch/mutability.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/57cdf2dc16e1833008ae5b120cb2c045d267dda8/tests%2Fui%2Fpattern_type_mismatch%2Fmutability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/57cdf2dc16e1833008ae5b120cb2c045d267dda8/tests%2Fui%2Fpattern_type_mismatch%2Fmutability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern_type_mismatch%2Fmutability.stderr?ref=57cdf2dc16e1833008ae5b120cb2c045d267dda8", "patch": "@@ -0,0 +1,19 @@\n+error: type of pattern does not match the expression type\n+  --> $DIR/mutability.rs:9:9\n+   |\n+LL |         Some(_) => (),\n+   |         ^^^^^^^\n+   |\n+   = note: `-D clippy::pattern-type-mismatch` implied by `-D warnings`\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/mutability.rs:15:9\n+   |\n+LL |         Some(_) => (),\n+   |         ^^^^^^^\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&mut _` pattern and adjust the enclosed variable bindings\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "065ea9fb9b5a4c823ddf37d111f8b466dd1a5025", "filename": "tests/ui/pattern_type_mismatch/pattern_alternatives.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/57cdf2dc16e1833008ae5b120cb2c045d267dda8/tests%2Fui%2Fpattern_type_mismatch%2Fpattern_alternatives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57cdf2dc16e1833008ae5b120cb2c045d267dda8/tests%2Fui%2Fpattern_type_mismatch%2Fpattern_alternatives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern_type_mismatch%2Fpattern_alternatives.rs?ref=57cdf2dc16e1833008ae5b120cb2c045d267dda8", "patch": "@@ -0,0 +1,24 @@\n+#![allow(clippy::all)]\n+#![warn(clippy::pattern_type_mismatch)]\n+\n+fn main() {}\n+\n+fn alternatives() {\n+    enum Value<'a> {\n+        Unused,\n+        A(&'a Option<i32>),\n+        B,\n+    }\n+    let ref_value = &Value::A(&Some(23));\n+\n+    // not ok\n+    if let Value::B | Value::A(_) = ref_value {}\n+    if let &Value::B | &Value::A(Some(_)) = ref_value {}\n+    if let Value::B | Value::A(Some(_)) = *ref_value {}\n+\n+    // ok\n+    if let &Value::B | &Value::A(_) = ref_value {}\n+    if let Value::B | Value::A(_) = *ref_value {}\n+    if let &Value::B | &Value::A(&Some(_)) = ref_value {}\n+    if let Value::B | Value::A(&Some(_)) = *ref_value {}\n+}"}, {"sha": "d285c93782c67962664f2a0e048d428307b8b3f7", "filename": "tests/ui/pattern_type_mismatch/pattern_alternatives.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/57cdf2dc16e1833008ae5b120cb2c045d267dda8/tests%2Fui%2Fpattern_type_mismatch%2Fpattern_alternatives.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/57cdf2dc16e1833008ae5b120cb2c045d267dda8/tests%2Fui%2Fpattern_type_mismatch%2Fpattern_alternatives.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern_type_mismatch%2Fpattern_alternatives.stderr?ref=57cdf2dc16e1833008ae5b120cb2c045d267dda8", "patch": "@@ -0,0 +1,27 @@\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_alternatives.rs:15:12\n+   |\n+LL |     if let Value::B | Value::A(_) = ref_value {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::pattern-type-mismatch` implied by `-D warnings`\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_alternatives.rs:16:34\n+   |\n+LL |     if let &Value::B | &Value::A(Some(_)) = ref_value {}\n+   |                                  ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_alternatives.rs:17:32\n+   |\n+LL |     if let Value::B | Value::A(Some(_)) = *ref_value {}\n+   |                                ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "417b1c107c55b8ce8c4ae160175c0e511ca3fcab", "filename": "tests/ui/pattern_type_mismatch/pattern_structs.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/57cdf2dc16e1833008ae5b120cb2c045d267dda8/tests%2Fui%2Fpattern_type_mismatch%2Fpattern_structs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57cdf2dc16e1833008ae5b120cb2c045d267dda8/tests%2Fui%2Fpattern_type_mismatch%2Fpattern_structs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern_type_mismatch%2Fpattern_structs.rs?ref=57cdf2dc16e1833008ae5b120cb2c045d267dda8", "patch": "@@ -0,0 +1,45 @@\n+#![allow(clippy::all)]\n+#![warn(clippy::pattern_type_mismatch)]\n+\n+fn main() {}\n+\n+fn struct_types() {\n+    struct Struct<'a> {\n+        ref_inner: &'a Option<i32>,\n+    }\n+    let ref_value = &Struct { ref_inner: &Some(42) };\n+\n+    // not ok\n+    let Struct { .. } = ref_value;\n+    if let &Struct { ref_inner: Some(_) } = ref_value {}\n+    if let Struct { ref_inner: Some(_) } = *ref_value {}\n+\n+    // ok\n+    let &Struct { .. } = ref_value;\n+    let Struct { .. } = *ref_value;\n+    if let &Struct { ref_inner: &Some(_) } = ref_value {}\n+    if let Struct { ref_inner: &Some(_) } = *ref_value {}\n+}\n+\n+fn struct_enum_variants() {\n+    enum StructEnum<'a> {\n+        Empty,\n+        Var { inner_ref: &'a Option<i32> },\n+    }\n+    let ref_value = &StructEnum::Var { inner_ref: &Some(42) };\n+\n+    // not ok\n+    if let StructEnum::Var { .. } = ref_value {}\n+    if let StructEnum::Var { inner_ref: Some(_) } = ref_value {}\n+    if let &StructEnum::Var { inner_ref: Some(_) } = ref_value {}\n+    if let StructEnum::Var { inner_ref: Some(_) } = *ref_value {}\n+    if let StructEnum::Empty = ref_value {}\n+\n+    // ok\n+    if let &StructEnum::Var { .. } = ref_value {}\n+    if let StructEnum::Var { .. } = *ref_value {}\n+    if let &StructEnum::Var { inner_ref: &Some(_) } = ref_value {}\n+    if let StructEnum::Var { inner_ref: &Some(_) } = *ref_value {}\n+    if let &StructEnum::Empty = ref_value {}\n+    if let StructEnum::Empty = *ref_value {}\n+}"}, {"sha": "d428e85b0c91403be6c9356fe3a383eb1a61d2ea", "filename": "tests/ui/pattern_type_mismatch/pattern_structs.stderr", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/57cdf2dc16e1833008ae5b120cb2c045d267dda8/tests%2Fui%2Fpattern_type_mismatch%2Fpattern_structs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/57cdf2dc16e1833008ae5b120cb2c045d267dda8/tests%2Fui%2Fpattern_type_mismatch%2Fpattern_structs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern_type_mismatch%2Fpattern_structs.stderr?ref=57cdf2dc16e1833008ae5b120cb2c045d267dda8", "patch": "@@ -0,0 +1,67 @@\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_structs.rs:13:9\n+   |\n+LL |     let Struct { .. } = ref_value;\n+   |         ^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::pattern-type-mismatch` implied by `-D warnings`\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_structs.rs:14:33\n+   |\n+LL |     if let &Struct { ref_inner: Some(_) } = ref_value {}\n+   |                                 ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_structs.rs:15:32\n+   |\n+LL |     if let Struct { ref_inner: Some(_) } = *ref_value {}\n+   |                                ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_structs.rs:32:12\n+   |\n+LL |     if let StructEnum::Var { .. } = ref_value {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_structs.rs:33:12\n+   |\n+LL |     if let StructEnum::Var { inner_ref: Some(_) } = ref_value {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_structs.rs:34:42\n+   |\n+LL |     if let &StructEnum::Var { inner_ref: Some(_) } = ref_value {}\n+   |                                          ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_structs.rs:35:41\n+   |\n+LL |     if let StructEnum::Var { inner_ref: Some(_) } = *ref_value {}\n+   |                                         ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_structs.rs:36:12\n+   |\n+LL |     if let StructEnum::Empty = ref_value {}\n+   |            ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "19504a051d8b12927f9365decd04f09f2b005d31", "filename": "tests/ui/pattern_type_mismatch/pattern_tuples.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/57cdf2dc16e1833008ae5b120cb2c045d267dda8/tests%2Fui%2Fpattern_type_mismatch%2Fpattern_tuples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57cdf2dc16e1833008ae5b120cb2c045d267dda8/tests%2Fui%2Fpattern_type_mismatch%2Fpattern_tuples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern_type_mismatch%2Fpattern_tuples.rs?ref=57cdf2dc16e1833008ae5b120cb2c045d267dda8", "patch": "@@ -0,0 +1,57 @@\n+#![allow(clippy::all)]\n+#![warn(clippy::pattern_type_mismatch)]\n+\n+fn main() {}\n+\n+fn tuple_types() {\n+    struct TupleStruct<'a>(&'a Option<i32>);\n+    let ref_value = &TupleStruct(&Some(42));\n+\n+    // not ok\n+    let TupleStruct(_) = ref_value;\n+    if let &TupleStruct(Some(_)) = ref_value {}\n+    if let TupleStruct(Some(_)) = *ref_value {}\n+\n+    // ok\n+    let &TupleStruct(_) = ref_value;\n+    let TupleStruct(_) = *ref_value;\n+    if let &TupleStruct(&Some(_)) = ref_value {}\n+    if let TupleStruct(&Some(_)) = *ref_value {}\n+}\n+\n+fn tuple_enum_variants() {\n+    enum TupleEnum<'a> {\n+        Empty,\n+        Var(&'a Option<i32>),\n+    }\n+    let ref_value = &TupleEnum::Var(&Some(42));\n+\n+    // not ok\n+    if let TupleEnum::Var(_) = ref_value {}\n+    if let &TupleEnum::Var(Some(_)) = ref_value {}\n+    if let TupleEnum::Var(Some(_)) = *ref_value {}\n+    if let TupleEnum::Empty = ref_value {}\n+\n+    // ok\n+    if let &TupleEnum::Var(_) = ref_value {}\n+    if let TupleEnum::Var(_) = *ref_value {}\n+    if let &TupleEnum::Var(&Some(_)) = ref_value {}\n+    if let TupleEnum::Var(&Some(_)) = *ref_value {}\n+    if let &TupleEnum::Empty = ref_value {}\n+    if let TupleEnum::Empty = *ref_value {}\n+}\n+\n+fn plain_tuples() {\n+    let ref_value = &(&Some(23), &Some(42));\n+\n+    // not ok\n+    let (_a, _b) = ref_value;\n+    if let &(_a, Some(_)) = ref_value {}\n+    if let (_a, Some(_)) = *ref_value {}\n+\n+    // ok\n+    let &(_a, _b) = ref_value;\n+    let (_a, _b) = *ref_value;\n+    if let &(_a, &Some(_)) = ref_value {}\n+    if let (_a, &Some(_)) = *ref_value {}\n+}"}, {"sha": "edd0074d00d3b52228a370642907526e70d1c26c", "filename": "tests/ui/pattern_type_mismatch/pattern_tuples.stderr", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/57cdf2dc16e1833008ae5b120cb2c045d267dda8/tests%2Fui%2Fpattern_type_mismatch%2Fpattern_tuples.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/57cdf2dc16e1833008ae5b120cb2c045d267dda8/tests%2Fui%2Fpattern_type_mismatch%2Fpattern_tuples.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern_type_mismatch%2Fpattern_tuples.stderr?ref=57cdf2dc16e1833008ae5b120cb2c045d267dda8", "patch": "@@ -0,0 +1,83 @@\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_tuples.rs:11:9\n+   |\n+LL |     let TupleStruct(_) = ref_value;\n+   |         ^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::pattern-type-mismatch` implied by `-D warnings`\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_tuples.rs:12:25\n+   |\n+LL |     if let &TupleStruct(Some(_)) = ref_value {}\n+   |                         ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_tuples.rs:13:24\n+   |\n+LL |     if let TupleStruct(Some(_)) = *ref_value {}\n+   |                        ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_tuples.rs:30:12\n+   |\n+LL |     if let TupleEnum::Var(_) = ref_value {}\n+   |            ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_tuples.rs:31:28\n+   |\n+LL |     if let &TupleEnum::Var(Some(_)) = ref_value {}\n+   |                            ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_tuples.rs:32:27\n+   |\n+LL |     if let TupleEnum::Var(Some(_)) = *ref_value {}\n+   |                           ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_tuples.rs:33:12\n+   |\n+LL |     if let TupleEnum::Empty = ref_value {}\n+   |            ^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_tuples.rs:48:9\n+   |\n+LL |     let (_a, _b) = ref_value;\n+   |         ^^^^^^^^\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_tuples.rs:49:18\n+   |\n+LL |     if let &(_a, Some(_)) = ref_value {}\n+   |                  ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_tuples.rs:50:17\n+   |\n+LL |     if let (_a, Some(_)) = *ref_value {}\n+   |                 ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: aborting due to 10 previous errors\n+"}, {"sha": "e89917c41e8c1a72a50451d1b628a0dfaef4fe78", "filename": "tests/ui/pattern_type_mismatch/syntax.rs", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/57cdf2dc16e1833008ae5b120cb2c045d267dda8/tests%2Fui%2Fpattern_type_mismatch%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57cdf2dc16e1833008ae5b120cb2c045d267dda8/tests%2Fui%2Fpattern_type_mismatch%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern_type_mismatch%2Fsyntax.rs?ref=57cdf2dc16e1833008ae5b120cb2c045d267dda8", "patch": "@@ -0,0 +1,146 @@\n+#![allow(clippy::all)]\n+#![warn(clippy::pattern_type_mismatch)]\n+\n+fn main() {}\n+\n+fn syntax_match() {\n+    let ref_value = &Some(&Some(42));\n+\n+    // not ok\n+    match ref_value {\n+        Some(_) => (),\n+        None => (),\n+    }\n+\n+    // ok\n+    match ref_value {\n+        &Some(_) => (),\n+        &None => (),\n+    }\n+    match *ref_value {\n+        Some(_) => (),\n+        None => (),\n+    }\n+}\n+\n+fn syntax_if_let() {\n+    let ref_value = &Some(42);\n+\n+    // not ok\n+    if let Some(_) = ref_value {}\n+\n+    // ok\n+    if let &Some(_) = ref_value {}\n+    if let Some(_) = *ref_value {}\n+}\n+\n+fn syntax_while_let() {\n+    let ref_value = &Some(42);\n+\n+    // not ok\n+    while let Some(_) = ref_value {\n+        break;\n+    }\n+\n+    // ok\n+    while let &Some(_) = ref_value {\n+        break;\n+    }\n+    while let Some(_) = *ref_value {\n+        break;\n+    }\n+}\n+\n+fn syntax_for() {\n+    let ref_value = &Some(23);\n+    let slice = &[(2, 3), (4, 2)];\n+\n+    // not ok\n+    for (_a, _b) in slice.iter() {}\n+\n+    // ok\n+    for &(_a, _b) in slice.iter() {}\n+}\n+\n+fn syntax_let() {\n+    let ref_value = &(2, 3);\n+\n+    // not ok\n+    let (_n, _m) = ref_value;\n+\n+    // ok\n+    let &(_n, _m) = ref_value;\n+    let (_n, _m) = *ref_value;\n+}\n+\n+fn syntax_fn() {\n+    // not ok\n+    fn foo((_a, _b): &(i32, i32)) {}\n+\n+    // ok\n+    fn foo_ok_1(&(_a, _b): &(i32, i32)) {}\n+}\n+\n+fn syntax_closure() {\n+    fn foo<F>(f: F)\n+    where\n+        F: FnOnce(&(i32, i32)),\n+    {\n+    }\n+\n+    // not ok\n+    foo(|(_a, _b)| ());\n+\n+    // ok\n+    foo(|&(_a, _b)| ());\n+}\n+\n+fn macro_with_expression() {\n+    macro_rules! matching_macro {\n+        ($e:expr) => {\n+            $e\n+        };\n+    }\n+    let value = &Some(23);\n+\n+    // not ok\n+    matching_macro!(match value {\n+        Some(_) => (),\n+        _ => (),\n+    });\n+\n+    // ok\n+    matching_macro!(match value {\n+        &Some(_) => (),\n+        _ => (),\n+    });\n+    matching_macro!(match *value {\n+        Some(_) => (),\n+        _ => (),\n+    });\n+}\n+\n+fn macro_expansion() {\n+    macro_rules! matching_macro {\n+        ($e:expr) => {\n+            // not ok\n+            match $e {\n+                Some(_) => (),\n+                _ => (),\n+            }\n+\n+            // ok\n+            match $e {\n+                &Some(_) => (),\n+                _ => (),\n+            }\n+            match *$e {\n+                Some(_) => (),\n+                _ => (),\n+            }\n+        };\n+    }\n+\n+    let value = &Some(23);\n+    matching_macro!(value);\n+}"}, {"sha": "5a5186bd4fcb3389cbca59b4e09fd7554e7f5330", "filename": "tests/ui/pattern_type_mismatch/syntax.stderr", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/57cdf2dc16e1833008ae5b120cb2c045d267dda8/tests%2Fui%2Fpattern_type_mismatch%2Fsyntax.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/57cdf2dc16e1833008ae5b120cb2c045d267dda8/tests%2Fui%2Fpattern_type_mismatch%2Fsyntax.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern_type_mismatch%2Fsyntax.stderr?ref=57cdf2dc16e1833008ae5b120cb2c045d267dda8", "patch": "@@ -0,0 +1,79 @@\n+error: type of pattern does not match the expression type\n+  --> $DIR/syntax.rs:11:9\n+   |\n+LL |         Some(_) => (),\n+   |         ^^^^^^^\n+   |\n+   = note: `-D clippy::pattern-type-mismatch` implied by `-D warnings`\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/syntax.rs:30:12\n+   |\n+LL |     if let Some(_) = ref_value {}\n+   |            ^^^^^^^\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/syntax.rs:41:15\n+   |\n+LL |     while let Some(_) = ref_value {\n+   |               ^^^^^^^\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/syntax.rs:59:9\n+   |\n+LL |     for (_a, _b) in slice.iter() {}\n+   |         ^^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/syntax.rs:69:9\n+   |\n+LL |     let (_n, _m) = ref_value;\n+   |         ^^^^^^^^\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/syntax.rs:78:12\n+   |\n+LL |     fn foo((_a, _b): &(i32, i32)) {}\n+   |            ^^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/syntax.rs:92:10\n+   |\n+LL |     foo(|(_a, _b)| ());\n+   |          ^^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/syntax.rs:108:9\n+   |\n+LL |         Some(_) => (),\n+   |         ^^^^^^^\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/syntax.rs:128:17\n+   |\n+LL |                 Some(_) => (),\n+   |                 ^^^^^^^\n+...\n+LL |     matching_macro!(value);\n+   |     ----------------------- in this macro invocation\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 9 previous errors\n+"}]}