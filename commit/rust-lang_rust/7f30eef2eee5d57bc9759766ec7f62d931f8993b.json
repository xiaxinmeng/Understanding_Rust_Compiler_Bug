{"sha": "7f30eef2eee5d57bc9759766ec7f62d931f8993b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmMzBlZWYyZWVlNWQ1N2JjOTc1OTc2NmVjN2Y2MmQ5MzFmODk5M2I=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-19T09:45:37Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-21T23:00:57Z"}, "message": "Introduce `MacroGenerable` trait", "tree": {"sha": "a84b9fc5e429c48a8f63351c027191ed91f85b06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a84b9fc5e429c48a8f63351c027191ed91f85b06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f30eef2eee5d57bc9759766ec7f62d931f8993b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f30eef2eee5d57bc9759766ec7f62d931f8993b", "html_url": "https://github.com/rust-lang/rust/commit/7f30eef2eee5d57bc9759766ec7f62d931f8993b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f30eef2eee5d57bc9759766ec7f62d931f8993b/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "179539f6eb61f75244a0dde641b6e4e09c0921ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/179539f6eb61f75244a0dde641b6e4e09c0921ec", "html_url": "https://github.com/rust-lang/rust/commit/179539f6eb61f75244a0dde641b6e4e09c0921ec"}], "stats": {"total": 99, "additions": 46, "deletions": 53}, "files": [{"sha": "b2ebe0e0145f2a25b81aaebeecbdc9df20aaf671", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 46, "deletions": 53, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/7f30eef2eee5d57bc9759766ec7f62d931f8993b/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f30eef2eee5d57bc9759766ec7f62d931f8993b/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=7f30eef2eee5d57bc9759766ec7f62d931f8993b", "patch": "@@ -35,6 +35,40 @@ use std_inject;\n use std::collections::HashSet;\n use std::env;\n \n+trait MacroGenerable: Sized {\n+    fn make_with<'a>(result: Box<MacResult + 'a>) -> Option<Self>;\n+    fn fold_with<F: Folder>(self, folder: &mut F) -> Self;\n+    fn dummy(span: Span) -> Self;\n+    fn kind_name() -> &'static str;\n+}\n+\n+macro_rules! impl_macro_generable {\n+    ($($ty:ty: $kind_name:expr, .$make:ident, $(.$fold:ident)* $(lift .$fold_elt:ident)*,\n+               |$span:ident| $dummy:expr;)*) => { $(\n+        impl MacroGenerable for $ty {\n+            fn kind_name() -> &'static str { $kind_name }\n+            fn make_with<'a>(result: Box<MacResult + 'a>) -> Option<Self> { result.$make() }\n+            fn fold_with<F: Folder>(self, folder: &mut F) -> Self {\n+                $( folder.$fold(self) )*\n+                $( self.into_iter().flat_map(|item| folder. $fold_elt (item)).collect() )*\n+            }\n+            fn dummy($span: Span) -> Self { $dummy }\n+        }\n+    )* }\n+}\n+\n+impl_macro_generable! {\n+    P<ast::Expr>: \"expression\", .make_expr, .fold_expr, |span| DummyResult::raw_expr(span);\n+    P<ast::Pat>:  \"pattern\",    .make_pat,  .fold_pat,  |span| P(DummyResult::raw_pat(span));\n+    P<ast::Ty>:   \"type\",       .make_ty,   .fold_ty,   |span| DummyResult::raw_ty(span);\n+    SmallVector<ast::ImplItem>:\n+        \"impl item\", .make_impl_items, lift .fold_impl_item, |_span| SmallVector::zero();\n+    SmallVector<P<ast::Item>>:\n+        \"item\",      .make_items,      lift .fold_item,      |_span| SmallVector::zero();\n+    SmallVector<ast::Stmt>:\n+        \"statement\", .make_stmts,      lift .fold_stmt,      |_span| SmallVector::zero();\n+}\n+\n // this function is called to detect use of feature-gated or invalid attributes\n // on macro invoations since they will not be detected after macro expansion\n fn check_attributes(attrs: &[ast::Attribute], fld: &MacroExpander) {\n@@ -59,9 +93,7 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             // Assert that we drop any macro attributes on the floor here\n             drop(attrs);\n \n-            let expanded_expr = match expand_mac_invoc(mac, span,\n-                                                       |r| r.make_expr(),\n-                                                       mark_expr, fld) {\n+            let expanded_expr = match expand_mac_invoc(mac, span, fld) {\n                 Some(expr) => expr,\n                 None => {\n                     return DummyResult::raw_expr(span);\n@@ -182,19 +214,9 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n     });\n }\n \n-/// Expand a (not-ident-style) macro invocation. Returns the result\n-/// of expansion and the mark which must be applied to the result.\n-/// Our current interface doesn't allow us to apply the mark to the\n-/// result until after calling make_expr, make_items, etc.\n-fn expand_mac_invoc<T, F, G>(mac: ast::Mac,\n-                             span: codemap::Span,\n-                             parse_thunk: F,\n-                             mark_thunk: G,\n-                             fld: &mut MacroExpander)\n-                             -> Option<T> where\n-    F: for<'a> FnOnce(Box<MacResult+'a>) -> Option<T>,\n-    G: FnOnce(T, Mrk) -> T,\n-{\n+/// Expand a (not-ident-style) macro invocation. Returns the result of expansion.\n+fn expand_mac_invoc<T: MacroGenerable>(mac: ast::Mac, span: Span, fld: &mut MacroExpander)\n+                                       -> Option<T> {\n     // it would almost certainly be cleaner to pass the whole\n     // macro invocation in, rather than pulling it apart and\n     // marking the tts and the ctxt separately. This also goes\n@@ -245,7 +267,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac,\n                     let expanded = expandfun.expand(fld.cx,\n                                                     mac_span,\n                                                     &marked_before[..]);\n-                    parse_thunk(expanded)\n+                    T::make_with(expanded)\n                 };\n                 let parsed = match opt_parsed {\n                     Some(e) => e,\n@@ -258,7 +280,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac,\n                         return None;\n                     }\n                 };\n-                Some(mark_thunk(parsed,fm))\n+                Some(parsed.fold_with(&mut Marker { mark: fm }))\n             }\n             _ => {\n                 fld.cx.span_err(\n@@ -523,11 +545,8 @@ fn expand_stmt(stmt: Stmt, fld: &mut MacroExpander) -> SmallVector<Stmt> {\n     // Assert that we drop any macro attributes on the floor here\n     drop(attrs);\n \n-    let maybe_new_items =\n-        expand_mac_invoc(mac.unwrap(), stmt.span,\n-                         |r| r.make_stmts(),\n-                         |stmts, mark| stmts.move_map(|m| mark_stmt(m, mark)),\n-                         fld);\n+    let maybe_new_items: Option<SmallVector<ast::Stmt>> =\n+        expand_mac_invoc(mac.unwrap(), stmt.span, fld);\n \n     let mut fully_expanded = match maybe_new_items {\n         Some(stmts) => {\n@@ -759,6 +778,7 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n             PatKind::Mac(mac) => (mac.node.path, mac.node.tts),\n             _ => unreachable!()\n         };\n+\n         if pth.segments.len() > 1 {\n             fld.cx.span_err(pth.span, \"expected macro name without module separators\");\n             return DummyResult::raw_pat(span);\n@@ -1079,11 +1099,8 @@ fn expand_impl_item(ii: ast::ImplItem, fld: &mut MacroExpander)\n         ast::ImplItemKind::Macro(mac) => {\n             check_attributes(&ii.attrs, fld);\n \n-            let maybe_new_items =\n-                expand_mac_invoc(mac, ii.span,\n-                                 |r| r.make_impl_items(),\n-                                 |meths, mark| meths.move_map(|m| mark_impl_item(m, mark)),\n-                                 fld);\n+            let maybe_new_items: Option<SmallVector<ast::ImplItem>> =\n+                expand_mac_invoc(mac, ii.span, fld);\n \n             match maybe_new_items {\n                 Some(impl_items) => {\n@@ -1139,10 +1156,7 @@ pub fn expand_type(t: P<ast::Ty>, fld: &mut MacroExpander) -> P<ast::Ty> {\n     let t = match t.node.clone() {\n         ast::TyKind::Mac(mac) => {\n             if fld.cx.ecfg.features.unwrap().type_macros {\n-                let expanded_ty = match expand_mac_invoc(mac, t.span,\n-                                                         |r| r.make_ty(),\n-                                                         mark_ty,\n-                                                         fld) {\n+                let expanded_ty = match expand_mac_invoc(mac, t.span, fld) {\n                     Some(ty) => ty,\n                     None => {\n                         return DummyResult::raw_ty(t.span);\n@@ -1426,38 +1440,17 @@ fn mark_tts(tts: &[TokenTree], m: Mrk) -> Vec<TokenTree> {\n     noop_fold_tts(tts, &mut Marker{mark:m})\n }\n \n-// apply a given mark to the given expr. Used following the expansion of a macro.\n-fn mark_expr(expr: P<ast::Expr>, m: Mrk) -> P<ast::Expr> {\n-    Marker{mark:m}.fold_expr(expr)\n-}\n-\n // apply a given mark to the given pattern. Used following the expansion of a macro.\n fn mark_pat(pat: P<ast::Pat>, m: Mrk) -> P<ast::Pat> {\n     Marker{mark:m}.fold_pat(pat)\n }\n \n-// apply a given mark to the given stmt. Used following the expansion of a macro.\n-fn mark_stmt(stmt: ast::Stmt, m: Mrk) -> ast::Stmt {\n-    Marker{mark:m}.fold_stmt(stmt)\n-        .expect_one(\"marking a stmt didn't return exactly one stmt\")\n-}\n-\n // apply a given mark to the given item. Used following the expansion of a macro.\n fn mark_item(expr: P<ast::Item>, m: Mrk) -> P<ast::Item> {\n     Marker{mark:m}.fold_item(expr)\n         .expect_one(\"marking an item didn't return exactly one item\")\n }\n \n-// apply a given mark to the given item. Used following the expansion of a macro.\n-fn mark_impl_item(ii: ast::ImplItem, m: Mrk) -> ast::ImplItem {\n-    Marker{mark:m}.fold_impl_item(ii)\n-        .expect_one(\"marking an impl item didn't return exactly one impl item\")\n-}\n-\n-fn mark_ty(ty: P<ast::Ty>, m: Mrk) -> P<ast::Ty> {\n-    Marker { mark: m }.fold_ty(ty)\n-}\n-\n /// Check that there are no macro invocations left in the AST:\n pub fn check_for_macros(sess: &parse::ParseSess, krate: &ast::Crate) {\n     visit::walk_crate(&mut MacroExterminator{sess:sess}, krate);"}]}