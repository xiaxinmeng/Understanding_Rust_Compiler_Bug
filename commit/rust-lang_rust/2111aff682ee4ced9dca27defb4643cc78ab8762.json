{"sha": "2111aff682ee4ced9dca27defb4643cc78ab8762", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxMTFhZmY2ODJlZTRjZWQ5ZGNhMjdkZWZiNDY0M2NjNzhhYjg3NjI=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2017-04-08T20:55:53Z"}, "committer": {"name": "Matt Ickstadt", "email": "mattico8@gmail.com", "date": "2017-04-24T00:19:38Z"}, "message": "Add Vec::splice and String::splice", "tree": {"sha": "d9c2d4b2f4b0c8a85eb181321fd0d1439d3b31e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9c2d4b2f4b0c8a85eb181321fd0d1439d3b31e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2111aff682ee4ced9dca27defb4643cc78ab8762", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2111aff682ee4ced9dca27defb4643cc78ab8762", "html_url": "https://github.com/rust-lang/rust/commit/2111aff682ee4ced9dca27defb4643cc78ab8762", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2111aff682ee4ced9dca27defb4643cc78ab8762/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mattico", "id": 853158, "node_id": "MDQ6VXNlcjg1MzE1OA==", "avatar_url": "https://avatars.githubusercontent.com/u/853158?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mattico", "html_url": "https://github.com/mattico", "followers_url": "https://api.github.com/users/mattico/followers", "following_url": "https://api.github.com/users/mattico/following{/other_user}", "gists_url": "https://api.github.com/users/mattico/gists{/gist_id}", "starred_url": "https://api.github.com/users/mattico/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mattico/subscriptions", "organizations_url": "https://api.github.com/users/mattico/orgs", "repos_url": "https://api.github.com/users/mattico/repos", "events_url": "https://api.github.com/users/mattico/events{/privacy}", "received_events_url": "https://api.github.com/users/mattico/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bd4b5c6db1468235f730bce403bf657123ecc57", "url": "https://api.github.com/repos/rust-lang/rust/commits/2bd4b5c6db1468235f730bce403bf657123ecc57", "html_url": "https://github.com/rust-lang/rust/commit/2bd4b5c6db1468235f730bce403bf657123ecc57"}], "stats": {"total": 320, "additions": 313, "deletions": 7}, "files": [{"sha": "2eef132374e58b8a9f92c8edb37e5c101713da37", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2111aff682ee4ced9dca27defb4643cc78ab8762/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2111aff682ee4ced9dca27defb4643cc78ab8762/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=2111aff682ee4ced9dca27defb4643cc78ab8762", "patch": "@@ -1519,13 +1519,9 @@ impl<T: Clone> ToOwned for [T] {\n         self.to_vec()\n     }\n \n-    // HACK(japaric): with cfg(test) the inherent `[T]::to_vec`, which is required for this method\n-    // definition, is not available. Since we don't require this method for testing purposes, I'll\n-    // just stub it\n-    // NB see the slice::hack module in slice.rs for more information\n     #[cfg(test)]\n     fn to_owned(&self) -> Vec<T> {\n-        panic!(\"not available with cfg(test)\")\n+        hack::to_vec(self)\n     }\n \n     fn clone_into(&self, target: &mut Vec<T>) {"}, {"sha": "8090bc1996e414a7cde696d419edf8612cdf9c3e", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 129, "deletions": 1, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/2111aff682ee4ced9dca27defb4643cc78ab8762/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2111aff682ee4ced9dca27defb4643cc78ab8762/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=2111aff682ee4ced9dca27defb4643cc78ab8762", "patch": "@@ -1316,7 +1316,7 @@ impl String {\n         self.vec.clear()\n     }\n \n-    /// Create a draining iterator that removes the specified range in the string\n+    /// Creates a draining iterator that removes the specified range in the string\n     /// and yields the removed chars.\n     ///\n     /// Note: The element range is removed even if the iterator is not\n@@ -1382,6 +1382,63 @@ impl String {\n         }\n     }\n \n+    /// Creates a splicing iterator that removes the specified range in the string,\n+    /// replaces with the given string, and yields the removed chars.\n+    /// The given string doesn\u2019t need to be the same length as the range.\n+    ///\n+    /// Note: The element range is removed even if the iterator is not\n+    /// consumed until the end.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the starting point or end point do not lie on a [`char`]\n+    /// boundary, or if they're out of bounds.\n+    ///\n+    /// [`char`]: ../../std/primitive.char.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(splice)]\n+    /// let mut s = String::from(\"\u03b1 is alpha, \u03b2 is beta\");\n+    /// let beta_offset = s.find('\u03b2').unwrap_or(s.len());\n+    ///\n+    /// // Replace the range up until the \u03b2 from the string\n+    /// let t: String = s.splice(..beta_offset, \"\u0391 is capital alpha; \").collect();\n+    /// assert_eq!(t, \"\u03b1 is alpha, \");\n+    /// assert_eq!(s, \"\u0391 is capital alpha; \u03b2 is beta\");\n+    /// ```\n+    #[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n+    pub fn splice<'a, 'b, R>(&'a mut self, range: R, replace_with: &'b str) -> Splice<'a, 'b>\n+        where R: RangeArgument<usize>\n+    {\n+        // Memory safety\n+        //\n+        // The String version of Splice does not have the memory safety issues\n+        // of the vector version. The data is just plain bytes.\n+        // Because the range removal happens in Drop, if the Splice iterator is leaked,\n+        // the removal will not happen.\n+        let len = self.len();\n+        let start = *range.start().unwrap_or(&0);\n+        let end = *range.end().unwrap_or(&len);\n+\n+        // Take out two simultaneous borrows. The &mut String won't be accessed\n+        // until iteration is over, in Drop.\n+        let self_ptr = self as *mut _;\n+        // slicing does the appropriate bounds checks\n+        let chars_iter = self[start..end].chars();\n+\n+        Splice {\n+            start: start,\n+            end: end,\n+            iter: chars_iter,\n+            string: self_ptr,\n+            replace_with: replace_with\n+        }\n+    }\n+\n     /// Converts this `String` into a `Box<str>`.\n     ///\n     /// This will drop any excess capacity.\n@@ -2145,3 +2202,74 @@ impl<'a> DoubleEndedIterator for Drain<'a> {\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a> FusedIterator for Drain<'a> {}\n+\n+/// A splicing iterator for `String`.\n+///\n+/// This struct is created by the [`splice()`] method on [`String`]. See its\n+/// documentation for more.\n+///\n+/// [`splice()`]: struct.String.html#method.splice\n+/// [`String`]: struct.String.html\n+#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n+pub struct Splice<'a, 'b> {\n+    /// Will be used as &'a mut String in the destructor\n+    string: *mut String,\n+    /// Start of part to remove\n+    start: usize,\n+    /// End of part to remove\n+    end: usize,\n+    /// Current remaining range to remove\n+    iter: Chars<'a>,\n+    replace_with: &'b str,\n+}\n+\n+#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n+unsafe impl<'a, 'b> Sync for Splice<'a, 'b> {}\n+#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n+unsafe impl<'a, 'b> Send for Splice<'a, 'b> {}\n+\n+#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n+impl<'a, 'b> Drop for Splice<'a, 'b> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            let vec = (*self.string).as_mut_vec();\n+            let range_len = self.end - self.start;\n+            let replacement_len = self.replace_with.len();\n+            let tail_len = vec.len() - self.end;\n+            if replacement_len > range_len {\n+                vec.reserve(replacement_len - range_len);\n+            }\n+            if replacement_len != range_len {\n+                let src = vec.as_ptr().offset(self.end as isize);\n+                let dst = vec.as_mut_ptr().offset((self.start + replacement_len) as isize);\n+                ptr::copy(src, dst, tail_len);\n+            }\n+            let src = self.replace_with.as_ptr();\n+            let dst = vec.as_mut_ptr().offset(self.start as isize);\n+            ptr::copy(src, dst, replacement_len);\n+            vec.set_len(self.start + replacement_len + tail_len);\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n+impl<'a, 'b> Iterator for Splice<'a, 'b> {\n+    type Item = char;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<char> {\n+        self.iter.next()\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+}\n+\n+#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n+impl<'a, 'b> DoubleEndedIterator for Splice<'a, 'b> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<char> {\n+        self.iter.next_back()\n+    }\n+}"}, {"sha": "eae3bf3915f60d1f40f30ab3203aafcc1363d4cf", "filename": "src/libcollections/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2111aff682ee4ced9dca27defb4643cc78ab8762/src%2Flibcollections%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2111aff682ee4ced9dca27defb4643cc78ab8762/src%2Flibcollections%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftests%2Flib.rs?ref=2111aff682ee4ced9dca27defb4643cc78ab8762", "patch": "@@ -20,6 +20,7 @@\n #![feature(pattern)]\n #![feature(placement_in_syntax)]\n #![feature(rand)]\n+#![feature(splice)]\n #![feature(step_by)]\n #![feature(str_escape)]\n #![feature(test)]"}, {"sha": "faaa9a1830b07b34df8c817e00fb2b26c0ca85e2", "filename": "src/libcollections/tests/string.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2111aff682ee4ced9dca27defb4643cc78ab8762/src%2Flibcollections%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2111aff682ee4ced9dca27defb4643cc78ab8762/src%2Flibcollections%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftests%2Fstring.rs?ref=2111aff682ee4ced9dca27defb4643cc78ab8762", "patch": "@@ -419,6 +419,14 @@ fn test_drain() {\n     assert_eq!(t, \"\");\n }\n \n+#[test]\n+fn test_splice() {\n+    let mut s = \"Hello, world!\".to_owned();\n+    let t: String = s.splice(7..12, \"\u4e16\u754c\").collect();\n+    assert_eq!(s, \"Hello, \u4e16\u754c!\");\n+    assert_eq!(t, \"world\");\n+}\n+\n #[test]\n fn test_extend_ref() {\n     let mut a = \"foo\".to_string();"}, {"sha": "e3453c70abaf271ce05e2ec88609bef7761290bc", "filename": "src/libcollections/tests/vec.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2111aff682ee4ced9dca27defb4643cc78ab8762/src%2Flibcollections%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2111aff682ee4ced9dca27defb4643cc78ab8762/src%2Flibcollections%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftests%2Fvec.rs?ref=2111aff682ee4ced9dca27defb4643cc78ab8762", "patch": "@@ -579,6 +579,16 @@ fn test_drain_inclusive_out_of_bounds() {\n     v.drain(5...5);\n }\n \n+#[test]\n+fn splice() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    let a = [10, 11, 12];\n+    v.splice(2..4, a.iter().cloned());\n+    assert_eq!(v, &[1, 2, 10, 11, 12, 5]);\n+    v.splice(1..3, Some(20));\n+    assert_eq!(v, &[1, 20, 11, 12, 5]);\n+}\n+\n #[test]\n fn test_into_boxed_slice() {\n     let xs = vec![1, 2, 3];"}, {"sha": "bbb067ca4e3b6cf5898bf2d65e58d23c20caea27", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 164, "deletions": 1, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/2111aff682ee4ced9dca27defb4643cc78ab8762/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2111aff682ee4ced9dca27defb4643cc78ab8762/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=2111aff682ee4ced9dca27defb4643cc78ab8762", "patch": "@@ -1057,7 +1057,7 @@ impl<T> Vec<T> {\n         self.len += count;\n     }\n \n-    /// Create a draining iterator that removes the specified range in the vector\n+    /// Creates a draining iterator that removes the specified range in the vector\n     /// and yields the removed items.\n     ///\n     /// Note 1: The element range is removed even if the iterator is only\n@@ -1845,6 +1845,54 @@ impl<T> Vec<T> {\n             }\n         }\n     }\n+\n+    /// Creates a splicing iterator that replaces the specified range in the vector\n+    /// with the given `replace_with` iterator and yields the removed items.\n+    /// `replace_with` does not need to be the same length as `range`.\n+    ///\n+    /// Note 1: The element range is removed even if the iterator is not\n+    /// consumed until the end.\n+    ///\n+    /// Note 2: It is unspecified how many elements are removed from the vector,\n+    /// if the `Splice` value is leaked.\n+    ///\n+    /// Note 3: The input iterator `replace_with` is only consumed\n+    /// when the `Splice` value is dropped.\n+    ///\n+    /// Note 4: This is optimal if:\n+    ///\n+    /// * The tail (elements in the vector after `range`) is empty,\n+    /// * or `replace_with` yields fewer elements than `range`\u2019s length\n+    /// * or the lower bound of its `size_hint()` is exact.\n+    ///\n+    /// Otherwise, a temporary vector is allocated and the tail is moved twice.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the starting point is greater than the end point or if\n+    /// the end point is greater than the length of the vector.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(splice)]\n+    /// let mut v = vec![1, 2, 3];\n+    /// let new = [7, 8];\n+    /// let u: Vec<_> = v.splice(..2, new.iter().cloned()).collect();\n+    /// assert_eq!(v, &[7, 8, 3]);\n+    /// assert_eq!(u, &[1, 2]);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n+    pub fn splice<R, I>(&mut self, range: R, replace_with: I) -> Splice<I::IntoIter>\n+        where R: RangeArgument<usize>, I: IntoIterator<Item=T>\n+    {\n+        Splice {\n+            drain: self.drain(range),\n+            replace_with: replace_with.into_iter(),\n+        }\n+    }\n+\n }\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n@@ -2344,3 +2392,118 @@ impl<'a, T> InPlace<T> for PlaceBack<'a, T> {\n         &mut *ptr\n     }\n }\n+\n+\n+/// A splicing iterator for `Vec<T>`. See the [`Vec::splice`](struct.Vec.html#method.splice) method.\n+#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n+pub struct Splice<'a, I: Iterator + 'a> {\n+    drain: Drain<'a, I::Item>,\n+    replace_with: I,\n+}\n+\n+#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n+impl<'a, I: Iterator> Iterator for Splice<'a, I> {\n+    type Item = I::Item;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.drain.next()\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.drain.size_hint()\n+    }\n+}\n+\n+#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n+impl<'a, I: Iterator> DoubleEndedIterator for Splice<'a, I> {\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        self.drain.next_back()\n+    }\n+}\n+\n+#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n+impl<'a, I: Iterator> ExactSizeIterator for Splice<'a, I> {}\n+\n+\n+#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n+impl<'a, I: Iterator> Drop for Splice<'a, I> {\n+    fn drop(&mut self) {\n+        // exhaust drain first\n+        while let Some(_) = self.drain.next() {}\n+\n+\n+        unsafe {\n+            if self.drain.tail_len == 0 {\n+                let vec = &mut *self.drain.vec;\n+                vec.extend(self.replace_with.by_ref());\n+                return\n+            }\n+\n+            // First fill the range left by drain().\n+            if !self.drain.fill(&mut self.replace_with) {\n+                return\n+            }\n+\n+            // There may be more elements. Use the lower bound as an estimate.\n+            // FIXME: Is the upper bound a better guess? Or something else?\n+            let (lower_bound, _upper_bound) = self.replace_with.size_hint();\n+            if lower_bound > 0  {\n+                self.drain.move_tail(lower_bound);\n+                if !self.drain.fill(&mut self.replace_with) {\n+                    return\n+                }\n+            }\n+\n+            // Collect any remaining elements.\n+            // This is a zero-length vector which does not allocate if `lower_bound` was exact.\n+            let mut collected = self.replace_with.by_ref().collect::<Vec<I::Item>>().into_iter();\n+            // Now we have an exact count.\n+            if collected.len() > 0 {\n+                self.drain.move_tail(collected.len());\n+                let filled = self.drain.fill(&mut collected);\n+                debug_assert!(filled);\n+                debug_assert_eq!(collected.len(), 0);\n+            }\n+        }\n+        // Let `Drain::drop` move the tail back if necessary and restore `vec.len`.\n+    }\n+}\n+\n+/// Private helper methods for `Splice::drop`\n+impl<'a, T> Drain<'a, T> {\n+    /// The range from `self.vec.len` to `self.tail_start` contains elements\n+    /// that have been moved out.\n+    /// Fill that range as much as possible with new elements from the `replace_with` iterator.\n+    /// Return whether we filled the entire range. (`replace_with.next()` didn\u2019t return `None`.)\n+    unsafe fn fill<I: Iterator<Item=T>>(&mut self, replace_with: &mut I) -> bool {\n+        let vec = &mut *self.vec;\n+        let range_start = vec.len;\n+        let range_end = self.tail_start;\n+        let range_slice = slice::from_raw_parts_mut(\n+            vec.as_mut_ptr().offset(range_start as isize),\n+            range_end - range_start);\n+\n+        for place in range_slice {\n+            if let Some(new_item) = replace_with.next() {\n+                ptr::write(place, new_item);\n+                vec.len += 1;\n+            } else {\n+                return false\n+            }\n+        }\n+        true\n+    }\n+\n+    /// Make room for inserting more elements before the tail.\n+    unsafe fn move_tail(&mut self, extra_capacity: usize) {\n+        let vec = &mut *self.vec;\n+        let used_capacity = self.tail_start + self.tail_len;\n+        vec.buf.reserve(used_capacity, extra_capacity);\n+\n+        let new_tail_start = self.tail_start + extra_capacity;\n+        let src = vec.as_ptr().offset(self.tail_start as isize);\n+        let dst = vec.as_mut_ptr().offset(new_tail_start as isize);\n+        ptr::copy(src, dst, self.tail_len);\n+        self.tail_start = new_tail_start;\n+    }\n+}"}]}