{"sha": "ee9b0c89e6a35b09dea708c0c0c619e1812f290e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlOWIwYzg5ZTZhMzViMDlkZWE3MDhjMGMwYzYxOWUxODEyZjI5MGU=", "commit": {"author": {"name": "Andrea Pretto", "email": "eulerdisk@gmail.com", "date": "2019-02-08T21:12:49Z"}, "committer": {"name": "Andrea Pretto", "email": "eulerdisk@gmail.com", "date": "2019-02-09T10:30:09Z"}, "message": "auto_import: struct variants for ImportAction", "tree": {"sha": "80613b006c28159ffea9b1c487aa669df8e4aaba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80613b006c28159ffea9b1c487aa669df8e4aaba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee9b0c89e6a35b09dea708c0c0c619e1812f290e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee9b0c89e6a35b09dea708c0c0c619e1812f290e", "html_url": "https://github.com/rust-lang/rust/commit/ee9b0c89e6a35b09dea708c0c0c619e1812f290e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee9b0c89e6a35b09dea708c0c0c619e1812f290e/comments", "author": {"login": "eulerdisk", "id": 10089822, "node_id": "MDQ6VXNlcjEwMDg5ODIy", "avatar_url": "https://avatars.githubusercontent.com/u/10089822?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eulerdisk", "html_url": "https://github.com/eulerdisk", "followers_url": "https://api.github.com/users/eulerdisk/followers", "following_url": "https://api.github.com/users/eulerdisk/following{/other_user}", "gists_url": "https://api.github.com/users/eulerdisk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eulerdisk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eulerdisk/subscriptions", "organizations_url": "https://api.github.com/users/eulerdisk/orgs", "repos_url": "https://api.github.com/users/eulerdisk/repos", "events_url": "https://api.github.com/users/eulerdisk/events{/privacy}", "received_events_url": "https://api.github.com/users/eulerdisk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eulerdisk", "id": 10089822, "node_id": "MDQ6VXNlcjEwMDg5ODIy", "avatar_url": "https://avatars.githubusercontent.com/u/10089822?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eulerdisk", "html_url": "https://github.com/eulerdisk", "followers_url": "https://api.github.com/users/eulerdisk/followers", "following_url": "https://api.github.com/users/eulerdisk/following{/other_user}", "gists_url": "https://api.github.com/users/eulerdisk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eulerdisk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eulerdisk/subscriptions", "organizations_url": "https://api.github.com/users/eulerdisk/orgs", "repos_url": "https://api.github.com/users/eulerdisk/repos", "events_url": "https://api.github.com/users/eulerdisk/events{/privacy}", "received_events_url": "https://api.github.com/users/eulerdisk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1866fb2dda595b9af1e5608a73f05dd2572f2a3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1866fb2dda595b9af1e5608a73f05dd2572f2a3e", "html_url": "https://github.com/rust-lang/rust/commit/1866fb2dda595b9af1e5608a73f05dd2572f2a3e"}], "stats": {"total": 151, "additions": 107, "deletions": 44}, "files": [{"sha": "77380b816bbc3776f8f17da7bfc9ee0b91e23379", "filename": "crates/ra_assists/src/auto_import.rs", "status": "modified", "additions": 107, "deletions": 44, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/ee9b0c89e6a35b09dea708c0c0c619e1812f290e/crates%2Fra_assists%2Fsrc%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee9b0c89e6a35b09dea708c0c0c619e1812f290e/crates%2Fra_assists%2Fsrc%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fauto_import.rs?ref=ee9b0c89e6a35b09dea708c0c0c619e1812f290e", "patch": "@@ -140,30 +140,64 @@ fn compare_path_segment_with_name(a: &ast::PathSegment, b: &ast::Name) -> bool {\n enum ImportAction<'a> {\n     Nothing,\n     // Add a brand new use statement.\n-    AddNewUse(\n-        Option<&'a SyntaxNode>, // anchor node\n-        bool,                   // true if we want to add the new statement after the anchor\n-    ),\n-\n-    // In the following actions we keep track of how may segments matched,\n-    // so we can choose the best action to take.\n+    AddNewUse {\n+        anchor: Option<&'a SyntaxNode>, // anchor node\n+        add_after_anchor: bool,\n+    },\n \n     // To split an existing use statement creating a nested import.\n-    AddNestedImport(\n-        usize,\n-        &'a ast::Path,                // the complete path we want to split\n-        Option<&'a ast::PathSegment>, // the first segment of path we want to add into the new nested list\n-        bool,                         // true if we want to add 'self' in addition to the segment\n-    ),\n+    AddNestedImport {\n+        // how may segments matched with the target path\n+        common_segments: usize,\n+        path_to_split: &'a ast::Path,\n+        // the first segment of path_to_split we want to add into the new nested list\n+        first_segment_to_split: Option<&'a ast::PathSegment>,\n+        // Wether to add 'self' in addition to the target path\n+        add_self: bool,\n+    },\n     // To add the target path to an existing nested import tree list.\n-    AddInTreeList(\n-        usize,\n-        &'a ast::UseTreeList,\n-        bool, // true if we want to add 'self'\n-    ),\n+    AddInTreeList {\n+        common_segments: usize,\n+        // The UseTreeList where to add the target path\n+        tree_list: &'a ast::UseTreeList,\n+        add_self: bool,\n+    },\n }\n \n impl<'a> ImportAction<'a> {\n+    fn add_new_use(anchor: Option<&'a SyntaxNode>, add_after_anchor: bool) -> Self {\n+        ImportAction::AddNewUse {\n+            anchor,\n+            add_after_anchor,\n+        }\n+    }\n+\n+    fn add_nested_import(\n+        common_segments: usize,\n+        path_to_split: &'a ast::Path,\n+        first_segment_to_split: Option<&'a ast::PathSegment>,\n+        add_self: bool,\n+    ) -> Self {\n+        ImportAction::AddNestedImport {\n+            common_segments,\n+            path_to_split,\n+            first_segment_to_split,\n+            add_self,\n+        }\n+    }\n+\n+    fn add_in_tree_list(\n+        common_segments: usize,\n+        tree_list: &'a ast::UseTreeList,\n+        add_self: bool,\n+    ) -> Self {\n+        ImportAction::AddInTreeList {\n+            common_segments,\n+            tree_list,\n+            add_self,\n+        }\n+    }\n+\n     fn better<'b>(left: &'b ImportAction<'a>, right: &'b ImportAction<'a>) -> &'b ImportAction<'a> {\n         if left.is_better(right) {\n             left\n@@ -175,13 +209,27 @@ impl<'a> ImportAction<'a> {\n     fn is_better(&self, other: &ImportAction) -> bool {\n         match (self, other) {\n             (ImportAction::Nothing, _) => true,\n-            (ImportAction::AddInTreeList(..), ImportAction::Nothing) => false,\n-            (ImportAction::AddNestedImport(n, ..), ImportAction::AddInTreeList(m, ..)) => n > m,\n-            (ImportAction::AddInTreeList(n, ..), ImportAction::AddNestedImport(m, ..)) => n > m,\n-            (ImportAction::AddInTreeList(..), _) => true,\n-            (ImportAction::AddNestedImport(..), ImportAction::Nothing) => false,\n-            (ImportAction::AddNestedImport(..), _) => true,\n-            (ImportAction::AddNewUse(..), _) => false,\n+            (ImportAction::AddInTreeList { .. }, ImportAction::Nothing) => false,\n+            (\n+                ImportAction::AddNestedImport {\n+                    common_segments: n, ..\n+                },\n+                ImportAction::AddInTreeList {\n+                    common_segments: m, ..\n+                },\n+            ) => n > m,\n+            (\n+                ImportAction::AddInTreeList {\n+                    common_segments: n, ..\n+                },\n+                ImportAction::AddNestedImport {\n+                    common_segments: m, ..\n+                },\n+            ) => n > m,\n+            (ImportAction::AddInTreeList { .. }, _) => true,\n+            (ImportAction::AddNestedImport { .. }, ImportAction::Nothing) => false,\n+            (ImportAction::AddNestedImport { .. }, _) => true,\n+            (ImportAction::AddNewUse { .. }, _) => false,\n         }\n     }\n }\n@@ -205,7 +253,7 @@ fn walk_use_tree_for_best_action<'a>(\n         Some(path) => path,\n         None => {\n             // If the use item don't have a path, it means it's broken (syntax error)\n-            return ImportAction::AddNewUse(\n+            return ImportAction::add_new_use(\n                 current_use_tree\n                     .syntax()\n                     .ancestors()\n@@ -231,7 +279,7 @@ fn walk_use_tree_for_best_action<'a>(\n     let right = current_path_segments.split_at(prev_len).1;\n     let common = compare_path_segments(left, right);\n     let mut action = match common {\n-        0 => ImportAction::AddNewUse(\n+        0 => ImportAction::add_new_use(\n             // e.g: target is std::fmt and we can have\n             // use foo::bar\n             // We add a brand new use statement\n@@ -259,7 +307,7 @@ fn walk_use_tree_for_best_action<'a>(\n                 if has_self {\n                     ImportAction::Nothing\n                 } else {\n-                    ImportAction::AddInTreeList(current_path_segments.len(), list, true)\n+                    ImportAction::add_in_tree_list(current_path_segments.len(), list, true)\n                 }\n             } else {\n                 // Case 1\n@@ -271,7 +319,7 @@ fn walk_use_tree_for_best_action<'a>(\n             // use std::io;\n             // We need to split.\n             let segments_to_split = current_path_segments.split_at(prev_len + common).1;\n-            ImportAction::AddNestedImport(\n+            ImportAction::add_nested_import(\n                 prev_len + common,\n                 path,\n                 Some(segments_to_split[0]),\n@@ -284,7 +332,7 @@ fn walk_use_tree_for_best_action<'a>(\n             // 2- use std::{ ... };\n \n             // fallback action\n-            let mut better_action = ImportAction::AddNewUse(\n+            let mut better_action = ImportAction::add_new_use(\n                 current_use_tree\n                     .syntax()\n                     .ancestors()\n@@ -306,24 +354,29 @@ fn walk_use_tree_for_best_action<'a>(\n                 }\n             } else {\n                 // Case 1, split\n-                better_action = ImportAction::AddNestedImport(prev_len + common, path, None, true)\n+                better_action = ImportAction::add_nested_import(prev_len + common, path, None, true)\n             }\n             better_action\n         }\n         common if left.len() < right.len() => {\n             // e.g: target is std::fmt and we can have\n             // use std::fmt::Debug;\n             let segments_to_split = current_path_segments.split_at(prev_len + common).1;\n-            ImportAction::AddNestedImport(prev_len + common, path, Some(segments_to_split[0]), true)\n+            ImportAction::add_nested_import(\n+                prev_len + common,\n+                path,\n+                Some(segments_to_split[0]),\n+                true,\n+            )\n         }\n         _ => unreachable!(),\n     };\n \n     // If we are inside a UseTreeList adding a use statement become adding to the existing\n     // tree list.\n     action = match (current_parent_use_tree_list, action) {\n-        (Some(use_tree_list), ImportAction::AddNewUse(..)) => {\n-            ImportAction::AddInTreeList(prev_len, use_tree_list, false)\n+        (Some(use_tree_list), ImportAction::AddNewUse { .. }) => {\n+            ImportAction::add_in_tree_list(prev_len, use_tree_list, false)\n         }\n         (_, _) => action,\n     };\n@@ -361,26 +414,36 @@ fn best_action_for_target<'b, 'a: 'b>(\n                 .map(AstNode::syntax)\n                 .or(Some(path.syntax()));\n \n-            return ImportAction::AddNewUse(anchor, false);\n+            return ImportAction::add_new_use(anchor, false);\n         }\n     }\n }\n \n fn make_assist(action: &ImportAction, target: &[&ast::PathSegment], edit: &mut AssistBuilder) {\n     match action {\n-        ImportAction::AddNewUse(anchor, after) => {\n-            make_assist_add_new_use(anchor, *after, target, edit)\n-        }\n-        ImportAction::AddInTreeList(n, tree_list_node, add_self) => {\n+        ImportAction::AddNewUse {\n+            anchor,\n+            add_after_anchor,\n+        } => make_assist_add_new_use(anchor, *add_after_anchor, target, edit),\n+        ImportAction::AddInTreeList {\n+            common_segments,\n+            tree_list,\n+            add_self,\n+        } => {\n             // We know that the fist n segments already exists in the use statement we want\n             // to modify, so we want to add only the last target.len() - n segments.\n-            let segments_to_add = target.split_at(*n).1;\n-            make_assist_add_in_tree_list(tree_list_node, segments_to_add, *add_self, edit)\n+            let segments_to_add = target.split_at(*common_segments).1;\n+            make_assist_add_in_tree_list(tree_list, segments_to_add, *add_self, edit)\n         }\n-        ImportAction::AddNestedImport(n, path, first_segment_to_split, add_self) => {\n-            let segments_to_add = target.split_at(*n).1;\n+        ImportAction::AddNestedImport {\n+            common_segments,\n+            path_to_split,\n+            first_segment_to_split,\n+            add_self,\n+        } => {\n+            let segments_to_add = target.split_at(*common_segments).1;\n             make_assist_add_nested_import(\n-                path,\n+                path_to_split,\n                 first_segment_to_split,\n                 segments_to_add,\n                 *add_self,"}]}