{"sha": "156b1fb9e15f63a8525e934a6857c37823b49c0e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1NmIxZmI5ZTE1ZjYzYTg1MjVlOTM0YTY4NTdjMzc4MjNiNDljMGU=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-25T05:39:32Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-06-05T11:41:02Z"}, "message": "Add a new Assert terminator to MIR for bounds & arithmetic checks.", "tree": {"sha": "ffbc1db2d8b0734f6e1e819c615cacaed8892a69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ffbc1db2d8b0734f6e1e819c615cacaed8892a69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/156b1fb9e15f63a8525e934a6857c37823b49c0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/156b1fb9e15f63a8525e934a6857c37823b49c0e", "html_url": "https://github.com/rust-lang/rust/commit/156b1fb9e15f63a8525e934a6857c37823b49c0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/156b1fb9e15f63a8525e934a6857c37823b49c0e/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fbff36d01e21380894a323bbf537219a8359291", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fbff36d01e21380894a323bbf537219a8359291", "html_url": "https://github.com/rust-lang/rust/commit/7fbff36d01e21380894a323bbf537219a8359291"}], "stats": {"total": 501, "additions": 305, "deletions": 196}, "files": [{"sha": "9666741d032b81386a1ba68d12323741442308e5", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=156b1fb9e15f63a8525e934a6857c37823b49c0e", "patch": "@@ -10,7 +10,7 @@\n \n use graphviz::IntoCow;\n use middle::const_val::ConstVal;\n-use rustc_const_math::{ConstUsize, ConstInt};\n+use rustc_const_math::{ConstUsize, ConstInt, ConstMathErr};\n use hir::def_id::DefId;\n use ty::subst::Substs;\n use ty::{self, AdtDef, ClosureSubsts, FnOutput, Region, Ty};\n@@ -354,6 +354,16 @@ pub enum TerminatorKind<'tcx> {\n         /// Cleanups to be done if the call unwinds.\n         cleanup: Option<BasicBlock>\n     },\n+\n+    /// Jump to the target if the condition has the expected value,\n+    /// otherwise panic with a message and a cleanup target.\n+    Assert {\n+        cond: Operand<'tcx>,\n+        expected: bool,\n+        msg: AssertMessage<'tcx>,\n+        target: BasicBlock,\n+        cleanup: Option<BasicBlock>\n+    }\n }\n \n impl<'tcx> Terminator<'tcx> {\n@@ -389,6 +399,8 @@ impl<'tcx> TerminatorKind<'tcx> {\n             Drop { ref target, unwind: None, .. } => {\n                 slice::ref_slice(target).into_cow()\n             }\n+            Assert { target, cleanup: Some(unwind), .. } => vec![target, unwind].into_cow(),\n+            Assert { ref target, .. } => slice::ref_slice(target).into_cow(),\n         }\n     }\n \n@@ -413,6 +425,8 @@ impl<'tcx> TerminatorKind<'tcx> {\n             Drop { ref mut target, unwind: None, .. } => {\n                 vec![target]\n             }\n+            Assert { ref mut target, cleanup: Some(ref mut unwind), .. } => vec![target, unwind],\n+            Assert { ref mut target, .. } => vec![target]\n         }\n     }\n }\n@@ -495,6 +509,26 @@ impl<'tcx> TerminatorKind<'tcx> {\n                 }\n                 write!(fmt, \")\")\n             }\n+            Assert { ref cond, expected, ref msg, .. } => {\n+                write!(fmt, \"assert(\")?;\n+                if !expected {\n+                    write!(fmt, \"!\")?;\n+                }\n+                write!(fmt, \"{:?}, \", cond)?;\n+\n+                match *msg {\n+                    AssertMessage::BoundsCheck { ref len, ref index } => {\n+                        write!(fmt, \"{:?}, {:?}, {:?}\",\n+                               \"index out of bounds: the len is {} but the index is {}\",\n+                               len, index)?;\n+                    }\n+                    AssertMessage::Math(ref err) => {\n+                        write!(fmt, \"{:?}\", err.description())?;\n+                    }\n+                }\n+\n+                write!(fmt, \")\")\n+            }\n         }\n     }\n \n@@ -532,10 +566,21 @@ impl<'tcx> TerminatorKind<'tcx> {\n             Drop { unwind: Some(_), .. } => {\n                 vec![\"return\".into_cow(), \"unwind\".into_cow()]\n             }\n+            Assert { cleanup: None, .. } => vec![\"\".into()],\n+            Assert { .. } =>\n+                vec![\"success\".into_cow(), \"unwind\".into_cow()]\n         }\n     }\n }\n \n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub enum AssertMessage<'tcx> {\n+    BoundsCheck {\n+        len: Operand<'tcx>,\n+        index: Operand<'tcx>\n+    },\n+    Math(ConstMathErr)\n+}\n \n ///////////////////////////////////////////////////////////////////////////\n // Statements"}, {"sha": "5c9582b945bb8b145211f3b6fa3663dc0dbe1d0e", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=156b1fb9e15f63a8525e934a6857c37823b49c0e", "patch": "@@ -127,6 +127,11 @@ macro_rules! make_mir_visitor {\n                 self.super_terminator_kind(block, kind);\n             }\n \n+            fn visit_assert_message(&mut self,\n+                                    msg: & $($mutability)* AssertMessage<'tcx>) {\n+                self.super_assert_message(msg);\n+            }\n+\n             fn visit_rvalue(&mut self,\n                             rvalue: & $($mutability)* Rvalue<'tcx>) {\n                 self.super_rvalue(rvalue);\n@@ -426,6 +431,31 @@ macro_rules! make_mir_visitor {\n                         }\n                         cleanup.map(|t| self.visit_branch(block, t));\n                     }\n+\n+                    TerminatorKind::Assert { ref $($mutability)* cond,\n+                                             expected: _,\n+                                             ref $($mutability)* msg,\n+                                             target,\n+                                             cleanup } => {\n+                        self.visit_operand(cond);\n+                        self.visit_assert_message(msg);\n+                        self.visit_branch(block, target);\n+                        cleanup.map(|t| self.visit_branch(block, t));\n+                    }\n+                }\n+            }\n+\n+            fn super_assert_message(&mut self,\n+                                    msg: & $($mutability)* AssertMessage<'tcx>) {\n+                match *msg {\n+                    AssertMessage::BoundsCheck {\n+                        ref $($mutability)* len,\n+                        ref $($mutability)* index\n+                    } => {\n+                        self.visit_operand(len);\n+                        self.visit_operand(index);\n+                    }\n+                    AssertMessage::Math(_) => {}\n                 }\n             }\n "}, {"sha": "81655b5e386f626ea074a7bc77da633b10270648", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs?ref=156b1fb9e15f63a8525e934a6857c37823b49c0e", "patch": "@@ -450,13 +450,14 @@ impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D>\n             repr::TerminatorKind::Return |\n             repr::TerminatorKind::Resume => {}\n             repr::TerminatorKind::Goto { ref target } |\n+            repr::TerminatorKind::Assert { ref target, cleanup: None, .. } |\n             repr::TerminatorKind::Drop { ref target, location: _, unwind: None } |\n-\n             repr::TerminatorKind::DropAndReplace {\n                 ref target, value: _, location: _, unwind: None\n             } => {\n                 self.propagate_bits_into_entry_set_for(in_out, changed, target);\n             }\n+            repr::TerminatorKind::Assert { ref target, cleanup: Some(ref unwind), .. } |\n             repr::TerminatorKind::Drop { ref target, location: _, unwind: Some(ref unwind) } |\n             repr::TerminatorKind::DropAndReplace {\n                 ref target, value: _, location: _, unwind: Some(ref unwind)"}, {"sha": "27d208240ac1cd2d8dc730585838f90ce8ef7bd7", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=156b1fb9e15f63a8525e934a6857c37823b49c0e", "patch": "@@ -663,6 +663,22 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n                 bb_ctxt.on_operand(SK::If, cond, source);\n             }\n \n+            TerminatorKind::Assert {\n+                ref cond, expected: _,\n+                ref msg, target: _, cleanup: _\n+            } => {\n+                // The `cond` is always of (copyable) type `bool`,\n+                // so there will never be anything to move.\n+                let _ = cond;\n+                match *msg {\n+                    AssertMessage:: BoundsCheck { ref len, ref index } => {\n+                        // Same for the usize length and index in bounds-checking.\n+                        let _ = (len, index);\n+                    }\n+                    AssertMessage::Math(_) => {}\n+                }\n+            }\n+\n             TerminatorKind::SwitchInt { switch_ty: _, values: _, targets: _, ref discr } |\n             TerminatorKind::Switch { adt_def: _, targets: _, ref discr } => {\n                 // The `discr` is not consumed; that is instead"}, {"sha": "9970810d4e278c58227bcf418a2abc4413ca5d5b", "filename": "src/librustc_const_math/err.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_const_math%2Ferr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_const_math%2Ferr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Ferr.rs?ref=156b1fb9e15f63a8525e934a6857c37823b49c0e", "patch": "@@ -10,7 +10,7 @@\n \n use syntax::ast;\n \n-#[derive(Debug, PartialEq, Eq, Clone)]\n+#[derive(Debug, PartialEq, Eq, Clone, RustcEncodable, RustcDecodable)]\n pub enum ConstMathErr {\n     NotInRange,\n     CmpBetweenUnequalTypes,\n@@ -25,7 +25,7 @@ pub enum ConstMathErr {\n }\n pub use self::ConstMathErr::*;\n \n-#[derive(Debug, PartialEq, Eq, Clone)]\n+#[derive(Debug, PartialEq, Eq, Clone, RustcEncodable, RustcDecodable)]\n pub enum Op {\n     Add,\n     Sub,"}, {"sha": "c1626b93f0c4181f1f9c18d4729fd04a2c9e01c6", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=156b1fb9e15f63a8525e934a6857c37823b49c0e", "patch": "@@ -12,7 +12,6 @@ use build::{BlockAnd, BlockAndExtension, Builder};\n use hair::*;\n use rustc::mir::repr::*;\n use rustc::hir;\n-use syntax::codemap::Span;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn ast_block(&mut self,\n@@ -82,22 +81,4 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             block.unit()\n         })\n     }\n-\n-    // Helper method for generating a conditional branch\n-    // Returns (TrueBlock, FalseBlock)\n-    pub fn build_cond_br(&mut self, block: BasicBlock, span: Span,\n-                         cond: Operand<'tcx>) -> (BasicBlock, BasicBlock) {\n-        let scope_id = self.innermost_scope_id();\n-\n-        let then_block = self.cfg.start_new_block();\n-        let else_block = self.cfg.start_new_block();\n-\n-        self.cfg.terminate(block, scope_id, span,\n-                           TerminatorKind::If {\n-                               cond: cond,\n-                               targets: (then_block, else_block)\n-                           });\n-\n-        (then_block, else_block)\n-    }\n }"}, {"sha": "bb5aca2d8d7c3db2d626c56c2ad5be1a43a62bb5", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=156b1fb9e15f63a8525e934a6857c37823b49c0e", "patch": "@@ -66,15 +66,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                                            idx.clone(),\n                                                            Operand::Consume(len.clone())));\n \n-                let (success, failure) = (this.cfg.start_new_block(), this.cfg.start_new_block());\n-                this.cfg.terminate(block,\n-                                   scope_id,\n-                                   expr_span,\n-                                   TerminatorKind::If {\n-                                       cond: Operand::Consume(lt),\n-                                       targets: (success, failure),\n-                                   });\n-                this.panic_bounds_check(failure, idx.clone(), Operand::Consume(len), expr_span);\n+                let msg = AssertMessage::BoundsCheck {\n+                    len: Operand::Consume(len),\n+                    index: idx.clone()\n+                };\n+                let success = this.assert(block, Operand::Consume(lt), true,\n+                                          msg, expr_span);\n                 success.and(slice.index(idx))\n             }\n             ExprKind::SelfRef => {"}, {"sha": "40b2fa61c133b053b9f5650c94ec8da8f34948d2", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=156b1fb9e15f63a8525e934a6857c37823b49c0e", "patch": "@@ -12,6 +12,7 @@\n \n use std;\n \n+use rustc_const_math::{ConstMathErr, Op};\n use rustc_data_structures::fnv::FnvHashMap;\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n@@ -88,10 +89,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     this.cfg.push_assign(block, scope_id, expr_span, &is_min,\n                                          Rvalue::BinaryOp(BinOp::Eq, arg.clone(), minval));\n \n-                    let (of_block, ok_block) = this.build_cond_br(block, expr_span,\n-                                                                  Operand::Consume(is_min));\n-                    this.panic(of_block, \"attempted to negate with overflow\", expr_span);\n-                    block = ok_block;\n+                    let err = ConstMathErr::Overflow(Op::Neg);\n+                    block = this.assert(block, Operand::Consume(is_min), false,\n+                                        AssertMessage::Math(err), expr_span);\n                 }\n                 block.and(Rvalue::UnaryOp(op, arg))\n             }\n@@ -261,27 +261,32 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             let val = result_value.clone().field(val_fld, ty);\n             let of = result_value.field(of_fld, bool_ty);\n \n-            let msg = if op == BinOp::Shl || op == BinOp::Shr {\n-                \"shift operation overflowed\"\n-            } else {\n-                \"arithmetic operation overflowed\"\n-            };\n+            let err = ConstMathErr::Overflow(match op {\n+                BinOp::Add => Op::Add,\n+                BinOp::Sub => Op::Sub,\n+                BinOp::Mul => Op::Mul,\n+                BinOp::Shl => Op::Shl,\n+                BinOp::Shr => Op::Shr,\n+                _ => {\n+                    bug!(\"MIR build_binary_op: {:?} is not checkable\", op)\n+                }\n+            });\n \n-            let (of_block, ok_block) = self.build_cond_br(block, span, Operand::Consume(of));\n-            self.panic(of_block, msg, span);\n+            block = self.assert(block, Operand::Consume(of), false,\n+                                AssertMessage::Math(err), span);\n \n-            ok_block.and(Rvalue::Use(Operand::Consume(val)))\n+            block.and(Rvalue::Use(Operand::Consume(val)))\n         } else {\n             if ty.is_integral() && (op == BinOp::Div || op == BinOp::Rem) {\n                 // Checking division and remainder is more complex, since we 1. always check\n                 // and 2. there are two possible failure cases, divide-by-zero and overflow.\n \n-                let (zero_msg, overflow_msg) = if op == BinOp::Div {\n-                    (\"attempted to divide by zero\",\n-                     \"attempted to divide with overflow\")\n+                let (zero_err, overflow_err) = if op == BinOp::Div {\n+                    (ConstMathErr::DivisionByZero,\n+                     ConstMathErr::Overflow(Op::Div))\n                 } else {\n-                    (\"attempted remainder with a divisor of zero\",\n-                     \"attempted remainder with overflow\")\n+                    (ConstMathErr::RemainderByZero,\n+                     ConstMathErr::Overflow(Op::Rem))\n                 };\n \n                 // Check for / 0\n@@ -290,11 +295,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 self.cfg.push_assign(block, scope_id, span, &is_zero,\n                                      Rvalue::BinaryOp(BinOp::Eq, rhs.clone(), zero));\n \n-                let (zero_block, ok_block) = self.build_cond_br(block, span,\n-                                                                Operand::Consume(is_zero));\n-                self.panic(zero_block, zero_msg, span);\n-\n-                block = ok_block;\n+                block = self.assert(block, Operand::Consume(is_zero), false,\n+                                    AssertMessage::Math(zero_err), span);\n \n                 // We only need to check for the overflow in one case:\n                 // MIN / -1, and only for signed values.\n@@ -318,11 +320,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     self.cfg.push_assign(block, scope_id, span, &of,\n                                          Rvalue::BinaryOp(BinOp::BitAnd, is_neg_1, is_min));\n \n-                    let (of_block, ok_block) = self.build_cond_br(block, span,\n-                                                                  Operand::Consume(of));\n-                    self.panic(of_block, overflow_msg, span);\n-\n-                    block = ok_block;\n+                    block = self.assert(block, Operand::Consume(of), false,\n+                                        AssertMessage::Math(overflow_err), span);\n                 }\n             }\n "}, {"sha": "209649dd2fd1832a2f8f335ca24dafeb78bce770", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 27, "deletions": 42, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=156b1fb9e15f63a8525e934a6857c37823b49c0e", "patch": "@@ -517,7 +517,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     }\n \n \n-\n     pub fn build_drop_and_replace(&mut self,\n                                   block: BasicBlock,\n                                   span: Span,\n@@ -538,48 +537,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         next_target.unit()\n     }\n \n-    // Panicking\n-    // =========\n-    // FIXME: should be moved into their own module\n-    pub fn panic_bounds_check(&mut self,\n-                              block: BasicBlock,\n-                              index: Operand<'tcx>,\n-                              len: Operand<'tcx>,\n-                              span: Span) {\n-        // fn(&(filename: &'static str, line: u32), index: usize, length: usize) -> !\n-        let region = ty::ReStatic; // FIXME(mir-borrowck): use a better region?\n-        let func = self.lang_function(lang_items::PanicBoundsCheckFnLangItem);\n-        let args = self.hir.tcx().replace_late_bound_regions(&func.ty.fn_args(), |_| region).0;\n-\n-        let ref_ty = args[0];\n-        let tup_ty = if let ty::TyRef(_, tyandmut) = ref_ty.sty {\n-            tyandmut.ty\n-        } else {\n-            span_bug!(span, \"unexpected panic_bound_check type: {:?}\", func.ty);\n-        };\n-\n-        let (tuple, tuple_ref) = (self.temp(tup_ty), self.temp(ref_ty));\n-        let (file, line) = self.span_to_fileline_args(span);\n-        let elems = vec![Operand::Constant(file), Operand::Constant(line)];\n-        let scope_id = self.innermost_scope_id();\n-        // FIXME: We should have this as a constant, rather than a stack variable (to not pollute\n-        // icache with cold branch code), however to achieve that we either have to rely on rvalue\n-        // promotion or have some way, in MIR, to create constants.\n-        self.cfg.push_assign(block, scope_id, span, &tuple, // tuple = (file_arg, line_arg);\n-                             Rvalue::Aggregate(AggregateKind::Tuple, elems));\n-        // FIXME: is this region really correct here?\n-        self.cfg.push_assign(block, scope_id, span, &tuple_ref, // tuple_ref = &tuple;\n-                             Rvalue::Ref(region, BorrowKind::Shared, tuple));\n-        let cleanup = self.diverge_cleanup();\n-        self.cfg.terminate(block, scope_id, span, TerminatorKind::Call {\n-            func: Operand::Constant(func),\n-            args: vec![Operand::Consume(tuple_ref), index, len],\n-            destination: None,\n-            cleanup: cleanup,\n-        });\n-    }\n-\n     /// Create diverge cleanup and branch to it from `block`.\n+    // FIXME: Remove this (used only for unreachable cases in match).\n     pub fn panic(&mut self, block: BasicBlock, msg: &'static str, span: Span) {\n         // fn(&(msg: &'static str filename: &'static str, line: u32)) -> !\n         let region = ty::ReStatic; // FIXME(mir-borrowck): use a better region?\n@@ -622,6 +581,32 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         });\n     }\n \n+    /// Create an Assert terminator and return the success block.\n+    /// If the boolean condition operand is not the expected value,\n+    /// a runtime panic will be caused with the given message.\n+    pub fn assert(&mut self, block: BasicBlock,\n+                  cond: Operand<'tcx>,\n+                  expected: bool,\n+                  msg: AssertMessage<'tcx>,\n+                  span: Span)\n+                  -> BasicBlock {\n+        let scope_id = self.innermost_scope_id();\n+\n+        let success_block = self.cfg.start_new_block();\n+        let cleanup = self.diverge_cleanup();\n+\n+        self.cfg.terminate(block, scope_id, span,\n+                           TerminatorKind::Assert {\n+                               cond: cond,\n+                               expected: expected,\n+                               msg: msg,\n+                               target: success_block,\n+                               cleanup: cleanup\n+                           });\n+\n+        success_block\n+    }\n+\n     fn lang_function(&mut self, lang_item: lang_items::LangItem) -> Constant<'tcx> {\n         let funcdid = match self.hir.tcx().lang_items.require(lang_item) {\n             Ok(d) => d,"}, {"sha": "590106e0a225be4eef740171ae90c24705eb203d", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=156b1fb9e15f63a8525e934a6857c37823b49c0e", "patch": "@@ -30,6 +30,7 @@ impl<'tcx> MutVisitor<'tcx> for NoLandingPads {\n                 /* nothing to do */\n             },\n             TerminatorKind::Call { cleanup: ref mut unwind, .. } |\n+            TerminatorKind::Assert { cleanup: ref mut unwind, .. } |\n             TerminatorKind::DropAndReplace { ref mut unwind, .. } |\n             TerminatorKind::Drop { ref mut unwind, .. } => {\n                 unwind.take();"}, {"sha": "b9eec6ecd9c5890260911d971a404a8ce0d30586", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 2, "deletions": 64, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=156b1fb9e15f63a8525e934a6857c37823b49c0e", "patch": "@@ -332,61 +332,6 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n         }\n     }\n \n-    /// Returns true if the block ends in a bounds check branch, i.e.:\n-    /// len = Len(array);\n-    /// cond = Lt(idx, len);\n-    /// if cond {\n-    ///     ...\n-    /// } else {\n-    ///     loc = (...);\n-    ///     loc_ref = &loc;\n-    ///     panic_bounds_check(loc_ref, idx, len);\n-    /// }\n-    fn is_bounds_check(&self, bb: BasicBlock,\n-                       cond_op: &Operand<'tcx>,\n-                       if_else: BasicBlock) -> bool {\n-        use rustc::mir::repr::Lvalue::*;\n-        use rustc::mir::repr::Operand::Consume;\n-        use rustc::mir::repr::Rvalue::*;\n-        use rustc::mir::repr::StatementKind::*;\n-        use rustc::mir::repr::TerminatorKind::*;\n-\n-        let stmts = &self.mir[bb].statements;\n-        let stmts_panic = &self.mir[if_else].statements;\n-        if stmts.len() < 2 || stmts_panic.len() != 2 {\n-            return false;\n-        }\n-\n-        let all = (&stmts[stmts.len() - 2].kind,\n-                   &stmts[stmts.len() - 1].kind,\n-                   cond_op,\n-                   &stmts_panic[0].kind,\n-                   &stmts_panic[1].kind,\n-                   &self.mir[if_else].terminator().kind);\n-        match all {\n-            (&Assign(Temp(len), Len(_)),\n-             &Assign(Temp(cond), BinaryOp(BinOp::Lt, ref idx, Consume(Temp(len2)))),\n-             /* if */ &Consume(Temp(cond2)), /* {...} else */\n-             &Assign(Temp(loc), Aggregate(..)),\n-             &Assign(Temp(loc_ref), Ref(_, _, Temp(loc2))),\n-             &Call {\n-                func: Operand::Constant(Constant {\n-                    literal: Literal::Item { def_id, .. }, ..\n-                }),\n-                ref args,\n-                destination: None,\n-                ..\n-            }) => {\n-                len == len2 && cond == cond2 && loc == loc2 &&\n-                args[0] == Consume(Temp(loc_ref)) &&\n-                args[1] == *idx &&\n-                args[2] == Consume(Temp(len)) &&\n-                Some(def_id) == self.tcx.lang_items.panic_bounds_check_fn()\n-            }\n-            _ => false\n-        }\n-    }\n-\n     /// Qualify a whole const, static initializer or const fn.\n     fn qualify_const(&mut self) -> Qualif {\n         let mir = self.mir;\n@@ -402,6 +347,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                 TerminatorKind::Goto { target } |\n                 // Drops are considered noops.\n                 TerminatorKind::Drop { target, .. } |\n+                TerminatorKind::Assert { target, .. } |\n                 TerminatorKind::Call { destination: Some((_, target)), .. } => {\n                     Some(target)\n                 }\n@@ -411,15 +357,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                     return Qualif::empty();\n                 }\n \n-                // Need to allow bounds checking branches.\n-                TerminatorKind::If { ref cond, targets: (if_true, if_else) } => {\n-                    if self.is_bounds_check(bb, cond, if_else) {\n-                        Some(if_true)\n-                    } else {\n-                        None\n-                    }\n-                }\n-\n+                TerminatorKind::If {..} |\n                 TerminatorKind::Switch {..} |\n                 TerminatorKind::SwitchInt {..} |\n                 TerminatorKind::DropAndReplace { .. } |"}, {"sha": "d008918026ab8bab84a21753af82bb93bcab2889", "filename": "src/librustc_mir/transform/simplify_cfg.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs?ref=156b1fb9e15f63a8525e934a6857c37823b49c0e", "patch": "@@ -181,7 +181,17 @@ fn simplify_branches(mir: &mut Mir) {\n                     }\n                 }\n \n+                TerminatorKind::Assert { target, cond: Operand::Constant(Constant {\n+                    literal: Literal::Value {\n+                        value: ConstVal::Bool(cond)\n+                    }, ..\n+                }), expected, .. } if cond == expected => {\n+                    changed = true;\n+                    TerminatorKind::Goto { target: target }\n+                }\n+\n                 TerminatorKind::SwitchInt { ref targets, .. } if targets.len() == 1 => {\n+                    changed = true;\n                     TerminatorKind::Goto { target: targets[0] }\n                 }\n                 _ => continue"}, {"sha": "019ed670d1f83d16cec395d97deec990a4c77faa", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=156b1fb9e15f63a8525e934a6857c37823b49c0e", "patch": "@@ -431,6 +431,21 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     self.check_call_inputs(mir, term, &sig, args);\n                 }\n             }\n+            TerminatorKind::Assert { ref cond, ref msg, .. } => {\n+                let cond_ty = mir.operand_ty(tcx, cond);\n+                if cond_ty != tcx.types.bool {\n+                    span_mirbug!(self, term, \"bad Assert ({:?}, not bool\", cond_ty);\n+                }\n+\n+                if let AssertMessage::BoundsCheck { ref len, ref index } = *msg {\n+                    if mir.operand_ty(tcx, len) != tcx.types.usize {\n+                        span_mirbug!(self, len, \"bounds-check length non-usize {:?}\", len)\n+                    }\n+                    if mir.operand_ty(tcx, index) != tcx.types.usize {\n+                        span_mirbug!(self, index, \"bounds-check index non-usize {:?}\", index)\n+                    }\n+                }\n+            }\n         }\n     }\n \n@@ -561,7 +576,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 }\n             }\n             TerminatorKind::Drop { target, unwind, .. } |\n-            TerminatorKind::DropAndReplace { target, unwind, .. } => {\n+            TerminatorKind::DropAndReplace { target, unwind, .. } |\n+            TerminatorKind::Assert { target, cleanup: unwind, .. } => {\n                 self.assert_iscleanup(mir, block, target, is_cleanup);\n                 if let Some(unwind) = unwind {\n                     if is_cleanup {"}, {"sha": "f524bc8596a5460d6b6d6823e5542d95cd22e59f", "filename": "src/librustc_trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_trans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_trans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2F_match.rs?ref=156b1fb9e15f63a8525e934a6857c37823b49c0e", "patch": "@@ -880,7 +880,7 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                rhs_t: Ty<'tcx>,\n                                debug_loc: DebugLoc)\n                                -> Result<'blk, 'tcx> {\n-        let did = langcall(bcx,\n+        let did = langcall(bcx.tcx(),\n                            None,\n                            &format!(\"comparison of `{}`\", rhs_t),\n                            StrEqFnLangItem);"}, {"sha": "e9b7b590b19a241d8db171b61e11fccc0ca47999", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=156b1fb9e15f63a8525e934a6857c37823b49c0e", "patch": "@@ -1165,18 +1165,18 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     })\n }\n \n-pub fn langcall(bcx: Block,\n+pub fn langcall(tcx: TyCtxt,\n                 span: Option<Span>,\n                 msg: &str,\n                 li: LangItem)\n                 -> DefId {\n-    match bcx.tcx().lang_items.require(li) {\n+    match tcx.lang_items.require(li) {\n         Ok(id) => id,\n         Err(s) => {\n             let msg = format!(\"{} {}\", msg, s);\n             match span {\n-                Some(span) => bcx.tcx().sess.span_fatal(span, &msg[..]),\n-                None => bcx.tcx().sess.fatal(&msg[..]),\n+                Some(span) => tcx.sess.span_fatal(span, &msg[..]),\n+                None => tcx.sess.fatal(&msg[..]),\n             }\n         }\n     }"}, {"sha": "0f686227c6f98f3241f980a5ece22ac8cfb093c8", "filename": "src/librustc_trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_trans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_trans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontrolflow.rs?ref=156b1fb9e15f63a8525e934a6857c37823b49c0e", "patch": "@@ -400,7 +400,7 @@ pub fn trans_fail<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let align = machine::llalign_of_min(ccx, val_ty(expr_file_line_const));\n     let expr_file_line = consts::addr_of(ccx, expr_file_line_const, align, \"panic_loc\");\n     let args = vec!(expr_file_line);\n-    let did = langcall(bcx, Some(call_info.span), \"\", PanicFnLangItem);\n+    let did = langcall(bcx.tcx(), Some(call_info.span), \"\", PanicFnLangItem);\n     Callee::def(ccx, did, ccx.tcx().mk_substs(Substs::empty()))\n         .call(bcx, call_info.debug_loc(), ArgVals(&args), None).bcx\n }\n@@ -428,7 +428,7 @@ pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let align = machine::llalign_of_min(ccx, val_ty(file_line_const));\n     let file_line = consts::addr_of(ccx, file_line_const, align, \"panic_bounds_check_loc\");\n     let args = vec!(file_line, index, len);\n-    let did = langcall(bcx, Some(call_info.span), \"\", PanicBoundsCheckFnLangItem);\n+    let did = langcall(bcx.tcx(), Some(call_info.span), \"\", PanicBoundsCheckFnLangItem);\n     Callee::def(ccx, did, ccx.tcx().mk_substs(Substs::empty()))\n         .call(bcx, call_info.debug_loc(), ArgVals(&args), None).bcx\n }"}, {"sha": "465ebace1b8307858defaa10fff42a687ad8d5da", "filename": "src/librustc_trans/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_trans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_trans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fexpr.rs?ref=156b1fb9e15f63a8525e934a6857c37823b49c0e", "patch": "@@ -2230,11 +2230,11 @@ impl OverflowOpViaIntrinsic {\n                         binop_debug_loc);\n \n         let expect = bcx.ccx().get_intrinsic(&\"llvm.expect.i1\");\n-        Call(bcx, expect, &[cond, C_integral(Type::i1(bcx.ccx()), 0, false)],\n-             binop_debug_loc);\n+        let expected = Call(bcx, expect, &[cond, C_bool(bcx.ccx(), false)],\n+                            binop_debug_loc);\n \n         let bcx =\n-            base::with_cond(bcx, cond, |bcx|\n+            base::with_cond(bcx, expected, |bcx|\n                 controlflow::trans_fail(bcx, info,\n                     InternedString::new(\"arithmetic operation overflowed\")));\n "}, {"sha": "211efeb4e4baa6209ee8f8cb8797cbd206bd032b", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=156b1fb9e15f63a8525e934a6857c37823b49c0e", "patch": "@@ -53,7 +53,7 @@ pub fn trans_exchange_free_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                            -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_exchange_free\");\n \n-    let def_id = langcall(bcx, None, \"\", ExchangeFreeFnLangItem);\n+    let def_id = langcall(bcx.tcx(), None, \"\", ExchangeFreeFnLangItem);\n     let args = [PointerCast(bcx, v, Type::i8p(bcx.ccx())), size, align];\n     Callee::def(bcx.ccx(), def_id, bcx.tcx().mk_substs(Substs::empty()))\n         .call(bcx, debug_loc, ArgVals(&args), None).bcx"}, {"sha": "bce639ac8f76ef1b105645425ddb273b1b23c726", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=156b1fb9e15f63a8525e934a6857c37823b49c0e", "patch": "@@ -161,6 +161,7 @@ pub fn cleanup_kinds<'bcx,'tcx>(_bcx: Block<'bcx,'tcx>,\n                     /* nothing to do */\n                 }\n                 TerminatorKind::Call { cleanup: unwind, .. } |\n+                TerminatorKind::Assert { cleanup: unwind, .. } |\n                 TerminatorKind::DropAndReplace { unwind, .. } |\n                 TerminatorKind::Drop { unwind, .. } => {\n                     if let Some(unwind) = unwind {"}, {"sha": "e4d137d36ac375d0e0e9a67086bdd467500aebad", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 92, "deletions": 1, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=156b1fb9e15f63a8525e934a6857c37823b49c0e", "patch": "@@ -9,22 +9,27 @@\n // except according to those terms.\n \n use llvm::{self, ValueRef};\n+use rustc::middle::lang_items;\n use rustc::ty;\n use rustc::mir::repr as mir;\n use abi::{Abi, FnType, ArgType};\n use adt;\n use base;\n use build;\n use callee::{Callee, CalleeData, Fn, Intrinsic, NamedTupleConstructor, Virtual};\n-use common::{self, type_is_fat_ptr, Block, BlockAndBuilder, LandingPad, C_undef};\n+use common::{self, type_is_fat_ptr, Block, BlockAndBuilder, LandingPad};\n+use common::{C_bool, C_str_slice, C_struct, C_u32, C_undef};\n+use consts;\n use debuginfo::DebugLoc;\n use Disr;\n use machine::{llalign_of_min, llbitsize_of_real};\n use meth;\n use type_of;\n use glue;\n use type_::Type;\n+\n use rustc_data_structures::fnv::FnvHashMap;\n+use syntax::parse::token;\n \n use super::{MirContext, TempRef};\n use super::analyze::CleanupKind;\n@@ -212,6 +217,92 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 }\n             }\n \n+            mir::TerminatorKind::Assert { ref cond, expected, ref msg, target, cleanup } => {\n+                let cond = self.trans_operand(&bcx, cond).immediate();\n+                let const_cond = common::const_to_opt_uint(cond).map(|c| c == 1);\n+\n+                // Don't translate the panic block if success if known.\n+                let lltarget = self.llblock(target);\n+                if const_cond == Some(expected) {\n+                    funclet_br(bcx, lltarget);\n+                    return;\n+                }\n+\n+                if const_cond == Some(!expected) {\n+                    // Do nothing to end up with an unconditional panic.\n+                } else {\n+                    // Pass the condition through llvm.expect for branch hinting.\n+                    let expect = bcx.ccx().get_intrinsic(&\"llvm.expect.i1\");\n+                    let cond = bcx.call(expect, &[cond, C_bool(bcx.ccx(), expected)], None);\n+\n+                    // Create the failure block and the conditional branch to it.\n+                    // After this point, bcx is the block for the call to panic.\n+                    let panic_block = self.fcx.new_block(\"panic\", None);\n+                    if expected {\n+                        bcx.cond_br(cond, lltarget, panic_block.llbb);\n+                    } else {\n+                        bcx.cond_br(cond, panic_block.llbb, lltarget);\n+                    }\n+                    bcx = panic_block.build();\n+                }\n+\n+                // Get the location information.\n+                let loc = bcx.sess().codemap().lookup_char_pos(terminator.span.lo);\n+                let filename = token::intern_and_get_ident(&loc.file.name);\n+                let filename = C_str_slice(bcx.ccx(), filename);\n+                let line = C_u32(bcx.ccx(), loc.line as u32);\n+\n+                // Put together the arguments to the panic entry point.\n+                let (lang_item, args) = match *msg {\n+                    mir::AssertMessage::BoundsCheck { ref len, ref index } => {\n+                        let len = self.trans_operand(&mut bcx, len);\n+                        let index = self.trans_operand(&mut bcx, index);\n+\n+                        let file_line = C_struct(bcx.ccx(), &[filename, line], false);\n+                        let align = llalign_of_min(bcx.ccx(), common::val_ty(file_line));\n+                        let file_line = consts::addr_of(bcx.ccx(),\n+                                                        file_line,\n+                                                        align,\n+                                                        \"panic_bounds_check_loc\");\n+                        (lang_items::PanicBoundsCheckFnLangItem,\n+                         vec![file_line, index.immediate(), len.immediate()])\n+                    }\n+                    mir::AssertMessage::Math(ref err) => {\n+                        let msg_str = token::intern_and_get_ident(err.description());\n+                        let msg_str = C_str_slice(bcx.ccx(), msg_str);\n+                        let msg_file_line = C_struct(bcx.ccx(),\n+                                                     &[msg_str, filename, line],\n+                                                     false);\n+                        let align = llalign_of_min(bcx.ccx(), common::val_ty(msg_file_line));\n+                        let msg_file_line = consts::addr_of(bcx.ccx(),\n+                                                            msg_file_line,\n+                                                            align,\n+                                                            \"panic_loc\");\n+                        (lang_items::PanicFnLangItem, vec![msg_file_line])\n+                    }\n+                };\n+\n+                // Obtain the panic entry point.\n+                let def_id = common::langcall(bcx.tcx(), Some(terminator.span), \"\", lang_item);\n+                let callee = Callee::def(bcx.ccx(), def_id,\n+                    bcx.ccx().empty_substs_for_def_id(def_id));\n+                let llfn = callee.reify(bcx.ccx()).val;\n+\n+                // Translate the actual panic invoke/call.\n+                if let Some(unwind) = cleanup {\n+                    let uwbcx = self.bcx(unwind);\n+                    let unwind = self.make_landing_pad(uwbcx);\n+                    bcx.invoke(llfn,\n+                               &args,\n+                               self.unreachable_block().llbb,\n+                               unwind.llbb(),\n+                               cleanup_bundle.as_ref());\n+                } else {\n+                    bcx.call(llfn, &args, cleanup_bundle.as_ref());\n+                    bcx.unreachable();\n+                }\n+            }\n+\n             mir::TerminatorKind::DropAndReplace { .. } => {\n                 bug!(\"undesugared DropAndReplace in trans: {:?}\", data);\n             }"}, {"sha": "9498a244e80e702eb028f801e7b2a93b0132ed77", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=156b1fb9e15f63a8525e934a6857c37823b49c0e", "patch": "@@ -287,14 +287,21 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     }))\n                 }\n \n-                // This is only supported to make bounds checking work.\n-                mir::TerminatorKind::If { ref cond, targets: (true_bb, false_bb) } => {\n+                mir::TerminatorKind::Assert { ref cond, expected, ref msg, target, .. } => {\n                     let cond = self.const_operand(cond, span)?;\n-                    if common::const_to_uint(cond.llval) != 0 {\n-                        true_bb\n-                    } else {\n-                        false_bb\n+                    let cond_bool = common::const_to_uint(cond.llval) != 0;\n+                    if cond_bool != expected {\n+                        let err = match *msg {\n+                            mir::AssertMessage::BoundsCheck {..} => {\n+                                ErrKind::IndexOutOfBounds\n+                            }\n+                            mir::AssertMessage::Math(ref err) => {\n+                                ErrKind::Math(err.clone())\n+                            }\n+                        };\n+                        consts::const_err(self.ccx, span, Err(err), TrueConst::Yes)?;\n                     }\n+                    target\n                 }\n \n                 mir::TerminatorKind::Call { ref func, ref args, ref destination, .. } => {\n@@ -308,13 +315,6 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                        func, fn_ty)\n                     };\n \n-                    // Indexing OOB doesn't call a const fn, handle it.\n-                    if Some(instance.def) == tcx.lang_items.panic_bounds_check_fn() {\n-                        consts::const_err(self.ccx, span,\n-                                          Err(ErrKind::IndexOutOfBounds),\n-                                          TrueConst::Yes)?;\n-                    }\n-\n                     let args = args.iter().map(|arg| {\n                         self.const_operand(arg, span)\n                     }).collect::<Result<Vec<_>, _>>()?;"}, {"sha": "b0567ab26e778b1e8147d87d1d7ceb6ac8de2bc1", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/156b1fb9e15f63a8525e934a6857c37823b49c0e/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=156b1fb9e15f63a8525e934a6857c37823b49c0e", "patch": "@@ -17,13 +17,13 @@ use asm;\n use base;\n use callee::Callee;\n use common::{self, val_ty,\n-             C_null,\n-             C_uint, C_undef, C_u8, BlockAndBuilder, Result};\n+             C_null, C_uint, C_undef, BlockAndBuilder, Result};\n use datum::{Datum, Lvalue};\n use debuginfo::DebugLoc;\n use adt;\n use machine;\n use type_of;\n+use type_::Type;\n use tvec;\n use value::Value;\n use Disr;\n@@ -611,9 +611,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 (val, bcx.zext(of, Type::bool(bcx.ccx())))\n             }\n             _ => {\n-                // Fall back to regular translation with a constant-false overflow flag\n-                (self.trans_scalar_binop(bcx, op, lhs, rhs, input_ty),\n-                 C_u8(bcx.ccx(), 0))\n+                bug!(\"Operator `{:?}` is not a checkable operator\", op)\n             }\n         };\n "}]}