{"sha": "db8a00bd99cdc10ae8166fca3827eefebf791471", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiOGEwMGJkOTljZGMxMGFlODE2NmZjYTM4MjdlZWZlYmY3OTE0NzE=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-12-05T18:29:57Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-12-05T18:29:57Z"}, "message": "Implement derive(Copy, Clone) properly (well, kind of)", "tree": {"sha": "b6149545fecab05613466689f6e21b5be3e8bd21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6149545fecab05613466689f6e21b5be3e8bd21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db8a00bd99cdc10ae8166fca3827eefebf791471", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db8a00bd99cdc10ae8166fca3827eefebf791471", "html_url": "https://github.com/rust-lang/rust/commit/db8a00bd99cdc10ae8166fca3827eefebf791471", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db8a00bd99cdc10ae8166fca3827eefebf791471/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab4ecca210d8d280a4e216c2b6edfff303269144", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab4ecca210d8d280a4e216c2b6edfff303269144", "html_url": "https://github.com/rust-lang/rust/commit/ab4ecca210d8d280a4e216c2b6edfff303269144"}], "stats": {"total": 248, "additions": 241, "deletions": 7}, "files": [{"sha": "fde50f7e6d37a43a652c3c80138da0d1e5046c1e", "filename": "crates/ra_hir_expand/src/builtin_derive.rs", "status": "modified", "additions": 180, "deletions": 7, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/db8a00bd99cdc10ae8166fca3827eefebf791471/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db8a00bd99cdc10ae8166fca3827eefebf791471/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_derive.rs?ref=db8a00bd99cdc10ae8166fca3827eefebf791471", "patch": "@@ -1,8 +1,15 @@\n //! Builtin derives.\n-use crate::db::AstDatabase;\n-use crate::{name, MacroCallId, MacroDefId, MacroDefKind};\n \n-use crate::quote;\n+use log::debug;\n+\n+use ra_parser::FragmentKind;\n+use ra_syntax::{\n+    ast::{self, AstNode, ModuleItemOwner, NameOwner, TypeParamsOwner},\n+    match_ast,\n+};\n+\n+use crate::db::AstDatabase;\n+use crate::{name, quote, MacroCallId, MacroDefId, MacroDefKind};\n \n macro_rules! register_builtin {\n     ( $(($name:ident, $kind: ident) => $expand:ident),* ) => {\n@@ -41,24 +48,190 @@ register_builtin! {\n     (CLONE_TRAIT, Clone) => clone_expand\n }\n \n+struct BasicAdtInfo {\n+    name: tt::Ident,\n+    type_params: usize,\n+}\n+\n+fn parse_adt(tt: &tt::Subtree) -> Result<BasicAdtInfo, mbe::ExpandError> {\n+    let (parsed, token_map) = mbe::token_tree_to_syntax_node(tt, FragmentKind::Items)?; // FragmentKind::Items doesn't parse attrs?\n+    let macro_items = ast::MacroItems::cast(parsed.syntax_node()).ok_or_else(|| {\n+        debug!(\"derive node didn't parse\");\n+        mbe::ExpandError::UnexpectedToken\n+    })?;\n+    let item = macro_items.items().next().ok_or_else(|| {\n+        debug!(\"no module item parsed\");\n+        mbe::ExpandError::NoMatchingRule\n+    })?;\n+    let node = item.syntax();\n+    let (name, params) = match_ast! {\n+        match node {\n+            ast::StructDef(it) => { (it.name(), it.type_param_list()) },\n+            ast::EnumDef(it) => { (it.name(), it.type_param_list()) },\n+            ast::UnionDef(it) => { (it.name(), it.type_param_list()) },\n+            _ => {\n+                debug!(\"unexpected node is {:?}\", node);\n+                return Err(mbe::ExpandError::ConversionError)\n+            },\n+        }\n+    };\n+    let name = name.ok_or_else(|| {\n+        debug!(\"parsed item has no name\");\n+        mbe::ExpandError::NoMatchingRule\n+    })?;\n+    let name_token_id = token_map.token_by_range(name.syntax().text_range()).ok_or_else(|| {\n+        debug!(\"name token not found\");\n+        mbe::ExpandError::ConversionError\n+    })?;\n+    let name_token = tt::Ident { id: name_token_id, text: name.text().clone() };\n+    let type_params = params.map_or(0, |type_param_list| type_param_list.type_params().count());\n+    Ok(BasicAdtInfo { name: name_token, type_params })\n+}\n+\n+fn make_type_args(n: usize, bound: Vec<tt::TokenTree>) -> Vec<tt::TokenTree> {\n+    let mut result = Vec::<tt::TokenTree>::new();\n+    result.push(tt::Leaf::Punct(tt::Punct { char: '<', spacing: tt::Spacing::Alone }).into());\n+    for i in 0..n {\n+        if i > 0 {\n+            result\n+                .push(tt::Leaf::Punct(tt::Punct { char: ',', spacing: tt::Spacing::Alone }).into());\n+        }\n+        result.push(\n+            tt::Leaf::Ident(tt::Ident {\n+                id: tt::TokenId::unspecified(),\n+                text: format!(\"T{}\", i).into(),\n+            })\n+            .into(),\n+        );\n+        result.extend(bound.iter().cloned());\n+    }\n+    result.push(tt::Leaf::Punct(tt::Punct { char: '>', spacing: tt::Spacing::Alone }).into());\n+    result\n+}\n+\n fn copy_expand(\n     _db: &dyn AstDatabase,\n     _id: MacroCallId,\n-    _tt: &tt::Subtree,\n+    tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n+    let info = parse_adt(tt)?;\n+    let name = info.name;\n+    let bound = (quote! { : std::marker::Copy }).token_trees;\n+    let type_params = make_type_args(info.type_params, bound);\n+    let type_args = make_type_args(info.type_params, Vec::new());\n     let expanded = quote! {\n-        impl Copy for Foo {}\n+        impl ##type_params std::marker::Copy for #name ##type_args {}\n     };\n     Ok(expanded)\n }\n \n fn clone_expand(\n     _db: &dyn AstDatabase,\n     _id: MacroCallId,\n-    _tt: &tt::Subtree,\n+    tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n+    let info = parse_adt(tt)?;\n+    let name = info.name;\n+    let bound = (quote! { : std::clone::Clone }).token_trees;\n+    let type_params = make_type_args(info.type_params, bound);\n+    let type_args = make_type_args(info.type_params, Vec::new());\n     let expanded = quote! {\n-        impl Clone for Foo {}\n+        impl ##type_params std::clone::Clone for #name ##type_args {}\n     };\n     Ok(expanded)\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use crate::{test_db::TestDB, AstId, MacroCallKind, MacroCallLoc, MacroFileKind};\n+    use ra_db::{fixture::WithFixture, SourceDatabase};\n+\n+    fn expand_builtin_derive(s: &str, expander: BuiltinDeriveExpander) -> String {\n+        let (db, file_id) = TestDB::with_single_file(&s);\n+        let parsed = db.parse(file_id);\n+        let items: Vec<_> =\n+            parsed.syntax_node().descendants().filter_map(|it| ast::ModuleItem::cast(it)).collect();\n+\n+        let ast_id_map = db.ast_id_map(file_id.into());\n+\n+        // the first one should be a macro_rules\n+        let def =\n+            MacroDefId { krate: None, ast_id: None, kind: MacroDefKind::BuiltInDerive(expander) };\n+\n+        let loc = MacroCallLoc {\n+            def,\n+            kind: MacroCallKind::Attr(AstId::new(file_id.into(), ast_id_map.ast_id(&items[0]))),\n+        };\n+\n+        let id = db.intern_macro(loc);\n+        let parsed = db.parse_or_expand(id.as_file(MacroFileKind::Items)).unwrap();\n+\n+        // FIXME text() for syntax nodes parsed from token tree looks weird\n+        // because there's no whitespace, see below\n+        parsed.text().to_string()\n+    }\n+\n+    #[test]\n+    fn test_copy_expand_simple() {\n+        let expanded = expand_builtin_derive(\n+            r#\"\n+        #[derive(Copy)]\n+        struct Foo;\n+\"#,\n+            BuiltinDeriveExpander::Copy,\n+        );\n+\n+        assert_eq!(expanded, \"impl <>std::marker::CopyforFoo <>{}\");\n+    }\n+\n+    #[test]\n+    fn test_copy_expand_with_type_params() {\n+        let expanded = expand_builtin_derive(\n+            r#\"\n+        #[derive(Copy)]\n+        struct Foo<A, B>;\n+\"#,\n+            BuiltinDeriveExpander::Copy,\n+        );\n+\n+        assert_eq!(\n+            expanded,\n+            \"impl<T0:std::marker::Copy,T1:std::marker::Copy>std::marker::CopyforFoo<T0,T1>{}\"\n+        );\n+    }\n+\n+    #[test]\n+    fn test_copy_expand_with_lifetimes() {\n+        let expanded = expand_builtin_derive(\n+            r#\"\n+        #[derive(Copy)]\n+        struct Foo<A, B, 'a, 'b>;\n+\"#,\n+            BuiltinDeriveExpander::Copy,\n+        );\n+\n+        // We currently just ignore lifetimes\n+\n+        assert_eq!(\n+            expanded,\n+            \"impl<T0:std::marker::Copy,T1:std::marker::Copy>std::marker::CopyforFoo<T0,T1>{}\"\n+        );\n+    }\n+\n+    #[test]\n+    fn test_clone_expand() {\n+        let expanded = expand_builtin_derive(\n+            r#\"\n+        #[derive(Clone)]\n+        struct Foo<A, B>;\n+\"#,\n+            BuiltinDeriveExpander::Clone,\n+        );\n+\n+        assert_eq!(\n+            expanded,\n+            \"impl<T0:std::clone::Clone,T1:std::clone::Clone>std::clone::CloneforFoo<T0,T1>{}\"\n+        );\n+    }\n+}"}, {"sha": "4f698ff134bcfdc384f1064cead207bcdaa1a593", "filename": "crates/ra_hir_expand/src/quote.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/db8a00bd99cdc10ae8166fca3827eefebf791471/crates%2Fra_hir_expand%2Fsrc%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db8a00bd99cdc10ae8166fca3827eefebf791471/crates%2Fra_hir_expand%2Fsrc%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fquote.rs?ref=db8a00bd99cdc10ae8166fca3827eefebf791471", "patch": "@@ -60,6 +60,15 @@ macro_rules! __quote {\n         }\n     };\n \n+    ( ## $first:ident $($tail:tt)* ) => {\n+        {\n+            let mut tokens = $first.into_iter().map($crate::quote::ToTokenTree::to_token).collect::<Vec<tt::TokenTree>>();\n+            let mut tail_tokens = $crate::quote::IntoTt::to_tokens($crate::__quote!($($tail)*));\n+            tokens.append(&mut tail_tokens);\n+            tokens\n+        }\n+    };\n+\n     // Brace\n     ( { $($tt:tt)* } ) => { $crate::__quote!(@SUBTREE Brace $($tt)*) };\n     // Bracket\n@@ -85,6 +94,7 @@ macro_rules! __quote {\n     ( & ) => {$crate::__quote!(@PUNCT '&')};\n     ( , ) => {$crate::__quote!(@PUNCT ',')};\n     ( : ) => {$crate::__quote!(@PUNCT ':')};\n+    ( :: ) => {$crate::__quote!(@PUNCT ':', ':')};\n     ( . ) => {$crate::__quote!(@PUNCT '.')};\n \n     ( $first:tt $($tail:tt)+ ) => {"}, {"sha": "9c29a054e274157135fd5299848256cdc0ea1147", "filename": "crates/ra_hir_ty/src/tests/macros.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/db8a00bd99cdc10ae8166fca3827eefebf791471/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db8a00bd99cdc10ae8166fca3827eefebf791471/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs?ref=db8a00bd99cdc10ae8166fca3827eefebf791471", "patch": "@@ -266,3 +266,54 @@ fn main() {\n     \"###\n     );\n }\n+\n+#[test]\n+fn infer_derive_clone_simple() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+#[derive(Clone)]\n+struct S;\n+fn test() {\n+    S.clone()<|>;\n+}\n+\n+//- /lib.rs crate:std\n+#[prelude_import]\n+use clone::*;\n+mod clone {\n+    trait Clone {\n+        fn clone(&self) -> Self;\n+    }\n+}\n+\"#,\n+    );\n+    assert_eq!(\"S\", type_at_pos(&db, pos));\n+}\n+\n+#[test]\n+fn infer_derive_clone_with_params() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+#[derive(Clone)]\n+struct S;\n+#[derive(Clone)]\n+struct Wrapper<T>(T);\n+struct NonClone;\n+fn test() {\n+    (Wrapper(S).clone(), Wrapper(NonClone).clone())<|>;\n+}\n+\n+//- /lib.rs crate:std\n+#[prelude_import]\n+use clone::*;\n+mod clone {\n+    trait Clone {\n+        fn clone(&self) -> Self;\n+    }\n+}\n+\"#,\n+    );\n+    assert_eq!(\"(Wrapper<S>, {unknown})\", type_at_pos(&db, pos));\n+}"}]}