{"sha": "22d4483dee55fbf0c9ba48a3ddfd8abe06805c07", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyZDQ0ODNkZWU1NWZiZjBjOWJhNDhhM2RkZmQ4YWJlMDY4MDVjMDc=", "commit": {"author": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-02-07T09:00:08Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-02-07T09:11:31Z"}, "message": "Simplify DefaultNumericFallback", "tree": {"sha": "933310d1c1c2539641087f2eeaabc23e8667c1a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/933310d1c1c2539641087f2eeaabc23e8667c1a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22d4483dee55fbf0c9ba48a3ddfd8abe06805c07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22d4483dee55fbf0c9ba48a3ddfd8abe06805c07", "html_url": "https://github.com/rust-lang/rust/commit/22d4483dee55fbf0c9ba48a3ddfd8abe06805c07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22d4483dee55fbf0c9ba48a3ddfd8abe06805c07/comments", "author": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b8b0a94b05f7189d028d91deda659ed266ef09d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b8b0a94b05f7189d028d91deda659ed266ef09d", "html_url": "https://github.com/rust-lang/rust/commit/8b8b0a94b05f7189d028d91deda659ed266ef09d"}], "stats": {"total": 673, "additions": 61, "deletions": 612}, "files": [{"sha": "b3b5a4a82511e238d53c850e9bd692f3645d6640", "filename": "clippy_lints/src/default_numeric_fallback.rs", "status": "modified", "additions": 38, "deletions": 356, "changes": 394, "blob_url": "https://github.com/rust-lang/rust/blob/22d4483dee55fbf0c9ba48a3ddfd8abe06805c07/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22d4483dee55fbf0c9ba48a3ddfd8abe06805c07/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs?ref=22d4483dee55fbf0c9ba48a3ddfd8abe06805c07", "patch": "@@ -1,17 +1,9 @@\n-use rustc_ast::ast::{Label, LitFloatType, LitIntType, LitKind};\n-use rustc_hir::{\n-    self as hir,\n-    intravisit::{walk_expr, walk_stmt, walk_ty, FnKind, NestedVisitorMap, Visitor},\n-    Body, BodyId, Expr, ExprKind, FnDecl, FnRetTy, Guard, HirId, Lit, Stmt, StmtKind,\n-};\n+use rustc_ast::{LitFloatType, LitIntType, LitKind};\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir::{Expr, ExprKind, HirId, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::{\n-    hir::map::Map,\n-    ty::{self, subst::GenericArgKind, FloatTy, IntTy, Ty, TyCtxt},\n-};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::Span;\n-use rustc_typeck::hir_ty_to_ty;\n+use rustc_middle::ty::{self, FloatTy, IntTy};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n \n use if_chain::if_chain;\n \n@@ -41,363 +33,53 @@ declare_clippy_lint! {\n     /// Use instead:\n     /// ```rust\n     /// let i = 10i32;\n-    /// let f = 1.23f64;\n+    /// let f: f64 = 1.23;\n     /// ```\n     pub DEFAULT_NUMERIC_FALLBACK,\n     restriction,\n     \"usage of unconstrained numeric literals which may cause default numeric fallback.\"\n }\n \n-declare_lint_pass!(DefaultNumericFallback => [DEFAULT_NUMERIC_FALLBACK]);\n-\n-/// Return the body that includes passed `hir_id` if exists.\n-fn enclosing_body_opt(tcx: TyCtxt<'_>, hir_id: HirId) -> Option<BodyId> {\n-    let hir_map = tcx.hir();\n-    let mut trace = vec![(hir_id)];\n-\n-    for (parent, _) in hir_map.parent_iter(hir_id) {\n-        trace.push(parent);\n-        if let Some(body) = hir_map.maybe_body_owned_by(parent) {\n-            if trace.iter().any(|hir_id| *hir_id == body.hir_id) {\n-                return Some(body);\n-            }\n-        }\n-    }\n-\n-    None\n+#[derive(Default)]\n+pub struct DefaultNumericFallback {\n+    /// Hold `init` in `Local` if `Local` has a type annotation.\n+    bounded_inits: FxHashSet<HirId>,\n }\n \n-fn ty_from_hir_ty<'tcx>(cx: &LateContext<'tcx>, hir_ty: &hir::Ty<'tcx>) -> Option<Ty<'tcx>> {\n-    if enclosing_body_opt(cx.tcx, hir_ty.hir_id).is_some() {\n-        cx.typeck_results().node_type_opt(hir_ty.hir_id)\n-    } else {\n-        Some(hir_ty_to_ty(cx.tcx, hir_ty))\n-    }\n-}\n+impl_lint_pass!(DefaultNumericFallback => [DEFAULT_NUMERIC_FALLBACK]);\n \n impl LateLintPass<'_> for DefaultNumericFallback {\n-    fn check_fn(\n-        &mut self,\n-        cx: &LateContext<'tcx>,\n-        _: FnKind<'tcx>,\n-        fn_decl: &'tcx FnDecl<'_>,\n-        body: &'tcx Body<'_>,\n-        _: Span,\n-        _: HirId,\n-    ) {\n-        let ret_ty_bound = match fn_decl.output {\n-            FnRetTy::DefaultReturn(_) => None,\n-            FnRetTy::Return(ty) => Some(ty),\n-        }\n-        .and_then(|ty| {\n-            if is_infer_included(ty) {\n-                None\n-            } else {\n-                ty_from_hir_ty(cx, ty)\n+    fn check_stmt(&mut self, _: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n+        if_chain! {\n+            if let StmtKind::Local(local) = stmt.kind;\n+            if local.ty.is_some();\n+            if let Some(init) = local.init;\n+            then {\n+                self.bounded_inits.insert(init.hir_id);\n             }\n-        });\n-\n-        let mut visitor = NumericFallbackVisitor::new(ret_ty_bound, cx);\n-        visitor.visit_body(body);\n-    }\n-}\n-\n-struct NumericFallbackVisitor<'a, 'tcx> {\n-    /// Stack manages type bound of exprs. The top element holds current expr type.\n-    ty_bounds: Vec<Option<Ty<'tcx>>>,\n-\n-    /// Ret type bound.\n-    ret_ty_bound: Option<Ty<'tcx>>,\n-\n-    /// Break type bounds.\n-    break_ty_bounds: Vec<(Option<Label>, Option<Ty<'tcx>>)>,\n-\n-    cx: &'a LateContext<'tcx>,\n-}\n-\n-impl<'a, 'tcx> NumericFallbackVisitor<'a, 'tcx> {\n-    fn new(ret_ty_bound: Option<Ty<'tcx>>, cx: &'a LateContext<'tcx>) -> Self {\n-        Self {\n-            ty_bounds: vec![ret_ty_bound],\n-            ret_ty_bound,\n-            break_ty_bounds: vec![],\n-            cx,\n         }\n     }\n \n-    /// Check whether a passed literal has potential to cause fallback or not.\n-    fn check_lit(&self, lit: &Lit, lit_ty: Ty<'tcx>) {\n-        let ty_bound = self.ty_bounds.last().unwrap();\n-\n-        let should_lint = match (&lit.node, lit_ty.kind()) {\n-            (LitKind::Int(_, LitIntType::Unsuffixed), ty::Int(ty::IntTy::I32)) => {\n-                // In case integer literal is explicitly bound to i32, then suppress lint.\n-                ty_bound.map_or(true, |ty_bound| !matches!(ty_bound.kind(), ty::Int(IntTy::I32)))\n-            },\n-\n-            (LitKind::Float(_, LitFloatType::Unsuffixed), ty::Float(ty::FloatTy::F64)) => {\n-                // In case float literal is explicitly bound to f64, then suppress lint.\n-                ty_bound.map_or(true, |ty_bound| !matches!(ty_bound.kind(), ty::Float(FloatTy::F64)))\n-            },\n-\n-            _ => false,\n-        };\n-\n-        if should_lint {\n-            span_lint_and_help(\n-                self.cx,\n-                DEFAULT_NUMERIC_FALLBACK,\n-                lit.span,\n-                \"default numeric fallback might occur\",\n-                None,\n-                \"consider adding suffix to avoid default numeric fallback\",\n-            );\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    #[allow(clippy::too_many_lines)]\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        match (&expr.kind, *self.ty_bounds.last().unwrap()) {\n-            (ExprKind::Array(_), Some(last_bound)) => {\n-                if let ty::Array(ty, _) = last_bound.kind() {\n-                    self.ty_bounds.push(Some(ty))\n-                } else {\n-                    self.ty_bounds.push(None)\n-                }\n-            },\n-\n-            (ExprKind::Call(func, args), _) => {\n-                if_chain! {\n-                    if let ExprKind::Path(ref func_path) = func.kind;\n-                    if let Some(def_id) = self.cx.qpath_res(func_path, func.hir_id).opt_def_id();\n-                    then {\n-                        let fn_sig = self.cx.tcx.fn_sig(def_id).skip_binder();\n-                        for (expr, bound) in args.iter().zip(fn_sig.inputs().iter()) {\n-                            // Push found arg type, then visit arg.\n-                            self.ty_bounds.push(Some(bound));\n-                            self.visit_expr(expr);\n-                            self.ty_bounds.pop();\n-                        }\n-                        return;\n-                    } else {\n-                        self.ty_bounds.push(None)\n-                    }\n-                }\n-            },\n-\n-            (ExprKind::MethodCall(_, _, args, _), _) => {\n-                if let Some(def_id) = self.cx.typeck_results().type_dependent_def_id(expr.hir_id) {\n-                    let fn_sig = self.cx.tcx.fn_sig(def_id).skip_binder();\n-                    for (expr, bound) in args.iter().zip(fn_sig.inputs().iter()) {\n-                        self.ty_bounds.push(Some(bound));\n-                        self.visit_expr(expr);\n-                        self.ty_bounds.pop();\n-                    }\n-                    return;\n-                }\n-\n-                self.ty_bounds.push(None)\n-            },\n-\n-            (ExprKind::Tup(exprs), Some(last_bound)) => {\n-                if let ty::Tuple(tys) = last_bound.kind() {\n-                    for (expr, bound) in exprs.iter().zip(tys.iter()) {\n-                        if let GenericArgKind::Type(ty) = bound.unpack() {\n-                            self.ty_bounds.push(Some(ty));\n-                        } else {\n-                            self.ty_bounds.push(None);\n-                        }\n-\n-                        self.visit_expr(expr);\n-                        self.ty_bounds.pop();\n-                    }\n-                    return;\n-                }\n-\n-                self.ty_bounds.push(None)\n-            },\n-\n-            (ExprKind::Lit(lit), _) => {\n-                let ty = self.cx.typeck_results().expr_ty(expr);\n-                self.check_lit(lit, ty);\n-                return;\n-            },\n-\n-            (ExprKind::If(cond, then, else_), last_bound) => {\n-                // Cond has no type bound in any situation.\n-                self.ty_bounds.push(None);\n-                self.visit_expr(cond);\n-                self.ty_bounds.pop();\n-\n-                // Propagate current bound to childs.\n-                self.ty_bounds.push(last_bound);\n-                self.visit_expr(then);\n-                if let Some(else_) = else_ {\n-                    self.visit_expr(else_);\n-                }\n-                self.ty_bounds.pop();\n-                return;\n-            },\n-\n-            (ExprKind::Loop(_, label, ..), last_bound) => {\n-                self.break_ty_bounds.push((*label, last_bound));\n-                walk_expr(self, expr);\n-                self.break_ty_bounds.pop();\n-                return;\n-            },\n-\n-            (ExprKind::Match(arg, arms, _), last_bound) => {\n-                // Match argument has no type bound.\n-                self.ty_bounds.push(None);\n-                self.visit_expr(arg);\n-                for arm in arms.iter() {\n-                    self.visit_pat(arm.pat);\n-                    if let Some(Guard::If(guard)) = arm.guard {\n-                        self.visit_expr(guard);\n-                    }\n-                }\n-                self.ty_bounds.pop();\n-\n-                // Propagate current bound.\n-                self.ty_bounds.push(last_bound);\n-                for arm in arms.iter() {\n-                    self.visit_expr(arm.body);\n-                }\n-                self.ty_bounds.pop();\n-                return;\n-            },\n-\n-            (ExprKind::Block(..), last_bound) => self.ty_bounds.push(last_bound),\n-\n-            (ExprKind::Break(destination, _), _) => {\n-                let ty = destination.label.map_or_else(\n-                    || self.break_ty_bounds.last().unwrap().1,\n-                    |dest_label| {\n-                        self.break_ty_bounds\n-                            .iter()\n-                            .rev()\n-                            .find_map(|(loop_label, ty)| {\n-                                loop_label.map_or(None, |loop_label| {\n-                                    if loop_label.ident == dest_label.ident {\n-                                        Some(*ty)\n-                                    } else {\n-                                        None\n-                                    }\n-                                })\n-                            })\n-                            .unwrap()\n-                    },\n-                );\n-                self.ty_bounds.push(ty);\n-            },\n-\n-            (ExprKind::Ret(_), _) => self.ty_bounds.push(self.ret_ty_bound),\n-\n-            (ExprKind::Struct(qpath, fields, base), _) => {\n-                if_chain! {\n-                    if let Some(def_id) = self.cx.qpath_res(qpath, expr.hir_id).opt_def_id();\n-                    let ty = self.cx.tcx.type_of(def_id);\n-                    if let Some(adt_def) = ty.ty_adt_def();\n-                    if adt_def.is_struct();\n-                    if let Some(variant) = adt_def.variants.iter().next();\n-                    then {\n-                        let fields_def = &variant.fields;\n-\n-                        // Push field type then visit each field expr.\n-                        for field in fields.iter() {\n-                            let field_ty =\n-                                fields_def\n-                                    .iter()\n-                                    .find_map(|f_def| {\n-                                        if f_def.ident == field.ident\n-                                            { Some(self.cx.tcx.type_of(f_def.did)) }\n-                                        else { None }\n-                                    });\n-                            self.ty_bounds.push(field_ty);\n-                            self.visit_expr(field.expr);\n-                            self.ty_bounds.pop();\n-                        }\n-\n-                        // Visit base with no bound.\n-                        if let Some(base) = base {\n-                            self.ty_bounds.push(None);\n-                            self.visit_expr(base);\n-                            self.ty_bounds.pop();\n-                        }\n-                        return;\n-                    }\n-                }\n-                self.ty_bounds.push(None);\n-            },\n-\n-            _ => self.ty_bounds.push(None),\n-        }\n-\n-        walk_expr(self, expr);\n-        self.ty_bounds.pop();\n-    }\n-\n-    fn visit_stmt(&mut self, stmt: &'tcx Stmt<'_>) {\n-        match stmt.kind {\n-            StmtKind::Local(local) => {\n-                let ty = local.ty.and_then(|hir_ty| {\n-                    if is_infer_included(hir_ty) {\n-                        None\n-                    } else {\n-                        ty_from_hir_ty(self.cx, hir_ty)\n-                    }\n-                });\n-                self.ty_bounds.push(ty);\n-            },\n-\n-            _ => self.ty_bounds.push(None),\n-        }\n-\n-        walk_stmt(self, stmt);\n-        self.ty_bounds.pop();\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-}\n-\n-/// Return true if a given ty includes `hir::TyKind::Infer`.\n-fn is_infer_included(ty: &hir::Ty<'_>) -> bool {\n-    let mut infer_ty_finder = InferTyFinder::new();\n-    infer_ty_finder.visit_ty(ty);\n-    infer_ty_finder.found\n-}\n-\n-struct InferTyFinder {\n-    found: bool,\n-}\n-\n-impl InferTyFinder {\n-    fn new() -> Self {\n-        Self { found: false }\n-    }\n-}\n-\n-impl<'tcx> Visitor<'tcx> for InferTyFinder {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_ty(&mut self, ty: &'tcx hir::Ty<'_>) {\n-        match ty.kind {\n-            hir::TyKind::Infer => {\n-                self.found = true;\n-            },\n-            _ => {\n-                walk_ty(self, ty);\n-            },\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        let expr_ty = cx.typeck_results().expr_ty(expr);\n+        let hir_id = expr.hir_id;\n+        if_chain! {\n+            if let ExprKind::Lit(ref lit) = expr.kind;\n+            if matches!(lit.node,\n+                        LitKind::Int(_, LitIntType::Unsuffixed) | LitKind::Float(_, LitFloatType::Unsuffixed));\n+            if matches!(expr_ty.kind(), ty::Int(IntTy::I32) | ty::Float(FloatTy::F64));\n+            if !self.bounded_inits.contains(&hir_id);\n+            if !cx.tcx.hir().parent_iter(hir_id).any(|(ref hir_id, _)| self.bounded_inits.contains(hir_id));\n+            then {\n+                 span_lint_and_help(\n+                    cx,\n+                    DEFAULT_NUMERIC_FALLBACK,\n+                    lit.span,\n+                    \"default numeric fallback might occur\",\n+                    None,\n+                    \"consider adding suffix to avoid default numeric fallback\",\n+                 )\n+            }\n         }\n     }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n }"}, {"sha": "6590613b93ab06ade9e0ee21e88e935e09d9244c", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22d4483dee55fbf0c9ba48a3ddfd8abe06805c07/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22d4483dee55fbf0c9ba48a3ddfd8abe06805c07/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=22d4483dee55fbf0c9ba48a3ddfd8abe06805c07", "patch": "@@ -1028,7 +1028,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box strings::StringAdd);\n     store.register_late_pass(|| box implicit_return::ImplicitReturn);\n     store.register_late_pass(|| box implicit_saturating_sub::ImplicitSaturatingSub);\n-    store.register_late_pass(|| box default_numeric_fallback::DefaultNumericFallback);\n+    store.register_late_pass(|| box default_numeric_fallback::DefaultNumericFallback::default());\n \n     let msrv = conf.msrv.as_ref().and_then(|s| {\n         parse_msrv(s, None, None).or_else(|| {"}, {"sha": "5ca5bc1e9075e4a3422d2274f4323ca410050a38", "filename": "tests/ui/default_numeric_fallback.rs", "status": "modified", "additions": 10, "deletions": 91, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/22d4483dee55fbf0c9ba48a3ddfd8abe06805c07/tests%2Fui%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22d4483dee55fbf0c9ba48a3ddfd8abe06805c07/tests%2Fui%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback.rs?ref=22d4483dee55fbf0c9ba48a3ddfd8abe06805c07", "patch": "@@ -1,99 +1,18 @@\n #![warn(clippy::default_numeric_fallback)]\n #![allow(unused)]\n-#![allow(clippy::never_loop)]\n-#![allow(clippy::no_effect)]\n-#![allow(clippy::unnecessary_operation)]\n-\n-fn ret_i31() -> i32 {\n-    23\n-}\n-\n-fn concrete_arg(x: i32) {}\n-\n-fn generic_arg<T>(t: T) {}\n-\n-struct ConcreteStruct {\n-    x: i32,\n-}\n-\n-struct GenericStruct<T> {\n-    x: T,\n-}\n-\n-struct StructForMethodCallTest {\n-    x: i32,\n-}\n-\n-impl StructForMethodCallTest {\n-    fn concrete_arg(&self, x: i32) {}\n-\n-    fn generic_arg<T>(&self, t: T) {}\n-}\n \n fn main() {\n-    let s = StructForMethodCallTest { x: 10_i32 };\n-\n     // Bad.\n-    let x = 22;\n-    let x = 0.12;\n-    let x: _ = 13;\n-    let x: [_; 3] = [1, 2, 3];\n-    let x: (_, i32) = (1, 2);\n-\n-    let x = if true { (1, 2) } else { (3, 4) };\n-\n-    let x = match 1 {\n-        1 => 1,\n-        _ => 2,\n-    };\n-\n-    let x = loop {\n-        break 1;\n-    };\n-\n-    let x = 'outer0: loop {\n-        {\n-            'inner0: loop {\n-                break 3;\n-            }\n-        };\n-        break 2;\n-    };\n-\n-    let x = GenericStruct { x: 1 };\n-\n-    generic_arg(10);\n-    s.generic_arg(10);\n-    let f = || -> _ { 1 };\n+    let x = 1;\n+    let x = 0.1;\n+    let x = if true { 1 } else { 2 };\n \n     // Good.\n-    let x = 22_i32;\n-    let x: f64 = 0.12;\n-    let x = 0.12_f64;\n-    let x: i32 = 13;\n-    let x: [i32; 3] = [1, 2, 3];\n-    let x: (i32, i32) = (1, 2);\n-\n-    let x: (i32, i32) = if true { (1, 2) } else { (3, 4) };\n-\n-    let x: i32 = match true {\n-        true => 1,\n-        _ => 2,\n-    };\n-\n-    let x: i32 = loop {\n-        break 1;\n-    };\n-\n-    let x: i32 = 'outer1: loop {\n-        'inner1: loop {\n-            break 'outer1 3;\n-        }\n-    };\n-\n-    let x = ConcreteStruct { x: 1 };\n-\n-    concrete_arg(10);\n-    s.concrete_arg(10);\n-    let f = || -> i32 { 1 };\n+    let x = 1_i32;\n+    let x: i32 = 1;\n+    let x: _ = 1;\n+    let x = 0.1_f64;\n+    let x: f64 = 0.1;\n+    let x: _ = 0.1;\n+    let x: _ = if true { 1 } else { 2 };\n }"}, {"sha": "c36409a052c6b9e9489a39be7b6bb63b227bf9d4", "filename": "tests/ui/default_numeric_fallback.stderr", "status": "modified", "additions": 12, "deletions": 164, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/22d4483dee55fbf0c9ba48a3ddfd8abe06805c07/tests%2Fui%2Fdefault_numeric_fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/22d4483dee55fbf0c9ba48a3ddfd8abe06805c07/tests%2Fui%2Fdefault_numeric_fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback.stderr?ref=22d4483dee55fbf0c9ba48a3ddfd8abe06805c07", "patch": "@@ -1,187 +1,35 @@\n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:37:13\n+  --> $DIR/default_numeric_fallback.rs:6:13\n    |\n-LL |     let x = 22;\n-   |             ^^\n+LL |     let x = 1;\n+   |             ^\n    |\n    = note: `-D clippy::default-numeric-fallback` implied by `-D warnings`\n    = help: consider adding suffix to avoid default numeric fallback\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:38:13\n+  --> $DIR/default_numeric_fallback.rs:7:13\n    |\n-LL |     let x = 0.12;\n-   |             ^^^^\n+LL |     let x = 0.1;\n+   |             ^^^\n    |\n    = help: consider adding suffix to avoid default numeric fallback\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:39:16\n+  --> $DIR/default_numeric_fallback.rs:8:23\n    |\n-LL |     let x: _ = 13;\n-   |                ^^\n-   |\n-   = help: consider adding suffix to avoid default numeric fallback\n-\n-error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:40:22\n-   |\n-LL |     let x: [_; 3] = [1, 2, 3];\n-   |                      ^\n-   |\n-   = help: consider adding suffix to avoid default numeric fallback\n-\n-error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:40:25\n-   |\n-LL |     let x: [_; 3] = [1, 2, 3];\n-   |                         ^\n-   |\n-   = help: consider adding suffix to avoid default numeric fallback\n-\n-error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:40:28\n-   |\n-LL |     let x: [_; 3] = [1, 2, 3];\n-   |                            ^\n-   |\n-   = help: consider adding suffix to avoid default numeric fallback\n-\n-error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:41:24\n-   |\n-LL |     let x: (_, i32) = (1, 2);\n-   |                        ^\n-   |\n-   = help: consider adding suffix to avoid default numeric fallback\n-\n-error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:41:27\n-   |\n-LL |     let x: (_, i32) = (1, 2);\n-   |                           ^\n-   |\n-   = help: consider adding suffix to avoid default numeric fallback\n-\n-error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:43:24\n-   |\n-LL |     let x = if true { (1, 2) } else { (3, 4) };\n-   |                        ^\n-   |\n-   = help: consider adding suffix to avoid default numeric fallback\n-\n-error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:43:27\n-   |\n-LL |     let x = if true { (1, 2) } else { (3, 4) };\n-   |                           ^\n-   |\n-   = help: consider adding suffix to avoid default numeric fallback\n-\n-error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:43:40\n-   |\n-LL |     let x = if true { (1, 2) } else { (3, 4) };\n-   |                                        ^\n-   |\n-   = help: consider adding suffix to avoid default numeric fallback\n-\n-error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:43:43\n-   |\n-LL |     let x = if true { (1, 2) } else { (3, 4) };\n-   |                                           ^\n-   |\n-   = help: consider adding suffix to avoid default numeric fallback\n-\n-error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:45:19\n-   |\n-LL |     let x = match 1 {\n-   |                   ^\n-   |\n-   = help: consider adding suffix to avoid default numeric fallback\n-\n-error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:46:9\n-   |\n-LL |         1 => 1,\n-   |         ^\n-   |\n-   = help: consider adding suffix to avoid default numeric fallback\n-\n-error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:46:14\n-   |\n-LL |         1 => 1,\n-   |              ^\n-   |\n-   = help: consider adding suffix to avoid default numeric fallback\n-\n-error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:47:14\n-   |\n-LL |         _ => 2,\n-   |              ^\n-   |\n-   = help: consider adding suffix to avoid default numeric fallback\n-\n-error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:51:15\n-   |\n-LL |         break 1;\n-   |               ^\n-   |\n-   = help: consider adding suffix to avoid default numeric fallback\n-\n-error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:57:23\n-   |\n-LL |                 break 3;\n+LL |     let x = if true { 1 } else { 2 };\n    |                       ^\n    |\n    = help: consider adding suffix to avoid default numeric fallback\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:60:15\n-   |\n-LL |         break 2;\n-   |               ^\n-   |\n-   = help: consider adding suffix to avoid default numeric fallback\n-\n-error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:63:32\n-   |\n-LL |     let x = GenericStruct { x: 1 };\n-   |                                ^\n-   |\n-   = help: consider adding suffix to avoid default numeric fallback\n-\n-error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:65:17\n-   |\n-LL |     generic_arg(10);\n-   |                 ^^\n-   |\n-   = help: consider adding suffix to avoid default numeric fallback\n-\n-error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:66:19\n+  --> $DIR/default_numeric_fallback.rs:8:34\n    |\n-LL |     s.generic_arg(10);\n-   |                   ^^\n-   |\n-   = help: consider adding suffix to avoid default numeric fallback\n-\n-error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:67:23\n-   |\n-LL |     let f = || -> _ { 1 };\n-   |                       ^\n+LL |     let x = if true { 1 } else { 2 };\n+   |                                  ^\n    |\n    = help: consider adding suffix to avoid default numeric fallback\n \n-error: aborting due to 23 previous errors\n+error: aborting due to 4 previous errors\n "}]}