{"sha": "ba0e2518c852f844a8975c2e4b1d5814dd2d11c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhMGUyNTE4Yzg1MmY4NDRhODk3NWMyZTRiMWQ1ODE0ZGQyZDExYzg=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2019-05-17T18:34:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-17T18:34:12Z"}, "message": "Rollup merge of #60901 - estebank:str-str-str, r=Centril\n\nHandle more string addition cases with appropriate suggestions", "tree": {"sha": "385cef7381ad87c5e965c33a76acf5401a83e967", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/385cef7381ad87c5e965c33a76acf5401a83e967"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba0e2518c852f844a8975c2e4b1d5814dd2d11c8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc3v6kCRBK7hj4Ov3rIwAAdHIIAJw4GDUDEj9sh41TRcN9P16s\nujyY6Mp0Jt/uvpNFXqhccWDwEPrqkQ1AmiLaHChrzzhCpAxSM6WYZm2s8uI+86kH\n5vkVwDgKVHRN8W8TBkyphcBOfSilcLAg6GSNTEuKXU8ZJUQCfq/Ob97t7c0tH3hg\nZlmlXQirPhWkmPVz3jECgSghR4Qfuj4/ERLmrQ1eCLYa2QIts9NvRWYwAnDotqpC\nB3kPfwZVFbEgRcjH0xnXHmUzfUIZgNAzb0dV/T3qsEsZQvgccH/Q1+jLSrLGz1u9\nRn+6OtJtW9EofBfKvydJfBtESG4sL2D1gD8sGgbAv+plNPXk8B28KzOjxVpBsTM=\n=XLE4\n-----END PGP SIGNATURE-----\n", "payload": "tree 385cef7381ad87c5e965c33a76acf5401a83e967\nparent 7269117f13d387f23bbb2853e01afb68f59cc281\nparent 8895fb945d0ea0ce124923aadc16adb68c74f3e6\nauthor Manish Goregaokar <manishsmail@gmail.com> 1558118052 -0700\ncommitter GitHub <noreply@github.com> 1558118052 -0700\n\nRollup merge of #60901 - estebank:str-str-str, r=Centril\n\nHandle more string addition cases with appropriate suggestions\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba0e2518c852f844a8975c2e4b1d5814dd2d11c8", "html_url": "https://github.com/rust-lang/rust/commit/ba0e2518c852f844a8975c2e4b1d5814dd2d11c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba0e2518c852f844a8975c2e4b1d5814dd2d11c8/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7269117f13d387f23bbb2853e01afb68f59cc281", "url": "https://api.github.com/repos/rust-lang/rust/commits/7269117f13d387f23bbb2853e01afb68f59cc281", "html_url": "https://github.com/rust-lang/rust/commit/7269117f13d387f23bbb2853e01afb68f59cc281"}, {"sha": "8895fb945d0ea0ce124923aadc16adb68c74f3e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/8895fb945d0ea0ce124923aadc16adb68c74f3e6", "html_url": "https://github.com/rust-lang/rust/commit/8895fb945d0ea0ce124923aadc16adb68c74f3e6"}], "stats": {"total": 267, "additions": 231, "deletions": 36}, "files": [{"sha": "cd207478f8f6f86e5c701df44e4257a01b2d7761", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 60, "deletions": 23, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e2518c852f844a8975c2e4b1d5814dd2d11c8/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e2518c852f844a8975c2e4b1d5814dd2d11c8/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=ba0e2518c852f844a8975c2e4b1d5814dd2d11c8", "patch": "@@ -305,8 +305,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             };\n                             if let Some(missing_trait) = missing_trait {\n                                 if op.node == hir::BinOpKind::Add &&\n-                                    self.check_str_addition(expr, lhs_expr, rhs_expr, lhs_ty,\n-                                                            rhs_ty, &mut err, true, op) {\n+                                    self.check_str_addition(\n+                                        lhs_expr, rhs_expr, lhs_ty, rhs_ty, &mut err, true, op) {\n                                     // This has nothing here because it means we did string\n                                     // concatenation (e.g., \"Hello \" += \"World!\"). This means\n                                     // we don't want the note in the else clause to be emitted\n@@ -400,8 +400,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             };\n                             if let Some(missing_trait) = missing_trait {\n                                 if op.node == hir::BinOpKind::Add &&\n-                                    self.check_str_addition(expr, lhs_expr, rhs_expr, lhs_ty,\n-                                                            rhs_ty, &mut err, false, op) {\n+                                    self.check_str_addition(\n+                                        lhs_expr, rhs_expr, lhs_ty, rhs_ty, &mut err, false, op) {\n                                     // This has nothing here because it means we did string\n                                     // concatenation (e.g., \"Hello \" + \"World!\"). This means\n                                     // we don't want the note in the else clause to be emitted\n@@ -502,9 +502,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         false\n     }\n \n+    /// Provide actionable suggestions when trying to add two strings with incorrect types,\n+    /// like `&str + &str`, `String + String` and `&str + &String`.\n+    ///\n+    /// If this function returns `true` it means a note was printed, so we don't need\n+    /// to print the normal \"implementation of `std::ops::Add` might be missing\" note\n     fn check_str_addition(\n         &self,\n-        expr: &'gcx hir::Expr,\n         lhs_expr: &'gcx hir::Expr,\n         rhs_expr: &'gcx hir::Expr,\n         lhs_ty: Ty<'tcx>,\n@@ -514,45 +518,78 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         op: hir::BinOp,\n     ) -> bool {\n         let source_map = self.tcx.sess.source_map();\n+        let remove_borrow_msg = \"String concatenation appends the string on the right to the \\\n+                                 string on the left and may require reallocation. This \\\n+                                 requires ownership of the string on the left\";\n+\n         let msg = \"`to_owned()` can be used to create an owned `String` \\\n                    from a string reference. String concatenation \\\n                    appends the string on the right to the string \\\n                    on the left and may require reallocation. This \\\n                    requires ownership of the string on the left\";\n-        // If this function returns true it means a note was printed, so we don't need\n-        // to print the normal \"implementation of `std::ops::Add` might be missing\" note\n+\n+        let is_std_string = |ty| &format!(\"{:?}\", ty) == \"std::string::String\";\n+\n         match (&lhs_ty.sty, &rhs_ty.sty) {\n-            (&Ref(_, l_ty, _), &Ref(_, r_ty, _))\n-            if l_ty.sty == Str && r_ty.sty == Str => {\n-                if !is_assign {\n-                    err.span_label(op.span,\n-                                   \"`+` can't be used to concatenate two `&str` strings\");\n+            (&Ref(_, l_ty, _), &Ref(_, r_ty, _)) // &str or &String + &str, &String or &&str\n+                if (l_ty.sty == Str || is_std_string(l_ty)) && (\n+                        r_ty.sty == Str || is_std_string(r_ty) ||\n+                        &format!(\"{:?}\", rhs_ty) == \"&&str\"\n+                    ) =>\n+            {\n+                if !is_assign { // Do not supply this message if `&str += &str`\n+                    err.span_label(\n+                        op.span,\n+                        \"`+` cannot be used to concatenate two `&str` strings\",\n+                    );\n                     match source_map.span_to_snippet(lhs_expr.span) {\n-                        Ok(lstring) => err.span_suggestion(\n-                            lhs_expr.span,\n-                            msg,\n-                            format!(\"{}.to_owned()\", lstring),\n-                            Applicability::MachineApplicable,\n-                        ),\n+                        Ok(lstring) => {\n+                            err.span_suggestion(\n+                                lhs_expr.span,\n+                                if lstring.starts_with(\"&\") {\n+                                    remove_borrow_msg\n+                                } else {\n+                                    msg\n+                                },\n+                                if lstring.starts_with(\"&\") {\n+                                    // let a = String::new();\n+                                    // let _ = &a + \"bar\";\n+                                    format!(\"{}\", &lstring[1..])\n+                                } else {\n+                                    format!(\"{}.to_owned()\", lstring)\n+                                },\n+                                Applicability::MachineApplicable,\n+                            )\n+                        }\n                         _ => err.help(msg),\n                     };\n                 }\n                 true\n             }\n-            (&Ref(_, l_ty, _), &Adt(..))\n-            if l_ty.sty == Str && &format!(\"{:?}\", rhs_ty) == \"std::string::String\" => {\n-                err.span_label(expr.span,\n-                    \"`+` can't be used to concatenate a `&str` with a `String`\");\n+            (&Ref(_, l_ty, _), &Adt(..)) // Handle `&str` & `&String` + `String`\n+                if (l_ty.sty == Str || is_std_string(l_ty)) && is_std_string(rhs_ty) =>\n+            {\n+                err.span_label(\n+                    op.span,\n+                    \"`+` cannot be used to concatenate a `&str` with a `String`\",\n+                );\n                 match (\n                     source_map.span_to_snippet(lhs_expr.span),\n                     source_map.span_to_snippet(rhs_expr.span),\n                     is_assign,\n                 ) {\n                     (Ok(l), Ok(r), false) => {\n+                        let to_string = if l.starts_with(\"&\") {\n+                            // let a = String::new(); let b = String::new();\n+                            // let _ = &a + b;\n+                            format!(\"{}\", &l[1..])\n+                        } else {\n+                            format!(\"{}.to_owned()\", l)\n+                        };\n                         err.multipart_suggestion(\n                             msg,\n                             vec![\n-                                (lhs_expr.span, format!(\"{}.to_owned()\", l)),\n+                                (lhs_expr.span, to_string),\n                                 (rhs_expr.span, format!(\"&{}\", r)),\n                             ],\n                             Applicability::MachineApplicable,"}, {"sha": "3d55267b8e8cf8af2f84c90bc1d7af9b779afcb0", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e2518c852f844a8975c2e4b1d5814dd2d11c8/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e2518c852f844a8975c2e4b1d5814dd2d11c8/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ba0e2518c852f844a8975c2e4b1d5814dd2d11c8", "patch": "@@ -3497,8 +3497,7 @@ impl<'a> Parser<'a> {\n                     let binary = self.mk_binary(source_map::respan(cur_op_span, ast_op), lhs, rhs);\n                     self.mk_expr(span, binary, ThinVec::new())\n                 }\n-                AssocOp::Assign =>\n-                    self.mk_expr(span, ExprKind::Assign(lhs, rhs), ThinVec::new()),\n+                AssocOp::Assign => self.mk_expr(span, ExprKind::Assign(lhs, rhs), ThinVec::new()),\n                 AssocOp::ObsoleteInPlace =>\n                     self.mk_expr(span, ExprKind::ObsoleteInPlace(lhs, rhs), ThinVec::new()),\n                 AssocOp::AssignOp(k) => {"}, {"sha": "7d11a8c8021283fc54c8c3c89e5ca281a5bbe6f7", "filename": "src/test/ui/issues/issue-47377.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e2518c852f844a8975c2e4b1d5814dd2d11c8/src%2Ftest%2Fui%2Fissues%2Fissue-47377.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e2518c852f844a8975c2e4b1d5814dd2d11c8/src%2Ftest%2Fui%2Fissues%2Fissue-47377.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-47377.stderr?ref=ba0e2518c852f844a8975c2e4b1d5814dd2d11c8", "patch": "@@ -4,7 +4,7 @@ error[E0369]: binary operation `+` cannot be applied to type `&str`\n LL |      let _a = b + \", World!\";\n    |               - ^ ---------- &str\n    |               | |\n-   |               | `+` can't be used to concatenate two `&str` strings\n+   |               | `+` cannot be used to concatenate two `&str` strings\n    |               &str\n help: `to_owned()` can be used to create an owned `String` from a string reference. String concatenation appends the string on the right to the string on the left and may require reallocation. This requires ownership of the string on the left\n    |"}, {"sha": "89a154c5109d80e0c4b02c28c77a0ff514205827", "filename": "src/test/ui/issues/issue-47380.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e2518c852f844a8975c2e4b1d5814dd2d11c8/src%2Ftest%2Fui%2Fissues%2Fissue-47380.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e2518c852f844a8975c2e4b1d5814dd2d11c8/src%2Ftest%2Fui%2Fissues%2Fissue-47380.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-47380.stderr?ref=ba0e2518c852f844a8975c2e4b1d5814dd2d11c8", "patch": "@@ -4,7 +4,7 @@ error[E0369]: binary operation `+` cannot be applied to type `&str`\n LL |     println!(\"\ud83e\udd80\ud83e\udd80\ud83e\udd80\ud83e\udd80\ud83e\udd80\"); let _a = b + \", World!\";\n    |                                      - ^ ---------- &str\n    |                                      | |\n-   |                                      | `+` can't be used to concatenate two `&str` strings\n+   |                                      | `+` cannot be used to concatenate two `&str` strings\n    |                                      &str\n help: `to_owned()` can be used to create an owned `String` from a string reference. String concatenation appends the string on the right to the string on the left and may require reallocation. This requires ownership of the string on the left\n    |"}, {"sha": "a3b1d1d81799fce76716f160f2cd95b64ebcfc80", "filename": "src/test/ui/span/issue-39018.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e2518c852f844a8975c2e4b1d5814dd2d11c8/src%2Ftest%2Fui%2Fspan%2Fissue-39018.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e2518c852f844a8975c2e4b1d5814dd2d11c8/src%2Ftest%2Fui%2Fspan%2Fissue-39018.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-39018.rs?ref=ba0e2518c852f844a8975c2e4b1d5814dd2d11c8", "patch": "@@ -16,3 +16,23 @@ enum World {\n     Hello,\n     Goodbye,\n }\n+\n+fn foo() {\n+    let a = String::new();\n+    let b = String::new();\n+    let c = \"\";\n+    let d = \"\";\n+    let e = &a;\n+    let _ = &a + &b; //~ ERROR binary operation\n+    let _ = &a + b; //~ ERROR binary operation\n+    let _ = a + &b; // ok\n+    let _ = a + b; //~ ERROR mismatched types\n+    let _ = e + b; //~ ERROR binary operation\n+    let _ = e + &b; //~ ERROR binary operation\n+    let _ = e + d; //~ ERROR binary operation\n+    let _ = e + &d; //~ ERROR binary operation\n+    let _ = &c + &d; //~ ERROR binary operation\n+    let _ = &c + d; //~ ERROR binary operation\n+    let _ = c + &d; //~ ERROR binary operation\n+    let _ = c + d; //~ ERROR binary operation\n+}"}, {"sha": "d8fbf841b6157cd5613248a65fbd22d545e8eb49", "filename": "src/test/ui/span/issue-39018.stderr", "status": "modified", "additions": 143, "deletions": 7, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e2518c852f844a8975c2e4b1d5814dd2d11c8/src%2Ftest%2Fui%2Fspan%2Fissue-39018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e2518c852f844a8975c2e4b1d5814dd2d11c8/src%2Ftest%2Fui%2Fspan%2Fissue-39018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-39018.stderr?ref=ba0e2518c852f844a8975c2e4b1d5814dd2d11c8", "patch": "@@ -4,7 +4,7 @@ error[E0369]: binary operation `+` cannot be applied to type `&str`\n LL |     let x = \"Hello \" + \"World!\";\n    |             -------- ^ -------- &str\n    |             |        |\n-   |             |        `+` can't be used to concatenate two `&str` strings\n+   |             |        `+` cannot be used to concatenate two `&str` strings\n    |             &str\n help: `to_owned()` can be used to create an owned `String` from a string reference. String concatenation appends the string on the right to the string on the left and may require reallocation. This requires ownership of the string on the left\n    |\n@@ -25,16 +25,152 @@ error[E0369]: binary operation `+` cannot be applied to type `&str`\n   --> $DIR/issue-39018.rs:11:22\n    |\n LL |     let x = \"Hello \" + \"World!\".to_owned();\n-   |             ---------^--------------------\n-   |             |          |\n-   |             |          std::string::String\n+   |             -------- ^ ------------------- std::string::String\n+   |             |        |\n+   |             |        `+` cannot be used to concatenate a `&str` with a `String`\n    |             &str\n-   |             `+` can't be used to concatenate a `&str` with a `String`\n help: `to_owned()` can be used to create an owned `String` from a string reference. String concatenation appends the string on the right to the string on the left and may require reallocation. This requires ownership of the string on the left\n    |\n LL |     let x = \"Hello \".to_owned() + &\"World!\".to_owned();\n    |             ^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 3 previous errors\n+error[E0369]: binary operation `+` cannot be applied to type `&std::string::String`\n+  --> $DIR/issue-39018.rs:26:16\n+   |\n+LL |     let _ = &a + &b;\n+   |             -- ^ -- &std::string::String\n+   |             |  |\n+   |             |  `+` cannot be used to concatenate two `&str` strings\n+   |             &std::string::String\n+help: String concatenation appends the string on the right to the string on the left and may require reallocation. This requires ownership of the string on the left\n+   |\n+LL |     let _ = a + &b;\n+   |             ^\n+\n+error[E0369]: binary operation `+` cannot be applied to type `&std::string::String`\n+  --> $DIR/issue-39018.rs:27:16\n+   |\n+LL |     let _ = &a + b;\n+   |             -- ^ - std::string::String\n+   |             |  |\n+   |             |  `+` cannot be used to concatenate a `&str` with a `String`\n+   |             &std::string::String\n+help: `to_owned()` can be used to create an owned `String` from a string reference. String concatenation appends the string on the right to the string on the left and may require reallocation. This requires ownership of the string on the left\n+   |\n+LL |     let _ = a + &b;\n+   |             ^   ^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-39018.rs:29:17\n+   |\n+LL |     let _ = a + b;\n+   |                 ^\n+   |                 |\n+   |                 expected &str, found struct `std::string::String`\n+   |                 help: consider borrowing here: `&b`\n+   |\n+   = note: expected type `&str`\n+              found type `std::string::String`\n+\n+error[E0369]: binary operation `+` cannot be applied to type `&std::string::String`\n+  --> $DIR/issue-39018.rs:30:15\n+   |\n+LL |     let _ = e + b;\n+   |             - ^ - std::string::String\n+   |             | |\n+   |             | `+` cannot be used to concatenate a `&str` with a `String`\n+   |             &std::string::String\n+help: `to_owned()` can be used to create an owned `String` from a string reference. String concatenation appends the string on the right to the string on the left and may require reallocation. This requires ownership of the string on the left\n+   |\n+LL |     let _ = e.to_owned() + &b;\n+   |             ^^^^^^^^^^^^   ^^\n+\n+error[E0369]: binary operation `+` cannot be applied to type `&std::string::String`\n+  --> $DIR/issue-39018.rs:31:15\n+   |\n+LL |     let _ = e + &b;\n+   |             - ^ -- &std::string::String\n+   |             | |\n+   |             | `+` cannot be used to concatenate two `&str` strings\n+   |             &std::string::String\n+help: `to_owned()` can be used to create an owned `String` from a string reference. String concatenation appends the string on the right to the string on the left and may require reallocation. This requires ownership of the string on the left\n+   |\n+LL |     let _ = e.to_owned() + &b;\n+   |             ^^^^^^^^^^^^\n+\n+error[E0369]: binary operation `+` cannot be applied to type `&std::string::String`\n+  --> $DIR/issue-39018.rs:32:15\n+   |\n+LL |     let _ = e + d;\n+   |             - ^ - &str\n+   |             | |\n+   |             | `+` cannot be used to concatenate two `&str` strings\n+   |             &std::string::String\n+help: `to_owned()` can be used to create an owned `String` from a string reference. String concatenation appends the string on the right to the string on the left and may require reallocation. This requires ownership of the string on the left\n+   |\n+LL |     let _ = e.to_owned() + d;\n+   |             ^^^^^^^^^^^^\n+\n+error[E0369]: binary operation `+` cannot be applied to type `&std::string::String`\n+  --> $DIR/issue-39018.rs:33:15\n+   |\n+LL |     let _ = e + &d;\n+   |             - ^ -- &&str\n+   |             | |\n+   |             | `+` cannot be used to concatenate two `&str` strings\n+   |             &std::string::String\n+help: `to_owned()` can be used to create an owned `String` from a string reference. String concatenation appends the string on the right to the string on the left and may require reallocation. This requires ownership of the string on the left\n+   |\n+LL |     let _ = e.to_owned() + &d;\n+   |             ^^^^^^^^^^^^\n+\n+error[E0369]: binary operation `+` cannot be applied to type `&&str`\n+  --> $DIR/issue-39018.rs:34:16\n+   |\n+LL |     let _ = &c + &d;\n+   |             -- ^ -- &&str\n+   |             |\n+   |             &&str\n+   |\n+   = note: an implementation of `std::ops::Add` might be missing for `&&str`\n+\n+error[E0369]: binary operation `+` cannot be applied to type `&&str`\n+  --> $DIR/issue-39018.rs:35:16\n+   |\n+LL |     let _ = &c + d;\n+   |             -- ^ - &str\n+   |             |\n+   |             &&str\n+   |\n+   = note: an implementation of `std::ops::Add` might be missing for `&&str`\n+\n+error[E0369]: binary operation `+` cannot be applied to type `&str`\n+  --> $DIR/issue-39018.rs:36:15\n+   |\n+LL |     let _ = c + &d;\n+   |             - ^ -- &&str\n+   |             | |\n+   |             | `+` cannot be used to concatenate two `&str` strings\n+   |             &str\n+help: `to_owned()` can be used to create an owned `String` from a string reference. String concatenation appends the string on the right to the string on the left and may require reallocation. This requires ownership of the string on the left\n+   |\n+LL |     let _ = c.to_owned() + &d;\n+   |             ^^^^^^^^^^^^\n+\n+error[E0369]: binary operation `+` cannot be applied to type `&str`\n+  --> $DIR/issue-39018.rs:37:15\n+   |\n+LL |     let _ = c + d;\n+   |             - ^ - &str\n+   |             | |\n+   |             | `+` cannot be used to concatenate two `&str` strings\n+   |             &str\n+help: `to_owned()` can be used to create an owned `String` from a string reference. String concatenation appends the string on the right to the string on the left and may require reallocation. This requires ownership of the string on the left\n+   |\n+LL |     let _ = c.to_owned() + d;\n+   |             ^^^^^^^^^^^^\n+\n+error: aborting due to 14 previous errors\n \n-For more information about this error, try `rustc --explain E0369`.\n+Some errors have detailed explanations: E0308, E0369.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "3e53cdc4d98ca36c8d9ad606d833cf772704847b", "filename": "src/test/ui/str/str-concat-on-double-ref.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e2518c852f844a8975c2e4b1d5814dd2d11c8/src%2Ftest%2Fui%2Fstr%2Fstr-concat-on-double-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e2518c852f844a8975c2e4b1d5814dd2d11c8/src%2Ftest%2Fui%2Fstr%2Fstr-concat-on-double-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstr%2Fstr-concat-on-double-ref.stderr?ref=ba0e2518c852f844a8975c2e4b1d5814dd2d11c8", "patch": "@@ -3,10 +3,13 @@ error[E0369]: binary operation `+` cannot be applied to type `&std::string::Stri\n    |\n LL |     let c = a + b;\n    |             - ^ - &str\n-   |             |\n+   |             | |\n+   |             | `+` cannot be used to concatenate two `&str` strings\n    |             &std::string::String\n+help: `to_owned()` can be used to create an owned `String` from a string reference. String concatenation appends the string on the right to the string on the left and may require reallocation. This requires ownership of the string on the left\n    |\n-   = note: an implementation of `std::ops::Add` might be missing for `&std::string::String`\n+LL |     let c = a.to_owned() + b;\n+   |             ^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}]}