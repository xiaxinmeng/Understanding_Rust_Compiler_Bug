{"sha": "e4722b6492c3a3b9636f7da6cee34b5879100de3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0NzIyYjY0OTJjM2EzYjk2MzZmN2RhNmNlZTM0YjU4NzkxMDBkZTM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-05-23T01:00:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-23T01:00:33Z"}, "message": "Merge #8932\n\n8932: internal: even prettier itemtrees r=jonas-schievink a=jonas-schievink\n\nExtends the ItemTree pretty printer to handle all `Path`s, and to print generic parameters and where-clauses.\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "40647077f6cfbd6481b00c5b9f6ecc14e67bd749", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40647077f6cfbd6481b00c5b9f6ecc14e67bd749"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4722b6492c3a3b9636f7da6cee34b5879100de3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgqakxCRBK7hj4Ov3rIwAAGqkIAIuSNQ47KihThkomJL5H5J/z\nUZfrdcGJYxrUhr3kGciCDUATLRdI1VFCzZ0lsx+mXUewoLW4TdERLLrmlF57tkir\nRkKO2c3d0j0fAtQvINZsRf7J+9CEqqLr+aRtYEdv51jVZw3AKUyppQP1RKdWl1qm\nYwQT62XNsi9exeFBg7oALTdBCjQ9S/CRlH+16JtrIzVi3HYKQ6sNGH86c5ZuCH5q\n4KmQuevFLATcqS+vKyDSqi8EnBwDSHaAEslnqXRQ+CafBwsMIoqOpGTkFx+B4rmQ\njE0fELNjOjUNHZyNBaFUMfda630ZoHGCu/DIir7ef6cdHl1rTva89TLxlaQwGUg=\n=XL9/\n-----END PGP SIGNATURE-----\n", "payload": "tree 40647077f6cfbd6481b00c5b9f6ecc14e67bd749\nparent bc1ba1549d97e7d5ddceb16b7238ae8aab5794d0\nparent 15ff7faf3dd7979cce2fb76106add30bb771c503\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1621731633 +0000\ncommitter GitHub <noreply@github.com> 1621731633 +0000\n\nMerge #8932\n\n8932: internal: even prettier itemtrees r=jonas-schievink a=jonas-schievink\n\nExtends the ItemTree pretty printer to handle all `Path`s, and to print generic parameters and where-clauses.\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4722b6492c3a3b9636f7da6cee34b5879100de3", "html_url": "https://github.com/rust-lang/rust/commit/e4722b6492c3a3b9636f7da6cee34b5879100de3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4722b6492c3a3b9636f7da6cee34b5879100de3/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc1ba1549d97e7d5ddceb16b7238ae8aab5794d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc1ba1549d97e7d5ddceb16b7238ae8aab5794d0", "html_url": "https://github.com/rust-lang/rust/commit/bc1ba1549d97e7d5ddceb16b7238ae8aab5794d0"}, {"sha": "15ff7faf3dd7979cce2fb76106add30bb771c503", "url": "https://api.github.com/repos/rust-lang/rust/commits/15ff7faf3dd7979cce2fb76106add30bb771c503", "html_url": "https://github.com/rust-lang/rust/commit/15ff7faf3dd7979cce2fb76106add30bb771c503"}], "stats": {"total": 376, "additions": 342, "deletions": 34}, "files": [{"sha": "4bc87a0e20b5672869252586c6ed9366a7b7f86b", "filename": "crates/hir_def/src/item_tree/pretty.rs", "status": "modified", "additions": 221, "deletions": 33, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/e4722b6492c3a3b9636f7da6cee34b5879100de3/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4722b6492c3a3b9636f7da6cee34b5879100de3/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Fpretty.rs?ref=e4722b6492c3a3b9636f7da6cee34b5879100de3", "patch": "@@ -2,7 +2,12 @@\n \n use std::fmt::{self, Write};\n \n-use crate::{attr::RawAttrs, visibility::RawVisibility};\n+use crate::{\n+    attr::RawAttrs,\n+    generics::{WherePredicate, WherePredicateTypeTarget},\n+    path::GenericArg,\n+    visibility::RawVisibility,\n+};\n \n use super::*;\n \n@@ -70,6 +75,13 @@ impl<'a> Printer<'a> {\n         }\n     }\n \n+    fn whitespace(&mut self) {\n+        match self.buf.chars().next_back() {\n+            None | Some('\\n') | Some(' ') => {}\n+            _ => self.buf.push(' '),\n+        }\n+    }\n+\n     fn print_attrs(&mut self, attrs: &RawAttrs, inner: bool) {\n         let inner = if inner { \"!\" } else { \"\" };\n         for attr in &**attrs {\n@@ -100,7 +112,8 @@ impl<'a> Printer<'a> {\n     fn print_fields(&mut self, fields: &Fields) {\n         match fields {\n             Fields::Record(fields) => {\n-                w!(self, \" {{\");\n+                self.whitespace();\n+                w!(self, \"{{\");\n                 self.indented(|this| {\n                     for field in fields.clone() {\n                         let Field { visibility, name, type_ref } = &this.tree[field];\n@@ -131,6 +144,25 @@ impl<'a> Printer<'a> {\n         }\n     }\n \n+    fn print_fields_and_where_clause(&mut self, fields: &Fields, params: &GenericParams) {\n+        match fields {\n+            Fields::Record(_) => {\n+                if self.print_where_clause(params) {\n+                    wln!(self);\n+                }\n+                self.print_fields(fields);\n+            }\n+            Fields::Unit => {\n+                self.print_where_clause(params);\n+                self.print_fields(fields);\n+            }\n+            Fields::Tuple(_) => {\n+                self.print_fields(fields);\n+                self.print_where_clause(params);\n+            }\n+        }\n+    }\n+\n     fn print_mod_item(&mut self, item: ModItem) {\n         self.print_attrs_of(item);\n \n@@ -174,7 +206,7 @@ impl<'a> Printer<'a> {\n                 let Function {\n                     name,\n                     visibility,\n-                    generic_params: _, // FIXME print these somehow\n+                    generic_params,\n                     abi,\n                     params,\n                     ret_type,\n@@ -188,7 +220,9 @@ impl<'a> Printer<'a> {\n                 if let Some(abi) = abi {\n                     w!(self, \"extern \\\"{}\\\" \", abi);\n                 }\n-                w!(self, \"fn {}(\", name);\n+                w!(self, \"fn {}\", name);\n+                self.print_generic_params(generic_params);\n+                w!(self, \"(\");\n                 if !params.is_empty() {\n                     self.indented(|this| {\n                         for param in params.clone() {\n@@ -208,37 +242,39 @@ impl<'a> Printer<'a> {\n                 }\n                 w!(self, \") -> \");\n                 self.print_type_ref(ret_type);\n+                self.print_where_clause(generic_params);\n                 wln!(self, \";\");\n             }\n             ModItem::Struct(it) => {\n-                let Struct { visibility, name, fields, generic_params: _, ast_id: _ } =\n-                    &self.tree[it];\n+                let Struct { visibility, name, fields, generic_params, ast_id: _ } = &self.tree[it];\n                 self.print_visibility(*visibility);\n                 w!(self, \"struct {}\", name);\n-                self.print_fields(fields);\n+                self.print_generic_params(generic_params);\n+                self.print_fields_and_where_clause(fields, generic_params);\n                 if matches!(fields, Fields::Record(_)) {\n                     wln!(self);\n                 } else {\n                     wln!(self, \";\");\n                 }\n             }\n             ModItem::Union(it) => {\n-                let Union { name, visibility, fields, generic_params: _, ast_id: _ } =\n-                    &self.tree[it];\n+                let Union { name, visibility, fields, generic_params, ast_id: _ } = &self.tree[it];\n                 self.print_visibility(*visibility);\n                 w!(self, \"union {}\", name);\n-                self.print_fields(fields);\n+                self.print_generic_params(generic_params);\n+                self.print_fields_and_where_clause(fields, generic_params);\n                 if matches!(fields, Fields::Record(_)) {\n                     wln!(self);\n                 } else {\n                     wln!(self, \";\");\n                 }\n             }\n             ModItem::Enum(it) => {\n-                let Enum { name, visibility, variants, generic_params: _, ast_id: _ } =\n-                    &self.tree[it];\n+                let Enum { name, visibility, variants, generic_params, ast_id: _ } = &self.tree[it];\n                 self.print_visibility(*visibility);\n-                w!(self, \"enum {} {{\", name);\n+                w!(self, \"enum {}\", name);\n+                self.print_generic_params(generic_params);\n+                self.print_where_clause_and_opening_brace(generic_params);\n                 self.indented(|this| {\n                     for variant in variants.clone() {\n                         let Variant { name, fields } = &this.tree[variant];\n@@ -286,7 +322,7 @@ impl<'a> Printer<'a> {\n                     is_unsafe,\n                     bounds,\n                     items,\n-                    generic_params: _,\n+                    generic_params,\n                     ast_id: _,\n                 } = &self.tree[it];\n                 self.print_visibility(*visibility);\n@@ -297,11 +333,12 @@ impl<'a> Printer<'a> {\n                     w!(self, \"auto \");\n                 }\n                 w!(self, \"trait {}\", name);\n+                self.print_generic_params(generic_params);\n                 if !bounds.is_empty() {\n                     w!(self, \": \");\n                     self.print_type_bounds(bounds);\n                 }\n-                w!(self, \" {{\");\n+                self.print_where_clause_and_opening_brace(generic_params);\n                 self.indented(|this| {\n                     for item in &**items {\n                         this.print_mod_item((*item).into());\n@@ -310,15 +347,11 @@ impl<'a> Printer<'a> {\n                 wln!(self, \"}}\");\n             }\n             ModItem::Impl(it) => {\n-                let Impl {\n-                    target_trait,\n-                    self_ty,\n-                    is_negative,\n-                    items,\n-                    generic_params: _,\n-                    ast_id: _,\n-                } = &self.tree[it];\n-                w!(self, \"impl \");\n+                let Impl { target_trait, self_ty, is_negative, items, generic_params, ast_id: _ } =\n+                    &self.tree[it];\n+                w!(self, \"impl\");\n+                self.print_generic_params(generic_params);\n+                w!(self, \" \");\n                 if *is_negative {\n                     w!(self, \"!\");\n                 }\n@@ -327,7 +360,7 @@ impl<'a> Printer<'a> {\n                     w!(self, \" for \");\n                 }\n                 self.print_type_ref(self_ty);\n-                w!(self, \" {{\");\n+                self.print_where_clause_and_opening_brace(generic_params);\n                 self.indented(|this| {\n                     for item in &**items {\n                         this.print_mod_item((*item).into());\n@@ -342,11 +375,12 @@ impl<'a> Printer<'a> {\n                     bounds,\n                     type_ref,\n                     is_extern,\n-                    generic_params: _,\n+                    generic_params,\n                     ast_id: _,\n                 } = &self.tree[it];\n                 self.print_visibility(*visibility);\n                 w!(self, \"type {}\", name);\n+                self.print_generic_params(generic_params);\n                 if !bounds.is_empty() {\n                     w!(self, \": \");\n                     self.print_type_bounds(bounds);\n@@ -355,6 +389,7 @@ impl<'a> Printer<'a> {\n                     w!(self, \" = \");\n                     self.print_type_ref(ty);\n                 }\n+                self.print_where_clause(generic_params);\n                 w!(self, \";\");\n                 if *is_extern {\n                     w!(self, \"  // extern\");\n@@ -466,7 +501,7 @@ impl<'a> Printer<'a> {\n             TypeRef::Macro(_ast_id) => {\n                 w!(self, \"<macro>\");\n             }\n-            TypeRef::Error => drop(write!(self, \"{{unknown}}\")),\n+            TypeRef::Error => w!(self, \"{{unknown}}\"),\n             TypeRef::ImplTrait(bounds) => {\n                 w!(self, \"impl \");\n                 self.print_type_bounds(bounds);\n@@ -493,15 +528,168 @@ impl<'a> Printer<'a> {\n     }\n \n     fn print_path(&mut self, path: &Path) {\n-        if path.type_anchor().is_none()\n-            && path.segments().iter().all(|seg| seg.args_and_bindings.is_none())\n-        {\n-            w!(self, \"{}\", path.mod_path());\n+        match path.type_anchor() {\n+            Some(anchor) => {\n+                w!(self, \"<\");\n+                self.print_type_ref(anchor);\n+                w!(self, \">::\");\n+            }\n+            None => match path.kind() {\n+                PathKind::Plain => {}\n+                PathKind::Super(0) => w!(self, \"self::\"),\n+                PathKind::Super(n) => {\n+                    for _ in 0..*n {\n+                        w!(self, \"super::\");\n+                    }\n+                }\n+                PathKind::Crate => w!(self, \"crate::\"),\n+                PathKind::Abs => w!(self, \"::\"),\n+                PathKind::DollarCrate(_) => w!(self, \"$crate::\"),\n+            },\n+        }\n+\n+        for (i, segment) in path.segments().iter().enumerate() {\n+            if i != 0 {\n+                w!(self, \"::\");\n+            }\n+\n+            w!(self, \"{}\", segment.name);\n+            if let Some(generics) = segment.args_and_bindings {\n+                // NB: these are all in type position, so `::<` turbofish syntax is not necessary\n+                w!(self, \"<\");\n+                let mut first = true;\n+                let args = if generics.has_self_type {\n+                    let (self_ty, args) = generics.args.split_first().unwrap();\n+                    w!(self, \"Self=\");\n+                    self.print_generic_arg(self_ty);\n+                    first = false;\n+                    args\n+                } else {\n+                    &generics.args\n+                };\n+                for arg in args {\n+                    if !first {\n+                        w!(self, \", \");\n+                    }\n+                    first = false;\n+                    self.print_generic_arg(arg);\n+                }\n+                for binding in &generics.bindings {\n+                    if !first {\n+                        w!(self, \", \");\n+                    }\n+                    first = false;\n+                    w!(self, \"{}\", binding.name);\n+                    if !binding.bounds.is_empty() {\n+                        w!(self, \": \");\n+                        self.print_type_bounds(&binding.bounds);\n+                    }\n+                    if let Some(ty) = &binding.type_ref {\n+                        w!(self, \" = \");\n+                        self.print_type_ref(ty);\n+                    }\n+                }\n+\n+                w!(self, \">\");\n+            }\n+        }\n+    }\n+\n+    fn print_generic_arg(&mut self, arg: &GenericArg) {\n+        match arg {\n+            GenericArg::Type(ty) => self.print_type_ref(ty),\n+            GenericArg::Lifetime(lt) => w!(self, \"{}\", lt.name),\n+        }\n+    }\n+\n+    fn print_generic_params(&mut self, params: &GenericParams) {\n+        if params.types.is_empty() && params.lifetimes.is_empty() && params.consts.is_empty() {\n+            return;\n+        }\n+\n+        w!(self, \"<\");\n+        let mut first = true;\n+        for (_, lt) in params.lifetimes.iter() {\n+            if !first {\n+                w!(self, \", \");\n+            }\n+            first = false;\n+            w!(self, \"{}\", lt.name);\n+        }\n+        for (idx, ty) in params.types.iter() {\n+            if !first {\n+                w!(self, \", \");\n+            }\n+            first = false;\n+            match &ty.name {\n+                Some(name) => w!(self, \"{}\", name),\n+                None => w!(self, \"_anon_{}\", idx.into_raw()),\n+            }\n+        }\n+        for (_, konst) in params.consts.iter() {\n+            if !first {\n+                w!(self, \", \");\n+            }\n+            first = false;\n+            w!(self, \"const {}: \", konst.name);\n+            self.print_type_ref(&konst.ty);\n+        }\n+        w!(self, \">\");\n+    }\n+\n+    fn print_where_clause_and_opening_brace(&mut self, params: &GenericParams) {\n+        if self.print_where_clause(params) {\n+            w!(self, \"\\n{{\");\n         } else {\n-            // too complicated, just use `Debug`\n-            w!(self, \"{:?}\", path);\n+            self.whitespace();\n+            w!(self, \"{{\");\n         }\n     }\n+\n+    fn print_where_clause(&mut self, params: &GenericParams) -> bool {\n+        if params.where_predicates.is_empty() {\n+            return false;\n+        }\n+\n+        w!(self, \"\\nwhere\");\n+        self.indented(|this| {\n+            for (i, pred) in params.where_predicates.iter().enumerate() {\n+                if i != 0 {\n+                    wln!(this, \",\");\n+                }\n+\n+                let (target, bound) = match pred {\n+                    WherePredicate::TypeBound { target, bound } => (target, bound),\n+                    WherePredicate::Lifetime { target, bound } => {\n+                        wln!(this, \"{}: {},\", target.name, bound.name);\n+                        continue;\n+                    }\n+                    WherePredicate::ForLifetime { lifetimes, target, bound } => {\n+                        w!(this, \"for<\");\n+                        for (i, lt) in lifetimes.iter().enumerate() {\n+                            if i != 0 {\n+                                w!(this, \", \");\n+                            }\n+                            w!(this, \"{}\", lt);\n+                        }\n+                        w!(this, \"> \");\n+                        (target, bound)\n+                    }\n+                };\n+\n+                match target {\n+                    WherePredicateTypeTarget::TypeRef(ty) => this.print_type_ref(ty),\n+                    WherePredicateTypeTarget::TypeParam(id) => match &params.types[*id].name {\n+                        Some(name) => w!(this, \"{}\", name),\n+                        None => w!(this, \"_anon_{}\", id.into_raw()),\n+                    },\n+                }\n+                w!(this, \": \");\n+                this.print_type_bounds(std::slice::from_ref(bound));\n+            }\n+        });\n+        true\n+    }\n }\n \n impl<'a> Write for Printer<'a> {"}, {"sha": "6407871b504967d48dfb04c63fef98ab88f6a585", "filename": "crates/hir_def/src/item_tree/tests.rs", "status": "modified", "additions": 121, "deletions": 1, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/e4722b6492c3a3b9636f7da6cee34b5879100de3/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4722b6492c3a3b9636f7da6cee34b5879100de3/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Ftests.rs?ref=e4722b6492c3a3b9636f7da6cee34b5879100de3", "patch": "@@ -183,7 +183,11 @@ trait Tr: SuperTrait + 'lifetime {\n                 _: (),\n             ) -> ();\n \n-            pub(self) trait Tr: SuperTrait + 'lifetime {\n+            pub(self) trait Tr<Self>: SuperTrait + 'lifetime\n+            where\n+                Self: SuperTrait,\n+                Self: 'lifetime\n+            {\n                 pub(self) type Assoc: AssocBound = Default;\n \n                 // flags = 0x1\n@@ -207,6 +211,8 @@ mod inline {\n \n     fn fn_in_module() {}\n }\n+\n+mod outline;\n         \"#,\n         expect![[r##\"\n             #[doc = \" outer\"]  // AttrId { is_doc_comment: true, ast_index: 0 }\n@@ -217,6 +223,8 @@ mod inline {\n                 // flags = 0x2\n                 pub(self) fn fn_in_module() -> ();\n             }\n+\n+            pub(self) mod outline;\n         \"##]],\n     );\n }\n@@ -242,3 +250,115 @@ m!();\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn mod_paths() {\n+    check(\n+        r#\"\n+struct S {\n+    a: self::Ty,\n+    b: super::SuperTy,\n+    c: super::super::SuperSuperTy,\n+    d: ::abs::Path,\n+    e: crate::Crate,\n+    f: plain::path::Ty,\n+}\n+        \"#,\n+        expect![[r#\"\n+            pub(self) struct S {\n+                pub(self) a: self::Ty,\n+                pub(self) b: super::SuperTy,\n+                pub(self) c: super::super::SuperSuperTy,\n+                pub(self) d: ::abs::Path,\n+                pub(self) e: crate::Crate,\n+                pub(self) f: plain::path::Ty,\n+            }\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn types() {\n+    check(\n+        r#\"\n+struct S {\n+    a: Mixed<'a, T, Item=(), OtherItem=u8>,\n+    b: <Fully as Qualified>::Syntax,\n+    c: <TypeAnchored>::Path::<'a>,\n+}\n+        \"#,\n+        expect![[r#\"\n+            pub(self) struct S {\n+                pub(self) a: Mixed<'a, T, Item = (), OtherItem = u8>,\n+                pub(self) b: Qualified<Self=Fully>::Syntax,\n+                pub(self) c: <TypeAnchored>::Path<'a>,\n+            }\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn generics() {\n+    check(\n+        r#\"\n+struct S<'a, 'b: 'a, T: Copy + 'a + 'b, const K: u8 = 0> {\n+    field: &'a &'b T,\n+}\n+\n+struct Tuple<T: Copy>(T);\n+\n+impl<'a, 'b: 'a, T: Copy + 'a + 'b, const K: u8 = 0> S<'a, 'b, T, K> {\n+    fn f<G: 'a>(arg: impl Copy) -> impl Copy {}\n+}\n+\n+enum Enum<'a, T, const U: u8> {}\n+union Union<'a, T, const U: u8> {}\n+\n+trait Tr<'a, T: 'a>: Super {}\n+        \"#,\n+        expect![[r#\"\n+            pub(self) struct S<'a, 'b, T, const K: u8>\n+            where\n+                T: Copy,\n+                T: 'a,\n+                T: 'b\n+            {\n+                pub(self) field: &'a &'b T,\n+            }\n+\n+            pub(self) struct Tuple<T>(\n+                pub(self) 0: T,\n+            )\n+            where\n+                T: Copy;\n+\n+            impl<'a, 'b, T, const K: u8> S<'a, 'b, T, K>\n+            where\n+                T: Copy,\n+                T: 'a,\n+                T: 'b\n+            {\n+                // flags = 0x2\n+                pub(self) fn f<G, _anon_1>(\n+                    _: impl Copy,\n+                ) -> impl Copy\n+                where\n+                    G: 'a,\n+                    _anon_1: Copy;\n+            }\n+\n+            pub(self) enum Enum<'a, T, const U: u8> {\n+            }\n+\n+            pub(self) union Union<'a, T, const U: u8> {\n+            }\n+\n+            pub(self) trait Tr<'a, Self, T>: Super\n+            where\n+                Self: Super,\n+                T: 'a\n+            {\n+            }\n+        \"#]],\n+    )\n+}"}]}