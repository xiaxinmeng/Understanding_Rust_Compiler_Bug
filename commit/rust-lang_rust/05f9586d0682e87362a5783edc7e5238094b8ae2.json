{"sha": "05f9586d0682e87362a5783edc7e5238094b8ae2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1Zjk1ODZkMDY4MmU4NzM2MmE1NzgzZWRjN2U1MjM4MDk0YjhhZTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-22T23:33:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-22T23:33:51Z"}, "message": "auto merge of #5980 : Kimundi/rust/ascii-encoding, r=thestinger\n\nAdded Ascii type to use for byte inputs that are known to contain Ascii only.", "tree": {"sha": "b5b43357ac886775de44f93791f120511fd706af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5b43357ac886775de44f93791f120511fd706af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05f9586d0682e87362a5783edc7e5238094b8ae2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05f9586d0682e87362a5783edc7e5238094b8ae2", "html_url": "https://github.com/rust-lang/rust/commit/05f9586d0682e87362a5783edc7e5238094b8ae2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05f9586d0682e87362a5783edc7e5238094b8ae2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "html_url": "https://github.com/rust-lang/rust/commit/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9"}, {"sha": "bf4f088eaccfe24d4c30e7bf52e4c2bd20b9ff47", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf4f088eaccfe24d4c30e7bf52e4c2bd20b9ff47", "html_url": "https://github.com/rust-lang/rust/commit/bf4f088eaccfe24d4c30e7bf52e4c2bd20b9ff47"}], "stats": {"total": 351, "additions": 320, "deletions": 31}, "files": [{"sha": "c07a31490c34673643fb11130c92a4bdeed4b71c", "filename": "src/libcore/char.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/05f9586d0682e87362a5783edc7e5238094b8ae2/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05f9586d0682e87362a5783edc7e5238094b8ae2/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=05f9586d0682e87362a5783edc7e5238094b8ae2", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -234,6 +234,21 @@ pub fn escape_default(c: char) -> ~str {\n     }\n }\n \n+/// Returns the amount of bytes this character would need if encoded in utf8\n+pub fn len_utf8_bytes(c: char) -> uint {\n+    static max_one_b: uint = 128u;\n+    static max_two_b: uint = 2048u;\n+    static max_three_b: uint = 65536u;\n+    static max_four_b: uint = 2097152u;\n+\n+    let code = c as uint;\n+    if code < max_one_b { 1u }\n+    else if code < max_two_b { 2u }\n+    else if code < max_three_b { 3u }\n+    else if code < max_four_b { 4u }\n+    else { fail!(~\"invalid character!\") }\n+}\n+\n /**\n  * Compare two chars\n  *\n@@ -334,7 +349,6 @@ fn test_escape_default() {\n     assert_eq!(escape_default('\\U0001d4b6'), ~\"\\\\U0001d4b6\");\n }\n \n-\n #[test]\n fn test_escape_unicode() {\n     assert_eq!(escape_unicode('\\x00'), ~\"\\\\x00\");"}, {"sha": "b0a3939db73a064b2e374c583a9c52d70bd59017", "filename": "src/libcore/core.rc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/05f9586d0682e87362a5783edc7e5238094b8ae2/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/05f9586d0682e87362a5783edc7e5238094b8ae2/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=05f9586d0682e87362a5783edc7e5238094b8ae2", "patch": "@@ -164,6 +164,9 @@ pub mod vec;\n pub mod at_vec;\n pub mod str;\n \n+#[path = \"str/ascii.rs\"]\n+pub mod ascii;\n+\n pub mod ptr;\n pub mod owned;\n pub mod managed;"}, {"sha": "15aa6c78ed6e081e1f6d9452f75c814cad3b8313", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/05f9586d0682e87362a5783edc7e5238094b8ae2/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05f9586d0682e87362a5783edc7e5238094b8ae2/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=05f9586d0682e87362a5783edc7e5238094b8ae2", "patch": "@@ -45,9 +45,10 @@ pub use path::Path;\n pub use path::PosixPath;\n pub use path::WindowsPath;\n pub use ptr::Ptr;\n+pub use ascii::{Ascii, AsciiCast, OwnedAsciiCast, AsciiStr};\n pub use str::{StrSlice, OwnedStr};\n pub use to_bytes::IterBytes;\n-pub use to_str::ToStr;\n+pub use to_str::{ToStr, ToStrConsume};\n pub use tuple::{CopyableTuple, ImmutableTuple, ExtendedTupleOps};\n pub use vec::{CopyableVector, ImmutableVector};\n pub use vec::{ImmutableEqVector, ImmutableCopyableVector};"}, {"sha": "9590f148e3046d2809631f397d64e6dfdefd39ee", "filename": "src/libcore/str.rs", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/05f9586d0682e87362a5783edc7e5238094b8ae2/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05f9586d0682e87362a5783edc7e5238094b8ae2/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=05f9586d0682e87362a5783edc7e5238094b8ae2", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -789,16 +789,18 @@ pub fn each_split_within<'a>(ss: &'a str,\n \n /// Convert a string to lowercase. ASCII only\n pub fn to_lower(s: &str) -> ~str {\n-    map(s,\n-        |c| unsafe{(libc::tolower(c as libc::c_char)) as char}\n-    )\n+    do map(s) |c| {\n+        assert!(char::is_ascii(c));\n+        (unsafe{libc::tolower(c as libc::c_char)}) as char\n+    }\n }\n \n /// Convert a string to uppercase. ASCII only\n pub fn to_upper(s: &str) -> ~str {\n-    map(s,\n-        |c| unsafe{(libc::toupper(c as libc::c_char)) as char}\n-    )\n+    do map(s) |c| {\n+        assert!(char::is_ascii(c));\n+        (unsafe{libc::toupper(c as libc::c_char)}) as char\n+    }\n }\n \n /**\n@@ -2317,20 +2319,20 @@ pub mod raw {\n     }\n \n     /// Removes the last byte from a string and returns it. (Not UTF-8 safe).\n-    pub fn pop_byte(s: &mut ~str) -> u8 {\n+    pub unsafe fn pop_byte(s: &mut ~str) -> u8 {\n         let len = len(*s);\n         assert!((len > 0u));\n         let b = s[len - 1u];\n-        unsafe { set_len(s, len - 1u) };\n+        set_len(s, len - 1u);\n         return b;\n     }\n \n     /// Removes the first byte from a string and returns it. (Not UTF-8 safe).\n-    pub fn shift_byte(s: &mut ~str) -> u8 {\n+    pub unsafe fn shift_byte(s: &mut ~str) -> u8 {\n         let len = len(*s);\n         assert!((len > 0u));\n         let b = s[0];\n-        *s = unsafe { raw::slice_bytes_owned(*s, 1u, len) };\n+        *s = raw::slice_bytes_owned(*s, 1u, len);\n         return b;\n     }\n \n@@ -3096,12 +3098,11 @@ mod tests {\n \n     #[test]\n     fn test_to_lower() {\n-        unsafe {\n-            assert!(~\"\" == map(~\"\",\n-                |c| libc::tolower(c as c_char) as char));\n-            assert!(~\"ymca\" == map(~\"YMCA\",\n-                |c| libc::tolower(c as c_char) as char));\n-        }\n+        // libc::tolower, and hence str::to_lower\n+        // are culturally insensitive: they only work for ASCII\n+        // (see Issue #1347)\n+        assert!(~\"\" == to_lower(\"\"));\n+        assert!(~\"ymca\" == to_lower(\"YMCA\"));\n     }\n \n     #[test]\n@@ -3346,15 +3347,15 @@ mod tests {\n     #[test]\n     fn test_shift_byte() {\n         let mut s = ~\"ABC\";\n-        let b = raw::shift_byte(&mut s);\n+        let b = unsafe{raw::shift_byte(&mut s)};\n         assert!((s == ~\"BC\"));\n         assert!((b == 65u8));\n     }\n \n     #[test]\n     fn test_pop_byte() {\n         let mut s = ~\"ABC\";\n-        let b = raw::pop_byte(&mut s);\n+        let b = unsafe{raw::pop_byte(&mut s)};\n         assert!((s == ~\"AB\"));\n         assert!((b == 67u8));\n     }\n@@ -3666,12 +3667,8 @@ mod tests {\n \n     #[test]\n     fn test_map() {\n-        unsafe {\n-            assert!(~\"\" == map(~\"\", |c|\n-                libc::toupper(c as c_char) as char));\n-            assert!(~\"YMCA\" == map(~\"ymca\",\n-                                  |c| libc::toupper(c as c_char) as char));\n-        }\n+        assert!(~\"\" == map(~\"\", |c| unsafe {libc::toupper(c as c_char)} as char));\n+        assert!(~\"YMCA\" == map(~\"ymca\", |c| unsafe {libc::toupper(c as c_char)} as char));\n     }\n \n     #[test]\n@@ -3685,11 +3682,11 @@ mod tests {\n \n     #[test]\n     fn test_any() {\n-        assert!(false  == any(~\"\", char::is_uppercase));\n+        assert!(false == any(~\"\", char::is_uppercase));\n         assert!(false == any(~\"ymca\", char::is_uppercase));\n         assert!(true  == any(~\"YMCA\", char::is_uppercase));\n-        assert!(true == any(~\"yMCA\", char::is_uppercase));\n-        assert!(true == any(~\"Ymcy\", char::is_uppercase));\n+        assert!(true  == any(~\"yMCA\", char::is_uppercase));\n+        assert!(true  == any(~\"Ymcy\", char::is_uppercase));\n     }\n \n     #[test]"}, {"sha": "339274ab47e4fc02dd4cc05da3bad2c399f0cd80", "filename": "src/libcore/str/ascii.rs", "status": "added", "additions": 268, "deletions": 0, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/05f9586d0682e87362a5783edc7e5238094b8ae2/src%2Flibcore%2Fstr%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05f9586d0682e87362a5783edc7e5238094b8ae2/src%2Flibcore%2Fstr%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fascii.rs?ref=05f9586d0682e87362a5783edc7e5238094b8ae2", "patch": "@@ -0,0 +1,268 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use to_str::{ToStr,ToStrConsume};\n+use str;\n+use cast;\n+\n+/// Datatype to hold one ascii character. It is 8 bit long.\n+#[deriving(Clone, Eq)]\n+pub struct Ascii { priv chr: u8 }\n+\n+pub impl Ascii {\n+    /// Converts a ascii character into a `u8`.\n+    #[inline(always)]\n+    fn to_byte(self) -> u8 {\n+        self.chr\n+    }\n+\n+    /// Converts a ascii character into a `char`.\n+    #[inline(always)]\n+    fn to_char(self) -> char {\n+        self.chr as char\n+    }\n+\n+    /// Convert to lowercase.\n+    #[inline(always)]\n+    fn to_lower(self) -> Ascii {\n+        if self.chr >= 65 && self.chr <= 90 {\n+            Ascii{chr: self.chr | 0x20 }\n+        } else {\n+            self\n+        }\n+    }\n+\n+    /// Convert to uppercase.\n+    #[inline(always)]\n+    fn to_upper(self) -> Ascii {\n+        if self.chr >= 97 && self.chr <= 122 {\n+            Ascii{chr: self.chr & !0x20 }\n+        } else {\n+            self\n+        }\n+    }\n+\n+    // Compares two ascii characters of equality, ignoring case.\n+    #[inline(always)]\n+    fn eq_ignore_case(self, other: Ascii) -> bool {\n+        self.to_lower().chr == other.to_lower().chr\n+    }\n+}\n+\n+impl ToStr for Ascii {\n+    #[inline(always)]\n+    fn to_str(&self) -> ~str { str::from_bytes(['\\'' as u8, self.chr, '\\'' as u8]) }\n+}\n+\n+/// Trait for converting into an ascii type.\n+pub trait AsciiCast<T> {\n+    /// Convert to an ascii type\n+    fn to_ascii(&self) -> T;\n+\n+    /// Check if convertible to ascii\n+    fn is_ascii(&self) -> bool;\n+}\n+\n+impl<'self> AsciiCast<&'self[Ascii]> for &'self [u8] {\n+    #[inline(always)]\n+    fn to_ascii(&self) -> &'self[Ascii] {\n+        assert!(self.is_ascii());\n+        unsafe{ cast::transmute(*self) }\n+    }\n+\n+    #[inline(always)]\n+    fn is_ascii(&self) -> bool {\n+        for self.each |b| {\n+            if !b.is_ascii() { return false; }\n+        }\n+        true\n+    }\n+}\n+\n+impl<'self> AsciiCast<&'self[Ascii]> for &'self str {\n+    #[inline(always)]\n+    fn to_ascii(&self) -> &'self[Ascii] {\n+        assert!(self.is_ascii());\n+        let (p,len): (*u8, uint) = unsafe{ cast::transmute(*self) };\n+        unsafe{ cast::transmute((p, len - 1))}\n+    }\n+\n+    #[inline(always)]\n+    fn is_ascii(&self) -> bool {\n+        for self.each |b| {\n+            if !b.is_ascii() { return false; }\n+        }\n+        true\n+    }\n+}\n+\n+impl AsciiCast<Ascii> for u8 {\n+    #[inline(always)]\n+    fn to_ascii(&self) -> Ascii {\n+        assert!(self.is_ascii());\n+        Ascii{ chr: *self }\n+    }\n+\n+    #[inline(always)]\n+    fn is_ascii(&self) -> bool {\n+        *self & 128 == 0u8\n+    }\n+}\n+\n+impl AsciiCast<Ascii> for char {\n+    #[inline(always)]\n+    fn to_ascii(&self) -> Ascii {\n+        assert!(self.is_ascii());\n+        Ascii{ chr: *self as u8 }\n+    }\n+\n+    #[inline(always)]\n+    fn is_ascii(&self) -> bool {\n+        *self - ('\\x7F' & *self) == '\\x00'\n+    }\n+}\n+\n+/// Trait for copyless casting to an ascii vector.\n+pub trait OwnedAsciiCast {\n+    /// Take ownership and cast to an ascii vector without trailing zero element.\n+    fn to_ascii_consume(self) -> ~[Ascii];\n+}\n+\n+impl OwnedAsciiCast for ~[u8] {\n+    #[inline(always)]\n+    fn to_ascii_consume(self) -> ~[Ascii] {\n+        assert!(self.is_ascii());\n+        unsafe {cast::transmute(self)}\n+    }\n+}\n+\n+impl OwnedAsciiCast for ~str {\n+    #[inline(always)]\n+    fn to_ascii_consume(self) -> ~[Ascii] {\n+        assert!(self.is_ascii());\n+        let mut s = self;\n+        unsafe {\n+            str::raw::pop_byte(&mut s);\n+            cast::transmute(s)\n+        }\n+    }\n+}\n+\n+/// Trait for converting an ascii type to a string. Needed to convert `&[Ascii]` to `~str`\n+pub trait AsciiStr {\n+    /// Convert to a string.\n+    fn to_str_ascii(&self) -> ~str;\n+\n+    /// Convert to vector representing a lower cased ascii string.\n+    fn to_lower(&self) -> ~[Ascii];\n+\n+    /// Convert to vector representing a upper cased ascii string.\n+    fn to_upper(&self) -> ~[Ascii];\n+\n+}\n+\n+impl<'self> AsciiStr for &'self [Ascii] {\n+    #[inline(always)]\n+    fn to_str_ascii(&self) -> ~str {\n+        let mut cpy = self.to_owned();\n+        cpy.push(0u8.to_ascii());\n+        unsafe {cast::transmute(cpy)}\n+    }\n+\n+    #[inline(always)]\n+    fn to_lower(&self) -> ~[Ascii] {\n+        self.map(|a| a.to_lower())\n+    }\n+\n+    #[inline(always)]\n+    fn to_upper(&self) -> ~[Ascii] {\n+        self.map(|a| a.to_upper())\n+    }\n+}\n+\n+impl ToStrConsume for ~[Ascii] {\n+    #[inline(always)]\n+    fn to_str_consume(self) -> ~str {\n+        let mut cpy = self;\n+        cpy.push(0u8.to_ascii());\n+        unsafe {cast::transmute(cpy)}\n+    }\n+}\n+\n+mod tests {\n+    use super::*;\n+\n+    macro_rules! v2ascii (\n+        ( [$($e:expr),*]) => ( [$(Ascii{chr:$e}),*]);\n+        (~[$($e:expr),*]) => (~[$(Ascii{chr:$e}),*]);\n+    )\n+\n+    #[test]\n+    fn test_ascii() {\n+        assert_eq!(65u8.to_ascii().to_byte(), 65u8);\n+        assert_eq!(65u8.to_ascii().to_char(), 'A');\n+        assert_eq!('A'.to_ascii().to_char(), 'A');\n+        assert_eq!('A'.to_ascii().to_byte(), 65u8);\n+\n+        assert_eq!('A'.to_ascii().to_lower().to_char(), 'a');\n+        assert_eq!('Z'.to_ascii().to_lower().to_char(), 'z');\n+        assert_eq!('a'.to_ascii().to_upper().to_char(), 'A');\n+        assert_eq!('z'.to_ascii().to_upper().to_char(), 'Z');\n+\n+        assert_eq!('@'.to_ascii().to_lower().to_char(), '@');\n+        assert_eq!('['.to_ascii().to_lower().to_char(), '[');\n+        assert_eq!('`'.to_ascii().to_upper().to_char(), '`');\n+        assert_eq!('{'.to_ascii().to_upper().to_char(), '{');\n+    }\n+\n+    #[test]\n+    fn test_ascii_vec() {\n+        assert_eq!((&[40u8, 32u8, 59u8]).to_ascii(), v2ascii!([40, 32, 59]));\n+        assert_eq!(\"( ;\".to_ascii(),                 v2ascii!([40, 32, 59]));\n+        // FIXME: #5475 borrowchk error, owned vectors do not live long enough\n+        // if chained-from directly\n+        let v = ~[40u8, 32u8, 59u8]; assert_eq!(v.to_ascii(), v2ascii!([40, 32, 59]));\n+        let v = ~\"( ;\";              assert_eq!(v.to_ascii(), v2ascii!([40, 32, 59]));\n+\n+        assert_eq!(\"abCDef&?#\".to_ascii().to_lower().to_str_ascii(), ~\"abcdef&?#\");\n+        assert_eq!(\"abCDef&?#\".to_ascii().to_upper().to_str_ascii(), ~\"ABCDEF&?#\");\n+    }\n+\n+    #[test]\n+    fn test_owned_ascii_vec() {\n+        // FIXME: #4318 Compiler crashes on moving self\n+        //assert_eq!(~\"( ;\".to_ascii_consume(), v2ascii!(~[40, 32, 59]));\n+        //assert_eq!(~[40u8, 32u8, 59u8].to_ascii_consume(), v2ascii!(~[40, 32, 59]));\n+        //assert_eq!(~\"( ;\".to_ascii_consume_with_null(), v2ascii!(~[40, 32, 59, 0]));\n+        //assert_eq!(~[40u8, 32u8, 59u8].to_ascii_consume_with_null(),\n+        //           v2ascii!(~[40, 32, 59, 0]));\n+    }\n+\n+    #[test]\n+    fn test_ascii_to_str() { assert_eq!(v2ascii!([40, 32, 59]).to_str_ascii(), ~\"( ;\"); }\n+\n+    #[test]\n+    fn test_ascii_to_str_consume() {\n+        // FIXME: #4318 Compiler crashes on moving self\n+        //assert_eq!(v2ascii!(~[40, 32, 59]).to_str_consume(), ~\"( ;\");\n+    }\n+\n+    #[test] #[should_fail]\n+    fn test_ascii_vec_fail_u8_slice()  { (&[127u8, 128u8, 255u8]).to_ascii(); }\n+\n+    #[test] #[should_fail]\n+    fn test_ascii_vec_fail_str_slice() { \"zo\u00e4\u534e\".to_ascii(); }\n+\n+    #[test] #[should_fail]\n+    fn test_ascii_fail_u8_slice() { 255u8.to_ascii(); }\n+\n+    #[test] #[should_fail]\n+    fn test_ascii_fail_char_slice() { '\u03bb'.to_ascii(); }\n+}"}, {"sha": "7f8e6915add16544423fa3e6592994649b33c221", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/05f9586d0682e87362a5783edc7e5238094b8ae2/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05f9586d0682e87362a5783edc7e5238094b8ae2/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=05f9586d0682e87362a5783edc7e5238094b8ae2", "patch": "@@ -20,6 +20,12 @@ pub trait ToStr {\n     fn to_str(&self) -> ~str;\n }\n \n+/// Trait for converting a type to a string, consuming it in the process.\n+pub trait ToStrConsume {\n+    // Cosume and convert to a string.\n+    fn to_str_consume(self) -> ~str;\n+}\n+\n impl ToStr for bool {\n     #[inline(always)]\n     fn to_str(&self) -> ~str { ::bool::to_str(*self) }"}]}