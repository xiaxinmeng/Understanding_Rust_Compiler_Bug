{"sha": "fbdd0388664127c3dd2c3e6a162b597a87ffa7c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiZGQwMzg4NjY0MTI3YzNkZDJjM2U2YTE2MmI1OTdhODdmZmE3Yzk=", "commit": {"author": {"name": "Josh Driver", "email": "keeperofdakeys@gmail.com", "date": "2017-02-01T10:33:09Z"}, "committer": {"name": "Josh Driver", "email": "keeperofdakeys@gmail.com", "date": "2017-02-04T23:01:02Z"}, "message": "Move derive macro expansion into the MacroExpander\n\nThis removes the expand_derives function, and sprinkles\nthe functionality throughout the Invocation Collector,\nExpander and Resolver.", "tree": {"sha": "96056b6ba5bb09e6618c7ed99f70cf5347cc9082", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96056b6ba5bb09e6618c7ed99f70cf5347cc9082"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9", "html_url": "https://github.com/rust-lang/rust/commit/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/comments", "author": {"login": "keeperofdakeys", "id": 141626, "node_id": "MDQ6VXNlcjE0MTYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/141626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/keeperofdakeys", "html_url": "https://github.com/keeperofdakeys", "followers_url": "https://api.github.com/users/keeperofdakeys/followers", "following_url": "https://api.github.com/users/keeperofdakeys/following{/other_user}", "gists_url": "https://api.github.com/users/keeperofdakeys/gists{/gist_id}", "starred_url": "https://api.github.com/users/keeperofdakeys/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/keeperofdakeys/subscriptions", "organizations_url": "https://api.github.com/users/keeperofdakeys/orgs", "repos_url": "https://api.github.com/users/keeperofdakeys/repos", "events_url": "https://api.github.com/users/keeperofdakeys/events{/privacy}", "received_events_url": "https://api.github.com/users/keeperofdakeys/received_events", "type": "User", "site_admin": false}, "committer": {"login": "keeperofdakeys", "id": 141626, "node_id": "MDQ6VXNlcjE0MTYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/141626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/keeperofdakeys", "html_url": "https://github.com/keeperofdakeys", "followers_url": "https://api.github.com/users/keeperofdakeys/followers", "following_url": "https://api.github.com/users/keeperofdakeys/following{/other_user}", "gists_url": "https://api.github.com/users/keeperofdakeys/gists{/gist_id}", "starred_url": "https://api.github.com/users/keeperofdakeys/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/keeperofdakeys/subscriptions", "organizations_url": "https://api.github.com/users/keeperofdakeys/orgs", "repos_url": "https://api.github.com/users/keeperofdakeys/repos", "events_url": "https://api.github.com/users/keeperofdakeys/events{/privacy}", "received_events_url": "https://api.github.com/users/keeperofdakeys/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a7380d7fcd99ef288ee038fd145da5af41ce84a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a7380d7fcd99ef288ee038fd145da5af41ce84a", "html_url": "https://github.com/rust-lang/rust/commit/0a7380d7fcd99ef288ee038fd145da5af41ce84a"}], "stats": {"total": 643, "additions": 378, "deletions": 265}, "files": [{"sha": "ea3112b2463f8ba27007e6e14405c475ef93e153", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=fbdd0388664127c3dd2c3e6a162b597a87ffa7c9", "patch": "@@ -250,6 +250,32 @@ impl<'a> base::Resolver for Resolver<'a> {\n         }\n         result\n     }\n+\n+    fn resolve_builtin_macro(&mut self, tname: Name) -> Result<Rc<SyntaxExtension>, Determinacy> {\n+        match self.builtin_macros.get(&tname).cloned() {\n+            Some(binding) => Ok(binding.get_macro(self)),\n+            None => Err(Determinacy::Undetermined),\n+        }\n+    }\n+\n+    fn resolve_derive_macro(&mut self, scope: Mark, path: &ast::Path, force: bool)\n+                            -> Result<Rc<SyntaxExtension>, Determinacy> {\n+        let ast::Path { span, .. } = *path;\n+        match self.resolve_macro(scope, path, false) {\n+            Ok(ext) => match *ext {\n+                SyntaxExtension::BuiltinDerive(..) |\n+                SyntaxExtension::ProcMacroDerive(..) => Ok(ext),\n+                _ => Err(Determinacy::Determined),\n+            },\n+            Err(Determinacy::Undetermined) if force => {\n+                let msg = format!(\"cannot find derive macro `{}` in this scope\", path);\n+                let mut err = self.session.struct_span_err(span, &msg);\n+                err.emit();\n+                Err(Determinacy::Determined)\n+            },\n+            Err(err) => Err(err),\n+        }\n+    }\n }\n \n impl<'a> Resolver<'a> {"}, {"sha": "9a717b86d091ed6682cd67427c89bda2baadf850", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=fbdd0388664127c3dd2c3e6a162b597a87ffa7c9", "patch": "@@ -536,6 +536,9 @@ pub trait Resolver {\n     fn find_attr_invoc(&mut self, attrs: &mut Vec<Attribute>) -> Option<Attribute>;\n     fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, force: bool)\n                      -> Result<Rc<SyntaxExtension>, Determinacy>;\n+    fn resolve_builtin_macro(&mut self, tname: Name) -> Result<Rc<SyntaxExtension>, Determinacy>;\n+    fn resolve_derive_macro(&mut self, scope: Mark, path: &ast::Path, force: bool)\n+                            -> Result<Rc<SyntaxExtension>, Determinacy>;\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -562,6 +565,13 @@ impl Resolver for DummyResolver {\n                      -> Result<Rc<SyntaxExtension>, Determinacy> {\n         Err(Determinacy::Determined)\n     }\n+    fn resolve_builtin_macro(&mut self, _tname: Name) -> Result<Rc<SyntaxExtension>, Determinacy> {\n+        Err(Determinacy::Determined)\n+    }\n+    fn resolve_derive_macro(&mut self, _scope: Mark, _path: &ast::Path, _force: bool)\n+                            -> Result<Rc<SyntaxExtension>, Determinacy> {\n+        Err(Determinacy::Determined)\n+    }\n }\n \n #[derive(Clone)]"}, {"sha": "946448eaaee99a2efbfe170e6c59515d7c24794f", "filename": "src/libsyntax/ext/derive.rs", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=fbdd0388664127c3dd2c3e6a162b597a87ffa7c9", "patch": "@@ -0,0 +1,218 @@\n+// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ast::Name;\n+use attr;\n+use ast::{self, NestedMetaItem}; use ext::base::{ExtCtxt, SyntaxExtension};\n+use codemap;\n+use ext::build::AstBuilder;\n+use feature_gate;\n+use symbol::Symbol;\n+use syntax_pos::Span;\n+\n+pub fn derive_attr_trait<'a>(cx: &mut ExtCtxt, attr: &'a ast::Attribute)\n+                             -> Option<&'a NestedMetaItem> {\n+    if attr.name() != \"derive\" {\n+        return None;\n+    }\n+    if attr.value_str().is_some() {\n+        cx.span_err(attr.span, \"unexpected value in `derive`\");\n+        return None;\n+    }\n+\n+    let traits = attr.meta_item_list().unwrap_or(&[]);\n+\n+    if traits.is_empty() {\n+        cx.span_warn(attr.span, \"empty trait list in `derive`\");\n+        return None;\n+    }\n+\n+    return traits.get(0);\n+}\n+\n+pub fn verify_derive_attrs(cx: &mut ExtCtxt, attrs: &[ast::Attribute]) {\n+    for attr in attrs {\n+        if attr.name() != \"derive\" {\n+            continue;\n+        }\n+\n+        if attr.value_str().is_some() {\n+            cx.span_err(attr.span, \"unexpected value in `derive`\");\n+        }\n+\n+        let traits = attr.meta_item_list().unwrap_or(&[]).to_owned();\n+\n+        if traits.is_empty() {\n+            cx.span_warn(attr.span, \"empty trait list in `derive`\");\n+            attr::mark_used(&attr);\n+            continue;\n+        }\n+        for titem in traits {\n+            if titem.word().is_none() {\n+                cx.span_err(titem.span, \"malformed `derive` entry\");\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(PartialEq, Debug, Clone, Copy)]\n+pub enum DeriveType {\n+    Legacy,\n+    ProcMacro,\n+    Builtin\n+}\n+\n+impl DeriveType {\n+    // Classify a derive trait name by resolving the macro.\n+    pub fn classify(cx: &mut ExtCtxt, tname: Name) -> DeriveType {\n+        let legacy_derive_name = Symbol::intern(&format!(\"derive_{}\", tname));\n+\n+        if let Ok(_) = cx.resolver.resolve_builtin_macro(legacy_derive_name) {\n+            return DeriveType::Legacy;\n+        }\n+\n+        match cx.resolver.resolve_builtin_macro(tname) {\n+            Ok(ext) => match *ext {\n+                SyntaxExtension::BuiltinDerive(..) => DeriveType::Builtin,\n+                _ => DeriveType::ProcMacro,\n+            },\n+            Err(_) => DeriveType::ProcMacro,\n+        }\n+    }\n+}\n+\n+pub fn get_derive_attr(cx: &mut ExtCtxt, attrs: &mut Vec<ast::Attribute>,\n+                       derive_type: DeriveType) -> Option<ast::Attribute> {\n+    for i in 0..attrs.len() {\n+        if attrs[i].name() != \"derive\" {\n+            continue;\n+        }\n+\n+        if attrs[i].value_str().is_some() {\n+            continue;\n+        }\n+\n+        let mut traits = attrs[i].meta_item_list().unwrap_or(&[]).to_owned();\n+\n+        // First, weed out malformed #[derive]\n+        traits.retain(|titem| titem.word().is_some());\n+\n+        let mut titem = None;\n+\n+        // See if we can find a matching trait.\n+        for j in 0..traits.len() {\n+            let tname = match traits[j].name() {\n+                Some(tname) => tname,\n+                _ => continue,\n+            };\n+\n+            if DeriveType::classify(cx, tname) == derive_type {\n+                titem = Some(traits.remove(j));\n+                break;\n+            }\n+        }\n+\n+        // If we find a trait, remove the trait from the attribute.\n+        if let Some(titem) = titem {\n+            if traits.len() == 0 {\n+                attrs.remove(i);\n+            } else {\n+                let derive = Symbol::intern(\"derive\");\n+                let mitem = cx.meta_list(titem.span, derive, traits);\n+                attrs[i] = cx.attribute(titem.span, mitem);\n+            }\n+            let derive = Symbol::intern(\"derive\");\n+            let mitem = cx.meta_list(titem.span, derive, vec![titem]);\n+            return Some(cx.attribute(mitem.span, mitem));\n+        }\n+    }\n+    return None;\n+}\n+\n+fn allow_unstable(cx: &mut ExtCtxt, span: Span, attr_name: &str) -> Span {\n+    Span {\n+        expn_id: cx.codemap().record_expansion(codemap::ExpnInfo {\n+            call_site: span,\n+            callee: codemap::NameAndSpan {\n+                format: codemap::MacroAttribute(Symbol::intern(attr_name)),\n+                span: Some(span),\n+                allow_internal_unstable: true,\n+            },\n+        }),\n+        ..span\n+    }\n+}\n+\n+pub fn add_derived_markers(cx: &mut ExtCtxt, attrs: &mut Vec<ast::Attribute>) {\n+    if attrs.is_empty() {\n+        return;\n+    }\n+\n+    let titems = attrs.iter().filter(|a| {\n+        a.name() == \"derive\"\n+    }).flat_map(|a| {\n+        a.meta_item_list().unwrap_or(&[]).iter()\n+    }).filter_map(|titem| {\n+        titem.name()\n+    }).collect::<Vec<_>>();\n+\n+    let span = attrs[0].span;\n+\n+    if !attrs.iter().any(|a| a.name() == \"structural_match\") &&\n+       titems.iter().any(|t| *t == \"PartialEq\") && titems.iter().any(|t| *t == \"Eq\") {\n+        let structural_match = Symbol::intern(\"structural_match\");\n+        let span = allow_unstable(cx, span, \"derive(PartialEq, Eq)\");\n+        let meta = cx.meta_word(span, structural_match);\n+        attrs.push(cx.attribute(span, meta));\n+    }\n+\n+    if !attrs.iter().any(|a| a.name() == \"rustc_copy_clone_marker\") &&\n+       titems.iter().any(|t| *t == \"Copy\") && titems.iter().any(|t| *t == \"Clone\") {\n+        let structural_match = Symbol::intern(\"rustc_copy_clone_marker\");\n+        let span = allow_unstable(cx, span, \"derive(Copy, Clone)\");\n+        let meta = cx.meta_word(span, structural_match);\n+        attrs.push(cx.attribute(span, meta));\n+    }\n+}\n+\n+pub fn find_derive_attr(cx: &mut ExtCtxt, attrs: &mut Vec<ast::Attribute>)\n+                        -> Option<ast::Attribute> {\n+    verify_derive_attrs(cx, attrs);\n+    get_derive_attr(cx, attrs, DeriveType::Legacy).and_then(|a| {\n+        let titem = derive_attr_trait(cx, &a);\n+        titem.and_then(|titem| {\n+            let tword = titem.word().unwrap();\n+            let tname = tword.name();\n+            if !cx.ecfg.enable_custom_derive() {\n+                feature_gate::emit_feature_err(\n+                    &cx.parse_sess,\n+                    \"custom_derive\",\n+                    titem.span,\n+                    feature_gate::GateIssue::Language,\n+                    feature_gate::EXPLAIN_CUSTOM_DERIVE\n+                );\n+                None\n+            } else {\n+                let name = Symbol::intern(&format!(\"derive_{}\", tname));\n+                if !cx.resolver.is_whitelisted_legacy_custom_derive(name) {\n+                    cx.span_warn(titem.span,\n+                                 feature_gate::EXPLAIN_DEPR_CUSTOM_DERIVE);\n+                }\n+                let mitem = cx.meta_word(titem.span, name);\n+                Some(cx.attribute(mitem.span, mitem))\n+            }\n+        })\n+    }).or_else(|| {\n+        get_derive_attr(cx, attrs, DeriveType::ProcMacro)\n+    }).or_else(|| {\n+        add_derived_markers(cx, attrs);\n+        get_derive_attr(cx, attrs, DeriveType::Builtin)\n+    })\n+}"}, {"sha": "8e7f8830eafbc586d2b2c04ad60d44487cc12dc9", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 102, "deletions": 8, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=fbdd0388664127c3dd2c3e6a162b597a87ffa7c9", "patch": "@@ -8,26 +8,27 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{Block, Ident, Mac_, PatKind};\n+use ast::{self, Block, Ident, Mac_, PatKind};\n use ast::{Name, MacStmtStyle, StmtKind, ItemKind};\n-use ast;\n-use ext::hygiene::Mark;\n-use ext::placeholders::{placeholder, PlaceholderExpander};\n use attr::{self, HasAttrs};\n use codemap::{ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n-use syntax_pos::{self, Span, ExpnId};\n use config::{is_test_or_bench, StripUnconfigured};\n use ext::base::*;\n+use ext::derive::{find_derive_attr, derive_attr_trait};\n+use ext::hygiene::Mark;\n+use ext::placeholders::{placeholder, PlaceholderExpander};\n use feature_gate::{self, Features};\n use fold;\n use fold::*;\n-use parse::{ParseSess, DirectoryOwnership, PResult, filemap_to_tts};\n use parse::parser::Parser;\n use parse::token;\n+use parse::{ParseSess, DirectoryOwnership, PResult, filemap_to_tts};\n use print::pprust;\n use ptr::P;\n use std_inject;\n+use symbol::Symbol;\n use symbol::keywords;\n+use syntax_pos::{self, Span, ExpnId};\n use tokenstream::{TokenTree, TokenStream};\n use util::small_vector::SmallVector;\n use visit::Visitor;\n@@ -166,13 +167,18 @@ pub enum InvocationKind {\n         attr: ast::Attribute,\n         item: Annotatable,\n     },\n+    Derive {\n+        attr: ast::Attribute,\n+        item: Annotatable,\n+    },\n }\n \n impl Invocation {\n     fn span(&self) -> Span {\n         match self.kind {\n             InvocationKind::Bang { span, .. } => span,\n             InvocationKind::Attr { ref attr, .. } => attr.span,\n+            InvocationKind::Derive { ref attr, .. } => attr.span,\n         }\n     }\n }\n@@ -250,6 +256,13 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     let path = ast::Path::from_ident(attr.span, ident);\n                     self.cx.resolver.resolve_macro(scope, &path, force)\n                 }\n+                InvocationKind::Derive { ref attr, .. } => {\n+                    let titem = derive_attr_trait(self.cx, &attr).unwrap();\n+                    let tname = titem.name().expect(\"Expected derive macro name\");\n+                    let ident = Ident::with_empty_ctxt(tname);\n+                    let path = ast::Path::from_ident(attr.span, ident);\n+                    self.cx.resolver.resolve_derive_macro(scope, &path, force)\n+                }\n             };\n             let ext = match resolution {\n                 Ok(ext) => Some(ext),\n@@ -330,6 +343,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         match invoc.kind {\n             InvocationKind::Bang { .. } => self.expand_bang_invoc(invoc, ext),\n             InvocationKind::Attr { .. } => self.expand_attr_invoc(invoc, ext),\n+            InvocationKind::Derive { .. } => self.expand_derive_invoc(invoc, ext),\n         }\n     }\n \n@@ -486,6 +500,71 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         })\n     }\n \n+    /// Expand a derive invocation. Returns the result of expansion.\n+    fn expand_derive_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n+        let Invocation { expansion_kind: kind, .. } = invoc;\n+        let (attr, item) = match invoc.kind {\n+            InvocationKind::Derive { attr, item } => (attr, item),\n+            _ => unreachable!(),\n+        };\n+\n+        attr::mark_used(&attr);\n+        let titem = derive_attr_trait(self.cx, &attr).unwrap();\n+        let tname = ast::Ident::with_empty_ctxt(titem.name().unwrap());\n+        let name = Symbol::intern(&format!(\"derive({})\", tname));\n+        let mitem = &attr.value;\n+\n+        self.cx.bt_push(ExpnInfo {\n+            call_site: attr.span,\n+            callee: NameAndSpan {\n+                format: MacroAttribute(attr.name()),\n+                span: Some(attr.span),\n+                allow_internal_unstable: false,\n+            }\n+        });\n+\n+        match *ext {\n+            SyntaxExtension::ProcMacroDerive(ref ext) => {\n+                let span = Span {\n+                    expn_id: self.cx.codemap().record_expansion(ExpnInfo {\n+                        call_site: mitem.span,\n+                        callee: NameAndSpan {\n+                            format: MacroAttribute(Symbol::intern(&format!(\"derive({})\", tname))),\n+                            span: None,\n+                            allow_internal_unstable: false,\n+                        },\n+                    }),\n+                    ..mitem.span\n+                };\n+                return kind.expect_from_annotatables(ext.expand(self.cx, span, &mitem, item));\n+            }\n+            SyntaxExtension::BuiltinDerive(func) => {\n+                let span = Span {\n+                    expn_id: self.cx.codemap().record_expansion(ExpnInfo {\n+                        call_site: titem.span,\n+                        callee: NameAndSpan {\n+                            format: MacroAttribute(name),\n+                            span: None,\n+                            allow_internal_unstable: true,\n+                        },\n+                    }),\n+                    ..titem.span\n+                };\n+                let mut items = Vec::new();\n+                func(self.cx, span, &mitem, &item, &mut |a| {\n+                    items.push(a)\n+                });\n+                items.insert(0, item);\n+                return kind.expect_from_annotatables(items);\n+            }\n+            _ => {\n+                let msg = &format!(\"macro `{}` may not be used for derive attributes\", name);\n+                self.cx.span_err(attr.span, &msg);\n+                kind.dummy(attr.span)\n+            }\n+        }\n+    }\n+\n     fn parse_expansion(&mut self, toks: TokenStream, kind: ExpansionKind, name: Name, span: Span)\n                        -> Expansion {\n         let mut parser = self.cx.new_parser_from_tts(&toks.trees().cloned().collect::<Vec<_>>());\n@@ -595,16 +674,31 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n \n     fn collect_attr(&mut self, attr: ast::Attribute, item: Annotatable, kind: ExpansionKind)\n                     -> Expansion {\n-        self.collect(kind, InvocationKind::Attr { attr: attr, item: item })\n+        let invoc_kind = if attr.name() == \"derive\" {\n+            if kind == ExpansionKind::TraitItems || kind == ExpansionKind::ImplItems {\n+                self.cx.span_err(attr.span, \"`derive` can be only be applied to items\");\n+                return kind.expect_from_annotatables(::std::iter::once(item));\n+            }\n+            InvocationKind::Derive { attr: attr, item: item }\n+        } else {\n+            InvocationKind::Attr { attr: attr, item: item }\n+        };\n+\n+        self.collect(kind, invoc_kind)\n     }\n \n     // If `item` is an attr invocation, remove and return the macro attribute.\n     fn classify_item<T: HasAttrs>(&mut self, mut item: T) -> (T, Option<ast::Attribute>) {\n         let mut attr = None;\n+\n         item = item.map_attrs(|mut attrs| {\n-            attr = self.cx.resolver.find_attr_invoc(&mut attrs);\n+            attr = self.cx.resolver.find_attr_invoc(&mut attrs).or_else(|| {\n+                find_derive_attr(self.cx, &mut attrs)\n+            });\n+\n             attrs\n         });\n+\n         (item, attr)\n     }\n "}, {"sha": "87a03adf6b77c018784aa535a3939f0ba1db4a2c", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=fbdd0388664127c3dd2c3e6a162b597a87ffa7c9", "patch": "@@ -128,6 +128,7 @@ pub mod print {\n pub mod ext {\n     pub mod base;\n     pub mod build;\n+    pub mod derive;\n     pub mod expand;\n     pub mod placeholders;\n     pub mod hygiene;"}, {"sha": "974e86a57412446d0b2457b48704e8e46a91f927", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=fbdd0388664127c3dd2c3e6a162b597a87ffa7c9", "patch": "@@ -54,7 +54,7 @@ impl MultiItemModifier for ProcMacroDerive {\n             Annotatable::Item(item) => item,\n             Annotatable::ImplItem(_) |\n             Annotatable::TraitItem(_) => {\n-                ecx.span_err(span, \"proc_macro_derive attributes may only be \\\n+                ecx.span_err(span, \"proc-macro derives may only be \\\n                                     applied to struct/enum items\");\n                 return Vec::new()\n             }\n@@ -63,7 +63,7 @@ impl MultiItemModifier for ProcMacroDerive {\n             ItemKind::Struct(..) |\n             ItemKind::Enum(..) => {},\n             _ => {\n-                ecx.span_err(span, \"proc_macro_derive attributes may only be \\\n+                ecx.span_err(span, \"proc-macro derives may only be \\\n                                     applied to struct/enum items\");\n                 return Vec::new()\n             }\n@@ -81,7 +81,7 @@ impl MultiItemModifier for ProcMacroDerive {\n         let stream = match res {\n             Ok(stream) => stream,\n             Err(e) => {\n-                let msg = \"proc_macro_derive attribute panicked\";\n+                let msg = \"proc-macro derive panicked\";\n                 let mut err = ecx.struct_span_fatal(span, msg);\n                 if let Some(s) = e.downcast_ref::<String>() {\n                     err.help(&format!(\"message: {}\", s));\n@@ -100,7 +100,7 @@ impl MultiItemModifier for ProcMacroDerive {\n                 Ok(new_items) => new_items,\n                 Err(_) => {\n                     // FIXME: handle this better\n-                    let msg = \"proc_macro_derive produced unparseable tokens\";\n+                    let msg = \"proc-macro derive produced unparseable tokens\";\n                     ecx.struct_span_fatal(span, msg).emit();\n                     panic!(FatalError);\n                 }"}, {"sha": "498f2348b80f109157f55992e684e7e91111b864", "filename": "src/libsyntax_ext/deriving/decodable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs?ref=fbdd0388664127c3dd2c3e6a162b597a87ffa7c9", "patch": "@@ -13,6 +13,7 @@\n use deriving;\n use deriving::generic::*;\n use deriving::generic::ty::*;\n+use deriving::warn_if_deprecated;\n \n use syntax::ast;\n use syntax::ast::{Expr, MetaItem, Mutability};\n@@ -35,7 +36,7 @@ pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n                                  mitem: &MetaItem,\n                                  item: &Annotatable,\n                                  push: &mut FnMut(Annotatable)) {\n-    deriving::warn_if_deprecated(cx, span, \"Decodable\");\n+    warn_if_deprecated(cx, span, \"Decodable\");\n     expand_deriving_decodable_imp(cx, span, mitem, item, push, \"serialize\")\n }\n "}, {"sha": "9d155c22ad031d86f4f3508d4195c5c051b5a5d8", "filename": "src/libsyntax_ext/deriving/encodable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=fbdd0388664127c3dd2c3e6a162b597a87ffa7c9", "patch": "@@ -91,6 +91,7 @@\n use deriving;\n use deriving::generic::*;\n use deriving::generic::ty::*;\n+use deriving::warn_if_deprecated;\n \n use syntax::ast::{Expr, ExprKind, MetaItem, Mutability};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n@@ -112,7 +113,7 @@ pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n                                  mitem: &MetaItem,\n                                  item: &Annotatable,\n                                  push: &mut FnMut(Annotatable)) {\n-    deriving::warn_if_deprecated(cx, span, \"Encodable\");\n+    warn_if_deprecated(cx, span, \"Encodable\");\n     expand_deriving_encodable_imp(cx, span, mitem, item, push, \"serialize\")\n }\n "}, {"sha": "3bceb02f3d6c5af6a2e2cff0a5cb9c452ce275c5", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 238, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=fbdd0388664127c3dd2c3e6a162b597a87ffa7c9", "patch": "@@ -11,12 +11,10 @@\n //! The compiler code necessary to implement the `#[derive]` extensions.\n \n use std::rc::Rc;\n-use syntax::ast::{self, MetaItem};\n-use syntax::attr::HasAttrs;\n+use syntax::ast;\n use syntax::codemap;\n use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxExtension, Resolver};\n use syntax::ext::build::AstBuilder;\n-use syntax::feature_gate;\n use syntax::ptr::P;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n@@ -90,241 +88,6 @@ fn allow_unstable(cx: &mut ExtCtxt, span: Span, attr_name: &str) -> Span {\n     }\n }\n \n-pub fn expand_derive(cx: &mut ExtCtxt,\n-                     span: Span,\n-                     mitem: &MetaItem,\n-                     annotatable: Annotatable)\n-                     -> Vec<Annotatable> {\n-    debug!(\"expand_derive: span = {:?}\", span);\n-    debug!(\"expand_derive: mitem = {:?}\", mitem);\n-    debug!(\"expand_derive: annotatable input  = {:?}\", annotatable);\n-    let mut item = match annotatable {\n-        Annotatable::Item(item) => item,\n-        other => {\n-            cx.span_err(span, \"`derive` can only be applied to items\");\n-            return vec![other]\n-        }\n-    };\n-\n-    let derive = Symbol::intern(\"derive\");\n-    let mut derive_attrs = Vec::new();\n-    item = item.map_attrs(|attrs| {\n-        let partition = attrs.into_iter().partition(|attr| attr.name() == derive);\n-        derive_attrs = partition.0;\n-        partition.1\n-    });\n-\n-    // Expand `#[derive]`s after other attribute macro invocations.\n-    if cx.resolver.find_attr_invoc(&mut item.attrs.clone()).is_some() {\n-        return vec![Annotatable::Item(item.map_attrs(|mut attrs| {\n-            attrs.push(cx.attribute(span, mitem.clone()));\n-            attrs.extend(derive_attrs);\n-            attrs\n-        }))];\n-    }\n-\n-    let get_traits = |mitem: &MetaItem, cx: &ExtCtxt| {\n-        if mitem.value_str().is_some() {\n-            cx.span_err(mitem.span, \"unexpected value in `derive`\");\n-        }\n-\n-        let traits = mitem.meta_item_list().unwrap_or(&[]).to_owned();\n-        if traits.is_empty() {\n-            cx.span_warn(mitem.span, \"empty trait list in `derive`\");\n-        }\n-        traits\n-    };\n-\n-    let mut traits = get_traits(mitem, cx);\n-    for derive_attr in derive_attrs {\n-        traits.extend(get_traits(&derive_attr.value, cx));\n-    }\n-\n-    // First, weed out malformed #[derive]\n-    traits.retain(|titem| {\n-        if titem.word().is_none() {\n-            cx.span_err(titem.span, \"malformed `derive` entry\");\n-            false\n-        } else {\n-            true\n-        }\n-    });\n-\n-    // Next, check for old-style #[derive(Foo)]\n-    //\n-    // These all get expanded to `#[derive_Foo]` and will get expanded first. If\n-    // we actually add any attributes here then we return to get those expanded\n-    // and then eventually we'll come back to finish off the other derive modes.\n-    let mut new_attributes = Vec::new();\n-    traits.retain(|titem| {\n-        let tword = titem.word().unwrap();\n-        let tname = tword.name();\n-\n-        if is_builtin_trait(tname) || {\n-            let derive_mode = ast::Path::from_ident(titem.span, ast::Ident::with_empty_ctxt(tname));\n-            cx.resolver.resolve_macro(cx.current_expansion.mark, &derive_mode, false).map(|ext| {\n-                if let SyntaxExtension::ProcMacroDerive(_) = *ext { true } else { false }\n-            }).unwrap_or(false)\n-        } {\n-            return true;\n-        }\n-\n-        if !cx.ecfg.enable_custom_derive() {\n-            feature_gate::emit_feature_err(&cx.parse_sess,\n-                                           \"custom_derive\",\n-                                           titem.span,\n-                                           feature_gate::GateIssue::Language,\n-                                           feature_gate::EXPLAIN_CUSTOM_DERIVE);\n-        } else {\n-            let name = Symbol::intern(&format!(\"derive_{}\", tname));\n-            if !cx.resolver.is_whitelisted_legacy_custom_derive(name) {\n-                cx.span_warn(titem.span, feature_gate::EXPLAIN_DEPR_CUSTOM_DERIVE);\n-            }\n-            let mitem = cx.meta_word(titem.span, name);\n-            new_attributes.push(cx.attribute(mitem.span, mitem));\n-        }\n-        false\n-    });\n-    if new_attributes.len() > 0 {\n-        item = item.map(|mut i| {\n-            i.attrs.extend(new_attributes);\n-            if traits.len() > 0 {\n-                let list = cx.meta_list(mitem.span, derive, traits);\n-                i.attrs.push(cx.attribute(mitem.span, list));\n-            }\n-            i\n-        });\n-        return vec![Annotatable::Item(item)]\n-    }\n-\n-    // Now check for macros-1.1 style custom #[derive].\n-    //\n-    // Expand each of them in order given, but *before* we expand any built-in\n-    // derive modes. The logic here is to:\n-    //\n-    // 1. Collect the remaining `#[derive]` annotations into a list. If\n-    //    there are any left, attach a `#[derive]` attribute to the item\n-    //    that we're currently expanding with the remaining derive modes.\n-    // 2. Manufacture a `#[derive(Foo)]` attribute to pass to the expander.\n-    // 3. Expand the current item we're expanding, getting back a list of\n-    //    items that replace it.\n-    // 4. Extend the returned list with the current list of items we've\n-    //    collected so far.\n-    // 5. Return everything!\n-    //\n-    // If custom derive extensions end up threading through the `#[derive]`\n-    // attribute, we'll get called again later on to continue expanding\n-    // those modes.\n-    let macros_11_derive = traits.iter()\n-                                 .cloned()\n-                                 .enumerate()\n-                                 .filter(|&(_, ref name)| !is_builtin_trait(name.name().unwrap()))\n-                                 .next();\n-    if let Some((i, titem)) = macros_11_derive {\n-        let tname = ast::Ident::with_empty_ctxt(titem.name().unwrap());\n-        let path = ast::Path::from_ident(titem.span, tname);\n-        let ext = cx.resolver.resolve_macro(cx.current_expansion.mark, &path, false).unwrap();\n-\n-        traits.remove(i);\n-        if traits.len() > 0 {\n-            item = item.map(|mut i| {\n-                let list = cx.meta_list(mitem.span, derive, traits);\n-                i.attrs.push(cx.attribute(mitem.span, list));\n-                i\n-            });\n-        }\n-        let titem = cx.meta_list_item_word(titem.span, titem.name().unwrap());\n-        let mitem = cx.meta_list(titem.span, derive, vec![titem]);\n-        let item = Annotatable::Item(item);\n-\n-        let span = Span {\n-            expn_id: cx.codemap().record_expansion(codemap::ExpnInfo {\n-                call_site: mitem.span,\n-                callee: codemap::NameAndSpan {\n-                    format: codemap::MacroAttribute(Symbol::intern(&format!(\"derive({})\", tname))),\n-                    span: None,\n-                    allow_internal_unstable: false,\n-                },\n-            }),\n-            ..mitem.span\n-        };\n-\n-        if let SyntaxExtension::ProcMacroDerive(ref ext) = *ext {\n-            return ext.expand(cx, span, &mitem, item);\n-        } else {\n-            unreachable!()\n-        }\n-    }\n-\n-    // Ok, at this point we know that there are no old-style `#[derive_Foo]` nor\n-    // any macros-1.1 style `#[derive(Foo)]`. Expand all built-in traits here.\n-\n-    // RFC #1445. `#[derive(PartialEq, Eq)]` adds a (trusted)\n-    // `#[structural_match]` attribute.\n-    let (partial_eq, eq) = (Symbol::intern(\"PartialEq\"), Symbol::intern(\"Eq\"));\n-    if traits.iter().any(|t| t.name() == Some(partial_eq)) &&\n-       traits.iter().any(|t| t.name() == Some(eq)) {\n-        let structural_match = Symbol::intern(\"structural_match\");\n-        let span = allow_unstable(cx, span, \"derive(PartialEq, Eq)\");\n-        let meta = cx.meta_word(span, structural_match);\n-        item = item.map(|mut i| {\n-            i.attrs.push(cx.attribute(span, meta));\n-            i\n-        });\n-    }\n-\n-    // RFC #1521. `Clone` can assume that `Copy` types' clone implementation is\n-    // the same as the copy implementation.\n-    //\n-    // Add a marker attribute here picked up during #[derive(Clone)]\n-    let (copy, clone) = (Symbol::intern(\"Copy\"), Symbol::intern(\"Clone\"));\n-    if traits.iter().any(|t| t.name() == Some(clone)) &&\n-       traits.iter().any(|t| t.name() == Some(copy)) {\n-        let marker = Symbol::intern(\"rustc_copy_clone_marker\");\n-        let span = allow_unstable(cx, span, \"derive(Copy, Clone)\");\n-        let meta = cx.meta_word(span, marker);\n-        item = item.map(|mut i| {\n-            i.attrs.push(cx.attribute(span, meta));\n-            i\n-        });\n-    }\n-\n-    let mut items = Vec::new();\n-    for titem in traits.iter() {\n-        let tname = titem.word().unwrap().name();\n-        let name = Symbol::intern(&format!(\"derive({})\", tname));\n-        let tname_cx = ast::Ident::with_empty_ctxt(titem.name().unwrap());\n-        let mitem = cx.meta_word(titem.span, name);\n-        let path = ast::Path::from_ident(titem.span, tname_cx);\n-        let ext = cx.resolver.resolve_macro(cx.current_expansion.mark, &path, false).unwrap();\n-\n-        let span = Span {\n-            expn_id: cx.codemap().record_expansion(codemap::ExpnInfo {\n-                call_site: titem.span,\n-                callee: codemap::NameAndSpan {\n-                    format: codemap::MacroAttribute(name),\n-                    span: None,\n-                    allow_internal_unstable: true,\n-                },\n-            }),\n-            ..titem.span\n-        };\n-\n-        if let SyntaxExtension::BuiltinDerive(ref func) = *ext {\n-            let my_item = Annotatable::Item(item);\n-            func(cx, span, &mitem, &my_item, &mut |a| {\n-                items.push(a)\n-            });\n-            item = my_item.expect_item();\n-        } else {\n-            unreachable!();\n-        }\n-    }\n-\n-    items.insert(0, Annotatable::Item(item));\n-    return items\n-}\n-\n macro_rules! derive_traits {\n     ($( $name:expr => $func:path, )+) => {\n         pub fn is_builtin_trait(name: ast::Name) -> bool {"}, {"sha": "7533171b08556df082f2fcabfd27dbcb11e3e3d0", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=fbdd0388664127c3dd2c3e6a162b597a87ffa7c9", "patch": "@@ -24,7 +24,6 @@\n #![feature(staged_api)]\n \n extern crate fmt_macros;\n-#[macro_use]\n extern crate log;\n #[macro_use]\n extern crate syntax;\n@@ -51,7 +50,7 @@ pub mod proc_macro_impl;\n \n use std::rc::Rc;\n use syntax::ast;\n-use syntax::ext::base::{MacroExpanderFn, NormalTT, MultiModifier, NamedSyntaxExtension};\n+use syntax::ext::base::{MacroExpanderFn, NormalTT, NamedSyntaxExtension};\n use syntax::symbol::Symbol;\n \n pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver,\n@@ -114,8 +113,6 @@ pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver,\n     register(Symbol::intern(\"format_args\"),\n              NormalTT(Box::new(format::expand_format_args), None, true));\n \n-    register(Symbol::intern(\"derive\"), MultiModifier(Box::new(deriving::expand_derive)));\n-\n     for (name, ext) in user_exts {\n         register(name, ext);\n     }"}, {"sha": "42fad803bfa68ae345d5643ff0ae3b0e99fbdadb", "filename": "src/test/compile-fail-fulldeps/proc-macro/derive-bad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fderive-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fderive-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fderive-bad.rs?ref=fbdd0388664127c3dd2c3e6a162b597a87ffa7c9", "patch": "@@ -16,7 +16,7 @@ extern crate derive_bad;\n #[derive(\n     A\n )]\n-//~^^ ERROR: proc_macro_derive produced unparseable tokens\n+//~^^ ERROR: proc-macro derive produced unparseable tokens\n struct A;\n \n fn main() {}"}, {"sha": "c483c048b418f11f437a37a8f13a03200cd472a6", "filename": "src/test/compile-fail-fulldeps/proc-macro/load-panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fload-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fload-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fload-panic.rs?ref=fbdd0388664127c3dd2c3e6a162b597a87ffa7c9", "patch": "@@ -14,7 +14,7 @@\n extern crate derive_panic;\n \n #[derive(A)]\n-//~^ ERROR: proc_macro_derive attribute panicked\n+//~^ ERROR: proc-macro derive panicked\n //~| HELP: message: nope!\n struct Foo;\n "}, {"sha": "d388ece084417160ce98517533942f71e0387ca5", "filename": "src/test/compile-fail/deriving-meta-unknown-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/src%2Ftest%2Fcompile-fail%2Fderiving-meta-unknown-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/src%2Ftest%2Fcompile-fail%2Fderiving-meta-unknown-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-meta-unknown-trait.rs?ref=fbdd0388664127c3dd2c3e6a162b597a87ffa7c9", "patch": "@@ -11,7 +11,7 @@\n // ignore-tidy-linelength\n \n #[derive(Eqr)]\n-//~^ ERROR `#[derive]` for custom traits is not stable enough for use. It is deprecated and will be removed in v1.15 (see issue #29644)\n+//~^ ERROR cannot find derive macro `Eqr` in this scope\n struct Foo;\n \n pub fn main() {}"}, {"sha": "97a39a46c19a81774f5e06f1b45118b65c7253da", "filename": "src/test/compile-fail/deriving-primitive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/src%2Ftest%2Fcompile-fail%2Fderiving-primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/src%2Ftest%2Fcompile-fail%2Fderiving-primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-primitive.rs?ref=fbdd0388664127c3dd2c3e6a162b597a87ffa7c9", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[derive(FromPrimitive)] //~ERROR `#[derive]` for custom traits is not stable\n+#[derive(FromPrimitive)] //~ERROR cannot find derive macro `FromPrimitive` in this scope\n enum Foo {}\n \n fn main() {}"}, {"sha": "f467ba3b1e19521a8e161573ea538c494ea5e34a", "filename": "src/test/compile-fail/macro-error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/src%2Ftest%2Fcompile-fail%2Fmacro-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/src%2Ftest%2Fcompile-fail%2Fmacro-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-error.rs?ref=fbdd0388664127c3dd2c3e6a162b597a87ffa7c9", "patch": "@@ -16,5 +16,5 @@ fn main() {\n     foo!(0); // Check that we report errors at macro definition, not expansion.\n \n     let _: cfg!(foo) = (); //~ ERROR non-type macro in type position\n-    derive!(); //~ ERROR `derive` can only be used in attributes\n+    derive!(); //~ ERROR macro undefined: 'derive!'\n }"}, {"sha": "3f710af8ac9a883f0c31ac5161e2828b3998771f", "filename": "src/test/compile-fail/macros-nonfatal-errors.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/src%2Ftest%2Fcompile-fail%2Fmacros-nonfatal-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/src%2Ftest%2Fcompile-fail%2Fmacros-nonfatal-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacros-nonfatal-errors.rs?ref=fbdd0388664127c3dd2c3e6a162b597a87ffa7c9", "patch": "@@ -14,9 +14,11 @@\n #![feature(asm)]\n #![feature(trace_macros, concat_idents)]\n \n-#[derive(Default, //~ ERROR\n-           Zero)] //~ ERROR\n-enum CantDeriveThose {}\n+#[derive(Zero)] //~ ERROR\n+struct CantDeriveThis;\n+\n+#[derive(Default)] //~ ERROR\n+enum OrDeriveThis {}\n \n fn main() {\n     doesnt_exist!(); //~ ERROR"}, {"sha": "9a5e2de14e3b0788754bee7982778fea7adb0253", "filename": "src/test/ui/custom-derive/issue-36935.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/src%2Ftest%2Fui%2Fcustom-derive%2Fissue-36935.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fbdd0388664127c3dd2c3e6a162b597a87ffa7c9/src%2Ftest%2Fui%2Fcustom-derive%2Fissue-36935.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcustom-derive%2Fissue-36935.stderr?ref=fbdd0388664127c3dd2c3e6a162b597a87ffa7c9", "patch": "@@ -1,4 +1,4 @@\n-error: proc_macro_derive attribute panicked\n+error: proc-macro derive panicked\n   --> $DIR/issue-36935.rs:17:15\n    |\n 17 | #[derive(Foo, Bar)]"}]}