{"sha": "d3d31105e99f5265880d0f010436ed5c6baab034", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzZDMxMTA1ZTk5ZjUyNjU4ODBkMGYwMTA0MzZlZDVjNmJhYWIwMzQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-06T10:45:27Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-06T10:54:44Z"}, "message": "clarify partially initialized Mutex issues", "tree": {"sha": "02ea7c780c9e844e81763cecc19b9c9ec8604391", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02ea7c780c9e844e81763cecc19b9c9ec8604391"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3d31105e99f5265880d0f010436ed5c6baab034", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3d31105e99f5265880d0f010436ed5c6baab034", "html_url": "https://github.com/rust-lang/rust/commit/d3d31105e99f5265880d0f010436ed5c6baab034", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3d31105e99f5265880d0f010436ed5c6baab034/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c98d2e63f732682b057c8c453b08f9e12b262e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c98d2e63f732682b057c8c453b08f9e12b262e6", "html_url": "https://github.com/rust-lang/rust/commit/7c98d2e63f732682b057c8c453b08f9e12b262e6"}], "stats": {"total": 35, "additions": 33, "deletions": 2}, "files": [{"sha": "09b2ddcbcac664f19911e0345cc173d79e341a52", "filename": "src/libstd/io/lazy.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d3d31105e99f5265880d0f010436ed5c6baab034/src%2Flibstd%2Fio%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3d31105e99f5265880d0f010436ed5c6baab034/src%2Flibstd%2Fio%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Flazy.rs?ref=d3d31105e99f5265880d0f010436ed5c6baab034", "patch": "@@ -27,6 +27,9 @@ unsafe impl<T> Sync for Lazy<T> {}\n \n impl<T: Send + Sync + 'static> Lazy<T> {\n     pub const fn new(init: fn() -> Arc<T>) -> Lazy<T> {\n+        // `lock` is never initialized fully, so this mutex is reentrant!\n+        // Do not use it in a way that might be reentrant, that could lead to\n+        // aliasing `&mut`.\n         Lazy {\n             lock: Mutex::new(),\n             ptr: Cell::new(ptr::null_mut()),\n@@ -48,6 +51,7 @@ impl<T: Send + Sync + 'static> Lazy<T> {\n         }\n     }\n \n+    // Must only be called with `lock` held\n     unsafe fn init(&'static self) -> Arc<T> {\n         // If we successfully register an at exit handler, then we cache the\n         // `Arc` allocation in our own internal box (it will get deallocated by\n@@ -60,6 +64,9 @@ impl<T: Send + Sync + 'static> Lazy<T> {\n             };\n             drop(Box::from_raw(ptr))\n         });\n+        // This could reentrantly call `init` again, which is a problem\n+        // because our `lock` allows reentrancy!\n+        // FIXME: Add argument why this is okay.\n         let ret = (self.init)();\n         if registered.is_ok() {\n             self.ptr.set(Box::into_raw(Box::new(ret.clone())));"}, {"sha": "c91bd5b22afcb2c11b95294bcf230a7a5e4a5e92", "filename": "src/libstd/sys/unix/args.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d3d31105e99f5265880d0f010436ed5c6baab034/src%2Flibstd%2Fsys%2Funix%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3d31105e99f5265880d0f010436ed5c6baab034/src%2Flibstd%2Fsys%2Funix%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fargs.rs?ref=d3d31105e99f5265880d0f010436ed5c6baab034", "patch": "@@ -80,6 +80,9 @@ mod imp {\n \n     static mut ARGC: isize = 0;\n     static mut ARGV: *const *const u8 = ptr::null();\n+    // `ENV_LOCK` is never initialized fully, so this mutex is reentrant!\n+    // Do not use it in a way that might be reentrant, that could lead to\n+    // aliasing `&mut`.\n     static LOCK: Mutex = Mutex::new();\n \n     pub unsafe fn init(argc: isize, argv: *const *const u8) {"}, {"sha": "f0711b603204ee906d4afaa45d05dcb75bafa638", "filename": "src/libstd/sys/unix/mutex.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3d31105e99f5265880d0f010436ed5c6baab034/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3d31105e99f5265880d0f010436ed5c6baab034/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs?ref=d3d31105e99f5265880d0f010436ed5c6baab034", "patch": "@@ -25,8 +25,10 @@ unsafe impl Sync for Mutex {}\n #[allow(dead_code)] // sys isn't exported yet\n impl Mutex {\n     pub const fn new() -> Mutex {\n-        // Might be moved and address is changing it is better to avoid\n-        // initialization of potentially opaque OS data before it landed\n+        // Might be moved to a different address, so it is better to avoid\n+        // initialization of potentially opaque OS data before it landed.\n+        // Be very careful using this newly constructed `Mutex`, it should\n+        // be initialized by calling `init()` first!\n         Mutex { inner: UnsafeCell::new(libc::PTHREAD_MUTEX_INITIALIZER) }\n     }\n     #[inline]"}, {"sha": "6ef9502ba624e6f68a8c07c03d536201d44e1c49", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d3d31105e99f5265880d0f010436ed5c6baab034/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3d31105e99f5265880d0f010436ed5c6baab034/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=d3d31105e99f5265880d0f010436ed5c6baab034", "patch": "@@ -33,6 +33,9 @@ use sys::fd;\n use vec;\n \n const TMPBUF_SZ: usize = 128;\n+// `ENV_LOCK` is never initialized fully, so this mutex is reentrant!\n+// Do not use it in a way that might be reentrant, that could lead to\n+// aliasing `&mut`.\n static ENV_LOCK: Mutex = Mutex::new();\n \n "}, {"sha": "633605039afdd9cb0148e07a74a91ece0b2df977", "filename": "src/libstd/sys_common/at_exit_imp.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3d31105e99f5265880d0f010436ed5c6baab034/src%2Flibstd%2Fsys_common%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3d31105e99f5265880d0f010436ed5c6baab034/src%2Flibstd%2Fsys_common%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fat_exit_imp.rs?ref=d3d31105e99f5265880d0f010436ed5c6baab034", "patch": "@@ -23,6 +23,9 @@ type Queue = Vec<Box<dyn FnBox()>>;\n // on poisoning and this module needs to operate at a lower level than requiring\n // the thread infrastructure to be in place (useful on the borders of\n // initialization/destruction).\n+// `LOCK` is never initialized fully, so this mutex is reentrant!\n+// Do not use it in a way that might be reentrant, that could lead to\n+// aliasing `&mut`.\n static LOCK: Mutex = Mutex::new();\n static mut QUEUE: *mut Queue = ptr::null_mut();\n \n@@ -72,6 +75,9 @@ pub fn push(f: Box<dyn FnBox()>) -> bool {\n     unsafe {\n         let _guard = LOCK.lock();\n         if init() {\n+            // This could reentrantly call `push` again, which is a problem because\n+            // `LOCK` allows reentrancy!\n+            // FIXME: Add argument why this is okay.\n             (*QUEUE).push(f);\n             true\n         } else {"}, {"sha": "77a33e4c6be86ef551e9075a7978a6c75424bd47", "filename": "src/libstd/sys_common/mutex.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3d31105e99f5265880d0f010436ed5c6baab034/src%2Flibstd%2Fsys_common%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3d31105e99f5265880d0f010436ed5c6baab034/src%2Flibstd%2Fsys_common%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmutex.rs?ref=d3d31105e99f5265880d0f010436ed5c6baab034", "patch": "@@ -24,11 +24,15 @@ impl Mutex {\n     ///\n     /// Behavior is undefined if the mutex is moved after it is\n     /// first used with any of the functions below.\n+    /// Also, the mutex might not be fully functional without calling\n+    /// `init`!  For example, on unix, the mutex is reentrant\n+    /// until `init` reconfigures it appropriately.\n     pub const fn new() -> Mutex { Mutex(imp::Mutex::new()) }\n \n     /// Prepare the mutex for use.\n     ///\n     /// This should be called once the mutex is at a stable memory address.\n+    /// It must not be called concurrently with any other operation.\n     #[inline]\n     pub unsafe fn init(&mut self) { self.0.init() }\n "}, {"sha": "2cc5372e26818ada5025eadc84177a33d0345d45", "filename": "src/libstd/sys_common/thread_local.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d3d31105e99f5265880d0f010436ed5c6baab034/src%2Flibstd%2Fsys_common%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3d31105e99f5265880d0f010436ed5c6baab034/src%2Flibstd%2Fsys_common%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fthread_local.rs?ref=d3d31105e99f5265880d0f010436ed5c6baab034", "patch": "@@ -161,6 +161,9 @@ impl StaticKey {\n         // Additionally a 0-index of a tls key hasn't been seen on windows, so\n         // we just simplify the whole branch.\n         if imp::requires_synchronized_create() {\n+            // `INIT_LOCK` is never initialized fully, so this mutex is reentrant!\n+            // Do not use it in a way that might be reentrant, that could lead to\n+            // aliasing `&mut`.\n             static INIT_LOCK: Mutex = Mutex::new();\n             let _guard = INIT_LOCK.lock();\n             let mut key = self.key.load(Ordering::SeqCst);"}, {"sha": "98b4ca36c26335fda26f7257bee0017957a1a47c", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d3d31105e99f5265880d0f010436ed5c6baab034/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3d31105e99f5265880d0f010436ed5c6baab034/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=d3d31105e99f5265880d0f010436ed5c6baab034", "patch": "@@ -940,6 +940,9 @@ pub struct ThreadId(u64);\n impl ThreadId {\n     // Generate a new unique thread ID.\n     fn new() -> ThreadId {\n+        // `GUARD` is never initialized fully, so this mutex is reentrant!\n+        // Do not use it in a way that might be reentrant, that could lead to\n+        // aliasing `&mut`.\n         static GUARD: mutex::Mutex = mutex::Mutex::new();\n         static mut COUNTER: u64 = 0;\n "}]}