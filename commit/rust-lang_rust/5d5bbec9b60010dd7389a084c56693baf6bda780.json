{"sha": "5d5bbec9b60010dd7389a084c56693baf6bda780", "node_id": "C_kwDOAAsO6NoAKDVkNWJiZWM5YjYwMDEwZGQ3Mzg5YTA4NGM1NjY5M2JhZjZiZGE3ODA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-07T14:25:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-07T14:25:12Z"}, "message": "Auto merge of #12187 - Veykril:completion-rev, r=Veykril\n\ninternal: More completion context refactoring", "tree": {"sha": "7c21f57af48d6d66fba33c4001a69feda3561522", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c21f57af48d6d66fba33c4001a69feda3561522"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d5bbec9b60010dd7389a084c56693baf6bda780", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d5bbec9b60010dd7389a084c56693baf6bda780", "html_url": "https://github.com/rust-lang/rust/commit/5d5bbec9b60010dd7389a084c56693baf6bda780", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d5bbec9b60010dd7389a084c56693baf6bda780/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bfb241afa3bd83b482aaddacd5d5cd2583603976", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfb241afa3bd83b482aaddacd5d5cd2583603976", "html_url": "https://github.com/rust-lang/rust/commit/bfb241afa3bd83b482aaddacd5d5cd2583603976"}, {"sha": "a0fc649269bda6c01f1b22d233ebb49cb34925a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0fc649269bda6c01f1b22d233ebb49cb34925a3", "html_url": "https://github.com/rust-lang/rust/commit/a0fc649269bda6c01f1b22d233ebb49cb34925a3"}], "stats": {"total": 597, "additions": 350, "deletions": 247}, "files": [{"sha": "0b7479fd0e84f748724ad247a4325f4bd559803f", "filename": "crates/ide-completion/src/completions/attribute.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs?ref=5d5bbec9b60010dd7389a084c56693baf6bda780", "patch": "@@ -18,7 +18,7 @@ use syntax::{\n \n use crate::{\n     completions::module_or_attr,\n-    context::{CompletionContext, PathCompletionCtx, PathKind, PathQualifierCtx},\n+    context::{CompletionContext, IdentContext, PathCompletionCtx, PathKind, PathQualifierCtx},\n     item::CompletionItem,\n     Completions,\n };\n@@ -35,7 +35,10 @@ pub(crate) fn complete_known_attribute_input(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n ) -> Option<()> {\n-    let attribute = ctx.fake_attribute_under_caret.as_ref()?;\n+    let attribute = match &ctx.ident_ctx {\n+        IdentContext::UnexpandedAttrTT { fake_attribute_under_caret: Some(it) } => it,\n+        _ => return None,\n+    };\n     let name_ref = match attribute.path() {\n         Some(p) => Some(p.as_single_name_ref()?),\n         None => None,\n@@ -69,8 +72,8 @@ pub(crate) fn complete_known_attribute_input(\n }\n \n pub(crate) fn complete_attribute(acc: &mut Completions, ctx: &CompletionContext) {\n-    let (is_absolute_path, qualifier, is_inner, annotated_item_kind) = match ctx.path_context {\n-        Some(PathCompletionCtx {\n+    let (is_absolute_path, qualifier, is_inner, annotated_item_kind) = match ctx.path_context() {\n+        Some(&PathCompletionCtx {\n             kind: PathKind::Attr { kind, annotated_item_kind },\n             is_absolute_path,\n             ref qualifier,"}, {"sha": "19414e4b31568ff117e5ba9a1f445edd9734cf8c", "filename": "crates/ide-completion/src/completions/attribute/derive.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs?ref=5d5bbec9b60010dd7389a084c56693baf6bda780", "patch": "@@ -11,9 +11,12 @@ use crate::{\n };\n \n pub(crate) fn complete_derive(acc: &mut Completions, ctx: &CompletionContext) {\n-    let (qualifier, is_absolute_path) = match ctx.path_context {\n-        Some(PathCompletionCtx {\n-            kind: PathKind::Derive, ref qualifier, is_absolute_path, ..\n+    let (qualifier, is_absolute_path) = match ctx.path_context() {\n+        Some(&PathCompletionCtx {\n+            kind: PathKind::Derive,\n+            ref qualifier,\n+            is_absolute_path,\n+            ..\n         }) => (qualifier, is_absolute_path),\n         _ => return,\n     };"}, {"sha": "6a553eadc1949257cb6c13fa2d8a85e6d1f48adc", "filename": "crates/ide-completion/src/completions/dot.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=5d5bbec9b60010dd7389a084c56693baf6bda780", "patch": "@@ -3,15 +3,21 @@\n use ide_db::FxHashSet;\n \n use crate::{\n-    context::{CompletionContext, PathCompletionCtx, PathKind},\n-    patterns::ImmediateLocation,\n+    context::{CompletionContext, DotAccess, NameRefContext, PathCompletionCtx, PathKind},\n     Completions,\n };\n \n /// Complete dot accesses, i.e. fields or methods.\n pub(crate) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n-    let dot_receiver = match ctx.dot_receiver() {\n-        Some(expr) => expr,\n+    let (dot_access, dot_receiver) = match ctx.nameref_ctx() {\n+        Some(NameRefContext {\n+            dot_access:\n+                Some(\n+                    access @ (DotAccess::Method { receiver: Some(receiver), .. }\n+                    | DotAccess::Field { receiver: Some(receiver), .. }),\n+                ),\n+            ..\n+        }) => (access, receiver),\n         _ => return complete_undotted_self(acc, ctx),\n     };\n \n@@ -20,7 +26,7 @@ pub(crate) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n         _ => return,\n     };\n \n-    if matches!(ctx.completion_location, Some(ImmediateLocation::MethodCall { .. })) {\n+    if let DotAccess::Method { .. } = dot_access {\n         cov_mark::hit!(test_no_struct_field_completion_for_method_call);\n     } else {\n         complete_fields(\n@@ -38,7 +44,7 @@ fn complete_undotted_self(acc: &mut Completions, ctx: &CompletionContext) {\n     if !ctx.config.enable_self_on_the_fly {\n         return;\n     }\n-    match ctx.path_context {\n+    match ctx.path_context() {\n         Some(PathCompletionCtx {\n             is_absolute_path: false,\n             qualifier: None,"}, {"sha": "a2a17d92185c428d623385fe98fae4b0728ee48c", "filename": "crates/ide-completion/src/completions/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs?ref=5d5bbec9b60010dd7389a084c56693baf6bda780", "patch": "@@ -14,7 +14,7 @@ pub(crate) fn complete_expr_path(acc: &mut Completions, ctx: &CompletionContext)\n         return;\n     }\n \n-    let (&is_absolute_path, qualifier) = match &ctx.path_context {\n+    let (&is_absolute_path, qualifier) = match ctx.path_context() {\n         Some(PathCompletionCtx {\n             kind: PathKind::Expr { .. },\n             is_absolute_path,"}, {"sha": "ae8c199f0c4699474aeacb39e6e0d27823a6f9ac", "filename": "crates/ide-completion/src/completions/extern_abi.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fextern_abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fextern_abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fextern_abi.rs?ref=5d5bbec9b60010dd7389a084c56693baf6bda780", "patch": "@@ -5,7 +5,9 @@ use syntax::{\n };\n \n use crate::{\n-    completions::Completions, context::CompletionContext, CompletionItem, CompletionItemKind,\n+    completions::Completions,\n+    context::{CompletionContext, IdentContext},\n+    CompletionItem, CompletionItemKind,\n };\n \n // Most of these are feature gated, we should filter/add feature gate completions once we have them.\n@@ -41,10 +43,14 @@ const SUPPORTED_CALLING_CONVENTIONS: &[&str] = &[\n ];\n \n pub(crate) fn complete_extern_abi(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n-    if ctx.token.parent().and_then(ast::Abi::cast).is_none() {\n-        return None;\n-    }\n-    let abi_str = ast::String::cast(ctx.token.clone())?;\n+    let abi_str = match &ctx.ident_ctx {\n+        IdentContext::String { expanded: Some(expanded), .. }\n+            if expanded.syntax().parent().map_or(false, |it| ast::Abi::can_cast(it.kind())) =>\n+        {\n+            expanded\n+        }\n+        _ => return None,\n+    };\n     let source_range = abi_str.text_range_between_quotes()?;\n     for &abi in SUPPORTED_CALLING_CONVENTIONS {\n         CompletionItem::new(CompletionItemKind::Keyword, source_range, abi).add_to(acc);"}, {"sha": "bbb50cb2657f4ed09180360faa10c6ddc98594d5", "filename": "crates/ide-completion/src/completions/flyimport.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=5d5bbec9b60010dd7389a084c56693baf6bda780", "patch": "@@ -119,7 +119,7 @@ pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext)\n         return None;\n     }\n     // FIXME: This should be encoded in a different way\n-    if ctx.pattern_ctx.is_none() && ctx.path_context.is_none() && !ctx.has_dot_receiver() {\n+    if ctx.pattern_ctx.is_none() && ctx.path_context().is_none() && !ctx.has_dot_receiver() {\n         // completion inside `ast::Name` of a item declaration\n         return None;\n     }\n@@ -217,10 +217,9 @@ pub(crate) fn position_for_import(\n ) -> Option<SyntaxNode> {\n     Some(\n         match import_candidate {\n-            Some(ImportCandidate::Path(_)) => ctx.name_syntax.as_ref()?.syntax(),\n             Some(ImportCandidate::TraitAssocItem(_)) => ctx.path_qual()?.syntax(),\n             Some(ImportCandidate::TraitMethod(_)) => ctx.dot_receiver()?.syntax(),\n-            None => return ctx.original_token.parent(),\n+            Some(ImportCandidate::Path(_)) | None => return ctx.original_token.parent(),\n         }\n         .clone(),\n     )"}, {"sha": "132599906af26b3ea2905105926daadeb43d8ccd", "filename": "crates/ide-completion/src/completions/format_string.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fformat_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fformat_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fformat_string.rs?ref=5d5bbec9b60010dd7389a084c56693baf6bda780", "patch": "@@ -2,16 +2,21 @@\n \n use ide_db::syntax_helpers::format_string::is_format_string;\n use itertools::Itertools;\n-use syntax::{ast, AstToken, TextRange, TextSize};\n+use syntax::{AstToken, TextRange, TextSize};\n \n-use crate::{context::CompletionContext, CompletionItem, CompletionItemKind, Completions};\n+use crate::{\n+    context::{CompletionContext, IdentContext},\n+    CompletionItem, CompletionItemKind, Completions,\n+};\n \n /// Complete identifiers in format strings.\n pub(crate) fn format_string(acc: &mut Completions, ctx: &CompletionContext) {\n-    let string = match ast::String::cast(ctx.token.clone())\n-        .zip(ast::String::cast(ctx.original_token.clone()))\n-    {\n-        Some((expanded, original)) if is_format_string(&expanded) => original,\n+    let string = match &ctx.ident_ctx {\n+        IdentContext::String { expanded: Some(expanded), original }\n+            if is_format_string(&expanded) =>\n+        {\n+            original\n+        }\n         _ => return,\n     };\n     let cursor = ctx.position.offset;"}, {"sha": "ebbc33c2da0db7d293cd5572239bbc1b03792e69", "filename": "crates/ide-completion/src/completions/item_list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs?ref=5d5bbec9b60010dd7389a084c56693baf6bda780", "patch": "@@ -12,7 +12,7 @@ pub(crate) fn complete_item_list(acc: &mut Completions, ctx: &CompletionContext)\n         return;\n     }\n \n-    let (&is_absolute_path, qualifier) = match &ctx.path_context {\n+    let (&is_absolute_path, qualifier) = match ctx.path_context() {\n         Some(PathCompletionCtx {\n             kind: PathKind::Item { .. },\n             is_absolute_path,"}, {"sha": "b34545414ec216d8ce5ffe0bbfc7ee138bef150a", "filename": "crates/ide-completion/src/completions/keyword.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fkeyword.rs?ref=5d5bbec9b60010dd7389a084c56693baf6bda780", "patch": "@@ -2,7 +2,7 @@\n //! - `self`, `super` and `crate`, as these are considered part of path completions.\n //! - `await`, as this is a postfix completion we handle this in the postfix completions.\n \n-use syntax::{SyntaxKind, T};\n+use syntax::T;\n \n use crate::{\n     context::{PathCompletionCtx, PathKind},\n@@ -11,18 +11,10 @@ use crate::{\n };\n \n pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionContext) {\n-    if ctx.token.kind() == SyntaxKind::COMMENT {\n-        cov_mark::hit!(no_keyword_completion_in_comments);\n-        return;\n-    }\n     if matches!(ctx.completion_location, Some(ImmediateLocation::RecordExpr(_))) {\n         cov_mark::hit!(no_keyword_completion_in_record_lit);\n         return;\n     }\n-    if ctx.fake_attribute_under_caret.is_some() {\n-        cov_mark::hit!(no_keyword_completion_in_attr_of_expr);\n-        return;\n-    }\n     if ctx.is_non_trivial_path() {\n         cov_mark::hit!(no_keyword_completion_in_non_trivial_path);\n         return;\n@@ -124,8 +116,8 @@ pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n         add_keyword(\"mut\", \"mut \");\n     }\n \n-    let (can_be_stmt, in_loop_body) = match ctx.path_context {\n-        Some(PathCompletionCtx {\n+    let (can_be_stmt, in_loop_body) = match ctx.path_context() {\n+        Some(&PathCompletionCtx {\n             is_absolute_path: false,\n             kind: PathKind::Expr { in_block_expr, in_loop_body, .. },\n             .."}, {"sha": "12fcc8920a14034ef3785da44ecf00e51ab6f11e", "filename": "crates/ide-completion/src/completions/lifetime.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcompletions%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcompletions%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Flifetime.rs?ref=5d5bbec9b60010dd7389a084c56693baf6bda780", "patch": "@@ -12,17 +12,20 @@ use syntax::{ast, TokenText};\n \n use crate::{\n     completions::Completions,\n-    context::{CompletionContext, LifetimeContext},\n+    context::{CompletionContext, LifetimeContext, LifetimeKind},\n };\n \n /// Completes lifetimes.\n pub(crate) fn complete_lifetime(acc: &mut Completions, ctx: &CompletionContext) {\n-    let lp = match &ctx.lifetime_ctx {\n-        Some(LifetimeContext::Lifetime) => None,\n-        Some(LifetimeContext::LifetimeParam { is_decl: false, param }) => Some(param),\n+    let (lp, lifetime) = match ctx.lifetime_ctx() {\n+        Some(LifetimeContext { kind: LifetimeKind::Lifetime, lifetime }) => (None, lifetime),\n+        Some(LifetimeContext {\n+            kind: LifetimeKind::LifetimeParam { is_decl: false, param },\n+            lifetime,\n+        }) => (Some(param), lifetime),\n         _ => return,\n     };\n-    let param_lifetime = match (ctx.lifetime(), lp.and_then(|lp| lp.lifetime())) {\n+    let param_lifetime = match (lifetime, lp.and_then(|lp| lp.lifetime())) {\n         (Some(lt), Some(lp)) if lp == lt.clone() => return,\n         (Some(_), Some(lp)) => Some(lp),\n         _ => None,\n@@ -46,7 +49,7 @@ pub(crate) fn complete_lifetime(acc: &mut Completions, ctx: &CompletionContext)\n \n /// Completes labels.\n pub(crate) fn complete_label(acc: &mut Completions, ctx: &CompletionContext) {\n-    if !matches!(ctx.lifetime_ctx, Some(LifetimeContext::LabelRef)) {\n+    if !matches!(ctx.lifetime_ctx(), Some(LifetimeContext { kind: LifetimeKind::LabelRef, .. })) {\n         return;\n     }\n     ctx.process_all_names_raw(&mut |name, res| {"}, {"sha": "827d9f85efbbb8e4c8af6b1cceaaf88d794d156f", "filename": "crates/ide-completion/src/completions/mod_.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fmod_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fmod_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fmod_.rs?ref=5d5bbec9b60010dd7389a084c56693baf6bda780", "patch": "@@ -3,21 +3,23 @@\n use std::iter;\n \n use hir::{Module, ModuleSource};\n-use ide_db::FxHashSet;\n use ide_db::{\n     base_db::{SourceDatabaseExt, VfsPath},\n-    RootDatabase, SymbolKind,\n+    FxHashSet, RootDatabase, SymbolKind,\n };\n use syntax::{ast, AstNode, SyntaxKind};\n \n-use crate::{context::NameContext, CompletionItem};\n-\n-use crate::{context::CompletionContext, Completions};\n+use crate::{\n+    context::{CompletionContext, NameContext, NameKind},\n+    CompletionItem, Completions,\n+};\n \n /// Complete mod declaration, i.e. `mod $0;`\n pub(crate) fn complete_mod(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n-    let mod_under_caret = match &ctx.name_ctx {\n-        Some(NameContext::Module(mod_under_caret)) if mod_under_caret.item_list().is_none() => {\n+    let mod_under_caret = match ctx.name_ctx() {\n+        Some(NameContext { kind: NameKind::Module(mod_under_caret), .. })\n+            if mod_under_caret.item_list().is_none() =>\n+        {\n             mod_under_caret\n         }\n         _ => return None,"}, {"sha": "211ca4e531b65fccfceb67e642ad7ac01cbeda62", "filename": "crates/ide-completion/src/completions/pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=5d5bbec9b60010dd7389a084c56693baf6bda780", "patch": "@@ -17,7 +17,7 @@ pub(crate) fn complete_pattern(acc: &mut Completions, ctx: &CompletionContext) {\n     };\n     let refutable = patctx.refutability == PatternRefutability::Refutable;\n \n-    if let Some(path_ctx) = &ctx.path_context {\n+    if let Some(path_ctx) = ctx.path_context() {\n         pattern_path_completion(acc, ctx, path_ctx);\n         return;\n     }"}, {"sha": "be0f6748891105b56379efae4f271f309f84273c", "filename": "crates/ide-completion/src/completions/postfix.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs?ref=5d5bbec9b60010dd7389a084c56693baf6bda780", "patch": "@@ -13,9 +13,8 @@ use text_edit::TextEdit;\n \n use crate::{\n     completions::postfix::format_like::add_format_like_completions,\n-    context::CompletionContext,\n+    context::{CompletionContext, DotAccess, NameRefContext},\n     item::{Builder, CompletionRelevancePostfixMatch},\n-    patterns::ImmediateLocation,\n     CompletionItem, CompletionItemKind, CompletionRelevance, Completions, SnippetScope,\n };\n \n@@ -24,11 +23,15 @@ pub(crate) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n         return;\n     }\n \n-    let (dot_receiver, receiver_is_ambiguous_float_literal) = match &ctx.completion_location {\n-        Some(ImmediateLocation::MethodCall { receiver: Some(it), .. }) => (it, false),\n-        Some(ImmediateLocation::FieldAccess {\n-            receiver: Some(it),\n-            receiver_is_ambiguous_float_literal,\n+    let (dot_receiver, receiver_is_ambiguous_float_literal) = match ctx.nameref_ctx() {\n+        Some(NameRefContext {\n+            dot_access: Some(DotAccess::Method { receiver: Some(it), .. }),\n+            ..\n+        }) => (it, false),\n+        Some(NameRefContext {\n+            dot_access:\n+                Some(DotAccess::Field { receiver: Some(it), receiver_is_ambiguous_float_literal }),\n+            ..\n         }) => (it, *receiver_is_ambiguous_float_literal),\n         _ => return,\n     };"}, {"sha": "2bae19c84fd7f62588711e4aabcf8ba20633a00f", "filename": "crates/ide-completion/src/completions/snippet.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fsnippet.rs?ref=5d5bbec9b60010dd7389a084c56693baf6bda780", "patch": "@@ -17,7 +17,7 @@ fn snippet(ctx: &CompletionContext, cap: SnippetCap, label: &str, snippet: &str)\n }\n \n pub(crate) fn complete_expr_snippet(acc: &mut Completions, ctx: &CompletionContext) {\n-    let can_be_stmt = match ctx.path_context {\n+    let &can_be_stmt = match ctx.path_context() {\n         Some(PathCompletionCtx {\n             is_absolute_path: false,\n             qualifier: None,\n@@ -43,7 +43,7 @@ pub(crate) fn complete_expr_snippet(acc: &mut Completions, ctx: &CompletionConte\n }\n \n pub(crate) fn complete_item_snippet(acc: &mut Completions, ctx: &CompletionContext) {\n-    let path_kind = match ctx.path_context {\n+    let path_kind = match ctx.path_context() {\n         Some(PathCompletionCtx {\n             is_absolute_path: false,\n             qualifier: None,"}, {"sha": "9381548e5ed9549c371aaac1e86551ed89048abd", "filename": "crates/ide-completion/src/completions/type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs?ref=5d5bbec9b60010dd7389a084c56693baf6bda780", "patch": "@@ -17,7 +17,7 @@ pub(crate) fn complete_type_path(acc: &mut Completions, ctx: &CompletionContext)\n         return;\n     }\n \n-    let (&is_absolute_path, qualifier) = match &ctx.path_context {\n+    let (&is_absolute_path, qualifier) = match ctx.path_context() {\n         Some(PathCompletionCtx { kind: PathKind::Type, is_absolute_path, qualifier, .. }) => {\n             (is_absolute_path, qualifier)\n         }"}, {"sha": "f1beeb454c893a09ea20d1aaad1f510e536c063e", "filename": "crates/ide-completion/src/completions/use_.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs?ref=5d5bbec9b60010dd7389a084c56693baf6bda780", "patch": "@@ -5,16 +5,19 @@ use ide_db::FxHashSet;\n use syntax::{ast, AstNode};\n \n use crate::{\n-    context::{CompletionContext, PathCompletionCtx, PathKind, PathQualifierCtx},\n+    context::{CompletionContext, NameRefContext, PathCompletionCtx, PathKind, PathQualifierCtx},\n     item::Builder,\n     CompletionRelevance, Completions,\n };\n \n pub(crate) fn complete_use_tree(acc: &mut Completions, ctx: &CompletionContext) {\n-    let (&is_absolute_path, qualifier) = match &ctx.path_context {\n-        Some(PathCompletionCtx { kind: PathKind::Use, is_absolute_path, qualifier, .. }) => {\n-            (is_absolute_path, qualifier)\n-        }\n+    let (&is_absolute_path, qualifier, name_ref) = match ctx.nameref_ctx() {\n+        Some(NameRefContext {\n+            path_ctx:\n+                Some(PathCompletionCtx { kind: PathKind::Use, is_absolute_path, qualifier, .. }),\n+            nameref,\n+            ..\n+        }) => (is_absolute_path, qualifier, nameref),\n         _ => return,\n     };\n \n@@ -55,7 +58,7 @@ pub(crate) fn complete_use_tree(acc: &mut Completions, ctx: &CompletionContext)\n                     let module_scope = module.scope(ctx.db, Some(ctx.module));\n                     let unknown_is_current = |name: &hir::Name| {\n                         matches!(\n-                            ctx.name_ref(),\n+                            name_ref,\n                             Some(name_ref) if name_ref.syntax().text() == name.to_smol_str().as_str()\n                         )\n                     };"}, {"sha": "b5e86b62d1a55b845c1c11894631192e31ab2ddf", "filename": "crates/ide-completion/src/completions/vis.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fvis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fvis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fvis.rs?ref=5d5bbec9b60010dd7389a084c56693baf6bda780", "patch": "@@ -8,7 +8,7 @@ use crate::{\n };\n \n pub(crate) fn complete_vis(acc: &mut Completions, ctx: &CompletionContext) {\n-    let (&is_absolute_path, qualifier, &has_in_token) = match &ctx.path_context {\n+    let (&is_absolute_path, qualifier, &has_in_token) = match ctx.path_context() {\n         Some(PathCompletionCtx {\n             kind: PathKind::Vis { has_in_token },\n             is_absolute_path,"}, {"sha": "5342c481e3651a0c26ef02e8aa6ee97eacdf5142", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 244, "deletions": 116, "changes": 360, "blob_url": "https://github.com/rust-lang/rust/blob/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=5d5bbec9b60010dd7389a084c56693baf6bda780", "patch": "@@ -14,8 +14,8 @@ use ide_db::{\n };\n use syntax::{\n     algo::{find_node_at_offset, non_trivia_sibling},\n-    ast::{self, AttrKind, HasName, NameOrNameRef},\n-    match_ast, AstNode, NodeOrToken,\n+    ast::{self, AttrKind, HasArgList, HasName, NameOrNameRef},\n+    match_ast, AstNode, AstToken, NodeOrToken,\n     SyntaxKind::{self, *},\n     SyntaxNode, SyntaxToken, TextRange, TextSize, T,\n };\n@@ -117,16 +117,29 @@ pub(super) struct PatternContext {\n }\n \n #[derive(Debug)]\n-pub(super) enum LifetimeContext {\n+pub(super) struct LifetimeContext {\n+    pub(super) lifetime: Option<ast::Lifetime>,\n+    pub(super) kind: LifetimeKind,\n+}\n+\n+#[derive(Debug)]\n+pub(super) enum LifetimeKind {\n     LifetimeParam { is_decl: bool, param: ast::LifetimeParam },\n     Lifetime,\n     LabelRef,\n     LabelDef,\n }\n \n+#[derive(Debug)]\n+pub(super) struct NameContext {\n+    #[allow(dead_code)]\n+    pub(super) name: Option<ast::Name>,\n+    pub(super) kind: NameKind,\n+}\n+\n #[derive(Debug)]\n #[allow(dead_code)]\n-pub(super) enum NameContext {\n+pub(super) enum NameKind {\n     Const,\n     ConstParam,\n     Enum,\n@@ -148,6 +161,43 @@ pub(super) enum NameContext {\n     Variant,\n }\n \n+#[derive(Debug)]\n+pub(super) struct NameRefContext {\n+    /// NameRef syntax in the original file\n+    pub(super) nameref: Option<ast::NameRef>,\n+    pub(super) dot_access: Option<DotAccess>,\n+    pub(super) path_ctx: Option<PathCompletionCtx>,\n+}\n+\n+#[derive(Debug)]\n+pub(super) enum IdentContext {\n+    Name(NameContext),\n+    NameRef(NameRefContext),\n+    Lifetime(LifetimeContext),\n+    /// Original token, fake token\n+    String {\n+        original: ast::String,\n+        expanded: Option<ast::String>,\n+    },\n+    UnexpandedAttrTT {\n+        fake_attribute_under_caret: Option<ast::Attr>,\n+    },\n+}\n+\n+#[derive(Debug)]\n+pub(super) enum DotAccess {\n+    Field {\n+        receiver: Option<ast::Expr>,\n+        /// True if the receiver is an integer and there is no ident in the original file after it yet\n+        /// like `0.$0`\n+        receiver_is_ambiguous_float_literal: bool,\n+    },\n+    Method {\n+        receiver: Option<ast::Expr>,\n+        has_parens: bool,\n+    },\n+}\n+\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) enum ParamKind {\n     Function(ast::Fn),\n@@ -183,20 +233,16 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) function_def: Option<ast::Fn>,\n     /// The parent impl of the cursor position if it exists.\n     pub(super) impl_def: Option<ast::Impl>,\n-    /// The NameLike under the cursor in the original file if it exists.\n-    pub(super) name_syntax: Option<ast::NameLike>,\n     /// Are we completing inside a let statement with a missing semicolon?\n     pub(super) incomplete_let: bool,\n \n     pub(super) completion_location: Option<ImmediateLocation>,\n     pub(super) prev_sibling: Option<ImmediatePrevSibling>,\n-    pub(super) fake_attribute_under_caret: Option<ast::Attr>,\n     pub(super) previous_token: Option<SyntaxToken>,\n \n-    pub(super) name_ctx: Option<NameContext>,\n-    pub(super) lifetime_ctx: Option<LifetimeContext>,\n+    pub(super) ident_ctx: IdentContext,\n+\n     pub(super) pattern_ctx: Option<PatternContext>,\n-    pub(super) path_context: Option<PathCompletionCtx>,\n \n     pub(super) existing_derives: FxHashSet<hir::Macro>,\n \n@@ -220,14 +266,6 @@ impl<'a> CompletionContext<'a> {\n         }\n     }\n \n-    pub(crate) fn name_ref(&self) -> Option<&ast::NameRef> {\n-        self.name_syntax.as_ref().and_then(ast::NameLike::as_name_ref)\n-    }\n-\n-    pub(crate) fn lifetime(&self) -> Option<&ast::Lifetime> {\n-        self.name_syntax.as_ref().and_then(ast::NameLike::as_lifetime)\n-    }\n-\n     pub(crate) fn previous_token_is(&self, kind: SyntaxKind) -> bool {\n         self.previous_token.as_ref().map_or(false, |tok| tok.kind() == kind)\n     }\n@@ -236,30 +274,48 @@ impl<'a> CompletionContext<'a> {\n         FamousDefs(&self.sema, self.krate)\n     }\n \n+    pub(super) fn nameref_ctx(&self) -> Option<&NameRefContext> {\n+        match &self.ident_ctx {\n+            IdentContext::NameRef(it) => Some(it),\n+            _ => None,\n+        }\n+    }\n+\n+    pub(super) fn name_ctx(&self) -> Option<&NameContext> {\n+        match &self.ident_ctx {\n+            IdentContext::Name(it) => Some(it),\n+            _ => None,\n+        }\n+    }\n+\n+    pub(super) fn lifetime_ctx(&self) -> Option<&LifetimeContext> {\n+        match &self.ident_ctx {\n+            IdentContext::Lifetime(it) => Some(it),\n+            _ => None,\n+        }\n+    }\n+\n     pub(crate) fn dot_receiver(&self) -> Option<&ast::Expr> {\n-        match &self.completion_location {\n-            Some(\n-                ImmediateLocation::MethodCall { receiver, .. }\n-                | ImmediateLocation::FieldAccess { receiver, .. },\n-            ) => receiver.as_ref(),\n+        match self.nameref_ctx() {\n+            Some(NameRefContext {\n+                dot_access:\n+                    Some(DotAccess::Method { receiver, .. } | DotAccess::Field { receiver, .. }),\n+                ..\n+            }) => receiver.as_ref(),\n             _ => None,\n         }\n     }\n \n     pub(crate) fn has_dot_receiver(&self) -> bool {\n-        matches!(\n-            &self.completion_location,\n-            Some(ImmediateLocation::FieldAccess { receiver, .. } | ImmediateLocation::MethodCall { receiver,.. })\n-                if receiver.is_some()\n-        )\n+        self.dot_receiver().is_some()\n     }\n \n     pub(crate) fn expects_assoc_item(&self) -> bool {\n         matches!(self.completion_location, Some(ImmediateLocation::Trait | ImmediateLocation::Impl))\n     }\n \n     pub(crate) fn expects_variant(&self) -> bool {\n-        matches!(self.name_ctx, Some(NameContext::Variant))\n+        matches!(self.name_ctx(), Some(NameContext { kind: NameKind::Variant, .. }))\n     }\n \n     pub(crate) fn expects_non_trait_assoc_item(&self) -> bool {\n@@ -284,7 +340,7 @@ impl<'a> CompletionContext<'a> {\n \n     pub(crate) fn expect_field(&self) -> bool {\n         matches!(self.completion_location, Some(ImmediateLocation::TupleField))\n-            || matches!(self.name_ctx, Some(NameContext::RecordField))\n+            || matches!(self.name_ctx(), Some(NameContext { kind: NameKind::RecordField, .. }))\n     }\n \n     /// Whether the cursor is right after a trait or impl header.\n@@ -321,24 +377,31 @@ impl<'a> CompletionContext<'a> {\n                 self.completion_location,\n                 Some(ImmediateLocation::RecordPat(_) | ImmediateLocation::RecordExpr(_))\n             )\n-            || matches!(self.name_ctx, Some(NameContext::Module(_) | NameContext::Rename))\n+            || matches!(\n+                self.name_ctx(),\n+                Some(NameContext { kind: NameKind::Module(_) | NameKind::Rename, .. })\n+            )\n+    }\n+\n+    pub(crate) fn path_context(&self) -> Option<&PathCompletionCtx> {\n+        self.nameref_ctx().and_then(|ctx| ctx.path_ctx.as_ref())\n     }\n \n     pub(crate) fn expects_expression(&self) -> bool {\n-        matches!(self.path_context, Some(PathCompletionCtx { kind: PathKind::Expr { .. }, .. }))\n+        matches!(self.path_context(), Some(PathCompletionCtx { kind: PathKind::Expr { .. }, .. }))\n     }\n \n     pub(crate) fn expects_type(&self) -> bool {\n-        matches!(self.path_context, Some(PathCompletionCtx { kind: PathKind::Type, .. }))\n+        matches!(self.path_context(), Some(PathCompletionCtx { kind: PathKind::Type, .. }))\n     }\n \n     pub(crate) fn path_is_call(&self) -> bool {\n-        self.path_context.as_ref().map_or(false, |it| it.has_call_parens)\n+        self.path_context().map_or(false, |it| it.has_call_parens)\n     }\n \n     pub(crate) fn is_non_trivial_path(&self) -> bool {\n         matches!(\n-            self.path_context,\n+            self.path_context(),\n             Some(\n                 PathCompletionCtx { is_absolute_path: true, .. }\n                     | PathCompletionCtx { qualifier: Some(_), .. }\n@@ -347,11 +410,11 @@ impl<'a> CompletionContext<'a> {\n     }\n \n     pub(crate) fn path_qual(&self) -> Option<&ast::Path> {\n-        self.path_context.as_ref().and_then(|it| it.qualifier.as_ref().map(|it| &it.path))\n+        self.path_context().and_then(|it| it.qualifier.as_ref().map(|it| &it.path))\n     }\n \n     pub(crate) fn path_kind(&self) -> Option<PathKind> {\n-        self.path_context.as_ref().map(|it| it.kind)\n+        self.path_context().map(|it| it.kind)\n     }\n \n     pub(crate) fn is_immediately_after_macro_bang(&self) -> bool {\n@@ -497,25 +560,22 @@ impl<'a> CompletionContext<'a> {\n             expected_type: None,\n             function_def: None,\n             impl_def: None,\n-            name_syntax: None,\n-            lifetime_ctx: None,\n-            pattern_ctx: None,\n-            name_ctx: None,\n+            incomplete_let: false,\n             completion_location: None,\n             prev_sibling: None,\n-            fake_attribute_under_caret: None,\n             previous_token: None,\n-            path_context: None,\n-            locals,\n-            incomplete_let: false,\n+            // dummy value, will be overwritten\n+            ident_ctx: IdentContext::UnexpandedAttrTT { fake_attribute_under_caret: None },\n+            pattern_ctx: None,\n             existing_derives: Default::default(),\n+            locals,\n         };\n         ctx.expand_and_fill(\n             original_file.syntax().clone(),\n             file_with_fake_ident.syntax().clone(),\n             offset,\n             fake_ident_token,\n-        );\n+        )?;\n         Some(ctx)\n     }\n \n@@ -528,7 +588,7 @@ impl<'a> CompletionContext<'a> {\n         mut speculative_file: SyntaxNode,\n         mut offset: TextSize,\n         mut fake_ident_token: SyntaxToken,\n-    ) {\n+    ) -> Option<()> {\n         let _p = profile::span(\"CompletionContext::expand_and_fill\");\n         let mut derive_ctx = None;\n \n@@ -658,7 +718,7 @@ impl<'a> CompletionContext<'a> {\n             break 'expansion;\n         }\n \n-        self.fill(&original_file, speculative_file, offset, derive_ctx);\n+        self.fill(&original_file, speculative_file, offset, derive_ctx)\n     }\n \n     /// Calculate the expected type and name of the cursor position.\n@@ -806,7 +866,7 @@ impl<'a> CompletionContext<'a> {\n         file_with_fake_ident: SyntaxNode,\n         offset: TextSize,\n         derive_ctx: Option<(SyntaxNode, SyntaxNode, TextSize, ast::Attr)>,\n-    ) {\n+    ) -> Option<()> {\n         let fake_ident_token = file_with_fake_ident.token_at_offset(offset).right_biased().unwrap();\n         let syntax_element = NodeOrToken::Token(fake_ident_token);\n         if is_in_token_of_for_loop(syntax_element.clone()) {\n@@ -815,11 +875,10 @@ impl<'a> CompletionContext<'a> {\n             // don't bother populating the context\n             // FIXME: the completion calculations should end up good enough\n             // such that this special case becomes unnecessary\n-            return;\n+            return None;\n         }\n \n         self.previous_token = previous_token(syntax_element.clone());\n-        self.fake_attribute_under_caret = syntax_element.ancestors().find_map(ast::Attr::cast);\n \n         self.incomplete_let =\n             syntax_element.ancestors().take(6).find_map(ast::LetStmt::cast).map_or(false, |it| {\n@@ -841,27 +900,53 @@ impl<'a> CompletionContext<'a> {\n             if let Some(ast::NameLike::NameRef(name_ref)) =\n                 find_node_at_offset(&file_with_fake_ident, offset)\n             {\n-                self.name_syntax =\n-                    find_node_at_offset(&original_file, name_ref.syntax().text_range().start());\n-                if let Some((path_ctx, _)) =\n-                    Self::classify_name_ref(&self.sema, &original_file, name_ref)\n-                {\n-                    self.path_context =\n-                        Some(PathCompletionCtx { kind: PathKind::Derive, ..path_ctx });\n+                let parent = name_ref.syntax().parent()?;\n+                let (mut nameref_ctx, _) =\n+                    Self::classify_name_ref(&self.sema, &original_file, name_ref, parent);\n+                if let Some(path_ctx) = &mut nameref_ctx.path_ctx {\n+                    path_ctx.kind = PathKind::Derive;\n                 }\n+                self.ident_ctx = IdentContext::NameRef(nameref_ctx);\n+                return Some(());\n             }\n-            return;\n+            return None;\n         }\n \n         let name_like = match find_node_at_offset(&file_with_fake_ident, offset) {\n             Some(it) => it,\n-            None => return,\n+            None => {\n+                if let Some(original) = ast::String::cast(self.original_token.clone()) {\n+                    self.ident_ctx = IdentContext::String {\n+                        original,\n+                        expanded: ast::String::cast(self.token.clone()),\n+                    };\n+                } else {\n+                    // Fix up trailing whitespace problem\n+                    // #[attr(foo = $0\n+                    let token = if self.token.kind() == SyntaxKind::WHITESPACE {\n+                        self.previous_token.as_ref()?\n+                    } else {\n+                        &self.token\n+                    };\n+                    let p = token.parent()?;\n+                    if p.kind() == SyntaxKind::TOKEN_TREE\n+                        && p.ancestors().any(|it| it.kind() == SyntaxKind::META)\n+                    {\n+                        self.ident_ctx = IdentContext::UnexpandedAttrTT {\n+                            fake_attribute_under_caret: syntax_element\n+                                .ancestors()\n+                                .find_map(ast::Attr::cast),\n+                        };\n+                    } else {\n+                        return None;\n+                    }\n+                }\n+                return Some(());\n+            }\n         };\n         self.completion_location =\n             determine_location(&self.sema, original_file, offset, &name_like);\n         self.prev_sibling = determine_prev_sibling(&name_like);\n-        self.name_syntax =\n-            find_node_at_offset(original_file, name_like.syntax().text_range().start());\n         self.impl_def = self\n             .sema\n             .token_ancestors_with_macros(self.token.clone())\n@@ -875,49 +960,53 @@ impl<'a> CompletionContext<'a> {\n \n         match name_like {\n             ast::NameLike::Lifetime(lifetime) => {\n-                self.lifetime_ctx = Self::classify_lifetime(&self.sema, original_file, lifetime);\n+                self.ident_ctx = IdentContext::Lifetime(Self::classify_lifetime(\n+                    &self.sema,\n+                    original_file,\n+                    lifetime,\n+                )?);\n             }\n             ast::NameLike::NameRef(name_ref) => {\n-                if let Some((path_ctx, pat_ctx)) =\n-                    Self::classify_name_ref(&self.sema, original_file, name_ref)\n-                {\n-                    self.path_context = Some(path_ctx);\n-                    self.pattern_ctx = pat_ctx;\n-                }\n+                let parent = name_ref.syntax().parent()?;\n+                let (nameref_ctx, pat_ctx) =\n+                    Self::classify_name_ref(&self.sema, &original_file, name_ref, parent);\n+                self.ident_ctx = IdentContext::NameRef(nameref_ctx);\n+                self.pattern_ctx = pat_ctx;\n             }\n             ast::NameLike::Name(name) => {\n-                if let Some((name_ctx, pat_ctx)) =\n-                    Self::classify_name(&self.sema, original_file, name)\n-                {\n-                    self.pattern_ctx = pat_ctx;\n-                    self.name_ctx = Some(name_ctx);\n-                }\n+                let (name_ctx, pat_ctx) = Self::classify_name(&self.sema, original_file, name)?;\n+                self.pattern_ctx = pat_ctx;\n+                self.ident_ctx = IdentContext::Name(name_ctx);\n             }\n         }\n+        Some(())\n     }\n \n     fn classify_lifetime(\n         _sema: &Semantics<RootDatabase>,\n-        _original_file: &SyntaxNode,\n+        original_file: &SyntaxNode,\n         lifetime: ast::Lifetime,\n     ) -> Option<LifetimeContext> {\n         let parent = lifetime.syntax().parent()?;\n         if parent.kind() == ERROR {\n             return None;\n         }\n \n-        Some(match_ast! {\n+        let kind = match_ast! {\n             match parent {\n-                ast::LifetimeParam(param) => LifetimeContext::LifetimeParam {\n+                ast::LifetimeParam(param) => LifetimeKind::LifetimeParam {\n                     is_decl: param.lifetime().as_ref() == Some(&lifetime),\n                     param\n                 },\n-                ast::BreakExpr(_) => LifetimeContext::LabelRef,\n-                ast::ContinueExpr(_) => LifetimeContext::LabelRef,\n-                ast::Label(_) => LifetimeContext::LabelDef,\n-                _ => LifetimeContext::Lifetime,\n+                ast::BreakExpr(_) => LifetimeKind::LabelRef,\n+                ast::ContinueExpr(_) => LifetimeKind::LabelRef,\n+                ast::Label(_) => LifetimeKind::LabelDef,\n+                _ => LifetimeKind::Lifetime,\n             }\n-        })\n+        };\n+        let lifetime = find_node_at_offset(&original_file, lifetime.syntax().text_range().start());\n+\n+        Some(LifetimeContext { lifetime, kind })\n     }\n \n     fn classify_name(\n@@ -927,12 +1016,12 @@ impl<'a> CompletionContext<'a> {\n     ) -> Option<(NameContext, Option<PatternContext>)> {\n         let parent = name.syntax().parent()?;\n         let mut pat_ctx = None;\n-        let name_ctx = match_ast! {\n+        let kind = match_ast! {\n             match parent {\n-                ast::Const(_) => NameContext::Const,\n-                ast::ConstParam(_) => NameContext::ConstParam,\n-                ast::Enum(_) => NameContext::Enum,\n-                ast::Fn(_) => NameContext::Function,\n+                ast::Const(_) => NameKind::Const,\n+                ast::ConstParam(_) => NameKind::ConstParam,\n+                ast::Enum(_) => NameKind::Enum,\n+                ast::Fn(_) => NameKind::Function,\n                 ast::IdentPat(bind_pat) => {\n                     let is_name_in_field_pat = bind_pat\n                         .syntax()\n@@ -943,36 +1032,67 @@ impl<'a> CompletionContext<'a> {\n                         pat_ctx = Some(pattern_context_for(original_file, bind_pat.into()));\n                     }\n \n-                    NameContext::IdentPat\n+                    NameKind::IdentPat\n                 },\n-                ast::MacroDef(_) => NameContext::MacroDef,\n-                ast::MacroRules(_) => NameContext::MacroRules,\n-                ast::Module(module) => NameContext::Module(module),\n-                ast::RecordField(_) => NameContext::RecordField,\n-                ast::Rename(_) => NameContext::Rename,\n-                ast::SelfParam(_) => NameContext::SelfParam,\n-                ast::Static(_) => NameContext::Static,\n-                ast::Struct(_) => NameContext::Struct,\n-                ast::Trait(_) => NameContext::Trait,\n-                ast::TypeAlias(_) => NameContext::TypeAlias,\n-                ast::TypeParam(_) => NameContext::TypeParam,\n-                ast::Union(_) => NameContext::Union,\n-                ast::Variant(_) => NameContext::Variant,\n+                ast::MacroDef(_) => NameKind::MacroDef,\n+                ast::MacroRules(_) => NameKind::MacroRules,\n+                ast::Module(module) => NameKind::Module(module),\n+                ast::RecordField(_) => NameKind::RecordField,\n+                ast::Rename(_) => NameKind::Rename,\n+                ast::SelfParam(_) => NameKind::SelfParam,\n+                ast::Static(_) => NameKind::Static,\n+                ast::Struct(_) => NameKind::Struct,\n+                ast::Trait(_) => NameKind::Trait,\n+                ast::TypeAlias(_) => NameKind::TypeAlias,\n+                ast::TypeParam(_) => NameKind::TypeParam,\n+                ast::Union(_) => NameKind::Union,\n+                ast::Variant(_) => NameKind::Variant,\n                 _ => return None,\n             }\n         };\n-        Some((name_ctx, pat_ctx))\n+        let name = find_node_at_offset(&original_file, name.syntax().text_range().start());\n+        Some((NameContext { name, kind }, pat_ctx))\n     }\n \n     fn classify_name_ref(\n         sema: &Semantics<RootDatabase>,\n         original_file: &SyntaxNode,\n         name_ref: ast::NameRef,\n-    ) -> Option<(PathCompletionCtx, Option<PatternContext>)> {\n-        let parent = name_ref.syntax().parent()?;\n-        let segment = ast::PathSegment::cast(parent)?;\n-        let path = segment.parent_path();\n+        parent: SyntaxNode,\n+    ) -> (NameRefContext, Option<PatternContext>) {\n+        let nameref = find_node_at_offset(&original_file, name_ref.syntax().text_range().start());\n+\n+        let mut nameref_ctx = NameRefContext { dot_access: None, path_ctx: None, nameref };\n+\n+        let segment = match_ast! {\n+            match parent {\n+                ast::PathSegment(segment) => segment,\n+                ast::FieldExpr(field) => {\n+                    let receiver = find_in_original_file(field.expr(), original_file);\n+                    let receiver_is_ambiguous_float_literal = match &receiver {\n+                        Some(ast::Expr::Literal(l)) => matches! {\n+                            l.kind(),\n+                            ast::LiteralKind::FloatNumber { .. } if l.syntax().last_token().map_or(false, |it| it.kind() == T![.])\n+                        },\n+                        _ => false,\n+                    };\n+                    nameref_ctx.dot_access = Some(DotAccess::Field { receiver, receiver_is_ambiguous_float_literal });\n+                    return (nameref_ctx, None);\n+                },\n+                ast::MethodCallExpr(method) => {\n+                    nameref_ctx.dot_access = Some(\n+                        DotAccess::Method {\n+                            receiver: find_in_original_file(method.receiver(), original_file),\n+                            has_parens: method.arg_list().map_or(false, |it| it.l_paren_token().is_some())\n+                        }\n+                    );\n+                    return (nameref_ctx, None);\n+                },\n+                _ => return (nameref_ctx, None),\n+            }\n+        };\n \n+        let path = segment.parent_path();\n         let mut path_ctx = PathCompletionCtx {\n             has_call_parens: false,\n             has_macro_bang: false,\n@@ -992,7 +1112,7 @@ impl<'a> CompletionContext<'a> {\n                 .unwrap_or(false)\n         };\n \n-        path_ctx.kind = path.syntax().ancestors().find_map(|it| {\n+        let kind = path.syntax().ancestors().find_map(|it| {\n             // using Option<Option<PathKind>> as extra controlflow\n             let kind = match_ast! {\n                 match it {\n@@ -1073,7 +1193,11 @@ impl<'a> CompletionContext<'a> {\n                 }\n             };\n             Some(kind)\n-        }).flatten()?;\n+        }).flatten();\n+        match kind {\n+            Some(kind) => path_ctx.kind = kind,\n+            None => return (nameref_ctx, pat_ctx),\n+        }\n         path_ctx.has_type_args = segment.generic_arg_list().is_some();\n \n         if let Some((path, use_tree_parent)) = path_or_use_tree_qualifier(&path) {\n@@ -1109,17 +1233,13 @@ impl<'a> CompletionContext<'a> {\n                     is_infer_qualifier,\n                 }\n             });\n-            return Some((path_ctx, pat_ctx));\n-        }\n-\n-        if let Some(segment) = path.segment() {\n+        } else if let Some(segment) = path.segment() {\n             if segment.coloncolon_token().is_some() {\n                 path_ctx.is_absolute_path = true;\n-                return Some((path_ctx, pat_ctx));\n             }\n         }\n-\n-        Some((path_ctx, pat_ctx))\n+        nameref_ctx.path_ctx = Some(path_ctx);\n+        (nameref_ctx, pat_ctx)\n     }\n }\n \n@@ -1174,6 +1294,14 @@ fn pattern_context_for(original_file: &SyntaxNode, pat: ast::Pat) -> PatternCont\n     }\n }\n \n+fn find_in_original_file<N: AstNode>(x: Option<N>, original_file: &SyntaxNode) -> Option<N> {\n+    fn find_node_with_range<N: AstNode>(syntax: &SyntaxNode, range: TextRange) -> Option<N> {\n+        let range = syntax.text_range().intersect(range)?;\n+        syntax.covering_element(range).ancestors().find_map(N::cast)\n+    }\n+    x.map(|e| e.syntax().text_range()).and_then(|r| find_node_with_range(original_file, r))\n+}\n+\n /// Attempts to find `node` inside `syntax` via `node`'s text range.\n fn find_node_in_file<N: AstNode>(syntax: &SyntaxNode, node: &N) -> Option<N> {\n     let syntax_range = syntax.text_range();"}, {"sha": "07b2ac4297f3a8e063f69e01399ae4259d7657ad", "filename": "crates/ide-completion/src/patterns.rs", "status": "modified", "additions": 1, "deletions": 30, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fpatterns.rs?ref=5d5bbec9b60010dd7389a084c56693baf6bda780", "patch": "@@ -8,7 +8,7 @@ use hir::Semantics;\n use ide_db::RootDatabase;\n use syntax::{\n     algo::non_trivia_sibling,\n-    ast::{self, HasArgList, HasLoopBody, HasName},\n+    ast::{self, HasLoopBody, HasName},\n     match_ast, AstNode, Direction, SyntaxElement,\n     SyntaxKind::*,\n     SyntaxNode, SyntaxToken, TextRange, TextSize,\n@@ -51,16 +51,6 @@ pub(crate) enum ImmediateLocation {\n     TypeBound,\n     /// Original file ast node\n     TypeAnnotation(TypeAnnotation),\n-    /// Original file ast node\n-    MethodCall {\n-        receiver: Option<ast::Expr>,\n-        has_parens: bool,\n-    },\n-    /// Original file ast node\n-    FieldAccess {\n-        receiver: Option<ast::Expr>,\n-        receiver_is_ambiguous_float_literal: bool,\n-    },\n     // Only set from a type arg\n     /// Original file ast node\n     GenericArgList(ast::GenericArgList),\n@@ -226,25 +216,6 @@ pub(crate) fn determine_location(\n             ast::GenericArgList(_) => sema\n                 .find_node_at_offset_with_macros(original_file, offset)\n                 .map(ImmediateLocation::GenericArgList)?,\n-            ast::FieldExpr(it) => {\n-                let receiver = find_in_original_file(it.expr(), original_file);\n-                let receiver_is_ambiguous_float_literal = if let Some(ast::Expr::Literal(l)) = &receiver {\n-                    match l.kind() {\n-                        ast::LiteralKind::FloatNumber { .. } => l.to_string().ends_with('.'),\n-                        _ => false,\n-                    }\n-                } else {\n-                    false\n-                };\n-                ImmediateLocation::FieldAccess {\n-                    receiver,\n-                    receiver_is_ambiguous_float_literal,\n-                }\n-            },\n-            ast::MethodCallExpr(it) => ImmediateLocation::MethodCall {\n-                receiver: find_in_original_file(it.receiver(), original_file),\n-                has_parens: it.arg_list().map_or(false, |it| it.l_paren_token().is_some())\n-            },\n             ast::Const(it) => {\n                 if !it.ty().map_or(false, |x| x.syntax().text_range().contains(offset)) {\n                     return None;"}, {"sha": "01c9bfdb85ce37fad6303fdcb21b7dacb95749e0", "filename": "crates/ide-completion/src/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender.rs?ref=5d5bbec9b60010dd7389a084c56693baf6bda780", "patch": "@@ -272,7 +272,7 @@ fn render_resolution_simple_(\n \n     // Add `<>` for generic types\n     let type_path_no_ty_args = matches!(\n-        ctx.completion.path_context,\n+        ctx.completion.path_context(),\n         Some(PathCompletionCtx { kind: PathKind::Type, has_type_args: false, .. })\n     ) && ctx.completion.config.add_call_parenthesis;\n     if type_path_no_ty_args {"}, {"sha": "1ede314e87bb40845f3d07e91e9d92e431496e9a", "filename": "crates/ide-completion/src/render/function.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs?ref=5d5bbec9b60010dd7389a084c56693baf6bda780", "patch": "@@ -7,9 +7,8 @@ use stdx::{format_to, to_lower_snake_case};\n use syntax::SmolStr;\n \n use crate::{\n-    context::{CompletionContext, PathCompletionCtx, PathKind},\n+    context::{CompletionContext, DotAccess, NameRefContext, PathCompletionCtx, PathKind},\n     item::{Builder, CompletionItem, CompletionItemKind, CompletionRelevance},\n-    patterns::ImmediateLocation,\n     render::{compute_exact_name_match, compute_ref_match, compute_type_match, RenderContext},\n };\n \n@@ -196,7 +195,7 @@ fn should_add_parens(ctx: &CompletionContext) -> bool {\n         return false;\n     }\n \n-    match ctx.path_context {\n+    match ctx.path_context() {\n         Some(PathCompletionCtx { kind: PathKind::Expr { .. }, has_call_parens: true, .. }) => {\n             return false\n         }\n@@ -208,8 +207,8 @@ fn should_add_parens(ctx: &CompletionContext) -> bool {\n     };\n \n     if matches!(\n-        ctx.completion_location,\n-        Some(ImmediateLocation::MethodCall { has_parens: true, .. })\n+        ctx.nameref_ctx(),\n+        Some(NameRefContext { dot_access: Some(DotAccess::Method { has_parens: true, .. }), .. })\n     ) {\n         return false;\n     }"}, {"sha": "e6540e6ac53c845c9d3e61685b235b624eee66be", "filename": "crates/ide-completion/src/render/literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs?ref=5d5bbec9b60010dd7389a084c56693baf6bda780", "patch": "@@ -52,7 +52,7 @@ fn render(\n     let db = completion.db;\n     let kind = thing.kind(db);\n     let has_call_parens =\n-        matches!(completion.path_context, Some(PathCompletionCtx { has_call_parens: true, .. }));\n+        matches!(completion.path_context(), Some(PathCompletionCtx { has_call_parens: true, .. }));\n \n     let fields = thing.fields(completion)?;\n     let (qualified_name, short_qualified_name, qualified) = match path {"}, {"sha": "9c51a6311a4dbc5a736fc59727be5acc14e6a688", "filename": "crates/ide-completion/src/render/macro_.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Frender%2Fmacro_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Frender%2Fmacro_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender%2Fmacro_.rs?ref=5d5bbec9b60010dd7389a084c56693baf6bda780", "patch": "@@ -33,8 +33,8 @@ fn render(\n     let is_fn_like = macro_.is_fn_like(completion.db);\n     let (bra, ket) = if is_fn_like { guess_macro_braces(&name, docs_str) } else { (\"\", \"\") };\n \n-    let needs_bang = match completion.path_context {\n-        Some(PathCompletionCtx { kind, has_macro_bang, .. }) => {\n+    let needs_bang = match completion.path_context() {\n+        Some(&PathCompletionCtx { kind, has_macro_bang, .. }) => {\n             is_fn_like && kind != PathKind::Use && !has_macro_bang\n         }\n         _ => is_fn_like,"}, {"sha": "5b403ae8cccb29e8f7eb84799890485f061a1aa8", "filename": "crates/ide-completion/src/render/pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Frender%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Frender%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender%2Fpattern.rs?ref=5d5bbec9b60010dd7389a084c56693baf6bda780", "patch": "@@ -78,7 +78,7 @@ fn render_pat(\n     fields_omitted: bool,\n ) -> Option<String> {\n     let has_call_parens = matches!(\n-        ctx.completion.path_context,\n+        ctx.completion.path_context(),\n         Some(PathCompletionCtx { has_call_parens: true, .. })\n     );\n     let mut pat = match kind {"}, {"sha": "0430aeea59b43af7c94584505eec177abe8638d8", "filename": "crates/ide-completion/src/tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests.rs?ref=5d5bbec9b60010dd7389a084c56693baf6bda780", "patch": "@@ -257,7 +257,6 @@ fn foo() {\n \n #[test]\n fn no_completions_in_comments() {\n-    cov_mark::check!(no_keyword_completion_in_comments);\n     assert_eq!(\n         completion_list(\n             r#\""}, {"sha": "52c69f84b610856b7156a6298331da811d6d2cf0", "filename": "crates/ide-completion/src/tests/attribute.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Ftests%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5bbec9b60010dd7389a084c56693baf6bda780/crates%2Fide-completion%2Fsrc%2Ftests%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fattribute.rs?ref=5d5bbec9b60010dd7389a084c56693baf6bda780", "patch": "@@ -579,25 +579,6 @@ fn attr_on_fn() {\n     );\n }\n \n-#[test]\n-fn attr_on_expr() {\n-    cov_mark::check!(no_keyword_completion_in_attr_of_expr);\n-    check(\n-        r#\"fn main() { #[$0] foo() }\"#,\n-        expect![[r#\"\n-            at allow(\u2026)\n-            at cfg(\u2026)\n-            at cfg_attr(\u2026)\n-            at deny(\u2026)\n-            at forbid(\u2026)\n-            at warn(\u2026)\n-            kw crate::\n-            kw self::\n-            kw super::\n-        \"#]],\n-    );\n-}\n-\n #[test]\n fn attr_in_source_file_end() {\n     check("}]}