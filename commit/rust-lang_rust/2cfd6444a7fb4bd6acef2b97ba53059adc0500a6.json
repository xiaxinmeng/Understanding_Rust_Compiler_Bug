{"sha": "2cfd6444a7fb4bd6acef2b97ba53059adc0500a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjZmQ2NDQ0YTdmYjRiZDZhY2VmMmI5N2JhNTMwNTlhZGMwNTAwYTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-03T16:46:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-03T16:46:12Z"}, "message": "Auto merge of #58673 - matthewjasper:typeck-ptr-coercions, r=pnkfelix\n\n[NLL] Type check operations with pointer types\n\nIt seems these were forgotten about. Moving to `Rvalue::AddressOf` simplifies the coercions from references, but I want this to be fixed as soon as possible.\n\nr? @pnkfelix", "tree": {"sha": "d04772a8cd5ed241e7a8c13ddcaf7eaebaf0b0f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d04772a8cd5ed241e7a8c13ddcaf7eaebaf0b0f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6", "html_url": "https://github.com/rust-lang/rust/commit/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0086b9e8972fef9fd4af24bae20d45021ed06c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0086b9e8972fef9fd4af24bae20d45021ed06c6", "html_url": "https://github.com/rust-lang/rust/commit/c0086b9e8972fef9fd4af24bae20d45021ed06c6"}, {"sha": "19a54e80934c802109ae7175cc824c22c672caa6", "url": "https://api.github.com/repos/rust-lang/rust/commits/19a54e80934c802109ae7175cc824c22c672caa6", "html_url": "https://github.com/rust-lang/rust/commit/19a54e80934c802109ae7175cc824c22c672caa6"}], "stats": {"total": 424, "additions": 408, "deletions": 16}, "files": [{"sha": "ba47116434f8d12440365a7d7a997bdc9fe5766f", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=2cfd6444a7fb4bd6acef2b97ba53059adc0500a6", "patch": "@@ -378,6 +378,7 @@ impl_stable_hash_for!(enum mir::CastKind {\n     ReifyFnPointer,\n     ClosureFnPointer,\n     UnsafeFnPointer,\n+    MutToConstPointer,\n     Unsize\n });\n "}, {"sha": "0462bb802312a494c138142d60b56dc1e881309f", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=2cfd6444a7fb4bd6acef2b97ba53059adc0500a6", "patch": "@@ -2237,6 +2237,9 @@ pub enum CastKind {\n     /// Converts safe fn() to unsafe fn()\n     UnsafeFnPointer,\n \n+    /// Coerces *mut T to *const T, preserving T.\n+    MutToConstPointer,\n+\n     /// \"Unsize\" -- convert a thin-or-fat pointer to a fat pointer.\n     /// codegen must figure out the details once full monomorphization\n     /// is known. For example, this could be used to cast from a"}, {"sha": "3c63dcb9ef307fb309e0c77316b05b5486aa7c3a", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=2cfd6444a7fb4bd6acef2b97ba53059adc0500a6", "patch": "@@ -59,7 +59,6 @@ use std::hash::{Hash, Hasher};\n use std::fmt;\n use std::mem;\n use std::ops::{Deref, Bound};\n-use std::ptr;\n use std::iter;\n use std::sync::mpsc;\n use std::sync::Arc;\n@@ -171,7 +170,7 @@ impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n \n                 // Make sure we don't end up with inference\n                 // types/regions in the global interner\n-                if ptr::eq(local, global) {\n+                if ptr_eq(local, global) {\n                     bug!(\"Attempted to intern `{:?}` which contains \\\n                         inference types/regions in the global type context\",\n                         &ty_struct);\n@@ -1163,7 +1162,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     /// Returns `true` if self is the same as self.global_tcx().\n     fn is_global(self) -> bool {\n-        ptr::eq(self.interners, &self.global_interners)\n+        ptr_eq(self.interners, &self.global_interners)\n     }\n \n     /// Creates a type context and call the closure with a `TyCtxt` reference\n@@ -1817,12 +1816,11 @@ impl<'a, 'tcx> Lift<'tcx> for &'a mir::interpret::Allocation {\n }\n \n pub mod tls {\n-    use super::{GlobalCtxt, TyCtxt};\n+    use super::{GlobalCtxt, TyCtxt, ptr_eq};\n \n     use std::fmt;\n     use std::mem;\n     use std::marker::PhantomData;\n-    use std::ptr;\n     use syntax_pos;\n     use crate::ty::query;\n     use errors::{Diagnostic, TRACK_DIAGNOSTICS};\n@@ -2065,7 +2063,7 @@ pub mod tls {\n     {\n         with_context(|context| {\n             unsafe {\n-                assert!(ptr::eq(context.tcx.gcx, tcx.gcx));\n+                assert!(ptr_eq(context.tcx.gcx, tcx.gcx));\n                 let context: &ImplicitCtxt<'_, '_, '_> = mem::transmute(context);\n                 f(context)\n             }\n@@ -2083,8 +2081,8 @@ pub mod tls {\n     {\n         with_context(|context| {\n             unsafe {\n-                assert!(ptr::eq(context.tcx.gcx, tcx.gcx));\n-                assert!(ptr::eq(context.tcx.interners, tcx.interners));\n+                assert!(ptr_eq(context.tcx.gcx, tcx.gcx));\n+                assert!(ptr_eq(context.tcx.interners, tcx.interners));\n                 let context: &ImplicitCtxt<'_, '_, '_> = mem::transmute(context);\n                 f(context)\n             }\n@@ -2970,6 +2968,12 @@ impl<T, R, E> InternIteratorElement<T, R> for Result<T, E> {\n     }\n }\n \n+// We are comparing types with different invariant lifetimes, so `ptr::eq`\n+// won't work for us.\n+fn ptr_eq<T, U>(t: *const T, u: *const U) -> bool {\n+    t as *const () == u as *const ()\n+}\n+\n pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     providers.in_scope_traits_map = |tcx, id| tcx.gcx.trait_map.get(&id).cloned();\n     providers.module_exports = |tcx, id| tcx.gcx.export_map.get(&id).cloned();"}, {"sha": "b8131671320e1ed86db2e444e59d8d7ac26aba7a", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=2cfd6444a7fb4bd6acef2b97ba53059adc0500a6", "patch": "@@ -257,7 +257,8 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             }\n                         }\n                     }\n-                    mir::CastKind::Misc if bx.cx().is_backend_scalar_pair(operand.layout) => {\n+                    mir::CastKind::MutToConstPointer\n+                    | mir::CastKind::Misc if bx.cx().is_backend_scalar_pair(operand.layout) => {\n                         if let OperandValue::Pair(data_ptr, meta) = operand.val {\n                             if bx.cx().is_backend_scalar_pair(cast) {\n                                 let data_cast = bx.pointercast(data_ptr,\n@@ -274,7 +275,8 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             bug!(\"Unexpected non-Pair operand\")\n                         }\n                     }\n-                    mir::CastKind::Misc => {\n+                    mir::CastKind::MutToConstPointer\n+                    | mir::CastKind::Misc => {\n                         assert!(bx.cx().is_backend_immediate(cast));\n                         let ll_t_out = bx.cx().immediate_backend_type(cast);\n                         if operand.layout.abi.is_uninhabited() {"}, {"sha": "cc03d4a0c96431835072ab92d5b0f94d6df37dd9", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 151, "deletions": 2, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=2cfd6444a7fb4bd6acef2b97ba53059adc0500a6", "patch": "@@ -27,6 +27,7 @@ use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::QueryRegionConstraint;\n use rustc::infer::outlives::env::RegionBoundPairs;\n use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime, NLLRegionVariableOrigin};\n+use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::mir::interpret::EvalErrorKind::BoundsCheck;\n use rustc::mir::tcx::PlaceTy;\n use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext, NonMutatingUseContext};\n@@ -2074,15 +2075,163 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         );\n                     }\n \n-                    CastKind::Misc => {}\n+                    CastKind::MutToConstPointer => {\n+                        let ty_from = match op.ty(mir, tcx).sty {\n+                            ty::RawPtr(ty::TypeAndMut {\n+                                ty: ty_from,\n+                                mutbl: hir::MutMutable,\n+                            }) => ty_from,\n+                            _ => {\n+                                span_mirbug!(\n+                                    self,\n+                                    rvalue,\n+                                    \"unexpected base type for cast {:?}\",\n+                                    ty,\n+                                );\n+                                return;\n+                            }\n+                        };\n+                        let ty_to = match ty.sty {\n+                            ty::RawPtr(ty::TypeAndMut {\n+                                ty: ty_to,\n+                                mutbl: hir::MutImmutable,\n+                            }) => ty_to,\n+                            _ => {\n+                                span_mirbug!(\n+                                    self,\n+                                    rvalue,\n+                                    \"unexpected target type for cast {:?}\",\n+                                    ty,\n+                                );\n+                                return;\n+                            }\n+                        };\n+                        if let Err(terr) = self.sub_types(\n+                            ty_from,\n+                            ty_to,\n+                            location.to_locations(),\n+                            ConstraintCategory::Cast,\n+                        ) {\n+                            span_mirbug!(\n+                                self,\n+                                rvalue,\n+                                \"relating {:?} with {:?} yields {:?}\",\n+                                ty_from,\n+                                ty_to,\n+                                terr\n+                            )\n+                        }\n+                    }\n+\n+                    CastKind::Misc => {\n+                        if let ty::Ref(_, mut ty_from, _) = op.ty(mir, tcx).sty {\n+                            let (mut ty_to, mutability) = if let ty::RawPtr(ty::TypeAndMut {\n+                                ty: ty_to,\n+                                mutbl,\n+                            }) = ty.sty {\n+                                (ty_to, mutbl)\n+                            } else {\n+                                span_mirbug!(\n+                                    self,\n+                                    rvalue,\n+                                    \"invalid cast types {:?} -> {:?}\",\n+                                    op.ty(mir, tcx),\n+                                    ty,\n+                                );\n+                                return;\n+                            };\n+\n+                            // Handle the direct cast from `&[T; N]` to `*const T` by unwrapping\n+                            // any array we find.\n+                            while let ty::Array(ty_elem_from, _) = ty_from.sty {\n+                                ty_from = ty_elem_from;\n+                                if let ty::Array(ty_elem_to, _) = ty_to.sty {\n+                                    ty_to = ty_elem_to;\n+                                } else {\n+                                    break;\n+                                }\n+                            }\n+\n+                            if let hir::MutMutable = mutability {\n+                                if let Err(terr) = self.eq_types(\n+                                    ty_from,\n+                                    ty_to,\n+                                    location.to_locations(),\n+                                    ConstraintCategory::Cast,\n+                                ) {\n+                                    span_mirbug!(\n+                                        self,\n+                                        rvalue,\n+                                        \"equating {:?} with {:?} yields {:?}\",\n+                                        ty_from,\n+                                        ty_to,\n+                                        terr\n+                                    )\n+                                }\n+                            } else {\n+                                if let Err(terr) = self.sub_types(\n+                                    ty_from,\n+                                    ty_to,\n+                                    location.to_locations(),\n+                                    ConstraintCategory::Cast,\n+                                ) {\n+                                    span_mirbug!(\n+                                        self,\n+                                        rvalue,\n+                                        \"relating {:?} with {:?} yields {:?}\",\n+                                        ty_from,\n+                                        ty_to,\n+                                        terr\n+                                    )\n+                                }\n+                            }\n+                        }\n+                    }\n                 }\n             }\n \n             Rvalue::Ref(region, _borrow_kind, borrowed_place) => {\n                 self.add_reborrow_constraint(mir, location, region, borrowed_place);\n             }\n \n-            // FIXME: These other cases have to be implemented in future PRs\n+            Rvalue::BinaryOp(BinOp::Eq, left, right)\n+            | Rvalue::BinaryOp(BinOp::Ne, left, right)\n+            | Rvalue::BinaryOp(BinOp::Lt, left, right)\n+            | Rvalue::BinaryOp(BinOp::Le, left, right)\n+            | Rvalue::BinaryOp(BinOp::Gt, left, right)\n+            | Rvalue::BinaryOp(BinOp::Ge, left, right) => {\n+                let ty_left = left.ty(mir, tcx);\n+                if let ty::RawPtr(_) | ty::FnPtr(_) = ty_left.sty {\n+                    let ty_right = right.ty(mir, tcx);\n+                    let common_ty = self.infcx.next_ty_var(\n+                        TypeVariableOrigin::MiscVariable(mir.source_info(location).span),\n+                    );\n+                    self.sub_types(\n+                        common_ty,\n+                        ty_left,\n+                        location.to_locations(),\n+                        ConstraintCategory::Boring\n+                    ).unwrap_or_else(|err| {\n+                        bug!(\"Could not equate type variable with {:?}: {:?}\", ty_left, err)\n+                    });\n+                    if let Err(terr) = self.sub_types(\n+                        common_ty,\n+                        ty_right,\n+                        location.to_locations(),\n+                        ConstraintCategory::Boring\n+                    ) {\n+                        span_mirbug!(\n+                            self,\n+                            rvalue,\n+                            \"unexpected comparison types {:?} and {:?} yields {:?}\",\n+                            ty_left,\n+                            ty_right,\n+                            terr\n+                        )\n+                    }\n+                }\n+            }\n+\n             Rvalue::Use(..)\n             | Rvalue::Len(..)\n             | Rvalue::BinaryOp(..)"}, {"sha": "20b95c363f5f7f9b875dff9127386cbf74079958", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=2cfd6444a7fb4bd6acef2b97ba53059adc0500a6", "patch": "@@ -196,6 +196,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             | ExprKind::ReifyFnPointer { .. }\n             | ExprKind::ClosureFnPointer { .. }\n             | ExprKind::UnsafeFnPointer { .. }\n+            | ExprKind::MutToConstPointer { .. }\n             | ExprKind::Unsize { .. }\n             | ExprKind::Repeat { .. }\n             | ExprKind::Borrow { .. }"}, {"sha": "f1a82ecef1b1d60a7b7be427fe186b1bbe3290c7", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=2cfd6444a7fb4bd6acef2b97ba53059adc0500a6", "patch": "@@ -147,8 +147,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 block.and(Rvalue::Use(Operand::Move(Place::Base(PlaceBase::Local(result)))))\n             }\n             ExprKind::Cast { source } => {\n-                let source = this.hir.mirror(source);\n-\n                 let source = unpack!(block = this.as_operand(block, scope, source));\n                 block.and(Rvalue::Cast(CastKind::Misc, source, expr.ty))\n             }\n@@ -168,6 +166,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let source = unpack!(block = this.as_operand(block, scope, source));\n                 block.and(Rvalue::Cast(CastKind::ClosureFnPointer, source, expr.ty))\n             }\n+            ExprKind::MutToConstPointer { source } => {\n+                let source = unpack!(block = this.as_operand(block, scope, source));\n+                block.and(Rvalue::Cast(CastKind::MutToConstPointer, source, expr.ty))\n+            }\n             ExprKind::Unsize { source } => {\n                 let source = unpack!(block = this.as_operand(block, scope, source));\n                 block.and(Rvalue::Cast(CastKind::Unsize, source, expr.ty))"}, {"sha": "c8c30ac3ce4d075a0c2238e1193a844a4a2a2695", "filename": "src/librustc_mir/build/expr/category.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs?ref=2cfd6444a7fb4bd6acef2b97ba53059adc0500a6", "patch": "@@ -62,6 +62,7 @@ impl Category {\n             | ExprKind::ReifyFnPointer { .. }\n             | ExprKind::ClosureFnPointer { .. }\n             | ExprKind::UnsafeFnPointer { .. }\n+            | ExprKind::MutToConstPointer { .. }\n             | ExprKind::Unsize { .. }\n             | ExprKind::Repeat { .. }\n             | ExprKind::Borrow { .. }"}, {"sha": "4d0418beea4dd72bd6c4c7ced88835573452e64b", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=2cfd6444a7fb4bd6acef2b97ba53059adc0500a6", "patch": "@@ -383,6 +383,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             | ExprKind::ReifyFnPointer { .. }\n             | ExprKind::ClosureFnPointer { .. }\n             | ExprKind::UnsafeFnPointer { .. }\n+            | ExprKind::MutToConstPointer { .. }\n             | ExprKind::Unsize { .. }\n             | ExprKind::Repeat { .. }\n             | ExprKind::Borrow { .. }"}, {"sha": "65cd9f7103d68d3c67d90c4a5a777112abdf67cb", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=2cfd6444a7fb4bd6acef2b97ba53059adc0500a6", "patch": "@@ -89,7 +89,7 @@ fn apply_adjustment<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             ExprKind::NeverToAny { source: expr.to_ref() }\n         }\n         Adjust::MutToConstPointer => {\n-            ExprKind::Cast { source: expr.to_ref() }\n+            ExprKind::MutToConstPointer { source: expr.to_ref() }\n         }\n         Adjust::Deref(None) => {\n             // Adjust the span from the block, to the last expression of the"}, {"sha": "6707b01ccc11bed7e6f04381256906bbcf14919e", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=2cfd6444a7fb4bd6acef2b97ba53059adc0500a6", "patch": "@@ -190,6 +190,9 @@ pub enum ExprKind<'tcx> {\n     UnsafeFnPointer {\n         source: ExprRef<'tcx>,\n     },\n+    MutToConstPointer {\n+        source: ExprRef<'tcx>,\n+    },\n     Unsize {\n         source: ExprRef<'tcx>,\n     },"}, {"sha": "73c73cc23dcf0cc90dd98f0440075c0882aab228", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=2cfd6444a7fb4bd6acef2b97ba53059adc0500a6", "patch": "@@ -33,7 +33,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 self.unsize_into(src, dest)?;\n             }\n \n-            Misc => {\n+            Misc | MutToConstPointer => {\n                 let src = self.read_immediate(src)?;\n \n                 if self.type_is_fat_ptr(src.layout.ty) {"}, {"sha": "20e5c0a23bc4b8ecd578e61bcf274720e1664e68", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=2cfd6444a7fb4bd6acef2b97ba53059adc0500a6", "patch": "@@ -1095,6 +1095,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             Rvalue::Cast(CastKind::UnsafeFnPointer, ..) |\n             Rvalue::Cast(CastKind::ClosureFnPointer, ..) |\n             Rvalue::Cast(CastKind::Unsize, ..) |\n+            Rvalue::Cast(CastKind::MutToConstPointer, ..) |\n             Rvalue::Discriminant(..) |\n             Rvalue::Len(_) |\n             Rvalue::Ref(..) |"}, {"sha": "f82e536ab254957b42968a7496c84f61f330605e", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=2cfd6444a7fb4bd6acef2b97ba53059adc0500a6", "patch": "@@ -152,6 +152,9 @@ fn check_rvalue(\n                 _ => check_operand(tcx, mir, operand, span),\n             }\n         }\n+        Rvalue::Cast(CastKind::MutToConstPointer, operand, _) => {\n+            check_operand(tcx, mir, operand, span)\n+        }\n         Rvalue::Cast(CastKind::UnsafeFnPointer, _, _) |\n         Rvalue::Cast(CastKind::ClosureFnPointer, _, _) |\n         Rvalue::Cast(CastKind::ReifyFnPointer, _, _) => Err(("}, {"sha": "b6a25eddb866d337e3a446337940d3b4232a9499", "filename": "src/test/ui/nll/type-check-pointer-coercions.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-coercions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-coercions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-coercions.rs?ref=2cfd6444a7fb4bd6acef2b97ba53059adc0500a6", "patch": "@@ -0,0 +1,39 @@\n+#![feature(nll)]\n+\n+fn shared_to_const<'a, 'b>(x: &&'a i32) -> *const &'b i32 {\n+    x   //~ ERROR\n+}\n+\n+fn unique_to_const<'a, 'b>(x: &mut &'a i32) -> *const &'b i32 {\n+    x   //~ ERROR\n+}\n+\n+fn unique_to_mut<'a, 'b>(x: &mut &'a i32) -> *mut &'b i32 {\n+    // Two errors because *mut is invariant\n+    x   //~ ERROR\n+        //~| ERROR\n+}\n+\n+fn mut_to_const<'a, 'b>(x: *mut &'a i32) -> *const &'b i32 {\n+    x   //~ ERROR\n+}\n+\n+fn array_elem<'a, 'b>(x: &'a i32) -> *const &'b i32 {\n+    let z = &[x; 3];\n+    let y = z as *const &i32;\n+    y   //~ ERROR\n+}\n+\n+fn array_coerce<'a, 'b>(x: &'a i32) -> *const [&'b i32; 3] {\n+    let z = &[x; 3];\n+    let y = z as *const [&i32; 3];\n+    y   //~ ERROR\n+}\n+\n+fn nested_array<'a, 'b>(x: &'a i32) -> *const [&'b i32; 2] {\n+    let z = &[[x; 2]; 3];\n+    let y = z as *const [&i32; 2];\n+    y   //~ ERROR\n+}\n+\n+fn main() {}"}, {"sha": "3b8d99421242e7e0f153596b4a6892ec82e095b3", "filename": "src/test/ui/nll/type-check-pointer-coercions.stderr", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-coercions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-coercions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-coercions.stderr?ref=2cfd6444a7fb4bd6acef2b97ba53059adc0500a6", "patch": "@@ -0,0 +1,87 @@\n+error: lifetime may not live long enough\n+  --> $DIR/type-check-pointer-coercions.rs:4:5\n+   |\n+LL | fn shared_to_const<'a, 'b>(x: &&'a i32) -> *const &'b i32 {\n+   |                    --  -- lifetime `'b` defined here\n+   |                    |\n+   |                    lifetime `'a` defined here\n+LL |     x   //~ ERROR\n+   |     ^ returning this value requires that `'a` must outlive `'b`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/type-check-pointer-coercions.rs:8:5\n+   |\n+LL | fn unique_to_const<'a, 'b>(x: &mut &'a i32) -> *const &'b i32 {\n+   |                    --  -- lifetime `'b` defined here\n+   |                    |\n+   |                    lifetime `'a` defined here\n+LL |     x   //~ ERROR\n+   |     ^ returning this value requires that `'a` must outlive `'b`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/type-check-pointer-coercions.rs:13:5\n+   |\n+LL | fn unique_to_mut<'a, 'b>(x: &mut &'a i32) -> *mut &'b i32 {\n+   |                  --  -- lifetime `'b` defined here\n+   |                  |\n+   |                  lifetime `'a` defined here\n+LL |     // Two errors because *mut is invariant\n+LL |     x   //~ ERROR\n+   |     ^ function was supposed to return data with lifetime `'a` but it is returning data with lifetime `'b`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/type-check-pointer-coercions.rs:13:5\n+   |\n+LL | fn unique_to_mut<'a, 'b>(x: &mut &'a i32) -> *mut &'b i32 {\n+   |                  --  -- lifetime `'b` defined here\n+   |                  |\n+   |                  lifetime `'a` defined here\n+LL |     // Two errors because *mut is invariant\n+LL |     x   //~ ERROR\n+   |     ^ returning this value requires that `'a` must outlive `'b`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/type-check-pointer-coercions.rs:18:5\n+   |\n+LL | fn mut_to_const<'a, 'b>(x: *mut &'a i32) -> *const &'b i32 {\n+   |                 --  -- lifetime `'b` defined here\n+   |                 |\n+   |                 lifetime `'a` defined here\n+LL |     x   //~ ERROR\n+   |     ^ returning this value requires that `'a` must outlive `'b`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/type-check-pointer-coercions.rs:24:5\n+   |\n+LL | fn array_elem<'a, 'b>(x: &'a i32) -> *const &'b i32 {\n+   |               --  -- lifetime `'b` defined here\n+   |               |\n+   |               lifetime `'a` defined here\n+...\n+LL |     y   //~ ERROR\n+   |     ^ returning this value requires that `'a` must outlive `'b`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/type-check-pointer-coercions.rs:30:5\n+   |\n+LL | fn array_coerce<'a, 'b>(x: &'a i32) -> *const [&'b i32; 3] {\n+   |                 --  -- lifetime `'b` defined here\n+   |                 |\n+   |                 lifetime `'a` defined here\n+...\n+LL |     y   //~ ERROR\n+   |     ^ returning this value requires that `'a` must outlive `'b`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/type-check-pointer-coercions.rs:36:5\n+   |\n+LL | fn nested_array<'a, 'b>(x: &'a i32) -> *const [&'b i32; 2] {\n+   |                 --  -- lifetime `'b` defined here\n+   |                 |\n+   |                 lifetime `'a` defined here\n+...\n+LL |     y   //~ ERROR\n+   |     ^ returning this value requires that `'a` must outlive `'b`\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "3c900356fab3b0bba2ab44f20d367bb0a83e28d9", "filename": "src/test/ui/nll/type-check-pointer-comparisons.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-comparisons.rs?ref=2cfd6444a7fb4bd6acef2b97ba53059adc0500a6", "patch": "@@ -0,0 +1,33 @@\n+#![feature(nll)]\n+\n+// Check that we assert that pointers have a common subtype for comparisons\n+\n+fn compare_const<'a, 'b>(x: *const &mut &'a i32, y: *const &mut &'b i32) {\n+    x == y;\n+    //~^ ERROR lifetime may not live long enough\n+    //~| ERROR lifetime may not live long enough\n+}\n+\n+fn compare_mut<'a, 'b>(x: *mut &'a i32, y: *mut &'b i32) {\n+    x == y;\n+    //~^ ERROR lifetime may not live long enough\n+    //~| ERROR lifetime may not live long enough\n+}\n+\n+fn compare_fn_ptr<'a, 'b, 'c>(f: fn(&'c mut &'a i32), g: fn(&'c mut &'b i32)) {\n+    f == g;\n+    //~^ ERROR lifetime may not live long enough\n+    //~| ERROR lifetime may not live long enough\n+}\n+\n+fn compare_hr_fn_ptr<'a>(f: fn(&'a i32), g: fn(&i32)) {\n+    // Ideally this should compile with the operands swapped as well, but HIR\n+    // type checking prevents it (and stops compilation) for now.\n+    f == g; // OK\n+}\n+\n+fn compare_const_fn_ptr<'a>(f: *const fn(&'a i32), g: *const fn(&i32)) {\n+    f == g; // OK\n+}\n+\n+fn main() {}"}, {"sha": "c0a994cfb6381d9464649782286d3f5d28153266", "filename": "src/test/ui/nll/type-check-pointer-comparisons.stderr", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-comparisons.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2cfd6444a7fb4bd6acef2b97ba53059adc0500a6/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-comparisons.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-comparisons.stderr?ref=2cfd6444a7fb4bd6acef2b97ba53059adc0500a6", "patch": "@@ -0,0 +1,62 @@\n+error: lifetime may not live long enough\n+  --> $DIR/type-check-pointer-comparisons.rs:6:5\n+   |\n+LL | fn compare_const<'a, 'b>(x: *const &mut &'a i32, y: *const &mut &'b i32) {\n+   |                  --  -- lifetime `'b` defined here\n+   |                  |\n+   |                  lifetime `'a` defined here\n+LL |     x == y;\n+   |     ^ requires that `'a` must outlive `'b`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/type-check-pointer-comparisons.rs:6:10\n+   |\n+LL | fn compare_const<'a, 'b>(x: *const &mut &'a i32, y: *const &mut &'b i32) {\n+   |                  --  -- lifetime `'b` defined here\n+   |                  |\n+   |                  lifetime `'a` defined here\n+LL |     x == y;\n+   |          ^ requires that `'b` must outlive `'a`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/type-check-pointer-comparisons.rs:12:5\n+   |\n+LL | fn compare_mut<'a, 'b>(x: *mut &'a i32, y: *mut &'b i32) {\n+   |                --  -- lifetime `'b` defined here\n+   |                |\n+   |                lifetime `'a` defined here\n+LL |     x == y;\n+   |     ^ requires that `'a` must outlive `'b`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/type-check-pointer-comparisons.rs:12:10\n+   |\n+LL | fn compare_mut<'a, 'b>(x: *mut &'a i32, y: *mut &'b i32) {\n+   |                --  -- lifetime `'b` defined here\n+   |                |\n+   |                lifetime `'a` defined here\n+LL |     x == y;\n+   |          ^ requires that `'b` must outlive `'a`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/type-check-pointer-comparisons.rs:18:5\n+   |\n+LL | fn compare_fn_ptr<'a, 'b, 'c>(f: fn(&'c mut &'a i32), g: fn(&'c mut &'b i32)) {\n+   |                   --  -- lifetime `'b` defined here\n+   |                   |\n+   |                   lifetime `'a` defined here\n+LL |     f == g;\n+   |     ^ requires that `'a` must outlive `'b`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/type-check-pointer-comparisons.rs:18:10\n+   |\n+LL | fn compare_fn_ptr<'a, 'b, 'c>(f: fn(&'c mut &'a i32), g: fn(&'c mut &'b i32)) {\n+   |                   --  -- lifetime `'b` defined here\n+   |                   |\n+   |                   lifetime `'a` defined here\n+LL |     f == g;\n+   |          ^ requires that `'b` must outlive `'a`\n+\n+error: aborting due to 6 previous errors\n+"}]}