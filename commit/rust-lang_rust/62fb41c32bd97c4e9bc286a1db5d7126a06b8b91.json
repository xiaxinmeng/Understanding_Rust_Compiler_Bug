{"sha": "62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyZmI0MWMzMmJkOTdjNGU5YmMyODZhMWRiNWQ3MTI2YTA2YjhiOTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-23T02:41:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-23T02:41:48Z"}, "message": "auto merge of #20145 : alexcrichton/rust/rollup, r=alexcrichton", "tree": {"sha": "fc1c7ab2bf1a29879d45235acaf0126ceae4d107", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc1c7ab2bf1a29879d45235acaf0126ceae4d107"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "html_url": "https://github.com/rust-lang/rust/commit/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f3cff6956d56048ef7afb6d33e17cbdb2dcf038", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f3cff6956d56048ef7afb6d33e17cbdb2dcf038", "html_url": "https://github.com/rust-lang/rust/commit/2f3cff6956d56048ef7afb6d33e17cbdb2dcf038"}, {"sha": "3583d613b9c81855feb067aeeebb525cf8a4184c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3583d613b9c81855feb067aeeebb525cf8a4184c", "html_url": "https://github.com/rust-lang/rust/commit/3583d613b9c81855feb067aeeebb525cf8a4184c"}], "stats": {"total": 11836, "additions": 6311, "deletions": 5525}, "files": [{"sha": "9aa09ac1763561e527850a0781c2bb4852fb6b06", "filename": "AUTHORS.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/AUTHORS.txt", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/AUTHORS.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/AUTHORS.txt?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -498,6 +498,7 @@ Robert Irelan <rirelan@gmail.com>\n Robert Knight <robertknight@gmail.com>\n Robert Millar <robert.millar@cantab.net>\n Roland Tanglao <roland@rolandtanglao.com>\n+Rolf Timmermans <r.w.timmermans@gmail.com>\n Ron Dahlgren <ronald.dahlgren@gmail.com>\n Roy Frostig <rfrostig@mozilla.com>\n Russell <rpjohnst@gmail.com>"}, {"sha": "4457ac8cce7e31fe39686105b38d1cdb72af7fab", "filename": "man/rustc.1", "status": "modified", "additions": 79, "deletions": 52, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/man%2Frustc.1", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/man%2Frustc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/man%2Frustc.1?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -12,75 +12,54 @@ This program is a compiler for the Rust language, available at\n .SH OPTIONS\n \n .TP\n-\\fB\\-\\-crate-name NAME\\fR\n-Specify the name of the crate being built\n-.TP\n-\\fB\\-\\-crate-type=[bin|lib|dylib|rlib|staticlib]\\fR\n-Configure the flavor of rust crate that is generated (default `bin`)\n+\\fB\\-h\\fR, \\fB\\-\\-help\\fR\n+Display the help message\n .TP\n \\fB\\-\\-cfg\\fR SPEC\n Configure the compilation environment\n .TP\n-\\fB\\-\\-emit=[asm,ir,bc,obj,link]\\fR\n-Configure the output that rustc will produce\n-.TP\n-\\fB\\-h\\fR, \\fB\\-\\-help\\fR\n-Display this message\n-.TP\n \\fB\\-L\\fR PATH\n Add a directory to the library search path\n .TP\n-\\fB\\-\\-no\\-trans\\fR\n-Run all passes except translation; no output\n+\\fB\\-l\\fR NAME[:KIND]\n+Link the generated crate(s) to the specified native library NAME. The optional\n+KIND can be one of, static, dylib, or framework. If omitted, dylib is assumed.\n .TP\n-\\fB\\-\\-no\\-analysis\\fR\n-Parse and expand the source, but run no analysis and produce no output\n+\\fB\\-\\-crate-type\\fR [bin|lib|rlib|dylib|staticlib]\n+Comma separated list of types of crates for the compiler to emit\n .TP\n-\\fB\\-g\\fR\n-Emit DWARF debug information into object files generated.\n+\\fB\\-\\-crate-name NAME\\fR\n+Specify the name of the crate being built\n .TP\n-\\fB\\-\\-debuginfo\\fR LEVEL\n-Emit DWARF debug info to the objects created: 0 = no debug info, 1 =\n-line-tables only (for stacktraces and breakpoints), 2 = full debug\n-info with variable and type information (same as -g).\n+\\fB\\-\\-emit\\fR [asm|llvm-bc|llvm-ir|obj|link|dep-info]\n+Configure the output that rustc will produce\n+.TP\n+\\fB\\-\\-print\\fR [crate-name|output-file-names|sysroot]\n+Comma separated list of compiler information to print on stdout\n+.TP\n+\\fB\\-g\\fR\n+Equivalent to \\fI\\-C\\fR debuginfo=2\n .TP\n \\fB\\-O\\fR\n-Equivalent to \\fI\\-\\-opt\\-level=2\\fR\n+Equivalent to \\fI\\-C\\fR opt-level=2\n .TP\n \\fB\\-o\\fR FILENAME\n-Write output to <filename>. Ignored if more than one --emit is specified.\n-.TP\n-\\fB\\-\\-opt\\-level\\fR LEVEL\n-Optimize with possible levels 0-3\n+Write output to <filename>. Ignored if multiple \\fI\\-\\-emit\\fR outputs are\n+specified.\n .TP\n \\fB\\-\\-out\\-dir\\fR DIR\n-Write output to compiler-chosen filename in <dir>. Ignored if -o is specified.\n-(default the current directory)\n-.TP\n-\\fB\\-\\-parse\\-only\\fR\n-Parse only; do not compile, assemble, or link\n+Write output to compiler-chosen filename in <dir>. Ignored if \\fI\\-o\\fR is\n+specified. Defaults to the current directory.\n .TP\n-\\fB\\-\\-pretty\\fR [TYPE]\n-Pretty-print the input instead of compiling; valid types are: normal\n-(un-annotated source), expanded (crates expanded), typed (crates\n-expanded, with type annotations), identified (fully parenthesized,\n-AST nodes and blocks with IDs), or flowgraph=<nodeid> (graphviz\n-formatted flowgraph for node)\n-.TP\n-\\fB\\-\\-dep-info\\fR [FILENAME]\n-Output dependency info to <filename> after compiling, in a format suitable\n-for use by Makefiles.\n-.TP\n-\\fB\\-\\-sysroot\\fR PATH\n-Override the system root\n+\\fB\\-\\-explain\\fR OPT\n+Provide a detailed explanation of an error message\n .TP\n \\fB\\-\\-test\\fR\n Build a test harness\n .TP\n \\fB\\-\\-target\\fR TRIPLE\n-Target triple cpu-manufacturer-kernel[-os] to compile for (see\n-http://sources.redhat.com/autobook/autobook/autobook_17.html\n-for details)\n+Target triple cpu-manufacturer-kernel[-os] to compile for (see chapter 3.4 of\n+http://www.sourceware.org/autobook/ for details)\n .TP\n \\fB\\-W\\fR help\n Print 'lint' options and default settings\n@@ -97,15 +76,30 @@ Set lint denied\n \\fB\\-F\\fR OPT, \\fB\\-\\-forbid\\fR OPT\n Set lint forbidden\n .TP\n-\\fB\\-Z\\fR FLAG\n-Set internal debugging options. Use \"-Z help\" to print available options.\n-.TP\n \\fB\\-C\\fR FLAG[=VAL], \\fB\\-\\-codegen\\fR FLAG[=VAL]\n Set a codegen-related flag to the value specified. Use \"-C help\" to print\n available flags. See CODEGEN OPTIONS below\n .TP\n-\\fB\\-v\\fR, \\fB\\-\\-version\\fR\n+\\fB\\-V\\fR, \\fB\\-\\-version\\fR\n Print version info and exit\n+.TP\n+\\fB\\-v\\fR, \\fB\\-\\-verbose\\fR\n+Use verbose output\n+.TP\n+\\fB\\-\\-extern\\fR NAME=PATH\n+Specify where an external rust library is located\n+.TP\n+\\fB\\-\\-sysroot\\fR PATH\n+Override the system root\n+.TP\n+\\fB\\-Z\\fR FLAG\n+Set internal debugging options. Use \"-Z help\" to print available options.\n+.TP\n+\\fB\\-\\-color\\fR auto|always|never\n+Configure coloring of output:\n+    auto = colorize, if output goes to a tty (default);\n+    always = always colorize output;\n+    never = never colorize output\n \n .SH CODEGEN OPTIONS\n \n@@ -121,6 +115,9 @@ objects.\n A space-separated list of extra arguments to pass to the linker when the linker\n is invoked.\n .TP\n+\\fBlto\\fR\n+Perform LLVM link-time optimizations.\n+.TP\n \\fBtarget-cpu\\fR=help\n Selects a target processor. If the value is 'help', then a list of available\n CPUs is printed.\n@@ -167,8 +164,38 @@ Prefers dynamic linking to static linking.\n \\fBno-integrated-as\\fR\n Force usage of an external assembler rather than LLVM's integrated one.\n .TP\n+\\fBno-redzone\\fR\n+Disable the use of the redzone.\n+.TP\n \\fBrelocation-model\\fR=[pic,static,dynamic-no-pic]\n-The relocation model to use. (default: pic)\n+The relocation model to use. (Default: pic)\n+.TP\n+\\fBcode-model\\fR=[small,kernel,medium,large]\n+Choose the code model to use.\n+.TP\n+\\fBmetadata\\fR=val\n+Metadata to mangle symbol names with.\n+.TP\n+\\fBextra-filename\\fR=val\n+Extra data to put in each output filename.\n+.TP\n+\\fBcodegen-units\\fR=val\n+Divide crate into N units to optimize in parallel.\n+.TP\n+\\fBremark\\fR=val\n+Print remarks for these optimization passes (space separated, or \"all\").\n+.TP\n+\\fBno-stack-check\\fR\n+Disable checks for stack exhaustion (a memory-safety hazard!).\n+.TP\n+\\fBdebuginfo\\fR=val\n+Debug info emission level:\n+    0 = no debug info;\n+    1 = line-tables only (for stacktraces and breakpoints);\n+    2 = full debug info with variable and type information.\n+.TP\n+\\fBopt-level\\fR=val\n+Optimize with possible levels 0-3\n \n .SH \"EXAMPLES\"\n To build an executable from a source file with a main function:"}, {"sha": "a1d18aae1b45948fbdcbdad8a9fd9f58f1a4fd04", "filename": "mk/rt.mk", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -35,7 +35,7 @@\n # that's per-target so you're allowed to conditionally add files based on the\n # target.\n ################################################################################\n-NATIVE_LIBS := rust_builtin hoedown morestack miniz context_switch \\\n+NATIVE_LIBS := rust_builtin hoedown morestack miniz \\\n \t\trustrt_native rust_test_helpers\n \n # $(1) is the target triple\n@@ -58,8 +58,7 @@ NATIVE_DEPS_rustrt_native_$(1) := \\\n \t\t\tarch/$$(HOST_$(1))/record_sp.S\n NATIVE_DEPS_rust_test_helpers_$(1) := rust_test_helpers.c\n NATIVE_DEPS_morestack_$(1) := arch/$$(HOST_$(1))/morestack.S\n-NATIVE_DEPS_context_switch_$(1) := \\\n-\t\t\tarch/$$(HOST_$(1))/_context.S\n+\n \n ################################################################################\n # You shouldn't find it that necessary to edit anything below this line."}, {"sha": "bdbfbfd7c89d60a9e1933b94c312ebc362ede8d2", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -152,7 +152,7 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n             matches.opt_str(\"ratchet-metrics\").map(|s| Path::new(s)),\n         ratchet_noise_percent:\n             matches.opt_str(\"ratchet-noise-percent\")\n-                   .and_then(|s| from_str::<f64>(s.as_slice())),\n+                   .and_then(|s| s.as_slice().parse::<f64>()),\n         runtool: matches.opt_str(\"runtool\"),\n         host_rustcflags: matches.opt_str(\"host-rustcflags\"),\n         target_rustcflags: matches.opt_str(\"target-rustcflags\"),\n@@ -190,9 +190,7 @@ pub fn log_config(config: &Config) {\n     logv(c, format!(\"filter: {}\",\n                     opt_str(&config.filter\n                                    .as_ref()\n-                                   .map(|re| {\n-                                       re.to_string().into_string()\n-                                   }))));\n+                                   .map(|re| re.to_string()))));\n     logv(c, format!(\"runtool: {}\", opt_str(&config.runtool)));\n     logv(c, format!(\"host-rustcflags: {}\",\n                     opt_str(&config.host_rustcflags)));"}, {"sha": "27be6c6d8356889e700203280c56e285e476364f", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -351,8 +351,8 @@ pub fn gdb_version_to_int(version_string: &str) -> int {\n         panic!(\"{}\", error_string);\n     }\n \n-    let major: int = from_str(components[0]).expect(error_string);\n-    let minor: int = from_str(components[1]).expect(error_string);\n+    let major: int = components[0].parse().expect(error_string);\n+    let minor: int = components[1].parse().expect(error_string);\n \n     return major * 1000 + minor;\n }\n@@ -362,6 +362,6 @@ pub fn lldb_version_to_int(version_string: &str) -> int {\n         \"Encountered LLDB version string with unexpected format: {}\",\n         version_string);\n     let error_string = error_string.as_slice();\n-    let major: int = from_str(version_string).expect(error_string);\n+    let major: int = version_string.parse().expect(error_string);\n     return major;\n }"}, {"sha": "bf72250c4705af70e5e43d64cf8eafb9f4e8e917", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -1361,7 +1361,7 @@ fn split_maybe_args(argstr: &Option<String>) -> Vec<String> {\n             s.as_slice()\n              .split(' ')\n              .filter_map(|s| {\n-                 if s.is_whitespace() {\n+                 if s.chars().all(|c| c.is_whitespace()) {\n                      None\n                  } else {\n                      Some(s.to_string())"}, {"sha": "22cbd18a86520a46f8b9c2998ae28fc8b53f32c9", "filename": "src/doc/guide.md", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -1010,8 +1010,8 @@ in the original declaration.\n Finally, because fields have names, we can access the field through dot\n notation: `origin.x`.\n \n-The values in structs are immutable, like other bindings in Rust. However, you\n-can use `mut` to make them mutable:\n+The values in structs are immutable by default, like other bindings in Rust.\n+Use `mut` to make them mutable:\n \n ```{rust}\n struct Point {\n@@ -2257,10 +2257,10 @@ a function for that:\n let input = io::stdin().read_line()\n                        .ok()\n                        .expect(\"Failed to read line\");\n-let input_num: Option<uint> = from_str(input.as_slice());\n+let input_num: Option<uint> = input.parse();\n ```\n \n-The `from_str` function takes in a `&str` value and converts it into something.\n+The `parse` function takes in a `&str` value and converts it into something.\n We tell it what kind of something with a type hint. Remember our type hint with\n `random()`? It looked like this:\n \n@@ -2279,8 +2279,8 @@ In this case, we say `x` is a `uint` explicitly, so Rust is able to properly\n tell `random()` what to generate. In a similar fashion, both of these work:\n \n ```{rust,ignore}\n-let input_num = from_str::<uint>(\"5\");       // input_num: Option<uint>\n-let input_num: Option<uint> = from_str(\"5\"); // input_num: Option<uint>\n+let input_num = \"5\".parse::<uint>();         // input_num: Option<uint>\n+let input_num: Option<uint> = \"5\".parse();   // input_num: Option<uint>\n ```\n \n Anyway, with us now converting our input to a number, our code looks like this:\n@@ -2301,7 +2301,7 @@ fn main() {\n     let input = io::stdin().read_line()\n                            .ok()\n                            .expect(\"Failed to read line\");\n-    let input_num: Option<uint> = from_str(input.as_slice());\n+    let input_num: Option<uint> = input.parse();\n \n     println!(\"You guessed: {}\", input_num);\n \n@@ -2350,7 +2350,7 @@ fn main() {\n     let input = io::stdin().read_line()\n                            .ok()\n                            .expect(\"Failed to read line\");\n-    let input_num: Option<uint> = from_str(input.as_slice());\n+    let input_num: Option<uint> = input.parse();\n \n     let num = match input_num {\n         Some(num) => num,\n@@ -2395,7 +2395,7 @@ Uh, what? But we did!\n \n ... actually, we didn't. See, when you get a line of input from `stdin()`,\n you get all the input. Including the `\\n` character from you pressing Enter.\n-Therefore, `from_str()` sees the string `\"5\\n\"` and says \"nope, that's not a\n+Therefore, `parse()` sees the string `\"5\\n\"` and says \"nope, that's not a\n number; there's non-number stuff in there!\" Luckily for us, `&str`s have an easy\n method we can use defined on them: `trim()`. One small modification, and our\n code looks like this:\n@@ -2416,7 +2416,7 @@ fn main() {\n     let input = io::stdin().read_line()\n                            .ok()\n                            .expect(\"Failed to read line\");\n-    let input_num: Option<uint> = from_str(input.as_slice().trim());\n+    let input_num: Option<uint> = input.trim().parse();\n \n     let num = match input_num {\n         Some(num) => num,\n@@ -2491,7 +2491,7 @@ fn main() {\n         let input = io::stdin().read_line()\n                                .ok()\n                                .expect(\"Failed to read line\");\n-        let input_num: Option<uint> = from_str(input.as_slice().trim());\n+        let input_num: Option<uint> = input.trim().parse();\n \n         let num = match input_num {\n             Some(num) => num,\n@@ -2566,7 +2566,7 @@ fn main() {\n         let input = io::stdin().read_line()\n                                .ok()\n                                .expect(\"Failed to read line\");\n-        let input_num: Option<uint> = from_str(input.as_slice().trim());\n+        let input_num: Option<uint> = input.trim().parse();\n \n         let num = match input_num {\n             Some(num) => num,\n@@ -2621,7 +2621,7 @@ fn main() {\n         let input = io::stdin().read_line()\n                                .ok()\n                                .expect(\"Failed to read line\");\n-        let input_num: Option<uint> = from_str(input.as_slice().trim());\n+        let input_num: Option<uint> = input.trim().parse();\n \n         let num = match input_num {\n             Some(num) => num,\n@@ -2697,7 +2697,7 @@ fn main() {\n         let input = io::stdin().read_line()\n                                .ok()\n                                .expect(\"Failed to read line\");\n-        let input_num: Option<uint> = from_str(input.as_slice().trim());\n+        let input_num: Option<uint> = input.trim().parse();\n \n         let num = match input_num {\n             Some(num) => num,"}, {"sha": "97184d534983c48fc16ffc7489448da7d221447a", "filename": "src/doc/reference.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -3177,7 +3177,7 @@ Some examples of call expressions:\n # fn add(x: int, y: int) -> int { 0 }\n \n let x: int = add(1, 2);\n-let pi: Option<f32> = from_str(\"3.14\");\n+let pi: Option<f32> = \"3.14\".parse();\n ```\n \n ### Lambda expressions"}, {"sha": "589e580cc912129fa5257763c567c7a0210be787", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 37, "deletions": 36, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -239,8 +239,8 @@ impl<T: Ord> BinaryHeap<T> {\n     /// }\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter(&self) -> Items<T> {\n-        Items { iter: self.data.iter() }\n+    pub fn iter(&self) -> Iter<T> {\n+        Iter { iter: self.data.iter() }\n     }\n \n     /// Creates a consuming iterator, that is, one that moves each value out of\n@@ -260,8 +260,8 @@ impl<T: Ord> BinaryHeap<T> {\n     /// }\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn into_iter(self) -> MoveItems<T> {\n-        MoveItems { iter: self.data.into_iter() }\n+    pub fn into_iter(self) -> IntoIter<T> {\n+        IntoIter { iter: self.data.into_iter() }\n     }\n \n     /// Returns the greatest item in a queue, or `None` if it is empty.\n@@ -272,15 +272,16 @@ impl<T: Ord> BinaryHeap<T> {\n     /// use std::collections::BinaryHeap;\n     ///\n     /// let mut heap = BinaryHeap::new();\n-    /// assert_eq!(heap.top(), None);\n+    /// assert_eq!(heap.peek(), None);\n     ///\n     /// heap.push(1i);\n     /// heap.push(5i);\n     /// heap.push(2i);\n-    /// assert_eq!(heap.top(), Some(&5i));\n+    /// assert_eq!(heap.peek(), Some(&5i));\n     ///\n     /// ```\n-    pub fn top(&self) -> Option<&T> {\n+    #[stable]\n+    pub fn peek(&self) -> Option<&T> {\n         self.data.get(0)\n     }\n \n@@ -388,7 +389,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// heap.push(1i);\n     ///\n     /// assert_eq!(heap.len(), 3);\n-    /// assert_eq!(heap.top(), Some(&5i));\n+    /// assert_eq!(heap.peek(), Some(&5i));\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn push(&mut self, item: T) {\n@@ -412,7 +413,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(heap.push_pop(3i), 5);\n     /// assert_eq!(heap.push_pop(9i), 9);\n     /// assert_eq!(heap.len(), 2);\n-    /// assert_eq!(heap.top(), Some(&3i));\n+    /// assert_eq!(heap.peek(), Some(&3i));\n     /// ```\n     pub fn push_pop(&mut self, mut item: T) -> T {\n         match self.data.get_mut(0) {\n@@ -442,7 +443,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(heap.replace(1i), None);\n     /// assert_eq!(heap.replace(3i), Some(1i));\n     /// assert_eq!(heap.len(), 1);\n-    /// assert_eq!(heap.top(), Some(&3i));\n+    /// assert_eq!(heap.peek(), Some(&3i));\n     /// ```\n     pub fn replace(&mut self, mut item: T) -> Option<T> {\n         if !self.is_empty() {\n@@ -571,44 +572,44 @@ impl<T: Ord> BinaryHeap<T> {\n }\n \n /// `BinaryHeap` iterator.\n-pub struct Items<'a, T: 'a> {\n-    iter: slice::Items<'a, T>,\n+pub struct Iter <'a, T: 'a> {\n+    iter: slice::Iter<'a, T>,\n }\n \n-impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n+impl<'a, T> Iterator<&'a T> for Iter<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n \n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-impl<'a, T> DoubleEndedIterator<&'a T> for Items<'a, T> {\n+impl<'a, T> DoubleEndedIterator<&'a T> for Iter<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a T> { self.iter.next_back() }\n }\n \n-impl<'a, T> ExactSizeIterator<&'a T> for Items<'a, T> {}\n+impl<'a, T> ExactSizeIterator<&'a T> for Iter<'a, T> {}\n \n /// An iterator that moves out of a `BinaryHeap`.\n-pub struct MoveItems<T> {\n-    iter: vec::MoveItems<T>,\n+pub struct IntoIter<T> {\n+    iter: vec::IntoIter<T>,\n }\n \n-impl<T> Iterator<T> for MoveItems<T> {\n+impl<T> Iterator<T> for IntoIter<T> {\n     #[inline]\n     fn next(&mut self) -> Option<T> { self.iter.next() }\n \n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-impl<T> DoubleEndedIterator<T> for MoveItems<T> {\n+impl<T> DoubleEndedIterator<T> for IntoIter<T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n }\n \n-impl<T> ExactSizeIterator<T> for MoveItems<T> {}\n+impl<T> ExactSizeIterator<T> for IntoIter<T> {}\n \n /// An iterator that drains a `BinaryHeap`.\n pub struct Drain<'a, T: 'a> {\n@@ -714,13 +715,13 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_top_and_pop() {\n+    fn test_peek_and_pop() {\n         let data = vec!(2u, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1);\n         let mut sorted = data.clone();\n         sorted.sort();\n         let mut heap = BinaryHeap::from_vec(data);\n         while !heap.is_empty() {\n-            assert_eq!(heap.top().unwrap(), sorted.last().unwrap());\n+            assert_eq!(heap.peek().unwrap(), sorted.last().unwrap());\n             assert_eq!(heap.pop().unwrap(), sorted.pop().unwrap());\n         }\n     }\n@@ -729,44 +730,44 @@ mod tests {\n     fn test_push() {\n         let mut heap = BinaryHeap::from_vec(vec!(2i, 4, 9));\n         assert_eq!(heap.len(), 3);\n-        assert!(*heap.top().unwrap() == 9);\n+        assert!(*heap.peek().unwrap() == 9);\n         heap.push(11);\n         assert_eq!(heap.len(), 4);\n-        assert!(*heap.top().unwrap() == 11);\n+        assert!(*heap.peek().unwrap() == 11);\n         heap.push(5);\n         assert_eq!(heap.len(), 5);\n-        assert!(*heap.top().unwrap() == 11);\n+        assert!(*heap.peek().unwrap() == 11);\n         heap.push(27);\n         assert_eq!(heap.len(), 6);\n-        assert!(*heap.top().unwrap() == 27);\n+        assert!(*heap.peek().unwrap() == 27);\n         heap.push(3);\n         assert_eq!(heap.len(), 7);\n-        assert!(*heap.top().unwrap() == 27);\n+        assert!(*heap.peek().unwrap() == 27);\n         heap.push(103);\n         assert_eq!(heap.len(), 8);\n-        assert!(*heap.top().unwrap() == 103);\n+        assert!(*heap.peek().unwrap() == 103);\n     }\n \n     #[test]\n     fn test_push_unique() {\n         let mut heap = BinaryHeap::from_vec(vec!(box 2i, box 4, box 9));\n         assert_eq!(heap.len(), 3);\n-        assert!(*heap.top().unwrap() == box 9);\n+        assert!(*heap.peek().unwrap() == box 9);\n         heap.push(box 11);\n         assert_eq!(heap.len(), 4);\n-        assert!(*heap.top().unwrap() == box 11);\n+        assert!(*heap.peek().unwrap() == box 11);\n         heap.push(box 5);\n         assert_eq!(heap.len(), 5);\n-        assert!(*heap.top().unwrap() == box 11);\n+        assert!(*heap.peek().unwrap() == box 11);\n         heap.push(box 27);\n         assert_eq!(heap.len(), 6);\n-        assert!(*heap.top().unwrap() == box 27);\n+        assert!(*heap.peek().unwrap() == box 27);\n         heap.push(box 3);\n         assert_eq!(heap.len(), 7);\n-        assert!(*heap.top().unwrap() == box 27);\n+        assert!(*heap.peek().unwrap() == box 27);\n         heap.push(box 103);\n         assert_eq!(heap.len(), 8);\n-        assert!(*heap.top().unwrap() == box 103);\n+        assert!(*heap.peek().unwrap() == box 103);\n     }\n \n     #[test]\n@@ -831,9 +832,9 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_empty_top() {\n+    fn test_empty_peek() {\n         let empty = BinaryHeap::<int>::new();\n-        assert!(empty.top().is_none());\n+        assert!(empty.peek().is_none());\n     }\n \n     #[test]"}, {"sha": "430d7210bf69b105be1a6ef4032974562548213b", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 967, "deletions": 769, "changes": 1736, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -8,8 +8,25 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// FIXME(Gankro): Bitv and BitvSet are very tightly coupled. Ideally (for maintenance),\n-// they should be in separate files/modules, with BitvSet only using Bitv's public API.\n+// FIXME(Gankro): Bitv and BitvSet are very tightly coupled. Ideally (for\n+// maintenance), they should be in separate files/modules, with BitvSet only\n+// using Bitv's public API. This will be hard for performance though, because\n+// `Bitv` will not want to leak its internal representation while its internal\n+// representation as `u32`s must be assumed for best performance.\n+\n+// FIXME(tbu-): `Bitv`'s methods shouldn't be `union`, `intersection`, but\n+// rather `or` and `and`.\n+\n+// (1) Be careful, most things can overflow here because the amount of bits in\n+//     memory can overflow `uint`.\n+// (2) Make sure that the underlying vector has no excess length:\n+//     E. g. `nbits == 16`, `storage.len() == 2` would be excess length,\n+//     because the last word isn't used at all. This is important because some\n+//     methods rely on it (for *CORRECTNESS*).\n+// (3) Make sure that the unused bits in the last word are zeroed out, again\n+//     other methods rely on it for *CORRECTNESS*.\n+// (4) `BitvSet` is tightly coupled with `Bitv`, so any changes you make in\n+// `Bitv` will need to be reflected in `BitvSet`.\n \n //! Collections implemented with bit vectors.\n //!\n@@ -31,7 +48,7 @@\n //! let primes = {\n //!     // Assume all numbers are prime to begin, and then we\n //!     // cross off non-primes progressively\n-//!     let mut bv = Bitv::with_capacity(max_prime, true);\n+//!     let mut bv = Bitv::from_elem(max_prime, true);\n //!\n //!     // Neither 0 nor 1 are prime\n //!     bv.set(0, false);\n@@ -68,18 +85,27 @@ use core::prelude::*;\n use core::cmp;\n use core::default::Default;\n use core::fmt;\n-use core::iter::{Chain, Enumerate, Repeat, Skip, Take, repeat};\n+use core::iter::{Cloned, Chain, Enumerate, Repeat, Skip, Take};\n use core::iter;\n use core::num::Int;\n-use core::slice;\n-use core::u32;\n-use std::hash;\n+use core::slice::{Iter, IterMut};\n+use core::{u8, u32, uint};\n \n-use vec::Vec;\n+use core::hash;\n+use Vec;\n \n-// FIXME(conventions): look, we just need to refactor this whole thing. Inside and out.\n+type Blocks<'a> = Cloned<Iter<'a, u32>>;\n+type MutBlocks<'a> = IterMut<'a, u32>;\n+type MatchWords<'a> = Chain<Enumerate<Blocks<'a>>, Skip<Take<Enumerate<Repeat<u32>>>>>;\n+\n+fn reverse_bits(byte: u8) -> u8 {\n+    let mut result = 0;\n+    for i in range(0, u8::BITS) {\n+        result |= ((byte >> i) & 1) << (u8::BITS - 1 - i);\n+    }\n+    result\n+}\n \n-type MatchWords<'a> = Chain<MaskWords<'a>, Skip<Take<Enumerate<Repeat<u32>>>>>;\n // Take two BitV's, and return iterators of their words, where the shorter one\n // has been padded with 0's\n fn match_words <'a,'b>(a: &'a Bitv, b: &'b Bitv) -> (MatchWords<'a>, MatchWords<'b>) {\n@@ -88,11 +114,11 @@ fn match_words <'a,'b>(a: &'a Bitv, b: &'b Bitv) -> (MatchWords<'a>, MatchWords<\n \n     // have to uselessly pretend to pad the longer one for type matching\n     if a_len < b_len {\n-        (a.mask_words(0).chain(repeat(0u32).enumerate().take(b_len).skip(a_len)),\n-         b.mask_words(0).chain(repeat(0u32).enumerate().take(0).skip(0)))\n+        (a.blocks().enumerate().chain(iter::repeat(0u32).enumerate().take(b_len).skip(a_len)),\n+         b.blocks().enumerate().chain(iter::repeat(0u32).enumerate().take(0).skip(0)))\n     } else {\n-        (a.mask_words(0).chain(repeat(0u32).enumerate().take(0).skip(0)),\n-         b.mask_words(0).chain(repeat(0u32).enumerate().take(a_len).skip(b_len)))\n+        (a.blocks().enumerate().chain(iter::repeat(0u32).enumerate().take(0).skip(0)),\n+         b.blocks().enumerate().chain(iter::repeat(0u32).enumerate().take(a_len).skip(b_len)))\n     }\n }\n \n@@ -106,7 +132,7 @@ static FALSE: bool = false;\n /// ```rust\n /// use collections::Bitv;\n ///\n-/// let mut bv = Bitv::with_capacity(10, false);\n+/// let mut bv = Bitv::from_elem(10, false);\n ///\n /// // insert all primes less than 10\n /// bv.set(2, true);\n@@ -133,57 +159,52 @@ pub struct Bitv {\n     nbits: uint\n }\n \n+// FIXME(Gankro): NopeNopeNopeNopeNope (wait for IndexGet to be a thing)\n impl Index<uint,bool> for Bitv {\n     #[inline]\n     fn index<'a>(&'a self, i: &uint) -> &'a bool {\n-        if self.get(*i) {\n+        if self.get(*i).expect(\"index out of bounds\") {\n             &TRUE\n         } else {\n             &FALSE\n         }\n     }\n }\n \n-struct MaskWords<'a> {\n-    iter: slice::Items<'a, u32>,\n-    next_word: Option<&'a u32>,\n-    last_word_mask: u32,\n-    offset: uint\n+/// Computes how many blocks are needed to store that many bits\n+fn blocks_for_bits(bits: uint) -> uint {\n+    // If we want 17 bits, dividing by 32 will produce 0. So we add 1 to make sure we\n+    // reserve enough. But if we want exactly a multiple of 32, this will actually allocate\n+    // one too many. So we need to check if that's the case. We can do that by computing if\n+    // bitwise AND by `32 - 1` is 0. But LLVM should be able to optimize the semantically\n+    // superior modulo operator on a power of two to this.\n+    //\n+    // Note that we can technically avoid this branch with the expression\n+    // `(nbits + u32::BITS - 1) / 32::BITS`, but if nbits is almost uint::MAX this will overflow.\n+    if bits % u32::BITS == 0 {\n+        bits / u32::BITS\n+    } else {\n+        bits / u32::BITS + 1\n+    }\n }\n \n-impl<'a> Iterator<(uint, u32)> for MaskWords<'a> {\n-    /// Returns (offset, word)\n-    #[inline]\n-    fn next(&mut self) -> Option<(uint, u32)> {\n-        let ret = self.next_word;\n-        match ret {\n-            Some(&w) => {\n-                self.next_word = self.iter.next();\n-                self.offset += 1;\n-                // The last word may need to be masked\n-                if self.next_word.is_none() {\n-                    Some((self.offset - 1, w & self.last_word_mask))\n-                } else {\n-                    Some((self.offset - 1, w))\n-                }\n-            },\n-            None => None\n-        }\n-    }\n+/// Computes the bitmask for the final word of the vector\n+fn mask_for_bits(bits: uint) -> u32 {\n+    // Note especially that a perfect multiple of u32::BITS should mask all 1s.\n+    !0u32 >> (u32::BITS - bits % u32::BITS) % u32::BITS\n }\n \n impl Bitv {\n+    /// Applies the given operation to the blocks of self and other, and sets\n+    /// self to be the result. This relies on the caller not to corrupt the\n+    /// last word.\n     #[inline]\n     fn process<F>(&mut self, other: &Bitv, mut op: F) -> bool where F: FnMut(u32, u32) -> u32 {\n-        let len = other.storage.len();\n-        assert_eq!(self.storage.len(), len);\n+        assert_eq!(self.len(), other.len());\n+        // This could theoretically be a `debug_assert!`.\n+        assert_eq!(self.storage.len(), other.storage.len());\n         let mut changed = false;\n-        // Notice: `a` is *not* masked here, which is fine as long as\n-        // `op` is a bitwise operation, since any bits that should've\n-        // been masked were fine to change anyway. `b` is masked to\n-        // make sure its unmasked bits do not cause damage.\n-        for (a, (_, b)) in self.storage.iter_mut()\n-                           .zip(other.mask_words(0)) {\n+        for (a, b) in self.blocks_mut().zip(other.blocks()) {\n             let w = op(*a, b);\n             if *a != w {\n                 changed = true;\n@@ -193,22 +214,26 @@ impl Bitv {\n         changed\n     }\n \n-    #[inline]\n-    fn mask_words<'a>(&'a self, mut start: uint) -> MaskWords<'a> {\n-        if start > self.storage.len() {\n-            start = self.storage.len();\n-        }\n-        let mut iter = self.storage[start..].iter();\n-        MaskWords {\n-          next_word: iter.next(),\n-          iter: iter,\n-          last_word_mask: {\n-              let rem = self.nbits % u32::BITS;\n-              if rem > 0 {\n-                  (1 << rem) - 1\n-              } else { !0 }\n-          },\n-          offset: start\n+    /// Iterator over mutable refs to  the underlying blocks of data.\n+    fn blocks_mut(&mut self) -> MutBlocks {\n+        // (2)\n+        self.storage.iter_mut()\n+    }\n+\n+    /// Iterator over the underlying blocks of data\n+    fn blocks(&self) -> Blocks {\n+        // (2)\n+        self.storage.iter().cloned()\n+    }\n+\n+    /// An operation might screw up the unused bits in the last block of the\n+    /// `Bitv`. As per (3), it's assumed to be all 0s. This method fixes it up.\n+    fn fix_last_block(&mut self) {\n+        let extra_bits = self.len() % u32::BITS;\n+        if extra_bits > 0 {\n+            let mask = (1 << extra_bits) - 1;\n+            let storage_len = self.storage.len();\n+            self.storage[storage_len - 1] &= mask;\n         }\n     }\n \n@@ -226,61 +251,132 @@ impl Bitv {\n     }\n \n     /// Creates a `Bitv` that holds `nbits` elements, setting each element\n-    /// to `init`.\n+    /// to `bit`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::Bitv;\n     ///\n-    /// let mut bv = Bitv::with_capacity(10u, false);\n+    /// let mut bv = Bitv::from_elem(10u, false);\n     /// assert_eq!(bv.len(), 10u);\n     /// for x in bv.iter() {\n     ///     assert_eq!(x, false);\n     /// }\n     /// ```\n-    pub fn with_capacity(nbits: uint, init: bool) -> Bitv {\n+    pub fn from_elem(nbits: uint, bit: bool) -> Bitv {\n+        let nblocks = blocks_for_bits(nbits);\n         let mut bitv = Bitv {\n-            storage: Vec::from_elem((nbits + u32::BITS - 1) / u32::BITS,\n-                                    if init { !0u32 } else { 0u32 }),\n+            storage: Vec::from_elem(nblocks, if bit { !0u32 } else { 0u32 }),\n             nbits: nbits\n         };\n+        bitv.fix_last_block();\n+        bitv\n+    }\n+\n+    /// Constructs a new, empty `Bitv` with the specified capacity.\n+    ///\n+    /// The bitvector will be able to hold at least `capacity` bits without\n+    /// reallocating. If `capacity` is 0, it will not allocate.\n+    ///\n+    /// It is important to note that this function does not specify the\n+    /// *length* of the returned bitvector, but only the *capacity*.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn with_capacity(nbits: uint) -> Bitv {\n+        Bitv {\n+            storage: Vec::with_capacity(blocks_for_bits(nbits)),\n+            nbits: 0,\n+        }\n+    }\n+\n+    /// Transforms a byte-vector into a `Bitv`. Each byte becomes eight bits,\n+    /// with the most significant bits of each byte coming first. Each\n+    /// bit becomes `true` if equal to 1 or `false` if equal to 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::Bitv;\n+    ///\n+    /// let bv = Bitv::from_bytes(&[0b10100000, 0b00010010]);\n+    /// assert!(bv.eq_vec(&[true, false, true, false,\n+    ///                     false, false, false, false,\n+    ///                     false, false, false, true,\n+    ///                     false, false, true, false]));\n+    /// ```\n+    pub fn from_bytes(bytes: &[u8]) -> Bitv {\n+        let len = bytes.len().checked_mul(u8::BITS).expect(\"capacity overflow\");\n+        let mut bitv = Bitv::with_capacity(len);\n+        let complete_words = bytes.len() / 4;\n+        let extra_bytes = bytes.len() % 4;\n+\n+        bitv.nbits = len;\n+\n+        for i in range(0, complete_words) {\n+            bitv.storage.push(\n+                (reverse_bits(bytes[i * 4 + 0]) as u32 << 0) |\n+                (reverse_bits(bytes[i * 4 + 1]) as u32 << 8) |\n+                (reverse_bits(bytes[i * 4 + 2]) as u32 << 16) |\n+                (reverse_bits(bytes[i * 4 + 3]) as u32 << 24)\n+            );\n+        }\n \n-        // Zero out any unused bits in the highest word if necessary\n-        let used_bits = bitv.nbits % u32::BITS;\n-        if init && used_bits != 0 {\n-            let largest_used_word = (bitv.nbits + u32::BITS - 1) / u32::BITS - 1;\n-            bitv.storage[largest_used_word] &= (1 << used_bits) - 1;\n+        if extra_bytes > 0 {\n+            let mut last_word = 0u32;\n+            for (i, &byte) in bytes[complete_words*4..].iter().enumerate() {\n+                last_word |= reverse_bits(byte) as u32 << (i * 8);\n+            }\n+            bitv.storage.push(last_word);\n         }\n \n         bitv\n     }\n \n-    /// Retrieves the value at index `i`.\n+    /// Creates a `Bitv` of the specified length where the value at each index\n+    /// is `f(index)`.\n     ///\n-    /// # Panics\n+    /// # Examples\n     ///\n-    /// Panics if `i` is out of bounds.\n+    /// ```\n+    /// use std::collections::Bitv;\n+    ///\n+    /// let bv = Bitv::from_fn(5, |i| { i % 2 == 0 });\n+    /// assert!(bv.eq_vec(&[true, false, true, false, true]));\n+    /// ```\n+    pub fn from_fn<F>(len: uint, mut f: F) -> Bitv where F: FnMut(uint) -> bool {\n+        let mut bitv = Bitv::from_elem(len, false);\n+        for i in range(0u, len) {\n+            bitv.set(i, f(i));\n+        }\n+        bitv\n+    }\n+\n+    /// Retrieves the value at index `i`, or `None` if the index is out of bounds.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::bitv;\n+    /// use std::collections::Bitv;\n     ///\n-    /// let bv = bitv::from_bytes(&[0b01100000]);\n-    /// assert_eq!(bv.get(0), false);\n-    /// assert_eq!(bv.get(1), true);\n+    /// let bv = Bitv::from_bytes(&[0b01100000]);\n+    /// assert_eq!(bv.get(0), Some(false));\n+    /// assert_eq!(bv.get(1), Some(true));\n+    /// assert_eq!(bv.get(100), None);\n     ///\n     /// // Can also use array indexing\n     /// assert_eq!(bv[1], true);\n     /// ```\n     #[inline]\n-    pub fn get(&self, i: uint) -> bool {\n-        assert!(i < self.nbits);\n+    #[unstable = \"panic semantics are likely to change in the future\"]\n+    pub fn get(&self, i: uint) -> Option<bool> {\n+        if i >= self.nbits {\n+            return None;\n+        }\n         let w = i / u32::BITS;\n         let b = i % u32::BITS;\n-        let x = self.storage[w] & (1 << b);\n-        x != 0\n+        self.storage.get(w).map(|&block|\n+            (block & (1 << b)) != 0\n+        )\n     }\n \n     /// Sets the value of a bit at an index `i`.\n@@ -294,11 +390,12 @@ impl Bitv {\n     /// ```\n     /// use std::collections::Bitv;\n     ///\n-    /// let mut bv = Bitv::with_capacity(5, false);\n+    /// let mut bv = Bitv::from_elem(5, false);\n     /// bv.set(3, true);\n     /// assert_eq!(bv[3], true);\n     /// ```\n     #[inline]\n+    #[unstable = \"panic semantics are likely to change in the future\"]\n     pub fn set(&mut self, i: uint, x: bool) {\n         assert!(i < self.nbits);\n         let w = i / u32::BITS;\n@@ -314,37 +411,39 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::bitv;\n+    /// use std::collections::Bitv;\n     ///\n     /// let before = 0b01100000;\n     /// let after  = 0b11111111;\n     ///\n-    /// let mut bv = bitv::from_bytes(&[before]);\n+    /// let mut bv = Bitv::from_bytes(&[before]);\n     /// bv.set_all();\n-    /// assert_eq!(bv, bitv::from_bytes(&[after]));\n+    /// assert_eq!(bv, Bitv::from_bytes(&[after]));\n     /// ```\n     #[inline]\n     pub fn set_all(&mut self) {\n         for w in self.storage.iter_mut() { *w = !0u32; }\n+        self.fix_last_block();\n     }\n \n     /// Flips all bits.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::bitv;\n+    /// use std::collections::Bitv;\n     ///\n     /// let before = 0b01100000;\n     /// let after  = 0b10011111;\n     ///\n-    /// let mut bv = bitv::from_bytes(&[before]);\n+    /// let mut bv = Bitv::from_bytes(&[before]);\n     /// bv.negate();\n-    /// assert_eq!(bv, bitv::from_bytes(&[after]));\n+    /// assert_eq!(bv, Bitv::from_bytes(&[after]));\n     /// ```\n     #[inline]\n     pub fn negate(&mut self) {\n         for w in self.storage.iter_mut() { *w = !*w; }\n+        self.fix_last_block();\n     }\n \n     /// Calculates the union of two bitvectors. This acts like the bitwise `or`\n@@ -360,17 +459,17 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::bitv;\n+    /// use std::collections::Bitv;\n     ///\n     /// let a   = 0b01100100;\n     /// let b   = 0b01011010;\n     /// let res = 0b01111110;\n     ///\n-    /// let mut a = bitv::from_bytes(&[a]);\n-    /// let b = bitv::from_bytes(&[b]);\n+    /// let mut a = Bitv::from_bytes(&[a]);\n+    /// let b = Bitv::from_bytes(&[b]);\n     ///\n     /// assert!(a.union(&b));\n-    /// assert_eq!(a, bitv::from_bytes(&[res]));\n+    /// assert_eq!(a, Bitv::from_bytes(&[res]));\n     /// ```\n     #[inline]\n     pub fn union(&mut self, other: &Bitv) -> bool {\n@@ -390,17 +489,17 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::bitv;\n+    /// use std::collections::Bitv;\n     ///\n     /// let a   = 0b01100100;\n     /// let b   = 0b01011010;\n     /// let res = 0b01000000;\n     ///\n-    /// let mut a = bitv::from_bytes(&[a]);\n-    /// let b = bitv::from_bytes(&[b]);\n+    /// let mut a = Bitv::from_bytes(&[a]);\n+    /// let b = Bitv::from_bytes(&[b]);\n     ///\n     /// assert!(a.intersect(&b));\n-    /// assert_eq!(a, bitv::from_bytes(&[res]));\n+    /// assert_eq!(a, Bitv::from_bytes(&[res]));\n     /// ```\n     #[inline]\n     pub fn intersect(&mut self, other: &Bitv) -> bool {\n@@ -420,24 +519,24 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::bitv;\n+    /// use std::collections::Bitv;\n     ///\n     /// let a   = 0b01100100;\n     /// let b   = 0b01011010;\n     /// let a_b = 0b00100100; // a - b\n     /// let b_a = 0b00011010; // b - a\n     ///\n-    /// let mut bva = bitv::from_bytes(&[a]);\n-    /// let bvb = bitv::from_bytes(&[b]);\n+    /// let mut bva = Bitv::from_bytes(&[a]);\n+    /// let bvb = Bitv::from_bytes(&[b]);\n     ///\n     /// assert!(bva.difference(&bvb));\n-    /// assert_eq!(bva, bitv::from_bytes(&[a_b]));\n+    /// assert_eq!(bva, Bitv::from_bytes(&[a_b]));\n     ///\n-    /// let bva = bitv::from_bytes(&[a]);\n-    /// let mut bvb = bitv::from_bytes(&[b]);\n+    /// let bva = Bitv::from_bytes(&[a]);\n+    /// let mut bvb = Bitv::from_bytes(&[b]);\n     ///\n     /// assert!(bvb.difference(&bva));\n-    /// assert_eq!(bvb, bitv::from_bytes(&[b_a]));\n+    /// assert_eq!(bvb, Bitv::from_bytes(&[b_a]));\n     /// ```\n     #[inline]\n     pub fn difference(&mut self, other: &Bitv) -> bool {\n@@ -451,35 +550,37 @@ impl Bitv {\n     /// ```\n     /// use std::collections::Bitv;\n     ///\n-    /// let mut bv = Bitv::with_capacity(5, true);\n+    /// let mut bv = Bitv::from_elem(5, true);\n     /// assert_eq!(bv.all(), true);\n     ///\n     /// bv.set(1, false);\n     /// assert_eq!(bv.all(), false);\n     /// ```\n-    #[inline]\n     pub fn all(&self) -> bool {\n         let mut last_word = !0u32;\n-        // Check that every word but the last is all-ones...\n-        self.mask_words(0).all(|(_, elem)|\n-            { let tmp = last_word; last_word = elem; tmp == !0u32 }) &&\n-        // ...and that the last word is ones as far as it needs to be\n-        (last_word == ((1 << self.nbits % u32::BITS) - 1) || last_word == !0u32)\n+        // Check that every block but the last is all-ones...\n+        self.blocks().all(|elem| {\n+            let tmp = last_word;\n+            last_word = elem;\n+            tmp == !0u32\n+        // and then check the last one has enough ones\n+        }) && (last_word == mask_for_bits(self.nbits))\n     }\n \n     /// Returns an iterator over the elements of the vector in order.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::bitv;\n+    /// use std::collections::Bitv;\n     ///\n-    /// let bv = bitv::from_bytes(&[0b01110100, 0b10010010]);\n+    /// let bv = Bitv::from_bytes(&[0b01110100, 0b10010010]);\n     /// assert_eq!(bv.iter().filter(|x| *x).count(), 7);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter<'a>(&'a self) -> Bits<'a> {\n-        Bits {bitv: self, next_idx: 0, end_idx: self.nbits}\n+        Bits { bitv: self, next_idx: 0, end_idx: self.nbits }\n     }\n \n     /// Returns `true` if all bits are 0.\n@@ -489,14 +590,14 @@ impl Bitv {\n     /// ```\n     /// use std::collections::Bitv;\n     ///\n-    /// let mut bv = Bitv::with_capacity(10, false);\n+    /// let mut bv = Bitv::from_elem(10, false);\n     /// assert_eq!(bv.none(), true);\n     ///\n     /// bv.set(3, true);\n     /// assert_eq!(bv.none(), false);\n     /// ```\n     pub fn none(&self) -> bool {\n-        self.mask_words(0).all(|(_, w)| w == 0)\n+        self.blocks().all(|w| w == 0)\n     }\n \n     /// Returns `true` if any bit is 1.\n@@ -506,7 +607,7 @@ impl Bitv {\n     /// ```\n     /// use std::collections::Bitv;\n     ///\n-    /// let mut bv = Bitv::with_capacity(10, false);\n+    /// let mut bv = Bitv::from_elem(10, false);\n     /// assert_eq!(bv.any(), false);\n     ///\n     /// bv.set(3, true);\n@@ -527,24 +628,24 @@ impl Bitv {\n     /// ```\n     /// use std::collections::Bitv;\n     ///\n-    /// let mut bv = Bitv::with_capacity(3, true);\n+    /// let mut bv = Bitv::from_elem(3, true);\n     /// bv.set(1, false);\n     ///\n     /// assert_eq!(bv.to_bytes(), vec!(0b10100000));\n     ///\n-    /// let mut bv = Bitv::with_capacity(9, false);\n+    /// let mut bv = Bitv::from_elem(9, false);\n     /// bv.set(2, true);\n     /// bv.set(8, true);\n     ///\n     /// assert_eq!(bv.to_bytes(), vec!(0b00100000, 0b10000000));\n     /// ```\n     pub fn to_bytes(&self) -> Vec<u8> {\n-        fn bit (bitv: &Bitv, byte: uint, bit: uint) -> u8 {\n+        fn bit(bitv: &Bitv, byte: uint, bit: uint) -> u8 {\n             let offset = byte * 8 + bit;\n             if offset >= bitv.nbits {\n                 0\n             } else {\n-                bitv.get(offset) as u8 << (7 - bit)\n+                bitv[offset] as u8 << (7 - bit)\n             }\n         }\n \n@@ -562,19 +663,10 @@ impl Bitv {\n         )\n     }\n \n-    /// Transforms `self` into a `Vec<bool>` by turning each bit into a `bool`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::bitv;\n-    ///\n-    /// let bv = bitv::from_bytes(&[0b10100000]);\n-    /// assert_eq!(bv.to_bools(), vec!(true, false, true, false,\n-    ///                                false, false, false, false));\n-    /// ```\n+    /// Deprecated: Use `iter().collect()`.\n+    #[deprecated = \"Use `iter().collect()`\"]\n     pub fn to_bools(&self) -> Vec<bool> {\n-        Vec::from_fn(self.nbits, |i| self.get(i))\n+        self.iter().collect()\n     }\n \n     /// Compares a `Bitv` to a slice of `bool`s.\n@@ -587,21 +679,16 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::bitv;\n+    /// use std::collections::Bitv;\n     ///\n-    /// let bv = bitv::from_bytes(&[0b10100000]);\n+    /// let bv = Bitv::from_bytes(&[0b10100000]);\n     ///\n     /// assert!(bv.eq_vec(&[true, false, true, false,\n     ///                     false, false, false, false]));\n     /// ```\n     pub fn eq_vec(&self, v: &[bool]) -> bool {\n         assert_eq!(self.nbits, v.len());\n-        let mut i = 0;\n-        while i < self.nbits {\n-            if self.get(i) != v[i] { return false; }\n-            i = i + 1;\n-        }\n-        true\n+        iter::order::eq(self.iter(), v.iter().cloned())\n     }\n \n     /// Shortens a `Bitv`, dropping excess elements.\n@@ -612,42 +699,75 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::bitv;\n+    /// use std::collections::Bitv;\n     ///\n-    /// let mut bv = bitv::from_bytes(&[0b01001011]);\n+    /// let mut bv = Bitv::from_bytes(&[0b01001011]);\n     /// bv.truncate(2);\n     /// assert!(bv.eq_vec(&[false, true]));\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn truncate(&mut self, len: uint) {\n         if len < self.len() {\n             self.nbits = len;\n-            let word_len = (len + u32::BITS - 1) / u32::BITS;\n-            self.storage.truncate(word_len);\n-            if len % u32::BITS > 0 {\n-                let mask = (1 << len % u32::BITS) - 1;\n-                self.storage[word_len - 1] &= mask;\n-            }\n+            // This fixes (2).\n+            self.storage.truncate(blocks_for_bits(len));\n+            self.fix_last_block();\n         }\n     }\n \n-    /// Grows the vector to be able to store `size` bits without resizing.\n+    /// Reserves capacity for at least `additional` more bits to be inserted in the given\n+    /// `Bitv`. The collection may reserve more space to avoid frequent reallocations.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity overflows `uint`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::Bitv;\n     ///\n-    /// let mut bv = Bitv::with_capacity(3, false);\n+    /// let mut bv = Bitv::from_elem(3, false);\n     /// bv.reserve(10);\n     /// assert_eq!(bv.len(), 3);\n-    /// assert!(bv.capacity() >= 10);\n+    /// assert!(bv.capacity() >= 13);\n+    /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn reserve(&mut self, additional: uint) {\n+        let desired_cap = self.len().checked_add(additional).expect(\"capacity overflow\");\n+        let storage_len = self.storage.len();\n+        if desired_cap > self.capacity() {\n+            self.storage.reserve(blocks_for_bits(desired_cap) - storage_len);\n+        }\n+    }\n+\n+    /// Reserves the minimum capacity for exactly `additional` more bits to be inserted in the\n+    /// given `Bitv`. Does nothing if the capacity is already sufficient.\n+    ///\n+    /// Note that the allocator may give the collection more space than it requests. Therefore\n+    /// capacity can not be relied upon to be precisely minimal. Prefer `reserve` if future\n+    /// insertions are expected.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity overflows `uint`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::Bitv;\n+    ///\n+    /// let mut bv = Bitv::from_elem(3, false);\n+    /// bv.reserve(10);\n+    /// assert_eq!(bv.len(), 3);\n+    /// assert!(bv.capacity() >= 13);\n     /// ```\n-    pub fn reserve(&mut self, size: uint) {\n-        let old_size = self.storage.len();\n-        let new_size = (size + u32::BITS - 1) / u32::BITS;\n-        if old_size < new_size {\n-            self.storage.grow(new_size - old_size, 0);\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn reserve_exact(&mut self, additional: uint) {\n+        let desired_cap = self.len().checked_add(additional).expect(\"capacity overflow\");\n+        let storage_len = self.storage.len();\n+        if desired_cap > self.capacity() {\n+            self.storage.reserve_exact(blocks_for_bits(desired_cap) - storage_len);\n         }\n     }\n \n@@ -664,83 +784,93 @@ impl Bitv {\n     /// assert!(bv.capacity() >= 10);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn capacity(&self) -> uint {\n-        self.storage.len() * u32::BITS\n+        self.storage.capacity().checked_mul(u32::BITS).unwrap_or(uint::MAX)\n     }\n \n     /// Grows the `Bitv` in-place, adding `n` copies of `value` to the `Bitv`.\n     ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new len overflows a `uint`.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::bitv;\n+    /// use std::collections::Bitv;\n     ///\n-    /// let mut bv = bitv::from_bytes(&[0b01001011]);\n+    /// let mut bv = Bitv::from_bytes(&[0b01001011]);\n     /// bv.grow(2, true);\n     /// assert_eq!(bv.len(), 10);\n     /// assert_eq!(bv.to_bytes(), vec!(0b01001011, 0b11000000));\n     /// ```\n     pub fn grow(&mut self, n: uint, value: bool) {\n-        let new_nbits = self.nbits + n;\n-        let new_nwords = (new_nbits + u32::BITS - 1) / u32::BITS;\n+        // Note: we just bulk set all the bits in the last word in this fn in multiple places\n+        // which is technically wrong if not all of these bits are to be used. However, at the end\n+        // of this fn we call `fix_last_block` at the end of this fn, which should fix this.\n+\n+        let new_nbits = self.nbits.checked_add(n).expect(\"capacity overflow\");\n+        let new_nblocks = blocks_for_bits(new_nbits);\n         let full_value = if value { !0 } else { 0 };\n-        // Correct the old tail word\n-        let old_last_word = (self.nbits + u32::BITS - 1) / u32::BITS - 1;\n+\n+        // Correct the old tail word, setting or clearing formerly unused bits\n+        let old_last_word = blocks_for_bits(self.nbits) - 1;\n         if self.nbits % u32::BITS > 0 {\n-            let overhang = self.nbits % u32::BITS; // # of already-used bits\n-            let mask = !((1 << overhang) - 1);  // e.g. 5 unused bits => 111110....0\n+            let mask = mask_for_bits(self.nbits);\n             if value {\n-                self.storage[old_last_word] |= mask;\n+                self.storage[old_last_word] |= !mask;\n             } else {\n-                self.storage[old_last_word] &= !mask;\n+                // Extra bits are already zero by invariant.\n             }\n         }\n+\n         // Fill in words after the old tail word\n-        let stop_idx = cmp::min(self.storage.len(), new_nwords);\n+        let stop_idx = cmp::min(self.storage.len(), new_nblocks);\n         for idx in range(old_last_word + 1, stop_idx) {\n             self.storage[idx] = full_value;\n         }\n+\n         // Allocate new words, if needed\n-        if new_nwords > self.storage.len() {\n-            let to_add = new_nwords - self.storage.len();\n+        if new_nblocks > self.storage.len() {\n+            let to_add = new_nblocks - self.storage.len();\n             self.storage.grow(to_add, full_value);\n-\n-            // Zero out and unused bits in the new tail word\n-            if value {\n-                let tail_word = new_nwords - 1;\n-                let used_bits = new_nbits % u32::BITS;\n-                self.storage[tail_word] &= (1 << used_bits) - 1;\n-            }\n         }\n+\n         // Adjust internal bit count\n         self.nbits = new_nbits;\n+\n+        self.fix_last_block();\n     }\n \n-    /// Shortens by one element and returns the removed element.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Assert if empty.\n+    /// Removes the last bit from the Bitv, and returns it. Returns None if the Bitv is empty.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::bitv;\n+    /// use std::collections::Bitv;\n     ///\n-    /// let mut bv = bitv::from_bytes(&[0b01001001]);\n-    /// assert_eq!(bv.pop(), true);\n-    /// assert_eq!(bv.pop(), false);\n+    /// let mut bv = Bitv::from_bytes(&[0b01001001]);\n+    /// assert_eq!(bv.pop(), Some(true));\n+    /// assert_eq!(bv.pop(), Some(false));\n     /// assert_eq!(bv.len(), 6);\n-    /// assert_eq!(bv.to_bytes(), vec!(0b01001000));\n     /// ```\n-    pub fn pop(&mut self) -> bool {\n-        let ret = self.get(self.nbits - 1);\n-        // If we are unusing a whole word, make sure it is zeroed out\n-        if self.nbits % u32::BITS == 1 {\n-            self.storage[self.nbits / u32::BITS] = 0;\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn pop(&mut self) -> Option<bool> {\n+        if self.is_empty() {\n+            None\n+        } else {\n+            let i = self.nbits - 1;\n+            let ret = self[i];\n+            // (3)\n+            self.set(i, false);\n+            self.nbits = i;\n+            if self.nbits % u32::BITS == 0 {\n+                // (2)\n+                self.storage.pop();\n+            }\n+            Some(ret)\n         }\n-        self.nbits -= 1;\n-        ret\n     }\n \n     /// Pushes a `bool` onto the end.\n@@ -755,12 +885,13 @@ impl Bitv {\n     /// bv.push(false);\n     /// assert!(bv.eq_vec(&[true, false]));\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn push(&mut self, elem: bool) {\n-        let insert_pos = self.nbits;\n-        self.nbits += 1;\n-        if self.storage.len() * u32::BITS < self.nbits {\n+        if self.nbits % u32::BITS == 0 {\n             self.storage.push(0);\n         }\n+        let insert_pos = self.nbits;\n+        self.nbits = self.nbits.checked_add(1).expect(\"Capacity overflow\");\n         self.set(insert_pos, elem);\n     }\n \n@@ -782,46 +913,16 @@ impl Bitv {\n     }\n }\n \n-/// Transforms a byte-vector into a `Bitv`. Each byte becomes eight bits,\n-/// with the most significant bits of each byte coming first. Each\n-/// bit becomes `true` if equal to 1 or `false` if equal to 0.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::collections::bitv;\n-///\n-/// let bv = bitv::from_bytes(&[0b10100000, 0b00010010]);\n-/// assert!(bv.eq_vec(&[true, false, true, false,\n-///                     false, false, false, false,\n-///                     false, false, false, true,\n-///                     false, false, true, false]));\n-/// ```\n+/// Deprecated: Now a static method on Bitv.\n+#[deprecated = \"Now a static method on Bitv\"]\n pub fn from_bytes(bytes: &[u8]) -> Bitv {\n-    from_fn(bytes.len() * 8, |i| {\n-        let b = bytes[i / 8] as u32;\n-        let offset = i % 8;\n-        b >> (7 - offset) & 1 == 1\n-    })\n+    Bitv::from_bytes(bytes)\n }\n \n-/// Creates a `Bitv` of the specified length where the value at each\n-/// index is `f(index)`.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::collections::bitv::from_fn;\n-///\n-/// let bv = from_fn(5, |i| { i % 2 == 0 });\n-/// assert!(bv.eq_vec(&[true, false, true, false, true]));\n-/// ```\n-pub fn from_fn<F>(len: uint, mut f: F) -> Bitv where F: FnMut(uint) -> bool {\n-    let mut bitv = Bitv::with_capacity(len, false);\n-    for i in range(0u, len) {\n-        bitv.set(i, f(i));\n-    }\n-    bitv\n+/// Deprecated: Now a static method on Bitv.\n+#[deprecated = \"Now a static method on Bitv\"]\n+pub fn from_fn<F>(len: uint, f: F) -> Bitv where F: FnMut(uint) -> bool {\n+    Bitv::from_fn(len, f)\n }\n \n #[stable]\n@@ -843,8 +944,7 @@ impl Extend<bool> for Bitv {\n     #[inline]\n     fn extend<I: Iterator<bool>>(&mut self, mut iterator: I) {\n         let (min, _) = iterator.size_hint();\n-        let nbits = self.nbits;\n-        self.reserve(nbits + min);\n+        self.reserve(min);\n         for element in iterator {\n             self.push(element)\n         }\n@@ -882,7 +982,7 @@ impl Ord for Bitv {\n impl fmt::Show for Bitv {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         for bit in self.iter() {\n-            try!(write!(fmt, \"{}\", if bit { 1u } else { 0u }));\n+            try!(write!(fmt, \"{}\", if bit { 1u32 } else { 0u32 }));\n         }\n         Ok(())\n     }\n@@ -891,7 +991,7 @@ impl fmt::Show for Bitv {\n impl<S: hash::Writer> hash::Hash<S> for Bitv {\n     fn hash(&self, state: &mut S) {\n         self.nbits.hash(state);\n-        for (_, elem) in self.mask_words(0) {\n+        for elem in self.blocks() {\n             elem.hash(state);\n         }\n     }\n@@ -903,7 +1003,7 @@ impl cmp::PartialEq for Bitv {\n         if self.nbits != other.nbits {\n             return false;\n         }\n-        self.mask_words(0).zip(other.mask_words(0)).all(|((_, w1), (_, w2))| w1 == w2)\n+        self.blocks().zip(other.blocks()).all(|(w1, w2)| w1 == w2)\n     }\n }\n \n@@ -922,7 +1022,7 @@ impl<'a> Iterator<bool> for Bits<'a> {\n         if self.next_idx != self.end_idx {\n             let idx = self.next_idx;\n             self.next_idx += 1;\n-            Some(self.bitv.get(idx))\n+            Some(self.bitv[idx])\n         } else {\n             None\n         }\n@@ -939,7 +1039,7 @@ impl<'a> DoubleEndedIterator<bool> for Bits<'a> {\n     fn next_back(&mut self) -> Option<bool> {\n         if self.next_idx != self.end_idx {\n             self.end_idx -= 1;\n-            Some(self.bitv.get(self.end_idx))\n+            Some(self.bitv[self.end_idx])\n         } else {\n             None\n         }\n@@ -959,7 +1059,7 @@ impl<'a> RandomAccessIterator<bool> for Bits<'a> {\n         if index >= self.indexable() {\n             None\n         } else {\n-            Some(self.bitv.get(index))\n+            Some(self.bitv[index])\n         }\n     }\n }\n@@ -975,7 +1075,6 @@ impl<'a> RandomAccessIterator<bool> for Bits<'a> {\n ///\n /// ```\n /// use std::collections::{BitvSet, Bitv};\n-/// use std::collections::bitv;\n ///\n /// // It's a regular set\n /// let mut s = BitvSet::new();\n@@ -990,7 +1089,7 @@ impl<'a> RandomAccessIterator<bool> for Bits<'a> {\n /// }\n ///\n /// // Can initialize from a `Bitv`\n-/// let other = BitvSet::from_bitv(bitv::from_bytes(&[0b11010000]));\n+/// let other = BitvSet::from_bitv(Bitv::from_bytes(&[0b11010000]));\n ///\n /// s.union_with(&other);\n ///\n@@ -1001,29 +1100,32 @@ impl<'a> RandomAccessIterator<bool> for Bits<'a> {\n ///\n /// // Can convert back to a `Bitv`\n /// let bv: Bitv = s.into_bitv();\n-/// assert!(bv.get(3));\n+/// assert!(bv[3]);\n /// ```\n #[deriving(Clone)]\n-pub struct BitvSet(Bitv);\n+pub struct BitvSet {\n+    bitv: Bitv,\n+}\n \n impl Default for BitvSet {\n     #[inline]\n     fn default() -> BitvSet { BitvSet::new() }\n }\n \n-impl FromIterator<bool> for BitvSet {\n-    fn from_iter<I:Iterator<bool>>(iterator: I) -> BitvSet {\n+impl FromIterator<uint> for BitvSet {\n+    fn from_iter<I:Iterator<uint>>(iterator: I) -> BitvSet {\n         let mut ret = BitvSet::new();\n         ret.extend(iterator);\n         ret\n     }\n }\n \n-impl Extend<bool> for BitvSet {\n+impl Extend<uint> for BitvSet {\n     #[inline]\n-    fn extend<I: Iterator<bool>>(&mut self, iterator: I) {\n-        let &BitvSet(ref mut self_bitv) = self;\n-        self_bitv.extend(iterator);\n+    fn extend<I: Iterator<uint>>(&mut self, mut iterator: I) {\n+        for i in iterator {\n+            self.insert(i);\n+        }\n     }\n }\n \n@@ -1054,45 +1156,47 @@ impl cmp::PartialEq for BitvSet {\n impl cmp::Eq for BitvSet {}\n \n impl BitvSet {\n-    /// Creates a new bit vector set with initially no contents.\n+    /// Creates a new empty `BitvSet`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BitvSet;\n+    ///\n     /// let mut s = BitvSet::new();\n     /// ```\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> BitvSet {\n-        BitvSet(Bitv::new())\n+        BitvSet { bitv: Bitv::new() }\n     }\n \n-    /// Creates a new bit vector set with initially no contents, able to\n+    /// Creates a new `BitvSet` with initially no contents, able to\n     /// hold `nbits` elements without resizing.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BitvSet;\n+    ///\n     /// let mut s = BitvSet::with_capacity(100);\n     /// assert!(s.capacity() >= 100);\n     /// ```\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn with_capacity(nbits: uint) -> BitvSet {\n-        let bitv = Bitv::with_capacity(nbits, false);\n+        let bitv = Bitv::from_elem(nbits, false);\n         BitvSet::from_bitv(bitv)\n     }\n \n-    /// Creates a new bit vector set from the given bit vector.\n+    /// Creates a new `BitvSet` from the given bit vector.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::{bitv, BitvSet};\n+    /// use std::collections::{Bitv, BitvSet};\n     ///\n-    /// let bv = bitv::from_bytes(&[0b01100000]);\n+    /// let bv = Bitv::from_bytes(&[0b01100000]);\n     /// let s = BitvSet::from_bitv(bv);\n     ///\n     /// // Print 1, 2 in arbitrary order\n@@ -1101,10 +1205,8 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n-    pub fn from_bitv(mut bitv: Bitv) -> BitvSet {\n-        // Mark every bit as valid\n-        bitv.nbits = bitv.capacity();\n-        BitvSet(bitv)\n+    pub fn from_bitv(bitv: Bitv) -> BitvSet {\n+        BitvSet { bitv: bitv }\n     }\n \n     /// Returns the capacity in bits for this bit vector. Inserting any\n@@ -1121,29 +1223,60 @@ impl BitvSet {\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn capacity(&self) -> uint {\n-        let &BitvSet(ref bitv) = self;\n-        bitv.capacity()\n+        self.bitv.capacity()\n+    }\n+\n+    /// Reserves capacity for the given `BitvSet` to contain `len` distinct elements. In the case\n+    /// of `BitvSet` this means reallocations will not occur as long as all inserted elements\n+    /// are less than `len`.\n+    ///\n+    /// The collection may reserve more space to avoid frequent reallocations.\n+    ///\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    ///\n+    /// let mut s = BitvSet::new();\n+    /// s.reserve_len(10);\n+    /// assert!(s.capacity() >= 10);\n+    /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn reserve_len(&mut self, len: uint) {\n+        let cur_len = self.bitv.len();\n+        if len >= cur_len {\n+            self.bitv.reserve(len - cur_len);\n+        }\n     }\n \n-    /// Grows the underlying vector to be able to store `size` bits.\n+    /// Reserves the minimum capacity for the given `BitvSet` to contain `len` distinct elements.\n+    /// In the case of `BitvSet` this means reallocations will not occur as long as all inserted\n+    /// elements are less than `len`.\n+    ///\n+    /// Note that the allocator may give the collection more space than it requests. Therefore\n+    /// capacity can not be relied upon to be precisely minimal. Prefer `reserve_len` if future\n+    /// insertions are expected.\n+    ///\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BitvSet;\n     ///\n     /// let mut s = BitvSet::new();\n-    /// s.reserve(10);\n+    /// s.reserve_len_exact(10);\n     /// assert!(s.capacity() >= 10);\n     /// ```\n-    pub fn reserve(&mut self, size: uint) {\n-        let &BitvSet(ref mut bitv) = self;\n-        bitv.reserve(size);\n-        if bitv.nbits < size {\n-            bitv.nbits = bitv.capacity();\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn reserve_len_exact(&mut self, len: uint) {\n+        let cur_len = self.bitv.len();\n+        if len >= cur_len {\n+            self.bitv.reserve_exact(len - cur_len);\n         }\n     }\n \n+\n     /// Consumes this set to return the underlying bit vector.\n     ///\n     /// # Examples\n@@ -1156,13 +1289,12 @@ impl BitvSet {\n     /// s.insert(3);\n     ///\n     /// let bv = s.into_bitv();\n-    /// assert!(bv.get(0));\n-    /// assert!(bv.get(3));\n+    /// assert!(bv[0]);\n+    /// assert!(bv[3]);\n     /// ```\n     #[inline]\n     pub fn into_bitv(self) -> Bitv {\n-        let BitvSet(bitv) = self;\n-        bitv\n+        self.bitv\n     }\n \n     /// Returns a reference to the underlying bit vector.\n@@ -1180,18 +1312,22 @@ impl BitvSet {\n     /// ```\n     #[inline]\n     pub fn get_ref<'a>(&'a self) -> &'a Bitv {\n-        let &BitvSet(ref bitv) = self;\n-        bitv\n+        &self.bitv\n     }\n \n     #[inline]\n     fn other_op<F>(&mut self, other: &BitvSet, mut f: F) where F: FnMut(u32, u32) -> u32 {\n-        // Expand the vector if necessary\n-        self.reserve(other.capacity());\n-\n         // Unwrap Bitvs\n-        let &BitvSet(ref mut self_bitv) = self;\n-        let &BitvSet(ref other_bitv) = other;\n+        let self_bitv = &mut self.bitv;\n+        let other_bitv = &other.bitv;\n+\n+        let self_len = self_bitv.len();\n+        let other_len = other_bitv.len();\n+\n+        // Expand the vector if necessary\n+        if self_len < other_len {\n+            self_bitv.grow(other_len - self_len, false);\n+        }\n \n         // virtually pad other with 0's for equal lengths\n         let mut other_words = {\n@@ -1228,7 +1364,7 @@ impl BitvSet {\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn shrink_to_fit(&mut self) {\n-        let &BitvSet(ref mut bitv) = self;\n+        let bitv = &mut self.bitv;\n         // Obtain original length\n         let old_len = bitv.storage.len();\n         // Obtain coarse trailing zero length\n@@ -1244,10 +1380,9 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n-    /// use std::collections::bitv;\n+    /// use std::collections::{Bitv, BitvSet};\n     ///\n-    /// let s = BitvSet::from_bitv(bitv::from_bytes(&[0b01001010]));\n+    /// let s = BitvSet::from_bitv(Bitv::from_bytes(&[0b01001010]));\n     ///\n     /// // Print 1, 4, 6 in arbitrary order\n     /// for x in s.iter() {\n@@ -1266,11 +1401,10 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n-    /// use std::collections::bitv;\n+    /// use std::collections::{Bitv, BitvSet};\n     ///\n-    /// let a = BitvSet::from_bitv(bitv::from_bytes(&[0b01101000]));\n-    /// let b = BitvSet::from_bitv(bitv::from_bytes(&[0b10100000]));\n+    /// let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b01101000]));\n+    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100000]));\n     ///\n     /// // Print 0, 1, 2, 4 in arbitrary order\n     /// for x in a.union(&b) {\n@@ -1297,11 +1431,10 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n-    /// use std::collections::bitv;\n+    /// use std::collections::{Bitv, BitvSet};\n     ///\n-    /// let a = BitvSet::from_bitv(bitv::from_bytes(&[0b01101000]));\n-    /// let b = BitvSet::from_bitv(bitv::from_bytes(&[0b10100000]));\n+    /// let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b01101000]));\n+    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100000]));\n     ///\n     /// // Print 2\n     /// for x in a.intersection(&b) {\n@@ -1312,8 +1445,7 @@ impl BitvSet {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn intersection<'a>(&'a self, other: &'a BitvSet) -> Take<TwoBitPositions<'a>> {\n         fn bitand(w1: u32, w2: u32) -> u32 { w1 & w2 }\n-\n-        let min = cmp::min(self.capacity(), other.capacity());\n+        let min = cmp::min(self.bitv.len(), other.bitv.len());\n         TwoBitPositions {\n             set: self,\n             other: other,\n@@ -1329,11 +1461,10 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n-    /// use std::collections::bitv;\n+    /// use std::collections::{BitvSet, Bitv};\n     ///\n-    /// let a = BitvSet::from_bitv(bitv::from_bytes(&[0b01101000]));\n-    /// let b = BitvSet::from_bitv(bitv::from_bytes(&[0b10100000]));\n+    /// let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b01101000]));\n+    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100000]));\n     ///\n     /// // Print 1, 4 in arbitrary order\n     /// for x in a.difference(&b) {\n@@ -1368,11 +1499,10 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n-    /// use std::collections::bitv;\n+    /// use std::collections::{BitvSet, Bitv};\n     ///\n-    /// let a = BitvSet::from_bitv(bitv::from_bytes(&[0b01101000]));\n-    /// let b = BitvSet::from_bitv(bitv::from_bytes(&[0b10100000]));\n+    /// let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b01101000]));\n+    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100000]));\n     ///\n     /// // Print 0, 1, 4 in arbitrary order\n     /// for x in a.symmetric_difference(&b) {\n@@ -1398,16 +1528,15 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n-    /// use std::collections::bitv;\n+    /// use std::collections::{BitvSet, Bitv};\n     ///\n     /// let a   = 0b01101000;\n     /// let b   = 0b10100000;\n     /// let res = 0b11101000;\n     ///\n-    /// let mut a = BitvSet::from_bitv(bitv::from_bytes(&[a]));\n-    /// let b = BitvSet::from_bitv(bitv::from_bytes(&[b]));\n-    /// let res = BitvSet::from_bitv(bitv::from_bytes(&[res]));\n+    /// let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[a]));\n+    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[b]));\n+    /// let res = BitvSet::from_bitv(Bitv::from_bytes(&[res]));\n     ///\n     /// a.union_with(&b);\n     /// assert_eq!(a, res);\n@@ -1422,16 +1551,15 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n-    /// use std::collections::bitv;\n+    /// use std::collections::{BitvSet, Bitv};\n     ///\n     /// let a   = 0b01101000;\n     /// let b   = 0b10100000;\n     /// let res = 0b00100000;\n     ///\n-    /// let mut a = BitvSet::from_bitv(bitv::from_bytes(&[a]));\n-    /// let b = BitvSet::from_bitv(bitv::from_bytes(&[b]));\n-    /// let res = BitvSet::from_bitv(bitv::from_bytes(&[res]));\n+    /// let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[a]));\n+    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[b]));\n+    /// let res = BitvSet::from_bitv(Bitv::from_bytes(&[res]));\n     ///\n     /// a.intersect_with(&b);\n     /// assert_eq!(a, res);\n@@ -1447,24 +1575,23 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n-    /// use std::collections::bitv;\n+    /// use std::collections::{BitvSet, Bitv};\n     ///\n     /// let a   = 0b01101000;\n     /// let b   = 0b10100000;\n     /// let a_b = 0b01001000; // a - b\n     /// let b_a = 0b10000000; // b - a\n     ///\n-    /// let mut bva = BitvSet::from_bitv(bitv::from_bytes(&[a]));\n-    /// let bvb = BitvSet::from_bitv(bitv::from_bytes(&[b]));\n-    /// let bva_b = BitvSet::from_bitv(bitv::from_bytes(&[a_b]));\n-    /// let bvb_a = BitvSet::from_bitv(bitv::from_bytes(&[b_a]));\n+    /// let mut bva = BitvSet::from_bitv(Bitv::from_bytes(&[a]));\n+    /// let bvb = BitvSet::from_bitv(Bitv::from_bytes(&[b]));\n+    /// let bva_b = BitvSet::from_bitv(Bitv::from_bytes(&[a_b]));\n+    /// let bvb_a = BitvSet::from_bitv(Bitv::from_bytes(&[b_a]));\n     ///\n     /// bva.difference_with(&bvb);\n     /// assert_eq!(bva, bva_b);\n     ///\n-    /// let bva = BitvSet::from_bitv(bitv::from_bytes(&[a]));\n-    /// let mut bvb = BitvSet::from_bitv(bitv::from_bytes(&[b]));\n+    /// let bva = BitvSet::from_bitv(Bitv::from_bytes(&[a]));\n+    /// let mut bvb = BitvSet::from_bitv(Bitv::from_bytes(&[b]));\n     ///\n     /// bvb.difference_with(&bva);\n     /// assert_eq!(bvb, bvb_a);\n@@ -1480,16 +1607,15 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n-    /// use std::collections::bitv;\n+    /// use std::collections::{BitvSet, Bitv};\n     ///\n     /// let a   = 0b01101000;\n     /// let b   = 0b10100000;\n     /// let res = 0b11001000;\n     ///\n-    /// let mut a = BitvSet::from_bitv(bitv::from_bytes(&[a]));\n-    /// let b = BitvSet::from_bitv(bitv::from_bytes(&[b]));\n-    /// let res = BitvSet::from_bitv(bitv::from_bytes(&[res]));\n+    /// let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[a]));\n+    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[b]));\n+    /// let res = BitvSet::from_bitv(Bitv::from_bytes(&[res]));\n     ///\n     /// a.symmetric_difference_with(&b);\n     /// assert_eq!(a, res);\n@@ -1503,32 +1629,29 @@ impl BitvSet {\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn len(&self) -> uint  {\n-        let &BitvSet(ref bitv) = self;\n-        bitv.storage.iter().fold(0, |acc, &n| acc + n.count_ones())\n+        self.bitv.blocks().fold(0, |acc, n| acc + n.count_ones())\n     }\n \n     /// Returns whether there are no bits set in this set\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool {\n-        let &BitvSet(ref bitv) = self;\n-        bitv.storage.iter().all(|&n| n == 0)\n+        self.bitv.none()\n     }\n \n     /// Clears all bits in this set\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) {\n-        let &BitvSet(ref mut bitv) = self;\n-        bitv.clear();\n+        self.bitv.clear();\n     }\n \n     /// Returns `true` if this set contains the specified integer.\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn contains(&self, value: &uint) -> bool {\n-        let &BitvSet(ref bitv) = self;\n-        *value < bitv.nbits && bitv.get(*value)\n+        let bitv = &self.bitv;\n+        *value < bitv.nbits && bitv[*value]\n     }\n \n     /// Returns `true` if the set has no elements in common with `other`.\n@@ -1543,14 +1666,14 @@ impl BitvSet {\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_subset(&self, other: &BitvSet) -> bool {\n-        let &BitvSet(ref self_bitv) = self;\n-        let &BitvSet(ref other_bitv) = other;\n+        let self_bitv = &self.bitv;\n+        let other_bitv = &other.bitv;\n+        let other_blocks = blocks_for_bits(other_bitv.len());\n \n         // Check that `self` intersect `other` is self\n-        self_bitv.mask_words(0).zip(other_bitv.mask_words(0))\n-                               .all(|((_, w1), (_, w2))| w1 & w2 == w1) &&\n-        // Check that `self` setminus `other` is empty\n-        self_bitv.mask_words(other_bitv.storage.len()).all(|(_, w)| w == 0)\n+        self_bitv.blocks().zip(other_bitv.blocks()).all(|(w1, w2)| w1 & w2 == w1) &&\n+        // Make sure if `self` has any more blocks than `other`, they're all 0\n+        self_bitv.blocks().skip(other_blocks).all(|w| w == 0)\n     }\n \n     /// Returns `true` if the set is a superset of another.\n@@ -1569,13 +1692,12 @@ impl BitvSet {\n         }\n \n         // Ensure we have enough space to hold the new element\n-        if value >= self.capacity() {\n-            let new_cap = cmp::max(value + 1, self.capacity() * 2);\n-            self.reserve(new_cap);\n+        let len = self.bitv.len();\n+        if value >= len {\n+            self.bitv.grow(value - len + 1, false)\n         }\n \n-        let &BitvSet(ref mut bitv) = self;\n-        bitv.set(value, true);\n+        self.bitv.set(value, true);\n         return true;\n     }\n \n@@ -1586,8 +1708,9 @@ impl BitvSet {\n         if !self.contains(value) {\n             return false;\n         }\n-        let &BitvSet(ref mut bitv) = self;\n-        bitv.set(*value, false);\n+\n+        self.bitv.set(*value, false);\n+\n         return true;\n     }\n }\n@@ -1632,7 +1755,7 @@ pub struct TwoBitPositions<'a> {\n \n impl<'a> Iterator<uint> for BitPositions<'a> {\n     fn next(&mut self) -> Option<uint> {\n-        while self.next_idx < self.set.capacity() {\n+        while self.next_idx < self.set.bitv.len() {\n             let idx = self.next_idx;\n             self.next_idx += 1;\n \n@@ -1646,18 +1769,18 @@ impl<'a> Iterator<uint> for BitPositions<'a> {\n \n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n-        (0, Some(self.set.capacity() - self.next_idx))\n+        (0, Some(self.set.bitv.len() - self.next_idx))\n     }\n }\n \n impl<'a> Iterator<uint> for TwoBitPositions<'a> {\n     fn next(&mut self) -> Option<uint> {\n-        while self.next_idx < self.set.capacity() ||\n-              self.next_idx < self.other.capacity() {\n+        while self.next_idx < self.set.bitv.len() ||\n+              self.next_idx < self.other.bitv.len() {\n             let bit_idx = self.next_idx % u32::BITS;\n             if bit_idx == 0 {\n-                let &BitvSet(ref s_bitv) = self.set;\n-                let &BitvSet(ref o_bitv) = self.other;\n+                let s_bitv = &self.set.bitv;\n+                let o_bitv = &self.other.bitv;\n                 // Merging the two words is a bit of an awkward dance since\n                 // one Bitv might be longer than the other\n                 let word_idx = self.next_idx / u32::BITS;\n@@ -1680,11 +1803,15 @@ impl<'a> Iterator<uint> for TwoBitPositions<'a> {\n \n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n-        let cap = cmp::max(self.set.capacity(), self.other.capacity());\n+        let cap = cmp::max(self.set.bitv.len(), self.other.bitv.len());\n         (0, Some(cap - self.next_idx))\n     }\n }\n \n+\n+\n+\n+\n #[cfg(test)]\n mod tests {\n     use prelude::*;\n@@ -1697,14 +1824,12 @@ mod tests {\n     use super::{Bitv, BitvSet, from_fn, from_bytes};\n     use bitv;\n \n-    static BENCH_BITS : uint = 1 << 14;\n-\n     #[test]\n     fn test_to_str() {\n         let zerolen = Bitv::new();\n         assert_eq!(zerolen.to_string(), \"\");\n \n-        let eightbits = Bitv::with_capacity(8u, false);\n+        let eightbits = Bitv::from_elem(8u, false);\n         assert_eq!(eightbits.to_string(), \"00000000\")\n     }\n \n@@ -1713,84 +1838,95 @@ mod tests {\n         let act = Bitv::new();\n         let exp = Vec::from_elem(0u, false);\n         assert!(act.eq_vec(exp.as_slice()));\n+        assert!(act.none() && act.all());\n     }\n \n     #[test]\n     fn test_1_element() {\n-        let mut act = Bitv::with_capacity(1u, false);\n+        let mut act = Bitv::from_elem(1u, false);\n         assert!(act.eq_vec(&[false]));\n-        act = Bitv::with_capacity(1u, true);\n+        assert!(act.none() && !act.all());\n+        act = Bitv::from_elem(1u, true);\n         assert!(act.eq_vec(&[true]));\n+        assert!(!act.none() && act.all());\n     }\n \n     #[test]\n     fn test_2_elements() {\n-        let mut b = bitv::Bitv::with_capacity(2, false);\n+        let mut b = Bitv::from_elem(2, false);\n         b.set(0, true);\n         b.set(1, false);\n         assert_eq!(b.to_string(), \"10\");\n+        assert!(!b.none() && !b.all());\n     }\n \n     #[test]\n     fn test_10_elements() {\n         let mut act;\n         // all 0\n \n-        act = Bitv::with_capacity(10u, false);\n+        act = Bitv::from_elem(10u, false);\n         assert!((act.eq_vec(\n                     &[false, false, false, false, false, false, false, false, false, false])));\n+        assert!(act.none() && !act.all());\n         // all 1\n \n-        act = Bitv::with_capacity(10u, true);\n+        act = Bitv::from_elem(10u, true);\n         assert!((act.eq_vec(&[true, true, true, true, true, true, true, true, true, true])));\n+        assert!(!act.none() && act.all());\n         // mixed\n \n-        act = Bitv::with_capacity(10u, false);\n+        act = Bitv::from_elem(10u, false);\n         act.set(0u, true);\n         act.set(1u, true);\n         act.set(2u, true);\n         act.set(3u, true);\n         act.set(4u, true);\n         assert!((act.eq_vec(&[true, true, true, true, true, false, false, false, false, false])));\n+        assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::with_capacity(10u, false);\n+        act = Bitv::from_elem(10u, false);\n         act.set(5u, true);\n         act.set(6u, true);\n         act.set(7u, true);\n         act.set(8u, true);\n         act.set(9u, true);\n         assert!((act.eq_vec(&[false, false, false, false, false, true, true, true, true, true])));\n+        assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::with_capacity(10u, false);\n+        act = Bitv::from_elem(10u, false);\n         act.set(0u, true);\n         act.set(3u, true);\n         act.set(6u, true);\n         act.set(9u, true);\n         assert!((act.eq_vec(&[true, false, false, true, false, false, true, false, false, true])));\n+        assert!(!act.none() && !act.all());\n     }\n \n     #[test]\n     fn test_31_elements() {\n         let mut act;\n         // all 0\n \n-        act = Bitv::with_capacity(31u, false);\n+        act = Bitv::from_elem(31u, false);\n         assert!(act.eq_vec(\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false]));\n+        assert!(act.none() && !act.all());\n         // all 1\n \n-        act = Bitv::with_capacity(31u, true);\n+        act = Bitv::from_elem(31u, true);\n         assert!(act.eq_vec(\n                 &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true]));\n+        assert!(!act.none() && act.all());\n         // mixed\n \n-        act = Bitv::with_capacity(31u, false);\n+        act = Bitv::from_elem(31u, false);\n         act.set(0u, true);\n         act.set(1u, true);\n         act.set(2u, true);\n@@ -1803,9 +1939,10 @@ mod tests {\n                 &[true, true, true, true, true, true, true, true, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false]));\n+        assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::with_capacity(31u, false);\n+        act = Bitv::from_elem(31u, false);\n         act.set(16u, true);\n         act.set(17u, true);\n         act.set(18u, true);\n@@ -1818,9 +1955,10 @@ mod tests {\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, true, true, true, true, true, true, true, true,\n                   false, false, false, false, false, false, false]));\n+        assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::with_capacity(31u, false);\n+        act = Bitv::from_elem(31u, false);\n         act.set(24u, true);\n         act.set(25u, true);\n         act.set(26u, true);\n@@ -1832,38 +1970,42 @@ mod tests {\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, true, true, true, true, true, true, true]));\n+        assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::with_capacity(31u, false);\n+        act = Bitv::from_elem(31u, false);\n         act.set(3u, true);\n         act.set(17u, true);\n         act.set(30u, true);\n         assert!(act.eq_vec(\n                 &[false, false, false, true, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, true, false, false, false, false, false, false,\n                   false, false, false, false, false, false, true]));\n+        assert!(!act.none() && !act.all());\n     }\n \n     #[test]\n     fn test_32_elements() {\n         let mut act;\n         // all 0\n \n-        act = Bitv::with_capacity(32u, false);\n+        act = Bitv::from_elem(32u, false);\n         assert!(act.eq_vec(\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false]));\n+        assert!(act.none() && !act.all());\n         // all 1\n \n-        act = Bitv::with_capacity(32u, true);\n+        act = Bitv::from_elem(32u, true);\n         assert!(act.eq_vec(\n                 &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true]));\n+        assert!(!act.none() && act.all());\n         // mixed\n \n-        act = Bitv::with_capacity(32u, false);\n+        act = Bitv::from_elem(32u, false);\n         act.set(0u, true);\n         act.set(1u, true);\n         act.set(2u, true);\n@@ -1876,9 +2018,10 @@ mod tests {\n                 &[true, true, true, true, true, true, true, true, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false]));\n+        assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::with_capacity(32u, false);\n+        act = Bitv::from_elem(32u, false);\n         act.set(16u, true);\n         act.set(17u, true);\n         act.set(18u, true);\n@@ -1891,9 +2034,10 @@ mod tests {\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, true, true, true, true, true, true, true, true,\n                   false, false, false, false, false, false, false, false]));\n+        assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::with_capacity(32u, false);\n+        act = Bitv::from_elem(32u, false);\n         act.set(24u, true);\n         act.set(25u, true);\n         act.set(26u, true);\n@@ -1906,9 +2050,10 @@ mod tests {\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, true, true, true, true, true, true, true, true]));\n+        assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::with_capacity(32u, false);\n+        act = Bitv::from_elem(32u, false);\n         act.set(3u, true);\n         act.set(17u, true);\n         act.set(30u, true);\n@@ -1917,28 +2062,31 @@ mod tests {\n                 &[false, false, false, true, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, true, false, false, false, false, false, false,\n                   false, false, false, false, false, false, true, true]));\n+        assert!(!act.none() && !act.all());\n     }\n \n     #[test]\n     fn test_33_elements() {\n         let mut act;\n         // all 0\n \n-        act = Bitv::with_capacity(33u, false);\n+        act = Bitv::from_elem(33u, false);\n         assert!(act.eq_vec(\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false]));\n+        assert!(act.none() && !act.all());\n         // all 1\n \n-        act = Bitv::with_capacity(33u, true);\n+        act = Bitv::from_elem(33u, true);\n         assert!(act.eq_vec(\n                 &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true, true]));\n+        assert!(!act.none() && act.all());\n         // mixed\n \n-        act = Bitv::with_capacity(33u, false);\n+        act = Bitv::from_elem(33u, false);\n         act.set(0u, true);\n         act.set(1u, true);\n         act.set(2u, true);\n@@ -1951,9 +2099,10 @@ mod tests {\n                 &[true, true, true, true, true, true, true, true, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false]));\n+        assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::with_capacity(33u, false);\n+        act = Bitv::from_elem(33u, false);\n         act.set(16u, true);\n         act.set(17u, true);\n         act.set(18u, true);\n@@ -1966,9 +2115,10 @@ mod tests {\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, true, true, true, true, true, true, true, true,\n                   false, false, false, false, false, false, false, false, false]));\n+        assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::with_capacity(33u, false);\n+        act = Bitv::from_elem(33u, false);\n         act.set(24u, true);\n         act.set(25u, true);\n         act.set(26u, true);\n@@ -1981,9 +2131,10 @@ mod tests {\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, true, true, true, true, true, true, true, true, false]));\n+        assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::with_capacity(33u, false);\n+        act = Bitv::from_elem(33u, false);\n         act.set(3u, true);\n         act.set(17u, true);\n         act.set(30u, true);\n@@ -1993,41 +2144,42 @@ mod tests {\n                 &[false, false, false, true, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, true, false, false, false, false, false, false,\n                   false, false, false, false, false, false, true, true, true]));\n+        assert!(!act.none() && !act.all());\n     }\n \n     #[test]\n     fn test_equal_differing_sizes() {\n-        let v0 = Bitv::with_capacity(10u, false);\n-        let v1 = Bitv::with_capacity(11u, false);\n+        let v0 = Bitv::from_elem(10u, false);\n+        let v1 = Bitv::from_elem(11u, false);\n         assert!(v0 != v1);\n     }\n \n     #[test]\n     fn test_equal_greatly_differing_sizes() {\n-        let v0 = Bitv::with_capacity(10u, false);\n-        let v1 = Bitv::with_capacity(110u, false);\n+        let v0 = Bitv::from_elem(10u, false);\n+        let v1 = Bitv::from_elem(110u, false);\n         assert!(v0 != v1);\n     }\n \n     #[test]\n     fn test_equal_sneaky_small() {\n-        let mut a = bitv::Bitv::with_capacity(1, false);\n+        let mut a = Bitv::from_elem(1, false);\n         a.set(0, true);\n \n-        let mut b = bitv::Bitv::with_capacity(1, true);\n+        let mut b = Bitv::from_elem(1, true);\n         b.set(0, true);\n \n         assert_eq!(a, b);\n     }\n \n     #[test]\n     fn test_equal_sneaky_big() {\n-        let mut a = bitv::Bitv::with_capacity(100, false);\n+        let mut a = Bitv::from_elem(100, false);\n         for i in range(0u, 100) {\n             a.set(i, true);\n         }\n \n-        let mut b = bitv::Bitv::with_capacity(100, true);\n+        let mut b = Bitv::from_elem(100, true);\n         for i in range(0u, 100) {\n             b.set(i, true);\n         }\n@@ -2037,18 +2189,18 @@ mod tests {\n \n     #[test]\n     fn test_from_bytes() {\n-        let bitv = from_bytes(&[0b10110110, 0b00000000, 0b11111111]);\n+        let bitv = Bitv::from_bytes(&[0b10110110, 0b00000000, 0b11111111]);\n         let str = concat!(\"10110110\", \"00000000\", \"11111111\");\n         assert_eq!(bitv.to_string(), str);\n     }\n \n     #[test]\n     fn test_to_bytes() {\n-        let mut bv = Bitv::with_capacity(3, true);\n+        let mut bv = Bitv::from_elem(3, true);\n         bv.set(1, false);\n         assert_eq!(bv.to_bytes(), vec!(0b10100000));\n \n-        let mut bv = Bitv::with_capacity(9, false);\n+        let mut bv = Bitv::from_elem(9, false);\n         bv.set(2, true);\n         bv.set(8, true);\n         assert_eq!(bv.to_bytes(), vec!(0b00100000, 0b10000000));\n@@ -2061,21 +2213,10 @@ mod tests {\n         assert_eq!(bitv.to_string(), \"1011\");\n     }\n \n-    #[test]\n-    fn test_bitv_set_from_bools() {\n-        let bools = vec![true, false, true, true];\n-        let a: BitvSet = bools.iter().map(|n| *n).collect();\n-        let mut b = BitvSet::new();\n-        b.insert(0);\n-        b.insert(2);\n-        b.insert(3);\n-        assert_eq!(a, b);\n-    }\n-\n     #[test]\n     fn test_to_bools() {\n         let bools = vec!(false, false, true, false, false, true, true, false);\n-        assert_eq!(from_bytes(&[0b00100110]).iter().collect::<Vec<bool>>(), bools);\n+        assert_eq!(Bitv::from_bytes(&[0b00100110]).iter().collect::<Vec<bool>>(), bools);\n     }\n \n     #[test]\n@@ -2090,120 +2231,421 @@ mod tests {\n         assert_eq!(bitv.iter().collect::<Vec<bool>>(), long)\n     }\n \n-    #[test]\n-    fn test_bitv_set_iterator() {\n-        let bools = [true, false, true, true];\n-        let bitv: BitvSet = bools.iter().map(|n| *n).collect();\n-\n-        let idxs: Vec<uint> = bitv.iter().collect();\n-        assert_eq!(idxs, vec!(0, 2, 3));\n-\n-        let long: BitvSet = range(0u, 10000).map(|n| n % 2 == 0).collect();\n-        let real = range_step(0, 10000, 2).collect::<Vec<uint>>();\n-\n-        let idxs: Vec<uint> = long.iter().collect();\n-        assert_eq!(idxs, real);\n-    }\n-\n-    #[test]\n-    fn test_bitv_set_frombitv_init() {\n-        let bools = [true, false];\n-        let lengths = [10, 64, 100];\n-        for &b in bools.iter() {\n-            for &l in lengths.iter() {\n-                let bitset = BitvSet::from_bitv(Bitv::with_capacity(l, b));\n-                assert_eq!(bitset.contains(&1u), b);\n-                assert_eq!(bitset.contains(&(l-1u)), b);\n-                assert!(!bitset.contains(&l))\n-            }\n-        }\n-    }\n-\n     #[test]\n     fn test_small_difference() {\n-        let mut b1 = Bitv::with_capacity(3, false);\n-        let mut b2 = Bitv::with_capacity(3, false);\n+        let mut b1 = Bitv::from_elem(3, false);\n+        let mut b2 = Bitv::from_elem(3, false);\n         b1.set(0, true);\n         b1.set(1, true);\n         b2.set(1, true);\n         b2.set(2, true);\n         assert!(b1.difference(&b2));\n-        assert!(b1.get(0));\n-        assert!(!b1.get(1));\n-        assert!(!b1.get(2));\n+        assert!(b1[0]);\n+        assert!(!b1[1]);\n+        assert!(!b1[2]);\n     }\n \n     #[test]\n     fn test_big_difference() {\n-        let mut b1 = Bitv::with_capacity(100, false);\n-        let mut b2 = Bitv::with_capacity(100, false);\n+        let mut b1 = Bitv::from_elem(100, false);\n+        let mut b2 = Bitv::from_elem(100, false);\n         b1.set(0, true);\n         b1.set(40, true);\n         b2.set(40, true);\n         b2.set(80, true);\n         assert!(b1.difference(&b2));\n-        assert!(b1.get(0));\n-        assert!(!b1.get(40));\n-        assert!(!b1.get(80));\n+        assert!(b1[0]);\n+        assert!(!b1[40]);\n+        assert!(!b1[80]);\n     }\n \n     #[test]\n     fn test_small_clear() {\n-        let mut b = Bitv::with_capacity(14, true);\n+        let mut b = Bitv::from_elem(14, true);\n+        assert!(!b.none() && b.all());\n         b.clear();\n-        assert!(b.none());\n+        assert!(b.none() && !b.all());\n     }\n \n     #[test]\n     fn test_big_clear() {\n-        let mut b = Bitv::with_capacity(140, true);\n+        let mut b = Bitv::from_elem(140, true);\n+        assert!(!b.none() && b.all());\n         b.clear();\n-        assert!(b.none());\n+        assert!(b.none() && !b.all());\n     }\n \n     #[test]\n-    fn test_bitv_masking() {\n-        let b = Bitv::with_capacity(140, true);\n-        let mut bs = BitvSet::from_bitv(b);\n-        assert!(bs.contains(&139));\n-        assert!(!bs.contains(&140));\n-        assert!(bs.insert(150));\n-        assert!(!bs.contains(&140));\n-        assert!(!bs.contains(&149));\n-        assert!(bs.contains(&150));\n-        assert!(!bs.contains(&151));\n+    fn test_bitv_lt() {\n+        let mut a = Bitv::from_elem(5u, false);\n+        let mut b = Bitv::from_elem(5u, false);\n+\n+        assert!(!(a < b) && !(b < a));\n+        b.set(2, true);\n+        assert!(a < b);\n+        a.set(3, true);\n+        assert!(a < b);\n+        a.set(2, true);\n+        assert!(!(a < b) && b < a);\n+        b.set(0, true);\n+        assert!(a < b);\n     }\n \n     #[test]\n-    fn test_bitv_set_basic() {\n-        // calculate nbits with u32::BITS granularity\n-        fn calc_nbits(bits: uint) -> uint {\n-            u32::BITS * ((bits + u32::BITS - 1) / u32::BITS)\n-        }\n+    fn test_ord() {\n+        let mut a = Bitv::from_elem(5u, false);\n+        let mut b = Bitv::from_elem(5u, false);\n \n-        let mut b = BitvSet::new();\n-        assert_eq!(b.capacity(), calc_nbits(0));\n-        assert!(b.insert(3));\n-        assert_eq!(b.capacity(), calc_nbits(3));\n-        assert!(!b.insert(3));\n-        assert!(b.contains(&3));\n-        assert!(b.insert(4));\n-        assert!(!b.insert(4));\n-        assert!(b.contains(&3));\n-        assert!(b.insert(400));\n-        assert_eq!(b.capacity(), calc_nbits(400));\n-        assert!(!b.insert(400));\n-        assert!(b.contains(&400));\n-        assert_eq!(b.len(), 3);\n+        assert!(a <= b && a >= b);\n+        a.set(1, true);\n+        assert!(a > b && a >= b);\n+        assert!(b < a && b <= a);\n+        b.set(1, true);\n+        b.set(2, true);\n+        assert!(b > a && b >= a);\n+        assert!(a < b && a <= b);\n     }\n \n-    #[test]\n-    fn test_bitv_set_intersection() {\n-        let mut a = BitvSet::new();\n-        let mut b = BitvSet::new();\n \n-        assert!(a.insert(11));\n-        assert!(a.insert(1));\n+    #[test]\n+    fn test_small_bitv_tests() {\n+        let v = Bitv::from_bytes(&[0]);\n+        assert!(!v.all());\n+        assert!(!v.any());\n+        assert!(v.none());\n+\n+        let v = Bitv::from_bytes(&[0b00010100]);\n+        assert!(!v.all());\n+        assert!(v.any());\n+        assert!(!v.none());\n+\n+        let v = Bitv::from_bytes(&[0xFF]);\n+        assert!(v.all());\n+        assert!(v.any());\n+        assert!(!v.none());\n+    }\n+\n+    #[test]\n+    fn test_big_bitv_tests() {\n+        let v = Bitv::from_bytes(&[ // 88 bits\n+            0, 0, 0, 0,\n+            0, 0, 0, 0,\n+            0, 0, 0]);\n+        assert!(!v.all());\n+        assert!(!v.any());\n+        assert!(v.none());\n+\n+        let v = Bitv::from_bytes(&[ // 88 bits\n+            0, 0, 0b00010100, 0,\n+            0, 0, 0, 0b00110100,\n+            0, 0, 0]);\n+        assert!(!v.all());\n+        assert!(v.any());\n+        assert!(!v.none());\n+\n+        let v = Bitv::from_bytes(&[ // 88 bits\n+            0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF]);\n+        assert!(v.all());\n+        assert!(v.any());\n+        assert!(!v.none());\n+    }\n+\n+    #[test]\n+    fn test_bitv_push_pop() {\n+        let mut s = Bitv::from_elem(5 * u32::BITS - 2, false);\n+        assert_eq!(s.len(), 5 * u32::BITS - 2);\n+        assert_eq!(s[5 * u32::BITS - 3], false);\n+        s.push(true);\n+        s.push(true);\n+        assert_eq!(s[5 * u32::BITS - 2], true);\n+        assert_eq!(s[5 * u32::BITS - 1], true);\n+        // Here the internal vector will need to be extended\n+        s.push(false);\n+        assert_eq!(s[5 * u32::BITS], false);\n+        s.push(false);\n+        assert_eq!(s[5 * u32::BITS + 1], false);\n+        assert_eq!(s.len(), 5 * u32::BITS + 2);\n+        // Pop it all off\n+        assert_eq!(s.pop(), Some(false));\n+        assert_eq!(s.pop(), Some(false));\n+        assert_eq!(s.pop(), Some(true));\n+        assert_eq!(s.pop(), Some(true));\n+        assert_eq!(s.len(), 5 * u32::BITS - 2);\n+    }\n+\n+    #[test]\n+    fn test_bitv_truncate() {\n+        let mut s = Bitv::from_elem(5 * u32::BITS, true);\n+\n+        assert_eq!(s, Bitv::from_elem(5 * u32::BITS, true));\n+        assert_eq!(s.len(), 5 * u32::BITS);\n+        s.truncate(4 * u32::BITS);\n+        assert_eq!(s, Bitv::from_elem(4 * u32::BITS, true));\n+        assert_eq!(s.len(), 4 * u32::BITS);\n+        // Truncating to a size > s.len() should be a noop\n+        s.truncate(5 * u32::BITS);\n+        assert_eq!(s, Bitv::from_elem(4 * u32::BITS, true));\n+        assert_eq!(s.len(), 4 * u32::BITS);\n+        s.truncate(3 * u32::BITS - 10);\n+        assert_eq!(s, Bitv::from_elem(3 * u32::BITS - 10, true));\n+        assert_eq!(s.len(), 3 * u32::BITS - 10);\n+        s.truncate(0);\n+        assert_eq!(s, Bitv::from_elem(0, true));\n+        assert_eq!(s.len(), 0);\n+    }\n+\n+    #[test]\n+    fn test_bitv_reserve() {\n+        let mut s = Bitv::from_elem(5 * u32::BITS, true);\n+        // Check capacity\n+        assert!(s.capacity() >= 5 * u32::BITS);\n+        s.reserve(2 * u32::BITS);\n+        assert!(s.capacity() >= 7 * u32::BITS);\n+        s.reserve(7 * u32::BITS);\n+        assert!(s.capacity() >= 12 * u32::BITS);\n+        s.reserve_exact(7 * u32::BITS);\n+        assert!(s.capacity() >= 12 * u32::BITS);\n+        s.reserve(7 * u32::BITS + 1);\n+        assert!(s.capacity() >= 12 * u32::BITS + 1);\n+        // Check that length hasn't changed\n+        assert_eq!(s.len(), 5 * u32::BITS);\n+        s.push(true);\n+        s.push(false);\n+        s.push(true);\n+        assert_eq!(s[5 * u32::BITS - 1], true);\n+        assert_eq!(s[5 * u32::BITS - 0], true);\n+        assert_eq!(s[5 * u32::BITS + 1], false);\n+        assert_eq!(s[5 * u32::BITS + 2], true);\n+    }\n+\n+    #[test]\n+    fn test_bitv_grow() {\n+        let mut bitv = Bitv::from_bytes(&[0b10110110, 0b00000000, 0b10101010]);\n+        bitv.grow(32, true);\n+        assert_eq!(bitv, Bitv::from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n+                                     0xFF, 0xFF, 0xFF, 0xFF]));\n+        bitv.grow(64, false);\n+        assert_eq!(bitv, Bitv::from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n+                                     0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0]));\n+        bitv.grow(16, true);\n+        assert_eq!(bitv, Bitv::from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n+                                     0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF]));\n+    }\n+\n+    #[test]\n+    fn test_bitv_extend() {\n+        let mut bitv = Bitv::from_bytes(&[0b10110110, 0b00000000, 0b11111111]);\n+        let ext = Bitv::from_bytes(&[0b01001001, 0b10010010, 0b10111101]);\n+        bitv.extend(ext.iter());\n+        assert_eq!(bitv, Bitv::from_bytes(&[0b10110110, 0b00000000, 0b11111111,\n+                                     0b01001001, 0b10010010, 0b10111101]));\n+    }\n+}\n+\n+\n+\n+\n+#[cfg(test)]\n+mod bitv_bench {\n+    use std::prelude::*;\n+    use std::rand;\n+    use std::rand::Rng;\n+    use std::u32;\n+    use test::{Bencher, black_box};\n+\n+    use super::Bitv;\n+\n+    static BENCH_BITS : uint = 1 << 14;\n+\n+    fn rng() -> rand::IsaacRng {\n+        let seed: &[_] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n+        rand::SeedableRng::from_seed(seed)\n+    }\n+\n+    #[bench]\n+    fn bench_uint_small(b: &mut Bencher) {\n+        let mut r = rng();\n+        let mut bitv = 0 as uint;\n+        b.iter(|| {\n+            for _ in range(0u, 100) {\n+                bitv |= 1 << ((r.next_u32() as uint) % u32::BITS);\n+            }\n+            black_box(&bitv)\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_bitv_set_big_fixed(b: &mut Bencher) {\n+        let mut r = rng();\n+        let mut bitv = Bitv::from_elem(BENCH_BITS, false);\n+        b.iter(|| {\n+            for _ in range(0u, 100) {\n+                bitv.set((r.next_u32() as uint) % BENCH_BITS, true);\n+            }\n+            black_box(&bitv)\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_bitv_set_big_variable(b: &mut Bencher) {\n+        let mut r = rng();\n+        let mut bitv = Bitv::from_elem(BENCH_BITS, false);\n+        b.iter(|| {\n+            for _ in range(0u, 100) {\n+                bitv.set((r.next_u32() as uint) % BENCH_BITS, r.gen());\n+            }\n+            black_box(&bitv);\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_bitv_set_small(b: &mut Bencher) {\n+        let mut r = rng();\n+        let mut bitv = Bitv::from_elem(u32::BITS, false);\n+        b.iter(|| {\n+            for _ in range(0u, 100) {\n+                bitv.set((r.next_u32() as uint) % u32::BITS, true);\n+            }\n+            black_box(&bitv);\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_bitv_big_union(b: &mut Bencher) {\n+        let mut b1 = Bitv::from_elem(BENCH_BITS, false);\n+        let b2 = Bitv::from_elem(BENCH_BITS, false);\n+        b.iter(|| {\n+            b1.union(&b2)\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_bitv_small_iter(b: &mut Bencher) {\n+        let bitv = Bitv::from_elem(u32::BITS, false);\n+        b.iter(|| {\n+            let mut sum = 0u;\n+            for _ in range(0u, 10) {\n+                for pres in bitv.iter() {\n+                    sum += pres as uint;\n+                }\n+            }\n+            sum\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_bitv_big_iter(b: &mut Bencher) {\n+        let bitv = Bitv::from_elem(BENCH_BITS, false);\n+        b.iter(|| {\n+            let mut sum = 0u;\n+            for pres in bitv.iter() {\n+                sum += pres as uint;\n+            }\n+            sum\n+        })\n+    }\n+}\n+\n+\n+\n+\n+\n+\n+\n+#[cfg(test)]\n+mod bitv_set_test {\n+    use prelude::*;\n+    use std::iter::range_step;\n+\n+    use super::{Bitv, BitvSet};\n+\n+    #[test]\n+    fn test_bitv_set_show() {\n+        let mut s = BitvSet::new();\n+        s.insert(1);\n+        s.insert(10);\n+        s.insert(50);\n+        s.insert(2);\n+        assert_eq!(\"{1, 2, 10, 50}\", s.to_string());\n+    }\n+\n+    #[test]\n+    fn test_bitv_set_from_uints() {\n+        let uints = vec![0, 2, 2, 3];\n+        let a: BitvSet = uints.into_iter().collect();\n+        let mut b = BitvSet::new();\n+        b.insert(0);\n+        b.insert(2);\n+        b.insert(3);\n+        assert_eq!(a, b);\n+    }\n+\n+    #[test]\n+    fn test_bitv_set_iterator() {\n+        let uints = vec![0, 2, 2, 3];\n+        let bitv: BitvSet = uints.into_iter().collect();\n+\n+        let idxs: Vec<uint> = bitv.iter().collect();\n+        assert_eq!(idxs, vec![0, 2, 3]);\n+\n+        let long: BitvSet = range(0u, 10000).filter(|&n| n % 2 == 0).collect();\n+        let real = range_step(0, 10000, 2).collect::<Vec<uint>>();\n+\n+        let idxs: Vec<uint> = long.iter().collect();\n+        assert_eq!(idxs, real);\n+    }\n+\n+    #[test]\n+    fn test_bitv_set_frombitv_init() {\n+        let bools = [true, false];\n+        let lengths = [10, 64, 100];\n+        for &b in bools.iter() {\n+            for &l in lengths.iter() {\n+                let bitset = BitvSet::from_bitv(Bitv::from_elem(l, b));\n+                assert_eq!(bitset.contains(&1u), b);\n+                assert_eq!(bitset.contains(&(l-1u)), b);\n+                assert!(!bitset.contains(&l));\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_bitv_masking() {\n+        let b = Bitv::from_elem(140, true);\n+        let mut bs = BitvSet::from_bitv(b);\n+        assert!(bs.contains(&139));\n+        assert!(!bs.contains(&140));\n+        assert!(bs.insert(150));\n+        assert!(!bs.contains(&140));\n+        assert!(!bs.contains(&149));\n+        assert!(bs.contains(&150));\n+        assert!(!bs.contains(&151));\n+    }\n+\n+    #[test]\n+    fn test_bitv_set_basic() {\n+        let mut b = BitvSet::new();\n+        assert!(b.insert(3));\n+        assert!(!b.insert(3));\n+        assert!(b.contains(&3));\n+        assert!(b.insert(4));\n+        assert!(!b.insert(4));\n+        assert!(b.contains(&3));\n+        assert!(b.insert(400));\n+        assert!(!b.insert(400));\n+        assert!(b.contains(&400));\n+        assert_eq!(b.len(), 3);\n+    }\n+\n+    #[test]\n+    fn test_bitv_set_intersection() {\n+        let mut a = BitvSet::new();\n+        let mut b = BitvSet::new();\n+\n+        assert!(a.insert(11));\n+        assert!(a.insert(1));\n         assert!(a.insert(3));\n         assert!(a.insert(77));\n         assert!(a.insert(103));\n@@ -2313,10 +2755,10 @@ mod tests {\n \n     #[test]\n     fn test_bitv_set_is_disjoint() {\n-        let a = BitvSet::from_bitv(from_bytes(&[0b10100010]));\n-        let b = BitvSet::from_bitv(from_bytes(&[0b01000000]));\n+        let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n+        let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b01000000]));\n         let c = BitvSet::new();\n-        let d = BitvSet::from_bitv(from_bytes(&[0b00110000]));\n+        let d = BitvSet::from_bitv(Bitv::from_bytes(&[0b00110000]));\n \n         assert!(!a.is_disjoint(&d));\n         assert!(!d.is_disjoint(&a));\n@@ -2336,13 +2778,13 @@ mod tests {\n         a.insert(0);\n         let mut b = BitvSet::new();\n         b.insert(5);\n-        let expected = BitvSet::from_bitv(from_bytes(&[0b10000100]));\n+        let expected = BitvSet::from_bitv(Bitv::from_bytes(&[0b10000100]));\n         a.union_with(&b);\n         assert_eq!(a, expected);\n \n         // Standard\n-        let mut a = BitvSet::from_bitv(from_bytes(&[0b10100010]));\n-        let mut b = BitvSet::from_bitv(from_bytes(&[0b01100010]));\n+        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n+        let mut b = BitvSet::from_bitv(Bitv::from_bytes(&[0b01100010]));\n         let c = a.clone();\n         a.union_with(&b);\n         b.union_with(&c);\n@@ -2353,16 +2795,16 @@ mod tests {\n     #[test]\n     fn test_bitv_set_intersect_with() {\n         // Explicitly 0'ed bits\n-        let mut a = BitvSet::from_bitv(from_bytes(&[0b10100010]));\n-        let mut b = BitvSet::from_bitv(from_bytes(&[0b00000000]));\n+        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n+        let mut b = BitvSet::from_bitv(Bitv::from_bytes(&[0b00000000]));\n         let c = a.clone();\n         a.intersect_with(&b);\n         b.intersect_with(&c);\n         assert!(a.is_empty());\n         assert!(b.is_empty());\n \n         // Uninitialized bits should behave like 0's\n-        let mut a = BitvSet::from_bitv(from_bytes(&[0b10100010]));\n+        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n         let mut b = BitvSet::new();\n         let c = a.clone();\n         a.intersect_with(&b);\n@@ -2371,8 +2813,8 @@ mod tests {\n         assert!(b.is_empty());\n \n         // Standard\n-        let mut a = BitvSet::from_bitv(from_bytes(&[0b10100010]));\n-        let mut b = BitvSet::from_bitv(from_bytes(&[0b01100010]));\n+        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n+        let mut b = BitvSet::from_bitv(Bitv::from_bytes(&[0b01100010]));\n         let c = a.clone();\n         a.intersect_with(&b);\n         b.intersect_with(&c);\n@@ -2383,20 +2825,20 @@ mod tests {\n     #[test]\n     fn test_bitv_set_difference_with() {\n         // Explicitly 0'ed bits\n-        let mut a = BitvSet::from_bitv(from_bytes(&[0b00000000]));\n-        let b = BitvSet::from_bitv(from_bytes(&[0b10100010]));\n+        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b00000000]));\n+        let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n         a.difference_with(&b);\n         assert!(a.is_empty());\n \n         // Uninitialized bits should behave like 0's\n         let mut a = BitvSet::new();\n-        let b = BitvSet::from_bitv(from_bytes(&[0b11111111]));\n+        let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b11111111]));\n         a.difference_with(&b);\n         assert!(a.is_empty());\n \n         // Standard\n-        let mut a = BitvSet::from_bitv(from_bytes(&[0b10100010]));\n-        let mut b = BitvSet::from_bitv(from_bytes(&[0b01100010]));\n+        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n+        let mut b = BitvSet::from_bitv(Bitv::from_bytes(&[0b01100010]));\n         let c = a.clone();\n         a.difference_with(&b);\n         b.difference_with(&c);\n@@ -2413,19 +2855,19 @@ mod tests {\n         let mut b = BitvSet::new();\n         b.insert(1);\n         b.insert(5);\n-        let expected = BitvSet::from_bitv(from_bytes(&[0b10000100]));\n+        let expected = BitvSet::from_bitv(Bitv::from_bytes(&[0b10000100]));\n         a.symmetric_difference_with(&b);\n         assert_eq!(a, expected);\n \n-        let mut a = BitvSet::from_bitv(from_bytes(&[0b10100010]));\n+        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n         let b = BitvSet::new();\n         let c = a.clone();\n         a.symmetric_difference_with(&b);\n         assert_eq!(a, c);\n \n         // Standard\n-        let mut a = BitvSet::from_bitv(from_bytes(&[0b11100010]));\n-        let mut b = BitvSet::from_bitv(from_bytes(&[0b01101010]));\n+        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b11100010]));\n+        let mut b = BitvSet::from_bitv(Bitv::from_bytes(&[0b01101010]));\n         let c = a.clone();\n         a.symmetric_difference_with(&b);\n         b.symmetric_difference_with(&c);\n@@ -2435,8 +2877,8 @@ mod tests {\n \n     #[test]\n     fn test_bitv_set_eq() {\n-        let a = BitvSet::from_bitv(from_bytes(&[0b10100010]));\n-        let b = BitvSet::from_bitv(from_bytes(&[0b00000000]));\n+        let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n+        let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b00000000]));\n         let c = BitvSet::new();\n \n         assert!(a == a);\n@@ -2449,8 +2891,8 @@ mod tests {\n \n     #[test]\n     fn test_bitv_set_cmp() {\n-        let a = BitvSet::from_bitv(from_bytes(&[0b10100010]));\n-        let b = BitvSet::from_bitv(from_bytes(&[0b00000000]));\n+        let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n+        let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b00000000]));\n         let c = BitvSet::new();\n \n         assert_eq!(a.cmp(&b), Greater);\n@@ -2474,38 +2916,6 @@ mod tests {\n         assert!(a.insert(1000));\n         assert!(a.remove(&1000));\n         a.shrink_to_fit();\n-        assert_eq!(a.capacity(), u32::BITS);\n-    }\n-\n-    #[test]\n-    fn test_bitv_lt() {\n-        let mut a = Bitv::with_capacity(5u, false);\n-        let mut b = Bitv::with_capacity(5u, false);\n-\n-        assert!(!(a < b) && !(b < a));\n-        b.set(2, true);\n-        assert!(a < b);\n-        a.set(3, true);\n-        assert!(a < b);\n-        a.set(2, true);\n-        assert!(!(a < b) && b < a);\n-        b.set(0, true);\n-        assert!(a < b);\n-    }\n-\n-    #[test]\n-    fn test_ord() {\n-        let mut a = Bitv::with_capacity(5u, false);\n-        let mut b = Bitv::with_capacity(5u, false);\n-\n-        assert!(a <= b && a >= b);\n-        a.set(1, true);\n-        assert!(a > b && a >= b);\n-        assert!(b < a && b <= a);\n-        b.set(1, true);\n-        b.set(2, true);\n-        assert!(b > a && b >= a);\n-        assert!(a < b && a <= b);\n     }\n \n     #[test]\n@@ -2526,206 +2936,29 @@ mod tests {\n         assert!(a.remove(&1000));\n         assert!(b.contains(&1000));\n     }\n+}\n \n-    #[test]\n-    fn test_small_bitv_tests() {\n-        let v = from_bytes(&[0]);\n-        assert!(!v.all());\n-        assert!(!v.any());\n-        assert!(v.none());\n-\n-        let v = from_bytes(&[0b00010100]);\n-        assert!(!v.all());\n-        assert!(v.any());\n-        assert!(!v.none());\n-\n-        let v = from_bytes(&[0xFF]);\n-        assert!(v.all());\n-        assert!(v.any());\n-        assert!(!v.none());\n-    }\n-\n-    #[test]\n-    fn test_big_bitv_tests() {\n-        let v = from_bytes(&[ // 88 bits\n-            0, 0, 0, 0,\n-            0, 0, 0, 0,\n-            0, 0, 0]);\n-        assert!(!v.all());\n-        assert!(!v.any());\n-        assert!(v.none());\n-\n-        let v = from_bytes(&[ // 88 bits\n-            0, 0, 0b00010100, 0,\n-            0, 0, 0, 0b00110100,\n-            0, 0, 0]);\n-        assert!(!v.all());\n-        assert!(v.any());\n-        assert!(!v.none());\n-\n-        let v = from_bytes(&[ // 88 bits\n-            0xFF, 0xFF, 0xFF, 0xFF,\n-            0xFF, 0xFF, 0xFF, 0xFF,\n-            0xFF, 0xFF, 0xFF]);\n-        assert!(v.all());\n-        assert!(v.any());\n-        assert!(!v.none());\n-    }\n-\n-    #[test]\n-    fn test_bitv_push_pop() {\n-        let mut s = Bitv::with_capacity(5 * u32::BITS - 2, false);\n-        assert_eq!(s.len(), 5 * u32::BITS - 2);\n-        assert_eq!(s.get(5 * u32::BITS - 3), false);\n-        s.push(true);\n-        s.push(true);\n-        assert_eq!(s.get(5 * u32::BITS - 2), true);\n-        assert_eq!(s.get(5 * u32::BITS - 1), true);\n-        // Here the internal vector will need to be extended\n-        s.push(false);\n-        assert_eq!(s.get(5 * u32::BITS), false);\n-        s.push(false);\n-        assert_eq!(s.get(5 * u32::BITS + 1), false);\n-        assert_eq!(s.len(), 5 * u32::BITS + 2);\n-        // Pop it all off\n-        assert_eq!(s.pop(), false);\n-        assert_eq!(s.pop(), false);\n-        assert_eq!(s.pop(), true);\n-        assert_eq!(s.pop(), true);\n-        assert_eq!(s.len(), 5 * u32::BITS - 2);\n-    }\n \n-    #[test]\n-    fn test_bitv_truncate() {\n-        let mut s = Bitv::with_capacity(5 * u32::BITS, true);\n \n-        assert_eq!(s, Bitv::with_capacity(5 * u32::BITS, true));\n-        assert_eq!(s.len(), 5 * u32::BITS);\n-        s.truncate(4 * u32::BITS);\n-        assert_eq!(s, Bitv::with_capacity(4 * u32::BITS, true));\n-        assert_eq!(s.len(), 4 * u32::BITS);\n-        // Truncating to a size > s.len() should be a noop\n-        s.truncate(5 * u32::BITS);\n-        assert_eq!(s, Bitv::with_capacity(4 * u32::BITS, true));\n-        assert_eq!(s.len(), 4 * u32::BITS);\n-        s.truncate(3 * u32::BITS - 10);\n-        assert_eq!(s, Bitv::with_capacity(3 * u32::BITS - 10, true));\n-        assert_eq!(s.len(), 3 * u32::BITS - 10);\n-        s.truncate(0);\n-        assert_eq!(s, Bitv::with_capacity(0, true));\n-        assert_eq!(s.len(), 0);\n-    }\n \n-    #[test]\n-    fn test_bitv_reserve() {\n-        let mut s = Bitv::with_capacity(5 * u32::BITS, true);\n-        // Check capacity\n-        assert_eq!(s.capacity(), 5 * u32::BITS);\n-        s.reserve(2 * u32::BITS);\n-        assert_eq!(s.capacity(), 5 * u32::BITS);\n-        s.reserve(7 * u32::BITS);\n-        assert_eq!(s.capacity(), 7 * u32::BITS);\n-        s.reserve(7 * u32::BITS);\n-        assert_eq!(s.capacity(), 7 * u32::BITS);\n-        s.reserve(7 * u32::BITS + 1);\n-        assert_eq!(s.capacity(), 8 * u32::BITS);\n-        // Check that length hasn't changed\n-        assert_eq!(s.len(), 5 * u32::BITS);\n-        s.push(true);\n-        s.push(false);\n-        s.push(true);\n-        assert_eq!(s.get(5 * u32::BITS - 1), true);\n-        assert_eq!(s.get(5 * u32::BITS - 0), true);\n-        assert_eq!(s.get(5 * u32::BITS + 1), false);\n-        assert_eq!(s.get(5 * u32::BITS + 2), true);\n-    }\n \n-    #[test]\n-    fn test_bitv_grow() {\n-        let mut bitv = from_bytes(&[0b10110110, 0b00000000, 0b10101010]);\n-        bitv.grow(32, true);\n-        assert_eq!(bitv, from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n-                                     0xFF, 0xFF, 0xFF, 0xFF]));\n-        bitv.grow(64, false);\n-        assert_eq!(bitv, from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n-                                     0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0]));\n-        bitv.grow(16, true);\n-        assert_eq!(bitv, from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n-                                     0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF]));\n-    }\n+#[cfg(test)]\n+mod bitv_set_bench {\n+    use std::prelude::*;\n+    use std::rand;\n+    use std::rand::Rng;\n+    use std::u32;\n+    use test::{Bencher, black_box};\n \n-    #[test]\n-    fn test_bitv_extend() {\n-        let mut bitv = from_bytes(&[0b10110110, 0b00000000, 0b11111111]);\n-        let ext = from_bytes(&[0b01001001, 0b10010010, 0b10111101]);\n-        bitv.extend(ext.iter());\n-        assert_eq!(bitv, from_bytes(&[0b10110110, 0b00000000, 0b11111111,\n-                                     0b01001001, 0b10010010, 0b10111101]));\n-    }\n+    use super::{Bitv, BitvSet};\n \n-    #[test]\n-    fn test_bitv_set_show() {\n-        let mut s = BitvSet::new();\n-        s.insert(1);\n-        s.insert(10);\n-        s.insert(50);\n-        s.insert(2);\n-        assert_eq!(\"{1, 2, 10, 50}\", s.to_string());\n-    }\n+    static BENCH_BITS : uint = 1 << 14;\n \n     fn rng() -> rand::IsaacRng {\n         let seed: &[_] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n         rand::SeedableRng::from_seed(seed)\n     }\n \n-    #[bench]\n-    fn bench_uint_small(b: &mut Bencher) {\n-        let mut r = rng();\n-        let mut bitv = 0 as uint;\n-        b.iter(|| {\n-            for _ in range(0u, 100) {\n-                bitv |= 1 << ((r.next_u32() as uint) % u32::BITS);\n-            }\n-            black_box(&bitv)\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_bitv_set_big_fixed(b: &mut Bencher) {\n-        let mut r = rng();\n-        let mut bitv = Bitv::with_capacity(BENCH_BITS, false);\n-        b.iter(|| {\n-            for _ in range(0u, 100) {\n-                bitv.set((r.next_u32() as uint) % BENCH_BITS, true);\n-            }\n-            black_box(&bitv)\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_bitv_set_big_variable(b: &mut Bencher) {\n-        let mut r = rng();\n-        let mut bitv = Bitv::with_capacity(BENCH_BITS, false);\n-        b.iter(|| {\n-            for _ in range(0u, 100) {\n-                bitv.set((r.next_u32() as uint) % BENCH_BITS, r.gen());\n-            }\n-            black_box(&bitv);\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_bitv_set_small(b: &mut Bencher) {\n-        let mut r = rng();\n-        let mut bitv = Bitv::with_capacity(u32::BITS, false);\n-        b.iter(|| {\n-            for _ in range(0u, 100) {\n-                bitv.set((r.next_u32() as uint) % u32::BITS, true);\n-            }\n-            black_box(&bitv);\n-        });\n-    }\n-\n     #[bench]\n     fn bench_bitvset_small(b: &mut Bencher) {\n         let mut r = rng();\n@@ -2750,44 +2983,9 @@ mod tests {\n         });\n     }\n \n-    #[bench]\n-    fn bench_bitv_big_union(b: &mut Bencher) {\n-        let mut b1 = Bitv::with_capacity(BENCH_BITS, false);\n-        let b2 = Bitv::with_capacity(BENCH_BITS, false);\n-        b.iter(|| {\n-            b1.union(&b2)\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_bitv_small_iter(b: &mut Bencher) {\n-        let bitv = Bitv::with_capacity(u32::BITS, false);\n-        b.iter(|| {\n-            let mut sum = 0u;\n-            for _ in range(0u, 10) {\n-                for pres in bitv.iter() {\n-                    sum += pres as uint;\n-                }\n-            }\n-            sum\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_bitv_big_iter(b: &mut Bencher) {\n-        let bitv = Bitv::with_capacity(BENCH_BITS, false);\n-        b.iter(|| {\n-            let mut sum = 0u;\n-            for pres in bitv.iter() {\n-                sum += pres as uint;\n-            }\n-            sum\n-        })\n-    }\n-\n     #[bench]\n     fn bench_bitvset_iter(b: &mut Bencher) {\n-        let bitv = BitvSet::from_bitv(from_fn(BENCH_BITS,\n+        let bitv = BitvSet::from_bitv(Bitv::from_fn(BENCH_BITS,\n                                               |idx| {idx % 3 == 0}));\n         b.iter(|| {\n             let mut sum = 0u;"}, {"sha": "65c644da3d8926dee83b3556c87237424f45ecce", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 55, "deletions": 29, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -88,36 +88,36 @@ pub struct BTreeMap<K, V> {\n }\n \n /// An abstract base over-which all other BTree iterators are built.\n-struct AbsEntries<T> {\n+struct AbsIter<T> {\n     lca: T,\n     left: RingBuf<T>,\n     right: RingBuf<T>,\n     size: uint,\n }\n \n /// An iterator over a BTreeMap's entries.\n-pub struct Entries<'a, K: 'a, V: 'a> {\n-    inner: AbsEntries<Traversal<'a, K, V>>\n+pub struct Iter<'a, K: 'a, V: 'a> {\n+    inner: AbsIter<Traversal<'a, K, V>>\n }\n \n /// A mutable iterator over a BTreeMap's entries.\n-pub struct MutEntries<'a, K: 'a, V: 'a> {\n-    inner: AbsEntries<MutTraversal<'a, K, V>>\n+pub struct IterMut<'a, K: 'a, V: 'a> {\n+    inner: AbsIter<MutTraversal<'a, K, V>>\n }\n \n /// An owning iterator over a BTreeMap's entries.\n-pub struct MoveEntries<K, V> {\n-    inner: AbsEntries<MoveTraversal<K, V>>\n+pub struct IntoIter<K, V> {\n+    inner: AbsIter<MoveTraversal<K, V>>\n }\n \n /// An iterator over a BTreeMap's keys.\n pub struct Keys<'a, K: 'a, V: 'a> {\n-    inner: Map<(&'a K, &'a V), &'a K, Entries<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n+    inner: Map<(&'a K, &'a V), &'a K, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n }\n \n /// An iterator over a BTreeMap's values.\n pub struct Values<'a, K: 'a, V: 'a> {\n-    inner: Map<(&'a K, &'a V), &'a V, Entries<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n+    inner: Map<(&'a K, &'a V), &'a V, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n }\n \n /// A view into a single entry in a map, which may either be vacant or occupied.\n@@ -929,7 +929,7 @@ enum StackOp<T> {\n }\n \n impl<K, V, E, T: Traverse<E> + DoubleEndedIterator<TraversalItem<K, V, E>>>\n-        Iterator<(K, V)> for AbsEntries<T> {\n+        Iterator<(K, V)> for AbsIter<T> {\n     // This function is pretty long, but only because there's a lot of cases to consider.\n     // Our iterator represents two search paths, left and right, to the smallest and largest\n     // elements we have yet to yield. lca represents the least common ancestor of these two paths,\n@@ -995,7 +995,7 @@ impl<K, V, E, T: Traverse<E> + DoubleEndedIterator<TraversalItem<K, V, E>>>\n }\n \n impl<K, V, E, T: Traverse<E> + DoubleEndedIterator<TraversalItem<K, V, E>>>\n-        DoubleEndedIterator<(K, V)> for AbsEntries<T> {\n+        DoubleEndedIterator<(K, V)> for AbsIter<T> {\n     // next_back is totally symmetric to next\n     fn next_back(&mut self) -> Option<(K, V)> {\n         loop {\n@@ -1032,34 +1032,34 @@ impl<K, V, E, T: Traverse<E> + DoubleEndedIterator<TraversalItem<K, V, E>>>\n     }\n }\n \n-impl<'a, K, V> Iterator<(&'a K, &'a V)> for Entries<'a, K, V> {\n+impl<'a, K, V> Iterator<(&'a K, &'a V)> for Iter<'a, K, V> {\n     fn next(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-impl<'a, K, V> DoubleEndedIterator<(&'a K, &'a V)> for Entries<'a, K, V> {\n+impl<'a, K, V> DoubleEndedIterator<(&'a K, &'a V)> for Iter<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next_back() }\n }\n-impl<'a, K, V> ExactSizeIterator<(&'a K, &'a V)> for Entries<'a, K, V> {}\n+impl<'a, K, V> ExactSizeIterator<(&'a K, &'a V)> for Iter<'a, K, V> {}\n \n \n-impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for MutEntries<'a, K, V> {\n+impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for IterMut<'a, K, V> {\n     fn next(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-impl<'a, K, V> DoubleEndedIterator<(&'a K, &'a mut V)> for MutEntries<'a, K, V> {\n+impl<'a, K, V> DoubleEndedIterator<(&'a K, &'a mut V)> for IterMut<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next_back() }\n }\n-impl<'a, K, V> ExactSizeIterator<(&'a K, &'a mut V)> for MutEntries<'a, K, V> {}\n+impl<'a, K, V> ExactSizeIterator<(&'a K, &'a mut V)> for IterMut<'a, K, V> {}\n \n \n-impl<K, V> Iterator<(K, V)> for MoveEntries<K, V> {\n+impl<K, V> Iterator<(K, V)> for IntoIter<K, V> {\n     fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-impl<K, V> DoubleEndedIterator<(K, V)> for MoveEntries<K, V> {\n+impl<K, V> DoubleEndedIterator<(K, V)> for IntoIter<K, V> {\n     fn next_back(&mut self) -> Option<(K, V)> { self.inner.next_back() }\n }\n-impl<K, V> ExactSizeIterator<(K, V)> for MoveEntries<K, V> {}\n+impl<K, V> ExactSizeIterator<(K, V)> for IntoIter<K, V> {}\n \n \n impl<'a, K, V> Iterator<&'a K> for Keys<'a, K, V> {\n@@ -1140,10 +1140,10 @@ impl<K, V> BTreeMap<K, V> {\n     /// assert_eq!((*first_key, *first_value), (1u, \"a\"));\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter<'a>(&'a self) -> Entries<'a, K, V> {\n+    pub fn iter<'a>(&'a self) -> Iter<'a, K, V> {\n         let len = self.len();\n-        Entries {\n-            inner: AbsEntries {\n+        Iter {\n+            inner: AbsIter {\n                 lca: Traverse::traverse(&self.root),\n                 left: RingBuf::new(),\n                 right: RingBuf::new(),\n@@ -1172,10 +1172,10 @@ impl<K, V> BTreeMap<K, V> {\n     /// }\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter_mut<'a>(&'a mut self) -> MutEntries<'a, K, V> {\n+    pub fn iter_mut<'a>(&'a mut self) -> IterMut<'a, K, V> {\n         let len = self.len();\n-        MutEntries {\n-            inner: AbsEntries {\n+        IterMut {\n+            inner: AbsIter {\n                 lca: Traverse::traverse(&mut self.root),\n                 left: RingBuf::new(),\n                 right: RingBuf::new(),\n@@ -1201,10 +1201,10 @@ impl<K, V> BTreeMap<K, V> {\n     /// }\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn into_iter(self) -> MoveEntries<K, V> {\n+    pub fn into_iter(self) -> IntoIter<K, V> {\n         let len = self.len();\n-        MoveEntries {\n-            inner: AbsEntries {\n+        IntoIter {\n+            inner: AbsIter {\n                 lca: Traverse::traverse(self.root),\n                 left: RingBuf::new(),\n                 right: RingBuf::new(),\n@@ -1230,6 +1230,7 @@ impl<K, V> BTreeMap<K, V> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n+        let first: fn((&'a K, &'a V)) -> &'a K = first; // coerce to fn pointer\n \n         Keys { inner: self.iter().map(first) }\n     }\n@@ -1251,6 +1252,7 @@ impl<K, V> BTreeMap<K, V> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n         fn second<A, B>((_, b): (A, B)) -> B { b }\n+        let second: fn((&'a K, &'a V)) -> &'a V = second; // coerce to fn pointer\n \n         Values { inner: self.iter().map(second) }\n     }\n@@ -1288,6 +1290,30 @@ impl<K, V> BTreeMap<K, V> {\n \n impl<K: Ord, V> BTreeMap<K, V> {\n     /// Gets the given key's corresponding entry in the map for in-place manipulation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut count: BTreeMap<&str, uint> = BTreeMap::new();\n+    ///\n+    /// // count the number of occurrences of letters in the vec\n+    /// for x in vec![\"a\",\"b\",\"a\",\"c\",\"a\",\"b\"].iter() {\n+    ///     match count.entry(*x) {\n+    ///         Entry::Vacant(view) => {\n+    ///             view.set(1);\n+    ///         },\n+    ///         Entry::Occupied(mut view) => {\n+    ///             let v = view.get_mut();\n+    ///             *v += 1;\n+    ///         },\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(count[\"a\"], 3u);\n+    /// ```\n     pub fn entry<'a>(&'a mut self, mut key: K) -> Entry<'a, K, V> {\n         // same basic logic of `swap` and `pop`, blended together\n         let mut stack = stack::PartialSearchStack::new(self);"}, {"sha": "2c3c546fdb7ff9c924984e491c4e625e6b17443b", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -1382,14 +1382,14 @@ pub enum TraversalItem<K, V, E> {\n }\n \n /// A traversal over a node's entries and edges\n-pub type Traversal<'a, K, V> = AbsTraversal<ElemsAndEdges<Zip<slice::Items<'a, K>,\n-                                                              slice::Items<'a, V>>,\n-                                                              slice::Items<'a, Node<K, V>>>>;\n+pub type Traversal<'a, K, V> = AbsTraversal<ElemsAndEdges<Zip<slice::Iter<'a, K>,\n+                                                              slice::Iter<'a, V>>,\n+                                                              slice::Iter<'a, Node<K, V>>>>;\n \n /// A mutable traversal over a node's entries and edges\n-pub type MutTraversal<'a, K, V> = AbsTraversal<ElemsAndEdges<Zip<slice::Items<'a, K>,\n-                                                                 slice::MutItems<'a, V>>,\n-                                                                 slice::MutItems<'a, Node<K, V>>>>;\n+pub type MutTraversal<'a, K, V> = AbsTraversal<ElemsAndEdges<Zip<slice::Iter<'a, K>,\n+                                                                 slice::IterMut<'a, V>>,\n+                                                                 slice::IterMut<'a, Node<K, V>>>>;\n \n /// An owning traversal over a node's entries and edges\n pub type MoveTraversal<K, V> = AbsTraversal<MoveTraversalImpl<K, V>>;"}, {"sha": "2935692ed1580d9537b1cb5d0f0a900e6b4bdf5a", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 39, "deletions": 38, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -13,7 +13,7 @@\n \n use core::prelude::*;\n \n-use btree_map::{BTreeMap, Keys, MoveEntries};\n+use btree_map::{BTreeMap, Keys};\n use std::hash::Hash;\n use core::borrow::BorrowFrom;\n use core::default::Default;\n@@ -33,37 +33,37 @@ pub struct BTreeSet<T>{\n }\n \n /// An iterator over a BTreeSet's items.\n-pub struct Items<'a, T: 'a> {\n+pub struct Iter<'a, T: 'a> {\n     iter: Keys<'a, T, ()>\n }\n \n /// An owning iterator over a BTreeSet's items.\n-pub struct MoveItems<T> {\n-    iter: Map<(T, ()), T, MoveEntries<T, ()>, fn((T, ())) -> T>\n+pub struct IntoIter<T> {\n+    iter: Map<(T, ()), T, ::btree_map::IntoIter<T, ()>, fn((T, ())) -> T>\n }\n \n /// A lazy iterator producing elements in the set difference (in-order).\n-pub struct DifferenceItems<'a, T:'a> {\n-    a: Peekable<&'a T, Items<'a, T>>,\n-    b: Peekable<&'a T, Items<'a, T>>,\n+pub struct Difference<'a, T:'a> {\n+    a: Peekable<&'a T, Iter<'a, T>>,\n+    b: Peekable<&'a T, Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set symmetric difference (in-order).\n-pub struct SymDifferenceItems<'a, T:'a> {\n-    a: Peekable<&'a T, Items<'a, T>>,\n-    b: Peekable<&'a T, Items<'a, T>>,\n+pub struct SymmetricDifference<'a, T:'a> {\n+    a: Peekable<&'a T, Iter<'a, T>>,\n+    b: Peekable<&'a T, Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set intersection (in-order).\n-pub struct IntersectionItems<'a, T:'a> {\n-    a: Peekable<&'a T, Items<'a, T>>,\n-    b: Peekable<&'a T, Items<'a, T>>,\n+pub struct Intersection<'a, T:'a> {\n+    a: Peekable<&'a T, Iter<'a, T>>,\n+    b: Peekable<&'a T, Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set union (in-order).\n-pub struct UnionItems<'a, T:'a> {\n-    a: Peekable<&'a T, Items<'a, T>>,\n-    b: Peekable<&'a T, Items<'a, T>>,\n+pub struct Union<'a, T:'a> {\n+    a: Peekable<&'a T, Iter<'a, T>>,\n+    b: Peekable<&'a T, Iter<'a, T>>,\n }\n \n impl<T: Ord> BTreeSet<T> {\n@@ -107,8 +107,8 @@ impl<T> BTreeSet<T> {\n     /// assert_eq!(v, vec![1u,2,3,4]);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter<'a>(&'a self) -> Items<'a, T> {\n-        Items { iter: self.map.keys() }\n+    pub fn iter<'a>(&'a self) -> Iter<'a, T> {\n+        Iter { iter: self.map.keys() }\n     }\n \n     /// Gets an iterator for moving out the BtreeSet's contents.\n@@ -124,10 +124,11 @@ impl<T> BTreeSet<T> {\n     /// assert_eq!(v, vec![1u,2,3,4]);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn into_iter(self) -> MoveItems<T> {\n+    pub fn into_iter(self) -> IntoIter<T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n+        let first: fn((T, ())) -> T = first; // coerce to fn pointer\n \n-        MoveItems { iter: self.map.into_iter().map(first) }\n+        IntoIter { iter: self.map.into_iter().map(first) }\n     }\n }\n \n@@ -151,8 +152,8 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(diff, vec![1u]);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> DifferenceItems<'a, T> {\n-        DifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+    pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> Difference<'a, T> {\n+        Difference{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n     /// Visits the values representing the symmetric difference, in ascending order.\n@@ -175,8 +176,8 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a BTreeSet<T>)\n-        -> SymDifferenceItems<'a, T> {\n-        SymDifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+        -> SymmetricDifference<'a, T> {\n+        SymmetricDifference{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n     /// Visits the values representing the intersection, in ascending order.\n@@ -199,8 +200,8 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>)\n-        -> IntersectionItems<'a, T> {\n-        IntersectionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+        -> Intersection<'a, T> {\n+        Intersection{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n     /// Visits the values representing the union, in ascending order.\n@@ -220,8 +221,8 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(union, vec![1u,2]);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> UnionItems<'a, T> {\n-        UnionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+    pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> Union<'a, T> {\n+        Union{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n     /// Return the number of elements in the set\n@@ -544,24 +545,24 @@ impl<T: Show> Show for BTreeSet<T> {\n     }\n }\n \n-impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n+impl<'a, T> Iterator<&'a T> for Iter<'a, T> {\n     fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n-impl<'a, T> DoubleEndedIterator<&'a T> for Items<'a, T> {\n+impl<'a, T> DoubleEndedIterator<&'a T> for Iter<'a, T> {\n     fn next_back(&mut self) -> Option<&'a T> { self.iter.next_back() }\n }\n-impl<'a, T> ExactSizeIterator<&'a T> for Items<'a, T> {}\n+impl<'a, T> ExactSizeIterator<&'a T> for Iter<'a, T> {}\n \n \n-impl<T> Iterator<T> for MoveItems<T> {\n+impl<T> Iterator<T> for IntoIter<T> {\n     fn next(&mut self) -> Option<T> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n-impl<T> DoubleEndedIterator<T> for MoveItems<T> {\n+impl<T> DoubleEndedIterator<T> for IntoIter<T> {\n     fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n }\n-impl<T> ExactSizeIterator<T> for MoveItems<T> {}\n+impl<T> ExactSizeIterator<T> for IntoIter<T> {}\n \n /// Compare `x` and `y`, but return `short` if x is None and `long` if y is None\n fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>,\n@@ -573,7 +574,7 @@ fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>,\n     }\n }\n \n-impl<'a, T: Ord> Iterator<&'a T> for DifferenceItems<'a, T> {\n+impl<'a, T: Ord> Iterator<&'a T> for Difference<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match cmp_opt(self.a.peek(), self.b.peek(), Less, Less) {\n@@ -585,7 +586,7 @@ impl<'a, T: Ord> Iterator<&'a T> for DifferenceItems<'a, T> {\n     }\n }\n \n-impl<'a, T: Ord> Iterator<&'a T> for SymDifferenceItems<'a, T> {\n+impl<'a, T: Ord> Iterator<&'a T> for SymmetricDifference<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n@@ -597,7 +598,7 @@ impl<'a, T: Ord> Iterator<&'a T> for SymDifferenceItems<'a, T> {\n     }\n }\n \n-impl<'a, T: Ord> Iterator<&'a T> for IntersectionItems<'a, T> {\n+impl<'a, T: Ord> Iterator<&'a T> for Intersection<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             let o_cmp = match (self.a.peek(), self.b.peek()) {\n@@ -615,7 +616,7 @@ impl<'a, T: Ord> Iterator<&'a T> for IntersectionItems<'a, T> {\n     }\n }\n \n-impl<'a, T: Ord> Iterator<&'a T> for UnionItems<'a, T> {\n+impl<'a, T: Ord> Iterator<&'a T> for Union<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {"}, {"sha": "de2a7307440120f4d9f84a6daa51120628a3ad49", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -51,21 +51,21 @@ struct Node<T> {\n }\n \n /// An iterator over references to the items of a `DList`.\n-pub struct Items<'a, T:'a> {\n+pub struct Iter<'a, T:'a> {\n     head: &'a Link<T>,\n     tail: Rawlink<Node<T>>,\n     nelem: uint,\n }\n \n // FIXME #11820: the &'a Option<> of the Link stops clone working.\n-impl<'a, T> Clone for Items<'a, T> {\n-    fn clone(&self) -> Items<'a, T> { *self }\n+impl<'a, T> Clone for Iter<'a, T> {\n+    fn clone(&self) -> Iter<'a, T> { *self }\n }\n \n-impl<'a,T> Copy for Items<'a,T> {}\n+impl<'a,T> Copy for Iter<'a,T> {}\n \n /// An iterator over mutable references to the items of a `DList`.\n-pub struct MutItems<'a, T:'a> {\n+pub struct IterMut<'a, T:'a> {\n     list: &'a mut DList<T>,\n     head: Rawlink<Node<T>>,\n     tail: Rawlink<Node<T>>,\n@@ -74,7 +74,7 @@ pub struct MutItems<'a, T:'a> {\n \n /// An iterator over mutable references to the items of a `DList`.\n #[deriving(Clone)]\n-pub struct MoveItems<T> {\n+pub struct IntoIter<T> {\n     list: DList<T>\n }\n \n@@ -394,19 +394,19 @@ impl<T> DList<T> {\n     /// Provides a forward iterator.\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter<'a>(&'a self) -> Items<'a, T> {\n-        Items{nelem: self.len(), head: &self.list_head, tail: self.list_tail}\n+    pub fn iter<'a>(&'a self) -> Iter<'a, T> {\n+        Iter{nelem: self.len(), head: &self.list_head, tail: self.list_tail}\n     }\n \n     /// Provides a forward iterator with mutable references.\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T> {\n+    pub fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n         let head_raw = match self.list_head {\n             Some(ref mut h) => Rawlink::some(&mut **h),\n             None => Rawlink::none(),\n         };\n-        MutItems{\n+        IterMut{\n             nelem: self.len(),\n             head: head_raw,\n             tail: self.list_tail,\n@@ -417,8 +417,8 @@ impl<T> DList<T> {\n     /// Consumes the list into an iterator yielding elements by value.\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn into_iter(self) -> MoveItems<T> {\n-        MoveItems{list: self}\n+    pub fn into_iter(self) -> IntoIter<T> {\n+        IntoIter{list: self}\n     }\n \n     /// Returns `true` if the `DList` is empty.\n@@ -451,31 +451,31 @@ impl<T> DList<T> {\n     /// Provides a reference to the front element, or `None` if the list is\n     /// empty.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn front(&self) -> Option<&T> {\n         self.list_head.as_ref().map(|head| &head.value)\n     }\n \n     /// Provides a mutable reference to the front element, or `None` if the list\n     /// is empty.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n         self.list_head.as_mut().map(|head| &mut head.value)\n     }\n \n     /// Provides a reference to the back element, or `None` if the list is\n     /// empty.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn back(&self) -> Option<&T> {\n         self.list_tail.resolve_immut().as_ref().map(|tail| &tail.value)\n     }\n \n     /// Provides a mutable reference to the back element, or `None` if the list\n     /// is empty.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n         self.list_tail.resolve().map(|tail| &mut tail.value)\n     }\n@@ -579,7 +579,7 @@ impl<T> Drop for DList<T> {\n }\n \n \n-impl<'a, A> Iterator<&'a A> for Items<'a, A> {\n+impl<'a, A> Iterator<&'a A> for Iter<'a, A> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a A> {\n         if self.nelem == 0 {\n@@ -598,7 +598,7 @@ impl<'a, A> Iterator<&'a A> for Items<'a, A> {\n     }\n }\n \n-impl<'a, A> DoubleEndedIterator<&'a A> for Items<'a, A> {\n+impl<'a, A> DoubleEndedIterator<&'a A> for Iter<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a A> {\n         if self.nelem == 0 {\n@@ -612,9 +612,9 @@ impl<'a, A> DoubleEndedIterator<&'a A> for Items<'a, A> {\n     }\n }\n \n-impl<'a, A> ExactSizeIterator<&'a A> for Items<'a, A> {}\n+impl<'a, A> ExactSizeIterator<&'a A> for Iter<'a, A> {}\n \n-impl<'a, A> Iterator<&'a mut A> for MutItems<'a, A> {\n+impl<'a, A> Iterator<&'a mut A> for IterMut<'a, A> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut A> {\n         if self.nelem == 0 {\n@@ -636,7 +636,7 @@ impl<'a, A> Iterator<&'a mut A> for MutItems<'a, A> {\n     }\n }\n \n-impl<'a, A> DoubleEndedIterator<&'a mut A> for MutItems<'a, A> {\n+impl<'a, A> DoubleEndedIterator<&'a mut A> for IterMut<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut A> {\n         if self.nelem == 0 {\n@@ -650,7 +650,7 @@ impl<'a, A> DoubleEndedIterator<&'a mut A> for MutItems<'a, A> {\n     }\n }\n \n-impl<'a, A> ExactSizeIterator<&'a mut A> for MutItems<'a, A> {}\n+impl<'a, A> ExactSizeIterator<&'a mut A> for IterMut<'a, A> {}\n \n /// Allows mutating a `DList` while iterating.\n pub trait ListInsertion<A> {\n@@ -664,8 +664,8 @@ pub trait ListInsertion<A> {\n     fn peek_next<'a>(&'a mut self) -> Option<&'a mut A>;\n }\n \n-// private methods for MutItems\n-impl<'a, A> MutItems<'a, A> {\n+// private methods for IterMut\n+impl<'a, A> IterMut<'a, A> {\n     fn insert_next_node(&mut self, mut ins_node: Box<Node<A>>) {\n         // Insert before `self.head` so that it is between the\n         // previously yielded element and self.head.\n@@ -687,7 +687,7 @@ impl<'a, A> MutItems<'a, A> {\n     }\n }\n \n-impl<'a, A> ListInsertion<A> for MutItems<'a, A> {\n+impl<'a, A> ListInsertion<A> for IterMut<'a, A> {\n     #[inline]\n     fn insert_next(&mut self, elt: A) {\n         self.insert_next_node(box Node::new(elt))\n@@ -702,7 +702,7 @@ impl<'a, A> ListInsertion<A> for MutItems<'a, A> {\n     }\n }\n \n-impl<A> Iterator<A> for MoveItems<A> {\n+impl<A> Iterator<A> for IntoIter<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> { self.list.pop_front() }\n \n@@ -712,7 +712,7 @@ impl<A> Iterator<A> for MoveItems<A> {\n     }\n }\n \n-impl<A> DoubleEndedIterator<A> for MoveItems<A> {\n+impl<A> DoubleEndedIterator<A> for IntoIter<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.list.pop_back() }\n }"}, {"sha": "fd04ce94247b7f2a352556dc0c6d519a4b4f3fae", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -178,8 +178,8 @@ impl<E:CLike> EnumSet<E> {\n \n     /// Returns an iterator over an `EnumSet`.\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter(&self) -> Items<E> {\n-        Items::new(self.bits)\n+    pub fn iter(&self) -> Iter<E> {\n+        Iter::new(self.bits)\n     }\n }\n \n@@ -208,18 +208,18 @@ impl<E:CLike> BitXor<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n }\n \n /// An iterator over an EnumSet\n-pub struct Items<E> {\n+pub struct Iter<E> {\n     index: uint,\n     bits: uint,\n }\n \n-impl<E:CLike> Items<E> {\n-    fn new(bits: uint) -> Items<E> {\n-        Items { index: 0, bits: bits }\n+impl<E:CLike> Iter<E> {\n+    fn new(bits: uint) -> Iter<E> {\n+        Iter { index: 0, bits: bits }\n     }\n }\n \n-impl<E:CLike> Iterator<E> for Items<E> {\n+impl<E:CLike> Iterator<E> for Iter<E> {\n     fn next(&mut self) -> Option<E> {\n         if self.bits == 0 {\n             return None;"}, {"sha": "363d30abd0347b02eef24cd234b3abb6a1c08dc7", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -121,15 +121,15 @@ mod prelude {\n     // in core and collections (may differ).\n     pub use slice::{PartialEqSliceExt, OrdSliceExt};\n     pub use slice::{AsSlice, SliceExt};\n-    pub use str::{from_str, Str, StrPrelude};\n+    pub use str::{from_str, Str};\n \n     // from other crates.\n     pub use alloc::boxed::Box;\n     pub use unicode::char::UnicodeChar;\n \n     // from collections.\n     pub use slice::{CloneSliceExt, VectorVector};\n-    pub use str::{IntoMaybeOwned, UnicodeStrPrelude, StrAllocating, StrVector};\n+    pub use str::{IntoMaybeOwned, StrVector};\n     pub use string::{String, ToString};\n     pub use vec::Vec;\n }"}, {"sha": "d4bd9b5228a8a069a3a11af4895a7e71d68512d2", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -228,6 +228,7 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(buf[0], 5);\n     /// assert_eq!(buf[2], 3);\n     /// ```\n+    #[stable]\n     pub fn swap(&mut self, i: uint, j: uint) {\n         assert!(i < self.len());\n         assert!(j < self.len());\n@@ -376,8 +377,8 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(buf.iter().collect::<Vec<&int>>().as_slice(), b);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter(&self) -> Items<T> {\n-        Items {\n+    pub fn iter(&self) -> Iter<T> {\n+        Iter {\n             tail: self.tail,\n             head: self.head,\n             ring: unsafe { self.buffer_as_slice() }\n@@ -402,8 +403,8 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(buf.iter_mut().collect::<Vec<&mut int>>()[], b);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T> {\n-        MutItems {\n+    pub fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n+        IterMut {\n             tail: self.tail,\n             head: self.head,\n             cap: self.cap,\n@@ -414,8 +415,8 @@ impl<T> RingBuf<T> {\n \n     /// Consumes the list into an iterator yielding elements by value.\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn into_iter(self) -> MoveItems<T> {\n-        MoveItems {\n+    pub fn into_iter(self) -> IntoIter<T> {\n+        IntoIter {\n             inner: self,\n         }\n     }\n@@ -546,7 +547,7 @@ impl<T> RingBuf<T> {\n     /// d.push_back(2i);\n     /// assert_eq!(d.front(), Some(&1i));\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn front(&self) -> Option<&T> {\n         if !self.is_empty() { Some(&self[0]) } else { None }\n     }\n@@ -570,7 +571,7 @@ impl<T> RingBuf<T> {\n     /// }\n     /// assert_eq!(d.front(), Some(&9i));\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n         if !self.is_empty() { Some(&mut self[0]) } else { None }\n     }\n@@ -590,7 +591,7 @@ impl<T> RingBuf<T> {\n     /// d.push_back(2i);\n     /// assert_eq!(d.back(), Some(&2i));\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn back(&self) -> Option<&T> {\n         if !self.is_empty() { Some(&self[self.len() - 1]) } else { None }\n     }\n@@ -614,7 +615,7 @@ impl<T> RingBuf<T> {\n     /// }\n     /// assert_eq!(d.back(), Some(&9i));\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n         let len = self.len();\n         if !self.is_empty() { Some(&mut self[len - 1]) } else { None }\n@@ -1122,13 +1123,13 @@ fn count(tail: uint, head: uint, size: uint) -> uint {\n }\n \n /// `RingBuf` iterator.\n-pub struct Items<'a, T:'a> {\n+pub struct Iter<'a, T:'a> {\n     ring: &'a [T],\n     tail: uint,\n     head: uint\n }\n \n-impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n+impl<'a, T> Iterator<&'a T> for Iter<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a T> {\n         if self.tail == self.head {\n@@ -1146,7 +1147,7 @@ impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n     }\n }\n \n-impl<'a, T> DoubleEndedIterator<&'a T> for Items<'a, T> {\n+impl<'a, T> DoubleEndedIterator<&'a T> for Iter<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a T> {\n         if self.tail == self.head {\n@@ -1157,9 +1158,9 @@ impl<'a, T> DoubleEndedIterator<&'a T> for Items<'a, T> {\n     }\n }\n \n-impl<'a, T> ExactSizeIterator<&'a T> for Items<'a, T> {}\n+impl<'a, T> ExactSizeIterator<&'a T> for Iter<'a, T> {}\n \n-impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n+impl<'a, T> RandomAccessIterator<&'a T> for Iter<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n         let (len, _) = self.size_hint();\n@@ -1177,19 +1178,19 @@ impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n     }\n }\n \n-// FIXME This was implemented differently from Items because of a problem\n+// FIXME This was implemented differently from Iter because of a problem\n //       with returning the mutable reference. I couldn't find a way to\n //       make the lifetime checker happy so, but there should be a way.\n /// `RingBuf` mutable iterator.\n-pub struct MutItems<'a, T:'a> {\n+pub struct IterMut<'a, T:'a> {\n     ptr: *mut T,\n     tail: uint,\n     head: uint,\n     cap: uint,\n     marker: marker::ContravariantLifetime<'a>,\n }\n \n-impl<'a, T> Iterator<&'a mut T> for MutItems<'a, T> {\n+impl<'a, T> Iterator<&'a mut T> for IterMut<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut T> {\n         if self.tail == self.head {\n@@ -1210,7 +1211,7 @@ impl<'a, T> Iterator<&'a mut T> for MutItems<'a, T> {\n     }\n }\n \n-impl<'a, T> DoubleEndedIterator<&'a mut T> for MutItems<'a, T> {\n+impl<'a, T> DoubleEndedIterator<&'a mut T> for IterMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut T> {\n         if self.tail == self.head {\n@@ -1224,14 +1225,14 @@ impl<'a, T> DoubleEndedIterator<&'a mut T> for MutItems<'a, T> {\n     }\n }\n \n-impl<'a, T> ExactSizeIterator<&'a mut T> for MutItems<'a, T> {}\n+impl<'a, T> ExactSizeIterator<&'a mut T> for IterMut<'a, T> {}\n \n // A by-value RingBuf iterator\n-pub struct MoveItems<T> {\n+pub struct IntoIter<T> {\n     inner: RingBuf<T>,\n }\n \n-impl<T> Iterator<T> for MoveItems<T> {\n+impl<T> Iterator<T> for IntoIter<T> {\n     #[inline]\n     fn next(&mut self) -> Option<T> {\n         self.inner.pop_front()\n@@ -1244,14 +1245,14 @@ impl<T> Iterator<T> for MoveItems<T> {\n     }\n }\n \n-impl<T> DoubleEndedIterator<T> for MoveItems<T> {\n+impl<T> DoubleEndedIterator<T> for IntoIter<T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n         self.inner.pop_back()\n     }\n }\n \n-impl<T> ExactSizeIterator<T> for MoveItems<T> {}\n+impl<T> ExactSizeIterator<T> for IntoIter<T> {}\n \n /// A draining RingBuf iterator\n pub struct Drain<'a, T: 'a> {"}, {"sha": "d6d94f57acf45b88c6739aa9c3736980c833a799", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -37,7 +37,7 @@\n //!\n //! ## Structs\n //!\n-//! There are several structs that are useful for slices, such as `Items`, which\n+//! There are several structs that are useful for slices, such as `Iter`, which\n //! represents iteration over a slice.\n //!\n //! ## Traits\n@@ -104,7 +104,7 @@ use self::Direction::*;\n use vec::Vec;\n \n pub use core::slice::{Chunks, AsSlice, SplitsN, Windows};\n-pub use core::slice::{Items, MutItems, PartialEqSliceExt};\n+pub use core::slice::{Iter, IterMut, PartialEqSliceExt};\n pub use core::slice::{ImmutableIntSlice, MutableIntSlice};\n pub use core::slice::{MutSplits, MutChunks, Splits};\n pub use core::slice::{bytes, mut_ref_slice, ref_slice};\n@@ -771,7 +771,7 @@ pub trait SliceExt<T> for Sized? {\n \n     /// Returns an iterator over the slice\n     #[unstable = \"iterator type may change\"]\n-    fn iter(&self) -> Items<T>;\n+    fn iter(&self) -> Iter<T>;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`.  The matched element is not contained in the subslices.\n@@ -970,7 +970,7 @@ pub trait SliceExt<T> for Sized? {\n \n     /// Returns an iterator that allows modifying each value\n     #[unstable = \"waiting on iterator type name conventions\"]\n-    fn iter_mut(&mut self) -> MutItems<T>;\n+    fn iter_mut(&mut self) -> IterMut<T>;\n \n     /// Returns a mutable pointer to the first element of a slice, or `None` if it is empty\n     #[unstable = \"name may change\"]\n@@ -1137,7 +1137,7 @@ impl<T> SliceExt<T> for [T] {\n     }\n \n     #[inline]\n-    fn iter<'a>(&'a self) -> Items<'a, T> {\n+    fn iter<'a>(&'a self) -> Iter<'a, T> {\n         core_slice::SliceExt::iter(self)\n     }\n \n@@ -1246,7 +1246,7 @@ impl<T> SliceExt<T> for [T] {\n     }\n \n     #[inline]\n-    fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T> {\n+    fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n         core_slice::SliceExt::iter_mut(self)\n     }\n "}, {"sha": "5feae5e558edfd3baf28197a1b29ad16628792cb", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 1025, "deletions": 152, "changes": 1177, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -56,33 +56,36 @@ use self::RecompositionState::*;\n use self::DecompositionType::*;\n \n use core::borrow::{BorrowFrom, Cow, ToOwned};\n+use core::char::Char;\n use core::clone::Clone;\n+use core::cmp::{Equiv, PartialEq, Eq, PartialOrd, Ord, Ordering};\n+use core::cmp;\n use core::default::Default;\n use core::fmt;\n use core::hash;\n-use core::char::Char;\n-use core::cmp::{mod, Eq, Equiv, Ord, Ordering, PartialEq, PartialOrd};\n-use core::iter::{range, AdditiveIterator, Iterator, IteratorExt};\n+use core::iter::AdditiveIterator;\n+use core::iter::{mod, range, Iterator, IteratorExt};\n use core::kinds::Sized;\n+use core::ops;\n use core::option::Option::{mod, Some, None};\n-use core::slice::{AsSlice, SliceExt};\n+use core::slice::AsSlice;\n+use core::str as core_str;\n+use unicode::str::{UnicodeStr, Utf16Encoder};\n \n use ring_buf::RingBuf;\n+use slice::SliceExt;\n use string::String;\n use unicode;\n use vec::Vec;\n \n-pub use core::str::{from_utf8, CharEq, Chars, CharOffsets};\n-pub use core::str::{Bytes, CharSplits};\n-pub use core::str::{CharSplitsN, AnyLines, MatchIndices, StrSplits};\n-pub use core::str::{Utf16Encoder, Utf16CodeUnits};\n-pub use core::str::{eq_slice, is_utf8, is_utf16, Utf16Items};\n-pub use core::str::{Utf16Item, ScalarValue, LoneSurrogate, utf16_items};\n-pub use core::str::{truncate_utf16_at_nul, utf8_char_width, CharRange};\n-pub use core::str::{FromStr, from_str};\n-pub use core::str::{Str, StrPrelude};\n+pub use core::str::{from_utf8, CharEq, Chars, CharIndices};\n+pub use core::str::{Bytes, CharSplits, is_utf8};\n+pub use core::str::{CharSplitsN, Lines, LinesAny, MatchIndices, StrSplits};\n+pub use core::str::{CharRange};\n+pub use core::str::{FromStr, from_str, Utf8Error};\n+pub use core::str::Str;\n pub use core::str::{from_utf8_unchecked, from_c_str};\n-pub use unicode::str::{UnicodeStrPrelude, Words, Graphemes, GraphemeIndices};\n+pub use unicode::str::{Words, Graphemes, GraphemeIndices};\n \n // FIXME(conventions): ensure bit/char conventions are followed by str's API\n \n@@ -91,6 +94,7 @@ Section: Creating a string\n */\n \n /// Methods for vectors of strings.\n+#[unstable = \"functionality may be replaced with iterators\"]\n pub trait StrVector for Sized? {\n     /// Concatenates a vector of strings.\n     ///\n@@ -117,6 +121,7 @@ pub trait StrVector for Sized? {\n     fn connect(&self, sep: &str) -> String;\n }\n \n+#[allow(deprecated)]\n impl<S: Str> StrVector for [S] {\n     fn concat(&self) -> String {\n         if self.is_empty() {\n@@ -129,7 +134,7 @@ impl<S: Str> StrVector for [S] {\n         let mut result = String::with_capacity(len);\n \n         for s in self.iter() {\n-            result.push_str(s.as_slice())\n+            result.push_str(s.as_slice());\n         }\n \n         result\n@@ -379,6 +384,21 @@ impl<'a> Iterator<char> for Recompositions<'a> {\n     }\n }\n \n+/// External iterator for a string's UTF16 codeunits.\n+/// Use with the `std::iter` module.\n+#[deriving(Clone)]\n+pub struct Utf16Units<'a> {\n+    encoder: Utf16Encoder<Chars<'a>>\n+}\n+\n+impl<'a> Iterator<u16> for Utf16Units<'a> {\n+    #[inline]\n+    fn next(&mut self) -> Option<u16> { self.encoder.next() }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.encoder.size_hint() }\n+}\n+\n /// Replaces all occurrences of one string with another.\n ///\n /// # Arguments\n@@ -394,21 +414,15 @@ impl<'a> Iterator<char> for Recompositions<'a> {\n /// # Examples\n ///\n /// ```rust\n+/// # #![allow(deprecated)]\n /// use std::str;\n /// let string = \"orange\";\n /// let new_string = str::replace(string, \"or\", \"str\");\n /// assert_eq!(new_string.as_slice(), \"strange\");\n /// ```\n+#[deprecated = \"call the inherent method instead\"]\n pub fn replace(s: &str, from: &str, to: &str) -> String {\n-    let mut result = String::new();\n-    let mut last_end = 0;\n-    for (start, end) in s.match_indices(from) {\n-        result.push_str(unsafe { s.slice_unchecked(last_end, start) });\n-        result.push_str(to);\n-        last_end = end;\n-    }\n-    result.push_str(unsafe { s.slice_unchecked(last_end, s.len()) });\n-    result\n+    s.replace(from, to)\n }\n \n /*\n@@ -434,7 +448,7 @@ Section: MaybeOwned\n /// A string type that can hold either a `String` or a `&str`.\n /// This can be useful as an optimization when an allocation is sometimes\n /// needed but not always.\n-#[deprecated = \"use std::str::CowString\"]\n+#[deprecated = \"use std::string::CowString\"]\n pub enum MaybeOwned<'a> {\n     /// A borrowed string.\n     Slice(&'a str),\n@@ -443,9 +457,10 @@ pub enum MaybeOwned<'a> {\n }\n \n /// A specialization of `CowString` to be sendable.\n+#[deprecated = \"use std::string::CowString<'static>\"]\n pub type SendStr = CowString<'static>;\n \n-#[deprecated = \"use std::str::CowString\"]\n+#[deprecated = \"use std::string::CowString\"]\n impl<'a> MaybeOwned<'a> {\n     /// Returns `true` if this `MaybeOwned` wraps an owned string.\n     ///\n@@ -483,6 +498,7 @@ impl<'a> MaybeOwned<'a> {\n \n     /// Return the number of bytes in this string.\n     #[inline]\n+    #[allow(deprecated)]\n     pub fn len(&self) -> uint { self.as_slice().len() }\n \n     /// Returns true if the string contains no bytes\n@@ -545,45 +561,47 @@ impl<'a> IntoMaybeOwned<'a> for MaybeOwned<'a> {\n     fn into_maybe_owned(self) -> MaybeOwned<'a> { self }\n }\n \n-#[deprecated = \"use std::str::CowString\"]\n+#[deprecated = \"use std::string::CowString\"]\n+#[allow(deprecated)]\n impl<'a> PartialEq for MaybeOwned<'a> {\n     #[inline]\n     fn eq(&self, other: &MaybeOwned) -> bool {\n         self.as_slice() == other.as_slice()\n     }\n }\n \n-#[deprecated = \"use std::str::CowString\"]\n+#[deprecated = \"use std::string::CowString\"]\n impl<'a> Eq for MaybeOwned<'a> {}\n \n-#[deprecated = \"use std::str::CowString\"]\n+#[deprecated = \"use std::string::CowString\"]\n impl<'a> PartialOrd for MaybeOwned<'a> {\n     #[inline]\n     fn partial_cmp(&self, other: &MaybeOwned) -> Option<Ordering> {\n         Some(self.cmp(other))\n     }\n }\n \n-#[deprecated = \"use std::str::CowString\"]\n+#[deprecated = \"use std::string::CowString\"]\n impl<'a> Ord for MaybeOwned<'a> {\n     #[inline]\n+    #[allow(deprecated)]\n     fn cmp(&self, other: &MaybeOwned) -> Ordering {\n         self.as_slice().cmp(other.as_slice())\n     }\n }\n \n #[allow(deprecated)]\n-#[deprecated = \"use std::str::CowString\"]\n+#[deprecated = \"use std::string::CowString\"]\n impl<'a, S: Str> Equiv<S> for MaybeOwned<'a> {\n     #[inline]\n     fn equiv(&self, other: &S) -> bool {\n         self.as_slice() == other.as_slice()\n     }\n }\n \n-#[deprecated = \"use std::str::CowString\"]\n+#[deprecated = \"use std::string::CowString\"]\n+#[allow(deprecated)]\n impl<'a> Str for MaybeOwned<'a> {\n-    #[allow(deprecated)]\n     #[inline]\n     fn as_slice<'b>(&'b self) -> &'b str {\n         match *self {\n@@ -593,19 +611,7 @@ impl<'a> Str for MaybeOwned<'a> {\n     }\n }\n \n-#[deprecated = \"use std::str::CowString\"]\n-impl<'a> StrAllocating for MaybeOwned<'a> {\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn into_string(self) -> String {\n-        match self {\n-            Slice(s) => String::from_str(s),\n-            Owned(s) => s\n-        }\n-    }\n-}\n-\n-#[deprecated = \"use std::str::CowString\"]\n+#[deprecated = \"use std::string::CowString\"]\n impl<'a> Clone for MaybeOwned<'a> {\n     #[allow(deprecated)]\n     #[inline]\n@@ -617,22 +623,23 @@ impl<'a> Clone for MaybeOwned<'a> {\n     }\n }\n \n-#[deprecated = \"use std::str::CowString\"]\n+#[deprecated = \"use std::string::CowString\"]\n impl<'a> Default for MaybeOwned<'a> {\n     #[allow(deprecated)]\n     #[inline]\n     fn default() -> MaybeOwned<'a> { Slice(\"\") }\n }\n \n-#[deprecated = \"use std::str::CowString\"]\n+#[deprecated = \"use std::string::CowString\"]\n+#[allow(deprecated)]\n impl<'a, H: hash::Writer> hash::Hash<H> for MaybeOwned<'a> {\n     #[inline]\n     fn hash(&self, hasher: &mut H) {\n         self.as_slice().hash(hasher)\n     }\n }\n \n-#[deprecated = \"use std::str::CowString\"]\n+#[deprecated = \"use std::string::CowString\"]\n impl<'a> fmt::Show for MaybeOwned<'a> {\n     #[inline]\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -650,10 +657,15 @@ impl BorrowFrom<String> for str {\n \n #[unstable = \"trait is unstable\"]\n impl ToOwned<String> for str {\n-    fn to_owned(&self) -> String { self.into_string() }\n+    fn to_owned(&self) -> String {\n+        unsafe {\n+            String::from_utf8_unchecked(self.as_bytes().to_owned())\n+        }\n+    }\n }\n \n /// Unsafe string operations.\n+#[deprecated]\n pub mod raw {\n     pub use core::str::raw::{from_utf8, c_str_to_static_slice, slice_bytes};\n     pub use core::str::raw::{slice_unchecked};\n@@ -664,46 +676,25 @@ Section: CowString\n */\n \n /// A clone-on-write string\n+#[deprecated = \"use std::string::CowString instead\"]\n pub type CowString<'a> = Cow<'a, String, str>;\n \n-impl<'a> Str for CowString<'a> {\n-    #[inline]\n-    fn as_slice<'b>(&'b self) -> &'b str {\n-        (**self).as_slice()\n-    }\n-}\n-\n /*\n Section: Trait implementations\n */\n \n /// Any string that can be represented as a slice.\n-pub trait StrAllocating: Str {\n-    /// Converts `self` into a `String`, not making a copy if possible.\n-    fn into_string(self) -> String;\n-\n+pub trait StrExt for Sized?: ops::Slice<uint, str> {\n     /// Escapes each char in `s` with `char::escape_default`.\n+    #[unstable = \"return type may change to be an iterator\"]\n     fn escape_default(&self) -> String {\n-        let me = self.as_slice();\n-        let mut out = String::with_capacity(me.len());\n-        for c in me.chars() {\n-            for c in c.escape_default() {\n-                out.push(c);\n-            }\n-        }\n-        out\n+        self.chars().flat_map(|c| c.escape_default()).collect()\n     }\n \n     /// Escapes each char in `s` with `char::escape_unicode`.\n+    #[unstable = \"return type may change to be an iterator\"]\n     fn escape_unicode(&self) -> String {\n-        let me = self.as_slice();\n-        let mut out = String::with_capacity(me.len());\n-        for c in me.chars() {\n-            for c in c.escape_unicode() {\n-                out.push(c);\n-            }\n-        }\n-        out\n+        self.chars().flat_map(|c| c.escape_unicode()).collect()\n     }\n \n     /// Replaces all occurrences of one string with another.\n@@ -730,25 +721,31 @@ pub trait StrAllocating: Str {\n     /// // not found, so no change.\n     /// assert_eq!(s.replace(\"cookie monster\", \"little lamb\"), s);\n     /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n     fn replace(&self, from: &str, to: &str) -> String {\n-        replace(self.as_slice(), from, to)\n+        let mut result = String::new();\n+        let mut last_end = 0;\n+        for (start, end) in self.match_indices(from) {\n+            result.push_str(unsafe { self.slice_unchecked(last_end, start) });\n+            result.push_str(to);\n+            last_end = end;\n+        }\n+        result.push_str(unsafe { self.slice_unchecked(last_end, self.len()) });\n+        result\n     }\n \n     /// Given a string, makes a new string with repeated copies of it.\n+    #[deprecated = \"use repeat(self).take(n).collect() instead\"]\n     fn repeat(&self, nn: uint) -> String {\n-        let me = self.as_slice();\n-        let mut ret = String::with_capacity(nn * me.len());\n-        for _ in range(0, nn) {\n-            ret.push_str(me);\n-        }\n-        ret\n+        iter::repeat(self[]).take(nn).collect()\n     }\n \n     /// Returns the Levenshtein Distance between two strings.\n+    #[deprecated = \"this function will be removed\"]\n     fn lev_distance(&self, t: &str) -> uint {\n-        let me = self.as_slice();\n-        if me.is_empty() { return t.char_len(); }\n-        if t.is_empty() { return me.char_len(); }\n+        let me = self[];\n+        if me.is_empty() { return t.chars().count(); }\n+        if t.is_empty() { return me.chars().count(); }\n \n         let mut dcol = Vec::from_fn(t.len() + 1, |x| x);\n         let mut t_last = 0;\n@@ -780,9 +777,10 @@ pub trait StrAllocating: Str {\n     /// Returns an iterator over the string in Unicode Normalization Form D\n     /// (canonical decomposition).\n     #[inline]\n+    #[unstable = \"this functionality may be moved to libunicode\"]\n     fn nfd_chars<'a>(&'a self) -> Decompositions<'a> {\n         Decompositions {\n-            iter: self.as_slice().chars(),\n+            iter: self[].chars(),\n             buffer: Vec::new(),\n             sorted: false,\n             kind: Canonical\n@@ -792,9 +790,10 @@ pub trait StrAllocating: Str {\n     /// Returns an iterator over the string in Unicode Normalization Form KD\n     /// (compatibility decomposition).\n     #[inline]\n+    #[unstable = \"this functionality may be moved to libunicode\"]\n     fn nfkd_chars<'a>(&'a self) -> Decompositions<'a> {\n         Decompositions {\n-            iter: self.as_slice().chars(),\n+            iter: self[].chars(),\n             buffer: Vec::new(),\n             sorted: false,\n             kind: Compatible\n@@ -804,6 +803,7 @@ pub trait StrAllocating: Str {\n     /// An Iterator over the string in Unicode Normalization Form C\n     /// (canonical decomposition followed by canonical composition).\n     #[inline]\n+    #[unstable = \"this functionality may be moved to libunicode\"]\n     fn nfc_chars<'a>(&'a self) -> Recompositions<'a> {\n         Recompositions {\n             iter: self.nfd_chars(),\n@@ -817,6 +817,7 @@ pub trait StrAllocating: Str {\n     /// An Iterator over the string in Unicode Normalization Form KC\n     /// (compatibility decomposition followed by canonical composition).\n     #[inline]\n+    #[unstable = \"this functionality may be moved to libunicode\"]\n     fn nfkc_chars<'a>(&'a self) -> Recompositions<'a> {\n         Recompositions {\n             iter: self.nfkd_chars(),\n@@ -826,30 +827,944 @@ pub trait StrAllocating: Str {\n             last_ccc: None\n         }\n     }\n-}\n \n-impl<'a> StrAllocating for &'a str {\n+    /// Returns true if one string contains another\n+    ///\n+    /// # Arguments\n+    ///\n+    /// - needle - The string to look for\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// assert!(\"bananas\".contains(\"nana\"));\n+    /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    fn contains(&self, needle: &str) -> bool {\n+        core_str::StrExt::contains(self[], needle)\n+    }\n+\n+    /// Returns true if a string contains a char.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// - needle - The char to look for\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// assert!(\"hello\".contains_char('e'));\n+    /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    fn contains_char(&self, needle: char) -> bool {\n+        core_str::StrExt::contains_char(self[], needle)\n+    }\n+\n+    /// An iterator over the characters of `self`. Note, this iterates\n+    /// over Unicode code-points, not Unicode graphemes.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: Vec<char> = \"abc \u00e5\u00e4\u00f6\".chars().collect();\n+    /// assert_eq!(v, vec!['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n+    /// ```\n+    #[stable]\n+    fn chars(&self) -> Chars {\n+        core_str::StrExt::chars(self[])\n+    }\n+\n+    /// An iterator over the bytes of `self`\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: Vec<u8> = \"bors\".bytes().collect();\n+    /// assert_eq!(v, b\"bors\".to_vec());\n+    /// ```\n+    #[stable]\n+    fn bytes(&self) -> Bytes {\n+        core_str::StrExt::bytes(self[])\n+    }\n+\n+    /// An iterator over the characters of `self` and their byte offsets.\n+    #[stable]\n+    fn char_indices(&self) -> CharIndices {\n+        core_str::StrExt::char_indices(self[])\n+    }\n+\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by `sep`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\n+    /// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n+    ///\n+    /// let v: Vec<&str> = \"abc1def2ghi\".split(|&: c: char| c.is_numeric()).collect();\n+    /// assert_eq!(v, vec![\"abc\", \"def\", \"ghi\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\n+    /// assert_eq!(v, vec![\"lion\", \"\", \"tiger\", \"leopard\"]);\n+    ///\n+    /// let v: Vec<&str> = \"\".split('X').collect();\n+    /// assert_eq!(v, vec![\"\"]);\n+    /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    fn split<Sep: CharEq>(&self, sep: Sep) -> CharSplits<Sep> {\n+        core_str::StrExt::split(self[], sep)\n+    }\n+\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by `sep`, restricted to splitting at most `count`\n+    /// times.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(2, ' ').collect();\n+    /// assert_eq!(v, vec![\"Mary\", \"had\", \"a little lambda\"]);\n+    ///\n+    /// let v: Vec<&str> = \"abc1def2ghi\".splitn(1, |&: c: char| c.is_numeric()).collect();\n+    /// assert_eq!(v, vec![\"abc\", \"def2ghi\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn(2, 'X').collect();\n+    /// assert_eq!(v, vec![\"lion\", \"\", \"tigerXleopard\"]);\n+    ///\n+    /// let v: Vec<&str> = \"abcXdef\".splitn(0, 'X').collect();\n+    /// assert_eq!(v, vec![\"abcXdef\"]);\n+    ///\n+    /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n+    /// assert_eq!(v, vec![\"\"]);\n+    /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    fn splitn<Sep: CharEq>(&self, count: uint, sep: Sep) -> CharSplitsN<Sep> {\n+        core_str::StrExt::splitn(self[], count, sep)\n+    }\n+\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by `sep`.\n+    ///\n+    /// Equivalent to `split`, except that the trailing substring\n+    /// is skipped if empty (terminator semantics).\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: Vec<&str> = \"A.B.\".split_terminator('.').collect();\n+    /// assert_eq!(v, vec![\"A\", \"B\"]);\n+    ///\n+    /// let v: Vec<&str> = \"A..B..\".split_terminator('.').collect();\n+    /// assert_eq!(v, vec![\"A\", \"\", \"B\", \"\"]);\n+    ///\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').rev().collect();\n+    /// assert_eq!(v, vec![\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n+    ///\n+    /// let v: Vec<&str> = \"abc1def2ghi\".split(|&: c: char| c.is_numeric()).rev().collect();\n+    /// assert_eq!(v, vec![\"ghi\", \"def\", \"abc\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').rev().collect();\n+    /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"\", \"lion\"]);\n+    /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    fn split_terminator<Sep: CharEq>(&self, sep: Sep) -> CharSplits<Sep> {\n+        core_str::StrExt::split_terminator(self[], sep)\n+    }\n+\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by `sep`, starting from the end of the string.\n+    /// Restricted to splitting at most `count` times.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(2, ' ').collect();\n+    /// assert_eq!(v, vec![\"lamb\", \"little\", \"Mary had a\"]);\n+    ///\n+    /// let v: Vec<&str> = \"abc1def2ghi\".rsplitn(1, |&: c: char| c.is_numeric()).collect();\n+    /// assert_eq!(v, vec![\"ghi\", \"abc1def\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(2, 'X').collect();\n+    /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"lionX\"]);\n+    /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    fn rsplitn<Sep: CharEq>(&self, count: uint, sep: Sep) -> CharSplitsN<Sep> {\n+        core_str::StrExt::rsplitn(self[], count, sep)\n+    }\n+\n+    /// An iterator over the start and end indices of the disjoint\n+    /// matches of `sep` within `self`.\n+    ///\n+    /// That is, each returned value `(start, end)` satisfies\n+    /// `self.slice(start, end) == sep`. For matches of `sep` within\n+    /// `self` that overlap, only the indices corresponding to the\n+    /// first match are returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: Vec<(uint, uint)> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n+    /// assert_eq!(v, vec![(0,3), (6,9), (12,15)]);\n+    ///\n+    /// let v: Vec<(uint, uint)> = \"1abcabc2\".match_indices(\"abc\").collect();\n+    /// assert_eq!(v, vec![(1,4), (4,7)]);\n+    ///\n+    /// let v: Vec<(uint, uint)> = \"ababa\".match_indices(\"aba\").collect();\n+    /// assert_eq!(v, vec![(0, 3)]); // only the first `aba`\n+    /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    fn match_indices<'a>(&'a self, sep: &'a str) -> MatchIndices<'a> {\n+        core_str::StrExt::match_indices(self[], sep)\n+    }\n+\n+    /// An iterator over the substrings of `self` separated by `sep`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".split_str(\"abc\").collect();\n+    /// assert_eq!(v, vec![\"\", \"XXX\", \"YYY\", \"\"]);\n+    ///\n+    /// let v: Vec<&str> = \"1abcabc2\".split_str(\"abc\").collect();\n+    /// assert_eq!(v, vec![\"1\", \"\", \"2\"]);\n+    /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    fn split_str<'a>(&'a self, s: &'a str) -> StrSplits<'a> {\n+        core_str::StrExt::split_str(self[], s)\n+    }\n+\n+    /// An iterator over the lines of a string (subsequences separated\n+    /// by `\\n`). This does not include the empty string after a\n+    /// trailing `\\n`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let four_lines = \"foo\\nbar\\n\\nbaz\\n\";\n+    /// let v: Vec<&str> = four_lines.lines().collect();\n+    /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// ```\n+    #[stable]\n+    fn lines(&self) -> Lines {\n+        core_str::StrExt::lines(self[])\n+    }\n+\n+    /// An iterator over the lines of a string, separated by either\n+    /// `\\n` or `\\r\\n`. As with `.lines()`, this does not include an\n+    /// empty trailing line.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let four_lines = \"foo\\r\\nbar\\n\\r\\nbaz\\n\";\n+    /// let v: Vec<&str> = four_lines.lines_any().collect();\n+    /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// ```\n+    #[stable]\n+    fn lines_any(&self) -> LinesAny {\n+        core_str::StrExt::lines_any(self[])\n+    }\n+\n+    /// Returns the number of Unicode code points (`char`) that a\n+    /// string holds.\n+    ///\n+    /// This does not perform any normalization, and is `O(n)`, since\n+    /// UTF-8 is a variable width encoding of code points.\n+    ///\n+    /// *Warning*: The number of code points in a string does not directly\n+    /// correspond to the number of visible characters or width of the\n+    /// visible text due to composing characters, and double- and\n+    /// zero-width ones.\n+    ///\n+    /// See also `.len()` for the byte length.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # #![allow(deprecated)]\n+    /// // composed forms of `\u00f6` and `\u00e9`\n+    /// let c = \"L\u00f6we \u8001\u864e L\u00e9opard\"; // German, Simplified Chinese, French\n+    /// // decomposed forms of `\u00f6` and `\u00e9`\n+    /// let d = \"Lo\\u{0308}we \u8001\u864e Le\\u{0301}opard\";\n+    ///\n+    /// assert_eq!(c.char_len(), 15);\n+    /// assert_eq!(d.char_len(), 17);\n+    ///\n+    /// assert_eq!(c.len(), 21);\n+    /// assert_eq!(d.len(), 23);\n+    ///\n+    /// // the two strings *look* the same\n+    /// println!(\"{}\", c);\n+    /// println!(\"{}\", d);\n+    /// ```\n+    #[deprecated = \"call .chars().count() instead\"]\n+    fn char_len(&self) -> uint {\n+        core_str::StrExt::char_len(self[])\n+    }\n+\n+    /// Returns a slice of the given string from the byte range\n+    /// [`begin`..`end`).\n+    ///\n+    /// This operation is `O(1)`.\n+    ///\n+    /// Panics when `begin` and `end` do not point to valid characters\n+    /// or point beyond the last character of the string.\n+    ///\n+    /// See also `slice_to` and `slice_from` for slicing prefixes and\n+    /// suffixes of strings, and `slice_chars` for slicing based on\n+    /// code point counts.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// assert_eq!(s.slice(0, 1), \"L\");\n+    ///\n+    /// assert_eq!(s.slice(1, 9), \"\u00f6we \u8001\");\n+    ///\n+    /// // these will panic:\n+    /// // byte 2 lies within `\u00f6`:\n+    /// // s.slice(2, 3);\n+    ///\n+    /// // byte 8 lies within `\u8001`\n+    /// // s.slice(1, 8);\n+    ///\n+    /// // byte 100 is outside the string\n+    /// // s.slice(3, 100);\n+    /// ```\n+    #[unstable = \"use slice notation [a..b] instead\"]\n+    fn slice(&self, begin: uint, end: uint) -> &str {\n+        core_str::StrExt::slice(self[], begin, end)\n+    }\n+\n+    /// Returns a slice of the string from `begin` to its end.\n+    ///\n+    /// Equivalent to `self.slice(begin, self.len())`.\n+    ///\n+    /// Panics when `begin` does not point to a valid character, or is\n+    /// out of bounds.\n+    ///\n+    /// See also `slice`, `slice_to` and `slice_chars`.\n+    #[unstable = \"use slice notation [a..] instead\"]\n+    fn slice_from(&self, begin: uint) -> &str {\n+        core_str::StrExt::slice_from(self[], begin)\n+    }\n+\n+    /// Returns a slice of the string from the beginning to byte\n+    /// `end`.\n+    ///\n+    /// Equivalent to `self.slice(0, end)`.\n+    ///\n+    /// Panics when `end` does not point to a valid character, or is\n+    /// out of bounds.\n+    ///\n+    /// See also `slice`, `slice_from` and `slice_chars`.\n+    #[unstable = \"use slice notation [0..a] instead\"]\n+    fn slice_to(&self, end: uint) -> &str {\n+        core_str::StrExt::slice_to(self[], end)\n+    }\n+\n+    /// Returns a slice of the string from the character range\n+    /// [`begin`..`end`).\n+    ///\n+    /// That is, start at the `begin`-th code point of the string and\n+    /// continue to the `end`-th code point. This does not detect or\n+    /// handle edge cases such as leaving a combining character as the\n+    /// first code point of the string.\n+    ///\n+    /// Due to the design of UTF-8, this operation is `O(end)`.\n+    /// See `slice`, `slice_to` and `slice_from` for `O(1)`\n+    /// variants that use byte indices rather than code point\n+    /// indices.\n+    ///\n+    /// Panics if `begin` > `end` or the either `begin` or `end` are\n+    /// beyond the last character of the string.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// assert_eq!(s.slice_chars(0, 4), \"L\u00f6we\");\n+    /// assert_eq!(s.slice_chars(5, 7), \"\u8001\u864e\");\n+    /// ```\n+    #[unstable = \"may have yet to prove its worth\"]\n+    fn slice_chars(&self, begin: uint, end: uint) -> &str {\n+        core_str::StrExt::slice_chars(self[], begin, end)\n+    }\n+\n+    /// Takes a bytewise (not UTF-8) slice from a string.\n+    ///\n+    /// Returns the substring from [`begin`..`end`).\n+    ///\n+    /// Caller must check both UTF-8 character boundaries and the boundaries of\n+    /// the entire slice as well.\n+    #[stable]\n+    unsafe fn slice_unchecked(&self, begin: uint, end: uint) -> &str {\n+        core_str::StrExt::slice_unchecked(self[], begin, end)\n+    }\n+\n+    /// Returns true if `needle` is a prefix of the string.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// assert!(\"banana\".starts_with(\"ba\"));\n+    /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    fn starts_with(&self, needle: &str) -> bool {\n+        core_str::StrExt::starts_with(self[], needle)\n+    }\n+\n+    /// Returns true if `needle` is a suffix of the string.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// assert!(\"banana\".ends_with(\"nana\"));\n+    /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    fn ends_with(&self, needle: &str) -> bool {\n+        core_str::StrExt::ends_with(self[], needle)\n+    }\n+\n+    /// Returns a string with characters that match `to_trim` removed from the left and the right.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * to_trim - a character matcher\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// assert_eq!(\"11foo1bar11\".trim_chars('1'), \"foo1bar\");\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(\"12foo1bar12\".trim_chars(x), \"foo1bar\");\n+    /// assert_eq!(\"123foo1bar123\".trim_chars(|&: c: char| c.is_numeric()), \"foo1bar\");\n+    /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    fn trim_chars<C: CharEq>(&self, to_trim: C) -> &str {\n+        core_str::StrExt::trim_chars(self[], to_trim)\n+    }\n+\n+    /// Returns a string with leading `chars_to_trim` removed.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * to_trim - a character matcher\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// assert_eq!(\"11foo1bar11\".trim_left_chars('1'), \"foo1bar11\");\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(\"12foo1bar12\".trim_left_chars(x), \"foo1bar12\");\n+    /// assert_eq!(\"123foo1bar123\".trim_left_chars(|&: c: char| c.is_numeric()), \"foo1bar123\");\n+    /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    fn trim_left_chars<C: CharEq>(&self, to_trim: C) -> &str {\n+        core_str::StrExt::trim_left_chars(self[], to_trim)\n+    }\n+\n+    /// Returns a string with trailing `chars_to_trim` removed.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * to_trim - a character matcher\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// assert_eq!(\"11foo1bar11\".trim_right_chars('1'), \"11foo1bar\");\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(\"12foo1bar12\".trim_right_chars(x), \"12foo1bar\");\n+    /// assert_eq!(\"123foo1bar123\".trim_right_chars(|&: c: char| c.is_numeric()), \"123foo1bar\");\n+    /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    fn trim_right_chars<C: CharEq>(&self, to_trim: C) -> &str {\n+        core_str::StrExt::trim_right_chars(self[], to_trim)\n+    }\n+\n+    /// Check that `index`-th byte lies at the start and/or end of a\n+    /// UTF-8 code point sequence.\n+    ///\n+    /// The start and end of the string (when `index == self.len()`)\n+    /// are considered to be boundaries.\n+    ///\n+    /// Panics if `index` is greater than `self.len()`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// assert!(s.is_char_boundary(0));\n+    /// // start of `\u8001`\n+    /// assert!(s.is_char_boundary(6));\n+    /// assert!(s.is_char_boundary(s.len()));\n+    ///\n+    /// // second byte of `\u00f6`\n+    /// assert!(!s.is_char_boundary(2));\n+    ///\n+    /// // third byte of `\u8001`\n+    /// assert!(!s.is_char_boundary(8));\n+    /// ```\n+    #[unstable = \"naming is uncertain with container conventions\"]\n+    fn is_char_boundary(&self, index: uint) -> bool {\n+        core_str::StrExt::is_char_boundary(self[], index)\n+    }\n+\n+    /// Pluck a character out of a string and return the index of the next\n+    /// character.\n+    ///\n+    /// This function can be used to iterate over the Unicode characters of a\n+    /// string.\n+    ///\n+    /// # Example\n+    ///\n+    /// This example manually iterates through the characters of a\n+    /// string; this should normally be done by `.chars()` or\n+    /// `.char_indices`.\n+    ///\n+    /// ```rust\n+    /// use std::str::CharRange;\n+    ///\n+    /// let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n+    /// let mut i = 0u;\n+    /// while i < s.len() {\n+    ///     let CharRange {ch, next} = s.char_range_at(i);\n+    ///     println!(\"{}: {}\", i, ch);\n+    ///     i = next;\n+    /// }\n+    /// ```\n+    ///\n+    /// This outputs:\n+    ///\n+    /// ```text\n+    /// 0: \u4e2d\n+    /// 3: \u534e\n+    /// 6: V\n+    /// 7: i\n+    /// 8: \u1ec7\n+    /// 11: t\n+    /// 12:\n+    /// 13: N\n+    /// 14: a\n+    /// 15: m\n+    /// ```\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * s - The string\n+    /// * i - The byte offset of the char to extract\n+    ///\n+    /// # Return value\n+    ///\n+    /// A record {ch: char, next: uint} containing the char value and the byte\n+    /// index of the next Unicode character.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `i` is greater than or equal to the length of the string.\n+    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n+    #[unstable = \"naming is uncertain with container conventions\"]\n+    fn char_range_at(&self, start: uint) -> CharRange {\n+        core_str::StrExt::char_range_at(self[], start)\n+    }\n+\n+    /// Given a byte position and a str, return the previous char and its position.\n+    ///\n+    /// This function can be used to iterate over a Unicode string in reverse.\n+    ///\n+    /// Returns 0 for next index if called on start index 0.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `i` is greater than the length of the string.\n+    /// If `i` is not an index following a valid UTF-8 character.\n+    #[unstable = \"naming is uncertain with container conventions\"]\n+    fn char_range_at_reverse(&self, start: uint) -> CharRange {\n+        core_str::StrExt::char_range_at_reverse(self[], start)\n+    }\n+\n+    /// Plucks the character starting at the `i`th byte of a string.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"ab\u03c0c\";\n+    /// assert_eq!(s.char_at(1), 'b');\n+    /// assert_eq!(s.char_at(2), '\u03c0');\n+    /// assert_eq!(s.char_at(4), 'c');\n+    /// ```\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `i` is greater than or equal to the length of the string.\n+    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n+    #[unstable = \"naming is uncertain with container conventions\"]\n+    fn char_at(&self, i: uint) -> char {\n+        core_str::StrExt::char_at(self[], i)\n+    }\n+\n+    /// Plucks the character ending at the `i`th byte of a string.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `i` is greater than the length of the string.\n+    /// If `i` is not an index following a valid UTF-8 character.\n+    #[unstable = \"naming is uncertain with container conventions\"]\n+    fn char_at_reverse(&self, i: uint) -> char {\n+        core_str::StrExt::char_at_reverse(self[], i)\n+    }\n+\n+    /// Work with the byte buffer of a string as a byte slice.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// assert_eq!(\"bors\".as_bytes(), b\"bors\");\n+    /// ```\n+    #[stable]\n+    fn as_bytes(&self) -> &[u8] {\n+        core_str::StrExt::as_bytes(self[])\n+    }\n+\n+    /// Returns the byte index of the first character of `self` that\n+    /// matches `search`.\n+    ///\n+    /// # Return value\n+    ///\n+    /// `Some` containing the byte index of the last matching character\n+    /// or `None` if there is no match\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.find('L'), Some(0));\n+    /// assert_eq!(s.find('\u00e9'), Some(14));\n+    ///\n+    /// // the first space\n+    /// assert_eq!(s.find(|&: c: char| c.is_whitespace()), Some(5));\n+    ///\n+    /// // neither are found\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(s.find(x), None);\n+    /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    fn find<C: CharEq>(&self, search: C) -> Option<uint> {\n+        core_str::StrExt::find(self[], search)\n+    }\n+\n+    /// Returns the byte index of the last character of `self` that\n+    /// matches `search`.\n+    ///\n+    /// # Return value\n+    ///\n+    /// `Some` containing the byte index of the last matching character\n+    /// or `None` if there is no match.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.rfind('L'), Some(13));\n+    /// assert_eq!(s.rfind('\u00e9'), Some(14));\n+    ///\n+    /// // the second space\n+    /// assert_eq!(s.rfind(|&: c: char| c.is_whitespace()), Some(12));\n+    ///\n+    /// // searches for an occurrence of either `1` or `2`, but neither are found\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(s.rfind(x), None);\n+    /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    fn rfind<C: CharEq>(&self, search: C) -> Option<uint> {\n+        core_str::StrExt::rfind(self[], search)\n+    }\n+\n+    /// Returns the byte index of the first matching substring\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * `needle` - The string to search for\n+    ///\n+    /// # Return value\n+    ///\n+    /// `Some` containing the byte index of the first matching substring\n+    /// or `None` if there is no match.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.find_str(\"\u8001\u864e L\"), Some(6));\n+    /// assert_eq!(s.find_str(\"muffin man\"), None);\n+    /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    fn find_str(&self, needle: &str) -> Option<uint> {\n+        core_str::StrExt::find_str(self[], needle)\n+    }\n+\n+    /// Retrieves the first character from a string slice and returns\n+    /// it. This does not allocate a new string; instead, it returns a\n+    /// slice that point one character beyond the character that was\n+    /// shifted. If the string does not contain any characters,\n+    /// None is returned instead.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// let (c, s1) = s.slice_shift_char().unwrap();\n+    /// assert_eq!(c, 'L');\n+    /// assert_eq!(s1, \"\u00f6we \u8001\u864e L\u00e9opard\");\n+    ///\n+    /// let (c, s2) = s1.slice_shift_char().unwrap();\n+    /// assert_eq!(c, '\u00f6');\n+    /// assert_eq!(s2, \"we \u8001\u864e L\u00e9opard\");\n+    /// ```\n+    #[unstable = \"awaiting conventions about shifting and slices\"]\n+    fn slice_shift_char(&self) -> Option<(char, &str)> {\n+        core_str::StrExt::slice_shift_char(self[])\n+    }\n+\n+    /// Returns the byte offset of an inner slice relative to an enclosing outer slice.\n+    ///\n+    /// Panics if `inner` is not a direct slice contained within self.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let string = \"a\\nb\\nc\";\n+    /// let lines: Vec<&str> = string.lines().collect();\n+    ///\n+    /// assert!(string.subslice_offset(lines[0]) == 0); // &\"a\"\n+    /// assert!(string.subslice_offset(lines[1]) == 2); // &\"b\"\n+    /// assert!(string.subslice_offset(lines[2]) == 4); // &\"c\"\n+    /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    fn subslice_offset(&self, inner: &str) -> uint {\n+        core_str::StrExt::subslice_offset(self[], inner)\n+    }\n+\n+    /// Return an unsafe pointer to the strings buffer.\n+    ///\n+    /// The caller must ensure that the string outlives this pointer,\n+    /// and that it is not reallocated (e.g. by pushing to the\n+    /// string).\n+    #[stable]\n+    #[inline]\n+    fn as_ptr(&self) -> *const u8 {\n+        core_str::StrExt::as_ptr(self[])\n+    }\n+\n+    /// Return an iterator of `u16` over the string encoded as UTF-16.\n+    #[unstable = \"this functionality may only be provided by libunicode\"]\n+    fn utf16_units(&self) -> Utf16Units {\n+        Utf16Units { encoder: Utf16Encoder::new(self[].chars()) }\n+    }\n+\n+    /// Return the number of bytes in this string\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// assert_eq!(\"foo\".len(), 3);\n+    /// assert_eq!(\"\u0192oo\".len(), 4);\n+    /// ```\n+    #[stable]\n     #[inline]\n-    fn into_string(self) -> String {\n-        String::from_str(self)\n+    fn len(&self) -> uint {\n+        core_str::StrExt::len(self[])\n+    }\n+\n+    /// Returns true if this slice contains no bytes\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// assert!(\"\".is_empty());\n+    /// ```\n+    #[inline]\n+    #[stable]\n+    fn is_empty(&self) -> bool {\n+        core_str::StrExt::is_empty(self[])\n+    }\n+\n+    /// Parse this string into the specified type.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// assert_eq!(\"4\".parse::<u32>(), Some(4));\n+    /// assert_eq!(\"j\".parse::<u32>(), None);\n+    /// ```\n+    #[inline]\n+    #[unstable = \"this method was just created\"]\n+    fn parse<F: FromStr>(&self) -> Option<F> {\n+        FromStr::from_str(self[])\n+    }\n+\n+    /// Returns an iterator over the\n+    /// [grapheme clusters](http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries)\n+    /// of the string.\n+    ///\n+    /// If `is_extended` is true, the iterator is over the *extended grapheme clusters*;\n+    /// otherwise, the iterator is over the *legacy grapheme clusters*.\n+    /// [UAX#29](http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries)\n+    /// recommends extended grapheme cluster boundaries for general processing.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let gr1 = \"a\\u{310}e\\u{301}o\\u{308}\\u{332}\".graphemes(true).collect::<Vec<&str>>();\n+    /// let b: &[_] = &[\"a\\u{310}\", \"e\\u{301}\", \"o\\u{308}\\u{332}\"];\n+    /// assert_eq!(gr1.as_slice(), b);\n+    /// let gr2 = \"a\\r\\nb\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\".graphemes(true).collect::<Vec<&str>>();\n+    /// let b: &[_] = &[\"a\", \"\\r\\n\", \"b\", \"\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\"];\n+    /// assert_eq!(gr2.as_slice(), b);\n+    /// ```\n+    #[unstable = \"this functionality may only be provided by libunicode\"]\n+    fn graphemes(&self, is_extended: bool) -> Graphemes {\n+        UnicodeStr::graphemes(self[], is_extended)\n+    }\n+\n+    /// Returns an iterator over the grapheme clusters of self and their byte offsets.\n+    /// See `graphemes()` method for more information.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let gr_inds = \"a\u0310e\u0301o\u0308\u0332\\r\\n\".grapheme_indices(true).collect::<Vec<(uint, &str)>>();\n+    /// let b: &[_] = &[(0u, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")];\n+    /// assert_eq!(gr_inds.as_slice(), b);\n+    /// ```\n+    #[unstable = \"this functionality may only be provided by libunicode\"]\n+    fn grapheme_indices(&self, is_extended: bool) -> GraphemeIndices {\n+        UnicodeStr::grapheme_indices(self[], is_extended)\n+    }\n+\n+    /// An iterator over the words of a string (subsequences separated\n+    /// by any sequence of whitespace). Sequences of whitespace are\n+    /// collapsed, so empty \"words\" are not included.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let some_words = \" Mary   had\\ta little  \\n\\t lamb\";\n+    /// let v: Vec<&str> = some_words.words().collect();\n+    /// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n+    /// ```\n+    #[stable]\n+    fn words(&self) -> Words {\n+        UnicodeStr::words(self[])\n+    }\n+\n+    /// Returns true if the string contains only whitespace.\n+    ///\n+    /// Whitespace characters are determined by `char::is_whitespace`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # #![allow(deprecated)]\n+    /// assert!(\" \\t\\n\".is_whitespace());\n+    /// assert!(\"\".is_whitespace());\n+    ///\n+    /// assert!( !\"abc\".is_whitespace());\n+    /// ```\n+    #[deprecated = \"use .chars().all(|c| c.is_whitespace())\"]\n+    fn is_whitespace(&self) -> bool {\n+        UnicodeStr::is_whitespace(self[])\n+    }\n+\n+    /// Returns true if the string contains only alphanumeric code\n+    /// points.\n+    ///\n+    /// Alphanumeric characters are determined by `char::is_alphanumeric`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # #![allow(deprecated)]\n+    /// assert!(\"L\u00f6we\u8001\u864eL\u00e9opard123\".is_alphanumeric());\n+    /// assert!(\"\".is_alphanumeric());\n+    ///\n+    /// assert!( !\" &*~\".is_alphanumeric());\n+    /// ```\n+    #[deprecated = \"use .chars().all(|c| c.is_alphanumeric())\"]\n+    fn is_alphanumeric(&self) -> bool {\n+        UnicodeStr::is_alphanumeric(self[])\n+    }\n+\n+    /// Returns a string's displayed width in columns, treating control\n+    /// characters as zero-width.\n+    ///\n+    /// `is_cjk` determines behavior for characters in the Ambiguous category:\n+    /// if `is_cjk` is `true`, these are 2 columns wide; otherwise, they are 1.\n+    /// In CJK locales, `is_cjk` should be `true`, else it should be `false`.\n+    /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n+    /// recommends that these characters be treated as 1 column (i.e.,\n+    /// `is_cjk` = `false`) if the locale is unknown.\n+    #[unstable = \"this functionality may only be provided by libunicode\"]\n+    fn width(&self, is_cjk: bool) -> uint {\n+        UnicodeStr::width(self[], is_cjk)\n+    }\n+\n+    /// Returns a string with leading and trailing whitespace removed.\n+    #[stable]\n+    fn trim(&self) -> &str {\n+        UnicodeStr::trim(self[])\n+    }\n+\n+    /// Returns a string with leading whitespace removed.\n+    #[stable]\n+    fn trim_left(&self) -> &str {\n+        UnicodeStr::trim_left(self[])\n+    }\n+\n+    /// Returns a string with trailing whitespace removed.\n+    #[stable]\n+    fn trim_right(&self) -> &str {\n+        UnicodeStr::trim_right(self[])\n+    }\n+\n+    /// Deprecated, call `.to_owned()` instead from the `std::borrow::ToOwned`\n+    /// trait.\n+    #[deprecated = \"call `.to_owned()` on `std::borrow::ToOwned` instead\"]\n+    fn into_string(&self) -> String {\n+        self[].to_owned()\n     }\n }\n \n+impl StrExt for str {}\n+\n #[cfg(test)]\n mod tests {\n-    use prelude::*;\n-    use core::default::Default;\n-    use core::iter::AdditiveIterator;\n-    use super::{eq_slice, from_utf8, is_utf8, is_utf16, raw};\n-    use super::truncate_utf16_at_nul;\n+    use std::iter::AdditiveIterator;\n+    use std::iter::range;\n+    use std::default::Default;\n+    use std::char::Char;\n+    use std::clone::Clone;\n+    use std::cmp::{Ord, PartialOrd, Equiv};\n+    use std::cmp::Ordering::{Equal, Greater, Less};\n+    use std::option::Option::{mod, Some, None};\n+    use std::result::Result::{Ok, Err};\n+    use std::ptr::RawPtr;\n+    use std::iter::{Iterator, IteratorExt, DoubleEndedIteratorExt};\n+\n+    use super::*;\n     use super::MaybeOwned::{Owned, Slice};\n+    use std::slice::{AsSlice, SliceExt};\n+    use string::{String, ToString};\n+    use vec::Vec;\n+    use slice::CloneSliceExt;\n \n-    #[test]\n-    fn test_eq_slice() {\n-        assert!((eq_slice(\"foobar\".slice(0, 3), \"foo\")));\n-        assert!((eq_slice(\"barfoo\".slice(3, 6), \"foo\")));\n-        assert!((!eq_slice(\"foo1\", \"foo2\")));\n-    }\n+    use unicode::char::UnicodeChar;\n \n     #[test]\n     fn test_le() {\n@@ -1380,6 +2295,7 @@ mod tests {\n \n     #[test]\n     fn test_is_utf16() {\n+        use unicode::str::is_utf16;\n         macro_rules! pos ( ($($e:expr),*) => { { $(assert!(is_utf16($e));)* } });\n \n         // non-surrogates\n@@ -1541,28 +2457,6 @@ mod tests {\n         assert!(!\"\".contains_char('a'));\n     }\n \n-    #[test]\n-    fn test_truncate_utf16_at_nul() {\n-        let v = [];\n-        let b: &[u16] = &[];\n-        assert_eq!(truncate_utf16_at_nul(&v), b);\n-\n-        let v = [0, 2, 3];\n-        assert_eq!(truncate_utf16_at_nul(&v), b);\n-\n-        let v = [1, 0, 3];\n-        let b: &[u16] = &[1];\n-        assert_eq!(truncate_utf16_at_nul(&v), b);\n-\n-        let v = [1, 2, 0];\n-        let b: &[u16] = &[1, 2];\n-        assert_eq!(truncate_utf16_at_nul(&v), b);\n-\n-        let v = [1, 2, 3];\n-        let b: &[u16] = &[1, 2, 3];\n-        assert_eq!(truncate_utf16_at_nul(&v), b);\n-    }\n-\n     #[test]\n     fn test_char_at() {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n@@ -1814,27 +2708,6 @@ mod tests {\n         assert_eq!(words, vec![\"M\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\", \"Little\", \"l\u00e4mb\"])\n     }\n \n-    #[test]\n-    fn test_lev_distance() {\n-        use core::char::{ from_u32, MAX };\n-        // Test bytelength agnosticity\n-        for c in range(0u32, MAX as u32)\n-                 .filter_map(|i| from_u32(i))\n-                 .map(|i| String::from_char(1, i)) {\n-            assert_eq!(c[].lev_distance(c[]), 0);\n-        }\n-\n-        let a = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n-        let b = \"\\nMary h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n-        let c = \"Mary h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n-        assert_eq!(a.lev_distance(b), 1);\n-        assert_eq!(b.lev_distance(a), 1);\n-        assert_eq!(a.lev_distance(c), 2);\n-        assert_eq!(c.lev_distance(a), 2);\n-        assert_eq!(b.lev_distance(c), 1);\n-        assert_eq!(c.lev_distance(b), 1);\n-    }\n-\n     #[test]\n     fn test_nfd_chars() {\n         macro_rules! t {\n@@ -2385,13 +3258,13 @@ mod tests {\n     #[test]\n     fn test_str_from_utf8() {\n         let xs = b\"hello\";\n-        assert_eq!(from_utf8(xs), Some(\"hello\"));\n+        assert_eq!(from_utf8(xs), Ok(\"hello\"));\n \n         let xs = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes();\n-        assert_eq!(from_utf8(xs), Some(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n+        assert_eq!(from_utf8(xs), Ok(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n \n         let xs = b\"hello\\xFF\";\n-        assert_eq!(from_utf8(xs), None);\n+        assert_eq!(from_utf8(xs), Err(Utf8Error::TooShort));\n     }\n \n     #[test]\n@@ -2440,8 +3313,8 @@ mod tests {\n \n     #[test]\n     fn test_maybe_owned_into_string() {\n-        assert_eq!(Slice(\"abcde\").into_string(), String::from_str(\"abcde\"));\n-        assert_eq!(Owned(String::from_str(\"abcde\")).into_string(),\n+        assert_eq!(Slice(\"abcde\").to_string(), String::from_str(\"abcde\"));\n+        assert_eq!(Owned(String::from_str(\"abcde\")).to_string(),\n                    String::from_str(\"abcde\"));\n     }\n "}, {"sha": "6c2659b13f7207b8e6206b26c5169deb801ccdb8", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 51, "deletions": 39, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -21,13 +21,12 @@ use core::hash;\n use core::mem;\n use core::ptr;\n use core::ops;\n-// FIXME: ICE's abound if you import the `Slice` type while importing `Slice` trait\n use core::raw::Slice as RawSlice;\n+use unicode::str as unicode_str;\n+use unicode::str::Utf16Item;\n \n use slice::CloneSliceExt;\n-use str;\n-use str::{CharRange, CowString, FromStr, StrAllocating};\n-use str::MaybeOwned::Owned;\n+use str::{mod, CharRange, FromStr, Utf8Error};\n use vec::{DerefVec, Vec, as_vec};\n \n /// A growable string stored as a UTF-8 encoded buffer.\n@@ -87,27 +86,31 @@ impl String {\n     /// Returns the vector as a string buffer, if possible, taking care not to\n     /// copy it.\n     ///\n-    /// Returns `Err` with the original vector if the vector contains invalid\n-    /// UTF-8.\n+    /// # Failure\n+    ///\n+    /// If the given vector is not valid UTF-8, then the original vector and the\n+    /// corresponding error is returned.\n     ///\n     /// # Examples\n     ///\n     /// ```rust\n+    /// # #![allow(deprecated)]\n+    /// use std::str::Utf8Error;\n+    ///\n     /// let hello_vec = vec![104, 101, 108, 108, 111];\n     /// let s = String::from_utf8(hello_vec);\n     /// assert_eq!(s, Ok(\"hello\".to_string()));\n     ///\n     /// let invalid_vec = vec![240, 144, 128];\n     /// let s = String::from_utf8(invalid_vec);\n-    /// assert_eq!(s, Err(vec![240, 144, 128]));\n+    /// assert_eq!(s, Err((vec![240, 144, 128], Utf8Error::TooShort)));\n     /// ```\n     #[inline]\n     #[unstable = \"error type may change\"]\n-    pub fn from_utf8(vec: Vec<u8>) -> Result<String, Vec<u8>> {\n-        if str::is_utf8(vec.as_slice()) {\n-            Ok(String { vec: vec })\n-        } else {\n-            Err(vec)\n+    pub fn from_utf8(vec: Vec<u8>) -> Result<String, (Vec<u8>, Utf8Error)> {\n+        match str::from_utf8(vec.as_slice()) {\n+            Ok(..) => Ok(String { vec: vec }),\n+            Err(e) => Err((vec, e))\n         }\n     }\n \n@@ -123,8 +126,9 @@ impl String {\n     /// ```\n     #[unstable = \"return type may change\"]\n     pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> CowString<'a> {\n-        if str::is_utf8(v) {\n-            return Cow::Borrowed(unsafe { mem::transmute(v) })\n+        match str::from_utf8(v) {\n+            Ok(s) => return Cow::Borrowed(s),\n+            Err(..) => {}\n         }\n \n         static TAG_CONT_U8: u8 = 128u8;\n@@ -173,7 +177,7 @@ impl String {\n             if byte < 128u8 {\n                 // subseqidx handles this\n             } else {\n-                let w = str::utf8_char_width(byte);\n+                let w = unicode_str::utf8_char_width(byte);\n \n                 match w {\n                     2 => {\n@@ -235,7 +239,7 @@ impl String {\n                 res.as_mut_vec().push_all(v[subseqidx..total])\n             };\n         }\n-        Cow::Owned(res.into_string())\n+        Cow::Owned(res)\n     }\n \n     /// Decode a UTF-16 encoded vector `v` into a `String`, returning `None`\n@@ -256,10 +260,10 @@ impl String {\n     #[unstable = \"error value in return may change\"]\n     pub fn from_utf16(v: &[u16]) -> Option<String> {\n         let mut s = String::with_capacity(v.len());\n-        for c in str::utf16_items(v) {\n+        for c in unicode_str::utf16_items(v) {\n             match c {\n-                str::ScalarValue(c) => s.push(c),\n-                str::LoneSurrogate(_) => return None\n+                Utf16Item::ScalarValue(c) => s.push(c),\n+                Utf16Item::LoneSurrogate(_) => return None\n             }\n         }\n         Some(s)\n@@ -281,7 +285,7 @@ impl String {\n     /// ```\n     #[stable]\n     pub fn from_utf16_lossy(v: &[u16]) -> String {\n-        str::utf16_items(v).map(|c| c.to_char_lossy()).collect()\n+        unicode_str::utf16_items(v).map(|c| c.to_char_lossy()).collect()\n     }\n \n     /// Convert a vector of `char`s to a `String`.\n@@ -812,21 +816,12 @@ impl<'a, 'b> PartialEq<CowString<'a>> for &'b str {\n }\n \n #[experimental = \"waiting on Str stabilization\"]\n+#[allow(deprecated)]\n impl Str for String {\n     #[inline]\n     #[stable]\n     fn as_slice<'a>(&'a self) -> &'a str {\n-        unsafe {\n-            mem::transmute(self.vec.as_slice())\n-        }\n-    }\n-}\n-\n-#[experimental = \"waiting on StrAllocating stabilization\"]\n-impl StrAllocating for String {\n-    #[inline]\n-    fn into_string(self) -> String {\n-        self\n+        unsafe { mem::transmute(self.vec.as_slice()) }\n     }\n }\n \n@@ -841,15 +836,15 @@ impl Default for String {\n #[experimental = \"waiting on Show stabilization\"]\n impl fmt::Show for String {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.as_slice().fmt(f)\n+        (**self).fmt(f)\n     }\n }\n \n #[experimental = \"waiting on Hash stabilization\"]\n impl<H: hash::Writer> hash::Hash<H> for String {\n     #[inline]\n     fn hash(&self, hasher: &mut H) {\n-        self.as_slice().hash(hasher)\n+        (**self).hash(hasher)\n     }\n }\n \n@@ -873,7 +868,7 @@ impl<'a> Add<&'a str, String> for String {\n impl ops::Slice<uint, str> for String {\n     #[inline]\n     fn as_slice_<'a>(&'a self) -> &'a str {\n-        self.as_slice()\n+        unsafe { mem::transmute(self.vec.as_slice()) }\n     }\n \n     #[inline]\n@@ -894,7 +889,9 @@ impl ops::Slice<uint, str> for String {\n \n #[experimental = \"waiting on Deref stabilization\"]\n impl ops::Deref<str> for String {\n-    fn deref<'a>(&'a self) -> &'a str { self.as_slice() }\n+    fn deref<'a>(&'a self) -> &'a str {\n+        unsafe { mem::transmute(self.vec[]) }\n+    }\n }\n \n /// Wrapper type providing a `&String` reference via `Deref`.\n@@ -1015,11 +1012,24 @@ pub mod raw {\n     }\n }\n \n+/// A clone-on-write string\n+#[stable]\n+pub type CowString<'a> = Cow<'a, String, str>;\n+\n+#[allow(deprecated)]\n+impl<'a> Str for CowString<'a> {\n+    #[inline]\n+    fn as_slice<'b>(&'b self) -> &'b str {\n+        (**self).as_slice()\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use prelude::*;\n     use test::Bencher;\n \n+    use str::{StrExt, Utf8Error};\n     use str;\n     use super::as_string;\n \n@@ -1038,14 +1048,16 @@ mod tests {\n     #[test]\n     fn test_from_utf8() {\n         let xs = b\"hello\".to_vec();\n-        assert_eq!(String::from_utf8(xs), Ok(String::from_str(\"hello\")));\n+        assert_eq!(String::from_utf8(xs),\n+                   Ok(String::from_str(\"hello\")));\n \n         let xs = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes().to_vec();\n-        assert_eq!(String::from_utf8(xs), Ok(String::from_str(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\")));\n+        assert_eq!(String::from_utf8(xs),\n+                   Ok(String::from_str(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\")));\n \n         let xs = b\"hello\\xFF\".to_vec();\n         assert_eq!(String::from_utf8(xs),\n-                   Err(b\"hello\\xFF\".to_vec()));\n+                   Err((b\"hello\\xFF\".to_vec(), Utf8Error::TooShort)));\n     }\n \n     #[test]\n@@ -1135,7 +1147,7 @@ mod tests {\n             let s_as_utf16 = s.utf16_units().collect::<Vec<u16>>();\n             let u_as_string = String::from_utf16(u.as_slice()).unwrap();\n \n-            assert!(str::is_utf16(u.as_slice()));\n+            assert!(::unicode::str::is_utf16(u.as_slice()));\n             assert_eq!(s_as_utf16, u);\n \n             assert_eq!(u_as_string, s);"}, {"sha": "fa0e4a2340e2aac37cad0a601e384b6efd4b44aa", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -888,7 +888,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn into_iter(self) -> MoveItems<T> {\n+    pub fn into_iter(self) -> IntoIter<T> {\n         unsafe {\n             let ptr = self.ptr;\n             let cap = self.cap;\n@@ -899,7 +899,7 @@ impl<T> Vec<T> {\n                 ptr.offset(self.len() as int) as *const T\n             };\n             mem::forget(self);\n-            MoveItems { allocation: ptr, cap: cap, ptr: begin, end: end }\n+            IntoIter { allocation: ptr, cap: cap, ptr: begin, end: end }\n         }\n     }\n \n@@ -1402,21 +1402,21 @@ impl<T:fmt::Show> fmt::Show for Vec<T> {\n }\n \n /// An iterator that moves out of a vector.\n-pub struct MoveItems<T> {\n+pub struct IntoIter<T> {\n     allocation: *mut T, // the block of memory allocated for the vector\n     cap: uint, // the capacity of the vector\n     ptr: *const T,\n     end: *const T\n }\n \n-impl<T> MoveItems<T> {\n+impl<T> IntoIter<T> {\n     /// Drops all items that have not yet been moved and returns the empty vector.\n     #[inline]\n     #[unstable]\n     pub fn into_inner(mut self) -> Vec<T> {\n         unsafe {\n             for _x in self { }\n-            let MoveItems { allocation, cap, ptr: _ptr, end: _end } = self;\n+            let IntoIter { allocation, cap, ptr: _ptr, end: _end } = self;\n             mem::forget(self);\n             Vec { ptr: allocation, cap: cap, len: 0 }\n         }\n@@ -1427,7 +1427,7 @@ impl<T> MoveItems<T> {\n     pub fn unwrap(self) -> Vec<T> { self.into_inner() }\n }\n \n-impl<T> Iterator<T> for MoveItems<T> {\n+impl<T> Iterator<T> for IntoIter<T> {\n     #[inline]\n     fn next<'a>(&'a mut self) -> Option<T> {\n         unsafe {\n@@ -1461,7 +1461,7 @@ impl<T> Iterator<T> for MoveItems<T> {\n     }\n }\n \n-impl<T> DoubleEndedIterator<T> for MoveItems<T> {\n+impl<T> DoubleEndedIterator<T> for IntoIter<T> {\n     #[inline]\n     fn next_back<'a>(&'a mut self) -> Option<T> {\n         unsafe {\n@@ -1484,10 +1484,10 @@ impl<T> DoubleEndedIterator<T> for MoveItems<T> {\n     }\n }\n \n-impl<T> ExactSizeIterator<T> for MoveItems<T> {}\n+impl<T> ExactSizeIterator<T> for IntoIter<T> {}\n \n #[unsafe_destructor]\n-impl<T> Drop for MoveItems<T> {\n+impl<T> Drop for IntoIter<T> {\n     fn drop(&mut self) {\n         // destroy the remaining elements\n         if self.cap != 0 {"}, {"sha": "207e27ccdccc3619571257e1e2d6e712e0a3f517", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -144,6 +144,7 @@ impl<V> VecMap<V> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn keys<'r>(&'r self) -> Keys<'r, V> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n+        let first: fn((uint, &'r V)) -> uint = first; // coerce to fn pointer\n \n         Keys { iter: self.iter().map(first) }\n     }\n@@ -153,6 +154,7 @@ impl<V> VecMap<V> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn values<'r>(&'r self) -> Values<'r, V> {\n         fn second<A, B>((_, b): (A, B)) -> B { b }\n+        let second: fn((uint, &'r V)) -> &'r V = second; // coerce to fn pointer\n \n         Values { iter: self.iter().map(second) }\n     }\n@@ -176,8 +178,8 @@ impl<V> VecMap<V> {\n     /// }\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter<'r>(&'r self) -> Entries<'r, V> {\n-        Entries {\n+    pub fn iter<'r>(&'r self) -> Iter<'r, V> {\n+        Iter {\n             front: 0,\n             back: self.v.len(),\n             iter: self.v.iter()\n@@ -207,8 +209,8 @@ impl<V> VecMap<V> {\n     /// }\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter_mut<'r>(&'r mut self) -> MutEntries<'r, V> {\n-        MutEntries {\n+    pub fn iter_mut<'r>(&'r mut self) -> IterMut<'r, V> {\n+        IterMut {\n             front: 0,\n             back: self.v.len(),\n             iter: self.v.iter_mut()\n@@ -235,13 +237,14 @@ impl<V> VecMap<V> {\n     /// assert_eq!(vec, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn into_iter(&mut self) -> MoveItems<V> {\n+    pub fn into_iter(&mut self) -> IntoIter<V> {\n         fn filter<A>((i, v): (uint, Option<A>)) -> Option<(uint, A)> {\n             v.map(|v| (i, v))\n         }\n+        let filter: fn((uint, Option<V>)) -> Option<(uint, V)> = filter; // coerce to fn ptr\n \n         let values = replace(&mut self.v, vec!());\n-        MoveItems { iter: values.into_iter().enumerate().filter_map(filter) }\n+        IntoIter { iter: values.into_iter().enumerate().filter_map(filter) }\n     }\n \n     /// Return the number of elements in the map.\n@@ -605,42 +608,42 @@ macro_rules! double_ended_iterator {\n }\n \n /// An iterator over the key-value pairs of a map.\n-pub struct Entries<'a, V:'a> {\n+pub struct Iter<'a, V:'a> {\n     front: uint,\n     back: uint,\n-    iter: slice::Items<'a, Option<V>>\n+    iter: slice::Iter<'a, Option<V>>\n }\n \n-iterator! { impl Entries -> (uint, &'a V), as_ref }\n-double_ended_iterator! { impl Entries -> (uint, &'a V), as_ref }\n+iterator! { impl Iter -> (uint, &'a V), as_ref }\n+double_ended_iterator! { impl Iter -> (uint, &'a V), as_ref }\n \n /// An iterator over the key-value pairs of a map, with the\n /// values being mutable.\n-pub struct MutEntries<'a, V:'a> {\n+pub struct IterMut<'a, V:'a> {\n     front: uint,\n     back: uint,\n-    iter: slice::MutItems<'a, Option<V>>\n+    iter: slice::IterMut<'a, Option<V>>\n }\n \n-iterator! { impl MutEntries -> (uint, &'a mut V), as_mut }\n-double_ended_iterator! { impl MutEntries -> (uint, &'a mut V), as_mut }\n+iterator! { impl IterMut -> (uint, &'a mut V), as_mut }\n+double_ended_iterator! { impl IterMut -> (uint, &'a mut V), as_mut }\n \n /// An iterator over the keys of a map.\n pub struct Keys<'a, V: 'a> {\n-    iter: Map<(uint, &'a V), uint, Entries<'a, V>, fn((uint, &'a V)) -> uint>\n+    iter: Map<(uint, &'a V), uint, Iter<'a, V>, fn((uint, &'a V)) -> uint>\n }\n \n /// An iterator over the values of a map.\n pub struct Values<'a, V: 'a> {\n-    iter: Map<(uint, &'a V), &'a V, Entries<'a, V>, fn((uint, &'a V)) -> &'a V>\n+    iter: Map<(uint, &'a V), &'a V, Iter<'a, V>, fn((uint, &'a V)) -> &'a V>\n }\n \n /// A consuming iterator over the key-value pairs of a map.\n-pub struct MoveItems<V> {\n+pub struct IntoIter<V> {\n     iter: FilterMap<\n     (uint, Option<V>),\n     (uint, V),\n-    Enumerate<vec::MoveItems<Option<V>>>,\n+    Enumerate<vec::IntoIter<Option<V>>>,\n     fn((uint, Option<V>)) -> Option<(uint, V)>>\n }\n \n@@ -662,11 +665,11 @@ impl<'a, V> DoubleEndedIterator<&'a V> for Values<'a, V> {\n }\n \n \n-impl<V> Iterator<(uint, V)> for MoveItems<V> {\n+impl<V> Iterator<(uint, V)> for IntoIter<V> {\n     fn next(&mut self) -> Option<(uint, V)> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n-impl<V> DoubleEndedIterator<(uint, V)> for MoveItems<V> {\n+impl<V> DoubleEndedIterator<(uint, V)> for IntoIter<V> {\n     fn next_back(&mut self) -> Option<(uint, V)> { self.iter.next_back() }\n }\n "}, {"sha": "ca523db214b0c50b444b8abad74e90a422a41ba5", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -41,7 +41,7 @@\n \n #![stable]\n \n-pub use self::Ordering::*;\n+use self::Ordering::*;\n \n use kinds::Sized;\n use option::Option::{mod, Some, None};"}, {"sha": "9ab450efd2272d86e61b469960adbf45cac6ae64", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -23,7 +23,7 @@ use num::cast;\n use ops::FnOnce;\n use result::Result::Ok;\n use slice::{mod, SliceExt};\n-use str::StrPrelude;\n+use str::StrExt;\n \n /// A flag that specifies whether to use exponential (scientific) notation.\n pub enum ExponentFormat {"}, {"sha": "fb26450ec758e063bb726af2811b2162ec81a958", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -24,7 +24,7 @@ use result::Result::{Ok, Err};\n use result;\n use slice::SliceExt;\n use slice;\n-use str::StrPrelude;\n+use str::{StrExt, Utf8Error};\n \n pub use self::num::radix;\n pub use self::num::Radix;\n@@ -89,7 +89,7 @@ pub struct Formatter<'a> {\n     precision: Option<uint>,\n \n     buf: &'a mut (FormatWriter+'a),\n-    curarg: slice::Items<'a, Argument<'a>>,\n+    curarg: slice::Iter<'a, Argument<'a>>,\n     args: &'a [Argument<'a>],\n }\n \n@@ -795,5 +795,18 @@ impl<'b, T: Show> Show for RefMut<'b, T> {\n     }\n }\n \n+impl Show for Utf8Error {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        match *self {\n+            Utf8Error::InvalidByte(n) => {\n+                write!(f, \"invalid utf-8: invalid byte at index {}\", n)\n+            }\n+            Utf8Error::TooShort => {\n+                write!(f, \"invalid utf-8: byte slice too short\")\n+            }\n+        }\n+    }\n+}\n+\n // If you expected tests to be here, look instead at the run-pass/ifmt.rs test,\n // it's a lot easier than creating all of the rt::Piece structures here."}, {"sha": "1cd4d7b89d6d66bd303b2bfd3f083b5d1375e42a", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -2612,6 +2612,9 @@ pub fn iterate<T, F>(seed: T, f: F) -> Iterate<T, F> where\n         val.clone()\n     }\n \n+    // coerce to a fn pointer\n+    let next: fn(&mut IterateState<T,F>) -> Option<T> = next;\n+\n     Unfold::new((f, Some(seed), true), next)\n }\n "}, {"sha": "60735879213d8cbfcfbe8e6e559178d1d2f1a07e", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -32,7 +32,7 @@ use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n use option::Option;\n use option::Option::{Some, None};\n-use str::{FromStr, from_str, StrPrelude};\n+use str::{FromStr, from_str, StrExt};\n \n /// Simultaneous division and remainder\n #[inline]"}, {"sha": "d831a57893bd77754980a174b6ff9d9452e507c4", "filename": "src/libcore/option.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -718,15 +718,15 @@ impl<T: Default> Option<T> {\n     /// # Example\n     ///\n     /// Convert a string to an integer, turning poorly-formed strings\n-    /// into 0 (the default value for integers). `from_str` converts\n+    /// into 0 (the default value for integers). `parse` converts\n     /// a string to any other type that implements `FromStr`, returning\n     /// `None` on error.\n     ///\n     /// ```\n     /// let good_year_from_input = \"1909\";\n     /// let bad_year_from_input = \"190blarg\";\n-    /// let good_year = from_str(good_year_from_input).unwrap_or_default();\n-    /// let bad_year = from_str(bad_year_from_input).unwrap_or_default();\n+    /// let good_year = good_year_from_input.parse().unwrap_or_default();\n+    /// let bad_year = bad_year_from_input.parse().unwrap_or_default();\n     ///\n     /// assert_eq!(1909i, good_year);\n     /// assert_eq!(0i, bad_year);"}, {"sha": "f6abc8da79c0c9d1ddb6bbea9445d4f56a7f035b", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -60,7 +60,7 @@ pub use option::Option::{Some, None};\n pub use ptr::RawPtr;\n pub use result::Result;\n pub use result::Result::{Ok, Err};\n-pub use str::{Str, StrPrelude};\n+pub use str::{Str, StrExt};\n pub use tuple::{Tuple1, Tuple2, Tuple3, Tuple4};\n pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};\n pub use tuple::{Tuple9, Tuple10, Tuple11, Tuple12};"}, {"sha": "8014b4dc89d70e10faf55286c45e1bc71885e157", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -458,7 +458,7 @@ impl<T, E> Result<T, E> {\n     ///     let line: IoResult<String> = buffer.read_line();\n     ///     // Convert the string line to a number using `map` and `from_str`\n     ///     let val: IoResult<int> = line.map(|line| {\n-    ///         from_str::<int>(line.as_slice().trim_right()).unwrap_or(0)\n+    ///         line.as_slice().trim_right().parse::<int>().unwrap_or(0)\n     ///     });\n     ///     // Add the value if there were no errors, otherwise add 0\n     ///     sum += val.ok().unwrap_or(0);"}, {"sha": "26684864c4c49fac5caa115c34853204e1b9355b", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -67,7 +67,7 @@ pub trait SliceExt<T> for Sized? {\n     fn slice_from<'a>(&'a self, start: uint) -> &'a [T];\n     fn slice_to<'a>(&'a self, end: uint) -> &'a [T];\n     fn split_at<'a>(&'a self, mid: uint) -> (&'a [T], &'a [T]);\n-    fn iter<'a>(&'a self) -> Items<'a, T>;\n+    fn iter<'a>(&'a self) -> Iter<'a, T>;\n     fn split<'a, P>(&'a self, pred: P) -> Splits<'a, T, P>\n                     where P: FnMut(&T) -> bool;\n     fn splitn<'a, P>(&'a self, n: uint, pred: P) -> SplitsN<Splits<'a, T, P>>\n@@ -92,7 +92,7 @@ pub trait SliceExt<T> for Sized? {\n     fn slice_mut<'a>(&'a mut self, start: uint, end: uint) -> &'a mut [T];\n     fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T];\n     fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T];\n-    fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T>;\n+    fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T>;\n     fn head_mut<'a>(&'a mut self) -> Option<&'a mut T>;\n     fn tail_mut<'a>(&'a mut self) -> &'a mut [T];\n     fn init_mut<'a>(&'a mut self) -> &'a mut [T];\n@@ -141,15 +141,15 @@ impl<T> SliceExt<T> for [T] {\n     }\n \n     #[inline]\n-    fn iter<'a>(&'a self) -> Items<'a, T> {\n+    fn iter<'a>(&'a self) -> Iter<'a, T> {\n         unsafe {\n             let p = self.as_ptr();\n             if mem::size_of::<T>() == 0 {\n-                Items{ptr: p,\n+                Iter{ptr: p,\n                       end: (p as uint + self.len()) as *const T,\n                       marker: marker::ContravariantLifetime::<'a>}\n             } else {\n-                Items{ptr: p,\n+                Iter{ptr: p,\n                       end: p.offset(self.len() as int),\n                       marker: marker::ContravariantLifetime::<'a>}\n             }\n@@ -286,15 +286,15 @@ impl<T> SliceExt<T> for [T] {\n     }\n \n     #[inline]\n-    fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T> {\n+    fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n         unsafe {\n             let p = self.as_mut_ptr();\n             if mem::size_of::<T>() == 0 {\n-                MutItems{ptr: p,\n+                IterMut{ptr: p,\n                          end: (p as uint + self.len()) as *mut T,\n                          marker: marker::ContravariantLifetime::<'a>}\n             } else {\n-                MutItems{ptr: p,\n+                IterMut{ptr: p,\n                          end: p.offset(self.len() as int),\n                          marker: marker::ContravariantLifetime::<'a>}\n             }\n@@ -655,7 +655,7 @@ impl<'a, T> Default for &'a [T] {\n // Iterators\n //\n \n-// The shared definition of the `Item` and `MutItems` iterators\n+// The shared definition of the `Item` and `IterMut` iterators\n macro_rules! iterator {\n     (struct $name:ident -> $ptr:ty, $elem:ty) => {\n         #[experimental = \"needs review\"]\n@@ -738,14 +738,14 @@ macro_rules! make_slice {\n \n /// Immutable slice iterator\n #[experimental = \"needs review\"]\n-pub struct Items<'a, T: 'a> {\n+pub struct Iter<'a, T: 'a> {\n     ptr: *const T,\n     end: *const T,\n     marker: marker::ContravariantLifetime<'a>\n }\n \n #[experimental]\n-impl<'a, T> ops::Slice<uint, [T]> for Items<'a, T> {\n+impl<'a, T> ops::Slice<uint, [T]> for Iter<'a, T> {\n     fn as_slice_(&self) -> &[T] {\n         self.as_slice()\n     }\n@@ -763,7 +763,7 @@ impl<'a, T> ops::Slice<uint, [T]> for Items<'a, T> {\n     }\n }\n \n-impl<'a, T> Items<'a, T> {\n+impl<'a, T> Iter<'a, T> {\n     /// View the underlying data as a subslice of the original data.\n     ///\n     /// This has the same lifetime as the original slice, and so the\n@@ -774,20 +774,20 @@ impl<'a, T> Items<'a, T> {\n     }\n }\n \n-impl<'a,T> Copy for Items<'a,T> {}\n+impl<'a,T> Copy for Iter<'a,T> {}\n \n-iterator!{struct Items -> *const T, &'a T}\n+iterator!{struct Iter -> *const T, &'a T}\n \n #[experimental = \"needs review\"]\n-impl<'a, T> ExactSizeIterator<&'a T> for Items<'a, T> {}\n+impl<'a, T> ExactSizeIterator<&'a T> for Iter<'a, T> {}\n \n #[stable]\n-impl<'a, T> Clone for Items<'a, T> {\n-    fn clone(&self) -> Items<'a, T> { *self }\n+impl<'a, T> Clone for Iter<'a, T> {\n+    fn clone(&self) -> Iter<'a, T> { *self }\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n+impl<'a, T> RandomAccessIterator<&'a T> for Iter<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n         let (exact, _) = self.size_hint();\n@@ -813,14 +813,14 @@ impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n \n /// Mutable slice iterator.\n #[experimental = \"needs review\"]\n-pub struct MutItems<'a, T: 'a> {\n+pub struct IterMut<'a, T: 'a> {\n     ptr: *mut T,\n     end: *mut T,\n     marker: marker::ContravariantLifetime<'a>,\n }\n \n #[experimental]\n-impl<'a, T> ops::Slice<uint, [T]> for MutItems<'a, T> {\n+impl<'a, T> ops::Slice<uint, [T]> for IterMut<'a, T> {\n     fn as_slice_<'b>(&'b self) -> &'b [T] {\n         make_slice!(T -> &'b [T]: self.ptr, self.end)\n     }\n@@ -839,7 +839,7 @@ impl<'a, T> ops::Slice<uint, [T]> for MutItems<'a, T> {\n }\n \n #[experimental]\n-impl<'a, T> ops::SliceMut<uint, [T]> for MutItems<'a, T> {\n+impl<'a, T> ops::SliceMut<uint, [T]> for IterMut<'a, T> {\n     fn as_mut_slice_<'b>(&'b mut self) -> &'b mut [T] {\n         make_slice!(T -> &'b mut [T]: self.ptr, self.end)\n     }\n@@ -857,7 +857,7 @@ impl<'a, T> ops::SliceMut<uint, [T]> for MutItems<'a, T> {\n     }\n }\n \n-impl<'a, T> MutItems<'a, T> {\n+impl<'a, T> IterMut<'a, T> {\n     /// View the underlying data as a subslice of the original data.\n     ///\n     /// To avoid creating `&mut` references that alias, this is forced\n@@ -870,10 +870,10 @@ impl<'a, T> MutItems<'a, T> {\n     }\n }\n \n-iterator!{struct MutItems -> *mut T, &'a mut T}\n+iterator!{struct IterMut -> *mut T, &'a mut T}\n \n #[experimental = \"needs review\"]\n-impl<'a, T> ExactSizeIterator<&'a mut T> for MutItems<'a, T> {}\n+impl<'a, T> ExactSizeIterator<&'a mut T> for IterMut<'a, T> {}\n \n /// An abstraction over the splitting iterators, so that splitn, splitn_mut etc\n /// can be implemented once."}, {"sha": "204ffae6cbd54818ac21e2b4296fc0c43af590d4", "filename": "src/libcore/str.rs", "status": "modified", "additions": 141, "deletions": 901, "changes": 1042, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -16,38 +16,37 @@\n \n #![doc(primitive = \"str\")]\n \n-pub use self::Utf16Item::*;\n-pub use self::Searcher::{Naive, TwoWay, TwoWayLong};\n+use self::Searcher::{Naive, TwoWay, TwoWayLong};\n \n-use char::Char;\n-use char;\n use clone::Clone;\n-use cmp::{Eq, mod};\n+use cmp::{mod, Eq};\n use default::Default;\n-use iter::{Map, Iterator, IteratorExt, DoubleEndedIterator};\n-use iter::{DoubleEndedIteratorExt, ExactSizeIterator};\n use iter::range;\n+use iter::{DoubleEndedIteratorExt, ExactSizeIterator};\n+use iter::{Map, Iterator, IteratorExt, DoubleEndedIterator};\n use kinds::Sized;\n use mem;\n use num::Int;\n-use option::Option;\n-use option::Option::{None, Some};\n use ops::{Fn, FnMut};\n+use option::Option::{mod, None, Some};\n use ptr::RawPtr;\n use raw::{Repr, Slice};\n+use result::Result::{mod, Ok, Err};\n use slice::{mod, SliceExt};\n use uint;\n \n /// A trait to abstract the idea of creating a new instance of a type from a\n /// string.\n-#[experimental = \"might need to return Result\"]\n+// FIXME(#17307): there should be an `E` associated type for a `Result` return\n+#[unstable = \"will return a Result once associated types are working\"]\n pub trait FromStr {\n     /// Parses a string `s` to return an optional value of this type. If the\n     /// string is ill-formatted, the None is returned.\n     fn from_str(s: &str) -> Option<Self>;\n }\n \n /// A utility function that just calls FromStr::from_str\n+#[deprecated = \"call the .parse() method on the string instead\"]\n pub fn from_str<A: FromStr>(s: &str) -> Option<A> {\n     FromStr::from_str(s)\n }\n@@ -60,9 +59,9 @@ impl FromStr for bool {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// assert_eq!(from_str::<bool>(\"true\"), Some(true));\n-    /// assert_eq!(from_str::<bool>(\"false\"), Some(false));\n-    /// assert_eq!(from_str::<bool>(\"not even a boolean\"), None);\n+    /// assert_eq!(\"true\".parse(), Some(true));\n+    /// assert_eq!(\"false\".parse(), Some(false));\n+    /// assert_eq!(\"not even a boolean\".parse::<bool>(), None);\n     /// ```\n     #[inline]\n     fn from_str(s: &str) -> Option<bool> {\n@@ -78,22 +77,39 @@ impl FromStr for bool {\n Section: Creating a string\n */\n \n-/// Converts a slice of bytes to a string slice without performing any allocations.\n+/// Errors which can occur when attempting to interpret a byte slice as a `str`.\n+#[deriving(Copy, Eq, PartialEq, Clone)]\n+pub enum Utf8Error {\n+    /// An invalid byte was detected at the byte offset given.\n+    ///\n+    /// The offset is guaranteed to be in bounds of the slice in question, and\n+    /// the byte at the specified offset was the first invalid byte in the\n+    /// sequence detected.\n+    InvalidByte(uint),\n+\n+    /// The byte slice was invalid because more bytes were needed but no more\n+    /// bytes were available.\n+    TooShort,\n+}\n+\n+/// Converts a slice of bytes to a string slice without performing any\n+/// allocations.\n ///\n /// Once the slice has been validated as utf-8, it is transmuted in-place and\n /// returned as a '&str' instead of a '&[u8]'\n ///\n-/// Returns None if the slice is not utf-8.\n-pub fn from_utf8<'a>(v: &'a [u8]) -> Option<&'a str> {\n-    if is_utf8(v) {\n-        Some(unsafe { from_utf8_unchecked(v) })\n-    } else {\n-        None\n-    }\n+/// # Failure\n+///\n+/// Returns `Err` if the slice is not utf-8 with a description as to why the\n+/// provided slice is not utf-8.\n+pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n+    try!(run_utf8_validation_iterator(&mut v.iter()));\n+    Ok(unsafe { from_utf8_unchecked(v) })\n }\n \n /// Converts a slice of bytes to a string slice without checking\n /// that the string contains valid UTF-8.\n+#[stable]\n pub unsafe fn from_utf8_unchecked<'a>(v: &'a [u8]) -> &'a str {\n     mem::transmute(v)\n }\n@@ -111,17 +127,19 @@ pub unsafe fn from_utf8_unchecked<'a>(v: &'a [u8]) -> &'a str {\n /// # Panics\n ///\n /// This function will panic if the string pointed to by `s` is not valid UTF-8.\n+#[unstable = \"may change location based on the outcome of the c_str module\"]\n pub unsafe fn from_c_str(s: *const i8) -> &'static str {\n     let s = s as *const u8;\n     let mut len = 0u;\n     while *s.offset(len as int) != 0 {\n         len += 1u;\n     }\n     let v: &'static [u8] = ::mem::transmute(Slice { data: s, len: len });\n-    from_utf8(v).expect(\"from_c_str passed invalid utf-8 data\")\n+    from_utf8(v).ok().expect(\"from_c_str passed invalid utf-8 data\")\n }\n \n /// Something that can be used to compare against a character\n+#[unstable = \"definition may change as pattern-related methods are stabilized\"]\n pub trait CharEq {\n     /// Determine if the splitter should split at the given character\n     fn matches(&mut self, char) -> bool;\n@@ -167,7 +185,7 @@ Section: Iterators\n /// Created with the method `.chars()`.\n #[deriving(Clone, Copy)]\n pub struct Chars<'a> {\n-    iter: slice::Items<'a, u8>\n+    iter: slice::Iter<'a, u8>\n }\n \n // Return the initial codepoint accumulator for the first byte.\n@@ -273,12 +291,12 @@ impl<'a> DoubleEndedIterator<char> for Chars<'a> {\n /// External iterator for a string's characters and their byte offsets.\n /// Use with the `std::iter` module.\n #[deriving(Clone)]\n-pub struct CharOffsets<'a> {\n+pub struct CharIndices<'a> {\n     front_offset: uint,\n     iter: Chars<'a>,\n }\n \n-impl<'a> Iterator<(uint, char)> for CharOffsets<'a> {\n+impl<'a> Iterator<(uint, char)> for CharIndices<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<(uint, char)> {\n         let (pre_len, _) = self.iter.iter.size_hint();\n@@ -299,7 +317,7 @@ impl<'a> Iterator<(uint, char)> for CharOffsets<'a> {\n     }\n }\n \n-impl<'a> DoubleEndedIterator<(uint, char)> for CharOffsets<'a> {\n+impl<'a> DoubleEndedIterator<(uint, char)> for CharIndices<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<(uint, char)> {\n         match self.iter.next_back() {\n@@ -315,13 +333,16 @@ impl<'a> DoubleEndedIterator<(uint, char)> for CharOffsets<'a> {\n \n /// External iterator for a string's bytes.\n /// Use with the `std::iter` module.\n-pub type Bytes<'a> = Map<&'a u8, u8, slice::Items<'a, u8>, BytesFn>;\n+#[stable]\n+#[deriving(Clone)]\n+pub struct Bytes<'a> {\n+    inner: Map<&'a u8, u8, slice::Iter<'a, u8>, BytesFn>,\n+}\n \n /// A temporary new type wrapper that ensures that the `Bytes` iterator\n /// is cloneable.\n #[deriving(Copy)]\n-#[experimental = \"iterator type instability\"]\n-pub struct BytesFn(fn(&u8) -> u8);\n+struct BytesFn(fn(&u8) -> u8);\n \n impl<'a> Fn(&'a u8) -> u8 for BytesFn {\n     extern \"rust-call\" fn call(&self, (ptr,): (&'a u8,)) -> u8 {\n@@ -355,8 +376,17 @@ pub struct CharSplitsN<'a, Sep> {\n     invert: bool,\n }\n \n+/// An iterator over the lines of a string, separated by `\\n`.\n+#[stable]\n+pub struct Lines<'a> {\n+    inner: CharSplits<'a, char>,\n+}\n+\n /// An iterator over the lines of a string, separated by either `\\n` or (`\\r\\n`).\n-pub type AnyLines<'a> = Map<&'a str, &'a str, CharSplits<'a, char>, fn(&str) -> &str>;\n+#[stable]\n+pub struct LinesAny<'a> {\n+    inner: Map<&'a str, &'a str, Lines<'a>, fn(&str) -> &str>,\n+}\n \n impl<'a, Sep> CharSplits<'a, Sep> {\n     #[inline]\n@@ -799,63 +829,6 @@ impl<'a> Iterator<&'a str> for StrSplits<'a> {\n     }\n }\n \n-/// External iterator for a string's UTF16 codeunits.\n-/// Use with the `std::iter` module.\n-#[deriving(Clone)]\n-pub struct Utf16CodeUnits<'a> {\n-    encoder: Utf16Encoder<Chars<'a>>\n-}\n-\n-impl<'a> Iterator<u16> for Utf16CodeUnits<'a> {\n-    #[inline]\n-    fn next(&mut self) -> Option<u16> { self.encoder.next() }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.encoder.size_hint() }\n-}\n-\n-\n-/// Iterator adaptor for encoding `char`s to UTF-16.\n-#[deriving(Clone)]\n-pub struct Utf16Encoder<I> {\n-    chars: I,\n-    extra: u16\n-}\n-\n-impl<I> Utf16Encoder<I> {\n-    /// Create an UTF-16 encoder from any `char` iterator.\n-    pub fn new(chars: I) -> Utf16Encoder<I> where I: Iterator<char> {\n-        Utf16Encoder { chars: chars, extra: 0 }\n-    }\n-}\n-\n-impl<I> Iterator<u16> for Utf16Encoder<I> where I: Iterator<char> {\n-    #[inline]\n-    fn next(&mut self) -> Option<u16> {\n-        if self.extra != 0 {\n-            let tmp = self.extra;\n-            self.extra = 0;\n-            return Some(tmp);\n-        }\n-\n-        let mut buf = [0u16, ..2];\n-        self.chars.next().map(|ch| {\n-            let n = ch.encode_utf16(buf[mut]).unwrap_or(0);\n-            if n == 2 { self.extra = buf[1]; }\n-            buf[0]\n-        })\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        let (low, high) = self.chars.size_hint();\n-        // every char gets either one u16 or two u16,\n-        // so this iterator is between 1 or 2 times as\n-        // long as the underlying iterator.\n-        (low, high.and_then(|n| n.checked_mul(2)))\n-    }\n-}\n-\n /*\n Section: Comparing strings\n */\n@@ -880,7 +853,7 @@ fn eq_slice_(a: &str, b: &str) -> bool {\n /// to compare &[u8] byte slices that are not necessarily valid UTF-8.\n #[lang=\"str_eq\"]\n #[inline]\n-pub fn eq_slice(a: &str, b: &str) -> bool {\n+fn eq_slice(a: &str, b: &str) -> bool {\n     eq_slice_(a, b)\n }\n \n@@ -893,32 +866,37 @@ Section: Misc\n /// `iter` reset such that it is pointing at the first byte in the\n /// invalid sequence.\n #[inline(always)]\n-fn run_utf8_validation_iterator(iter: &mut slice::Items<u8>) -> bool {\n+fn run_utf8_validation_iterator(iter: &mut slice::Iter<u8>)\n+                                -> Result<(), Utf8Error> {\n+    let whole = iter.as_slice();\n     loop {\n         // save the current thing we're pointing at.\n         let old = *iter;\n \n         // restore the iterator we had at the start of this codepoint.\n-        macro_rules! err ( () => { {*iter = old; return false} });\n+        macro_rules! err (() => { {\n+            *iter = old;\n+            return Err(Utf8Error::InvalidByte(whole.len() - iter.as_slice().len()))\n+        } });\n         macro_rules! next ( () => {\n-                match iter.next() {\n-                    Some(a) => *a,\n-                    // we needed data, but there was none: error!\n-                    None => err!()\n-                }\n-            });\n+            match iter.next() {\n+                Some(a) => *a,\n+                // we needed data, but there was none: error!\n+                None => return Err(Utf8Error::TooShort),\n+            }\n+        });\n \n         let first = match iter.next() {\n             Some(&b) => b,\n             // we're at the end of the iterator and a codepoint\n             // boundary at the same time, so this string is valid.\n-            None => return true\n+            None => return Ok(())\n         };\n \n         // ASCII characters are always valid, so only large\n         // bytes need more examination.\n         if first >= 128 {\n-            let w = utf8_char_width(first);\n+            let w = UTF8_CHAR_WIDTH[first as uint] as uint;\n             let second = next!();\n             // 2-byte encoding is for codepoints  \\u{0080} to  \\u{07ff}\n             //        first  C2 80        last DF BF\n@@ -964,145 +942,13 @@ fn run_utf8_validation_iterator(iter: &mut slice::Items<u8>) -> bool {\n }\n \n /// Determines if a vector of bytes contains valid UTF-8.\n+#[deprecated = \"call from_utf8 instead\"]\n pub fn is_utf8(v: &[u8]) -> bool {\n-    run_utf8_validation_iterator(&mut v.iter())\n-}\n-\n-/// Determines if a vector of `u16` contains valid UTF-16\n-pub fn is_utf16(v: &[u16]) -> bool {\n-    let mut it = v.iter();\n-    macro_rules! next ( ($ret:expr) => {\n-            match it.next() { Some(u) => *u, None => return $ret }\n-        }\n-    );\n-    loop {\n-        let u = next!(true);\n-\n-        match char::from_u32(u as u32) {\n-            Some(_) => {}\n-            None => {\n-                let u2 = next!(false);\n-                if u < 0xD7FF || u > 0xDBFF ||\n-                    u2 < 0xDC00 || u2 > 0xDFFF { return false; }\n-            }\n-        }\n-    }\n-}\n-\n-/// An iterator that decodes UTF-16 encoded codepoints from a vector\n-/// of `u16`s.\n-#[deriving(Clone)]\n-pub struct Utf16Items<'a> {\n-    iter: slice::Items<'a, u16>\n-}\n-/// The possibilities for values decoded from a `u16` stream.\n-#[deriving(Copy, PartialEq, Eq, Clone, Show)]\n-pub enum Utf16Item {\n-    /// A valid codepoint.\n-    ScalarValue(char),\n-    /// An invalid surrogate without its pair.\n-    LoneSurrogate(u16)\n-}\n-\n-impl Utf16Item {\n-    /// Convert `self` to a `char`, taking `LoneSurrogate`s to the\n-    /// replacement character (U+FFFD).\n-    #[inline]\n-    pub fn to_char_lossy(&self) -> char {\n-        match *self {\n-            ScalarValue(c) => c,\n-            LoneSurrogate(_) => '\\u{FFFD}'\n-        }\n-    }\n+    run_utf8_validation_iterator(&mut v.iter()).is_ok()\n }\n \n-impl<'a> Iterator<Utf16Item> for Utf16Items<'a> {\n-    fn next(&mut self) -> Option<Utf16Item> {\n-        let u = match self.iter.next() {\n-            Some(u) => *u,\n-            None => return None\n-        };\n-\n-        if u < 0xD800 || 0xDFFF < u {\n-            // not a surrogate\n-            Some(ScalarValue(unsafe {mem::transmute(u as u32)}))\n-        } else if u >= 0xDC00 {\n-            // a trailing surrogate\n-            Some(LoneSurrogate(u))\n-        } else {\n-            // preserve state for rewinding.\n-            let old = self.iter;\n-\n-            let u2 = match self.iter.next() {\n-                Some(u2) => *u2,\n-                // eof\n-                None => return Some(LoneSurrogate(u))\n-            };\n-            if u2 < 0xDC00 || u2 > 0xDFFF {\n-                // not a trailing surrogate so we're not a valid\n-                // surrogate pair, so rewind to redecode u2 next time.\n-                self.iter = old;\n-                return Some(LoneSurrogate(u))\n-            }\n-\n-            // all ok, so lets decode it.\n-            let c = ((u - 0xD800) as u32 << 10 | (u2 - 0xDC00) as u32) + 0x1_0000;\n-            Some(ScalarValue(unsafe {mem::transmute(c)}))\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        let (low, high) = self.iter.size_hint();\n-        // we could be entirely valid surrogates (2 elements per\n-        // char), or entirely non-surrogates (1 element per char)\n-        (low / 2, high)\n-    }\n-}\n-\n-/// Create an iterator over the UTF-16 encoded codepoints in `v`,\n-/// returning invalid surrogates as `LoneSurrogate`s.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// use std::str;\n-/// use std::str::{ScalarValue, LoneSurrogate};\n-///\n-/// // \ud834\udd1emus<invalid>ic<invalid>\n-/// let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n-///          0x0073, 0xDD1E, 0x0069, 0x0063,\n-///          0xD834];\n-///\n-/// assert_eq!(str::utf16_items(&v).collect::<Vec<_>>(),\n-///            vec![ScalarValue('\ud834\udd1e'),\n-///                 ScalarValue('m'), ScalarValue('u'), ScalarValue('s'),\n-///                 LoneSurrogate(0xDD1E),\n-///                 ScalarValue('i'), ScalarValue('c'),\n-///                 LoneSurrogate(0xD834)]);\n-/// ```\n-pub fn utf16_items<'a>(v: &'a [u16]) -> Utf16Items<'a> {\n-    Utf16Items { iter : v.iter() }\n-}\n-\n-/// Return a slice of `v` ending at (and not including) the first NUL\n-/// (0).\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// use std::str;\n-///\n-/// // \"abcd\"\n-/// let mut v = ['a' as u16, 'b' as u16, 'c' as u16, 'd' as u16];\n-/// // no NULs so no change\n-/// assert_eq!(str::truncate_utf16_at_nul(&v), v.as_slice());\n-///\n-/// // \"ab\\0d\"\n-/// v[2] = 0;\n-/// let b: &[_] = &['a' as u16, 'b' as u16];\n-/// assert_eq!(str::truncate_utf16_at_nul(&v), b);\n-/// ```\n+/// Deprecated function\n+#[deprecated = \"this function will be removed\"]\n pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n     match v.iter().position(|c| *c == 0) {\n         // don't include the 0\n@@ -1133,6 +979,7 @@ static UTF8_CHAR_WIDTH: [u8, ..256] = [\n \n /// Given a first byte, determine how many bytes are in this UTF-8 character\n #[inline]\n+#[deprecated = \"this function has moved to libunicode\"]\n pub fn utf8_char_width(b: u8) -> uint {\n     return UTF8_CHAR_WIDTH[b as uint] as uint;\n }\n@@ -1141,6 +988,7 @@ pub fn utf8_char_width(b: u8) -> uint {\n /// the next `char` in a string.  This can be used as a data structure\n /// for iterating over the UTF-8 bytes of a string.\n #[deriving(Copy)]\n+#[unstable = \"naming is uncertain with container conventions\"]\n pub struct CharRange {\n     /// Current `char`\n     pub ch: char,\n@@ -1159,7 +1007,7 @@ pub mod raw {\n     use ptr::RawPtr;\n     use raw::Slice;\n     use slice::SliceExt;\n-    use str::{is_utf8, StrPrelude};\n+    use str::StrExt;\n \n     /// Converts a slice of bytes to a string slice without checking\n     /// that the string contains valid UTF-8.\n@@ -1181,8 +1029,7 @@ pub mod raw {\n             curr = s.offset(len as int);\n         }\n         let v = Slice { data: s, len: len };\n-        assert!(is_utf8(::mem::transmute(v)));\n-        ::mem::transmute(v)\n+        super::from_utf8(::mem::transmute(v)).unwrap()\n     }\n \n     /// Takes a bytewise (not UTF-8) slice from a string.\n@@ -1225,7 +1072,7 @@ pub mod traits {\n     use option::Option;\n     use option::Option::Some;\n     use ops;\n-    use str::{Str, StrPrelude, eq_slice};\n+    use str::{Str, StrExt, eq_slice};\n \n     impl Ord for str {\n         #[inline]\n@@ -1291,707 +1138,70 @@ pub mod traits {\n }\n \n /// Any string that can be represented as a slice\n+#[unstable = \"Instead of taking this bound generically, this trait will be \\\n+              replaced with one of slicing syntax, deref coercions, or \\\n+              a more generic conversion trait\"]\n pub trait Str for Sized? {\n     /// Work with `self` as a slice.\n     fn as_slice<'a>(&'a self) -> &'a str;\n }\n \n+#[allow(deprecated)]\n impl Str for str {\n     #[inline]\n     fn as_slice<'a>(&'a self) -> &'a str { self }\n }\n \n+#[allow(deprecated)]\n impl<'a, Sized? S> Str for &'a S where S: Str {\n     #[inline]\n     fn as_slice(&self) -> &str { Str::as_slice(*self) }\n }\n \n /// Methods for string slices\n-pub trait StrPrelude for Sized? {\n-    /// Returns true if one string contains another\n-    ///\n-    /// # Arguments\n-    ///\n-    /// - needle - The string to look for\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// assert!(\"bananas\".contains(\"nana\"));\n-    /// ```\n-    fn contains(&self, needle: &str) -> bool;\n+#[allow(missing_docs)]\n+pub trait StrExt for Sized? {\n+    // NB there are no docs here are they're all located on the StrExt trait in\n+    // libcollections, not here.\n \n-    /// Returns true if a string contains a char.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// - needle - The char to look for\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// assert!(\"hello\".contains_char('e'));\n-    /// ```\n+    fn contains(&self, needle: &str) -> bool;\n     fn contains_char(&self, needle: char) -> bool;\n-\n-    /// An iterator over the characters of `self`. Note, this iterates\n-    /// over Unicode code-points, not Unicode graphemes.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: Vec<char> = \"abc \u00e5\u00e4\u00f6\".chars().collect();\n-    /// assert_eq!(v, vec!['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n-    /// ```\n     fn chars<'a>(&'a self) -> Chars<'a>;\n-\n-    /// An iterator over the bytes of `self`\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: Vec<u8> = \"bors\".bytes().collect();\n-    /// assert_eq!(v, b\"bors\".to_vec());\n-    /// ```\n     fn bytes<'a>(&'a self) -> Bytes<'a>;\n-\n-    /// An iterator over the characters of `self` and their byte offsets.\n-    fn char_indices<'a>(&'a self) -> CharOffsets<'a>;\n-\n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by `sep`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// # #![feature(unboxed_closures)]\n-    ///\n-    /// # fn main() {\n-    /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\n-    /// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n-    ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".split(|&: c: char| c.is_numeric()).collect();\n-    /// assert_eq!(v, vec![\"abc\", \"def\", \"ghi\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\n-    /// assert_eq!(v, vec![\"lion\", \"\", \"tiger\", \"leopard\"]);\n-    ///\n-    /// let v: Vec<&str> = \"\".split('X').collect();\n-    /// assert_eq!(v, vec![\"\"]);\n-    /// # }\n-    /// ```\n+    fn char_indices<'a>(&'a self) -> CharIndices<'a>;\n     fn split<'a, Sep: CharEq>(&'a self, sep: Sep) -> CharSplits<'a, Sep>;\n-\n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by `sep`, restricted to splitting at most `count`\n-    /// times.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// # #![feature(unboxed_closures)]\n-    ///\n-    /// # fn main() {\n-    /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(2, ' ').collect();\n-    /// assert_eq!(v, vec![\"Mary\", \"had\", \"a little lambda\"]);\n-    ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".splitn(1, |&: c: char| c.is_numeric()).collect();\n-    /// assert_eq!(v, vec![\"abc\", \"def2ghi\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn(2, 'X').collect();\n-    /// assert_eq!(v, vec![\"lion\", \"\", \"tigerXleopard\"]);\n-    ///\n-    /// let v: Vec<&str> = \"abcXdef\".splitn(0, 'X').collect();\n-    /// assert_eq!(v, vec![\"abcXdef\"]);\n-    ///\n-    /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n-    /// assert_eq!(v, vec![\"\"]);\n-    /// # }\n-    /// ```\n     fn splitn<'a, Sep: CharEq>(&'a self, count: uint, sep: Sep) -> CharSplitsN<'a, Sep>;\n-\n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by `sep`.\n-    ///\n-    /// Equivalent to `split`, except that the trailing substring\n-    /// is skipped if empty (terminator semantics).\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// # #![feature(unboxed_closures)]\n-    ///\n-    /// # fn main() {\n-    /// let v: Vec<&str> = \"A.B.\".split_terminator('.').collect();\n-    /// assert_eq!(v, vec![\"A\", \"B\"]);\n-    ///\n-    /// let v: Vec<&str> = \"A..B..\".split_terminator('.').collect();\n-    /// assert_eq!(v, vec![\"A\", \"\", \"B\", \"\"]);\n-    ///\n-    /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').rev().collect();\n-    /// assert_eq!(v, vec![\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n-    ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".split(|&: c: char| c.is_numeric()).rev().collect();\n-    /// assert_eq!(v, vec![\"ghi\", \"def\", \"abc\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').rev().collect();\n-    /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"\", \"lion\"]);\n-    /// # }\n-    /// ```\n     fn split_terminator<'a, Sep: CharEq>(&'a self, sep: Sep) -> CharSplits<'a, Sep>;\n-\n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by `sep`, starting from the end of the string.\n-    /// Restricted to splitting at most `count` times.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// # #![feature(unboxed_closures)]\n-    ///\n-    /// # fn main() {\n-    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(2, ' ').collect();\n-    /// assert_eq!(v, vec![\"lamb\", \"little\", \"Mary had a\"]);\n-    ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".rsplitn(1, |&: c: char| c.is_numeric()).collect();\n-    /// assert_eq!(v, vec![\"ghi\", \"abc1def\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(2, 'X').collect();\n-    /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"lionX\"]);\n-    /// # }\n-    /// ```\n     fn rsplitn<'a, Sep: CharEq>(&'a self, count: uint, sep: Sep) -> CharSplitsN<'a, Sep>;\n-\n-    /// An iterator over the start and end indices of the disjoint\n-    /// matches of `sep` within `self`.\n-    ///\n-    /// That is, each returned value `(start, end)` satisfies\n-    /// `self.slice(start, end) == sep`. For matches of `sep` within\n-    /// `self` that overlap, only the indices corresponding to the\n-    /// first match are returned.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: Vec<(uint, uint)> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n-    /// assert_eq!(v, vec![(0,3), (6,9), (12,15)]);\n-    ///\n-    /// let v: Vec<(uint, uint)> = \"1abcabc2\".match_indices(\"abc\").collect();\n-    /// assert_eq!(v, vec![(1,4), (4,7)]);\n-    ///\n-    /// let v: Vec<(uint, uint)> = \"ababa\".match_indices(\"aba\").collect();\n-    /// assert_eq!(v, vec![(0, 3)]); // only the first `aba`\n-    /// ```\n     fn match_indices<'a>(&'a self, sep: &'a str) -> MatchIndices<'a>;\n-\n-    /// An iterator over the substrings of `self` separated by `sep`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".split_str(\"abc\").collect();\n-    /// assert_eq!(v, vec![\"\", \"XXX\", \"YYY\", \"\"]);\n-    ///\n-    /// let v: Vec<&str> = \"1abcabc2\".split_str(\"abc\").collect();\n-    /// assert_eq!(v, vec![\"1\", \"\", \"2\"]);\n-    /// ```\n     fn split_str<'a>(&'a self, &'a str) -> StrSplits<'a>;\n-\n-    /// An iterator over the lines of a string (subsequences separated\n-    /// by `\\n`). This does not include the empty string after a\n-    /// trailing `\\n`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let four_lines = \"foo\\nbar\\n\\nbaz\\n\";\n-    /// let v: Vec<&str> = four_lines.lines().collect();\n-    /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n-    /// ```\n-    fn lines<'a>(&'a self) -> CharSplits<'a, char>;\n-\n-    /// An iterator over the lines of a string, separated by either\n-    /// `\\n` or `\\r\\n`. As with `.lines()`, this does not include an\n-    /// empty trailing line.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let four_lines = \"foo\\r\\nbar\\n\\r\\nbaz\\n\";\n-    /// let v: Vec<&str> = four_lines.lines_any().collect();\n-    /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n-    /// ```\n-    fn lines_any<'a>(&'a self) -> AnyLines<'a>;\n-\n-    /// Returns the number of Unicode code points (`char`) that a\n-    /// string holds.\n-    ///\n-    /// This does not perform any normalization, and is `O(n)`, since\n-    /// UTF-8 is a variable width encoding of code points.\n-    ///\n-    /// *Warning*: The number of code points in a string does not directly\n-    /// correspond to the number of visible characters or width of the\n-    /// visible text due to composing characters, and double- and\n-    /// zero-width ones.\n-    ///\n-    /// See also `.len()` for the byte length.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// // composed forms of `\u00f6` and `\u00e9`\n-    /// let c = \"L\u00f6we \u8001\u864e L\u00e9opard\"; // German, Simplified Chinese, French\n-    /// // decomposed forms of `\u00f6` and `\u00e9`\n-    /// let d = \"Lo\\u{0308}we \u8001\u864e Le\\u{0301}opard\";\n-    ///\n-    /// assert_eq!(c.char_len(), 15);\n-    /// assert_eq!(d.char_len(), 17);\n-    ///\n-    /// assert_eq!(c.len(), 21);\n-    /// assert_eq!(d.len(), 23);\n-    ///\n-    /// // the two strings *look* the same\n-    /// println!(\"{}\", c);\n-    /// println!(\"{}\", d);\n-    /// ```\n+    fn lines<'a>(&'a self) -> Lines<'a>;\n+    fn lines_any<'a>(&'a self) -> LinesAny<'a>;\n     fn char_len(&self) -> uint;\n-\n-    /// Returns a slice of the given string from the byte range\n-    /// [`begin`..`end`).\n-    ///\n-    /// This operation is `O(1)`.\n-    ///\n-    /// Panics when `begin` and `end` do not point to valid characters\n-    /// or point beyond the last character of the string.\n-    ///\n-    /// See also `slice_to` and `slice_from` for slicing prefixes and\n-    /// suffixes of strings, and `slice_chars` for slicing based on\n-    /// code point counts.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// assert_eq!(s.slice(0, 1), \"L\");\n-    ///\n-    /// assert_eq!(s.slice(1, 9), \"\u00f6we \u8001\");\n-    ///\n-    /// // these will panic:\n-    /// // byte 2 lies within `\u00f6`:\n-    /// // s.slice(2, 3);\n-    ///\n-    /// // byte 8 lies within `\u8001`\n-    /// // s.slice(1, 8);\n-    ///\n-    /// // byte 100 is outside the string\n-    /// // s.slice(3, 100);\n-    /// ```\n     fn slice<'a>(&'a self, begin: uint, end: uint) -> &'a str;\n-\n-    /// Returns a slice of the string from `begin` to its end.\n-    ///\n-    /// Equivalent to `self.slice(begin, self.len())`.\n-    ///\n-    /// Panics when `begin` does not point to a valid character, or is\n-    /// out of bounds.\n-    ///\n-    /// See also `slice`, `slice_to` and `slice_chars`.\n     fn slice_from<'a>(&'a self, begin: uint) -> &'a str;\n-\n-    /// Returns a slice of the string from the beginning to byte\n-    /// `end`.\n-    ///\n-    /// Equivalent to `self.slice(0, end)`.\n-    ///\n-    /// Panics when `end` does not point to a valid character, or is\n-    /// out of bounds.\n-    ///\n-    /// See also `slice`, `slice_from` and `slice_chars`.\n     fn slice_to<'a>(&'a self, end: uint) -> &'a str;\n-\n-    /// Returns a slice of the string from the character range\n-    /// [`begin`..`end`).\n-    ///\n-    /// That is, start at the `begin`-th code point of the string and\n-    /// continue to the `end`-th code point. This does not detect or\n-    /// handle edge cases such as leaving a combining character as the\n-    /// first code point of the string.\n-    ///\n-    /// Due to the design of UTF-8, this operation is `O(end)`.\n-    /// See `slice`, `slice_to` and `slice_from` for `O(1)`\n-    /// variants that use byte indices rather than code point\n-    /// indices.\n-    ///\n-    /// Panics if `begin` > `end` or the either `begin` or `end` are\n-    /// beyond the last character of the string.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// assert_eq!(s.slice_chars(0, 4), \"L\u00f6we\");\n-    /// assert_eq!(s.slice_chars(5, 7), \"\u8001\u864e\");\n-    /// ```\n     fn slice_chars<'a>(&'a self, begin: uint, end: uint) -> &'a str;\n-\n-    /// Takes a bytewise (not UTF-8) slice from a string.\n-    ///\n-    /// Returns the substring from [`begin`..`end`).\n-    ///\n-    /// Caller must check both UTF-8 character boundaries and the boundaries of\n-    /// the entire slice as well.\n     unsafe fn slice_unchecked<'a>(&'a self, begin: uint, end: uint) -> &'a str;\n-\n-    /// Returns true if `needle` is a prefix of the string.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// assert!(\"banana\".starts_with(\"ba\"));\n-    /// ```\n     fn starts_with(&self, needle: &str) -> bool;\n-\n-    /// Returns true if `needle` is a suffix of the string.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// assert!(\"banana\".ends_with(\"nana\"));\n-    /// ```\n     fn ends_with(&self, needle: &str) -> bool;\n-\n-    /// Returns a string with characters that match `to_trim` removed from the left and the right.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * to_trim - a character matcher\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// # #![feature(unboxed_closures)]\n-    ///\n-    /// # fn main() {\n-    /// assert_eq!(\"11foo1bar11\".trim_chars('1'), \"foo1bar\");\n-    /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_chars(x), \"foo1bar\");\n-    /// assert_eq!(\"123foo1bar123\".trim_chars(|&: c: char| c.is_numeric()), \"foo1bar\");\n-    /// # }\n-    /// ```\n     fn trim_chars<'a, C: CharEq>(&'a self, to_trim: C) -> &'a str;\n-\n-    /// Returns a string with leading `chars_to_trim` removed.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * to_trim - a character matcher\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// # #![feature(unboxed_closures)]\n-    ///\n-    /// # fn main() {\n-    /// assert_eq!(\"11foo1bar11\".trim_left_chars('1'), \"foo1bar11\");\n-    /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_left_chars(x), \"foo1bar12\");\n-    /// assert_eq!(\"123foo1bar123\".trim_left_chars(|&: c: char| c.is_numeric()), \"foo1bar123\");\n-    /// # }\n-    /// ```\n     fn trim_left_chars<'a, C: CharEq>(&'a self, to_trim: C) -> &'a str;\n-\n-    /// Returns a string with trailing `chars_to_trim` removed.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * to_trim - a character matcher\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// # #![feature(unboxed_closures)]\n-    ///\n-    /// # fn main() {\n-    /// assert_eq!(\"11foo1bar11\".trim_right_chars('1'), \"11foo1bar\");\n-    /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_right_chars(x), \"12foo1bar\");\n-    /// assert_eq!(\"123foo1bar123\".trim_right_chars(|&: c: char| c.is_numeric()), \"123foo1bar\");\n-    /// # }\n-    /// ```\n     fn trim_right_chars<'a, C: CharEq>(&'a self, to_trim: C) -> &'a str;\n-\n-    /// Check that `index`-th byte lies at the start and/or end of a\n-    /// UTF-8 code point sequence.\n-    ///\n-    /// The start and end of the string (when `index == self.len()`)\n-    /// are considered to be boundaries.\n-    ///\n-    /// Panics if `index` is greater than `self.len()`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// assert!(s.is_char_boundary(0));\n-    /// // start of `\u8001`\n-    /// assert!(s.is_char_boundary(6));\n-    /// assert!(s.is_char_boundary(s.len()));\n-    ///\n-    /// // second byte of `\u00f6`\n-    /// assert!(!s.is_char_boundary(2));\n-    ///\n-    /// // third byte of `\u8001`\n-    /// assert!(!s.is_char_boundary(8));\n-    /// ```\n     fn is_char_boundary(&self, index: uint) -> bool;\n-\n-    /// Pluck a character out of a string and return the index of the next\n-    /// character.\n-    ///\n-    /// This function can be used to iterate over the Unicode characters of a\n-    /// string.\n-    ///\n-    /// # Example\n-    ///\n-    /// This example manually iterates through the characters of a\n-    /// string; this should normally be done by `.chars()` or\n-    /// `.char_indices`.\n-    ///\n-    /// ```rust\n-    /// use std::str::CharRange;\n-    ///\n-    /// let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n-    /// let mut i = 0u;\n-    /// while i < s.len() {\n-    ///     let CharRange {ch, next} = s.char_range_at(i);\n-    ///     println!(\"{}: {}\", i, ch);\n-    ///     i = next;\n-    /// }\n-    /// ```\n-    ///\n-    /// This outputs:\n-    ///\n-    /// ```text\n-    /// 0: \u4e2d\n-    /// 3: \u534e\n-    /// 6: V\n-    /// 7: i\n-    /// 8: \u1ec7\n-    /// 11: t\n-    /// 12:\n-    /// 13: N\n-    /// 14: a\n-    /// 15: m\n-    /// ```\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * s - The string\n-    /// * i - The byte offset of the char to extract\n-    ///\n-    /// # Return value\n-    ///\n-    /// A record {ch: char, next: uint} containing the char value and the byte\n-    /// index of the next Unicode character.\n-    ///\n-    /// # Panics\n-    ///\n-    /// If `i` is greater than or equal to the length of the string.\n-    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n     fn char_range_at(&self, start: uint) -> CharRange;\n-\n-    /// Given a byte position and a str, return the previous char and its position.\n-    ///\n-    /// This function can be used to iterate over a Unicode string in reverse.\n-    ///\n-    /// Returns 0 for next index if called on start index 0.\n-    ///\n-    /// # Panics\n-    ///\n-    /// If `i` is greater than the length of the string.\n-    /// If `i` is not an index following a valid UTF-8 character.\n     fn char_range_at_reverse(&self, start: uint) -> CharRange;\n-\n-    /// Plucks the character starting at the `i`th byte of a string.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let s = \"ab\u03c0c\";\n-    /// assert_eq!(s.char_at(1), 'b');\n-    /// assert_eq!(s.char_at(2), '\u03c0');\n-    /// assert_eq!(s.char_at(4), 'c');\n-    /// ```\n-    ///\n-    /// # Panics\n-    ///\n-    /// If `i` is greater than or equal to the length of the string.\n-    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n     fn char_at(&self, i: uint) -> char;\n-\n-    /// Plucks the character ending at the `i`th byte of a string.\n-    ///\n-    /// # Panics\n-    ///\n-    /// If `i` is greater than the length of the string.\n-    /// If `i` is not an index following a valid UTF-8 character.\n     fn char_at_reverse(&self, i: uint) -> char;\n-\n-    /// Work with the byte buffer of a string as a byte slice.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// assert_eq!(\"bors\".as_bytes(), b\"bors\");\n-    /// ```\n     fn as_bytes<'a>(&'a self) -> &'a [u8];\n-\n-    /// Returns the byte index of the first character of `self` that\n-    /// matches `search`.\n-    ///\n-    /// # Return value\n-    ///\n-    /// `Some` containing the byte index of the last matching character\n-    /// or `None` if there is no match\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// # #![feature(unboxed_closures)]\n-    ///\n-    /// # fn main() {\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.find('L'), Some(0));\n-    /// assert_eq!(s.find('\u00e9'), Some(14));\n-    ///\n-    /// // the first space\n-    /// assert_eq!(s.find(|&: c: char| c.is_whitespace()), Some(5));\n-    ///\n-    /// // neither are found\n-    /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(s.find(x), None);\n-    /// # }\n-    /// ```\n     fn find<C: CharEq>(&self, search: C) -> Option<uint>;\n-\n-    /// Returns the byte index of the last character of `self` that\n-    /// matches `search`.\n-    ///\n-    /// # Return value\n-    ///\n-    /// `Some` containing the byte index of the last matching character\n-    /// or `None` if there is no match.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// # #![feature(unboxed_closures)]\n-    ///\n-    /// # fn main() {\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.rfind('L'), Some(13));\n-    /// assert_eq!(s.rfind('\u00e9'), Some(14));\n-    ///\n-    /// // the second space\n-    /// assert_eq!(s.rfind(|&: c: char| c.is_whitespace()), Some(12));\n-    ///\n-    /// // searches for an occurrence of either `1` or `2`, but neither are found\n-    /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(s.rfind(x), None);\n-    /// # }\n-    /// ```\n     fn rfind<C: CharEq>(&self, search: C) -> Option<uint>;\n-\n-    /// Returns the byte index of the first matching substring\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * `needle` - The string to search for\n-    ///\n-    /// # Return value\n-    ///\n-    /// `Some` containing the byte index of the first matching substring\n-    /// or `None` if there is no match.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.find_str(\"\u8001\u864e L\"), Some(6));\n-    /// assert_eq!(s.find_str(\"muffin man\"), None);\n-    /// ```\n     fn find_str(&self, &str) -> Option<uint>;\n-\n-    /// Retrieves the first character from a string slice and returns\n-    /// it. This does not allocate a new string; instead, it returns a\n-    /// slice that point one character beyond the character that was\n-    /// shifted. If the string does not contain any characters,\n-    /// None is returned instead.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// let (c, s1) = s.slice_shift_char().unwrap();\n-    /// assert_eq!(c, 'L');\n-    /// assert_eq!(s1, \"\u00f6we \u8001\u864e L\u00e9opard\");\n-    ///\n-    /// let (c, s2) = s1.slice_shift_char().unwrap();\n-    /// assert_eq!(c, '\u00f6');\n-    /// assert_eq!(s2, \"we \u8001\u864e L\u00e9opard\");\n-    /// ```\n     fn slice_shift_char<'a>(&'a self) -> Option<(char, &'a str)>;\n-\n-    /// Returns the byte offset of an inner slice relative to an enclosing outer slice.\n-    ///\n-    /// Panics if `inner` is not a direct slice contained within self.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let string = \"a\\nb\\nc\";\n-    /// let lines: Vec<&str> = string.lines().collect();\n-    ///\n-    /// assert!(string.subslice_offset(lines[0]) == 0); // &\"a\"\n-    /// assert!(string.subslice_offset(lines[1]) == 2); // &\"b\"\n-    /// assert!(string.subslice_offset(lines[2]) == 4); // &\"c\"\n-    /// ```\n     fn subslice_offset(&self, inner: &str) -> uint;\n-\n-    /// Return an unsafe pointer to the strings buffer.\n-    ///\n-    /// The caller must ensure that the string outlives this pointer,\n-    /// and that it is not reallocated (e.g. by pushing to the\n-    /// string).\n     fn as_ptr(&self) -> *const u8;\n-\n-    /// Return an iterator of `u16` over the string encoded as UTF-16.\n-    fn utf16_units<'a>(&'a self) -> Utf16CodeUnits<'a>;\n-\n-    /// Return the number of bytes in this string\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// assert_eq!(\"foo\".len(), 3);\n-    /// assert_eq!(\"\u0192oo\".len(), 4);\n-    /// ```\n-    #[experimental = \"not triaged yet\"]\n     fn len(&self) -> uint;\n-\n-    /// Returns true if this slice contains no bytes\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// assert!(\"\".is_empty());\n-    /// ```\n-    #[inline]\n-    #[experimental = \"not triaged yet\"]\n-    fn is_empty(&self) -> bool { self.len() == 0 }\n+    fn is_empty(&self) -> bool;\n }\n \n #[inline(never)]\n@@ -2001,7 +1211,7 @@ fn slice_error_fail(s: &str, begin: uint, end: uint) -> ! {\n           begin, end, s);\n }\n \n-impl StrPrelude for str {\n+impl StrExt for str {\n     #[inline]\n     fn contains(&self, needle: &str) -> bool {\n         self.find_str(needle).is_some()\n@@ -2021,12 +1231,12 @@ impl StrPrelude for str {\n     fn bytes(&self) -> Bytes {\n         fn deref(&x: &u8) -> u8 { x }\n \n-        self.as_bytes().iter().map(BytesFn(deref))\n+        Bytes { inner: self.as_bytes().iter().map(BytesFn(deref)) }\n     }\n \n     #[inline]\n-    fn char_indices(&self) -> CharOffsets {\n-        CharOffsets{front_offset: 0, iter: self.chars()}\n+    fn char_indices(&self) -> CharIndices {\n+        CharIndices { front_offset: 0, iter: self.chars() }\n     }\n \n     #[inline]\n@@ -2089,18 +1299,19 @@ impl StrPrelude for str {\n     }\n \n     #[inline]\n-    fn lines(&self) -> CharSplits<char> {\n-        self.split_terminator('\\n')\n+    fn lines(&self) -> Lines {\n+        Lines { inner: self.split_terminator('\\n') }\n     }\n \n-    fn lines_any(&self) -> AnyLines {\n+    fn lines_any(&self) -> LinesAny {\n         fn f(line: &str) -> &str {\n             let l = line.len();\n             if l > 0 && line.as_bytes()[l - 1] == b'\\r' { line.slice(0, l - 1) }\n             else { line }\n         }\n \n-        self.lines().map(f)\n+        let f: fn(&str) -> &str = f; // coerce to fn pointer\n+        LinesAny { inner: self.lines().map(f) }\n     }\n \n     #[inline]\n@@ -2353,12 +1564,10 @@ impl StrPrelude for str {\n     }\n \n     #[inline]\n-    fn utf16_units(&self) -> Utf16CodeUnits {\n-        Utf16CodeUnits { encoder: Utf16Encoder::new(self.chars()) }\n-    }\n+    fn len(&self) -> uint { self.repr().len }\n \n     #[inline]\n-    fn len(&self) -> uint { self.repr().len }\n+    fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n #[stable]\n@@ -2367,3 +1576,34 @@ impl<'a> Default for &'a str {\n     fn default() -> &'a str { \"\" }\n }\n \n+impl<'a> Iterator<&'a str> for Lines<'a> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> { self.inner.next() }\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+}\n+impl<'a> DoubleEndedIterator<&'a str> for Lines<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str> { self.inner.next_back() }\n+}\n+impl<'a> Iterator<&'a str> for LinesAny<'a> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> { self.inner.next() }\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+}\n+impl<'a> DoubleEndedIterator<&'a str> for LinesAny<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str> { self.inner.next_back() }\n+}\n+impl<'a> Iterator<u8> for Bytes<'a> {\n+    #[inline]\n+    fn next(&mut self) -> Option<u8> { self.inner.next() }\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+}\n+impl<'a> DoubleEndedIterator<u8> for Bytes<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<u8> { self.inner.next_back() }\n+}\n+impl<'a> ExactSizeIterator<u8> for Bytes<'a> {}"}, {"sha": "a92914c99e35b7b5a83af0619864b772eccb976d", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -69,6 +69,7 @@\n \n use clone::Clone;\n use cmp::*;\n+use cmp::Ordering::*;\n use default::Default;\n use option::Option;\n use option::Option::Some;"}, {"sha": "44029ebb7fa0f95e0121f99e8664230b3aac6d40", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -13,6 +13,7 @@\n extern crate core;\n extern crate test;\n extern crate libc;\n+extern crate unicode;\n \n mod any;\n mod atomic;"}, {"sha": "63d6e14a4a6b88165b72589aa0158a184777fe2b", "filename": "src/libcoretest/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcoretest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibcoretest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fstr.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -117,7 +117,7 @@ fn test_rev_split_char_iterator_no_trailing() {\n \n #[test]\n fn test_utf16_code_units() {\n-    use core::str::Utf16Encoder;\n+    use unicode::str::Utf16Encoder;\n     assert_eq!(Utf16Encoder::new(vec!['\u00e9', '\\U0001F4A9'].into_iter()).collect::<Vec<u16>>(),\n                vec![0xE9, 0xD83D, 0xDCA9])\n }"}, {"sha": "c284fb7c9e338b9e561b49d64eb1ca2eabfde6f8", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -23,7 +23,8 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n-#![feature(macro_rules, globs)]\n+#![feature(macro_rules, globs, slicing_syntax)]\n+\n pub use self::Piece::*;\n pub use self::Position::*;\n pub use self::Alignment::*;\n@@ -136,7 +137,7 @@ pub enum Count<'a> {\n /// necessary there's probably lots of room for improvement performance-wise.\n pub struct Parser<'a> {\n     input: &'a str,\n-    cur: str::CharOffsets<'a>,\n+    cur: str::CharIndices<'a>,\n     /// Error messages accumulated during parsing\n     pub errors: Vec<string::String>,\n }\n@@ -208,13 +209,11 @@ impl<'a> Parser<'a> {\n                 self.cur.next();\n             }\n             Some((_, other)) => {\n-                self.err(format!(\"expected `{}`, found `{}`\",\n-                                 c,\n-                                 other).as_slice());\n+                self.err(format!(\"expected `{}`, found `{}`\", c, other)[]);\n             }\n             None => {\n                 self.err(format!(\"expected `{}` but string was terminated\",\n-                                 c).as_slice());\n+                                 c)[]);\n             }\n         }\n     }\n@@ -237,12 +236,12 @@ impl<'a> Parser<'a> {\n             // we may not consume the character, so clone the iterator\n             match self.cur.clone().next() {\n                 Some((pos, '}')) | Some((pos, '{')) => {\n-                    return self.input.slice(start, pos);\n+                    return self.input[start..pos];\n                 }\n                 Some(..) => { self.cur.next(); }\n                 None => {\n                     self.cur.next();\n-                    return self.input.slice(start, self.input.len());\n+                    return self.input[start..self.input.len()];\n                 }\n             }\n         }\n@@ -282,7 +281,7 @@ impl<'a> Parser<'a> {\n             flags: 0,\n             precision: CountImplied,\n             width: CountImplied,\n-            ty: self.input.slice(0, 0),\n+            ty: self.input[0..0],\n         };\n         if !self.consume(':') { return spec }\n \n@@ -391,7 +390,7 @@ impl<'a> Parser<'a> {\n                 self.cur.next();\n                 pos\n             }\n-            Some(..) | None => { return self.input.slice(0, 0); }\n+            Some(..) | None => { return self.input[0..0]; }\n         };\n         let mut end;\n         loop {\n@@ -403,7 +402,7 @@ impl<'a> Parser<'a> {\n                 None => { end = self.input.len(); break }\n             }\n         }\n-        self.input.slice(start, end)\n+        self.input[start..end]\n     }\n \n     /// Optionally parses an integer at the current position. This doesn't deal"}, {"sha": "0426f269376216340c144e3b255bca04b35ae11a", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 28, "deletions": 33, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -85,7 +85,7 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n-#![feature(globs, phase)]\n+#![feature(globs, phase, slicing_syntax)]\n #![feature(unboxed_closures)]\n #![deny(missing_docs)]\n \n@@ -101,9 +101,8 @@ use self::Whitespace::*;\n use self::LengthLimit::*;\n \n use std::fmt;\n-use std::result::Result::{Err, Ok};\n+use std::iter::repeat;\n use std::result;\n-use std::string::String;\n \n /// Name of an option. Either a string or a single char.\n #[deriving(Clone, PartialEq, Eq)]\n@@ -282,7 +281,7 @@ impl OptGroup {\n \n impl Matches {\n     fn opt_vals(&self, nm: &str) -> Vec<Optval> {\n-        match find_opt(self.opts.as_slice(), Name::from_str(nm)) {\n+        match find_opt(self.opts[], Name::from_str(nm)) {\n             Some(id) => self.vals[id].clone(),\n             None => panic!(\"No option '{}' defined\", nm)\n         }\n@@ -310,8 +309,7 @@ impl Matches {\n     /// Returns true if any of several options were matched.\n     pub fn opts_present(&self, names: &[String]) -> bool {\n         for nm in names.iter() {\n-            match find_opt(self.opts.as_slice(),\n-                           Name::from_str(nm.as_slice())) {\n+            match find_opt(self.opts.as_slice(), Name::from_str(nm[])) {\n                 Some(id) if !self.vals[id].is_empty() => return true,\n                 _ => (),\n             };\n@@ -322,7 +320,7 @@ impl Matches {\n     /// Returns the string argument supplied to one of several matching options or `None`.\n     pub fn opts_str(&self, names: &[String]) -> Option<String> {\n         for nm in names.iter() {\n-            match self.opt_val(nm.as_slice()) {\n+            match self.opt_val(nm[]) {\n                 Some(Val(ref s)) => return Some(s.clone()),\n                 _ => ()\n             }\n@@ -587,7 +585,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n     while i < l {\n         let cur = args[i].clone();\n         let curlen = cur.len();\n-        if !is_arg(cur.as_slice()) {\n+        if !is_arg(cur[]) {\n             free.push(cur);\n         } else if cur == \"--\" {\n             let mut j = i + 1;\n@@ -597,7 +595,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n             let mut names;\n             let mut i_arg = None;\n             if cur.as_bytes()[1] == b'-' {\n-                let tail = cur.slice(2, curlen);\n+                let tail = cur[2..curlen];\n                 let tail_eq: Vec<&str> = tail.split('=').collect();\n                 if tail_eq.len() <= 1 {\n                     names = vec!(Long(tail.to_string()));\n@@ -633,7 +631,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                     };\n \n                     if arg_follows && range.next < curlen {\n-                        i_arg = Some(cur.slice(range.next, curlen).to_string());\n+                        i_arg = Some(cur[range.next..curlen].to_string());\n                         break;\n                     }\n \n@@ -660,7 +658,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                             .push(Val((i_arg.clone())\n                             .unwrap()));\n                     } else if name_pos < names.len() || i + 1 == l ||\n-                            is_arg(args[i + 1].as_slice()) {\n+                            is_arg(args[i + 1][]) {\n                         vals[optid].push(Given);\n                     } else {\n                         i += 1;\n@@ -702,7 +700,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n /// Derive a usage message from a set of long options.\n pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n \n-    let desc_sep = format!(\"\\n{}\", \" \".repeat(24));\n+    let desc_sep = format!(\"\\n{}\", repeat(\" \").take(24).collect::<String>());\n \n     let rows = opts.iter().map(|optref| {\n         let OptGroup{short_name,\n@@ -712,14 +710,14 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n                      hasarg,\n                      ..} = (*optref).clone();\n \n-        let mut row = \" \".repeat(4);\n+        let mut row = repeat(\" \").take(4).collect::<String>();\n \n         // short option\n         match short_name.len() {\n             0 => {}\n             1 => {\n                 row.push('-');\n-                row.push_str(short_name.as_slice());\n+                row.push_str(short_name[]);\n                 row.push(' ');\n             }\n             _ => panic!(\"the short name should only be 1 ascii char long\"),\n@@ -730,31 +728,31 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n             0 => {}\n             _ => {\n                 row.push_str(\"--\");\n-                row.push_str(long_name.as_slice());\n+                row.push_str(long_name[]);\n                 row.push(' ');\n             }\n         }\n \n         // arg\n         match hasarg {\n             No => {}\n-            Yes => row.push_str(hint.as_slice()),\n+            Yes => row.push_str(hint[]),\n             Maybe => {\n                 row.push('[');\n-                row.push_str(hint.as_slice());\n+                row.push_str(hint[]);\n                 row.push(']');\n             }\n         }\n \n         // FIXME: #5516 should be graphemes not codepoints\n         // here we just need to indent the start of the description\n-        let rowlen = row.char_len();\n+        let rowlen = row.chars().count();\n         if rowlen < 24 {\n             for _ in range(0, 24 - rowlen) {\n                 row.push(' ');\n             }\n         } else {\n-            row.push_str(desc_sep.as_slice())\n+            row.push_str(desc_sep[]);\n         }\n \n         // Normalize desc to contain words separated by one space character\n@@ -766,16 +764,14 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n \n         // FIXME: #5516 should be graphemes not codepoints\n         let mut desc_rows = Vec::new();\n-        each_split_within(desc_normalized_whitespace.as_slice(),\n-                          54,\n-                          |substr| {\n+        each_split_within(desc_normalized_whitespace[], 54, |substr| {\n             desc_rows.push(substr.to_string());\n             true\n         });\n \n         // FIXME: #5516 should be graphemes not codepoints\n         // wrapped description\n-        row.push_str(desc_rows.connect(desc_sep.as_slice()).as_slice());\n+        row.push_str(desc_rows.connect(desc_sep[])[]);\n \n         row\n     });\n@@ -794,18 +790,18 @@ fn format_option(opt: &OptGroup) -> String {\n     // Use short_name is possible, but fallback to long_name.\n     if opt.short_name.len() > 0 {\n         line.push('-');\n-        line.push_str(opt.short_name.as_slice());\n+        line.push_str(opt.short_name[]);\n     } else {\n         line.push_str(\"--\");\n-        line.push_str(opt.long_name.as_slice());\n+        line.push_str(opt.long_name[]);\n     }\n \n     if opt.hasarg != No {\n         line.push(' ');\n         if opt.hasarg == Maybe {\n             line.push('[');\n         }\n-        line.push_str(opt.hint.as_slice());\n+        line.push_str(opt.hint[]);\n         if opt.hasarg == Maybe {\n             line.push(']');\n         }\n@@ -827,8 +823,7 @@ pub fn short_usage(program_name: &str, opts: &[OptGroup]) -> String {\n     line.push_str(opts.iter()\n                       .map(format_option)\n                       .collect::<Vec<String>>()\n-                      .connect(\" \")\n-                      .as_slice());\n+                      .connect(\" \")[]);\n     line\n }\n \n@@ -891,9 +886,9 @@ fn each_split_within<F>(ss: &str, lim: uint, mut it: F) -> bool where\n             (B, Cr, UnderLim) => { B }\n             (B, Cr, OverLim)  if (i - last_start + 1) > lim\n                             => panic!(\"word starting with {} longer than limit!\",\n-                                    ss.slice(last_start, i + 1)),\n+                                    ss[last_start..i + 1]),\n             (B, Cr, OverLim)  => {\n-                *cont = it(ss.slice(slice_start, last_end));\n+                *cont = it(ss[slice_start..last_end]);\n                 slice_start = last_start;\n                 B\n             }\n@@ -903,7 +898,7 @@ fn each_split_within<F>(ss: &str, lim: uint, mut it: F) -> bool where\n             }\n             (B, Ws, OverLim)  => {\n                 last_end = i;\n-                *cont = it(ss.slice(slice_start, last_end));\n+                *cont = it(ss[slice_start..last_end]);\n                 A\n             }\n \n@@ -912,14 +907,14 @@ fn each_split_within<F>(ss: &str, lim: uint, mut it: F) -> bool where\n                 B\n             }\n             (C, Cr, OverLim)  => {\n-                *cont = it(ss.slice(slice_start, last_end));\n+                *cont = it(ss[slice_start..last_end]);\n                 slice_start = i;\n                 last_start = i;\n                 last_end = i;\n                 B\n             }\n             (C, Ws, OverLim)  => {\n-                *cont = it(ss.slice(slice_start, last_end));\n+                *cont = it(ss[slice_start..last_end]);\n                 A\n             }\n             (C, Ws, UnderLim) => {"}, {"sha": "ce3df1090bd58c756f1336604d2a1bca0930e577", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -448,8 +448,8 @@ impl<'a> LabelText<'a> {\n     /// Renders text as string suitable for a label in a .dot file.\n     pub fn escape(&self) -> String {\n         match self {\n-            &LabelStr(ref s) => (&**s).escape_default(),\n-            &EscStr(ref s) => LabelText::escape_str(s.as_slice()),\n+            &LabelStr(ref s) => s.escape_default(),\n+            &EscStr(ref s) => LabelText::escape_str(s[]),\n         }\n     }\n \n@@ -475,10 +475,10 @@ impl<'a> LabelText<'a> {\n \n     /// Puts `suffix` on a line below this label, with a blank line separator.\n     pub fn suffix_line(self, suffix: LabelText) -> LabelText<'static> {\n-        let mut prefix = self.pre_escaped_content().into_string();\n+        let mut prefix = self.pre_escaped_content().into_owned();\n         let suffix = suffix.pre_escaped_content();\n         prefix.push_str(r\"\\n\\n\");\n-        prefix.push_str(suffix.as_slice());\n+        prefix.push_str(suffix[]);\n         EscStr(prefix.into_cow())\n     }\n }\n@@ -671,7 +671,7 @@ mod tests {\n \n     impl<'a> Labeller<'a, Node, &'a Edge> for LabelledGraph {\n         fn graph_id(&'a self) -> Id<'a> {\n-            Id::new(self.name.as_slice()).unwrap()\n+            Id::new(self.name[]).unwrap()\n         }\n         fn node_id(&'a self, n: &Node) -> Id<'a> {\n             id_name(n)\n@@ -735,7 +735,7 @@ mod tests {\n     fn test_input(g: LabelledGraph) -> IoResult<String> {\n         let mut writer = Vec::new();\n         render(&g, &mut writer).unwrap();\n-        (&mut writer.as_slice()).read_to_string()\n+        (&mut writer[]).read_to_string()\n     }\n \n     // All of the tests use raw-strings as the format for the expected outputs,\n@@ -847,7 +847,7 @@ r#\"digraph hasse_diagram {\n                  edge(1, 3, \";\"),    edge(2, 3, \";\"   )));\n \n         render(&g, &mut writer).unwrap();\n-        let r = (&mut writer.as_slice()).read_to_string();\n+        let r = (&mut writer[]).read_to_string();\n \n         assert_eq!(r.unwrap(),\n r#\"digraph syntax_tree {"}, {"sha": "88483b6c935435dc440afb03026c995fb4743af0", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -63,7 +63,7 @@ impl<'a,T> IntoMaybeOwnedVector<'a,T> for &'a [T] {\n }\n \n impl<'a,T> MaybeOwnedVector<'a,T> {\n-    pub fn iter(&'a self) -> slice::Items<'a,T> {\n+    pub fn iter(&'a self) -> slice::Iter<'a,T> {\n         match self {\n             &Growable(ref v) => v.as_slice().iter(),\n             &Borrowed(ref v) => v.iter(),"}, {"sha": "2b25a64affee313ad36a9904e5818ae49e423826", "filename": "src/liblog/directive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Fliblog%2Fdirective.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Fliblog%2Fdirective.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fdirective.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -23,7 +23,7 @@ pub static LOG_LEVEL_NAMES: [&'static str, ..4] = [\"ERROR\", \"WARN\", \"INFO\",\n \n /// Parse an individual log level that is either a number or a symbolic log level\n fn parse_log_level(level: &str) -> Option<u32> {\n-    from_str::<u32>(level).or_else(|| {\n+    level.parse::<u32>().or_else(|| {\n         let pos = LOG_LEVEL_NAMES.iter().position(|&name| name.eq_ignore_ascii_case(level));\n         pos.map(|p| p as u32 + 1)\n     }).map(|p| cmp::min(p, ::MAX_LOG_LEVEL))"}, {"sha": "97301628a4512aa6f65cf37740e2bde2b1c5046b", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -164,7 +164,7 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n-#![feature(macro_rules, unboxed_closures)]\n+#![feature(macro_rules, unboxed_closures, slicing_syntax)]\n #![deny(missing_docs)]\n \n extern crate regex;\n@@ -280,7 +280,7 @@ pub fn log(level: u32, loc: &'static LogLocation, args: &fmt::Arguments) {\n     // Test the literal string from args against the current filter, if there\n     // is one.\n     match unsafe { FILTER.as_ref() } {\n-        Some(filter) if !filter.is_match(args.to_string().as_slice()) => return,\n+        Some(filter) if !filter.is_match(args.to_string()[]) => return,\n         _ => {}\n     }\n \n@@ -370,12 +370,12 @@ pub fn mod_enabled(level: u32, module: &str) -> bool {\n \n fn enabled(level: u32,\n            module: &str,\n-           iter: slice::Items<directive::LogDirective>)\n+           iter: slice::Iter<directive::LogDirective>)\n            -> bool {\n     // Search for the longest match, the vector is assumed to be pre-sorted.\n     for directive in iter.rev() {\n         match directive.name {\n-            Some(ref name) if !module.starts_with(name.as_slice()) => {},\n+            Some(ref name) if !module.starts_with(name[]) => {},\n             Some(..) | None => {\n                 return level <= directive.level\n             }\n@@ -390,7 +390,7 @@ fn enabled(level: u32,\n /// `Once` primitive (and this function is called from that primitive).\n fn init() {\n     let (mut directives, filter) = match os::getenv(\"RUST_LOG\") {\n-        Some(spec) => directive::parse_logging_spec(spec.as_slice()),\n+        Some(spec) => directive::parse_logging_spec(spec[]),\n         None => (Vec::new(), None),\n     };\n "}, {"sha": "0cd8df73c37ce6af7718692bd9df7e19a2d8a056", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 27, "deletions": 30, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -286,7 +286,7 @@ impl<'a> Parser<'a> {\n             true => Ok(()),\n             false => {\n                 self.err(format!(\"Expected {} but got EOF.\",\n-                                 expected).as_slice())\n+                                 expected)[])\n             }\n         }\n     }\n@@ -295,10 +295,10 @@ impl<'a> Parser<'a> {\n         match self.next_char() {\n             true if self.cur() == expected => Ok(()),\n             true => self.err(format!(\"Expected '{}' but got '{}'.\",\n-                                     expected, self.cur()).as_slice()),\n+                                     expected, self.cur())[]),\n             false => {\n                 self.err(format!(\"Expected '{}' but got EOF.\",\n-                                 expected).as_slice())\n+                                 expected)[])\n             }\n         }\n     }\n@@ -443,14 +443,14 @@ impl<'a> Parser<'a> {\n                         Literal(c3, _) => c2 = c3, // allow literal escapes below\n                         ast =>\n                             return self.err(format!(\"Expected a literal, but got {}.\",\n-                                                    ast).as_slice()),\n+                                                    ast)[]),\n                     }\n                 }\n                 if c2 < c {\n                     return self.err(format!(\"Invalid character class \\\n                                              range '{}-{}'\",\n                                             c,\n-                                            c2).as_slice())\n+                                            c2)[])\n                 }\n                 ranges.push((c, self.cur()))\n             } else {\n@@ -488,7 +488,7 @@ impl<'a> Parser<'a> {\n                 FLAG_EMPTY\n             };\n         let name = self.slice(name_start, closer - 1);\n-        match find_class(ASCII_CLASSES, name.as_slice()) {\n+        match find_class(ASCII_CLASSES, name[]) {\n             None => None,\n             Some(ranges) => {\n                 self.chari = closer;\n@@ -513,7 +513,7 @@ impl<'a> Parser<'a> {\n                     return self.err(format!(\"No closing brace for counted \\\n                                              repetition starting at position \\\n                                              {}.\",\n-                                            start).as_slice())\n+                                            start)[])\n                 }\n             };\n         self.chari = closer;\n@@ -524,7 +524,7 @@ impl<'a> Parser<'a> {\n         // Parse the min and max values from the regex.\n         let (mut min, mut max): (uint, Option<uint>);\n         if !inner.contains(\",\") {\n-            min = try!(self.parse_uint(inner.as_slice()));\n+            min = try!(self.parse_uint(inner[]));\n             max = Some(min);\n         } else {\n             let pieces: Vec<&str> = inner.splitn(1, ',').collect();\n@@ -546,19 +546,19 @@ impl<'a> Parser<'a> {\n         if min > MAX_REPEAT {\n             return self.err(format!(\n                 \"{} exceeds maximum allowed repetitions ({})\",\n-                min, MAX_REPEAT).as_slice());\n+                min, MAX_REPEAT)[]);\n         }\n         if max.is_some() {\n             let m = max.unwrap();\n             if m > MAX_REPEAT {\n                 return self.err(format!(\n                     \"{} exceeds maximum allowed repetitions ({})\",\n-                    m, MAX_REPEAT).as_slice());\n+                    m, MAX_REPEAT)[]);\n             }\n             if m < min {\n                 return self.err(format!(\n                     \"Max repetitions ({}) cannot be smaller than min \\\n-                     repetitions ({}).\", m, min).as_slice());\n+                     repetitions ({}).\", m, min)[]);\n             }\n         }\n \n@@ -622,8 +622,7 @@ impl<'a> Parser<'a> {\n                 Ok(AstClass(ranges, flags))\n             }\n             _ => {\n-                self.err(format!(\"Invalid escape sequence '\\\\\\\\{}'\",\n-                                 c).as_slice())\n+                self.err(format!(\"Invalid escape sequence '\\\\\\\\{}'\", c)[])\n             }\n         }\n     }\n@@ -643,7 +642,7 @@ impl<'a> Parser<'a> {\n                     Some(i) => i,\n                     None => return self.err(format!(\n                         \"Missing '}}' for unclosed '{{' at position {}\",\n-                        self.chari).as_slice()),\n+                        self.chari)[]),\n                 };\n             if closer - self.chari + 1 == 0 {\n                 return self.err(\"No Unicode class name found.\")\n@@ -657,10 +656,10 @@ impl<'a> Parser<'a> {\n             name = self.slice(self.chari + 1, self.chari + 2);\n             self.chari += 1;\n         }\n-        match find_class(UNICODE_CLASSES, name.as_slice()) {\n+        match find_class(UNICODE_CLASSES, name[]) {\n             None => {\n                 return self.err(format!(\"Could not find Unicode class '{}'\",\n-                                        name).as_slice())\n+                                        name)[])\n             }\n             Some(ranges) => {\n                 Ok(AstClass(ranges, negated | (self.flags & FLAG_NOCASE)))\n@@ -683,11 +682,11 @@ impl<'a> Parser<'a> {\n             }\n         }\n         let s = self.slice(start, end);\n-        match num::from_str_radix::<u32>(s.as_slice(), 8) {\n+        match num::from_str_radix::<u32>(s[], 8) {\n             Some(n) => Ok(Literal(try!(self.char_from_u32(n)), FLAG_EMPTY)),\n             None => {\n                 self.err(format!(\"Could not parse '{}' as octal number.\",\n-                                 s).as_slice())\n+                                 s)[])\n             }\n         }\n     }\n@@ -705,12 +704,12 @@ impl<'a> Parser<'a> {\n                 None => {\n                     return self.err(format!(\"Missing '}}' for unclosed \\\n                                              '{{' at position {}\",\n-                                            start).as_slice())\n+                                            start)[])\n                 }\n                 Some(i) => i,\n             };\n         self.chari = closer;\n-        self.parse_hex_digits(self.slice(start, closer).as_slice())\n+        self.parse_hex_digits(self.slice(start, closer)[])\n     }\n \n     // Parses a two-digit hex number.\n@@ -730,8 +729,7 @@ impl<'a> Parser<'a> {\n         match num::from_str_radix::<u32>(s, 16) {\n             Some(n) => Ok(Literal(try!(self.char_from_u32(n)), FLAG_EMPTY)),\n             None => {\n-                self.err(format!(\"Could not parse '{}' as hex number.\",\n-                                 s).as_slice())\n+                self.err(format!(\"Could not parse '{}' as hex number.\", s)[])\n             }\n         }\n     }\n@@ -757,7 +755,7 @@ impl<'a> Parser<'a> {\n         }\n         if self.names.contains(&name) {\n             return self.err(format!(\"Duplicate capture group name '{}'.\",\n-                                    name).as_slice())\n+                                    name)[])\n         }\n         self.names.push(name.clone());\n         self.chari = closer;\n@@ -791,7 +789,7 @@ impl<'a> Parser<'a> {\n                     if sign < 0 {\n                         return self.err(format!(\n                             \"Cannot negate flags twice in '{}'.\",\n-                            self.slice(start, self.chari + 1)).as_slice())\n+                            self.slice(start, self.chari + 1))[])\n                     }\n                     sign = -1;\n                     saw_flag = false;\n@@ -802,7 +800,7 @@ impl<'a> Parser<'a> {\n                         if !saw_flag {\n                             return self.err(format!(\n                                 \"A valid flag does not follow negation in '{}'\",\n-                                self.slice(start, self.chari + 1)).as_slice())\n+                                self.slice(start, self.chari + 1))[])\n                         }\n                         flags = flags ^ flags;\n                     }\n@@ -814,7 +812,7 @@ impl<'a> Parser<'a> {\n                     return Ok(())\n                 }\n                 _ => return self.err(format!(\n-                    \"Unrecognized flag '{}'.\", self.cur()).as_slice()),\n+                    \"Unrecognized flag '{}'.\", self.cur())[]),\n             }\n         }\n     }\n@@ -908,11 +906,11 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_uint(&self, s: &str) -> Result<uint, Error> {\n-        match from_str::<uint>(s) {\n+        match s.parse::<uint>() {\n             Some(i) => Ok(i),\n             None => {\n                 self.err(format!(\"Expected an unsigned integer but got '{}'.\",\n-                                 s).as_slice())\n+                                 s)[])\n             }\n         }\n     }\n@@ -922,8 +920,7 @@ impl<'a> Parser<'a> {\n             Some(c) => Ok(c),\n             None => {\n                 self.err(format!(\"Could not decode '{}' to unicode \\\n-                                  character.\",\n-                                 n).as_slice())\n+                                  character.\", n)[])\n             }\n         }\n     }"}, {"sha": "4383192edafb05485f4984190b8ee7c6c17edaf9", "filename": "src/libregex/re.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -417,7 +417,7 @@ impl Regex {\n     /// # extern crate regex; #[phase(plugin)] extern crate regex_macros;\n     /// # fn main() {\n     /// let re = regex!(\"[^01]+\");\n-    /// assert_eq!(re.replace(\"1078910\", \"\").as_slice(), \"1010\");\n+    /// assert_eq!(re.replace(\"1078910\", \"\"), \"1010\");\n     /// # }\n     /// ```\n     ///\n@@ -435,7 +435,7 @@ impl Regex {\n     /// let result = re.replace(\"Springsteen, Bruce\", |&: caps: &Captures| {\n     ///     format!(\"{} {}\", caps.at(2).unwrap_or(\"\"), caps.at(1).unwrap_or(\"\"))\n     /// });\n-    /// assert_eq!(result.as_slice(), \"Bruce Springsteen\");\n+    /// assert_eq!(result, \"Bruce Springsteen\");\n     /// # }\n     /// ```\n     ///\n@@ -450,7 +450,7 @@ impl Regex {\n     /// # fn main() {\n     /// let re = regex!(r\"(?P<last>[^,\\s]+),\\s+(?P<first>\\S+)\");\n     /// let result = re.replace(\"Springsteen, Bruce\", \"$first $last\");\n-    /// assert_eq!(result.as_slice(), \"Bruce Springsteen\");\n+    /// assert_eq!(result, \"Bruce Springsteen\");\n     /// # }\n     /// ```\n     ///\n@@ -469,7 +469,7 @@ impl Regex {\n     ///\n     /// let re = regex!(r\"(?P<last>[^,\\s]+),\\s+(\\S+)\");\n     /// let result = re.replace(\"Springsteen, Bruce\", NoExpand(\"$2 $last\"));\n-    /// assert_eq!(result.as_slice(), \"$2 $last\");\n+    /// assert_eq!(result, \"$2 $last\");\n     /// # }\n     /// ```\n     pub fn replace<R: Replacer>(&self, text: &str, rep: R) -> String {\n@@ -505,19 +505,19 @@ impl Regex {\n             }\n \n             let (s, e) = cap.pos(0).unwrap(); // captures only reports matches\n-            new.push_str(text.slice(last_match, s));\n-            new.push_str(rep.reg_replace(&cap).as_slice());\n+            new.push_str(text[last_match..s]);\n+            new.push_str(rep.reg_replace(&cap)[]);\n             last_match = e;\n         }\n-        new.push_str(text.slice(last_match, text.len()));\n+        new.push_str(text[last_match..text.len()]);\n         return new;\n     }\n \n     /// Returns the original string of this regex.\n     pub fn as_str<'a>(&'a self) -> &'a str {\n         match *self {\n-            Dynamic(ExDynamic { ref original, .. }) => original.as_slice(),\n-            Native(ExNative { ref original, .. }) => original.as_slice(),\n+            Dynamic(ExDynamic { ref original, .. }) => original[],\n+            Native(ExNative { ref original, .. }) => original[],\n         }\n     }\n \n@@ -540,8 +540,8 @@ impl Regex {\n }\n \n pub enum NamesIter<'a> {\n-    NamesIterNative(::std::slice::Items<'a, Option<&'static str>>),\n-    NamesIterDynamic(::std::slice::Items<'a, Option<String>>)\n+    NamesIterNative(::std::slice::Iter<'a, Option<&'static str>>),\n+    NamesIterDynamic(::std::slice::Iter<'a, Option<String>>)\n }\n \n impl<'a> Iterator<Option<String>> for NamesIter<'a> {\n@@ -608,13 +608,13 @@ impl<'r, 't> Iterator<&'t str> for RegexSplits<'r, 't> {\n                 if self.last >= text.len() {\n                     None\n                 } else {\n-                    let s = text.slice(self.last, text.len());\n+                    let s = text[self.last..text.len()];\n                     self.last = text.len();\n                     Some(s)\n                 }\n             }\n             Some((s, e)) => {\n-                let matched = text.slice(self.last, s);\n+                let matched = text[self.last..s];\n                 self.last = e;\n                 Some(matched)\n             }\n@@ -642,7 +642,7 @@ impl<'r, 't> Iterator<&'t str> for RegexSplitsN<'r, 't> {\n         } else {\n             self.cur += 1;\n             if self.cur >= self.limit {\n-                Some(text.slice(self.splits.last, text.len()))\n+                Some(text[self.splits.last..text.len()])\n             } else {\n                 self.splits.next()\n             }\n@@ -769,13 +769,13 @@ impl<'t> Captures<'t> {\n             let pre = refs.at(1).unwrap_or(\"\");\n             let name = refs.at(2).unwrap_or(\"\");\n             format!(\"{}{}\", pre,\n-                    match from_str::<uint>(name.as_slice()) {\n+                    match name.parse::<uint>() {\n                 None => self.name(name).unwrap_or(\"\").to_string(),\n                 Some(i) => self.at(i).unwrap_or(\"\").to_string(),\n             })\n         });\n         let re = Regex::new(r\"\\$\\$\").unwrap();\n-        re.replace_all(text.as_slice(), NoExpand(\"$\"))\n+        re.replace_all(text[], NoExpand(\"$\"))\n     }\n \n     /// Returns the number of captured groups."}, {"sha": "4647c92e3d1e8a09e25d7e8098acaf593a63f027", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -40,6 +40,8 @@ extern crate collections;\n #[phase(plugin, link)] extern crate log;\n #[phase(plugin, link)] extern crate syntax;\n \n+extern crate \"serialize\" as rustc_serialize; // used by deriving\n+\n #[cfg(test)]\n extern crate test;\n \n@@ -115,6 +117,7 @@ pub mod util {\n     pub mod ppaux;\n     pub mod nodemap;\n     pub mod snapshot_vec;\n+    pub mod lev_distance;\n }\n \n pub mod lib {"}, {"sha": "0fd69ea25bc0d1361edec3b515047fa2ee3a3294", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -250,10 +250,12 @@ impl LintPass for TypeLimits {\n                         let (min, max) = float_ty_range(t);\n                         let lit_val: f64 = match lit.node {\n                             ast::LitFloat(ref v, _) |\n-                            ast::LitFloatUnsuffixed(ref v) => match from_str(v.get()) {\n-                                Some(f) => f,\n-                                None => return\n-                            },\n+                            ast::LitFloatUnsuffixed(ref v) => {\n+                                match v.parse() {\n+                                    Some(f) => f,\n+                                    None => return\n+                                }\n+                            }\n                             _ => panic!()\n                         };\n                         if lit_val < min || lit_val > max {\n@@ -507,7 +509,7 @@ impl BoxPointers {\n         if n_uniq > 0 {\n             let s = ty_to_string(cx.tcx, ty);\n             let m = format!(\"type uses owned (Box type) pointers: {}\", s);\n-            cx.span_lint(BOX_POINTERS, span, m.as_slice());\n+            cx.span_lint(BOX_POINTERS, span, m[]);\n         }\n     }\n }\n@@ -587,7 +589,7 @@ impl LintPass for RawPointerDeriving {\n     }\n \n     fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n-        if !attr::contains_name(item.attrs.as_slice(), \"automatically_derived\") {\n+        if !attr::contains_name(item.attrs[], \"automatically_derived\") {\n             return\n         }\n         let did = match item.node {\n@@ -766,11 +768,11 @@ impl LintPass for UnusedResults {\n             ty::ty_enum(did, _) => {\n                 if ast_util::is_local(did) {\n                     if let ast_map::NodeItem(it) = cx.tcx.map.get(did.node) {\n-                        warned |= check_must_use(cx, it.attrs.as_slice(), s.span);\n+                        warned |= check_must_use(cx, it.attrs[], s.span);\n                     }\n                 } else {\n                     csearch::get_item_attrs(&cx.sess().cstore, did, |attrs| {\n-                        warned |= check_must_use(cx, attrs.as_slice(), s.span);\n+                        warned |= check_must_use(cx, attrs[], s.span);\n                     });\n                 }\n             }\n@@ -792,7 +794,7 @@ impl LintPass for UnusedResults {\n                             msg.push_str(s.get());\n                         }\n                     }\n-                    cx.span_lint(UNUSED_MUST_USE, sp, msg.as_slice());\n+                    cx.span_lint(UNUSED_MUST_USE, sp, msg[]);\n                     return true;\n                 }\n             }\n@@ -838,7 +840,7 @@ impl NonCamelCaseTypes {\n             } else {\n                 format!(\"{} `{}` should have a camel case name such as `{}`\", sort, s, c)\n             };\n-            cx.span_lint(NON_CAMEL_CASE_TYPES, span, m.as_slice());\n+            cx.span_lint(NON_CAMEL_CASE_TYPES, span, m[]);\n         }\n     }\n }\n@@ -978,7 +980,7 @@ impl NonSnakeCase {\n         if !is_snake_case(ident) {\n             cx.span_lint(NON_SNAKE_CASE, span,\n                 format!(\"{} `{}` should have a snake case name such as `{}`\",\n-                        sort, s, to_snake_case(s.get())).as_slice());\n+                        sort, s, to_snake_case(s.get()))[]);\n         }\n     }\n }\n@@ -1065,7 +1067,7 @@ impl LintPass for NonUpperCaseGlobals {\n                         format!(\"static constant `{}` should have an uppercase name \\\n                                  such as `{}`\",\n                                 s.get(), s.get().chars().map(|c| c.to_uppercase())\n-                                .collect::<String>().as_slice()).as_slice());\n+                                .collect::<String>()[])[]);\n                 }\n             }\n             _ => {}\n@@ -1082,7 +1084,7 @@ impl LintPass for NonUpperCaseGlobals {\n                         format!(\"static constant in pattern `{}` should have an uppercase \\\n                                  name such as `{}`\",\n                                 s.get(), s.get().chars().map(|c| c.to_uppercase())\n-                                    .collect::<String>().as_slice()).as_slice());\n+                                    .collect::<String>()[])[]);\n                 }\n             }\n             _ => {}\n@@ -1107,7 +1109,7 @@ impl UnusedParens {\n             if !necessary {\n                 cx.span_lint(UNUSED_PARENS, value.span,\n                              format!(\"unnecessary parentheses around {}\",\n-                                     msg).as_slice())\n+                                     msg)[])\n             }\n         }\n \n@@ -1209,7 +1211,7 @@ impl LintPass for UnusedImportBraces {\n                                     let m = format!(\"braces around {} is unnecessary\",\n                                                     token::get_ident(*name).get());\n                                     cx.span_lint(UNUSED_IMPORT_BRACES, view_item.span,\n-                                                 m.as_slice());\n+                                                 m[]);\n                                 },\n                                 _ => ()\n                             }\n@@ -1248,7 +1250,7 @@ impl LintPass for NonShorthandFieldPatterns {\n                     if ident.node.as_str() == fieldpat.node.ident.as_str() {\n                         cx.span_lint(NON_SHORTHAND_FIELD_PATTERNS, fieldpat.span,\n                                      format!(\"the `{}:` in this pattern is redundant and can \\\n-                                              be removed\", ident.node.as_str()).as_slice())\n+                                              be removed\", ident.node.as_str())[])\n                     }\n                 }\n             }\n@@ -1352,7 +1354,7 @@ impl LintPass for UnusedMut {\n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         if let ast::ExprMatch(_, ref arms, _) = e.node {\n             for a in arms.iter() {\n-                self.check_unused_mut_pat(cx, a.pats.as_slice())\n+                self.check_unused_mut_pat(cx, a.pats[])\n             }\n         }\n     }\n@@ -1473,7 +1475,7 @@ impl MissingDoc {\n         });\n         if !has_doc {\n             cx.span_lint(MISSING_DOCS, sp,\n-                format!(\"missing documentation for {}\", desc).as_slice());\n+                format!(\"missing documentation for {}\", desc)[]);\n         }\n     }\n }\n@@ -1487,7 +1489,7 @@ impl LintPass for MissingDoc {\n         let doc_hidden = self.doc_hidden() || attrs.iter().any(|attr| {\n             attr.check_name(\"doc\") && match attr.meta_item_list() {\n                 None => false,\n-                Some(l) => attr::contains_name(l.as_slice(), \"hidden\"),\n+                Some(l) => attr::contains_name(l[], \"hidden\"),\n             }\n         });\n         self.doc_hidden_stack.push(doc_hidden);\n@@ -1509,7 +1511,7 @@ impl LintPass for MissingDoc {\n     }\n \n     fn check_crate(&mut self, cx: &Context, krate: &ast::Crate) {\n-        self.check_missing_docs_attrs(cx, None, krate.attrs.as_slice(),\n+        self.check_missing_docs_attrs(cx, None, krate.attrs[],\n                                      krate.span, \"crate\");\n     }\n \n@@ -1523,7 +1525,7 @@ impl LintPass for MissingDoc {\n             ast::ItemTy(..) => \"a type alias\",\n             _ => return\n         };\n-        self.check_missing_docs_attrs(cx, Some(it.id), it.attrs.as_slice(),\n+        self.check_missing_docs_attrs(cx, Some(it.id), it.attrs[],\n                                      it.span, desc);\n     }\n \n@@ -1536,13 +1538,13 @@ impl LintPass for MissingDoc {\n \n             // Otherwise, doc according to privacy. This will also check\n             // doc for default methods defined on traits.\n-            self.check_missing_docs_attrs(cx, Some(m.id), m.attrs.as_slice(),\n+            self.check_missing_docs_attrs(cx, Some(m.id), m.attrs[],\n                                           m.span, \"a method\");\n         }\n     }\n \n     fn check_ty_method(&mut self, cx: &Context, tm: &ast::TypeMethod) {\n-        self.check_missing_docs_attrs(cx, Some(tm.id), tm.attrs.as_slice(),\n+        self.check_missing_docs_attrs(cx, Some(tm.id), tm.attrs[],\n                                      tm.span, \"a type method\");\n     }\n \n@@ -1552,14 +1554,14 @@ impl LintPass for MissingDoc {\n                 let cur_struct_def = *self.struct_def_stack.last()\n                     .expect(\"empty struct_def_stack\");\n                 self.check_missing_docs_attrs(cx, Some(cur_struct_def),\n-                                              sf.node.attrs.as_slice(), sf.span,\n+                                              sf.node.attrs[], sf.span,\n                                               \"a struct field\")\n             }\n         }\n     }\n \n     fn check_variant(&mut self, cx: &Context, v: &ast::Variant, _: &ast::Generics) {\n-        self.check_missing_docs_attrs(cx, Some(v.node.id), v.node.attrs.as_slice(),\n+        self.check_missing_docs_attrs(cx, Some(v.node.id), v.node.attrs[],\n                                      v.span, \"a variant\");\n         assert!(!self.in_variant);\n         self.in_variant = true;\n@@ -1675,7 +1677,7 @@ impl Stability {\n             _ => format!(\"use of {} item\", label)\n         };\n \n-        cx.span_lint(lint, span, msg.as_slice());\n+        cx.span_lint(lint, span, msg[]);\n     }\n \n     fn is_internal(&self, cx: &Context, span: Span) -> bool {"}, {"sha": "ffae485364a8625bbc9d3d22cffda256b3aac743", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -104,7 +104,7 @@ impl LintStore {\n     }\n \n     pub fn get_lints<'t>(&'t self) -> &'t [(&'static Lint, bool)] {\n-        self.lints.as_slice()\n+        self.lints[]\n     }\n \n     pub fn get_lint_groups<'t>(&'t self) -> Vec<(&'static str, Vec<LintId>, bool)> {\n@@ -124,11 +124,11 @@ impl LintStore {\n                 match (sess, from_plugin) {\n                     // We load builtin lints first, so a duplicate is a compiler bug.\n                     // Use early_error when handling -W help with no crate.\n-                    (None, _) => early_error(msg.as_slice()),\n-                    (Some(sess), false) => sess.bug(msg.as_slice()),\n+                    (None, _) => early_error(msg[]),\n+                    (Some(sess), false) => sess.bug(msg[]),\n \n                     // A duplicate name from a plugin is a user error.\n-                    (Some(sess), true)  => sess.err(msg.as_slice()),\n+                    (Some(sess), true)  => sess.err(msg[]),\n                 }\n             }\n \n@@ -149,11 +149,11 @@ impl LintStore {\n             match (sess, from_plugin) {\n                 // We load builtin lints first, so a duplicate is a compiler bug.\n                 // Use early_error when handling -W help with no crate.\n-                (None, _) => early_error(msg.as_slice()),\n-                (Some(sess), false) => sess.bug(msg.as_slice()),\n+                (None, _) => early_error(msg[]),\n+                (Some(sess), false) => sess.bug(msg[]),\n \n                 // A duplicate name from a plugin is a user error.\n-                (Some(sess), true)  => sess.err(msg.as_slice()),\n+                (Some(sess), true)  => sess.err(msg[]),\n             }\n         }\n     }\n@@ -260,8 +260,8 @@ impl LintStore {\n                 let warning = format!(\"lint {} has been renamed to {}\",\n                                       lint_name, new_name);\n                 match span {\n-                    Some(span) => sess.span_warn(span, warning.as_slice()),\n-                    None => sess.warn(warning.as_slice()),\n+                    Some(span) => sess.span_warn(span, warning[]),\n+                    None => sess.warn(warning[]),\n                 };\n                 Some(lint_id)\n             }\n@@ -271,21 +271,21 @@ impl LintStore {\n \n     pub fn process_command_line(&mut self, sess: &Session) {\n         for &(ref lint_name, level) in sess.opts.lint_opts.iter() {\n-            match self.find_lint(lint_name.as_slice(), sess, None) {\n+            match self.find_lint(lint_name[], sess, None) {\n                 Some(lint_id) => self.set_level(lint_id, (level, CommandLine)),\n                 None => {\n                     match self.lint_groups.iter().map(|(&x, pair)| (x, pair.0.clone()))\n                                                  .collect::<FnvHashMap<&'static str,\n                                                                        Vec<LintId>>>()\n-                                                 .get(lint_name.as_slice()) {\n+                                                 .get(lint_name[]) {\n                         Some(v) => {\n                             v.iter()\n                              .map(|lint_id: &LintId|\n                                      self.set_level(*lint_id, (level, CommandLine)))\n                              .collect::<Vec<()>>();\n                         }\n                         None => sess.err(format!(\"unknown {} flag: {}\",\n-                                                 level.as_str(), lint_name).as_slice()),\n+                                                 level.as_str(), lint_name)[]),\n                     }\n                 }\n             }\n@@ -396,10 +396,10 @@ pub fn raw_emit_lint(sess: &Session, lint: &'static Lint,\n     if level == Forbid { level = Deny; }\n \n     match (level, span) {\n-        (Warn, Some(sp)) => sess.span_warn(sp, msg.as_slice()),\n-        (Warn, None)     => sess.warn(msg.as_slice()),\n-        (Deny, Some(sp)) => sess.span_err(sp, msg.as_slice()),\n-        (Deny, None)     => sess.err(msg.as_slice()),\n+        (Warn, Some(sp)) => sess.span_warn(sp, msg[]),\n+        (Warn, None)     => sess.warn(msg[]),\n+        (Deny, Some(sp)) => sess.span_err(sp, msg[]),\n+        (Deny, None)     => sess.err(msg[]),\n         _ => sess.bug(\"impossible level in raw_emit_lint\"),\n     }\n \n@@ -492,7 +492,7 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n                                 None => {\n                                     self.span_lint(builtin::UNKNOWN_LINTS, span,\n                                                format!(\"unknown `{}` attribute: `{}`\",\n-                                                       level.as_str(), lint_name).as_slice());\n+                                                       level.as_str(), lint_name)[]);\n                                     continue;\n                                 }\n                             }\n@@ -508,7 +508,7 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n                     self.tcx.sess.span_err(span,\n                                            format!(\"{}({}) overruled by outer forbid({})\",\n                                                    level.as_str(), lint_name,\n-                                                   lint_name).as_slice());\n+                                                   lint_name)[]);\n                 } else if now != level {\n                     let src = self.lints.get_level_source(lint_id).1;\n                     self.level_stack.push((lint_id, (now, src)));\n@@ -543,22 +543,22 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     fn visit_item(&mut self, it: &ast::Item) {\n-        self.with_lint_attrs(it.attrs.as_slice(), |cx| {\n+        self.with_lint_attrs(it.attrs[], |cx| {\n             run_lints!(cx, check_item, it);\n             cx.visit_ids(|v| v.visit_item(it));\n             visit::walk_item(cx, it);\n         })\n     }\n \n     fn visit_foreign_item(&mut self, it: &ast::ForeignItem) {\n-        self.with_lint_attrs(it.attrs.as_slice(), |cx| {\n+        self.with_lint_attrs(it.attrs[], |cx| {\n             run_lints!(cx, check_foreign_item, it);\n             visit::walk_foreign_item(cx, it);\n         })\n     }\n \n     fn visit_view_item(&mut self, i: &ast::ViewItem) {\n-        self.with_lint_attrs(i.attrs.as_slice(), |cx| {\n+        self.with_lint_attrs(i.attrs[], |cx| {\n             run_lints!(cx, check_view_item, i);\n             cx.visit_ids(|v| v.visit_view_item(i));\n             visit::walk_view_item(cx, i);\n@@ -584,7 +584,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n                 body: &'v ast::Block, span: Span, id: ast::NodeId) {\n         match fk {\n             visit::FkMethod(_, _, m) => {\n-                self.with_lint_attrs(m.attrs.as_slice(), |cx| {\n+                self.with_lint_attrs(m.attrs[], |cx| {\n                     run_lints!(cx, check_fn, fk, decl, body, span, id);\n                     cx.visit_ids(|v| {\n                         v.visit_fn(fk, decl, body, span, id);\n@@ -600,7 +600,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     }\n \n     fn visit_ty_method(&mut self, t: &ast::TypeMethod) {\n-        self.with_lint_attrs(t.attrs.as_slice(), |cx| {\n+        self.with_lint_attrs(t.attrs[], |cx| {\n             run_lints!(cx, check_ty_method, t);\n             visit::walk_ty_method(cx, t);\n         })\n@@ -617,14 +617,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     }\n \n     fn visit_struct_field(&mut self, s: &ast::StructField) {\n-        self.with_lint_attrs(s.node.attrs.as_slice(), |cx| {\n+        self.with_lint_attrs(s.node.attrs[], |cx| {\n             run_lints!(cx, check_struct_field, s);\n             visit::walk_struct_field(cx, s);\n         })\n     }\n \n     fn visit_variant(&mut self, v: &ast::Variant, g: &ast::Generics) {\n-        self.with_lint_attrs(v.node.attrs.as_slice(), |cx| {\n+        self.with_lint_attrs(v.node.attrs[], |cx| {\n             run_lints!(cx, check_variant, v, g);\n             visit::walk_variant(cx, v, g);\n             run_lints!(cx, check_variant_post, v, g);\n@@ -718,7 +718,7 @@ impl<'a, 'tcx> IdVisitingOperation for Context<'a, 'tcx> {\n             None => {}\n             Some(lints) => {\n                 for (lint_id, span, msg) in lints.into_iter() {\n-                    self.span_lint(lint_id.lint, span, msg.as_slice())\n+                    self.span_lint(lint_id.lint, span, msg[])\n                 }\n             }\n         }\n@@ -764,7 +764,7 @@ pub fn check_crate(tcx: &ty::ctxt,\n     let mut cx = Context::new(tcx, krate, exported_items);\n \n     // Visit the whole crate.\n-    cx.with_lint_attrs(krate.attrs.as_slice(), |cx| {\n+    cx.with_lint_attrs(krate.attrs[], |cx| {\n         cx.visit_id(ast::CRATE_NODE_ID);\n         cx.visit_ids(|v| {\n             v.visited_outermost = true;\n@@ -784,7 +784,7 @@ pub fn check_crate(tcx: &ty::ctxt,\n         for &(lint, span, ref msg) in v.iter() {\n             tcx.sess.span_bug(span,\n                               format!(\"unprocessed lint {} at {}: {}\",\n-                                      lint.as_str(), tcx.map.node_to_string(*id), *msg).as_slice())\n+                                      lint.as_str(), tcx.map.node_to_string(*id), *msg)[])\n         }\n     }\n "}, {"sha": "98b57511957f605000ce7a9caa0ae569ec469d19", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -95,11 +95,11 @@ fn warn_if_multiple_versions(diag: &SpanHandler, cstore: &CStore) {\n     for (name, dupes) in map.into_iter() {\n         if dupes.len() == 1 { continue }\n         diag.handler().warn(\n-            format!(\"using multiple versions of crate `{}`\", name).as_slice());\n+            format!(\"using multiple versions of crate `{}`\", name)[]);\n         for dupe in dupes.into_iter() {\n             let data = cstore.get_crate_data(dupe);\n             diag.span_note(data.span, \"used here\");\n-            loader::note_crate_name(diag, data.name().as_slice());\n+            loader::note_crate_name(diag, data.name()[]);\n         }\n     }\n }\n@@ -117,7 +117,7 @@ fn should_link(i: &ast::ViewItem) -> bool {\n     i.attrs.iter().all(|attr| {\n         attr.name().get() != \"phase\" ||\n             attr.meta_item_list().map_or(false, |phases| {\n-                attr::contains_name(phases.as_slice(), \"link\")\n+                attr::contains_name(phases[], \"link\")\n             })\n     })\n }\n@@ -131,8 +131,8 @@ fn visit_view_item(e: &mut Env, i: &ast::ViewItem) {\n         Some(info) => {\n             let (cnum, _, _) = resolve_crate(e,\n                                              &None,\n-                                             info.ident.as_slice(),\n-                                             info.name.as_slice(),\n+                                             info.ident[],\n+                                             info.name[],\n                                              None,\n                                              i.span);\n             e.sess.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n@@ -157,7 +157,7 @@ fn extract_crate_info(e: &Env, i: &ast::ViewItem) -> Option<CrateInfo> {\n             let name = match *path_opt {\n                 Some((ref path_str, _)) => {\n                     let name = path_str.get().to_string();\n-                    validate_crate_name(Some(e.sess), name.as_slice(),\n+                    validate_crate_name(Some(e.sess), name[],\n                                         Some(i.span));\n                     name\n                 }\n@@ -188,7 +188,7 @@ pub fn validate_crate_name(sess: Option<&Session>, s: &str, sp: Option<Span>) {\n     for c in s.chars() {\n         if c.is_alphanumeric() { continue }\n         if c == '_' || c == '-' { continue }\n-        err(format!(\"invalid character `{}` in crate name: `{}`\", c, s).as_slice());\n+        err(format!(\"invalid character `{}` in crate name: `{}`\", c, s)[]);\n     }\n     match sess {\n         Some(sess) => sess.abort_if_errors(),\n@@ -246,7 +246,7 @@ fn visit_item(e: &Env, i: &ast::Item) {\n                                 } else {\n                                     e.sess.span_err(m.span,\n                                         format!(\"unknown kind: `{}`\",\n-                                                k).as_slice());\n+                                                k)[]);\n                                     cstore::NativeUnknown\n                                 }\n                             }\n@@ -327,7 +327,7 @@ fn existing_match(e: &Env, name: &str,\n         match e.sess.opts.externs.get(name) {\n             Some(locs) => {\n                 let found = locs.iter().any(|l| {\n-                    let l = fs::realpath(&Path::new(l.as_slice())).ok();\n+                    let l = fs::realpath(&Path::new(l[])).ok();\n                     l == source.dylib || l == source.rlib\n                 });\n                 if found {\n@@ -405,7 +405,7 @@ fn resolve_crate<'a>(e: &mut Env,\n                 crate_name: name,\n                 hash: hash.map(|a| &*a),\n                 filesearch: e.sess.target_filesearch(),\n-                triple: e.sess.opts.target_triple.as_slice(),\n+                triple: e.sess.opts.target_triple[],\n                 root: root,\n                 rejected_via_hash: vec!(),\n                 rejected_via_triple: vec!(),\n@@ -431,8 +431,8 @@ fn resolve_crate_deps(e: &mut Env,\n     decoder::get_crate_deps(cdata).iter().map(|dep| {\n         debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n         let (local_cnum, _, _) = resolve_crate(e, root,\n-                                               dep.name.as_slice(),\n-                                               dep.name.as_slice(),\n+                                               dep.name[],\n+                                               dep.name[],\n                                                Some(&dep.hash),\n                                                span);\n         (dep.cnum, local_cnum)\n@@ -455,14 +455,14 @@ impl<'a> PluginMetadataReader<'a> {\n \n     pub fn read_plugin_metadata(&mut self, krate: &ast::ViewItem) -> PluginMetadata {\n         let info = extract_crate_info(&self.env, krate).unwrap();\n-        let target_triple = self.env.sess.opts.target_triple.as_slice();\n+        let target_triple = self.env.sess.opts.target_triple[];\n         let is_cross = target_triple != config::host_triple();\n         let mut should_link = info.should_link && !is_cross;\n         let mut load_ctxt = loader::Context {\n             sess: self.env.sess,\n             span: krate.span,\n-            ident: info.ident.as_slice(),\n-            crate_name: info.name.as_slice(),\n+            ident: info.ident[],\n+            crate_name: info.name[],\n             hash: None,\n             filesearch: self.env.sess.host_filesearch(),\n             triple: config::host_triple(),\n@@ -483,7 +483,7 @@ impl<'a> PluginMetadataReader<'a> {\n                     let message = format!(\"crate `{}` contains a plugin_registrar fn but \\\n                                   only a version for triple `{}` could be found (need {})\",\n                                   info.ident, target_triple, config::host_triple());\n-                    self.env.sess.span_err(krate.span, message.as_slice());\n+                    self.env.sess.span_err(krate.span, message[]);\n                     // need to abort now because the syntax expansion\n                     // code will shortly attempt to load and execute\n                     // code from the found library.\n@@ -502,7 +502,7 @@ impl<'a> PluginMetadataReader<'a> {\n             let message = format!(\"plugin crate `{}` only found in rlib format, \\\n                                    but must be available in dylib format\",\n                                   info.ident);\n-            self.env.sess.span_err(krate.span, message.as_slice());\n+            self.env.sess.span_err(krate.span, message[]);\n             // No need to abort because the loading code will just ignore this\n             // empty dylib.\n         }\n@@ -511,11 +511,11 @@ impl<'a> PluginMetadataReader<'a> {\n             macros: macros,\n             registrar_symbol: registrar,\n         };\n-        if should_link && existing_match(&self.env, info.name.as_slice(),\n+        if should_link && existing_match(&self.env, info.name[],\n                                          None).is_none() {\n             // register crate now to avoid double-reading metadata\n-            register_crate(&mut self.env, &None, info.ident.as_slice(),\n-                           info.name.as_slice(), krate.span, library);\n+            register_crate(&mut self.env, &None, info.ident[],\n+                           info.name[], krate.span, library);\n         }\n         pc\n     }"}, {"sha": "13342bf82cfea7bf7128989ea282b5621d095467", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -95,7 +95,7 @@ pub fn get_item_path(tcx: &ty::ctxt, def: ast::DefId) -> Vec<ast_map::PathElem>\n \n     // FIXME #1920: This path is not always correct if the crate is not linked\n     // into the root namespace.\n-    let mut r = vec![ast_map::PathMod(token::intern(cdata.name.as_slice()))];\n+    let mut r = vec![ast_map::PathMod(token::intern(cdata.name[]))];\n     r.push_all(path.as_slice());\n     r\n }"}, {"sha": "f05607a999b668eea80d3fd6348d80872ed618a4", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -221,7 +221,7 @@ fn each_reexport<F>(d: rbml::Doc, f: F) -> bool where\n fn variant_disr_val(d: rbml::Doc) -> Option<ty::Disr> {\n     reader::maybe_get_doc(d, tag_disr_val).and_then(|val_doc| {\n         reader::with_doc_data(val_doc, |data| {\n-            str::from_utf8(data).and_then(from_str)\n+            str::from_utf8(data).ok().and_then(|s| s.parse())\n         })\n     })\n }\n@@ -700,7 +700,7 @@ pub fn get_enum_variants<'tcx>(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::Nod\n                                 item, tcx, cdata);\n         let name = item_name(&*intr, item);\n         let (ctor_ty, arg_tys, arg_names) = match ctor_ty.sty {\n-            ty::ty_bare_fn(ref f) =>\n+            ty::ty_bare_fn(_, ref f) =>\n                 (Some(ctor_ty), f.sig.0.inputs.clone(), None),\n             _ => { // Nullary or struct enum variant.\n                 let mut arg_names = Vec::new();\n@@ -1160,7 +1160,7 @@ pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n     }\n     reader::tagged_docs(depsdoc, tag_crate_dep, |depdoc| {\n         let name = docstr(depdoc, tag_crate_dep_crate_name);\n-        let hash = Svh::new(docstr(depdoc, tag_crate_dep_hash).as_slice());\n+        let hash = Svh::new(docstr(depdoc, tag_crate_dep_hash)[]);\n         deps.push(CrateDep {\n             cnum: crate_num,\n             name: name,\n@@ -1345,7 +1345,7 @@ pub fn get_dylib_dependency_formats(cdata: Cmd)\n         if spec.len() == 0 { continue }\n         let cnum = spec.split(':').nth(0).unwrap();\n         let link = spec.split(':').nth(1).unwrap();\n-        let cnum = from_str(cnum).unwrap();\n+        let cnum = cnum.parse().unwrap();\n         let cnum = match cdata.cnum_map.get(&cnum) {\n             Some(&n) => n,\n             None => panic!(\"didn't find a crate in the cnum_map\")"}, {"sha": "6782b3a74813e668e9aa680018ca9f1fd1753ec6", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -95,7 +95,7 @@ fn encode_impl_type_basename(rbml_w: &mut Encoder, name: ast::Ident) {\n }\n \n pub fn encode_def_id(rbml_w: &mut Encoder, id: DefId) {\n-    rbml_w.wr_tagged_str(tag_def_id, def_to_string(id).as_slice());\n+    rbml_w.wr_tagged_str(tag_def_id, def_to_string(id)[]);\n }\n \n #[deriving(Clone)]\n@@ -154,7 +154,7 @@ fn encode_variant_id(rbml_w: &mut Encoder, vid: DefId) {\n     rbml_w.end_tag();\n \n     rbml_w.start_tag(tag_mod_child);\n-    rbml_w.wr_str(s.as_slice());\n+    rbml_w.wr_str(s[]);\n     rbml_w.end_tag();\n }\n \n@@ -264,7 +264,7 @@ fn encode_symbol(ecx: &EncodeContext,\n         }\n         None => {\n             ecx.diag.handler().bug(\n-                format!(\"encode_symbol: id not found {}\", id).as_slice());\n+                format!(\"encode_symbol: id not found {}\", id)[]);\n         }\n     }\n     rbml_w.end_tag();\n@@ -332,8 +332,8 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n         encode_name(rbml_w, variant.node.name.name);\n         encode_parent_item(rbml_w, local_def(id));\n         encode_visibility(rbml_w, variant.node.vis);\n-        encode_attributes(rbml_w, variant.node.attrs.as_slice());\n-        encode_repr_attrs(rbml_w, ecx, variant.node.attrs.as_slice());\n+        encode_attributes(rbml_w, variant.node.attrs[]);\n+        encode_repr_attrs(rbml_w, ecx, variant.node.attrs[]);\n \n         let stab = stability::lookup(ecx.tcx, ast_util::local_def(variant.node.id));\n         encode_stability(rbml_w, stab);\n@@ -344,9 +344,9 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                 let fields = ty::lookup_struct_fields(ecx.tcx, def_id);\n                 let idx = encode_info_for_struct(ecx,\n                                                  rbml_w,\n-                                                 fields.as_slice(),\n+                                                 fields[],\n                                                  index);\n-                encode_struct_fields(rbml_w, fields.as_slice(), def_id);\n+                encode_struct_fields(rbml_w, fields[], def_id);\n                 encode_index(rbml_w, idx, write_i64);\n             }\n         }\n@@ -386,12 +386,12 @@ fn encode_reexported_static_method(rbml_w: &mut Encoder,\n             exp.name, token::get_name(method_name));\n     rbml_w.start_tag(tag_items_data_item_reexport);\n     rbml_w.start_tag(tag_items_data_item_reexport_def_id);\n-    rbml_w.wr_str(def_to_string(method_def_id).as_slice());\n+    rbml_w.wr_str(def_to_string(method_def_id)[]);\n     rbml_w.end_tag();\n     rbml_w.start_tag(tag_items_data_item_reexport_name);\n     rbml_w.wr_str(format!(\"{}::{}\",\n                           exp.name,\n-                          token::get_name(method_name)).as_slice());\n+                          token::get_name(method_name))[]);\n     rbml_w.end_tag();\n     rbml_w.end_tag();\n }\n@@ -529,7 +529,7 @@ fn encode_reexports(ecx: &EncodeContext,\n                        id);\n                 rbml_w.start_tag(tag_items_data_item_reexport);\n                 rbml_w.start_tag(tag_items_data_item_reexport_def_id);\n-                rbml_w.wr_str(def_to_string(exp.def_id).as_slice());\n+                rbml_w.wr_str(def_to_string(exp.def_id)[]);\n                 rbml_w.end_tag();\n                 rbml_w.start_tag(tag_items_data_item_reexport_name);\n                 rbml_w.wr_str(exp.name.as_str());\n@@ -562,13 +562,13 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n     // Encode info about all the module children.\n     for item in md.items.iter() {\n         rbml_w.start_tag(tag_mod_child);\n-        rbml_w.wr_str(def_to_string(local_def(item.id)).as_slice());\n+        rbml_w.wr_str(def_to_string(local_def(item.id))[]);\n         rbml_w.end_tag();\n \n         each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n             rbml_w.start_tag(tag_mod_child);\n             rbml_w.wr_str(def_to_string(local_def(\n-                        auxiliary_node_id)).as_slice());\n+                        auxiliary_node_id))[]);\n             rbml_w.end_tag();\n             true\n         });\n@@ -580,7 +580,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                    did, ecx.tcx.map.node_to_string(did));\n \n             rbml_w.start_tag(tag_mod_impl);\n-            rbml_w.wr_str(def_to_string(local_def(did)).as_slice());\n+            rbml_w.wr_str(def_to_string(local_def(did))[]);\n             rbml_w.end_tag();\n         }\n     }\n@@ -615,7 +615,7 @@ fn encode_visibility(rbml_w: &mut Encoder, visibility: ast::Visibility) {\n         ast::Public => 'y',\n         ast::Inherited => 'i',\n     };\n-    rbml_w.wr_str(ch.to_string().as_slice());\n+    rbml_w.wr_str(ch.to_string()[]);\n     rbml_w.end_tag();\n }\n \n@@ -627,7 +627,7 @@ fn encode_unboxed_closure_kind(rbml_w: &mut Encoder,\n         ty::FnMutUnboxedClosureKind => 'm',\n         ty::FnOnceUnboxedClosureKind => 'o',\n     };\n-    rbml_w.wr_str(ch.to_string().as_slice());\n+    rbml_w.wr_str(ch.to_string()[]);\n     rbml_w.end_tag();\n }\n \n@@ -788,7 +788,7 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n         rbml_w.end_tag();\n \n         rbml_w.wr_tagged_str(tag_region_param_def_def_id,\n-                             def_to_string(param.def_id).as_slice());\n+                             def_to_string(param.def_id)[]);\n \n         rbml_w.wr_tagged_u64(tag_region_param_def_space,\n                              param.space.to_uint() as u64);\n@@ -864,9 +864,9 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_path(rbml_w, impl_path.chain(Some(elem).into_iter()));\n     match ast_item_opt {\n         Some(&ast::MethodImplItem(ref ast_method)) => {\n-            encode_attributes(rbml_w, ast_method.attrs.as_slice());\n+            encode_attributes(rbml_w, ast_method.attrs[]);\n             let any_types = !pty.generics.types.is_empty();\n-            if any_types || is_default_impl || should_inline(ast_method.attrs.as_slice()) {\n+            if any_types || is_default_impl || should_inline(ast_method.attrs[]) {\n                 encode_inlined_item(ecx, rbml_w, IIImplItemRef(local_def(parent_id),\n                                                                ast_item_opt.unwrap()));\n             }\n@@ -909,7 +909,7 @@ fn encode_info_for_associated_type(ecx: &EncodeContext,\n     match typedef_opt {\n         None => {}\n         Some(typedef) => {\n-            encode_attributes(rbml_w, typedef.attrs.as_slice());\n+            encode_attributes(rbml_w, typedef.attrs[]);\n             encode_type(ecx, rbml_w, ty::node_id_to_type(ecx.tcx,\n                                                          typedef.id));\n         }\n@@ -1043,7 +1043,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_path(rbml_w, path);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n-        encode_attributes(rbml_w, item.attrs.as_slice());\n+        encode_attributes(rbml_w, item.attrs[]);\n         rbml_w.end_tag();\n       }\n       ast::ItemConst(_, _) => {\n@@ -1069,8 +1069,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(rbml_w, item.ident.name);\n         encode_path(rbml_w, path);\n-        encode_attributes(rbml_w, item.attrs.as_slice());\n-        if tps_len > 0u || should_inline(item.attrs.as_slice()) {\n+        encode_attributes(rbml_w, item.attrs[]);\n+        if tps_len > 0u || should_inline(item.attrs[]) {\n             encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n         }\n         if tps_len == 0 {\n@@ -1086,7 +1086,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_info_for_mod(ecx,\n                             rbml_w,\n                             m,\n-                            item.attrs.as_slice(),\n+                            item.attrs[],\n                             item.id,\n                             path,\n                             item.ident,\n@@ -1103,7 +1103,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // Encode all the items in this module.\n         for foreign_item in fm.items.iter() {\n             rbml_w.start_tag(tag_mod_child);\n-            rbml_w.wr_str(def_to_string(local_def(foreign_item.id)).as_slice());\n+            rbml_w.wr_str(def_to_string(local_def(foreign_item.id))[]);\n             rbml_w.end_tag();\n         }\n         encode_visibility(rbml_w, vis);\n@@ -1131,8 +1131,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_item_variances(rbml_w, ecx, item.id);\n         encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(rbml_w, item.ident.name);\n-        encode_attributes(rbml_w, item.attrs.as_slice());\n-        encode_repr_attrs(rbml_w, ecx, item.attrs.as_slice());\n+        encode_attributes(rbml_w, item.attrs[]);\n+        encode_repr_attrs(rbml_w, ecx, item.attrs[]);\n         for v in (*enum_definition).variants.iter() {\n             encode_variant_id(rbml_w, local_def(v.node.id));\n         }\n@@ -1149,7 +1149,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_enum_variant_info(ecx,\n                                  rbml_w,\n                                  item.id,\n-                                 (*enum_definition).variants.as_slice(),\n+                                 (*enum_definition).variants[],\n                                  index);\n       }\n       ast::ItemStruct(ref struct_def, _) => {\n@@ -1161,7 +1161,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n            class itself */\n         let idx = encode_info_for_struct(ecx,\n                                          rbml_w,\n-                                         fields.as_slice(),\n+                                         fields[],\n                                          index);\n \n         /* Index the class*/\n@@ -1175,16 +1175,16 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n         encode_item_variances(rbml_w, ecx, item.id);\n         encode_name(rbml_w, item.ident.name);\n-        encode_attributes(rbml_w, item.attrs.as_slice());\n+        encode_attributes(rbml_w, item.attrs[]);\n         encode_path(rbml_w, path.clone());\n         encode_stability(rbml_w, stab);\n         encode_visibility(rbml_w, vis);\n-        encode_repr_attrs(rbml_w, ecx, item.attrs.as_slice());\n+        encode_repr_attrs(rbml_w, ecx, item.attrs[]);\n \n         /* Encode def_ids for each field and method\n          for methods, write all the stuff get_trait_method\n         needs to know*/\n-        encode_struct_fields(rbml_w, fields.as_slice(), def_id);\n+        encode_struct_fields(rbml_w, fields[], def_id);\n \n         encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n \n@@ -1216,7 +1216,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_family(rbml_w, 'i');\n         encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(rbml_w, item.ident.name);\n-        encode_attributes(rbml_w, item.attrs.as_slice());\n+        encode_attributes(rbml_w, item.attrs[]);\n         encode_unsafety(rbml_w, unsafety);\n         match ty.node {\n             ast::TyPath(ref path, _) if path.segments\n@@ -1319,7 +1319,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_generics(rbml_w, ecx, &trait_def.generics, tag_item_generics);\n         encode_trait_ref(rbml_w, ecx, &*trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(rbml_w, item.ident.name);\n-        encode_attributes(rbml_w, item.attrs.as_slice());\n+        encode_attributes(rbml_w, item.attrs[]);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n         for &method_def_id in ty::trait_item_def_ids(tcx, def_id).iter() {\n@@ -1337,7 +1337,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             rbml_w.end_tag();\n \n             rbml_w.start_tag(tag_mod_child);\n-            rbml_w.wr_str(def_to_string(method_def_id.def_id()).as_slice());\n+            rbml_w.wr_str(def_to_string(method_def_id.def_id())[]);\n             rbml_w.end_tag();\n         }\n         encode_path(rbml_w, path.clone());\n@@ -1422,14 +1422,14 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             };\n             match trait_item {\n                 &ast::RequiredMethod(ref m) => {\n-                    encode_attributes(rbml_w, m.attrs.as_slice());\n+                    encode_attributes(rbml_w, m.attrs[]);\n                     encode_trait_item(rbml_w);\n                     encode_item_sort(rbml_w, 'r');\n                     encode_method_argument_names(rbml_w, &*m.decl);\n                 }\n \n                 &ast::ProvidedMethod(ref m) => {\n-                    encode_attributes(rbml_w, m.attrs.as_slice());\n+                    encode_attributes(rbml_w, m.attrs[]);\n                     encode_trait_item(rbml_w);\n                     encode_item_sort(rbml_w, 'p');\n                     encode_inlined_item(ecx, rbml_w, IITraitItemRef(def_id, trait_item));\n@@ -1438,7 +1438,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n                 &ast::TypeTraitItem(ref associated_type) => {\n                     encode_attributes(rbml_w,\n-                                      associated_type.attrs.as_slice());\n+                                      associated_type.attrs[]);\n                     encode_item_sort(rbml_w, 't');\n                 }\n             }\n@@ -1802,7 +1802,7 @@ fn encode_macro_def(ecx: &EncodeContext,\n     let def = ecx.tcx.sess.codemap().span_to_snippet(*span)\n         .expect(\"Unable to find source for macro\");\n     rbml_w.start_tag(tag_macro_def);\n-    rbml_w.wr_str(def.as_slice());\n+    rbml_w.wr_str(def[]);\n     rbml_w.end_tag();\n }\n \n@@ -1849,7 +1849,7 @@ fn encode_struct_field_attrs(rbml_w: &mut Encoder, krate: &ast::Crate) {\n         fn visit_struct_field(&mut self, field: &ast::StructField) {\n             self.rbml_w.start_tag(tag_struct_field);\n             self.rbml_w.wr_tagged_u32(tag_struct_field_id, field.node.id);\n-            encode_attributes(self.rbml_w, field.node.attrs.as_slice());\n+            encode_attributes(self.rbml_w, field.node.attrs[]);\n             self.rbml_w.end_tag();\n         }\n     }\n@@ -1921,13 +1921,13 @@ fn encode_misc_info(ecx: &EncodeContext,\n     rbml_w.start_tag(tag_misc_info_crate_items);\n     for item in krate.module.items.iter() {\n         rbml_w.start_tag(tag_mod_child);\n-        rbml_w.wr_str(def_to_string(local_def(item.id)).as_slice());\n+        rbml_w.wr_str(def_to_string(local_def(item.id))[]);\n         rbml_w.end_tag();\n \n         each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n             rbml_w.start_tag(tag_mod_child);\n             rbml_w.wr_str(def_to_string(local_def(\n-                        auxiliary_node_id)).as_slice());\n+                        auxiliary_node_id))[]);\n             rbml_w.end_tag();\n             true\n         });\n@@ -2096,17 +2096,17 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n \n     let mut rbml_w = writer::Encoder::new(wr);\n \n-    encode_crate_name(&mut rbml_w, ecx.link_meta.crate_name.as_slice());\n+    encode_crate_name(&mut rbml_w, ecx.link_meta.crate_name[]);\n     encode_crate_triple(&mut rbml_w,\n                         tcx.sess\n                            .opts\n                            .target_triple\n-                           .as_slice());\n+                           []);\n     encode_hash(&mut rbml_w, &ecx.link_meta.crate_hash);\n     encode_dylib_dependency_formats(&mut rbml_w, &ecx);\n \n     let mut i = rbml_w.writer.tell().unwrap();\n-    encode_attributes(&mut rbml_w, krate.attrs.as_slice());\n+    encode_attributes(&mut rbml_w, krate.attrs[]);\n     stats.attr_bytes = rbml_w.writer.tell().unwrap() - i;\n \n     i = rbml_w.writer.tell().unwrap();"}, {"sha": "5f554eb9c1e5c0dc577490f68704a11816d3356d", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -316,14 +316,14 @@ impl<'a> Context<'a> {\n             &Some(ref r) => format!(\"{} which `{}` depends on\",\n                                     message, r.ident)\n         };\n-        self.sess.span_err(self.span, message.as_slice());\n+        self.sess.span_err(self.span, message[]);\n \n         if self.rejected_via_triple.len() > 0 {\n             let mismatches = self.rejected_via_triple.iter();\n             for (i, &CrateMismatch{ ref path, ref got }) in mismatches.enumerate() {\n                 self.sess.fileline_note(self.span,\n                     format!(\"crate `{}`, path #{}, triple {}: {}\",\n-                            self.ident, i+1, got, path.display()).as_slice());\n+                            self.ident, i+1, got, path.display())[]);\n             }\n         }\n         if self.rejected_via_hash.len() > 0 {\n@@ -333,15 +333,15 @@ impl<'a> Context<'a> {\n             for (i, &CrateMismatch{ ref path, .. }) in mismatches.enumerate() {\n                 self.sess.fileline_note(self.span,\n                     format!(\"crate `{}` path {}{}: {}\",\n-                            self.ident, \"#\", i+1, path.display()).as_slice());\n+                            self.ident, \"#\", i+1, path.display())[]);\n             }\n             match self.root {\n                 &None => {}\n                 &Some(ref r) => {\n                     for (i, path) in r.paths().iter().enumerate() {\n                         self.sess.fileline_note(self.span,\n                             format!(\"crate `{}` path #{}: {}\",\n-                                    r.ident, i+1, path.display()).as_slice());\n+                                    r.ident, i+1, path.display())[]);\n                     }\n                 }\n             }\n@@ -387,7 +387,7 @@ impl<'a> Context<'a> {\n                 None => return FileDoesntMatch,\n                 Some(file) => file,\n             };\n-            let (hash, rlib) = if file.starts_with(rlib_prefix.as_slice()) &&\n+            let (hash, rlib) = if file.starts_with(rlib_prefix[]) &&\n                     file.ends_with(\".rlib\") {\n                 (file.slice(rlib_prefix.len(), file.len() - \".rlib\".len()),\n                  true)\n@@ -448,26 +448,26 @@ impl<'a> Context<'a> {\n             _ => {\n                 self.sess.span_err(self.span,\n                     format!(\"multiple matching crates for `{}`\",\n-                            self.crate_name).as_slice());\n+                            self.crate_name)[]);\n                 self.sess.note(\"candidates:\");\n                 for lib in libraries.iter() {\n                     match lib.dylib {\n                         Some(ref p) => {\n                             self.sess.note(format!(\"path: {}\",\n-                                                   p.display()).as_slice());\n+                                                   p.display())[]);\n                         }\n                         None => {}\n                     }\n                     match lib.rlib {\n                         Some(ref p) => {\n                             self.sess.note(format!(\"path: {}\",\n-                                                   p.display()).as_slice());\n+                                                   p.display())[]);\n                         }\n                         None => {}\n                     }\n                     let data = lib.metadata.as_slice();\n                     let name = decoder::get_crate_name(data);\n-                    note_crate_name(self.sess.diagnostic(), name.as_slice());\n+                    note_crate_name(self.sess.diagnostic(), name[]);\n                 }\n                 None\n             }\n@@ -521,19 +521,19 @@ impl<'a> Context<'a> {\n                                    format!(\"multiple {} candidates for `{}` \\\n                                             found\",\n                                            flavor,\n-                                           self.crate_name).as_slice());\n+                                           self.crate_name)[]);\n                 self.sess.span_note(self.span,\n                                     format!(r\"candidate #1: {}\",\n                                             ret.as_ref().unwrap()\n-                                               .display()).as_slice());\n+                                               .display())[]);\n                 error = 1;\n                 ret = None;\n             }\n             if error > 0 {\n                 error += 1;\n                 self.sess.span_note(self.span,\n                                     format!(r\"candidate #{}: {}\", error,\n-                                            lib.display()).as_slice());\n+                                            lib.display())[]);\n                 continue\n             }\n             *slot = Some(metadata);\n@@ -608,30 +608,30 @@ impl<'a> Context<'a> {\n         let mut rlibs = HashSet::new();\n         let mut dylibs = HashSet::new();\n         {\n-            let mut locs = locs.iter().map(|l| Path::new(l.as_slice())).filter(|loc| {\n+            let mut locs = locs.iter().map(|l| Path::new(l[])).filter(|loc| {\n                 if !loc.exists() {\n                     sess.err(format!(\"extern location for {} does not exist: {}\",\n-                                     self.crate_name, loc.display()).as_slice());\n+                                     self.crate_name, loc.display())[]);\n                     return false;\n                 }\n                 let file = match loc.filename_str() {\n                     Some(file) => file,\n                     None => {\n                         sess.err(format!(\"extern location for {} is not a file: {}\",\n-                                         self.crate_name, loc.display()).as_slice());\n+                                         self.crate_name, loc.display())[]);\n                         return false;\n                     }\n                 };\n                 if file.starts_with(\"lib\") && file.ends_with(\".rlib\") {\n                     return true\n                 } else {\n                     let (ref prefix, ref suffix) = dylibname;\n-                    if file.starts_with(prefix.as_slice()) && file.ends_with(suffix.as_slice()) {\n+                    if file.starts_with(prefix[]) && file.ends_with(suffix[]) {\n                         return true\n                     }\n                 }\n                 sess.err(format!(\"extern location for {} is of an unknown type: {}\",\n-                                 self.crate_name, loc.display()).as_slice());\n+                                 self.crate_name, loc.display())[]);\n                 false\n             });\n \n@@ -664,7 +664,7 @@ impl<'a> Context<'a> {\n }\n \n pub fn note_crate_name(diag: &SpanHandler, name: &str) {\n-    diag.handler().note(format!(\"crate name: {}\", name).as_slice());\n+    diag.handler().note(format!(\"crate name: {}\", name)[]);\n }\n \n impl ArchiveMetadata {"}, {"sha": "61ea93a9fdd1be38338597e2c0ccb33d35cb05e1", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -233,7 +233,7 @@ fn parse_trait_store(st: &mut PState, conv: conv_did) -> ty::TraitStore {\n         '&' => ty::RegionTraitStore(parse_region(st, conv), parse_mutability(st)),\n         c => {\n             st.tcx.sess.bug(format!(\"parse_trait_store(): bad input '{}'\",\n-                                    c).as_slice())\n+                                    c)[])\n         }\n     }\n }\n@@ -287,7 +287,7 @@ fn parse_bound_region(st: &mut PState, conv: conv_did) -> ty::BoundRegion {\n         }\n         '[' => {\n             let def = parse_def(st, RegionParameter, |x,y| conv(x,y));\n-            let ident = token::str_to_ident(parse_str(st, ']').as_slice());\n+            let ident = token::str_to_ident(parse_str(st, ']')[]);\n             ty::BrNamed(def, ident.name)\n         }\n         'f' => {\n@@ -318,7 +318,7 @@ fn parse_region(st: &mut PState, conv: conv_did) -> ty::Region {\n         assert_eq!(next(st), '|');\n         let index = parse_uint(st);\n         assert_eq!(next(st), '|');\n-        let nm = token::str_to_ident(parse_str(st, ']').as_slice());\n+        let nm = token::str_to_ident(parse_str(st, ']')[]);\n         ty::ReEarlyBound(node_id, space, index, nm.name)\n       }\n       'f' => {\n@@ -453,7 +453,11 @@ fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> Ty<'tcx> {\n         return ty::mk_closure(st.tcx, parse_closure_ty(st, |x,y| conv(x,y)));\n       }\n       'F' => {\n-        return ty::mk_bare_fn(st.tcx, parse_bare_fn_ty(st, |x,y| conv(x,y)));\n+          let def_id = parse_def(st, NominalType, |x,y| conv(x,y));\n+          return ty::mk_bare_fn(st.tcx, Some(def_id), parse_bare_fn_ty(st, |x,y| conv(x,y)));\n+      }\n+      'G' => {\n+          return ty::mk_bare_fn(st.tcx, None, parse_bare_fn_ty(st, |x,y| conv(x,y)));\n       }\n       '#' => {\n         let pos = parse_hex(st);\n@@ -560,7 +564,7 @@ fn parse_abi_set(st: &mut PState) -> abi::Abi {\n     assert_eq!(next(st), '[');\n     scan(st, |c| c == ']', |bytes| {\n         let abi_str = str::from_utf8(bytes).unwrap();\n-        abi::lookup(abi_str.as_slice()).expect(abi_str)\n+        abi::lookup(abi_str[]).expect(abi_str)\n     })\n }\n \n@@ -639,12 +643,12 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n     let crate_part = buf[0u..colon_idx];\n     let def_part = buf[colon_idx + 1u..len];\n \n-    let crate_num = match str::from_utf8(crate_part).and_then(from_str::<uint>) {\n+    let crate_num = match str::from_utf8(crate_part).ok().and_then(|s| s.parse::<uint>()) {\n        Some(cn) => cn as ast::CrateNum,\n        None => panic!(\"internal error: parse_def_id: crate number expected, found {}\",\n                      crate_part)\n     };\n-    let def_num = match str::from_utf8(def_part).and_then(from_str::<uint>) {\n+    let def_num = match str::from_utf8(def_part).ok().and_then(|s| s.parse::<uint>()) {\n        Some(dn) => dn as ast::NodeId,\n        None => panic!(\"internal error: parse_def_id: id expected, found {}\",\n                      def_part)"}, {"sha": "7fa23620af4b63e0abbd2b6be7b35738bed31b33", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -123,8 +123,13 @@ pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'t\n             mywrite!(w, \"f\");\n             enc_closure_ty(w, cx, &**f);\n         }\n-        ty::ty_bare_fn(ref f) => {\n+        ty::ty_bare_fn(Some(def_id), ref f) => {\n             mywrite!(w, \"F\");\n+            mywrite!(w, \"{}|\", (cx.ds)(def_id));\n+            enc_bare_fn_ty(w, cx, f);\n+        }\n+        ty::ty_bare_fn(None, ref f) => {\n+            mywrite!(w, \"G\");\n             enc_bare_fn_ty(w, cx, f);\n         }\n         ty::ty_infer(_) => {"}, {"sha": "060e2f67faf988a0c6266b86f0fdca155ca8e43d", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -48,7 +48,7 @@ pub fn ast_ty_to_prim_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ast_ty: &ast::Ty)\n                 None => {\n                     tcx.sess.span_bug(ast_ty.span,\n                                       format!(\"unbound path {}\",\n-                                              path.repr(tcx)).as_slice())\n+                                              path.repr(tcx))[])\n                 }\n                 Some(&d) => d\n             };"}, {"sha": "e8627dfa64b0bdc5e11e79e03f2256658b65c88e", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -132,7 +132,7 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n             // Do an Option dance to use the path after it is moved below.\n             let s = ast_map::path_to_string(ast_map::Values(path.iter()));\n             path_as_str = Some(s);\n-            path_as_str.as_ref().map(|x| x.as_slice())\n+            path_as_str.as_ref().map(|x| x[])\n         });\n         let mut ast_dsr = reader::Decoder::new(ast_doc);\n         let from_id_range = Decodable::decode(&mut ast_dsr).unwrap();\n@@ -1007,14 +1007,21 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n \n         self.emit_enum(\"AutoAdjustment\", |this| {\n             match *adj {\n-                ty::AdjustAddEnv(store) => {\n-                    this.emit_enum_variant(\"AutoAddEnv\", 0, 1, |this| {\n-                        this.emit_enum_variant_arg(0, |this| store.encode(this))\n+                ty::AdjustAddEnv(def_id, store) => {\n+                    this.emit_enum_variant(\"AdjustAddEnv\", 0, 2, |this| {\n+                        this.emit_enum_variant_arg(0, |this| def_id.encode(this));\n+                        this.emit_enum_variant_arg(1, |this| store.encode(this))\n+                    })\n+                }\n+\n+                ty::AdjustReifyFnPointer(def_id) => {\n+                    this.emit_enum_variant(\"AdjustReifyFnPointer\", 1, 2, |this| {\n+                        this.emit_enum_variant_arg(0, |this| def_id.encode(this))\n                     })\n                 }\n \n                 ty::AdjustDerefRef(ref auto_deref_ref) => {\n-                    this.emit_enum_variant(\"AutoDerefRef\", 1, 1, |this| {\n+                    this.emit_enum_variant(\"AdjustDerefRef\", 2, 2, |this| {\n                         this.emit_enum_variant_arg(0,\n                             |this| Ok(this.emit_auto_deref_ref(ecx, auto_deref_ref)))\n                     })\n@@ -1648,12 +1655,20 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n             this.read_enum_variant(&variants, |this, i| {\n                 Ok(match i {\n                     0 => {\n+                        let def_id: ast::DefId =\n+                            this.read_def_id(dcx);\n                         let store: ty::TraitStore =\n                             this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n \n-                        ty::AdjustAddEnv(store.tr(dcx))\n+                        ty::AdjustAddEnv(def_id, store.tr(dcx))\n                     }\n                     1 => {\n+                        let def_id: ast::DefId =\n+                            this.read_def_id(dcx);\n+\n+                        ty::AdjustReifyFnPointer(def_id)\n+                    }\n+                    2 => {\n                         let auto_deref_ref: ty::AutoDerefRef =\n                             this.read_enum_variant_arg(0,\n                                 |this| Ok(this.read_auto_deref_ref(dcx))).unwrap();\n@@ -1876,7 +1891,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n             None => {\n                 dcx.tcx.sess.bug(\n                     format!(\"unknown tag found in side tables: {:x}\",\n-                            tag).as_slice());\n+                            tag)[]);\n             }\n             Some(value) => {\n                 let val_doc = entry_doc.get(c::tag_table_val as uint);\n@@ -1961,7 +1976,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n                     _ => {\n                         dcx.tcx.sess.bug(\n                             format!(\"unknown tag found in side tables: {:x}\",\n-                                    tag).as_slice());\n+                                    tag)[]);\n                     }\n                 }\n             }"}, {"sha": "2d50757782dbd3419c0d97276837c615ed22adf3", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -362,7 +362,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 let mut cond_exit = discr_exit;\n                 for arm in arms.iter() {\n                     cond_exit = self.add_dummy_node(&[cond_exit]);        // 2\n-                    let pats_exit = self.pats_any(arm.pats.as_slice(),\n+                    let pats_exit = self.pats_any(arm.pats[],\n                                                   cond_exit);            // 3\n                     let guard_exit = self.opt_expr(&arm.guard,\n                                                    pats_exit);           // 4\n@@ -617,14 +617,14 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                         self.tcx.sess.span_bug(\n                             expr.span,\n                             format!(\"no loop scope for id {}\",\n-                                    loop_id).as_slice());\n+                                    loop_id)[]);\n                     }\n \n                     r => {\n                         self.tcx.sess.span_bug(\n                             expr.span,\n                             format!(\"bad entry `{}` in def_map for label\",\n-                                    r).as_slice());\n+                                    r)[]);\n                     }\n                 }\n             }"}, {"sha": "13bd22a67c410dc2da59f07d217198f41037e568", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -50,7 +50,7 @@ fn replace_newline_with_backslash_l(s: String) -> String {\n }\n \n impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n-    fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(self.name.as_slice()).unwrap() }\n+    fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(self.name[]).unwrap() }\n \n     fn node_id(&'a self, &(i,_): &Node<'a>) -> dot::Id<'a> {\n         dot::Id::new(format!(\"N{}\", i.node_id())).unwrap()\n@@ -83,8 +83,7 @@ impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n             let s = self.ast_map.node_to_string(node_id);\n             // left-aligns the lines\n             let s = replace_newline_with_backslash_l(s);\n-            label.push_str(format!(\"exiting scope_{} {}\", i,\n-                                   s.as_slice()).as_slice());\n+            label.push_str(format!(\"exiting scope_{} {}\", i, s[])[]);\n         }\n         dot::EscStr(label.into_cow())\n     }"}, {"sha": "e08dd64d4d4111480a01152c283d299668bb6da1", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -127,7 +127,11 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &ast::Expr) -> bool {\n         ast::ExprCast(ref from, _) => {\n             let toty = ty::expr_ty(v.tcx, e);\n             let fromty = ty::expr_ty(v.tcx, &**from);\n-            if !ty::type_is_numeric(toty) && !ty::type_is_unsafe_ptr(toty) {\n+            let is_legal_cast =\n+                ty::type_is_numeric(toty) ||\n+                ty::type_is_unsafe_ptr(toty) ||\n+                (ty::type_is_bare_fn(toty) && ty::type_is_bare_fn_item(fromty));\n+            if !is_legal_cast {\n                 span_err!(v.tcx.sess, e.span, E0012,\n                           \"can not cast to `{}` in a constant expression\",\n                           ppaux::ty_to_string(v.tcx, toty));"}, {"sha": "5a08d7c179d1cc238466f96fb534182a8ea0ebb7", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -74,13 +74,11 @@ impl<'a> CheckLoopVisitor<'a> {\n             Loop => {}\n             Closure => {\n                 self.sess.span_err(span,\n-                                   format!(\"`{}` inside of a closure\",\n-                                           name).as_slice());\n+                                   format!(\"`{}` inside of a closure\", name)[]);\n             }\n             Normal => {\n                 self.sess.span_err(span,\n-                                   format!(\"`{}` outside of loop\",\n-                                           name).as_slice());\n+                                   format!(\"`{}` outside of loop\", name)[]);\n             }\n         }\n     }"}, {"sha": "da1bd09ceffddcbffc99c71daf513ad76bda9f2c", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -162,7 +162,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n                 // First, check legality of move bindings.\n                 check_legality_of_move_bindings(cx,\n                                                 arm.guard.is_some(),\n-                                                arm.pats.as_slice());\n+                                                arm.pats[]);\n \n                 // Second, if there is a guard on each arm, make sure it isn't\n                 // assigning or borrowing anything mutably.\n@@ -199,7 +199,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n             }\n \n             // Fourth, check for unreachable arms.\n-            check_arms(cx, inlined_arms.as_slice(), source);\n+            check_arms(cx, inlined_arms[], source);\n \n             // Finally, check if the whole match expression is exhaustive.\n             // Check for empty enum, because is_useful only works on inhabited types.\n@@ -231,7 +231,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n                     pat.span,\n                     format!(\"refutable pattern in `for` loop binding: \\\n                             `{}` not covered\",\n-                            pat_to_string(uncovered_pat)).as_slice());\n+                            pat_to_string(uncovered_pat))[]);\n             });\n \n             // Check legality of move bindings.\n@@ -304,7 +304,7 @@ fn check_arms(cx: &MatchCheckCtxt,\n         for pat in pats.iter() {\n             let v = vec![&**pat];\n \n-            match is_useful(cx, &seen, v.as_slice(), LeaveOutWitness) {\n+            match is_useful(cx, &seen, v[], LeaveOutWitness) {\n                 NotUseful => {\n                     match source {\n                         ast::MatchSource::IfLetDesugar { .. } => {\n@@ -356,7 +356,7 @@ fn raw_pat<'a>(p: &'a Pat) -> &'a Pat {\n fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix) {\n     match is_useful(cx, matrix, &[DUMMY_WILD_PAT], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n-            let witness = match pats.as_slice() {\n+            let witness = match pats[] {\n                 [ref witness] => &**witness,\n                 [] => DUMMY_WILD_PAT,\n                 _ => unreachable!()\n@@ -610,7 +610,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n                         UsefulWithWitness(pats) => UsefulWithWitness({\n                             let arity = constructor_arity(cx, &c, left_ty);\n                             let mut result = {\n-                                let pat_slice = pats.as_slice();\n+                                let pat_slice = pats[];\n                                 let subpats = Vec::from_fn(arity, |i| {\n                                     pat_slice.get(i).map_or(DUMMY_WILD_PAT, |p| &**p)\n                                 });\n@@ -657,10 +657,10 @@ fn is_useful_specialized(cx: &MatchCheckCtxt, &Matrix(ref m): &Matrix,\n                          witness: WitnessPreference) -> Usefulness {\n     let arity = constructor_arity(cx, &ctor, lty);\n     let matrix = Matrix(m.iter().filter_map(|r| {\n-        specialize(cx, r.as_slice(), &ctor, 0u, arity)\n+        specialize(cx, r[], &ctor, 0u, arity)\n     }).collect());\n     match specialize(cx, v, &ctor, 0u, arity) {\n-        Some(v) => is_useful(cx, &matrix, v.as_slice(), witness),\n+        Some(v) => is_useful(cx, &matrix, v[], witness),\n         None => NotUseful\n     }\n }\n@@ -1047,7 +1047,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                             format!(\"binding pattern {} is not an \\\n                                      identifier: {}\",\n                                     p.id,\n-                                    p.node).as_slice());\n+                                    p.node)[]);\n                     }\n                 }\n             }"}, {"sha": "6ff34d625005f19807b91fc95e36869ad43d9eeb", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -112,7 +112,7 @@ impl<'a, 'tcx> CheckStaticVisitor<'a, 'tcx> {\n         };\n \n         self.tcx.sess.span_err(e.span, format!(\"mutable statics are not allowed \\\n-                                                to have {}\", suffix).as_slice());\n+                                                to have {}\", suffix)[]);\n     }\n \n     fn check_static_type(&self, e: &ast::Expr) {\n@@ -168,7 +168,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckStaticVisitor<'a, 'tcx> {\n             ty::ty_enum(did, _) if ty::has_dtor(self.tcx, did) => {\n                 self.tcx.sess.span_err(e.span,\n                                        format!(\"{} are not allowed to have \\\n-                                                destructors\", self.msg()).as_slice())\n+                                                destructors\", self.msg())[])\n             }\n             _ => {}\n         }\n@@ -232,7 +232,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckStaticVisitor<'a, 'tcx> {\n                         let msg = \"constants cannot refer to other statics, \\\n                                    insert an intermediate constant \\\n                                    instead\";\n-                        self.tcx.sess.span_err(e.span, msg.as_slice());\n+                        self.tcx.sess.span_err(e.span, msg[]);\n                     }\n                     _ => {}\n                 }"}, {"sha": "c36b4aa7f231e741c9135470c919429d6259b5b6", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -105,7 +105,7 @@ impl<'a, 'ast, 'v> Visitor<'v> for CheckItemRecursionVisitor<'a, 'ast> {\n                           _ => {\n                             self.sess.span_err(e.span,\n                               format!(\"expected item, found {}\",\n-                                      self.ast_map.node_to_string(def_id.node)).as_slice());\n+                                      self.ast_map.node_to_string(def_id.node))[]);\n                             return;\n                           },\n                         }"}, {"sha": "5b89912dd03fcadec6cd0f130a82ad7dc44bf1d7", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -117,7 +117,7 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n                 ast::ItemEnum(ast::EnumDef { ref variants }, _) => {\n-                    variant_expr(variants.as_slice(), variant_def.node)\n+                    variant_expr(variants[], variant_def.node)\n                 }\n                 _ => None\n             },\n@@ -138,7 +138,7 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n                     // NOTE this doesn't do the right thing, it compares inlined\n                     // NodeId's to the original variant_def's NodeId, but they\n                     // come from different crates, so they will likely never match.\n-                    variant_expr(variants.as_slice(), variant_def.node).map(|e| e.id)\n+                    variant_expr(variants[], variant_def.node).map(|e| e.id)\n                 }\n                 _ => None\n             },\n@@ -364,7 +364,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<ast::Pat> {\n pub fn eval_const_expr(tcx: &ty::ctxt, e: &Expr) -> const_val {\n     match eval_const_expr_partial(tcx, e) {\n         Ok(r) => r,\n-        Err(s) => tcx.sess.span_fatal(e.span, s.as_slice())\n+        Err(s) => tcx.sess.span_fatal(e.span, s[])\n     }\n }\n \n@@ -603,7 +603,7 @@ pub fn lit_to_const(lit: &ast::Lit) -> const_val {\n         ast::LitInt(n, ast::UnsignedIntLit(_)) => const_uint(n),\n         ast::LitFloat(ref n, _) |\n         ast::LitFloatUnsuffixed(ref n) => {\n-            const_float(from_str::<f64>(n.get()).unwrap() as f64)\n+            const_float(n.get().parse::<f64>().unwrap() as f64)\n         }\n         ast::LitBool(b) => const_bool(b)\n     }"}, {"sha": "a2d417ca345d8830312762bbffcf30f09d92b83b", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -311,7 +311,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                 let mut t = on_entry.to_vec();\n                 self.apply_gen_kill(cfgidx, t.as_mut_slice());\n                 temp_bits = t;\n-                temp_bits.as_slice()\n+                temp_bits[]\n             }\n         };\n         debug!(\"{} each_bit_for_node({}, cfgidx={}) bits={}\",\n@@ -420,7 +420,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                 let bits = self.kills.slice_mut(start, end);\n                 debug!(\"{} add_kills_from_flow_exits flow_exit={} bits={} [before]\",\n                        self.analysis_name, flow_exit, mut_bits_to_string(bits));\n-                bits.clone_from_slice(orig_kills.as_slice());\n+                bits.clone_from_slice(orig_kills[]);\n                 debug!(\"{} add_kills_from_flow_exits flow_exit={} bits={} [after]\",\n                        self.analysis_name, flow_exit, mut_bits_to_string(bits));\n             }\n@@ -553,7 +553,7 @@ fn bits_to_string(words: &[uint]) -> String {\n         let mut v = word;\n         for _ in range(0u, uint::BYTES) {\n             result.push(sep);\n-            result.push_str(format!(\"{:02x}\", v & 0xFF).as_slice());\n+            result.push_str(format!(\"{:02x}\", v & 0xFF)[]);\n             v >>= 8;\n             sep = '-';\n         }"}, {"sha": "a54bc4a945ae25f29104334a38d8d70e8b57341e", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -20,7 +20,7 @@ use syntax::ast_util::local_def;\n \n use std::cell::RefCell;\n \n-#[deriving(Clone, Copy, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+#[deriving(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n pub enum Def {\n     DefFn(ast::DefId, bool /* is_ctor */),\n     DefStaticMethod(/* method */ ast::DefId, MethodProvenance),\n@@ -73,13 +73,13 @@ pub struct Export {\n     pub def_id: ast::DefId, // The definition of the target.\n }\n \n-#[deriving(Clone, Copy, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+#[deriving(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n pub enum MethodProvenance {\n     FromTrait(ast::DefId),\n     FromImpl(ast::DefId),\n }\n \n-#[deriving(Clone, Copy, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+#[deriving(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n pub enum TyParamProvenance {\n     FromSelf(ast::DefId),\n     FromParam(ast::DefId),"}, {"sha": "6b56ece28bdb2e30968a38e13bbfffc17c316621", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -118,7 +118,7 @@ fn calculate_type(sess: &session::Session,\n                 let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n                 if src.rlib.is_some() { return }\n                 sess.err(format!(\"dependency `{}` not found in rlib format\",\n-                                 data.name).as_slice());\n+                                 data.name)[]);\n             });\n             return Vec::new();\n         }\n@@ -197,7 +197,7 @@ fn calculate_type(sess: &session::Session,\n                                  match kind {\n                                      cstore::RequireStatic => \"rlib\",\n                                      cstore::RequireDynamic => \"dylib\",\n-                                 }).as_slice());\n+                                 })[]);\n             }\n         }\n     }\n@@ -222,7 +222,7 @@ fn add_library(sess: &session::Session,\n                 let data = sess.cstore.get_crate_data(cnum);\n                 sess.err(format!(\"cannot satisfy dependencies so `{}` only \\\n                                   shows up once\",\n-                                 data.name).as_slice());\n+                                 data.name)[]);\n                 sess.help(\"having upstream crates all available in one format \\\n                            will likely make this go away\");\n             }"}, {"sha": "52899aaba412f8f4fdd4f961c4d04b428299b809", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -32,7 +32,7 @@ enum UnsafeContext {\n \n fn type_is_unsafe_function(ty: Ty) -> bool {\n     match ty.sty {\n-        ty::ty_bare_fn(ref f) => f.unsafety == ast::Unsafety::Unsafe,\n+        ty::ty_bare_fn(_, ref f) => f.unsafety == ast::Unsafety::Unsafe,\n         ty::ty_closure(ref f) => f.unsafety == ast::Unsafety::Unsafe,\n         _ => false,\n     }"}, {"sha": "7e31ae04ae083cabd79232e015dcf96502be3d6e", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -678,7 +678,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         self.tcx().sess.span_bug(\n                             callee.span,\n                             format!(\"unexpected callee type {}\",\n-                                    callee_ty.repr(self.tcx())).as_slice())\n+                                    callee_ty.repr(self.tcx()))[])\n                     }\n                 };\n                 match overloaded_call_type {\n@@ -824,10 +824,12 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             None => { }\n             Some(adjustment) => {\n                 match *adjustment {\n-                    ty::AdjustAddEnv(..) => {\n-                        // Creating a closure consumes the input and stores it\n-                        // into the resulting rvalue.\n-                        debug!(\"walk_adjustment(AutoAddEnv)\");\n+                    ty::AdjustAddEnv(..) |\n+                    ty::AdjustReifyFnPointer(..) => {\n+                        // Creating a closure/fn-pointer consumes the\n+                        // input and stores it into the resulting\n+                        // rvalue.\n+                        debug!(\"walk_adjustment(AutoAddEnv|AdjustReifyFnPointer)\");\n                         let cmt_unadjusted =\n                             return_if_err!(self.mc.cat_expr_unadjusted(expr));\n                         self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n@@ -869,7 +871,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         ty::ty_rptr(r, ref m) => (m.mutbl, r),\n                         _ => self.tcx().sess.span_bug(expr.span,\n                                 format!(\"bad overloaded deref type {}\",\n-                                    method_ty.repr(self.tcx())).as_slice())\n+                                    method_ty.repr(self.tcx()))[])\n                     };\n                     let bk = ty::BorrowKind::from_mutbl(m);\n                     self.delegate.borrow(expr.id, expr.span, cmt,\n@@ -1186,7 +1188,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                             // pattern.\n \n                             let msg = format!(\"Pattern has unexpected type: {}\", def);\n-                            tcx.sess.span_bug(pat.span, msg.as_slice())\n+                            tcx.sess.span_bug(pat.span, msg[])\n                         }\n \n                         Some(def) => {\n@@ -1195,7 +1197,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                             // should not resolve.\n \n                             let msg = format!(\"Pattern has unexpected def: {}\", def);\n-                            tcx.sess.span_bug(pat.span, msg.as_slice())\n+                            tcx.sess.span_bug(pat.span, msg[])\n                         }\n                     }\n                 }"}, {"sha": "62cf47da687019317fe1408baabaa5e96216ddda", "filename": "src/librustc/middle/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -83,7 +83,7 @@ pub fn simplify_type(tcx: &ty::ctxt,\n         ty::ty_closure(ref f) => {\n             Some(FunctionSimplifiedType(f.sig.0.inputs.len()))\n         }\n-        ty::ty_bare_fn(ref f) => {\n+        ty::ty_bare_fn(_, ref f) => {\n             Some(FunctionSimplifiedType(f.sig.0.inputs.len()))\n         }\n         ty::ty_param(_) => {"}, {"sha": "ec83b8fae9b7c6d23a2d35f89d7f3d9bdc87d783", "filename": "src/librustc/middle/infer/coercion.rs", "status": "modified", "additions": 66, "deletions": 50, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -84,10 +84,14 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         let Coerce(ref v) = *self; v\n     }\n \n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n+        self.get_ref().infcx.tcx\n+    }\n+\n     pub fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n         debug!(\"Coerce.tys({} => {})\",\n-               a.repr(self.get_ref().infcx.tcx),\n-               b.repr(self.get_ref().infcx.tcx));\n+               a.repr(self.tcx()),\n+               b.repr(self.tcx()));\n \n         // Consider coercing the subtype to a DST\n         let unsize = self.unpack_actual_value(a, |a| {\n@@ -170,13 +174,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         self.unpack_actual_value(a, |a| {\n             match a.sty {\n-                ty::ty_bare_fn(ref a_f) => {\n-                    // Bare functions are coercible to any closure type.\n-                    //\n-                    // FIXME(#3320) this should go away and be\n-                    // replaced with proper inference, got a patch\n-                    // underway - ndm\n-                    self.coerce_from_bare_fn(a, a_f, b)\n+                ty::ty_bare_fn(Some(a_def_id), ref a_f) => {\n+                    // Function items are coercible to any closure\n+                    // type; function pointers are not (that would\n+                    // require double indirection).\n+                    self.coerce_from_fn_item(a, a_def_id, a_f, b)\n                 }\n                 _ => {\n                     // Otherwise, just use subtyping rules.\n@@ -206,8 +208,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                    mutbl_b: ast::Mutability)\n                                    -> CoerceResult<'tcx> {\n         debug!(\"coerce_borrowed_pointer(a={}, b={})\",\n-               a.repr(self.get_ref().infcx.tcx),\n-               b.repr(self.get_ref().infcx.tcx));\n+               a.repr(self.tcx()),\n+               b.repr(self.tcx()));\n \n         // If we have a parameter of type `&M T_a` and the value\n         // provided is `expr`, we will be adding an implicit borrow,\n@@ -227,7 +229,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             }\n         };\n \n-        let a_borrowed = ty::mk_rptr(self.get_ref().infcx.tcx,\n+        let a_borrowed = ty::mk_rptr(self.tcx(),\n                                      r_borrow,\n                                      mt {ty: inner_ty, mutbl: mutbl_b});\n         try!(sub.tys(a_borrowed, b));\n@@ -247,8 +249,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                       b: Ty<'tcx>)\n                       -> CoerceResult<'tcx> {\n         debug!(\"coerce_unsized(a={}, b={})\",\n-               a.repr(self.get_ref().infcx.tcx),\n-               b.repr(self.get_ref().infcx.tcx));\n+               a.repr(self.tcx()),\n+               b.repr(self.tcx()));\n \n         // Note, we want to avoid unnecessary unsizing. We don't want to coerce to\n         // a DST unless we have to. This currently comes out in the wash since\n@@ -268,7 +270,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n                             let coercion = Coercion(self.get_ref().trace.clone());\n                             let r_borrow = self.get_ref().infcx.next_region_var(coercion);\n-                            let ty = ty::mk_rptr(self.get_ref().infcx.tcx,\n+                            let ty = ty::mk_rptr(self.tcx(),\n                                                  r_borrow,\n                                                  ty::mt{ty: ty, mutbl: mt_b.mutbl});\n                             try!(self.get_ref().infcx.try(|_| sub.tys(ty, b)));\n@@ -292,7 +294,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                 return Err(ty::terr_mutability);\n                             }\n \n-                            let ty = ty::mk_ptr(self.get_ref().infcx.tcx,\n+                            let ty = ty::mk_ptr(self.tcx(),\n                                                  ty::mt{ty: ty, mutbl: mt_b.mutbl});\n                             try!(self.get_ref().infcx.try(|_| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n@@ -311,7 +313,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 self.unpack_actual_value(t_a, |a| {\n                     match self.unsize_ty(t_a, a, t_b) {\n                         Some((ty, kind)) => {\n-                            let ty = ty::mk_uniq(self.get_ref().infcx.tcx, ty);\n+                            let ty = ty::mk_uniq(self.tcx(), ty);\n                             try!(self.get_ref().infcx.try(|_| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n                                     AutoUnsizeUniq({}))\", kind);\n@@ -336,9 +338,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                  a: Ty<'tcx>,\n                  ty_b: Ty<'tcx>)\n                  -> Option<(Ty<'tcx>, ty::UnsizeKind<'tcx>)> {\n-        debug!(\"unsize_ty(a={}, ty_b={})\", a, ty_b.repr(self.get_ref().infcx.tcx));\n+        debug!(\"unsize_ty(a={}, ty_b={})\", a, ty_b.repr(self.tcx()));\n \n-        let tcx = self.get_ref().infcx.tcx;\n+        let tcx = self.tcx();\n \n         self.unpack_actual_value(ty_b, |b|\n             match (&a.sty, &b.sty) {\n@@ -412,7 +414,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                               b: Ty<'tcx>,\n                               b_mutbl: ast::Mutability) -> CoerceResult<'tcx>\n     {\n-        let tcx = self.get_ref().infcx.tcx;\n+        let tcx = self.tcx();\n \n         debug!(\"coerce_borrowed_object(a={}, b={}, b_mutbl={})\",\n                a.repr(tcx),\n@@ -431,7 +433,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                             b: Ty<'tcx>,\n                             b_mutbl: ast::Mutability) -> CoerceResult<'tcx>\n     {\n-        let tcx = self.get_ref().infcx.tcx;\n+        let tcx = self.tcx();\n \n         debug!(\"coerce_unsafe_object(a={}, b={}, b_mutbl={})\",\n                a.repr(tcx),\n@@ -451,7 +453,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         F: FnOnce(Ty<'tcx>) -> Ty<'tcx>,\n         G: FnOnce() -> ty::AutoRef<'tcx>,\n     {\n-        let tcx = self.get_ref().infcx.tcx;\n+        let tcx = self.tcx();\n \n         match a.sty {\n             ty::ty_rptr(_, ty::mt{ty, mutbl}) => match ty.sty {\n@@ -480,45 +482,59 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                               b: Ty<'tcx>)\n                               -> CoerceResult<'tcx> {\n         debug!(\"coerce_borrowed_fn(a={}, b={})\",\n-               a.repr(self.get_ref().infcx.tcx),\n-               b.repr(self.get_ref().infcx.tcx));\n+               a.repr(self.tcx()),\n+               b.repr(self.tcx()));\n \n         match a.sty {\n-            ty::ty_bare_fn(ref f) => {\n-                self.coerce_from_bare_fn(a, f, b)\n+            ty::ty_bare_fn(Some(a_def_id), ref f) => {\n+                self.coerce_from_fn_item(a, a_def_id, f, b)\n             }\n             _ => {\n                 self.subtype(a, b)\n             }\n         }\n     }\n \n-    ///  Attempts to coerce from a bare Rust function (`extern \"Rust\" fn`) into a closure or a\n-    ///  `proc`.\n-    fn coerce_from_bare_fn(&self, a: Ty<'tcx>, fn_ty_a: &ty::BareFnTy<'tcx>, b: Ty<'tcx>)\n+    fn coerce_from_fn_item(&self,\n+                           a: Ty<'tcx>,\n+                           fn_def_id_a: ast::DefId,\n+                           fn_ty_a: &ty::BareFnTy<'tcx>,\n+                           b: Ty<'tcx>)\n                            -> CoerceResult<'tcx> {\n+        /*!\n+         * Attempts to coerce from the type of a Rust function item\n+         * into a closure or a `proc`.\n+         */\n+\n         self.unpack_actual_value(b, |b| {\n+            debug!(\"coerce_from_fn_item(a={}, b={})\",\n+                   a.repr(self.tcx()), b.repr(self.tcx()));\n \n-            debug!(\"coerce_from_bare_fn(a={}, b={})\",\n-                   a.repr(self.get_ref().infcx.tcx), b.repr(self.get_ref().infcx.tcx));\n+            match b.sty {\n+                ty::ty_closure(ref f) => {\n+                    if fn_ty_a.abi != abi::Rust || fn_ty_a.unsafety != ast::Unsafety::Normal {\n+                        return self.subtype(a, b);\n+                    }\n \n-            if fn_ty_a.abi != abi::Rust || fn_ty_a.unsafety != ast::Unsafety::Normal {\n-                return self.subtype(a, b);\n+                    let fn_ty_b = (*f).clone();\n+                    let adj = ty::AdjustAddEnv(fn_def_id_a, fn_ty_b.store);\n+                    let a_closure = ty::mk_closure(self.tcx(),\n+                                                   ty::ClosureTy {\n+                                                       sig: fn_ty_a.sig.clone(),\n+                                                       .. *fn_ty_b\n+                                                   });\n+                    try!(self.subtype(a_closure, b));\n+                    Ok(Some(adj))\n+                }\n+                ty::ty_bare_fn(None, _) => {\n+                    let a_fn_pointer = ty::mk_bare_fn(self.tcx(), None, (*fn_ty_a).clone());\n+                    try!(self.subtype(a_fn_pointer, b));\n+                    Ok(Some(ty::AdjustReifyFnPointer(fn_def_id_a)))\n+                }\n+                _ => {\n+                    return self.subtype(a, b)\n+                }\n             }\n-\n-            let fn_ty_b = match b.sty {\n-                ty::ty_closure(ref f) => (*f).clone(),\n-                _ => return self.subtype(a, b)\n-            };\n-\n-            let adj = ty::AdjustAddEnv(fn_ty_b.store);\n-            let a_closure = ty::mk_closure(self.get_ref().infcx.tcx,\n-                                           ty::ClosureTy {\n-                                                sig: fn_ty_a.sig.clone(),\n-                                                .. *fn_ty_b\n-                                           });\n-            try!(self.subtype(a_closure, b));\n-            Ok(Some(adj))\n         })\n     }\n \n@@ -528,8 +544,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                              mutbl_b: ast::Mutability)\n                              -> CoerceResult<'tcx> {\n         debug!(\"coerce_unsafe_ptr(a={}, b={})\",\n-               a.repr(self.get_ref().infcx.tcx),\n-               b.repr(self.get_ref().infcx.tcx));\n+               a.repr(self.tcx()),\n+               b.repr(self.tcx()));\n \n         let mt_a = match a.sty {\n             ty::ty_rptr(_, mt) | ty::ty_ptr(mt) => mt,\n@@ -539,7 +555,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         };\n \n         // Check that the types which they point at are compatible.\n-        let a_unsafe = ty::mk_ptr(self.get_ref().infcx.tcx, ty::mt{ mutbl: mutbl_b, ty: mt_a.ty });\n+        let a_unsafe = ty::mk_ptr(self.tcx(), ty::mt{ mutbl: mutbl_b, ty: mt_a.ty });\n         try!(self.subtype(a_unsafe, b));\n         if !can_coerce_mutbls(mt_a.mutbl, mutbl_b) {\n             return Err(ty::terr_mutability);"}, {"sha": "14687b8fd75c61ef645743eae55ac8f9e74a18e8", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -141,7 +141,7 @@ pub trait Combine<'tcx> {\n                             for _ in a_regions.iter() {\n                                 invariance.push(ty::Invariant);\n                             }\n-                            invariance.as_slice()\n+                            invariance[]\n                         }\n                     };\n \n@@ -411,7 +411,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n             format!(\"{}: bot and var types should have been handled ({},{})\",\n                     this.tag(),\n                     a.repr(this.infcx().tcx),\n-                    b.repr(this.infcx().tcx)).as_slice());\n+                    b.repr(this.infcx().tcx))[]);\n       }\n \n       (&ty::ty_err, _) | (_, &ty::ty_err) => {\n@@ -568,11 +568,12 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n         }\n       }\n \n-      (&ty::ty_bare_fn(ref a_fty), &ty::ty_bare_fn(ref b_fty)) => {\n-        this.bare_fn_tys(a_fty, b_fty).and_then(|fty| {\n-            Ok(ty::mk_bare_fn(tcx, fty))\n-        })\n-      }\n+        (&ty::ty_bare_fn(a_opt_def_id, ref a_fty), &ty::ty_bare_fn(b_opt_def_id, ref b_fty))\n+            if a_opt_def_id == b_opt_def_id =>\n+        {\n+            let fty = try!(this.bare_fn_tys(a_fty, b_fty));\n+            Ok(ty::mk_bare_fn(tcx, a_opt_def_id, fty))\n+        }\n \n       (&ty::ty_closure(ref a_fty), &ty::ty_closure(ref b_fty)) => {\n         this.closure_tys(&**a_fty, &**b_fty).and_then(|fty| {"}, {"sha": "0ea3d415ec5cea47b77dc39092d16a8222b09cb9", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -199,9 +199,9 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                 ref trace_origins,\n                                 ref same_regions) => {\n                     if !same_regions.is_empty() {\n-                        self.report_processed_errors(var_origins.as_slice(),\n-                                                     trace_origins.as_slice(),\n-                                                     same_regions.as_slice());\n+                        self.report_processed_errors(var_origins[],\n+                                                     trace_origins[],\n+                                                     same_regions[]);\n                     }\n                 }\n             }\n@@ -374,7 +374,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             format!(\"{}: {} ({})\",\n                  message_root_str,\n                  expected_found_str,\n-                 ty::type_err_to_str(self.tcx, terr)).as_slice());\n+                 ty::type_err_to_str(self.tcx, terr))[]);\n \n         match trace.origin {\n             infer::MatchExpressionArm(_, arm_span) =>\n@@ -438,13 +438,13 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     origin.span(),\n                     format!(\n                         \"the parameter type `{}` may not live long enough\",\n-                        param_ty.user_string(self.tcx)).as_slice());\n+                        param_ty.user_string(self.tcx))[]);\n                 self.tcx.sess.span_help(\n                     origin.span(),\n                     format!(\n                         \"consider adding an explicit lifetime bound `{}: {}`...\",\n                         param_ty.user_string(self.tcx),\n-                        sub.user_string(self.tcx)).as_slice());\n+                        sub.user_string(self.tcx))[]);\n             }\n \n             ty::ReStatic => {\n@@ -453,12 +453,12 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     origin.span(),\n                     format!(\n                         \"the parameter type `{}` may not live long enough\",\n-                        param_ty.user_string(self.tcx)).as_slice());\n+                        param_ty.user_string(self.tcx))[]);\n                 self.tcx.sess.span_help(\n                     origin.span(),\n                     format!(\n                         \"consider adding an explicit lifetime bound `{}: 'static`...\",\n-                        param_ty.user_string(self.tcx)).as_slice());\n+                        param_ty.user_string(self.tcx))[]);\n             }\n \n             _ => {\n@@ -467,16 +467,16 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     origin.span(),\n                     format!(\n                         \"the parameter type `{}` may not live long enough\",\n-                        param_ty.user_string(self.tcx)).as_slice());\n+                        param_ty.user_string(self.tcx))[]);\n                 self.tcx.sess.span_help(\n                     origin.span(),\n                     format!(\n                         \"consider adding an explicit lifetime bound to `{}`\",\n-                        param_ty.user_string(self.tcx)).as_slice());\n+                        param_ty.user_string(self.tcx))[]);\n                 note_and_explain_region(\n                     self.tcx,\n                     format!(\"the parameter type `{}` must be valid for \",\n-                            param_ty.user_string(self.tcx)).as_slice(),\n+                            param_ty.user_string(self.tcx))[],\n                     sub,\n                     \"...\");\n             }\n@@ -518,7 +518,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                             ty::local_var_name_str(self.tcx,\n                                                    upvar_id.var_id)\n                                 .get()\n-                                .to_string()).as_slice());\n+                                .to_string())[]);\n                 note_and_explain_region(\n                     self.tcx,\n                     \"...the borrowed pointer is valid for \",\n@@ -530,7 +530,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                             ty::local_var_name_str(self.tcx,\n                                                    upvar_id.var_id)\n                                 .get()\n-                                .to_string()).as_slice(),\n+                                .to_string())[],\n                     sup,\n                     \"\");\n             }\n@@ -576,7 +576,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                             outlive the enclosing closure\",\n                             ty::local_var_name_str(self.tcx,\n                                                    id).get()\n-                                                      .to_string()).as_slice());\n+                                                      .to_string())[]);\n                 note_and_explain_region(\n                     self.tcx,\n                     \"captured variable is valid for \",\n@@ -618,7 +618,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     format!(\"the type `{}` does not fulfill the \\\n                              required lifetime\",\n-                            self.ty_to_string(ty)).as_slice());\n+                            self.ty_to_string(ty))[]);\n                 note_and_explain_region(self.tcx,\n                                         \"type must outlive \",\n                                         sub,\n@@ -644,7 +644,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     format!(\"the type `{}` (provided as the value of \\\n                              a type parameter) is not valid at this point\",\n-                            self.ty_to_string(ty)).as_slice());\n+                            self.ty_to_string(ty))[]);\n                 note_and_explain_region(self.tcx,\n                                         \"type must outlive \",\n                                         sub,\n@@ -710,7 +710,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     format!(\"type of expression contains references \\\n                              that are not valid during the expression: `{}`\",\n-                            self.ty_to_string(t)).as_slice());\n+                            self.ty_to_string(t))[]);\n                 note_and_explain_region(\n                     self.tcx,\n                     \"type is only valid for \",\n@@ -732,7 +732,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     format!(\"in type `{}`, reference has a longer lifetime \\\n                              than the data it references\",\n-                            self.ty_to_string(ty)).as_slice());\n+                            self.ty_to_string(ty))[]);\n                 note_and_explain_region(\n                     self.tcx,\n                     \"the pointer is valid for \",\n@@ -857,7 +857,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         let (fn_decl, generics, unsafety, ident, expl_self, span)\n                                     = node_inner.expect(\"expect item fn\");\n         let taken = lifetimes_in_scope(self.tcx, scope_id);\n-        let life_giver = LifeGiver::with_taken(taken.as_slice());\n+        let life_giver = LifeGiver::with_taken(taken[]);\n         let rebuilder = Rebuilder::new(self.tcx, fn_decl, expl_self,\n                                        generics, same_regions, &life_giver);\n         let (fn_decl, expl_self, generics) = rebuilder.rebuild();\n@@ -933,7 +933,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n             }\n             expl_self_opt = self.rebuild_expl_self(expl_self_opt, lifetime,\n                                                    &anon_nums, &region_names);\n-            inputs = self.rebuild_args_ty(inputs.as_slice(), lifetime,\n+            inputs = self.rebuild_args_ty(inputs[], lifetime,\n                                           &anon_nums, &region_names);\n             output = self.rebuild_output(&output, lifetime, &anon_nums, &region_names);\n             ty_params = self.rebuild_ty_params(ty_params, lifetime,\n@@ -968,7 +968,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                 names.push(lt_name);\n             }\n             names.sort();\n-            let name = token::str_to_ident(names[0].as_slice()).name;\n+            let name = token::str_to_ident(names[0][]).name;\n             return (name_to_dummy_lifetime(name), Kept);\n         }\n         return (self.life_giver.give_lifetime(), Fresh);\n@@ -1219,7 +1219,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                                 .sess\n                                 .fatal(format!(\n                                         \"unbound path {}\",\n-                                        pprust::path_to_string(path)).as_slice())\n+                                        pprust::path_to_string(path))[])\n                         }\n                         Some(&d) => d\n                     };\n@@ -1417,7 +1417,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                                               opt_explicit_self, generics);\n         let msg = format!(\"consider using an explicit lifetime \\\n                            parameter as shown: {}\", suggested_fn);\n-        self.tcx.sess.span_help(span, msg.as_slice());\n+        self.tcx.sess.span_help(span, msg[]);\n     }\n \n     fn report_inference_failure(&self,\n@@ -1455,7 +1455,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n             var_origin.span(),\n             format!(\"cannot infer an appropriate lifetime{} \\\n                     due to conflicting requirements\",\n-                    var_description).as_slice());\n+                    var_description)[]);\n     }\n \n     fn note_region_origin(&self, origin: &SubregionOrigin<'tcx>) {\n@@ -1500,7 +1500,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                         self.tcx.sess.span_note(\n                             trace.origin.span(),\n                             format!(\"...so that {} ({})\",\n-                                    desc, values_str).as_slice());\n+                                    desc, values_str)[]);\n                     }\n                     None => {\n                         // Really should avoid printing this error at\n@@ -1509,7 +1509,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                         // doing right now. - nmatsakis\n                         self.tcx.sess.span_note(\n                             trace.origin.span(),\n-                            format!(\"...so that {}\", desc).as_slice());\n+                            format!(\"...so that {}\", desc)[]);\n                     }\n                 }\n             }\n@@ -1526,7 +1526,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                         \"...so that closure can access `{}`\",\n                         ty::local_var_name_str(self.tcx, upvar_id.var_id)\n                             .get()\n-                            .to_string()).as_slice())\n+                            .to_string())[])\n             }\n             infer::InfStackClosure(span) => {\n                 self.tcx.sess.span_note(\n@@ -1551,7 +1551,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                             does not outlive the enclosing closure\",\n                             ty::local_var_name_str(\n                                 self.tcx,\n-                                id).get().to_string()).as_slice());\n+                                id).get().to_string())[]);\n             }\n             infer::IndexSlice(span) => {\n                 self.tcx.sess.span_note(\n@@ -1595,7 +1595,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     format!(\"...so type `{}` of expression is valid during the \\\n                              expression\",\n-                            self.ty_to_string(t)).as_slice());\n+                            self.ty_to_string(t))[]);\n             }\n             infer::BindingTypeIsNotValidAtDecl(span) => {\n                 self.tcx.sess.span_note(\n@@ -1607,28 +1607,28 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     format!(\"...so that the reference type `{}` \\\n                              does not outlive the data it points at\",\n-                            self.ty_to_string(ty)).as_slice());\n+                            self.ty_to_string(ty))[]);\n             }\n             infer::RelateParamBound(span, t) => {\n                 self.tcx.sess.span_note(\n                     span,\n                     format!(\"...so that the type `{}` \\\n                              will meet the declared lifetime bounds\",\n-                            self.ty_to_string(t)).as_slice());\n+                            self.ty_to_string(t))[]);\n             }\n             infer::RelateDefaultParamBound(span, t) => {\n                 self.tcx.sess.span_note(\n                     span,\n                     format!(\"...so that type parameter \\\n                              instantiated with `{}`, \\\n                              will meet its declared lifetime bounds\",\n-                            self.ty_to_string(t)).as_slice());\n+                            self.ty_to_string(t))[]);\n             }\n             infer::RelateRegionParamBound(span) => {\n                 self.tcx.sess.span_note(\n                     span,\n                     format!(\"...so that the declared lifetime parameter bounds \\\n-                                are satisfied\").as_slice());\n+                                are satisfied\")[]);\n             }\n         }\n     }\n@@ -1677,15 +1677,15 @@ fn lifetimes_in_scope(tcx: &ty::ctxt,\n         Some(node) => match node {\n             ast_map::NodeItem(item) => match item.node {\n                 ast::ItemFn(_, _, _, ref gen, _) => {\n-                    taken.push_all(gen.lifetimes.as_slice());\n+                    taken.push_all(gen.lifetimes[]);\n                     None\n                 },\n                 _ => None\n             },\n             ast_map::NodeImplItem(ii) => {\n                 match *ii {\n                     ast::MethodImplItem(ref m) => {\n-                        taken.push_all(m.pe_generics().lifetimes.as_slice());\n+                        taken.push_all(m.pe_generics().lifetimes[]);\n                         Some(m.id)\n                     }\n                     ast::TypeImplItem(_) => None,\n@@ -1744,10 +1744,10 @@ impl LifeGiver {\n         let mut lifetime;\n         loop {\n             let mut s = String::from_str(\"'\");\n-            s.push_str(num_to_string(self.counter.get()).as_slice());\n+            s.push_str(num_to_string(self.counter.get())[]);\n             if !self.taken.contains(&s) {\n                 lifetime = name_to_dummy_lifetime(\n-                                    token::str_to_ident(s.as_slice()).name);\n+                                    token::str_to_ident(s[]).name);\n                 self.generated.borrow_mut().push(lifetime);\n                 break;\n             }"}, {"sha": "2a19f37e7d41514c27792fa87a1aed1886ce23c5", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -189,7 +189,7 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n                 span,\n                 format!(\"region {} is not associated with \\\n                          any bound region from A!\",\n-                        r0).as_slice())\n+                        r0)[])\n         }\n     }\n \n@@ -339,7 +339,7 @@ fn var_ids<'tcx, T: Combine<'tcx>>(combiner: &T,\n             r => {\n                 combiner.infcx().tcx.sess.span_bug(\n                     combiner.trace().origin.span(),\n-                    format!(\"found non-region-vid: {}\", r).as_slice());\n+                    format!(\"found non-region-vid: {}\", r)[]);\n             }\n         }).collect()\n }"}, {"sha": "6d031c8650756affc1734265ebc7eb85f4393214", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -992,7 +992,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n                 self.tcx.sess.span_err(sp, format!(\"{}{}\",\n                     mk_msg(resolved_expected.map(|t| self.ty_to_string(t)), actual_ty),\n-                    error_str).as_slice());\n+                    error_str)[]);\n \n                 for err in err.iter() {\n                     ty::note_and_explain_type_err(self.tcx, *err)"}, {"sha": "0ca1a593ce7fe55491440554e9e7d8d0789e3317", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -60,7 +60,7 @@ pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a,\n     }\n \n     let requested_node : Option<ast::NodeId> =\n-        os::getenv(\"RUST_REGION_GRAPH_NODE\").and_then(|s|from_str(s.as_slice()));\n+        os::getenv(\"RUST_REGION_GRAPH_NODE\").and_then(|s| s.parse());\n \n     if requested_node.is_some() && requested_node != Some(subject_node) {\n         return;"}, {"sha": "661f7e56429ee63d4922a59ded88b8dbcf84dd90", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -464,7 +464,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 origin.span(),\n                 format!(\"cannot relate bound region: {} <= {}\",\n                         sub.repr(self.tcx),\n-                        sup.repr(self.tcx)).as_slice());\n+                        sup.repr(self.tcx))[]);\n           }\n           (_, ReStatic) => {\n             // all regions are subregions of static, so we can ignore this\n@@ -724,7 +724,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             self.tcx.sess.bug(\n                 format!(\"cannot relate bound region: LUB({}, {})\",\n                         a.repr(self.tcx),\n-                        b.repr(self.tcx)).as_slice());\n+                        b.repr(self.tcx))[]);\n           }\n \n           (ReStatic, _) | (_, ReStatic) => {\n@@ -741,7 +741,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 format!(\"lub_concrete_regions invoked with \\\n                          non-concrete regions: {}, {}\",\n                         a,\n-                        b).as_slice());\n+                        b)[]);\n           }\n \n           (ReFree(ref fr), ReScope(s_id)) |\n@@ -824,7 +824,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n               self.tcx.sess.bug(\n                   format!(\"cannot relate bound region: GLB({}, {})\",\n                           a.repr(self.tcx),\n-                          b.repr(self.tcx)).as_slice());\n+                          b.repr(self.tcx))[]);\n             }\n \n             (ReStatic, r) | (r, ReStatic) => {\n@@ -844,7 +844,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     format!(\"glb_concrete_regions invoked with \\\n                              non-concrete regions: {}, {}\",\n                             a,\n-                            b).as_slice());\n+                            b)[]);\n             }\n \n             (ReFree(ref fr), ReScope(s_id)) |\n@@ -965,7 +965,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         self.expansion(var_data.as_mut_slice());\n         self.contraction(var_data.as_mut_slice());\n         let values =\n-            self.extract_values_and_collect_conflicts(var_data.as_slice(),\n+            self.extract_values_and_collect_conflicts(var_data[],\n                                                       errors);\n         self.collect_concrete_region_errors(&values, errors);\n         values\n@@ -1403,7 +1403,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     for var {}, lower_bounds={}, upper_bounds={}\",\n                     node_idx,\n                     lower_bounds.repr(self.tcx),\n-                    upper_bounds.repr(self.tcx)).as_slice());\n+                    upper_bounds.repr(self.tcx))[]);\n     }\n \n     fn collect_error_for_contracting_node(\n@@ -1447,7 +1447,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             format!(\"collect_error_for_contracting_node() could not find error \\\n                      for var {}, upper_bounds={}\",\n                     node_idx,\n-                    upper_bounds.repr(self.tcx)).as_slice());\n+                    upper_bounds.repr(self.tcx))[]);\n     }\n \n     fn collect_concrete_regions(&self,"}, {"sha": "6acbc98b4b27b651ec4f2bb04eb4aea44f381d9a", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -74,7 +74,7 @@ struct IntrinsicCheckingVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n     fn def_id_is_transmute(&self, def_id: DefId) -> bool {\n         let intrinsic = match ty::lookup_item_type(self.tcx, def_id).ty.sty {\n-            ty::ty_bare_fn(ref bfty) => bfty.abi == RustIntrinsic,\n+            ty::ty_bare_fn(_, ref bfty) => bfty.abi == RustIntrinsic,\n             _ => return false\n         };\n         if def_id.krate == ast::LOCAL_CRATE {\n@@ -123,7 +123,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n                 DefFn(did, _) if self.def_id_is_transmute(did) => {\n                     let typ = ty::node_id_to_type(self.tcx, expr.id);\n                     match typ.sty {\n-                        ty_bare_fn(ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {\n+                        ty_bare_fn(_, ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {\n                             if let ty::FnConverging(to) = bare_fn_ty.sig.0.output {\n                                 let from = bare_fn_ty.sig.0.inputs[0];\n                                 self.check_transmute(expr.span, from, to, expr.id);"}, {"sha": "967e7f070c5ae19697571b910e4234f723052c92", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -65,7 +65,7 @@ impl LanguageItems {\n         }\n     }\n \n-    pub fn items<'a>(&'a self) -> Enumerate<slice::Items<'a, Option<ast::DefId>>> {\n+    pub fn items<'a>(&'a self) -> Enumerate<slice::Iter<'a, Option<ast::DefId>>> {\n         self.items.iter().enumerate()\n     }\n "}, {"sha": "798daf8d5410b1634cd591d7892f45052ed7a049", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -323,7 +323,7 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n             self.tcx\n                 .sess\n                 .span_bug(span, format!(\"no variable registered for id {}\",\n-                                        node_id).as_slice());\n+                                        node_id)[]);\n           }\n         }\n     }\n@@ -594,7 +594,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.ir.tcx.sess.span_bug(\n                 span,\n                 format!(\"no live node registered for node {}\",\n-                        node_id).as_slice());\n+                        node_id)[]);\n           }\n         }\n     }\n@@ -1129,7 +1129,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           // Uninteresting cases: just propagate in rev exec order\n \n           ast::ExprVec(ref exprs) => {\n-            self.propagate_through_exprs(exprs.as_slice(), succ)\n+            self.propagate_through_exprs(exprs[], succ)\n           }\n \n           ast::ExprRepeat(ref element, ref count) => {\n@@ -1154,7 +1154,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             } else {\n                 succ\n             };\n-            let succ = self.propagate_through_exprs(args.as_slice(), succ);\n+            let succ = self.propagate_through_exprs(args[], succ);\n             self.propagate_through_expr(&**f, succ)\n           }\n \n@@ -1167,11 +1167,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             } else {\n                 succ\n             };\n-            self.propagate_through_exprs(args.as_slice(), succ)\n+            self.propagate_through_exprs(args[], succ)\n           }\n \n           ast::ExprTup(ref exprs) => {\n-            self.propagate_through_exprs(exprs.as_slice(), succ)\n+            self.propagate_through_exprs(exprs[], succ)\n           }\n \n           ast::ExprBinary(op, ref l, ref r) if ast_util::lazy_binop(op) => {"}, {"sha": "006515ea0a051cd506dbe59a186a3b5fbccb1e65", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -238,7 +238,7 @@ pub fn deref_kind<'tcx>(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>) -> deref_kind {\n       None => {\n         tcx.sess.bug(\n             format!(\"deref_kind() invoked on non-derefable type {}\",\n-                    ty_to_string(tcx, t)).as_slice());\n+                    ty_to_string(tcx, t))[]);\n       }\n     }\n }\n@@ -441,8 +441,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n             Some(adjustment) => {\n                 match *adjustment {\n-                    ty::AdjustAddEnv(..) => {\n-                        debug!(\"cat_expr(AdjustAddEnv): {}\",\n+                    ty::AdjustAddEnv(..) | ty::AdjustReifyFnPointer(..) => {\n+                        debug!(\"cat_expr(AdjustAddEnv|AdjustReifyFnPointer): {}\",\n                                expr.repr(self.tcx()));\n                         // Convert a bare fn to a closure by adding NULL env.\n                         // Result is an rvalue.\n@@ -635,7 +635,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                           span,\n                           format!(\"Upvar of non-closure {} - {}\",\n                                   fn_node_id,\n-                                  ty.repr(self.tcx())).as_slice());\n+                                  ty.repr(self.tcx()))[]);\n                   }\n               }\n           }\n@@ -917,7 +917,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 self.tcx().sess.span_bug(\n                     node.span(),\n                     format!(\"Explicit deref of non-derefable type: {}\",\n-                            base_cmt.ty.repr(self.tcx())).as_slice());\n+                            base_cmt.ty.repr(self.tcx()))[]);\n             }\n         }\n     }\n@@ -996,7 +996,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                         self.tcx().sess.span_bug(\n                             elt.span(),\n                             format!(\"Explicit index of non-index type `{}`\",\n-                                    base_cmt.ty.repr(self.tcx())).as_slice());\n+                                    base_cmt.ty.repr(self.tcx()))[]);\n                     }\n                 }\n             }"}, {"sha": "6f63ae166fe417e7c798572b636f22edd6dbfd69", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -615,10 +615,10 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         match result {\n             None => true,\n             Some((span, msg, note)) => {\n-                self.tcx.sess.span_err(span, msg.as_slice());\n+                self.tcx.sess.span_err(span, msg[]);\n                 match note {\n                     Some((span, msg)) => {\n-                        self.tcx.sess.span_note(span, msg.as_slice())\n+                        self.tcx.sess.span_note(span, msg[])\n                     }\n                     None => {},\n                 }\n@@ -720,7 +720,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             UnnamedField(idx) => format!(\"field #{} of {} is private\",\n                                          idx + 1, struct_desc),\n         };\n-        self.tcx.sess.span_err(span, msg.as_slice());\n+        self.tcx.sess.span_err(span, msg[]);\n     }\n \n     // Given the ID of a method, checks to ensure it's in scope.\n@@ -742,7 +742,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                                              method_id,\n                                              None,\n                                              format!(\"method `{}`\",\n-                                                     string).as_slice()));\n+                                                     string)[]));\n     }\n \n     // Checks that a path is in scope.\n@@ -759,9 +759,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                 self.ensure_public(span,\n                                    def,\n                                    Some(origdid),\n-                                   format!(\"{} `{}`\",\n-                                           tyname,\n-                                           name).as_slice())\n+                                   format!(\"{} `{}`\", tyname, name)[])\n             };\n \n             match self.last_private_map[path_id] {"}, {"sha": "4d83075480bcc0877dda9a089efeb2a46c6fa19c", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -50,7 +50,7 @@ fn generics_require_inlining(generics: &ast::Generics) -> bool {\n // monomorphized or it was marked with `#[inline]`. This will only return\n // true for functions.\n fn item_might_be_inlined(item: &ast::Item) -> bool {\n-    if attributes_specify_inlining(item.attrs.as_slice()) {\n+    if attributes_specify_inlining(item.attrs[]) {\n         return true\n     }\n \n@@ -65,7 +65,7 @@ fn item_might_be_inlined(item: &ast::Item) -> bool {\n \n fn method_might_be_inlined(tcx: &ty::ctxt, method: &ast::Method,\n                            impl_src: ast::DefId) -> bool {\n-    if attributes_specify_inlining(method.attrs.as_slice()) ||\n+    if attributes_specify_inlining(method.attrs[]) ||\n         generics_require_inlining(method.pe_generics()) {\n         return true\n     }\n@@ -202,7 +202,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     ast::MethodImplItem(ref method) => {\n                         if generics_require_inlining(method.pe_generics()) ||\n                                 attributes_specify_inlining(\n-                                    method.attrs.as_slice()) {\n+                                    method.attrs[]) {\n                             true\n                         } else {\n                             let impl_did = self.tcx\n@@ -249,7 +249,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 None => {\n                     self.tcx.sess.bug(format!(\"found unmapped ID in worklist: \\\n                                                {}\",\n-                                              search_item).as_slice())\n+                                              search_item)[])\n                 }\n             }\n         }\n@@ -341,7 +341,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     .bug(format!(\"found unexpected thingy in worklist: {}\",\n                                  self.tcx\n                                      .map\n-                                     .node_to_string(search_item)).as_slice())\n+                                     .node_to_string(search_item))[])\n             }\n         }\n     }"}, {"sha": "8df78281cc227e9bf1f092b400ddf6ddf67d5fbc", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -36,7 +36,8 @@ use syntax::visit::{Visitor, FnKind};\n /// placate the same deriving in `ty::FreeRegion`, but we may want to\n /// actually attach a more meaningful ordering to scopes than the one\n /// generated via deriving here.\n-#[deriving(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, Encodable, Decodable, Show)]\n+#[deriving(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n+           RustcDecodable, Show, Copy)]\n pub enum CodeExtent {\n     Misc(ast::NodeId)\n }"}, {"sha": "28cb80df7713bb49441d6727237611abc959fe42", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -33,7 +33,7 @@ use syntax::visit;\n use syntax::visit::Visitor;\n use util::nodemap::NodeMap;\n \n-#[deriving(Clone, Copy, PartialEq, Eq, Hash, Encodable, Decodable, Show)]\n+#[deriving(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Show)]\n pub enum DefRegion {\n     DefStaticRegion,\n     DefEarlyBoundRegion(/* space */ subst::ParamSpace,\n@@ -409,7 +409,7 @@ impl<'a> LifetimeContext<'a> {\n         self.sess.span_err(\n             lifetime_ref.span,\n             format!(\"use of undeclared lifetime name `{}`\",\n-                    token::get_name(lifetime_ref.name)).as_slice());\n+                    token::get_name(lifetime_ref.name))[]);\n     }\n \n     fn check_lifetime_defs(&mut self, old_scope: Scope, lifetimes: &Vec<ast::LifetimeDef>) {\n@@ -423,7 +423,7 @@ impl<'a> LifetimeContext<'a> {\n                         lifetime.lifetime.span,\n                         format!(\"illegal lifetime parameter name: `{}`\",\n                                 token::get_name(lifetime.lifetime.name))\n-                            .as_slice());\n+                            []);\n                 }\n             }\n \n@@ -437,7 +437,7 @@ impl<'a> LifetimeContext<'a> {\n                         format!(\"lifetime name `{}` declared twice in \\\n                                 the same scope\",\n                                 token::get_name(lifetime_j.lifetime.name))\n-                            .as_slice());\n+                            []);\n                 }\n             }\n "}, {"sha": "6ae639e0313e0adaa7bd8e88b764f42586f649cb", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -18,7 +18,7 @@ use middle::ty_fold::{mod, TypeFoldable, TypeFolder};\n use util::ppaux::Repr;\n \n use std::fmt;\n-use std::slice::Items;\n+use std::slice::Iter;\n use std::vec::Vec;\n use syntax::codemap::{Span, DUMMY_SP};\n \n@@ -187,8 +187,8 @@ impl RegionSubsts {\n ///////////////////////////////////////////////////////////////////////////\n // ParamSpace\n \n-#[deriving(Copy, PartialOrd, Ord, PartialEq, Eq,\n-           Clone, Hash, Encodable, Decodable, Show)]\n+#[deriving(PartialOrd, Ord, PartialEq, Eq, Copy,\n+           Clone, Hash, RustcEncodable, RustcDecodable, Show)]\n pub enum ParamSpace {\n     TypeSpace,  // Type parameters attached to a type definition, trait, or impl\n     SelfSpace,  // Self parameter on a trait\n@@ -224,7 +224,7 @@ impl ParamSpace {\n /// Vector of things sorted by param space. Used to keep\n /// the set of things declared on the type, self, or method\n /// distinct.\n-#[deriving(PartialEq, Eq, Clone, Hash, Encodable, Decodable)]\n+#[deriving(PartialEq, Eq, Clone, Hash, RustcEncodable, RustcDecodable)]\n pub struct VecPerParamSpace<T> {\n     // This was originally represented as a tuple with one Vec<T> for\n     // each variant of ParamSpace, and that remains the abstraction\n@@ -400,7 +400,7 @@ impl<T> VecPerParamSpace<T> {\n         &self.get_slice(space)[index]\n     }\n \n-    pub fn iter<'a>(&'a self) -> Items<'a,T> {\n+    pub fn iter<'a>(&'a self) -> Iter<'a,T> {\n         self.content.iter()\n     }\n \n@@ -620,7 +620,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n                                      (space={}, index={})\",\n                                     region_name.as_str(),\n                                     self.root_ty.repr(self.tcx()),\n-                                    space, i).as_slice());\n+                                    space, i)[]);\n                             }\n                         }\n                 }\n@@ -677,7 +677,7 @@ impl<'a,'tcx> SubstFolder<'a,'tcx> {\n                             p.space,\n                             p.idx,\n                             self.root_ty.repr(self.tcx()),\n-                            self.substs.repr(self.tcx())).as_slice());\n+                            self.substs.repr(self.tcx()))[]);\n             }\n         };\n "}, {"sha": "d48685ce27d89fe6c92d87a4cc8b63c372b59574", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -154,7 +154,7 @@ pub fn ty_is_local<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         ty::ty_err => {\n             tcx.sess.bug(\n                 format!(\"ty_is_local invoked on unexpected type: {}\",\n-                        ty.repr(tcx)).as_slice())\n+                        ty.repr(tcx))[])\n         }\n     }\n }"}, {"sha": "8028971a46346270ba41d91bfa83dae77c25d327", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -19,7 +19,7 @@ use middle::subst;\n use middle::ty::{mod, Ty};\n use middle::infer::InferCtxt;\n use std::rc::Rc;\n-use std::slice::Items;\n+use std::slice::Iter;\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n \n@@ -304,7 +304,7 @@ impl<'tcx> ObligationCause<'tcx> {\n }\n \n impl<'tcx, N> Vtable<'tcx, N> {\n-    pub fn iter_nested(&self) -> Items<N> {\n+    pub fn iter_nested(&self) -> Iter<N> {\n         match *self {\n             VtableImpl(ref i) => i.iter_nested(),\n             VtableFnPointer(..) => (&[]).iter(),\n@@ -338,7 +338,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n }\n \n impl<'tcx, N> VtableImplData<'tcx, N> {\n-    pub fn iter_nested(&self) -> Items<N> {\n+    pub fn iter_nested(&self) -> Iter<N> {\n         self.nested.iter()\n     }\n \n@@ -365,7 +365,7 @@ impl<'tcx, N> VtableImplData<'tcx, N> {\n }\n \n impl<N> VtableBuiltinData<N> {\n-    pub fn iter_nested(&self) -> Items<N> {\n+    pub fn iter_nested(&self) -> Iter<N> {\n         self.nested.iter()\n     }\n "}, {"sha": "f849f4c9b937ef247db7b096c2420ec4c66cc288", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -709,7 +709,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let all_bounds =\n             util::transitive_bounds(\n-                self.tcx(), caller_trait_refs.as_slice());\n+                self.tcx(), caller_trait_refs[]);\n \n         let matching_bounds =\n             all_bounds.filter(\n@@ -762,7 +762,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.tcx().sess.span_bug(\n                     obligation.cause.span,\n                     format!(\"No entry for unboxed closure: {}\",\n-                            closure_def_id.repr(self.tcx())).as_slice());\n+                            closure_def_id.repr(self.tcx()))[]);\n             }\n         };\n \n@@ -795,7 +795,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             // provide an impl, but only for suitable `fn` pointers\n-            ty::ty_bare_fn(ty::BareFnTy {\n+            ty::ty_bare_fn(_, ty::BareFnTy {\n                 unsafety: ast::Unsafety::Normal,\n                 abi: abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n@@ -984,7 +984,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::ty_int(_) |\n             ty::ty_bool |\n             ty::ty_float(_) |\n-            ty::ty_bare_fn(_) |\n+            ty::ty_bare_fn(..) |\n             ty::ty_char => {\n                 // safe for everything\n                 Ok(If(Vec::new()))\n@@ -1281,7 +1281,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.tcx().sess.bug(\n                     format!(\n                         \"asked to assemble builtin bounds of unexpected type: {}\",\n-                        self_ty.repr(self.tcx())).as_slice());\n+                        self_ty.repr(self.tcx()))[]);\n             }\n         };\n \n@@ -1436,7 +1436,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.tcx().sess.span_bug(\n                     obligation.cause.span,\n                     format!(\"builtin bound for {} was ambig\",\n-                            obligation.repr(self.tcx())).as_slice());\n+                            obligation.repr(self.tcx()))[]);\n             }\n         }\n     }\n@@ -1543,7 +1543,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n         let sig = match self_ty.sty {\n-            ty::ty_bare_fn(ty::BareFnTy {\n+            ty::ty_bare_fn(_, ty::BareFnTy {\n                 unsafety: ast::Unsafety::Normal,\n                 abi: abi::Rust,\n                 ref sig\n@@ -1554,7 +1554,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.tcx().sess.span_bug(\n                     obligation.cause.span,\n                     format!(\"Fn pointer candidate for inappropriate self type: {}\",\n-                            self_ty.repr(self.tcx())).as_slice());\n+                            self_ty.repr(self.tcx()))[]);\n             }\n         };\n \n@@ -1595,7 +1595,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.tcx().sess.span_bug(\n                     obligation.cause.span,\n                     format!(\"No entry for unboxed closure: {}\",\n-                            closure_def_id.repr(self.tcx())).as_slice());\n+                            closure_def_id.repr(self.tcx()))[]);\n             }\n         };\n \n@@ -1692,8 +1692,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.tcx().sess.bug(\n                     format!(\"Impl {} was matchable against {} but now is not\",\n                             impl_def_id.repr(self.tcx()),\n-                            obligation.repr(self.tcx()))\n-                        .as_slice());\n+                            obligation.repr(self.tcx()))[]);\n             }\n         }\n     }"}, {"sha": "22fdea8afb59bbcace7efc92f52bb19c1e9f1d4f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 115, "deletions": 70, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -246,7 +246,7 @@ pub struct mt<'tcx> {\n     pub mutbl: ast::Mutability,\n }\n \n-#[deriving(Clone, Copy, PartialEq, Eq, Hash, Encodable, Decodable, Show)]\n+#[deriving(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Show)]\n pub enum TraitStore {\n     /// Box<Trait>\n     UniqTraitStore,\n@@ -277,13 +277,13 @@ pub enum ast_ty_to_ty_cache_entry<'tcx> {\n     atttce_resolved(Ty<'tcx>)  /* resolved to a type, irrespective of region */\n }\n \n-#[deriving(Clone, PartialEq, Decodable, Encodable)]\n+#[deriving(Clone, PartialEq, RustcDecodable, RustcEncodable)]\n pub struct ItemVariances {\n     pub types: VecPerParamSpace<Variance>,\n     pub regions: VecPerParamSpace<Variance>,\n }\n \n-#[deriving(Clone, Copy, PartialEq, Decodable, Encodable, Show)]\n+#[deriving(Clone, PartialEq, RustcDecodable, RustcEncodable, Show, Copy)]\n pub enum Variance {\n     Covariant,      // T<A> <: T<B> iff A <: B -- e.g., function return type\n     Invariant,      // T<A> <: T<B> iff B == A -- e.g., type of mutable cell\n@@ -293,7 +293,8 @@ pub enum Variance {\n \n #[deriving(Clone, Show)]\n pub enum AutoAdjustment<'tcx> {\n-    AdjustAddEnv(ty::TraitStore),\n+    AdjustAddEnv(ast::DefId, ty::TraitStore),\n+    AdjustReifyFnPointer(ast::DefId), // go from a fn-item type to a fn-pointer type\n     AdjustDerefRef(AutoDerefRef<'tcx>)\n }\n \n@@ -430,7 +431,7 @@ pub fn type_of_adjust<'tcx>(cx: &ctxt<'tcx>, adj: &AutoAdjustment<'tcx>) -> Opti\n     }\n }\n \n-#[deriving(Clone, Copy, Encodable, Decodable, PartialEq, PartialOrd, Show)]\n+#[deriving(Clone, Copy, RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Show)]\n pub struct param_index {\n     pub space: subst::ParamSpace,\n     pub index: uint\n@@ -510,7 +511,7 @@ pub struct MethodCall {\n     pub adjustment: ExprAdjustment\n }\n \n-#[deriving(Clone, Copy, PartialEq, Eq, Hash, Show, Encodable, Decodable)]\n+#[deriving(Clone, PartialEq, Eq, Hash, Show, RustcEncodable, RustcDecodable, Copy)]\n pub enum ExprAdjustment {\n     NoAdjustment,\n     AutoDeref(uint),\n@@ -973,15 +974,15 @@ pub struct ParamTy {\n /// is the outer fn.\n ///\n /// [dbi]: http://en.wikipedia.org/wiki/De_Bruijn_index\n-#[deriving(Clone, Copy, PartialEq, Eq, Hash, Encodable, Decodable, Show)]\n+#[deriving(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Show, Copy)]\n pub struct DebruijnIndex {\n     // We maintain the invariant that this is never 0. So 1 indicates\n     // the innermost binder. To ensure this, create with `DebruijnIndex::new`.\n     pub depth: uint,\n }\n \n /// Representation of regions:\n-#[deriving(Clone, Copy, PartialEq, Eq, Hash, Encodable, Decodable, Show)]\n+#[deriving(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Show, Copy)]\n pub enum Region {\n     // Region bound in a type or fn declaration which will be\n     // substituted 'early' -- that is, at the same time when type\n@@ -1028,7 +1029,7 @@ pub struct UpvarId {\n     pub closure_expr_id: ast::NodeId,\n }\n \n-#[deriving(Clone, Copy, PartialEq, Eq, Hash, Show, Encodable, Decodable)]\n+#[deriving(Clone, PartialEq, Eq, Hash, Show, RustcEncodable, RustcDecodable, Copy)]\n pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n     ImmBorrow,\n@@ -1121,7 +1122,7 @@ pub enum BorrowKind {\n /// - Through mutation, the borrowed upvars can actually escape\n ///   the closure, so sometimes it is necessary for them to be larger\n ///   than the closure lifetime itself.\n-#[deriving(Copy, PartialEq, Clone, Encodable, Decodable, Show)]\n+#[deriving(PartialEq, Clone, RustcEncodable, RustcDecodable, Show, Copy)]\n pub struct UpvarBorrow {\n     pub kind: BorrowKind,\n     pub region: ty::Region,\n@@ -1146,15 +1147,17 @@ impl Region {\n     }\n }\n \n-#[deriving(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, Encodable, Decodable, Show)]\n+#[deriving(Clone, PartialEq, PartialOrd, Eq, Ord, Hash,\n+           RustcEncodable, RustcDecodable, Show, Copy)]\n /// A \"free\" region `fr` can be interpreted as \"some region\n /// at least as big as the scope `fr.scope`\".\n pub struct FreeRegion {\n     pub scope: region::CodeExtent,\n     pub bound_region: BoundRegion\n }\n \n-#[deriving(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, Encodable, Decodable, Show)]\n+#[deriving(Clone, PartialEq, PartialOrd, Eq, Ord, Hash,\n+           RustcEncodable, RustcDecodable, Show, Copy)]\n pub enum BoundRegion {\n     /// An anonymous region parameter for a given fn (&T)\n     BrAnon(uint),\n@@ -1243,11 +1246,17 @@ pub enum sty<'tcx> {\n     ty_vec(Ty<'tcx>, Option<uint>), // Second field is length.\n     ty_ptr(mt<'tcx>),\n     ty_rptr(Region, mt<'tcx>),\n-    ty_bare_fn(BareFnTy<'tcx>),\n+\n+    // If the def-id is Some(_), then this is the type of a specific\n+    // fn item. Otherwise, if None(_), it a fn pointer type.\n+    ty_bare_fn(Option<DefId>, BareFnTy<'tcx>),\n+\n     ty_closure(Box<ClosureTy<'tcx>>),\n     ty_trait(Box<TyTrait<'tcx>>),\n     ty_struct(DefId, Substs<'tcx>),\n+\n     ty_unboxed_closure(DefId, Region, Substs<'tcx>),\n+\n     ty_tup(Vec<Ty<'tcx>>),\n \n     ty_param(ParamTy), // type parameter\n@@ -1412,7 +1421,8 @@ pub struct ExistentialBounds {\n \n pub type BuiltinBounds = EnumSet<BuiltinBound>;\n \n-#[deriving(Copy, Clone, Encodable, PartialEq, Eq, Decodable, Hash, Show)]\n+#[deriving(Clone, RustcEncodable, PartialEq, Eq, RustcDecodable, Hash,\n+           Show, Copy)]\n #[repr(uint)]\n pub enum BuiltinBound {\n     BoundSend,\n@@ -1463,7 +1473,7 @@ pub struct FloatVid {\n     pub index: uint\n }\n \n-#[deriving(Clone, Copy, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct RegionVid {\n     pub index: uint\n }\n@@ -1485,7 +1495,7 @@ pub enum InferTy {\n     FreshIntTy(uint),\n }\n \n-#[deriving(Clone, Copy, Encodable, Decodable, Eq, Hash, Show)]\n+#[deriving(Clone, RustcEncodable, RustcDecodable, Eq, Hash, Show, Copy)]\n pub enum InferRegion {\n     ReVar(RegionVid),\n     ReSkolemized(uint, BoundRegion)\n@@ -1571,7 +1581,7 @@ pub struct TypeParameterDef<'tcx> {\n     pub default: Option<Ty<'tcx>>,\n }\n \n-#[deriving(Encodable, Decodable, Clone, Show)]\n+#[deriving(RustcEncodable, RustcDecodable, Clone, Show)]\n pub struct RegionParameterDef {\n     pub name: ast::Name,\n     pub def_id: ast::DefId,\n@@ -1891,7 +1901,7 @@ impl<'tcx> ParameterEnvironment<'tcx> {\n             _ => {\n                 cx.sess.bug(format!(\"ParameterEnvironment::from_item(): \\\n                                      `{}` is not an item\",\n-                                    cx.map.node_to_string(id)).as_slice())\n+                                    cx.map.node_to_string(id))[])\n             }\n         }\n     }\n@@ -1960,7 +1970,7 @@ impl UnboxedClosureKind {\n         };\n         match result {\n             Ok(trait_did) => trait_did,\n-            Err(err) => cx.sess.fatal(err.as_slice()),\n+            Err(err) => cx.sess.fatal(err[]),\n         }\n     }\n }\n@@ -2178,7 +2188,7 @@ impl FlagComputation {\n                 self.add_tys(ts[]);\n             }\n \n-            &ty_bare_fn(ref f) => {\n+            &ty_bare_fn(_, ref f) => {\n                 self.add_fn_sig(&f.sig);\n             }\n \n@@ -2339,15 +2349,19 @@ pub fn mk_closure<'tcx>(cx: &ctxt<'tcx>, fty: ClosureTy<'tcx>) -> Ty<'tcx> {\n     mk_t(cx, ty_closure(box fty))\n }\n \n-pub fn mk_bare_fn<'tcx>(cx: &ctxt<'tcx>, fty: BareFnTy<'tcx>) -> Ty<'tcx> {\n-    mk_t(cx, ty_bare_fn(fty))\n+pub fn mk_bare_fn<'tcx>(cx: &ctxt<'tcx>,\n+                        opt_def_id: Option<ast::DefId>,\n+                        fty: BareFnTy<'tcx>) -> Ty<'tcx> {\n+    mk_t(cx, ty_bare_fn(opt_def_id, fty))\n }\n \n pub fn mk_ctor_fn<'tcx>(cx: &ctxt<'tcx>,\n+                        def_id: ast::DefId,\n                         input_tys: &[Ty<'tcx>],\n                         output: Ty<'tcx>) -> Ty<'tcx> {\n     let input_args = input_tys.iter().map(|ty| *ty).collect();\n     mk_bare_fn(cx,\n+               Some(def_id),\n                BareFnTy {\n                    unsafety: ast::Unsafety::Normal,\n                    abi: abi::Rust,\n@@ -2446,7 +2460,7 @@ pub fn maybe_walk_ty<'tcx>(ty: Ty<'tcx>, f: |Ty<'tcx>| -> bool) {\n             }\n         }\n         ty_tup(ref ts) => { for tt in ts.iter() { maybe_walk_ty(*tt, |x| f(x)); } }\n-        ty_bare_fn(ref ft) => {\n+        ty_bare_fn(_, ref ft) => {\n             for a in ft.sig.0.inputs.iter() { maybe_walk_ty(*a, |x| f(x)); }\n             if let ty::FnConverging(output) = ft.sig.0.output {\n                 maybe_walk_ty(output, f);\n@@ -2596,7 +2610,7 @@ pub fn sequence_element_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n         ty_str => mk_mach_uint(ast::TyU8),\n         ty_open(ty) => sequence_element_type(cx, ty),\n         _ => cx.sess.bug(format!(\"sequence_element_type called on non-sequence value: {}\",\n-                                 ty_to_string(cx, ty)).as_slice()),\n+                                 ty_to_string(cx, ty))[]),\n     }\n }\n \n@@ -2929,7 +2943,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n             // Scalar and unique types are sendable, and durable\n             ty_infer(ty::FreshIntTy(_)) |\n             ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n-            ty_bare_fn(_) | ty::ty_char => {\n+            ty_bare_fn(..) | ty::ty_char => {\n                 TC::None\n             }\n \n@@ -2972,7 +2986,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n             ty_struct(did, ref substs) => {\n                 let flds = struct_fields(cx, did, substs);\n                 let mut res =\n-                    TypeContents::union(flds.as_slice(),\n+                    TypeContents::union(flds[],\n                                         |f| tc_mt(cx, f.mt, cache));\n \n                 if !lookup_repr_hints(cx, did).contains(&attr::ReprExtern) {\n@@ -2989,21 +3003,21 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n                 // FIXME(#14449): `borrowed_contents` below assumes `&mut`\n                 // unboxed closure.\n                 let upvars = unboxed_closure_upvars(cx, did, substs);\n-                TypeContents::union(upvars.as_slice(),\n+                TypeContents::union(upvars[],\n                                     |f| tc_ty(cx, f.ty, cache)) |\n                     borrowed_contents(r, MutMutable)\n             }\n \n             ty_tup(ref tys) => {\n-                TypeContents::union(tys.as_slice(),\n+                TypeContents::union(tys[],\n                                     |ty| tc_ty(cx, *ty, cache))\n             }\n \n             ty_enum(did, ref substs) => {\n                 let variants = substd_enum_variants(cx, did, substs);\n                 let mut res =\n-                    TypeContents::union(variants.as_slice(), |variant| {\n-                        TypeContents::union(variant.args.as_slice(),\n+                    TypeContents::union(variants[], |variant| {\n+                        TypeContents::union(variant.args[],\n                                             |arg_ty| {\n                             tc_ty(cx, *arg_ty, cache)\n                         })\n@@ -3068,7 +3082,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n                 kind_bounds_to_contents(\n                     cx,\n                     tp_def.bounds.builtin_bounds,\n-                    tp_def.bounds.trait_bounds.as_slice())\n+                    tp_def.bounds.trait_bounds[])\n             }\n \n             ty_infer(_) => {\n@@ -3264,7 +3278,7 @@ pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n             ty_uint(_) |\n             ty_float(_) |\n             ty_str |\n-            ty_bare_fn(_) |\n+            ty_bare_fn(..) |\n             ty_closure(_) |\n             ty_infer(_) |\n             ty_err |\n@@ -3560,6 +3574,13 @@ pub fn type_is_bare_fn(ty: Ty) -> bool {\n     }\n }\n \n+pub fn type_is_bare_fn_item(ty: Ty) -> bool {\n+    match ty.sty {\n+        ty_bare_fn(Some(_), _) => true,\n+        _ => false\n+    }\n+}\n+\n pub fn type_is_fp(ty: Ty) -> bool {\n     match ty.sty {\n       ty_infer(FloatVar(_)) | ty_float(_) => true,\n@@ -3658,7 +3679,7 @@ pub fn close_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     match ty.sty {\n         ty_open(ty) => mk_rptr(cx, ReStatic, mt {ty: ty, mutbl:ast::MutImmutable}),\n         _ => cx.sess.bug(format!(\"Trying to close a non-open type {}\",\n-                                 ty_to_string(cx, ty)).as_slice())\n+                                 ty_to_string(cx, ty))[])\n     }\n }\n \n@@ -3759,7 +3780,7 @@ pub fn node_id_to_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId)\n         Some(ty) => ty.clone(),\n         None => cx.sess.bug(\n             format!(\"node_id_to_trait_ref: no trait ref for node `{}`\",\n-                    cx.map.node_to_string(id)).as_slice())\n+                    cx.map.node_to_string(id))[])\n     }\n }\n \n@@ -3772,7 +3793,7 @@ pub fn node_id_to_type<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId) -> Ty<'tcx> {\n        Some(ty) => ty,\n        None => cx.sess.bug(\n            format!(\"node_id_to_type: no type for node `{}`\",\n-                   cx.map.node_to_string(id)).as_slice())\n+                   cx.map.node_to_string(id))[])\n     }\n }\n \n@@ -3792,7 +3813,7 @@ pub fn node_id_item_substs<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId) -> ItemSubsts\n \n pub fn fn_is_variadic(fty: Ty) -> bool {\n     match fty.sty {\n-        ty_bare_fn(ref f) => f.sig.0.variadic,\n+        ty_bare_fn(_, ref f) => f.sig.0.variadic,\n         ty_closure(ref f) => f.sig.0.variadic,\n         ref s => {\n             panic!(\"fn_is_variadic() called on non-fn type: {}\", s)\n@@ -3802,7 +3823,7 @@ pub fn fn_is_variadic(fty: Ty) -> bool {\n \n pub fn ty_fn_sig<'tcx>(fty: Ty<'tcx>) -> &'tcx PolyFnSig<'tcx> {\n     match fty.sty {\n-        ty_bare_fn(ref f) => &f.sig,\n+        ty_bare_fn(_, ref f) => &f.sig,\n         ty_closure(ref f) => &f.sig,\n         ref s => {\n             panic!(\"ty_fn_sig() called on non-fn type: {}\", s)\n@@ -3813,7 +3834,7 @@ pub fn ty_fn_sig<'tcx>(fty: Ty<'tcx>) -> &'tcx PolyFnSig<'tcx> {\n /// Returns the ABI of the given function.\n pub fn ty_fn_abi(fty: Ty) -> abi::Abi {\n     match fty.sty {\n-        ty_bare_fn(ref f) => f.abi,\n+        ty_bare_fn(_, ref f) => f.abi,\n         ty_closure(ref f) => f.abi,\n         _ => panic!(\"ty_fn_abi() called on non-fn type\"),\n     }\n@@ -3840,7 +3861,7 @@ pub fn ty_closure_store(fty: Ty) -> TraitStore {\n \n pub fn ty_fn_ret<'tcx>(fty: Ty<'tcx>) -> FnOutput<'tcx> {\n     match fty.sty {\n-        ty_bare_fn(ref f) => f.sig.0.output,\n+        ty_bare_fn(_, ref f) => f.sig.0.output,\n         ty_closure(ref f) => f.sig.0.output,\n         ref s => {\n             panic!(\"ty_fn_ret() called on non-fn type: {}\", s)\n@@ -3850,7 +3871,7 @@ pub fn ty_fn_ret<'tcx>(fty: Ty<'tcx>) -> FnOutput<'tcx> {\n \n pub fn is_fn_ty(fty: Ty) -> bool {\n     match fty.sty {\n-        ty_bare_fn(_) => true,\n+        ty_bare_fn(..) => true,\n         ty_closure(_) => true,\n         _ => false\n     }\n@@ -3865,7 +3886,7 @@ pub fn ty_region(tcx: &ctxt,\n             tcx.sess.span_bug(\n                 span,\n                 format!(\"ty_region() invoked on an inappropriate ty: {}\",\n-                        s).as_slice());\n+                        s)[]);\n         }\n     }\n }\n@@ -3926,11 +3947,11 @@ pub fn expr_span(cx: &ctxt, id: NodeId) -> Span {\n         Some(f) => {\n             cx.sess.bug(format!(\"Node id {} is not an expr: {}\",\n                                 id,\n-                                f).as_slice());\n+                                f)[]);\n         }\n         None => {\n             cx.sess.bug(format!(\"Node id {} is not present \\\n-                                in the node map\", id).as_slice());\n+                                in the node map\", id)[]);\n         }\n     }\n }\n@@ -3946,14 +3967,14 @@ pub fn local_var_name_str(cx: &ctxt, id: NodeId) -> InternedString {\n                     cx.sess.bug(\n                         format!(\"Variable id {} maps to {}, not local\",\n                                 id,\n-                                pat).as_slice());\n+                                pat)[]);\n                 }\n             }\n         }\n         r => {\n             cx.sess.bug(format!(\"Variable id {} maps to {}, not local\",\n                                 id,\n-                                r).as_slice());\n+                                r)[]);\n         }\n     }\n }\n@@ -3975,9 +3996,9 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n     return match adjustment {\n         Some(adjustment) => {\n             match *adjustment {\n-                AdjustAddEnv(store) => {\n+                AdjustAddEnv(_, store) => {\n                     match unadjusted_ty.sty {\n-                        ty::ty_bare_fn(ref b) => {\n+                        ty::ty_bare_fn(Some(_), ref b) => {\n                             let bounds = ty::ExistentialBounds {\n                                 region_bound: ReStatic,\n                                 builtin_bounds: all_builtin_bounds(),\n@@ -3994,13 +4015,27 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                         }\n                         ref b => {\n                             cx.sess.bug(\n-                                format!(\"add_env adjustment on non-bare-fn: \\\n+                                format!(\"add_env adjustment on non-fn-item: \\\n                                          {}\",\n                                         b).as_slice());\n                         }\n                     }\n                 }\n \n+                AdjustReifyFnPointer(_) => {\n+                    match unadjusted_ty.sty {\n+                        ty::ty_bare_fn(Some(_), ref b) => {\n+                            ty::mk_bare_fn(cx, None, (*b).clone())\n+                        }\n+                        ref b => {\n+                            cx.sess.bug(\n+                                format!(\"AdjustReifyFnPointer adjustment on non-fn-item: \\\n+                                         {}\",\n+                                        b)[]);\n+                        }\n+                    }\n+                }\n+\n                 AdjustDerefRef(ref adj) => {\n                     let mut adjusted_ty = unadjusted_ty;\n \n@@ -4024,7 +4059,7 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                                                 {}\",\n                                                 i,\n                                                 ty_to_string(cx, adjusted_ty))\n-                                                          .as_slice());\n+                                                          []);\n                                 }\n                             }\n                         }\n@@ -4087,7 +4122,7 @@ pub fn unsize_ty<'tcx>(cx: &ctxt<'tcx>,\n             }\n             _ => cx.sess.span_bug(span,\n                                   format!(\"UnsizeLength with bad sty: {}\",\n-                                          ty_to_string(cx, ty)).as_slice())\n+                                          ty_to_string(cx, ty))[])\n         },\n         &UnsizeStruct(box ref k, tp_index) => match ty.sty {\n             ty_struct(did, ref substs) => {\n@@ -4099,7 +4134,7 @@ pub fn unsize_ty<'tcx>(cx: &ctxt<'tcx>,\n             }\n             _ => cx.sess.span_bug(span,\n                                   format!(\"UnsizeStruct with bad sty: {}\",\n-                                          ty_to_string(cx, ty)).as_slice())\n+                                          ty_to_string(cx, ty))[])\n         },\n         &UnsizeVtable(TyTrait { ref principal, bounds }, _) => {\n             mk_trait(cx, (*principal).clone(), bounds)\n@@ -4112,7 +4147,7 @@ pub fn resolve_expr(tcx: &ctxt, expr: &ast::Expr) -> def::Def {\n         Some(&def) => def,\n         None => {\n             tcx.sess.span_bug(expr.span, format!(\n-                \"no def-map entry for expr {}\", expr.id).as_slice());\n+                \"no def-map entry for expr {}\", expr.id)[]);\n         }\n     }\n }\n@@ -4206,7 +4241,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n                         expr.span,\n                         format!(\"uncategorized def for expr {}: {}\",\n                                 expr.id,\n-                                def).as_slice());\n+                                def)[]);\n                 }\n             }\n         }\n@@ -4331,7 +4366,7 @@ pub fn field_idx_strict(tcx: &ctxt, name: ast::Name, fields: &[field])\n         token::get_name(name),\n         fields.iter()\n               .map(|f| token::get_name(f.name).get().to_string())\n-              .collect::<Vec<String>>()).as_slice());\n+              .collect::<Vec<String>>())[]);\n }\n \n pub fn impl_or_trait_item_idx(id: ast::Name, trait_items: &[ImplOrTraitItem])\n@@ -4353,7 +4388,8 @@ pub fn ty_sort_string<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> String {\n         ty_vec(_, None) => \"slice\".to_string(),\n         ty_ptr(_) => \"*-ptr\".to_string(),\n         ty_rptr(_, _) => \"&-ptr\".to_string(),\n-        ty_bare_fn(_) => \"extern fn\".to_string(),\n+        ty_bare_fn(Some(_), _) => format!(\"fn item\"),\n+        ty_bare_fn(None, _) => \"fn pointer\".to_string(),\n         ty_closure(_) => \"fn\".to_string(),\n         ty_trait(ref inner) => {\n             format!(\"trait {}\", item_path_str(cx, inner.principal.def_id()))\n@@ -4544,6 +4580,10 @@ pub fn note_and_explain_type_err(cx: &ctxt, err: &type_err) {\n                                     \"concrete lifetime that was found is \",\n                                     conc_region, \"\");\n         }\n+        terr_regions_overly_polymorphic(_, ty::ReInfer(ty::ReVar(_))) => {\n+            // don't bother to print out the message below for\n+            // inference variables, it's not very illuminating.\n+        }\n         terr_regions_overly_polymorphic(_, conc_region) => {\n             note_and_explain_region(cx,\n                                     \"expected concrete lifetime is \",\n@@ -4565,7 +4605,7 @@ pub fn provided_trait_methods<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                 match item.node {\n                     ItemTrait(_, _, _, _, ref ms) => {\n                         let (_, p) =\n-                            ast_util::split_trait_methods(ms.as_slice());\n+                            ast_util::split_trait_methods(ms[]);\n                         p.iter()\n                          .map(|m| {\n                             match impl_or_trait_item(\n@@ -4584,14 +4624,14 @@ pub fn provided_trait_methods<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                     _ => {\n                         cx.sess.bug(format!(\"provided_trait_methods: `{}` is \\\n                                              not a trait\",\n-                                            id).as_slice())\n+                                            id)[])\n                     }\n                 }\n             }\n             _ => {\n                 cx.sess.bug(format!(\"provided_trait_methods: `{}` is not a \\\n                                      trait\",\n-                                    id).as_slice())\n+                                    id)[])\n             }\n         }\n     } else {\n@@ -4827,7 +4867,7 @@ impl<'tcx> VariantInfo<'tcx> {\n             },\n             ast::StructVariantKind(ref struct_def) => {\n \n-                let fields: &[StructField] = struct_def.fields.as_slice();\n+                let fields: &[StructField] = struct_def.fields[];\n \n                 assert!(fields.len() > 0);\n \n@@ -4978,7 +5018,7 @@ pub fn enum_variants<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                                                 cx.sess\n                                                   .span_err(e.span,\n                                                             format!(\"expected constant: {}\",\n-                                                                    *err).as_slice());\n+                                                                    *err)[]);\n                                             }\n                                         },\n                                     None => {}\n@@ -5258,7 +5298,7 @@ pub fn lookup_struct_fields(cx: &ctxt, did: ast::DefId) -> Vec<field_ty> {\n             _ => {\n                 cx.sess.bug(\n                     format!(\"ID not mapped to struct fields: {}\",\n-                            cx.map.node_to_string(did.node)).as_slice());\n+                            cx.map.node_to_string(did.node))[]);\n             }\n         }\n     } else {\n@@ -5291,7 +5331,7 @@ pub fn struct_fields<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId, substs: &Substs<'tc\n pub fn tup_fields<'tcx>(v: &[Ty<'tcx>]) -> Vec<field<'tcx>> {\n     v.iter().enumerate().map(|(i, &f)| {\n        field {\n-            name: token::intern(i.to_string().as_slice()),\n+            name: token::intern(i.to_string()[]),\n             mt: mt {\n                 ty: f,\n                 mutbl: MutImmutable\n@@ -5470,7 +5510,7 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n             };\n             tcx.sess.span_err(count_expr.span, format!(\n                 \"expected positive integer for repeat count, found {}\",\n-                found).as_slice());\n+                found)[]);\n         }\n         Err(_) => {\n             let found = match count_expr.node {\n@@ -5485,7 +5525,7 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n             };\n             tcx.sess.span_err(count_expr.span, format!(\n                 \"expected constant integer for repeat count, found {}\",\n-                found).as_slice());\n+                found)[]);\n         }\n     }\n     0\n@@ -5884,8 +5924,9 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n                     region(state, r);\n                     mt(state, m);\n                 }\n-                ty_bare_fn(ref b) => {\n+                ty_bare_fn(opt_def_id, ref b) => {\n                     byte!(14);\n+                    hash!(opt_def_id);\n                     hash!(b.unsafety);\n                     hash!(b.abi);\n                     fn_sig(state, &b.sig);\n@@ -6200,7 +6241,7 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n             ty_str |\n             ty_vec(_, _) |\n             ty_ptr(_) |\n-            ty_bare_fn(_) |\n+            ty_bare_fn(..) |\n             ty_tup(_) |\n             ty_param(_) |\n             ty_infer(_) |\n@@ -6223,7 +6264,7 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n }\n \n /// A free variable referred to in a function.\n-#[deriving(Copy, Encodable, Decodable)]\n+#[deriving(Copy, RustcEncodable, RustcDecodable)]\n pub struct Freevar {\n     /// The variable being accessed free.\n     pub def: def::Def,\n@@ -6244,14 +6285,15 @@ pub fn with_freevars<T, F>(tcx: &ty::ctxt, fid: ast::NodeId, f: F) -> T where\n {\n     match tcx.freevars.borrow().get(&fid) {\n         None => f(&[]),\n-        Some(d) => f(d.as_slice())\n+        Some(d) => f(d[])\n     }\n }\n \n impl<'tcx> AutoAdjustment<'tcx> {\n     pub fn is_identity(&self) -> bool {\n         match *self {\n             AdjustAddEnv(..) => false,\n+            AdjustReifyFnPointer(..) => false,\n             AdjustDerefRef(ref r) => r.is_identity(),\n         }\n     }\n@@ -6367,8 +6409,11 @@ impl DebruijnIndex {\n impl<'tcx> Repr<'tcx> for AutoAdjustment<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         match *self {\n-            AdjustAddEnv(ref trait_store) => {\n-                format!(\"AdjustAddEnv({})\", trait_store)\n+            AdjustAddEnv(def_id, ref trait_store) => {\n+                format!(\"AdjustAddEnv({},{})\", def_id.repr(tcx), trait_store)\n+            }\n+            AdjustReifyFnPointer(def_id) => {\n+                format!(\"AdjustAddEnv({})\", def_id.repr(tcx))\n             }\n             AdjustDerefRef(ref data) => {\n                 data.repr(tcx)"}, {"sha": "a35ea30b217913ac4e789ef1062620250570b66f", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -538,8 +538,8 @@ pub fn super_fold_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n         ty::ty_tup(ref ts) => {\n             ty::ty_tup(ts.fold_with(this))\n         }\n-        ty::ty_bare_fn(ref f) => {\n-            ty::ty_bare_fn(f.fold_with(this))\n+        ty::ty_bare_fn(opt_def_id, ref f) => {\n+            ty::ty_bare_fn(opt_def_id, f.fold_with(this))\n         }\n         ty::ty_closure(ref f) => {\n             ty::ty_closure(box f.fold_with(this))"}, {"sha": "a2e334543206cc68ea6ed35e75639b9f3f64e246", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -141,17 +141,17 @@ impl<'a> PluginLoader<'a> {\n             // this is fatal: there are almost certainly macros we need\n             // inside this crate, so continue would spew \"macro undefined\"\n             // errors\n-            Err(err) => self.sess.span_fatal(vi.span, err.as_slice())\n+            Err(err) => self.sess.span_fatal(vi.span, err[])\n         };\n \n         unsafe {\n             let registrar =\n-                match lib.symbol(symbol.as_slice()) {\n+                match lib.symbol(symbol[]) {\n                     Ok(registrar) => {\n                         mem::transmute::<*mut u8,PluginRegistrarFun>(registrar)\n                     }\n                     // again fatal if we can't register macros\n-                    Err(err) => self.sess.span_fatal(vi.span, err.as_slice())\n+                    Err(err) => self.sess.span_fatal(vi.span, err[])\n                 };\n \n             self.plugins.registrars.push(registrar);"}, {"sha": "6629f6620d4847e28996d88795cc8a863bf6be3d", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 161, "deletions": 76, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -34,7 +34,6 @@ use syntax::parse::token::InternedString;\n \n use std::collections::HashMap;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n-use getopts::{optopt, optmulti, optflag, optflagopt};\n use getopts;\n use std::cell::{RefCell};\n use std::fmt;\n@@ -278,7 +277,8 @@ debugging_opts! {\n         PRINT_REGION_GRAPH,\n         PARSE_ONLY,\n         NO_TRANS,\n-        NO_ANALYSIS\n+        NO_ANALYSIS,\n+        UNSTABLE_OPTIONS\n     ]\n     0\n }\n@@ -330,7 +330,8 @@ pub fn debugging_opts_map() -> Vec<(&'static str, &'static str, u64)> {\n      (\"no-trans\", \"Run all passes except translation; no output\", NO_TRANS),\n      (\"no-analysis\", \"Parse and expand the source, but run no analysis and\",\n       NO_TRANS),\n-    ]\n+     (\"unstable-options\", \"Adds unstable command line options to rustc interface\",\n+      UNSTABLE_OPTIONS)]\n }\n \n #[deriving(Clone)]\n@@ -555,17 +556,17 @@ pub fn build_codegen_options(matches: &getopts::Matches) -> CodegenOptions\n                 match (value, opt_type_desc) {\n                     (Some(..), None) => {\n                         early_error(format!(\"codegen option `{}` takes no \\\n-                                             value\", key).as_slice())\n+                                             value\", key)[])\n                     }\n                     (None, Some(type_desc)) => {\n                         early_error(format!(\"codegen option `{0}` requires \\\n                                              {1} (-C {0}=<value>)\",\n-                                            key, type_desc).as_slice())\n+                                            key, type_desc)[])\n                     }\n                     (Some(value), Some(type_desc)) => {\n                         early_error(format!(\"incorrect value `{}` for codegen \\\n                                              option `{}` - {} was expected\",\n-                                             value, key, type_desc).as_slice())\n+                                             value, key, type_desc)[])\n                     }\n                     (None, None) => unreachable!()\n                 }\n@@ -575,7 +576,7 @@ pub fn build_codegen_options(matches: &getopts::Matches) -> CodegenOptions\n         }\n         if !found {\n             early_error(format!(\"unknown codegen option: `{}`\",\n-                                key).as_slice());\n+                                key)[]);\n         }\n     }\n     return cg;\n@@ -588,10 +589,10 @@ pub fn default_lib_output() -> CrateType {\n pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n     use syntax::parse::token::intern_and_get_ident as intern;\n \n-    let end = sess.target.target.target_endian.as_slice();\n-    let arch = sess.target.target.arch.as_slice();\n-    let wordsz = sess.target.target.target_word_size.as_slice();\n-    let os = sess.target.target.target_os.as_slice();\n+    let end = sess.target.target.target_endian[];\n+    let arch = sess.target.target.arch[];\n+    let wordsz = sess.target.target.target_word_size[];\n+    let os = sess.target.target.target_os[];\n \n     let fam = match sess.target.target.options.is_like_windows {\n         true  => InternedString::new(\"windows\"),\n@@ -627,23 +628,23 @@ pub fn build_configuration(sess: &Session) -> ast::CrateConfig {\n         append_configuration(&mut user_cfg, InternedString::new(\"test\"))\n     }\n     let mut v = user_cfg.into_iter().collect::<Vec<_>>();\n-    v.push_all(default_cfg.as_slice());\n+    v.push_all(default_cfg[]);\n     v\n }\n \n pub fn build_target_config(opts: &Options, sp: &SpanHandler) -> Config {\n-    let target = match Target::search(opts.target_triple.as_slice()) {\n+    let target = match Target::search(opts.target_triple[]) {\n         Ok(t) => t,\n         Err(e) => {\n-            sp.handler().fatal((format!(\"Error loading target specification: {}\", e)).as_slice());\n+            sp.handler().fatal((format!(\"Error loading target specification: {}\", e))[]);\n     }\n     };\n \n-    let (int_type, uint_type) = match target.target_word_size.as_slice() {\n+    let (int_type, uint_type) = match target.target_word_size[] {\n         \"32\" => (ast::TyI32, ast::TyU32),\n         \"64\" => (ast::TyI64, ast::TyU64),\n         w    => sp.handler().fatal((format!(\"target specification was invalid: unrecognized \\\n-                                            target-word-size {}\", w)).as_slice())\n+                                            target-word-size {}\", w))[])\n     };\n \n     Config {\n@@ -653,95 +654,179 @@ pub fn build_target_config(opts: &Options, sp: &SpanHandler) -> Config {\n     }\n }\n \n+/// Returns the \"short\" subset of the stable rustc command line options.\n pub fn short_optgroups() -> Vec<getopts::OptGroup> {\n+    rustc_short_optgroups().into_iter()\n+        .filter(|g|g.is_stable())\n+        .map(|g|g.opt_group)\n+        .collect()\n+}\n+\n+/// Returns all of the stable rustc command line options.\n+pub fn optgroups() -> Vec<getopts::OptGroup> {\n+    rustc_optgroups().into_iter()\n+        .filter(|g|g.is_stable())\n+        .map(|g|g.opt_group)\n+        .collect()\n+}\n+\n+#[deriving(Copy, Clone, PartialEq, Eq, Show)]\n+pub enum OptionStability { Stable, Unstable }\n+\n+#[deriving(Clone, PartialEq, Eq)]\n+pub struct RustcOptGroup {\n+    pub opt_group: getopts::OptGroup,\n+    pub stability: OptionStability,\n+}\n+\n+impl RustcOptGroup {\n+    pub fn is_stable(&self) -> bool {\n+        self.stability == OptionStability::Stable\n+    }\n+\n+    fn stable(g: getopts::OptGroup) -> RustcOptGroup {\n+        RustcOptGroup { opt_group: g, stability: OptionStability::Stable }\n+    }\n+\n+    fn unstable(g: getopts::OptGroup) -> RustcOptGroup {\n+        RustcOptGroup { opt_group: g, stability: OptionStability::Unstable }\n+    }\n+}\n+\n+// The `opt` local module holds wrappers around the `getopts` API that\n+// adds extra rustc-specific metadata to each option; such metadata\n+// is exposed by .  The public\n+// functions below ending with `_u` are the functions that return\n+// *unstable* options, i.e. options that are only enabled when the\n+// user also passes the `-Z unstable-options` debugging flag.\n+mod opt {\n+    // The `fn opt_u` etc below are written so that we can use them\n+    // in the future; do not warn about them not being used right now.\n+    #![allow(dead_code)]\n+\n+    use getopts;\n+    use super::RustcOptGroup;\n+\n+    type R = RustcOptGroup;\n+    type S<'a> = &'a str;\n+\n+    fn stable(g: getopts::OptGroup) -> R { RustcOptGroup::stable(g) }\n+    fn unstable(g: getopts::OptGroup) -> R { RustcOptGroup::unstable(g) }\n+\n+    // FIXME (pnkfelix): We default to stable since the current set of\n+    // options is defacto stable.  However, it would be good to revise the\n+    // code so that a stable option is the thing that takes extra effort\n+    // to encode.\n+\n+    pub fn     opt(a: S, b: S, c: S, d: S) -> R { stable(getopts::optopt(a, b, c, d)) }\n+    pub fn   multi(a: S, b: S, c: S, d: S) -> R { stable(getopts::optmulti(a, b, c, d)) }\n+    pub fn    flag(a: S, b: S, c: S)       -> R { stable(getopts::optflag(a, b, c)) }\n+    pub fn flagopt(a: S, b: S, c: S, d: S) -> R { stable(getopts::optflagopt(a, b, c, d)) }\n+\n+    pub fn     opt_u(a: S, b: S, c: S, d: S) -> R { unstable(getopts::optopt(a, b, c, d)) }\n+    pub fn   multi_u(a: S, b: S, c: S, d: S) -> R { unstable(getopts::optmulti(a, b, c, d)) }\n+    pub fn    flag_u(a: S, b: S, c: S)       -> R { unstable(getopts::optflag(a, b, c)) }\n+    pub fn flagopt_u(a: S, b: S, c: S, d: S) -> R { unstable(getopts::optflagopt(a, b, c, d)) }\n+}\n+\n+/// Returns the \"short\" subset of the rustc command line options,\n+/// including metadata for each option, such as whether the option is\n+/// part of the stable long-term interface for rustc.\n+pub fn rustc_short_optgroups() -> Vec<RustcOptGroup> {\n     vec![\n-        optflag(\"h\", \"help\", \"Display this message\"),\n-        optmulti(\"\", \"cfg\", \"Configure the compilation environment\", \"SPEC\"),\n-        optmulti(\"L\", \"\",   \"Add a directory to the library search path\", \"PATH\"),\n-        optmulti(\"l\", \"\",   \"Link the generated crate(s) to the specified native\n+        opt::flag(\"h\", \"help\", \"Display this message\"),\n+        opt::multi(\"\", \"cfg\", \"Configure the compilation environment\", \"SPEC\"),\n+        opt::multi(\"L\", \"\",   \"Add a directory to the library search path\", \"PATH\"),\n+        opt::multi(\"l\", \"\",   \"Link the generated crate(s) to the specified native\n                              library NAME. The optional KIND can be one of,\n                              static, dylib, or framework. If omitted, dylib is\n                              assumed.\", \"NAME[:KIND]\"),\n-        optmulti(\"\", \"crate-type\", \"Comma separated list of types of crates\n+        opt::multi(\"\", \"crate-type\", \"Comma separated list of types of crates\n                                     for the compiler to emit\",\n-                 \"[bin|lib|rlib|dylib|staticlib|dep-info]\"),\n-        optopt(\"\", \"crate-name\", \"Specify the name of the crate being built\",\n+                   \"[bin|lib|rlib|dylib|staticlib]\"),\n+        opt::opt(\"\", \"crate-name\", \"Specify the name of the crate being built\",\n                \"NAME\"),\n-        optmulti(\"\", \"emit\", \"Comma separated list of types of output for \\\n+        opt::multi(\"\", \"emit\", \"Comma separated list of types of output for \\\n                               the compiler to emit\",\n-                 \"[asm|llvm-bc|llvm-ir|obj|link]\"),\n-        optmulti(\"\", \"print\", \"Comma separated list of compiler information to \\\n+                 \"[asm|llvm-bc|llvm-ir|obj|link|dep-info]\"),\n+        opt::multi(\"\", \"print\", \"Comma separated list of compiler information to \\\n                                print on stdout\",\n                  \"[crate-name|output-file-names|sysroot]\"),\n-        optflag(\"g\",  \"\",  \"Equivalent to --debuginfo=2\"),\n-        optflag(\"O\", \"\", \"Equivalent to --opt-level=2\"),\n-        optopt(\"o\", \"\", \"Write output to <filename>\", \"FILENAME\"),\n-        optopt(\"\",  \"out-dir\", \"Write output to compiler-chosen filename \\\n+        opt::flag(\"g\",  \"\",  \"Equivalent to -C debuginfo=2\"),\n+        opt::flag(\"O\", \"\", \"Equivalent to -C opt-level=2\"),\n+        opt::opt(\"o\", \"\", \"Write output to <filename>\", \"FILENAME\"),\n+        opt::opt(\"\",  \"out-dir\", \"Write output to compiler-chosen filename \\\n                                 in <dir>\", \"DIR\"),\n-        optopt(\"\", \"explain\", \"Provide a detailed explanation of an error \\\n+        opt::opt(\"\", \"explain\", \"Provide a detailed explanation of an error \\\n                                message\", \"OPT\"),\n-        optflag(\"\", \"test\", \"Build a test harness\"),\n-        optopt(\"\", \"target\", \"Target triple cpu-manufacturer-kernel[-os] \\\n+        opt::flag(\"\", \"test\", \"Build a test harness\"),\n+        opt::opt(\"\", \"target\", \"Target triple cpu-manufacturer-kernel[-os] \\\n                               to compile for (see chapter 3.4 of \\\n                               http://www.sourceware.org/autobook/\n                               for details)\",\n                \"TRIPLE\"),\n-        optmulti(\"W\", \"warn\", \"Set lint warnings\", \"OPT\"),\n-        optmulti(\"A\", \"allow\", \"Set lint allowed\", \"OPT\"),\n-        optmulti(\"D\", \"deny\", \"Set lint denied\", \"OPT\"),\n-        optmulti(\"F\", \"forbid\", \"Set lint forbidden\", \"OPT\"),\n-        optmulti(\"C\", \"codegen\", \"Set a codegen option\", \"OPT[=VALUE]\"),\n-        optflag(\"V\", \"version\", \"Print version info and exit\"),\n-        optflag(\"v\", \"verbose\", \"Use verbose output\"),\n+        opt::multi(\"W\", \"warn\", \"Set lint warnings\", \"OPT\"),\n+        opt::multi(\"A\", \"allow\", \"Set lint allowed\", \"OPT\"),\n+        opt::multi(\"D\", \"deny\", \"Set lint denied\", \"OPT\"),\n+        opt::multi(\"F\", \"forbid\", \"Set lint forbidden\", \"OPT\"),\n+        opt::multi(\"C\", \"codegen\", \"Set a codegen option\", \"OPT[=VALUE]\"),\n+        opt::flag(\"V\", \"version\", \"Print version info and exit\"),\n+        opt::flag(\"v\", \"verbose\", \"Use verbose output\"),\n     ]\n }\n \n-// rustc command line options\n-pub fn optgroups() -> Vec<getopts::OptGroup> {\n-    let mut opts = short_optgroups();\n+/// Returns all rustc command line options, including metadata for\n+/// each option, such as whether the option is part of the stable\n+/// long-term interface for rustc.\n+pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n+    let mut opts = rustc_short_optgroups();\n     opts.push_all(&[\n-        optmulti(\"\", \"extern\", \"Specify where an external rust library is \\\n+        opt::multi(\"\", \"extern\", \"Specify where an external rust library is \\\n                                 located\",\n                  \"NAME=PATH\"),\n-        optopt(\"\", \"opt-level\", \"Optimize with possible levels 0-3\", \"LEVEL\"),\n-        optopt(\"\", \"sysroot\", \"Override the system root\", \"PATH\"),\n-        optmulti(\"Z\", \"\", \"Set internal debugging options\", \"FLAG\"),\n-        optopt(\"\", \"color\", \"Configure coloring of output:\n+        opt::opt(\"\", \"opt-level\", \"Optimize with possible levels 0-3\", \"LEVEL\"),\n+        opt::opt(\"\", \"sysroot\", \"Override the system root\", \"PATH\"),\n+        opt::multi(\"Z\", \"\", \"Set internal debugging options\", \"FLAG\"),\n+        opt::opt(\"\", \"color\", \"Configure coloring of output:\n             auto   = colorize, if output goes to a tty (default);\n             always = always colorize output;\n             never  = never colorize output\", \"auto|always|never\"),\n \n         // DEPRECATED\n-        optflag(\"\", \"print-crate-name\", \"Output the crate name and exit\"),\n-        optflag(\"\", \"print-file-name\", \"Output the file(s) that would be \\\n+        opt::flag(\"\", \"print-crate-name\", \"Output the crate name and exit\"),\n+        opt::flag(\"\", \"print-file-name\", \"Output the file(s) that would be \\\n                                         written if compilation \\\n                                         continued and exit\"),\n-        optopt(\"\",  \"debuginfo\",  \"Emit DWARF debug info to the objects created:\n+        opt::opt(\"\",  \"debuginfo\",  \"Emit DWARF debug info to the objects created:\n              0 = no debug info,\n              1 = line-tables only (for stacktraces and breakpoints),\n              2 = full debug info with variable and type information \\\n                     (same as -g)\", \"LEVEL\"),\n-        optflag(\"\", \"no-trans\", \"Run all passes except translation; no output\"),\n-        optflag(\"\", \"no-analysis\", \"Parse and expand the source, but run no \\\n+        opt::flag(\"\", \"no-trans\", \"Run all passes except translation; no output\"),\n+        opt::flag(\"\", \"no-analysis\", \"Parse and expand the source, but run no \\\n                                     analysis and produce no output\"),\n-        optflag(\"\", \"parse-only\", \"Parse only; do not compile, assemble, \\\n+        opt::flag(\"\", \"parse-only\", \"Parse only; do not compile, assemble, \\\n                                    or link\"),\n-        optflagopt(\"\", \"pretty\",\n+        opt::flagopt(\"\", \"pretty\",\n                    \"Pretty-print the input instead of compiling;\n                    valid types are: `normal` (un-annotated source),\n                    `expanded` (crates expanded),\n-                   `typed` (crates expanded, with type annotations),\n-                   `expanded,identified` (fully parenthesized, AST nodes with IDs), or\n-                   `flowgraph=<nodeid>` (graphviz formatted flowgraph for node)\",\n+                   `typed` (crates expanded, with type annotations), or\n+                   `expanded,identified` (fully parenthesized, AST nodes with IDs).\",\n                  \"TYPE\"),\n-        optflagopt(\"\", \"dep-info\",\n+        opt::flagopt_u(\"\", \"xpretty\",\n+                     \"Pretty-print the input instead of compiling, unstable variants;\n+                      valid types are any of the types for `--pretty`, as well as:\n+                      `flowgraph=<nodeid>` (graphviz formatted flowgraph for node), or\n+                      `everybody_loops` (all function bodies replaced with `loop {}`).\",\n+                     \"TYPE\"),\n+        opt::flagopt(\"\", \"dep-info\",\n                  \"Output dependency info to <filename> after compiling, \\\n                   in a format suitable for use by Makefiles\", \"FILENAME\"),\n     ]);\n     opts\n }\n \n-\n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n pub fn parse_cfgspecs(cfgspecs: Vec<String> ) -> ast::CrateConfig {\n     cfgspecs.into_iter().map(|s| {\n@@ -756,7 +841,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let unparsed_crate_types = matches.opt_strs(\"crate-type\");\n     let crate_types = parse_crate_types_from_list(unparsed_crate_types)\n-        .unwrap_or_else(|e| early_error(e.as_slice()));\n+        .unwrap_or_else(|e| early_error(e[]));\n \n     let mut lint_opts = vec!();\n     let mut describe_lints = false;\n@@ -766,7 +851,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             if lint_name == \"help\" {\n                 describe_lints = true;\n             } else {\n-                lint_opts.push((lint_name.replace(\"-\", \"_\").into_string(), level));\n+                lint_opts.push((lint_name.replace(\"-\", \"_\"), level));\n             }\n         }\n     }\n@@ -784,7 +869,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         }\n         if this_bit == 0 {\n             early_error(format!(\"unknown debug flag: {}\",\n-                                *debug_flag).as_slice())\n+                                *debug_flag)[])\n         }\n         debugging_opts |= this_bit;\n     }\n@@ -829,7 +914,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n                     \"dep-info\" => OutputTypeDepInfo,\n                     _ => {\n                         early_error(format!(\"unknown emission type: `{}`\",\n-                                            part).as_slice())\n+                                            part)[])\n                     }\n                 };\n                 output_types.push(output_type)\n@@ -868,7 +953,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n                 Some(arg) => {\n                     early_error(format!(\"optimization level needs to be \\\n                                          between 0-3 (instead was `{}`)\",\n-                                        arg).as_slice());\n+                                        arg)[]);\n                 }\n             }\n         } else {\n@@ -906,7 +991,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             Some(arg) => {\n                 early_error(format!(\"debug info level needs to be between \\\n                                      0-2 (instead was `{}`)\",\n-                                    arg).as_slice());\n+                                    arg)[]);\n             }\n         }\n     } else {\n@@ -923,7 +1008,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     };\n \n     let addl_lib_search_paths = matches.opt_strs(\"L\").iter().map(|s| {\n-        Path::new(s.as_slice())\n+        Path::new(s[])\n     }).collect();\n \n     let libs = matches.opt_strs(\"l\").into_iter().map(|s| {\n@@ -937,7 +1022,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             (_, s) => {\n                 early_error(format!(\"unknown library kind `{}`, expected \\\n                                      one of dylib, framework, or static\",\n-                                    s).as_slice());\n+                                    s)[]);\n             }\n         };\n         (name.to_string(), kind)\n@@ -982,7 +1067,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         //             --debuginfo\");\n     }\n \n-    let color = match matches.opt_str(\"color\").as_ref().map(|s| s.as_slice()) {\n+    let color = match matches.opt_str(\"color\").as_ref().map(|s| s[]) {\n         Some(\"auto\")   => Auto,\n         Some(\"always\") => Always,\n         Some(\"never\")  => Never,\n@@ -992,7 +1077,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         Some(arg) => {\n             early_error(format!(\"argument for --color must be auto, always \\\n                                  or never (instead was `{}`)\",\n-                                arg).as_slice())\n+                                arg)[])\n         }\n     };\n \n@@ -1093,15 +1178,15 @@ mod test {\n     #[test]\n     fn test_switch_implies_cfg_test() {\n         let matches =\n-            &match getopts(&[\"--test\".to_string()], optgroups().as_slice()) {\n+            &match getopts(&[\"--test\".to_string()], optgroups()[]) {\n               Ok(m) => m,\n               Err(f) => panic!(\"test_switch_implies_cfg_test: {}\", f)\n             };\n         let registry = diagnostics::registry::Registry::new(&[]);\n         let sessopts = build_session_options(matches);\n         let sess = build_session(sessopts, None, registry);\n         let cfg = build_configuration(&sess);\n-        assert!((attr::contains_name(cfg.as_slice(), \"test\")));\n+        assert!((attr::contains_name(cfg[], \"test\")));\n     }\n \n     // When the user supplies --test and --cfg test, don't implicitly add\n@@ -1110,7 +1195,7 @@ mod test {\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n         let matches =\n             &match getopts(&[\"--test\".to_string(), \"--cfg=test\".to_string()],\n-                           optgroups().as_slice()) {\n+                           optgroups()[]) {\n               Ok(m) => m,\n               Err(f) => {\n                 panic!(\"test_switch_implies_cfg_test_unless_cfg_test: {}\", f)\n@@ -1130,7 +1215,7 @@ mod test {\n         {\n             let matches = getopts(&[\n                 \"-Awarnings\".to_string()\n-            ], optgroups().as_slice()).unwrap();\n+            ], optgroups()[]).unwrap();\n             let registry = diagnostics::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, None, registry);\n@@ -1141,7 +1226,7 @@ mod test {\n             let matches = getopts(&[\n                 \"-Awarnings\".to_string(),\n                 \"-Dwarnings\".to_string()\n-            ], optgroups().as_slice()).unwrap();\n+            ], optgroups()[]).unwrap();\n             let registry = diagnostics::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, None, registry);\n@@ -1151,7 +1236,7 @@ mod test {\n         {\n             let matches = getopts(&[\n                 \"-Adead_code\".to_string()\n-            ], optgroups().as_slice()).unwrap();\n+            ], optgroups()[]).unwrap();\n             let registry = diagnostics::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, None, registry);"}, {"sha": "37bdd1673e9ca3cb69b439e8bd8dffda0544603c", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -172,7 +172,7 @@ impl Session {\n     // cases later on\n     pub fn impossible_case(&self, sp: Span, msg: &str) -> ! {\n         self.span_bug(sp,\n-                      format!(\"impossible case reached: {}\", msg).as_slice());\n+                      format!(\"impossible case reached: {}\", msg)[]);\n     }\n     pub fn verbose(&self) -> bool { self.debugging_opt(config::VERBOSE) }\n     pub fn time_passes(&self) -> bool { self.debugging_opt(config::TIME_PASSES) }\n@@ -211,7 +211,7 @@ impl Session {\n     }\n     pub fn target_filesearch<'a>(&'a self) -> filesearch::FileSearch<'a> {\n         filesearch::FileSearch::new(self.sysroot(),\n-                                    self.opts.target_triple.as_slice(),\n+                                    self.opts.target_triple[],\n                                     &self.opts.addl_lib_search_paths)\n     }\n     pub fn host_filesearch<'a>(&'a self) -> filesearch::FileSearch<'a> {"}, {"sha": "e1448364a9e05a7c36028d5dbe0bfdbdaa8ea646", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -14,6 +14,7 @@ use std::cell::{RefCell, Cell};\n use std::collections::HashMap;\n use std::fmt::Show;\n use std::hash::{Hash, Hasher};\n+use std::iter::repeat;\n use std::time::Duration;\n \n use syntax::ast;\n@@ -48,7 +49,7 @@ pub fn time<T, U, F>(do_it: bool, what: &str, u: U, f: F) -> T where\n     };\n     let rv = rv.unwrap();\n \n-    println!(\"{}time: {}.{:03} \\t{}\", \"  \".repeat(old),\n+    println!(\"{}time: {}.{:03} \\t{}\", repeat(\"  \").take(old).collect::<String>(),\n              dur.num_seconds(), dur.num_milliseconds() % 1000, what);\n     DEPTH.with(|slot| slot.set(old));\n "}, {"sha": "24e9883744407b9ebb698e2caa6f4f6a8278cdda", "filename": "src/librustc/util/lev_distance.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Futil%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Futil%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Flev_distance.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cmp;\n+\n+pub fn lev_distance(me: &str, t: &str) -> uint {\n+    if me.is_empty() { return t.chars().count(); }\n+    if t.is_empty() { return me.chars().count(); }\n+\n+    let mut dcol = Vec::from_fn(t.len() + 1, |x| x);\n+    let mut t_last = 0;\n+\n+    for (i, sc) in me.chars().enumerate() {\n+\n+        let mut current = i;\n+        dcol[0] = current + 1;\n+\n+        for (j, tc) in t.chars().enumerate() {\n+\n+            let next = dcol[j + 1];\n+\n+            if sc == tc {\n+                dcol[j + 1] = current;\n+            } else {\n+                dcol[j + 1] = cmp::min(current, next);\n+                dcol[j + 1] = cmp::min(dcol[j + 1], dcol[j]) + 1;\n+            }\n+\n+            current = next;\n+            t_last = j;\n+        }\n+    }\n+\n+    dcol[t_last + 1]\n+}\n+\n+#[test]\n+fn test_lev_distance() {\n+    use std::char::{ from_u32, MAX };\n+    // Test bytelength agnosticity\n+    for c in range(0u32, MAX as u32)\n+             .filter_map(|i| from_u32(i))\n+             .map(|i| String::from_char(1, i)) {\n+        assert_eq!(lev_distance(c[], c[]), 0);\n+    }\n+\n+    let a = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n+    let b = \"\\nMary h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n+    let c = \"Mary h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n+    assert_eq!(lev_distance(a, b), 1);\n+    assert_eq!(lev_distance(b, a), 1);\n+    assert_eq!(lev_distance(a, c), 2);\n+    assert_eq!(lev_distance(c, a), 2);\n+    assert_eq!(lev_distance(b, c), 1);\n+    assert_eq!(lev_distance(c, b), 1);\n+}"}, {"sha": "a02004e6d18a3a2aa673322d5e3bcd1ade3269ef", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -55,12 +55,12 @@ pub fn note_and_explain_region(cx: &ctxt,\n       (ref str, Some(span)) => {\n         cx.sess.span_note(\n             span,\n-            format!(\"{}{}{}\", prefix, *str, suffix).as_slice());\n+            format!(\"{}{}{}\", prefix, *str, suffix)[]);\n         Some(span)\n       }\n       (ref str, None) => {\n         cx.sess.note(\n-            format!(\"{}{}{}\", prefix, *str, suffix).as_slice());\n+            format!(\"{}{}{}\", prefix, *str, suffix)[]);\n         None\n       }\n     }\n@@ -254,12 +254,14 @@ pub fn vec_map_to_string<T, F>(ts: &[T], f: F) -> String where\n \n pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n     fn bare_fn_to_string<'tcx>(cx: &ctxt<'tcx>,\n+                               opt_def_id: Option<ast::DefId>,\n                                unsafety: ast::Unsafety,\n                                abi: abi::Abi,\n                                ident: Option<ast::Ident>,\n                                sig: &ty::PolyFnSig<'tcx>)\n                                -> String {\n         let mut s = String::new();\n+\n         match unsafety {\n             ast::Unsafety::Normal => {}\n             ast::Unsafety::Unsafe => {\n@@ -269,7 +271,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         };\n \n         if abi != abi::Rust {\n-            s.push_str(format!(\"extern {} \", abi.to_string()).as_slice());\n+            s.push_str(format!(\"extern {} \", abi.to_string())[]);\n         };\n \n         s.push_str(\"fn\");\n@@ -284,6 +286,16 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n \n         push_sig_to_string(cx, &mut s, '(', ')', sig, \"\");\n \n+        match opt_def_id {\n+            Some(def_id) => {\n+                s.push_str(\" {\");\n+                let path_str = ty::item_path_str(cx, def_id);\n+                s.push_str(path_str[]);\n+                s.push_str(\"}\");\n+            }\n+            None => { }\n+        }\n+\n         s\n     }\n \n@@ -293,7 +305,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         match cty.store {\n             ty::UniqTraitStore => {}\n             ty::RegionTraitStore(region, _) => {\n-                s.push_str(region_to_string(cx, \"\", true, region).as_slice());\n+                s.push_str(region_to_string(cx, \"\", true, region)[]);\n             }\n         }\n \n@@ -312,15 +324,15 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n                 assert_eq!(cty.onceness, ast::Once);\n                 s.push_str(\"proc\");\n                 push_sig_to_string(cx, &mut s, '(', ')', &cty.sig,\n-                                   bounds_str.as_slice());\n+                                   bounds_str[]);\n             }\n             ty::RegionTraitStore(..) => {\n                 match cty.onceness {\n                     ast::Many => {}\n                     ast::Once => s.push_str(\"once \")\n                 }\n                 push_sig_to_string(cx, &mut s, '|', '|', &cty.sig,\n-                                   bounds_str.as_slice());\n+                                   bounds_str[]);\n             }\n         }\n \n@@ -353,7 +365,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n             ty::FnConverging(t) => {\n                 if !ty::type_is_nil(t) {\n                    s.push_str(\" -> \");\n-                   s.push_str(ty_to_string(cx, t).as_slice());\n+                   s.push_str(ty_to_string(cx, t)[]);\n                 }\n             }\n             ty::FnDiverging => {\n@@ -390,7 +402,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         }\n         ty_rptr(r, ref tm) => {\n             let mut buf = region_ptr_to_string(cx, r);\n-            buf.push_str(mt_to_string(cx, tm).as_slice());\n+            buf.push_str(mt_to_string(cx, tm)[]);\n             buf\n         }\n         ty_open(typ) =>\n@@ -400,16 +412,16 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n                 .iter()\n                 .map(|elem| ty_to_string(cx, *elem))\n                 .collect::<Vec<_>>();\n-            match strs.as_slice() {\n+            match strs[] {\n                 [ref string] => format!(\"({},)\", string),\n                 strs => format!(\"({})\", strs.connect(\", \"))\n             }\n         }\n         ty_closure(ref f) => {\n             closure_to_string(cx, &**f)\n         }\n-        ty_bare_fn(ref f) => {\n-            bare_fn_to_string(cx, f.unsafety, f.abi, None, &f.sig)\n+        ty_bare_fn(opt_def_id, ref f) => {\n+            bare_fn_to_string(cx, opt_def_id, f.unsafety, f.abi, None, &f.sig)\n         }\n         ty_infer(infer_ty) => infer_ty_to_string(cx, infer_ty),\n         ty_err => \"[type error]\".to_string(),\n@@ -551,7 +563,7 @@ pub fn parameterized<'tcx>(cx: &ctxt<'tcx>,\n pub fn ty_to_short_str<'tcx>(cx: &ctxt<'tcx>, typ: Ty<'tcx>) -> String {\n     let mut s = typ.repr(cx).to_string();\n     if s.len() >= 32u {\n-        s = s.slice(0u, 32u).to_string();\n+        s = s[0u..32u].to_string();\n     }\n     return s;\n }\n@@ -616,15 +628,15 @@ impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for [T] {\n \n impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for OwnedSlice<T> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        repr_vec(tcx, self.as_slice())\n+        repr_vec(tcx, self[])\n     }\n }\n \n // This is necessary to handle types like Option<~[T]>, for which\n // autoderef cannot convert the &[T] handler\n impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for Vec<T> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        repr_vec(tcx, self.as_slice())\n+        repr_vec(tcx, self[])\n     }\n }\n "}, {"sha": "0bd4265e487a64f25fa19a7d2f022879e7481fae", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -53,7 +53,7 @@ fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n           args: &str, cwd: Option<&Path>,\n           paths: &[&Path]) -> ProcessOutput {\n     let ar = match *maybe_ar_prog {\n-        Some(ref ar) => ar.as_slice(),\n+        Some(ref ar) => ar[],\n         None => \"ar\"\n     };\n     let mut cmd = Command::new(ar);\n@@ -75,22 +75,22 @@ fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n             if !o.status.success() {\n                 handler.err(format!(\"{} failed with: {}\",\n                                  cmd,\n-                                 o.status).as_slice());\n+                                 o.status)[]);\n                 handler.note(format!(\"stdout ---\\n{}\",\n                                   str::from_utf8(o.output\n-                                                  .as_slice()).unwrap())\n-                          .as_slice());\n+                                                  []).unwrap())\n+                          []);\n                 handler.note(format!(\"stderr ---\\n{}\",\n                                   str::from_utf8(o.error\n-                                                  .as_slice()).unwrap())\n-                          .as_slice());\n+                                                  []).unwrap())\n+                          []);\n                 handler.abort_if_errors();\n             }\n             o\n         },\n         Err(e) => {\n-            handler.err(format!(\"could not exec `{}`: {}\", ar.as_slice(),\n-                             e).as_slice());\n+            handler.err(format!(\"could not exec `{}`: {}\", ar[],\n+                             e)[]);\n             handler.abort_if_errors();\n             panic!(\"rustc::back::archive::run_ar() should not reach this point\");\n         }\n@@ -106,16 +106,16 @@ pub fn find_library(name: &str, osprefix: &str, ossuffix: &str,\n \n     for path in search_paths.iter() {\n         debug!(\"looking for {} inside {}\", name, path.display());\n-        let test = path.join(oslibname.as_slice());\n+        let test = path.join(oslibname[]);\n         if test.exists() { return test }\n         if oslibname != unixlibname {\n-            let test = path.join(unixlibname.as_slice());\n+            let test = path.join(unixlibname[]);\n             if test.exists() { return test }\n         }\n     }\n     handler.fatal(format!(\"could not find native static library `{}`, \\\n                            perhaps an -L flag is missing?\",\n-                          name).as_slice());\n+                          name)[]);\n }\n \n impl<'a> Archive<'a> {\n@@ -147,7 +147,7 @@ impl<'a> Archive<'a> {\n     /// Lists all files in an archive\n     pub fn files(&self) -> Vec<String> {\n         let output = run_ar(self.handler, &self.maybe_ar_prog, \"t\", None, &[&self.dst]);\n-        let output = str::from_utf8(output.output.as_slice()).unwrap();\n+        let output = str::from_utf8(output.output[]).unwrap();\n         // use lines_any because windows delimits output with `\\r\\n` instead of\n         // just `\\n`\n         output.lines_any().map(|s| s.to_string()).collect()\n@@ -179,9 +179,9 @@ impl<'a> ArchiveBuilder<'a> {\n     /// search in the relevant locations for a library named `name`.\n     pub fn add_native_library(&mut self, name: &str) -> io::IoResult<()> {\n         let location = find_library(name,\n-                                    self.archive.slib_prefix.as_slice(),\n-                                    self.archive.slib_suffix.as_slice(),\n-                                    self.archive.lib_search_paths.as_slice(),\n+                                    self.archive.slib_prefix[],\n+                                    self.archive.slib_suffix[],\n+                                    self.archive.lib_search_paths[],\n                                     self.archive.handler);\n         self.add_archive(&location, name, |_| false)\n     }\n@@ -197,12 +197,12 @@ impl<'a> ArchiveBuilder<'a> {\n         // as simple comparison is not enough - there\n         // might be also an extra name suffix\n         let obj_start = format!(\"{}\", name);\n-        let obj_start = obj_start.as_slice();\n+        let obj_start = obj_start[];\n         // Ignoring all bytecode files, no matter of\n         // name\n         let bc_ext = \".bytecode.deflate\";\n \n-        self.add_archive(rlib, name.as_slice(), |fname: &str| {\n+        self.add_archive(rlib, name[], |fname: &str| {\n             let skip_obj = lto && fname.starts_with(obj_start)\n                 && fname.ends_with(\".o\");\n             skip_obj || fname.ends_with(bc_ext) || fname == METADATA_FILENAME\n@@ -239,7 +239,7 @@ impl<'a> ArchiveBuilder<'a> {\n             // allow running `ar s file.a` to update symbols only.\n             if self.should_update_symbols {\n                 run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n-                       \"s\", Some(self.work_dir.path()), args.as_slice());\n+                       \"s\", Some(self.work_dir.path()), args[]);\n             }\n             return self.archive;\n         }\n@@ -259,7 +259,7 @@ impl<'a> ArchiveBuilder<'a> {\n                 // Add the archive members seen so far, without updating the\n                 // symbol table (`S`).\n                 run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n-                       \"cruS\", Some(self.work_dir.path()), args.as_slice());\n+                       \"cruS\", Some(self.work_dir.path()), args[]);\n \n                 args.clear();\n                 args.push(&abs_dst);\n@@ -274,7 +274,7 @@ impl<'a> ArchiveBuilder<'a> {\n         // necessary.\n         let flags = if self.should_update_symbols { \"crus\" } else { \"cruS\" };\n         run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n-               flags, Some(self.work_dir.path()), args.as_slice());\n+               flags, Some(self.work_dir.path()), args[]);\n \n         self.archive\n     }\n@@ -316,7 +316,7 @@ impl<'a> ArchiveBuilder<'a> {\n             } else {\n                 filename\n             };\n-            let new_filename = self.work_dir.path().join(filename.as_slice());\n+            let new_filename = self.work_dir.path().join(filename[]);\n             try!(fs::rename(file, &new_filename));\n             self.members.push(Path::new(filename));\n         }"}, {"sha": "1056ac928e687e7f996c9c5830c3225bb4144c8e", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -44,15 +44,15 @@ pub fn get_rpath_flags<F, G>(config: RPathConfig<F, G>) -> Vec<String> where\n         l.map(|p| p.clone())\n     }).collect::<Vec<_>>();\n \n-    let rpaths = get_rpaths(config, libs.as_slice());\n-    flags.push_all(rpaths_to_flags(rpaths.as_slice()).as_slice());\n+    let rpaths = get_rpaths(config, libs[]);\n+    flags.push_all(rpaths_to_flags(rpaths[])[]);\n     flags\n }\n \n fn rpaths_to_flags(rpaths: &[String]) -> Vec<String> {\n     let mut ret = Vec::new();\n     for rpath in rpaths.iter() {\n-        ret.push(format!(\"-Wl,-rpath,{}\", (*rpath).as_slice()));\n+        ret.push(format!(\"-Wl,-rpath,{}\", (*rpath)[]));\n     }\n     return ret;\n }\n@@ -82,14 +82,14 @@ fn get_rpaths<F, G>(mut config: RPathConfig<F, G>, libs: &[Path]) -> Vec<String>\n         }\n     }\n \n-    log_rpaths(\"relative\", rel_rpaths.as_slice());\n-    log_rpaths(\"fallback\", fallback_rpaths.as_slice());\n+    log_rpaths(\"relative\", rel_rpaths[]);\n+    log_rpaths(\"fallback\", fallback_rpaths[]);\n \n     let mut rpaths = rel_rpaths;\n-    rpaths.push_all(fallback_rpaths.as_slice());\n+    rpaths.push_all(fallback_rpaths[]);\n \n     // Remove duplicates\n-    let rpaths = minimize_rpaths(rpaths.as_slice());\n+    let rpaths = minimize_rpaths(rpaths[]);\n     return rpaths;\n }\n \n@@ -140,7 +140,7 @@ fn minimize_rpaths(rpaths: &[String]) -> Vec<String> {\n     let mut set = HashSet::new();\n     let mut minimized = Vec::new();\n     for rpath in rpaths.iter() {\n-        if set.insert(rpath.as_slice()) {\n+        if set.insert(rpath[]) {\n             minimized.push(rpath.clone());\n         }\n     }"}, {"sha": "d40c9ee8af6af75564b5b83efd2a3bdc61da1f83", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -65,7 +65,7 @@ impl Svh {\n     }\n \n     pub fn as_str<'a>(&'a self) -> &'a str {\n-        self.hash.as_slice()\n+        self.hash[]\n     }\n \n     pub fn calculate(metadata: &Vec<String>, krate: &ast::Crate) -> Svh {\n@@ -358,7 +358,7 @@ mod svh_visitor {\n             fn macro_name(macro: &Mac) -> token::InternedString {\n                 match &macro.node {\n                     &MacInvocTT(ref path, ref _tts, ref _stx_ctxt) => {\n-                        let s = path.segments.as_slice();\n+                        let s = path.segments[];\n                         assert_eq!(s.len(), 1);\n                         content(s[0].identifier)\n                     }"}, {"sha": "99a25bebf40ab4999fd95c84a204cd86314b32be", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -224,7 +224,7 @@ impl Target {\n                 Some(val) => val,\n                 None =>\n                     handler.fatal((format!(\"Field {} in target specification is required\", name))\n-                                  .as_slice())\n+                                  [])\n             }\n         };\n \n@@ -365,7 +365,7 @@ impl Target {\n \n         let target_path = os::getenv(\"RUST_TARGET_PATH\").unwrap_or(String::new());\n \n-        let paths = os::split_paths(target_path.as_slice());\n+        let paths = os::split_paths(target_path[]);\n         // FIXME 16351: add a sane default search path?\n \n         for dir in paths.iter() {"}, {"sha": "568bb023b68a28f9aae4a60ad84d5ac24c3be447", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -469,23 +469,23 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                         new_loan.span,\n                         format!(\"cannot borrow `{}`{} as mutable \\\n                                 more than once at a time\",\n-                                nl, new_loan_msg).as_slice())\n+                                nl, new_loan_msg)[])\n                 }\n \n                 (ty::UniqueImmBorrow, _) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n                         format!(\"closure requires unique access to `{}` \\\n                                 but {} is already borrowed{}\",\n-                                nl, ol_pronoun, old_loan_msg).as_slice());\n+                                nl, ol_pronoun, old_loan_msg)[]);\n                 }\n \n                 (_, ty::UniqueImmBorrow) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n                         format!(\"cannot borrow `{}`{} as {} because \\\n                                 previous closure requires unique access\",\n-                                nl, new_loan_msg, new_loan.kind.to_user_str()).as_slice());\n+                                nl, new_loan_msg, new_loan.kind.to_user_str())[]);\n                 }\n \n                 (_, _) => {\n@@ -498,7 +498,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                 new_loan.kind.to_user_str(),\n                                 ol_pronoun,\n                                 old_loan.kind.to_user_str(),\n-                                old_loan_msg).as_slice());\n+                                old_loan_msg)[]);\n                 }\n             }\n \n@@ -507,7 +507,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                     self.bccx.span_note(\n                         span,\n                         format!(\"borrow occurs due to use of `{}` in closure\",\n-                                nl).as_slice());\n+                                nl)[]);\n                 }\n                 _ => { }\n             }\n@@ -556,7 +556,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n             self.bccx.span_note(\n                 old_loan.span,\n-                format!(\"{}; {}\", borrow_summary, rule_summary).as_slice());\n+                format!(\"{}; {}\", borrow_summary, rule_summary)[]);\n \n             let old_loan_span = self.tcx().map.span(old_loan.kill_scope.node_id());\n             self.bccx.span_end_note(old_loan_span,\n@@ -626,13 +626,13 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 self.bccx.span_err(\n                     span,\n                     format!(\"cannot use `{}` because it was mutably borrowed\",\n-                            self.bccx.loan_path_to_string(copy_path).as_slice())\n-                    .as_slice());\n+                            self.bccx.loan_path_to_string(copy_path)[])\n+                    []);\n                 self.bccx.span_note(\n                     loan_span,\n                     format!(\"borrow of `{}` occurs here\",\n-                            self.bccx.loan_path_to_string(&*loan_path).as_slice())\n-                    .as_slice());\n+                            self.bccx.loan_path_to_string(&*loan_path)[])\n+                    []);\n             }\n         }\n     }\n@@ -651,20 +651,20 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 let err_message = match move_kind {\n                     move_data::Captured =>\n                         format!(\"cannot move `{}` into closure because it is borrowed\",\n-                                self.bccx.loan_path_to_string(move_path).as_slice()),\n+                                self.bccx.loan_path_to_string(move_path)[]),\n                     move_data::Declared |\n                     move_data::MoveExpr |\n                     move_data::MovePat =>\n                         format!(\"cannot move out of `{}` because it is borrowed\",\n-                                self.bccx.loan_path_to_string(move_path).as_slice())\n+                                self.bccx.loan_path_to_string(move_path)[])\n                 };\n \n-                self.bccx.span_err(span, err_message.as_slice());\n+                self.bccx.span_err(span, err_message[]);\n                 self.bccx.span_note(\n                     loan_span,\n                     format!(\"borrow of `{}` occurs here\",\n-                            self.bccx.loan_path_to_string(&*loan_path).as_slice())\n-                    .as_slice());\n+                            self.bccx.loan_path_to_string(&*loan_path)[])\n+                    []);\n             }\n         }\n     }\n@@ -814,7 +814,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                     self.bccx.span_err(\n                         assignment_span,\n                         format!(\"cannot assign to {}\",\n-                                self.bccx.cmt_to_string(&*assignee_cmt)).as_slice());\n+                                self.bccx.cmt_to_string(&*assignee_cmt))[]);\n                     self.bccx.span_help(\n                         self.tcx().map.span(upvar_id.closure_expr_id),\n                         \"consider changing this closure to take self by mutable reference\");\n@@ -823,7 +823,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                         assignment_span,\n                         format!(\"cannot assign to {} {}\",\n                                 assignee_cmt.mutbl.to_user_str(),\n-                                self.bccx.cmt_to_string(&*assignee_cmt)).as_slice());\n+                                self.bccx.cmt_to_string(&*assignee_cmt))[]);\n                 }\n             }\n             _ => match opt_loan_path(&assignee_cmt) {\n@@ -833,14 +833,14 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                         format!(\"cannot assign to {} {} `{}`\",\n                                 assignee_cmt.mutbl.to_user_str(),\n                                 self.bccx.cmt_to_string(&*assignee_cmt),\n-                                self.bccx.loan_path_to_string(&*lp)).as_slice());\n+                                self.bccx.loan_path_to_string(&*lp))[]);\n                 }\n                 None => {\n                     self.bccx.span_err(\n                         assignment_span,\n                         format!(\"cannot assign to {} {}\",\n                                 assignee_cmt.mutbl.to_user_str(),\n-                                self.bccx.cmt_to_string(&*assignee_cmt)).as_slice());\n+                                self.bccx.cmt_to_string(&*assignee_cmt))[]);\n                 }\n             }\n         }\n@@ -960,10 +960,10 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         self.bccx.span_err(\n             span,\n             format!(\"cannot assign to `{}` because it is borrowed\",\n-                    self.bccx.loan_path_to_string(loan_path)).as_slice());\n+                    self.bccx.loan_path_to_string(loan_path))[]);\n         self.bccx.span_note(\n             loan.span,\n             format!(\"borrow of `{}` occurs here\",\n-                    self.bccx.loan_path_to_string(loan_path)).as_slice());\n+                    self.bccx.loan_path_to_string(loan_path))[]);\n     }\n }"}, {"sha": "dbbc52cf36235970cb80ea153ff5848f245441cd", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -124,12 +124,12 @@ pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n         let attrs : &[ast::Attribute];\n         attrs = match tcx.map.find(id) {\n             Some(ast_map::NodeItem(ref item)) =>\n-                item.attrs.as_slice(),\n+                item.attrs[],\n             Some(ast_map::NodeImplItem(&ast::MethodImplItem(ref m))) =>\n-                m.attrs.as_slice(),\n+                m.attrs[],\n             Some(ast_map::NodeTraitItem(&ast::ProvidedMethod(ref m))) =>\n-                m.attrs.as_slice(),\n-            _ => [].as_slice(),\n+                m.attrs[],\n+            _ => [][],\n         };\n \n         let span_err =\n@@ -145,7 +145,7 @@ pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n         for (i, mpi) in vec_rc.iter().enumerate() {\n             let render = || this.path_loan_path(*mpi).user_string(tcx);\n             if span_err {\n-                tcx.sess.span_err(sp, format!(\"{}: `{}`\", kind, render()).as_slice());\n+                tcx.sess.span_err(sp, format!(\"{}: `{}`\", kind, render())[]);\n             }\n             if print {\n                 println!(\"id:{} {}[{}] `{}`\", id, kind, i, render());\n@@ -157,7 +157,7 @@ pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n         for (i, f) in vec_rc.iter().enumerate() {\n             let render = || f.loan_path_user_string(this, tcx);\n             if span_err {\n-                tcx.sess.span_err(sp, format!(\"{}: `{}`\", kind, render()).as_slice());\n+                tcx.sess.span_err(sp, format!(\"{}: `{}`\", kind, render())[]);\n             }\n             if print {\n                 println!(\"id:{} {}[{}] `{}`\", id, kind, i, render());\n@@ -199,11 +199,11 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n     // First, filter out duplicates\n     moved.sort();\n     moved.dedup();\n-    debug!(\"fragments 1 moved: {}\", path_lps(moved.as_slice()));\n+    debug!(\"fragments 1 moved: {}\", path_lps(moved[]));\n \n     assigned.sort();\n     assigned.dedup();\n-    debug!(\"fragments 1 assigned: {}\", path_lps(assigned.as_slice()));\n+    debug!(\"fragments 1 assigned: {}\", path_lps(assigned[]));\n \n     // Second, build parents from the moved and assigned.\n     for m in moved.iter() {\n@@ -223,14 +223,14 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n \n     parents.sort();\n     parents.dedup();\n-    debug!(\"fragments 2 parents: {}\", path_lps(parents.as_slice()));\n+    debug!(\"fragments 2 parents: {}\", path_lps(parents[]));\n \n     // Third, filter the moved and assigned fragments down to just the non-parents\n-    moved.retain(|f| non_member(*f, parents.as_slice()));\n-    debug!(\"fragments 3 moved: {}\", path_lps(moved.as_slice()));\n+    moved.retain(|f| non_member(*f, parents[]));\n+    debug!(\"fragments 3 moved: {}\", path_lps(moved[]));\n \n-    assigned.retain(|f| non_member(*f, parents.as_slice()));\n-    debug!(\"fragments 3 assigned: {}\", path_lps(assigned.as_slice()));\n+    assigned.retain(|f| non_member(*f, parents[]));\n+    debug!(\"fragments 3 assigned: {}\", path_lps(assigned[]));\n \n     // Fourth, build the leftover from the moved, assigned, and parents.\n     for m in moved.iter() {\n@@ -248,16 +248,16 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n \n     unmoved.sort();\n     unmoved.dedup();\n-    debug!(\"fragments 4 unmoved: {}\", frag_lps(unmoved.as_slice()));\n+    debug!(\"fragments 4 unmoved: {}\", frag_lps(unmoved[]));\n \n     // Fifth, filter the leftover fragments down to its core.\n     unmoved.retain(|f| match *f {\n         AllButOneFrom(_) => true,\n-        Just(mpi) => non_member(mpi, parents.as_slice()) &&\n-            non_member(mpi, moved.as_slice()) &&\n-            non_member(mpi, assigned.as_slice())\n+        Just(mpi) => non_member(mpi, parents[]) &&\n+            non_member(mpi, moved[]) &&\n+            non_member(mpi, assigned[])\n     });\n-    debug!(\"fragments 5 unmoved: {}\", frag_lps(unmoved.as_slice()));\n+    debug!(\"fragments 5 unmoved: {}\", frag_lps(unmoved[]));\n \n     // Swap contents back in.\n     fragments.unmoved_fragments = unmoved;\n@@ -434,7 +434,7 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n             let msg = format!(\"type {} ({}) is not fragmentable\",\n                               parent_ty.repr(tcx), sty_and_variant_info);\n             let opt_span = origin_id.and_then(|id|tcx.map.opt_span(id));\n-            tcx.sess.opt_span_bug(opt_span, msg.as_slice())\n+            tcx.sess.opt_span_bug(opt_span, msg[])\n         }\n     }\n }"}, {"sha": "d7f50ccc6ba3ca19ae18f0d8e21fefd60883209b", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -310,7 +310,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                         self.tcx().sess.span_bug(\n                             cmt.span,\n                             format!(\"invalid borrow lifetime: {}\",\n-                                    loan_region).as_slice());\n+                                    loan_region)[]);\n                     }\n                 };\n                 debug!(\"loan_scope = {}\", loan_scope);"}, {"sha": "73b345a70af4665484821ace157ff4a331d9ab08", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -120,7 +120,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n             bccx.span_err(\n                 move_from.span,\n                 format!(\"cannot move out of {}\",\n-                        bccx.cmt_to_string(&*move_from)).as_slice());\n+                        bccx.cmt_to_string(&*move_from))[]);\n         }\n \n         mc::cat_downcast(ref b, _) |\n@@ -132,7 +132,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                         move_from.span,\n                         format!(\"cannot move out of type `{}`, \\\n                                  which defines the `Drop` trait\",\n-                                b.ty.user_string(bccx.tcx)).as_slice());\n+                                b.ty.user_string(bccx.tcx))[]);\n                 },\n                 _ => panic!(\"this path should not cause illegal move\")\n             }\n@@ -155,10 +155,10 @@ fn note_move_destination(bccx: &BorrowckCtxt,\n             format!(\"to prevent the move, \\\n                      use `ref {0}` or `ref mut {0}` to capture value by \\\n                      reference\",\n-                    pat_name).as_slice());\n+                    pat_name)[]);\n     } else {\n         bccx.span_note(move_to_span,\n                        format!(\"and here (use `ref {0}` or `ref mut {0}`)\",\n-                               pat_name).as_slice());\n+                               pat_name)[]);\n     }\n }"}, {"sha": "a13001b796850f02947a3de8b312314f22a0cb9c", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -146,7 +146,7 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n     check_loans::check_loans(this,\n                              &loan_dfcx,\n                              flowed_moves,\n-                             all_loans.as_slice(),\n+                             all_loans[],\n                              id,\n                              decl,\n                              body);\n@@ -527,7 +527,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     pub fn report(&self, err: BckError<'tcx>) {\n         self.span_err(\n             err.span,\n-            self.bckerr_to_string(&err).as_slice());\n+            self.bckerr_to_string(&err)[]);\n         self.note_and_explain_bckerr(err);\n     }\n \n@@ -549,7 +549,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     use_span,\n                     format!(\"{} of possibly uninitialized variable: `{}`\",\n                             verb,\n-                            self.loan_path_to_string(lp)).as_slice());\n+                            self.loan_path_to_string(lp))[]);\n                 (self.loan_path_to_string(moved_lp),\n                  String::new())\n             }\n@@ -591,7 +591,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     format!(\"{} of {}moved value: `{}`\",\n                             verb,\n                             msg,\n-                            nl).as_slice());\n+                            nl)[]);\n                 (ol, moved_lp_msg)\n             }\n         };\n@@ -610,7 +610,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         self.tcx.sess.bug(format!(\"MoveExpr({}) maps to \\\n                                                    {}, not Expr\",\n                                                   the_move.id,\n-                                                  r).as_slice())\n+                                                  r)[])\n                     }\n                 };\n                 let (suggestion, _) = move_suggestion(self.tcx, param_env, expr_ty,\n@@ -621,7 +621,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             ol,\n                             moved_lp_msg,\n                             expr_ty.user_string(self.tcx),\n-                            suggestion).as_slice());\n+                            suggestion)[]);\n             }\n \n             move_data::MovePat => {\n@@ -632,7 +632,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                              which is moved by default\",\n                             ol,\n                             moved_lp_msg,\n-                            pat_ty.user_string(self.tcx)).as_slice());\n+                            pat_ty.user_string(self.tcx))[]);\n                 self.tcx.sess.span_help(span,\n                     \"use `ref` to override\");\n             }\n@@ -648,7 +648,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         self.tcx.sess.bug(format!(\"Captured({}) maps to \\\n                                                    {}, not Expr\",\n                                                   the_move.id,\n-                                                  r).as_slice())\n+                                                  r)[])\n                     }\n                 };\n                 let (suggestion, help) = move_suggestion(self.tcx,\n@@ -663,7 +663,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             ol,\n                             moved_lp_msg,\n                             expr_ty.user_string(self.tcx),\n-                            suggestion).as_slice());\n+                            suggestion)[]);\n                 self.tcx.sess.span_help(expr_span, help);\n             }\n         }\n@@ -696,7 +696,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.tcx.sess.span_err(\n             span,\n             format!(\"re-assignment of immutable variable `{}`\",\n-                    self.loan_path_to_string(lp)).as_slice());\n+                    self.loan_path_to_string(lp))[]);\n         self.tcx.sess.span_note(assign.span, \"prior assignment occurs here\");\n     }\n \n@@ -822,25 +822,25 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 self.tcx.sess.span_err(\n                     span,\n                     format!(\"{} in an aliasable location\",\n-                             prefix).as_slice());\n+                             prefix)[]);\n             }\n             mc::AliasableClosure(id) => {\n                 self.tcx.sess.span_err(span,\n                                        format!(\"{} in a captured outer \\\n-                                               variable in an `Fn` closure\", prefix).as_slice());\n+                                               variable in an `Fn` closure\", prefix)[]);\n                 span_help!(self.tcx.sess, self.tcx.map.span(id),\n                            \"consider changing this closure to take self by mutable reference\");\n             }\n             mc::AliasableStatic(..) |\n             mc::AliasableStaticMut(..) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"{} in a static location\", prefix).as_slice());\n+                    format!(\"{} in a static location\", prefix)[]);\n             }\n             mc::AliasableBorrowed => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"{} in a `&` reference\", prefix).as_slice());\n+                    format!(\"{} in a `&` reference\", prefix)[]);\n             }\n         }\n \n@@ -908,12 +908,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 note_and_explain_region(\n                     self.tcx,\n                     format!(\"{} would have to be valid for \",\n-                            descr).as_slice(),\n+                            descr)[],\n                     loan_scope,\n                     \"...\");\n                 note_and_explain_region(\n                     self.tcx,\n-                    format!(\"...but {} is only valid for \", descr).as_slice(),\n+                    format!(\"...but {} is only valid for \", descr)[],\n                     ptr_scope,\n                     \"\");\n             }\n@@ -933,7 +933,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 out.push('(');\n                 self.append_loan_path_to_string(&**lp_base, out);\n                 out.push_str(DOWNCAST_PRINTED_OPERATOR);\n-                out.push_str(ty::item_path_str(self.tcx, variant_def_id).as_slice());\n+                out.push_str(ty::item_path_str(self.tcx, variant_def_id)[]);\n                 out.push(')');\n             }\n \n@@ -947,7 +947,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     }\n                     mc::PositionalField(idx) => {\n                         out.push('.');\n-                        out.push_str(idx.to_string().as_slice());\n+                        out.push_str(idx.to_string()[]);\n                     }\n                 }\n             }\n@@ -979,7 +979,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 out.push('(');\n                 self.append_autoderefd_loan_path_to_string(&**lp_base, out);\n                 out.push(':');\n-                out.push_str(ty::item_path_str(self.tcx, variant_def_id).as_slice());\n+                out.push_str(ty::item_path_str(self.tcx, variant_def_id)[]);\n                 out.push(')');\n             }\n "}, {"sha": "e2813c8e9882ad112e55896fafd6d3357d3ec902", "filename": "src/librustc_borrowck/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fgraphviz.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -59,7 +59,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n             if seen_one { sets.push_str(\" \"); } else { seen_one = true; }\n             sets.push_str(variant.short_name());\n             sets.push_str(\": \");\n-            sets.push_str(self.dataflow_for_variant(e, n, variant).as_slice());\n+            sets.push_str(self.dataflow_for_variant(e, n, variant)[]);\n         }\n         sets\n     }\n@@ -88,7 +88,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n                 set.push_str(\", \");\n             }\n             let loan_str = self.borrowck_ctxt.loan_path_to_string(&*lp);\n-            set.push_str(loan_str.as_slice());\n+            set.push_str(loan_str[]);\n             saw_some = true;\n             true\n         });"}, {"sha": "20bb9c2f4fd1cd5f6445e7b79a2d6348444382cf", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -58,12 +58,12 @@ pub fn compile_input(sess: Session,\n             let outputs = build_output_filenames(input,\n                                                  outdir,\n                                                  output,\n-                                                 krate.attrs.as_slice(),\n+                                                 krate.attrs[],\n                                                  &sess);\n-            let id = link::find_crate_name(Some(&sess), krate.attrs.as_slice(),\n+            let id = link::find_crate_name(Some(&sess), krate.attrs[],\n                                            input);\n             let expanded_crate\n-                = match phase_2_configure_and_expand(&sess, krate, id.as_slice(),\n+                = match phase_2_configure_and_expand(&sess, krate, id[],\n                                                      addl_plugins) {\n                     None => return,\n                     Some(k) => k\n@@ -75,7 +75,7 @@ pub fn compile_input(sess: Session,\n         let mut forest = ast_map::Forest::new(expanded_crate);\n         let ast_map = assign_node_ids_and_map(&sess, &mut forest);\n \n-        write_out_deps(&sess, input, &outputs, id.as_slice());\n+        write_out_deps(&sess, input, &outputs, id[]);\n \n         if stop_after_phase_2(&sess) { return; }\n \n@@ -163,9 +163,9 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     let time_passes = sess.time_passes();\n \n     *sess.crate_types.borrow_mut() =\n-        collect_crate_types(sess, krate.attrs.as_slice());\n+        collect_crate_types(sess, krate.attrs[]);\n     *sess.crate_metadata.borrow_mut() =\n-        collect_crate_metadata(sess, krate.attrs.as_slice());\n+        collect_crate_metadata(sess, krate.attrs[]);\n \n     time(time_passes, \"gated feature checking\", (), |_| {\n         let (features, unknown_features) =\n@@ -257,8 +257,8 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n             if cfg!(windows) {\n                 _old_path = os::getenv(\"PATH\").unwrap_or(_old_path);\n                 let mut new_path = sess.host_filesearch().get_dylib_search_paths();\n-                new_path.extend(os::split_paths(_old_path.as_slice()).into_iter());\n-                os::setenv(\"PATH\", os::join_paths(new_path.as_slice()).unwrap());\n+                new_path.extend(os::split_paths(_old_path[]).into_iter());\n+                os::setenv(\"PATH\", os::join_paths(new_path[]).unwrap());\n             }\n             let cfg = syntax::ext::expand::ExpansionConfig {\n                 crate_name: crate_name.to_string(),\n@@ -503,7 +503,7 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n         time(sess.time_passes(), \"LLVM passes\", (), |_|\n             write::run_passes(sess,\n                               trans,\n-                              sess.opts.output_types.as_slice(),\n+                              sess.opts.output_types[],\n                               outputs));\n     }\n \n@@ -517,14 +517,14 @@ pub fn phase_6_link_output(sess: &Session,\n                            outputs: &OutputFilenames) {\n     let old_path = os::getenv(\"PATH\").unwrap_or_else(||String::new());\n     let mut new_path = sess.host_filesearch().get_tools_search_paths();\n-    new_path.extend(os::split_paths(old_path.as_slice()).into_iter());\n-    os::setenv(\"PATH\", os::join_paths(new_path.as_slice()).unwrap());\n+    new_path.extend(os::split_paths(old_path[]).into_iter());\n+    os::setenv(\"PATH\", os::join_paths(new_path[]).unwrap());\n \n     time(sess.time_passes(), \"linking\", (), |_|\n          link::link_binary(sess,\n                            trans,\n                            outputs,\n-                           trans.link.crate_name.as_slice()));\n+                           trans.link.crate_name[]));\n \n     os::setenv(\"PATH\", old_path);\n }\n@@ -613,7 +613,7 @@ fn write_out_deps(sess: &Session,\n         // write Makefile-compatible dependency rules\n         let files: Vec<String> = sess.codemap().files.borrow()\n                                    .iter().filter(|fmap| fmap.is_real_file())\n-                                   .map(|fmap| escape_dep_filename(fmap.name.as_slice()))\n+                                   .map(|fmap| escape_dep_filename(fmap.name[]))\n                                    .collect();\n         let mut file = try!(io::File::create(&deps_filename));\n         for path in out_filenames.iter() {\n@@ -627,7 +627,7 @@ fn write_out_deps(sess: &Session,\n         Ok(()) => {}\n         Err(e) => {\n             sess.fatal(format!(\"error writing dependencies to `{}`: {}\",\n-                               deps_filename.display(), e).as_slice());\n+                               deps_filename.display(), e)[]);\n         }\n     }\n }\n@@ -698,7 +698,7 @@ pub fn collect_crate_types(session: &Session,\n         if !res {\n             session.warn(format!(\"dropping unsupported crate type `{}` \\\n                                    for target `{}`\",\n-                                 *crate_type, session.opts.target_triple).as_slice());\n+                                 *crate_type, session.opts.target_triple)[]);\n         }\n \n         res"}, {"sha": "e2791aff14e49bcef25018d580f4a222263c7ee4", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 61, "deletions": 19, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -55,6 +55,7 @@ use rustc::DIAGNOSTICS;\n \n use std::any::AnyRefExt;\n use std::io;\n+use std::iter::repeat;\n use std::os;\n use std::thread;\n \n@@ -88,12 +89,12 @@ fn run_compiler(args: &[String]) {\n     let descriptions = diagnostics::registry::Registry::new(&DIAGNOSTICS);\n     match matches.opt_str(\"explain\") {\n         Some(ref code) => {\n-            match descriptions.find_description(code.as_slice()) {\n+            match descriptions.find_description(code[]) {\n                 Some(ref description) => {\n                     println!(\"{}\", description);\n                 }\n                 None => {\n-                    early_error(format!(\"no extended information for {}\", code).as_slice());\n+                    early_error(format!(\"no extended information for {}\", code)[]);\n                 }\n             }\n             return;\n@@ -119,7 +120,7 @@ fn run_compiler(args: &[String]) {\n             early_error(\"no input filename given\");\n         }\n         1u => {\n-            let ifile = matches.free[0].as_slice();\n+            let ifile = matches.free[0][];\n             if ifile == \"-\" {\n                 let contents = io::stdin().read_to_end().unwrap();\n                 let src = String::from_utf8(contents).unwrap();\n@@ -138,8 +139,19 @@ fn run_compiler(args: &[String]) {\n     }\n \n     let pretty = matches.opt_default(\"pretty\", \"normal\").map(|a| {\n-        pretty::parse_pretty(&sess, a.as_slice())\n+        // stable pretty-print variants only\n+        pretty::parse_pretty(&sess, a.as_slice(), false)\n     });\n+    let pretty = if pretty.is_none() &&\n+        sess.debugging_opt(config::UNSTABLE_OPTIONS) {\n+            matches.opt_str(\"xpretty\").map(|a| {\n+                // extended with unstable pretty-print variants\n+                pretty::parse_pretty(&sess, a.as_slice(), true)\n+            })\n+        } else {\n+            pretty\n+        };\n+\n     match pretty.into_iter().next() {\n         Some((ppm, opt_uii)) => {\n             pretty::pretty_print_input(sess, cfg, &input, ppm, opt_uii, ofile);\n@@ -196,12 +208,16 @@ pub fn version(binary: &str, matches: &getopts::Matches) {\n     }\n }\n \n-fn usage(verbose: bool) {\n+fn usage(verbose: bool, include_unstable_options: bool) {\n     let groups = if verbose {\n-        config::optgroups()\n+        config::rustc_optgroups()\n     } else {\n-        config::short_optgroups()\n+        config::rustc_short_optgroups()\n     };\n+    let groups : Vec<_> = groups.into_iter()\n+        .filter(|x| include_unstable_options || x.is_stable())\n+        .map(|x|x.opt_group)\n+        .collect();\n     let message = format!(\"Usage: rustc [OPTIONS] INPUT\");\n     let extra_help = if verbose {\n         \"\"\n@@ -261,7 +277,8 @@ Available lint options:\n         .map(|&s| s.name.width(true))\n         .max().unwrap_or(0);\n     let padded = |x: &str| {\n-        let mut s = \" \".repeat(max_name_len - x.char_len());\n+        let mut s = repeat(\" \").take(max_name_len - x.chars().count())\n+                               .collect::<String>();\n         s.push_str(x);\n         s\n     };\n@@ -274,7 +291,7 @@ Available lint options:\n         for lint in lints.into_iter() {\n             let name = lint.name_lower().replace(\"_\", \"-\");\n             println!(\"    {}  {:7.7}  {}\",\n-                     padded(name.as_slice()), lint.default_level.as_str(), lint.desc);\n+                     padded(name[]), lint.default_level.as_str(), lint.desc);\n         }\n         println!(\"\\n\");\n     };\n@@ -287,7 +304,8 @@ Available lint options:\n         .map(|&(s, _)| s.width(true))\n         .max().unwrap_or(0);\n     let padded = |x: &str| {\n-        let mut s = \" \".repeat(max_name_len - x.char_len());\n+        let mut s = repeat(\" \").take(max_name_len - x.chars().count())\n+                               .collect::<String>();\n         s.push_str(x);\n         s\n     };\n@@ -303,7 +321,7 @@ Available lint options:\n             let desc = to.into_iter().map(|x| x.as_str().replace(\"_\", \"-\"))\n                          .collect::<Vec<String>>().connect(\", \");\n             println!(\"    {}  {}\",\n-                     padded(name.as_slice()), desc);\n+                     padded(name[]), desc);\n         }\n         println!(\"\\n\");\n     };\n@@ -362,20 +380,45 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n     let _binary = args.remove(0).unwrap();\n \n     if args.is_empty() {\n-        usage(false);\n+        // user did not write `-v` nor `-Z unstable-options`, so do not\n+        // include that extra information.\n+        usage(false, false);\n         return None;\n     }\n \n     let matches =\n-        match getopts::getopts(args.as_slice(), config::optgroups().as_slice()) {\n+        match getopts::getopts(args[], config::optgroups()[]) {\n             Ok(m) => m,\n-            Err(f) => {\n-                early_error(f.to_string().as_slice());\n+            Err(f_stable_attempt) => {\n+                // redo option parsing, including unstable options this time,\n+                // in anticipation that the mishandled option was one of the\n+                // unstable ones.\n+                let all_groups : Vec<getopts::OptGroup>\n+                    = config::rustc_optgroups().into_iter().map(|x|x.opt_group).collect();\n+                match getopts::getopts(args.as_slice(), all_groups.as_slice()) {\n+                    Ok(m_unstable) => {\n+                        let r = m_unstable.opt_strs(\"Z\");\n+                        let include_unstable_options = r.iter().any(|x| *x == \"unstable-options\");\n+                        if include_unstable_options {\n+                            m_unstable\n+                        } else {\n+                            early_error(f_stable_attempt.to_string().as_slice());\n+                        }\n+                    }\n+                    Err(_) => {\n+                        // ignore the error from the unstable attempt; just\n+                        // pass the error we got from the first try.\n+                        early_error(f_stable_attempt.to_string().as_slice());\n+                    }\n+                }\n             }\n         };\n \n+    let r = matches.opt_strs(\"Z\");\n+    let include_unstable_options = r.iter().any(|x| *x == \"unstable-options\");\n+\n     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n-        usage(matches.opt_present(\"verbose\"));\n+        usage(matches.opt_present(\"verbose\"), include_unstable_options);\n         return None;\n     }\n \n@@ -518,16 +561,15 @@ pub fn monitor<F:FnOnce()+Send>(f: F) {\n                     \"run with `RUST_BACKTRACE=1` for a backtrace\".to_string(),\n                 ];\n                 for note in xs.iter() {\n-                    emitter.emit(None, note.as_slice(), None, diagnostic::Note)\n+                    emitter.emit(None, note[], None, diagnostic::Note)\n                 }\n \n                 match r.read_to_string() {\n                     Ok(s) => println!(\"{}\", s),\n                     Err(e) => {\n                         emitter.emit(None,\n                                      format!(\"failed to read internal \\\n-                                              stderr: {}\",\n-                                             e).as_slice(),\n+                                              stderr: {}\", e)[],\n                                      None,\n                                      diagnostic::Error)\n                     }"}, {"sha": "9334c648a1f70b97a65d8d3d55ca8f69ef3cddc2", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 109, "deletions": 27, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -30,7 +30,10 @@ use rustc_borrowck::graphviz as borrowck_dot;\n \n use syntax::ast;\n use syntax::ast_map::{mod, blocks, NodePrinter};\n+use syntax::codemap;\n+use syntax::fold::{mod, Folder};\n use syntax::print::{pp, pprust};\n+use syntax::ptr::P;\n \n use graphviz as dot;\n \n@@ -42,6 +45,7 @@ use arena::TypedArena;\n #[deriving(Copy, PartialEq, Show)]\n pub enum PpSourceMode {\n     PpmNormal,\n+    PpmEveryBodyLoops,\n     PpmExpanded,\n     PpmTyped,\n     PpmIdentified,\n@@ -55,26 +59,36 @@ pub enum PpMode {\n     PpmFlowGraph,\n }\n \n-pub fn parse_pretty(sess: &Session, name: &str) -> (PpMode, Option<UserIdentifiedItem>) {\n+pub fn parse_pretty(sess: &Session,\n+                    name: &str,\n+                    extended: bool) -> (PpMode, Option<UserIdentifiedItem>) {\n     let mut split = name.splitn(1, '=');\n     let first = split.next().unwrap();\n     let opt_second = split.next();\n-    let first = match first {\n-        \"normal\"       => PpmSource(PpmNormal),\n-        \"expanded\"     => PpmSource(PpmExpanded),\n-        \"typed\"        => PpmSource(PpmTyped),\n-        \"expanded,identified\" => PpmSource(PpmExpandedIdentified),\n-        \"expanded,hygiene\" => PpmSource(PpmExpandedHygiene),\n-        \"identified\"   => PpmSource(PpmIdentified),\n-        \"flowgraph\"    => PpmFlowGraph,\n+    let first = match (first, extended) {\n+        (\"normal\", _)       => PpmSource(PpmNormal),\n+        (\"everybody_loops\", true) => PpmSource(PpmEveryBodyLoops),\n+        (\"expanded\", _)     => PpmSource(PpmExpanded),\n+        (\"typed\", _)        => PpmSource(PpmTyped),\n+        (\"expanded,identified\", _) => PpmSource(PpmExpandedIdentified),\n+        (\"expanded,hygiene\", _) => PpmSource(PpmExpandedHygiene),\n+        (\"identified\", _)   => PpmSource(PpmIdentified),\n+        (\"flowgraph\", true)    => PpmFlowGraph,\n         _ => {\n-            sess.fatal(format!(\n-                \"argument to `pretty` must be one of `normal`, \\\n-                 `expanded`, `flowgraph=<nodeid>`, `typed`, `identified`, \\\n-                 or `expanded,identified`; got {}\", name).as_slice());\n+            if extended {\n+                sess.fatal(format!(\n+                    \"argument to `xpretty` must be one of `normal`, \\\n+                     `expanded`, `flowgraph=<nodeid>`, `typed`, `identified`, \\\n+                     `expanded,identified`, or `everybody_loops`; got {}\", name).as_slice());\n+            } else {\n+                sess.fatal(format!(\n+                    \"argument to `pretty` must be one of `normal`, \\\n+                     `expanded`, `typed`, `identified`, \\\n+                     or `expanded,identified`; got {}\", name).as_slice());\n+            }\n         }\n     };\n-    let opt_second = opt_second.and_then::<UserIdentifiedItem, _>(from_str);\n+    let opt_second = opt_second.and_then(|s| s.parse::<UserIdentifiedItem>());\n     (first, opt_second)\n }\n \n@@ -105,7 +119,7 @@ impl PpSourceMode {\n         F: FnOnce(&PrinterSupport, B) -> A,\n     {\n         match *self {\n-            PpmNormal | PpmExpanded => {\n+            PpmNormal | PpmEveryBodyLoops | PpmExpanded => {\n                 let annotation = NoAnn { sess: sess, ast_map: ast_map };\n                 f(&annotation, payload)\n             }\n@@ -276,7 +290,7 @@ impl<'tcx> pprust::PpAnn for TypedAnnotation<'tcx> {\n                 try!(pp::word(&mut s.s,\n                               ppaux::ty_to_string(\n                                   tcx,\n-                                  ty::expr_ty(tcx, expr)).as_slice()));\n+                                  ty::expr_ty(tcx, expr))[]));\n                 s.pclose()\n             }\n             _ => Ok(())\n@@ -311,7 +325,7 @@ pub enum UserIdentifiedItem {\n \n impl FromStr for UserIdentifiedItem {\n     fn from_str(s: &str) -> Option<UserIdentifiedItem> {\n-        from_str(s).map(ItemViaNode).or_else(|| {\n+        s.parse().map(ItemViaNode).or_else(|| {\n             let v : Vec<_> = s.split_str(\"::\")\n                 .map(|x|x.to_string())\n                 .collect();\n@@ -322,7 +336,7 @@ impl FromStr for UserIdentifiedItem {\n \n enum NodesMatchingUII<'a, 'ast: 'a> {\n     NodesMatchingDirect(option::IntoIter<ast::NodeId>),\n-    NodesMatchingSuffix(ast_map::NodesMatchingSuffix<'a, 'ast, String>),\n+    NodesMatchingSuffix(ast_map::NodesMatchingSuffix<'a, 'ast>),\n }\n \n impl<'a, 'ast> Iterator<ast::NodeId> for NodesMatchingUII<'a, 'ast> {\n@@ -348,7 +362,7 @@ impl UserIdentifiedItem {\n             ItemViaNode(node_id) =>\n                 NodesMatchingDirect(Some(node_id).into_iter()),\n             ItemViaPath(ref parts) =>\n-                NodesMatchingSuffix(map.nodes_matching_suffix(parts.as_slice())),\n+                NodesMatchingSuffix(map.nodes_matching_suffix(parts[])),\n         }\n     }\n \n@@ -360,7 +374,7 @@ impl UserIdentifiedItem {\n                         user_option,\n                         self.reconstructed_input(),\n                         is_wrong_because);\n-            sess.fatal(message.as_slice())\n+            sess.fatal(message[])\n         };\n \n         let mut saw_node = ast::DUMMY_NODE_ID;\n@@ -384,6 +398,7 @@ impl UserIdentifiedItem {\n fn needs_ast_map(ppm: &PpMode, opt_uii: &Option<UserIdentifiedItem>) -> bool {\n     match *ppm {\n         PpmSource(PpmNormal) |\n+        PpmSource(PpmEveryBodyLoops) |\n         PpmSource(PpmIdentified) => opt_uii.is_some(),\n \n         PpmSource(PpmExpanded) |\n@@ -397,6 +412,7 @@ fn needs_ast_map(ppm: &PpMode, opt_uii: &Option<UserIdentifiedItem>) -> bool {\n fn needs_expansion(ppm: &PpMode) -> bool {\n     match *ppm {\n         PpmSource(PpmNormal) |\n+        PpmSource(PpmEveryBodyLoops) |\n         PpmSource(PpmIdentified) => false,\n \n         PpmSource(PpmExpanded) |\n@@ -407,19 +423,85 @@ fn needs_expansion(ppm: &PpMode) -> bool {\n     }\n }\n \n+struct ReplaceBodyWithLoop {\n+    within_static_or_const: bool,\n+}\n+\n+impl ReplaceBodyWithLoop {\n+    fn new() -> ReplaceBodyWithLoop {\n+        ReplaceBodyWithLoop { within_static_or_const: false }\n+    }\n+}\n+\n+impl fold::Folder for ReplaceBodyWithLoop {\n+    fn fold_item_underscore(&mut self, i: ast::Item_) -> ast::Item_ {\n+        match i {\n+            ast::ItemStatic(..) | ast::ItemConst(..) => {\n+                self.within_static_or_const = true;\n+                let ret = fold::noop_fold_item_underscore(i, self);\n+                self.within_static_or_const = false;\n+                return ret;\n+            }\n+            _ => {\n+                fold::noop_fold_item_underscore(i, self)\n+            }\n+        }\n+    }\n+\n+\n+    fn fold_block(&mut self, b: P<ast::Block>) -> P<ast::Block> {\n+        fn expr_to_block(rules: ast::BlockCheckMode,\n+                         e: Option<P<ast::Expr>>) -> P<ast::Block> {\n+            P(ast::Block {\n+                expr: e,\n+                view_items: vec![], stmts: vec![], rules: rules,\n+                id: ast::DUMMY_NODE_ID, span: codemap::DUMMY_SP,\n+            })\n+        }\n+\n+        if !self.within_static_or_const {\n+\n+            let empty_block = expr_to_block(ast::DefaultBlock, None);\n+            let loop_expr = P(ast::Expr {\n+                node: ast::ExprLoop(empty_block, None),\n+                id: ast::DUMMY_NODE_ID, span: codemap::DUMMY_SP\n+            });\n+\n+            expr_to_block(b.rules, Some(loop_expr))\n+\n+        } else {\n+            fold::noop_fold_block(b, self)\n+        }\n+    }\n+\n+    // in general the pretty printer processes unexpanded code, so\n+    // we override the default `fold_mac` method which panics.\n+    fn fold_mac(&mut self, _macro: ast::Mac) -> ast::Mac {\n+        fold::noop_fold_mac(_macro, self)\n+    }\n+}\n+\n pub fn pretty_print_input(sess: Session,\n                           cfg: ast::CrateConfig,\n                           input: &Input,\n                           ppm: PpMode,\n                           opt_uii: Option<UserIdentifiedItem>,\n                           ofile: Option<Path>) {\n     let krate = driver::phase_1_parse_input(&sess, cfg, input);\n+\n+    let krate = if let PpmSource(PpmEveryBodyLoops) = ppm {\n+        let mut fold = ReplaceBodyWithLoop::new();\n+        fold.fold_crate(krate)\n+    } else {\n+        krate\n+    };\n+\n     let id = link::find_crate_name(Some(&sess), krate.attrs.as_slice(), input);\n \n     let is_expanded = needs_expansion(&ppm);\n     let compute_ast_map = needs_ast_map(&ppm, &opt_uii);\n     let krate = if compute_ast_map {\n-        match driver::phase_2_configure_and_expand(&sess, krate, id.as_slice(), None) {\n+        match driver::phase_2_configure_and_expand(&sess, krate, id[], None) {\n             None => return,\n             Some(k) => k\n         }\n@@ -438,7 +520,7 @@ pub fn pretty_print_input(sess: Session,\n     };\n \n     let src_name = driver::source_name(input);\n-    let src = sess.codemap().get_filemap(src_name.as_slice())\n+    let src = sess.codemap().get_filemap(src_name[])\n                             .src.as_bytes().to_vec();\n     let mut rdr = MemReader::new(src);\n \n@@ -499,15 +581,15 @@ pub fn pretty_print_input(sess: Session,\n             debug!(\"pretty printing flow graph for {}\", opt_uii);\n             let uii = opt_uii.unwrap_or_else(|| {\n                 sess.fatal(format!(\"`pretty flowgraph=..` needs NodeId (int) or\n-                                     unique path suffix (b::c::d)\").as_slice())\n+                                     unique path suffix (b::c::d)\")[])\n \n             });\n             let ast_map = ast_map.expect(\"--pretty flowgraph missing ast_map\");\n             let nodeid = uii.to_one_node_id(\"--pretty\", &sess, &ast_map);\n \n             let node = ast_map.find(nodeid).unwrap_or_else(|| {\n                 sess.fatal(format!(\"--pretty flowgraph couldn't find id: {}\",\n-                                   nodeid).as_slice())\n+                                   nodeid)[])\n             });\n \n             let code = blocks::Code::from_node(node);\n@@ -526,8 +608,8 @@ pub fn pretty_print_input(sess: Session,\n                     // point to what was found, if there's an\n                     // accessible span.\n                     match ast_map.opt_span(nodeid) {\n-                        Some(sp) => sess.span_fatal(sp, message.as_slice()),\n-                        None => sess.fatal(message.as_slice())\n+                        Some(sp) => sess.span_fatal(sp, message[]),\n+                        None => sess.fatal(message[])\n                     }\n                 }\n             }\n@@ -587,7 +669,7 @@ fn print_flowgraph<W:io::Writer>(variants: Vec<borrowck_dot::Variant>,\n             let m = \"graphviz::render failed\";\n             io::IoError {\n                 detail: Some(match orig_detail {\n-                    None => m.into_string(),\n+                    None => m.to_string(),\n                     Some(d) => format!(\"{}: {}\", m, d)\n                 }),\n                 ..ioerr"}, {"sha": "526bbca8d70ddb0a34812bce2b87868bf2fd4960", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -253,7 +253,18 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n                 output_ty: Ty<'tcx>)\n                 -> Ty<'tcx>\n     {\n-        ty::mk_ctor_fn(self.infcx.tcx, input_tys, output_ty)\n+        let input_args = input_tys.iter().map(|ty| *ty).collect();\n+        ty::mk_bare_fn(self.infcx.tcx,\n+                       None,\n+                       ty::BareFnTy {\n+                           unsafety: ast::Unsafety::Normal,\n+                           abi: abi::Rust,\n+                           sig: ty::Binder(ty::FnSig {\n+                               inputs: input_args,\n+                               output: ty::FnConverging(output_ty),\n+                               variadic: false\n+                           })\n+                       })\n     }\n \n     pub fn t_nil(&self) -> Ty<'tcx> {"}, {"sha": "bf9e9294307ef241aa7e45c432d3ea3fd211afdb", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 63, "deletions": 62, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -57,6 +57,7 @@ use rustc::middle::privacy::*;\n use rustc::middle::subst::{ParamSpace, FnSpace, TypeSpace};\n use rustc::middle::ty::{CaptureModeMap, Freevar, FreevarMap, TraitMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, DefIdSet, FnvHashMap};\n+use rustc::util::lev_distance::lev_distance;\n \n use syntax::ast::{Arm, BindByRef, BindByValue, BindingMode, Block, Crate, CrateNum};\n use syntax::ast::{DeclItem, DefId, Expr, ExprAgain, ExprBreak, ExprField};\n@@ -1118,14 +1119,14 @@ impl<'a> Resolver<'a> {\n                     self.resolve_error(sp,\n                         format!(\"duplicate definition of {} `{}`\",\n                              namespace_error_to_string(duplicate_type),\n-                             token::get_name(name)).as_slice());\n+                             token::get_name(name))[]);\n                     {\n                         let r = child.span_for_namespace(ns);\n                         for sp in r.iter() {\n                             self.session.span_note(*sp,\n                                  format!(\"first definition of {} `{}` here\",\n                                       namespace_error_to_string(duplicate_type),\n-                                      token::get_name(name)).as_slice());\n+                                      token::get_name(name))[]);\n                         }\n                     }\n                 }\n@@ -2146,7 +2147,7 @@ impl<'a> Resolver<'a> {\n                 debug!(\"(building import directive) building import \\\n                         directive: {}::{}\",\n                        self.names_to_string(module_.imports.borrow().last().unwrap()\n-                                                 .module_path.as_slice()),\n+                                                 .module_path[]),\n                        token::get_name(target));\n \n                 let mut import_resolutions = module_.import_resolutions\n@@ -2264,10 +2265,10 @@ impl<'a> Resolver<'a> {\n                     let msg = format!(\"unresolved import `{}`{}\",\n                                       self.import_path_to_string(\n                                           import_directive.module_path\n-                                                          .as_slice(),\n+                                                          [],\n                                           import_directive.subclass),\n                                       help);\n-                    self.resolve_error(span, msg.as_slice());\n+                    self.resolve_error(span, msg[]);\n                 }\n                 Indeterminate => break, // Bail out. We'll come around next time.\n                 Success(()) => () // Good. Continue.\n@@ -2297,7 +2298,7 @@ impl<'a> Resolver<'a> {\n                                         .iter()\n                                         .map(|seg| seg.identifier.name)\n                                         .collect();\n-        self.names_to_string(names.as_slice())\n+        self.names_to_string(names[])\n     }\n \n     fn import_directive_subclass_to_string(&mut self,\n@@ -2339,7 +2340,7 @@ impl<'a> Resolver<'a> {\n \n         debug!(\"(resolving import for module) resolving import `{}::...` in \\\n                 `{}`\",\n-               self.names_to_string(module_path.as_slice()),\n+               self.names_to_string(module_path[]),\n                self.module_to_string(&*module_));\n \n         // First, resolve the module path for the directive, if necessary.\n@@ -2348,7 +2349,7 @@ impl<'a> Resolver<'a> {\n             Some((self.graph_root.get_module(), LastMod(AllPublic)))\n         } else {\n             match self.resolve_module_path(module_.clone(),\n-                                           module_path.as_slice(),\n+                                           module_path[],\n                                            DontUseLexicalScope,\n                                            import_directive.span,\n                                            ImportSearch) {\n@@ -2940,7 +2941,7 @@ impl<'a> Resolver<'a> {\n                                     ValueNS => \"value\",\n                                   },\n                                   token::get_name(name).get());\n-                self.session.span_err(import_span, msg.as_slice());\n+                self.session.span_err(import_span, msg[]);\n             }\n             Some(_) | None => {}\n         }\n@@ -2955,7 +2956,7 @@ impl<'a> Resolver<'a> {\n         if !name_bindings.defined_in_namespace_with(namespace, IMPORTABLE) {\n             let msg = format!(\"`{}` is not directly importable\",\n                               token::get_name(name));\n-            self.session.span_err(import_span, msg.as_slice());\n+            self.session.span_err(import_span, msg[]);\n         }\n     }\n \n@@ -2980,7 +2981,7 @@ impl<'a> Resolver<'a> {\n                                        crate in this module \\\n                                        (maybe you meant `use {0}::*`?)\",\n                                       token::get_name(name).get());\n-                    self.session.span_err(import_span, msg.as_slice());\n+                    self.session.span_err(import_span, msg[]);\n                 }\n                 Some(_) | None => {}\n             }\n@@ -3002,7 +3003,7 @@ impl<'a> Resolver<'a> {\n                     let msg = format!(\"import `{}` conflicts with value \\\n                                        in this module\",\n                                       token::get_name(name).get());\n-                    self.session.span_err(import_span, msg.as_slice());\n+                    self.session.span_err(import_span, msg[]);\n                     if let Some(span) = value.value_span {\n                         self.session.span_note(span,\n                                                \"conflicting value here\");\n@@ -3020,7 +3021,7 @@ impl<'a> Resolver<'a> {\n                             let msg = format!(\"import `{}` conflicts with type in \\\n                                                this module\",\n                                               token::get_name(name).get());\n-                            self.session.span_err(import_span, msg.as_slice());\n+                            self.session.span_err(import_span, msg[]);\n                             if let Some(span) = ty.type_span {\n                                 self.session.span_note(span,\n                                                        \"note conflicting type here\")\n@@ -3033,7 +3034,7 @@ impl<'a> Resolver<'a> {\n                                         let msg = format!(\"inherent implementations \\\n                                                            are only allowed on types \\\n                                                            defined in the current module\");\n-                                        self.session.span_err(span, msg.as_slice());\n+                                        self.session.span_err(span, msg[]);\n                                         self.session.span_note(import_span,\n                                                                \"import from other module here\")\n                                     }\n@@ -3042,7 +3043,7 @@ impl<'a> Resolver<'a> {\n                                     let msg = format!(\"import `{}` conflicts with existing \\\n                                                        submodule\",\n                                                       token::get_name(name).get());\n-                                    self.session.span_err(import_span, msg.as_slice());\n+                                    self.session.span_err(import_span, msg[]);\n                                     if let Some(span) = ty.type_span {\n                                         self.session.span_note(span,\n                                                                \"note conflicting module here\")\n@@ -3072,7 +3073,7 @@ impl<'a> Resolver<'a> {\n                 .span_err(span,\n                           format!(\"an external crate named `{}` has already \\\n                                    been imported into this module\",\n-                                  token::get_name(name).get()).as_slice());\n+                                  token::get_name(name).get())[]);\n         }\n     }\n \n@@ -3091,7 +3092,7 @@ impl<'a> Resolver<'a> {\n                           format!(\"the name `{}` conflicts with an external \\\n                                    crate that has been imported into this \\\n                                    module\",\n-                                  token::get_name(name).get()).as_slice());\n+                                  token::get_name(name).get())[]);\n         }\n     }\n \n@@ -3139,7 +3140,7 @@ impl<'a> Resolver<'a> {\n                     let segment_name = token::get_name(name);\n                     let module_name = self.module_to_string(&*search_module);\n                     let mut span = span;\n-                    let msg = if \"???\" == module_name.as_slice() {\n+                    let msg = if \"???\" == module_name[] {\n                         span.hi = span.lo + Pos::from_uint(segment_name.get().len());\n \n                         match search_parent_externals(name,\n@@ -3252,14 +3253,14 @@ impl<'a> Resolver<'a> {\n         match module_prefix_result {\n             Failed(None) => {\n                 let mpath = self.names_to_string(module_path);\n-                let mpath = mpath.as_slice();\n+                let mpath = mpath[];\n                 match mpath.rfind(':') {\n                     Some(idx) => {\n                         let msg = format!(\"Could not find `{}` in `{}`\",\n                                             // idx +- 1 to account for the\n                                             // colons on either side\n-                                            mpath.slice_from(idx + 1),\n-                                            mpath.slice_to(idx - 1));\n+                                            mpath[idx + 1..],\n+                                            mpath[0..idx - 1]);\n                         return Failed(Some((span, msg)));\n                     },\n                     None => {\n@@ -3430,7 +3431,7 @@ impl<'a> Resolver<'a> {\n                                               true) {\n                 Failed(Some((span, msg))) =>\n                     self.resolve_error(span, format!(\"failed to resolve. {}\",\n-                                                     msg)),\n+                                                     msg)[]),\n                 Failed(None) => (), // Continue up the search chain.\n                 Indeterminate => {\n                     // We couldn't see through the higher scope because of an\n@@ -3685,8 +3686,8 @@ impl<'a> Resolver<'a> {\n                                    \"unresolved import\");\n             } else {\n                 let err = format!(\"unresolved import (maybe you meant `{}::*`?)\",\n-                                  sn.slice(0, sn.len()));\n-                self.resolve_error((*imports)[index].span, err.as_slice());\n+                                  sn);\n+                self.resolve_error((*imports)[index].span, err[]);\n             }\n         }\n \n@@ -3778,7 +3779,7 @@ impl<'a> Resolver<'a> {\n         match def_like {\n             DlDef(d @ DefUpvar(..)) => {\n                 self.session.span_bug(span,\n-                    format!(\"unexpected {} in bindings\", d).as_slice())\n+                    format!(\"unexpected {} in bindings\", d)[])\n             }\n             DlDef(d @ DefLocal(_)) => {\n                 let node_id = d.def_id().node;\n@@ -3994,7 +3995,7 @@ impl<'a> Resolver<'a> {\n                                             generics,\n                                             implemented_traits,\n                                             &**self_type,\n-                                            impl_items.as_slice());\n+                                            impl_items[]);\n             }\n \n             ItemTrait(_, ref generics, ref unbound, ref bounds, ref trait_items) => {\n@@ -4079,7 +4080,7 @@ impl<'a> Resolver<'a> {\n             ItemStruct(ref struct_def, ref generics) => {\n                 self.resolve_struct(item.id,\n                                     generics,\n-                                    struct_def.fields.as_slice());\n+                                    struct_def.fields[]);\n             }\n \n             ItemMod(ref module_) => {\n@@ -4152,7 +4153,7 @@ impl<'a> Resolver<'a> {\n                                                     parameter in this type \\\n                                                     parameter list\",\n                                                    token::get_name(\n-                                                       name)).as_slice())\n+                                                       name))[])\n                     }\n                     seen_bindings.insert(name);\n \n@@ -4329,7 +4330,7 @@ impl<'a> Resolver<'a> {\n                 };\n \n                 let msg = format!(\"attempt to {} a nonexistent trait `{}`\", usage_str, path_str);\n-                self.resolve_error(trait_reference.path.span, msg.as_slice());\n+                self.resolve_error(trait_reference.path.span, msg[]);\n             }\n             Some(def) => {\n                 match def {\n@@ -4341,14 +4342,14 @@ impl<'a> Resolver<'a> {\n                         self.resolve_error(trait_reference.path.span,\n                                            format!(\"`{}` is not a trait\",\n                                                    self.path_names_to_string(\n-                                                       &trait_reference.path)));\n+                                                       &trait_reference.path))[]);\n \n                         // If it's a typedef, give a note\n                         if let DefTy(..) = def {\n                             self.session.span_note(\n                                 trait_reference.path.span,\n                                 format!(\"`type` aliases cannot be used for traits\")\n-                                    .as_slice());\n+                                    []);\n                         }\n                     }\n                 }\n@@ -4545,7 +4546,7 @@ impl<'a> Resolver<'a> {\n                 self.resolve_error(span,\n                                     format!(\"method `{}` is not a member of trait `{}`\",\n                                             token::get_name(name),\n-                                            path_str).as_slice());\n+                                            path_str)[]);\n             }\n         }\n     }\n@@ -4612,7 +4613,7 @@ impl<'a> Resolver<'a> {\n                         format!(\"variable `{}` from pattern #1 is \\\n                                   not bound in pattern #{}\",\n                                 token::get_name(key),\n-                                i + 1).as_slice());\n+                                i + 1)[]);\n                   }\n                   Some(binding_i) => {\n                     if binding_0.binding_mode != binding_i.binding_mode {\n@@ -4621,7 +4622,7 @@ impl<'a> Resolver<'a> {\n                             format!(\"variable `{}` is bound with different \\\n                                       mode in pattern #{} than in pattern #1\",\n                                     token::get_name(key),\n-                                    i + 1).as_slice());\n+                                    i + 1)[]);\n                     }\n                   }\n                 }\n@@ -4634,7 +4635,7 @@ impl<'a> Resolver<'a> {\n                         format!(\"variable `{}` from pattern {}{} is \\\n                                   not bound in pattern {}1\",\n                                 token::get_name(key),\n-                                \"#\", i + 1, \"#\").as_slice());\n+                                \"#\", i + 1, \"#\")[]);\n                 }\n             }\n         }\n@@ -4751,7 +4752,7 @@ impl<'a> Resolver<'a> {\n                     None => {\n                         let msg = format!(\"use of undeclared type name `{}`\",\n                                           self.path_names_to_string(path));\n-                        self.resolve_error(ty.span, msg.as_slice());\n+                        self.resolve_error(ty.span, msg[]);\n                     }\n                 }\n             }\n@@ -4831,7 +4832,7 @@ impl<'a> Resolver<'a> {\n                                 format!(\"declaration of `{}` shadows an enum \\\n                                          variant or unit-like struct in \\\n                                          scope\",\n-                                        token::get_name(renamed)).as_slice());\n+                                        token::get_name(renamed))[]);\n                         }\n                         FoundConst(ref def, lp) if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `{}` to \\\n@@ -4883,7 +4884,7 @@ impl<'a> Resolver<'a> {\n                                                             list\",\n                                                            token::get_ident(\n                                                                ident))\n-                                                   .as_slice())\n+                                                   [])\n                             } else if bindings_list.get(&renamed) ==\n                                     Some(&pat_id) {\n                                 // Then this is a duplicate variable in the\n@@ -4892,7 +4893,7 @@ impl<'a> Resolver<'a> {\n                                     format!(\"identifier `{}` is bound \\\n                                              more than once in the same \\\n                                              pattern\",\n-                                            token::get_ident(ident)).as_slice());\n+                                            token::get_ident(ident))[]);\n                             }\n                             // Else, not bound in the same pattern: do\n                             // nothing.\n@@ -4921,7 +4922,7 @@ impl<'a> Resolver<'a> {\n                                         path.segments\n                                             .last()\n                                             .unwrap()\n-                                            .identifier)).as_slice());\n+                                            .identifier))[]);\n                         }\n                         None => {\n                             self.resolve_error(path.span,\n@@ -4930,7 +4931,7 @@ impl<'a> Resolver<'a> {\n                                         path.segments\n                                             .last()\n                                             .unwrap()\n-                                            .identifier)).as_slice());\n+                                            .identifier))[]);\n                         }\n                     }\n \n@@ -4961,7 +4962,7 @@ impl<'a> Resolver<'a> {\n                                     def: {}\", result);\n                             let msg = format!(\"`{}` does not name a structure\",\n                                               self.path_names_to_string(path));\n-                            self.resolve_error(path.span, msg.as_slice());\n+                            self.resolve_error(path.span, msg[]);\n                         }\n                     }\n                 }\n@@ -5023,7 +5024,7 @@ impl<'a> Resolver<'a> {\n                 match err {\n                     Some((span, msg)) => {\n                         self.resolve_error(span, format!(\"failed to resolve: {}\",\n-                                                         msg));\n+                                                         msg)[]);\n                     }\n                     None => ()\n                 }\n@@ -5219,7 +5220,7 @@ impl<'a> Resolver<'a> {\n         let last_private;\n         let module = self.current_module.clone();\n         match self.resolve_module_path(module,\n-                                       module_path.as_slice(),\n+                                       module_path[],\n                                        UseLexicalScope,\n                                        path.span,\n                                        PathSearch) {\n@@ -5234,7 +5235,7 @@ impl<'a> Resolver<'a> {\n                 };\n \n                 self.resolve_error(span, format!(\"failed to resolve. {}\",\n-                                                 msg.as_slice()));\n+                                                 msg)[]);\n                 return None;\n             }\n             Indeterminate => panic!(\"indeterminate unexpected\"),\n@@ -5277,7 +5278,7 @@ impl<'a> Resolver<'a> {\n         let containing_module;\n         let last_private;\n         match self.resolve_module_path_from_root(root_module,\n-                                                 module_path.as_slice(),\n+                                                 module_path[],\n                                                  0,\n                                                  path.span,\n                                                  PathSearch,\n@@ -5287,13 +5288,13 @@ impl<'a> Resolver<'a> {\n                     Some((span, msg)) => (span, msg),\n                     None => {\n                         let msg = format!(\"Use of undeclared module `::{}`\",\n-                                          self.names_to_string(module_path.as_slice()));\n+                                          self.names_to_string(module_path[]));\n                         (path.span, msg)\n                     }\n                 };\n \n                 self.resolve_error(span, format!(\"failed to resolve. {}\",\n-                                                 msg.as_slice()));\n+                                                 msg)[]);\n                 return None;\n             }\n \n@@ -5334,7 +5335,7 @@ impl<'a> Resolver<'a> {\n             }\n             TypeNS => {\n                 let name = ident.name;\n-                self.search_ribs(self.type_ribs.as_slice(), name, span)\n+                self.search_ribs(self.type_ribs[], name, span)\n             }\n         };\n \n@@ -5388,7 +5389,8 @@ impl<'a> Resolver<'a> {\n             Failed(err) => {\n                 match err {\n                     Some((span, msg)) =>\n-                        self.resolve_error(span, format!(\"failed to resolve. {}\", msg)),\n+                        self.resolve_error(span, format!(\"failed to resolve. {}\",\n+                                                         msg)[]),\n                     None => ()\n                 }\n \n@@ -5408,9 +5410,9 @@ impl<'a> Resolver<'a> {\n         rs\n     }\n \n-    fn resolve_error<T: Str>(&self, span: Span, s: T) {\n+    fn resolve_error(&self, span: Span, s: &str) {\n         if self.emit_errors {\n-            self.session.span_err(span, s.as_slice());\n+            self.session.span_err(span, s);\n         }\n     }\n \n@@ -5445,7 +5447,7 @@ impl<'a> Resolver<'a> {\n                 }\n             } else {\n                 match this.resolve_module_path(root,\n-                                                name_path.as_slice(),\n+                                                name_path[],\n                                                 UseLexicalScope,\n                                                 span,\n                                                 PathSearch) {\n@@ -5483,7 +5485,7 @@ impl<'a> Resolver<'a> {\n         let name_path = path.segments.iter().map(|seg| seg.identifier.name).collect::<Vec<_>>();\n \n         // Look for a method in the current self type's impl module.\n-        match get_module(self, path.span, name_path.as_slice()) {\n+        match get_module(self, path.span, name_path[]) {\n             Some(module) => match module.children.borrow().get(&name) {\n                 Some(binding) => {\n                     let p_str = self.path_names_to_string(&path);\n@@ -5539,7 +5541,7 @@ impl<'a> Resolver<'a> {\n \n         let mut smallest = 0;\n         for (i, other) in maybes.iter().enumerate() {\n-            values[i] = name.lev_distance(other.get());\n+            values[i] = lev_distance(name, other.get());\n \n             if values[i] <= values[smallest] {\n                 smallest = i;\n@@ -5694,7 +5696,7 @@ impl<'a> Resolver<'a> {\n                                 def: {}\", result);\n                         let msg = format!(\"`{}` does not name a structure\",\n                                           self.path_names_to_string(path));\n-                        self.resolve_error(path.span, msg.as_slice());\n+                        self.resolve_error(path.span, msg[]);\n                     }\n                 }\n \n@@ -5750,13 +5752,13 @@ impl<'a> Resolver<'a> {\n \n             ExprBreak(Some(label)) | ExprAgain(Some(label)) => {\n                 let renamed = mtwt::resolve(label);\n-                match self.search_ribs(self.label_ribs.as_slice(),\n+                match self.search_ribs(self.label_ribs[],\n                                        renamed, expr.span) {\n                     None => {\n                         self.resolve_error(\n                             expr.span,\n                             format!(\"use of undeclared label `{}`\",\n-                                    token::get_ident(label)).as_slice())\n+                                    token::get_ident(label))[])\n                     }\n                     Some(DlDef(def @ DefLabel(_))) => {\n                         // Since this def is a label, it is never read.\n@@ -5892,7 +5894,7 @@ impl<'a> Resolver<'a> {\n                                   then {}\",\n                                  node_id,\n                                  *entry.get(),\n-                                 def).as_slice());\n+                                 def)[]);\n             },\n             Vacant(entry) => { entry.set(def); },\n         }\n@@ -5908,7 +5910,7 @@ impl<'a> Resolver<'a> {\n                 self.resolve_error(pat.span,\n                                    format!(\"cannot use `ref` binding mode \\\n                                             with {}\",\n-                                           descr).as_slice());\n+                                           descr)[]);\n             }\n         }\n     }\n@@ -5944,8 +5946,7 @@ impl<'a> Resolver<'a> {\n             return \"???\".to_string();\n         }\n         self.names_to_string(names.into_iter().rev()\n-                                  .collect::<Vec<ast::Name>>()\n-                                  .as_slice())\n+                                  .collect::<Vec<ast::Name>>()[])\n     }\n \n     #[allow(dead_code)]   // useful for debugging"}, {"sha": "ec61d3a69537c73d2549be3e9c3997501804993a", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -126,7 +126,7 @@ pub fn find_crate_name(sess: Option<&Session>,\n                        attrs: &[ast::Attribute],\n                        input: &Input) -> String {\n     let validate = |s: String, span: Option<Span>| {\n-        creader::validate_crate_name(sess, s.as_slice(), span);\n+        creader::validate_crate_name(sess, s[], span);\n         s\n     };\n \n@@ -144,7 +144,7 @@ pub fn find_crate_name(sess: Option<&Session>,\n                     let msg = format!(\"--crate-name and #[crate_name] are \\\n                                        required to match, but `{}` != `{}`\",\n                                       s, name);\n-                    sess.span_err(attr.span, msg.as_slice());\n+                    sess.span_err(attr.span, msg[]);\n                 }\n             }\n             return validate(s.clone(), None);\n@@ -190,17 +190,17 @@ fn symbol_hash<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // to be independent of one another in the crate.\n \n     symbol_hasher.reset();\n-    symbol_hasher.input_str(link_meta.crate_name.as_slice());\n+    symbol_hasher.input_str(link_meta.crate_name[]);\n     symbol_hasher.input_str(\"-\");\n     symbol_hasher.input_str(link_meta.crate_hash.as_str());\n     for meta in tcx.sess.crate_metadata.borrow().iter() {\n-        symbol_hasher.input_str(meta.as_slice());\n+        symbol_hasher.input_str(meta[]);\n     }\n     symbol_hasher.input_str(\"-\");\n-    symbol_hasher.input_str(encoder::encoded_ty(tcx, t).as_slice());\n+    symbol_hasher.input_str(encoder::encoded_ty(tcx, t)[]);\n     // Prefix with 'h' so that it never blends into adjacent digits\n     let mut hash = String::from_str(\"h\");\n-    hash.push_str(truncated_hash_result(symbol_hasher).as_slice());\n+    hash.push_str(truncated_hash_result(symbol_hasher)[]);\n     hash\n }\n \n@@ -249,7 +249,7 @@ pub fn sanitize(s: &str) -> String {\n                 let mut tstr = String::new();\n                 for c in c.escape_unicode() { tstr.push(c) }\n                 result.push('$');\n-                result.push_str(tstr.slice_from(1));\n+                result.push_str(tstr[1..]);\n             }\n         }\n     }\n@@ -258,7 +258,7 @@ pub fn sanitize(s: &str) -> String {\n     if result.len() > 0u &&\n         result.as_bytes()[0] != '_' as u8 &&\n         ! (result.as_bytes()[0] as char).is_xid_start() {\n-        return format!(\"_{}\", result.as_slice());\n+        return format!(\"_{}\", result[]);\n     }\n \n     return result;\n@@ -284,12 +284,12 @@ pub fn mangle<PI: Iterator<PathElem>>(mut path: PI,\n \n     fn push(n: &mut String, s: &str) {\n         let sani = sanitize(s);\n-        n.push_str(format!(\"{}{}\", sani.len(), sani).as_slice());\n+        n.push_str(format!(\"{}{}\", sani.len(), sani)[]);\n     }\n \n     // First, connect each component with <len, name> pairs.\n     for e in path {\n-        push(&mut n, token::get_name(e.name()).get().as_slice())\n+        push(&mut n, token::get_name(e.name()).get()[])\n     }\n \n     match hash {\n@@ -327,17 +327,17 @@ pub fn mangle_exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, path: PathEl\n     hash.push(EXTRA_CHARS.as_bytes()[extra2] as char);\n     hash.push(EXTRA_CHARS.as_bytes()[extra3] as char);\n \n-    exported_name(path, hash.as_slice())\n+    exported_name(path, hash[])\n }\n \n pub fn mangle_internal_name_by_type_and_seq<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                       t: Ty<'tcx>,\n                                                       name: &str) -> String {\n     let s = ppaux::ty_to_string(ccx.tcx(), t);\n-    let path = [PathName(token::intern(s.as_slice())),\n+    let path = [PathName(token::intern(s[])),\n                 gensym_name(name)];\n     let hash = get_symbol_hash(ccx, t);\n-    mangle(ast_map::Values(path.iter()), Some(hash.as_slice()))\n+    mangle(ast_map::Values(path.iter()), Some(hash[]))\n }\n \n pub fn mangle_internal_name_by_path_and_seq(path: PathElems, flav: &str) -> String {\n@@ -357,7 +357,7 @@ pub fn remove(sess: &Session, path: &Path) {\n         Err(e) => {\n             sess.err(format!(\"failed to remove {}: {}\",\n                              path.display(),\n-                             e).as_slice());\n+                             e)[]);\n         }\n     }\n }\n@@ -372,7 +372,7 @@ pub fn link_binary(sess: &Session,\n     for &crate_type in sess.crate_types.borrow().iter() {\n         if invalid_output_for_target(sess, crate_type) {\n             sess.bug(format!(\"invalid output type `{}` for target os `{}`\",\n-                             crate_type, sess.opts.target_triple).as_slice());\n+                             crate_type, sess.opts.target_triple)[]);\n         }\n         let out_file = link_binary_output(sess, trans, crate_type, outputs,\n                                           crate_name);\n@@ -437,8 +437,8 @@ pub fn filename_for_input(sess: &Session,\n             out_filename.with_filename(format!(\"lib{}.rlib\", libname))\n         }\n         config::CrateTypeDylib => {\n-            let (prefix, suffix) = (sess.target.target.options.dll_prefix.as_slice(),\n-                                    sess.target.target.options.dll_suffix.as_slice());\n+            let (prefix, suffix) = (sess.target.target.options.dll_prefix[],\n+                                    sess.target.target.options.dll_suffix[]);\n             out_filename.with_filename(format!(\"{}{}{}\",\n                                                prefix,\n                                                libname,\n@@ -448,7 +448,7 @@ pub fn filename_for_input(sess: &Session,\n             out_filename.with_filename(format!(\"lib{}.a\", libname))\n         }\n         config::CrateTypeExecutable => {\n-            let suffix = sess.target.target.options.exe_suffix.as_slice();\n+            let suffix = sess.target.target.options.exe_suffix[];\n             out_filename.with_filename(format!(\"{}{}\", libname, suffix))\n         }\n     }\n@@ -477,12 +477,12 @@ fn link_binary_output(sess: &Session,\n     if !out_is_writeable {\n         sess.fatal(format!(\"output file {} is not writeable -- check its \\\n                             permissions.\",\n-                           out_filename.display()).as_slice());\n+                           out_filename.display())[]);\n     }\n     else if !obj_is_writeable {\n         sess.fatal(format!(\"object file {} is not writeable -- check its \\\n                             permissions.\",\n-                           obj_filename.display()).as_slice());\n+                           obj_filename.display())[]);\n     }\n \n     match crate_type {\n@@ -507,7 +507,7 @@ fn archive_search_paths(sess: &Session) -> Vec<Path> {\n     let mut rustpath = filesearch::rust_path();\n     rustpath.push(sess.target_filesearch().get_lib_path());\n     let mut search: Vec<Path> = sess.opts.addl_lib_search_paths.borrow().clone();\n-    search.push_all(rustpath.as_slice());\n+    search.push_all(rustpath[]);\n     return search;\n }\n \n@@ -536,7 +536,7 @@ fn link_rlib<'a>(sess: &'a Session,\n     for &(ref l, kind) in sess.cstore.get_used_libraries().borrow().iter() {\n         match kind {\n             cstore::NativeStatic => {\n-                ab.add_native_library(l.as_slice()).unwrap();\n+                ab.add_native_library(l[]).unwrap();\n             }\n             cstore::NativeFramework | cstore::NativeUnknown => {}\n         }\n@@ -584,12 +584,12 @@ fn link_rlib<'a>(sess: &'a Session,\n             let tmpdir = TempDir::new(\"rustc\").ok().expect(\"needs a temp dir\");\n             let metadata = tmpdir.path().join(METADATA_FILENAME);\n             match fs::File::create(&metadata).write(trans.metadata\n-                                                         .as_slice()) {\n+                                                         []) {\n                 Ok(..) => {}\n                 Err(e) => {\n                     sess.err(format!(\"failed to write {}: {}\",\n                                      metadata.display(),\n-                                     e).as_slice());\n+                                     e)[]);\n                     sess.abort_if_errors();\n                 }\n             }\n@@ -605,27 +605,27 @@ fn link_rlib<'a>(sess: &'a Session,\n                 // extension to it. This is to work around a bug in LLDB that\n                 // would cause it to crash if the name of a file in an archive\n                 // was exactly 16 bytes.\n-                let bc_filename = obj_filename.with_extension(format!(\"{}.bc\", i).as_slice());\n+                let bc_filename = obj_filename.with_extension(format!(\"{}.bc\", i)[]);\n                 let bc_deflated_filename = obj_filename.with_extension(\n-                    format!(\"{}.bytecode.deflate\", i).as_slice());\n+                    format!(\"{}.bytecode.deflate\", i)[]);\n \n                 let bc_data = match fs::File::open(&bc_filename).read_to_end() {\n                     Ok(buffer) => buffer,\n                     Err(e) => sess.fatal(format!(\"failed to read bytecode: {}\",\n-                                                 e).as_slice())\n+                                                 e)[])\n                 };\n \n-                let bc_data_deflated = match flate::deflate_bytes(bc_data.as_slice()) {\n+                let bc_data_deflated = match flate::deflate_bytes(bc_data[]) {\n                     Some(compressed) => compressed,\n                     None => sess.fatal(format!(\"failed to compress bytecode from {}\",\n-                                               bc_filename.display()).as_slice())\n+                                               bc_filename.display())[])\n                 };\n \n                 let mut bc_file_deflated = match fs::File::create(&bc_deflated_filename) {\n                     Ok(file) => file,\n                     Err(e) => {\n                         sess.fatal(format!(\"failed to create compressed bytecode \\\n-                                            file: {}\", e).as_slice())\n+                                            file: {}\", e)[])\n                     }\n                 };\n \n@@ -634,7 +634,7 @@ fn link_rlib<'a>(sess: &'a Session,\n                     Ok(()) => {}\n                     Err(e) => {\n                         sess.err(format!(\"failed to write compressed bytecode: \\\n-                                          {}\", e).as_slice());\n+                                          {}\", e)[]);\n                         sess.abort_if_errors()\n                     }\n                 };\n@@ -674,7 +674,7 @@ fn write_rlib_bytecode_object_v1<T: Writer>(writer: &mut T,\n     try! { writer.write(RLIB_BYTECODE_OBJECT_MAGIC) };\n     try! { writer.write_le_u32(1) };\n     try! { writer.write_le_u64(bc_data_deflated_size) };\n-    try! { writer.write(bc_data_deflated.as_slice()) };\n+    try! { writer.write(bc_data_deflated[]) };\n \n     let number_of_bytes_written_so_far =\n         RLIB_BYTECODE_OBJECT_MAGIC.len() +                // magic id\n@@ -725,11 +725,11 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n         let p = match *path {\n             Some(ref p) => p.clone(), None => {\n                 sess.err(format!(\"could not find rlib for: `{}`\",\n-                                 name).as_slice());\n+                                 name)[]);\n                 continue\n             }\n         };\n-        ab.add_rlib(&p, name.as_slice(), sess.lto()).unwrap();\n+        ab.add_rlib(&p, name[], sess.lto()).unwrap();\n \n         let native_libs = csearch::get_native_libraries(&sess.cstore, cnum);\n         all_native_libs.extend(native_libs.into_iter());\n@@ -751,7 +751,7 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n             cstore::NativeUnknown => \"library\",\n             cstore::NativeFramework => \"framework\",\n         };\n-        sess.note(format!(\"{}: {}\", name, *lib).as_slice());\n+        sess.note(format!(\"{}: {}\", name, *lib)[]);\n     }\n }\n \n@@ -765,12 +765,12 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n \n     // The invocations of cc share some flags across platforms\n     let pname = get_cc_prog(sess);\n-    let mut cmd = Command::new(pname.as_slice());\n+    let mut cmd = Command::new(pname[]);\n \n-    cmd.args(sess.target.target.options.pre_link_args.as_slice());\n+    cmd.args(sess.target.target.options.pre_link_args[]);\n     link_args(&mut cmd, sess, dylib, tmpdir.path(),\n               trans, obj_filename, out_filename);\n-    cmd.args(sess.target.target.options.post_link_args.as_slice());\n+    cmd.args(sess.target.target.options.post_link_args[]);\n     if !sess.target.target.options.no_compiler_rt {\n         cmd.arg(\"-lcompiler-rt\");\n     }\n@@ -790,11 +790,11 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n             if !prog.status.success() {\n                 sess.err(format!(\"linking with `{}` failed: {}\",\n                                  pname,\n-                                 prog.status).as_slice());\n-                sess.note(format!(\"{}\", &cmd).as_slice());\n+                                 prog.status)[]);\n+                sess.note(format!(\"{}\", &cmd)[]);\n                 let mut output = prog.error.clone();\n-                output.push_all(prog.output.as_slice());\n-                sess.note(str::from_utf8(output.as_slice()).unwrap());\n+                output.push_all(prog.output[]);\n+                sess.note(str::from_utf8(output[]).unwrap());\n                 sess.abort_if_errors();\n             }\n             debug!(\"linker stderr:\\n{}\", String::from_utf8(prog.error).unwrap());\n@@ -803,7 +803,7 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n         Err(e) => {\n             sess.err(format!(\"could not exec the linker `{}`: {}\",\n                              pname,\n-                             e).as_slice());\n+                             e)[]);\n             sess.abort_if_errors();\n         }\n     }\n@@ -815,7 +815,7 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n         match Command::new(\"dsymutil\").arg(out_filename).output() {\n             Ok(..) => {}\n             Err(e) => {\n-                sess.err(format!(\"failed to run dsymutil: {}\", e).as_slice());\n+                sess.err(format!(\"failed to run dsymutil: {}\", e)[]);\n                 sess.abort_if_errors();\n             }\n         }\n@@ -864,7 +864,7 @@ fn link_args(cmd: &mut Command,\n \n             let mut v = b\"-Wl,-force_load,\".to_vec();\n             v.push_all(morestack.as_vec());\n-            cmd.arg(v.as_slice());\n+            cmd.arg(v[]);\n         } else {\n             cmd.args(&[\"-Wl,--whole-archive\", \"-lmorestack\", \"-Wl,--no-whole-archive\"]);\n         }\n@@ -989,7 +989,7 @@ fn link_args(cmd: &mut Command,\n             if sess.opts.cg.rpath {\n                 let mut v = \"-Wl,-install_name,@rpath/\".as_bytes().to_vec();\n                 v.push_all(out_filename.filename().unwrap());\n-                cmd.arg(v.as_slice());\n+                cmd.arg(v[]);\n             }\n         } else {\n             cmd.arg(\"-shared\");\n@@ -1001,7 +1001,7 @@ fn link_args(cmd: &mut Command,\n     // addl_lib_search_paths\n     if sess.opts.cg.rpath {\n         let sysroot = sess.sysroot();\n-        let target_triple = sess.opts.target_triple.as_slice();\n+        let target_triple = sess.opts.target_triple[];\n         let get_install_prefix_lib_path = |:| {\n             let install_prefix = option_env!(\"CFG_PREFIX\").expect(\"CFG_PREFIX\");\n             let tlib = filesearch::relative_target_lib_path(sysroot, target_triple);\n@@ -1018,14 +1018,14 @@ fn link_args(cmd: &mut Command,\n             get_install_prefix_lib_path: get_install_prefix_lib_path,\n             realpath: ::util::fs::realpath\n         };\n-        cmd.args(rpath::get_rpath_flags(rpath_config).as_slice());\n+        cmd.args(rpath::get_rpath_flags(rpath_config)[]);\n     }\n \n     // Finally add all the linker arguments provided on the command line along\n     // with any #[link_args] attributes found inside the crate\n     let empty = Vec::new();\n-    cmd.args(sess.opts.cg.link_args.as_ref().unwrap_or(&empty).as_slice());\n-    cmd.args(used_link_args.as_slice());\n+    cmd.args(sess.opts.cg.link_args.as_ref().unwrap_or(&empty)[]);\n+    cmd.args(used_link_args[]);\n }\n \n // # Native library linking\n@@ -1083,14 +1083,14 @@ fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n         } else {\n             // -force_load is the OSX equivalent of --whole-archive, but it\n             // involves passing the full path to the library to link.\n-            let lib = archive::find_library(l.as_slice(),\n-                                            sess.target.target.options.staticlib_prefix.as_slice(),\n-                                            sess.target.target.options.staticlib_suffix.as_slice(),\n-                                            search_path.as_slice(),\n+            let lib = archive::find_library(l[],\n+                                            sess.target.target.options.staticlib_prefix[],\n+                                            sess.target.target.options.staticlib_suffix[],\n+                                            search_path[],\n                                             &sess.diagnostic().handler);\n             let mut v = b\"-Wl,-force_load,\".to_vec();\n             v.push_all(lib.as_vec());\n-            cmd.arg(v.as_slice());\n+            cmd.arg(v[]);\n         }\n     }\n     if takes_hints {\n@@ -1103,7 +1103,7 @@ fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n                 cmd.arg(format!(\"-l{}\", l));\n             }\n             cstore::NativeFramework => {\n-                cmd.arg(\"-framework\").arg(l.as_slice());\n+                cmd.arg(\"-framework\").arg(l[]);\n             }\n             cstore::NativeStatic => unreachable!(),\n         }\n@@ -1184,9 +1184,9 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n         // against the archive.\n         if sess.lto() {\n             let name = cratepath.filename_str().unwrap();\n-            let name = name.slice(3, name.len() - 5); // chop off lib/.rlib\n+            let name = name[3..name.len() - 5]; // chop off lib/.rlib\n             time(sess.time_passes(),\n-                 format!(\"altering {}.rlib\", name).as_slice(),\n+                 format!(\"altering {}.rlib\", name)[],\n                  (), |()| {\n                 let dst = tmpdir.join(cratepath.filename().unwrap());\n                 match fs::copy(&cratepath, &dst) {\n@@ -1195,7 +1195,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                         sess.err(format!(\"failed to copy {} to {}: {}\",\n                                          cratepath.display(),\n                                          dst.display(),\n-                                         e).as_slice());\n+                                         e)[]);\n                         sess.abort_if_errors();\n                     }\n                 }\n@@ -1207,7 +1207,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                     Err(e) => {\n                         sess.err(format!(\"failed to chmod {} when preparing \\\n                                           for LTO: {}\", dst.display(),\n-                                         e).as_slice());\n+                                         e)[]);\n                         sess.abort_if_errors();\n                     }\n                 }\n@@ -1221,9 +1221,9 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                     maybe_ar_prog: sess.opts.cg.ar.clone()\n                 };\n                 let mut archive = Archive::open(config);\n-                archive.remove_file(format!(\"{}.o\", name).as_slice());\n+                archive.remove_file(format!(\"{}.o\", name)[]);\n                 let files = archive.files();\n-                if files.iter().any(|s| s.as_slice().ends_with(\".o\")) {\n+                if files.iter().any(|s| s[].ends_with(\".o\")) {\n                     cmd.arg(dst);\n                 }\n             });\n@@ -1245,7 +1245,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n \n         let mut v = \"-l\".as_bytes().to_vec();\n         v.push_all(unlib(&sess.target, cratepath.filestem().unwrap()));\n-        cmd.arg(v.as_slice());\n+        cmd.arg(v[]);\n     }\n }\n \n@@ -1287,7 +1287,7 @@ fn add_upstream_native_libraries(cmd: &mut Command, sess: &Session) {\n                 }\n                 cstore::NativeFramework => {\n                     cmd.arg(\"-framework\");\n-                    cmd.arg(lib.as_slice());\n+                    cmd.arg(lib[]);\n                 }\n                 cstore::NativeStatic => {\n                     sess.bug(\"statics shouldn't be propagated\");"}, {"sha": "1271330897e737fa5171e8334ae6dafbc0c3203d", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -53,29 +53,29 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n             Some(p) => p,\n             None => {\n                 sess.fatal(format!(\"could not find rlib for: `{}`\",\n-                                   name).as_slice());\n+                                   name)[]);\n             }\n         };\n \n         let archive = ArchiveRO::open(&path).expect(\"wanted an rlib\");\n         let file = path.filename_str().unwrap();\n-        let file = file.slice(3, file.len() - 5); // chop off lib/.rlib\n+        let file = file[3..file.len() - 5]; // chop off lib/.rlib\n         debug!(\"reading {}\", file);\n         for i in iter::count(0u, 1) {\n             let bc_encoded = time(sess.time_passes(),\n-                                  format!(\"check for {}.{}.bytecode.deflate\", name, i).as_slice(),\n+                                  format!(\"check for {}.{}.bytecode.deflate\", name, i)[],\n                                   (),\n                                   |_| {\n                                       archive.read(format!(\"{}.{}.bytecode.deflate\",\n-                                                           file, i).as_slice())\n+                                                           file, i)[])\n                                   });\n             let bc_encoded = match bc_encoded {\n                 Some(data) => data,\n                 None => {\n                     if i == 0 {\n                         // No bitcode was found at all.\n                         sess.fatal(format!(\"missing compressed bytecode in {}\",\n-                                           path.display()).as_slice());\n+                                           path.display())[]);\n                     }\n                     // No more bitcode files to read.\n                     break;\n@@ -98,12 +98,12 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                             Some(inflated) => inflated,\n                             None => {\n                                 sess.fatal(format!(\"failed to decompress bc of `{}`\",\n-                                                   name).as_slice())\n+                                                   name)[])\n                             }\n                         }\n                     } else {\n                         sess.fatal(format!(\"Unsupported bytecode format version {}\",\n-                                           version).as_slice())\n+                                           version)[])\n                     }\n                 })\n             } else {\n@@ -114,7 +114,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                         Some(bc) => bc,\n                         None => {\n                             sess.fatal(format!(\"failed to decompress bc of `{}`\",\n-                                               name).as_slice())\n+                                               name)[])\n                         }\n                     }\n                 })\n@@ -123,15 +123,15 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n             let ptr = bc_decoded.as_slice().as_ptr();\n             debug!(\"linking {}, part {}\", name, i);\n             time(sess.time_passes(),\n-                 format!(\"ll link {}.{}\", name, i).as_slice(),\n+                 format!(\"ll link {}.{}\", name, i)[],\n                  (),\n                  |()| unsafe {\n                 if !llvm::LLVMRustLinkInExternalBitcode(llmod,\n                                                         ptr as *const libc::c_char,\n                                                         bc_decoded.len() as libc::size_t) {\n                     write::llvm_err(sess.diagnostic().handler(),\n                                     format!(\"failed to load bc of `{}`\",\n-                                            name.as_slice()));\n+                                            name[]));\n                 }\n             });\n         }"}, {"sha": "5be66d4292097dc62556aa8df0244a9ef5d51bad", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -46,13 +46,13 @@ pub fn llvm_err(handler: &diagnostic::Handler, msg: String) -> ! {\n     unsafe {\n         let cstr = llvm::LLVMRustGetLastError();\n         if cstr == ptr::null() {\n-            handler.fatal(msg.as_slice());\n+            handler.fatal(msg[]);\n         } else {\n             let err = CString::new(cstr, true);\n             let err = String::from_utf8_lossy(err.as_bytes());\n             handler.fatal(format!(\"{}: {}\",\n-                                  msg.as_slice(),\n-                                  err.as_slice()).as_slice());\n+                                  msg[],\n+                                  err[])[]);\n         }\n     }\n }\n@@ -103,13 +103,13 @@ impl SharedEmitter {\n             match diag.code {\n                 Some(ref code) => {\n                     handler.emit_with_code(None,\n-                                           diag.msg.as_slice(),\n-                                           code.as_slice(),\n+                                           diag.msg[],\n+                                           code[],\n                                            diag.lvl);\n                 },\n                 None => {\n                     handler.emit(None,\n-                                 diag.msg.as_slice(),\n+                                 diag.msg[],\n                                  diag.lvl);\n                 },\n             }\n@@ -164,8 +164,8 @@ fn get_llvm_opt_level(optimize: config::OptLevel) -> llvm::CodeGenOptLevel {\n \n fn create_target_machine(sess: &Session) -> TargetMachineRef {\n     let reloc_model_arg = match sess.opts.cg.relocation_model {\n-        Some(ref s) => s.as_slice(),\n-        None => sess.target.target.options.relocation_model.as_slice()\n+        Some(ref s) => s[],\n+        None => sess.target.target.options.relocation_model[]\n     };\n     let reloc_model = match reloc_model_arg {\n         \"pic\" => llvm::RelocPIC,\n@@ -176,7 +176,7 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n             sess.err(format!(\"{} is not a valid relocation mode\",\n                              sess.opts\n                                  .cg\n-                                 .relocation_model).as_slice());\n+                                 .relocation_model)[]);\n             sess.abort_if_errors();\n             unreachable!();\n         }\n@@ -197,8 +197,8 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n     let fdata_sections = ffunction_sections;\n \n     let code_model_arg = match sess.opts.cg.code_model {\n-        Some(ref s) => s.as_slice(),\n-        None => sess.target.target.options.code_model.as_slice()\n+        Some(ref s) => s[],\n+        None => sess.target.target.options.code_model[]\n     };\n \n     let code_model = match code_model_arg {\n@@ -211,19 +211,19 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n             sess.err(format!(\"{} is not a valid code model\",\n                              sess.opts\n                                  .cg\n-                                 .code_model).as_slice());\n+                                 .code_model)[]);\n             sess.abort_if_errors();\n             unreachable!();\n         }\n     };\n \n-    let triple = sess.target.target.llvm_target.as_slice();\n+    let triple = sess.target.target.llvm_target[];\n \n     let tm = unsafe {\n         triple.with_c_str(|t| {\n             let cpu = match sess.opts.cg.target_cpu {\n-                Some(ref s) => s.as_slice(),\n-                None => sess.target.target.options.cpu.as_slice()\n+                Some(ref s) => s[],\n+                None => sess.target.target.options.cpu[]\n             };\n             cpu.with_c_str(|cpu| {\n                 target_feature(sess).with_c_str(|features| {\n@@ -350,13 +350,13 @@ unsafe extern \"C\" fn inline_asm_handler(diag: SMDiagnosticRef,\n     match cgcx.lto_ctxt {\n         Some((sess, _)) => {\n             sess.codemap().with_expn_info(ExpnId::from_llvm_cookie(cookie), |info| match info {\n-                Some(ei) => sess.span_err(ei.call_site, msg.as_slice()),\n-                None     => sess.err(msg.as_slice()),\n+                Some(ei) => sess.span_err(ei.call_site, msg[]),\n+                None     => sess.err(msg[]),\n             });\n         }\n \n         None => {\n-            cgcx.handler.err(msg.as_slice());\n+            cgcx.handler.err(msg[]);\n             cgcx.handler.note(\"build without -C codegen-units for more exact errors\");\n         }\n     }\n@@ -380,8 +380,8 @@ unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo\n                 cgcx.handler.note(format!(\"optimization {} for {} at {}: {}\",\n                                           opt.kind.describe(),\n                                           pass_name,\n-                                          if loc.is_empty() { \"[unknown]\" } else { loc.as_slice() },\n-                                          llvm::twine_to_string(opt.message)).as_slice());\n+                                          if loc.is_empty() { \"[unknown]\" } else { loc[] },\n+                                          llvm::twine_to_string(opt.message))[]);\n             }\n         }\n \n@@ -413,7 +413,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n \n     if config.emit_no_opt_bc {\n         let ext = format!(\"{}.no-opt.bc\", name_extra);\n-        output_names.with_extension(ext.as_slice()).with_c_str(|buf| {\n+        output_names.with_extension(ext[]).with_c_str(|buf| {\n             llvm::LLVMWriteBitcodeToFile(llmod, buf);\n         })\n     }\n@@ -445,7 +445,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n                 pass.with_c_str(|s| {\n                     if !llvm::LLVMRustAddPass(mpm, s) {\n                         cgcx.handler.warn(format!(\"unknown pass {}, ignoring\",\n-                                                  *pass).as_slice());\n+                                                  *pass)[]);\n                     }\n                 })\n             }\n@@ -467,7 +467,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n \n                     if config.emit_lto_bc {\n                         let name = format!(\"{}.lto.bc\", name_extra);\n-                        output_names.with_extension(name.as_slice()).with_c_str(|buf| {\n+                        output_names.with_extension(name[]).with_c_str(|buf| {\n                             llvm::LLVMWriteBitcodeToFile(llmod, buf);\n                         })\n                     }\n@@ -501,30 +501,30 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n \n     if config.emit_bc {\n         let ext = format!(\"{}.bc\", name_extra);\n-        output_names.with_extension(ext.as_slice()).with_c_str(|buf| {\n+        output_names.with_extension(ext[]).with_c_str(|buf| {\n             llvm::LLVMWriteBitcodeToFile(llmod, buf);\n         })\n     }\n \n     time(config.time_passes, \"codegen passes\", (), |()| {\n         if config.emit_ir {\n             let ext = format!(\"{}.ll\", name_extra);\n-            output_names.with_extension(ext.as_slice()).with_c_str(|output| {\n+            output_names.with_extension(ext[]).with_c_str(|output| {\n                 with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                     llvm::LLVMRustPrintModule(cpm, llmod, output);\n                 })\n             })\n         }\n \n         if config.emit_asm {\n-            let path = output_names.with_extension(format!(\"{}.s\", name_extra).as_slice());\n+            let path = output_names.with_extension(format!(\"{}.s\", name_extra)[]);\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 write_output_file(cgcx.handler, tm, cpm, llmod, &path, llvm::AssemblyFileType);\n             });\n         }\n \n         if config.emit_obj {\n-            let path = output_names.with_extension(format!(\"{}.o\", name_extra).as_slice());\n+            let path = output_names.with_extension(format!(\"{}.o\", name_extra)[]);\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 write_output_file(cgcx.handler, tm, cpm, llmod, &path, llvm::ObjectFileType);\n             });\n@@ -638,7 +638,7 @@ pub fn run_passes(sess: &Session,\n \n     // Process the work items, optionally using worker threads.\n     if sess.opts.cg.codegen_units == 1 {\n-        run_work_singlethreaded(sess, trans.reachable.as_slice(), work_items);\n+        run_work_singlethreaded(sess, trans.reachable[], work_items);\n     } else {\n         run_work_multithreaded(sess, work_items, sess.opts.cg.codegen_units);\n     }\n@@ -666,7 +666,7 @@ pub fn run_passes(sess: &Session,\n                 // 2) Multiple codegen units, with `-o some_name`.  We have\n                 //    no good solution for this case, so warn the user.\n                 sess.warn(format!(\"ignoring -o because multiple .{} files were produced\",\n-                                  ext).as_slice());\n+                                  ext)[]);\n             } else {\n                 // 3) Multiple codegen units, but no `-o some_name`.  We\n                 //    just leave the `foo.0.x` files in place.\n@@ -699,20 +699,20 @@ pub fn run_passes(sess: &Session,\n             };\n \n         let pname = get_cc_prog(sess);\n-        let mut cmd = Command::new(pname.as_slice());\n+        let mut cmd = Command::new(pname[]);\n \n-        cmd.args(sess.target.target.options.pre_link_args.as_slice());\n+        cmd.args(sess.target.target.options.pre_link_args[]);\n         cmd.arg(\"-nostdlib\");\n \n         for index in range(0, trans.modules.len()) {\n-            cmd.arg(crate_output.with_extension(format!(\"{}.o\", index).as_slice()));\n+            cmd.arg(crate_output.with_extension(format!(\"{}.o\", index)[]));\n         }\n \n         cmd.arg(\"-r\")\n            .arg(\"-o\")\n            .arg(windows_output_path.as_ref().unwrap_or(output_path));\n \n-        cmd.args(sess.target.target.options.post_link_args.as_slice());\n+        cmd.args(sess.target.target.options.post_link_args[]);\n \n         if (sess.opts.debugging_opts & config::PRINT_LINK_ARGS) != 0 {\n             println!(\"{}\", &cmd);\n@@ -725,14 +725,14 @@ pub fn run_passes(sess: &Session,\n             Ok(status) => {\n                 if !status.success() {\n                     sess.err(format!(\"linking of {} with `{}` failed\",\n-                                     output_path.display(), cmd).as_slice());\n+                                     output_path.display(), cmd)[]);\n                     sess.abort_if_errors();\n                 }\n             },\n             Err(e) => {\n                 sess.err(format!(\"could not exec the linker `{}`: {}\",\n                                  pname,\n-                                 e).as_slice());\n+                                 e)[]);\n                 sess.abort_if_errors();\n             },\n         }\n@@ -817,12 +817,12 @@ pub fn run_passes(sess: &Session,\n         for i in range(0, trans.modules.len()) {\n             if modules_config.emit_obj {\n                 let ext = format!(\"{}.o\", i);\n-                remove(sess, &crate_output.with_extension(ext.as_slice()));\n+                remove(sess, &crate_output.with_extension(ext[]));\n             }\n \n             if modules_config.emit_bc && !keep_numbered_bitcode {\n                 let ext = format!(\"{}.bc\", i);\n-                remove(sess, &crate_output.with_extension(ext.as_slice()));\n+                remove(sess, &crate_output.with_extension(ext[]));\n             }\n         }\n \n@@ -948,7 +948,7 @@ fn run_work_multithreaded(sess: &Session,\n \n pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n     let pname = get_cc_prog(sess);\n-    let mut cmd = Command::new(pname.as_slice());\n+    let mut cmd = Command::new(pname[]);\n \n     cmd.arg(\"-c\").arg(\"-o\").arg(outputs.path(config::OutputTypeObject))\n                            .arg(outputs.temp_path(config::OutputTypeAssembly));\n@@ -959,18 +959,18 @@ pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n             if !prog.status.success() {\n                 sess.err(format!(\"linking with `{}` failed: {}\",\n                                  pname,\n-                                 prog.status).as_slice());\n-                sess.note(format!(\"{}\", &cmd).as_slice());\n+                                 prog.status)[]);\n+                sess.note(format!(\"{}\", &cmd)[]);\n                 let mut note = prog.error.clone();\n-                note.push_all(prog.output.as_slice());\n-                sess.note(str::from_utf8(note.as_slice()).unwrap());\n+                note.push_all(prog.output[]);\n+                sess.note(str::from_utf8(note[]).unwrap());\n                 sess.abort_if_errors();\n             }\n         },\n         Err(e) => {\n             sess.err(format!(\"could not exec the linker `{}`: {}\",\n                              pname,\n-                             e).as_slice());\n+                             e)[]);\n             sess.abort_if_errors();\n         }\n     }\n@@ -1003,7 +1003,7 @@ unsafe fn configure_llvm(sess: &Session) {\n         if sess.print_llvm_passes() { add(\"-debug-pass=Structure\"); }\n \n         for arg in sess.opts.cg.llvm_args.iter() {\n-            add((*arg).as_slice());\n+            add((*arg)[]);\n         }\n     }\n "}, {"sha": "0183aa8c2aabb16b3abb6ee61faf9fbe51e6c64c", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 73, "deletions": 73, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -94,7 +94,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n         // dump info about all the external crates referenced from this crate\n         self.sess.cstore.iter_crate_data(|n, cmd| {\n-            self.fmt.external_crate_str(krate.span, cmd.name.as_slice(), n);\n+            self.fmt.external_crate_str(krate.span, cmd.name[], n);\n         });\n         self.fmt.recorder.record(\"end_external_crates\\n\");\n     }\n@@ -143,7 +143,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         for &(ref span, ref qualname) in sub_paths.iter() {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n-                                     qualname.as_slice(),\n+                                     qualname[],\n                                      self.cur_scope);\n         }\n     }\n@@ -161,7 +161,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         for &(ref span, ref qualname) in sub_paths.iter() {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n-                                     qualname.as_slice(),\n+                                     qualname[],\n                                      self.cur_scope);\n         }\n     }\n@@ -180,7 +180,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         let (ref span, ref qualname) = sub_paths[len-2];\n         self.fmt.sub_type_ref_str(path.span,\n                                   *span,\n-                                  qualname.as_slice());\n+                                  qualname[]);\n \n         // write the other sub-paths\n         if len <= 2 {\n@@ -190,7 +190,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         for &(ref span, ref qualname) in sub_paths.iter() {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n-                                     qualname.as_slice(),\n+                                     qualname[],\n                                      self.cur_scope);\n         }\n     }\n@@ -199,7 +199,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n     fn lookup_type_ref(&self, ref_id: NodeId) -> Option<DefId> {\n         if !self.analysis.ty_cx.def_map.borrow().contains_key(&ref_id) {\n             self.sess.bug(format!(\"def_map has no key for {} in lookup_type_ref\",\n-                                  ref_id).as_slice());\n+                                  ref_id)[]);\n         }\n         let def = (*self.analysis.ty_cx.def_map.borrow())[ref_id];\n         match def {\n@@ -212,7 +212,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         let def_map = self.analysis.ty_cx.def_map.borrow();\n         if !def_map.contains_key(&ref_id) {\n             self.sess.span_bug(span, format!(\"def_map has no key for {} in lookup_def_kind\",\n-                                             ref_id).as_slice());\n+                                             ref_id)[]);\n         }\n         let def = (*def_map)[ref_id];\n         match def {\n@@ -241,7 +241,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefMethod(..) |\n             def::DefPrimTy(_) => {\n                 self.sess.span_bug(span, format!(\"lookup_def_kind for unexpected item: {}\",\n-                                                 def).as_slice());\n+                                                 def)[]);\n             },\n         }\n     }\n@@ -262,8 +262,8 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                     span_utils.span_for_last_ident(p.span),\n                                     id,\n                                     qualname,\n-                                    path_to_string(p).as_slice(),\n-                                    typ.as_slice());\n+                                    path_to_string(p)[],\n+                                    typ[]);\n             }\n             self.collected_paths.clear();\n         }\n@@ -285,14 +285,14 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     match item.node {\n                         ast::ItemImpl(_, _, _, ref ty, _) => {\n                             let mut result = String::from_str(\"<\");\n-                            result.push_str(ty_to_string(&**ty).as_slice());\n+                            result.push_str(ty_to_string(&**ty)[]);\n \n                             match ty::trait_of_item(&self.analysis.ty_cx,\n                                                     ast_util::local_def(method.id)) {\n                                 Some(def_id) => {\n                                     result.push_str(\" as \");\n                                     result.push_str(\n-                                        ty::item_path_str(&self.analysis.ty_cx, def_id).as_slice());\n+                                        ty::item_path_str(&self.analysis.ty_cx, def_id)[]);\n                                 },\n                                 None => {}\n                             }\n@@ -302,7 +302,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                         _ => {\n                             self.sess.span_bug(method.span,\n                                                format!(\"Container {} for method {} not an impl?\",\n-                                                       impl_id.node, method.id).as_slice());\n+                                                       impl_id.node, method.id)[]);\n                         },\n                     }\n                 },\n@@ -312,7 +312,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                impl_id.node,\n                                                method.id,\n                                                self.analysis.ty_cx.map.get(impl_id.node)\n-                                              ).as_slice());\n+                                              )[]);\n                 },\n             },\n             None => match ty::trait_of_item(&self.analysis.ty_cx,\n@@ -328,20 +328,20 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                         _ => {\n                             self.sess.span_bug(method.span,\n                                                format!(\"Could not find container {} for method {}\",\n-                                                       def_id.node, method.id).as_slice());\n+                                                       def_id.node, method.id)[]);\n                         }\n                     }\n                 },\n                 None => {\n                     self.sess.span_bug(method.span,\n                                        format!(\"Could not find container for method {}\",\n-                                               method.id).as_slice());\n+                                               method.id)[]);\n                 },\n             },\n         };\n \n         qualname.push_str(get_ident(method.pe_ident()).get());\n-        let qualname = qualname.as_slice();\n+        let qualname = qualname[];\n \n         // record the decl for this def (if it has one)\n         let decl_id = ty::trait_item_of_item(&self.analysis.ty_cx,\n@@ -430,13 +430,13 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     Some(sub_span) => self.fmt.field_str(field.span,\n                                                          Some(sub_span),\n                                                          field.node.id,\n-                                                         name.get().as_slice(),\n-                                                         qualname.as_slice(),\n-                                                         typ.as_slice(),\n+                                                         name.get()[],\n+                                                         qualname[],\n+                                                         typ[],\n                                                          scope_id),\n                     None => self.sess.span_bug(field.span,\n                                                format!(\"Could not find sub-span for field {}\",\n-                                                       qualname).as_slice()),\n+                                                       qualname)[]),\n                 }\n             },\n             _ => (),\n@@ -463,7 +463,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             self.fmt.typedef_str(full_span,\n                                  Some(*param_ss),\n                                  param.id,\n-                                 name.as_slice(),\n+                                 name[],\n                                  \"\");\n         }\n         self.visit_generics(generics);\n@@ -480,10 +480,10 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.fmt.fn_str(item.span,\n                         sub_span,\n                         item.id,\n-                        qualname.as_slice(),\n+                        qualname[],\n                         self.cur_scope);\n \n-        self.process_formals(&decl.inputs, qualname.as_slice());\n+        self.process_formals(&decl.inputs, qualname[]);\n \n         // walk arg and return types\n         for arg in decl.inputs.iter() {\n@@ -497,7 +497,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         // walk the body\n         self.nest(item.id, |v| v.visit_block(&*body));\n \n-        self.process_generic_params(ty_params, item.span, qualname.as_slice(), item.id);\n+        self.process_generic_params(ty_params, item.span, qualname[], item.id);\n     }\n \n     fn process_static(&mut self,\n@@ -519,9 +519,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             sub_span,\n                             item.id,\n                             get_ident(item.ident).get(),\n-                            qualname.as_slice(),\n-                            value.as_slice(),\n-                            ty_to_string(&*typ).as_slice(),\n+                            qualname[],\n+                            value[],\n+                            ty_to_string(&*typ)[],\n                             self.cur_scope);\n \n         // walk type and init value\n@@ -542,9 +542,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             sub_span,\n                             item.id,\n                             get_ident(item.ident).get(),\n-                            qualname.as_slice(),\n+                            qualname[],\n                             \"\",\n-                            ty_to_string(&*typ).as_slice(),\n+                            ty_to_string(&*typ)[],\n                             self.cur_scope);\n \n         // walk type and init value\n@@ -568,17 +568,17 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             sub_span,\n                             item.id,\n                             ctor_id,\n-                            qualname.as_slice(),\n+                            qualname[],\n                             self.cur_scope,\n-                            val.as_slice());\n+                            val[]);\n \n         // fields\n         for field in def.fields.iter() {\n-            self.process_struct_field_def(field, qualname.as_slice(), item.id);\n+            self.process_struct_field_def(field, qualname[], item.id);\n             self.visit_ty(&*field.node.ty);\n         }\n \n-        self.process_generic_params(ty_params, item.span, qualname.as_slice(), item.id);\n+        self.process_generic_params(ty_params, item.span, qualname[], item.id);\n     }\n \n     fn process_enum(&mut self,\n@@ -591,12 +591,12 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             Some(sub_span) => self.fmt.enum_str(item.span,\n                                                 Some(sub_span),\n                                                 item.id,\n-                                                enum_name.as_slice(),\n+                                                enum_name[],\n                                                 self.cur_scope,\n-                                                val.as_slice()),\n+                                                val[]),\n             None => self.sess.span_bug(item.span,\n                                        format!(\"Could not find subspan for enum {}\",\n-                                               enum_name).as_slice()),\n+                                               enum_name)[]),\n         }\n         for variant in enum_definition.variants.iter() {\n             let name = get_ident(variant.node.name);\n@@ -612,9 +612,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                self.span.span_for_first_ident(variant.span),\n                                                variant.node.id,\n                                                name,\n-                                               qualname.as_slice(),\n-                                               enum_name.as_slice(),\n-                                               val.as_slice(),\n+                                               qualname[],\n+                                               enum_name[],\n+                                               val[],\n                                                item.id);\n                     for arg in args.iter() {\n                         self.visit_ty(&*arg.ty);\n@@ -630,20 +630,20 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                         self.span.span_for_first_ident(variant.span),\n                         variant.node.id,\n                         ctor_id,\n-                        qualname.as_slice(),\n-                        enum_name.as_slice(),\n-                        val.as_slice(),\n+                        qualname[],\n+                        enum_name[],\n+                        val[],\n                         item.id);\n \n                     for field in struct_def.fields.iter() {\n-                        self.process_struct_field_def(field, enum_name.as_slice(), variant.node.id);\n+                        self.process_struct_field_def(field, enum_name[], variant.node.id);\n                         self.visit_ty(&*field.node.ty);\n                     }\n                 }\n             }\n         }\n \n-        self.process_generic_params(ty_params, item.span, enum_name.as_slice(), item.id);\n+        self.process_generic_params(ty_params, item.span, enum_name[], item.id);\n     }\n \n     fn process_impl(&mut self,\n@@ -703,9 +703,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.fmt.trait_str(item.span,\n                            sub_span,\n                            item.id,\n-                           qualname.as_slice(),\n+                           qualname[],\n                            self.cur_scope,\n-                           val.as_slice());\n+                           val[]);\n \n         // super-traits\n         for super_bound in trait_refs.iter() {\n@@ -737,7 +737,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         }\n \n         // walk generics and methods\n-        self.process_generic_params(generics, item.span, qualname.as_slice(), item.id);\n+        self.process_generic_params(generics, item.span, qualname[], item.id);\n         for method in methods.iter() {\n             self.visit_trait_item(method)\n         }\n@@ -755,9 +755,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.fmt.mod_str(item.span,\n                          sub_span,\n                          item.id,\n-                         qualname.as_slice(),\n+                         qualname[],\n                          self.cur_scope,\n-                         filename.as_slice());\n+                         filename[]);\n \n         self.nest(item.id, |v| visit::walk_mod(v, m));\n     }\n@@ -773,7 +773,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         if !def_map.contains_key(&ex.id) {\n             self.sess.span_bug(ex.span,\n                                format!(\"def_map has no key for {} in visit_expr\",\n-                                       ex.id).as_slice());\n+                                       ex.id)[]);\n         }\n         let def = &(*def_map)[ex.id];\n         let sub_span = self.span.span_for_last_ident(ex.span);\n@@ -840,7 +840,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                              self.cur_scope),\n             _ => self.sess.span_bug(ex.span,\n                                     format!(\"Unexpected def kind while looking up path in '{}'\",\n-                                            self.span.snippet(ex.span)).as_slice()),\n+                                            self.span.snippet(ex.span))[]),\n         }\n         // modules or types in the path prefix\n         match *def {\n@@ -961,7 +961,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                self.cur_scope);\n \n         // walk receiver and args\n-        visit::walk_exprs(self, args.as_slice());\n+        visit::walk_exprs(self, args[]);\n     }\n \n     fn process_pat(&mut self, p:&ast::Pat) {\n@@ -978,7 +978,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     None => {\n                         self.sess.span_bug(p.span,\n                                            format!(\"Could not find struct_def for `{}`\",\n-                                                   self.span.snippet(p.span)).as_slice());\n+                                                   self.span.snippet(p.span))[]);\n                     }\n                 };\n                 for &Spanned { node: ref field, span } in fields.iter() {\n@@ -1062,11 +1062,11 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 self.fmt.typedef_str(item.span,\n                                      sub_span,\n                                      item.id,\n-                                     qualname.as_slice(),\n-                                     value.as_slice());\n+                                     qualname[],\n+                                     value[]);\n \n                 self.visit_ty(&**ty);\n-                self.process_generic_params(ty_params, item.span, qualname.as_slice(), item.id);\n+                self.process_generic_params(ty_params, item.span, qualname[], item.id);\n             },\n             ast::ItemMac(_) => (),\n             _ => visit::walk_item(self, item),\n@@ -1123,12 +1123,12 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                     None => {\n                         self.sess.span_bug(method_type.span,\n                                            format!(\"Could not find trait for method {}\",\n-                                                   method_type.id).as_slice());\n+                                                   method_type.id)[]);\n                     },\n                 };\n \n                 qualname.push_str(get_ident(method_type.ident).get());\n-                let qualname = qualname.as_slice();\n+                let qualname = qualname[];\n \n                 let sub_span = self.span.sub_span_after_keyword(method_type.span, keywords::Fn);\n                 self.fmt.method_decl_str(method_type.span,\n@@ -1243,7 +1243,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                           id,\n                                           cnum,\n                                           name,\n-                                          s.as_slice(),\n+                                          s[],\n                                           self.cur_scope);\n             },\n         }\n@@ -1349,8 +1349,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 }\n \n                 let mut id = String::from_str(\"$\");\n-                id.push_str(ex.id.to_string().as_slice());\n-                self.process_formals(&decl.inputs, id.as_slice());\n+                id.push_str(ex.id.to_string()[]);\n+                self.process_formals(&decl.inputs, id[]);\n \n                 // walk arg and return types\n                 for arg in decl.inputs.iter() {\n@@ -1393,7 +1393,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n         // process collected paths\n         for &(id, ref p, ref immut, ref_kind) in self.collected_paths.iter() {\n             let value = if *immut {\n-                self.span.snippet(p.span).into_string()\n+                self.span.snippet(p.span).to_string()\n             } else {\n                 \"<mutable>\".to_string()\n             };\n@@ -1402,15 +1402,15 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n             if !def_map.contains_key(&id) {\n                 self.sess.span_bug(p.span,\n                                    format!(\"def_map has no key for {} in visit_arm\",\n-                                           id).as_slice());\n+                                           id)[]);\n             }\n             let def = &(*def_map)[id];\n             match *def {\n                 def::DefLocal(id)  => self.fmt.variable_str(p.span,\n                                                             sub_span,\n                                                             id,\n-                                                            path_to_string(p).as_slice(),\n-                                                            value.as_slice(),\n+                                                            path_to_string(p)[],\n+                                                            value[],\n                                                             \"\"),\n                 def::DefVariant(_,id,_) => self.fmt.ref_str(ref_kind,\n                                                             p.span,\n@@ -1462,9 +1462,9 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n             self.fmt.variable_str(p.span,\n                                   sub_span,\n                                   id,\n-                                  path_to_string(p).as_slice(),\n-                                  value.as_slice(),\n-                                  typ.as_slice());\n+                                  path_to_string(p)[],\n+                                  value[],\n+                                  typ[]);\n         }\n         self.collected_paths.clear();\n \n@@ -1482,7 +1482,7 @@ pub fn process_crate(sess: &Session,\n         return;\n     }\n \n-    let cratename = match attr::find_crate_name(krate.attrs.as_slice()) {\n+    let cratename = match attr::find_crate_name(krate.attrs[]) {\n         Some(name) => name.get().to_string(),\n         None => {\n             info!(\"Could not find crate name, using 'unknown_crate'\");\n@@ -1503,7 +1503,7 @@ pub fn process_crate(sess: &Session,\n \n     match fs::mkdir_recursive(&root_path, io::USER_RWX) {\n         Err(e) => sess.err(format!(\"Could not create directory {}: {}\",\n-                           root_path.display(), e).as_slice()),\n+                           root_path.display(), e)[]),\n         _ => (),\n     }\n \n@@ -1520,7 +1520,7 @@ pub fn process_crate(sess: &Session,\n         Ok(f) => box f,\n         Err(e) => {\n             let disp = root_path.display();\n-            sess.fatal(format!(\"Could not open {}: {}\", disp, e).as_slice());\n+            sess.fatal(format!(\"Could not open {}: {}\", disp, e)[]);\n         }\n     };\n     root_path.pop();\n@@ -1546,7 +1546,7 @@ pub fn process_crate(sess: &Session,\n         cur_scope: 0\n     };\n \n-    visitor.dump_crate_info(cratename.as_slice(), krate);\n+    visitor.dump_crate_info(cratename[], krate);\n \n     visit::walk_crate(&mut visitor, krate);\n }"}, {"sha": "08670864ade9386dfb3e8b9a9d9f80124b9112f9", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -41,7 +41,7 @@ impl Recorder {\n         assert!(self.dump_spans);\n         let result = format!(\"span,kind,{},{},text,\\\"{}\\\"\\n\",\n                              kind, su.extent_str(span), escape(su.snippet(span)));\n-        self.record(result.as_slice());\n+        self.record(result[]);\n     }\n }\n \n@@ -158,15 +158,15 @@ impl<'a> FmtStrs<'a> {\n         if values.len() != fields.len() {\n             self.span.sess.span_bug(span, format!(\n                 \"Mismatch between length of fields for '{}', expected '{}', found '{}'\",\n-                kind, fields.len(), values.len()).as_slice());\n+                kind, fields.len(), values.len())[]);\n         }\n \n         let values = values.iter().map(|s| {\n             // Never take more than 1020 chars\n             if s.len() > 1020 {\n-                s.slice_to(1020)\n+                s[..1020]\n             } else {\n-                s.as_slice()\n+                s[]\n             }\n         });\n \n@@ -182,7 +182,7 @@ impl<'a> FmtStrs<'a> {\n             }\n         )));\n         Some(strs.fold(String::new(), |mut s, ss| {\n-            s.push_str(ss.as_slice());\n+            s.push_str(ss[]);\n             s\n         }))\n     }\n@@ -196,7 +196,7 @@ impl<'a> FmtStrs<'a> {\n         if needs_span {\n             self.span.sess.span_bug(span, format!(\n                 \"Called record_without_span for '{}' which does requires a span\",\n-                label).as_slice());\n+                label)[]);\n         }\n         assert!(!dump_spans);\n \n@@ -210,9 +210,9 @@ impl<'a> FmtStrs<'a> {\n         };\n \n         let mut result = String::from_str(label);\n-        result.push_str(values_str.as_slice());\n+        result.push_str(values_str[]);\n         result.push_str(\"\\n\");\n-        self.recorder.record(result.as_slice());\n+        self.recorder.record(result[]);\n     }\n \n     pub fn record_with_span(&mut self,\n@@ -235,15 +235,15 @@ impl<'a> FmtStrs<'a> {\n         if !needs_span {\n             self.span.sess.span_bug(span,\n                                     format!(\"Called record_with_span for '{}' \\\n-                                             which does not require a span\", label).as_slice());\n+                                             which does not require a span\", label)[]);\n         }\n \n         let values_str = match self.make_values_str(label, fields, values, span) {\n             Some(vs) => vs,\n             None => return,\n         };\n         let result = format!(\"{},{}{}\\n\", label, self.span.extent_str(sub_span), values_str);\n-        self.recorder.record(result.as_slice());\n+        self.recorder.record(result[]);\n     }\n \n     pub fn check_and_record(&mut self,\n@@ -273,7 +273,7 @@ impl<'a> FmtStrs<'a> {\n         // variable def's node id\n         let mut qualname = String::from_str(name);\n         qualname.push_str(\"$\");\n-        qualname.push_str(id.to_string().as_slice());\n+        qualname.push_str(id.to_string()[]);\n         self.check_and_record(Variable,\n                               span,\n                               sub_span,"}, {"sha": "a92d3c06e64fba5f6263bf33e8fdedb1c3b8fe01", "filename": "src/librustc_trans/save/span_utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -218,7 +218,7 @@ impl<'a> SpanUtils<'a> {\n             let loc = self.sess.codemap().lookup_char_pos(span.lo);\n             self.sess.span_bug(span,\n                 format!(\"Mis-counted brackets when breaking path? Parsing '{}' in {}, line {}\",\n-                        self.snippet(span), loc.file.name, loc.line).as_slice());\n+                        self.snippet(span), loc.file.name, loc.line)[]);\n         }\n         if result.is_none() && prev.tok.is_ident() && bracket_count == 0 {\n             return self.make_sub_span(span, Some(prev.sp));\n@@ -244,7 +244,7 @@ impl<'a> SpanUtils<'a> {\n                     let loc = self.sess.codemap().lookup_char_pos(span.lo);\n                     self.sess.span_bug(span, format!(\n                         \"Mis-counted brackets when breaking path? Parsing '{}' in {}, line {}\",\n-                         self.snippet(span), loc.file.name, loc.line).as_slice());\n+                         self.snippet(span), loc.file.name, loc.line)[]);\n                 }\n                 return result\n             }"}, {"sha": "33fd14a441b8a955e27b5b013fbb048389bcb25c", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -427,7 +427,7 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _indenter = indenter();\n \n     m.iter().filter_map(|br| {\n-        e(br.pats.as_slice()).map(|pats| {\n+        e(br.pats[]).map(|pats| {\n             let this = br.pats[col];\n             let mut bound_ptrs = br.bound_ptrs.clone();\n             match this.node {\n@@ -548,7 +548,7 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n         param_env: param_env,\n     };\n     enter_match(bcx, dm, m, col, val, |pats|\n-        check_match::specialize(&mcx, pats.as_slice(), &ctor, col, variant_size)\n+        check_match::specialize(&mcx, pats[], &ctor, col, variant_size)\n     )\n }\n \n@@ -790,7 +790,7 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n         let did = langcall(cx,\n                            None,\n                            format!(\"comparison of `{}`\",\n-                                   cx.ty_to_string(rhs_t)).as_slice(),\n+                                   cx.ty_to_string(rhs_t))[],\n                            StrEqFnLangItem);\n         callee::trans_lang_call(cx, did, &[lhs, rhs], None)\n     }\n@@ -943,7 +943,7 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             if has_nested_bindings(m, col) {\n                 let expanded = expand_nested_bindings(bcx, m, col, val);\n                 compile_submatch_continue(bcx,\n-                                          expanded.as_slice(),\n+                                          expanded[],\n                                           vals,\n                                           chk,\n                                           col,\n@@ -1035,8 +1035,8 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                         field_vals.len())\n             );\n             let mut vals = field_vals;\n-            vals.push_all(vals_left.as_slice());\n-            compile_submatch(bcx, pats.as_slice(), vals.as_slice(), chk, has_genuine_default);\n+            vals.push_all(vals_left[]);\n+            compile_submatch(bcx, pats[], vals[], chk, has_genuine_default);\n             return;\n         }\n         _ => ()\n@@ -1189,10 +1189,10 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n         let opt_ms = enter_opt(opt_cx, pat_id, dm, m, opt, col, size, val);\n         let mut opt_vals = unpacked;\n-        opt_vals.push_all(vals_left.as_slice());\n+        opt_vals.push_all(vals_left[]);\n         compile_submatch(opt_cx,\n-                         opt_ms.as_slice(),\n-                         opt_vals.as_slice(),\n+                         opt_ms[],\n+                         opt_vals[],\n                          branch_chk.as_ref().unwrap_or(chk),\n                          has_genuine_default);\n     }\n@@ -1211,8 +1211,8 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             }\n             _ => {\n                 compile_submatch(else_cx,\n-                                 defaults.as_slice(),\n-                                 vals_left.as_slice(),\n+                                 defaults[],\n+                                 vals_left[],\n                                  chk,\n                                  has_genuine_default);\n             }\n@@ -1333,21 +1333,21 @@ fn create_bindings_map<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, pat: &ast::Pat,\n                                  \"__llmatch\");\n                 trmode = TrByCopy(alloca_no_lifetime(bcx,\n                                          llvariable_ty,\n-                                         bcx.ident(ident).as_slice()));\n+                                         bcx.ident(ident)[]));\n             }\n             ast::BindByValue(_) => {\n                 // in this case, the final type of the variable will be T,\n                 // but during matching we need to store a *T as explained\n                 // above\n                 llmatch = alloca_no_lifetime(bcx,\n                                  llvariable_ty.ptr_to(),\n-                                 bcx.ident(ident).as_slice());\n+                                 bcx.ident(ident)[]);\n                 trmode = TrByMove;\n             }\n             ast::BindByRef(_) => {\n                 llmatch = alloca_no_lifetime(bcx,\n                                  llvariable_ty,\n-                                 bcx.ident(ident).as_slice());\n+                                 bcx.ident(ident)[]);\n                 trmode = TrByRef;\n             }\n         };\n@@ -1415,7 +1415,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n         && arm.pats.last().unwrap().node == ast::PatWild(ast::PatWildSingle)\n     });\n \n-    compile_submatch(bcx, matches.as_slice(), &[discr_datum.val], &chk, has_default);\n+    compile_submatch(bcx, matches[], &[discr_datum.val], &chk, has_default);\n \n     let mut arm_cxs = Vec::new();\n     for arm_data in arm_datas.iter() {\n@@ -1429,7 +1429,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n         arm_cxs.push(bcx);\n     }\n \n-    bcx = scope_cx.fcx.join_blocks(match_id, arm_cxs.as_slice());\n+    bcx = scope_cx.fcx.join_blocks(match_id, arm_cxs[]);\n     return bcx;\n }\n \n@@ -1581,7 +1581,7 @@ fn mk_binding_alloca<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n     let var_ty = node_id_type(bcx, p_id);\n \n     // Allocate memory on stack for the binding.\n-    let llval = alloc_ty(bcx, var_ty, bcx.ident(*ident).as_slice());\n+    let llval = alloc_ty(bcx, var_ty, bcx.ident(*ident)[]);\n \n     // Subtle: be sure that we *populate* the memory *before*\n     // we schedule the cleanup.\n@@ -1619,7 +1619,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     if bcx.sess().asm_comments() {\n         add_comment(bcx, format!(\"bind_irrefutable_pat(pat={})\",\n-                                 pat.repr(bcx.tcx())).as_slice());\n+                                 pat.repr(bcx.tcx()))[]);\n     }\n \n     let _indenter = indenter();"}, {"sha": "9794611dd8471185ab858b1adde587942436f99d", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -156,7 +156,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                      t: Ty<'tcx>) -> Repr<'tcx> {\n     match t.sty {\n         ty::ty_tup(ref elems) => {\n-            Univariant(mk_struct(cx, elems.as_slice(), false, t), false)\n+            Univariant(mk_struct(cx, elems[], false, t), false)\n         }\n         ty::ty_struct(def_id, ref substs) => {\n             let fields = ty::lookup_struct_fields(cx.tcx(), def_id);\n@@ -167,16 +167,16 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n             if dtor { ftys.push(ty::mk_bool()); }\n \n-            Univariant(mk_struct(cx, ftys.as_slice(), packed, t), dtor)\n+            Univariant(mk_struct(cx, ftys[], packed, t), dtor)\n         }\n         ty::ty_unboxed_closure(def_id, _, ref substs) => {\n             let upvars = ty::unboxed_closure_upvars(cx.tcx(), def_id, substs);\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n-            Univariant(mk_struct(cx, upvar_types.as_slice(), false, t), false)\n+            Univariant(mk_struct(cx, upvar_types[], false, t), false)\n         }\n         ty::ty_enum(def_id, ref substs) => {\n             let cases = get_cases(cx.tcx(), def_id, substs);\n-            let hint = *ty::lookup_repr_hints(cx.tcx(), def_id).as_slice().get(0)\n+            let hint = *ty::lookup_repr_hints(cx.tcx(), def_id)[].get(0)\n                 .unwrap_or(&attr::ReprAny);\n \n             let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n@@ -186,7 +186,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 // (Typechecking will reject discriminant-sizing attrs.)\n                 assert_eq!(hint, attr::ReprAny);\n                 let ftys = if dtor { vec!(ty::mk_bool()) } else { vec!() };\n-                return Univariant(mk_struct(cx, ftys.as_slice(), false, t),\n+                return Univariant(mk_struct(cx, ftys[], false, t),\n                                   dtor);\n             }\n \n@@ -209,7 +209,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 cx.sess().bug(format!(\"non-C-like enum {} with specified \\\n                                       discriminants\",\n                                       ty::item_path_str(cx.tcx(),\n-                                                        def_id)).as_slice());\n+                                                        def_id))[]);\n             }\n \n             if cases.len() == 1 {\n@@ -218,7 +218,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 assert_eq!(hint, attr::ReprAny);\n                 let mut ftys = cases[0].tys.clone();\n                 if dtor { ftys.push(ty::mk_bool()); }\n-                return Univariant(mk_struct(cx, ftys.as_slice(), false, t),\n+                return Univariant(mk_struct(cx, ftys[], false, t),\n                                   dtor);\n             }\n \n@@ -227,7 +227,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 let mut discr = 0;\n                 while discr < 2 {\n                     if cases[1 - discr].is_zerolen(cx, t) {\n-                        let st = mk_struct(cx, cases[discr].tys.as_slice(),\n+                        let st = mk_struct(cx, cases[discr].tys[],\n                                            false, t);\n                         match cases[discr].find_ptr(cx) {\n                             Some(ThinPointer(_)) if st.fields.len() == 1 => {\n@@ -260,17 +260,17 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             let fields : Vec<_> = cases.iter().map(|c| {\n                 let mut ftys = vec!(ty_of_inttype(ity));\n-                ftys.push_all(c.tys.as_slice());\n+                ftys.push_all(c.tys[]);\n                 if dtor { ftys.push(ty::mk_bool()); }\n-                mk_struct(cx, ftys.as_slice(), false, t)\n+                mk_struct(cx, ftys[], false, t)\n             }).collect();\n \n-            ensure_enum_fits_in_address_space(cx, ity, fields.as_slice(), t);\n+            ensure_enum_fits_in_address_space(cx, ity, fields[], t);\n \n             General(ity, fields, dtor)\n         }\n         _ => cx.sess().bug(format!(\"adt::represent_type called on non-ADT type: {}\",\n-                           ty_to_string(cx.tcx(), t)).as_slice())\n+                           ty_to_string(cx.tcx(), t))[])\n     }\n }\n \n@@ -290,7 +290,7 @@ pub enum PointerField {\n impl<'tcx> Case<'tcx> {\n     fn is_zerolen<'a>(&self, cx: &CrateContext<'a, 'tcx>, scapegoat: Ty<'tcx>)\n                       -> bool {\n-        mk_struct(cx, self.tys.as_slice(), false, scapegoat).size == 0\n+        mk_struct(cx, self.tys[], false, scapegoat).size == 0\n     }\n \n     fn find_ptr<'a>(&self, cx: &CrateContext<'a, 'tcx>) -> Option<PointerField> {\n@@ -352,9 +352,9 @@ fn mk_struct<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n            .map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n     };\n \n-    ensure_struct_fits_in_address_space(cx, lltys.as_slice(), packed, scapegoat);\n+    ensure_struct_fits_in_address_space(cx, lltys[], packed, scapegoat);\n \n-    let llty_rec = Type::struct_(cx, lltys.as_slice(), packed);\n+    let llty_rec = Type::struct_(cx, lltys[], packed);\n     Struct {\n         size: machine::llsize_of_alloc(cx, llty_rec),\n         align: machine::llalign_of_min(cx, llty_rec),\n@@ -403,7 +403,7 @@ fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntTyp\n             return ity;\n         }\n         attr::ReprExtern => {\n-            attempts = match cx.sess().target.target.arch.as_slice() {\n+            attempts = match cx.sess().target.target.arch[] {\n                 // WARNING: the ARM EABI has two variants; the one corresponding to `at_least_32`\n                 // appears to be used on Linux and NetBSD, but some systems may use the variant\n                 // corresponding to `choose_shortest`.  However, we don't run on those yet...?\n@@ -530,7 +530,7 @@ pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     match *r {\n         CEnum(..) | General(..) | RawNullablePointer { .. } => { }\n         Univariant(ref st, _) | StructWrappedNullablePointer { nonnull: ref st, .. } =>\n-            llty.set_struct_body(struct_llfields(cx, st, false, false).as_slice(),\n+            llty.set_struct_body(struct_llfields(cx, st, false, false)[],\n                                  st.packed)\n     }\n }\n@@ -546,7 +546,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         Univariant(ref st, _) | StructWrappedNullablePointer { nonnull: ref st, .. } => {\n             match name {\n                 None => {\n-                    Type::struct_(cx, struct_llfields(cx, st, sizing, dst).as_slice(),\n+                    Type::struct_(cx, struct_llfields(cx, st, sizing, dst)[],\n                                   st.packed)\n                 }\n                 Some(name) => { assert_eq!(sizing, false); Type::named_struct(cx, name) }\n@@ -565,7 +565,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // of the size.\n             //\n             // FIXME #10604: this breaks when vector types are present.\n-            let (size, align) = union_size_and_align(sts.as_slice());\n+            let (size, align) = union_size_and_align(sts[]);\n             let align_s = align as u64;\n             let discr_ty = ll_inttype(cx, ity);\n             let discr_size = machine::llsize_of_alloc(cx, discr_ty);\n@@ -586,10 +586,10 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                            Type::array(&discr_ty, align_s / discr_size - 1),\n                            pad_ty);\n             match name {\n-                None => Type::struct_(cx, fields.as_slice(), false),\n+                None => Type::struct_(cx, fields[], false),\n                 Some(name) => {\n                     let mut llty = Type::named_struct(cx, name);\n-                    llty.set_struct_body(fields.as_slice(), false);\n+                    llty.set_struct_body(fields[], false);\n                     llty\n                 }\n             }\n@@ -847,7 +847,7 @@ pub fn struct_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, st: &Struct<'tcx>, v\n     let val = if needs_cast {\n         let ccx = bcx.ccx();\n         let fields = st.fields.iter().map(|&ty| type_of::type_of(ccx, ty)).collect::<Vec<_>>();\n-        let real_ty = Type::struct_(ccx, fields.as_slice(), st.packed);\n+        let real_ty = Type::struct_(ccx, fields[], st.packed);\n         PointerCast(bcx, val, real_ty.ptr_to())\n     } else {\n         val\n@@ -879,14 +879,14 @@ pub fn fold_variants<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n             for (discr, case) in cases.iter().enumerate() {\n                 let mut variant_cx = fcx.new_temp_block(\n-                    format!(\"enum-variant-iter-{}\", discr.to_string()).as_slice()\n+                    format!(\"enum-variant-iter-{}\", discr.to_string())[]\n                 );\n                 let rhs_val = C_integral(ll_inttype(ccx, ity), discr as u64, true);\n                 AddCase(llswitch, rhs_val, variant_cx.llbb);\n \n                 let fields = case.fields.iter().map(|&ty|\n                     type_of::type_of(bcx.ccx(), ty)).collect::<Vec<_>>();\n-                let real_ty = Type::struct_(ccx, fields.as_slice(), case.packed);\n+                let real_ty = Type::struct_(ccx, fields[], case.packed);\n                 let variant_value = PointerCast(variant_cx, value, real_ty.ptr_to());\n \n                 variant_cx = f(variant_cx, case, variant_value);\n@@ -961,14 +961,14 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n             let lldiscr = C_integral(ll_inttype(ccx, ity), discr as u64, true);\n             let mut f = vec![lldiscr];\n             f.push_all(vals);\n-            let mut contents = build_const_struct(ccx, case, f.as_slice());\n+            let mut contents = build_const_struct(ccx, case, f[]);\n             contents.push_all(&[padding(ccx, max_sz - case.size)]);\n-            C_struct(ccx, contents.as_slice(), false)\n+            C_struct(ccx, contents[], false)\n         }\n         Univariant(ref st, _dro) => {\n             assert!(discr == 0);\n             let contents = build_const_struct(ccx, st, vals);\n-            C_struct(ccx, contents.as_slice(), st.packed)\n+            C_struct(ccx, contents[], st.packed)\n         }\n         RawNullablePointer { nndiscr, nnty, .. } => {\n             if discr == nndiscr {\n@@ -982,7 +982,7 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n             if discr == nndiscr {\n                 C_struct(ccx, build_const_struct(ccx,\n                                                  nonnull,\n-                                                 vals).as_slice(),\n+                                                 vals)[],\n                          false)\n             } else {\n                 let vals = nonnull.fields.iter().map(|&ty| {\n@@ -992,7 +992,7 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n                 }).collect::<Vec<ValueRef>>();\n                 C_struct(ccx, build_const_struct(ccx,\n                                                  nonnull,\n-                                                 vals.as_slice()).as_slice(),\n+                                                 vals[])[],\n                          false)\n             }\n         }"}, {"sha": "b8bee1000824dc4f6031a9abd6d0d35504d0cff8", "filename": "src/librustc_trans/trans/asm.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fasm.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -72,7 +72,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n                                     callee::DontAutorefArg)\n         })\n     }).collect::<Vec<_>>();\n-    inputs.push_all(ext_inputs.as_slice());\n+    inputs.push_all(ext_inputs[]);\n \n     // no failure occurred preparing operands, no need to cleanup\n     fcx.pop_custom_cleanup_scope(temp_scope);\n@@ -92,18 +92,18 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n         if !clobbers.is_empty() {\n             clobbers.push(',');\n         }\n-        clobbers.push_str(more_clobbers.as_slice());\n+        clobbers.push_str(more_clobbers[]);\n     }\n \n     // Add the clobbers to our constraints list\n     if clobbers.len() != 0 && constraints.len() != 0 {\n         constraints.push(',');\n-        constraints.push_str(clobbers.as_slice());\n+        constraints.push_str(clobbers[]);\n     } else {\n-        constraints.push_str(clobbers.as_slice());\n+        constraints.push_str(clobbers[]);\n     }\n \n-    debug!(\"Asm Constraints: {}\", constraints.as_slice());\n+    debug!(\"Asm Constraints: {}\", constraints[]);\n \n     let num_outputs = outputs.len();\n \n@@ -113,7 +113,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n     } else if num_outputs == 1 {\n         output_types[0]\n     } else {\n-        Type::struct_(bcx.ccx(), output_types.as_slice(), false)\n+        Type::struct_(bcx.ccx(), output_types[], false)\n     };\n \n     let dialect = match ia.dialect {\n@@ -126,7 +126,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n             InlineAsmCall(bcx,\n                           a,\n                           c,\n-                          inputs.as_slice(),\n+                          inputs[],\n                           output_type,\n                           ia.volatile,\n                           ia.alignstack,"}, {"sha": "f49fc7f06c5014a2b5e656af9da9d5fdddcd1770", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 60, "deletions": 59, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -249,7 +249,7 @@ fn get_extern_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<'tcx>,\n     let f = decl_rust_fn(ccx, fn_ty, name);\n \n     csearch::get_item_attrs(&ccx.sess().cstore, did, |attrs| {\n-        set_llvm_fn_attrs(ccx, attrs.as_slice(), f)\n+        set_llvm_fn_attrs(ccx, attrs[], f)\n     });\n \n     ccx.externs().borrow_mut().insert(name.to_string(), f);\n@@ -282,7 +282,7 @@ pub fn kind_for_unboxed_closure(ccx: &CrateContext, closure_id: ast::DefId)\n pub fn decl_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                               fn_ty: Ty<'tcx>, name: &str) -> ValueRef {\n     let (inputs, output, abi, env) = match fn_ty.sty {\n-        ty::ty_bare_fn(ref f) => {\n+        ty::ty_bare_fn(_, ref f) => {\n             (f.sig.0.inputs.clone(), f.sig.0.output, f.abi, None)\n         }\n         ty::ty_closure(ref f) => {\n@@ -302,7 +302,7 @@ pub fn decl_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         _ => panic!(\"expected closure or fn\")\n     };\n \n-    let llfty = type_of_rust_fn(ccx, env, inputs.as_slice(), output, abi);\n+    let llfty = type_of_rust_fn(ccx, env, inputs[], output, abi);\n     debug!(\"decl_rust_fn(input count={},type={})\",\n            inputs.len(),\n            ccx.tn().type_to_string(llfty));\n@@ -369,7 +369,7 @@ fn require_alloc_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         Err(s) => {\n             bcx.sess().fatal(format!(\"allocation of `{}` {}\",\n                                      bcx.ty_to_string(info_ty),\n-                                     s).as_slice());\n+                                     s)[]);\n         }\n     }\n }\n@@ -510,7 +510,7 @@ pub fn unset_split_stack(f: ValueRef) {\n // silently mangles such symbols, breaking our linkage model.\n pub fn note_unique_llvm_symbol(ccx: &CrateContext, sym: String) {\n     if ccx.all_llvm_symbols().borrow().contains(&sym) {\n-        ccx.sess().bug(format!(\"duplicate LLVM symbol: {}\", sym).as_slice());\n+        ccx.sess().bug(format!(\"duplicate LLVM symbol: {}\", sym)[]);\n     }\n     ccx.all_llvm_symbols().borrow_mut().insert(sym);\n }\n@@ -542,11 +542,12 @@ pub fn get_res_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         let class_ty = ty::lookup_item_type(tcx, parent_id).ty.subst(tcx, substs);\n         let llty = type_of_dtor(ccx, class_ty);\n         let dtor_ty = ty::mk_ctor_fn(ccx.tcx(),\n+                                     did,\n                                      &[glue::get_drop_glue_type(ccx, t)],\n                                      ty::mk_nil(ccx.tcx()));\n         get_extern_fn(ccx,\n                       &mut *ccx.externs().borrow_mut(),\n-                      name.as_slice(),\n+                      name[],\n                       llvm::CCallConv,\n                       llty,\n                       dtor_ty)\n@@ -796,8 +797,8 @@ pub fn iter_structural_ty<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                       let variant_cx =\n                           fcx.new_temp_block(\n                               format!(\"enum-iter-variant-{}\",\n-                                      variant.disr_val.to_string().as_slice())\n-                                     .as_slice());\n+                                      variant.disr_val.to_string()[])\n+                                     []);\n                       match adt::trans_case(cx, &*repr, variant.disr_val) {\n                           _match::SingleResult(r) => {\n                               AddCase(llswitch, r.val, variant_cx.llbb)\n@@ -822,7 +823,7 @@ pub fn iter_structural_ty<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n       }\n       _ => {\n           cx.sess().unimpl(format!(\"type in iter_structural_ty: {}\",\n-                                   ty_to_string(cx.tcx(), t)).as_slice())\n+                                   ty_to_string(cx.tcx(), t))[])\n       }\n     }\n     return cx;\n@@ -904,7 +905,7 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n         }\n         _ => {\n             cx.sess().bug(format!(\"fail-if-zero on unexpected type: {}\",\n-                                  ty_to_string(cx.tcx(), rhs_t)).as_slice());\n+                                  ty_to_string(cx.tcx(), rhs_t))[]);\n         }\n     };\n     let bcx = with_cond(cx, is_zero, |bcx| {\n@@ -955,22 +956,22 @@ pub fn trans_external_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                      did: ast::DefId, t: Ty<'tcx>) -> ValueRef {\n     let name = csearch::get_symbol(&ccx.sess().cstore, did);\n     match t.sty {\n-        ty::ty_bare_fn(ref fn_ty) => {\n+        ty::ty_bare_fn(_, ref fn_ty) => {\n             match ccx.sess().target.target.adjust_abi(fn_ty.abi) {\n                 Rust | RustCall => {\n-                    get_extern_rust_fn(ccx, t, name.as_slice(), did)\n+                    get_extern_rust_fn(ccx, t, name[], did)\n                 }\n                 RustIntrinsic => {\n                     ccx.sess().bug(\"unexpected intrinsic in trans_external_path\")\n                 }\n                 _ => {\n                     foreign::register_foreign_item_fn(ccx, fn_ty.abi, t,\n-                                                      name.as_slice())\n+                                                      name[])\n                 }\n             }\n         }\n         ty::ty_closure(_) => {\n-            get_extern_rust_fn(ccx, t, name.as_slice(), did)\n+            get_extern_rust_fn(ccx, t, name[], did)\n         }\n         _ => {\n             get_extern_const(ccx, did, t)\n@@ -1024,7 +1025,7 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n         let llresult = Invoke(bcx,\n                               llfn,\n-                              llargs.as_slice(),\n+                              llargs[],\n                               normal_bcx.llbb,\n                               landing_pad,\n                               Some(attributes));\n@@ -1040,7 +1041,7 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             None => debuginfo::clear_source_location(bcx.fcx)\n         };\n \n-        let llresult = Call(bcx, llfn, llargs.as_slice(), Some(attributes));\n+        let llresult = Call(bcx, llfn, llargs[], Some(attributes));\n         return (llresult, bcx);\n     }\n }\n@@ -1157,7 +1158,7 @@ pub fn call_lifetime_end(cx: Block, ptr: ValueRef) {\n pub fn call_memcpy(cx: Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n     let _icx = push_ctxt(\"call_memcpy\");\n     let ccx = cx.ccx();\n-    let key = match ccx.sess().target.target.target_word_size.as_slice() {\n+    let key = match ccx.sess().target.target.target_word_size[] {\n         \"32\" => \"llvm.memcpy.p0i8.p0i8.i32\",\n         \"64\" => \"llvm.memcpy.p0i8.p0i8.i64\",\n         tws => panic!(\"Unsupported target word size for memcpy: {}\", tws),\n@@ -1204,7 +1205,7 @@ fn memzero<'a, 'tcx>(b: &Builder<'a, 'tcx>, llptr: ValueRef, ty: Ty<'tcx>) {\n \n     let llty = type_of::type_of(ccx, ty);\n \n-    let intrinsic_key = match ccx.sess().target.target.target_word_size.as_slice() {\n+    let intrinsic_key = match ccx.sess().target.target.target_word_size[] {\n         \"32\" => \"llvm.memset.p0i8.i32\",\n         \"64\" => \"llvm.memset.p0i8.i64\",\n         tws => panic!(\"Unsupported target word size for memset: {}\", tws),\n@@ -1691,7 +1692,7 @@ fn copy_unboxed_closure_args_to_allocas<'blk, 'tcx>(\n                                                          \"argtuple\",\n                                                          arg_scope_id));\n     let untupled_arg_types = match monomorphized_arg_types[0].sty {\n-        ty::ty_tup(ref types) => types.as_slice(),\n+        ty::ty_tup(ref types) => types[],\n         _ => {\n             bcx.tcx().sess.span_bug(args[0].pat.span,\n                                     \"first arg to `rust-call` ABI function \\\n@@ -1879,29 +1880,29 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let arg_datums = if abi != RustCall {\n         create_datums_for_fn_args(&fcx,\n-                                  monomorphized_arg_types.as_slice())\n+                                  monomorphized_arg_types[])\n     } else {\n         create_datums_for_fn_args_under_call_abi(\n             bcx,\n             arg_scope,\n-            monomorphized_arg_types.as_slice())\n+            monomorphized_arg_types[])\n     };\n \n     bcx = match closure_env.kind {\n         closure::NotClosure | closure::BoxedClosure(..) => {\n             copy_args_to_allocas(&fcx,\n                                  arg_scope,\n                                  bcx,\n-                                 decl.inputs.as_slice(),\n+                                 decl.inputs[],\n                                  arg_datums)\n         }\n         closure::UnboxedClosure(..) => {\n             copy_unboxed_closure_args_to_allocas(\n                 bcx,\n                 arg_scope,\n-                decl.inputs.as_slice(),\n+                decl.inputs[],\n                 arg_datums,\n-                monomorphized_arg_types.as_slice())\n+                monomorphized_arg_types[])\n         }\n     };\n \n@@ -2014,11 +2015,11 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let tcx = ccx.tcx();\n \n     let result_ty = match ctor_ty.sty {\n-        ty::ty_bare_fn(ref bft) => bft.sig.0.output.unwrap(),\n+        ty::ty_bare_fn(_, ref bft) => bft.sig.0.output.unwrap(),\n         _ => ccx.sess().bug(\n             format!(\"trans_enum_variant_constructor: \\\n                      unexpected ctor return type {}\",\n-                     ctor_ty.repr(tcx)).as_slice())\n+                     ctor_ty.repr(tcx))[])\n     };\n \n     // Get location to store the result. If the user does not care about\n@@ -2041,7 +2042,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 bcx = expr::trans_adt(bcx,\n                                       result_ty,\n                                       disr,\n-                                      fields.as_slice(),\n+                                      fields[],\n                                       None,\n                                       expr::SaveIn(llresult),\n                                       call_info);\n@@ -2086,11 +2087,11 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n     let ctor_ty = ctor_ty.subst(ccx.tcx(), param_substs);\n \n     let result_ty = match ctor_ty.sty {\n-        ty::ty_bare_fn(ref bft) => bft.sig.0.output,\n+        ty::ty_bare_fn(_, ref bft) => bft.sig.0.output,\n         _ => ccx.sess().bug(\n             format!(\"trans_enum_variant_or_tuple_like_struct: \\\n                      unexpected ctor return type {}\",\n-                    ty_to_string(ccx.tcx(), ctor_ty)).as_slice())\n+                    ty_to_string(ccx.tcx(), ctor_ty))[])\n     };\n \n     let arena = TypedArena::new();\n@@ -2102,7 +2103,7 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n \n     let arg_tys = ty::ty_fn_args(ctor_ty);\n \n-    let arg_datums = create_datums_for_fn_args(&fcx, arg_tys.as_slice());\n+    let arg_datums = create_datums_for_fn_args(&fcx, arg_tys[]);\n \n     if !type_is_zero_size(fcx.ccx, result_ty.unwrap()) {\n         let dest = fcx.get_ret_slot(bcx, result_ty, \"eret_slot\");\n@@ -2166,7 +2167,7 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span,\n                             lvlsrc, Some(sp),\n                             format!(\"enum variant is more than three times larger \\\n                                      ({} bytes) than the next largest (ignoring padding)\",\n-                                    largest).as_slice());\n+                                    largest)[]);\n \n         ccx.sess().span_note(enum_def.variants[largest_index].span,\n                              \"this variant is the largest\");\n@@ -2284,7 +2285,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n     match item.node {\n       ast::ItemFn(ref decl, _fn_style, abi, ref generics, ref body) => {\n         if !generics.is_type_parameterized() {\n-            let trans_everywhere = attr::requests_inline(item.attrs.as_slice());\n+            let trans_everywhere = attr::requests_inline(item.attrs[]);\n             // Ignore `trans_everywhere` for cross-crate inlined items\n             // (`from_external`).  `trans_item` will be called once for each\n             // compilation unit that references the item, so it will still get\n@@ -2295,7 +2296,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                     foreign::trans_rust_fn_with_foreign_abi(ccx,\n                                                             &**decl,\n                                                             &**body,\n-                                                            item.attrs.as_slice(),\n+                                                            item.attrs[],\n                                                             llfn,\n                                                             &Substs::trans_empty(),\n                                                             item.id,\n@@ -2307,7 +2308,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                              llfn,\n                              &Substs::trans_empty(),\n                              item.id,\n-                             item.attrs.as_slice());\n+                             item.attrs[]);\n                 }\n                 update_linkage(ccx,\n                                llfn,\n@@ -2324,7 +2325,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n       ast::ItemImpl(_, ref generics, _, _, ref impl_items) => {\n         meth::trans_impl(ccx,\n                          item.ident,\n-                         impl_items.as_slice(),\n+                         impl_items[],\n                          generics,\n                          item.id);\n       }\n@@ -2350,7 +2351,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n \n           // Do static_assert checking. It can't really be done much earlier\n           // because we need to get the value of the bool out of LLVM\n-          if attr::contains_name(item.attrs.as_slice(), \"static_assert\") {\n+          if attr::contains_name(item.attrs[], \"static_assert\") {\n               if m == ast::MutMutable {\n                   ccx.sess().span_fatal(expr.span,\n                                         \"cannot have static_assert on a mutable \\\n@@ -2421,13 +2422,13 @@ fn register_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                          node_type: Ty<'tcx>)\n                          -> ValueRef {\n     match node_type.sty {\n-        ty::ty_bare_fn(ref f) => {\n+        ty::ty_bare_fn(_, ref f) => {\n             assert!(f.abi == Rust || f.abi == RustCall);\n         }\n         _ => panic!(\"expected bare rust fn\")\n     };\n \n-    let llfn = decl_rust_fn(ccx, node_type, sym.as_slice());\n+    let llfn = decl_rust_fn(ccx, node_type, sym[]);\n     finish_register_fn(ccx, sp, sym, node_id, llfn);\n     llfn\n }\n@@ -2438,7 +2439,7 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n \n     let (fn_sig, abi, has_env) = match fn_ty.sty {\n         ty::ty_closure(ref f) => (f.sig.clone(), f.abi, true),\n-        ty::ty_bare_fn(ref f) => (f.sig.clone(), f.abi, false),\n+        ty::ty_bare_fn(_, ref f) => (f.sig.clone(), f.abi, false),\n         ty::ty_unboxed_closure(closure_did, _, ref substs) => {\n             let unboxed_closures = ccx.tcx().unboxed_closures.borrow();\n             let ref function_type = (*unboxed_closures)[closure_did]\n@@ -2467,12 +2468,12 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n                 _ => ccx.sess().bug(\"expected tuple'd inputs\")\n             }\n         },\n-        ty::ty_bare_fn(_) if abi == RustCall => {\n+        ty::ty_bare_fn(..) if abi == RustCall => {\n             let mut inputs = vec![fn_sig.0.inputs[0]];\n \n             match fn_sig.0.inputs[1].sty {\n                 ty::ty_tup(ref t_in) => {\n-                    inputs.push_all(t_in.as_slice());\n+                    inputs.push_all(t_in[]);\n                     inputs\n                 }\n                 _ => ccx.sess().bug(\"expected tuple'd inputs\")\n@@ -2607,7 +2608,7 @@ pub fn register_fn_llvmty(ccx: &CrateContext,\n                           llfty: Type) -> ValueRef {\n     debug!(\"register_fn_llvmty id={} sym={}\", node_id, sym);\n \n-    let llfn = decl_fn(ccx, sym.as_slice(), cc, llfty, ty::FnConverging(ty::mk_nil(ccx.tcx())));\n+    let llfn = decl_fn(ccx, sym[], cc, llfty, ty::FnConverging(ty::mk_nil(ccx.tcx())));\n     finish_register_fn(ccx, sp, sym, node_id, llfn);\n     llfn\n }\n@@ -2659,7 +2660,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n             let (start_fn, args) = if use_start_lang_item {\n                 let start_def_id = match ccx.tcx().lang_items.require(StartFnLangItem) {\n                     Ok(id) => id,\n-                    Err(s) => { ccx.sess().fatal(s.as_slice()); }\n+                    Err(s) => { ccx.sess().fatal(s[]); }\n                 };\n                 let start_fn = if start_def_id.krate == ast::LOCAL_CRATE {\n                     get_item_val(ccx, start_def_id.node)\n@@ -2750,7 +2751,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n     let val = match item {\n         ast_map::NodeItem(i) => {\n             let ty = ty::node_id_to_type(ccx.tcx(), i.id);\n-            let sym = || exported_name(ccx, id, ty, i.attrs.as_slice());\n+            let sym = || exported_name(ccx, id, ty, i.attrs[]);\n \n             let v = match i.node {\n                 ast::ItemStatic(_, _, ref expr) => {\n@@ -2773,16 +2774,16 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                         } else {\n                             llvm::LLVMTypeOf(v)\n                         };\n-                        if contains_null(sym.as_slice()) {\n+                        if contains_null(sym[]) {\n                             ccx.sess().fatal(\n                                 format!(\"Illegal null byte in export_name \\\n-                                         value: `{}`\", sym).as_slice());\n+                                         value: `{}`\", sym)[]);\n                         }\n                         let g = sym.with_c_str(|buf| {\n                             llvm::LLVMAddGlobal(ccx.llmod(), llty, buf)\n                         });\n \n-                        if attr::contains_name(i.attrs.as_slice(),\n+                        if attr::contains_name(i.attrs[],\n                                                \"thread_local\") {\n                             llvm::set_thread_local(g, true);\n                         }\n@@ -2807,19 +2808,19 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                                                                    sym,\n                                                                    i.id)\n                     };\n-                    set_llvm_fn_attrs(ccx, i.attrs.as_slice(), llfn);\n+                    set_llvm_fn_attrs(ccx, i.attrs[], llfn);\n                     llfn\n                 }\n \n                 _ => panic!(\"get_item_val: weird result in table\")\n             };\n \n-            match attr::first_attr_value_str_by_name(i.attrs.as_slice(),\n+            match attr::first_attr_value_str_by_name(i.attrs[],\n                                                      \"link_section\") {\n                 Some(sect) => {\n                     if contains_null(sect.get()) {\n                         ccx.sess().fatal(format!(\"Illegal null byte in link_section value: `{}`\",\n-                                                 sect.get()).as_slice());\n+                                                 sect.get())[]);\n                     }\n                     unsafe {\n                         sect.get().with_c_str(|buf| {\n@@ -2863,7 +2864,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     let abi = ccx.tcx().map.get_foreign_abi(id);\n                     let ty = ty::node_id_to_type(ccx.tcx(), ni.id);\n                     let name = foreign::link_name(&*ni);\n-                    foreign::register_foreign_item_fn(ccx, abi, ty, name.get().as_slice())\n+                    foreign::register_foreign_item_fn(ccx, abi, ty, name.get()[])\n                 }\n                 ast::ForeignItemStatic(..) => {\n                     foreign::register_static(ccx, &*ni)\n@@ -2886,7 +2887,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             let sym = exported_name(ccx,\n                                     id,\n                                     ty,\n-                                    enm.attrs.as_slice());\n+                                    enm.attrs[]);\n \n             llfn = match enm.node {\n                 ast::ItemEnum(_, _) => {\n@@ -2914,7 +2915,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                                     id,\n                                     ty,\n                                     struct_item.attrs\n-                                               .as_slice());\n+                                               []);\n             let llfn = register_fn(ccx, struct_item.span,\n                                    sym, ctor_id, ty);\n             set_inline_hint(llfn);\n@@ -2923,7 +2924,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n \n         ref variant => {\n             ccx.sess().bug(format!(\"get_item_val(): unexpected variant: {}\",\n-                                   variant).as_slice())\n+                                   variant)[])\n         }\n     };\n \n@@ -2944,10 +2945,10 @@ fn register_method(ccx: &CrateContext, id: ast::NodeId,\n                    m: &ast::Method) -> ValueRef {\n     let mty = ty::node_id_to_type(ccx.tcx(), id);\n \n-    let sym = exported_name(ccx, id, mty, m.attrs.as_slice());\n+    let sym = exported_name(ccx, id, mty, m.attrs[]);\n \n     let llfn = register_fn(ccx, m.span, sym, id, mty);\n-    set_llvm_fn_attrs(ccx, m.attrs.as_slice(), llfn);\n+    set_llvm_fn_attrs(ccx, m.attrs[], llfn);\n     llfn\n }\n \n@@ -2986,7 +2987,7 @@ pub fn write_metadata(cx: &SharedCrateContext, krate: &ast::Crate) -> Vec<u8> {\n         Some(compressed) => compressed,\n         None => cx.sess().fatal(\"failed to compress metadata\"),\n     }.as_slice());\n-    let llmeta = C_bytes_in_context(cx.metadata_llcx(), compressed.as_slice());\n+    let llmeta = C_bytes_in_context(cx.metadata_llcx(), compressed[]);\n     let llconst = C_struct_in_context(cx.metadata_llcx(), &[llmeta], false);\n     let name = format!(\"rust_metadata_{}_{}\",\n                        cx.link_meta().crate_name,\n@@ -3114,7 +3115,7 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n     let link_meta = link::build_link_meta(&tcx.sess, krate, name);\n \n     let codegen_units = tcx.sess.opts.cg.codegen_units;\n-    let shared_ccx = SharedCrateContext::new(link_meta.crate_name.as_slice(),\n+    let shared_ccx = SharedCrateContext::new(link_meta.crate_name[],\n                                              codegen_units,\n                                              tcx,\n                                              export_map,\n@@ -3216,7 +3217,7 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n         llmod: shared_ccx.metadata_llmod(),\n     };\n     let formats = shared_ccx.tcx().dependency_formats.borrow().clone();\n-    let no_builtins = attr::contains_name(krate.attrs.as_slice(), \"no_builtins\");\n+    let no_builtins = attr::contains_name(krate.attrs[], \"no_builtins\");\n \n     let translation = CrateTranslation {\n         modules: modules,"}, {"sha": "ab25343ff5fe0c46e4832c70fe7cf641eb11ba3f", "filename": "src/librustc_trans/trans/basic_block.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fbasic_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fbasic_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbasic_block.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -37,7 +37,10 @@ impl BasicBlock {\n \n     pub fn pred_iter(self) -> Preds {\n         fn is_a_terminator_inst(user: &Value) -> bool { user.is_a_terminator_inst() }\n+        let is_a_terminator_inst: fn(&Value) -> bool = is_a_terminator_inst;\n+\n         fn get_parent(user: Value) -> BasicBlock { user.get_parent().unwrap() }\n+        let get_parent: fn(Value) -> BasicBlock = get_parent;\n \n         self.as_value().user_iter()\n             .filter(is_a_terminator_inst)"}, {"sha": "1b9c9d221b909b0f5a28ea8b731d5f8b6bfde7ee", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -555,7 +555,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         } else {\n             let v = ixs.iter().map(|i| C_i32(self.ccx, *i as i32)).collect::<Vec<ValueRef>>();\n             self.count_insn(\"gepi\");\n-            self.inbounds_gep(base, v.as_slice())\n+            self.inbounds_gep(base, v[])\n         }\n     }\n \n@@ -763,8 +763,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let s = format!(\"{} ({})\",\n                             text,\n                             self.ccx.sess().codemap().span_to_string(sp));\n-            debug!(\"{}\", s.as_slice());\n-            self.add_comment(s.as_slice());\n+            debug!(\"{}\", s[]);\n+            self.add_comment(s[]);\n         }\n     }\n \n@@ -801,7 +801,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }).collect::<Vec<_>>();\n \n         debug!(\"Asm Output Type: {}\", self.ccx.tn().type_to_string(output));\n-        let fty = Type::func(argtys.as_slice(), &output);\n+        let fty = Type::func(argtys[], &output);\n         unsafe {\n             let v = llvm::LLVMInlineAsm(\n                 fty.to_ref(), asm, cons, volatile, alignstack, dia as c_uint);"}, {"sha": "9ea158fbe2101c70a74b14665daa55898887022e", "filename": "src/librustc_trans/trans/cabi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -107,7 +107,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n                         ret_def: bool) -> FnType {\n-    match ccx.sess().target.target.arch.as_slice() {\n+    match ccx.sess().target.target.arch[] {\n         \"x86\" => cabi_x86::compute_abi_info(ccx, atys, rty, ret_def),\n         \"x86_64\" => if ccx.sess().target.target.options.is_like_windows {\n             cabi_x86_win64::compute_abi_info(ccx, atys, rty, ret_def)\n@@ -117,6 +117,6 @@ pub fn compute_abi_info(ccx: &CrateContext,\n         \"arm\" => cabi_arm::compute_abi_info(ccx, atys, rty, ret_def),\n         \"mips\" => cabi_mips::compute_abi_info(ccx, atys, rty, ret_def),\n         a => ccx.sess().fatal((format!(\"unrecognized arch \\\"{}\\\" in target specification\", a))\n-                              .as_slice()),\n+                              []),\n     }\n }"}, {"sha": "7f22faf050da04e98350e2e12fc98226c048d7da", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -21,7 +21,8 @@ pub use self::CallArgs::*;\n use arena::TypedArena;\n use back::{abi,link};\n use session;\n-use llvm::{ValueRef, get_param};\n+use llvm::{ValueRef};\n+use llvm::get_param;\n use llvm;\n use metadata::csearch;\n use middle::def;\n@@ -122,7 +123,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                     expr.span,\n                     format!(\"type of callee is neither bare-fn nor closure: \\\n                              {}\",\n-                            bcx.ty_to_string(datum.ty)).as_slice());\n+                            bcx.ty_to_string(datum.ty))[]);\n             }\n         }\n     }\n@@ -158,7 +159,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                 }\n             }\n             def::DefFn(did, _) if match expr_ty.sty {\n-                ty::ty_bare_fn(ref f) => f.abi == synabi::RustIntrinsic,\n+                ty::ty_bare_fn(_, ref f) => f.abi == synabi::RustIntrinsic,\n                 _ => false\n             } => {\n                 let substs = node_id_substs(bcx, ExprId(ref_expr.id));\n@@ -208,7 +209,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                 bcx.tcx().sess.span_bug(\n                     ref_expr.span,\n                     format!(\"cannot translate def {} \\\n-                             to a callable thing!\", def).as_slice());\n+                             to a callable thing!\", def)[]);\n             }\n         }\n     }\n@@ -275,24 +276,26 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n \n     // Construct the \"tuply\" version of `bare_fn_ty`. It takes two arguments: `self`,\n     // which is the fn pointer, and `args`, which is the arguments tuple.\n-    let (input_tys, output_ty) =\n+    let (opt_def_id, input_tys, output_ty) =\n         match bare_fn_ty.sty {\n-            ty::ty_bare_fn(ty::BareFnTy { unsafety: ast::Unsafety::Normal,\n+            ty::ty_bare_fn(opt_def_id,\n+                           ty::BareFnTy { unsafety: ast::Unsafety::Normal,\n                                           abi: synabi::Rust,\n                                           sig: ty::Binder(ty::FnSig { inputs: ref input_tys,\n                                                                       output: output_ty,\n                                                                       variadic: false })}) =>\n             {\n-                (input_tys, output_ty)\n+                (opt_def_id, input_tys, output_ty)\n             }\n \n             _ => {\n                 tcx.sess.bug(format!(\"trans_fn_pointer_shim invoked on invalid type: {}\",\n-                                           bare_fn_ty.repr(tcx)).as_slice());\n+                                           bare_fn_ty.repr(tcx))[]);\n             }\n         };\n     let tuple_input_ty = ty::mk_tup(tcx, input_tys.to_vec());\n     let tuple_fn_ty = ty::mk_bare_fn(tcx,\n+                                     opt_def_id,\n                                      ty::BareFnTy { unsafety: ast::Unsafety::Normal,\n                                                     abi: synabi::RustCall,\n                                                     sig: ty::Binder(ty::FnSig {\n@@ -310,7 +313,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     let llfn =\n         decl_internal_rust_fn(ccx,\n                               tuple_fn_ty,\n-                              function_name.as_slice());\n+                              function_name[]);\n \n     //\n     let block_arena = TypedArena::new();\n@@ -345,7 +348,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n                            None,\n                            bare_fn_ty,\n                            |bcx, _| Callee { bcx: bcx, data: Fn(llfnpointer) },\n-                           ArgVals(llargs.as_slice()),\n+                           ArgVals(llargs[]),\n                            dest).bcx;\n \n     finish_fn(&fcx, bcx, output_ty);\n@@ -655,7 +658,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     let mut bcx = callee.bcx;\n \n     let (abi, ret_ty) = match callee_ty.sty {\n-        ty::ty_bare_fn(ref f) => (f.abi, f.sig.0.output),\n+        ty::ty_bare_fn(_, ref f) => (f.abi, f.sig.0.output),\n         ty::ty_closure(ref f) => (f.abi, f.sig.0.output),\n         _ => panic!(\"expected bare rust fn or closure in trans_call_inner\")\n     };\n@@ -813,7 +816,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n         bcx = foreign::trans_native_call(bcx, callee_ty,\n                                          llfn, opt_llretslot.unwrap(),\n-                                         llargs.as_slice(), arg_tys);\n+                                         llargs[], arg_tys);\n     }\n \n     fcx.pop_and_trans_custom_cleanup_scope(bcx, arg_cleanup_scope);"}, {"sha": "c1bb21c496adfe97ecc2ce9cdce16fe9ea541b24", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -404,7 +404,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n \n         self.ccx.sess().bug(\n             format!(\"no cleanup scope {} found\",\n-                    self.ccx.tcx().map.node_to_string(cleanup_scope)).as_slice());\n+                    self.ccx.tcx().map.node_to_string(cleanup_scope))[]);\n     }\n \n     /// Schedules a cleanup to occur in the top-most scope, which must be a temporary scope.\n@@ -586,7 +586,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                     LoopExit(id, _) => {\n                         self.ccx.sess().bug(format!(\n                                 \"cannot exit from scope {}, \\\n-                                not in scope\", id).as_slice());\n+                                not in scope\", id)[]);\n                     }\n                 }\n             }\n@@ -655,7 +655,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                 let name = scope.block_name(\"clean\");\n                 debug!(\"generating cleanups for {}\", name);\n                 let bcx_in = self.new_block(label.is_unwind(),\n-                                            name.as_slice(),\n+                                            name[],\n                                             None);\n                 let mut bcx_out = bcx_in;\n                 for cleanup in scope.cleanups.iter().rev() {\n@@ -702,7 +702,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                 Some(llbb) => { return llbb; }\n                 None => {\n                     let name = last_scope.block_name(\"unwind\");\n-                    pad_bcx = self.new_block(true, name.as_slice(), None);\n+                    pad_bcx = self.new_block(true, name[], None);\n                     last_scope.cached_landing_pad = Some(pad_bcx.llbb);\n                 }\n             }\n@@ -1020,7 +1020,7 @@ pub fn temporary_scope(tcx: &ty::ctxt,\n         }\n         None => {\n             tcx.sess.bug(format!(\"no temporary scope available for expr {}\",\n-                                 id).as_slice())\n+                                 id)[])\n         }\n     }\n }"}, {"sha": "0ae9de8c89183b83d993deac8baa830ddec2f597", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 13, "deletions": 25, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -13,7 +13,6 @@ pub use self::ClosureKind::*;\n use back::abi;\n use back::link::mangle_internal_name_by_path_and_seq;\n use llvm::ValueRef;\n-use middle::def;\n use middle::mem_categorization::Typer;\n use trans::adt;\n use trans::base::*;\n@@ -177,7 +176,7 @@ pub fn store_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let tcx = ccx.tcx();\n \n     // compute the type of the closure\n-    let cdata_ty = mk_closure_tys(tcx, bound_values.as_slice());\n+    let cdata_ty = mk_closure_tys(tcx, bound_values[]);\n \n     // cbox_ty has the form of a tuple: (a, b, c) we want a ptr to a\n     // tuple.  This could be a ptr in uniq or a box or on stack,\n@@ -206,7 +205,7 @@ pub fn store_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n         if ccx.sess().asm_comments() {\n             add_comment(bcx, format!(\"Copy {} into closure\",\n-                                     bv.to_string(ccx)).as_slice());\n+                                     bv.to_string(ccx))[]);\n         }\n \n         let bound_data = GEPi(bcx, llbox, &[0u, abi::BOX_FIELD_BODY, i]);\n@@ -444,7 +443,7 @@ pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let s = tcx.map.with_path(id, |path| {\n         mangle_internal_name_by_path_and_seq(path, \"closure\")\n     });\n-    let llfn = decl_internal_rust_fn(ccx, fty, s.as_slice());\n+    let llfn = decl_internal_rust_fn(ccx, fty, s[]);\n \n     // set an inline hint for all closures\n     set_inline_hint(llfn);\n@@ -468,7 +467,7 @@ pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                   &[],\n                   ty::ty_fn_ret(fty),\n                   ty::ty_fn_abi(fty),\n-                  ClosureEnv::new(freevars.as_slice(),\n+                  ClosureEnv::new(freevars[],\n                                   BoxedClosure(cdata_ty, store)));\n     fill_fn_pair(bcx, dest_addr, llfn, llbox);\n     bcx\n@@ -514,7 +513,7 @@ pub fn get_or_create_declaration_if_unboxed_closure<'blk, 'tcx>(bcx: Block<'blk,\n         mangle_internal_name_by_path_and_seq(path, \"unboxed_closure\")\n     });\n \n-    let llfn = decl_internal_rust_fn(ccx, function_type, symbol.as_slice());\n+    let llfn = decl_internal_rust_fn(ccx, function_type, symbol[]);\n \n     // set an inline hint for all closures\n     set_inline_hint(llfn);\n@@ -563,7 +562,7 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n                   &[],\n                   ty::ty_fn_ret(function_type),\n                   ty::ty_fn_abi(function_type),\n-                  ClosureEnv::new(freevars.as_slice(),\n+                  ClosureEnv::new(freevars[],\n                                   UnboxedClosure(freevar_mode)));\n \n     // Don't hoist this to the top of the function. It's perfectly legitimate\n@@ -603,21 +602,10 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n \n pub fn get_wrapper_for_bare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                          closure_ty: Ty<'tcx>,\n-                                         def: def::Def,\n+                                         def_id: ast::DefId,\n                                          fn_ptr: ValueRef,\n                                          is_local: bool) -> ValueRef {\n \n-    let def_id = match def {\n-        def::DefFn(did, _) | def::DefStaticMethod(did, _) |\n-        def::DefVariant(_, did, _) | def::DefStruct(did) => did,\n-        _ => {\n-            ccx.sess().bug(format!(\"get_wrapper_for_bare_fn: \\\n-                                    expected a statically resolved fn, got \\\n-                                    {}\",\n-                                    def).as_slice());\n-        }\n-    };\n-\n     match ccx.closure_bare_wrapper_cache().borrow().get(&fn_ptr) {\n         Some(&llval) => return llval,\n         None => {}\n@@ -632,17 +620,17 @@ pub fn get_wrapper_for_bare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         _ => {\n             ccx.sess().bug(format!(\"get_wrapper_for_bare_fn: \\\n                                     expected a closure ty, got {}\",\n-                                    closure_ty.repr(tcx)).as_slice());\n+                                    closure_ty.repr(tcx))[]);\n         }\n     };\n \n     let name = ty::with_path(tcx, def_id, |path| {\n         mangle_internal_name_by_path_and_seq(path, \"as_closure\")\n     });\n     let llfn = if is_local {\n-        decl_internal_rust_fn(ccx, closure_ty, name.as_slice())\n+        decl_internal_rust_fn(ccx, closure_ty, name[])\n     } else {\n-        decl_rust_fn(ccx, closure_ty, name.as_slice())\n+        decl_rust_fn(ccx, closure_ty, name[])\n     };\n \n     ccx.closure_bare_wrapper_cache().borrow_mut().insert(fn_ptr, llfn);\n@@ -663,7 +651,7 @@ pub fn get_wrapper_for_bare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let args = create_datums_for_fn_args(&fcx,\n                                          ty::ty_fn_args(closure_ty)\n-                                            .as_slice());\n+                                            []);\n     let mut llargs = Vec::new();\n     match fcx.llretslotptr.get() {\n         Some(llretptr) => {\n@@ -697,11 +685,11 @@ pub fn get_wrapper_for_bare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n pub fn make_closure_from_bare_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                              closure_ty: Ty<'tcx>,\n-                                             def: def::Def,\n+                                             def_id: ast::DefId,\n                                              fn_ptr: ValueRef)\n                                              -> DatumBlock<'blk, 'tcx, Expr>  {\n     let scratch = rvalue_scratch_datum(bcx, closure_ty, \"__adjust\");\n-    let wrapper = get_wrapper_for_bare_fn(bcx.ccx(), closure_ty, def, fn_ptr, true);\n+    let wrapper = get_wrapper_for_bare_fn(bcx.ccx(), closure_ty, def_id, fn_ptr, true);\n     fill_fn_pair(bcx, scratch.val, wrapper, C_null(Type::i8p(bcx.ccx())));\n \n     DatumBlock::new(bcx, scratch.to_expr_datum())"}, {"sha": "9a3e39ff10b310772e004ca0d1065c14d6cfa2ff", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -117,7 +117,7 @@ pub fn gensym_name(name: &str) -> PathElem {\n     let num = token::gensym(name).uint();\n     // use one colon which will get translated to a period by the mangler, and\n     // we're guaranteed that `num` is globally unique for this crate.\n-    PathName(token::gensym(format!(\"{}:{}\", name, num).as_slice()))\n+    PathName(token::gensym(format!(\"{}:{}\", name, num)[]))\n }\n \n #[deriving(Copy)]\n@@ -436,7 +436,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n             Some(v) => v.clone(),\n             None => {\n                 self.tcx().sess.bug(format!(\n-                    \"no def associated with node id {}\", nid).as_slice());\n+                    \"no def associated with node id {}\", nid)[]);\n             }\n         }\n     }\n@@ -817,7 +817,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 span,\n                 format!(\"Encountered error `{}` selecting `{}` during trans\",\n                         e.repr(tcx),\n-                        trait_ref.repr(tcx)).as_slice())\n+                        trait_ref.repr(tcx))[])\n         }\n     };\n \n@@ -844,7 +844,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     span,\n                     format!(\"Encountered errors `{}` fulfilling `{}` during trans\",\n                             errors.repr(tcx),\n-                            trait_ref.repr(tcx)).as_slice());\n+                            trait_ref.repr(tcx))[]);\n             }\n         }\n     }\n@@ -892,7 +892,7 @@ pub fn node_id_substs<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             format!(\"type parameters for node {} include inference types: \\\n                      {}\",\n                     node,\n-                    substs.repr(bcx.tcx())).as_slice());\n+                    substs.repr(bcx.tcx()))[]);\n     }\n \n     let substs = substs.erase_regions();\n@@ -909,8 +909,8 @@ pub fn langcall(bcx: Block,\n         Err(s) => {\n             let msg = format!(\"{} {}\", msg, s);\n             match span {\n-                Some(span) => bcx.tcx().sess.span_fatal(span, msg.as_slice()),\n-                None => bcx.tcx().sess.fatal(msg.as_slice()),\n+                Some(span) => bcx.tcx().sess.span_fatal(span, msg[]),\n+                None => bcx.tcx().sess.fatal(msg[]),\n             }\n         }\n     }"}, {"sha": "bc386dc96a469230182c48529ba28b7307229158", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -54,7 +54,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n                 _ => cx.sess().span_bug(lit.span,\n                         format!(\"integer literal has type {} (expected int \\\n                                  or uint)\",\n-                                ty_to_string(cx.tcx(), lit_int_ty)).as_slice())\n+                                ty_to_string(cx.tcx(), lit_int_ty))[])\n             }\n         }\n         ast::LitFloat(ref fs, t) => {\n@@ -74,7 +74,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n         }\n         ast::LitBool(b) => C_bool(cx, b),\n         ast::LitStr(ref s, _) => C_str_slice(cx, (*s).clone()),\n-        ast::LitBinary(ref data) => C_binary_slice(cx, data.as_slice()),\n+        ast::LitBinary(ref data) => C_binary_slice(cx, data[]),\n     }\n }\n \n@@ -95,9 +95,9 @@ fn const_vec(cx: &CrateContext, e: &ast::Expr,\n                       .collect::<Vec<_>>();\n     // If the vector contains enums, an LLVM array won't work.\n     let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n-        C_struct(cx, vs.as_slice(), false)\n+        C_struct(cx, vs[], false)\n     } else {\n-        C_array(llunitty, vs.as_slice())\n+        C_array(llunitty, vs[])\n     };\n     (v, llunitty)\n }\n@@ -152,13 +152,13 @@ fn const_deref<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, v: ValueRef,\n                 }\n                 _ => {\n                     cx.sess().bug(format!(\"unexpected dereferenceable type {}\",\n-                                          ty_to_string(cx.tcx(), t)).as_slice())\n+                                          ty_to_string(cx.tcx(), t))[])\n                 }\n             }\n         }\n         None => {\n             cx.sess().bug(format!(\"cannot dereference const of type {}\",\n-                                  ty_to_string(cx.tcx(), t)).as_slice())\n+                                  ty_to_string(cx.tcx(), t))[])\n         }\n     }\n }\n@@ -190,20 +190,23 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, e: &ast::Expr)\n         None => { }\n         Some(adj) => {\n             match adj {\n-                ty::AdjustAddEnv(ty::RegionTraitStore(ty::ReStatic, _)) => {\n-                    let def = ty::resolve_expr(cx.tcx(), e);\n+                ty::AdjustAddEnv(def_id, ty::RegionTraitStore(ty::ReStatic, _)) => {\n                     let wrapper = closure::get_wrapper_for_bare_fn(cx,\n                                                                    ety_adjusted,\n-                                                                   def,\n+                                                                   def_id,\n                                                                    llconst,\n                                                                    true);\n                     llconst = C_struct(cx, &[wrapper, C_null(Type::i8p(cx))], false)\n                 }\n-                ty::AdjustAddEnv(store) => {\n+                ty::AdjustAddEnv(_, store) => {\n                     cx.sess()\n                       .span_bug(e.span,\n                                 format!(\"unexpected static function: {}\",\n-                                        store).as_slice())\n+                                        store)[])\n+                }\n+                ty::AdjustReifyFnPointer(_def_id) => {\n+                    // FIXME(#19925) once fn item types are\n+                    // zero-sized, we'll need to do something here\n                 }\n                 ty::AdjustDerefRef(ref adj) => {\n                     let mut ty = ety;\n@@ -264,15 +267,15 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, e: &ast::Expr)\n                                         }\n                                         _ => cx.sess().span_bug(e.span,\n                                             format!(\"unimplemented type in const unsize: {}\",\n-                                                    ty_to_string(cx.tcx(), ty)).as_slice())\n+                                                    ty_to_string(cx.tcx(), ty))[])\n                                     }\n                                 }\n                                 _ => {\n                                     cx.sess()\n                                       .span_bug(e.span,\n                                                 format!(\"unimplemented const \\\n                                                          autoref {}\",\n-                                                        autoref).as_slice())\n+                                                        autoref)[])\n                                 }\n                             }\n                         }\n@@ -293,7 +296,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, e: &ast::Expr)\n         }\n         cx.sess().bug(format!(\"const {} of type {} has size {} instead of {}\",\n                          e.repr(cx.tcx()), ty_to_string(cx.tcx(), ety),\n-                         csize, tsize).as_slice());\n+                         csize, tsize)[]);\n     }\n     (llconst, ety_adjusted)\n }\n@@ -443,7 +446,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                       _ => cx.sess().span_bug(base.span,\n                                               format!(\"index-expr base must be a vector \\\n                                                        or string type, found {}\",\n-                                                      ty_to_string(cx.tcx(), bt)).as_slice())\n+                                                      ty_to_string(cx.tcx(), bt))[])\n                   },\n                   ty::ty_rptr(_, mt) => match mt.ty.sty {\n                       ty::ty_vec(_, Some(u)) => {\n@@ -452,12 +455,12 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                       _ => cx.sess().span_bug(base.span,\n                                               format!(\"index-expr base must be a vector \\\n                                                        or string type, found {}\",\n-                                                      ty_to_string(cx.tcx(), bt)).as_slice())\n+                                                      ty_to_string(cx.tcx(), bt))[])\n                   },\n                   _ => cx.sess().span_bug(base.span,\n                                           format!(\"index-expr base must be a vector \\\n                                                    or string type, found {}\",\n-                                                  ty_to_string(cx.tcx(), bt)).as_slice())\n+                                                  ty_to_string(cx.tcx(), bt))[])\n               };\n \n               let len = llvm::LLVMConstIntGetZExtValue(len) as u64;\n@@ -558,8 +561,8 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n           ast::ExprTup(ref es) => {\n               let ety = ty::expr_ty(cx.tcx(), e);\n               let repr = adt::represent_type(cx, ety);\n-              let vals = map_list(es.as_slice());\n-              adt::trans_const(cx, &*repr, 0, vals.as_slice())\n+              let vals = map_list(es[]);\n+              adt::trans_const(cx, &*repr, 0, vals[])\n           }\n           ast::ExprStruct(_, ref fs, ref base_opt) => {\n               let ety = ty::expr_ty(cx.tcx(), e);\n@@ -590,7 +593,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                           }\n                       }\n                   }).collect::<Vec<_>>();\n-                  adt::trans_const(cx, &*repr, discr, cs.as_slice())\n+                  adt::trans_const(cx, &*repr, discr, cs[])\n               })\n           }\n           ast::ExprVec(ref es) => {\n@@ -607,9 +610,9 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n             };\n             let vs = Vec::from_elem(n, const_expr(cx, &**elem).0);\n             if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n-                C_struct(cx, vs.as_slice(), false)\n+                C_struct(cx, vs[], false)\n             } else {\n-                C_array(llunitty, vs.as_slice())\n+                C_array(llunitty, vs[])\n             }\n           }\n           ast::ExprPath(ref pth) => {\n@@ -655,20 +658,20 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                   Some(def::DefStruct(_)) => {\n                       let ety = ty::expr_ty(cx.tcx(), e);\n                       let repr = adt::represent_type(cx, ety);\n-                      let arg_vals = map_list(args.as_slice());\n-                      adt::trans_const(cx, &*repr, 0, arg_vals.as_slice())\n+                      let arg_vals = map_list(args[]);\n+                      adt::trans_const(cx, &*repr, 0, arg_vals[])\n                   }\n                   Some(def::DefVariant(enum_did, variant_did, _)) => {\n                       let ety = ty::expr_ty(cx.tcx(), e);\n                       let repr = adt::represent_type(cx, ety);\n                       let vinfo = ty::enum_variant_with_id(cx.tcx(),\n                                                            enum_did,\n                                                            variant_did);\n-                      let arg_vals = map_list(args.as_slice());\n+                      let arg_vals = map_list(args[]);\n                       adt::trans_const(cx,\n                                        &*repr,\n                                        vinfo.disr_val,\n-                                       arg_vals.as_slice())\n+                                       arg_vals[])\n                   }\n                   _ => cx.sess().span_bug(e.span, \"expected a struct or variant def\")\n               }"}, {"sha": "2c71dd831fbcb8f44a937e6622e3a91cfa206011", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -284,7 +284,7 @@ impl<'tcx> SharedCrateContext<'tcx> {\n             // such as a function name in the module.\n             // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n             let llmod_id = format!(\"{}.{}.rs\", crate_name, i);\n-            let local_ccx = LocalCrateContext::new(&shared_ccx, llmod_id.as_slice());\n+            let local_ccx = LocalCrateContext::new(&shared_ccx, llmod_id[]);\n             shared_ccx.local_ccxs.push(local_ccx);\n         }\n \n@@ -374,7 +374,7 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                                           .target\n                                           .target\n                                           .data_layout\n-                                          .as_slice());\n+                                          []);\n \n             let dbg_cx = if shared.tcx.sess.opts.debuginfo != NoDebugInfo {\n                 Some(debuginfo::CrateDebugContext::new(llmod))\n@@ -726,7 +726,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     pub fn report_overbig_object(&self, obj: Ty<'tcx>) -> ! {\n         self.sess().fatal(\n             format!(\"the type `{}` is too big for the current architecture\",\n-                    obj.repr(self.tcx())).as_slice())\n+                    obj.repr(self.tcx()))[])\n     }\n }\n "}, {"sha": "b19faf4df1fcdd6d8b732ece9f31762c5046e5ad", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -48,7 +48,7 @@ pub fn trans_stmt<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     debug!(\"trans_stmt({})\", s.repr(cx.tcx()));\n \n     if cx.sess().asm_comments() {\n-        add_span_comment(cx, s.span, s.repr(cx.tcx()).as_slice());\n+        add_span_comment(cx, s.span, s.repr(cx.tcx())[]);\n     }\n \n     let mut bcx = cx;\n@@ -188,7 +188,7 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n \n     let name = format!(\"then-block-{}-\", thn.id);\n-    let then_bcx_in = bcx.fcx.new_id_block(name.as_slice(), thn.id);\n+    let then_bcx_in = bcx.fcx.new_id_block(name[], thn.id);\n     let then_bcx_out = trans_block(then_bcx_in, &*thn, dest);\n     trans::debuginfo::clear_source_location(bcx.fcx);\n \n@@ -434,7 +434,7 @@ pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 Some(&def::DefLabel(loop_id)) => loop_id,\n                 ref r => {\n                     bcx.tcx().sess.bug(format!(\"{} in def-map for label\",\n-                                               r).as_slice())\n+                                               r)[])\n                 }\n             }\n         }\n@@ -498,7 +498,7 @@ pub fn trans_fail<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let v_str = C_str_slice(ccx, fail_str);\n     let loc = bcx.sess().codemap().lookup_char_pos(sp.lo);\n-    let filename = token::intern_and_get_ident(loc.file.name.as_slice());\n+    let filename = token::intern_and_get_ident(loc.file.name[]);\n     let filename = C_str_slice(ccx, filename);\n     let line = C_uint(ccx, loc.line);\n     let expr_file_line_const = C_struct(ccx, &[v_str, filename, line], false);\n@@ -507,7 +507,7 @@ pub fn trans_fail<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let did = langcall(bcx, Some(sp), \"\", PanicFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,\n                                       did,\n-                                      args.as_slice(),\n+                                      args[],\n                                       Some(expr::Ignore)).bcx;\n     Unreachable(bcx);\n     return bcx;\n@@ -523,7 +523,7 @@ pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Extract the file/line from the span\n     let loc = bcx.sess().codemap().lookup_char_pos(sp.lo);\n-    let filename = token::intern_and_get_ident(loc.file.name.as_slice());\n+    let filename = token::intern_and_get_ident(loc.file.name[]);\n \n     // Invoke the lang item\n     let filename = C_str_slice(ccx,  filename);\n@@ -534,7 +534,7 @@ pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let did = langcall(bcx, Some(sp), \"\", PanicBoundsCheckFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,\n                                       did,\n-                                      args.as_slice(),\n+                                      args[],\n                                       Some(expr::Ignore)).bcx;\n     Unreachable(bcx);\n     return bcx;"}, {"sha": "9ab4e92b51131af4fe028edf4952cccecee848e8", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -463,7 +463,7 @@ impl<'tcx> Datum<'tcx, Lvalue> {\n             }\n             _ => bcx.tcx().sess.bug(\n                 format!(\"Unexpected unsized type in get_element: {}\",\n-                        bcx.ty_to_string(self.ty)).as_slice())\n+                        bcx.ty_to_string(self.ty))[])\n         };\n         Datum {\n             val: val,"}, {"sha": "6226aace8a8a11a0cda3476c93bc72c64811f0b5", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 72, "deletions": 72, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -285,7 +285,7 @@ impl<'tcx> TypeMap<'tcx> {\n                                        metadata: DIType) {\n         if self.type_to_metadata.insert(type_, metadata).is_some() {\n             cx.sess().bug(format!(\"Type metadata for Ty '{}' is already in the TypeMap!\",\n-                                   ppaux::ty_to_string(cx.tcx(), type_)).as_slice());\n+                                   ppaux::ty_to_string(cx.tcx(), type_))[]);\n         }\n     }\n \n@@ -298,7 +298,7 @@ impl<'tcx> TypeMap<'tcx> {\n         if self.unique_id_to_metadata.insert(unique_type_id, metadata).is_some() {\n             let unique_type_id_str = self.get_unique_type_id_as_string(unique_type_id);\n             cx.sess().bug(format!(\"Type metadata for unique id '{}' is already in the TypeMap!\",\n-                                  unique_type_id_str.as_slice()).as_slice());\n+                                  unique_type_id_str[])[]);\n         }\n     }\n \n@@ -379,14 +379,14 @@ impl<'tcx> TypeMap<'tcx> {\n                         self.get_unique_type_id_of_type(cx, component_type);\n                     let component_type_id =\n                         self.get_unique_type_id_as_string(component_type_id);\n-                    unique_type_id.push_str(component_type_id.as_slice());\n+                    unique_type_id.push_str(component_type_id[]);\n                 }\n             },\n             ty::ty_uniq(inner_type) => {\n                 unique_type_id.push('~');\n                 let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(inner_type_id.as_slice());\n+                unique_type_id.push_str(inner_type_id[]);\n             },\n             ty::ty_ptr(ty::mt { ty: inner_type, mutbl } ) => {\n                 unique_type_id.push('*');\n@@ -396,7 +396,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n                 let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(inner_type_id.as_slice());\n+                unique_type_id.push_str(inner_type_id[]);\n             },\n             ty::ty_rptr(_, ty::mt { ty: inner_type, mutbl }) => {\n                 unique_type_id.push('&');\n@@ -406,12 +406,12 @@ impl<'tcx> TypeMap<'tcx> {\n \n                 let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(inner_type_id.as_slice());\n+                unique_type_id.push_str(inner_type_id[]);\n             },\n             ty::ty_vec(inner_type, optional_length) => {\n                 match optional_length {\n                     Some(len) => {\n-                        unique_type_id.push_str(format!(\"[{}]\", len).as_slice());\n+                        unique_type_id.push_str(format!(\"[{}]\", len)[]);\n                     }\n                     None => {\n                         unique_type_id.push_str(\"[]\");\n@@ -420,7 +420,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n                 let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(inner_type_id.as_slice());\n+                unique_type_id.push_str(inner_type_id[]);\n             },\n             ty::ty_trait(ref trait_data) => {\n                 unique_type_id.push_str(\"trait \");\n@@ -431,7 +431,7 @@ impl<'tcx> TypeMap<'tcx> {\n                                        trait_data.principal.substs(),\n                                        &mut unique_type_id);\n             },\n-            ty::ty_bare_fn(ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n+            ty::ty_bare_fn(_, ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n                 if unsafety == ast::Unsafety::Unsafe {\n                     unique_type_id.push_str(\"unsafe \");\n                 }\n@@ -445,7 +445,7 @@ impl<'tcx> TypeMap<'tcx> {\n                         self.get_unique_type_id_of_type(cx, parameter_type);\n                     let parameter_type_id =\n                         self.get_unique_type_id_as_string(parameter_type_id);\n-                    unique_type_id.push_str(parameter_type_id.as_slice());\n+                    unique_type_id.push_str(parameter_type_id[]);\n                     unique_type_id.push(',');\n                 }\n \n@@ -458,7 +458,7 @@ impl<'tcx> TypeMap<'tcx> {\n                     ty::FnConverging(ret_ty) => {\n                         let return_type_id = self.get_unique_type_id_of_type(cx, ret_ty);\n                         let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n-                        unique_type_id.push_str(return_type_id.as_slice());\n+                        unique_type_id.push_str(return_type_id[]);\n                     }\n                     ty::FnDiverging => {\n                         unique_type_id.push_str(\"!\");\n@@ -479,8 +479,8 @@ impl<'tcx> TypeMap<'tcx> {\n             },\n             _ => {\n                 cx.sess().bug(format!(\"get_unique_type_id_of_type() - unexpected type: {}, {}\",\n-                                      ppaux::ty_to_string(cx.tcx(), type_).as_slice(),\n-                                      type_.sty).as_slice())\n+                                      ppaux::ty_to_string(cx.tcx(), type_)[],\n+                                      type_.sty)[])\n             }\n         };\n \n@@ -523,7 +523,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n             output.push_str(crate_hash.as_str());\n             output.push_str(\"/\");\n-            output.push_str(format!(\"{:x}\", def_id.node).as_slice());\n+            output.push_str(format!(\"{:x}\", def_id.node)[]);\n \n             // Maybe check that there is no self type here.\n \n@@ -536,7 +536,7 @@ impl<'tcx> TypeMap<'tcx> {\n                         type_map.get_unique_type_id_of_type(cx, type_parameter);\n                     let param_type_id =\n                         type_map.get_unique_type_id_as_string(param_type_id);\n-                    output.push_str(param_type_id.as_slice());\n+                    output.push_str(param_type_id[]);\n                     output.push(',');\n                 }\n \n@@ -578,7 +578,7 @@ impl<'tcx> TypeMap<'tcx> {\n                 self.get_unique_type_id_of_type(cx, parameter_type);\n             let parameter_type_id =\n                 self.get_unique_type_id_as_string(parameter_type_id);\n-            unique_type_id.push_str(parameter_type_id.as_slice());\n+            unique_type_id.push_str(parameter_type_id[]);\n             unique_type_id.push(',');\n         }\n \n@@ -592,7 +592,7 @@ impl<'tcx> TypeMap<'tcx> {\n             ty::FnConverging(ret_ty) => {\n                 let return_type_id = self.get_unique_type_id_of_type(cx, ret_ty);\n                 let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n-                unique_type_id.push_str(return_type_id.as_slice());\n+                unique_type_id.push_str(return_type_id[]);\n             }\n             ty::FnDiverging => {\n                 unique_type_id.push_str(\"!\");\n@@ -623,7 +623,7 @@ impl<'tcx> TypeMap<'tcx> {\n         let enum_type_id = self.get_unique_type_id_of_type(cx, enum_type);\n         let enum_variant_type_id = format!(\"{}::{}\",\n                                            self.get_unique_type_id_as_string(enum_type_id)\n-                                               .as_slice(),\n+                                               [],\n                                            variant_name);\n         let interner_key = self.unique_id_interner.intern(Rc::new(enum_variant_type_id));\n         UniqueTypeId(interner_key)\n@@ -798,19 +798,19 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n                                          create_global_var_metadata() -\n                                          Captured var-id refers to \\\n                                          unexpected ast_item variant: {}\",\n-                                        var_item).as_slice())\n+                                        var_item)[])\n                 }\n             }\n         },\n         _ => cx.sess().bug(format!(\"debuginfo::create_global_var_metadata() \\\n                                     - Captured var-id refers to unexpected \\\n                                     ast_map variant: {}\",\n-                                   var_item).as_slice())\n+                                   var_item)[])\n     };\n \n     let (file_metadata, line_number) = if span != codemap::DUMMY_SP {\n         let loc = span_start(cx, span);\n-        (file_metadata(cx, loc.file.name.as_slice()), loc.line as c_uint)\n+        (file_metadata(cx, loc.file.name[]), loc.line as c_uint)\n     } else {\n         (UNKNOWN_FILE_METADATA, UNKNOWN_LINE_NUMBER)\n     };\n@@ -821,7 +821,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     let namespace_node = namespace_for_item(cx, ast_util::local_def(node_id));\n     let var_name = token::get_ident(ident).get().to_string();\n     let linkage_name =\n-        namespace_node.mangled_name_of_contained_item(var_name.as_slice());\n+        namespace_node.mangled_name_of_contained_item(var_name[]);\n     let var_scope = namespace_node.scope;\n \n     var_name.with_c_str(|var_name| {\n@@ -861,7 +861,7 @@ pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n             None => {\n                 bcx.sess().span_bug(span,\n                     format!(\"no entry in lllocals table for {}\",\n-                            node_id).as_slice());\n+                            node_id)[]);\n             }\n         };\n \n@@ -910,7 +910,7 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                 \"debuginfo::create_captured_var_metadata() - \\\n                                  Captured var-id refers to unexpected \\\n                                  ast_map variant: {}\",\n-                                 ast_item).as_slice());\n+                                 ast_item)[]);\n                 }\n             }\n         }\n@@ -920,7 +920,7 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                         format!(\"debuginfo::create_captured_var_metadata() - \\\n                                  Captured var-id refers to unexpected \\\n                                  ast_map variant: {}\",\n-                                ast_item).as_slice());\n+                                ast_item)[]);\n         }\n     };\n \n@@ -1023,7 +1023,7 @@ pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n             None => {\n                 bcx.sess().span_bug(span,\n                     format!(\"no entry in lllocals table for {}\",\n-                            node_id).as_slice());\n+                            node_id)[]);\n             }\n         };\n \n@@ -1239,7 +1239,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             match expr.node {\n                 ast::ExprClosure(_, _, ref fn_decl, ref top_level_block) => {\n                     let name = format!(\"fn{}\", token::gensym(\"fn\"));\n-                    let name = token::str_to_ident(name.as_slice());\n+                    let name = token::str_to_ident(name[]);\n                     (name, &**fn_decl,\n                         // This is not quite right. It should actually inherit\n                         // the generics of the enclosing function.\n@@ -1273,7 +1273,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     cx.sess()\n                       .bug(format!(\"create_function_debug_context: \\\n                                     unexpected sort of node: {}\",\n-                                    fnitem).as_slice())\n+                                    fnitem)[])\n                 }\n             }\n         }\n@@ -1284,7 +1284,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n         _ => cx.sess().bug(format!(\"create_function_debug_context: \\\n                                     unexpected sort of node: {}\",\n-                                   fnitem).as_slice())\n+                                   fnitem)[])\n     };\n \n     // This can be the case for functions inlined from another crate\n@@ -1293,7 +1293,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n \n     let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, loc.file.name.as_slice());\n+    let file_metadata = file_metadata(cx, loc.file.name[]);\n \n     let function_type_metadata = unsafe {\n         let fn_signature = get_function_signature(cx,\n@@ -1320,7 +1320,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let (linkage_name, containing_scope) = if has_path {\n         let namespace_node = namespace_for_item(cx, ast_util::local_def(fn_ast_id));\n         let linkage_name = namespace_node.mangled_name_of_contained_item(\n-            function_name.as_slice());\n+            function_name[]);\n         let containing_scope = namespace_node.scope;\n         (linkage_name, containing_scope)\n     } else {\n@@ -1405,7 +1405,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             signature.push(type_metadata(cx, arg_type, codemap::DUMMY_SP));\n         }\n \n-        return create_DIArray(DIB(cx), signature.as_slice());\n+        return create_DIArray(DIB(cx), signature[]);\n     }\n \n     fn get_template_parameters<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n@@ -1438,7 +1438,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 actual_self_type,\n                 true);\n \n-            name_to_append_suffix_to.push_str(actual_self_type_name.as_slice());\n+            name_to_append_suffix_to.push_str(actual_self_type_name[]);\n \n             if generics.is_type_parameterized() {\n                 name_to_append_suffix_to.push_str(\",\");\n@@ -1478,7 +1478,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let actual_type_name = compute_debuginfo_type_name(cx,\n                                                                actual_type,\n                                                                true);\n-            name_to_append_suffix_to.push_str(actual_type_name.as_slice());\n+            name_to_append_suffix_to.push_str(actual_type_name[]);\n \n             if index != generics.ty_params.len() - 1 {\n                 name_to_append_suffix_to.push_str(\",\");\n@@ -1506,7 +1506,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n         name_to_append_suffix_to.push('>');\n \n-        return create_DIArray(DIB(cx), template_params.as_slice());\n+        return create_DIArray(DIB(cx), template_params[]);\n     }\n }\n \n@@ -1604,7 +1604,7 @@ fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let cx: &CrateContext = bcx.ccx();\n \n     let filename = span_start(cx, span).file.name.clone();\n-    let file_metadata = file_metadata(cx, filename.as_slice());\n+    let file_metadata = file_metadata(cx, filename[]);\n \n     let name = token::get_ident(variable_ident);\n     let loc = span_start(cx, span);\n@@ -1691,7 +1691,7 @@ fn file_metadata(cx: &CrateContext, full_path: &str) -> DIFile {\n     let work_dir = cx.sess().working_dir.as_str().unwrap();\n     let file_name =\n         if full_path.starts_with(work_dir) {\n-            full_path.slice(work_dir.len() + 1u, full_path.len())\n+            full_path[work_dir.len() + 1u..full_path.len()]\n         } else {\n             full_path\n         };\n@@ -1725,7 +1725,7 @@ fn scope_metadata(fcx: &FunctionContext,\n \n             fcx.ccx.sess().span_bug(error_reporting_span,\n                 format!(\"debuginfo: Could not find scope info for node {}\",\n-                        node).as_slice());\n+                        node)[]);\n         }\n     }\n }\n@@ -1925,7 +1925,7 @@ impl<'tcx> RecursiveTypeDescription<'tcx> {\n                         cx.sess().bug(format!(\"Forward declaration of potentially recursive type \\\n                                               '{}' was not found in TypeMap!\",\n                                               ppaux::ty_to_string(cx.tcx(), unfinished_type))\n-                                      .as_slice());\n+                                      []);\n                     }\n                 }\n \n@@ -1937,7 +1937,7 @@ impl<'tcx> RecursiveTypeDescription<'tcx> {\n                 set_members_of_composite_type(cx,\n                                               metadata_stub,\n                                               llvm_type,\n-                                              member_descriptions.as_slice());\n+                                              member_descriptions[]);\n                 return MetadataCreationResult::new(metadata_stub, true);\n             }\n         }\n@@ -2009,7 +2009,7 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let struct_metadata_stub = create_struct_stub(cx,\n                                                   struct_llvm_type,\n-                                                  struct_name.as_slice(),\n+                                                  struct_name[],\n                                                   unique_type_id,\n                                                   containing_scope);\n \n@@ -2070,7 +2070,7 @@ fn prepare_tuple_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         unique_type_id,\n         create_struct_stub(cx,\n                            tuple_llvm_type,\n-                           tuple_name.as_slice(),\n+                           tuple_name[],\n                            unique_type_id,\n                            UNKNOWN_SCOPE_METADATA),\n         tuple_llvm_type,\n@@ -2130,7 +2130,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                         set_members_of_composite_type(cx,\n                                                       variant_type_metadata,\n                                                       variant_llvm_type,\n-                                                      member_descriptions.as_slice());\n+                                                      member_descriptions[]);\n                         MemberDescription {\n                             name: \"\".to_string(),\n                             llvm_type: variant_llvm_type,\n@@ -2163,7 +2163,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     set_members_of_composite_type(cx,\n                                                   variant_type_metadata,\n                                                   variant_llvm_type,\n-                                                  member_descriptions.as_slice());\n+                                                  member_descriptions[]);\n                     vec![\n                         MemberDescription {\n                             name: \"\".to_string(),\n@@ -2263,7 +2263,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 set_members_of_composite_type(cx,\n                                               variant_type_metadata,\n                                               variant_llvm_type,\n-                                              variant_member_descriptions.as_slice());\n+                                              variant_member_descriptions[]);\n \n                 // Encode the information about the null variant in the union\n                 // member's name.\n@@ -2342,7 +2342,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                     .iter()\n                                     .map(|&t| type_of::type_of(cx, t))\n                                     .collect::<Vec<_>>()\n-                                    .as_slice(),\n+                                    [],\n                       struct_def.packed);\n     // Could do some consistency checks here: size, align, field count, discr type\n \n@@ -2366,7 +2366,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         Some(ref names) => {\n             names.iter()\n                  .map(|ident| {\n-                     token::get_ident(*ident).get().to_string().into_string()\n+                     token::get_ident(*ident).get().to_string()\n                  }).collect()\n         }\n         None => variant_info.args.iter().map(|_| \"\".to_string()).collect()\n@@ -2409,7 +2409,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, enum_def_id);\n     let loc = span_start(cx, definition_span);\n-    let file_metadata = file_metadata(cx, loc.file.name.as_slice());\n+    let file_metadata = file_metadata(cx, loc.file.name[]);\n \n     let variants = ty::enum_variants(cx.tcx(), enum_def_id);\n \n@@ -2456,7 +2456,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                             UNKNOWN_LINE_NUMBER,\n                             bytes_to_bits(discriminant_size),\n                             bytes_to_bits(discriminant_align),\n-                            create_DIArray(DIB(cx), enumerators_metadata.as_slice()),\n+                            create_DIArray(DIB(cx), enumerators_metadata[]),\n                             discriminant_base_type_metadata)\n                     }\n                 });\n@@ -2598,7 +2598,7 @@ fn set_members_of_composite_type(cx: &CrateContext,\n                                         Please use a rustc built with anewer \\\n                                         version of LLVM.\",\n                                        llvm_version_major,\n-                                       llvm_version_minor).as_slice());\n+                                       llvm_version_minor)[]);\n             } else {\n                 cx.sess().bug(\"debuginfo::set_members_of_composite_type() - \\\n                                Already completed forward declaration re-encountered.\");\n@@ -2637,7 +2637,7 @@ fn set_members_of_composite_type(cx: &CrateContext,\n         .collect();\n \n     unsafe {\n-        let type_array = create_DIArray(DIB(cx), member_metadata.as_slice());\n+        let type_array = create_DIArray(DIB(cx), member_metadata[]);\n         llvm::LLVMDICompositeTypeSetTypeArray(composite_type_metadata, type_array);\n     }\n }\n@@ -2738,7 +2738,7 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let member_llvm_types = slice_llvm_type.field_types();\n     assert!(slice_layout_is_correct(cx,\n-                                    member_llvm_types.as_slice(),\n+                                    member_llvm_types[],\n                                     element_type));\n     let member_descriptions = [\n         MemberDescription {\n@@ -2760,11 +2760,11 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     assert!(member_descriptions.len() == member_llvm_types.len());\n \n     let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, loc.file.name.as_slice());\n+    let file_metadata = file_metadata(cx, loc.file.name[]);\n \n     let metadata = composite_type_metadata(cx,\n                                            slice_llvm_type,\n-                                           slice_type_name.as_slice(),\n+                                           slice_type_name[],\n                                            unique_type_id,\n                                            &member_descriptions,\n                                            UNKNOWN_SCOPE_METADATA,\n@@ -2810,7 +2810,7 @@ fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             llvm::LLVMDIBuilderCreateSubroutineType(\n                 DIB(cx),\n                 UNKNOWN_FILE_METADATA,\n-                create_DIArray(DIB(cx), signature_metadata.as_slice()))\n+                create_DIArray(DIB(cx), signature_metadata[]))\n         },\n         false);\n }\n@@ -2836,7 +2836,7 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let pp_type_name = ppaux::ty_to_string(cx.tcx(), trait_type);\n             cx.sess().bug(format!(\"debuginfo: Unexpected trait-object type in \\\n                                    trait_pointer_metadata(): {}\",\n-                                   pp_type_name.as_slice()).as_slice());\n+                                   pp_type_name[])[]);\n         }\n     };\n \n@@ -2850,7 +2850,7 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     composite_type_metadata(cx,\n                             trait_llvm_type,\n-                            trait_type_name.as_slice(),\n+                            trait_type_name[],\n                             unique_type_id,\n                             &[],\n                             containing_scope,\n@@ -2951,7 +2951,7 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n             }\n         }\n-        ty::ty_bare_fn(ref barefnty) => {\n+        ty::ty_bare_fn(_, ref barefnty) => {\n             subroutine_type_metadata(cx, unique_type_id, &barefnty.sig, usage_site_span)\n         }\n         ty::ty_closure(ref closurety) => {\n@@ -2973,13 +2973,13 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::ty_tup(ref elements) => {\n             prepare_tuple_metadata(cx,\n                                    t,\n-                                   elements.as_slice(),\n+                                   elements[],\n                                    unique_type_id,\n                                    usage_site_span).finalize(cx)\n         }\n         _ => {\n             cx.sess().bug(format!(\"debuginfo: unexpected type in type_metadata: {}\",\n-                                  sty).as_slice())\n+                                  sty)[])\n         }\n     };\n \n@@ -2997,9 +2997,9 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                  type id '{}' to already be in \\\n                                                  the debuginfo::TypeMap but it \\\n                                                  was not. (Ty = {})\",\n-                                                unique_type_id_str.as_slice(),\n+                                                unique_type_id_str[],\n                                                 ppaux::ty_to_string(cx.tcx(), t));\n-                    cx.sess().span_bug(usage_site_span, error_message.as_slice());\n+                    cx.sess().span_bug(usage_site_span, error_message[]);\n                 }\n             };\n \n@@ -3012,9 +3012,9 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                      UniqueTypeId maps in \\\n                                                      debuginfo::TypeMap. \\\n                                                      UniqueTypeId={}, Ty={}\",\n-                            unique_type_id_str.as_slice(),\n+                            unique_type_id_str[],\n                             ppaux::ty_to_string(cx.tcx(), t));\n-                        cx.sess().span_bug(usage_site_span, error_message.as_slice());\n+                        cx.sess().span_bug(usage_site_span, error_message[]);\n                     }\n                 }\n                 None => {\n@@ -3215,7 +3215,7 @@ fn populate_scope_map(cx: &CrateContext,\n     {\n         // Create a new lexical scope and push it onto the stack\n         let loc = cx.sess().codemap().lookup_char_pos(scope_span.lo);\n-        let file_metadata = file_metadata(cx, loc.file.name.as_slice());\n+        let file_metadata = file_metadata(cx, loc.file.name[]);\n         let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n         let scope_metadata = unsafe {\n@@ -3340,7 +3340,7 @@ fn populate_scope_map(cx: &CrateContext,\n                         let file_metadata = file_metadata(cx,\n                                                           loc.file\n                                                              .name\n-                                                             .as_slice());\n+                                                             []);\n                         let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n                         let scope_metadata = unsafe {\n@@ -3763,7 +3763,7 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             push_item_name(cx, trait_data.principal.def_id(), false, output);\n             push_type_params(cx, trait_data.principal.substs(), output);\n         },\n-        ty::ty_bare_fn(ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n+        ty::ty_bare_fn(_, ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n             if unsafety == ast::Unsafety::Unsafe {\n                 output.push_str(\"unsafe \");\n             }\n@@ -3874,7 +3874,7 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::ty_open(_) |\n         ty::ty_param(_) => {\n             cx.sess().bug(format!(\"debuginfo: Trying to create type name for \\\n-                unexpected type: {}\", ppaux::ty_to_string(cx.tcx(), t)).as_slice());\n+                unexpected type: {}\", ppaux::ty_to_string(cx.tcx(), t))[]);\n         }\n     }\n \n@@ -3957,21 +3957,21 @@ impl NamespaceTreeNode {\n                 None => {}\n             }\n             let string = token::get_name(node.name);\n-            output.push_str(format!(\"{}\", string.get().len()).as_slice());\n+            output.push_str(format!(\"{}\", string.get().len())[]);\n             output.push_str(string.get());\n         }\n \n         let mut name = String::from_str(\"_ZN\");\n         fill_nested(self, &mut name);\n-        name.push_str(format!(\"{}\", item_name.len()).as_slice());\n+        name.push_str(format!(\"{}\", item_name.len())[]);\n         name.push_str(item_name);\n         name.push('E');\n         name\n     }\n }\n \n fn crate_root_namespace<'a>(cx: &'a CrateContext) -> &'a str {\n-    cx.link_meta().crate_name.as_slice()\n+    cx.link_meta().crate_name[]\n }\n \n fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTreeNode> {\n@@ -4048,7 +4048,7 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTree\n             None => {\n                 cx.sess().bug(format!(\"debuginfo::namespace_for_item(): \\\n                                        path too short for {}\",\n-                                      def_id).as_slice());\n+                                      def_id)[]);\n             }\n         }\n     })"}, {"sha": "3388a7623e315e12f0e3671fc5044279dc013e52", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 34, "deletions": 30, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -54,7 +54,7 @@ use trans::inline;\n use trans::tvec;\n use trans::type_of;\n use middle::ty::{struct_fields, tup_fields};\n-use middle::ty::{AdjustDerefRef, AdjustAddEnv, AutoUnsafe};\n+use middle::ty::{AdjustDerefRef, AdjustReifyFnPointer, AdjustAddEnv, AutoUnsafe};\n use middle::ty::{AutoPtr};\n use middle::ty::{mod, Ty};\n use middle::ty::MethodCall;\n@@ -177,8 +177,12 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n            datum.to_string(bcx.ccx()),\n            adjustment.repr(bcx.tcx()));\n     match adjustment {\n-        AdjustAddEnv(..) => {\n-            datum = unpack_datum!(bcx, add_env(bcx, expr, datum));\n+        AdjustAddEnv(def_id, _) => {\n+            datum = unpack_datum!(bcx, add_env(bcx, def_id, expr, datum));\n+        }\n+        AdjustReifyFnPointer(_def_id) => {\n+            // FIXME(#19925) once fn item types are\n+            // zero-sized, we'll need to do something here\n         }\n         AdjustDerefRef(ref adj) => {\n             let (autoderefs, use_autoref) = match adj.autoref {\n@@ -311,7 +315,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     unsized_info(bcx, k, id, ty_substs[tp_index], |t| t)\n                 }\n                 _ => bcx.sess().bug(format!(\"UnsizeStruct with bad sty: {}\",\n-                                          bcx.ty_to_string(unadjusted_ty)).as_slice())\n+                                          bcx.ty_to_string(unadjusted_ty))[])\n             },\n             &ty::UnsizeVtable(ty::TyTrait { ref principal, .. }, _) => {\n                 let substs = principal.substs().with_self_ty(unadjusted_ty).erase_regions();\n@@ -442,7 +446,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let unboxed_ty = match datum_ty.sty {\n             ty::ty_uniq(t) => t,\n             _ => bcx.sess().bug(format!(\"Expected ty_uniq, found {}\",\n-                                        bcx.ty_to_string(datum_ty)).as_slice())\n+                                        bcx.ty_to_string(datum_ty))[])\n         };\n         let result_ty = ty::mk_uniq(tcx, ty::unsize_ty(tcx, unboxed_ty, k, expr.span));\n \n@@ -466,6 +470,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n \n     fn add_env<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                           def_id: ast::DefId,\n                            expr: &ast::Expr,\n                            datum: Datum<'tcx, Expr>)\n                            -> DatumBlock<'blk, 'tcx, Expr> {\n@@ -477,8 +482,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n         let closure_ty = expr_ty_adjusted(bcx, expr);\n         let fn_ptr = datum.to_llscalarish(bcx);\n-        let def = ty::resolve_expr(bcx.tcx(), expr);\n-        closure::make_closure_from_bare_fn(bcx, closure_ty, def, fn_ptr)\n+        closure::make_closure_from_bare_fn(bcx, closure_ty, def_id, fn_ptr)\n     }\n }\n \n@@ -660,7 +664,7 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 expr.span,\n                 format!(\"trans_rvalue_datum_unadjusted reached \\\n                          fall-through case: {}\",\n-                        expr.node).as_slice());\n+                        expr.node)[]);\n         }\n     }\n }\n@@ -1007,7 +1011,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 expr.span,\n                 format!(\"trans_rvalue_stmt_unadjusted reached \\\n                          fall-through case: {}\",\n-                        expr.node).as_slice());\n+                        expr.node)[]);\n         }\n     }\n }\n@@ -1033,14 +1037,14 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             controlflow::trans_if(bcx, expr.id, &**cond, &**thn, els.as_ref().map(|e| &**e), dest)\n         }\n         ast::ExprMatch(ref discr, ref arms, _) => {\n-            _match::trans_match(bcx, expr, &**discr, arms.as_slice(), dest)\n+            _match::trans_match(bcx, expr, &**discr, arms[], dest)\n         }\n         ast::ExprBlock(ref blk) => {\n             controlflow::trans_block(bcx, &**blk, dest)\n         }\n         ast::ExprStruct(_, ref fields, ref base) => {\n             trans_struct(bcx,\n-                         fields.as_slice(),\n+                         fields[],\n                          base.as_ref().map(|e| &**e),\n                          expr.span,\n                          expr.id,\n@@ -1052,7 +1056,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             trans_adt(bcx,\n                       expr_ty(bcx, expr),\n                       0,\n-                      numbered_fields.as_slice(),\n+                      numbered_fields[],\n                       None,\n                       dest,\n                       Some(NodeInfo { id: expr.id, span: expr.span }))\n@@ -1096,21 +1100,21 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 trans_overloaded_call(bcx,\n                                       expr,\n                                       &**f,\n-                                      args.as_slice(),\n+                                      args[],\n                                       Some(dest))\n             } else {\n                 callee::trans_call(bcx,\n                                    expr,\n                                    &**f,\n-                                   callee::ArgExprs(args.as_slice()),\n+                                   callee::ArgExprs(args[]),\n                                    dest)\n             }\n         }\n         ast::ExprMethodCall(_, _, ref args) => {\n             callee::trans_method_call(bcx,\n                                       expr,\n                                       &*args[0],\n-                                      callee::ArgExprs(args.as_slice()),\n+                                      callee::ArgExprs(args[]),\n                                       dest)\n         }\n         ast::ExprBinary(op, ref lhs, ref rhs) => {\n@@ -1159,7 +1163,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 expr.span,\n                 format!(\"trans_rvalue_dps_unadjusted reached fall-through \\\n                          case: {}\",\n-                        expr.node).as_slice());\n+                        expr.node)[]);\n         }\n     }\n }\n@@ -1207,7 +1211,7 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         _ => {\n             bcx.tcx().sess.span_bug(ref_expr.span, format!(\n                 \"Non-DPS def {} referened by {}\",\n-                def, bcx.node_id_to_string(ref_expr.id)).as_slice());\n+                def, bcx.node_id_to_string(ref_expr.id))[]);\n         }\n     }\n }\n@@ -1234,7 +1238,7 @@ fn trans_def_fn_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             bcx.tcx().sess.span_bug(ref_expr.span, format!(\n                     \"trans_def_fn_unadjusted invoked on: {} for {}\",\n                     def,\n-                    ref_expr.repr(bcx.tcx())).as_slice());\n+                    ref_expr.repr(bcx.tcx()))[]);\n         }\n     };\n \n@@ -1257,7 +1261,7 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 None => {\n                     bcx.sess().bug(format!(\n                         \"trans_local_var: no llval for upvar {} found\",\n-                        nid).as_slice());\n+                        nid)[]);\n                 }\n             }\n         }\n@@ -1267,7 +1271,7 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 None => {\n                     bcx.sess().bug(format!(\n                         \"trans_local_var: no datum for local/arg {} found\",\n-                        nid).as_slice());\n+                        nid)[]);\n                 }\n             };\n             debug!(\"take_local(nid={}, v={}, ty={})\",\n@@ -1277,7 +1281,7 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         _ => {\n             bcx.sess().unimpl(format!(\n                 \"unsupported def type in trans_local_var: {}\",\n-                def).as_slice());\n+                def)[]);\n         }\n     }\n }\n@@ -1294,11 +1298,11 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n {\n     match ty.sty {\n         ty::ty_struct(did, ref substs) => {\n-            op(0, struct_fields(tcx, did, substs).as_slice())\n+            op(0, struct_fields(tcx, did, substs)[])\n         }\n \n         ty::ty_tup(ref v) => {\n-            op(0, tup_fields(v.as_slice()).as_slice())\n+            op(0, tup_fields(v[])[])\n         }\n \n         ty::ty_enum(_, ref substs) => {\n@@ -1308,7 +1312,7 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n                     tcx.sess.bug(format!(\n                         \"cannot get field types from the enum type {} \\\n                          without a node ID\",\n-                        ty.repr(tcx)).as_slice());\n+                        ty.repr(tcx))[]);\n                 }\n                 Some(node_id) => {\n                     let def = tcx.def_map.borrow()[node_id].clone();\n@@ -1319,7 +1323,7 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n                             op(variant_info.disr_val,\n                                struct_fields(tcx,\n                                              variant_id,\n-                                             substs).as_slice())\n+                                             substs)[])\n                         }\n                         _ => {\n                             tcx.sess.bug(\"resolve didn't map this expr to a \\\n@@ -1333,7 +1337,7 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n         _ => {\n             tcx.sess.bug(format!(\n                 \"cannot get field types from the type {}\",\n-                ty.repr(tcx)).as_slice());\n+                ty.repr(tcx))[]);\n         }\n     }\n }\n@@ -1388,7 +1392,7 @@ fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         trans_adt(bcx,\n                   ty,\n                   discr,\n-                  numbered_fields.as_slice(),\n+                  numbered_fields[],\n                   optbase,\n                   dest,\n                   Some(NodeInfo { id: expr_id, span: expr_span }))\n@@ -2025,7 +2029,7 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                             t_in.repr(bcx.tcx()),\n                                             k_in,\n                                             t_out.repr(bcx.tcx()),\n-                                            k_out).as_slice())\n+                                            k_out)[])\n                 }\n             }\n         }\n@@ -2034,7 +2038,7 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     t_in.repr(bcx.tcx()),\n                                     k_in,\n                                     t_out.repr(bcx.tcx()),\n-                                    k_out).as_slice())\n+                                    k_out)[])\n     };\n     return immediate_rvalue_bcx(bcx, newval, t_out).to_expr_datumblock();\n }\n@@ -2196,7 +2200,7 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n                 format!(\"deref invoked on expr of illegal type {}\",\n-                        datum.ty.repr(bcx.tcx())).as_slice());\n+                        datum.ty.repr(bcx.tcx()))[]);\n         }\n     };\n "}, {"sha": "1bad476863fdb6fdec5c65ddd916f5f7cc049bd0", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -106,7 +106,7 @@ pub fn register_static(ccx: &CrateContext,\n     let llty = type_of::type_of(ccx, ty);\n \n     let ident = link_name(foreign_item);\n-    match attr::first_attr_value_str_by_name(foreign_item.attrs.as_slice(),\n+    match attr::first_attr_value_str_by_name(foreign_item.attrs[],\n                                              \"linkage\") {\n         // If this is a static with a linkage specified, then we need to handle\n         // it a little specially. The typesystem prevents things like &T and\n@@ -228,16 +228,16 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n            ccx.tn().val_to_string(llretptr));\n \n     let (fn_abi, fn_sig) = match callee_ty.sty {\n-        ty::ty_bare_fn(ref fn_ty) => (fn_ty.abi, fn_ty.sig.clone()),\n+        ty::ty_bare_fn(_, ref fn_ty) => (fn_ty.abi, fn_ty.sig.clone()),\n         _ => ccx.sess().bug(\"trans_native_call called on non-function type\")\n     };\n-    let llsig = foreign_signature(ccx, &fn_sig, passed_arg_tys.as_slice());\n+    let llsig = foreign_signature(ccx, &fn_sig, passed_arg_tys[]);\n     let fn_type = cabi::compute_abi_info(ccx,\n-                                         llsig.llarg_tys.as_slice(),\n+                                         llsig.llarg_tys[],\n                                          llsig.llret_ty,\n                                          llsig.ret_def);\n \n-    let arg_tys: &[cabi::ArgType] = fn_type.arg_tys.as_slice();\n+    let arg_tys: &[cabi::ArgType] = fn_type.arg_tys[];\n \n     let mut llargs_foreign = Vec::new();\n \n@@ -363,7 +363,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let llforeign_retval = CallWithConv(bcx,\n                                         llfn,\n-                                        llargs_foreign.as_slice(),\n+                                        llargs_foreign[],\n                                         cc,\n                                         Some(attrs));\n \n@@ -433,7 +433,7 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n                 abi => {\n                     let ty = ty::node_id_to_type(ccx.tcx(), foreign_item.id);\n                     register_foreign_item_fn(ccx, abi, ty,\n-                                             lname.get().as_slice());\n+                                             lname.get()[]);\n                     // Unlike for other items, we shouldn't call\n                     // `base::update_linkage` here.  Foreign items have\n                     // special linkage requirements, which are handled\n@@ -479,7 +479,7 @@ pub fn decl_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let tys = foreign_types_for_fn_ty(ccx, t);\n     let llfn_ty = lltype_for_fn_from_foreign_types(ccx, &tys);\n     let cconv = match t.sty {\n-        ty::ty_bare_fn(ref fn_ty) => {\n+        ty::ty_bare_fn(_, ref fn_ty) => {\n             llvm_calling_convention(ccx, fn_ty.abi)\n         }\n         _ => panic!(\"expected bare fn in decl_rust_fn_with_foreign_abi\")\n@@ -502,7 +502,7 @@ pub fn register_rust_fn_with_foreign_abi(ccx: &CrateContext,\n     let llfn_ty = lltype_for_fn_from_foreign_types(ccx, &tys);\n     let t = ty::node_id_to_type(ccx.tcx(), node_id);\n     let cconv = match t.sty {\n-        ty::ty_bare_fn(ref fn_ty) => {\n+        ty::ty_bare_fn(_, ref fn_ty) => {\n             llvm_calling_convention(ccx, fn_ty.abi)\n         }\n         _ => panic!(\"expected bare fn in register_rust_fn_with_foreign_abi\")\n@@ -556,22 +556,22 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // Compute the type that the function would have if it were just a\n         // normal Rust function. This will be the type of the wrappee fn.\n         match t.sty {\n-            ty::ty_bare_fn(ref f) => {\n+            ty::ty_bare_fn(_, ref f) => {\n                 assert!(f.abi != Rust && f.abi != RustIntrinsic);\n             }\n             _ => {\n                 ccx.sess().bug(format!(\"build_rust_fn: extern fn {} has ty {}, \\\n                                         expected a bare fn ty\",\n                                        ccx.tcx().map.path_to_string(id),\n-                                       t.repr(tcx)).as_slice());\n+                                       t.repr(tcx))[]);\n             }\n         };\n \n         debug!(\"build_rust_fn: path={} id={} t={}\",\n                ccx.tcx().map.path_to_string(id),\n                id, t.repr(tcx));\n \n-        let llfn = base::decl_internal_rust_fn(ccx, t, ps.as_slice());\n+        let llfn = base::decl_internal_rust_fn(ccx, t, ps[]);\n         base::set_llvm_fn_attrs(ccx, attrs, llfn);\n         base::trans_fn(ccx, decl, body, llfn, param_substs, id, &[]);\n         llfn\n@@ -744,7 +744,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         debug!(\"calling llrustfn = {}, t = {}\",\n                ccx.tn().val_to_string(llrustfn), t.repr(ccx.tcx()));\n         let attributes = base::get_fn_llvm_attributes(ccx, t);\n-        let llrust_ret_val = builder.call(llrustfn, llrust_args.as_slice(), Some(attributes));\n+        let llrust_ret_val = builder.call(llrustfn, llrust_args[], Some(attributes));\n \n         // Get the return value where the foreign fn expects it.\n         let llforeign_ret_ty = match tys.fn_ty.ret_ty.cast {\n@@ -811,9 +811,9 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n // the massive simplifications that have occurred.\n \n pub fn link_name(i: &ast::ForeignItem) -> InternedString {\n-    match attr::first_attr_value_str_by_name(i.attrs.as_slice(), \"link_name\") {\n+    match attr::first_attr_value_str_by_name(i.attrs[], \"link_name\") {\n         Some(ln) => ln.clone(),\n-        None => match weak_lang_items::link_name(i.attrs.as_slice()) {\n+        None => match weak_lang_items::link_name(i.attrs[]) {\n             Some(name) => name,\n             None => token::get_ident(i.ident),\n         }\n@@ -849,12 +849,12 @@ fn foreign_types_for_id<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                      ty: Ty<'tcx>) -> ForeignTypes<'tcx> {\n     let fn_sig = match ty.sty {\n-        ty::ty_bare_fn(ref fn_ty) => fn_ty.sig.clone(),\n+        ty::ty_bare_fn(_, ref fn_ty) => fn_ty.sig.clone(),\n         _ => ccx.sess().bug(\"foreign_types_for_fn_ty called on non-function type\")\n     };\n     let llsig = foreign_signature(ccx, &fn_sig, fn_sig.0.inputs.as_slice());\n     let fn_ty = cabi::compute_abi_info(ccx,\n-                                       llsig.llarg_tys.as_slice(),\n+                                       llsig.llarg_tys[],\n                                        llsig.llret_ty,\n                                        llsig.ret_def);\n     debug!(\"foreign_types_for_fn_ty(\\\n@@ -863,9 +863,9 @@ fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            fn_ty={} -> {}, \\\n            ret_def={}\",\n            ty.repr(ccx.tcx()),\n-           ccx.tn().types_to_str(llsig.llarg_tys.as_slice()),\n+           ccx.tn().types_to_str(llsig.llarg_tys[]),\n            ccx.tn().type_to_string(llsig.llret_ty),\n-           ccx.tn().types_to_str(fn_ty.arg_tys.iter().map(|t| t.ty).collect::<Vec<_>>().as_slice()),\n+           ccx.tn().types_to_str(fn_ty.arg_tys.iter().map(|t| t.ty).collect::<Vec<_>>()[]),\n            ccx.tn().type_to_string(fn_ty.ret_ty.ty),\n            llsig.ret_def);\n \n@@ -915,7 +915,7 @@ fn lltype_for_fn_from_foreign_types(ccx: &CrateContext, tys: &ForeignTypes) -> T\n     if tys.fn_sig.0.variadic {\n         Type::variadic_func(llargument_tys.as_slice(), &llreturn_ty)\n     } else {\n-        Type::func(llargument_tys.as_slice(), &llreturn_ty)\n+        Type::func(llargument_tys[], &llreturn_ty)\n     }\n }\n "}, {"sha": "26734d854afc036f1a1d9ec9cff5048208233eac", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -160,7 +160,7 @@ pub fn get_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Val\n \n     let (glue, new_sym) = match ccx.available_drop_glues().borrow().get(&t) {\n         Some(old_sym) => {\n-            let glue = decl_cdecl_fn(ccx, old_sym.as_slice(), llfnty, ty::mk_nil(ccx.tcx()));\n+            let glue = decl_cdecl_fn(ccx, old_sym[], llfnty, ty::mk_nil(ccx.tcx()));\n             (glue, None)\n         },\n         None => {\n@@ -226,12 +226,12 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let fty = ty::lookup_item_type(bcx.tcx(), dtor_did).ty.subst(bcx.tcx(), substs);\n     let self_ty = match fty.sty {\n-        ty::ty_bare_fn(ref f) => {\n+        ty::ty_bare_fn(_, ref f) => {\n             assert!(f.sig.0.inputs.len() == 1);\n             f.sig.0.inputs[0]\n         }\n         _ => bcx.sess().bug(format!(\"Expected function type, found {}\",\n-                                    bcx.ty_to_string(fty)).as_slice())\n+                                    bcx.ty_to_string(fty))[])\n     };\n \n     let (struct_data, info) = if ty::type_is_sized(bcx.tcx(), t) {\n@@ -289,6 +289,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n \n         let dtor_ty = ty::mk_ctor_fn(bcx.tcx(),\n+                                     class_did,\n                                      &[get_drop_glue_type(bcx.ccx(), t)],\n                                      ty::mk_nil(bcx.tcx()));\n         let (_, variant_cx) = invoke(variant_cx, dtor_addr, args[], dtor_ty, None, false);\n@@ -350,7 +351,7 @@ fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info:\n             (Mul(bcx, info, C_uint(bcx.ccx(), unit_size)), C_uint(bcx.ccx(), 8u))\n         }\n         _ => bcx.sess().bug(format!(\"Unexpected unsized type, found {}\",\n-                                    bcx.ty_to_string(t)).as_slice())\n+                                    bcx.ty_to_string(t))[])\n     }\n }\n \n@@ -422,7 +423,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                         bcx.sess().warn(format!(\"Ignoring drop flag in destructor for {}\\\n                                                  because the struct is unsized. See issue\\\n                                                  #16758\",\n-                                                bcx.ty_to_string(t)).as_slice());\n+                                                bcx.ty_to_string(t))[]);\n                         trans_struct_drop(bcx, t, v0, dtor, did, substs)\n                     }\n                 }\n@@ -504,7 +505,7 @@ pub fn declare_tydesc<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>)\n     note_unique_llvm_symbol(ccx, name);\n \n     let ty_name = token::intern_and_get_ident(\n-        ppaux::ty_to_string(ccx.tcx(), t).as_slice());\n+        ppaux::ty_to_string(ccx.tcx(), t)[]);\n     let ty_name = C_str_slice(ccx, ty_name);\n \n     debug!(\"--- declare_tydesc {}\", ppaux::ty_to_string(ccx.tcx(), t));\n@@ -523,8 +524,8 @@ fn declare_generic_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n     let fn_nm = mangle_internal_name_by_type_and_seq(\n         ccx,\n         t,\n-        format!(\"glue_{}\", name).as_slice());\n-    let llfn = decl_cdecl_fn(ccx, fn_nm.as_slice(), llfnty, ty::mk_nil(ccx.tcx()));\n+        format!(\"glue_{}\", name)[]);\n+    let llfn = decl_cdecl_fn(ccx, fn_nm[], llfnty, ty::mk_nil(ccx.tcx()));\n     note_unique_llvm_symbol(ccx, fn_nm.clone());\n     return (fn_nm, llfn);\n }"}, {"sha": "fff89999d99b58cb599ad334ea0fbff7a6a0a26e", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -118,7 +118,7 @@ pub fn check_intrinsics(ccx: &CrateContext) {\n                             \"\"\n                         } else {\n                             \"s\"\n-                        }).as_slice());\n+                        })[]);\n         }\n         if ty::type_is_fat_ptr(ccx.tcx(), transmute_restriction.to) ||\n            ty::type_is_fat_ptr(ccx.tcx(), transmute_restriction.from) {\n@@ -150,7 +150,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let tcx = bcx.tcx();\n \n     let ret_ty = match callee_ty.sty {\n-        ty::ty_bare_fn(ref f) => f.sig.0.output,\n+        ty::ty_bare_fn(_, ref f) => f.sig.0.output,\n         _ => panic!(\"expected bare_fn in trans_intrinsic_call\")\n     };\n     let foreign_item = tcx.map.expect_foreign_item(node);"}, {"sha": "38c6b802d0485f4205b73ab265b9af581464aee5", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -77,7 +77,7 @@ pub fn trans_impl(ccx: &CrateContext,\n         match *impl_item {\n             ast::MethodImplItem(ref method) => {\n                 if method.pe_generics().ty_params.len() == 0u {\n-                    let trans_everywhere = attr::requests_inline(method.attrs.as_slice());\n+                    let trans_everywhere = attr::requests_inline(method.attrs[]);\n                     for (ref ccx, is_origin) in ccx.maybe_iter(trans_everywhere) {\n                         let llfn = get_item_val(ccx, method.id);\n                         trans_fn(ccx,\n@@ -293,7 +293,7 @@ pub fn trans_static_method_callee(bcx: Block,\n         _ => {\n             bcx.tcx().sess.bug(\n                 format!(\"static call to invalid vtable: {}\",\n-                        vtbl.repr(bcx.tcx())).as_slice());\n+                        vtbl.repr(bcx.tcx()))[]);\n         }\n     }\n }\n@@ -375,7 +375,7 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         traits::VtableParam(..) => {\n             bcx.sess().bug(\n                 format!(\"resolved vtable bad vtable {} in trans\",\n-                        vtable.repr(bcx.tcx())).as_slice());\n+                        vtable.repr(bcx.tcx()))[]);\n         }\n     }\n }\n@@ -477,7 +477,7 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     debug!(\"(translating trait callee) loading method\");\n     // Replace the self type (&Self or Box<Self>) with an opaque pointer.\n     let llcallee_ty = match callee_ty.sty {\n-        ty::ty_bare_fn(ref f) if f.abi == Rust || f.abi == RustCall => {\n+        ty::ty_bare_fn(_, ref f) if f.abi == Rust || f.abi == RustCall => {\n             type_of_rust_fn(ccx,\n                             Some(Type::i8p(ccx)),\n                             f.sig.0.inputs.slice_from(1),\n@@ -566,7 +566,7 @@ pub fn get_vtable<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 bcx.sess().bug(\n                     format!(\"resolved vtable for {} to bad vtable {} in trans\",\n                             trait_ref.repr(bcx.tcx()),\n-                            vtable.repr(bcx.tcx())).as_slice());\n+                            vtable.repr(bcx.tcx()))[]);\n             }\n         }\n     });\n@@ -598,7 +598,7 @@ pub fn make_vtable<I: Iterator<ValueRef>>(ccx: &CrateContext,\n     let components: Vec<_> = head.into_iter().chain(ptrs).collect();\n \n     unsafe {\n-        let tbl = C_struct(ccx, components.as_slice(), false);\n+        let tbl = C_struct(ccx, components[], false);\n         let sym = token::gensym(\"vtable\");\n         let vt_gvar = format!(\"vtable{}\", sym.uint()).with_c_str(|buf| {\n             llvm::LLVMAddGlobal(ccx.llmod(), val_ty(tbl).to_ref(), buf)\n@@ -639,7 +639,8 @@ fn emit_vtable_methods<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                        m.repr(tcx),\n                        substs.repr(tcx));\n                 if m.generics.has_type_params(subst::FnSpace) ||\n-                   ty::type_has_self(ty::mk_bare_fn(tcx, m.fty.clone())) {\n+                    ty::type_has_self(ty::mk_bare_fn(tcx, None, m.fty.clone()))\n+                {\n                     debug!(\"(making impl vtable) method has self or type \\\n                             params: {}\",\n                            token::get_name(name));"}, {"sha": "2a6aff56513a16acf6f87b538c393f252b8e228d", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -122,7 +122,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n         hash = format!(\"h{}\", state.result());\n         ccx.tcx().map.with_path(fn_id.node, |path| {\n-            exported_name(path, hash.as_slice())\n+            exported_name(path, hash[])\n         })\n     };\n \n@@ -132,9 +132,9 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let mut hash_id = Some(hash_id);\n     let mk_lldecl = |abi: abi::Abi| {\n         let lldecl = if abi != abi::Rust {\n-            foreign::decl_rust_fn_with_foreign_abi(ccx, mono_ty, s.as_slice())\n+            foreign::decl_rust_fn_with_foreign_abi(ccx, mono_ty, s[])\n         } else {\n-            decl_internal_rust_fn(ccx, mono_ty, s.as_slice())\n+            decl_internal_rust_fn(ccx, mono_ty, s[])\n         };\n \n         ccx.monomorphized().borrow_mut().insert(hash_id.take().unwrap(), lldecl);\n@@ -168,12 +168,12 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                   ..\n               } => {\n                   let d = mk_lldecl(abi);\n-                  let needs_body = setup_lldecl(d, i.attrs.as_slice());\n+                  let needs_body = setup_lldecl(d, i.attrs[]);\n                   if needs_body {\n                       if abi != abi::Rust {\n                           foreign::trans_rust_fn_with_foreign_abi(\n                               ccx, &**decl, &**body, &[], d, psubsts, fn_id.node,\n-                              Some(hash.as_slice()));\n+                              Some(hash[]));\n                       } else {\n                           trans_fn(ccx, &**decl, &**body, d, psubsts, fn_id.node, &[]);\n                       }\n@@ -197,7 +197,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     trans_enum_variant(ccx,\n                                        parent,\n                                        &*v,\n-                                       args.as_slice(),\n+                                       args[],\n                                        this_tv.disr_val,\n                                        psubsts,\n                                        d);\n@@ -211,7 +211,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             match *ii {\n                 ast::MethodImplItem(ref mth) => {\n                     let d = mk_lldecl(abi::Rust);\n-                    let needs_body = setup_lldecl(d, mth.attrs.as_slice());\n+                    let needs_body = setup_lldecl(d, mth.attrs[]);\n                     if needs_body {\n                         trans_fn(ccx,\n                                  mth.pe_fn_decl(),\n@@ -232,7 +232,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             match *method {\n                 ast::ProvidedMethod(ref mth) => {\n                     let d = mk_lldecl(abi::Rust);\n-                    let needs_body = setup_lldecl(d, mth.attrs.as_slice());\n+                    let needs_body = setup_lldecl(d, mth.attrs[]);\n                     if needs_body {\n                         trans_fn(ccx, mth.pe_fn_decl(), mth.pe_body(), d,\n                                  psubsts, mth.id, &[]);\n@@ -241,15 +241,15 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 }\n                 _ => {\n                     ccx.sess().bug(format!(\"can't monomorphize a {}\",\n-                                           map_node).as_slice())\n+                                           map_node)[])\n                 }\n             }\n         }\n         ast_map::NodeStructCtor(struct_def) => {\n             let d = mk_lldecl(abi::Rust);\n             set_inline_hint(d);\n             base::trans_tuple_struct(ccx,\n-                                     struct_def.fields.as_slice(),\n+                                     struct_def.fields[],\n                                      struct_def.ctor_id.expect(\"ast-mapped tuple struct \\\n                                                                 didn't have a ctor id\"),\n                                      psubsts,\n@@ -267,7 +267,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ast_map::NodePat(..) |\n         ast_map::NodeLocal(..) => {\n             ccx.sess().bug(format!(\"can't monomorphize a {}\",\n-                                   map_node).as_slice())\n+                                   map_node)[])\n         }\n     };\n "}, {"sha": "45a2a343066c46e5aca02906e2f3473eb14b8a3d", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -102,7 +102,7 @@ impl Type {\n     }\n \n     pub fn int(ccx: &CrateContext) -> Type {\n-        match ccx.tcx().sess.target.target.target_word_size.as_slice() {\n+        match ccx.tcx().sess.target.target.target_word_size[] {\n             \"32\" => Type::i32(ccx),\n             \"64\" => Type::i64(ccx),\n             tws => panic!(\"Unsupported target word size for int: {}\", tws),"}, {"sha": "499195b51b9cea434f62de0288269d166d17b864", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -137,7 +137,7 @@ pub fn type_of_rust_fn<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let input_tys = inputs.iter().map(|&arg_ty| type_of_explicit_arg(cx, arg_ty));\n     atys.extend(input_tys);\n \n-    Type::func(atys.as_slice(), &lloutputtype)\n+    Type::func(atys[], &lloutputtype)\n }\n \n // Given a function type and a count of ty params, construct an llvm type\n@@ -150,7 +150,9 @@ pub fn type_of_fn_from_ty<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, fty: Ty<'tcx>)\n                             f.sig.0.output,\n                             f.abi)\n         }\n-        ty::ty_bare_fn(ref f) => {\n+        ty::ty_bare_fn(_, ref f) => {\n+            // FIXME(#19925) once fn item types are\n+            // zero-sized, we'll need to do something here\n             if f.abi == abi::Rust || f.abi == abi::RustCall {\n                 type_of_rust_fn(cx,\n                                 None,\n@@ -187,7 +189,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n     let llsizingty = match t.sty {\n         _ if !ty::lltype_is_sized(cx.tcx(), t) => {\n             cx.sess().bug(format!(\"trying to take the sizing type of {}, an unsized type\",\n-                                  ppaux::ty_to_string(cx.tcx(), t)).as_slice())\n+                                  ppaux::ty_to_string(cx.tcx(), t))[])\n         }\n \n         ty::ty_bool => Type::bool(cx),\n@@ -241,7 +243,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n \n         ty::ty_infer(..) | ty::ty_param(..) | ty::ty_err(..) => {\n             cx.sess().bug(format!(\"fictitious type {} in sizing_type_of()\",\n-                                  ppaux::ty_to_string(cx.tcx(), t)).as_slice())\n+                                  ppaux::ty_to_string(cx.tcx(), t))[])\n         }\n         ty::ty_vec(_, None) | ty::ty_trait(..) | ty::ty_str => panic!(\"unreachable\")\n     };\n@@ -318,7 +320,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n           let repr = adt::represent_type(cx, t);\n           let tps = substs.types.get_slice(subst::TypeSpace);\n           let name = llvm_type_name(cx, an_enum, did, tps);\n-          adt::incomplete_type_of(cx, &*repr, name.as_slice())\n+          adt::incomplete_type_of(cx, &*repr, name[])\n       }\n       ty::ty_unboxed_closure(did, _, ref substs) => {\n           // Only create the named struct, but don't fill it in. We\n@@ -329,7 +331,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n           // contents of the VecPerParamSpace to to construct the llvm\n           // name\n           let name = llvm_type_name(cx, an_unboxed_closure, did, substs.types.as_slice());\n-          adt::incomplete_type_of(cx, &*repr, name.as_slice())\n+          adt::incomplete_type_of(cx, &*repr, name[])\n       }\n \n       ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) | ty::ty_ptr(ty::mt{ty, ..}) => {\n@@ -364,7 +366,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n \n       ty::ty_str => Type::i8(cx),\n \n-      ty::ty_bare_fn(_) => {\n+      ty::ty_bare_fn(..) => {\n           type_of_fn_from_ty(cx, t).ptr_to()\n       }\n       ty::ty_closure(_) => {\n@@ -389,7 +391,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n               let repr = adt::represent_type(cx, t);\n               let tps = substs.types.get_slice(subst::TypeSpace);\n               let name = llvm_type_name(cx, a_struct, did, tps);\n-              adt::incomplete_type_of(cx, &*repr, name.as_slice())\n+              adt::incomplete_type_of(cx, &*repr, name[])\n           }\n       }\n \n@@ -408,7 +410,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n           }\n           ty::ty_trait(..) => Type::opaque_trait(cx),\n           _ => cx.sess().bug(format!(\"ty_open with sized type: {}\",\n-                                     ppaux::ty_to_string(cx.tcx(), t)).as_slice())\n+                                     ppaux::ty_to_string(cx.tcx(), t))[])\n       },\n \n       ty::ty_infer(..) => cx.sess().bug(\"type_of with ty_infer\"),"}, {"sha": "ff577d2d45d4bdf001e32a4a46aaed8d31645dbd", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -168,7 +168,7 @@ pub fn opt_ast_region_to_region<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                     format!(\"`{}`\", name)\n                                 } else {\n                                     format!(\"one of `{}`'s {} elided lifetimes\", name, n)\n-                                }.as_slice());\n+                                }[]);\n \n                                 if len == 2 && i == 0 {\n                                     m.push_str(\" or \");\n@@ -323,7 +323,7 @@ fn create_substs_for_ast_path<'tcx,AC,RS>(\n                                    format!(\"wrong number of type arguments: {} {}, found {}\",\n                                            expected,\n                                            required_ty_param_count,\n-                                           supplied_ty_param_count).as_slice());\n+                                           supplied_ty_param_count)[]);\n     } else if supplied_ty_param_count > formal_ty_param_count {\n         let expected = if required_ty_param_count < formal_ty_param_count {\n             \"expected at most\"\n@@ -334,7 +334,7 @@ fn create_substs_for_ast_path<'tcx,AC,RS>(\n                                    format!(\"wrong number of type arguments: {} {}, found {}\",\n                                            expected,\n                                            formal_ty_param_count,\n-                                           supplied_ty_param_count).as_slice());\n+                                           supplied_ty_param_count)[]);\n     }\n \n     if supplied_ty_param_count > required_ty_param_count\n@@ -723,7 +723,7 @@ pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                         .sess\n                         .span_bug(ast_ty.span,\n                                   format!(\"unbound path {}\",\n-                                          path.repr(this.tcx())).as_slice())\n+                                          path.repr(this.tcx()))[])\n                 }\n                 Some(&d) => d\n             };\n@@ -798,14 +798,14 @@ fn ast_ty_to_trait_ref<'tcx,AC,RS>(this: &AC,\n             match ty.node {\n                 ast::TyRptr(None, ref mut_ty) => {\n                     span_note!(this.tcx().sess, ty.span,\n-                               \"perhaps you meant `&{}({} +{})`? (per RFC 248)\",\n+                               \"perhaps you meant `&{}({} +{})`? (per RFC 438)\",\n                                ppaux::mutability_to_string(mut_ty.mutbl),\n                                pprust::ty_to_string(&*mut_ty.ty),\n                                pprust::bounds_to_string(bounds));\n                 }\n                ast::TyRptr(Some(ref lt), ref mut_ty) => {\n                     span_note!(this.tcx().sess, ty.span,\n-                               \"perhaps you meant `&{} {}({} +{})`? (per RFC 248)\",\n+                               \"perhaps you meant `&{} {}({} +{})`? (per RFC 438)\",\n                                pprust::lifetime_to_string(lt),\n                                ppaux::mutability_to_string(mut_ty.mutbl),\n                                pprust::ty_to_string(&*mut_ty.ty),\n@@ -814,7 +814,7 @@ fn ast_ty_to_trait_ref<'tcx,AC,RS>(this: &AC,\n \n                 _ => {\n                     span_note!(this.tcx().sess, ty.span,\n-                               \"perhaps you forgot parentheses? (per RFC 248)\");\n+                               \"perhaps you forgot parentheses? (per RFC 438)\");\n                 }\n             }\n             Err(ErrorReported)\n@@ -920,10 +920,10 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                 ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty), None)\n             }\n             ast::TyObjectSum(ref ty, ref bounds) => {\n-                match ast_ty_to_trait_ref(this, rscope, &**ty, bounds.as_slice()) {\n+                match ast_ty_to_trait_ref(this, rscope, &**ty, bounds[]) {\n                     Ok(trait_ref) => {\n                         trait_ref_to_object_type(this, rscope, ast_ty.span,\n-                                                 trait_ref, bounds.as_slice())\n+                                                 trait_ref, bounds[])\n                     }\n                     Err(ErrorReported) => {\n                         ty::mk_err()\n@@ -954,7 +954,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                     tcx.sess.span_err(ast_ty.span,\n                                       \"variadic function must have C calling convention\");\n                 }\n-                ty::mk_bare_fn(tcx, ty_of_bare_fn(this, bf.unsafety, bf.abi, &*bf.decl))\n+                ty::mk_bare_fn(tcx, None, ty_of_bare_fn(this, bf.unsafety, bf.abi, &*bf.decl))\n             }\n             ast::TyClosure(ref f) => {\n                 // Use corresponding trait store to figure out default bounds\n@@ -977,15 +977,15 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                 ty::mk_closure(tcx, fn_decl)\n             }\n             ast::TyPolyTraitRef(ref bounds) => {\n-                conv_ty_poly_trait_ref(this, rscope, ast_ty.span, bounds.as_slice())\n+                conv_ty_poly_trait_ref(this, rscope, ast_ty.span, bounds[])\n             }\n             ast::TyPath(ref path, id) => {\n                 let a_def = match tcx.def_map.borrow().get(&id) {\n                     None => {\n                         tcx.sess\n                            .span_bug(ast_ty.span,\n                                      format!(\"unbound path {}\",\n-                                             path.repr(tcx)).as_slice())\n+                                             path.repr(tcx))[])\n                     }\n                     Some(&d) => d\n                 };\n@@ -1019,7 +1019,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                     def::DefMod(id) => {\n                         tcx.sess.span_fatal(ast_ty.span,\n                             format!(\"found module name used as a type: {}\",\n-                                    tcx.map.node_to_string(id.node)).as_slice());\n+                                    tcx.map.node_to_string(id.node))[]);\n                     }\n                     def::DefPrimTy(_) => {\n                         panic!(\"DefPrimTy arm missed in previous ast_ty_to_prim_ty call\");\n@@ -1038,7 +1038,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                                           .last()\n                                                           .unwrap()\n                                                           .identifier)\n-                                                  .get()).as_slice());\n+                                                  .get())[]);\n                         ty::mk_err()\n                     }\n                     def::DefAssociatedPath(typ, assoc_ident) => {\n@@ -1084,7 +1084,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                         tcx.sess.span_fatal(ast_ty.span,\n                                             format!(\"found value name used \\\n                                                      as a type: {}\",\n-                                                    a_def).as_slice());\n+                                                    a_def)[]);\n                     }\n                 }\n             }\n@@ -1112,7 +1112,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                             ast_ty.span,\n                             format!(\"expected constant expr for array \\\n                                      length: {}\",\n-                                    *r).as_slice());\n+                                    *r)[]);\n                     }\n                 }\n             }\n@@ -1235,7 +1235,7 @@ fn ty_of_method_or_bare_fn<'a, 'tcx, AC: AstConv<'tcx>>(\n     let input_params = if self_ty.is_some() {\n         decl.inputs.slice_from(1)\n     } else {\n-        decl.inputs.as_slice()\n+        decl.inputs[]\n     };\n     let input_tys = input_params.iter().map(|a| ty_of_arg(this, &rb, a, None));\n     let input_pats: Vec<String> = input_params.iter()\n@@ -1502,7 +1502,7 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx, AC, RS>(\n         this.tcx().sess.span_err(\n             b.trait_ref.path.span,\n             format!(\"only the builtin traits can be used \\\n-                     as closure or object bounds\").as_slice());\n+                     as closure or object bounds\")[]);\n     }\n \n     let region_bound = compute_region_bound(this,\n@@ -1572,7 +1572,7 @@ fn compute_opt_region_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n         tcx.sess.span_err(\n             span,\n             format!(\"ambiguous lifetime bound, \\\n-                     explicit lifetime bound required\").as_slice());\n+                     explicit lifetime bound required\")[]);\n     }\n     return Some(r);\n }\n@@ -1598,7 +1598,7 @@ fn compute_region_bound<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n                 None => {\n                     this.tcx().sess.span_err(\n                         span,\n-                        format!(\"explicit lifetime bound required\").as_slice());\n+                        format!(\"explicit lifetime bound required\")[]);\n                     ty::ReStatic\n                 }\n             }"}, {"sha": "d3b518ec2e3ab5489965686c268a1611a9f37370", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -113,7 +113,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         self.add_obligations(&pick, &method_bounds_substs, &method_bounds);\n \n         // Create the final `MethodCallee`.\n-        let fty = ty::mk_bare_fn(self.tcx(), ty::BareFnTy {\n+        let fty = ty::mk_bare_fn(self.tcx(), None, ty::BareFnTy {\n             sig: ty::Binder(method_sig),\n             unsafety: pick.method_ty.fty.unsafety,\n             abi: pick.method_ty.fty.abi.clone(),\n@@ -466,7 +466,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     fn fixup_derefs_on_method_receiver_if_necessary(&self,\n                                                     method_callee: &MethodCallee) {\n         let sig = match method_callee.ty.sty {\n-            ty::ty_bare_fn(ref f) => f.sig.clone(),\n+            ty::ty_bare_fn(_, ref f) => f.sig.clone(),\n             ty::ty_closure(ref f) => f.sig.clone(),\n             _ => return,\n         };"}, {"sha": "19776318c876d712f84587b19dc047cd3f4d5f0e", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -199,7 +199,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n                                                                        infer::FnCall,\n                                                                        &fn_sig).0;\n     let transformed_self_ty = fn_sig.inputs[0];\n-    let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n+    let fty = ty::mk_bare_fn(tcx, None, ty::BareFnTy {\n         sig: ty::Binder(fn_sig),\n         unsafety: bare_fn_ty.unsafety,\n         abi: bare_fn_ty.abi.clone(),\n@@ -269,7 +269,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n                                 span,\n                                 format!(\n                                     \"trait method is &self but first arg is: {}\",\n-                                    transformed_self_ty.repr(fcx.tcx())).as_slice());\n+                                    transformed_self_ty.repr(fcx.tcx()))[]);\n                         }\n                     }\n                 }\n@@ -279,7 +279,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n                         span,\n                         format!(\n                             \"unexpected explicit self type in operator method: {}\",\n-                            method_ty.explicit_self).as_slice());\n+                            method_ty.explicit_self)[]);\n                 }\n             }\n         }\n@@ -333,7 +333,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             if is_field {\n                 cx.sess.span_note(span,\n                     format!(\"use `(s.{0})(...)` if you meant to call the \\\n-                            function stored in the `{0}` field\", method_ustring).as_slice());\n+                            function stored in the `{0}` field\", method_ustring)[]);\n             }\n \n             if static_sources.len() > 0 {"}, {"sha": "961b664e404caeed7a5940a0a203eb8e045ff4ff", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -557,7 +557,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                     self.tcx().sess.span_bug(\n                         self.span,\n                         format!(\"No entry for unboxed closure: {}\",\n-                                closure_def_id.repr(self.tcx())).as_slice());\n+                                closure_def_id.repr(self.tcx()))[]);\n                 }\n             };\n "}, {"sha": "3139a17f9989eacf022405208c52e303a1742e55", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 71, "deletions": 51, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -399,7 +399,7 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let fty = fty.subst(ccx.tcx, &param_env.free_substs);\n \n     match fty.sty {\n-        ty::ty_bare_fn(ref fn_ty) => {\n+        ty::ty_bare_fn(_, ref fn_ty) => {\n             let inh = Inherited::new(ccx.tcx, param_env);\n             let fcx = check_fn(ccx, fn_ty.unsafety, id, &fn_ty.sig,\n                                decl, id, body, &inh);\n@@ -518,7 +518,7 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n     // The free region references will be bound the node_id of the body block.\n     let fn_sig = liberate_late_bound_regions(tcx, CodeExtent::from_node_id(body.id), fn_sig);\n \n-    let arg_tys = fn_sig.inputs.as_slice();\n+    let arg_tys = fn_sig.inputs[];\n     let ret_ty = fn_sig.output;\n \n     debug!(\"check_fn(arg_tys={}, ret_ty={}, fn_id={})\",\n@@ -616,7 +616,7 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n       ast::ItemEnum(ref enum_definition, _) => {\n         check_enum_variants(ccx,\n                             it.span,\n-                            enum_definition.variants.as_slice(),\n+                            enum_definition.variants[],\n                             it.id);\n       }\n       ast::ItemFn(ref decl, _, _, _, ref body) => {\n@@ -915,7 +915,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                         but not in the trait\",\n                         token::get_name(trait_m.name),\n                         ppaux::explicit_self_category_to_str(\n-                            &impl_m.explicit_self)).as_slice());\n+                            &impl_m.explicit_self))[]);\n             return;\n         }\n         (_, &ty::StaticExplicitSelfCategory) => {\n@@ -925,7 +925,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                         but not in the impl\",\n                         token::get_name(trait_m.name),\n                         ppaux::explicit_self_category_to_str(\n-                            &trait_m.explicit_self)).as_slice());\n+                            &trait_m.explicit_self))[]);\n             return;\n         }\n         _ => {\n@@ -1132,9 +1132,9 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     }\n \n     // Compute skolemized form of impl and trait method tys.\n-    let impl_fty = ty::mk_bare_fn(tcx, impl_m.fty.clone());\n+    let impl_fty = ty::mk_bare_fn(tcx, None, impl_m.fty.clone());\n     let impl_fty = impl_fty.subst(tcx, &impl_to_skol_substs);\n-    let trait_fty = ty::mk_bare_fn(tcx, trait_m.fty.clone());\n+    let trait_fty = ty::mk_bare_fn(tcx, None, trait_m.fty.clone());\n     let trait_fty = trait_fty.subst(tcx, &trait_to_skol_substs);\n \n     // Check the impl method type IM is a subtype of the trait method\n@@ -1229,7 +1229,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                 span,\n                 format!(\"lifetime parameters or bounds on method `{}` do \\\n                          not match the trait declaration\",\n-                        token::get_name(impl_m.name)).as_slice());\n+                        token::get_name(impl_m.name))[]);\n             return false;\n         }\n \n@@ -1281,7 +1281,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                          from its counterpart `{}` \\\n                          declared in the trait\",\n                         impl_param.name.user_string(tcx),\n-                        trait_param.name.user_string(tcx)).as_slice());\n+                        trait_param.name.user_string(tcx))[]);\n                 true\n             } else {\n                 false\n@@ -1291,14 +1291,14 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                 tcx.sess.span_note(\n                     span,\n                     format!(\"the impl is missing the following bounds: `{}`\",\n-                            missing.user_string(tcx)).as_slice());\n+                            missing.user_string(tcx))[]);\n             }\n \n             if extra.len() != 0 {\n                 tcx.sess.span_note(\n                     span,\n                     format!(\"the impl has the following extra bounds: `{}`\",\n-                            extra.user_string(tcx)).as_slice());\n+                            extra.user_string(tcx))[]);\n             }\n \n             if err {\n@@ -1389,14 +1389,18 @@ fn check_cast(fcx: &FnCtxt,\n         }, t_e, None);\n     }\n \n+    let t_e_is_bare_fn_item = ty::type_is_bare_fn_item(t_e);\n+\n     let t_1_is_scalar = ty::type_is_scalar(t_1);\n     let t_1_is_char = ty::type_is_char(t_1);\n     let t_1_is_bare_fn = ty::type_is_bare_fn(t_1);\n     let t_1_is_float = ty::type_is_floating_point(t_1);\n \n     // casts to scalars other than `char` and `bare fn` are trivial\n     let t_1_is_trivial = t_1_is_scalar && !t_1_is_char && !t_1_is_bare_fn;\n-    if ty::type_is_c_like_enum(fcx.tcx(), t_e) && t_1_is_trivial {\n+    if t_e_is_bare_fn_item && t_1_is_bare_fn {\n+        demand::coerce(fcx, e.span, t_1, &*e);\n+    } else if ty::type_is_c_like_enum(fcx.tcx(), t_e) && t_1_is_trivial {\n         if t_1_is_float || ty::type_is_unsafe_ptr(t_1) {\n             fcx.type_error_message(span, |actual| {\n                 format!(\"illegal cast; cast through an \\\n@@ -1557,7 +1561,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.tcx().sess.span_bug(\n                     span,\n                     format!(\"no type for local variable {}\",\n-                            nid).as_slice());\n+                            nid)[]);\n             }\n         }\n     }\n@@ -1634,7 +1638,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                        span: Span,\n                                        adj: &ty::AutoAdjustment<'tcx>) {\n         match *adj {\n-            ty::AdjustAddEnv(..) => { }\n+            ty::AdjustAddEnv(..) |\n+            ty::AdjustReifyFnPointer(..) => {\n+            }\n             ty::AdjustDerefRef(ref d_r) => {\n                 match d_r.autoref {\n                     Some(ref a_r) => {\n@@ -1805,7 +1811,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Some(&t) => t,\n             None => {\n                 self.tcx().sess.bug(format!(\"no type for expr in fcx {}\",\n-                                            self.tag()).as_slice());\n+                                            self.tag())[]);\n             }\n         }\n     }\n@@ -1835,7 +1841,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.tcx().sess.bug(\n                     format!(\"no type for node {}: {} in fcx {}\",\n                             id, self.tcx().map.node_to_string(id),\n-                            self.tag()).as_slice());\n+                            self.tag())[]);\n             }\n         }\n     }\n@@ -2043,7 +2049,7 @@ fn try_overloaded_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // Bail out if the callee is a bare function or a closure. We check those\n     // manually.\n     match structurally_resolved_type(fcx, callee.span, callee_type).sty {\n-        ty::ty_bare_fn(_) | ty::ty_closure(_) => return false,\n+        ty::ty_bare_fn(..) | ty::ty_closure(_) => return false,\n         _ => {}\n     }\n \n@@ -2392,7 +2398,7 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         Ok(trait_did) => trait_did,\n         Err(ref err_string) => {\n             fcx.tcx().sess.span_err(iterator_expr.span,\n-                                    err_string.as_slice());\n+                                    err_string[]);\n             return ty::mk_err()\n         }\n     };\n@@ -2419,7 +2425,7 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                         format!(\"`for` loop expression has type `{}` which does \\\n                                                 not implement the `Iterator` trait; \\\n                                                 maybe try .iter()\",\n-                                                ty_string).as_slice());\n+                                                ty_string)[]);\n             }\n             ty::mk_err()\n         }\n@@ -2457,7 +2463,7 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                             format!(\"`next` method of the `Iterator` \\\n                                                     trait has an unexpected type `{}`\",\n                                                     fcx.infcx().ty_to_string(return_type))\n-                                            .as_slice());\n+                                            []);\n                     ty::mk_err()\n                 }\n             }\n@@ -2484,7 +2490,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n         check_argument_types(fcx,\n                              sp,\n-                             err_inputs.as_slice(),\n+                             err_inputs[],\n                              callee_expr,\n                              args_no_rcvr,\n                              autoref_args,\n@@ -2493,7 +2499,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         ty::FnConverging(ty::mk_err())\n     } else {\n         match method_fn_ty.sty {\n-            ty::ty_bare_fn(ref fty) => {\n+            ty::ty_bare_fn(_, ref fty) => {\n                 // HACK(eddyb) ignore self in the definition (see above).\n                 check_argument_types(fcx,\n                                      sp,\n@@ -2921,7 +2927,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         });\n \n         let fn_sig = match fn_ty.sty {\n-            ty::ty_bare_fn(ty::BareFnTy {ref sig, ..}) |\n+            ty::ty_bare_fn(_, ty::BareFnTy {ref sig, ..}) |\n             ty::ty_closure(box ty::ClosureTy {ref sig, ..}) => sig,\n             _ => {\n                 fcx.type_error_message(call_expr.span, |actual| {\n@@ -2941,7 +2947,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         // Call the generic checker.\n         check_argument_types(fcx,\n                              call_expr.span,\n-                             fn_sig.inputs.as_slice(),\n+                             fn_sig.inputs[],\n                              f,\n                              args,\n                              AutorefArgs::No,\n@@ -3306,7 +3312,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     ty::ty_struct(base_id, ref substs) => {\n                         debug!(\"struct named {}\", ppaux::ty_to_string(tcx, base_t));\n                         let fields = ty::lookup_struct_fields(tcx, base_id);\n-                        lookup_field_ty(tcx, base_id, fields.as_slice(),\n+                        lookup_field_ty(tcx, base_id, fields[],\n                                         field.node.name, &(*substs))\n                     }\n                     _ => None\n@@ -3369,7 +3375,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                         if tuple_like {\n                             debug!(\"tuple struct named {}\", ppaux::ty_to_string(tcx, base_t));\n                             let fields = ty::lookup_struct_fields(tcx, base_id);\n-                            lookup_tup_field_ty(tcx, base_id, fields.as_slice(),\n+                            lookup_tup_field_ty(tcx, base_id, fields[],\n                                                 idx.node, &(*substs))\n                         } else {\n                             None\n@@ -3418,7 +3424,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                 substitutions: subst::Substs<'tcx>,\n                                                 field_types: &[ty::field_ty],\n                                                 ast_fields: &[ast::Field],\n-                                                check_completeness: bool)  {\n+                                                check_completeness: bool,\n+                                                enum_id_opt: Option<ast::DefId>)  {\n         let tcx = fcx.ccx.tcx;\n \n         let mut class_field_map = FnvHashMap::new();\n@@ -3437,13 +3444,24 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             match pair {\n                 None => {\n                     fcx.type_error_message(\n-                      field.ident.span,\n-                      |actual| {\n-                          format!(\"structure `{}` has no field named `{}`\",\n-                                  actual, token::get_ident(field.ident.node))\n-                      },\n-                      struct_ty,\n-                      None);\n+                        field.ident.span,\n+                        |actual| match enum_id_opt {\n+                            Some(enum_id) => {\n+                                let variant_type = ty::enum_variant_with_id(tcx,\n+                                                                            enum_id,\n+                                                                            class_id);\n+                                format!(\"struct variant `{}::{}` has no field named `{}`\",\n+                                        actual, variant_type.name.as_str(),\n+                                        token::get_ident(field.ident.node))\n+                            }\n+                            None => {\n+                                format!(\"structure `{}` has no field named `{}`\",\n+                                        actual,\n+                                        token::get_ident(field.ident.node))\n+                            }\n+                        },\n+                        struct_ty,\n+                        None);\n                     error_happened = true;\n                 }\n                 Some((_, true)) => {\n@@ -3522,9 +3540,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                        class_id,\n                                        id,\n                                        struct_substs,\n-                                       class_fields.as_slice(),\n+                                       class_fields[],\n                                        fields,\n-                                       base_expr.is_none());\n+                                       base_expr.is_none(),\n+                                       None);\n         if ty::type_is_error(fcx.node_ty(id)) {\n             struct_type = ty::mk_err();\n         }\n@@ -3564,9 +3583,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                        variant_id,\n                                        id,\n                                        substitutions,\n-                                       variant_fields.as_slice(),\n+                                       variant_fields[],\n                                        fields,\n-                                       true);\n+                                       true,\n+                                       Some(enum_id));\n         fcx.write_ty(id, enum_type);\n     }\n \n@@ -3861,7 +3881,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n \n         let lhs_ty = fcx.expr_ty(&**lhs);\n-        check_expr_has_type(fcx, &**rhs, lhs_ty);\n+        check_expr_coercable_to_type(fcx, &**rhs, lhs_ty);\n         let rhs_ty = fcx.expr_ty(&**rhs);\n \n         fcx.require_expr_have_sized_type(&**lhs, traits::AssignmentLhsSized);\n@@ -3936,8 +3956,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           let f_ty = fcx.expr_ty(&**f);\n \n           let args: Vec<_> = args.iter().map(|x| x).collect();\n-          if !try_overloaded_call(fcx, expr, &**f, f_ty, args.as_slice()) {\n-              check_call(fcx, expr, &**f, args.as_slice());\n+          if !try_overloaded_call(fcx, expr, &**f, f_ty, args[]) {\n+              check_call(fcx, expr, &**f, args[]);\n               let args_err = args.iter().fold(false,\n                  |rest_err, a| {\n                      // is this not working?\n@@ -3949,7 +3969,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           }\n       }\n       ast::ExprMethodCall(ident, ref tps, ref args) => {\n-        check_method_call(fcx, expr, ident, args.as_slice(), tps.as_slice(), lvalue_pref);\n+        check_method_call(fcx, expr, ident, args[], tps[], lvalue_pref);\n         let arg_tys = args.iter().map(|a| fcx.expr_ty(&**a));\n         let  args_err = arg_tys.fold(false,\n              |rest_err, a| {\n@@ -4074,7 +4094,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let struct_id = match def {\n             Some(def::DefVariant(enum_id, variant_id, true)) => {\n                 check_struct_enum_variant(fcx, id, expr.span, enum_id,\n-                                          variant_id, fields.as_slice());\n+                                          variant_id, fields[]);\n                 enum_id\n             }\n             Some(def::DefTrait(def_id)) => {\n@@ -4083,7 +4103,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     pprust::path_to_string(path));\n                 check_struct_fields_on_error(fcx,\n                                              id,\n-                                             fields.as_slice(),\n+                                             fields[],\n                                              base_expr);\n                 def_id\n             },\n@@ -4096,7 +4116,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                  id,\n                                                  expr.span,\n                                                  struct_did,\n-                                                 fields.as_slice(),\n+                                                 fields[],\n                                                  base_expr.as_ref().map(|e| &**e));\n                     }\n                     _ => {\n@@ -4105,7 +4125,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                             pprust::path_to_string(path));\n                         check_struct_fields_on_error(fcx,\n                                                      id,\n-                                                     fields.as_slice(),\n+                                                     fields[],\n                                                      base_expr);\n                     }\n                 }\n@@ -4146,7 +4166,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                          fcx.infcx()\n                                             .ty_to_string(\n                                                 actual_structure_type),\n-                                         type_error_description).as_slice());\n+                                         type_error_description)[]);\n                     ty::note_and_explain_type_err(tcx, &type_error);\n                 }\n             }\n@@ -4755,7 +4775,7 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n     }\n \n     let hint = *ty::lookup_repr_hints(ccx.tcx, ast::DefId { krate: ast::LOCAL_CRATE, node: id })\n-                    .as_slice().get(0).unwrap_or(&attr::ReprAny);\n+                    [].get(0).unwrap_or(&attr::ReprAny);\n \n     if hint != attr::ReprAny && vs.len() <= 1 {\n         if vs.len() == 1 {\n@@ -5438,7 +5458,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"get_tydesc\" => {\n               let tydesc_ty = match ty::get_tydesc_ty(ccx.tcx) {\n                   Ok(t) => t,\n-                  Err(s) => { tcx.sess.span_fatal(it.span, s.as_slice()); }\n+                  Err(s) => { tcx.sess.span_fatal(it.span, s[]); }\n               };\n               let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {\n                   ty: tydesc_ty,\n@@ -5454,7 +5474,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                                 ty::mk_struct(ccx.tcx, did,\n                                               subst::Substs::empty())),\n                     Err(msg) => {\n-                        tcx.sess.span_fatal(it.span, msg.as_slice());\n+                        tcx.sess.span_fatal(it.span, msg[]);\n                     }\n                 }\n             },\n@@ -5627,7 +5647,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n         };\n         (n_tps, inputs, ty::FnConverging(output))\n     };\n-    let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n+    let fty = ty::mk_bare_fn(tcx, None, ty::BareFnTy {\n         unsafety: ast::Unsafety::Unsafe,\n         abi: abi::RustIntrinsic,\n         sig: ty::Binder(FnSig {"}, {"sha": "22502c0dd1a1f6b836eb90008e05df5934c98ec8", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -251,7 +251,7 @@ fn region_of_def(fcx: &FnCtxt, def: def::Def) -> ty::Region {\n         }\n         _ => {\n             tcx.sess.bug(format!(\"unexpected def in region_of_def: {}\",\n-                                 def).as_slice())\n+                                 def)[])\n         }\n     }\n }\n@@ -345,13 +345,13 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n             Some(f) => f,\n             None => {\n                 self.tcx().sess.bug(\n-                    format!(\"No fn-sig entry for id={}\", id).as_slice());\n+                    format!(\"No fn-sig entry for id={}\", id)[]);\n             }\n         };\n \n         let len = self.region_param_pairs.len();\n-        self.relate_free_regions(fn_sig.as_slice(), body.id);\n-        link_fn_args(self, CodeExtent::from_node_id(body.id), fn_decl.inputs.as_slice());\n+        self.relate_free_regions(fn_sig[], body.id);\n+        link_fn_args(self, CodeExtent::from_node_id(body.id), fn_decl.inputs[]);\n         self.visit_block(body);\n         self.visit_region_obligations(body.id);\n         self.region_param_pairs.truncate(len);\n@@ -738,7 +738,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n         }\n \n         ast::ExprMatch(ref discr, ref arms, _) => {\n-            link_match(rcx, &**discr, arms.as_slice());\n+            link_match(rcx, &**discr, arms[]);\n \n             visit::walk_expr(rcx, expr);\n         }\n@@ -1186,7 +1186,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                     ty::ty_rptr(r, ref m) => (m.mutbl, r),\n                     _ => rcx.tcx().sess.span_bug(deref_expr.span,\n                             format!(\"bad overloaded deref type {}\",\n-                                    method.ty.repr(rcx.tcx())).as_slice())\n+                                    method.ty.repr(rcx.tcx()))[])\n                 };\n                 {\n                     let mc = mc::MemCategorizationContext::new(rcx);\n@@ -1560,7 +1560,7 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                         span,\n                         format!(\"Illegal upvar id: {}\",\n                                 upvar_id.repr(\n-                                    rcx.tcx())).as_slice());\n+                                    rcx.tcx()))[]);\n                 }\n             }\n         }"}, {"sha": "eaf638e388e3505d330d71f390acafab409cd2ec", "filename": "src/librustc_typeck/check/regionmanip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -138,7 +138,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n             ty::ty_open(_) => {\n                 self.tcx.sess.bug(\n                     format!(\"Unexpected type encountered while doing wf check: {}\",\n-                            ty.repr(self.tcx)).as_slice());\n+                            ty.repr(self.tcx))[]);\n             }\n         }\n     }"}, {"sha": "e23bf46b564b37dba9296a5b87cce0aab9edc3cf", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -77,15 +77,15 @@ pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 source_expr.span,\n                 format!(\"can only cast an boxed pointer \\\n                          to a boxed object, not a {}\",\n-                        ty::ty_sort_string(fcx.tcx(), source_ty)).as_slice());\n+                        ty::ty_sort_string(fcx.tcx(), source_ty))[]);\n         }\n \n         (_, &ty::ty_rptr(..)) => {\n             fcx.ccx.tcx.sess.span_err(\n                 source_expr.span,\n                 format!(\"can only cast a &-pointer \\\n                          to an &-object, not a {}\",\n-                        ty::ty_sort_string(fcx.tcx(), source_ty)).as_slice());\n+                        ty::ty_sort_string(fcx.tcx(), source_ty))[]);\n         }\n \n         _ => {\n@@ -164,7 +164,7 @@ fn check_object_safety_inner<'tcx>(tcx: &ty::ctxt<'tcx>,\n             trait_name);\n \n         for msg in errors {\n-            tcx.sess.note(msg.as_slice());\n+            tcx.sess.note(msg[]);\n         }\n     }\n \n@@ -455,7 +455,7 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     format!(\n                         \"unable to infer enough type information about `{}`; type annotations \\\n                          required\",\n-                        self_ty.user_string(fcx.tcx())).as_slice());\n+                        self_ty.user_string(fcx.tcx()))[]);\n             } else {\n                 fcx.tcx().sess.span_err(\n                     obligation.cause.span,\n@@ -464,7 +464,7 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                          locate the impl of the trait `{}` for \\\n                          the type `{}`; type annotations required\",\n                         trait_ref.user_string(fcx.tcx()),\n-                        self_ty.user_string(fcx.tcx())).as_slice());\n+                        self_ty.user_string(fcx.tcx()))[]);\n                 note_obligation_cause(fcx, obligation);\n             }\n         }\n@@ -477,7 +477,7 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                  cannot locate the impl of the trait `{}` for \\\n                  the type `{}`\",\n                 trait_ref.user_string(fcx.tcx()),\n-                self_ty.user_string(fcx.tcx())).as_slice());\n+                self_ty.user_string(fcx.tcx()))[]);\n     }\n }\n "}, {"sha": "a2fb44fff796fa5573594115888e5bbe8f0c39ed", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -355,7 +355,7 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n \n                 self.fold_substs(substs);\n             }\n-            ty::ty_bare_fn(ty::BareFnTy{sig: ref fn_sig, ..}) |\n+            ty::ty_bare_fn(_, ty::BareFnTy{sig: ref fn_sig, ..}) |\n             ty::ty_closure(box ty::ClosureTy{sig: ref fn_sig, ..}) => {\n                 self.binding_count += 1;\n "}, {"sha": "b123d97d8970c42945f1ed8142defbd951ba8de2", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -15,7 +15,6 @@ use self::ResolveReason::*;\n \n use astconv::AstConv;\n use check::FnCtxt;\n-use middle::def;\n use middle::pat_util;\n use middle::ty::{mod, Ty, MethodCall, MethodCallee};\n use middle::ty_fold::{TypeFolder,TypeFoldable};\n@@ -267,25 +266,12 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             Some(adjustment) => {\n                 let adj_object = ty::adjust_is_object(&adjustment);\n                 let resolved_adjustment = match adjustment {\n-                    ty::AdjustAddEnv(store) => {\n-                        // FIXME(eddyb) #2190 Allow only statically resolved\n-                        // bare functions to coerce to a closure to avoid\n-                        // constructing (slower) indirect call wrappers.\n-                        match self.tcx().def_map.borrow().get(&id) {\n-                            Some(&def::DefFn(..)) |\n-                            Some(&def::DefStaticMethod(..)) |\n-                            Some(&def::DefVariant(..)) |\n-                            Some(&def::DefStruct(_)) => {\n-                            }\n-                            _ => {\n-                                span_err!(self.tcx().sess, reason.span(self.tcx()), E0100,\n-                                    \"cannot coerce non-statically resolved bare fn to closure\");\n-                                span_help!(self.tcx().sess, reason.span(self.tcx()),\n-                                    \"consider embedding the function in a closure\");\n-                            }\n-                        }\n+                    ty::AdjustAddEnv(def_id, store) => {\n+                        ty::AdjustAddEnv(def_id, self.resolve(&store, reason))\n+                    }\n \n-                        ty::AdjustAddEnv(self.resolve(&store, reason))\n+                    ty::AdjustReifyFnPointer(def_id) => {\n+                        ty::AdjustReifyFnPointer(def_id)\n                     }\n \n                     ty::AdjustDerefRef(adj) => {"}, {"sha": "b08db39c18984308eafc2b8042129a0e99bfdea9", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "patch": "@@ -235,7 +235,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             // impl, plus its own.\n             let new_polytype = ty::Polytype {\n                 generics: new_method_ty.generics.clone(),\n-                ty: ty::mk_bare_fn(tcx, new_method_ty.fty.clone())\n+                ty: ty::mk_bare_fn(tcx, Some(new_did), new_method_ty.fty.clone())\n             };\n             debug!(\"new_polytype={}\", new_polytype.repr(tcx));\n \n@@ -488,15 +488,15 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                                  format!(\"the trait `Copy` may not be \\\n                                           implemented for this type; field \\\n                                           `{}` does not implement `Copy`\",\n-                                         token::get_name(name)).as_slice())\n+                                         token::get_name(name))[])\n                 }\n                 Err(ty::VariantDoesNotImplementCopy(name)) => {\n                     tcx.sess\n                        .span_err(span,\n                                  format!(\"the trait `Copy` may not be \\\n                                           implemented for this type; variant \\\n                                           `{}` does not implement `Copy`\",\n-                                         token::get_name(name)).as_slice())\n+                                         token::get_name(name))[])\n                 }\n                 Err(ty::TypeIsStructural) => {\n                     tcx.sess"}, {"sha": "8380ed349cb3d470a934ceb57fe902fd677e692d", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "65dff774528a7d7be5013faf729debda4eb6c2c5", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "8e69bc42d9a0d03714daae21bc12461cfb3917d5", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "2bc93ade7774e87d3757efae574f9d1081c5a647", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "0dd6c2a7ce7305b6fa17e1d25e6e83095e03a1f6", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "7f7c055062aaadde84dd878202eb667f7525f2b5", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "25a20e5998bd8ff8a6d80bd9219c07ba229af60e", "filename": "src/librustdoc/externalfiles.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "a2d5530692c11cbe5171e1502716d8e057b04cd1", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "c936f6a0819d2c797dc959e66a156a49015aeea1", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "f7984b8973cc6a0968cf6c2d84cc7a7ea4430190", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "dc31cfae99cb41a99fefcf0cd5e9335bfc5cb230", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "8dfb352d0288f8cc9773ef47b449ed3943cc9e09", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "9a67b479106eed4fa762736e9cd986299219b4ed", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "2e3adf8e767873181fd74af7dcba70f1fea941e4", "filename": "src/librustdoc/stability_summary.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustdoc%2Fstability_summary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibrustdoc%2Fstability_summary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fstability_summary.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "7df5590fb40e2e1e07c0b9a7b778d26038e13c5c", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 141, "deletions": 110, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "4a2bbbeec03a48d26a501e30006e59e8811514d2", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "558f9e603e15989fd8ccbd1607761883ffe6d235", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "2c49beca98de60aafdc6e3b5a73d4304ca25a172", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "fb44961017fcdf4d753f710e90a732424603beca", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "d749cd77cef2dc0b385ae47a0d1ea9ba5ab2c226", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "6d83d5510b35735603d535dd01974c68bca04cfa", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 120, "deletions": 6, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "8f2152c5a9ded3ce48be6add6520cf17df4c6b8b", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "368abe7cb1244a55bf818df512377a80fe69fa35", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "cd7d9aacc90109bb8a33d2d1f6852d37bd4a40a5", "filename": "src/libstd/error.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "7010eae6dba0dba03e285e707d6232fc07451661", "filename": "src/libstd/failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffailure.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "233ad78109382d1275fd47742254d9e480b81a1b", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "89a649d55bdc4ec50e0dbe55d887be6039317c88", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "4a0a393642439c0d6a726d338065d8108cc7ba03", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "1c5ceaf24506f0ae07ffc35bb78b5a7f04b2543c", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "d6331f3c718ac4c9d7b1aeaa1ba04893f593eb19", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "ceb9a4102f6353c385743e0a68f40b1650aa2566", "filename": "src/libstd/os.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "30f3f56bc1c10be7fd520fc9e175f5fbadf5f45b", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "f0a00b421c3a34d55d5e35e8cd0e3d6f4240a459", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "7d10188c437e245701f602553f7acd48ffc67e3b", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 84, "deletions": 78, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "49b888d17f47f64f661cd0ec8264e514118c3c34", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "775e9bb526f7cbc84a300e47b4385b386e6d1654", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "d64336569c6e9e98eac3453279a6cf965af66c19", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "eb15a7ba378e0e48d857b1f2fce5162071f62a2c", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "d8cd8455deb5cfdf39b052d91b0e8b13423fc181", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "1d646eb06b16774f2fd00705972f2e7cef663d86", "filename": "src/libstd/sys/common/backtrace.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "316d97064eeca0ccb91424df417be4c8db4338e5", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "42c8f7705e1fcdf2fbcdce5c43ad091486d2ece2", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "15eddd569beec82d9d6171a1977283997d3b203c", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "e007b46b261b485819cfe17ed5da4413ae472e00", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 40, "deletions": 3, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "0c2c76077dd5458595987f6b4c7736307110919e", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "f793de5bb57ef9f735ea28fe6d989ec9be725bc4", "filename": "src/libstd/sys/windows/tty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "04718dcc6ae3bb8435437dc817256cb0317f6897", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "b1599cb807d01be58c143a33bc53212cdd32459a", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "9d4bf77d4a5d33c40977d9136e7c50b1730bcbc7", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 107, "deletions": 104, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "9b42a8f75406900b0819e45c9a54595959b59f86", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "9196055267f6f9f2b056f0f9f6b1c032a6047f33", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "df820b40cb6de63d8aaf2d754cfa60f65e8c5128", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "6b9af29c604571182e91961497f04d07dffc9505", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "88dfdf6e2d8f6b85c4eb05835139b98567a2ef2e", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "90fc28014e64f83101d1827d5f5547e60d1f1511", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "b77b822a6b2a150ab9db1c84c5790b52e46bc825", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "d45871708dc20dd6fef7899c2591e97ca5ed50c8", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "77165168746b7251d6ca834f16c3017ac6dc50b7", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "03dd08fdf7fe43f35d81d5221df75fa60bb0dcdc", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "2cf60d30a1b25a16b563cea975011038633176d0", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "c27a27fce6a908bc671d8695f8bbd78678a6856c", "filename": "src/libsyntax/ext/deriving/bounds.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "eedec6f37c840f11343dc2f92c8f7da5195c7774", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "57dfbc0c6e8bcf6f3f56ffd2a2a91e8ef997596e", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "8bd3df6232ce5d61d67232fe3e7dd8c8b90cd67b", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "cf0201294ae54c02e9d941eafd370a22ea06c0ba", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "edf29e670eb88dfdb9c4b6b2eb779a72448b4b92", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "19b45a1e6100718ea121012ed61af0fd2e0f6a0f", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "9fedc4a158e1569f5d5403cf05fd4e270dfe26ed", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "f2b6f6bfe16b05e7e46d74e7d48854866c894cda", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "aad4045f00a521edd45912f06f467e8d4dbd12a3", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "6a296333fdb6a59bb9d3fc4949177548892ed572", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "368d4fa84476fd08c0ec41cf4adad404c9462430", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "7c2c5c1530c99df30006dce8bd849c3adc166fac", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "73ef18b8449e0ee1f31641154e9eeb8d2f96c8aa", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "08014dc13383f99d822b815a781ffe55bdccf5c6", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "deed0b78e87e47665d5cad104cd476f7f424eab1", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "d53a4b0e8d1c1143d866bc32fb50fabf6f1b4eb6", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "d5093c5055c79251956e391d1feb5f802d3ff28e", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "3023c547fb05302e1eccc647a0c16577788085bc", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "41693d9d47a51d0cdd67ca2c692daffeadfb1708", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "b8da8365f7e236a979af9dd199e995bb433d00c4", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "13d020f6ae31b3cede3ef09e87d4daa58cfa152d", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "8cefb111fd1fcc1249fbb9a5f1a79467e7839279", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "e3c831c09bac5cc315858a4da3837e31aec55883", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "197970317d245686992c1b7e0184c591ef7fb6c9", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 75, "deletions": 75, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "f575d3d6c676b884a4b3042d4769bdf39ea42551", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "ab0e0f9585c4ed7165ec540af6c785000ca1a7a4", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "21410395a90b3444b2500ad9b7600764745555ae", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 154, "deletions": 133, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "e1c8ff5011b267bc85db0d219eaf1be9cfec05b1", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "bc7dda8c44acc598cb0532921984fb711d3ccf6a", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "97eb43165833abbfb36e5b7f9922f0b928ff1237", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "946181770c8e95d7437c88b21151046ba51aeaa6", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "d944d0362fbe50e481c57c3017b7d3120403d376", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "395fac52d8dacedbbeb2f44d1c800291a9fcd069", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "4b73fe04c859d513cfc28d8b55ae388040fc5e0a", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "e58a0229d69623fd1bce2f55e8720c437a0d2e18", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "d33362ec232952648921833ef015678deb7b2090", "filename": "src/libunicode/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibunicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibunicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Flib.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "a3d4dd057d0024780eb74780e6f8a9ef417b910d", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 212, "deletions": 96, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "38fc4827f5861e811ded6db100301a08f6af6b09", "filename": "src/rt/arch/arm/_context.S", "status": "removed", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/2f3cff6956d56048ef7afb6d33e17cbdb2dcf038/src%2Frt%2Farch%2Farm%2F_context.S", "raw_url": "https://github.com/rust-lang/rust/raw/2f3cff6956d56048ef7afb6d33e17cbdb2dcf038/src%2Frt%2Farch%2Farm%2F_context.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Farm%2F_context.S?ref=2f3cff6956d56048ef7afb6d33e17cbdb2dcf038"}, {"sha": "6b79a82e4acafdbab2ba7426c7585faaf85ca4af", "filename": "src/rt/arch/i386/_context.S", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/2f3cff6956d56048ef7afb6d33e17cbdb2dcf038/src%2Frt%2Farch%2Fi386%2F_context.S", "raw_url": "https://github.com/rust-lang/rust/raw/2f3cff6956d56048ef7afb6d33e17cbdb2dcf038/src%2Frt%2Farch%2Fi386%2F_context.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2F_context.S?ref=2f3cff6956d56048ef7afb6d33e17cbdb2dcf038"}, {"sha": "cfe77cc30456b1bacd67918aceab9948aa817af2", "filename": "src/rt/arch/mips/_context.S", "status": "removed", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/2f3cff6956d56048ef7afb6d33e17cbdb2dcf038/src%2Frt%2Farch%2Fmips%2F_context.S", "raw_url": "https://github.com/rust-lang/rust/raw/2f3cff6956d56048ef7afb6d33e17cbdb2dcf038/src%2Frt%2Farch%2Fmips%2F_context.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fmips%2F_context.S?ref=2f3cff6956d56048ef7afb6d33e17cbdb2dcf038"}, {"sha": "cfe77cc30456b1bacd67918aceab9948aa817af2", "filename": "src/rt/arch/mipsel/_context.S", "status": "removed", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/2f3cff6956d56048ef7afb6d33e17cbdb2dcf038/src%2Frt%2Farch%2Fmipsel%2F_context.S", "raw_url": "https://github.com/rust-lang/rust/raw/2f3cff6956d56048ef7afb6d33e17cbdb2dcf038/src%2Frt%2Farch%2Fmipsel%2F_context.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fmipsel%2F_context.S?ref=2f3cff6956d56048ef7afb6d33e17cbdb2dcf038"}, {"sha": "36caf7720c40c5ece1a138bd524c86884fb0364b", "filename": "src/rt/arch/x86_64/_context.S", "status": "removed", "additions": 0, "deletions": 192, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/2f3cff6956d56048ef7afb6d33e17cbdb2dcf038/src%2Frt%2Farch%2Fx86_64%2F_context.S", "raw_url": "https://github.com/rust-lang/rust/raw/2f3cff6956d56048ef7afb6d33e17cbdb2dcf038/src%2Frt%2Farch%2Fx86_64%2F_context.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fx86_64%2F_context.S?ref=2f3cff6956d56048ef7afb6d33e17cbdb2dcf038"}, {"sha": "25160ca68a6b398d526f71e5c55492d24385706e", "filename": "src/rt/arch/x86_64/regs.h", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/2f3cff6956d56048ef7afb6d33e17cbdb2dcf038/src%2Frt%2Farch%2Fx86_64%2Fregs.h", "raw_url": "https://github.com/rust-lang/rust/raw/2f3cff6956d56048ef7afb6d33e17cbdb2dcf038/src%2Frt%2Farch%2Fx86_64%2Fregs.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fx86_64%2Fregs.h?ref=2f3cff6956d56048ef7afb6d33e17cbdb2dcf038"}, {"sha": "6aa6b02857fbe3d86646dea5d27e79a8f181a5e2", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "1b4e5891f941de493f284cf808da66326a7b88ea", "filename": "src/test/compile-fail/borrowck-autoref-3261.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "1db813292b01241b79535116219a01fa6f2b93c5", "filename": "src/test/compile-fail/cast-to-bare-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Fcompile-fail%2Fcast-to-bare-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Fcompile-fail%2Fcast-to-bare-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-to-bare-fn.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "52f4c4749e224f90e1455befddc899c5cf7557a6", "filename": "src/test/compile-fail/coerce-bare-fn-to-closure-and-proc.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Fcompile-fail%2Fcoerce-bare-fn-to-closure-and-proc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Fcompile-fail%2Fcoerce-bare-fn-to-closure-and-proc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoerce-bare-fn-to-closure-and-proc.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "dd4a24bfb2fdc17a6fbb89ef8b222e8568a41013", "filename": "src/test/compile-fail/fn-item-type.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Fcompile-fail%2Ffn-item-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Fcompile-fail%2Ffn-item-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-item-type.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "cd4ec495556c562303249997f20c36d31f7b3694", "filename": "src/test/compile-fail/issue-10764.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Fcompile-fail%2Fissue-10764.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Fcompile-fail%2Fissue-10764.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10764.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "e3ced3028098bf08e27006a140d40a6ff00405d8", "filename": "src/test/compile-fail/issue-19922.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Fcompile-fail%2Fissue-19922.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Fcompile-fail%2Fissue-19922.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19922.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "6e8f7ffb68da4285549855b1da38623942474616", "filename": "src/test/compile-fail/issue-9575.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Fcompile-fail%2Fissue-9575.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Fcompile-fail%2Fissue-9575.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-9575.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "3e6a95b04f743ab8e7a6e56dc48afba0110f5aae", "filename": "src/test/compile-fail/region-lifetime-bounds-on-fns-where-clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Fcompile-fail%2Fregion-lifetime-bounds-on-fns-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Fcompile-fail%2Fregion-lifetime-bounds-on-fns-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-lifetime-bounds-on-fns-where-clause.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "2d635e9fc2718067c399cb060bc588ef8ea76e56", "filename": "src/test/compile-fail/region-multiple-lifetime-bounds-on-fns-where-clause.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Fcompile-fail%2Fregion-multiple-lifetime-bounds-on-fns-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Fcompile-fail%2Fregion-multiple-lifetime-bounds-on-fns-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-multiple-lifetime-bounds-on-fns-where-clause.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "4a42728da6f580f0aab75f13891ba84b9eb8b670", "filename": "src/test/compile-fail/regions-lifetime-bounds-on-fns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Fcompile-fail%2Fregions-lifetime-bounds-on-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Fcompile-fail%2Fregions-lifetime-bounds-on-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-lifetime-bounds-on-fns.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "f4654367970d11d052b16a23f73f54b8933e3113", "filename": "src/test/compile-fail/regions-nested-fns.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "de934286a7cba65010cb1500694953750dd42d74", "filename": "src/test/compile-fail/resolve-conflict-type-vs-import.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-type-vs-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-type-vs-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-type-vs-import.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "bce397c47932f453baa83c8deffb871c1a593b04", "filename": "src/test/compile-fail/static-reference-to-fn-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Fcompile-fail%2Fstatic-reference-to-fn-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Fcompile-fail%2Fstatic-reference-to-fn-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-reference-to-fn-1.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "d7255c3ba0694ff96f10149795d439cb22bba3c7", "filename": "src/test/compile-fail/static-reference-to-fn-2.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Fcompile-fail%2Fstatic-reference-to-fn-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Fcompile-fail%2Fstatic-reference-to-fn-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-reference-to-fn-2.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "bc9f89a3d15ffc13141f252e1aa03c84b3dcf4c5", "filename": "src/test/pretty/asm-options.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Fpretty%2Fasm-options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Fpretty%2Fasm-options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fasm-options.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "e4389cd69dd62f88ed6b53ca928abe3999b912a6", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "0562e000e56e94beaf95079f8f6b5a35fc0dec70", "filename": "src/test/run-make/graphviz-flowgraph/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2FMakefile?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "c5f69f249db6bfe1707d9936c73362fcbd92fc65", "filename": "src/test/run-pass/bitv-perf-test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "069ca6ecf49dd4c3f1ef83212d7e7fef3beebfa0", "filename": "src/test/run-pass/const-extern-function.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Frun-pass%2Fconst-extern-function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Frun-pass%2Fconst-extern-function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-extern-function.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "3febff18704deea2faf81c12c4d46e9966d6d09c", "filename": "src/test/run-pass/extern-compare-with-return-type.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Frun-pass%2Fextern-compare-with-return-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Frun-pass%2Fextern-compare-with-return-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-compare-with-return-type.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "bfd02f5e27b0c4bced6290d6c5973584916c27b5", "filename": "src/test/run-pass/fn-item-type-cast.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Frun-pass%2Ffn-item-type-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Frun-pass%2Ffn-item-type-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-item-type-cast.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "8427a0f444621ce93cdbf25a07240b7eacfbbcdc", "filename": "src/test/run-pass/fn-item-type-coerce.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Frun-pass%2Ffn-item-type-coerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Frun-pass%2Ffn-item-type-coerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-item-type-coerce.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "d28950241874d2db112f1d5be09a2adc696933c5", "filename": "src/test/run-pass/issue-10767.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Frun-pass%2Fissue-10767.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Frun-pass%2Fissue-10767.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10767.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "bc4ceb38de33cdc9b1ff848a04e3a69709d839a8", "filename": "src/test/run-pass/issue-11736.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Frun-pass%2Fissue-11736.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Frun-pass%2Fissue-11736.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11736.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "1282077028ffbe93128ed341ade6c20e077831c9", "filename": "src/test/run-pass/issue-13167.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Frun-pass%2Fissue-13167.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Frun-pass%2Fissue-13167.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13167.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "0f4978d78dd86700d0961236461cb6a7ca632250", "filename": "src/test/run-pass/issue-15444.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Frun-pass%2Fissue-15444.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Frun-pass%2Fissue-15444.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15444.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "2f466d4ca8c47f59a72dc9b2e4c964955e99d8ea", "filename": "src/test/run-pass/issue-19340-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Frun-pass%2Fissue-19340-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Frun-pass%2Fissue-19340-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-19340-1.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "8300220edeaff11310fc5bedc06ec6013cfee7b6", "filename": "src/test/run-pass/issue-19340-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Frun-pass%2Fissue-19340-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Frun-pass%2Fissue-19340-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-19340-2.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}, {"sha": "7db84d518ff30bd4cbfe731009330fbcf81aa6d0", "filename": "src/test/run-pass/issue-19367.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Frun-pass%2Fissue-19367.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91/src%2Ftest%2Frun-pass%2Fissue-19367.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-19367.rs?ref=62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}]}