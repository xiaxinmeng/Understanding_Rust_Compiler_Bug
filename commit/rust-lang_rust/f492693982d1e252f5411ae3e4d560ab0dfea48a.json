{"sha": "f492693982d1e252f5411ae3e4d560ab0dfea48a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0OTI2OTM5ODJkMWUyNTJmNTQxMWFlM2U0ZDU2MGFiMGRmZWE0OGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-25T16:08:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-25T16:08:11Z"}, "message": "Auto merge of #59276 - oli-obk:cleanups, r=eddyb\n\nCleanup (pretty) printing of `ty::Const`\n\nr? @eddyb\n\naddresses https://github.com/rust-lang/rust/pull/59178/files/5cd28066214a4a255bac6655c20bf05cb95730fd#r266243236 and https://github.com/rust-lang/rust/pull/59178/files/5cd28066214a4a255bac6655c20bf05cb95730fd#r266243336", "tree": {"sha": "0de87039ac27ace7a63b3e1f5fb84ff6d426045f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0de87039ac27ace7a63b3e1f5fb84ff6d426045f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f492693982d1e252f5411ae3e4d560ab0dfea48a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f492693982d1e252f5411ae3e4d560ab0dfea48a", "html_url": "https://github.com/rust-lang/rust/commit/f492693982d1e252f5411ae3e4d560ab0dfea48a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f492693982d1e252f5411ae3e4d560ab0dfea48a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02f5786a324c40b2d8b2d0df98456e48fb45d30c", "url": "https://api.github.com/repos/rust-lang/rust/commits/02f5786a324c40b2d8b2d0df98456e48fb45d30c", "html_url": "https://github.com/rust-lang/rust/commit/02f5786a324c40b2d8b2d0df98456e48fb45d30c"}, {"sha": "0b732aa6071fd165d8f2c0972495b5e058699b47", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b732aa6071fd165d8f2c0972495b5e058699b47", "html_url": "https://github.com/rust-lang/rust/commit/0b732aa6071fd165d8f2c0972495b5e058699b47"}], "stats": {"total": 885, "additions": 488, "deletions": 397}, "files": [{"sha": "d34ed114972c5a794627ea18c0a36cede861562b", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -12,7 +12,7 @@ __pycache__/\n .project\n .settings/\n .valgrindrc\n-.vscode/\n+.vscode\n .favorites.json\n /*-*-*-*/\n /*-*-*/"}, {"sha": "8ec9d42ec5f827b272ae5a78016fc45a4ee0e93b", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -462,6 +462,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             type Region = !;\n             type Type = !;\n             type DynExistential = !;\n+            type Const = !;\n \n             fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx> {\n                 self.tcx\n@@ -488,6 +489,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 Err(NonTrivialPath)\n             }\n \n+            fn print_const(\n+                self,\n+                _ct: &'tcx ty::Const<'tcx>,\n+            ) -> Result<Self::Const, Self::Error> {\n+                Err(NonTrivialPath)\n+            }\n+\n             fn path_crate(\n                 self,\n                 cnum: CrateNum,"}, {"sha": "8f52ef7a3f3a4c1d0ad8b827fcda24585aa67b1e", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -260,7 +260,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n \n             ConstValue::Param(_) |\n             ConstValue::Scalar(_) |\n-            ConstValue::Slice(..) |\n+            ConstValue::Slice { .. } |\n             ConstValue::ByRef(..) |\n             ConstValue::Unevaluated(..) => {}\n         }"}, {"sha": "b9ce42ac8f290847498b3b4d2bb253cf3cbf45b0", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -791,6 +791,7 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n             type Region = ();\n             type Type = ();\n             type DynExistential = ();\n+            type Const = ();\n \n             fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n                 self.tcx\n@@ -807,7 +808,14 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n             fn print_dyn_existential(\n                 self,\n                 _predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n-                ) -> Result<Self::DynExistential, Self::Error> {\n+            ) -> Result<Self::DynExistential, Self::Error> {\n+                Ok(())\n+            }\n+\n+            fn print_const(\n+                self,\n+                _ct: &'tcx ty::Const<'tcx>,\n+            ) -> Result<Self::Const, Self::Error> {\n                 Ok(())\n             }\n "}, {"sha": "9c2fd399ee029bf73e3cd3ad646e6347eb27c5e0", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -38,7 +38,7 @@ impl ErrorHandled {\n }\n \n pub type ConstEvalRawResult<'tcx> = Result<RawConst<'tcx>, ErrorHandled>;\n-pub type ConstEvalResult<'tcx> = Result<ty::Const<'tcx>, ErrorHandled>;\n+pub type ConstEvalResult<'tcx> = Result<&'tcx ty::Const<'tcx>, ErrorHandled>;\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct ConstEvalErr<'tcx> {"}, {"sha": "72545f23f8e2bf3ac67a39ebef68f6afd60c0e76", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -35,14 +35,12 @@ pub enum ConstValue<'tcx> {\n     /// Not using the enum `Value` to encode that this must not be `Undef`.\n     Scalar(Scalar),\n \n-    /// Used only for slices and strings (`&[T]`, `&str`, `*const [T]`, `*mut str`, `Box<str>`,\n-    /// etc.).\n-    ///\n-    /// Empty slices don't necessarily have an address backed by an `AllocId`, thus we also need to\n-    /// enable integer pointers. The `Scalar` type covers exactly those two cases. While we could\n-    /// create dummy-`AllocId`s, the additional code effort for the conversions doesn't seem worth\n-    /// it.\n-    Slice(Scalar, u64),\n+    /// Used only for `&[u8]` and `&str`\n+    Slice {\n+        data: &'tcx Allocation,\n+        start: usize,\n+        end: usize,\n+    },\n \n     /// An allocation together with a pointer into the allocation.\n     /// Invariant: the pointer's `AllocId` resolves to the allocation.\n@@ -54,7 +52,7 @@ pub enum ConstValue<'tcx> {\n }\n \n #[cfg(target_arch = \"x86_64\")]\n-static_assert_size!(ConstValue<'_>, 40);\n+static_assert_size!(ConstValue<'_>, 32);\n \n impl<'tcx> ConstValue<'tcx> {\n     #[inline]\n@@ -65,7 +63,7 @@ impl<'tcx> ConstValue<'tcx> {\n             ConstValue::Placeholder(_) |\n             ConstValue::ByRef(..) |\n             ConstValue::Unevaluated(..) |\n-            ConstValue::Slice(..) => None,\n+            ConstValue::Slice { .. } => None,\n             ConstValue::Scalar(val) => Some(val),\n         }\n     }\n@@ -79,14 +77,6 @@ impl<'tcx> ConstValue<'tcx> {\n     pub fn try_to_ptr(&self) -> Option<Pointer> {\n         self.try_to_scalar()?.to_ptr().ok()\n     }\n-\n-    #[inline]\n-    pub fn new_slice(\n-        val: Scalar,\n-        len: u64,\n-    ) -> Self {\n-        ConstValue::Slice(val, len)\n-    }\n }\n \n /// A `Scalar` represents an immediate, primitive value existing outside of a"}, {"sha": "84aff8101a09d99c3ed55111ba46572bc30ad713", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 26, "deletions": 85, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -9,8 +9,6 @@ use crate::hir::def_id::DefId;\n use crate::hir::{self, InlineAsm as HirInlineAsm};\n use crate::mir::interpret::{ConstValue, InterpError, Scalar};\n use crate::mir::visit::MirVisitable;\n-use rustc_apfloat::ieee::{Double, Single};\n-use rustc_apfloat::Float;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::dominators::{dominators, Dominators};\n use rustc_data_structures::graph::{self, GraphPredecessors, GraphSuccessors};\n@@ -21,13 +19,13 @@ use rustc_macros::HashStable;\n use crate::rustc_serialize::{self as serialize};\n use smallvec::SmallVec;\n use std::borrow::Cow;\n-use std::fmt::{self, Debug, Formatter, Write};\n+use std::fmt::{self, Debug, Formatter, Write, Display};\n use std::iter::FusedIterator;\n use std::ops::{Index, IndexMut};\n use std::slice;\n use std::vec::IntoIter;\n use std::{iter, mem, option, u32};\n-use syntax::ast::{self, Name};\n+use syntax::ast::Name;\n use syntax::symbol::{InternedString, Symbol};\n use syntax_pos::{Span, DUMMY_SP};\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n@@ -1662,28 +1660,25 @@ impl<'tcx> TerminatorKind<'tcx> {\n                 switch_ty,\n                 ..\n             } => {\n-                let size = ty::tls::with(|tcx| {\n+                ty::tls::with(|tcx| {\n                     let param_env = ty::ParamEnv::empty();\n                     let switch_ty = tcx.lift_to_global(&switch_ty).unwrap();\n-                    tcx.layout_of(param_env.and(switch_ty)).unwrap().size\n-                });\n-                values\n-                    .iter()\n-                    .map(|&u| {\n-                        let mut s = String::new();\n-                        let c = ty::Const {\n-                            val: ConstValue::Scalar(\n-                                Scalar::Bits {\n-                                    bits: u,\n-                                    size: size.bytes() as u8,\n-                                }.into(),\n-                            ),\n-                            ty: switch_ty,\n-                        };\n-                        fmt_const_val(&mut s, c).unwrap();\n-                        s.into()\n-                    }).chain(iter::once(\"otherwise\".into()))\n-                    .collect()\n+                    let size = tcx.layout_of(param_env.and(switch_ty)).unwrap().size;\n+                    values\n+                        .iter()\n+                        .map(|&u| {\n+                            tcx.mk_const(ty::Const {\n+                                val: ConstValue::Scalar(\n+                                    Scalar::Bits {\n+                                        bits: u,\n+                                        size: size.bytes() as u8,\n+                                    }.into(),\n+                                ),\n+                                ty: switch_ty,\n+                            }).to_string().into()\n+                        }).chain(iter::once(\"otherwise\".into()))\n+                        .collect()\n+                })\n             }\n             Call {\n                 destination: Some(_),\n@@ -2331,9 +2326,7 @@ impl<'tcx> Operand<'tcx> {\n             span,\n             ty,\n             user_ty: None,\n-            literal: tcx.mk_const(\n-                ty::Const::zero_sized(ty),\n-            ),\n+            literal: ty::Const::zero_sized(tcx, ty),\n         })\n     }\n \n@@ -2827,67 +2820,15 @@ newtype_index! {\n \n impl<'tcx> Debug for Constant<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n-        write!(fmt, \"const \")?;\n-        fmt_const_val(fmt, *self.literal)\n-    }\n-}\n-/// Write a `ConstValue` in a way closer to the original source code than the `Debug` output.\n-pub fn fmt_const_val(f: &mut impl Write, const_val: ty::Const<'_>) -> fmt::Result {\n-    use crate::ty::TyKind::*;\n-    let value = const_val.val;\n-    let ty = const_val.ty;\n-    // print some primitives\n-    if let ConstValue::Scalar(Scalar::Bits { bits, .. }) = value {\n-        match ty.sty {\n-            Bool if bits == 0 => return write!(f, \"false\"),\n-            Bool if bits == 1 => return write!(f, \"true\"),\n-            Float(ast::FloatTy::F32) => return write!(f, \"{}f32\", Single::from_bits(bits)),\n-            Float(ast::FloatTy::F64) => return write!(f, \"{}f64\", Double::from_bits(bits)),\n-            Uint(ui) => return write!(f, \"{:?}{}\", bits, ui),\n-            Int(i) => {\n-                let bit_width = ty::tls::with(|tcx| {\n-                    let ty = tcx.lift_to_global(&ty).unwrap();\n-                    tcx.layout_of(ty::ParamEnv::empty().and(ty))\n-                        .unwrap()\n-                        .size\n-                        .bits()\n-                });\n-                let shift = 128 - bit_width;\n-                return write!(f, \"{:?}{}\", ((bits as i128) << shift) >> shift, i);\n-            }\n-            Char => return write!(f, \"{:?}\", ::std::char::from_u32(bits as u32).unwrap()),\n-            _ => {}\n-        }\n+        write!(fmt, \"{}\", self)\n     }\n-    // print function definitions\n-    if let FnDef(did, _) = ty.sty {\n-        return write!(f, \"{}\", def_path_str(did));\n-    }\n-    // print string literals\n-    if let ConstValue::Slice(ptr, len) = value {\n-        if let Scalar::Ptr(ptr) = ptr {\n-            if let Ref(_, &ty::TyS { sty: Str, .. }, _) = ty.sty {\n-                return ty::tls::with(|tcx| {\n-                    let alloc = tcx.alloc_map.lock().get(ptr.alloc_id);\n-                    if let Some(interpret::AllocKind::Memory(alloc)) = alloc {\n-                        assert_eq!(len as usize as u64, len);\n-                        let slice =\n-                            &alloc.bytes[(ptr.offset.bytes() as usize)..][..(len as usize)];\n-                        let s = ::std::str::from_utf8(slice).expect(\"non utf8 str from miri\");\n-                        write!(f, \"{:?}\", s)\n-                    } else {\n-                        write!(f, \"pointer to erroneous constant {:?}, {:?}\", ptr, len)\n-                    }\n-                });\n-            }\n-        }\n-    }\n-    // just raw dump everything else\n-    write!(f, \"{:?} : {}\", value, ty)\n }\n \n-fn def_path_str(def_id: DefId) -> String {\n-    ty::tls::with(|tcx| tcx.def_path_str(def_id))\n+impl<'tcx> Display for Constant<'tcx> {\n+    fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n+        write!(fmt, \"const \")?;\n+        write!(fmt, \"{}\", self.literal)\n+    }\n }\n \n impl<'tcx> graph::DirectedGraph for Mir<'tcx> {"}, {"sha": "b1c4e4091128015b66a2a879c752f4081fe3c793", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -412,7 +412,6 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n                         };\n                         if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n                             let substs = tcx.lift_to_global(&substs).unwrap();\n-                            let evaluated = tcx.mk_const(evaluated);\n                             let evaluated = evaluated.subst(tcx, substs);\n                             return evaluated;\n                         }\n@@ -426,7 +425,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n                                 promoted: None\n                             };\n                             if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n-                                return tcx.mk_const(evaluated);\n+                                return evaluated;\n                             }\n                         }\n                     }"}, {"sha": "d09a9c107869b603bbfd3f33f47cbc4847ed9809", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -202,7 +202,6 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n                         };\n                         if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n                             let substs = tcx.lift_to_global(&substs).unwrap();\n-                            let evaluated = tcx.mk_const(evaluated);\n                             let evaluated = evaluated.subst(tcx, substs);\n                             return evaluated;\n                         }\n@@ -216,7 +215,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n                                 promoted: None,\n                             };\n                             if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n-                                return tcx.mk_const(evaluated);\n+                                return evaluated;\n                             }\n                         }\n                     }"}, {"sha": "a56fe7d7003a1b0e31d1abce55b2fb1f0f78859e", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -24,7 +24,7 @@ use crate::middle::lang_items;\n use crate::middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use crate::middle::stability;\n use crate::mir::{self, Mir, interpret, ProjectionKind};\n-use crate::mir::interpret::{ConstValue, Allocation};\n+use crate::mir::interpret::{ConstValue, Allocation, Scalar};\n use crate::ty::subst::{Kind, InternalSubsts, SubstsRef, Subst};\n use crate::ty::ReprOptions;\n use crate::traits;\n@@ -1000,7 +1000,10 @@ impl<'tcx> CommonConsts<'tcx> {\n         };\n \n         CommonConsts {\n-            err: mk_const(ty::Const::zero_sized(types.err)),\n+            err: mk_const(ty::Const {\n+                val: ConstValue::Scalar(Scalar::Bits { bits: 0, size: 0 }),\n+                ty: types.err,\n+            }),\n         }\n     }\n }\n@@ -1822,14 +1825,6 @@ nop_list_lift!{ProjectionKind => ProjectionKind}\n // this is the impl for `&'a InternalSubsts<'a>`\n nop_list_lift!{Kind<'a> => Kind<'tcx>}\n \n-impl<'a, 'tcx> Lift<'tcx> for &'a mir::interpret::Allocation {\n-    type Lifted = &'tcx mir::interpret::Allocation;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        assert!(tcx.global_arenas.const_allocs.in_arena(*self as *const _));\n-        Some(unsafe { mem::transmute(*self) })\n-    }\n-}\n-\n pub mod tls {\n     use super::{GlobalCtxt, TyCtxt, ptr_eq};\n \n@@ -2594,9 +2589,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     #[inline]\n     pub fn mk_array(self, ty: Ty<'tcx>, n: u64) -> Ty<'tcx> {\n-        self.mk_ty(Array(ty, self.mk_const(\n-            ty::Const::from_usize(self.global_tcx(), n)\n-        )))\n+        self.mk_ty(Array(ty, ty::Const::from_usize(self.global_tcx(), n)))\n     }\n \n     #[inline]"}, {"sha": "dae28d51efc2ead309d4765d76a941708e3abb73", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -939,7 +939,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n     fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n         let flags = FlagComputation::for_const(c);\n         debug!(\"HasTypeFlagsVisitor: c={:?} c.flags={:?} self.flags={:?}\", c, flags, self.flags);\n-        flags.intersects(self.flags) || c.super_visit_with(self)\n+        flags.intersects(self.flags)\n     }\n }\n "}, {"sha": "53d4466cfef684d8007e4b4c569ba64e15cfe634", "filename": "src/librustc/ty/print/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -31,6 +31,7 @@ pub trait Printer<'gcx: 'tcx, 'tcx>: Sized {\n     type Region;\n     type Type;\n     type DynExistential;\n+    type Const;\n \n     fn tcx(&'a self) -> TyCtxt<'a, 'gcx, 'tcx>;\n \n@@ -66,6 +67,11 @@ pub trait Printer<'gcx: 'tcx, 'tcx>: Sized {\n         predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n     ) -> Result<Self::DynExistential, Self::Error>;\n \n+    fn print_const(\n+        self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<Self::Const, Self::Error>;\n+\n     fn path_crate(\n         self,\n         cnum: CrateNum,\n@@ -325,3 +331,11 @@ impl<'gcx: 'tcx, 'tcx, P: Printer<'gcx, 'tcx>> Print<'gcx, 'tcx, P>\n         cx.print_dyn_existential(self)\n     }\n }\n+\n+impl<'gcx: 'tcx, 'tcx, P: Printer<'gcx, 'tcx>> Print<'gcx, 'tcx, P> for &'tcx ty::Const<'tcx> {\n+    type Output = P::Const;\n+    type Error = P::Error;\n+    fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {\n+        cx.print_const(self)\n+    }\n+}"}, {"sha": "67265633318440182714337883b35b3891ba8b88", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 127, "deletions": 17, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -1,12 +1,16 @@\n use crate::hir;\n-use crate::hir::def::Namespace;\n+use crate::hir::def::{Namespace, DefKind};\n use crate::hir::map::{DefPathData, DisambiguatedDefPathData};\n use crate::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use crate::middle::cstore::{ExternCrate, ExternCrateSource};\n use crate::middle::region;\n use crate::ty::{self, DefIdTree, ParamConst, Ty, TyCtxt, TypeFoldable};\n use crate::ty::subst::{Kind, Subst, UnpackedKind};\n-use crate::mir::interpret::ConstValue;\n+use crate::ty::layout::Size;\n+use crate::mir::interpret::{ConstValue, sign_extend, Scalar};\n+use syntax::ast;\n+use rustc_apfloat::ieee::{Double, Single};\n+use rustc_apfloat::Float;\n use rustc_target::spec::abi::Abi;\n use syntax::symbol::{kw, InternedString};\n \n@@ -169,6 +173,7 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n         Region = Self,\n         Type = Self,\n         DynExistential = Self,\n+        Const = Self,\n     > +\n     fmt::Write\n {\n@@ -661,12 +666,10 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n             },\n             ty::Array(ty, sz) => {\n                 p!(write(\"[\"), print(ty), write(\"; \"));\n-                match sz.val {\n-                    ConstValue::Unevaluated(..) |\n-                    ConstValue::Infer(..) => p!(write(\"_\")),\n-                    ConstValue::Param(ParamConst { name, .. }) =>\n-                        p!(write(\"{}\", name)),\n-                    _ => p!(write(\"{}\", sz.unwrap_usize(self.tcx()))),\n+                if let Some(n) = sz.assert_usize(self.tcx()) {\n+                    p!(write(\"{}\", n));\n+                } else {\n+                    p!(write(\"_\"));\n                 }\n                 p!(write(\"]\"))\n             }\n@@ -804,6 +807,113 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n \n         Ok(self)\n     }\n+\n+    fn pretty_print_const(\n+        mut self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<Self::Const, Self::Error> {\n+        define_scoped_cx!(self);\n+\n+        let u8 = self.tcx().types.u8;\n+        if let ty::FnDef(did, substs) = ct.ty.sty {\n+            p!(print_value_path(did, substs));\n+            return Ok(self);\n+        }\n+        if let ConstValue::Unevaluated(did, substs) = ct.val {\n+            match self.tcx().def_kind(did) {\n+                | Some(DefKind::Static)\n+                | Some(DefKind::Const)\n+                | Some(DefKind::AssociatedConst) => p!(print_value_path(did, substs)),\n+                _ => if did.is_local() {\n+                    let span = self.tcx().def_span(did);\n+                    if let Ok(snip) = self.tcx().sess.source_map().span_to_snippet(span) {\n+                        p!(write(\"{}\", snip))\n+                    } else {\n+                        p!(write(\"_: \"), print(ct.ty))\n+                    }\n+                } else {\n+                    p!(write(\"_: \"), print(ct.ty))\n+                },\n+            }\n+            return Ok(self);\n+        }\n+        if let ConstValue::Infer(..) = ct.val {\n+            p!(write(\"_: \"), print(ct.ty));\n+            return Ok(self);\n+        }\n+        if let ConstValue::Param(ParamConst { name, .. }) = ct.val {\n+            p!(write(\"{}\", name));\n+            return Ok(self);\n+        }\n+        if let ConstValue::Scalar(Scalar::Bits { bits, .. }) = ct.val {\n+            match ct.ty.sty {\n+                ty::Bool => {\n+                    p!(write(\"{}\", if bits == 0 { \"false\" } else { \"true\" }));\n+                    return Ok(self);\n+                },\n+                ty::Float(ast::FloatTy::F32) => {\n+                    p!(write(\"{}f32\", Single::from_bits(bits)));\n+                    return Ok(self);\n+                },\n+                ty::Float(ast::FloatTy::F64) => {\n+                    p!(write(\"{}f64\", Double::from_bits(bits)));\n+                    return Ok(self);\n+                },\n+                ty::Uint(ui) => {\n+                    p!(write(\"{}{}\", bits, ui));\n+                    return Ok(self);\n+                },\n+                ty::Int(i) =>{\n+                    let ty = self.tcx().lift_to_global(&ct.ty).unwrap();\n+                    let size = self.tcx().layout_of(ty::ParamEnv::empty().and(ty))\n+                        .unwrap()\n+                        .size;\n+                    p!(write(\"{}{}\", sign_extend(bits, size) as i128, i));\n+                    return Ok(self);\n+                },\n+                ty::Char => {\n+                    p!(write(\"{:?}\", ::std::char::from_u32(bits as u32).unwrap()));\n+                    return Ok(self);\n+                }\n+                _ => {},\n+            }\n+        }\n+        if let ty::Ref(_, ref_ty, _) = ct.ty.sty {\n+            let byte_str = match (ct.val, &ref_ty.sty) {\n+                (ConstValue::Scalar(Scalar::Ptr(ptr)), ty::Array(t, n)) if *t == u8 => {\n+                    let n = n.unwrap_usize(self.tcx());\n+                    Some(self.tcx()\n+                        .alloc_map.lock()\n+                        .unwrap_memory(ptr.alloc_id)\n+                        .get_bytes(&self.tcx(), ptr, Size::from_bytes(n)).unwrap())\n+                },\n+                (ConstValue::Slice { data, start, end }, ty::Slice(t)) if *t == u8 => {\n+                    Some(&data.bytes[start..end])\n+                },\n+                (ConstValue::Slice { data, start, end }, ty::Str) => {\n+                    let slice = &data.bytes[start..end];\n+                    let s = ::std::str::from_utf8(slice)\n+                        .expect(\"non utf8 str from miri\");\n+                    p!(write(\"{:?}\", s));\n+                    return Ok(self);\n+                },\n+                _ => None,\n+            };\n+            if let Some(byte_str) = byte_str {\n+                p!(write(\"b\\\"\"));\n+                for &c in byte_str {\n+                    for e in std::ascii::escape_default(c) {\n+                        self.write_char(e as char)?;\n+                    }\n+                }\n+                p!(write(\"\\\"\"));\n+                return Ok(self);\n+            }\n+        }\n+        p!(write(\"{:?} : \", ct.val), print(ct.ty));\n+\n+        Ok(self)\n+    }\n }\n \n // HACK(eddyb) boxed to avoid moving around a large struct by-value.\n@@ -896,6 +1006,7 @@ impl<F: fmt::Write> Printer<'gcx, 'tcx> for FmtPrinter<'_, 'gcx, 'tcx, F> {\n     type Region = Self;\n     type Type = Self;\n     type DynExistential = Self;\n+    type Const = Self;\n \n     fn tcx(&'a self) -> TyCtxt<'a, 'gcx, 'tcx> {\n         self.tcx\n@@ -971,6 +1082,13 @@ impl<F: fmt::Write> Printer<'gcx, 'tcx> for FmtPrinter<'_, 'gcx, 'tcx, F> {\n         self.pretty_print_dyn_existential(predicates)\n     }\n \n+    fn print_const(\n+        self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<Self::Const, Self::Error> {\n+        self.pretty_print_const(ct)\n+    }\n+\n     fn path_crate(\n         mut self,\n         cnum: CrateNum,\n@@ -1444,6 +1562,7 @@ impl fmt::Display for ty::RegionKind {\n forward_display_to_print! {\n     Ty<'tcx>,\n     &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+    &'tcx ty::Const<'tcx>,\n \n     // HACK(eddyb) these are exhaustive instead of generic,\n     // because `for<'gcx: 'tcx, 'tcx>` isn't possible yet.\n@@ -1533,15 +1652,6 @@ define_print_and_forward_display! {\n         p!(print_def_path(self.def_id, self.substs));\n     }\n \n-    &'tcx ty::Const<'tcx> {\n-        match self.val {\n-            ConstValue::Unevaluated(..) |\n-            ConstValue::Infer(..) => p!(write(\"_\")),\n-            ConstValue::Param(ParamConst { name, .. }) => p!(write(\"{}\", name)),\n-            _ => p!(write(\"{:?}\", self)),\n-        }\n-    }\n-\n     ty::ParamTy {\n         p!(write(\"{}\", self.name))\n     }"}, {"sha": "0daa567052d5662ec881cad2b4c366f30b6c5ca4", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -6,15 +6,14 @@\n use crate::hir::def::Namespace;\n use crate::mir::ProjectionKind;\n use crate::mir::interpret::ConstValue;\n-use crate::ty::{self, Lift, Ty, TyCtxt, ConstVid, InferConst};\n+use crate::ty::{self, Lift, Ty, TyCtxt, InferConst};\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use crate::ty::print::{FmtPrinter, Printer};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use smallvec::SmallVec;\n use crate::mir::interpret;\n \n use std::fmt;\n-use std::marker::PhantomData;\n use std::rc::Rc;\n \n impl fmt::Debug for ty::GenericParamDef {\n@@ -788,16 +787,6 @@ BraceStructLiftImpl! {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for ConstVid<'a> {\n-    type Lifted = ConstVid<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, _: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        Some(ConstVid {\n-            index: self.index,\n-            phantom: PhantomData,\n-        })\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // TypeFoldable implementations.\n //\n@@ -1356,7 +1345,7 @@ impl<'tcx> TypeFoldable<'tcx> for ConstValue<'tcx> {\n             ConstValue::Param(p) => ConstValue::Param(p.fold_with(folder)),\n             ConstValue::Placeholder(p) => ConstValue::Placeholder(p),\n             ConstValue::Scalar(a) => ConstValue::Scalar(a),\n-            ConstValue::Slice(a, b) => ConstValue::Slice(a, b),\n+            ConstValue::Slice { data, start, end } => ConstValue::Slice { data, start, end },\n             ConstValue::Unevaluated(did, substs)\n                 => ConstValue::Unevaluated(did, substs.fold_with(folder)),\n         }\n@@ -1369,7 +1358,7 @@ impl<'tcx> TypeFoldable<'tcx> for ConstValue<'tcx> {\n             ConstValue::Param(p) => p.visit_with(visitor),\n             ConstValue::Placeholder(_) => false,\n             ConstValue::Scalar(_) => false,\n-            ConstValue::Slice(..) => false,\n+            ConstValue::Slice { .. } => false,\n             ConstValue::Unevaluated(_, substs) => substs.visit_with(visitor),\n         }\n     }"}, {"sha": "a2b2fc7a4451a23eba0d5e6bffc3c2e039e5c671", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -2207,47 +2207,48 @@ pub struct Const<'tcx> {\n }\n \n #[cfg(target_arch = \"x86_64\")]\n-static_assert_size!(Const<'_>, 48);\n+static_assert_size!(Const<'_>, 40);\n \n impl<'tcx> Const<'tcx> {\n     #[inline]\n     pub fn from_scalar(\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n         val: Scalar,\n         ty: Ty<'tcx>,\n-    ) -> Self {\n-        Self {\n+    ) -> &'tcx Self {\n+        tcx.mk_const(Self {\n             val: ConstValue::Scalar(val),\n             ty,\n-        }\n+        })\n     }\n \n     #[inline]\n     pub fn from_bits(\n         tcx: TyCtxt<'_, '_, 'tcx>,\n         bits: u128,\n         ty: ParamEnvAnd<'tcx, Ty<'tcx>>,\n-    ) -> Self {\n+    ) -> &'tcx Self {\n         let ty = tcx.lift_to_global(&ty).unwrap();\n         let size = tcx.layout_of(ty).unwrap_or_else(|e| {\n             panic!(\"could not compute layout for {:?}: {:?}\", ty, e)\n         }).size;\n         let truncated = truncate(bits, size);\n         assert_eq!(truncated, bits, \"from_bits called with untruncated value\");\n-        Self::from_scalar(Scalar::Bits { bits, size: size.bytes() as u8 }, ty.value)\n+        Self::from_scalar(tcx, Scalar::Bits { bits, size: size.bytes() as u8 }, ty.value)\n     }\n \n     #[inline]\n-    pub fn zero_sized(ty: Ty<'tcx>) -> Self {\n-        Self::from_scalar(Scalar::Bits { bits: 0, size: 0 }, ty)\n+    pub fn zero_sized(tcx: TyCtxt<'_, '_, 'tcx>, ty: Ty<'tcx>) -> &'tcx Self {\n+        Self::from_scalar(tcx, Scalar::Bits { bits: 0, size: 0 }, ty)\n     }\n \n     #[inline]\n-    pub fn from_bool(tcx: TyCtxt<'_, '_, 'tcx>, v: bool) -> Self {\n+    pub fn from_bool(tcx: TyCtxt<'_, '_, 'tcx>, v: bool) -> &'tcx Self {\n         Self::from_bits(tcx, v as u128, ParamEnv::empty().and(tcx.types.bool))\n     }\n \n     #[inline]\n-    pub fn from_usize(tcx: TyCtxt<'_, '_, 'tcx>, n: u64) -> Self {\n+    pub fn from_usize(tcx: TyCtxt<'_, '_, 'tcx>, n: u64) -> &'tcx Self {\n         Self::from_bits(tcx, n as u128, ParamEnv::empty().and(tcx.types.usize))\n     }\n "}, {"sha": "eaa1dd186a536c39667e4bd3120a36f5719dba99", "filename": "src/librustc_codegen_ssa/mir/constant.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -13,7 +13,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn eval_mir_constant(\n         &mut self,\n         constant: &mir::Constant<'tcx>,\n-    ) -> Result<ty::Const<'tcx>, ErrorHandled> {\n+    ) -> Result<&'tcx ty::Const<'tcx>, ErrorHandled> {\n         match constant.literal.val {\n             mir::interpret::ConstValue::Unevaluated(def_id, ref substs) => {\n                 let substs = self.monomorphize(substs);\n@@ -26,7 +26,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 };\n                 self.cx.tcx().const_eval(ty::ParamEnv::reveal_all().and(cid))\n             },\n-            _ => Ok(*self.monomorphize(&constant.literal)),\n+            _ => Ok(self.monomorphize(&constant.literal)),\n         }\n     }\n \n@@ -36,7 +36,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         bx: &Bx,\n         span: Span,\n         ty: Ty<'tcx>,\n-        constant: Result<ty::Const<'tcx>, ErrorHandled>,\n+        constant: Result<&'tcx ty::Const<'tcx>, ErrorHandled>,\n     ) -> (Bx::Value, Ty<'tcx>) {\n         constant\n             .map(|c| {"}, {"sha": "ec471a1323eab917dd548d77c968fadb1b5d1621", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -1,7 +1,7 @@\n-use rustc::mir::interpret::{ConstValue, ErrorHandled};\n+use rustc::mir::interpret::{ConstValue, ErrorHandled, Pointer, Scalar};\n use rustc::mir;\n use rustc::ty;\n-use rustc::ty::layout::{self, Align, LayoutOf, TyLayout};\n+use rustc::ty::layout::{self, Align, LayoutOf, TyLayout, Size};\n \n use crate::base;\n use crate::MemFlags;\n@@ -67,7 +67,7 @@ impl<'a, 'tcx: 'a, V: CodegenObject> OperandRef<'tcx, V> {\n \n     pub fn from_const<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         bx: &mut Bx,\n-        val: ty::Const<'tcx>\n+        val: &'tcx ty::Const<'tcx>\n     ) -> Result<Self, ErrorHandled> {\n         let layout = bx.layout_of(val.ty);\n \n@@ -92,17 +92,21 @@ impl<'a, 'tcx: 'a, V: CodegenObject> OperandRef<'tcx, V> {\n                 );\n                 OperandValue::Immediate(llval)\n             },\n-            ConstValue::Slice(a, b) => {\n+            ConstValue::Slice { data, start, end } => {\n                 let a_scalar = match layout.abi {\n                     layout::Abi::ScalarPair(ref a, _) => a,\n                     _ => bug!(\"from_const: invalid ScalarPair layout: {:#?}\", layout)\n                 };\n+                let a = Scalar::from(Pointer::new(\n+                    bx.tcx().alloc_map.lock().allocate(data),\n+                    Size::from_bytes(start as u64),\n+                )).into();\n                 let a_llval = bx.scalar_to_backend(\n                     a,\n                     a_scalar,\n                     bx.scalar_pair_element_backend_type(layout, 0, true),\n                 );\n-                let b_llval = bx.const_usize(b);\n+                let b_llval = bx.const_usize((end - start) as u64);\n                 OperandValue::Pair(a_llval, b_llval)\n             },\n             ConstValue::ByRef(ptr, alloc) => {"}, {"sha": "864071629078aab7e011b94c60b296f0cbf5c818", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -96,6 +96,7 @@ use rustc::ty::print::{PrettyPrinter, Printer, Print};\n use rustc::ty::query::Providers;\n use rustc::ty::subst::{Kind, SubstsRef, UnpackedKind};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::mir::interpret::{ConstValue, Scalar};\n use rustc::util::common::record_time;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_mir::monomorphize::item::{InstantiationMode, MonoItem, MonoItemExt};\n@@ -391,6 +392,7 @@ impl Printer<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n     type Region = Self;\n     type Type = Self;\n     type DynExistential = Self;\n+    type Const = Self;\n \n     fn tcx(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         self.tcx\n@@ -436,6 +438,20 @@ impl Printer<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n         Ok(self)\n     }\n \n+    fn print_const(\n+        mut self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<Self::Const, Self::Error> {\n+        // only print integers\n+        if let ConstValue::Scalar(Scalar::Bits { .. }) = ct.val {\n+            if ct.ty.is_integral() {\n+                return self.pretty_print_const(ct);\n+            }\n+        }\n+        self.write_str(\"_\")?;\n+        Ok(self)\n+    }\n+\n     fn path_crate(\n         mut self,\n         cnum: CrateNum,"}, {"sha": "8c2ef082c339fc2af044a52323bf30709c692f7a", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -737,12 +737,12 @@ enum TestKind<'tcx> {\n     SwitchInt {\n         switch_ty: Ty<'tcx>,\n         options: Vec<u128>,\n-        indices: FxHashMap<ty::Const<'tcx>, usize>,\n+        indices: FxHashMap<&'tcx ty::Const<'tcx>, usize>,\n     },\n \n     // test for equality\n     Eq {\n-        value: ty::Const<'tcx>,\n+        value: &'tcx ty::Const<'tcx>,\n         ty: Ty<'tcx>,\n     },\n "}, {"sha": "0995a2f7fdf491ec37bf0cb0adc4453e5e4f0c1d", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -98,7 +98,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                      candidate: &Candidate<'pat, 'tcx>,\n                                      switch_ty: Ty<'tcx>,\n                                      options: &mut Vec<u128>,\n-                                     indices: &mut FxHashMap<ty::Const<'tcx>, usize>)\n+                                     indices: &mut FxHashMap<&'tcx ty::Const<'tcx>, usize>)\n                                      -> bool\n     {\n         let match_pair = match candidate.match_pairs.iter().find(|mp| mp.place == *test_place) {\n@@ -305,7 +305,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     }\n                     let eq_def_id = self.hir.tcx().lang_items().eq_trait().unwrap();\n                     let (mty, method) = self.hir.trait_method(eq_def_id, \"eq\", ty, &[ty.into()]);\n-                    let method = self.hir.tcx().mk_const(method);\n \n                     let re_erased = self.hir.tcx().lifetimes.re_erased;\n                     // take the argument by reference\n@@ -371,8 +370,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             TestKind::Range(PatternRange { ref lo, ref hi, ty, ref end }) => {\n                 // Test `val` by computing `lo <= val && val <= hi`, using primitive comparisons.\n-                let lo = self.literal_operand(test.span, ty.clone(), lo.clone());\n-                let hi = self.literal_operand(test.span, ty.clone(), hi.clone());\n+                let lo = self.literal_operand(test.span, ty, lo);\n+                let hi = self.literal_operand(test.span, ty, hi);\n                 let val = Operand::Copy(place.clone());\n \n                 let fail = self.cfg.start_new_block();\n@@ -724,7 +723,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     fn const_range_contains(\n         &self,\n         range: PatternRange<'tcx>,\n-        value: ty::Const<'tcx>,\n+        value: &'tcx ty::Const<'tcx>,\n     ) -> Option<bool> {\n         use std::cmp::Ordering::*;\n \n@@ -744,7 +743,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     fn values_not_contained_in_range(\n         &self,\n         range: PatternRange<'tcx>,\n-        indices: &FxHashMap<ty::Const<'tcx>, usize>,\n+        indices: &FxHashMap<&'tcx ty::Const<'tcx>, usize>,\n     ) -> Option<bool> {\n         for &val in indices.keys() {\n             if self.const_range_contains(range, val)? {"}, {"sha": "daf59d7a1353c1f70913c51ebf5d343b18b88643", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -27,13 +27,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn literal_operand(&mut self,\n                            span: Span,\n                            ty: Ty<'tcx>,\n-                           literal: ty::Const<'tcx>)\n+                           literal: &'tcx ty::Const<'tcx>)\n                            -> Operand<'tcx> {\n         let constant = box Constant {\n             span,\n             ty,\n             user_ty: None,\n-            literal: self.hir.tcx().mk_const(literal),\n+            literal,\n         };\n         Operand::Constant(constant)\n     }"}, {"sha": "776d4c242415a494dfc72c5d9183b139d627fbf0", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 36, "deletions": 10, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -5,6 +5,7 @@ use std::error::Error;\n use std::borrow::{Borrow, Cow};\n use std::hash::Hash;\n use std::collections::hash_map::Entry;\n+use std::convert::TryInto;\n \n use rustc::hir::def::DefKind;\n use rustc::hir::def_id::DefId;\n@@ -65,7 +66,7 @@ pub(crate) fn eval_promoted<'a, 'mir, 'tcx>(\n fn mplace_to_const<'tcx>(\n     ecx: &CompileTimeEvalContext<'_, '_, 'tcx>,\n     mplace: MPlaceTy<'tcx>,\n-) -> ty::Const<'tcx> {\n+) -> &'tcx ty::Const<'tcx> {\n     let MemPlace { ptr, align, meta } = *mplace;\n     // extract alloc-offset pair\n     assert!(meta.is_none());\n@@ -79,17 +80,24 @@ fn mplace_to_const<'tcx>(\n     // interned this?  I thought that is the entire point of that `FinishStatic` stuff?\n     let alloc = ecx.tcx.intern_const_alloc(alloc);\n     let val = ConstValue::ByRef(ptr, alloc);\n-    ty::Const { val, ty: mplace.layout.ty }\n+    ecx.tcx.mk_const(ty::Const { val, ty: mplace.layout.ty })\n }\n \n fn op_to_const<'tcx>(\n     ecx: &CompileTimeEvalContext<'_, '_, 'tcx>,\n     op: OpTy<'tcx>,\n-) -> ty::Const<'tcx> {\n+) -> &'tcx ty::Const<'tcx> {\n     // We do not normalize just any data.  Only non-union scalars and slices.\n     let normalize = match op.layout.abi {\n         layout::Abi::Scalar(..) => op.layout.ty.ty_adt_def().map_or(true, |adt| !adt.is_union()),\n-        layout::Abi::ScalarPair(..) => op.layout.ty.is_slice(),\n+        layout::Abi::ScalarPair(..) => match op.layout.ty.sty {\n+            ty::Ref(_, inner, _) => match inner.sty {\n+                ty::Slice(elem) => elem == ecx.tcx.types.u8,\n+                ty::Str => true,\n+                _ => false,\n+            },\n+            _ => false,\n+        },\n         _ => false,\n     };\n     let normalized_op = if normalize {\n@@ -101,10 +109,28 @@ fn op_to_const<'tcx>(\n         Ok(mplace) => return mplace_to_const(ecx, mplace),\n         Err(Immediate::Scalar(x)) =>\n             ConstValue::Scalar(x.not_undef().unwrap()),\n-        Err(Immediate::ScalarPair(a, b)) =>\n-            ConstValue::Slice(a.not_undef().unwrap(), b.to_usize(ecx).unwrap()),\n+        Err(Immediate::ScalarPair(a, b)) => {\n+            let (data, start) = match a.not_undef().unwrap() {\n+                Scalar::Ptr(ptr) => (\n+                    ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id),\n+                    ptr.offset.bytes(),\n+                ),\n+                Scalar::Bits { .. } => (\n+                    ecx.tcx.intern_const_alloc(Allocation::from_byte_aligned_bytes(b\"\", ())),\n+                    0,\n+                ),\n+            };\n+            let len = b.to_usize(&ecx.tcx.tcx).unwrap();\n+            let start = start.try_into().unwrap();\n+            let len: usize = len.try_into().unwrap();\n+            ConstValue::Slice {\n+                data,\n+                start,\n+                end: start + len,\n+            }\n+        },\n     };\n-    ty::Const { val, ty: op.layout.ty }\n+    ecx.tcx.mk_const(ty::Const { val, ty: op.layout.ty })\n }\n \n // Returns a pointer to where the result lives\n@@ -450,8 +476,8 @@ pub fn const_field<'a, 'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n     variant: Option<VariantIdx>,\n     field: mir::Field,\n-    value: ty::Const<'tcx>,\n-) -> ty::Const<'tcx> {\n+    value: &'tcx ty::Const<'tcx>,\n+) -> &'tcx ty::Const<'tcx> {\n     trace!(\"const_field: {:?}, {:?}\", field, value);\n     let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env);\n     // get the operand again\n@@ -473,7 +499,7 @@ pub fn const_field<'a, 'tcx>(\n pub fn const_variant_index<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    val: ty::Const<'tcx>,\n+    val: &'tcx ty::Const<'tcx>,\n ) -> VariantIdx {\n     trace!(\"const_variant_index: {:?}\", val);\n     let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env);"}, {"sha": "d2c86d36238e1eeb76358dfe8e9cb0cd32f71a69", "filename": "src/librustc_mir/hair/constant.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fconstant.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -14,7 +14,7 @@ crate fn lit_to_const<'a, 'gcx, 'tcx>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     ty: Ty<'tcx>,\n     neg: bool,\n-) -> Result<ty::Const<'tcx>, LitToConstError> {\n+) -> Result<&'tcx ty::Const<'tcx>, LitToConstError> {\n     use syntax::ast::*;\n \n     let trunc = |n| {\n@@ -33,16 +33,18 @@ crate fn lit_to_const<'a, 'gcx, 'tcx>(\n     let lit = match *lit {\n         LitKind::Str(ref s, _) => {\n             let s = s.as_str();\n-            let id = tcx.allocate_bytes(s.as_bytes());\n-            ConstValue::new_slice(Scalar::Ptr(id.into()), s.len() as u64)\n+            let allocation = Allocation::from_byte_aligned_bytes(s.as_bytes(), ());\n+            let allocation = tcx.intern_const_alloc(allocation);\n+            ConstValue::Slice { data: allocation, start: 0, end: s.len() }\n         },\n         LitKind::Err(ref s) => {\n             let s = s.as_str();\n-            let id = tcx.allocate_bytes(s.as_bytes());\n-            return Ok(ty::Const {\n-                val: ConstValue::new_slice(Scalar::Ptr(id.into()), s.len() as u64),\n+            let allocation = Allocation::from_byte_aligned_bytes(s.as_bytes(), ());\n+            let allocation = tcx.intern_const_alloc(allocation);\n+            return Ok(tcx.mk_const(ty::Const {\n+                val: ConstValue::Slice{ data: allocation, start: 0, end: s.len() },\n                 ty: tcx.types.err,\n-            });\n+            }));\n         },\n         LitKind::ByteStr(ref data) => {\n             let id = tcx.allocate_bytes(data);\n@@ -71,7 +73,7 @@ crate fn lit_to_const<'a, 'gcx, 'tcx>(\n         LitKind::Bool(b) => ConstValue::Scalar(Scalar::from_bool(b)),\n         LitKind::Char(c) => ConstValue::Scalar(Scalar::from_char(c)),\n     };\n-    Ok(ty::Const { val: lit, ty })\n+    Ok(tcx.mk_const(ty::Const { val: lit, ty }))\n }\n \n fn parse_float<'tcx>("}, {"sha": "ca457b0ac7c727374129907b2bf334379fc40db9", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -329,9 +329,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprKind::Lit(ref lit) => ExprKind::Literal {\n-            literal: cx.tcx.mk_const(\n-                cx.const_eval_literal(&lit.node, expr_ty, lit.span, false)\n-            ),\n+            literal: cx.const_eval_literal(&lit.node, expr_ty, lit.span, false),\n             user_ty: None,\n         },\n \n@@ -429,9 +427,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             } else {\n                 if let hir::ExprKind::Lit(ref lit) = arg.node {\n                     ExprKind::Literal {\n-                        literal: cx.tcx.mk_const(\n-                            cx.const_eval_literal(&lit.node, expr_ty, lit.span, true)\n-                        ),\n+                        literal: cx.const_eval_literal(&lit.node, expr_ty, lit.span, true),\n                         user_ty: None,\n                     }\n                 } else {\n@@ -680,7 +676,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         ty: var_ty,\n                         span: expr.span,\n                         kind: ExprKind::Literal {\n-                            literal: cx.tcx.mk_const(literal),\n+                            literal,\n                             user_ty: None\n                         },\n                     }.to_ref();\n@@ -694,10 +690,10 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                             // in case we are offsetting from a computed discriminant\n                             // and not the beginning of discriminants (which is always `0`)\n                             let substs = InternalSubsts::identity_for_item(cx.tcx(), did);\n-                            let lhs = mk_const(ty::Const {\n+                            let lhs = mk_const(cx.tcx().mk_const(ty::Const {\n                                 val: ConstValue::Unevaluated(did, substs),\n                                 ty: var_ty,\n-                            });\n+                            }));\n                             let bin = ExprKind::Binary {\n                                 op: BinOp::Add,\n                                 lhs,\n@@ -837,9 +833,7 @@ fn method_callee<'a, 'gcx, 'tcx>(\n         ty,\n         span,\n         kind: ExprKind::Literal {\n-            literal: cx.tcx().mk_const(\n-                ty::Const::zero_sized(ty)\n-            ),\n+            literal: ty::Const::zero_sized(cx.tcx(), ty),\n             user_ty,\n         },\n     }\n@@ -902,9 +896,10 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             let user_ty = user_substs_applied_to_res(cx, expr.hir_id, res);\n             debug!(\"convert_path_expr: user_ty={:?}\", user_ty);\n             ExprKind::Literal {\n-                literal: cx.tcx.mk_const(ty::Const::zero_sized(\n+                literal: ty::Const::zero_sized(\n+                    cx.tcx,\n                     cx.tables().node_type(expr.hir_id),\n-                )),\n+                ),\n                 user_ty,\n             }\n         }"}, {"sha": "c993a02a6decc2391df6326cddd9d6ce47921904", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -106,7 +106,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn usize_literal(&mut self, value: u64) -> &'tcx ty::Const<'tcx> {\n-        self.tcx.mk_const(ty::Const::from_usize(self.tcx, value))\n+        ty::Const::from_usize(self.tcx, value)\n     }\n \n     pub fn bool_ty(&mut self) -> Ty<'tcx> {\n@@ -118,11 +118,11 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn true_literal(&mut self) -> &'tcx ty::Const<'tcx> {\n-        self.tcx.mk_const(ty::Const::from_bool(self.tcx, true))\n+        ty::Const::from_bool(self.tcx, true)\n     }\n \n     pub fn false_literal(&mut self) -> &'tcx ty::Const<'tcx> {\n-        self.tcx.mk_const(ty::Const::from_bool(self.tcx, false))\n+        ty::Const::from_bool(self.tcx, false)\n     }\n \n     pub fn const_eval_literal(\n@@ -131,7 +131,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         ty: Ty<'tcx>,\n         sp: Span,\n         neg: bool,\n-    ) -> ty::Const<'tcx> {\n+    ) -> &'tcx ty::Const<'tcx> {\n         trace!(\"const_eval_literal: {:#?}, {:?}, {:?}, {:?}\", lit, ty, sp, neg);\n \n         match lit_to_const(lit, self.tcx, ty, neg) {\n@@ -166,14 +166,14 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                         method_name: &str,\n                         self_ty: Ty<'tcx>,\n                         params: &[Kind<'tcx>])\n-                        -> (Ty<'tcx>, ty::Const<'tcx>) {\n+                        -> (Ty<'tcx>, &'tcx ty::Const<'tcx>) {\n         let method_name = Symbol::intern(method_name);\n         let substs = self.tcx.mk_substs_trait(self_ty, params);\n         for item in self.tcx.associated_items(trait_def_id) {\n             if item.kind == ty::AssociatedKind::Method && item.ident.name == method_name {\n                 let method_ty = self.tcx.type_of(item.def_id);\n                 let method_ty = method_ty.subst(self.tcx, substs);\n-                return (method_ty, ty::Const::zero_sized(method_ty));\n+                return (method_ty, ty::Const::zero_sized(self.tcx, method_ty));\n             }\n         }\n "}, {"sha": "29e9c425685e858bf9e3ac31b28dd7343b438bd8", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 52, "deletions": 81, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -172,7 +172,7 @@ use rustc::ty::{self, Ty, TyCtxt, TypeFoldable, Const};\n use rustc::ty::layout::{Integer, IntegerExt, VariantIdx, Size};\n \n use rustc::mir::Field;\n-use rustc::mir::interpret::{ConstValue, Scalar, truncate};\n+use rustc::mir::interpret::{ConstValue, Scalar, truncate, AllocId, Pointer};\n use rustc::util::common::ErrorReported;\n \n use syntax::attr::{SignedInt, UnsignedInt};\n@@ -186,6 +186,7 @@ use std::fmt;\n use std::iter::{FromIterator, IntoIterator};\n use std::ops::RangeInclusive;\n use std::u128;\n+use std::convert::TryInto;\n \n pub fn expand_pattern<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>, pat: Pattern<'tcx>)\n                                 -> &'a Pattern<'tcx>\n@@ -221,16 +222,17 @@ impl<'a, 'tcx> LiteralExpander<'a, 'tcx> {\n             // unsize array to slice if pattern is array but match value or other patterns are slice\n             (ConstValue::Scalar(Scalar::Ptr(p)), ty::Array(t, n), ty::Slice(u)) => {\n                 assert_eq!(t, u);\n-                ConstValue::Slice(\n-                    Scalar::Ptr(p),\n-                    n.val.try_to_scalar()\n-                        .unwrap()\n-                        .to_usize(&self.tcx)\n-                        .unwrap(),\n-                )\n+                ConstValue::Slice {\n+                    data: self.tcx.alloc_map.lock().unwrap_memory(p.alloc_id),\n+                    start: p.offset.bytes().try_into().unwrap(),\n+                    end: n.unwrap_usize(self.tcx).try_into().unwrap(),\n+                }\n             },\n             // fat pointers stay the same\n-            (ConstValue::Slice(..), _, _) => val,\n+            | (ConstValue::Slice { .. }, _, _)\n+            | (_, ty::Slice(_), ty::Slice(_))\n+            | (_, ty::Str, ty::Str)\n+            => val,\n             // FIXME(oli-obk): this is reachable for `const FOO: &&&u32 = &&&42;` being used\n             _ => bug!(\"cannot deref {:#?}, {} -> {}\", val, crty, rty),\n         }\n@@ -255,10 +257,10 @@ impl<'a, 'tcx> PatternFolder<'tcx> for LiteralExpander<'a, 'tcx> {\n                         subpattern: Pattern {\n                             ty: rty,\n                             span: pat.span,\n-                            kind: box PatternKind::Constant { value: Const {\n-                                val: self.fold_const_value_deref(val, rty, crty),\n+                            kind: box PatternKind::Constant { value: self.tcx.mk_const(Const {\n+                                val: self.fold_const_value_deref(*val, rty, crty),\n                                 ty: rty,\n-                            } },\n+                            }) },\n                         }\n                     }\n                 }\n@@ -423,7 +425,7 @@ enum Constructor<'tcx> {\n     /// Enum variants.\n     Variant(DefId),\n     /// Literal values.\n-    ConstantValue(ty::Const<'tcx>),\n+    ConstantValue(&'tcx ty::Const<'tcx>),\n     /// Ranges of literal values (`2...5` and `2..5`).\n     ConstantRange(u128, u128, Ty<'tcx>, RangeEnd),\n     /// Array patterns of length n.\n@@ -786,9 +788,9 @@ fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n                         max_fixed_len,\n                         n.unwrap_usize(cx.tcx),\n                     ),\n-                    (ConstValue::Slice(_, n), ty::Slice(_)) => max_fixed_len = cmp::max(\n+                    (ConstValue::Slice{ start, end, .. }, ty::Slice(_)) => max_fixed_len = cmp::max(\n                         max_fixed_len,\n-                        n,\n+                        (end - start) as u64,\n                     ),\n                     _ => {},\n                 }\n@@ -1424,49 +1426,24 @@ fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n fn slice_pat_covered_by_const<'tcx>(\n     tcx: TyCtxt<'_, 'tcx, '_>,\n     _span: Span,\n-    const_val: ty::Const<'tcx>,\n+    const_val: &'tcx ty::Const<'tcx>,\n     prefix: &[Pattern<'tcx>],\n     slice: &Option<Pattern<'tcx>>,\n     suffix: &[Pattern<'tcx>]\n ) -> Result<bool, ErrorReported> {\n     let data: &[u8] = match (const_val.val, &const_val.ty.sty) {\n         (ConstValue::ByRef(ptr, alloc), ty::Array(t, n)) => {\n-            if *t != tcx.types.u8 {\n-                // FIXME(oli-obk): can't mix const patterns with slice patterns and get\n-                // any sort of exhaustiveness/unreachable check yet\n-                // This solely means that we don't lint about unreachable patterns, even if some\n-                // are definitely unreachable.\n-                return Ok(false);\n-            }\n+            assert_eq!(*t, tcx.types.u8);\n             let n = n.assert_usize(tcx).unwrap();\n             alloc.get_bytes(&tcx, ptr, Size::from_bytes(n)).unwrap()\n         },\n-        // a slice fat pointer to a zero length slice\n-        (ConstValue::Slice(Scalar::Bits { .. }, 0), ty::Slice(t)) => {\n-            if *t != tcx.types.u8 {\n-                // FIXME(oli-obk): can't mix const patterns with slice patterns and get\n-                // any sort of exhaustiveness/unreachable check yet\n-                // This solely means that we don't lint about unreachable patterns, even if some\n-                // are definitely unreachable.\n-                return Ok(false);\n-            }\n-            &[]\n-        },\n-        //\n-        (ConstValue::Slice(Scalar::Ptr(ptr), n), ty::Slice(t)) => {\n-            if *t != tcx.types.u8 {\n-                // FIXME(oli-obk): can't mix const patterns with slice patterns and get\n-                // any sort of exhaustiveness/unreachable check yet\n-                // This solely means that we don't lint about unreachable patterns, even if some\n-                // are definitely unreachable.\n-                return Ok(false);\n-            }\n-            tcx.alloc_map\n-                .lock()\n-                .unwrap_memory(ptr.alloc_id)\n-                .get_bytes(&tcx, ptr, Size::from_bytes(n))\n-                .unwrap()\n+        (ConstValue::Slice { data, start, end }, ty::Slice(t)) => {\n+            assert_eq!(*t, tcx.types.u8);\n+            let ptr = Pointer::new(AllocId(0), Size::from_bytes(start as u64));\n+            data.get_bytes(&tcx, ptr, Size::from_bytes((end - start) as u64)).unwrap()\n         },\n+        // FIXME(oli-obk): create a way to extract fat pointers from ByRef\n+        (_, ty::Slice(_)) => return Ok(false),\n         _ => bug!(\n             \"slice_pat_covered_by_const: {:#?}, {:#?}, {:#?}, {:#?}\",\n             const_val, prefix, slice, suffix,\n@@ -1774,11 +1751,12 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                     // necessarily point to memory, they are usually just integers. The only time\n                     // they should be pointing to memory is when they are subslices of nonzero\n                     // slices\n-                    let (opt_ptr, n, ty) = match value.ty.sty {\n+                    let (alloc, offset, n, ty) = match value.ty.sty {\n                         ty::Array(t, n) => {\n                             match value.val {\n                                 ConstValue::ByRef(ptr, alloc) => (\n-                                    Some((ptr, alloc)),\n+                                    alloc,\n+                                    ptr.offset,\n                                     n.unwrap_usize(cx.tcx),\n                                     t,\n                                 ),\n@@ -1790,14 +1768,16 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                         },\n                         ty::Slice(t) => {\n                             match value.val {\n-                                ConstValue::Slice(ptr, n) => (\n-                                    ptr.to_ptr().ok().map(|ptr| (\n-                                        ptr,\n-                                        cx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id),\n-                                    )),\n-                                    n,\n+                                ConstValue::Slice { data, start, end } => (\n+                                    data,\n+                                    Size::from_bytes(start as u64),\n+                                    (end - start) as u64,\n                                     t,\n                                 ),\n+                                ConstValue::ByRef(..) => {\n+                                    // FIXME(oli-obk): implement `deref` for `ConstValue`\n+                                    return None;\n+                                },\n                                 _ => span_bug!(\n                                     pat.span,\n                                     \"slice pattern constant must be scalar pair but is {:?}\",\n@@ -1814,31 +1794,22 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                     };\n                     if wild_patterns.len() as u64 == n {\n                         // convert a constant slice/array pattern to a list of patterns.\n-                        match (n, opt_ptr) {\n-                            (0, _) => Some(SmallVec::new()),\n-                            (_, Some((ptr, alloc))) => {\n-                                let layout = cx.tcx.layout_of(cx.param_env.and(ty)).ok()?;\n-                                (0..n).map(|i| {\n-                                    let ptr = ptr.offset(layout.size * i, &cx.tcx).ok()?;\n-                                    let scalar = alloc.read_scalar(\n-                                        &cx.tcx, ptr, layout.size,\n-                                    ).ok()?;\n-                                    let scalar = scalar.not_undef().ok()?;\n-                                    let value = ty::Const::from_scalar(scalar, ty);\n-                                    let pattern = Pattern {\n-                                        ty,\n-                                        span: pat.span,\n-                                        kind: box PatternKind::Constant { value },\n-                                    };\n-                                    Some(&*cx.pattern_arena.alloc(pattern))\n-                                }).collect()\n-                            },\n-                            (_, None) => span_bug!(\n-                                pat.span,\n-                                \"non zero length slice with const-val {:?}\",\n-                                value,\n-                            ),\n-                        }\n+                        let layout = cx.tcx.layout_of(cx.param_env.and(ty)).ok()?;\n+                        let ptr = Pointer::new(AllocId(0), offset);\n+                        (0..n).map(|i| {\n+                            let ptr = ptr.offset(layout.size * i, &cx.tcx).ok()?;\n+                            let scalar = alloc.read_scalar(\n+                                &cx.tcx, ptr, layout.size,\n+                            ).ok()?;\n+                            let scalar = scalar.not_undef().ok()?;\n+                            let value = ty::Const::from_scalar(cx.tcx, scalar, ty);\n+                            let pattern = Pattern {\n+                                ty,\n+                                span: pat.span,\n+                                kind: box PatternKind::Constant { value },\n+                            };\n+                            Some(&*cx.pattern_arena.alloc(pattern))\n+                        }).collect()\n                     } else {\n                         None\n                     }"}, {"sha": "1c47f850ddb75d051a382ea3b22d50d9ebeccdc1", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 34, "deletions": 31, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -10,13 +10,13 @@ use crate::const_eval::{const_field, const_variant_index};\n use crate::hair::util::UserAnnotatedTyHelpers;\n use crate::hair::constant::*;\n \n-use rustc::mir::{fmt_const_val, Field, BorrowKind, Mutability};\n+use rustc::mir::{Field, BorrowKind, Mutability};\n use rustc::mir::{UserTypeProjection};\n-use rustc::mir::interpret::{Scalar, GlobalId, ConstValue, sign_extend};\n+use rustc::mir::interpret::{GlobalId, ConstValue, sign_extend, AllocId, Pointer};\n use rustc::ty::{self, Region, TyCtxt, AdtDef, Ty, UserType, DefIdTree};\n use rustc::ty::{CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations};\n use rustc::ty::subst::{SubstsRef, Kind};\n-use rustc::ty::layout::VariantIdx;\n+use rustc::ty::layout::{VariantIdx, Size};\n use rustc::hir::{self, PatKind, RangeEnd};\n use rustc::hir::def::{CtorOf, Res, DefKind, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n@@ -152,7 +152,7 @@ pub enum PatternKind<'tcx> {\n     },\n \n     Constant {\n-        value: ty::Const<'tcx>,\n+        value: &'tcx ty::Const<'tcx>,\n     },\n \n     Range(PatternRange<'tcx>),\n@@ -176,8 +176,8 @@ pub enum PatternKind<'tcx> {\n \n #[derive(Copy, Clone, Debug, PartialEq)]\n pub struct PatternRange<'tcx> {\n-    pub lo: ty::Const<'tcx>,\n-    pub hi: ty::Const<'tcx>,\n+    pub lo: &'tcx ty::Const<'tcx>,\n+    pub hi: &'tcx ty::Const<'tcx>,\n     pub ty: Ty<'tcx>,\n     pub end: RangeEnd,\n }\n@@ -291,15 +291,15 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n                 write!(f, \"{}\", subpattern)\n             }\n             PatternKind::Constant { value } => {\n-                fmt_const_val(f, value)\n+                write!(f, \"{}\", value)\n             }\n             PatternKind::Range(PatternRange { lo, hi, ty: _, end }) => {\n-                fmt_const_val(f, lo)?;\n+                write!(f, \"{}\", lo)?;\n                 match end {\n                     RangeEnd::Included => write!(f, \"..=\")?,\n                     RangeEnd::Excluded => write!(f, \"..\")?,\n                 }\n-                fmt_const_val(f, hi)\n+                write!(f, \"{}\", hi)\n             }\n             PatternKind::Slice { ref prefix, ref slice, ref suffix } |\n             PatternKind::Array { ref prefix, ref slice, ref suffix } => {\n@@ -942,7 +942,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n     fn const_to_pat(\n         &self,\n         instance: ty::Instance<'tcx>,\n-        cv: ty::Const<'tcx>,\n+        cv: &'tcx ty::Const<'tcx>,\n         id: hir::HirId,\n         span: Span,\n     ) -> Pattern<'tcx> {\n@@ -1205,16 +1205,16 @@ impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n             PatternKind::Constant {\n                 value\n             } => PatternKind::Constant {\n-                value: value.fold_with(folder)\n+                value,\n             },\n             PatternKind::Range(PatternRange {\n                 lo,\n                 hi,\n                 ty,\n                 end,\n             }) => PatternKind::Range(PatternRange {\n-                lo: lo.fold_with(folder),\n-                hi: hi.fold_with(folder),\n+                lo,\n+                hi,\n                 ty: ty.fold_with(folder),\n                 end,\n             }),\n@@ -1242,8 +1242,8 @@ impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n \n pub fn compare_const_vals<'a, 'gcx, 'tcx>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    a: ty::Const<'tcx>,\n-    b: ty::Const<'tcx>,\n+    a: &'tcx ty::Const<'tcx>,\n+    b: &'tcx ty::Const<'tcx>,\n     ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n ) -> Option<Ordering> {\n     trace!(\"compare_const_vals: {:?}, {:?}\", a, b);\n@@ -1293,22 +1293,25 @@ pub fn compare_const_vals<'a, 'gcx, 'tcx>(\n     if let ty::Str = ty.value.sty {\n         match (a.val, b.val) {\n             (\n-                ConstValue::Slice(\n-                    Scalar::Ptr(ptr_a),\n-                    len_a,\n-                ),\n-                ConstValue::Slice(\n-                    Scalar::Ptr(ptr_b),\n-                    len_b,\n-                ),\n-            ) if ptr_a.offset.bytes() == 0 && ptr_b.offset.bytes() == 0 => {\n-                if len_a == len_b {\n-                    let map = tcx.alloc_map.lock();\n-                    let alloc_a = map.unwrap_memory(ptr_a.alloc_id);\n-                    let alloc_b = map.unwrap_memory(ptr_b.alloc_id);\n-                    if alloc_a.bytes.len() as u64 == len_a {\n-                        return from_bool(alloc_a == alloc_b);\n-                    }\n+                ConstValue::Slice { data: alloc_a, start: offset_a, end: end_a },\n+                ConstValue::Slice { data: alloc_b, start: offset_b, end: end_b },\n+            ) => {\n+                let len_a = end_a - offset_a;\n+                let len_b = end_b - offset_b;\n+                let a = alloc_a.get_bytes(\n+                    &tcx,\n+                    // invent a pointer, only the offset is relevant anyway\n+                    Pointer::new(AllocId(0), Size::from_bytes(offset_a as u64)),\n+                    Size::from_bytes(len_a as u64),\n+                );\n+                let b = alloc_b.get_bytes(\n+                    &tcx,\n+                    // invent a pointer, only the offset is relevant anyway\n+                    Pointer::new(AllocId(0), Size::from_bytes(offset_b as u64)),\n+                    Size::from_bytes(len_b as u64),\n+                );\n+                if let (Ok(a), Ok(b)) = (a, b) {\n+                    return from_bool(a == b);\n                 }\n             }\n             _ => (),"}, {"sha": "e26b147ea581dd82a6fba1b2bf037fc89d516941", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -512,7 +512,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n             Move(ref place) =>\n                 self.eval_place_to_op(place, layout)?,\n \n-            Constant(ref constant) => self.eval_const_to_op(*constant.literal, layout)?,\n+            Constant(ref constant) => self.eval_const_to_op(constant.literal, layout)?,\n         };\n         trace!(\"{:?}: {:?}\", mir_op, *op);\n         Ok(op)\n@@ -532,7 +532,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n     // in patterns via the `const_eval` module\n     crate fn eval_const_to_op(\n         &self,\n-        val: ty::Const<'tcx>,\n+        val: &'tcx ty::Const<'tcx>,\n         layout: Option<TyLayout<'tcx>>,\n     ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         let op = match val.val {\n@@ -545,11 +545,16 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                     MemPlace::from_ptr(ptr.with_default_tag(), alloc.align)\n                 )\n             },\n-            ConstValue::Slice(a, b) =>\n+            ConstValue::Slice { data, start, end } =>\n                 Operand::Immediate(Immediate::ScalarPair(\n-                    a.with_default_tag().into(),\n-                    Scalar::from_uint(b, self.tcx.data_layout.pointer_size)\n-                        .with_default_tag().into(),\n+                    Scalar::from(Pointer::new(\n+                        self.tcx.alloc_map.lock().allocate(data),\n+                        Size::from_bytes(start as u64),\n+                    )).with_default_tag().into(),\n+                    Scalar::from_uint(\n+                        (end - start) as u64,\n+                        self.tcx.data_layout.pointer_size,\n+                    ).with_default_tag().into(),\n                 )),\n             ConstValue::Scalar(x) =>\n                 Operand::Immediate(Immediate::Scalar(x.with_default_tag().into())),"}, {"sha": "b90db7646d4929f1be224ccc83f112cfefbac787", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -609,7 +609,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n     fn visit_const(&mut self, constant: &&'tcx ty::Const<'tcx>, location: Location) {\n         debug!(\"visiting const {:?} @ {:?}\", *constant, location);\n \n-        collect_const(self.tcx, **constant, self.param_substs, self.output);\n+        collect_const(self.tcx, *constant, self.param_substs, self.output);\n \n         self.super_const(constant);\n     }\n@@ -1248,17 +1248,17 @@ fn def_id_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n fn collect_const<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    constant: ty::Const<'tcx>,\n+    constant: &'tcx ty::Const<'tcx>,\n     param_substs: SubstsRef<'tcx>,\n     output: &mut Vec<MonoItem<'tcx>>,\n ) {\n     debug!(\"visiting const {:?}\", constant);\n \n     match constant.val {\n-        ConstValue::Slice(Scalar::Ptr(ptr), _) |\n         ConstValue::Scalar(Scalar::Ptr(ptr)) =>\n             collect_miri(tcx, ptr.alloc_id, output),\n-        ConstValue::ByRef(_ptr, alloc) => {\n+        ConstValue::Slice { data: alloc, start: _, end: _ } |\n+        ConstValue::ByRef(_, alloc) => {\n             for &((), id) in alloc.relocations.values() {\n                 collect_miri(tcx, id, output);\n             }"}, {"sha": "8b44f148facf6dd9608fbe88f8677a64bf08dfad", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -401,7 +401,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n     // as well as the unprintable types of constants (see `push_type_name` for more details).\n     pub fn push_const_name(&self, c: &Const<'tcx>, output: &mut String, debug: bool) {\n         match c.val {\n-            ConstValue::Scalar(..) | ConstValue::Slice(..) | ConstValue::ByRef(..) => {\n+            ConstValue::Scalar(..) | ConstValue::Slice { .. } | ConstValue::ByRef(..) => {\n                 // FIXME(const_generics): we could probably do a better job here.\n                 write!(output, \"{:?}\", c).unwrap()\n             }"}, {"sha": "8be660ae17ae90ebfe5ba564d29d4655dadcb76a", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -458,9 +458,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n             span: self.span,\n             ty: func_ty,\n             user_ty: None,\n-            literal: tcx.mk_const(\n-                ty::Const::zero_sized(func_ty),\n-            ),\n+            literal: ty::Const::zero_sized(tcx, func_ty),\n         });\n \n         let ref_loc = self.make_place(\n@@ -520,9 +518,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n             span: self.span,\n             ty: self.tcx.types.usize,\n             user_ty: None,\n-            literal: self.tcx.mk_const(\n-                ty::Const::from_usize(self.tcx, value),\n-            ),\n+            literal: ty::Const::from_usize(self.tcx, value),\n         }\n     }\n \n@@ -762,9 +758,7 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 span,\n                 ty,\n                 user_ty: None,\n-                literal: tcx.mk_const(\n-                    ty::Const::zero_sized(ty)\n-                ),\n+                literal: ty::Const::zero_sized(tcx, ty),\n              }),\n              vec![rcvr])\n         }"}, {"sha": "2f6793e049419989b895e41610519ef4185bb57a", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -282,7 +282,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n         c: &Constant<'tcx>,\n     ) -> Option<Const<'tcx>> {\n         self.ecx.tcx.span = c.span;\n-        match self.ecx.eval_const_to_op(*c.literal, None) {\n+        match self.ecx.eval_const_to_op(c.literal, None) {\n             Ok(op) => {\n                 Some(op)\n             },\n@@ -506,7 +506,8 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                 span,\n                 ty,\n                 user_ty: None,\n-                literal: self.tcx.mk_const(ty::Const::from_scalar(\n+                literal: self.tcx.mk_const(*ty::Const::from_scalar(\n+                    self.tcx,\n                     scalar,\n                     ty,\n                 ))"}, {"sha": "6320cb442481448da19a9385b22d3dbce41a3c78", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -533,9 +533,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             span,\n             ty: self.tcx.types.bool,\n             user_ty: None,\n-            literal: self.tcx.mk_const(\n-                ty::Const::from_bool(self.tcx, val),\n-            ),\n+            literal: ty::Const::from_bool(self.tcx, val),\n         })))\n     }\n "}, {"sha": "ab2f2933a969e62519c2e65714d10a0db0b7f6e9", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -757,9 +757,7 @@ fn insert_panic_block<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             span: mir.span,\n             ty: tcx.types.bool,\n             user_ty: None,\n-            literal: tcx.mk_const(\n-                ty::Const::from_bool(tcx, false),\n-            ),\n+            literal: ty::Const::from_bool(tcx, false),\n         }),\n         expected: true,\n         msg: message,"}, {"sha": "ac5ebc5e2512a9de4b668b184ca70a7442751404", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -975,9 +975,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             span: self.source_info.span,\n             ty: self.tcx().types.usize,\n             user_ty: None,\n-            literal: self.tcx().mk_const(\n-                ty::Const::from_usize(self.tcx(), val.into())\n-            ),\n+            literal: ty::Const::from_usize(self.tcx(), val.into()),\n         })\n     }\n "}, {"sha": "b5bb62a0f460c73b19bcee881be94099eac232a3", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -4441,7 +4441,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if element_ty.references_error() {\n                     tcx.types.err\n                 } else if let Ok(count) = count {\n-                    tcx.mk_ty(ty::Array(t, tcx.mk_const(count)))\n+                    tcx.mk_ty(ty::Array(t, count))\n                 } else {\n                     tcx.types.err\n                 }"}, {"sha": "fb0caa55ffbb496671b1ecf58b964ed2a4de82e1", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -2956,7 +2956,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n             ty::Str => Primitive(PrimitiveType::Str),\n             ty::Slice(ty) => Slice(box ty.clean(cx)),\n             ty::Array(ty, n) => {\n-                let mut n = *cx.tcx.lift(&n).expect(\"array lift failed\");\n+                let mut n = cx.tcx.lift(&n).expect(\"array lift failed\");\n                 if let ConstValue::Unevaluated(def_id, substs) = n.val {\n                     let param_env = cx.tcx.param_env(def_id);\n                     let cid = GlobalId {\n@@ -4126,7 +4126,7 @@ fn name_from_pat(p: &hir::Pat) -> String {\n     }\n }\n \n-fn print_const(cx: &DocContext<'_>, n: ty::Const<'_>) -> String {\n+fn print_const(cx: &DocContext<'_>, n: &ty::Const<'_>) -> String {\n     match n.val {\n         ConstValue::Unevaluated(def_id, _) => {\n             if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(def_id) {\n@@ -4136,12 +4136,15 @@ fn print_const(cx: &DocContext<'_>, n: ty::Const<'_>) -> String {\n             }\n         },\n         _ => {\n-            let mut s = String::new();\n-            ::rustc::mir::fmt_const_val(&mut s, n).expect(\"fmt_const_val failed\");\n+            let mut s = n.to_string();\n             // array lengths are obviously usize\n             if s.ends_with(\"usize\") {\n                 let n = s.len() - \"usize\".len();\n                 s.truncate(n);\n+                if s.ends_with(\": \") {\n+                    let n = s.len() - \": \".len();\n+                    s.truncate(n);\n+                }\n             }\n             s\n         },"}, {"sha": "9f55d8496440561a2b4f0b3bf6c6fd3ebe246129", "filename": "src/test/mir-opt/box_expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Ftest%2Fmir-opt%2Fbox_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Ftest%2Fmir-opt%2Fbox_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbox_expr.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -52,7 +52,7 @@ impl Drop for S {\n //         StorageDead(_2);\n //         StorageLive(_4);\n //         _4 = move _1;\n-//         _3 = const std::mem::drop(move _4) -> [return: bb5, unwind: bb7];\n+//         _3 = const std::mem::drop::<std::boxed::Box<S>>(move _4) -> [return: bb5, unwind: bb7];\n //     }\n //\n //     bb5: {"}, {"sha": "7edfa3e1124db09e237600190f5ae0b7c51f500a", "filename": "src/test/mir-opt/byte_slice.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Ftest%2Fmir-opt%2Fbyte_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Ftest%2Fmir-opt%2Fbyte_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbyte_slice.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -0,0 +1,15 @@\n+// compile-flags: -Z mir-opt-level=0\n+\n+fn main() {\n+    let x = b\"foo\";\n+    let y = [5u8, b'x'];\n+}\n+\n+// END RUST SOURCE\n+// START rustc.main.EraseRegions.after.mir\n+// ...\n+// _1 = const b\"foo\";\n+// ...\n+// _2 = [const 5u8, const 120u8];\n+// ...\n+// END rustc.main.EraseRegions.after.mir"}, {"sha": "a2c5fb920cd30ff872b844aea5807f0c62a79dd3", "filename": "src/test/mir-opt/inline-trait-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Ftest%2Fmir-opt%2Finline-trait-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Ftest%2Fmir-opt%2Finline-trait-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline-trait-method.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -25,7 +25,7 @@ impl X for () {\n // ...\n // bb0: {\n // ...\n-//     _0 = const X::y(move _2) -> bb1;\n+//     _0 = const <dyn X as X>::y(move _2) -> bb1;\n // }\n // ...\n // END rustc.test.Inline.after.mir"}, {"sha": "4ad4311113a3ad0ec39c6d8ca5c67c2aa46a1faa", "filename": "src/test/mir-opt/inline-trait-method_2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Ftest%2Fmir-opt%2Finline-trait-method_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Ftest%2Fmir-opt%2Finline-trait-method_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline-trait-method_2.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -30,7 +30,7 @@ fn main() {\n // ...\n // bb0: {\n // ...\n-//     _0 = const X::y(move _2) -> bb1;\n+//     _0 = const <dyn X as X>::y(move _2) -> bb1;\n // }\n // ...\n // END rustc.test2.Inline.after.mir"}, {"sha": "447f3a07a6a98d830df8107ed9b4696bd979f442", "filename": "src/test/mir-opt/issue-49232.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Ftest%2Fmir-opt%2Fissue-49232.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Ftest%2Fmir-opt%2Fissue-49232.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-49232.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -93,7 +93,7 @@ fn main() {\n //         StorageDead(_3);\n //         StorageLive(_6);\n //         _6 = &_2;\n-//         _5 = const std::mem::drop(move _6) -> [return: bb19, unwind: bb4];\n+//         _5 = const std::mem::drop::<&i32>(move _6) -> [return: bb19, unwind: bb4];\n //     }\n //     bb19: {\n //         StorageDead(_6);"}, {"sha": "67a55101d829f7a99a69c1deb6d7742bec2bfc7f", "filename": "src/test/mir-opt/unusual-item-types.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Ftest%2Fmir-opt%2Funusual-item-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Ftest%2Fmir-opt%2Funusual-item-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funusual-item-types.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -1,5 +1,6 @@\n // Test that we don't ICE when trying to dump MIR for unusual item types and\n // that we don't create filenames containing `<` and `>`\n+// ignore-tidy-linelength\n \n struct A;\n \n@@ -68,7 +69,7 @@ fn main() {\n // }\n // bb7: {\n //     _2 = &mut (*_1);\n-//     _3 = const std::ops::Drop::drop(move _2) -> [return: bb6, unwind: bb5];\n+//     _3 = const <std::vec::Vec<i32> as std::ops::Drop>::drop(move _2) -> [return: bb6, unwind: bb5];\n // }\n // END rustc.ptr-real_drop_in_place.std__vec__Vec_i32_.AddMovesForPackedDrops.before.mir\n "}, {"sha": "544cd05cdbebf9cb7a40964eb2fbfb6b01c02ff9", "filename": "src/test/ui/const-generics/cannot-infer-const-args.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Ftest%2Fui%2Fconst-generics%2Fcannot-infer-const-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Ftest%2Fui%2Fconst-generics%2Fcannot-infer-const-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fcannot-infer-const-args.stderr?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -8,7 +8,7 @@ error[E0282]: type annotations needed\n   --> $DIR/cannot-infer-const-args.rs:9:5\n    |\n LL |     foo();\n-   |     ^^^ cannot infer type for `fn() -> usize {foo::<_>}`\n+   |     ^^^ cannot infer type for `fn() -> usize {foo::<_: usize>}`\n \n error: aborting due to previous error\n "}, {"sha": "3cc6de5bc4285ce48465f066f61d2ed725f070be", "filename": "src/test/ui/consts/const_let_refutable.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.nll.stderr?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -4,7 +4,7 @@ error[E0005]: refutable pattern in function argument: `&[]` not covered\n LL | const fn slice([a, b]: &[i32]) -> i32 {\n    |                ^^^^^^ pattern `&[]` not covered\n \n-error[E0723]: can only call other `const fn` within a `const fn`, but `const std::ops::Add::add` is not stable as `const fn`\n+error[E0723]: can only call other `const fn` within a `const fn`, but `const <&i32 as std::ops::Add>::add` is not stable as `const fn`\n   --> $DIR/const_let_refutable.rs:4:5\n    |\n LL |     a + b"}, {"sha": "cdd696ee7fbff06b1d4581a4e49929e8d02791d7", "filename": "src/test/ui/consts/const_let_refutable.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.stderr?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -4,7 +4,7 @@ error[E0005]: refutable pattern in function argument: `&[]` not covered\n LL | const fn slice([a, b]: &[i32]) -> i32 {\n    |                ^^^^^^ pattern `&[]` not covered\n \n-error[E0723]: can only call other `const fn` within a `const fn`, but `const std::ops::Add::add` is not stable as `const fn`\n+error[E0723]: can only call other `const fn` within a `const fn`, but `const <&i32 as std::ops::Add>::add` is not stable as `const fn`\n   --> $DIR/const_let_refutable.rs:4:5\n    |\n LL |     a + b"}, {"sha": "fabaea0535f5bdea8a7d263cc428d807fd476428", "filename": "src/test/ui/pattern/const-pat-ice.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Ftest%2Fui%2Fpattern%2Fconst-pat-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Ftest%2Fui%2Fpattern%2Fconst-pat-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fconst-pat-ice.stderr?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -1,4 +1,4 @@\n-thread 'rustc' panicked at 'assertion failed: rows.iter().all(|r| r.len() == v.len())', src/librustc_mir/hair/pattern/_match.rs:1083:5\n+thread 'rustc' panicked at 'assertion failed: rows.iter().all(|r| r.len() == v.len())', src/librustc_mir/hair/pattern/_match.rs:1085:5\n note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n \n error: internal compiler error: unexpected panic"}, {"sha": "a36c550f530a9a0f90113cb0f112b4db701a1532", "filename": "src/test/ui/pattern/slice-pattern-const-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const-2.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -6,13 +6,13 @@ fn main() {\n     match s {\n         MAGIC_TEST => (),\n         [0x00, 0x00, 0x00, 0x00] => (),\n-        [4, 5, 6, 7] => (), //~ ERROR unreachable pattern\n+        [4, 5, 6, 7] => (), // FIXME(oli-obk): this should warn, but currently does not\n         _ => (),\n     }\n     match s {\n         [0x00, 0x00, 0x00, 0x00] => (),\n         MAGIC_TEST => (),\n-        [4, 5, 6, 7] => (), //~ ERROR unreachable pattern\n+        [4, 5, 6, 7] => (), // FIXME(oli-obk): this should warn, but currently does not\n         _ => (),\n     }\n     match s {"}, {"sha": "0c7401269dfc744c3f4ac02dee90ff2b4a4e4f0a", "filename": "src/test/ui/pattern/slice-pattern-const-2.stderr", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const-2.stderr?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -1,26 +1,14 @@\n error: unreachable pattern\n-  --> $DIR/slice-pattern-const-2.rs:9:9\n+  --> $DIR/slice-pattern-const-2.rs:28:9\n    |\n-LL |         [4, 5, 6, 7] => (),\n-   |         ^^^^^^^^^^^^\n+LL |         FOO => (),\n+   |         ^^^\n    |\n note: lint level defined here\n   --> $DIR/slice-pattern-const-2.rs:1:9\n    |\n LL | #![deny(unreachable_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error: unreachable pattern\n-  --> $DIR/slice-pattern-const-2.rs:15:9\n-   |\n-LL |         [4, 5, 6, 7] => (),\n-   |         ^^^^^^^^^^^^\n-\n-error: unreachable pattern\n-  --> $DIR/slice-pattern-const-2.rs:28:9\n-   |\n-LL |         FOO => (),\n-   |         ^^^\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n "}, {"sha": "d48b182f2a2008fd3a95b26a8798a14cebe831da", "filename": "src/test/ui/symbol-names/impl2.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl2.rs?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -0,0 +1,14 @@\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+trait Foo {\n+    fn baz();\n+}\n+\n+impl Foo for [u8; 1 + 2] {\n+    #[rustc_def_path] //~ ERROR def-path(<[u8; _] as Foo>::baz)\n+    fn baz() { }\n+}\n+\n+fn main() {\n+}"}, {"sha": "de26fed44139e10bc910e7de1e966ff0fd6b2de5", "filename": "src/test/ui/symbol-names/impl2.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f492693982d1e252f5411ae3e4d560ab0dfea48a/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl2.stderr?ref=f492693982d1e252f5411ae3e4d560ab0dfea48a", "patch": "@@ -0,0 +1,8 @@\n+error: def-path(<[u8; _] as Foo>::baz)\n+  --> $DIR/impl2.rs:9:5\n+   |\n+LL |     #[rustc_def_path]\n+   |     ^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}]}