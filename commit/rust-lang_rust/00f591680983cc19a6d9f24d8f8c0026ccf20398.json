{"sha": "00f591680983cc19a6d9f24d8f8c0026ccf20398", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwZjU5MTY4MDk4M2NjMTlhNmQ5ZjI0ZDhmOGMwMDI2Y2NmMjAzOTg=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-08T14:38:58Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-08T16:22:23Z"}, "message": "std: replace the str::each* fns/methods with byte iterators", "tree": {"sha": "fd8fb9c6dbaa2627ada292bbd918070f1559d1ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd8fb9c6dbaa2627ada292bbd918070f1559d1ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00f591680983cc19a6d9f24d8f8c0026ccf20398", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00f591680983cc19a6d9f24d8f8c0026ccf20398", "html_url": "https://github.com/rust-lang/rust/commit/00f591680983cc19a6d9f24d8f8c0026ccf20398", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00f591680983cc19a6d9f24d8f8c0026ccf20398/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b806b4d06a6b82771657f9b79728d3fba84ebed", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b806b4d06a6b82771657f9b79728d3fba84ebed", "html_url": "https://github.com/rust-lang/rust/commit/4b806b4d06a6b82771657f9b79728d3fba84ebed"}], "stats": {"total": 240, "additions": 79, "deletions": 161}, "files": [{"sha": "dd3e4f48c634b924dc731b5120ab78cb61525cf3", "filename": "src/libextra/time.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00f591680983cc19a6d9f24d8f8c0026ccf20398/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00f591680983cc19a6d9f24d8f8c0026ccf20398/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=00f591680983cc19a6d9f24d8f8c0026ccf20398", "patch": "@@ -16,6 +16,7 @@ use core::i32;\n use core::int;\n use core::io;\n use core::str;\n+use core::iterator::IteratorUtil;\n \n static NSEC_PER_SEC: i32 = 1_000_000_000_i32;\n \n@@ -261,7 +262,7 @@ impl Tm {\n priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n     fn match_str(s: &str, pos: uint, needle: &str) -> bool {\n         let mut i = pos;\n-        for str::each(needle) |ch| {\n+        for needle.bytes_iter().advance |ch| {\n             if s[i] != ch {\n                 return false;\n             }"}, {"sha": "f9d1116499586f3cd2a4fef850cd702250161b1c", "filename": "src/libstd/str.rs", "status": "modified", "additions": 69, "deletions": 151, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/00f591680983cc19a6d9f24d8f8c0026ccf20398/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00f591680983cc19a6d9f24d8f8c0026ccf20398/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=00f591680983cc19a6d9f24d8f8c0026ccf20398", "patch": "@@ -35,7 +35,7 @@ use str;\n use to_str::ToStr;\n use uint;\n use vec;\n-use vec::{OwnedVector, OwnedCopyableVector};\n+use vec::{OwnedVector, OwnedCopyableVector, ImmutableVector};\n \n #[cfg(not(test))] use cmp::{Eq, Ord, Equiv, TotalEq};\n \n@@ -1249,42 +1249,6 @@ pub fn map(ss: &str, ff: &fn(char) -> char) -> ~str {\n     result\n }\n \n-/// Iterate over the bytes in a string\n-#[inline(always)]\n-pub fn each(s: &str, it: &fn(u8) -> bool) -> bool {\n-    eachi(s, |_i, b| it(b))\n-}\n-\n-/// Iterate over the bytes in a string, with indices\n-#[inline(always)]\n-pub fn eachi(s: &str, it: &fn(uint, u8) -> bool) -> bool {\n-    let mut pos = 0;\n-    let len = s.len();\n-\n-    while pos < len {\n-        if !it(pos, s[pos]) { return false; }\n-        pos += 1;\n-    }\n-    return true;\n-}\n-\n-/// Iterate over the bytes in a string in reverse\n-#[inline(always)]\n-pub fn each_reverse(s: &str, it: &fn(u8) -> bool) -> bool {\n-    eachi_reverse(s, |_i, b| it(b) )\n-}\n-\n-/// Iterate over the bytes in a string in reverse, with indices\n-#[inline(always)]\n-pub fn eachi_reverse(s: &str, it: &fn(uint, u8) -> bool) -> bool {\n-    let mut pos = s.len();\n-    while pos > 0 {\n-        pos -= 1;\n-        if !it(pos, s[pos]) { return false; }\n-    }\n-    return true;\n-}\n-\n /*\n Section: Searching\n */\n@@ -1604,7 +1568,7 @@ pub fn rfind_between(s: &str, start: uint, end: uint, f: &fn(char) -> bool) -> O\n // Utility used by various searching functions\n fn match_at<'a,'b>(haystack: &'a str, needle: &'b str, at: uint) -> bool {\n     let mut i = at;\n-    for each(needle) |c| { if haystack[i] != c { return false; } i += 1u; }\n+    for needle.bytes_iter().advance |c| { if haystack[i] != c { return false; } i += 1u; }\n     return true;\n }\n \n@@ -2557,10 +2521,8 @@ pub trait StrSlice<'self> {\n     fn contains_char(&self, needle: char) -> bool;\n     fn iter(&self) -> StrCharIterator<'self>;\n     fn rev_iter(&self) -> StrCharRevIterator<'self>;\n-    fn each(&self, it: &fn(u8) -> bool) -> bool;\n-    fn eachi(&self, it: &fn(uint, u8) -> bool) -> bool;\n-    fn each_reverse(&self, it: &fn(u8) -> bool) -> bool;\n-    fn eachi_reverse(&self, it: &fn(uint, u8) -> bool) -> bool;\n+    fn bytes_iter(&self) -> StrBytesIterator<'self>;\n+    fn bytes_rev_iter(&self) -> StrBytesRevIterator<'self>;\n     fn ends_with(&self, needle: &str) -> bool;\n     fn is_empty(&self) -> bool;\n     fn is_whitespace(&self) -> bool;\n@@ -2628,20 +2590,14 @@ impl<'self> StrSlice<'self> for &'self str {\n         }\n     }\n \n-    /// Iterate over the bytes in a string\n-    #[inline]\n-    fn each(&self, it: &fn(u8) -> bool) -> bool { each(*self, it) }\n-    /// Iterate over the bytes in a string, with indices\n-    #[inline]\n-    fn eachi(&self, it: &fn(uint, u8) -> bool) -> bool { eachi(*self, it) }\n-    /// Iterate over the bytes in a string\n-    #[inline]\n-    fn each_reverse(&self, it: &fn(u8) -> bool) -> bool { each_reverse(*self, it) }\n-    /// Iterate over the bytes in a string, with indices\n-    #[inline]\n-    fn eachi_reverse(&self, it: &fn(uint, u8) -> bool) -> bool {\n-        eachi_reverse(*self, it)\n+    fn bytes_iter(&self) -> StrBytesIterator<'self> {\n+        StrBytesIterator { it: as_bytes_slice(*self).iter() }\n     }\n+    fn bytes_rev_iter(&self) -> StrBytesRevIterator<'self> {\n+        StrBytesRevIterator { it: as_bytes_slice(*self).rev_iter() }\n+    }\n+\n+\n     /// Returns true if one string ends with another\n     #[inline]\n     fn ends_with(&self, needle: &str) -> bool {\n@@ -2832,6 +2788,32 @@ impl<'self> Iterator<char> for StrCharRevIterator<'self> {\n     }\n }\n \n+/// External iterator for a string's bytes. Use with the `std::iterator`\n+/// module.\n+pub struct StrBytesIterator<'self> {\n+    priv it: vec::VecIterator<'self, u8>\n+}\n+\n+impl<'self> Iterator<u8> for StrBytesIterator<'self> {\n+    #[inline]\n+    fn next(&mut self) -> Option<u8> {\n+        self.it.next().map_consume(|&x| x)\n+    }\n+}\n+\n+/// External iterator for a string's bytes in reverse order. Use with\n+/// the `std::iterator` module.\n+pub struct StrBytesRevIterator<'self> {\n+    priv it: vec::VecRevIterator<'self, u8>\n+}\n+\n+impl<'self> Iterator<u8> for StrBytesRevIterator<'self> {\n+    #[inline]\n+    fn next(&mut self) -> Option<u8> {\n+        self.it.next().map_consume(|&x| x)\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use iterator::IteratorUtil;\n@@ -3922,102 +3904,6 @@ mod tests {\n         }\n     }\n \n-    #[test]\n-    fn test_each() {\n-        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        let v = [\n-            224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n-            184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n-            109\n-        ];\n-        let mut pos = 0;\n-\n-        for s.each |b| {\n-            assert_eq!(b, v[pos]);\n-            pos += 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_each_empty() {\n-        for \"\".each |b| {\n-            assert_eq!(b, 0u8);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_eachi() {\n-        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        let v = [\n-            224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n-            184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n-            109\n-        ];\n-        let mut pos = 0;\n-\n-        for s.eachi |i, b| {\n-            assert_eq!(pos, i);\n-            assert_eq!(b, v[pos]);\n-            pos += 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_eachi_empty() {\n-        for \"\".eachi |i, b| {\n-            assert_eq!(i, 0);\n-            assert_eq!(b, 0);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_each_reverse() {\n-        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        let v = [\n-            224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n-            184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n-            109\n-        ];\n-        let mut pos = v.len();\n-\n-        for s.each_reverse |b| {\n-            pos -= 1;\n-            assert_eq!(b, v[pos]);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_each_empty_reverse() {\n-        for \"\".each_reverse |b| {\n-            assert_eq!(b, 0u8);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_eachi_reverse() {\n-        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        let v = [\n-            224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n-            184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n-            109\n-        ];\n-        let mut pos = v.len();\n-\n-        for s.eachi_reverse |i, b| {\n-            pos -= 1;\n-            assert_eq!(pos, i);\n-            assert_eq!(b, v[pos]);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_eachi_reverse_empty() {\n-        for \"\".eachi_reverse |i, b| {\n-            assert_eq!(i, 0);\n-            assert_eq!(b, 0);\n-        }\n-    }\n-\n     #[test]\n     fn test_escape_unicode() {\n         assert_eq!(escape_unicode(\"abc\"), ~\"\\\\x61\\\\x62\\\\x63\");\n@@ -4097,4 +3983,36 @@ mod tests {\n         }\n         assert_eq!(pos, v.len());\n     }\n+\n+    #[test]\n+    fn test_bytes_iterator() {\n+        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let v = [\n+            224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n+            184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n+            109\n+        ];\n+        let mut pos = 0;\n+\n+        for s.bytes_iter().advance |b| {\n+            assert_eq!(b, v[pos]);\n+            pos += 1;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_bytes_rev_iterator() {\n+        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let v = [\n+            224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n+            184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n+            109\n+        ];\n+        let mut pos = v.len();\n+\n+        for s.bytes_rev_iter().advance |b| {\n+            pos -= 1;\n+            assert_eq!(b, v[pos]);\n+        }\n+    }\n }"}, {"sha": "e288d605714f4be6efb960c7ea027bb3b41993c3", "filename": "src/libstd/str/ascii.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00f591680983cc19a6d9f24d8f8c0026ccf20398/src%2Flibstd%2Fstr%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00f591680983cc19a6d9f24d8f8c0026ccf20398/src%2Flibstd%2Fstr%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr%2Fascii.rs?ref=00f591680983cc19a6d9f24d8f8c0026ccf20398", "patch": "@@ -15,6 +15,7 @@ use str;\n use str::StrSlice;\n use cast;\n use old_iter::BaseIter;\n+use iterator::IteratorUtil;\n use vec::{CopyableVector, ImmutableVector, OwnedVector};\n \n /// Datatype to hold one ascii character. It is 8 bit long.\n@@ -101,10 +102,7 @@ impl<'self> AsciiCast<&'self[Ascii]> for &'self str {\n \n     #[inline(always)]\n     fn is_ascii(&self) -> bool {\n-        for self.each |b| {\n-            if !b.is_ascii() { return false; }\n-        }\n-        true\n+        self.bytes_iter().all(|b| b.is_ascii())\n     }\n }\n "}, {"sha": "51fbaee7a3396dabaa9113dca58337f13e97f335", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00f591680983cc19a6d9f24d8f8c0026ccf20398/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00f591680983cc19a6d9f24d8f8c0026ccf20398/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=00f591680983cc19a6d9f24d8f8c0026ccf20398", "patch": "@@ -10,6 +10,7 @@\n \n /* The compiler code necessary to support the bytes! extension. */\n \n+use core::iterator::IteratorUtil;\n use ast;\n use codemap::span;\n use ext::base::*;\n@@ -27,7 +28,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree]) -> bas\n             ast::expr_lit(lit) => match lit.node {\n                 // string literal, push each byte to vector expression\n                 ast::lit_str(s) => {\n-                    for s.each |byte| {\n+                    for s.bytes_iter().advance |byte| {\n                         bytes.push(cx.expr_u8(sp, byte));\n                     }\n                 }"}, {"sha": "a42d70f5ae2d84a5ca20aca4aa0a46932c480370", "filename": "src/test/run-pass/linear-for-loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00f591680983cc19a6d9f24d8f8c0026ccf20398/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00f591680983cc19a6d9f24d8f8c0026ccf20398/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs?ref=00f591680983cc19a6d9f24d8f8c0026ccf20398", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::str;\n+use std::iterator::IteratorUtil;\n \n pub fn main() {\n     let x = ~[1, 2, 3];\n@@ -18,7 +18,7 @@ pub fn main() {\n     assert_eq!(y, 6);\n     let s = ~\"hello there\";\n     let mut i: int = 0;\n-    for str::each(s) |c| {\n+    for s.bytes_iter().advance |c| {\n         if i == 0 { assert!((c == 'h' as u8)); }\n         if i == 1 { assert!((c == 'e' as u8)); }\n         if i == 2 { assert!((c == 'l' as u8)); }"}, {"sha": "8a8454390582586d363b63340f4b19d48e370b73", "filename": "src/test/run-pass/utf8.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00f591680983cc19a6d9f24d8f8c0026ccf20398/src%2Ftest%2Frun-pass%2Futf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00f591680983cc19a6d9f24d8f8c0026ccf20398/src%2Ftest%2Frun-pass%2Futf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8.rs?ref=00f591680983cc19a6d9f24d8f8c0026ccf20398", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::str;\n+use std::iterator::IteratorUtil;\n \n pub fn main() {\n     let yen: char = '\u00a5'; // 0xa5\n@@ -43,7 +43,7 @@ pub fn main() {\n \n     fn check_str_eq(a: ~str, b: ~str) {\n         let mut i: int = 0;\n-        for str::each(a) |ab| {\n+        for a.bytes_iter().advance |ab| {\n             debug!(i);\n             debug!(ab);\n             let bb: u8 = b[i];"}]}