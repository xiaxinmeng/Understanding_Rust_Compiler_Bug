{"sha": "fe15880beb3359bcf6d4d5bd8f527a553e2e86bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlMTU4ODBiZWIzMzU5YmNmNmQ0ZDViZDhmNTI3YTU1M2UyZTg2YmY=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-12-02T19:54:05Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-12-02T19:54:05Z"}, "message": "Revert \"down to for-loops not comparing as equal\"\n\nThis reverts commit cf1fa94be1e98dba2ce1755e1c86acef50daf599.", "tree": {"sha": "9b3469b7158a2207a21681ff11fe4a95fe65a301", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b3469b7158a2207a21681ff11fe4a95fe65a301"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe15880beb3359bcf6d4d5bd8f527a553e2e86bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe15880beb3359bcf6d4d5bd8f527a553e2e86bf", "html_url": "https://github.com/rust-lang/rust/commit/fe15880beb3359bcf6d4d5bd8f527a553e2e86bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe15880beb3359bcf6d4d5bd8f527a553e2e86bf/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42fb11f887c574530e52a055cd3b735ff06c102f", "url": "https://api.github.com/repos/rust-lang/rust/commits/42fb11f887c574530e52a055cd3b735ff06c102f", "html_url": "https://github.com/rust-lang/rust/commit/42fb11f887c574530e52a055cd3b735ff06c102f"}], "stats": {"total": 101, "additions": 60, "deletions": 41}, "files": [{"sha": "f6903b107904c75a0d74bd71452d48022655be4b", "filename": "clippy_lints/src/utils/hir.rs", "status": "modified", "additions": 58, "deletions": 37, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/fe15880beb3359bcf6d4d5bd8f527a553e2e86bf/clippy_lints%2Fsrc%2Futils%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe15880beb3359bcf6d4d5bd8f527a553e2e86bf/clippy_lints%2Fsrc%2Futils%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir.rs?ref=fe15880beb3359bcf6d4d5bd8f527a553e2e86bf", "patch": "@@ -1,7 +1,6 @@\n use consts::constant;\n use rustc::lint::*;\n use rustc::hir::*;\n-use rustc::hir::def::Def;\n use std::hash::{Hash, Hasher};\n use std::collections::hash_map::DefaultHasher;\n use syntax::ast::{Name, NodeId};\n@@ -104,8 +103,8 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             (&ExprLoop(ref lb, ref ll, _), &ExprLoop(ref rb, ref rl, _)) => {\n                 self.eq_block(lb, rb) && both(ll, rl, |l, r| l.node.as_str() == r.node.as_str())\n             }\n-            (&ExprMatch(ref le, ref la, _), &ExprMatch(ref re, ref ra, _)) => {\n-                self.eq_expr(le, re) &&\n+            (&ExprMatch(ref le, ref la, ref ls), &ExprMatch(ref re, ref ra, ref rs)) => {\n+                ls == rs && self.eq_expr(le, re) &&\n                 over(la, ra, |l, r| {\n                     self.eq_expr(&l.body, &r.body) && both(&l.guard, &r.guard, |l, r| self.eq_expr(l, r)) &&\n                     over(&l.pats, &r.pats, |l, r| self.eq_pat(l, r))\n@@ -119,10 +118,9 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             }\n             (&ExprRepeat(ref le, ref ll), &ExprRepeat(ref re, ref rl)) => self.eq_expr(le, re) && self.eq_expr(ll, rl),\n             (&ExprRet(ref l), &ExprRet(ref r)) => both(l, r, |l, r| self.eq_expr(l, r)),\n-            (&ExprPath(ref l), &ExprPath(ref r)) => self.eq_qpath(l, left.id, r, right.id),\n+            (&ExprPath(ref l), &ExprPath(ref r)) => self.eq_qpath(l, r),\n             (&ExprStruct(ref l_path, ref lf, ref lo), &ExprStruct(ref r_path, ref rf, ref ro)) => {\n-                self.eq_qpath(l_path, left.id, r_path, right.id) &&\n-                both(lo, ro, |l, r| self.eq_expr(l, r)) &&\n+                self.eq_qpath(l_path, r_path) && both(lo, ro, |l, r| self.eq_expr(l, r)) &&\n                 over(lf, rf, |l, r| self.eq_field(l, r))\n             }\n             (&ExprTup(ref l_tup), &ExprTup(ref r_tup)) => self.eq_exprs(l_tup, r_tup),\n@@ -144,17 +142,21 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         left.name.node == right.name.node && self.eq_expr(&left.expr, &right.expr)\n     }\n \n+    fn eq_lifetime(&self, left: &Lifetime, right: &Lifetime) -> bool {\n+        left.name == right.name\n+    }\n+\n     /// Check whether two patterns are the same.\n     pub fn eq_pat(&self, left: &Pat, right: &Pat) -> bool {\n         match (&left.node, &right.node) {\n             (&PatKind::Box(ref l), &PatKind::Box(ref r)) => self.eq_pat(l, r),\n             (&PatKind::TupleStruct(ref lp, ref la, ls), &PatKind::TupleStruct(ref rp, ref ra, rs)) => {\n-                self.eq_qpath(lp, left.id, rp, right.id) && over(la, ra, |l, r| self.eq_pat(l, r)) && ls == rs\n+                self.eq_qpath(lp, rp) && over(la, ra, |l, r| self.eq_pat(l, r)) && ls == rs\n             }\n-            (&PatKind::Binding(ref lb, _, ref li, ref lp), &PatKind::Binding(ref rb, _, ref ri, ref rp)) => {\n-                lb == rb && li.node.as_str() == ri.node.as_str() && both(lp, rp, |l, r| self.eq_pat(l, r))\n+            (&PatKind::Binding(ref lb, ref ld, ref li, ref lp), &PatKind::Binding(ref rb, ref rd, ref ri, ref rp)) => {\n+                lb == rb && ld == rd && li.node.as_str() == ri.node.as_str() && both(lp, rp, |l, r| self.eq_pat(l, r))\n             }\n-            (&PatKind::Path(ref l), &PatKind::Path(ref r)) => self.eq_qpath(l, left.id, r, right.id),\n+            (&PatKind::Path(ref l), &PatKind::Path(ref r)) => self.eq_qpath(l, r),\n             (&PatKind::Lit(ref l), &PatKind::Lit(ref r)) => self.eq_expr(l, r),\n             (&PatKind::Tuple(ref l, ls), &PatKind::Tuple(ref r, rs)) => {\n                 ls == rs && over(l, r, |l, r| self.eq_pat(l, r))\n@@ -172,23 +174,48 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n     }\n \n-    fn eq_qpath(&self, left: &QPath, lid: NodeId, right: &QPath, rid: NodeId) -> bool {\n-        let l = self.cx.tcx.tables().qpath_def(left, lid);\n-        let r = self.cx.tcx.tables().qpath_def(right, rid);\n+    fn eq_qpath(&self, left: &QPath, right: &QPath) -> bool {\n+        match (left, right) {\n+            (&QPath::Resolved(ref lty, ref lpath), &QPath::Resolved(ref rty, ref rpath)) => {\n+                both(lty, rty, |l, r| self.eq_ty(l, r)) && self.eq_path(lpath, rpath)\n+            },\n+            (&QPath::TypeRelative(ref lty, ref lseg), &QPath::TypeRelative(ref rty, ref rseg)) => {\n+                self.eq_ty(lty, rty) && self.eq_path_segment(lseg, rseg)\n+            },\n+            _ => false,\n+        }\n+    }\n+\n+    fn eq_path(&self, left: &Path, right: &Path) -> bool {\n+        left.global == right.global &&\n+        over(&left.segments, &right.segments, |l, r| self.eq_path_segment(l, r))\n+    }\n \n-        if let (Def::Local(_), Def::Local(_)) = (l, r) {\n-            if let (&QPath::Resolved(None, ref l), &QPath::Resolved(None, ref r)) = (left, right) {\n-                assert_eq!(l.segments.len(), 1);\n-                assert_eq!(r.segments.len(), 1);\n-                l.segments[0].name == r.segments[0].name\n-            } else {\n-                unreachable!();\n+    fn eq_path_parameters(&self, left: &PathParameters, right: &PathParameters) -> bool {\n+        match (left, right) {\n+            (&AngleBracketedParameters(ref left), &AngleBracketedParameters(ref right)) => {\n+                over(&left.lifetimes, &right.lifetimes, |l, r| self.eq_lifetime(l, r)) &&\n+                over(&left.types, &right.types, |l, r| self.eq_ty(l, r)) &&\n+                over(&left.bindings, &right.bindings, |l, r| self.eq_type_binding(l, r))\n+            }\n+            (&ParenthesizedParameters(ref left), &ParenthesizedParameters(ref right)) => {\n+                over(&left.inputs, &right.inputs, |l, r| self.eq_ty(l, r)) &&\n+                both(&left.output, &right.output, |l, r| self.eq_ty(l, r))\n+            }\n+            (&AngleBracketedParameters(_), &ParenthesizedParameters(_)) |\n+            (&ParenthesizedParameters(_), &AngleBracketedParameters(_)) => {\n+                false\n             }\n-        } else {\n-            l == r\n         }\n     }\n \n+    fn eq_path_segment(&self, left: &PathSegment, right: &PathSegment) -> bool {\n+        // The == of idents doesn't work with different contexts,\n+        // we have to be explicit about hygiene\n+        left.name.as_str() == right.name.as_str() &&\n+        self.eq_path_parameters(&left.parameters, &right.parameters)\n+    }\n+\n     fn eq_ty(&self, left: &Ty, right: &Ty) -> bool {\n         match (&left.node, &right.node) {\n             (&TySlice(ref l_vec), &TySlice(ref r_vec)) => self.eq_ty(l_vec, r_vec),\n@@ -199,12 +226,16 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             (&TyRptr(_, ref l_rmut), &TyRptr(_, ref r_rmut)) => {\n                 l_rmut.mutbl == r_rmut.mutbl && self.eq_ty(&*l_rmut.ty, &*r_rmut.ty)\n             }\n-            (&TyPath(ref l), &TyPath(ref r)) => self.eq_qpath(l, left.id, r, right.id),\n+            (&TyPath(ref l), &TyPath(ref r)) => self.eq_qpath(l, r),\n             (&TyTup(ref l), &TyTup(ref r)) => over(l, r, |l, r| self.eq_ty(l, r)),\n             (&TyInfer, &TyInfer) => true,\n             _ => false,\n         }\n     }\n+\n+    fn eq_type_binding(&self, left: &TypeBinding, right: &TypeBinding) -> bool {\n+        left.name == right.name && self.eq_ty(&left.ty, &right.ty)\n+    }\n }\n \n fn swap_binop<'a>(binop: BinOp_, lhs: &'a Expr, rhs: &'a Expr) -> Option<(BinOp_, &'a Expr, &'a Expr)> {\n@@ -388,7 +419,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                     self.hash_name(&i.node);\n                 }\n             }\n-            ExprMatch(ref e, ref arms, _) => {\n+            ExprMatch(ref e, ref arms, ref s) => {\n                 let c: fn(_, _, _) -> _ = ExprMatch;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n@@ -400,6 +431,8 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                     }\n                     self.hash_expr(&arm.body);\n                 }\n+\n+                s.hash(&mut self.s);\n             }\n             ExprMethodCall(ref name, ref _tys, ref args) => {\n                 let c: fn(_, _, _) -> _ = ExprMethodCall;\n@@ -495,19 +528,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n     }\n \n     pub fn hash_qpath(&mut self, p: &QPath, id: NodeId) {\n-        let def = self.cx.tcx.tables().qpath_def(p, id);\n-        if let Def::Local(_) = def {\n-            true.hash(&mut self.s);\n-            if let QPath::Resolved(None, ref seq) = *p {\n-                assert_eq!(seq.segments.len(), 1);\n-                self.hash_name(&seq.segments[0].name);\n-            } else {\n-                unreachable!();\n-            }\n-        } else {\n-            false.hash(&mut self.s);\n-            def.hash(&mut self.s);\n-        }\n+        self.cx.tcx.tables().qpath_def(p, id).hash(&mut self.s);\n     }\n \n     pub fn hash_path(&mut self, p: &Path) {"}, {"sha": "005129f1b5da542dc558924e331b12d37a1cc409", "filename": "tests/compile-fail/copies.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe15880beb3359bcf6d4d5bd8f527a553e2e86bf/tests%2Fcompile-fail%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe15880beb3359bcf6d4d5bd8f527a553e2e86bf/tests%2Fcompile-fail%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcopies.rs?ref=fe15880beb3359bcf6d4d5bd8f527a553e2e86bf", "patch": "@@ -224,18 +224,16 @@ fn if_same_then_else() -> Result<&'static str, ()> {\n     }\n \n     if true {\n-        //~^NOTE same as this\n         if let Some(42) = None {}\n     }\n-    else { //~ERROR this `if` has identical blocks\n+    else {\n         if let Option::Some(42) = None {}\n     }\n \n     if true {\n-        //~^NOTE same as this\n         if let Some(42) = None::<u8> {}\n     }\n-    else { //~ERROR this `if` has identical blocks\n+    else {\n         if let Some(42) = None {}\n     }\n "}]}