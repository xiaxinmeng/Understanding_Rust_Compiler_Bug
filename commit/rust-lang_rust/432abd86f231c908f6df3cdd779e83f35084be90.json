{"sha": "432abd86f231c908f6df3cdd779e83f35084be90", "node_id": "C_kwDOAAsO6NoAKDQzMmFiZDg2ZjIzMWM5MDhmNmRmM2NkZDc3OWU4M2YzNTA4NGJlOTA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-20T19:10:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-20T19:10:11Z"}, "message": "Auto merge of #102061 - notriddle:rollup-kwu9vp8, r=notriddle\n\nRollup of 12 pull requests\n\nSuccessful merges:\n\n - #100250 (Manually cleanup token stream when macro expansion aborts.)\n - #101014 (Fix -Zmeta-stats ICE by giving `FileEncoder` file read permissions)\n - #101958 (Improve error for when query is unsupported by crate)\n - #101976 (MirPhase: clarify that linting is not a semantic change)\n - #102001 (Use LLVM C-API to build atomic cmpxchg and fence)\n - #102008 (Add GUI test for notable traits element position)\n - #102013 (Simplify rpitit handling on lower_fn_decl)\n - #102021 (some post-valtree cleanup)\n - #102027 (rustdoc: remove `docblock` class from `item-decl`)\n - #102034 (rustdoc: remove no-op CSS `h1-6 { border-bottom-color }`)\n - #102038 (Make the `normalize-overflow` rustdoc test actually do something)\n - #102053 (:arrow_up: rust-analyzer)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "c29cc2538d936d0746c5b28c474ce005d1f00fb0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c29cc2538d936d0746c5b28c474ce005d1f00fb0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/432abd86f231c908f6df3cdd779e83f35084be90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/432abd86f231c908f6df3cdd779e83f35084be90", "html_url": "https://github.com/rust-lang/rust/commit/432abd86f231c908f6df3cdd779e83f35084be90", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/432abd86f231c908f6df3cdd779e83f35084be90/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd8cc91045281f7f1924ecc101f2c6002f6a1eee", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd8cc91045281f7f1924ecc101f2c6002f6a1eee", "html_url": "https://github.com/rust-lang/rust/commit/cd8cc91045281f7f1924ecc101f2c6002f6a1eee"}, {"sha": "25f5483f581a56fa6186ed7e986b0a5d80ba896b", "url": "https://api.github.com/repos/rust-lang/rust/commits/25f5483f581a56fa6186ed7e986b0a5d80ba896b", "html_url": "https://github.com/rust-lang/rust/commit/25f5483f581a56fa6186ed7e986b0a5d80ba896b"}], "stats": {"total": 3000, "additions": 1984, "deletions": 1016}, "files": [{"sha": "e9c05eb5f455fa79f0a454078e63a19e71235d25", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 15, "deletions": 45, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -324,16 +324,10 @@ enum FnDeclKind {\n }\n \n impl FnDeclKind {\n-    fn impl_trait_return_allowed(&self, tcx: TyCtxt<'_>) -> bool {\n+    fn impl_trait_allowed(&self, tcx: TyCtxt<'_>) -> bool {\n         match self {\n             FnDeclKind::Fn | FnDeclKind::Inherent => true,\n             FnDeclKind::Impl if tcx.features().return_position_impl_trait_in_trait => true,\n-            _ => false,\n-        }\n-    }\n-\n-    fn impl_trait_in_trait_allowed(&self, tcx: TyCtxt<'_>) -> bool {\n-        match self {\n             FnDeclKind::Trait if tcx.features().return_position_impl_trait_in_trait => true,\n             _ => false,\n         }\n@@ -1698,9 +1692,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }));\n \n         let output = if let Some((ret_id, span)) = make_ret_async {\n-            match kind {\n-                FnDeclKind::Trait => {\n-                    if !kind.impl_trait_in_trait_allowed(self.tcx) {\n+            if !kind.impl_trait_allowed(self.tcx) {\n+                match kind {\n+                    FnDeclKind::Trait | FnDeclKind::Impl => {\n                         self.tcx\n                             .sess\n                             .create_feature_err(\n@@ -1709,51 +1703,27 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             )\n                             .emit();\n                     }\n-                    self.lower_async_fn_ret_ty(\n-                        &decl.output,\n-                        fn_node_id.expect(\"`make_ret_async` but no `fn_def_id`\"),\n-                        ret_id,\n-                        true,\n-                    )\n-                }\n-                _ => {\n-                    if !kind.impl_trait_return_allowed(self.tcx) {\n-                        if kind == FnDeclKind::Impl {\n-                            self.tcx\n-                                .sess\n-                                .create_feature_err(\n-                                    TraitFnAsync { fn_span, span },\n-                                    sym::return_position_impl_trait_in_trait,\n-                                )\n-                                .emit();\n-                        } else {\n-                            self.tcx.sess.emit_err(TraitFnAsync { fn_span, span });\n-                        }\n+                    _ => {\n+                        self.tcx.sess.emit_err(TraitFnAsync { fn_span, span });\n                     }\n-                    self.lower_async_fn_ret_ty(\n-                        &decl.output,\n-                        fn_node_id.expect(\"`make_ret_async` but no `fn_def_id`\"),\n-                        ret_id,\n-                        false,\n-                    )\n                 }\n             }\n+\n+            self.lower_async_fn_ret_ty(\n+                &decl.output,\n+                fn_node_id.expect(\"`make_ret_async` but no `fn_def_id`\"),\n+                ret_id,\n+                matches!(kind, FnDeclKind::Trait),\n+            )\n         } else {\n             match decl.output {\n                 FnRetTy::Ty(ref ty) => {\n                     let mut context = match fn_node_id {\n-                        Some(fn_node_id) if kind.impl_trait_return_allowed(self.tcx) => {\n-                            let fn_def_id = self.local_def_id(fn_node_id);\n-                            ImplTraitContext::ReturnPositionOpaqueTy {\n-                                origin: hir::OpaqueTyOrigin::FnReturn(fn_def_id),\n-                                in_trait: false,\n-                            }\n-                        }\n-                        Some(fn_node_id) if kind.impl_trait_in_trait_allowed(self.tcx) => {\n+                        Some(fn_node_id) if kind.impl_trait_allowed(self.tcx) => {\n                             let fn_def_id = self.local_def_id(fn_node_id);\n                             ImplTraitContext::ReturnPositionOpaqueTy {\n                                 origin: hir::OpaqueTyOrigin::FnReturn(fn_def_id),\n-                                in_trait: true,\n+                                in_trait: matches!(kind, FnDeclKind::Trait),\n                             }\n                         }\n                         _ => ImplTraitContext::Disallowed(match kind {"}, {"sha": "009f3c783d4c8d946cdd73f1fc011bce86a93611", "filename": "compiler/rustc_builtin_macros/src/cfg_eval.rs", "status": "modified", "additions": 36, "deletions": 28, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -7,6 +7,7 @@ use rustc_ast::visit::Visitor;\n use rustc_ast::NodeId;\n use rustc_ast::{mut_visit, visit};\n use rustc_ast::{Attribute, HasAttrs, HasTokens};\n+use rustc_errors::PResult;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_expand::config::StripUnconfigured;\n use rustc_expand::configure;\n@@ -144,33 +145,34 @@ impl CfgEval<'_, '_> {\n         // the location of `#[cfg]` and `#[cfg_attr]` in the token stream. The tokenization\n         // process is lossless, so this process is invisible to proc-macros.\n \n-        let parse_annotatable_with: fn(&mut Parser<'_>) -> _ = match annotatable {\n-            Annotatable::Item(_) => {\n-                |parser| Annotatable::Item(parser.parse_item(ForceCollect::Yes).unwrap().unwrap())\n-            }\n-            Annotatable::TraitItem(_) => |parser| {\n-                Annotatable::TraitItem(\n-                    parser.parse_trait_item(ForceCollect::Yes).unwrap().unwrap().unwrap(),\n-                )\n-            },\n-            Annotatable::ImplItem(_) => |parser| {\n-                Annotatable::ImplItem(\n-                    parser.parse_impl_item(ForceCollect::Yes).unwrap().unwrap().unwrap(),\n-                )\n-            },\n-            Annotatable::ForeignItem(_) => |parser| {\n-                Annotatable::ForeignItem(\n-                    parser.parse_foreign_item(ForceCollect::Yes).unwrap().unwrap().unwrap(),\n-                )\n-            },\n-            Annotatable::Stmt(_) => |parser| {\n-                Annotatable::Stmt(P(parser.parse_stmt(ForceCollect::Yes).unwrap().unwrap()))\n-            },\n-            Annotatable::Expr(_) => {\n-                |parser| Annotatable::Expr(parser.parse_expr_force_collect().unwrap())\n-            }\n-            _ => unreachable!(),\n-        };\n+        let parse_annotatable_with: for<'a> fn(&mut Parser<'a>) -> PResult<'a, _> =\n+            match annotatable {\n+                Annotatable::Item(_) => {\n+                    |parser| Ok(Annotatable::Item(parser.parse_item(ForceCollect::Yes)?.unwrap()))\n+                }\n+                Annotatable::TraitItem(_) => |parser| {\n+                    Ok(Annotatable::TraitItem(\n+                        parser.parse_trait_item(ForceCollect::Yes)?.unwrap().unwrap(),\n+                    ))\n+                },\n+                Annotatable::ImplItem(_) => |parser| {\n+                    Ok(Annotatable::ImplItem(\n+                        parser.parse_impl_item(ForceCollect::Yes)?.unwrap().unwrap(),\n+                    ))\n+                },\n+                Annotatable::ForeignItem(_) => |parser| {\n+                    Ok(Annotatable::ForeignItem(\n+                        parser.parse_foreign_item(ForceCollect::Yes)?.unwrap().unwrap(),\n+                    ))\n+                },\n+                Annotatable::Stmt(_) => |parser| {\n+                    Ok(Annotatable::Stmt(P(parser.parse_stmt(ForceCollect::Yes)?.unwrap())))\n+                },\n+                Annotatable::Expr(_) => {\n+                    |parser| Ok(Annotatable::Expr(parser.parse_expr_force_collect()?))\n+                }\n+                _ => unreachable!(),\n+            };\n \n         // 'Flatten' all nonterminals (i.e. `TokenKind::Interpolated`)\n         // to `None`-delimited groups containing the corresponding tokens. This\n@@ -193,7 +195,13 @@ impl CfgEval<'_, '_> {\n         let mut parser =\n             rustc_parse::stream_to_parser(&self.cfg.sess.parse_sess, orig_tokens, None);\n         parser.capture_cfg = true;\n-        annotatable = parse_annotatable_with(&mut parser);\n+        match parse_annotatable_with(&mut parser) {\n+            Ok(a) => annotatable = a,\n+            Err(mut err) => {\n+                err.emit();\n+                return Some(annotatable);\n+            }\n+        }\n \n         // Now that we have our re-parsed `AttrTokenStream`, recursively configuring\n         // our attribute target will correctly the tokens as well."}, {"sha": "59b1c7fb5dbd040feb5405184e4cd7dd49d8802d", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -1,14 +1,13 @@\n use crate::attributes;\n use crate::common::Funclet;\n use crate::context::CodegenCx;\n-use crate::llvm::{self, BasicBlock, False};\n-use crate::llvm::{AtomicOrdering, AtomicRmwBinOp, SynchronizationScope};\n+use crate::llvm::{self, AtomicOrdering, AtomicRmwBinOp, BasicBlock};\n use crate::type_::Type;\n use crate::type_of::LayoutLlvmExt;\n use crate::value::Value;\n use cstr::cstr;\n use libc::{c_char, c_uint};\n-use rustc_codegen_ssa::common::{IntPredicate, RealPredicate, TypeKind};\n+use rustc_codegen_ssa::common::{IntPredicate, RealPredicate, SynchronizationScope, TypeKind};\n use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::*;\n@@ -1042,15 +1041,17 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     ) -> &'ll Value {\n         let weak = if weak { llvm::True } else { llvm::False };\n         unsafe {\n-            llvm::LLVMRustBuildAtomicCmpXchg(\n+            let value = llvm::LLVMBuildAtomicCmpXchg(\n                 self.llbuilder,\n                 dst,\n                 cmp,\n                 src,\n                 AtomicOrdering::from_generic(order),\n                 AtomicOrdering::from_generic(failure_order),\n-                weak,\n-            )\n+                llvm::False, // SingleThreaded\n+            );\n+            llvm::LLVMSetWeak(value, weak);\n+            value\n         }\n     }\n     fn atomic_rmw(\n@@ -1067,21 +1068,26 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                 dst,\n                 src,\n                 AtomicOrdering::from_generic(order),\n-                False,\n+                llvm::False, // SingleThreaded\n             )\n         }\n     }\n \n     fn atomic_fence(\n         &mut self,\n         order: rustc_codegen_ssa::common::AtomicOrdering,\n-        scope: rustc_codegen_ssa::common::SynchronizationScope,\n+        scope: SynchronizationScope,\n     ) {\n+        let single_threaded = match scope {\n+            SynchronizationScope::SingleThread => llvm::True,\n+            SynchronizationScope::CrossThread => llvm::False,\n+        };\n         unsafe {\n-            llvm::LLVMRustBuildAtomicFence(\n+            llvm::LLVMBuildFence(\n                 self.llbuilder,\n                 AtomicOrdering::from_generic(order),\n-                SynchronizationScope::from_generic(scope),\n+                single_threaded,\n+                UNNAMED,\n             );\n         }\n     }"}, {"sha": "09f2c35689765b509858545a593c6391f044bac9", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 9, "deletions": 27, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -400,27 +400,6 @@ impl AtomicOrdering {\n     }\n }\n \n-/// LLVMRustSynchronizationScope\n-#[derive(Copy, Clone)]\n-#[repr(C)]\n-pub enum SynchronizationScope {\n-    SingleThread,\n-    CrossThread,\n-}\n-\n-impl SynchronizationScope {\n-    pub fn from_generic(sc: rustc_codegen_ssa::common::SynchronizationScope) -> Self {\n-        match sc {\n-            rustc_codegen_ssa::common::SynchronizationScope::SingleThread => {\n-                SynchronizationScope::SingleThread\n-            }\n-            rustc_codegen_ssa::common::SynchronizationScope::CrossThread => {\n-                SynchronizationScope::CrossThread\n-            }\n-        }\n-    }\n-}\n-\n /// LLVMRustFileType\n #[derive(Copy, Clone)]\n #[repr(C)]\n@@ -1782,16 +1761,18 @@ extern \"C\" {\n         Order: AtomicOrdering,\n     ) -> &'a Value;\n \n-    pub fn LLVMRustBuildAtomicCmpXchg<'a>(\n+    pub fn LLVMBuildAtomicCmpXchg<'a>(\n         B: &Builder<'a>,\n         LHS: &'a Value,\n         CMP: &'a Value,\n         RHS: &'a Value,\n         Order: AtomicOrdering,\n         FailureOrder: AtomicOrdering,\n-        Weak: Bool,\n+        SingleThreaded: Bool,\n     ) -> &'a Value;\n \n+    pub fn LLVMSetWeak(CmpXchgInst: &Value, IsWeak: Bool);\n+\n     pub fn LLVMBuildAtomicRMW<'a>(\n         B: &Builder<'a>,\n         Op: AtomicRmwBinOp,\n@@ -1801,11 +1782,12 @@ extern \"C\" {\n         SingleThreaded: Bool,\n     ) -> &'a Value;\n \n-    pub fn LLVMRustBuildAtomicFence(\n-        B: &Builder<'_>,\n+    pub fn LLVMBuildFence<'a>(\n+        B: &Builder<'a>,\n         Order: AtomicOrdering,\n-        Scope: SynchronizationScope,\n-    );\n+        SingleThreaded: Bool,\n+        Name: *const c_char,\n+    ) -> &'a Value;\n \n     /// Writes a module to the specified path. Returns 0 on success.\n     pub fn LLVMWriteBitcodeToFile(M: &Module, Path: *const c_char) -> c_int;"}, {"sha": "1c33e7845cb0b0b813ac7fcb6cc8e45fb287f271", "filename": "compiler/rustc_const_eval/src/const_eval/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -100,10 +100,10 @@ pub(crate) fn try_destructure_mir_constant<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     val: mir::ConstantKind<'tcx>,\n-) -> InterpResult<'tcx, mir::DestructuredMirConstant<'tcx>> {\n+) -> InterpResult<'tcx, mir::DestructuredConstant<'tcx>> {\n     trace!(\"destructure_mir_constant: {:?}\", val);\n     let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n-    let op = ecx.mir_const_to_op(&val, None)?;\n+    let op = ecx.const_to_op(&val, None)?;\n \n     // We go to `usize` as we cannot allocate anything bigger anyway.\n     let (field_count, variant, down) = match val.ty().kind() {\n@@ -129,7 +129,7 @@ pub(crate) fn try_destructure_mir_constant<'tcx>(\n         .collect::<InterpResult<'tcx, Vec<_>>>()?;\n     let fields = tcx.arena.alloc_from_iter(fields_iter);\n \n-    Ok(mir::DestructuredMirConstant { variant, fields })\n+    Ok(mir::DestructuredConstant { variant, fields })\n }\n \n #[instrument(skip(tcx), level = \"debug\")]\n@@ -139,7 +139,7 @@ pub(crate) fn deref_mir_constant<'tcx>(\n     val: mir::ConstantKind<'tcx>,\n ) -> mir::ConstantKind<'tcx> {\n     let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n-    let op = ecx.mir_const_to_op(&val, None).unwrap();\n+    let op = ecx.const_to_op(&val, None).unwrap();\n     let mplace = ecx.deref_operand(&op).unwrap();\n     if let Some(alloc_id) = mplace.ptr.provenance {\n         assert_eq!("}, {"sha": "bdebfbb3ff51051a3a12e7be2dc75b327cbf7e3a", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -683,11 +683,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         self.stack_mut().push(frame);\n \n         // Make sure all the constants required by this frame evaluate successfully (post-monomorphization check).\n-        for const_ in &body.required_consts {\n-            let span = const_.span;\n-            let const_ =\n-                self.subst_from_current_frame_and_normalize_erasing_regions(const_.literal)?;\n-            self.mir_const_to_op(&const_, None).map_err(|err| {\n+        for ct in &body.required_consts {\n+            let span = ct.span;\n+            let ct = self.subst_from_current_frame_and_normalize_erasing_regions(ct.literal)?;\n+            self.const_to_op(&ct, None).map_err(|err| {\n                 // If there was an error, set the span of the current frame to this constant.\n                 // Avoiding doing this when evaluation succeeds.\n                 self.frame_mut().loc = Err(span);"}, {"sha": "dc5305aabcf8972c7c49e97a2aaa8036ab9e97a9", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 31, "deletions": 39, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -534,7 +534,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // * During ConstProp, with `TooGeneric` or since the `required_consts` were not all\n                 //   checked yet.\n                 // * During CTFE, since promoteds in `const`/`static` initializer bodies can fail.\n-                self.mir_const_to_op(&val, layout)?\n+                self.const_to_op(&val, layout)?\n             }\n         };\n         trace!(\"{:?}: {:?}\", mir_op, *op);\n@@ -549,50 +549,42 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ops.iter().map(|op| self.eval_operand(op, None)).collect()\n     }\n \n-    // Used when the miri-engine runs into a constant and for extracting information from constants\n-    // in patterns via the `const_eval` module\n-    /// The `val` and `layout` are assumed to already be in our interpreter\n-    /// \"universe\" (param_env).\n     pub fn const_to_op(\n-        &self,\n-        c: ty::Const<'tcx>,\n-        layout: Option<TyAndLayout<'tcx>>,\n-    ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n-        match c.kind() {\n-            ty::ConstKind::Param(_) | ty::ConstKind::Placeholder(..) => throw_inval!(TooGeneric),\n-            ty::ConstKind::Error(DelaySpanBugEmitted { reported, .. }) => {\n-                throw_inval!(AlreadyReported(reported))\n-            }\n-            ty::ConstKind::Unevaluated(uv) => {\n-                // NOTE: We evaluate to a `ValTree` here as a check to ensure\n-                // we're working with valid constants, even though we never need it.\n-                let instance = self.resolve(uv.def, uv.substs)?;\n-                let cid = GlobalId { instance, promoted: None };\n-                let _valtree = self\n-                    .tcx\n-                    .eval_to_valtree(self.param_env.and(cid))?\n-                    .unwrap_or_else(|| bug!(\"unable to create ValTree for {:?}\", uv));\n-\n-                Ok(self.eval_to_allocation(cid)?.into())\n-            }\n-            ty::ConstKind::Bound(..) | ty::ConstKind::Infer(..) => {\n-                span_bug!(self.cur_span(), \"const_to_op: Unexpected ConstKind {:?}\", c)\n-            }\n-            ty::ConstKind::Value(valtree) => {\n-                let ty = c.ty();\n-                let const_val = self.tcx.valtree_to_const_val((ty, valtree));\n-                self.const_val_to_op(const_val, ty, layout)\n-            }\n-        }\n-    }\n-\n-    pub fn mir_const_to_op(\n         &self,\n         val: &mir::ConstantKind<'tcx>,\n         layout: Option<TyAndLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n         match val {\n-            mir::ConstantKind::Ty(ct) => self.const_to_op(*ct, layout),\n+            mir::ConstantKind::Ty(ct) => {\n+                match ct.kind() {\n+                    ty::ConstKind::Param(_) | ty::ConstKind::Placeholder(..) => {\n+                        throw_inval!(TooGeneric)\n+                    }\n+                    ty::ConstKind::Error(DelaySpanBugEmitted { reported, .. }) => {\n+                        throw_inval!(AlreadyReported(reported))\n+                    }\n+                    ty::ConstKind::Unevaluated(uv) => {\n+                        // NOTE: We evaluate to a `ValTree` here as a check to ensure\n+                        // we're working with valid constants, even though we never need it.\n+                        let instance = self.resolve(uv.def, uv.substs)?;\n+                        let cid = GlobalId { instance, promoted: None };\n+                        let _valtree = self\n+                            .tcx\n+                            .eval_to_valtree(self.param_env.and(cid))?\n+                            .unwrap_or_else(|| bug!(\"unable to create ValTree for {uv:?}\"));\n+\n+                        Ok(self.eval_to_allocation(cid)?.into())\n+                    }\n+                    ty::ConstKind::Bound(..) | ty::ConstKind::Infer(..) => {\n+                        span_bug!(self.cur_span(), \"unexpected ConstKind in ctfe: {ct:?}\")\n+                    }\n+                    ty::ConstKind::Value(valtree) => {\n+                        let ty = ct.ty();\n+                        let const_val = self.tcx.valtree_to_const_val((ty, valtree));\n+                        self.const_val_to_op(const_val, ty, layout)\n+                    }\n+                }\n+            }\n             mir::ConstantKind::Val(val, ty) => self.const_val_to_op(*val, *ty, layout),\n             mir::ConstantKind::Unevaluated(uv, _) => {\n                 let instance = self.resolve(uv.def, uv.substs)?;"}, {"sha": "b2cfcf53c599373e31224582ce9ebb0e9663e147", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -406,45 +406,6 @@ extern \"C\" LLVMValueRef LLVMRustBuildAtomicStore(LLVMBuilderRef B,\n   return wrap(SI);\n }\n \n-// FIXME: Use the C-API LLVMBuildAtomicCmpXchg and LLVMSetWeak\n-// once we raise our minimum support to LLVM 10.\n-extern \"C\" LLVMValueRef\n-LLVMRustBuildAtomicCmpXchg(LLVMBuilderRef B, LLVMValueRef Target,\n-                           LLVMValueRef Old, LLVMValueRef Source,\n-                           LLVMAtomicOrdering Order,\n-                           LLVMAtomicOrdering FailureOrder, LLVMBool Weak) {\n-  // Rust probably knows the alignment of the target value and should be able to\n-  // specify something more precise than MaybeAlign here. See also\n-  // https://reviews.llvm.org/D97224 which may be a useful reference.\n-  AtomicCmpXchgInst *ACXI = unwrap(B)->CreateAtomicCmpXchg(\n-      unwrap(Target), unwrap(Old), unwrap(Source), llvm::MaybeAlign(), fromRust(Order),\n-      fromRust(FailureOrder));\n-  ACXI->setWeak(Weak);\n-  return wrap(ACXI);\n-}\n-\n-enum class LLVMRustSynchronizationScope {\n-  SingleThread,\n-  CrossThread,\n-};\n-\n-static SyncScope::ID fromRust(LLVMRustSynchronizationScope Scope) {\n-  switch (Scope) {\n-  case LLVMRustSynchronizationScope::SingleThread:\n-    return SyncScope::SingleThread;\n-  case LLVMRustSynchronizationScope::CrossThread:\n-    return SyncScope::System;\n-  default:\n-    report_fatal_error(\"bad SynchronizationScope.\");\n-  }\n-}\n-\n-extern \"C\" LLVMValueRef\n-LLVMRustBuildAtomicFence(LLVMBuilderRef B, LLVMAtomicOrdering Order,\n-                         LLVMRustSynchronizationScope Scope) {\n-  return wrap(unwrap(B)->CreateFence(fromRust(Order), fromRust(Scope)));\n-}\n-\n enum class LLVMRustAsmDialect {\n   Att,\n   Intel,"}, {"sha": "a8c7505329cda205edc4959e2eaff0f442ab6694", "filename": "compiler/rustc_middle/src/mir/interpret/queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -211,7 +211,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self,\n         param_env: ty::ParamEnv<'tcx>,\n         constant: mir::ConstantKind<'tcx>,\n-    ) -> mir::DestructuredMirConstant<'tcx> {\n+    ) -> mir::DestructuredConstant<'tcx> {\n         self.try_destructure_mir_constant(param_env.and(constant)).unwrap()\n     }\n }"}, {"sha": "efd7357afc46c98f1b886a42e3b0b9217137ccce", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -392,16 +392,9 @@ pub enum ClosureOutlivesSubject<'tcx> {\n     Region(ty::RegionVid),\n }\n \n-/// The constituent parts of a type level constant of kind ADT or array.\n-#[derive(Copy, Clone, Debug, HashStable)]\n-pub struct DestructuredConst<'tcx> {\n-    pub variant: Option<VariantIdx>,\n-    pub fields: &'tcx [ty::Const<'tcx>],\n-}\n-\n /// The constituent parts of a mir constant of kind ADT or array.\n #[derive(Copy, Clone, Debug, HashStable)]\n-pub struct DestructuredMirConstant<'tcx> {\n+pub struct DestructuredConstant<'tcx> {\n     pub variant: Option<VariantIdx>,\n     pub fields: &'tcx [ConstantKind<'tcx>],\n }"}, {"sha": "568d63fb062171b85bdb8ff12c99c5c2319eef68", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -82,9 +82,10 @@ pub enum MirPhase {\n     ///    access to. This occurs in generator bodies. Such locals do not behave like other locals,\n     ///    because they eg may be aliased in surprising ways. Runtime MIR has no such special locals -\n     ///    all generator bodies are lowered and so all places that look like locals really are locals.\n-    ///  - Const prop lints: The lint pass which reports eg `200_u8 + 200_u8` as an error is run as a\n-    ///    part of analysis to runtime MIR lowering. This means that transformations which may supress\n-    ///    such errors may not run on analysis MIR.\n+    ///\n+    /// Also note that the lint pass which reports eg `200_u8 + 200_u8` as an error is run as a part\n+    /// of analysis to runtime MIR lowering. To ensure lints are reported reliably, this means that\n+    /// transformations which may supress such errors should not run on analysis MIR.\n     Runtime(RuntimePhase),\n }\n "}, {"sha": "1afea4864b8dd712f170101d2af49d4487680326", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -1007,7 +1007,9 @@ rustc_queries! {\n \n     /// Tries to destructure an `mir::ConstantKind` ADT or array into its variant index\n     /// and its field values.\n-    query try_destructure_mir_constant(key: ty::ParamEnvAnd<'tcx, mir::ConstantKind<'tcx>>) -> Option<mir::DestructuredMirConstant<'tcx>> {\n+    query try_destructure_mir_constant(\n+        key: ty::ParamEnvAnd<'tcx, mir::ConstantKind<'tcx>>\n+    ) -> Option<mir::DestructuredConstant<'tcx>> {\n         desc { \"destructuring mir constant\"}\n         remap_env_constness\n     }"}, {"sha": "4bc821dcfa1fb4ae566e115ba97ae04071bc1ab1", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 1, "deletions": 44, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -1,9 +1,6 @@\n use crate::mir::interpret::LitToConstInput;\n use crate::mir::ConstantKind;\n-use crate::ty::{\n-    self, InlineConstSubsts, InlineConstSubstsParts, InternalSubsts, ParamEnv, ParamEnvAnd, Ty,\n-    TyCtxt, TypeVisitable,\n-};\n+use crate::ty::{self, InternalSubsts, ParamEnv, ParamEnvAnd, Ty, TyCtxt};\n use rustc_data_structures::intern::Interned;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n@@ -151,46 +148,6 @@ impl<'tcx> Const<'tcx> {\n         }\n     }\n \n-    pub fn from_inline_const(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Self {\n-        debug!(\"Const::from_inline_const(def_id={:?})\", def_id);\n-\n-        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-\n-        let body_id = match tcx.hir().get(hir_id) {\n-            hir::Node::AnonConst(ac) => ac.body,\n-            _ => span_bug!(\n-                tcx.def_span(def_id.to_def_id()),\n-                \"from_inline_const can only process anonymous constants\"\n-            ),\n-        };\n-\n-        let expr = &tcx.hir().body(body_id).value;\n-\n-        let ty = tcx.typeck(def_id).node_type(hir_id);\n-\n-        let ret = match Self::try_eval_lit_or_param(tcx, ty, expr) {\n-            Some(v) => v,\n-            None => {\n-                let typeck_root_def_id = tcx.typeck_root_def_id(def_id.to_def_id());\n-                let parent_substs =\n-                    tcx.erase_regions(InternalSubsts::identity_for_item(tcx, typeck_root_def_id));\n-                let substs =\n-                    InlineConstSubsts::new(tcx, InlineConstSubstsParts { parent_substs, ty })\n-                        .substs;\n-                tcx.mk_const(ty::ConstS {\n-                    kind: ty::ConstKind::Unevaluated(ty::Unevaluated {\n-                        def: ty::WithOptConstParam::unknown(def_id).to_global(),\n-                        substs,\n-                        promoted: (),\n-                    }),\n-                    ty,\n-                })\n-            }\n-        };\n-        debug_assert!(!ret.has_free_regions());\n-        ret\n-    }\n-\n     /// Interns the given value as a constant.\n     #[inline]\n     pub fn from_value(tcx: TyCtxt<'tcx>, val: ty::ValTree<'tcx>, ty: Ty<'tcx>) -> Self {"}, {"sha": "be208a9fc7041338d29c2c53245b54779f9d0ccb", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -277,8 +277,9 @@ macro_rules! define_callbacks {\n             fn default() -> Self {\n                 Providers {\n                     $($name: |_, key| bug!(\n-                        \"`tcx.{}({:?})` unsupported by its crate; \\\n-                         perhaps the `{}` query was never assigned a provider function\",\n+                        \"`tcx.{}({:?})` is not supported for external or local crate;\\n\n+                        hint: Queries can be either made to the local crate, or the external crate. This error means you tried to use it for one that's not supported (likely the local crate).\\n\n+                        If that's not the case, {} was likely never assigned to a provider function.\\n\",\n                         stringify!($name),\n                         key,\n                         stringify!($name),"}, {"sha": "11645f840c1352732398e85a20e134a6a985b0f1", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -680,7 +680,7 @@ macro_rules! ClonePatternFoldableImpls {\n }\n \n ClonePatternFoldableImpls! { <'tcx>\n-    Span, Field, Mutability, Symbol, LocalVarId, usize, ty::Const<'tcx>,\n+    Span, Field, Mutability, Symbol, LocalVarId, usize,\n     Region<'tcx>, Ty<'tcx>, BindingMode, AdtDef<'tcx>,\n     SubstsRef<'tcx>, &'tcx GenericArg<'tcx>, UserType<'tcx>,\n     UserTypeProjection, CanonicalUserTypeAnnotation<'tcx>"}, {"sha": "cb134a20ea03efa2a3d73e07b4a74fa1a5ba3fca", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -471,7 +471,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             return None;\n         }\n \n-        self.ecx.mir_const_to_op(&c.literal, None).ok()\n+        self.ecx.const_to_op(&c.literal, None).ok()\n     }\n \n     /// Returns the value, if any, of evaluating `place`."}, {"sha": "2885f06b19cd610ba8304e936518e15b55c015c6", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -292,7 +292,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             return None;\n         }\n \n-        match self.ecx.mir_const_to_op(&c.literal, None) {\n+        match self.ecx.const_to_op(&c.literal, None) {\n             Ok(op) => Some(op),\n             Err(error) => {\n                 let tcx = self.ecx.tcx.at(c.span);"}, {"sha": "86c386b94c8349a08b2ba100f47e6f1e5bbff92b", "filename": "compiler/rustc_parse/src/parser/attr_wrapper.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -459,6 +459,5 @@ fn make_token_stream(\n             panic!(\"Unexpected last token {:?}\", last_token)\n         }\n     }\n-    assert!(stack.is_empty(), \"Stack should be empty: final_buf={:?} stack={:?}\", final_buf, stack);\n     AttrTokenStream::new(final_buf.inner)\n }"}, {"sha": "f35cc08f4fbfe61eb663c4f53bfd0b0ff8021424", "filename": "compiler/rustc_serialize/src/opaque.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -193,7 +193,9 @@ impl FileEncoder {\n         // shaves an instruction off those code paths (on x86 at least).\n         assert!(capacity <= usize::MAX - max_leb128_len());\n \n-        let file = File::create(path)?;\n+        // Create the file for reading and writing, because some encoders do both\n+        // (e.g. the metadata encoder when -Zmeta-stats is enabled)\n+        let file = File::options().read(true).write(true).create(true).truncate(true).open(path)?;\n \n         Ok(FileEncoder {\n             buf: Box::new_uninit_slice(capacity),"}, {"sha": "23e04ae6a53925f65504ad6d548ee831b24f8083", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -487,18 +487,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn array_length_to_const(&self, length: &hir::ArrayLen) -> ty::Const<'tcx> {\n         match length {\n             &hir::ArrayLen::Infer(_, span) => self.ct_infer(self.tcx.types.usize, None, span),\n-            hir::ArrayLen::Body(anon_const) => self.to_const(anon_const),\n+            hir::ArrayLen::Body(anon_const) => {\n+                let const_def_id = self.tcx.hir().local_def_id(anon_const.hir_id);\n+                let span = self.tcx.hir().span(anon_const.hir_id);\n+                let c = ty::Const::from_anon_const(self.tcx, const_def_id);\n+                self.register_wf_obligation(c.into(), span, ObligationCauseCode::WellFormed(None));\n+                self.normalize_associated_types_in(span, c)\n+            }\n         }\n     }\n \n-    pub fn to_const(&self, ast_c: &hir::AnonConst) -> ty::Const<'tcx> {\n-        let const_def_id = self.tcx.hir().local_def_id(ast_c.hir_id);\n-        let span = self.tcx.hir().span(ast_c.hir_id);\n-        let c = ty::Const::from_anon_const(self.tcx, const_def_id);\n-        self.register_wf_obligation(c.into(), span, ObligationCauseCode::WellFormed(None));\n-        self.normalize_associated_types_in(span, c)\n-    }\n-\n     pub fn const_arg_to_const(\n         &self,\n         ast_c: &hir::AnonConst,"}, {"sha": "87961890f53e57b814611f5683acf4666c821c8e", "filename": "compiler/rustc_typeck/src/coherence/orphan.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -5,7 +5,6 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_errors::{Diagnostic, ErrorGuaranteed};\n use rustc_hir as hir;\n-use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::util::IgnoreRegions;\n@@ -229,12 +228,8 @@ fn emit_orphan_check_error<'tcx>(\n                 \"only traits defined in the current crate {msg}\"\n             );\n             err.span_label(sp, \"impl doesn't use only types from inside the current crate\");\n-            for (ty, is_target_ty) in &tys {\n-                let mut ty = *ty;\n-                tcx.infer_ctxt().enter(|infcx| {\n-                    // Remove the lifetimes unnecessary for this error.\n-                    ty = infcx.freshen(ty);\n-                });\n+            for &(mut ty, is_target_ty) in &tys {\n+                ty = tcx.erase_regions(ty);\n                 ty = match ty.kind() {\n                     // Remove the type arguments from the output, as they are not relevant.\n                     // You can think of this as the reverse of `resolve_vars_if_possible`.\n@@ -264,7 +259,7 @@ fn emit_orphan_check_error<'tcx>(\n                 };\n \n                 let msg = format!(\"{} is not defined in the current crate{}\", ty, postfix);\n-                if *is_target_ty {\n+                if is_target_ty {\n                     // Point at `D<A>` in `impl<A, B> for C<B> in D<A>`\n                     err.span_label(self_ty_span, &msg);\n                 } else {"}, {"sha": "3e324bbb069c619f7f6f8f0591bdcb1d77f0283a", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -514,7 +514,7 @@ fn item_function(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, f: &cle\n         + name.as_str().len()\n         + generics_len;\n \n-    wrap_into_docblock(w, |w| {\n+    wrap_into_item_decl(w, |w| {\n         wrap_item(w, \"fn\", |w| {\n             render_attributes_in_pre(w, it, \"\");\n             w.reserve(header_len);\n@@ -553,7 +553,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n         cx.tcx().trait_def(t.def_id).must_implement_one_of.clone();\n \n     // Output the trait definition\n-    wrap_into_docblock(w, |w| {\n+    wrap_into_item_decl(w, |w| {\n         wrap_item(w, \"trait\", |w| {\n             render_attributes_in_pre(w, it, \"\");\n             write!(\n@@ -1033,7 +1033,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n }\n \n fn item_trait_alias(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean::TraitAlias) {\n-    wrap_into_docblock(w, |w| {\n+    wrap_into_item_decl(w, |w| {\n         wrap_item(w, \"trait-alias\", |w| {\n             render_attributes_in_pre(w, it, \"\");\n             write!(\n@@ -1057,7 +1057,7 @@ fn item_trait_alias(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &\n }\n \n fn item_opaque_ty(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean::OpaqueTy) {\n-    wrap_into_docblock(w, |w| {\n+    wrap_into_item_decl(w, |w| {\n         wrap_item(w, \"opaque\", |w| {\n             render_attributes_in_pre(w, it, \"\");\n             write!(\n@@ -1096,7 +1096,7 @@ fn item_typedef(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clea\n         });\n     }\n \n-    wrap_into_docblock(w, |w| write_content(w, cx, it, t));\n+    wrap_into_item_decl(w, |w| write_content(w, cx, it, t));\n \n     document(w, cx, it, None, HeadingOffset::H2);\n \n@@ -1110,7 +1110,7 @@ fn item_typedef(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clea\n }\n \n fn item_union(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean::Union) {\n-    wrap_into_docblock(w, |w| {\n+    wrap_into_item_decl(w, |w| {\n         wrap_item(w, \"union\", |w| {\n             render_attributes_in_pre(w, it, \"\");\n             render_union(w, it, Some(&s.generics), &s.fields, \"\", cx);\n@@ -1174,7 +1174,7 @@ fn print_tuple_struct_fields(w: &mut Buffer, cx: &Context<'_>, s: &[clean::Item]\n \n fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::Enum) {\n     let count_variants = e.variants().count();\n-    wrap_into_docblock(w, |w| {\n+    wrap_into_item_decl(w, |w| {\n         wrap_item(w, \"enum\", |w| {\n             render_attributes_in_pre(w, it, \"\");\n             write!(\n@@ -1333,14 +1333,14 @@ fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::\n }\n \n fn item_macro(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean::Macro) {\n-    wrap_into_docblock(w, |w| {\n+    wrap_into_item_decl(w, |w| {\n         highlight::render_macro_with_highlighting(&t.source, w);\n     });\n     document(w, cx, it, None, HeadingOffset::H2)\n }\n \n fn item_proc_macro(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, m: &clean::ProcMacro) {\n-    wrap_into_docblock(w, |w| {\n+    wrap_into_item_decl(w, |w| {\n         let name = it.name.expect(\"proc-macros always have names\");\n         match m.kind {\n             MacroKind::Bang => {\n@@ -1387,7 +1387,7 @@ fn item_primitive(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item) {\n }\n \n fn item_constant(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, c: &clean::Constant) {\n-    wrap_into_docblock(w, |w| {\n+    wrap_into_item_decl(w, |w| {\n         wrap_item(w, \"const\", |w| {\n             render_attributes_in_code(w, it);\n \n@@ -1436,7 +1436,7 @@ fn item_constant(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, c: &cle\n }\n \n fn item_struct(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean::Struct) {\n-    wrap_into_docblock(w, |w| {\n+    wrap_into_item_decl(w, |w| {\n         wrap_item(w, \"struct\", |w| {\n             render_attributes_in_code(w, it);\n             render_struct(w, it, Some(&s.generics), s.struct_type, &s.fields, \"\", true, cx);\n@@ -1489,7 +1489,7 @@ fn item_struct(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean\n }\n \n fn item_static(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean::Static) {\n-    wrap_into_docblock(w, |w| {\n+    wrap_into_item_decl(w, |w| {\n         wrap_item(w, \"static\", |w| {\n             render_attributes_in_code(w, it);\n             write!(\n@@ -1506,7 +1506,7 @@ fn item_static(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean\n }\n \n fn item_foreign_type(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item) {\n-    wrap_into_docblock(w, |w| {\n+    wrap_into_item_decl(w, |w| {\n         wrap_item(w, \"foreigntype\", |w| {\n             w.write_str(\"extern {\\n\");\n             render_attributes_in_code(w, it);\n@@ -1595,11 +1595,11 @@ fn bounds(t_bounds: &[clean::GenericBound], trait_alias: bool, cx: &Context<'_>)\n     bounds\n }\n \n-fn wrap_into_docblock<F>(w: &mut Buffer, f: F)\n+fn wrap_into_item_decl<F>(w: &mut Buffer, f: F)\n where\n     F: FnOnce(&mut Buffer),\n {\n-    w.write_str(\"<div class=\\\"docblock item-decl\\\">\");\n+    w.write_str(\"<div class=\\\"item-decl\\\">\");\n     f(w);\n     w.write_str(\"</div>\")\n }"}, {"sha": "e985e6c43ade9ae0a1e6150a8672c8fd435306d1", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -141,10 +141,6 @@ h1, h2, h3, h4 {\n h1.fqn {\n \tmargin: 0;\n \tpadding: 0;\n-\tborder-bottom-color: var(--headings-border-bottom-color);\n-}\n-h2, h3, h4 {\n-\tborder-bottom-color: var(--headings-border-bottom-color);\n }\n .main-heading {\n \tdisplay: flex;\n@@ -372,9 +368,6 @@ code, pre, a.test-arrow, .code-header {\n pre {\n \tpadding: 14px;\n }\n-.docblock.item-decl {\n-\tmargin-left: 0;\n-}\n .item-decl pre {\n \toverflow-x: auto;\n }\n@@ -662,9 +655,6 @@ h2.location a {\n \n .docblock h5 { font-size: 1rem; }\n .docblock h6 { font-size: 0.875rem; }\n-.docblock h1, .docblock h2, .docblock h3, .docblock h4, .docblock h5, .docblock h6 {\n-\tborder-bottom-color: var(--headings-border-bottom-color);\n-}\n \n .docblock {\n \tmargin-left: 24px;"}, {"sha": "f2fc3e9afc2a2adfe6eff3c70292081b278fad19", "filename": "src/test/rustdoc-gui/check-code-blocks-margin.goml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc-gui%2Fcheck-code-blocks-margin.goml", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc-gui%2Fcheck-code-blocks-margin.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fcheck-code-blocks-margin.goml?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -1,6 +1,6 @@\n // This test ensures that the docblock elements have the appropriate left margin.\n goto: file://|DOC_PATH|/test_docs/fn.foo.html\n // The top docblock elements shouldn't have left margin...\n-assert-css: (\"#main-content .docblock.item-decl\", {\"margin-left\": \"0px\"})\n+assert-css: (\"#main-content .item-decl\", {\"margin-left\": \"0px\"})\n // ... but all the others should!\n-assert-css: (\"#main-content .docblock:not(.item-decl)\", {\"margin-left\": \"24px\"})\n+assert-css: (\"#main-content .docblock\", {\"margin-left\": \"24px\"})"}, {"sha": "c0c4d1b43aac10136fb240ae11a2412051db2032", "filename": "src/test/rustdoc-gui/docblock-details.goml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc-gui%2Fdocblock-details.goml", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc-gui%2Fdocblock-details.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fdocblock-details.goml?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -14,7 +14,7 @@ assert-css: (\n // We now check that the `<summary>` doesn't have a bottom border and has the correct display.\n assert-css: (\n     \".top-doc .docblock summary h4\",\n-    {\"border-bottom\": \"0px none rgb(210, 210, 210)\"},\n+    {\"border-bottom-width\": \"0px\"},\n )\n // This allows to ensure that summary is on one line only!\n assert-property: (\".top-doc .docblock summary h4\", {\"offsetHeight\": \"33\"})"}, {"sha": "13e8ec9fb16a787249e809d78f2dd13989896643", "filename": "src/test/rustdoc-gui/font-weight.goml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc-gui%2Ffont-weight.goml", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc-gui%2Ffont-weight.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Ffont-weight.goml?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -1,6 +1,6 @@\n // This test checks that the font weight is correctly applied.\n goto: file://|DOC_PATH|/lib2/struct.Foo.html\n-assert-css: (\"//*[@class='docblock item-decl']//a[text()='Alias']\", {\"font-weight\": \"400\"})\n+assert-css: (\"//*[@class='item-decl']//a[text()='Alias']\", {\"font-weight\": \"400\"})\n assert-css: (\n     \"//*[@class='structfield small-section-header']//a[text()='Alias']\",\n     {\"font-weight\": \"400\"},\n@@ -19,7 +19,7 @@ goto: file://|DOC_PATH|/lib2/trait.Trait.html\n \n // This is a complex selector, so here's how it works:\n //\n-// * //*[@class='docblock item-decl'] \u2014 selects element of any tag with classes docblock and item-decl\n+// * //*[@class='item-decl'] \u2014 selects element of any tag with classes docblock and item-decl\n // * /pre[@class='rust trait'] \u2014 selects immediate child with tag pre and classes rust and trait\n // * /code \u2014 selects immediate child with tag code\n // * /a[@class='constant'] \u2014 selects immediate child with tag a and class constant\n@@ -29,11 +29,11 @@ goto: file://|DOC_PATH|/lib2/trait.Trait.html\n // This uses '/parent::*' as a proxy for the style of the text node.\n // We can't just select the '<a>' because intermediate tags could be added.\n assert-count: (\n-    \"//*[@class='docblock item-decl']/pre[@class='rust trait']/code/a[@class='constant']//text()/parent::*\",\n+    \"//*[@class='item-decl']/pre[@class='rust trait']/code/a[@class='constant']//text()/parent::*\",\n     1,\n )\n assert-css: (\n-    \"//*[@class='docblock item-decl']/pre[@class='rust trait']/code/a[@class='constant']//text()/parent::*\",\n+    \"//*[@class='item-decl']/pre[@class='rust trait']/code/a[@class='constant']//text()/parent::*\",\n     {\"font-weight\": \"400\"},\n )\n "}, {"sha": "53308e13480bf7250fc03c4e7f58229ec70ccd34", "filename": "src/test/rustdoc-gui/headings.goml", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc-gui%2Fheadings.goml", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc-gui%2Fheadings.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fheadings.goml?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -168,19 +168,19 @@ assert-css: (\n )\n assert-css: (\n     \".top-doc .docblock h5\",\n-    {\"color\": \"rgb(0, 0, 0)\", \"border-bottom\": \"0px none rgb(221, 221, 221)\"},\n+    {\"color\": \"rgb(0, 0, 0)\", \"border-bottom-width\": \"0px\"},\n )\n assert-css: (\n     \"#implementations-list .docblock h4\",\n-    {\"color\": \"rgb(0, 0, 0)\", \"border-bottom\": \"0px none rgb(221, 221, 221)\"},\n+    {\"color\": \"rgb(0, 0, 0)\", \"border-bottom-width\": \"0px\"},\n )\n assert-css: (\n     \"#implementations-list .docblock h5\",\n-    {\"color\": \"rgb(0, 0, 0)\", \"border-bottom\": \"0px none rgb(221, 221, 221)\"},\n+    {\"color\": \"rgb(0, 0, 0)\", \"border-bottom-width\": \"0px\"},\n )\n assert-css: (\n     \"#implementations-list .docblock h6\",\n-    {\"color\": \"rgb(0, 0, 0)\", \"border-bottom\": \"0px none rgb(221, 221, 221)\"},\n+    {\"color\": \"rgb(0, 0, 0)\", \"border-bottom-width\": \"0px\"},\n )\n \n local-storage: {\"rustdoc-theme\": \"dark\"}\n@@ -199,19 +199,19 @@ assert-css: (\n )\n assert-css: (\n     \".top-doc .docblock h5\",\n-    {\"color\": \"rgb(221, 221, 221)\", \"border-bottom\": \"0px none rgb(210, 210, 210)\"},\n+    {\"color\": \"rgb(221, 221, 221)\", \"border-bottom-width\": \"0px\"},\n )\n assert-css: (\n     \"#implementations-list .docblock h4\",\n-    {\"color\": \"rgb(221, 221, 221)\", \"border-bottom\": \"0px none rgb(210, 210, 210)\"},\n+    {\"color\": \"rgb(221, 221, 221)\", \"border-bottom-width\": \"0px\"},\n )\n assert-css: (\n     \"#implementations-list .docblock h5\",\n-    {\"color\": \"rgb(221, 221, 221)\", \"border-bottom\": \"0px none rgb(210, 210, 210)\"},\n+    {\"color\": \"rgb(221, 221, 221)\", \"border-bottom-width\": \"0px\"},\n )\n assert-css: (\n     \"#implementations-list .docblock h6\",\n-    {\"color\": \"rgb(221, 221, 221)\", \"border-bottom\": \"0px none rgb(210, 210, 210)\"},\n+    {\"color\": \"rgb(221, 221, 221)\", \"border-bottom-width\": \"0px\"},\n )\n \n local-storage: {\"rustdoc-theme\": \"ayu\"}\n@@ -230,19 +230,19 @@ assert-css: (\n )\n assert-css: (\n     \".top-doc .docblock h5\",\n-    {\"color\": \"rgb(197, 197, 197)\", \"border-bottom\": \"0px none rgb(92, 103, 115)\"},\n+    {\"color\": \"rgb(197, 197, 197)\", \"border-bottom-width\": \"0px\"},\n )\n assert-css: (\n     \"#implementations-list .docblock h4\",\n-    {\"color\": \"rgb(255, 255, 255)\", \"border-bottom\": \"0px none rgb(92, 103, 115)\"},\n+    {\"color\": \"rgb(255, 255, 255)\", \"border-bottom-width\": \"0px\"},\n )\n assert-css: (\n     \"#implementations-list .docblock h5\",\n-    {\"color\": \"rgb(197, 197, 197)\", \"border-bottom\": \"0px none rgb(92, 103, 115)\"},\n+    {\"color\": \"rgb(197, 197, 197)\", \"border-bottom-width\": \"0px\"},\n )\n assert-css: (\n     \"#implementations-list .docblock h6\",\n-    {\"color\": \"rgb(197, 197, 197)\", \"border-bottom\": \"0px none rgb(92, 103, 115)\"},\n+    {\"color\": \"rgb(197, 197, 197)\", \"border-bottom-width\": \"0px\"},\n )\n \n local-storage: {\"rustdoc-theme\": \"light\"}"}, {"sha": "17478da4fea291986a47147bc7303273db0df617", "filename": "src/test/rustdoc-gui/item-info-overflow.goml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc-gui%2Fitem-info-overflow.goml", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc-gui%2Fitem-info-overflow.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fitem-info-overflow.goml?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -3,7 +3,7 @@ goto: file://|DOC_PATH|/lib2/struct.LongItemInfo.html\n // We set a fixed size so there is no chance of \"random\" resize.\n size: (1200, 870)\n // Logically, the \"item-decl\" and the \"item-info\" should have the same scroll width.\n-compare-elements-property: (\".docblock.item-decl\", \".item-info\", [\"scrollWidth\"])\n+compare-elements-property: (\".item-decl\", \".item-info\", [\"scrollWidth\"])\n assert-property: (\".item-info\", {\"scrollWidth\": \"890\"})\n // Just to be sure we're comparing the correct \"item-info\":\n assert-text: ("}, {"sha": "69088a0774fc42e64b9f3df834b61f525081e92c", "filename": "src/test/rustdoc-gui/notable-trait.goml", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc-gui%2Fnotable-trait.goml", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc-gui%2Fnotable-trait.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fnotable-trait.goml?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -0,0 +1,91 @@\n+// This test checks the position of the `i` for the notable traits.\n+goto: file://|DOC_PATH|/test_docs/struct.NotableStructWithLongName.html\n+show-text: true\n+// We start with a wide screen.\n+size: (1100, 600)\n+// Checking they have the same y position.\n+compare-elements-position: (\n+    \"//*[@id='method.create_an_iterator_from_read']//a[text()='NotableStructWithLongName']\",\n+    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\",\n+    (\"y\"),\n+)\n+// Checking they don't have the same x position.\n+compare-elements-position-false: (\n+    \"//*[@id='method.create_an_iterator_from_read']//a[text()='NotableStructWithLongName']\",\n+    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\",\n+    (\"x\"),\n+)\n+// The `i` should be *after* the type.\n+assert-position: (\n+    \"//*[@id='method.create_an_iterator_from_read']//a[text()='NotableStructWithLongName']\",\n+    {\"x\": 692},\n+)\n+assert-position: (\n+    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\",\n+    {\"x\": 966},\n+)\n+\n+\n+// Now only the `i` should be on the next line.\n+size: (1055, 600)\n+compare-elements-position-false: (\n+    \"//*[@id='method.create_an_iterator_from_read']//a[text()='NotableStructWithLongName']\",\n+    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\",\n+    (\"y\", \"x\"),\n+)\n+\n+// Now both the `i` and the struct name should be on the next line.\n+size: (980, 600)\n+// Checking they have the same y position.\n+compare-elements-position: (\n+    \"//*[@id='method.create_an_iterator_from_read']//a[text()='NotableStructWithLongName']\",\n+    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\",\n+    (\"y\"),\n+)\n+// Checking they don't have the same x position.\n+compare-elements-position-false: (\n+    \"//*[@id='method.create_an_iterator_from_read']//a[text()='NotableStructWithLongName']\",\n+    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\",\n+    (\"x\"),\n+)\n+// The `i` should be *after* the type.\n+assert-position: (\n+    \"//*[@id='method.create_an_iterator_from_read']//a[text()='NotableStructWithLongName']\",\n+    {\"x\": 245},\n+)\n+assert-position: (\n+    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\",\n+    {\"x\": 519},\n+)\n+\n+// Checking on mobile now.\n+size: (650, 600)\n+// Checking they have the same y position.\n+compare-elements-position: (\n+    \"//*[@id='method.create_an_iterator_from_read']//a[text()='NotableStructWithLongName']\",\n+    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\",\n+    (\"y\"),\n+)\n+// Checking they don't have the same x position.\n+compare-elements-position-false: (\n+    \"//*[@id='method.create_an_iterator_from_read']//a[text()='NotableStructWithLongName']\",\n+    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\",\n+    (\"x\"),\n+)\n+// The `i` should be *after* the type.\n+assert-position: (\n+    \"//*[@id='method.create_an_iterator_from_read']//a[text()='NotableStructWithLongName']\",\n+    {\"x\": 15},\n+)\n+assert-position: (\n+    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\",\n+    {\"x\": 289},\n+)\n+\n+// Checking on very small mobile. The `i` should be on its own line.\n+size: (410, 600)\n+compare-elements-position-false: (\n+    \"//*[@id='method.create_an_iterator_from_read']//a[text()='NotableStructWithLongName']\",\n+    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\",\n+    (\"y\", \"x\"),\n+)"}, {"sha": "e6177ff84b42e86bb6b9f6f118bd1528302bb15a", "filename": "src/test/rustdoc-gui/src/test_docs/lib.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -325,3 +325,15 @@ pub mod doc_block_table {\n     }\n \n }\n+\n+pub struct NotableStructWithLongName<R>(R);\n+\n+impl<R: std::io::Read> NotableStructWithLongName<R> {\n+    pub fn create_an_iterator_from_read(r: R) -> NotableStructWithLongName<R> { Self(r) }\n+}\n+\n+impl<R: std::io::Read> std::iter::Iterator for NotableStructWithLongName<R> {\n+    type Item = ();\n+\n+    fn next(&mut self) -> Option<Self::Item> { () }\n+}"}, {"sha": "3698fe70e7f7e2fa41b3e628d377090122164c73", "filename": "src/test/rustdoc-ui/normalize-overflow.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc-ui%2Fnormalize-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc-ui%2Fnormalize-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fnormalize-overflow.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -1,3 +1,5 @@\n // aux-crate:overflow=overflow.rs\n // check-pass\n // Regression test for <https://github.com/rust-lang/rust/issues/79506>.\n+\n+extern crate overflow;"}, {"sha": "36e10923c85354e44ef7658f031ed5e5b49fd090", "filename": "src/test/rustdoc/attribute-rendering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Fattribute-rendering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Fattribute-rendering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fattribute-rendering.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -1,7 +1,7 @@\n #![crate_name = \"foo\"]\n \n // @has 'foo/fn.f.html'\n-// @has - //*[@'class=\"docblock item-decl\"]' '#[export_name = \"f\"] pub fn f()'\n+// @has - //*[@'class=\"item-decl\"]' '#[export_name = \"f\"] pub fn f()'\n #[export_name = \"\\\n f\"]\n pub fn f() {}"}, {"sha": "a36dadced87d71e906c79babf398039265b46c12", "filename": "src/test/rustdoc/attributes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fattributes.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -8,6 +8,6 @@ pub extern \"C\" fn f() {}\n #[export_name = \"bar\"]\n pub extern \"C\" fn g() {}\n \n-// @has foo/struct.Repr.html '//*[@class=\"docblock item-decl\"]' '#[repr(C, align(8))]'\n+// @has foo/struct.Repr.html '//*[@class=\"item-decl\"]' '#[repr(C, align(8))]'\n #[repr(C, align(8))]\n pub struct Repr;"}, {"sha": "8d95f0de9d098809873d8299e430c65a7e07ea25", "filename": "src/test/rustdoc/const-value-display.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Fconst-value-display.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Fconst-value-display.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fconst-value-display.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -1,9 +1,9 @@\n #![crate_name = \"foo\"]\n \n // @has 'foo/constant.HOUR_IN_SECONDS.html'\n-// @has - '//*[@class=\"docblock item-decl\"]//code' 'pub const HOUR_IN_SECONDS: u64 = _; // 3_600u64'\n+// @has - '//*[@class=\"item-decl\"]//code' 'pub const HOUR_IN_SECONDS: u64 = _; // 3_600u64'\n pub const HOUR_IN_SECONDS: u64 = 60 * 60;\n \n // @has 'foo/constant.NEGATIVE.html'\n-// @has - '//*[@class=\"docblock item-decl\"]//code' 'pub const NEGATIVE: i64 = _; // -3_600i64'\n+// @has - '//*[@class=\"item-decl\"]//code' 'pub const NEGATIVE: i64 = _; // -3_600i64'\n pub const NEGATIVE: i64 = -60 * 60;"}, {"sha": "e47edc1321851744137066320b05838c0084ac67", "filename": "src/test/rustdoc/decl-trailing-whitespace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Fdecl-trailing-whitespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Fdecl-trailing-whitespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fdecl-trailing-whitespace.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -7,7 +7,7 @@ pub struct Error;\n // @has 'foo/trait.Write.html'\n \n pub trait Write {\n-    // @snapshot 'declaration' - '//*[@class=\"docblock item-decl\"]//code'\n+    // @snapshot 'declaration' - '//*[@class=\"item-decl\"]//code'\n     fn poll_write(\n         self: Option<String>,\n         cx: &mut Option<String>,"}, {"sha": "b8c52b7b791d61c3acbf000adb2c3c8262acc829", "filename": "src/test/rustdoc/macro-higher-kinded-function.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Fmacro-higher-kinded-function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Fmacro-higher-kinded-function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fmacro-higher-kinded-function.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -11,8 +11,8 @@ macro_rules! gen {\n }\n \n // @has 'foo/struct.Providers.html'\n-// @has - '//*[@class=\"docblock item-decl\"]//code' \"pub a: for<'tcx> fn(_: TyCtxt<'tcx>, _: u8) -> i8,\"\n-// @has - '//*[@class=\"docblock item-decl\"]//code' \"pub b: for<'tcx> fn(_: TyCtxt<'tcx>, _: u16) -> i16,\"\n+// @has - '//*[@class=\"item-decl\"]//code' \"pub a: for<'tcx> fn(_: TyCtxt<'tcx>, _: u8) -> i8,\"\n+// @has - '//*[@class=\"item-decl\"]//code' \"pub b: for<'tcx> fn(_: TyCtxt<'tcx>, _: u16) -> i16,\"\n // @has - '//*[@id=\"structfield.a\"]/code' \"a: for<'tcx> fn(_: TyCtxt<'tcx>, _: u8) -> i8\"\n // @has - '//*[@id=\"structfield.b\"]/code' \"b: for<'tcx> fn(_: TyCtxt<'tcx>, _: u16) -> i16\"\n gen! {"}, {"sha": "6694c91d104425c9653c7879194a56a596a34370", "filename": "src/test/rustdoc/reexport-dep-foreign-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Freexport-dep-foreign-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Freexport-dep-foreign-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Freexport-dep-foreign-fn.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -8,5 +8,5 @@\n extern crate all_item_types;\n \n // @has 'foo/fn.foo_ffn.html'\n-// @has - '//*[@class=\"docblock item-decl\"]//code' 'pub unsafe extern \"C\" fn foo_ffn()'\n+// @has - '//*[@class=\"item-decl\"]//code' 'pub unsafe extern \"C\" fn foo_ffn()'\n pub use all_item_types::foo_ffn;"}, {"sha": "11364e7f707ef9c7e0d3e4756245907abea61087", "filename": "src/test/rustdoc/reexports-priv.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Freexports-priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Freexports-priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Freexports-priv.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -5,7 +5,7 @@\n \n extern crate reexports;\n \n-// @has 'foo/macro.addr_of.html' '//*[@class=\"docblock item-decl\"]' 'pub macro addr_of($place:expr) {'\n+// @has 'foo/macro.addr_of.html' '//*[@class=\"item-decl\"]' 'pub macro addr_of($place:expr) {'\n pub use reexports::addr_of;\n // @!has 'foo/macro.addr_of_crate.html'\n pub(crate) use reexports::addr_of_crate;\n@@ -14,7 +14,7 @@ pub(self) use reexports::addr_of_self;\n // @!has 'foo/macro.addr_of_local.html'\n use reexports::addr_of_local;\n \n-// @has 'foo/struct.Foo.html' '//*[@class=\"docblock item-decl\"]' 'pub struct Foo;'\n+// @has 'foo/struct.Foo.html' '//*[@class=\"item-decl\"]' 'pub struct Foo;'\n pub use reexports::Foo;\n // @!has 'foo/struct.FooCrate.html'\n pub(crate) use reexports::FooCrate;\n@@ -23,7 +23,7 @@ pub(self) use reexports::FooSelf;\n // @!has 'foo/struct.FooLocal.html'\n use reexports::FooLocal;\n \n-// @has 'foo/enum.Bar.html' '//*[@class=\"docblock item-decl\"]' 'pub enum Bar {'\n+// @has 'foo/enum.Bar.html' '//*[@class=\"item-decl\"]' 'pub enum Bar {'\n pub use reexports::Bar;\n // @!has 'foo/enum.BarCrate.html'\n pub(crate) use reexports::BarCrate;\n@@ -50,7 +50,7 @@ pub(self) use reexports::TypeSelf;\n // @!has 'foo/type.TypeLocal.html'\n use reexports::TypeLocal;\n \n-// @has 'foo/union.Union.html' '//*[@class=\"docblock item-decl\"]' 'pub union Union {'\n+// @has 'foo/union.Union.html' '//*[@class=\"item-decl\"]' 'pub union Union {'\n pub use reexports::Union;\n // @!has 'foo/union.UnionCrate.html'\n pub(crate) use reexports::UnionCrate;\n@@ -61,33 +61,33 @@ use reexports::UnionLocal;\n \n pub mod outer {\n     pub mod inner {\n-        // @has 'foo/outer/inner/macro.addr_of.html' '//*[@class=\"docblock item-decl\"]' 'pub macro addr_of($place:expr) {'\n+        // @has 'foo/outer/inner/macro.addr_of.html' '//*[@class=\"item-decl\"]' 'pub macro addr_of($place:expr) {'\n         pub use reexports::addr_of;\n-        // @has 'foo/outer/inner/macro.addr_of_crate.html' '//*[@class=\"docblock item-decl\"]' 'pub(crate) macro addr_of_crate($place:expr) {'\n+        // @has 'foo/outer/inner/macro.addr_of_crate.html' '//*[@class=\"item-decl\"]' 'pub(crate) macro addr_of_crate($place:expr) {'\n         pub(crate) use reexports::addr_of_crate;\n-        // @has 'foo/outer/inner/macro.addr_of_super.html' '//*[@class=\"docblock item-decl\"]' 'pub(in outer) macro addr_of_super($place:expr) {'\n+        // @has 'foo/outer/inner/macro.addr_of_super.html' '//*[@class=\"item-decl\"]' 'pub(in outer) macro addr_of_super($place:expr) {'\n         pub(super) use reexports::addr_of_super;\n         // @!has 'foo/outer/inner/macro.addr_of_self.html'\n         pub(self) use reexports::addr_of_self;\n         // @!has 'foo/outer/inner/macro.addr_of_local.html'\n         use reexports::addr_of_local;\n \n-        // @has 'foo/outer/inner/struct.Foo.html' '//*[@class=\"docblock item-decl\"]' 'pub struct Foo;'\n+        // @has 'foo/outer/inner/struct.Foo.html' '//*[@class=\"item-decl\"]' 'pub struct Foo;'\n         pub use reexports::Foo;\n-        // @has 'foo/outer/inner/struct.FooCrate.html' '//*[@class=\"docblock item-decl\"]' 'pub(crate) struct FooCrate;'\n+        // @has 'foo/outer/inner/struct.FooCrate.html' '//*[@class=\"item-decl\"]' 'pub(crate) struct FooCrate;'\n         pub(crate) use reexports::FooCrate;\n-        // @has 'foo/outer/inner/struct.FooSuper.html' '//*[@class=\"docblock item-decl\"]' 'pub(in outer) struct FooSuper;'\n+        // @has 'foo/outer/inner/struct.FooSuper.html' '//*[@class=\"item-decl\"]' 'pub(in outer) struct FooSuper;'\n         pub(super) use reexports::FooSuper;\n         // @!has 'foo/outer/inner/struct.FooSelf.html'\n         pub(self) use reexports::FooSelf;\n         // @!has 'foo/outer/inner/struct.FooLocal.html'\n         use reexports::FooLocal;\n \n-        // @has 'foo/outer/inner/enum.Bar.html' '//*[@class=\"docblock item-decl\"]' 'pub enum Bar {'\n+        // @has 'foo/outer/inner/enum.Bar.html' '//*[@class=\"item-decl\"]' 'pub enum Bar {'\n         pub use reexports::Bar;\n-        // @has 'foo/outer/inner/enum.BarCrate.html' '//*[@class=\"docblock item-decl\"]' 'pub(crate) enum BarCrate {'\n+        // @has 'foo/outer/inner/enum.BarCrate.html' '//*[@class=\"item-decl\"]' 'pub(crate) enum BarCrate {'\n         pub(crate) use reexports::BarCrate;\n-        // @has 'foo/outer/inner/enum.BarSuper.html' '//*[@class=\"docblock item-decl\"]' 'pub(in outer) enum BarSuper {'\n+        // @has 'foo/outer/inner/enum.BarSuper.html' '//*[@class=\"item-decl\"]' 'pub(in outer) enum BarSuper {'\n         pub(super) use reexports::BarSuper;\n         // @!has 'foo/outer/inner/enum.BarSelf.html'\n         pub(self) use reexports::BarSelf;\n@@ -116,11 +116,11 @@ pub mod outer {\n         // @!has 'foo/outer/inner/type.TypeLocal.html'\n         use reexports::TypeLocal;\n \n-        // @has 'foo/outer/inner/union.Union.html' '//*[@class=\"docblock item-decl\"]' 'pub union Union {'\n+        // @has 'foo/outer/inner/union.Union.html' '//*[@class=\"item-decl\"]' 'pub union Union {'\n         pub use reexports::Union;\n-        // @has 'foo/outer/inner/union.UnionCrate.html' '//*[@class=\"docblock item-decl\"]' 'pub(crate) union UnionCrate {'\n+        // @has 'foo/outer/inner/union.UnionCrate.html' '//*[@class=\"item-decl\"]' 'pub(crate) union UnionCrate {'\n         pub(crate) use reexports::UnionCrate;\n-        // @has 'foo/outer/inner/union.UnionSuper.html' '//*[@class=\"docblock item-decl\"]' 'pub(in outer) union UnionSuper {'\n+        // @has 'foo/outer/inner/union.UnionSuper.html' '//*[@class=\"item-decl\"]' 'pub(in outer) union UnionSuper {'\n         pub(super) use reexports::UnionSuper;\n         // @!has 'foo/outer/inner/union.UnionSelf.html'\n         pub(self) use reexports::UnionSelf;"}, {"sha": "9aa6d7224baca200e54974cbee5ab25404d18a68", "filename": "src/test/rustdoc/reexports.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Freexports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Freexports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Freexports.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -4,7 +4,7 @@\n \n extern crate reexports;\n \n-// @has 'foo/macro.addr_of.html' '//*[@class=\"docblock item-decl\"]' 'pub macro addr_of($place:expr) {'\n+// @has 'foo/macro.addr_of.html' '//*[@class=\"item-decl\"]' 'pub macro addr_of($place:expr) {'\n pub use reexports::addr_of;\n // @!has 'foo/macro.addr_of_crate.html'\n pub(crate) use reexports::addr_of_crate;\n@@ -13,7 +13,7 @@ pub(self) use reexports::addr_of_self;\n // @!has 'foo/macro.addr_of_local.html'\n use reexports::addr_of_local;\n \n-// @has 'foo/struct.Foo.html' '//*[@class=\"docblock item-decl\"]' 'pub struct Foo;'\n+// @has 'foo/struct.Foo.html' '//*[@class=\"item-decl\"]' 'pub struct Foo;'\n pub use reexports::Foo;\n // @!has 'foo/struct.FooCrate.html'\n pub(crate) use reexports::FooCrate;\n@@ -22,7 +22,7 @@ pub(self) use reexports::FooSelf;\n // @!has 'foo/struct.FooLocal.html'\n use reexports::FooLocal;\n \n-// @has 'foo/enum.Bar.html' '//*[@class=\"docblock item-decl\"]' 'pub enum Bar {'\n+// @has 'foo/enum.Bar.html' '//*[@class=\"item-decl\"]' 'pub enum Bar {'\n pub use reexports::Bar;\n // @!has 'foo/enum.BarCrate.html'\n pub(crate) use reexports::BarCrate;\n@@ -49,7 +49,7 @@ pub(self) use reexports::TypeSelf;\n // @!has 'foo/type.TypeLocal.html'\n use reexports::TypeLocal;\n \n-// @has 'foo/union.Union.html' '//*[@class=\"docblock item-decl\"]' 'pub union Union {'\n+// @has 'foo/union.Union.html' '//*[@class=\"item-decl\"]' 'pub union Union {'\n pub use reexports::Union;\n // @!has 'foo/union.UnionCrate.html'\n pub(crate) use reexports::UnionCrate;\n@@ -60,7 +60,7 @@ use reexports::UnionLocal;\n \n pub mod outer {\n     pub mod inner {\n-        // @has 'foo/outer/inner/macro.addr_of.html' '//*[@class=\"docblock item-decl\"]' 'pub macro addr_of($place:expr) {'\n+        // @has 'foo/outer/inner/macro.addr_of.html' '//*[@class=\"item-decl\"]' 'pub macro addr_of($place:expr) {'\n         pub use reexports::addr_of;\n         // @!has 'foo/outer/inner/macro.addr_of_crate.html'\n         pub(crate) use reexports::addr_of_crate;\n@@ -71,7 +71,7 @@ pub mod outer {\n         // @!has 'foo/outer/inner/macro.addr_of_local.html'\n         use reexports::addr_of_local;\n \n-        // @has 'foo/outer/inner/struct.Foo.html' '//*[@class=\"docblock item-decl\"]' 'pub struct Foo;'\n+        // @has 'foo/outer/inner/struct.Foo.html' '//*[@class=\"item-decl\"]' 'pub struct Foo;'\n         pub use reexports::Foo;\n         // @!has 'foo/outer/inner/struct.FooCrate.html'\n         pub(crate) use reexports::FooCrate;\n@@ -82,7 +82,7 @@ pub mod outer {\n         // @!has 'foo/outer/inner/struct.FooLocal.html'\n         use reexports::FooLocal;\n \n-        // @has 'foo/outer/inner/enum.Bar.html' '//*[@class=\"docblock item-decl\"]' 'pub enum Bar {'\n+        // @has 'foo/outer/inner/enum.Bar.html' '//*[@class=\"item-decl\"]' 'pub enum Bar {'\n         pub use reexports::Bar;\n         // @!has 'foo/outer/inner/enum.BarCrate.html'\n         pub(crate) use reexports::BarCrate;\n@@ -115,7 +115,7 @@ pub mod outer {\n         // @!has 'foo/outer/inner/type.TypeLocal.html'\n         use reexports::TypeLocal;\n \n-        // @has 'foo/outer/inner/union.Union.html' '//*[@class=\"docblock item-decl\"]' 'pub union Union {'\n+        // @has 'foo/outer/inner/union.Union.html' '//*[@class=\"item-decl\"]' 'pub union Union {'\n         pub use reexports::Union;\n         // @!has 'foo/outer/inner/union.UnionCrate.html'\n         pub(crate) use reexports::UnionCrate;"}, {"sha": "47a1d62f5a7a3fc5cb81b1d61e8a055262b112e7", "filename": "src/test/rustdoc/toggle-item-contents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Ftoggle-item-contents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Ftoggle-item-contents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ftoggle-item-contents.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -55,7 +55,7 @@ pub union Union {\n \n // @has 'toggle_item_contents/struct.PrivStruct.html'\n // @count - '//details[@class=\"rustdoc-toggle type-contents-toggle\"]' 0\n-// @has - '//div[@class=\"docblock item-decl\"]' '/* private fields */'\n+// @has - '//div[@class=\"item-decl\"]' '/* private fields */'\n pub struct PrivStruct {\n     a: usize,\n     b: usize,"}, {"sha": "791c099cc52336451cbfa9418c460ca82d3834cb", "filename": "src/test/rustdoc/trait_alias.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Ftrait_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Ftrait_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ftrait_alias.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -14,13 +14,13 @@ use std::fmt::Debug;\n // @has foo/index.html '//a[@class=\"traitalias\"]' 'Foo'\n \n // @has foo/traitalias.CopyAlias.html\n-// @has - '//section[@id=\"main-content\"]/div[@class=\"docblock item-decl\"]/pre' 'trait CopyAlias = Copy;'\n+// @has - '//section[@id=\"main-content\"]/div[@class=\"item-decl\"]/pre' 'trait CopyAlias = Copy;'\n pub trait CopyAlias = Copy;\n // @has foo/traitalias.Alias2.html\n-// @has - '//section[@id=\"main-content\"]/div[@class=\"docblock item-decl\"]/pre' 'trait Alias2 = Copy + Debug;'\n+// @has - '//section[@id=\"main-content\"]/div[@class=\"item-decl\"]/pre' 'trait Alias2 = Copy + Debug;'\n pub trait Alias2 = Copy + Debug;\n // @has foo/traitalias.Foo.html\n-// @has - '//section[@id=\"main-content\"]/div[@class=\"docblock item-decl\"]/pre' 'trait Foo<T> = Into<T> + Debug;'\n+// @has - '//section[@id=\"main-content\"]/div[@class=\"item-decl\"]/pre' 'trait Foo<T> = Into<T> + Debug;'\n pub trait Foo<T> = Into<T> + Debug;\n // @has foo/fn.bar.html '//a[@href=\"traitalias.Alias2.html\"]' 'Alias2'\n pub fn bar<T>() where T: Alias2 {}"}, {"sha": "6c1b5d31513526b21c8630f5c6b3e2c39d05864b", "filename": "src/test/rustdoc/where.SWhere_Simd_item-decl.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Fwhere.SWhere_Simd_item-decl.html", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Fwhere.SWhere_Simd_item-decl.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fwhere.SWhere_Simd_item-decl.html?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -1 +1 @@\n-<div class=\"docblock item-decl\"><pre class=\"rust struct\"><code>pub struct Simd&lt;T&gt;(_) <br /><span class=\"where\">where<br />&#160;&#160;&#160;&#160;T: <a class=\"trait\" href=\"trait.MyTrait.html\" title=\"trait foo::MyTrait\">MyTrait</a></span>;</code></pre></div>\n\\ No newline at end of file\n+<div class=\"item-decl\"><pre class=\"rust struct\"><code>pub struct Simd&lt;T&gt;(_)<br /><span class=\"where\">where<br />&#160;&#160;&#160;&#160;T: <a class=\"trait\" href=\"trait.MyTrait.html\" title=\"trait foo::MyTrait\">MyTrait</a></span>;</code></pre></div>\n\\ No newline at end of file"}, {"sha": "0fbdc0c9cd1e8a16435f3bdf88e2e51d02c1f294", "filename": "src/test/rustdoc/where.SWhere_TraitWhere_item-decl.html", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Fwhere.SWhere_TraitWhere_item-decl.html", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Fwhere.SWhere_TraitWhere_item-decl.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fwhere.SWhere_TraitWhere_item-decl.html?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -1,3 +1,3 @@\n-<div class=\"docblock item-decl\"><pre class=\"rust trait\"><code>pub trait TraitWhere {\n-    type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a>&lt;'a&gt;<br />&#160;&#160;&#160; <span class=\"where\">where<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Self: 'a</span>;\n+<div class=\"item-decl\"><pre class=\"rust trait\"><code>pub trait TraitWhere {\n+    type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a>&lt;'a&gt;<br />&#160;&#160;&#160;<span class=\"where\">where<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Self: 'a</span>;\n }</code></pre></div>\n\\ No newline at end of file"}, {"sha": "8818d74ddd087dda5ed6040bcb9c150a1a208d17", "filename": "src/test/rustdoc/where.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Fwhere.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Fwhere.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fwhere.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -20,13 +20,13 @@ impl<D> Delta<D> where D: MyTrait {\n pub struct Echo<E>(E);\n \n // @has 'foo/struct.Simd.html'\n-// @snapshot SWhere_Simd_item-decl - '//div[@class=\"docblock item-decl\"]'\n+// @snapshot SWhere_Simd_item-decl - '//div[@class=\"item-decl\"]'\n pub struct Simd<T>([T; 1])\n where\n     T: MyTrait;\n \n // @has 'foo/trait.TraitWhere.html'\n-// @snapshot SWhere_TraitWhere_item-decl - '//div[@class=\"docblock item-decl\"]'\n+// @snapshot SWhere_TraitWhere_item-decl - '//div[@class=\"item-decl\"]'\n pub trait TraitWhere {\n     type Item<'a> where Self: 'a;\n }"}, {"sha": "c74866f4a10b89afb03fa19838e394455d05f248", "filename": "src/test/rustdoc/whitespace-after-where-clause.enum.html", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.enum.html", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.enum.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.enum.html?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -1,4 +1,4 @@\n-<div class=\"docblock item-decl\"><pre class=\"rust enum\"><code>pub enum Cow&lt;'a, B:&#160;?<a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a> + 'a&gt; <span class=\"where fmt-newline\">where<br />&#160;&#160;&#160;&#160;B: <a class=\"trait\" href=\"trait.ToOwned.html\" title=\"trait foo::ToOwned\">ToOwned</a>&lt;dyn <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>&gt;,&#160;</span>{\n+<div class=\"item-decl\"><pre class=\"rust enum\"><code>pub enum Cow&lt;'a, B:&#160;?<a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a> + 'a&gt;<span class=\"where fmt-newline\">where<br />&#160;&#160;&#160;&#160;B: <a class=\"trait\" href=\"trait.ToOwned.html\" title=\"trait foo::ToOwned\">ToOwned</a>&lt;dyn <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>&gt;,</span>{\n     Borrowed(<a class=\"primitive\" href=\"{{channel}}/std/primitive.reference.html\">&amp;'a </a>B),\n     Whatever(<a class=\"primitive\" href=\"{{channel}}/std/primitive.u32.html\">u32</a>),\n-}</code></pre></div>\n+}</code></pre></div>\n\\ No newline at end of file"}, {"sha": "ac7d7759821107d0acaf605772640945441a58c3", "filename": "src/test/rustdoc/whitespace-after-where-clause.enum2.html", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.enum2.html", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.enum2.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.enum2.html?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -1,4 +1,4 @@\n-<div class=\"docblock item-decl\"><pre class=\"rust enum\"><code>pub enum Cow2&lt;'a, B:&#160;?<a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a> + <a class=\"trait\" href=\"trait.ToOwned.html\" title=\"trait foo::ToOwned\">ToOwned</a>&lt;dyn <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>&gt; + 'a&gt; {\n+<div class=\"item-decl\"><pre class=\"rust enum\"><code>pub enum Cow2&lt;'a, B:&#160;?<a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a> + <a class=\"trait\" href=\"trait.ToOwned.html\" title=\"trait foo::ToOwned\">ToOwned</a>&lt;dyn <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>&gt; + 'a&gt; {\n     Borrowed(<a class=\"primitive\" href=\"{{channel}}/std/primitive.reference.html\">&amp;'a </a>B),\n     Whatever(<a class=\"primitive\" href=\"{{channel}}/std/primitive.u32.html\">u32</a>),\n-}</code></pre></div>\n+}</code></pre></div>\n\\ No newline at end of file"}, {"sha": "4b740b970fc20a425028f175aab99d4b8f9cd578", "filename": "src/test/rustdoc/whitespace-after-where-clause.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -4,7 +4,7 @@\n #![crate_name = \"foo\"]\n \n // @has 'foo/trait.ToOwned.html'\n-// @snapshot trait - '//*[@class=\"docblock item-decl\"]'\n+// @snapshot trait - '//*[@class=\"item-decl\"]'\n pub trait ToOwned<T>\n where T: Clone\n {\n@@ -14,7 +14,7 @@ where T: Clone\n }\n \n // @has 'foo/trait.ToOwned2.html'\n-// @snapshot trait2 - '//*[@class=\"docblock item-decl\"]'\n+// @snapshot trait2 - '//*[@class=\"item-decl\"]'\n // There should be a whitespace before `{` in this case!\n pub trait ToOwned2<T: Clone> {\n     type Owned;\n@@ -23,7 +23,7 @@ pub trait ToOwned2<T: Clone> {\n }\n \n // @has 'foo/enum.Cow.html'\n-// @snapshot enum - '//*[@class=\"docblock item-decl\"]'\n+// @snapshot enum - '//*[@class=\"item-decl\"]'\n pub enum Cow<'a, B: ?Sized + 'a>\n where\n     B: ToOwned<Clone>,\n@@ -33,15 +33,15 @@ where\n }\n \n // @has 'foo/enum.Cow2.html'\n-// @snapshot enum2 - '//*[@class=\"docblock item-decl\"]'\n+// @snapshot enum2 - '//*[@class=\"item-decl\"]'\n // There should be a whitespace before `{` in this case!\n pub enum Cow2<'a, B: ?Sized + ToOwned<Clone> + 'a> {\n     Borrowed(&'a B),\n     Whatever(u32),\n }\n \n // @has 'foo/struct.Struct.html'\n-// @snapshot struct - '//*[@class=\"docblock item-decl\"]'\n+// @snapshot struct - '//*[@class=\"item-decl\"]'\n pub struct Struct<'a, B: ?Sized + 'a>\n where\n     B: ToOwned<Clone>,\n@@ -51,15 +51,15 @@ where\n }\n \n // @has 'foo/struct.Struct2.html'\n-// @snapshot struct2 - '//*[@class=\"docblock item-decl\"]'\n+// @snapshot struct2 - '//*[@class=\"item-decl\"]'\n // There should be a whitespace before `{` in this case!\n pub struct Struct2<'a, B: ?Sized + ToOwned<Clone> + 'a> {\n     pub a: &'a B,\n     pub b: u32,\n }\n \n // @has 'foo/union.Union.html'\n-// @snapshot union - '//*[@class=\"docblock item-decl\"]'\n+// @snapshot union - '//*[@class=\"item-decl\"]'\n pub union Union<'a, B: ?Sized + 'a>\n where\n     B: ToOwned<Clone>,\n@@ -69,7 +69,7 @@ where\n }\n \n // @has 'foo/union.Union2.html'\n-// @snapshot union2 - '//*[@class=\"docblock item-decl\"]'\n+// @snapshot union2 - '//*[@class=\"item-decl\"]'\n // There should be a whitespace before `{` in this case!\n pub union Union2<'a, B: ?Sized + ToOwned<Clone> + 'a> {\n     a: &'a B,"}, {"sha": "1ba1367d20f72f1f5341d01a9a284807aac50968", "filename": "src/test/rustdoc/whitespace-after-where-clause.struct.html", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.struct.html", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.struct.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.struct.html?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -1,4 +1,4 @@\n-<div class=\"docblock item-decl\"><pre class=\"rust struct\"><code>pub struct Struct&lt;'a, B:&#160;?<a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a> + 'a&gt; <span class=\"where fmt-newline\">where<br />&#160;&#160;&#160;&#160;B: <a class=\"trait\" href=\"trait.ToOwned.html\" title=\"trait foo::ToOwned\">ToOwned</a>&lt;dyn <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>&gt;,&#160;</span>{\n+<div class=\"item-decl\"><pre class=\"rust struct\"><code>pub struct Struct&lt;'a, B:&#160;?<a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a> + 'a&gt;<span class=\"where fmt-newline\">where<br />&#160;&#160;&#160;&#160;B: <a class=\"trait\" href=\"trait.ToOwned.html\" title=\"trait foo::ToOwned\">ToOwned</a>&lt;dyn <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>&gt;,</span>{\n     pub a: <a class=\"primitive\" href=\"{{channel}}/std/primitive.reference.html\">&amp;'a </a>B,\n     pub b: <a class=\"primitive\" href=\"{{channel}}/std/primitive.u32.html\">u32</a>,\n-}</code></pre></div>\n+}</code></pre></div>\n\\ No newline at end of file"}, {"sha": "fb06b0f77c5ce5f2c431f1a84bac8d4362965f52", "filename": "src/test/rustdoc/whitespace-after-where-clause.struct2.html", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.struct2.html", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.struct2.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.struct2.html?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -1,4 +1,4 @@\n-<div class=\"docblock item-decl\"><pre class=\"rust struct\"><code>pub struct Struct2&lt;'a, B:&#160;?<a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a> + <a class=\"trait\" href=\"trait.ToOwned.html\" title=\"trait foo::ToOwned\">ToOwned</a>&lt;dyn <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>&gt; + 'a&gt; {\n+<div class=\"item-decl\"><pre class=\"rust struct\"><code>pub struct Struct2&lt;'a, B:&#160;?<a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a> + <a class=\"trait\" href=\"trait.ToOwned.html\" title=\"trait foo::ToOwned\">ToOwned</a>&lt;dyn <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>&gt; + 'a&gt; {\n     pub a: <a class=\"primitive\" href=\"{{channel}}/std/primitive.reference.html\">&amp;'a </a>B,\n     pub b: <a class=\"primitive\" href=\"{{channel}}/std/primitive.u32.html\">u32</a>,\n-}</code></pre></div>\n+}</code></pre></div>\n\\ No newline at end of file"}, {"sha": "16b5582370353acec5e1988580e8c7fd3259b8a9", "filename": "src/test/rustdoc/whitespace-after-where-clause.trait.html", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.trait.html", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.trait.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.trait.html?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -1,6 +1,6 @@\n-<div class=\"docblock item-decl\"><pre class=\"rust trait\"><code>pub trait ToOwned&lt;T&gt; <span class=\"where fmt-newline\">where<br />&#160;&#160;&#160;&#160;T: <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>,&#160;</span>{\n+<div class=\"item-decl\"><pre class=\"rust trait\"><code>pub trait ToOwned&lt;T&gt;<span class=\"where fmt-newline\">where<br />&#160;&#160;&#160;&#160;T: <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>,</span>{\n     type <a href=\"#associatedtype.Owned\" class=\"associatedtype\">Owned</a>;\n \n     fn <a href=\"#tymethod.to_owned\" class=\"fnname\">to_owned</a>(&amp;self) -&gt; Self::<a class=\"associatedtype\" href=\"trait.ToOwned.html#associatedtype.Owned\" title=\"type foo::ToOwned::Owned\">Owned</a>;\n <span class=\"item-spacer\" />    fn <a href=\"#tymethod.whatever\" class=\"fnname\">whatever</a>(&amp;self) -&gt; T;\n-}</code></pre></div>\n+}</code></pre></div>\n\\ No newline at end of file"}, {"sha": "eeca6e1f5008161c9b9dfae288020d845c715ed3", "filename": "src/test/rustdoc/whitespace-after-where-clause.trait2.html", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.trait2.html", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.trait2.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.trait2.html?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -1,6 +1,6 @@\n-<div class=\"docblock item-decl\"><pre class=\"rust trait\"><code>pub trait ToOwned2&lt;T:&#160;<a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>&gt; {\n+<div class=\"item-decl\"><pre class=\"rust trait\"><code>pub trait ToOwned2&lt;T:&#160;<a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>&gt; {\n     type <a href=\"#associatedtype.Owned\" class=\"associatedtype\">Owned</a>;\n \n     fn <a href=\"#tymethod.to_owned\" class=\"fnname\">to_owned</a>(&amp;self) -&gt; Self::<a class=\"associatedtype\" href=\"trait.ToOwned2.html#associatedtype.Owned\" title=\"type foo::ToOwned2::Owned\">Owned</a>;\n <span class=\"item-spacer\" />    fn <a href=\"#tymethod.whatever\" class=\"fnname\">whatever</a>(&amp;self) -&gt; T;\n-}</code></pre></div>\n+}</code></pre></div>\n\\ No newline at end of file"}, {"sha": "0dfb6407d45f1f60ac0e7eb3593e2a2636f6dde2", "filename": "src/test/rustdoc/whitespace-after-where-clause.union.html", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.union.html", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.union.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.union.html?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -1,3 +1,3 @@\n-<div class=\"docblock item-decl\"><pre class=\"rust union\"><code>pub union Union&lt;'a, B:&#160;?<a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a> + 'a&gt; <span class=\"where fmt-newline\">where<br />&#160;&#160;&#160;&#160;B: <a class=\"trait\" href=\"trait.ToOwned.html\" title=\"trait foo::ToOwned\">ToOwned</a>&lt;dyn <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>&gt;,&#160;</span>{\n+<div class=\"item-decl\"><pre class=\"rust union\"><code>pub union Union&lt;'a, B:&#160;?<a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a> + 'a&gt;<span class=\"where fmt-newline\">where<br />&#160;&#160;&#160;&#160;B: <a class=\"trait\" href=\"trait.ToOwned.html\" title=\"trait foo::ToOwned\">ToOwned</a>&lt;dyn <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>&gt;,</span>{\n     /* private fields */\n-}</code></pre></div>\n+}</code></pre></div>\n\\ No newline at end of file"}, {"sha": "0d237df53c7f463605bce968c4d96a3d8c0d876b", "filename": "src/test/rustdoc/whitespace-after-where-clause.union2.html", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.union2.html", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.union2.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.union2.html?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -1,3 +1,3 @@\n-<div class=\"docblock item-decl\"><pre class=\"rust union\"><code>pub union Union2&lt;'a, B:&#160;?<a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a> + <a class=\"trait\" href=\"trait.ToOwned.html\" title=\"trait foo::ToOwned\">ToOwned</a>&lt;dyn <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>&gt; + 'a&gt; {\n+<div class=\"item-decl\"><pre class=\"rust union\"><code>pub union Union2&lt;'a, B:&#160;?<a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a> + <a class=\"trait\" href=\"trait.ToOwned.html\" title=\"trait foo::ToOwned\">ToOwned</a>&lt;dyn <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>&gt; + 'a&gt; {\n     /* private fields */\n-}</code></pre></div>\n+}</code></pre></div>\n\\ No newline at end of file"}, {"sha": "ae6de3c5046cde67c20f266a3fbfbf52acc1ff2c", "filename": "src/test/ui/macros/syntax-error-recovery.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Fui%2Fmacros%2Fsyntax-error-recovery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Fui%2Fmacros%2Fsyntax-error-recovery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fsyntax-error-recovery.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -0,0 +1,18 @@\n+macro_rules! values {\n+    ($($token:ident($value:literal) $(as $inner:ty)? => $attr:meta,)*) => {\n+        #[derive(Debug)]\n+        pub enum TokenKind {\n+            $(\n+                #[$attr]\n+                $token $($inner)? = $value,\n+            )*\n+        }\n+    };\n+}\n+//~^^^^^ ERROR expected one of `(`, `,`, `=`, `{`, or `}`, found `(String)`\n+//~| ERROR macro expansion ignores token `(String)` and any following\n+\n+values!(STRING(1) as (String) => cfg(test),);\n+//~^ ERROR expected one of `!` or `::`, found `<eof>`\n+\n+fn main() {}"}, {"sha": "c153b3b910bbe8dd932341003200db2ca141c731", "filename": "src/test/ui/macros/syntax-error-recovery.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Fui%2Fmacros%2Fsyntax-error-recovery.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftest%2Fui%2Fmacros%2Fsyntax-error-recovery.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fsyntax-error-recovery.stderr?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -0,0 +1,30 @@\n+error: expected one of `(`, `,`, `=`, `{`, or `}`, found `(String)`\n+  --> $DIR/syntax-error-recovery.rs:7:26\n+   |\n+LL |                 $token $($inner)? = $value,\n+   |                          ^^^^^^ expected one of `(`, `,`, `=`, `{`, or `}`\n+...\n+LL | values!(STRING(1) as (String) => cfg(test),);\n+   | -------------------------------------------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `values` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: macro expansion ignores token `(String)` and any following\n+  --> $DIR/syntax-error-recovery.rs:7:26\n+   |\n+LL |                 $token $($inner)? = $value,\n+   |                          ^^^^^^\n+...\n+LL | values!(STRING(1) as (String) => cfg(test),);\n+   | -------------------------------------------- caused by the macro expansion here\n+   |\n+   = note: the usage of `values!` is likely invalid in item context\n+\n+error: expected one of `!` or `::`, found `<eof>`\n+  --> $DIR/syntax-error-recovery.rs:15:9\n+   |\n+LL | values!(STRING(1) as (String) => cfg(test),);\n+   |         ^^^^^^ expected one of `!` or `::`\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "216cf51447fadd00bd93c30d4d0698a5ab818762", "filename": "src/tools/rust-analyzer/Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2FCargo.lock?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -394,6 +394,7 @@ dependencies = [\n  \"crossbeam-channel\",\n  \"jod-thread\",\n  \"paths\",\n+ \"rustc-hash\",\n  \"serde\",\n  \"serde_json\",\n  \"stdx\",\n@@ -660,6 +661,7 @@ dependencies = [\n  \"indexmap\",\n  \"itertools\",\n  \"limit\",\n+ \"memchr\",\n  \"once_cell\",\n  \"parser\",\n  \"profile\","}, {"sha": "688e790c5368cdbe67c15b21287681b9e2f5fa22", "filename": "src/tools/rust-analyzer/crates/flycheck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2FCargo.toml?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -13,6 +13,7 @@ doctest = false\n crossbeam-channel = \"0.5.5\"\n tracing = \"0.1.35\"\n cargo_metadata = \"0.15.0\"\n+rustc-hash = \"1.1.0\"\n serde = { version = \"1.0.137\", features = [\"derive\"] }\n serde_json = \"1.0.81\"\n jod-thread = \"0.1.2\""}, {"sha": "fdc03f4053a2714b18b0364b58127eb73d195ab9", "filename": "src/tools/rust-analyzer/crates/flycheck/src/lib.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -12,6 +12,7 @@ use std::{\n \n use crossbeam_channel::{never, select, unbounded, Receiver, Sender};\n use paths::AbsPathBuf;\n+use rustc_hash::FxHashMap;\n use serde::Deserialize;\n use stdx::{process::streaming_output, JodChild};\n \n@@ -30,18 +31,20 @@ pub enum FlycheckConfig {\n         all_features: bool,\n         features: Vec<String>,\n         extra_args: Vec<String>,\n+        extra_env: FxHashMap<String, String>,\n     },\n     CustomCommand {\n         command: String,\n         args: Vec<String>,\n+        extra_env: FxHashMap<String, String>,\n     },\n }\n \n impl fmt::Display for FlycheckConfig {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             FlycheckConfig::CargoCommand { command, .. } => write!(f, \"cargo {}\", command),\n-            FlycheckConfig::CustomCommand { command, args } => {\n+            FlycheckConfig::CustomCommand { command, args, .. } => {\n                 write!(f, \"{} {}\", command, args.join(\" \"))\n             }\n         }\n@@ -256,6 +259,7 @@ impl FlycheckActor {\n                 all_features,\n                 extra_args,\n                 features,\n+                extra_env,\n             } => {\n                 let mut cmd = Command::new(toolchain::cargo());\n                 cmd.arg(command);\n@@ -281,11 +285,13 @@ impl FlycheckActor {\n                     }\n                 }\n                 cmd.args(extra_args);\n+                cmd.envs(extra_env);\n                 cmd\n             }\n-            FlycheckConfig::CustomCommand { command, args } => {\n+            FlycheckConfig::CustomCommand { command, args, extra_env } => {\n                 let mut cmd = Command::new(command);\n                 cmd.args(args);\n+                cmd.envs(extra_env);\n                 cmd\n             }\n         };"}, {"sha": "b94b50004093ccdee496da7c23884e9a46428b5b", "filename": "src/tools/rust-analyzer/crates/hir-def/src/find_path.rs", "status": "modified", "additions": 231, "deletions": 131, "changes": 362, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ffind_path.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -1,6 +1,6 @@\n //! An algorithm to find a path to refer to a certain item.\n \n-use std::iter;\n+use std::{cmp::Ordering, iter};\n \n use hir_expand::name::{known, AsName, Name};\n use rustc_hash::FxHashSet;\n@@ -16,57 +16,29 @@ use crate::{\n \n /// Find a path that can be used to refer to a certain item. This can depend on\n /// *from where* you're referring to the item, hence the `from` parameter.\n-pub fn find_path(db: &dyn DefDatabase, item: ItemInNs, from: ModuleId) -> Option<ModPath> {\n+pub fn find_path(\n+    db: &dyn DefDatabase,\n+    item: ItemInNs,\n+    from: ModuleId,\n+    prefer_no_std: bool,\n+) -> Option<ModPath> {\n     let _p = profile::span(\"find_path\");\n-    find_path_inner(db, item, from, None)\n+    find_path_inner(db, item, from, None, prefer_no_std)\n }\n \n pub fn find_path_prefixed(\n     db: &dyn DefDatabase,\n     item: ItemInNs,\n     from: ModuleId,\n     prefix_kind: PrefixKind,\n+    prefer_no_std: bool,\n ) -> Option<ModPath> {\n     let _p = profile::span(\"find_path_prefixed\");\n-    find_path_inner(db, item, from, Some(prefix_kind))\n+    find_path_inner(db, item, from, Some(prefix_kind), prefer_no_std)\n }\n \n const MAX_PATH_LEN: usize = 15;\n \n-trait ModPathExt {\n-    fn starts_with_std(&self) -> bool;\n-    fn can_start_with_std(&self) -> bool;\n-}\n-\n-impl ModPathExt for ModPath {\n-    fn starts_with_std(&self) -> bool {\n-        self.segments().first() == Some(&known::std)\n-    }\n-\n-    // Can we replace the first segment with `std::` and still get a valid, identical path?\n-    fn can_start_with_std(&self) -> bool {\n-        let first_segment = self.segments().first();\n-        first_segment == Some(&known::alloc) || first_segment == Some(&known::core)\n-    }\n-}\n-\n-fn check_self_super(def_map: &DefMap, item: ItemInNs, from: ModuleId) -> Option<ModPath> {\n-    if item == ItemInNs::Types(from.into()) {\n-        // - if the item is the module we're in, use `self`\n-        Some(ModPath::from_segments(PathKind::Super(0), None))\n-    } else if let Some(parent_id) = def_map[from.local_id].parent {\n-        // - if the item is the parent module, use `super` (this is not used recursively, since `super::super` is ugly)\n-        let parent_id = def_map.module_id(parent_id);\n-        if item == ItemInNs::Types(ModuleDefId::ModuleId(parent_id)) {\n-            Some(ModPath::from_segments(PathKind::Super(1), None))\n-        } else {\n-            None\n-        }\n-    } else {\n-        None\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum PrefixKind {\n     /// Causes paths to always start with either `self`, `super`, `crate` or a crate-name.\n@@ -94,135 +66,247 @@ impl PrefixKind {\n         self == &PrefixKind::ByCrate\n     }\n }\n+\n /// Attempts to find a path to refer to the given `item` visible from the `from` ModuleId\n fn find_path_inner(\n     db: &dyn DefDatabase,\n     item: ItemInNs,\n     from: ModuleId,\n     prefixed: Option<PrefixKind>,\n+    prefer_no_std: bool,\n ) -> Option<ModPath> {\n-    // FIXME: Do fast path for std/core libs?\n+    // - if the item is a builtin, it's in scope\n+    if let ItemInNs::Types(ModuleDefId::BuiltinType(builtin)) = item {\n+        return Some(ModPath::from_segments(PathKind::Plain, Some(builtin.as_name())));\n+    }\n \n-    let mut visited_modules = FxHashSet::default();\n     let def_map = from.def_map(db);\n-    find_path_inner_(db, &def_map, from, item, MAX_PATH_LEN, prefixed, &mut visited_modules)\n+    let crate_root = def_map.crate_root(db);\n+    // - if the item is a module, jump straight to module search\n+    if let ItemInNs::Types(ModuleDefId::ModuleId(module_id)) = item {\n+        let mut visited_modules = FxHashSet::default();\n+        return find_path_for_module(\n+            db,\n+            &def_map,\n+            &mut visited_modules,\n+            crate_root,\n+            from,\n+            module_id,\n+            MAX_PATH_LEN,\n+            prefixed,\n+            prefer_no_std || db.crate_supports_no_std(crate_root.krate),\n+        );\n+    }\n+\n+    // - if the item is already in scope, return the name under which it is\n+    let scope_name = find_in_scope(db, &def_map, from, item);\n+    if prefixed.is_none() {\n+        if let Some(scope_name) = scope_name {\n+            return Some(ModPath::from_segments(PathKind::Plain, Some(scope_name)));\n+        }\n+    }\n+\n+    // - if the item is in the prelude, return the name from there\n+    if let Some(value) = find_in_prelude(db, &crate_root.def_map(db), item, from) {\n+        return value;\n+    }\n+\n+    if let Some(ModuleDefId::EnumVariantId(variant)) = item.as_module_def_id() {\n+        // - if the item is an enum variant, refer to it via the enum\n+        if let Some(mut path) = find_path_inner(\n+            db,\n+            ItemInNs::Types(variant.parent.into()),\n+            from,\n+            prefixed,\n+            prefer_no_std,\n+        ) {\n+            let data = db.enum_data(variant.parent);\n+            path.push_segment(data.variants[variant.local_id].name.clone());\n+            return Some(path);\n+        }\n+        // If this doesn't work, it seems we have no way of referring to the\n+        // enum; that's very weird, but there might still be a reexport of the\n+        // variant somewhere\n+    }\n+\n+    let mut visited_modules = FxHashSet::default();\n+\n+    calculate_best_path(\n+        db,\n+        &def_map,\n+        &mut visited_modules,\n+        crate_root,\n+        MAX_PATH_LEN,\n+        item,\n+        from,\n+        prefixed,\n+        prefer_no_std || db.crate_supports_no_std(crate_root.krate),\n+        scope_name,\n+    )\n }\n \n-fn find_path_inner_(\n+fn find_path_for_module(\n     db: &dyn DefDatabase,\n     def_map: &DefMap,\n+    visited_modules: &mut FxHashSet<ModuleId>,\n+    crate_root: ModuleId,\n     from: ModuleId,\n-    item: ItemInNs,\n+    module_id: ModuleId,\n     max_len: usize,\n-    mut prefixed: Option<PrefixKind>,\n-    visited_modules: &mut FxHashSet<ModuleId>,\n+    prefixed: Option<PrefixKind>,\n+    prefer_no_std: bool,\n ) -> Option<ModPath> {\n     if max_len == 0 {\n         return None;\n     }\n \n     // Base cases:\n-\n     // - if the item is already in scope, return the name under which it is\n-    let scope_name = def_map.with_ancestor_maps(db, from.local_id, &mut |def_map, local_id| {\n-        def_map[local_id].scope.name_of(item).map(|(name, _)| name.clone())\n-    });\n+    let scope_name = find_in_scope(db, def_map, from, ItemInNs::Types(module_id.into()));\n     if prefixed.is_none() {\n         if let Some(scope_name) = scope_name {\n             return Some(ModPath::from_segments(PathKind::Plain, Some(scope_name)));\n         }\n     }\n \n-    // - if the item is a builtin, it's in scope\n-    if let ItemInNs::Types(ModuleDefId::BuiltinType(builtin)) = item {\n-        return Some(ModPath::from_segments(PathKind::Plain, Some(builtin.as_name())));\n-    }\n-\n     // - if the item is the crate root, return `crate`\n-    let crate_root = def_map.crate_root(db);\n-    if item == ItemInNs::Types(ModuleDefId::ModuleId(crate_root)) {\n+    if module_id == crate_root {\n         return Some(ModPath::from_segments(PathKind::Crate, None));\n     }\n \n+    // - if relative paths are fine, check if we are searching for a parent\n     if prefixed.filter(PrefixKind::is_absolute).is_none() {\n-        if let modpath @ Some(_) = check_self_super(&def_map, item, from) {\n+        if let modpath @ Some(_) = find_self_super(&def_map, module_id, from) {\n             return modpath;\n         }\n     }\n \n     // - if the item is the crate root of a dependency crate, return the name from the extern prelude\n     let root_def_map = crate_root.def_map(db);\n-    if let ItemInNs::Types(ModuleDefId::ModuleId(item)) = item {\n-        for (name, &def_id) in root_def_map.extern_prelude() {\n-            if item == def_id {\n-                let name = scope_name.unwrap_or_else(|| name.clone());\n-\n-                let name_already_occupied_in_type_ns = def_map\n-                    .with_ancestor_maps(db, from.local_id, &mut |def_map, local_id| {\n-                        def_map[local_id]\n-                            .scope\n-                            .type_(&name)\n-                            .filter(|&(id, _)| id != ModuleDefId::ModuleId(def_id))\n-                    })\n-                    .is_some();\n-                let kind = if name_already_occupied_in_type_ns {\n-                    cov_mark::hit!(ambiguous_crate_start);\n-                    PathKind::Abs\n-                } else {\n-                    PathKind::Plain\n-                };\n-                return Some(ModPath::from_segments(kind, Some(name)));\n-            }\n+    for (name, &def_id) in root_def_map.extern_prelude() {\n+        if module_id == def_id {\n+            let name = scope_name.unwrap_or_else(|| name.clone());\n+\n+            let name_already_occupied_in_type_ns = def_map\n+                .with_ancestor_maps(db, from.local_id, &mut |def_map, local_id| {\n+                    def_map[local_id]\n+                        .scope\n+                        .type_(&name)\n+                        .filter(|&(id, _)| id != ModuleDefId::ModuleId(def_id))\n+                })\n+                .is_some();\n+            let kind = if name_already_occupied_in_type_ns {\n+                cov_mark::hit!(ambiguous_crate_start);\n+                PathKind::Abs\n+            } else {\n+                PathKind::Plain\n+            };\n+            return Some(ModPath::from_segments(kind, Some(name)));\n         }\n     }\n \n-    // - if the item is in the prelude, return the name from there\n+    if let Some(value) = find_in_prelude(db, &root_def_map, ItemInNs::Types(module_id.into()), from)\n+    {\n+        return value;\n+    }\n+    calculate_best_path(\n+        db,\n+        def_map,\n+        visited_modules,\n+        crate_root,\n+        max_len,\n+        ItemInNs::Types(module_id.into()),\n+        from,\n+        prefixed,\n+        prefer_no_std,\n+        scope_name,\n+    )\n+}\n+\n+fn find_in_scope(\n+    db: &dyn DefDatabase,\n+    def_map: &DefMap,\n+    from: ModuleId,\n+    item: ItemInNs,\n+) -> Option<Name> {\n+    def_map.with_ancestor_maps(db, from.local_id, &mut |def_map, local_id| {\n+        def_map[local_id].scope.name_of(item).map(|(name, _)| name.clone())\n+    })\n+}\n+\n+fn find_in_prelude(\n+    db: &dyn DefDatabase,\n+    root_def_map: &DefMap,\n+    item: ItemInNs,\n+    from: ModuleId,\n+) -> Option<Option<ModPath>> {\n     if let Some(prelude_module) = root_def_map.prelude() {\n         // Preludes in block DefMaps are ignored, only the crate DefMap is searched\n         let prelude_def_map = prelude_module.def_map(db);\n         let prelude_scope = &prelude_def_map[prelude_module.local_id].scope;\n         if let Some((name, vis)) = prelude_scope.name_of(item) {\n             if vis.is_visible_from(db, from) {\n-                return Some(ModPath::from_segments(PathKind::Plain, Some(name.clone())));\n+                return Some(Some(ModPath::from_segments(PathKind::Plain, Some(name.clone()))));\n             }\n         }\n     }\n+    None\n+}\n \n-    // Recursive case:\n-    // - if the item is an enum variant, refer to it via the enum\n-    if let Some(ModuleDefId::EnumVariantId(variant)) = item.as_module_def_id() {\n-        if let Some(mut path) = find_path(db, ItemInNs::Types(variant.parent.into()), from) {\n-            let data = db.enum_data(variant.parent);\n-            path.push_segment(data.variants[variant.local_id].name.clone());\n-            return Some(path);\n+fn find_self_super(def_map: &DefMap, item: ModuleId, from: ModuleId) -> Option<ModPath> {\n+    if item == from {\n+        // - if the item is the module we're in, use `self`\n+        Some(ModPath::from_segments(PathKind::Super(0), None))\n+    } else if let Some(parent_id) = def_map[from.local_id].parent {\n+        // - if the item is the parent module, use `super` (this is not used recursively, since `super::super` is ugly)\n+        let parent_id = def_map.module_id(parent_id);\n+        if item == parent_id {\n+            Some(ModPath::from_segments(PathKind::Super(1), None))\n+        } else {\n+            None\n         }\n-        // If this doesn't work, it seems we have no way of referring to the\n-        // enum; that's very weird, but there might still be a reexport of the\n-        // variant somewhere\n+    } else {\n+        None\n     }\n+}\n \n-    // - otherwise, look for modules containing (reexporting) it and import it from one of those\n-    let prefer_no_std = db.crate_supports_no_std(crate_root.krate);\n+fn calculate_best_path(\n+    db: &dyn DefDatabase,\n+    def_map: &DefMap,\n+    visited_modules: &mut FxHashSet<ModuleId>,\n+    crate_root: ModuleId,\n+    max_len: usize,\n+    item: ItemInNs,\n+    from: ModuleId,\n+    mut prefixed: Option<PrefixKind>,\n+    prefer_no_std: bool,\n+    scope_name: Option<Name>,\n+) -> Option<ModPath> {\n+    if max_len <= 1 {\n+        return None;\n+    }\n     let mut best_path = None;\n-    let mut best_path_len = max_len;\n-\n+    // Recursive case:\n+    // - otherwise, look for modules containing (reexporting) it and import it from one of those\n     if item.krate(db) == Some(from.krate) {\n+        let mut best_path_len = max_len;\n         // Item was defined in the same crate that wants to import it. It cannot be found in any\n         // dependency in this case.\n-        // FIXME: this should have a fast path that doesn't look through the prelude again?\n         for (module_id, name) in find_local_import_locations(db, item, from) {\n             if !visited_modules.insert(module_id) {\n                 cov_mark::hit!(recursive_imports);\n                 continue;\n             }\n-            if let Some(mut path) = find_path_inner_(\n+            if let Some(mut path) = find_path_for_module(\n                 db,\n                 def_map,\n+                visited_modules,\n+                crate_root,\n                 from,\n-                ItemInNs::Types(ModuleDefId::ModuleId(module_id)),\n+                module_id,\n                 best_path_len - 1,\n                 prefixed,\n-                visited_modules,\n+                prefer_no_std,\n             ) {\n                 path.push_segment(name);\n \n@@ -245,14 +329,16 @@ fn find_path_inner_(\n             import_map.import_info_for(item).and_then(|info| {\n                 // Determine best path for containing module and append last segment from `info`.\n                 // FIXME: we should guide this to look up the path locally, or from the same crate again?\n-                let mut path = find_path_inner_(\n+                let mut path = find_path_for_module(\n                     db,\n                     def_map,\n+                    visited_modules,\n                     from,\n-                    ItemInNs::Types(ModuleDefId::ModuleId(info.container)),\n-                    best_path_len - 1,\n+                    crate_root,\n+                    info.container,\n+                    max_len - 1,\n                     prefixed,\n-                    visited_modules,\n+                    prefer_no_std,\n                 )?;\n                 cov_mark::hit!(partially_imported);\n                 path.push_segment(info.path.segments.last()?.clone());\n@@ -268,16 +354,12 @@ fn find_path_inner_(\n             best_path = Some(new_path);\n         }\n     }\n-\n-    // If the item is declared inside a block expression, don't use a prefix, as we don't handle\n-    // that correctly (FIXME).\n-    if let Some(item_module) = item.as_module_def_id().and_then(|did| did.module(db)) {\n-        if item_module.def_map(db).block_id().is_some() && prefixed.is_some() {\n+    if let Some(module) = item.module(db) {\n+        if module.def_map(db).block_id().is_some() && prefixed.is_some() {\n             cov_mark::hit!(prefixed_in_block_expression);\n             prefixed = Some(PrefixKind::Plain);\n         }\n     }\n-\n     match prefixed.map(PrefixKind::prefix) {\n         Some(prefix) => best_path.or_else(|| {\n             scope_name.map(|scope_name| ModPath::from_segments(prefix, Some(scope_name)))\n@@ -287,29 +369,48 @@ fn find_path_inner_(\n }\n \n fn select_best_path(old_path: ModPath, new_path: ModPath, prefer_no_std: bool) -> ModPath {\n-    if old_path.starts_with_std() && new_path.can_start_with_std() {\n-        if prefer_no_std {\n-            cov_mark::hit!(prefer_no_std_paths);\n-            new_path\n-        } else {\n-            cov_mark::hit!(prefer_std_paths);\n-            old_path\n+    const STD_CRATES: [Name; 3] = [known::std, known::core, known::alloc];\n+    match (old_path.segments().first(), new_path.segments().first()) {\n+        (Some(old), Some(new)) if STD_CRATES.contains(old) && STD_CRATES.contains(new) => {\n+            let rank = match prefer_no_std {\n+                false => |name: &Name| match name {\n+                    name if name == &known::core => 0,\n+                    name if name == &known::alloc => 0,\n+                    name if name == &known::std => 1,\n+                    _ => unreachable!(),\n+                },\n+                true => |name: &Name| match name {\n+                    name if name == &known::core => 2,\n+                    name if name == &known::alloc => 1,\n+                    name if name == &known::std => 0,\n+                    _ => unreachable!(),\n+                },\n+            };\n+            let nrank = rank(new);\n+            let orank = rank(old);\n+            match nrank.cmp(&orank) {\n+                Ordering::Less => old_path,\n+                Ordering::Equal => {\n+                    if new_path.len() < old_path.len() {\n+                        new_path\n+                    } else {\n+                        old_path\n+                    }\n+                }\n+                Ordering::Greater => new_path,\n+            }\n         }\n-    } else if new_path.starts_with_std() && old_path.can_start_with_std() {\n-        if prefer_no_std {\n-            cov_mark::hit!(prefer_no_std_paths);\n-            old_path\n-        } else {\n-            cov_mark::hit!(prefer_std_paths);\n-            new_path\n+        _ => {\n+            if new_path.len() < old_path.len() {\n+                new_path\n+            } else {\n+                old_path\n+            }\n         }\n-    } else if new_path.len() < old_path.len() {\n-        new_path\n-    } else {\n-        old_path\n     }\n }\n \n+// FIXME: Remove allocations\n /// Finds locations in `from.krate` from which `item` can be imported by `from`.\n fn find_local_import_locations(\n     db: &dyn DefDatabase,\n@@ -428,7 +529,8 @@ mod tests {\n             .take_types()\n             .unwrap();\n \n-        let found_path = find_path_inner(&db, ItemInNs::Types(resolved), module, prefix_kind);\n+        let found_path =\n+            find_path_inner(&db, ItemInNs::Types(resolved), module, prefix_kind, false);\n         assert_eq!(found_path, Some(mod_path), \"{:?}\", prefix_kind);\n     }\n \n@@ -468,8 +570,8 @@ $0\n         \"#,\n             \"E::A\",\n             \"E::A\",\n-            \"E::A\",\n-            \"E::A\",\n+            \"crate::E::A\",\n+            \"self::E::A\",\n         );\n     }\n \n@@ -788,7 +890,6 @@ pub use super::foo;\n \n     #[test]\n     fn prefer_std_paths_over_alloc() {\n-        cov_mark::check!(prefer_std_paths);\n         check_found_path(\n             r#\"\n //- /main.rs crate:main deps:alloc,std\n@@ -813,7 +914,6 @@ pub mod sync {\n \n     #[test]\n     fn prefer_core_paths_over_std() {\n-        cov_mark::check!(prefer_no_std_paths);\n         check_found_path(\n             r#\"\n //- /main.rs crate:main deps:core,std"}, {"sha": "7721221c444758a23d2d4d45c06d692657fbe6fb", "filename": "src/tools/rust-analyzer/crates/hir-def/src/item_scope.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_scope.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -18,7 +18,7 @@ use crate::{\n     ConstId, HasModule, ImplId, LocalModuleId, MacroId, ModuleDefId, ModuleId, TraitId,\n };\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n pub(crate) enum ImportType {\n     Glob,\n     Named,\n@@ -302,13 +302,13 @@ impl ItemScope {\n                             $changed = true;\n                         }\n                         Entry::Occupied(mut entry)\n-                            if $glob_imports.$field.contains(&$lookup)\n-                                && matches!($def_import_type, ImportType::Named) =>\n+                            if matches!($def_import_type, ImportType::Named) =>\n                         {\n-                            cov_mark::hit!(import_shadowed);\n-                            $glob_imports.$field.remove(&$lookup);\n-                            entry.insert(fld);\n-                            $changed = true;\n+                            if $glob_imports.$field.remove(&$lookup) {\n+                                cov_mark::hit!(import_shadowed);\n+                                entry.insert(fld);\n+                                $changed = true;\n+                            }\n                         }\n                         _ => {}\n                     }\n@@ -457,8 +457,15 @@ impl ItemInNs {\n     /// Returns the crate defining this item (or `None` if `self` is built-in).\n     pub fn krate(&self, db: &dyn DefDatabase) -> Option<CrateId> {\n         match self {\n-            ItemInNs::Types(did) | ItemInNs::Values(did) => did.module(db).map(|m| m.krate),\n+            ItemInNs::Types(id) | ItemInNs::Values(id) => id.module(db).map(|m| m.krate),\n             ItemInNs::Macros(id) => Some(id.module(db).krate),\n         }\n     }\n+\n+    pub fn module(&self, db: &dyn DefDatabase) -> Option<ModuleId> {\n+        match self {\n+            ItemInNs::Types(id) | ItemInNs::Values(id) => id.module(db),\n+            ItemInNs::Macros(id) => Some(id.module(db)),\n+        }\n+    }\n }"}, {"sha": "9242b48c59319a89cad17f21d4b431eccf52fa4d", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -534,6 +534,7 @@ impl DefCollector<'_> {\n             match per_ns.types {\n                 Some((ModuleDefId::ModuleId(m), _)) => {\n                     self.def_map.prelude = Some(m);\n+                    break;\n                 }\n                 types => {\n                     tracing::debug!("}, {"sha": "69283e55a4c2cb0e6acce24fe7f2ac73c11d2410", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/db.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdb.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -150,6 +150,14 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n         id: chalk_db::AssociatedTyValueId,\n     ) -> Arc<chalk_db::AssociatedTyValue>;\n \n+    #[salsa::invoke(crate::traits::normalize_projection_query)]\n+    #[salsa::transparent]\n+    fn normalize_projection(\n+        &self,\n+        projection: crate::ProjectionTy,\n+        env: Arc<crate::TraitEnvironment>,\n+    ) -> Ty;\n+\n     #[salsa::invoke(trait_solve_wait)]\n     #[salsa::transparent]\n     fn trait_solve("}, {"sha": "874abdaea8370f4ef2a8e3bc1c28abab3d5c6dcc", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/display.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -533,6 +533,7 @@ impl HirDisplay for Ty {\n                             f.db.upcast(),\n                             ItemInNs::Types((*def_id).into()),\n                             module_id,\n+                            false,\n                         ) {\n                             write!(f, \"{}\", path)?;\n                         } else {"}, {"sha": "e37763e8ea7f03075b5c19349d4c7d5ff1baf69d", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -673,10 +673,6 @@ impl<'a> InferenceContext<'a> {\n         )\n     }\n \n-    fn resolve_obligations_as_possible(&mut self) {\n-        self.table.resolve_obligations_as_possible();\n-    }\n-\n     fn push_obligation(&mut self, o: DomainGoal) {\n         self.table.register_obligation(o.cast(Interner));\n     }\n@@ -696,7 +692,6 @@ impl<'a> InferenceContext<'a> {\n     }\n \n     fn resolve_ty_shallow(&mut self, ty: &Ty) -> Ty {\n-        self.resolve_obligations_as_possible();\n         self.table.resolve_ty_shallow(ty)\n     }\n "}, {"sha": "de4a5446e57f00e948bee718ae6013dcddbb99b7", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/lib.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flib.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -196,20 +196,6 @@ pub(crate) fn make_binders<T: HasInterner<Interner = Interner>>(\n     make_binders_with_count(db, usize::MAX, generics, value)\n }\n \n-// FIXME: get rid of this\n-pub fn make_canonical<T: HasInterner<Interner = Interner>>(\n-    value: T,\n-    kinds: impl IntoIterator<Item = TyVariableKind>,\n-) -> Canonical<T> {\n-    let kinds = kinds.into_iter().map(|tk| {\n-        chalk_ir::CanonicalVarKind::new(\n-            chalk_ir::VariableKind::Ty(tk),\n-            chalk_ir::UniverseIndex::ROOT,\n-        )\n-    });\n-    Canonical { value, binders: chalk_ir::CanonicalVarKinds::from_iter(Interner, kinds) }\n-}\n-\n // FIXME: get rid of this, just replace it by FnPointer\n /// A function signature as seen by type inference: Several parameter types and\n /// one return type."}, {"sha": "41fcef73d9be40827aa671979c8da0f0931560c6", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 61, "deletions": 13, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -914,22 +914,10 @@ fn iterate_trait_method_candidates(\n     let db = table.db;\n     let env = table.trait_env.clone();\n     let self_is_array = matches!(self_ty.kind(Interner), chalk_ir::TyKind::Array(..));\n-    // if ty is `dyn Trait`, the trait doesn't need to be in scope\n-    let inherent_trait =\n-        self_ty.dyn_trait().into_iter().flat_map(|t| all_super_traits(db.upcast(), t));\n-    let env_traits = matches!(self_ty.kind(Interner), TyKind::Placeholder(_))\n-        // if we have `T: Trait` in the param env, the trait doesn't need to be in scope\n-        .then(|| {\n-            env.traits_in_scope_from_clauses(self_ty.clone())\n-                .flat_map(|t| all_super_traits(db.upcast(), t))\n-        })\n-        .into_iter()\n-        .flatten();\n-    let traits = inherent_trait.chain(env_traits).chain(traits_in_scope.iter().copied());\n \n     let canonical_self_ty = table.canonicalize(self_ty.clone()).value;\n \n-    'traits: for t in traits {\n+    'traits: for &t in traits_in_scope {\n         let data = db.trait_data(t);\n \n         // Traits annotated with `#[rustc_skip_array_during_method_dispatch]` are skipped during\n@@ -979,6 +967,44 @@ fn iterate_inherent_methods(\n ) -> ControlFlow<()> {\n     let db = table.db;\n     let env = table.trait_env.clone();\n+\n+    // For trait object types and placeholder types with trait bounds, the methods of the trait and\n+    // its super traits are considered inherent methods. This matters because these methods have\n+    // higher priority than the other traits' methods, which would be considered in\n+    // `iterate_trait_method_candidates()` only after this function.\n+    match self_ty.kind(Interner) {\n+        TyKind::Placeholder(_) => {\n+            let env = table.trait_env.clone();\n+            let traits = env\n+                .traits_in_scope_from_clauses(self_ty.clone())\n+                .flat_map(|t| all_super_traits(db.upcast(), t));\n+            iterate_inherent_trait_methods(\n+                self_ty,\n+                table,\n+                name,\n+                receiver_ty,\n+                receiver_adjustments.clone(),\n+                callback,\n+                traits,\n+            )?;\n+        }\n+        TyKind::Dyn(_) => {\n+            if let Some(principal_trait) = self_ty.dyn_trait() {\n+                let traits = all_super_traits(db.upcast(), principal_trait);\n+                iterate_inherent_trait_methods(\n+                    self_ty,\n+                    table,\n+                    name,\n+                    receiver_ty,\n+                    receiver_adjustments.clone(),\n+                    callback,\n+                    traits.into_iter(),\n+                )?;\n+            }\n+        }\n+        _ => {}\n+    }\n+\n     let def_crates = match def_crates(db, self_ty, env.krate) {\n         Some(k) => k,\n         None => return ControlFlow::Continue(()),\n@@ -1020,6 +1046,28 @@ fn iterate_inherent_methods(\n     }\n     return ControlFlow::Continue(());\n \n+    fn iterate_inherent_trait_methods(\n+        self_ty: &Ty,\n+        table: &mut InferenceTable<'_>,\n+        name: Option<&Name>,\n+        receiver_ty: Option<&Ty>,\n+        receiver_adjustments: Option<ReceiverAdjustments>,\n+        callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n+        traits: impl Iterator<Item = TraitId>,\n+    ) -> ControlFlow<()> {\n+        let db = table.db;\n+        for t in traits {\n+            let data = db.trait_data(t);\n+            for &(_, item) in data.items.iter() {\n+                // We don't pass `visible_from_module` as all trait items should be visible.\n+                if is_valid_candidate(table, name, receiver_ty, item, self_ty, None) {\n+                    callback(receiver_adjustments.clone().unwrap_or_default(), item)?;\n+                }\n+            }\n+        }\n+        ControlFlow::Continue(())\n+    }\n+\n     fn impls_for_self_ty(\n         impls: &InherentImpls,\n         self_ty: &Ty,"}, {"sha": "ac8edb841a580322b18b5a47b9eb39ae174b3a49", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/method_resolution.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -1218,6 +1218,40 @@ fn main() {\n     );\n }\n \n+#[test]\n+fn dyn_trait_method_priority() {\n+    check_types(\n+        r#\"\n+//- minicore: from\n+trait Trait {\n+    fn into(&self) -> usize { 0 }\n+}\n+\n+fn foo(a: &dyn Trait) {\n+    let _ = a.into();\n+      //^usize\n+}\n+        \"#,\n+    );\n+}\n+\n+#[test]\n+fn trait_method_priority_for_placeholder_type() {\n+    check_types(\n+        r#\"\n+//- minicore: from\n+trait Trait {\n+    fn into(&self) -> usize { 0 }\n+}\n+\n+fn foo<T: Trait>(a: &T) {\n+    let _ = a.into();\n+      //^usize\n+}\n+        \"#,\n+    );\n+}\n+\n #[test]\n fn autoderef_visibility_field() {\n     check("}, {"sha": "372c3a3cca644fd0966c88bc992c5c06087ffb03", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/traits.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftraits.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -1,6 +1,6 @@\n //! Trait solving using Chalk.\n \n-use std::env::var;\n+use std::{env::var, sync::Arc};\n \n use chalk_ir::GoalData;\n use chalk_recursive::Cache;\n@@ -12,8 +12,9 @@ use stdx::panic_context;\n use syntax::SmolStr;\n \n use crate::{\n-    db::HirDatabase, AliasEq, AliasTy, Canonical, DomainGoal, Goal, Guidance, InEnvironment,\n-    Interner, Solution, TraitRefExt, Ty, TyKind, WhereClause,\n+    db::HirDatabase, infer::unify::InferenceTable, AliasEq, AliasTy, Canonical, DomainGoal, Goal,\n+    Guidance, InEnvironment, Interner, ProjectionTy, Solution, TraitRefExt, Ty, TyKind,\n+    WhereClause,\n };\n \n /// This controls how much 'time' we give the Chalk solver before giving up.\n@@ -64,6 +65,16 @@ impl TraitEnvironment {\n     }\n }\n \n+pub(crate) fn normalize_projection_query(\n+    db: &dyn HirDatabase,\n+    projection: ProjectionTy,\n+    env: Arc<TraitEnvironment>,\n+) -> Ty {\n+    let mut table = InferenceTable::new(db, env);\n+    let ty = table.normalize_projection_ty(projection);\n+    table.resolve_completely(ty)\n+}\n+\n /// Solve a trait goal using Chalk.\n pub(crate) fn trait_solve_query(\n     db: &dyn HirDatabase,"}, {"sha": "d2717c5665471e70f7b1bbe7e0f9a01d2d193295", "filename": "src/tools/rust-analyzer/crates/hir/src/lib.rs", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -63,10 +63,9 @@ use hir_ty::{\n     primitive::UintTy,\n     subst_prefix,\n     traits::FnTrait,\n-    AliasEq, AliasTy, BoundVar, CallableDefId, CallableSig, Canonical, CanonicalVarKinds, Cast,\n-    ClosureId, DebruijnIndex, GenericArgData, InEnvironment, Interner, ParamKind,\n-    QuantifiedWhereClause, Scalar, Solution, Substitution, TraitEnvironment, TraitRefExt, Ty,\n-    TyBuilder, TyDefId, TyExt, TyKind, TyVariableKind, WhereClause,\n+    AliasTy, CallableDefId, CallableSig, Canonical, CanonicalVarKinds, Cast, ClosureId,\n+    GenericArgData, Interner, ParamKind, QuantifiedWhereClause, Scalar, Substitution,\n+    TraitEnvironment, TraitRefExt, Ty, TyBuilder, TyDefId, TyExt, TyKind, WhereClause,\n };\n use itertools::Itertools;\n use nameres::diagnostics::DefDiagnosticKind;\n@@ -582,8 +581,13 @@ impl Module {\n \n     /// Finds a path that can be used to refer to the given item from within\n     /// this module, if possible.\n-    pub fn find_use_path(self, db: &dyn DefDatabase, item: impl Into<ItemInNs>) -> Option<ModPath> {\n-        hir_def::find_path::find_path(db, item.into().into(), self.into())\n+    pub fn find_use_path(\n+        self,\n+        db: &dyn DefDatabase,\n+        item: impl Into<ItemInNs>,\n+        prefer_no_std: bool,\n+    ) -> Option<ModPath> {\n+        hir_def::find_path::find_path(db, item.into().into(), self.into(), prefer_no_std)\n     }\n \n     /// Finds a path that can be used to refer to the given item from within\n@@ -593,8 +597,15 @@ impl Module {\n         db: &dyn DefDatabase,\n         item: impl Into<ItemInNs>,\n         prefix_kind: PrefixKind,\n+        prefer_no_std: bool,\n     ) -> Option<ModPath> {\n-        hir_def::find_path::find_path_prefixed(db, item.into().into(), self.into(), prefix_kind)\n+        hir_def::find_path::find_path_prefixed(\n+            db,\n+            item.into().into(),\n+            self.into(),\n+            prefix_kind,\n+            prefer_no_std,\n+        )\n     }\n }\n \n@@ -2880,27 +2891,12 @@ impl Type {\n                 }\n             })\n             .build();\n-        let goal = hir_ty::make_canonical(\n-            InEnvironment::new(\n-                &self.env.env,\n-                AliasEq {\n-                    alias: AliasTy::Projection(projection),\n-                    ty: TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0))\n-                        .intern(Interner),\n-                }\n-                .cast(Interner),\n-            ),\n-            [TyVariableKind::General].into_iter(),\n-        );\n \n-        match db.trait_solve(self.env.krate, goal)? {\n-            Solution::Unique(s) => s\n-                .value\n-                .subst\n-                .as_slice(Interner)\n-                .first()\n-                .map(|ty| self.derived(ty.assert_ty_ref(Interner).clone())),\n-            Solution::Ambig(_) => None,\n+        let ty = db.normalize_projection(projection, self.env.clone());\n+        if ty.is_unknown() {\n+            None\n+        } else {\n+            Some(self.derived(ty))\n         }\n     }\n "}, {"sha": "60d1588a44e54dba41e753f2511ffd879ac64f73", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/assist_config.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fassist_config.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fassist_config.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fassist_config.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -13,4 +13,5 @@ pub struct AssistConfig {\n     pub snippet_cap: Option<SnippetCap>,\n     pub allowed: Option<Vec<AssistKind>>,\n     pub insert_use: InsertUseConfig,\n+    pub prefer_no_std: bool,\n }"}, {"sha": "73f4db4e5ff2ba065a20ee39c7aa368ff91f754e", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/add_missing_match_arms.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -87,7 +87,7 @@ pub(crate) fn add_missing_match_arms(acc: &mut Assists, ctx: &AssistContext<'_>)\n             .into_iter()\n             .filter_map(|variant| {\n                 Some((\n-                    build_pat(ctx.db(), module, variant)?,\n+                    build_pat(ctx.db(), module, variant, ctx.config.prefer_no_std)?,\n                     variant.should_be_hidden(ctx.db(), module.krate()),\n                 ))\n             })\n@@ -132,8 +132,9 @@ pub(crate) fn add_missing_match_arms(acc: &mut Assists, ctx: &AssistContext<'_>)\n                 let is_hidden = variants\n                     .iter()\n                     .any(|variant| variant.should_be_hidden(ctx.db(), module.krate()));\n-                let patterns =\n-                    variants.into_iter().filter_map(|variant| build_pat(ctx.db(), module, variant));\n+                let patterns = variants.into_iter().filter_map(|variant| {\n+                    build_pat(ctx.db(), module, variant, ctx.config.prefer_no_std)\n+                });\n \n                 (ast::Pat::from(make::tuple_pat(patterns)), is_hidden)\n             })\n@@ -349,10 +350,16 @@ fn resolve_tuple_of_enum_def(\n         .collect()\n }\n \n-fn build_pat(db: &RootDatabase, module: hir::Module, var: ExtendedVariant) -> Option<ast::Pat> {\n+fn build_pat(\n+    db: &RootDatabase,\n+    module: hir::Module,\n+    var: ExtendedVariant,\n+    prefer_no_std: bool,\n+) -> Option<ast::Pat> {\n     match var {\n         ExtendedVariant::Variant(var) => {\n-            let path = mod_path_to_ast(&module.find_use_path(db, ModuleDef::from(var))?);\n+            let path =\n+                mod_path_to_ast(&module.find_use_path(db, ModuleDef::from(var), prefer_no_std)?);\n \n             // FIXME: use HIR for this; it doesn't currently expose struct vs. tuple vs. unit variants though\n             let pat: ast::Pat = match var.source(db)?.value.kind() {"}, {"sha": "e257218ba937686275d3c8f78f998d0f49e4d073", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/auto_import.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -89,8 +89,11 @@ use crate::{AssistContext, AssistId, AssistKind, Assists, GroupLabel};\n // ```\n pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let (import_assets, syntax_under_caret) = find_importable_node(ctx)?;\n-    let mut proposed_imports =\n-        import_assets.search_for_imports(&ctx.sema, ctx.config.insert_use.prefix_kind);\n+    let mut proposed_imports = import_assets.search_for_imports(\n+        &ctx.sema,\n+        ctx.config.insert_use.prefix_kind,\n+        ctx.config.prefer_no_std,\n+    );\n     if proposed_imports.is_empty() {\n         return None;\n     }"}, {"sha": "95d11abe8bc0f6fea075297b0c1473e81ec7a77b", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/convert_into_to_from.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_into_to_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_into_to_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_into_to_from.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -50,7 +50,7 @@ pub(crate) fn convert_into_to_from(acc: &mut Assists, ctx: &AssistContext<'_>) -\n             _ => return None,\n         };\n \n-        mod_path_to_ast(&module.find_use_path(ctx.db(), src_type_def)?)\n+        mod_path_to_ast(&module.find_use_path(ctx.db(), src_type_def, ctx.config.prefer_no_std)?)\n     };\n \n     let dest_type = match &ast_trait {"}, {"sha": "d6c8ea785f84aa87f1b2904e06ddcdab103eafc1", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/extract_function.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -152,6 +152,7 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext<'_>) -> Op\n                         ctx.sema.db,\n                         ModuleDef::from(control_flow_enum),\n                         ctx.config.insert_use.prefix_kind,\n+                        ctx.config.prefer_no_std,\n                     );\n \n                     if let Some(mod_path) = mod_path {"}, {"sha": "8d5cab283d0616d3297e864a782f61e4965975cd", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -409,6 +409,7 @@ fn process_references(\n                     ctx.sema.db,\n                     *enum_module_def,\n                     ctx.config.insert_use.prefix_kind,\n+                    ctx.config.prefer_no_std,\n                 );\n                 if let Some(mut mod_path) = mod_path {\n                     mod_path.pop_segment();"}, {"sha": "8f4405a8c869cf9273e481775f98bff95e63a24b", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_deref.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -58,7 +58,8 @@ fn generate_record_deref(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<(\n \n     let module = ctx.sema.to_def(&strukt)?.module(ctx.db());\n     let trait_ = deref_type_to_generate.to_trait(&ctx.sema, module.krate())?;\n-    let trait_path = module.find_use_path(ctx.db(), ModuleDef::Trait(trait_))?;\n+    let trait_path =\n+        module.find_use_path(ctx.db(), ModuleDef::Trait(trait_), ctx.config.prefer_no_std)?;\n \n     let field_type = field.ty()?;\n     let field_name = field.name()?;\n@@ -98,7 +99,8 @@ fn generate_tuple_deref(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()\n \n     let module = ctx.sema.to_def(&strukt)?.module(ctx.db());\n     let trait_ = deref_type_to_generate.to_trait(&ctx.sema, module.krate())?;\n-    let trait_path = module.find_use_path(ctx.db(), ModuleDef::Trait(trait_))?;\n+    let trait_path =\n+        module.find_use_path(ctx.db(), ModuleDef::Trait(trait_), ctx.config.prefer_no_std)?;\n \n     let field_type = field.ty()?;\n     let target = field.syntax().text_range();"}, {"sha": "9cda74d9e0d31e4c41c65ed99b396d1cec982545", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_new.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -60,8 +60,11 @@ pub(crate) fn generate_new(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option\n \n                 let item_in_ns = hir::ItemInNs::from(hir::ModuleDef::from(ty.as_adt()?));\n \n-                let type_path = current_module\n-                    .find_use_path(ctx.sema.db, item_for_path_search(ctx.sema.db, item_in_ns)?)?;\n+                let type_path = current_module.find_use_path(\n+                    ctx.sema.db,\n+                    item_for_path_search(ctx.sema.db, item_in_ns)?,\n+                    ctx.config.prefer_no_std,\n+                )?;\n \n                 let expr = use_trivial_constructor(\n                     &ctx.sema.db,"}, {"sha": "92b2fa79d717bda9deeecb4811de419160c89b55", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/move_format_string_arg.rs", "status": "added", "additions": 268, "deletions": 0, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_format_string_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_format_string_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_format_string_arg.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -0,0 +1,268 @@\n+use crate::{AssistContext, Assists};\n+use ide_db::{\n+    assists::{AssistId, AssistKind},\n+    syntax_helpers::{\n+        format_string::is_format_string,\n+        format_string_exprs::{parse_format_exprs, Arg},\n+    },\n+};\n+use itertools::Itertools;\n+use syntax::{ast, AstNode, AstToken, NodeOrToken, SyntaxKind::COMMA, TextRange};\n+\n+// Assist: move_format_string_arg\n+//\n+// Move an expression out of a format string.\n+//\n+// ```\n+// macro_rules! format_args {\n+//     ($lit:literal $(tt:tt)*) => { 0 },\n+// }\n+// macro_rules! print {\n+//     ($($arg:tt)*) => (std::io::_print(format_args!($($arg)*)));\n+// }\n+//\n+// fn main() {\n+//     print!(\"{x + 1}$0\");\n+// }\n+// ```\n+// ->\n+// ```\n+// macro_rules! format_args {\n+//     ($lit:literal $(tt:tt)*) => { 0 },\n+// }\n+// macro_rules! print {\n+//     ($($arg:tt)*) => (std::io::_print(format_args!($($arg)*)));\n+// }\n+//\n+// fn main() {\n+//     print!(\"{}\"$0, x + 1);\n+// }\n+// ```\n+\n+pub(crate) fn move_format_string_arg(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n+    let fmt_string = ctx.find_token_at_offset::<ast::String>()?;\n+    let tt = fmt_string.syntax().parent().and_then(ast::TokenTree::cast)?;\n+\n+    let expanded_t = ast::String::cast(\n+        ctx.sema.descend_into_macros_with_kind_preference(fmt_string.syntax().clone()),\n+    )?;\n+    if !is_format_string(&expanded_t) {\n+        return None;\n+    }\n+\n+    let (new_fmt, extracted_args) = parse_format_exprs(fmt_string.text()).ok()?;\n+    if extracted_args.is_empty() {\n+        return None;\n+    }\n+\n+    acc.add(\n+        AssistId(\n+            \"move_format_string_arg\",\n+            // if there aren't any expressions, then make the assist a RefactorExtract\n+            if extracted_args.iter().filter(|f| matches!(f, Arg::Expr(_))).count() == 0 {\n+                AssistKind::RefactorExtract\n+            } else {\n+                AssistKind::QuickFix\n+            },\n+        ),\n+        \"Extract format args\",\n+        tt.syntax().text_range(),\n+        |edit| {\n+            let fmt_range = fmt_string.syntax().text_range();\n+\n+            // Replace old format string with new format string whose arguments have been extracted\n+            edit.replace(fmt_range, new_fmt);\n+\n+            // Insert cursor at end of format string\n+            edit.insert(fmt_range.end(), \"$0\");\n+\n+            // Extract existing arguments in macro\n+            let tokens =\n+                tt.token_trees_and_tokens().filter_map(NodeOrToken::into_token).collect_vec();\n+\n+            let mut existing_args: Vec<String> = vec![];\n+\n+            let mut current_arg = String::new();\n+            if let [_opening_bracket, format_string, _args_start_comma, tokens @ .., end_bracket] =\n+                tokens.as_slice()\n+            {\n+                for t in tokens {\n+                    if t.kind() == COMMA {\n+                        existing_args.push(current_arg.trim().into());\n+                        current_arg.clear();\n+                    } else {\n+                        current_arg.push_str(t.text());\n+                    }\n+                }\n+                existing_args.push(current_arg.trim().into());\n+\n+                // delete everything after the format string till end bracket\n+                // we're going to insert the new arguments later\n+                edit.delete(TextRange::new(\n+                    format_string.text_range().end(),\n+                    end_bracket.text_range().start(),\n+                ));\n+            }\n+\n+            // Start building the new args\n+            let mut existing_args = existing_args.into_iter();\n+            let mut args = String::new();\n+\n+            let mut placeholder_idx = 1;\n+\n+            for extracted_args in extracted_args {\n+                // remove expr from format string\n+                args.push_str(\", \");\n+\n+                match extracted_args {\n+                    Arg::Ident(s) | Arg::Expr(s) => {\n+                        // insert arg\n+                        args.push_str(&s);\n+                    }\n+                    Arg::Placeholder => {\n+                        // try matching with existing argument\n+                        match existing_args.next() {\n+                            Some(ea) => {\n+                                args.push_str(&ea);\n+                            }\n+                            None => {\n+                                // insert placeholder\n+                                args.push_str(&format!(\"${placeholder_idx}\"));\n+                                placeholder_idx += 1;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Insert new args\n+            edit.insert(fmt_range.end(), args);\n+        },\n+    );\n+\n+    Some(())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use crate::tests::check_assist;\n+\n+    const MACRO_DECL: &'static str = r#\"\n+macro_rules! format_args {\n+    ($lit:literal $(tt:tt)*) => { 0 },\n+}\n+macro_rules! print {\n+    ($($arg:tt)*) => (std::io::_print(format_args!($($arg)*)));\n+}\n+\"#;\n+\n+    fn add_macro_decl(s: &'static str) -> String {\n+        MACRO_DECL.to_string() + s\n+    }\n+\n+    #[test]\n+    fn multiple_middle_arg() {\n+        check_assist(\n+            move_format_string_arg,\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    print!(\"{} {x + 1:b} {}$0\", y + 2, 2);\n+}\n+\"#,\n+            ),\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    print!(\"{} {:b} {}\"$0, y + 2, x + 1, 2);\n+}\n+\"#,\n+            ),\n+        );\n+    }\n+\n+    #[test]\n+    fn single_arg() {\n+        check_assist(\n+            move_format_string_arg,\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    print!(\"{obj.value:b}$0\",);\n+}\n+\"#,\n+            ),\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    print!(\"{:b}\"$0, obj.value);\n+}\n+\"#,\n+            ),\n+        );\n+    }\n+\n+    #[test]\n+    fn multiple_middle_placeholders_arg() {\n+        check_assist(\n+            move_format_string_arg,\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    print!(\"{} {x + 1:b} {} {}$0\", y + 2, 2);\n+}\n+\"#,\n+            ),\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    print!(\"{} {:b} {} {}\"$0, y + 2, x + 1, 2, $1);\n+}\n+\"#,\n+            ),\n+        );\n+    }\n+\n+    #[test]\n+    fn multiple_trailing_args() {\n+        check_assist(\n+            move_format_string_arg,\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    print!(\"{} {x + 1:b} {Struct(1, 2)}$0\", 1);\n+}\n+\"#,\n+            ),\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    print!(\"{} {:b} {}\"$0, 1, x + 1, Struct(1, 2));\n+}\n+\"#,\n+            ),\n+        );\n+    }\n+\n+    #[test]\n+    fn improper_commas() {\n+        check_assist(\n+            move_format_string_arg,\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    print!(\"{} {x + 1:b} {Struct(1, 2)}$0\", 1,);\n+}\n+\"#,\n+            ),\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    print!(\"{} {:b} {}\"$0, 1, x + 1, Struct(1, 2));\n+}\n+\"#,\n+            ),\n+        );\n+    }\n+}"}, {"sha": "e57d1d065d6229361ca68604e8ace6c8b9331c1d", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/qualify_method_call.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -44,8 +44,11 @@ pub(crate) fn qualify_method_call(acc: &mut Assists, ctx: &AssistContext<'_>) ->\n     let current_module = ctx.sema.scope(call.syntax())?.module();\n     let target_module_def = ModuleDef::from(resolved_call);\n     let item_in_ns = ItemInNs::from(target_module_def);\n-    let receiver_path = current_module\n-        .find_use_path(ctx.sema.db, item_for_path_search(ctx.sema.db, item_in_ns)?)?;\n+    let receiver_path = current_module.find_use_path(\n+        ctx.sema.db,\n+        item_for_path_search(ctx.sema.db, item_in_ns)?,\n+        ctx.config.prefer_no_std,\n+    )?;\n \n     let qualify_candidate = QualifyCandidate::ImplMethod(ctx.sema.db, call, resolved_call);\n "}, {"sha": "4b2af550bc5e4902c15bdf4a158ba6ee0bef6326", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/qualify_path.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_path.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -37,7 +37,8 @@ use crate::{\n // ```\n pub(crate) fn qualify_path(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let (import_assets, syntax_under_caret) = find_importable_node(ctx)?;\n-    let mut proposed_imports = import_assets.search_for_relative_paths(&ctx.sema);\n+    let mut proposed_imports =\n+        import_assets.search_for_relative_paths(&ctx.sema, ctx.config.prefer_no_std);\n     if proposed_imports.is_empty() {\n         return None;\n     }"}, {"sha": "9fd5e1886d206ef3dad043c6e29f2a4eb88b1219", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -85,7 +85,7 @@ pub(crate) fn replace_derive_with_manual_impl(\n     })\n     .flat_map(|trait_| {\n         current_module\n-            .find_use_path(ctx.sema.db, hir::ModuleDef::Trait(trait_))\n+            .find_use_path(ctx.sema.db, hir::ModuleDef::Trait(trait_), ctx.config.prefer_no_std)\n             .as_ref()\n             .map(mod_path_to_ast)\n             .zip(Some(trait_))"}, {"sha": "dbbc56958f1e2ede4419e6887073c662bdc9f40e", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/replace_qualified_name_with_use.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -67,6 +67,7 @@ pub(crate) fn replace_qualified_name_with_use(\n                 ctx.sema.db,\n                 module,\n                 ctx.config.insert_use.prefix_kind,\n+                ctx.config.prefer_no_std,\n             )\n         })\n         .flatten();"}, {"sha": "812d22efbd797c42bc533d20c9a477207481aad6", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Flib.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -136,6 +136,7 @@ mod handlers {\n     mod flip_binexpr;\n     mod flip_comma;\n     mod flip_trait_bound;\n+    mod move_format_string_arg;\n     mod generate_constant;\n     mod generate_default_from_enum_variant;\n     mod generate_default_from_new;\n@@ -254,6 +255,7 @@ mod handlers {\n             merge_imports::merge_imports,\n             merge_match_arms::merge_match_arms,\n             move_bounds::move_bounds_to_where_clause,\n+            move_format_string_arg::move_format_string_arg,\n             move_guard::move_arm_cond_to_match_guard,\n             move_guard::move_guard_to_arm_body,\n             move_module_to_file::move_module_to_file,"}, {"sha": "258144bae3d08dfad368fa824804d9c4f3128674", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -29,6 +29,7 @@ pub(crate) const TEST_CONFIG: AssistConfig = AssistConfig {\n         group: true,\n         skip_glob_imports: true,\n     },\n+    prefer_no_std: false,\n };\n \n pub(crate) fn with_single_file(text: &str) -> (RootDatabase, FileId) {"}, {"sha": "3a696635afd275c8830781e30259f5944f71f2d1", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/tests/generated.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -1591,6 +1591,37 @@ fn apply<T, U, F>(f: F, x: T) -> U where F: FnOnce(T) -> U {\n     )\n }\n \n+#[test]\n+fn doctest_move_format_string_arg() {\n+    check_doc_test(\n+        \"move_format_string_arg\",\n+        r#####\"\n+macro_rules! format_args {\n+    ($lit:literal $(tt:tt)*) => { 0 },\n+}\n+macro_rules! print {\n+    ($($arg:tt)*) => (std::io::_print(format_args!($($arg)*)));\n+}\n+\n+fn main() {\n+    print!(\"{x + 1}$0\");\n+}\n+\"#####,\n+        r#####\"\n+macro_rules! format_args {\n+    ($lit:literal $(tt:tt)*) => { 0 },\n+}\n+macro_rules! print {\n+    ($($arg:tt)*) => (std::io::_print(format_args!($($arg)*)));\n+}\n+\n+fn main() {\n+    print!(\"{}\"$0, x + 1);\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_move_from_mod_rs() {\n     check_doc_test("}, {"sha": "97b90c62dd7775b1073181148bb6ae5ea27826c9", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -551,7 +551,11 @@ fn enum_variants_with_paths(\n     }\n \n     for variant in variants {\n-        if let Some(path) = ctx.module.find_use_path(ctx.db, hir::ModuleDef::from(variant)) {\n+        if let Some(path) = ctx.module.find_use_path(\n+            ctx.db,\n+            hir::ModuleDef::from(variant),\n+            ctx.config.prefer_no_std,\n+        ) {\n             // Variants with trivial paths are already added by the existing completion logic,\n             // so we should avoid adding these twice\n             if path.segments().len() > 1 {"}, {"sha": "3192b21cfb2e2da3ae3bd49b5e560c561fa58fd1", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/expr.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -165,7 +165,11 @@ pub(crate) fn complete_expr_path(\n                     hir::Adt::Struct(strukt) => {\n                         let path = ctx\n                             .module\n-                            .find_use_path(ctx.db, hir::ModuleDef::from(strukt))\n+                            .find_use_path(\n+                                ctx.db,\n+                                hir::ModuleDef::from(strukt),\n+                                ctx.config.prefer_no_std,\n+                            )\n                             .filter(|it| it.len() > 1);\n \n                         acc.add_struct_literal(ctx, path_ctx, strukt, path, None);\n@@ -183,7 +187,11 @@ pub(crate) fn complete_expr_path(\n                     hir::Adt::Union(un) => {\n                         let path = ctx\n                             .module\n-                            .find_use_path(ctx.db, hir::ModuleDef::from(un))\n+                            .find_use_path(\n+                                ctx.db,\n+                                hir::ModuleDef::from(un),\n+                                ctx.config.prefer_no_std,\n+                            )\n                             .filter(|it| it.len() > 1);\n \n                         acc.add_union_literal(ctx, un, path, None);"}, {"sha": "364969af9c9abc8aa6721d9ccbdfa1f515915251", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/flyimport.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -262,7 +262,11 @@ fn import_on_the_fly(\n \n     acc.add_all(\n         import_assets\n-            .search_for_imports(&ctx.sema, ctx.config.insert_use.prefix_kind)\n+            .search_for_imports(\n+                &ctx.sema,\n+                ctx.config.insert_use.prefix_kind,\n+                ctx.config.prefer_no_std,\n+            )\n             .into_iter()\n             .filter(ns_filter)\n             .filter(|import| {\n@@ -306,7 +310,11 @@ fn import_on_the_fly_pat_(\n \n     acc.add_all(\n         import_assets\n-            .search_for_imports(&ctx.sema, ctx.config.insert_use.prefix_kind)\n+            .search_for_imports(\n+                &ctx.sema,\n+                ctx.config.insert_use.prefix_kind,\n+                ctx.config.prefer_no_std,\n+            )\n             .into_iter()\n             .filter(ns_filter)\n             .filter(|import| {\n@@ -344,7 +352,7 @@ fn import_on_the_fly_method(\n     let user_input_lowercased = potential_import_name.to_lowercase();\n \n     import_assets\n-        .search_for_imports(&ctx.sema, ctx.config.insert_use.prefix_kind)\n+        .search_for_imports(&ctx.sema, ctx.config.insert_use.prefix_kind, ctx.config.prefer_no_std)\n         .into_iter()\n         .filter(|import| {\n             !ctx.is_item_hidden(&import.item_to_import)"}, {"sha": "58d5bf114cca4abfbee7ae0f200c92e9c1780a0a", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/pattern.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -145,6 +145,7 @@ pub(crate) fn complete_pattern_path(\n                             u.ty(ctx.db)\n                         }\n                         hir::PathResolution::Def(hir::ModuleDef::BuiltinType(ty)) => ty.ty(ctx.db),\n+                        hir::PathResolution::Def(hir::ModuleDef::TypeAlias(ty)) => ty.ty(ctx.db),\n                         _ => return,\n                     };\n "}, {"sha": "b43bdb9ab9d1a5b861b148195bfdee890c56192e", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/postfix/format_like.rs", "status": "modified", "additions": 12, "deletions": 235, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -16,8 +16,11 @@\n //\n // image::https://user-images.githubusercontent.com/48062697/113020656-b560f500-917a-11eb-87de-02991f61beb8.gif[]\n \n-use ide_db::SnippetCap;\n-use syntax::ast::{self, AstToken};\n+use ide_db::{\n+    syntax_helpers::format_string_exprs::{parse_format_exprs, with_placeholders},\n+    SnippetCap,\n+};\n+use syntax::{ast, AstToken};\n \n use crate::{\n     completions::postfix::build_postfix_snippet_builder, context::CompletionContext, Completions,\n@@ -43,250 +46,24 @@ pub(crate) fn add_format_like_completions(\n     cap: SnippetCap,\n     receiver_text: &ast::String,\n ) {\n-    let input = match string_literal_contents(receiver_text) {\n-        // It's not a string literal, do not parse input.\n-        Some(input) => input,\n-        None => return,\n-    };\n-\n     let postfix_snippet = match build_postfix_snippet_builder(ctx, cap, dot_receiver) {\n         Some(it) => it,\n         None => return,\n     };\n-    let mut parser = FormatStrParser::new(input);\n \n-    if parser.parse().is_ok() {\n+    if let Ok((out, exprs)) = parse_format_exprs(receiver_text.text()) {\n+        let exprs = with_placeholders(exprs);\n         for (label, macro_name) in KINDS {\n-            let snippet = parser.to_suggestion(macro_name);\n+            let snippet = format!(r#\"{}({}, {})\"#, macro_name, out, exprs.join(\", \"));\n \n             postfix_snippet(label, macro_name, &snippet).add_to(acc);\n         }\n     }\n }\n \n-/// Checks whether provided item is a string literal.\n-fn string_literal_contents(item: &ast::String) -> Option<String> {\n-    let item = item.text();\n-    if item.len() >= 2 && item.starts_with('\\\"') && item.ends_with('\\\"') {\n-        return Some(item[1..item.len() - 1].to_owned());\n-    }\n-\n-    None\n-}\n-\n-/// Parser for a format-like string. It is more allowing in terms of string contents,\n-/// as we expect variable placeholders to be filled with expressions.\n-#[derive(Debug)]\n-pub(crate) struct FormatStrParser {\n-    input: String,\n-    output: String,\n-    extracted_expressions: Vec<String>,\n-    state: State,\n-    parsed: bool,\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq)]\n-enum State {\n-    NotExpr,\n-    MaybeExpr,\n-    Expr,\n-    MaybeIncorrect,\n-    FormatOpts,\n-}\n-\n-impl FormatStrParser {\n-    pub(crate) fn new(input: String) -> Self {\n-        Self {\n-            input,\n-            output: String::new(),\n-            extracted_expressions: Vec::new(),\n-            state: State::NotExpr,\n-            parsed: false,\n-        }\n-    }\n-\n-    pub(crate) fn parse(&mut self) -> Result<(), ()> {\n-        let mut current_expr = String::new();\n-\n-        let mut placeholder_id = 1;\n-\n-        // Count of open braces inside of an expression.\n-        // We assume that user knows what they're doing, thus we treat it like a correct pattern, e.g.\n-        // \"{MyStruct { val_a: 0, val_b: 1 }}\".\n-        let mut inexpr_open_count = 0;\n-\n-        // We need to escape '\\' and '$'. See the comments on `get_receiver_text()` for detail.\n-        let mut chars = self.input.chars().peekable();\n-        while let Some(chr) = chars.next() {\n-            match (self.state, chr) {\n-                (State::NotExpr, '{') => {\n-                    self.output.push(chr);\n-                    self.state = State::MaybeExpr;\n-                }\n-                (State::NotExpr, '}') => {\n-                    self.output.push(chr);\n-                    self.state = State::MaybeIncorrect;\n-                }\n-                (State::NotExpr, _) => {\n-                    if matches!(chr, '\\\\' | '$') {\n-                        self.output.push('\\\\');\n-                    }\n-                    self.output.push(chr);\n-                }\n-                (State::MaybeIncorrect, '}') => {\n-                    // It's okay, we met \"}}\".\n-                    self.output.push(chr);\n-                    self.state = State::NotExpr;\n-                }\n-                (State::MaybeIncorrect, _) => {\n-                    // Error in the string.\n-                    return Err(());\n-                }\n-                (State::MaybeExpr, '{') => {\n-                    self.output.push(chr);\n-                    self.state = State::NotExpr;\n-                }\n-                (State::MaybeExpr, '}') => {\n-                    // This is an empty sequence '{}'. Replace it with placeholder.\n-                    self.output.push(chr);\n-                    self.extracted_expressions.push(format!(\"${}\", placeholder_id));\n-                    placeholder_id += 1;\n-                    self.state = State::NotExpr;\n-                }\n-                (State::MaybeExpr, _) => {\n-                    if matches!(chr, '\\\\' | '$') {\n-                        current_expr.push('\\\\');\n-                    }\n-                    current_expr.push(chr);\n-                    self.state = State::Expr;\n-                }\n-                (State::Expr, '}') => {\n-                    if inexpr_open_count == 0 {\n-                        self.output.push(chr);\n-                        self.extracted_expressions.push(current_expr.trim().into());\n-                        current_expr = String::new();\n-                        self.state = State::NotExpr;\n-                    } else {\n-                        // We're closing one brace met before inside of the expression.\n-                        current_expr.push(chr);\n-                        inexpr_open_count -= 1;\n-                    }\n-                }\n-                (State::Expr, ':') if chars.peek().copied() == Some(':') => {\n-                    // path separator\n-                    current_expr.push_str(\"::\");\n-                    chars.next();\n-                }\n-                (State::Expr, ':') => {\n-                    if inexpr_open_count == 0 {\n-                        // We're outside of braces, thus assume that it's a specifier, like \"{Some(value):?}\"\n-                        self.output.push(chr);\n-                        self.extracted_expressions.push(current_expr.trim().into());\n-                        current_expr = String::new();\n-                        self.state = State::FormatOpts;\n-                    } else {\n-                        // We're inside of braced expression, assume that it's a struct field name/value delimiter.\n-                        current_expr.push(chr);\n-                    }\n-                }\n-                (State::Expr, '{') => {\n-                    current_expr.push(chr);\n-                    inexpr_open_count += 1;\n-                }\n-                (State::Expr, _) => {\n-                    if matches!(chr, '\\\\' | '$') {\n-                        current_expr.push('\\\\');\n-                    }\n-                    current_expr.push(chr);\n-                }\n-                (State::FormatOpts, '}') => {\n-                    self.output.push(chr);\n-                    self.state = State::NotExpr;\n-                }\n-                (State::FormatOpts, _) => {\n-                    if matches!(chr, '\\\\' | '$') {\n-                        self.output.push('\\\\');\n-                    }\n-                    self.output.push(chr);\n-                }\n-            }\n-        }\n-\n-        if self.state != State::NotExpr {\n-            return Err(());\n-        }\n-\n-        self.parsed = true;\n-        Ok(())\n-    }\n-\n-    pub(crate) fn to_suggestion(&self, macro_name: &str) -> String {\n-        assert!(self.parsed, \"Attempt to get a suggestion from not parsed expression\");\n-\n-        let expressions_as_string = self.extracted_expressions.join(\", \");\n-        format!(r#\"{}(\"{}\", {})\"#, macro_name, self.output, expressions_as_string)\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use expect_test::{expect, Expect};\n-\n-    fn check(input: &str, expect: &Expect) {\n-        let mut parser = FormatStrParser::new((*input).to_owned());\n-        let outcome_repr = if parser.parse().is_ok() {\n-            // Parsing should be OK, expected repr is \"string; expr_1, expr_2\".\n-            if parser.extracted_expressions.is_empty() {\n-                parser.output\n-            } else {\n-                format!(\"{}; {}\", parser.output, parser.extracted_expressions.join(\", \"))\n-            }\n-        } else {\n-            // Parsing should fail, expected repr is \"-\".\n-            \"-\".to_owned()\n-        };\n-\n-        expect.assert_eq(&outcome_repr);\n-    }\n-\n-    #[test]\n-    fn format_str_parser() {\n-        let test_vector = &[\n-            (\"no expressions\", expect![[\"no expressions\"]]),\n-            (r\"no expressions with \\$0$1\", expect![r\"no expressions with \\\\\\$0\\$1\"]),\n-            (\"{expr} is {2 + 2}\", expect![[\"{} is {}; expr, 2 + 2\"]]),\n-            (\"{expr:?}\", expect![[\"{:?}; expr\"]]),\n-            (\"{expr:1$}\", expect![[r\"{:1\\$}; expr\"]]),\n-            (\"{$0}\", expect![[r\"{}; \\$0\"]]),\n-            (\"{malformed\", expect![[\"-\"]]),\n-            (\"malformed}\", expect![[\"-\"]]),\n-            (\"{{correct\", expect![[\"{{correct\"]]),\n-            (\"correct}}\", expect![[\"correct}}\"]]),\n-            (\"{correct}}}\", expect![[\"{}}}; correct\"]]),\n-            (\"{correct}}}}}\", expect![[\"{}}}}}; correct\"]]),\n-            (\"{incorrect}}\", expect![[\"-\"]]),\n-            (\"placeholders {} {}\", expect![[\"placeholders {} {}; $1, $2\"]]),\n-            (\"mixed {} {2 + 2} {}\", expect![[\"mixed {} {} {}; $1, 2 + 2, $2\"]]),\n-            (\n-                \"{SomeStruct { val_a: 0, val_b: 1 }}\",\n-                expect![[\"{}; SomeStruct { val_a: 0, val_b: 1 }\"]],\n-            ),\n-            (\"{expr:?} is {2.32f64:.5}\", expect![[\"{:?} is {:.5}; expr, 2.32f64\"]]),\n-            (\n-                \"{SomeStruct { val_a: 0, val_b: 1 }:?}\",\n-                expect![[\"{:?}; SomeStruct { val_a: 0, val_b: 1 }\"]],\n-            ),\n-            (\"{     2 + 2        }\", expect![[\"{}; 2 + 2\"]]),\n-            (\"{strsim::jaro_winkle(a)}\", expect![[\"{}; strsim::jaro_winkle(a)\"]]),\n-            (\"{foo::bar::baz()}\", expect![[\"{}; foo::bar::baz()\"]]),\n-            (\"{foo::bar():?}\", expect![[\"{:?}; foo::bar()\"]]),\n-        ];\n-\n-        for (input, output) in test_vector {\n-            check(input, output)\n-        }\n-    }\n \n     #[test]\n     fn test_into_suggestion() {\n@@ -302,10 +79,10 @@ mod tests {\n         ];\n \n         for (kind, input, output) in test_vector {\n-            let mut parser = FormatStrParser::new((*input).to_owned());\n-            parser.parse().expect(\"Parsing must succeed\");\n-\n-            assert_eq!(&parser.to_suggestion(*kind), output);\n+            let (parsed_string, exprs) = parse_format_exprs(input).unwrap();\n+            let exprs = with_placeholders(exprs);\n+            let snippet = format!(r#\"{}(\"{}\", {})\"#, kind, parsed_string, exprs.join(\", \"));\n+            assert_eq!(&snippet, output);\n         }\n     }\n }"}, {"sha": "a0f5e81b4fb6c3396efd9d1ec7093e6402f43e85", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/config.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fconfig.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -17,6 +17,7 @@ pub struct CompletionConfig {\n     pub callable: Option<CallableSnippets>,\n     pub snippet_cap: Option<SnippetCap>,\n     pub insert_use: InsertUseConfig,\n+    pub prefer_no_std: bool,\n     pub snippets: Vec<Snippet>,\n }\n "}, {"sha": "8d21f4fce0a2b324a3fc112c23ac2faef9560afa", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Flib.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -234,7 +234,12 @@ pub fn resolve_completion_edits(\n         );\n         let import = items_with_name\n             .filter_map(|candidate| {\n-                current_module.find_use_path_prefixed(db, candidate, config.insert_use.prefix_kind)\n+                current_module.find_use_path_prefixed(\n+                    db,\n+                    candidate,\n+                    config.insert_use.prefix_kind,\n+                    config.prefer_no_std,\n+                )\n             })\n             .find(|mod_path| mod_path.to_string() == full_import_path);\n         if let Some(import_path) = import {"}, {"sha": "f3b8eae4fe8cd8c25fff08afa889326e37da642e", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/snippet.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fsnippet.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -174,8 +174,12 @@ fn import_edits(ctx: &CompletionContext<'_>, requires: &[GreenNode]) -> Option<V\n             hir::PathResolution::Def(def) => def.into(),\n             _ => return None,\n         };\n-        let path =\n-            ctx.module.find_use_path_prefixed(ctx.db, item, ctx.config.insert_use.prefix_kind)?;\n+        let path = ctx.module.find_use_path_prefixed(\n+            ctx.db,\n+            item,\n+            ctx.config.insert_use.prefix_kind,\n+            ctx.config.prefer_no_std,\n+        )?;\n         Some((path.len() > 1).then(|| LocatedImport::new(path.clone(), item, item, None)))\n     };\n     let mut res = Vec::with_capacity(requires.len());"}, {"sha": "9e2beb9ee328862289fd507f504a4e79767ec903", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -66,6 +66,7 @@ pub(crate) const TEST_CONFIG: CompletionConfig = CompletionConfig {\n     enable_private_editable: false,\n     callable: Some(CallableSnippets::FillArguments),\n     snippet_cap: SnippetCap::new(true),\n+    prefer_no_std: false,\n     insert_use: InsertUseConfig {\n         granularity: ImportGranularity::Crate,\n         prefix_kind: PrefixKind::Plain,"}, {"sha": "db8bef66405efb3e55e564c55385edfe9dc7b823", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/pattern.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -714,3 +714,30 @@ impl Ty {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn through_alias() {\n+    check_empty(\n+        r#\"\n+enum Enum<T> {\n+    Unit,\n+    Tuple(T),\n+}\n+\n+type EnumAlias<T> = Enum<T>;\n+\n+fn f(x: EnumAlias<u8>) {\n+    match x {\n+        EnumAlias::$0 => (),\n+        _ => (),\n+    }\n+\n+}\n+\n+\"#,\n+        expect![[r#\"\n+            bn Tuple(\u2026) Tuple($1)$0\n+            bn Unit     Unit$0\n+        \"#]],\n+    );\n+}"}, {"sha": "30272bc16f636754489c6838c64448ac48f8283a", "filename": "src/tools/rust-analyzer/crates/ide-db/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2FCargo.toml?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -20,6 +20,7 @@ either = \"1.7.0\"\n itertools = \"0.10.3\"\n arrayvec = \"0.7.2\"\n indexmap = \"1.9.1\"\n+memchr = \"2.5.0\"\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n parser = { path = \"../parser\", version = \"0.0.0\" }"}, {"sha": "40a6a3e8970fb770428c092b901ad23bc1bf7536", "filename": "src/tools/rust-analyzer/crates/ide-db/src/imports/import_assets.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fimports%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fimports%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fimports%2Fimport_assets.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -212,18 +212,20 @@ impl ImportAssets {\n         &self,\n         sema: &Semantics<'_, RootDatabase>,\n         prefix_kind: PrefixKind,\n+        prefer_no_std: bool,\n     ) -> Vec<LocatedImport> {\n         let _p = profile::span(\"import_assets::search_for_imports\");\n-        self.search_for(sema, Some(prefix_kind))\n+        self.search_for(sema, Some(prefix_kind), prefer_no_std)\n     }\n \n     /// This may return non-absolute paths if a part of the returned path is already imported into scope.\n     pub fn search_for_relative_paths(\n         &self,\n         sema: &Semantics<'_, RootDatabase>,\n+        prefer_no_std: bool,\n     ) -> Vec<LocatedImport> {\n         let _p = profile::span(\"import_assets::search_for_relative_paths\");\n-        self.search_for(sema, None)\n+        self.search_for(sema, None, prefer_no_std)\n     }\n \n     pub fn path_fuzzy_name_to_exact(&mut self, case_sensitive: bool) {\n@@ -242,6 +244,7 @@ impl ImportAssets {\n         &self,\n         sema: &Semantics<'_, RootDatabase>,\n         prefixed: Option<PrefixKind>,\n+        prefer_no_std: bool,\n     ) -> Vec<LocatedImport> {\n         let _p = profile::span(\"import_assets::search_for\");\n \n@@ -252,6 +255,7 @@ impl ImportAssets {\n                 item_for_path_search(sema.db, item)?,\n                 &self.module_with_candidate,\n                 prefixed,\n+                prefer_no_std,\n             )\n         };\n \n@@ -564,11 +568,12 @@ fn get_mod_path(\n     item_to_search: ItemInNs,\n     module_with_candidate: &Module,\n     prefixed: Option<PrefixKind>,\n+    prefer_no_std: bool,\n ) -> Option<ModPath> {\n     if let Some(prefix_kind) = prefixed {\n-        module_with_candidate.find_use_path_prefixed(db, item_to_search, prefix_kind)\n+        module_with_candidate.find_use_path_prefixed(db, item_to_search, prefix_kind, prefer_no_std)\n     } else {\n-        module_with_candidate.find_use_path(db, item_to_search)\n+        module_with_candidate.find_use_path(db, item_to_search, prefer_no_std)\n     }\n }\n "}, {"sha": "e0bc0f89f0a1d14bdd54d384802ae8587311e41d", "filename": "src/tools/rust-analyzer/crates/ide-db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Flib.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -38,6 +38,7 @@ pub mod syntax_helpers {\n     pub mod node_ext;\n     pub mod insert_whitespace_into_node;\n     pub mod format_string;\n+    pub mod format_string_exprs;\n \n     pub use parser::LexedStr;\n }"}, {"sha": "12d873b4a0aa8be0c067f697cb7823375e7ce625", "filename": "src/tools/rust-analyzer/crates/ide-db/src/path_transform.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fpath_transform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fpath_transform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fpath_transform.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -173,6 +173,7 @@ impl<'a> Ctx<'a> {\n                             let found_path = self.target_module.find_use_path(\n                                 self.source_scope.db.upcast(),\n                                 hir::ModuleDef::Trait(trait_ref),\n+                                false,\n                             )?;\n                             match ast::make::ty_path(mod_path_to_ast(&found_path)) {\n                                 ast::Type::PathType(path_ty) => Some(path_ty),\n@@ -209,7 +210,7 @@ impl<'a> Ctx<'a> {\n                 }\n \n                 let found_path =\n-                    self.target_module.find_use_path(self.source_scope.db.upcast(), def)?;\n+                    self.target_module.find_use_path(self.source_scope.db.upcast(), def, false)?;\n                 let res = mod_path_to_ast(&found_path).clone_for_update();\n                 if let Some(args) = path.segment().and_then(|it| it.generic_arg_list()) {\n                     if let Some(segment) = res.segment() {"}, {"sha": "7cabdb55e8d284100a4a272f0888029340742bcb", "filename": "src/tools/rust-analyzer/crates/ide-db/src/search.rs", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsearch.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -8,7 +8,9 @@ use std::{mem, sync::Arc};\n \n use base_db::{FileId, FileRange, SourceDatabase, SourceDatabaseExt};\n use hir::{DefWithBody, HasAttrs, HasSource, InFile, ModuleSource, Semantics, Visibility};\n+use memchr::memmem::Finder;\n use once_cell::unsync::Lazy;\n+use parser::SyntaxKind;\n use stdx::hash::NoHashHashMap;\n use syntax::{ast, match_ast, AstNode, TextRange, TextSize};\n \n@@ -67,6 +69,7 @@ pub enum ReferenceCategory {\n     // Create\n     Write,\n     Read,\n+    Import,\n     // FIXME: Some day should be able to search in doc comments. Would probably\n     // need to switch from enum to bitflags then?\n     // DocComment\n@@ -409,14 +412,17 @@ impl<'a> FindUsages<'a> {\n             Some(s) => s.as_str(),\n             None => return,\n         };\n+        let finder = &Finder::new(name);\n+        let include_self_kw_refs =\n+            self.include_self_kw_refs.as_ref().map(|ty| (ty, Finder::new(\"Self\")));\n \n-        // these can't be closures because rust infers the lifetimes wrong ...\n+        // for<'a> |text: &'a str, name: &'a str, search_range: TextRange| -> impl Iterator<Item = TextSize> + 'a { ... }\n         fn match_indices<'a>(\n             text: &'a str,\n-            name: &'a str,\n+            finder: &'a Finder<'a>,\n             search_range: TextRange,\n         ) -> impl Iterator<Item = TextSize> + 'a {\n-            text.match_indices(name).filter_map(move |(idx, _)| {\n+            finder.find_iter(text.as_bytes()).filter_map(move |idx| {\n                 let offset: TextSize = idx.try_into().unwrap();\n                 if !search_range.contains_inclusive(offset) {\n                     return None;\n@@ -425,6 +431,7 @@ impl<'a> FindUsages<'a> {\n             })\n         }\n \n+        // for<'a> |scope: &'a SearchScope| -> impl Iterator<Item = (Arc<String>, FileId, TextRange)> + 'a { ... }\n         fn scope_files<'a>(\n             sema: &'a Semantics<'_, RootDatabase>,\n             scope: &'a SearchScope,\n@@ -448,7 +455,7 @@ impl<'a> FindUsages<'a> {\n             let tree = Lazy::new(move || sema.parse(file_id).syntax().clone());\n \n             // Search for occurrences of the items name\n-            for offset in match_indices(&text, name, search_range) {\n+            for offset in match_indices(&text, finder, search_range) {\n                 for name in sema.find_nodes_at_offset_with_descend(&tree, offset) {\n                     if match name {\n                         ast::NameLike::NameRef(name_ref) => self.found_name_ref(&name_ref, sink),\n@@ -460,8 +467,8 @@ impl<'a> FindUsages<'a> {\n                 }\n             }\n             // Search for occurrences of the `Self` referring to our type\n-            if let Some(self_ty) = &self.include_self_kw_refs {\n-                for offset in match_indices(&text, \"Self\", search_range) {\n+            if let Some((self_ty, finder)) = &include_self_kw_refs {\n+                for offset in match_indices(&text, finder, search_range) {\n                     for name_ref in sema.find_nodes_at_offset_with_descend(&tree, offset) {\n                         if self.found_self_ty_name_ref(self_ty, &name_ref, sink) {\n                             return;\n@@ -477,20 +484,22 @@ impl<'a> FindUsages<'a> {\n                 let scope = search_scope\n                     .intersection(&SearchScope::module_and_children(self.sema.db, module));\n \n-                let is_crate_root = module.is_crate_root(self.sema.db);\n+                let is_crate_root =\n+                    module.is_crate_root(self.sema.db).then(|| Finder::new(\"crate\"));\n+                let finder = &Finder::new(\"super\");\n \n                 for (text, file_id, search_range) in scope_files(sema, &scope) {\n                     let tree = Lazy::new(move || sema.parse(file_id).syntax().clone());\n \n-                    for offset in match_indices(&text, \"super\", search_range) {\n+                    for offset in match_indices(&text, finder, search_range) {\n                         for name_ref in sema.find_nodes_at_offset_with_descend(&tree, offset) {\n                             if self.found_name_ref(&name_ref, sink) {\n                                 return;\n                             }\n                         }\n                     }\n-                    if is_crate_root {\n-                        for offset in match_indices(&text, \"crate\", search_range) {\n+                    if let Some(finder) = &is_crate_root {\n+                        for offset in match_indices(&text, finder, search_range) {\n                             for name_ref in sema.find_nodes_at_offset_with_descend(&tree, offset) {\n                                 if self.found_name_ref(&name_ref, sink) {\n                                     return;\n@@ -531,8 +540,9 @@ impl<'a> FindUsages<'a> {\n                     search_range.unwrap_or_else(|| TextRange::up_to(TextSize::of(text.as_str())));\n \n                 let tree = Lazy::new(|| sema.parse(file_id).syntax().clone());\n+                let finder = &Finder::new(\"self\");\n \n-                for offset in match_indices(&text, \"self\", search_range) {\n+                for offset in match_indices(&text, finder, search_range) {\n                     for name_ref in sema.find_nodes_at_offset_with_descend(&tree, offset) {\n                         if self.found_self_module_name_ref(&name_ref, sink) {\n                             return;\n@@ -577,7 +587,7 @@ impl<'a> FindUsages<'a> {\n                 let reference = FileReference {\n                     range,\n                     name: ast::NameLike::NameRef(name_ref.clone()),\n-                    category: None,\n+                    category: is_name_ref_in_import(name_ref).then(|| ReferenceCategory::Import),\n                 };\n                 sink(file_id, reference)\n             }\n@@ -756,7 +766,7 @@ impl ReferenceCategory {\n     fn new(def: &Definition, r: &ast::NameRef) -> Option<ReferenceCategory> {\n         // Only Locals and Fields have accesses for now.\n         if !matches!(def, Definition::Local(_) | Definition::Field(_)) {\n-            return None;\n+            return is_name_ref_in_import(r).then(|| ReferenceCategory::Import);\n         }\n \n         let mode = r.syntax().ancestors().find_map(|node| {\n@@ -783,3 +793,12 @@ impl ReferenceCategory {\n         mode.or(Some(ReferenceCategory::Read))\n     }\n }\n+\n+fn is_name_ref_in_import(name_ref: &ast::NameRef) -> bool {\n+    name_ref\n+        .syntax()\n+        .parent()\n+        .and_then(ast::PathSegment::cast)\n+        .and_then(|it| it.parent_path().top_path().syntax().parent())\n+        .map_or(false, |it| it.kind() == SyntaxKind::USE_TREE)\n+}"}, {"sha": "ac6c6e8feeea01e1b2ef90cc2c664fd0b1bb76fe", "filename": "src/tools/rust-analyzer/crates/ide-db/src/syntax_helpers/format_string_exprs.rs", "status": "added", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string_exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string_exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string_exprs.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -0,0 +1,267 @@\n+//! Tools to work with expressions present in format string literals for the `format_args!` family of macros.\n+//! Primarily meant for assists and completions.\n+\n+/// Enum for represenging extraced format string args.\n+/// Can either be extracted expressions (which includes identifiers),\n+/// or placeholders `{}`.\n+#[derive(Debug, PartialEq, Eq)]\n+pub enum Arg {\n+    Placeholder,\n+    Ident(String),\n+    Expr(String),\n+}\n+\n+/**\n+ Add placeholders like `$1` and `$2` in place of [`Arg::Placeholder`],\n+ and unwraps the [`Arg::Ident`] and [`Arg::Expr`] enums.\n+ ```rust\n+ # use ide_db::syntax_helpers::format_string_exprs::*;\n+ assert_eq!(with_placeholders(vec![Arg::Ident(\"ident\".to_owned()), Arg::Placeholder, Arg::Expr(\"expr + 2\".to_owned())]), vec![\"ident\".to_owned(), \"$1\".to_owned(), \"expr + 2\".to_owned()])\n+ ```\n+*/\n+\n+pub fn with_placeholders(args: Vec<Arg>) -> Vec<String> {\n+    let mut placeholder_id = 1;\n+    args.into_iter()\n+        .map(move |a| match a {\n+            Arg::Expr(s) | Arg::Ident(s) => s,\n+            Arg::Placeholder => {\n+                let s = format!(\"${placeholder_id}\");\n+                placeholder_id += 1;\n+                s\n+            }\n+        })\n+        .collect()\n+}\n+\n+/**\n+ Parser for a format-like string. It is more allowing in terms of string contents,\n+ as we expect variable placeholders to be filled with expressions.\n+\n+ Built for completions and assists, and escapes `\\` and `$` in output.\n+ (See the comments on `get_receiver_text()` for detail.)\n+ Splits a format string that may contain expressions\n+ like\n+ ```rust\n+ assert_eq!(parse(\"{ident} {} {expr + 42} \").unwrap(), (\"{} {} {}\", vec![Arg::Ident(\"ident\"), Arg::Placeholder, Arg::Expr(\"expr + 42\")]));\n+ ```\n+*/\n+pub fn parse_format_exprs(input: &str) -> Result<(String, Vec<Arg>), ()> {\n+    #[derive(Debug, Clone, Copy, PartialEq)]\n+    enum State {\n+        NotArg,\n+        MaybeArg,\n+        Expr,\n+        Ident,\n+        MaybeIncorrect,\n+        FormatOpts,\n+    }\n+\n+    let mut state = State::NotArg;\n+    let mut current_expr = String::new();\n+    let mut extracted_expressions = Vec::new();\n+    let mut output = String::new();\n+\n+    // Count of open braces inside of an expression.\n+    // We assume that user knows what they're doing, thus we treat it like a correct pattern, e.g.\n+    // \"{MyStruct { val_a: 0, val_b: 1 }}\".\n+    let mut inexpr_open_count = 0;\n+\n+    let mut chars = input.chars().peekable();\n+    while let Some(chr) = chars.next() {\n+        match (state, chr) {\n+            (State::NotArg, '{') => {\n+                output.push(chr);\n+                state = State::MaybeArg;\n+            }\n+            (State::NotArg, '}') => {\n+                output.push(chr);\n+                state = State::MaybeIncorrect;\n+            }\n+            (State::NotArg, _) => {\n+                if matches!(chr, '\\\\' | '$') {\n+                    output.push('\\\\');\n+                }\n+                output.push(chr);\n+            }\n+            (State::MaybeIncorrect, '}') => {\n+                // It's okay, we met \"}}\".\n+                output.push(chr);\n+                state = State::NotArg;\n+            }\n+            (State::MaybeIncorrect, _) => {\n+                // Error in the string.\n+                return Err(());\n+            }\n+            // Escaped braces `{{`\n+            (State::MaybeArg, '{') => {\n+                output.push(chr);\n+                state = State::NotArg;\n+            }\n+            (State::MaybeArg, '}') => {\n+                // This is an empty sequence '{}'.\n+                output.push(chr);\n+                extracted_expressions.push(Arg::Placeholder);\n+                state = State::NotArg;\n+            }\n+            (State::MaybeArg, _) => {\n+                if matches!(chr, '\\\\' | '$') {\n+                    current_expr.push('\\\\');\n+                }\n+                current_expr.push(chr);\n+\n+                // While Rust uses the unicode sets of XID_start and XID_continue for Identifiers\n+                // this is probably the best we can do to avoid a false positive\n+                if chr.is_alphabetic() || chr == '_' {\n+                    state = State::Ident;\n+                } else {\n+                    state = State::Expr;\n+                }\n+            }\n+            (State::Ident | State::Expr, '}') => {\n+                if inexpr_open_count == 0 {\n+                    output.push(chr);\n+\n+                    if matches!(state, State::Expr) {\n+                        extracted_expressions.push(Arg::Expr(current_expr.trim().into()));\n+                    } else {\n+                        extracted_expressions.push(Arg::Ident(current_expr.trim().into()));\n+                    }\n+\n+                    current_expr = String::new();\n+                    state = State::NotArg;\n+                } else {\n+                    // We're closing one brace met before inside of the expression.\n+                    current_expr.push(chr);\n+                    inexpr_open_count -= 1;\n+                }\n+            }\n+            (State::Ident | State::Expr, ':') if matches!(chars.peek(), Some(':')) => {\n+                // path separator\n+                state = State::Expr;\n+                current_expr.push_str(\"::\");\n+                chars.next();\n+            }\n+            (State::Ident | State::Expr, ':') => {\n+                if inexpr_open_count == 0 {\n+                    // We're outside of braces, thus assume that it's a specifier, like \"{Some(value):?}\"\n+                    output.push(chr);\n+\n+                    if matches!(state, State::Expr) {\n+                        extracted_expressions.push(Arg::Expr(current_expr.trim().into()));\n+                    } else {\n+                        extracted_expressions.push(Arg::Ident(current_expr.trim().into()));\n+                    }\n+\n+                    current_expr = String::new();\n+                    state = State::FormatOpts;\n+                } else {\n+                    // We're inside of braced expression, assume that it's a struct field name/value delimiter.\n+                    current_expr.push(chr);\n+                }\n+            }\n+            (State::Ident | State::Expr, '{') => {\n+                state = State::Expr;\n+                current_expr.push(chr);\n+                inexpr_open_count += 1;\n+            }\n+            (State::Ident | State::Expr, _) => {\n+                if !(chr.is_alphanumeric() || chr == '_' || chr == '#') {\n+                    state = State::Expr;\n+                }\n+\n+                if matches!(chr, '\\\\' | '$') {\n+                    current_expr.push('\\\\');\n+                }\n+                current_expr.push(chr);\n+            }\n+            (State::FormatOpts, '}') => {\n+                output.push(chr);\n+                state = State::NotArg;\n+            }\n+            (State::FormatOpts, _) => {\n+                if matches!(chr, '\\\\' | '$') {\n+                    output.push('\\\\');\n+                }\n+                output.push(chr);\n+            }\n+        }\n+    }\n+\n+    if state != State::NotArg {\n+        return Err(());\n+    }\n+\n+    Ok((output, extracted_expressions))\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use expect_test::{expect, Expect};\n+\n+    fn check(input: &str, expect: &Expect) {\n+        let (output, exprs) = parse_format_exprs(input).unwrap_or((\"-\".to_string(), vec![]));\n+        let outcome_repr = if !exprs.is_empty() {\n+            format!(\"{}; {}\", output, with_placeholders(exprs).join(\", \"))\n+        } else {\n+            output\n+        };\n+\n+        expect.assert_eq(&outcome_repr);\n+    }\n+\n+    #[test]\n+    fn format_str_parser() {\n+        let test_vector = &[\n+            (\"no expressions\", expect![[\"no expressions\"]]),\n+            (r\"no expressions with \\$0$1\", expect![r\"no expressions with \\\\\\$0\\$1\"]),\n+            (\"{expr} is {2 + 2}\", expect![[\"{} is {}; expr, 2 + 2\"]]),\n+            (\"{expr:?}\", expect![[\"{:?}; expr\"]]),\n+            (\"{expr:1$}\", expect![[r\"{:1\\$}; expr\"]]),\n+            (\"{$0}\", expect![[r\"{}; \\$0\"]]),\n+            (\"{malformed\", expect![[\"-\"]]),\n+            (\"malformed}\", expect![[\"-\"]]),\n+            (\"{{correct\", expect![[\"{{correct\"]]),\n+            (\"correct}}\", expect![[\"correct}}\"]]),\n+            (\"{correct}}}\", expect![[\"{}}}; correct\"]]),\n+            (\"{correct}}}}}\", expect![[\"{}}}}}; correct\"]]),\n+            (\"{incorrect}}\", expect![[\"-\"]]),\n+            (\"placeholders {} {}\", expect![[\"placeholders {} {}; $1, $2\"]]),\n+            (\"mixed {} {2 + 2} {}\", expect![[\"mixed {} {} {}; $1, 2 + 2, $2\"]]),\n+            (\n+                \"{SomeStruct { val_a: 0, val_b: 1 }}\",\n+                expect![[\"{}; SomeStruct { val_a: 0, val_b: 1 }\"]],\n+            ),\n+            (\"{expr:?} is {2.32f64:.5}\", expect![[\"{:?} is {:.5}; expr, 2.32f64\"]]),\n+            (\n+                \"{SomeStruct { val_a: 0, val_b: 1 }:?}\",\n+                expect![[\"{:?}; SomeStruct { val_a: 0, val_b: 1 }\"]],\n+            ),\n+            (\"{     2 + 2        }\", expect![[\"{}; 2 + 2\"]]),\n+            (\"{strsim::jaro_winkle(a)}\", expect![[\"{}; strsim::jaro_winkle(a)\"]]),\n+            (\"{foo::bar::baz()}\", expect![[\"{}; foo::bar::baz()\"]]),\n+            (\"{foo::bar():?}\", expect![[\"{:?}; foo::bar()\"]]),\n+        ];\n+\n+        for (input, output) in test_vector {\n+            check(input, output)\n+        }\n+    }\n+\n+    #[test]\n+    fn arg_type() {\n+        assert_eq!(\n+            parse_format_exprs(\"{_ident} {r#raw_ident} {expr.obj} {name {thing: 42} } {}\")\n+                .unwrap()\n+                .1,\n+            vec![\n+                Arg::Ident(\"_ident\".to_owned()),\n+                Arg::Ident(\"r#raw_ident\".to_owned()),\n+                Arg::Expr(\"expr.obj\".to_owned()),\n+                Arg::Expr(\"name {thing: 42}\".to_owned()),\n+                Arg::Placeholder\n+            ]\n+        );\n+    }\n+}"}, {"sha": "3034295196b42a32a26882259e2338facaa52cc6", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/json_is_not_rust.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fjson_is_not_rust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fjson_is_not_rust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fjson_is_not_rust.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -137,6 +137,7 @@ pub(crate) fn json_in_items(\n                                         sema.db,\n                                         it,\n                                         config.insert_use.prefix_kind,\n+                                        config.prefer_no_std,\n                                     ) {\n                                         insert_use(\n                                             &scope,\n@@ -152,6 +153,7 @@ pub(crate) fn json_in_items(\n                                         sema.db,\n                                         it,\n                                         config.insert_use.prefix_kind,\n+                                        config.prefer_no_std,\n                                     ) {\n                                         insert_use(\n                                             &scope,"}, {"sha": "7f140eb6a74a6223dbdf26da59289184e1354e75", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/missing_fields.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -124,6 +124,7 @@ fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::MissingFields) -> Option<Vec<Ass\n                         let type_path = current_module?.find_use_path(\n                             ctx.sema.db,\n                             item_for_path_search(ctx.sema.db, item_in_ns)?,\n+                            ctx.config.prefer_no_std,\n                         )?;\n \n                         use_trivial_constructor("}, {"sha": "62c69f90baa4f9f55b1b15bcb827f67883c3f1cd", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/type_mismatch.rs", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -59,9 +59,6 @@ fn add_reference(\n     d: &hir::TypeMismatch,\n     acc: &mut Vec<Assist>,\n ) -> Option<()> {\n-    let root = ctx.sema.db.parse_or_expand(d.expr.file_id)?;\n-    let expr_node = d.expr.value.to_node(&root);\n-\n     let range = ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range;\n \n     let (_, mutability) = d.expected.as_reference()?;\n@@ -72,7 +69,7 @@ fn add_reference(\n \n     let ampersands = format!(\"&{}\", mutability.as_keyword_for_ref());\n \n-    let edit = TextEdit::insert(expr_node.syntax().text_range().start(), ampersands);\n+    let edit = TextEdit::insert(range.start(), ampersands);\n     let source_change =\n         SourceChange::from_text_edit(d.expr.file_id.original_file(ctx.sema.db), edit);\n     acc.push(fix(\"add_reference_here\", \"Add reference here\", source_change, range));\n@@ -314,6 +311,34 @@ fn main() {\n         );\n     }\n \n+    #[test]\n+    fn test_add_reference_to_macro_call() {\n+        check_fix(\n+            r#\"\n+macro_rules! thousand {\n+    () => {\n+        1000_u64\n+    };\n+}\n+fn test(foo: &u64) {}\n+fn main() {\n+    test($0thousand!());\n+}\n+            \"#,\n+            r#\"\n+macro_rules! thousand {\n+    () => {\n+        1000_u64\n+    };\n+}\n+fn test(foo: &u64) {}\n+fn main() {\n+    test(&thousand!());\n+}\n+            \"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_add_mutable_reference_to_let_stmt() {\n         check_fix("}, {"sha": "ae299f0584148937c64b897e7cf658359a5c7069", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Flib.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -150,6 +150,7 @@ pub struct DiagnosticsConfig {\n     pub expr_fill_default: ExprFillDefaultMode,\n     // FIXME: We may want to include a whole `AssistConfig` here\n     pub insert_use: InsertUseConfig,\n+    pub prefer_no_std: bool,\n }\n \n impl DiagnosticsConfig {\n@@ -170,6 +171,7 @@ impl DiagnosticsConfig {\n                 group: false,\n                 skip_glob_imports: false,\n             },\n+            prefer_no_std: false,\n         }\n     }\n }"}, {"sha": "57b5ab6abda6936f281eaf5315854261cd4d0e7b", "filename": "src/tools/rust-analyzer/crates/ide-ssr/src/matching.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2Fsrc%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2Fsrc%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2Fsrc%2Fmatching.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -648,9 +648,10 @@ impl Match {\n             .module();\n         for (path, resolved_path) in &template.resolved_paths {\n             if let hir::PathResolution::Def(module_def) = resolved_path.resolution {\n-                let mod_path = module.find_use_path(sema.db, module_def).ok_or_else(|| {\n-                    match_error!(\"Failed to render template path `{}` at match location\")\n-                })?;\n+                let mod_path =\n+                    module.find_use_path(sema.db, module_def, false).ok_or_else(|| {\n+                        match_error!(\"Failed to render template path `{}` at match location\")\n+                    })?;\n                 self.rendered_template_paths.insert(path.clone(), mod_path);\n             }\n         }"}, {"sha": "bfbe0db6e4b84f3c579a376cd9ca40faa2cade2c", "filename": "src/tools/rust-analyzer/crates/ide/src/annotations.rs", "status": "modified", "additions": 75, "deletions": 18, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fannotations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fannotations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fannotations.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -41,6 +41,12 @@ pub struct AnnotationConfig {\n     pub annotate_references: bool,\n     pub annotate_method_references: bool,\n     pub annotate_enum_variant_references: bool,\n+    pub location: AnnotationLocation,\n+}\n+\n+pub enum AnnotationLocation {\n+    AboveName,\n+    AboveWholeItem,\n }\n \n pub(crate) fn annotations(\n@@ -65,10 +71,10 @@ pub(crate) fn annotations(\n     visit_file_defs(&Semantics::new(db), file_id, &mut |def| {\n         let range = match def {\n             Definition::Const(konst) if config.annotate_references => {\n-                konst.source(db).and_then(|node| name_range(db, node, file_id))\n+                konst.source(db).and_then(|node| name_range(db, config, node, file_id))\n             }\n             Definition::Trait(trait_) if config.annotate_references || config.annotate_impls => {\n-                trait_.source(db).and_then(|node| name_range(db, node, file_id))\n+                trait_.source(db).and_then(|node| name_range(db, config, node, file_id))\n             }\n             Definition::Adt(adt) => match adt {\n                 hir::Adt::Enum(enum_) => {\n@@ -77,7 +83,9 @@ pub(crate) fn annotations(\n                             .variants(db)\n                             .into_iter()\n                             .map(|variant| {\n-                                variant.source(db).and_then(|node| name_range(db, node, file_id))\n+                                variant\n+                                    .source(db)\n+                                    .and_then(|node| name_range(db, config, node, file_id))\n                             })\n                             .flatten()\n                             .for_each(|range| {\n@@ -88,14 +96,14 @@ pub(crate) fn annotations(\n                             })\n                     }\n                     if config.annotate_references || config.annotate_impls {\n-                        enum_.source(db).and_then(|node| name_range(db, node, file_id))\n+                        enum_.source(db).and_then(|node| name_range(db, config, node, file_id))\n                     } else {\n                         None\n                     }\n                 }\n                 _ => {\n                     if config.annotate_references || config.annotate_impls {\n-                        adt.source(db).and_then(|node| name_range(db, node, file_id))\n+                        adt.source(db).and_then(|node| name_range(db, config, node, file_id))\n                     } else {\n                         None\n                     }\n@@ -113,6 +121,7 @@ pub(crate) fn annotations(\n             annotations\n                 .push(Annotation { range, kind: AnnotationKind::HasImpls { file_id, data: None } });\n         }\n+\n         if config.annotate_references {\n             annotations.push(Annotation {\n                 range,\n@@ -122,12 +131,18 @@ pub(crate) fn annotations(\n \n         fn name_range<T: HasName>(\n             db: &RootDatabase,\n+            config: &AnnotationConfig,\n             node: InFile<T>,\n             source_file_id: FileId,\n         ) -> Option<TextRange> {\n             if let Some(InFile { file_id, value }) = node.original_ast_node(db) {\n                 if file_id == source_file_id.into() {\n-                    return value.name().map(|it| it.syntax().text_range());\n+                    return match config.location {\n+                        AnnotationLocation::AboveName => {\n+                            value.name().map(|name| name.syntax().text_range())\n+                        }\n+                        AnnotationLocation::AboveWholeItem => Some(value.syntax().text_range()),\n+                    };\n                 }\n             }\n             None\n@@ -188,21 +203,23 @@ mod tests {\n \n     use crate::{fixture, Annotation, AnnotationConfig};\n \n-    fn check(ra_fixture: &str, expect: Expect) {\n+    use super::AnnotationLocation;\n+\n+    const DEFAULT_CONFIG: AnnotationConfig = AnnotationConfig {\n+        binary_target: true,\n+        annotate_runnables: true,\n+        annotate_impls: true,\n+        annotate_references: true,\n+        annotate_method_references: true,\n+        annotate_enum_variant_references: true,\n+        location: AnnotationLocation::AboveName,\n+    };\n+\n+    fn check_with_config(ra_fixture: &str, expect: Expect, config: &AnnotationConfig) {\n         let (analysis, file_id) = fixture::file(ra_fixture);\n \n         let annotations: Vec<Annotation> = analysis\n-            .annotations(\n-                &AnnotationConfig {\n-                    binary_target: true,\n-                    annotate_runnables: true,\n-                    annotate_impls: true,\n-                    annotate_references: true,\n-                    annotate_method_references: true,\n-                    annotate_enum_variant_references: true,\n-                },\n-                file_id,\n-            )\n+            .annotations(config, file_id)\n             .unwrap()\n             .into_iter()\n             .map(|annotation| analysis.resolve_annotation(annotation).unwrap())\n@@ -211,6 +228,10 @@ mod tests {\n         expect.assert_debug_eq(&annotations);\n     }\n \n+    fn check(ra_fixture: &str, expect: Expect) {\n+        check_with_config(ra_fixture, expect, &DEFAULT_CONFIG);\n+    }\n+\n     #[test]\n     fn const_annotations() {\n         check(\n@@ -786,4 +807,40 @@ m!();\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn test_annotations_appear_above_whole_item_when_configured_to_do_so() {\n+        check_with_config(\n+            r#\"\n+/// This is a struct named Foo, obviously.\n+#[derive(Clone)]\n+struct Foo;\n+\"#,\n+            expect![[r#\"\n+                [\n+                    Annotation {\n+                        range: 0..71,\n+                        kind: HasImpls {\n+                            file_id: FileId(\n+                                0,\n+                            ),\n+                            data: Some(\n+                                [],\n+                            ),\n+                        },\n+                    },\n+                    Annotation {\n+                        range: 0..71,\n+                        kind: HasReferences {\n+                            file_id: FileId(\n+                                0,\n+                            ),\n+                            data: None,\n+                        },\n+                    },\n+                ]\n+            \"#]],\n+            &AnnotationConfig { location: AnnotationLocation::AboveWholeItem, ..DEFAULT_CONFIG },\n+        );\n+    }\n }"}, {"sha": "1bdd626f1e834cbec0c8437639d46b130988c55d", "filename": "src/tools/rust-analyzer/crates/ide/src/highlight_related.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -377,6 +377,7 @@ mod tests {\n                         match it {\n                             ReferenceCategory::Read => \"read\",\n                             ReferenceCategory::Write => \"write\",\n+                            ReferenceCategory::Import => \"import\",\n                         }\n                         .to_string()\n                     }),\n@@ -423,20 +424,20 @@ struct Foo;\n         check(\n             r#\"\n use crate$0;\n-  //^^^^^\n+  //^^^^^ import\n use self;\n-  //^^^^\n+  //^^^^ import\n mod __ {\n     use super;\n-      //^^^^^\n+      //^^^^^ import\n }\n \"#,\n         );\n         check(\n             r#\"\n //- /main.rs crate:main deps:lib\n use lib$0;\n-  //^^^\n+  //^^^ import\n //- /lib.rs crate:lib\n \"#,\n         );\n@@ -450,7 +451,7 @@ use lib$0;\n mod foo;\n //- /foo.rs\n use self$0;\n- // ^^^^\n+ // ^^^^ import\n \"#,\n         );\n     }"}, {"sha": "93fcd7cad7a18e976a5a0ea98f389ac4aa02b8ba", "filename": "src/tools/rust-analyzer/crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -1687,6 +1687,74 @@ fn main() {\n         );\n     }\n \n+    #[test]\n+    fn iterator_hint_regression_issue_12674() {\n+        // Ensure we don't crash while solving the projection type of iterators.\n+        check_expect(\n+            InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG },\n+            r#\"\n+//- minicore: iterators\n+struct S<T>(T);\n+impl<T> S<T> {\n+    fn iter(&self) -> Iter<'_, T> { loop {} }\n+}\n+struct Iter<'a, T: 'a>(&'a T);\n+impl<'a, T> Iterator for Iter<'a, T> {\n+    type Item = &'a T;\n+    fn next(&mut self) -> Option<Self::Item> { loop {} }\n+}\n+struct Container<'a> {\n+    elements: S<&'a str>,\n+}\n+struct SliceIter<'a, T>(&'a T);\n+impl<'a, T> Iterator for SliceIter<'a, T> {\n+    type Item = &'a T;\n+    fn next(&mut self) -> Option<Self::Item> { loop {} }\n+}\n+\n+fn main(a: SliceIter<'_, Container>) {\n+    a\n+    .filter_map(|c| Some(c.elements.iter().filter_map(|v| Some(v))))\n+    .map(|e| e);\n+}\n+            \"#,\n+            expect![[r#\"\n+                [\n+                    InlayHint {\n+                        range: 484..554,\n+                        kind: ChainingHint,\n+                        label: [\n+                            \"impl Iterator<Item = impl Iterator<Item = &&str>>\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                484..554,\n+                            ),\n+                        ),\n+                    },\n+                    InlayHint {\n+                        range: 484..485,\n+                        kind: ChainingHint,\n+                        label: [\n+                            \"SliceIter<Container>\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                484..485,\n+                            ),\n+                        ),\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n+\n     #[test]\n     fn infer_call_method_return_associated_types_with_generic() {\n         check_types("}, {"sha": "c1ef25b592b1be4e2aebc8c3a6b719f7c3c27db3", "filename": "src/tools/rust-analyzer/crates/ide/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Flib.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -74,7 +74,7 @@ use syntax::SourceFile;\n use crate::navigation_target::{ToNav, TryToNav};\n \n pub use crate::{\n-    annotations::{Annotation, AnnotationConfig, AnnotationKind},\n+    annotations::{Annotation, AnnotationConfig, AnnotationKind, AnnotationLocation},\n     call_hierarchy::CallItem,\n     expand_macro::ExpandedMacro,\n     file_structure::{StructureNode, StructureNodeKind},"}, {"sha": "e942413c11057ed40810a518b85eb0dcf641ea7c", "filename": "src/tools/rust-analyzer/crates/ide/src/references.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Freferences.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -742,7 +742,7 @@ pub struct Foo {\n             expect![[r#\"\n                 foo Module FileId(0) 0..8 4..7\n \n-                FileId(0) 14..17\n+                FileId(0) 14..17 Import\n             \"#]],\n         );\n     }\n@@ -760,7 +760,7 @@ use self$0;\n             expect![[r#\"\n                 foo Module FileId(0) 0..8 4..7\n \n-                FileId(1) 4..8\n+                FileId(1) 4..8 Import\n             \"#]],\n         );\n     }\n@@ -775,7 +775,7 @@ use self$0;\n             expect![[r#\"\n                 Module FileId(0) 0..10\n \n-                FileId(0) 4..8\n+                FileId(0) 4..8 Import\n             \"#]],\n         );\n     }\n@@ -803,7 +803,7 @@ pub(super) struct Foo$0 {\n             expect![[r#\"\n                 Foo Struct FileId(2) 0..41 18..21\n \n-                FileId(1) 20..23\n+                FileId(1) 20..23 Import\n                 FileId(1) 47..50\n             \"#]],\n         );\n@@ -966,7 +966,7 @@ fn g() { f(); }\n             expect![[r#\"\n                 f Function FileId(0) 22..31 25..26\n \n-                FileId(1) 11..12\n+                FileId(1) 11..12 Import\n                 FileId(1) 24..25\n             \"#]],\n         );\n@@ -1424,9 +1424,9 @@ pub use level1::Foo;\n             expect![[r#\"\n                 Foo Struct FileId(0) 0..15 11..14\n \n-                FileId(1) 16..19\n-                FileId(2) 16..19\n-                FileId(3) 16..19\n+                FileId(1) 16..19 Import\n+                FileId(2) 16..19 Import\n+                FileId(3) 16..19 Import\n             \"#]],\n         );\n     }\n@@ -1454,7 +1454,7 @@ lib::foo!();\n             expect![[r#\"\n                 foo Macro FileId(1) 0..61 29..32\n \n-                FileId(0) 46..49\n+                FileId(0) 46..49 Import\n                 FileId(2) 0..3\n                 FileId(3) 5..8\n             \"#]],\n@@ -1617,7 +1617,7 @@ struct Foo;\n             expect![[r#\"\n                 derive_identity Derive FileId(2) 1..107 45..60\n \n-                FileId(0) 17..31\n+                FileId(0) 17..31 Import\n                 FileId(0) 56..70\n             \"#]],\n         );"}, {"sha": "139a8cb8cbe589b9e586cdf6c8c0f94c36126e54", "filename": "src/tools/rust-analyzer/crates/mbe/src/expander/matcher.rs", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -203,17 +203,16 @@ impl BindingsBuilder {\n     }\n \n     fn build(self, idx: &BindingsIdx) -> Bindings {\n-        let mut bindings = Bindings::default();\n-        self.build_inner(&mut bindings, &self.nodes[idx.0]);\n-        bindings\n+        self.build_inner(&self.nodes[idx.0])\n     }\n \n-    fn build_inner(&self, bindings: &mut Bindings, link_nodes: &[LinkNode<Rc<BindingKind>>]) {\n+    fn build_inner(&self, link_nodes: &[LinkNode<Rc<BindingKind>>]) -> Bindings {\n+        let mut bindings = Bindings::default();\n         let mut nodes = Vec::new();\n         self.collect_nodes(link_nodes, &mut nodes);\n \n         for cmd in nodes {\n-            match &**cmd {\n+            match cmd {\n                 BindingKind::Empty(name) => {\n                     bindings.push_empty(name);\n                 }\n@@ -246,13 +245,15 @@ impl BindingsBuilder {\n                 }\n             }\n         }\n+\n+        bindings\n     }\n \n     fn collect_nested_ref<'a>(\n         &'a self,\n         id: usize,\n         len: usize,\n-        nested_refs: &mut Vec<&'a Vec<LinkNode<Rc<BindingKind>>>>,\n+        nested_refs: &mut Vec<&'a [LinkNode<Rc<BindingKind>>]>,\n     ) {\n         self.nested[id].iter().take(len).for_each(|it| match it {\n             LinkNode::Node(id) => nested_refs.push(&self.nodes[*id]),\n@@ -262,26 +263,16 @@ impl BindingsBuilder {\n \n     fn collect_nested(&self, idx: usize, nested_idx: usize, nested: &mut Vec<Bindings>) {\n         let last = &self.nodes[idx];\n-        let mut nested_refs = Vec::new();\n+        let mut nested_refs: Vec<&[_]> = Vec::new();\n         self.nested[nested_idx].iter().for_each(|it| match *it {\n             LinkNode::Node(idx) => nested_refs.push(&self.nodes[idx]),\n             LinkNode::Parent { idx, len } => self.collect_nested_ref(idx, len, &mut nested_refs),\n         });\n         nested_refs.push(last);\n-\n-        nested_refs.into_iter().for_each(|iter| {\n-            let mut child_bindings = Bindings::default();\n-            self.build_inner(&mut child_bindings, iter);\n-            nested.push(child_bindings)\n-        })\n+        nested.extend(nested_refs.into_iter().map(|iter| self.build_inner(iter)));\n     }\n \n-    fn collect_nodes_ref<'a>(\n-        &'a self,\n-        id: usize,\n-        len: usize,\n-        nodes: &mut Vec<&'a Rc<BindingKind>>,\n-    ) {\n+    fn collect_nodes_ref<'a>(&'a self, id: usize, len: usize, nodes: &mut Vec<&'a BindingKind>) {\n         self.nodes[id].iter().take(len).for_each(|it| match it {\n             LinkNode::Node(it) => nodes.push(it),\n             LinkNode::Parent { idx, len } => self.collect_nodes_ref(*idx, *len, nodes),\n@@ -291,7 +282,7 @@ impl BindingsBuilder {\n     fn collect_nodes<'a>(\n         &'a self,\n         link_nodes: &'a [LinkNode<Rc<BindingKind>>],\n-        nodes: &mut Vec<&'a Rc<BindingKind>>,\n+        nodes: &mut Vec<&'a BindingKind>,\n     ) {\n         link_nodes.iter().for_each(|it| match it {\n             LinkNode::Node(it) => nodes.push(it),\n@@ -386,10 +377,10 @@ fn match_loop_inner<'t>(\n         let op = match item.dot.peek() {\n             None => {\n                 // We are at or past the end of the matcher of `item`.\n-                if item.up.is_some() {\n+                if let Some(up) = &item.up {\n                     if item.sep_parsed.is_none() {\n                         // Get the `up` matcher\n-                        let mut new_pos = *item.up.clone().unwrap();\n+                        let mut new_pos = (**up).clone();\n                         new_pos.bindings = bindings_builder.copy(&new_pos.bindings);\n                         // Add matches from this repetition to the `matches` of `up`\n                         bindings_builder.push_nested(&mut new_pos.bindings, &item.bindings);\n@@ -402,7 +393,7 @@ fn match_loop_inner<'t>(\n \n                     // Check if we need a separator.\n                     // We check the separator one by one\n-                    let sep_idx = *item.sep_parsed.as_ref().unwrap_or(&0);\n+                    let sep_idx = item.sep_parsed.unwrap_or(0);\n                     let sep_len = item.sep.as_ref().map_or(0, Separator::tt_count);\n                     if item.sep.is_some() && sep_idx != sep_len {\n                         let sep = item.sep.as_ref().unwrap();"}, {"sha": "837ea016193cdc4f6f22f80c65a27ebcd7bbc7d9", "filename": "src/tools/rust-analyzer/crates/project-model/src/build_scripts.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -43,10 +43,12 @@ impl WorkspaceBuildScripts {\n         if let Some([program, args @ ..]) = config.run_build_script_command.as_deref() {\n             let mut cmd = Command::new(program);\n             cmd.args(args);\n+            cmd.envs(&config.extra_env);\n             return cmd;\n         }\n \n         let mut cmd = Command::new(toolchain::cargo());\n+        cmd.envs(&config.extra_env);\n \n         cmd.args(&[\"check\", \"--quiet\", \"--workspace\", \"--message-format=json\"]);\n "}, {"sha": "736d80041bd5115ac5bc3701f6549ea6feb35e52", "filename": "src/tools/rust-analyzer/crates/project-model/src/cargo_workspace.rs", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -2,6 +2,7 @@\n \n use std::iter;\n use std::path::PathBuf;\n+use std::str::from_utf8;\n use std::{ops, process::Command};\n \n use anyhow::{Context, Result};\n@@ -98,6 +99,8 @@ pub struct CargoConfig {\n     pub wrap_rustc_in_build_scripts: bool,\n \n     pub run_build_script_command: Option<Vec<String>>,\n+\n+    pub extra_env: FxHashMap<String, String>,\n }\n \n impl CargoConfig {\n@@ -263,8 +266,8 @@ impl CargoWorkspace {\n         let target = config\n             .target\n             .clone()\n-            .or_else(|| cargo_config_build_target(cargo_toml))\n-            .or_else(|| rustc_discover_host_triple(cargo_toml));\n+            .or_else(|| cargo_config_build_target(cargo_toml, config))\n+            .or_else(|| rustc_discover_host_triple(cargo_toml, config));\n \n         let mut meta = MetadataCommand::new();\n         meta.cargo_path(toolchain::cargo());\n@@ -292,8 +295,27 @@ impl CargoWorkspace {\n         // unclear whether cargo itself supports it.\n         progress(\"metadata\".to_string());\n \n-        let meta =\n-            meta.exec().with_context(|| format!(\"Failed to run `{:?}`\", meta.cargo_command()))?;\n+        fn exec_with_env(\n+            command: &cargo_metadata::MetadataCommand,\n+            extra_env: &FxHashMap<String, String>,\n+        ) -> Result<cargo_metadata::Metadata, cargo_metadata::Error> {\n+            let mut command = command.cargo_command();\n+            command.envs(extra_env);\n+            let output = command.output()?;\n+            if !output.status.success() {\n+                return Err(cargo_metadata::Error::CargoMetadata {\n+                    stderr: String::from_utf8(output.stderr)?,\n+                });\n+            }\n+            let stdout = from_utf8(&output.stdout)?\n+                .lines()\n+                .find(|line| line.starts_with('{'))\n+                .ok_or(cargo_metadata::Error::NoJson)?;\n+            cargo_metadata::MetadataCommand::parse(stdout)\n+        }\n+\n+        let meta = exec_with_env(&meta, &config.extra_env)\n+            .with_context(|| format!(\"Failed to run `{:?}`\", meta.cargo_command()))?;\n \n         Ok(meta)\n     }\n@@ -463,8 +485,9 @@ impl CargoWorkspace {\n     }\n }\n \n-fn rustc_discover_host_triple(cargo_toml: &ManifestPath) -> Option<String> {\n+fn rustc_discover_host_triple(cargo_toml: &ManifestPath, config: &CargoConfig) -> Option<String> {\n     let mut rustc = Command::new(toolchain::rustc());\n+    rustc.envs(&config.extra_env);\n     rustc.current_dir(cargo_toml.parent()).arg(\"-vV\");\n     tracing::debug!(\"Discovering host platform by {:?}\", rustc);\n     match utf8_stdout(rustc) {\n@@ -486,8 +509,9 @@ fn rustc_discover_host_triple(cargo_toml: &ManifestPath) -> Option<String> {\n     }\n }\n \n-fn cargo_config_build_target(cargo_toml: &ManifestPath) -> Option<String> {\n+fn cargo_config_build_target(cargo_toml: &ManifestPath, config: &CargoConfig) -> Option<String> {\n     let mut cargo_config = Command::new(toolchain::cargo());\n+    cargo_config.envs(&config.extra_env);\n     cargo_config\n         .current_dir(cargo_toml.parent())\n         .args(&[\"-Z\", \"unstable-options\", \"config\", \"get\", \"build.target\"])"}, {"sha": "486cb143b80bd22678fa584a6aedacd14529e9d8", "filename": "src/tools/rust-analyzer/crates/project-model/src/rustc_cfg.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Frustc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Frustc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Frustc_cfg.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -4,9 +4,13 @@ use std::process::Command;\n \n use anyhow::Result;\n \n-use crate::{cfg_flag::CfgFlag, utf8_stdout, ManifestPath};\n+use crate::{cfg_flag::CfgFlag, utf8_stdout, CargoConfig, ManifestPath};\n \n-pub(crate) fn get(cargo_toml: Option<&ManifestPath>, target: Option<&str>) -> Vec<CfgFlag> {\n+pub(crate) fn get(\n+    cargo_toml: Option<&ManifestPath>,\n+    target: Option<&str>,\n+    config: &CargoConfig,\n+) -> Vec<CfgFlag> {\n     let _p = profile::span(\"rustc_cfg::get\");\n     let mut res = Vec::with_capacity(6 * 2 + 1);\n \n@@ -18,7 +22,7 @@ pub(crate) fn get(cargo_toml: Option<&ManifestPath>, target: Option<&str>) -> Ve\n         }\n     }\n \n-    match get_rust_cfgs(cargo_toml, target) {\n+    match get_rust_cfgs(cargo_toml, target, config) {\n         Ok(rustc_cfgs) => {\n             tracing::debug!(\n                 \"rustc cfgs found: {:?}\",\n@@ -35,9 +39,14 @@ pub(crate) fn get(cargo_toml: Option<&ManifestPath>, target: Option<&str>) -> Ve\n     res\n }\n \n-fn get_rust_cfgs(cargo_toml: Option<&ManifestPath>, target: Option<&str>) -> Result<String> {\n+fn get_rust_cfgs(\n+    cargo_toml: Option<&ManifestPath>,\n+    target: Option<&str>,\n+    config: &CargoConfig,\n+) -> Result<String> {\n     if let Some(cargo_toml) = cargo_toml {\n         let mut cargo_config = Command::new(toolchain::cargo());\n+        cargo_config.envs(&config.extra_env);\n         cargo_config\n             .current_dir(cargo_toml.parent())\n             .args(&[\"-Z\", \"unstable-options\", \"rustc\", \"--print\", \"cfg\"])\n@@ -52,6 +61,7 @@ fn get_rust_cfgs(cargo_toml: Option<&ManifestPath>, target: Option<&str>) -> Res\n     }\n     // using unstable cargo features failed, fall back to using plain rustc\n     let mut cmd = Command::new(toolchain::rustc());\n+    cmd.envs(&config.extra_env);\n     cmd.args(&[\"--print\", \"cfg\", \"-O\"]);\n     if let Some(target) = target {\n         cmd.args(&[\"--target\", target]);"}, {"sha": "3282719fef3d7a3d0b1c188487797cb384b24817", "filename": "src/tools/rust-analyzer/crates/project-model/src/sysroot.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fsysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fsysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fsysroot.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -10,7 +10,7 @@ use anyhow::{format_err, Result};\n use la_arena::{Arena, Idx};\n use paths::{AbsPath, AbsPathBuf};\n \n-use crate::{utf8_stdout, ManifestPath};\n+use crate::{utf8_stdout, CargoConfig, ManifestPath};\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct Sysroot {\n@@ -67,18 +67,20 @@ impl Sysroot {\n         self.crates.iter().map(|(id, _data)| id)\n     }\n \n-    pub fn discover(dir: &AbsPath) -> Result<Sysroot> {\n+    pub fn discover(dir: &AbsPath, config: &CargoConfig) -> Result<Sysroot> {\n         tracing::debug!(\"Discovering sysroot for {}\", dir.display());\n-        let sysroot_dir = discover_sysroot_dir(dir)?;\n-        let sysroot_src_dir = discover_sysroot_src_dir(&sysroot_dir, dir)?;\n+        let sysroot_dir = discover_sysroot_dir(dir, config)?;\n+        let sysroot_src_dir = discover_sysroot_src_dir(&sysroot_dir, dir, config)?;\n         let res = Sysroot::load(sysroot_dir, sysroot_src_dir)?;\n         Ok(res)\n     }\n \n-    pub fn discover_rustc(cargo_toml: &ManifestPath) -> Option<ManifestPath> {\n+    pub fn discover_rustc(cargo_toml: &ManifestPath, config: &CargoConfig) -> Option<ManifestPath> {\n         tracing::debug!(\"Discovering rustc source for {}\", cargo_toml.display());\n         let current_dir = cargo_toml.parent();\n-        discover_sysroot_dir(current_dir).ok().and_then(|sysroot_dir| get_rustc_src(&sysroot_dir))\n+        discover_sysroot_dir(current_dir, config)\n+            .ok()\n+            .and_then(|sysroot_dir| get_rustc_src(&sysroot_dir))\n     }\n \n     pub fn load(sysroot_dir: AbsPathBuf, sysroot_src_dir: AbsPathBuf) -> Result<Sysroot> {\n@@ -144,8 +146,9 @@ impl Sysroot {\n     }\n }\n \n-fn discover_sysroot_dir(current_dir: &AbsPath) -> Result<AbsPathBuf> {\n+fn discover_sysroot_dir(current_dir: &AbsPath, config: &CargoConfig) -> Result<AbsPathBuf> {\n     let mut rustc = Command::new(toolchain::rustc());\n+    rustc.envs(&config.extra_env);\n     rustc.current_dir(current_dir).args(&[\"--print\", \"sysroot\"]);\n     tracing::debug!(\"Discovering sysroot by {:?}\", rustc);\n     let stdout = utf8_stdout(rustc)?;\n@@ -155,6 +158,7 @@ fn discover_sysroot_dir(current_dir: &AbsPath) -> Result<AbsPathBuf> {\n fn discover_sysroot_src_dir(\n     sysroot_path: &AbsPathBuf,\n     current_dir: &AbsPath,\n+    config: &CargoConfig,\n ) -> Result<AbsPathBuf> {\n     if let Ok(path) = env::var(\"RUST_SRC_PATH\") {\n         let path = AbsPathBuf::try_from(path.as_str())\n@@ -170,6 +174,7 @@ fn discover_sysroot_src_dir(\n     get_rust_src(sysroot_path)\n         .or_else(|| {\n             let mut rustup = Command::new(toolchain::rustup());\n+            rustup.envs(&config.extra_env);\n             rustup.current_dir(current_dir).args(&[\"component\", \"add\", \"rust-src\"]);\n             utf8_stdout(rustup).ok()?;\n             get_rust_src(sysroot_path)"}, {"sha": "bea624bd54195e73651a0539919a4e80b03a4932", "filename": "src/tools/rust-analyzer/crates/project-model/src/tests.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftests.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -10,8 +10,8 @@ use paths::{AbsPath, AbsPathBuf};\n use serde::de::DeserializeOwned;\n \n use crate::{\n-    CargoWorkspace, CfgOverrides, ProjectJson, ProjectJsonData, ProjectWorkspace, Sysroot,\n-    WorkspaceBuildScripts,\n+    CargoConfig, CargoWorkspace, CfgOverrides, ProjectJson, ProjectJsonData, ProjectWorkspace,\n+    Sysroot, WorkspaceBuildScripts,\n };\n \n fn load_cargo(file: &str) -> CrateGraph {\n@@ -92,13 +92,17 @@ fn rooted_project_json(data: ProjectJsonData) -> ProjectJson {\n }\n \n fn to_crate_graph(project_workspace: ProjectWorkspace) -> CrateGraph {\n-    project_workspace.to_crate_graph(&mut |_, _| Ok(Vec::new()), &mut {\n-        let mut counter = 0;\n-        move |_path| {\n-            counter += 1;\n-            Some(FileId(counter))\n-        }\n-    })\n+    project_workspace.to_crate_graph(\n+        &mut |_, _| Ok(Vec::new()),\n+        &mut {\n+            let mut counter = 0;\n+            move |_path| {\n+                counter += 1;\n+                Some(FileId(counter))\n+            }\n+        },\n+        &CargoConfig::default(),\n+    )\n }\n \n fn check_crate_graph(crate_graph: CrateGraph, expect: Expect) {"}, {"sha": "bc4ab45daeffc80a418711f3f0f03a4c7e8f73c1", "filename": "src/tools/rust-analyzer/crates/project-model/src/workspace.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fworkspace.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -156,11 +156,12 @@ impl ProjectWorkspace {\n                 })?;\n                 let project_location = project_json.parent().to_path_buf();\n                 let project_json = ProjectJson::new(&project_location, data);\n-                ProjectWorkspace::load_inline(project_json, config.target.as_deref())?\n+                ProjectWorkspace::load_inline(project_json, config.target.as_deref(), config)?\n             }\n             ProjectManifest::CargoToml(cargo_toml) => {\n                 let cargo_version = utf8_stdout({\n                     let mut cmd = Command::new(toolchain::cargo());\n+                    cmd.envs(&config.extra_env);\n                     cmd.arg(\"--version\");\n                     cmd\n                 })?;\n@@ -186,7 +187,7 @@ impl ProjectWorkspace {\n                 let sysroot = if config.no_sysroot {\n                     None\n                 } else {\n-                    Some(Sysroot::discover(cargo_toml.parent()).with_context(|| {\n+                    Some(Sysroot::discover(cargo_toml.parent(), config).with_context(|| {\n                         format!(\n                             \"Failed to find sysroot for Cargo.toml file {}. Is rust-src installed?\",\n                             cargo_toml.display()\n@@ -196,7 +197,7 @@ impl ProjectWorkspace {\n \n                 let rustc_dir = match &config.rustc_source {\n                     Some(RustcSource::Path(path)) => ManifestPath::try_from(path.clone()).ok(),\n-                    Some(RustcSource::Discover) => Sysroot::discover_rustc(&cargo_toml),\n+                    Some(RustcSource::Discover) => Sysroot::discover_rustc(&cargo_toml, config),\n                     None => None,\n                 };\n \n@@ -216,7 +217,7 @@ impl ProjectWorkspace {\n                     None => None,\n                 };\n \n-                let rustc_cfg = rustc_cfg::get(Some(&cargo_toml), config.target.as_deref());\n+                let rustc_cfg = rustc_cfg::get(Some(&cargo_toml), config.target.as_deref(), config);\n \n                 let cfg_overrides = config.cfg_overrides();\n                 ProjectWorkspace::Cargo {\n@@ -237,6 +238,7 @@ impl ProjectWorkspace {\n     pub fn load_inline(\n         project_json: ProjectJson,\n         target: Option<&str>,\n+        config: &CargoConfig,\n     ) -> Result<ProjectWorkspace> {\n         let sysroot = match (project_json.sysroot.clone(), project_json.sysroot_src.clone()) {\n             (Some(sysroot), Some(sysroot_src)) => Some(Sysroot::load(sysroot, sysroot_src)?),\n@@ -258,7 +260,7 @@ impl ProjectWorkspace {\n             (None, None) => None,\n         };\n \n-        let rustc_cfg = rustc_cfg::get(None, target);\n+        let rustc_cfg = rustc_cfg::get(None, target, config);\n         Ok(ProjectWorkspace::Json { project: project_json, sysroot, rustc_cfg })\n     }\n \n@@ -268,8 +270,9 @@ impl ProjectWorkspace {\n                 .first()\n                 .and_then(|it| it.parent())\n                 .ok_or_else(|| format_err!(\"No detached files to load\"))?,\n+            &CargoConfig::default(),\n         )?;\n-        let rustc_cfg = rustc_cfg::get(None, None);\n+        let rustc_cfg = rustc_cfg::get(None, None, &CargoConfig::default());\n         Ok(ProjectWorkspace::DetachedFiles { files: detached_files, sysroot, rustc_cfg })\n     }\n \n@@ -416,6 +419,7 @@ impl ProjectWorkspace {\n         &self,\n         load_proc_macro: &mut dyn FnMut(&str, &AbsPath) -> ProcMacroLoadResult,\n         load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n+        config: &CargoConfig,\n     ) -> CrateGraph {\n         let _p = profile::span(\"ProjectWorkspace::to_crate_graph\");\n \n@@ -426,6 +430,7 @@ impl ProjectWorkspace {\n                 load,\n                 project,\n                 sysroot,\n+                config,\n             ),\n             ProjectWorkspace::Cargo {\n                 cargo,\n@@ -464,6 +469,7 @@ fn project_json_to_crate_graph(\n     load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n     project: &ProjectJson,\n     sysroot: &Option<Sysroot>,\n+    config: &CargoConfig,\n ) -> CrateGraph {\n     let mut crate_graph = CrateGraph::default();\n     let sysroot_deps = sysroot\n@@ -489,9 +495,9 @@ fn project_json_to_crate_graph(\n             };\n \n             let target_cfgs = match krate.target.as_deref() {\n-                Some(target) => {\n-                    cfg_cache.entry(target).or_insert_with(|| rustc_cfg::get(None, Some(target)))\n-                }\n+                Some(target) => cfg_cache\n+                    .entry(target)\n+                    .or_insert_with(|| rustc_cfg::get(None, Some(target), config)),\n                 None => &rustc_cfg,\n             };\n "}, {"sha": "80128e43fd3c50f6be8ce8aec7190ff8a4fe9df6", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/analysis_stats.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -80,7 +80,8 @@ impl flags::AnalysisStats {\n             Some(build_scripts_sw.elapsed())\n         };\n \n-        let (host, vfs, _proc_macro) = load_workspace(workspace, &load_cargo_config)?;\n+        let (host, vfs, _proc_macro) =\n+            load_workspace(workspace, &cargo_config, &load_cargo_config)?;\n         let db = host.raw_database();\n         eprint!(\"{:<20} {}\", \"Database loaded:\", db_load_sw.elapsed());\n         eprint!(\" (metadata {}\", metadata_time);"}, {"sha": "88953096e2bcd5fff1e61984085458505319b62a", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -38,7 +38,7 @@ pub fn load_workspace_at(\n         workspace.set_build_scripts(build_scripts)\n     }\n \n-    load_workspace(workspace, load_config)\n+    load_workspace(workspace, cargo_config, load_config)\n }\n \n // Note: Since this function is used by external tools that use rust-analyzer as a library\n@@ -48,6 +48,7 @@ pub fn load_workspace_at(\n // these tools need access to `ProjectWorkspace`, too, which `load_workspace_at` hides.\n pub fn load_workspace(\n     ws: ProjectWorkspace,\n+    cargo_config: &CargoConfig,\n     load_config: &LoadCargoConfig,\n ) -> Result<(AnalysisHost, vfs::Vfs, Option<ProcMacroServer>)> {\n     let (sender, receiver) = unbounded();\n@@ -75,6 +76,7 @@ pub fn load_workspace(\n             vfs.set_file_contents(path.clone(), contents);\n             vfs.file_id(&path)\n         },\n+        cargo_config,\n     );\n \n     let project_folders = ProjectFolders::new(&[ws], &[]);"}, {"sha": "79577bf78c8f9d64096e6754017c19164ead274b", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/lsif.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -299,7 +299,8 @@ impl flags::Lsif {\n \n         let workspace = ProjectWorkspace::load(manifest, &cargo_config, no_progress)?;\n \n-        let (host, vfs, _proc_macro) = load_workspace(workspace, &load_cargo_config)?;\n+        let (host, vfs, _proc_macro) =\n+            load_workspace(workspace, &cargo_config, &load_cargo_config)?;\n         let db = host.raw_database();\n         let analysis = host.analysis();\n "}, {"sha": "05c16bb39e3515960130a7b4d19307ee083be650", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/scip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -40,7 +40,7 @@ impl flags::Scip {\n \n         let workspace = ProjectWorkspace::load(manifest, &cargo_config, no_progress)?;\n \n-        let (host, vfs, _) = load_workspace(workspace, &load_cargo_config)?;\n+        let (host, vfs, _) = load_workspace(workspace, &cargo_config, &load_cargo_config)?;\n         let db = host.raw_database();\n         let analysis = host.analysis();\n "}, {"sha": "9ef79e6f381208c0a09dbcafbef2518751fc1ee5", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 65, "deletions": 2, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -84,6 +84,9 @@ config_data! {\n         /// Use `RUSTC_WRAPPER=rust-analyzer` when running build scripts to\n         /// avoid checking unnecessary things.\n         cargo_buildScripts_useRustcWrapper: bool = \"true\",\n+        /// Extra environment variables that will be set when running cargo, rustc\n+        /// or other commands within the workspace. Useful for setting RUSTFLAGS.\n+        cargo_extraEnv: FxHashMap<String, String> = \"{}\",\n         /// List of features to activate.\n         ///\n         /// Set this to `\"all\"` to pass `--all-features` to cargo.\n@@ -105,6 +108,8 @@ config_data! {\n         checkOnSave_enable: bool                         = \"true\",\n         /// Extra arguments for `cargo check`.\n         checkOnSave_extraArgs: Vec<String>               = \"[]\",\n+        /// Extra environment variables that will be set when running `cargo check`.\n+        checkOnSave_extraEnv: FxHashMap<String, String> = \"{}\",\n         /// List of features to activate. Defaults to\n         /// `#rust-analyzer.cargo.features#`.\n         ///\n@@ -219,7 +224,6 @@ config_data! {\n         files_excludeDirs: Vec<PathBuf> = \"[]\",\n         /// Controls file watching implementation.\n         files_watcher: FilesWatcherDef = \"\\\"client\\\"\",\n-\n         /// Enables highlighting of related references while the cursor is on `break`, `loop`, `while`, or `for` keywords.\n         highlightRelated_breakPoints_enable: bool = \"true\",\n         /// Enables highlighting of all exit points while the cursor is on any `return`, `?`, `fn`, or return type arrow (`->`).\n@@ -263,6 +267,8 @@ config_data! {\n         imports_group_enable: bool                           = \"true\",\n         /// Whether to allow import insertion to merge new imports into single path glob imports like `use std::fmt::*;`.\n         imports_merge_glob: bool           = \"true\",\n+        /// Prefer to unconditionally use imports of the core and alloc crate, over the std crate.\n+        imports_prefer_no_std: bool                     = \"false\",\n         /// The path structure for newly inserted paths to use.\n         imports_prefix: ImportPrefixDef               = \"\\\"plain\\\"\",\n \n@@ -307,6 +313,7 @@ config_data! {\n         /// Join lines unwraps trivial blocks.\n         joinLines_unwrapTrivialBlock: bool = \"true\",\n \n+\n         /// Whether to show `Debug` lens. Only applies when\n         /// `#rust-analyzer.lens.enable#` is set.\n         lens_debug_enable: bool            = \"true\",\n@@ -318,6 +325,8 @@ config_data! {\n         /// Whether to show `Implementations` lens. Only applies when\n         /// `#rust-analyzer.lens.enable#` is set.\n         lens_implementations_enable: bool  = \"true\",\n+        /// Where to render annotations.\n+        lens_location: AnnotationLocation = \"\\\"above_name\\\"\",\n         /// Whether to show `References` lens for Struct, Enum, and Union.\n         /// Only applies when `#rust-analyzer.lens.enable#` is set.\n         lens_references_adt_enable: bool = \"false\",\n@@ -359,6 +368,9 @@ config_data! {\n         /// this is rust-analyzer itself, but we override this in tests).\n         procMacro_server: Option<PathBuf>          = \"null\",\n \n+        /// Exclude imports from find-all-references.\n+        references_excludeImports: bool = \"false\",\n+\n         /// Command to be executed instead of 'cargo' for runnables.\n         runnables_command: Option<String> = \"null\",\n         /// Additional arguments to be passed to cargo for runnables such as\n@@ -494,6 +506,25 @@ pub struct LensConfig {\n     pub refs_adt: bool,   // for Struct, Enum, Union and Trait\n     pub refs_trait: bool, // for Struct, Enum, Union and Trait\n     pub enum_variant_refs: bool,\n+\n+    // annotations\n+    pub location: AnnotationLocation,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Deserialize)]\n+#[serde(rename_all = \"snake_case\")]\n+pub enum AnnotationLocation {\n+    AboveName,\n+    AboveWholeItem,\n+}\n+\n+impl From<AnnotationLocation> for ide::AnnotationLocation {\n+    fn from(location: AnnotationLocation) -> Self {\n+        match location {\n+            AnnotationLocation::AboveName => ide::AnnotationLocation::AboveName,\n+            AnnotationLocation::AboveWholeItem => ide::AnnotationLocation::AboveWholeItem,\n+        }\n+    }\n }\n \n impl LensConfig {\n@@ -918,6 +949,7 @@ impl Config {\n                 ExprFillDefaultDef::Default => ExprFillDefaultMode::Default,\n             },\n             insert_use: self.insert_use_config(),\n+            prefer_no_std: self.data.imports_prefer_no_std,\n         }\n     }\n \n@@ -929,6 +961,16 @@ impl Config {\n         }\n     }\n \n+    pub fn extra_env(&self) -> &FxHashMap<String, String> {\n+        &self.data.cargo_extraEnv\n+    }\n+\n+    pub fn check_on_save_extra_env(&self) -> FxHashMap<String, String> {\n+        let mut extra_env = self.data.cargo_extraEnv.clone();\n+        extra_env.extend(self.data.checkOnSave_extraEnv.clone());\n+        extra_env\n+    }\n+\n     pub fn lru_capacity(&self) -> Option<usize> {\n         self.data.lru_capacity\n     }\n@@ -998,6 +1040,7 @@ impl Config {\n             unset_test_crates: UnsetTestCrates::Only(self.data.cargo_unsetTest.clone()),\n             wrap_rustc_in_build_scripts: self.data.cargo_buildScripts_useRustcWrapper,\n             run_build_script_command: self.data.cargo_buildScripts_overrideCommand.clone(),\n+            extra_env: self.data.cargo_extraEnv.clone(),\n         }\n     }\n \n@@ -1023,7 +1066,11 @@ impl Config {\n             Some(args) if !args.is_empty() => {\n                 let mut args = args.clone();\n                 let command = args.remove(0);\n-                FlycheckConfig::CustomCommand { command, args }\n+                FlycheckConfig::CustomCommand {\n+                    command,\n+                    args,\n+                    extra_env: self.check_on_save_extra_env(),\n+                }\n             }\n             Some(_) | None => FlycheckConfig::CargoCommand {\n                 command: self.data.checkOnSave_command.clone(),\n@@ -1051,6 +1098,7 @@ impl Config {\n                     CargoFeatures::Listed(it) => it,\n                 },\n                 extra_args: self.data.checkOnSave_extraArgs.clone(),\n+                extra_env: self.check_on_save_extra_env(),\n             },\n         };\n         Some(flycheck_config)\n@@ -1133,6 +1181,7 @@ impl Config {\n                 CallableCompletionDef::None => None,\n             },\n             insert_use: self.insert_use_config(),\n+            prefer_no_std: self.data.imports_prefer_no_std,\n             snippet_cap: SnippetCap::new(try_or_def!(\n                 self.caps\n                     .text_document\n@@ -1147,6 +1196,10 @@ impl Config {\n         }\n     }\n \n+    pub fn find_all_refs_exclude_imports(&self) -> bool {\n+        self.data.references_excludeImports\n+    }\n+\n     pub fn snippet_cap(&self) -> bool {\n         self.experimental(\"snippetTextEdit\")\n     }\n@@ -1156,6 +1209,7 @@ impl Config {\n             snippet_cap: SnippetCap::new(self.experimental(\"snippetTextEdit\")),\n             allowed: None,\n             insert_use: self.insert_use_config(),\n+            prefer_no_std: self.data.imports_prefer_no_std,\n         }\n     }\n \n@@ -1185,6 +1239,7 @@ impl Config {\n             refs_trait: self.data.lens_enable && self.data.lens_references_trait_enable,\n             enum_variant_refs: self.data.lens_enable\n                 && self.data.lens_references_enumVariant_enable,\n+            location: self.data.lens_location,\n         }\n     }\n \n@@ -1921,6 +1976,14 @@ fn field_props(field: &str, ty: &str, doc: &[&str], default: &str) -> serde_json\n                 \"Use server-side file watching\",\n             ],\n         },\n+        \"AnnotationLocation\" => set! {\n+            \"type\": \"string\",\n+            \"enum\": [\"above_name\", \"above_whole_item\"],\n+            \"enumDescriptions\": [\n+                \"Render annotations above the name of the item.\",\n+                \"Render annotations above the whole item, including documentation comments and attributes.\"\n+            ],\n+        },\n         _ => panic!(\"missing entry for {}: {}\", ty, default),\n     }\n "}, {"sha": "8c3ea77d0611587c2f7f7b94083f5d4764d0cf6b", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -10,8 +10,8 @@ use std::{\n use anyhow::Context;\n use ide::{\n     AnnotationConfig, AssistKind, AssistResolveStrategy, FileId, FilePosition, FileRange,\n-    HoverAction, HoverGotoTypeData, Query, RangeInfo, Runnable, RunnableKind, SingleResolve,\n-    SourceChange, TextEdit,\n+    HoverAction, HoverGotoTypeData, Query, RangeInfo, ReferenceCategory, Runnable, RunnableKind,\n+    SingleResolve, SourceChange, TextEdit,\n };\n use ide_db::SymbolKind;\n use lsp_server::ErrorCode;\n@@ -1012,6 +1012,8 @@ pub(crate) fn handle_references(\n     let _p = profile::span(\"handle_references\");\n     let position = from_proto::file_position(&snap, params.text_document_position)?;\n \n+    let exclude_imports = snap.config.find_all_refs_exclude_imports();\n+\n     let refs = match snap.analysis.find_all_refs(position, None)? {\n         None => return Ok(None),\n         Some(refs) => refs,\n@@ -1032,7 +1034,11 @@ pub(crate) fn handle_references(\n             refs.references\n                 .into_iter()\n                 .flat_map(|(file_id, refs)| {\n-                    refs.into_iter().map(move |(range, _)| FileRange { file_id, range })\n+                    refs.into_iter()\n+                        .filter(|&(_, category)| {\n+                            !exclude_imports || category != Some(ReferenceCategory::Import)\n+                        })\n+                        .map(move |(range, _)| FileRange { file_id, range })\n                 })\n                 .chain(decl)\n         })\n@@ -1234,6 +1240,7 @@ pub(crate) fn handle_code_lens(\n             annotate_references: lens_config.refs_adt,\n             annotate_method_references: lens_config.method_refs,\n             annotate_enum_variant_references: lens_config.enum_variant_refs,\n+            location: lens_config.location.into(),\n         },\n         file_id,\n     )?;\n@@ -1283,7 +1290,7 @@ pub(crate) fn handle_document_highlight(\n         .into_iter()\n         .map(|ide::HighlightedRange { range, category }| lsp_types::DocumentHighlight {\n             range: to_proto::range(&line_index, range),\n-            kind: category.map(to_proto::document_highlight_kind),\n+            kind: category.and_then(to_proto::document_highlight_kind),\n         })\n         .collect();\n     Ok(Some(res))\n@@ -1782,6 +1789,7 @@ fn run_rustfmt(\n     let mut command = match snap.config.rustfmt() {\n         RustfmtConfig::Rustfmt { extra_args, enable_range_formatting } => {\n             let mut cmd = process::Command::new(toolchain::rustfmt());\n+            cmd.envs(snap.config.extra_env());\n             cmd.args(extra_args);\n             // try to chdir to the file so we can respect `rustfmt.toml`\n             // FIXME: use `rustfmt --config-path` once\n@@ -1839,6 +1847,7 @@ fn run_rustfmt(\n         }\n         RustfmtConfig::CustomCommand { command, args } => {\n             let mut cmd = process::Command::new(command);\n+            cmd.envs(snap.config.extra_env());\n             cmd.args(args);\n             cmd\n         }"}, {"sha": "96b1cb6b12713d5f0c666d8791cdb890a1d20e43", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/integrated_benchmarks.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fintegrated_benchmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fintegrated_benchmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fintegrated_benchmarks.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -145,6 +145,7 @@ fn integrated_completion_benchmark() {\n                 skip_glob_imports: true,\n             },\n             snippets: Vec::new(),\n+            prefer_no_std: false,\n         };\n         let position =\n             FilePosition { file_id, offset: TextSize::try_from(completion_offset).unwrap() };\n@@ -182,6 +183,7 @@ fn integrated_completion_benchmark() {\n                 skip_glob_imports: true,\n             },\n             snippets: Vec::new(),\n+            prefer_no_std: false,\n         };\n         let position =\n             FilePosition { file_id, offset: TextSize::try_from(completion_offset).unwrap() };"}, {"sha": "4cf5de46c485ed134f8d93469a046e5016ca199f", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -143,6 +143,7 @@ impl GlobalState {\n                             project_model::ProjectWorkspace::load_inline(\n                                 it.clone(),\n                                 cargo_config.target.as_deref(),\n+                                &cargo_config,\n                             )\n                         }\n                     })\n@@ -398,7 +399,11 @@ impl GlobalState {\n                         dummy_replacements.get(crate_name).map(|v| &**v).unwrap_or_default(),\n                     )\n                 };\n-                crate_graph.extend(ws.to_crate_graph(&mut load_proc_macro, &mut load));\n+                crate_graph.extend(ws.to_crate_graph(\n+                    &mut load_proc_macro,\n+                    &mut load,\n+                    &self.config.cargo(),\n+                ));\n             }\n             crate_graph\n         };"}, {"sha": "1de801e23e5c861c6e80e9dab1231332e4244e72", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -83,10 +83,11 @@ pub(crate) fn structure_node_kind(kind: StructureNodeKind) -> lsp_types::SymbolK\n \n pub(crate) fn document_highlight_kind(\n     category: ReferenceCategory,\n-) -> lsp_types::DocumentHighlightKind {\n+) -> Option<lsp_types::DocumentHighlightKind> {\n     match category {\n-        ReferenceCategory::Read => lsp_types::DocumentHighlightKind::READ,\n-        ReferenceCategory::Write => lsp_types::DocumentHighlightKind::WRITE,\n+        ReferenceCategory::Read => Some(lsp_types::DocumentHighlightKind::READ),\n+        ReferenceCategory::Write => Some(lsp_types::DocumentHighlightKind::WRITE),\n+        ReferenceCategory::Import => None,\n     }\n }\n "}, {"sha": "996d4c023d7b2a04799033a96af490c27662b709", "filename": "src/tools/rust-analyzer/docs/user/generated_config.adoc", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fgenerated_config.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fgenerated_config.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fgenerated_config.adoc?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -46,6 +46,12 @@ cargo check --quiet --workspace --message-format=json --all-targets\n Use `RUSTC_WRAPPER=rust-analyzer` when running build scripts to\n avoid checking unnecessary things.\n --\n+[[rust-analyzer.cargo.extraEnv]]rust-analyzer.cargo.extraEnv (default: `{}`)::\n++\n+--\n+Extra environment variables that will be set when running cargo, rustc\n+or other commands within the workspace. Useful for setting RUSTFLAGS.\n+--\n [[rust-analyzer.cargo.features]]rust-analyzer.cargo.features (default: `[]`)::\n +\n --\n@@ -93,6 +99,11 @@ Run specified `cargo check` command for diagnostics on save.\n --\n Extra arguments for `cargo check`.\n --\n+[[rust-analyzer.checkOnSave.extraEnv]]rust-analyzer.checkOnSave.extraEnv (default: `{}`)::\n++\n+--\n+Extra environment variables that will be set when running `cargo check`.\n+--\n [[rust-analyzer.checkOnSave.features]]rust-analyzer.checkOnSave.features (default: `null`)::\n +\n --\n@@ -353,6 +364,11 @@ Group inserted imports by the https://rust-analyzer.github.io/manual.html#auto-i\n --\n Whether to allow import insertion to merge new imports into single path glob imports like `use std::fmt::*;`.\n --\n+[[rust-analyzer.imports.prefer.no.std]]rust-analyzer.imports.prefer.no.std (default: `false`)::\n++\n+--\n+Prefer to unconditionally use imports of the core and alloc crate, over the std crate.\n+--\n [[rust-analyzer.imports.prefix]]rust-analyzer.imports.prefix (default: `\"plain\"`)::\n +\n --\n@@ -474,6 +490,11 @@ client doesn't set the corresponding capability.\n Whether to show `Implementations` lens. Only applies when\n `#rust-analyzer.lens.enable#` is set.\n --\n+[[rust-analyzer.lens.location]]rust-analyzer.lens.location (default: `\"above_name\"`)::\n++\n+--\n+Where to render annotations.\n+--\n [[rust-analyzer.lens.references.adt.enable]]rust-analyzer.lens.references.adt.enable (default: `false`)::\n +\n --\n@@ -546,6 +567,11 @@ This config takes a map of crate names with the exported proc-macro names to ign\n Internal config, path to proc-macro server executable (typically,\n this is rust-analyzer itself, but we override this in tests).\n --\n+[[rust-analyzer.references.excludeImports]]rust-analyzer.references.excludeImports (default: `false`)::\n++\n+--\n+Exclude imports from find-all-references.\n+--\n [[rust-analyzer.runnables.command]]rust-analyzer.runnables.command (default: `null`)::\n +\n --"}, {"sha": "94b41c049bc3008214ae934fbf88815e67f93d07", "filename": "src/tools/rust-analyzer/editors/code/package.json", "status": "modified", "additions": 33, "deletions": 9, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage.json?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -206,11 +206,6 @@\n                 \"title\": \"Show RA Version\",\n                 \"category\": \"rust-analyzer\"\n             },\n-            {\n-                \"command\": \"rust-analyzer.toggleInlayHints\",\n-                \"title\": \"Toggle inlay hints\",\n-                \"category\": \"rust-analyzer\"\n-            },\n             {\n                 \"command\": \"rust-analyzer.openDocs\",\n                 \"title\": \"Open docs under cursor\",\n@@ -442,6 +437,11 @@\n                     \"default\": true,\n                     \"type\": \"boolean\"\n                 },\n+                \"rust-analyzer.cargo.extraEnv\": {\n+                    \"markdownDescription\": \"Extra environment variables that will be set when running cargo, rustc\\nor other commands within the workspace. Useful for setting RUSTFLAGS.\",\n+                    \"default\": {},\n+                    \"type\": \"object\"\n+                },\n                 \"rust-analyzer.cargo.features\": {\n                     \"markdownDescription\": \"List of features to activate.\\n\\nSet this to `\\\"all\\\"` to pass `--all-features` to cargo.\",\n                     \"default\": [],\n@@ -514,6 +514,11 @@\n                         \"type\": \"string\"\n                     }\n                 },\n+                \"rust-analyzer.checkOnSave.extraEnv\": {\n+                    \"markdownDescription\": \"Extra environment variables that will be set when running `cargo check`.\",\n+                    \"default\": {},\n+                    \"type\": \"object\"\n+                },\n                 \"rust-analyzer.checkOnSave.features\": {\n                     \"markdownDescription\": \"List of features to activate. Defaults to\\n`#rust-analyzer.cargo.features#`.\\n\\nSet to `\\\"all\\\"` to pass `--all-features` to Cargo.\",\n                     \"default\": null,\n@@ -803,6 +808,11 @@\n                     \"default\": true,\n                     \"type\": \"boolean\"\n                 },\n+                \"rust-analyzer.imports.prefer.no.std\": {\n+                    \"markdownDescription\": \"Prefer to unconditionally use imports of the core and alloc crate, over the std crate.\",\n+                    \"default\": false,\n+                    \"type\": \"boolean\"\n+                },\n                 \"rust-analyzer.imports.prefix\": {\n                     \"markdownDescription\": \"The path structure for newly inserted paths to use.\",\n                     \"default\": \"plain\",\n@@ -963,6 +973,19 @@\n                     \"default\": true,\n                     \"type\": \"boolean\"\n                 },\n+                \"rust-analyzer.lens.location\": {\n+                    \"markdownDescription\": \"Where to render annotations.\",\n+                    \"default\": \"above_name\",\n+                    \"type\": \"string\",\n+                    \"enum\": [\n+                        \"above_name\",\n+                        \"above_whole_item\"\n+                    ],\n+                    \"enumDescriptions\": [\n+                        \"Render annotations above the name of the item.\",\n+                        \"Render annotations above the whole item, including documentation comments and attributes.\"\n+                    ]\n+                },\n                 \"rust-analyzer.lens.references.adt.enable\": {\n                     \"markdownDescription\": \"Whether to show `References` lens for Struct, Enum, and Union.\\nOnly applies when `#rust-analyzer.lens.enable#` is set.\",\n                     \"default\": false,\n@@ -1036,6 +1059,11 @@\n                         \"string\"\n                     ]\n                 },\n+                \"rust-analyzer.references.excludeImports\": {\n+                    \"markdownDescription\": \"Exclude imports from find-all-references.\",\n+                    \"default\": false,\n+                    \"type\": \"boolean\"\n+                },\n                 \"rust-analyzer.runnables.command\": {\n                     \"markdownDescription\": \"Command to be executed instead of 'cargo' for runnables.\",\n                     \"default\": null,\n@@ -1633,10 +1661,6 @@\n                     \"command\": \"rust-analyzer.serverVersion\",\n                     \"when\": \"inRustProject\"\n                 },\n-                {\n-                    \"command\": \"rust-analyzer.toggleInlayHints\",\n-                    \"when\": \"inRustProject\"\n-                },\n                 {\n                     \"command\": \"rust-analyzer.openDocs\",\n                     \"when\": \"inRustProject\""}, {"sha": "b9ad525e361f0e20e5807ac9d2b24ab306d4f716", "filename": "src/tools/rust-analyzer/editors/code/src/commands.ts", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fcommands.ts", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fcommands.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fcommands.ts?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -321,30 +321,6 @@ export function serverVersion(ctx: Ctx): Cmd {\n     };\n }\n \n-export function toggleInlayHints(_ctx: Ctx): Cmd {\n-    return async () => {\n-        const config = vscode.workspace.getConfiguration(\"editor.inlayHints\", {\n-            languageId: \"rust\",\n-        });\n-\n-        const value = config.get(\"enabled\");\n-        let stringValue;\n-        if (typeof value === \"string\") {\n-            stringValue = value;\n-        } else {\n-            stringValue = value ? \"on\" : \"off\";\n-        }\n-        const nextValues: Record<string, string> = {\n-            on: \"off\",\n-            off: \"on\",\n-            onUnlessPressed: \"offUnlessPressed\",\n-            offUnlessPressed: \"onUnlessPressed\",\n-        };\n-        const nextValue = nextValues[stringValue] ?? \"on\";\n-        await config.update(\"enabled\", nextValue, vscode.ConfigurationTarget.Global);\n-    };\n-}\n-\n // Opens the virtual file that will show the syntax tree\n //\n // The contents of the file come from the `TextDocumentContentProvider`"}, {"sha": "41bde4195e07d254da0d5532101c140969c17dc2", "filename": "src/tools/rust-analyzer/editors/code/src/main.ts", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/432abd86f231c908f6df3cdd779e83f35084be90/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts?ref=432abd86f231c908f6df3cdd779e83f35084be90", "patch": "@@ -180,7 +180,6 @@ async function initCommonContext(context: vscode.ExtensionContext, ctx: Ctx) {\n \n     ctx.registerCommand(\"ssr\", commands.ssr);\n     ctx.registerCommand(\"serverVersion\", commands.serverVersion);\n-    ctx.registerCommand(\"toggleInlayHints\", commands.toggleInlayHints);\n \n     // Internal commands which are invoked by the server.\n     ctx.registerCommand(\"runSingle\", commands.runSingle);"}]}