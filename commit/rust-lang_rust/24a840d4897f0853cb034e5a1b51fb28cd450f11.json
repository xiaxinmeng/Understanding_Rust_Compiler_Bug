{"sha": "24a840d4897f0853cb034e5a1b51fb28cd450f11", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0YTg0MGQ0ODk3ZjA4NTNjYjAzNGU1YTFiNTFmYjI4Y2Q0NTBmMTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-03T08:06:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-03T08:06:59Z"}, "message": "Auto merge of #22971 - lifthrasiir:metadata-reform, r=huonw\n\nThis is a series of individual but correlated changes to the metadata format. The changes are significant enough that it (finally) bumps the metadata encoding version. In brief, they altogether reduce the total size of stage1 binaries by 27% (!!!!). Almost every low-hanging fruit has been considered and fixed; see the individual commits for details.\r\n\r\nDetailed library (not just metadata) size changes for x86_64-unknown-linux-gnu stage1 binaries (baseline being 3a96d6a9818fe2affc98a187fb1065120458cee9):\r\n\r\n````\r\n   before     after  delta path\r\n--------- --------- ------ --------------------------------\r\n  1706146   1050412  38.4% liballoc-4e7c5e5c.rlib\r\n   398576    152454  61.8% libarena-4e7c5e5c.rlib\r\n    71441     56892  20.4% libarena-4e7c5e5c.so\r\n 14424754   5084102  64.8% libcollections-4e7c5e5c.rlib\r\n 39143186  14743118  62.3% libcore-4e7c5e5c.rlib\r\n   195574    188150   3.8% libflate-4e7c5e5c.rlib\r\n   153123    152603   0.3% libflate-4e7c5e5c.so\r\n   477152    215262  54.9% libfmt_macros-4e7c5e5c.rlib\r\n    77728     66601  14.3% libfmt_macros-4e7c5e5c.so\r\n  1216936    684104  43.8% libgetopts-4e7c5e5c.rlib\r\n   207846    181116  12.9% libgetopts-4e7c5e5c.so\r\n   349722    147530  57.8% libgraphviz-4e7c5e5c.rlib\r\n    60196     49197  18.3% libgraphviz-4e7c5e5c.so\r\n   729842    259906  64.4% liblibc-4e7c5e5c.rlib\r\n   349358    247014  29.3% liblog-4e7c5e5c.rlib\r\n    88878     83163   6.4% liblog-4e7c5e5c.so\r\n  1968508    732840  62.8% librand-4e7c5e5c.rlib\r\n  1968204    696326  64.6% librbml-4e7c5e5c.rlib\r\n   283207    206589  27.1% librbml-4e7c5e5c.so\r\n 72369394  46401230  35.9% librustc-4e7c5e5c.rlib\r\n 11941372  10498483  12.1% librustc-4e7c5e5c.so\r\n  2717894   1983272  27.0% librustc_back-4e7c5e5c.rlib\r\n   501900    464176   7.5% librustc_back-4e7c5e5c.so\r\n    15058     12588  16.4% librustc_bitflags-4e7c5e5c.rlib\r\n  4008268   2961912  26.1% librustc_borrowck-4e7c5e5c.rlib\r\n   837550    785633   6.2% librustc_borrowck-4e7c5e5c.so\r\n  6473348   6095470   5.8% librustc_driver-4e7c5e5c.rlib\r\n  1448785   1433945   1.0% librustc_driver-4e7c5e5c.so\r\n 95483688  94779704   0.7% librustc_llvm-4e7c5e5c.rlib\r\n 43516815  43487809   0.1% librustc_llvm-4e7c5e5c.so\r\n   938140    817236  12.9% librustc_privacy-4e7c5e5c.rlib\r\n   182653    176563   3.3% librustc_privacy-4e7c5e5c.so\r\n  4390288   3543284  19.3% librustc_resolve-4e7c5e5c.rlib\r\n   872981    831824   4.7% librustc_resolve-4e7c5e5c.so\r\n 18176426  14795426  18.6% librustc_trans-4e7c5e5c.rlib\r\n  3657354   3480026   4.8% librustc_trans-4e7c5e5c.so\r\n 16815076  13868862  17.5% librustc_typeck-4e7c5e5c.rlib\r\n  3274439   3123898   4.6% librustc_typeck-4e7c5e5c.so\r\n 21372308  14890582  30.3% librustdoc-4e7c5e5c.rlib\r\n  4501971   4172202   7.3% librustdoc-4e7c5e5c.so\r\n  8055028   2951044  63.4% libserialize-4e7c5e5c.rlib\r\n   958101    710016  25.9% libserialize-4e7c5e5c.so\r\n 30810208  15160648  50.8% libstd-4e7c5e5c.rlib\r\n  6819003   5967485  12.5% libstd-4e7c5e5c.so\r\n 58850950  31949594  45.7% libsyntax-4e7c5e5c.rlib\r\n  9060154   7882423  13.0% libsyntax-4e7c5e5c.so\r\n  1474310   1062102  28.0% libterm-4e7c5e5c.rlib\r\n   345577    323952   6.3% libterm-4e7c5e5c.so\r\n  2827854   1643056  41.9% libtest-4e7c5e5c.rlib\r\n   517811    452519  12.6% libtest-4e7c5e5c.so\r\n  2274106   1761240  22.6% libunicode-4e7c5e5c.rlib\r\n--------- --------- ------ --------------------------------\r\n499359187 363465583  27.2% total\r\n````\r\n\r\nSome notes:\r\n\r\n* Uncompressed metadata compacts very well. It is less visible for compressed metadata but still it achieves about 5~10% reduction.\r\n* *Every* commit is designed to reduce the metadata in one way. There is absolutely no negative impact associated to changes (that's why the table above doesn't contain a minus delta).\r\n* I've confirmed that this compiles through `make all`, making it almost correct. Other platforms have to be tested though.\r\n* Oh, I'll rebase this as soon as I have spare time, but I guess this needs an extensive review anyway.\r\n* I haven't rigorously checked the encoder and decoder performance. I tried to minimize the impact (some encodings are actually simpler than the original), but I'm not sure.\r\n\r\nFixes #2743, #9303 (partially) and #21482.", "tree": {"sha": "a74bd526249d15937704631acfdc69527f934519", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a74bd526249d15937704631acfdc69527f934519"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24a840d4897f0853cb034e5a1b51fb28cd450f11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24a840d4897f0853cb034e5a1b51fb28cd450f11", "html_url": "https://github.com/rust-lang/rust/commit/24a840d4897f0853cb034e5a1b51fb28cd450f11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24a840d4897f0853cb034e5a1b51fb28cd450f11/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5457eab3c5f1abeb0ba4e9275d55a398f6a09134", "url": "https://api.github.com/repos/rust-lang/rust/commits/5457eab3c5f1abeb0ba4e9275d55a398f6a09134", "html_url": "https://github.com/rust-lang/rust/commit/5457eab3c5f1abeb0ba4e9275d55a398f6a09134"}, {"sha": "2008b54bf3687996d2e3a3ab151a0b6330a51b7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2008b54bf3687996d2e3a3ab151a0b6330a51b7a", "html_url": "https://github.com/rust-lang/rust/commit/2008b54bf3687996d2e3a3ab151a0b6330a51b7a"}], "stats": {"total": 1382, "additions": 758, "deletions": 624}, "files": [{"sha": "844d097bdafa95f32b2c166ed25ee56e5d2a6306", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 438, "deletions": 198, "changes": 636, "blob_url": "https://github.com/rust-lang/rust/blob/24a840d4897f0853cb034e5a1b51fb28cd450f11/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a840d4897f0853cb034e5a1b51fb28cd450f11/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=24a840d4897f0853cb034e5a1b51fb28cd450f11", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,12 +8,108 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Really Bad Markup Language (rbml) is a temporary measure until we migrate\n-//! the rust object metadata to a better serialization format. It is not\n-//! intended to be used by users.\n+//! Really Bad Markup Language (rbml) is an internal serialization format of rustc.\n+//! This is not intended to be used by users.\n //!\n-//! It is loosely based on the Extensible Binary Markup Language (ebml):\n-//!     http://www.matroska.org/technical/specs/rfc/index.html\n+//! Originally based on the Extensible Binary Markup Language\n+//! (ebml; http://www.matroska.org/technical/specs/rfc/index.html),\n+//! it is now a separate format tuned for the rust object metadata.\n+//!\n+//! # Encoding\n+//!\n+//! RBML document consists of the tag, length and data.\n+//! The encoded data can contain multiple RBML documents concatenated.\n+//!\n+//! **Tags** are a hint for the following data.\n+//! Tags are a number from 0x000 to 0xfff, where 0xf0 through 0xff is reserved.\n+//! Tags less than 0xf0 are encoded in one literal byte.\n+//! Tags greater than 0xff are encoded in two big-endian bytes,\n+//! where the tag number is ORed with 0xf000. (E.g. tag 0x123 = `f1 23`)\n+//!\n+//! **Lengths** encode the length of the following data.\n+//! It is a variable-length unsigned int, and one of the following forms:\n+//!\n+//! - `80` through `fe` for lengths up to 0x7e;\n+//! - `40 ff` through `7f ff` for lengths up to 0x3fff;\n+//! - `20 40 00` through `3f ff ff` for lengths up to 0x1fffff;\n+//! - `10 20 00 00` through `1f ff ff ff` for lengths up to 0xfffffff.\n+//!\n+//! The \"overlong\" form is allowed so that the length can be encoded\n+//! without the prior knowledge of the encoded data.\n+//! For example, the length 0 can be represented either by `80`, `40 00`,\n+//! `20 00 00` or `10 00 00 00`.\n+//! The encoder tries to minimize the length if possible.\n+//! Also, some predefined tags listed below are so commonly used that\n+//! their lengths are omitted (\"implicit length\").\n+//!\n+//! **Data** can be either binary bytes or zero or more nested RBML documents.\n+//! Nested documents cannot overflow, and should be entirely contained\n+//! within a parent document.\n+//!\n+//! # Predefined Tags\n+//!\n+//! Most RBML tags are defined by the application.\n+//! (For the rust object metadata, see also `rustc::metadata::common`.)\n+//! RBML itself does define a set of predefined tags however,\n+//! intended for the auto-serialization implementation.\n+//!\n+//! Predefined tags with an implicit length:\n+//!\n+//! - `U8`  (`00`): 1-byte unsigned integer.\n+//! - `U16` (`01`): 2-byte big endian unsigned integer.\n+//! - `U32` (`02`): 4-byte big endian unsigned integer.\n+//! - `U64` (`03`): 8-byte big endian unsigned integer.\n+//!   Any of `U*` tags can be used to encode primitive unsigned integer types,\n+//!   as long as it is no greater than the actual size.\n+//!   For example, `u8` can only be represented via the `U8` tag.\n+//!\n+//! - `I8`  (`04`): 1-byte signed integer.\n+//! - `I16` (`05`): 2-byte big endian signed integer.\n+//! - `I32` (`06`): 4-byte big endian signed integer.\n+//! - `I64` (`07`): 8-byte big endian signed integer.\n+//!   Similar to `U*` tags. Always uses two's complement encoding.\n+//!\n+//! - `Bool` (`08`): 1-byte boolean value, `00` for false and `01` for true.\n+//!\n+//! - `Char` (`09`): 4-byte big endian Unicode scalar value.\n+//!   Surrogate pairs or out-of-bound values are invalid.\n+//!\n+//! - `F32` (`0a`): 4-byte big endian unsigned integer representing\n+//!   IEEE 754 binary32 floating-point format.\n+//! - `F64` (`0b`): 8-byte big endian unsigned integer representing\n+//!   IEEE 754 binary64 floating-point format.\n+//!\n+//! - `Sub8`  (`0c`): 1-byte unsigned integer for supplementary information.\n+//! - `Sub32` (`0d`): 4-byte unsigned integer for supplementary information.\n+//!   Those two tags normally occur as the first subdocument of certain tags,\n+//!   namely `Enum`, `Vec` and `Map`, to provide a variant or size information.\n+//!   They can be used interchangably.\n+//!\n+//! Predefined tags with an explicit length:\n+//!\n+//! - `Str` (`10`): A UTF-8-encoded string.\n+//!\n+//! - `Enum` (`11`): An enum.\n+//!   The first subdocument should be `Sub*` tags with a variant ID.\n+//!   Subsequent subdocuments, if any, encode variant arguments.\n+//!\n+//! - `Vec` (`12`): A vector (sequence).\n+//! - `VecElt` (`13`): A vector element.\n+//!   The first subdocument should be `Sub*` tags with the number of elements.\n+//!   Subsequent subdocuments should be `VecElt` tag per each element.\n+//!\n+//! - `Map` (`14`): A map (associated array).\n+//! - `MapKey` (`15`): A key part of the map entry.\n+//! - `MapVal` (`16`): A value part of the map entry.\n+//!   The first subdocument should be `Sub*` tags with the number of entries.\n+//!   Subsequent subdocuments should be an alternating sequence of\n+//!   `MapKey` and `MapVal` tags per each entry.\n+//!\n+//! - `Opaque` (`17`): An opaque, custom-format tag.\n+//!   Used to wrap ordinary custom tags or data in the auto-serialized context.\n+//!   Rustc typically uses this to encode type informations.\n+//!\n+//! First 0x20 tags are reserved by RBML; custom tags start at 0x20.\n \n #![crate_name = \"rbml\"]\n #![unstable(feature = \"rustc_private\")]\n@@ -64,6 +160,10 @@ impl<'doc> Doc<'doc> {\n         reader::get_doc(*self, tag)\n     }\n \n+    pub fn is_empty(&self) -> bool {\n+        self.start == self.end\n+    }\n+\n     pub fn as_str_slice<'a>(&'a self) -> &'a str {\n         str::from_utf8(&self.data[self.start..self.end]).unwrap()\n     }\n@@ -80,41 +180,51 @@ pub struct TaggedDoc<'a> {\n \n #[derive(Copy, Debug)]\n pub enum EbmlEncoderTag {\n-    EsUint,     // 0\n-    EsU64,      // 1\n-    EsU32,      // 2\n-    EsU16,      // 3\n-    EsU8,       // 4\n-    EsInt,      // 5\n-    EsI64,      // 6\n-    EsI32,      // 7\n-    EsI16,      // 8\n-    EsI8,       // 9\n-    EsBool,     // 10\n-    EsChar,     // 11\n-    EsStr,      // 12\n-    EsF64,      // 13\n-    EsF32,      // 14\n-    EsFloat,    // 15\n-    EsEnum,     // 16\n-    EsEnumVid,  // 17\n-    EsEnumBody, // 18\n-    EsVec,      // 19\n-    EsVecLen,   // 20\n-    EsVecElt,   // 21\n-    EsMap,      // 22\n-    EsMapLen,   // 23\n-    EsMapKey,   // 24\n-    EsMapVal,   // 25\n-\n-    EsOpaque,\n-\n-    EsLabel, // Used only when debugging\n+    // tags 00..1f are reserved for auto-serialization.\n+    // first NUM_IMPLICIT_TAGS tags are implicitly sized and lengths are not encoded.\n+\n+    EsU8       = 0x00, // + 1 byte\n+    EsU16      = 0x01, // + 2 bytes\n+    EsU32      = 0x02, // + 4 bytes\n+    EsU64      = 0x03, // + 8 bytes\n+    EsI8       = 0x04, // + 1 byte\n+    EsI16      = 0x05, // + 2 bytes\n+    EsI32      = 0x06, // + 4 bytes\n+    EsI64      = 0x07, // + 8 bytes\n+    EsBool     = 0x08, // + 1 byte\n+    EsChar     = 0x09, // + 4 bytes\n+    EsF32      = 0x0a, // + 4 bytes\n+    EsF64      = 0x0b, // + 8 bytes\n+    EsSub8     = 0x0c, // + 1 byte\n+    EsSub32    = 0x0d, // + 4 bytes\n+    // 0x0e and 0x0f are reserved\n+\n+    EsStr      = 0x10,\n+    EsEnum     = 0x11, // encodes the variant id as the first EsSub*\n+    EsVec      = 0x12, // encodes the # of elements as the first EsSub*\n+    EsVecElt   = 0x13,\n+    EsMap      = 0x14, // encodes the # of pairs as the first EsSub*\n+    EsMapKey   = 0x15,\n+    EsMapVal   = 0x16,\n+    EsOpaque   = 0x17,\n }\n \n+const NUM_TAGS: uint = 0x1000;\n+const NUM_IMPLICIT_TAGS: uint = 0x0e;\n+\n+static TAG_IMPLICIT_LEN: [i8; NUM_IMPLICIT_TAGS] = [\n+    1, 2, 4, 8, // EsU*\n+    1, 2, 4, 8, // ESI*\n+    1, // EsBool\n+    4, // EsChar\n+    4, 8, // EsF*\n+    1, 4, // EsSub*\n+];\n+\n #[derive(Debug)]\n pub enum Error {\n     IntTooBig(uint),\n+    InvalidTag(uint),\n     Expected(String),\n     IoError(std::old_io::IoError),\n     ApplicationError(String)\n@@ -138,11 +248,11 @@ pub mod reader {\n \n     use serialize;\n \n-    use super::{ ApplicationError, EsVec, EsMap, EsEnum, EsVecLen, EsVecElt,\n-        EsMapLen, EsMapKey, EsEnumVid, EsU64, EsU32, EsU16, EsU8, EsInt, EsI64,\n+    use super::{ ApplicationError, EsVec, EsMap, EsEnum, EsSub8, EsSub32,\n+        EsVecElt, EsMapKey, EsU64, EsU32, EsU16, EsU8, EsI64,\n         EsI32, EsI16, EsI8, EsBool, EsF64, EsF32, EsChar, EsStr, EsMapVal,\n-        EsEnumBody, EsUint, EsOpaque, EsLabel, EbmlEncoderTag, Doc, TaggedDoc,\n-        Error, IntTooBig, Expected };\n+        EsOpaque, EbmlEncoderTag, Doc, TaggedDoc,\n+        Error, IntTooBig, InvalidTag, Expected, NUM_IMPLICIT_TAGS, TAG_IMPLICIT_LEN };\n \n     pub type DecodeResult<T> = Result<T, Error>;\n     // rbml reading\n@@ -165,6 +275,18 @@ pub mod reader {\n         pub next: uint\n     }\n \n+    pub fn tag_at(data: &[u8], start: uint) -> DecodeResult<Res> {\n+        let v = data[start] as uint;\n+        if v < 0xf0 {\n+            Ok(Res { val: v, next: start + 1 })\n+        } else if v > 0xf0 {\n+            Ok(Res { val: ((v & 0xf) << 8) | data[start + 1] as uint, next: start + 2 })\n+        } else {\n+            // every tag starting with byte 0xf0 is an overlong form, which is prohibited.\n+            Err(InvalidTag(v))\n+        }\n+    }\n+\n     #[inline(never)]\n     fn vuint_at_slow(data: &[u8], start: uint) -> DecodeResult<Res> {\n         let a = data[start];\n@@ -237,9 +359,17 @@ pub mod reader {\n         }\n     }\n \n+    pub fn tag_len_at(data: &[u8], tag: Res) -> DecodeResult<Res> {\n+        if tag.val < NUM_IMPLICIT_TAGS && TAG_IMPLICIT_LEN[tag.val] >= 0 {\n+            Ok(Res { val: TAG_IMPLICIT_LEN[tag.val] as uint, next: tag.next })\n+        } else {\n+            vuint_at(data, tag.next)\n+        }\n+    }\n+\n     pub fn doc_at<'a>(data: &'a [u8], start: uint) -> DecodeResult<TaggedDoc<'a>> {\n-        let elt_tag = try!(vuint_at(data, start));\n-        let elt_size = try!(vuint_at(data, elt_tag.next));\n+        let elt_tag = try!(tag_at(data, start));\n+        let elt_size = try!(tag_len_at(data, elt_tag));\n         let end = elt_size.next + elt_size.val;\n         Ok(TaggedDoc {\n             tag: elt_tag.val,\n@@ -250,8 +380,8 @@ pub mod reader {\n     pub fn maybe_get_doc<'a>(d: Doc<'a>, tg: uint) -> Option<Doc<'a>> {\n         let mut pos = d.start;\n         while pos < d.end {\n-            let elt_tag = try_or!(vuint_at(d.data, pos), None);\n-            let elt_size = try_or!(vuint_at(d.data, elt_tag.next), None);\n+            let elt_tag = try_or!(tag_at(d.data, pos), None);\n+            let elt_size = try_or!(tag_len_at(d.data, elt_tag), None);\n             pos = elt_size.next + elt_size.val;\n             if elt_tag.val == tg {\n                 return Some(Doc { data: d.data, start: elt_size.next,\n@@ -276,8 +406,8 @@ pub mod reader {\n     {\n         let mut pos = d.start;\n         while pos < d.end {\n-            let elt_tag = try_or!(vuint_at(d.data, pos), false);\n-            let elt_size = try_or!(vuint_at(d.data, elt_tag.next), false);\n+            let elt_tag = try_or!(tag_at(d.data, pos), false);\n+            let elt_size = try_or!(tag_len_at(d.data, elt_tag), false);\n             pos = elt_size.next + elt_size.val;\n             let doc = Doc { data: d.data, start: elt_size.next, end: pos };\n             if !it(elt_tag.val, doc) {\n@@ -292,8 +422,8 @@ pub mod reader {\n     {\n         let mut pos = d.start;\n         while pos < d.end {\n-            let elt_tag = try_or!(vuint_at(d.data, pos), false);\n-            let elt_size = try_or!(vuint_at(d.data, elt_tag.next), false);\n+            let elt_tag = try_or!(tag_at(d.data, pos), false);\n+            let elt_size = try_or!(tag_len_at(d.data, elt_tag), false);\n             pos = elt_size.next + elt_size.val;\n             if elt_tag.val == tg {\n                 let doc = Doc { data: d.data, start: elt_size.next,\n@@ -357,23 +487,6 @@ pub mod reader {\n             }\n         }\n \n-        fn _check_label(&mut self, lbl: &str) -> DecodeResult<()> {\n-            if self.pos < self.parent.end {\n-                let TaggedDoc { tag: r_tag, doc: r_doc } =\n-                    try!(doc_at(self.parent.data, self.pos));\n-\n-                if r_tag == (EsLabel as uint) {\n-                    self.pos = r_doc.end;\n-                    let str = r_doc.as_str_slice();\n-                    if lbl != str {\n-                        return Err(Expected(format!(\"Expected label {:?} but \\\n-                                                     found {:?}\", lbl, str)));\n-                    }\n-                }\n-            }\n-            Ok(())\n-        }\n-\n         fn next_doc(&mut self, exp_tag: EbmlEncoderTag) -> DecodeResult<Doc<'doc>> {\n             debug!(\". next_doc(exp_tag={:?})\", exp_tag);\n             if self.pos >= self.parent.end {\n@@ -416,10 +529,66 @@ pub mod reader {\n             Ok(r)\n         }\n \n-        fn _next_uint(&mut self, exp_tag: EbmlEncoderTag) -> DecodeResult<uint> {\n-            let r = doc_as_u32(try!(self.next_doc(exp_tag)));\n-            debug!(\"_next_uint exp_tag={:?} result={:?}\", exp_tag, r);\n-            Ok(r as uint)\n+        fn _next_sub(&mut self) -> DecodeResult<uint> {\n+            // empty vector/map optimization\n+            if self.parent.is_empty() {\n+                return Ok(0);\n+            }\n+\n+            let TaggedDoc { tag: r_tag, doc: r_doc } =\n+                try!(doc_at(self.parent.data, self.pos));\n+            let r = if r_tag == (EsSub8 as uint) {\n+                doc_as_u8(r_doc) as uint\n+            } else if r_tag == (EsSub32 as uint) {\n+                doc_as_u32(r_doc) as uint\n+            } else {\n+                return Err(Expected(format!(\"expected EBML doc with tag {:?} or {:?} but \\\n+                                             found tag {:?}\", EsSub8, EsSub32, r_tag)));\n+            };\n+            if r_doc.end > self.parent.end {\n+                return Err(Expected(format!(\"invalid EBML, child extends to \\\n+                                             {:#x}, parent to {:#x}\",\n+                                            r_doc.end, self.parent.end)));\n+            }\n+            self.pos = r_doc.end;\n+            debug!(\"_next_sub result={:?}\", r);\n+            Ok(r)\n+        }\n+\n+        // variable-length unsigned integer with different tags.\n+        // `first_tag` should be a tag for u8 or i8.\n+        // `last_tag` should be the largest allowed integer tag with the matching signedness.\n+        // all tags between them should be valid, in the order of u8, u16, u32 and u64.\n+        fn _next_int(&mut self,\n+                     first_tag: EbmlEncoderTag,\n+                     last_tag: EbmlEncoderTag) -> DecodeResult<u64> {\n+            if self.pos >= self.parent.end {\n+                return Err(Expected(format!(\"no more documents in \\\n+                                             current node!\")));\n+            }\n+\n+            let TaggedDoc { tag: r_tag, doc: r_doc } =\n+                try!(doc_at(self.parent.data, self.pos));\n+            let r = if first_tag as uint <= r_tag && r_tag <= last_tag as uint {\n+                match r_tag - first_tag as uint {\n+                    0 => doc_as_u8(r_doc) as u64,\n+                    1 => doc_as_u16(r_doc) as u64,\n+                    2 => doc_as_u32(r_doc) as u64,\n+                    3 => doc_as_u64(r_doc) as u64,\n+                    _ => unreachable!(),\n+                }\n+            } else {\n+                return Err(Expected(format!(\"expected EBML doc with tag {:?} through {:?} but \\\n+                                             found tag {:?}\", first_tag, last_tag, r_tag)));\n+            };\n+            if r_doc.end > self.parent.end {\n+                return Err(Expected(format!(\"invalid EBML, child extends to \\\n+                                             {:#x}, parent to {:#x}\",\n+                                            r_doc.end, self.parent.end)));\n+            }\n+            self.pos = r_doc.end;\n+            debug!(\"_next_int({:?}, {:?}) result={:?}\", first_tag, last_tag, r);\n+            Ok(r)\n         }\n \n         pub fn read_opaque<R, F>(&mut self, op: F) -> DecodeResult<R> where\n@@ -443,33 +612,25 @@ pub mod reader {\n         type Error = Error;\n         fn read_nil(&mut self) -> DecodeResult<()> { Ok(()) }\n \n-        fn read_u64(&mut self) -> DecodeResult<u64> { Ok(doc_as_u64(try!(self.next_doc(EsU64)))) }\n-        fn read_u32(&mut self) -> DecodeResult<u32> { Ok(doc_as_u32(try!(self.next_doc(EsU32)))) }\n-        fn read_u16(&mut self) -> DecodeResult<u16> { Ok(doc_as_u16(try!(self.next_doc(EsU16)))) }\n-        fn read_u8 (&mut self) -> DecodeResult<u8 > { Ok(doc_as_u8 (try!(self.next_doc(EsU8 )))) }\n+        fn read_u64(&mut self) -> DecodeResult<u64> { self._next_int(EsU8, EsU64) }\n+        fn read_u32(&mut self) -> DecodeResult<u32> { Ok(try!(self._next_int(EsU8, EsU32)) as u32) }\n+        fn read_u16(&mut self) -> DecodeResult<u16> { Ok(try!(self._next_int(EsU8, EsU16)) as u16) }\n+        fn read_u8(&mut self) -> DecodeResult<u8> { Ok(doc_as_u8(try!(self.next_doc(EsU8)))) }\n         fn read_uint(&mut self) -> DecodeResult<uint> {\n-            let v = doc_as_u64(try!(self.next_doc(EsUint)));\n+            let v = try!(self._next_int(EsU8, EsU64));\n             if v > (::std::usize::MAX as u64) {\n                 Err(IntTooBig(v as uint))\n             } else {\n                 Ok(v as uint)\n             }\n         }\n \n-        fn read_i64(&mut self) -> DecodeResult<i64> {\n-            Ok(doc_as_u64(try!(self.next_doc(EsI64))) as i64)\n-        }\n-        fn read_i32(&mut self) -> DecodeResult<i32> {\n-            Ok(doc_as_u32(try!(self.next_doc(EsI32))) as i32)\n-        }\n-        fn read_i16(&mut self) -> DecodeResult<i16> {\n-            Ok(doc_as_u16(try!(self.next_doc(EsI16))) as i16)\n-        }\n-        fn read_i8 (&mut self) -> DecodeResult<i8> {\n-            Ok(doc_as_u8(try!(self.next_doc(EsI8 ))) as i8)\n-        }\n+        fn read_i64(&mut self) -> DecodeResult<i64> { Ok(try!(self._next_int(EsI8, EsI64)) as i64) }\n+        fn read_i32(&mut self) -> DecodeResult<i32> { Ok(try!(self._next_int(EsI8, EsI32)) as i32) }\n+        fn read_i16(&mut self) -> DecodeResult<i16> { Ok(try!(self._next_int(EsI8, EsI16)) as i16) }\n+        fn read_i8(&mut self) -> DecodeResult<i8> { Ok(doc_as_u8(try!(self.next_doc(EsI8))) as i8) }\n         fn read_int(&mut self) -> DecodeResult<int> {\n-            let v = doc_as_u64(try!(self.next_doc(EsInt))) as i64;\n+            let v = try!(self._next_int(EsI8, EsI64)) as i64;\n             if v > (isize::MAX as i64) || v < (isize::MIN as i64) {\n                 debug!(\"FIXME \\\\#6122: Removing this makes this function miscompile\");\n                 Err(IntTooBig(v as uint))\n@@ -502,7 +663,6 @@ pub mod reader {\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n             debug!(\"read_enum({})\", name);\n-            try!(self._check_label(name));\n \n             let doc = try!(self.next_doc(EsEnum));\n \n@@ -522,20 +682,10 @@ pub mod reader {\n             where F: FnMut(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n         {\n             debug!(\"read_enum_variant()\");\n-            let idx = try!(self._next_uint(EsEnumVid));\n+            let idx = try!(self._next_sub());\n             debug!(\"  idx={}\", idx);\n \n-            let doc = try!(self.next_doc(EsEnumBody));\n-\n-            let (old_parent, old_pos) = (self.parent, self.pos);\n-            self.parent = doc;\n-            self.pos = self.parent.start;\n-\n-            let result = try!(f(self, idx));\n-\n-            self.parent = old_parent;\n-            self.pos = old_pos;\n-            Ok(result)\n+            f(self, idx)\n         }\n \n         fn read_enum_variant_arg<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n@@ -550,20 +700,10 @@ pub mod reader {\n             where F: FnMut(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n         {\n             debug!(\"read_enum_struct_variant()\");\n-            let idx = try!(self._next_uint(EsEnumVid));\n+            let idx = try!(self._next_sub());\n             debug!(\"  idx={}\", idx);\n \n-            let doc = try!(self.next_doc(EsEnumBody));\n-\n-            let (old_parent, old_pos) = (self.parent, self.pos);\n-            self.parent = doc;\n-            self.pos = self.parent.start;\n-\n-            let result = try!(f(self, idx));\n-\n-            self.parent = old_parent;\n-            self.pos = old_pos;\n-            Ok(result)\n+            f(self, idx)\n         }\n \n         fn read_enum_struct_variant_field<T, F>(&mut self,\n@@ -588,7 +728,6 @@ pub mod reader {\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n             debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n-            try!(self._check_label(name));\n             f(self)\n         }\n \n@@ -652,7 +791,7 @@ pub mod reader {\n         {\n             debug!(\"read_seq()\");\n             self.push_doc(EsVec, move |d| {\n-                let len = try!(d._next_uint(EsVecLen));\n+                let len = try!(d._next_sub());\n                 debug!(\"  len={}\", len);\n                 f(d, len)\n             })\n@@ -670,7 +809,7 @@ pub mod reader {\n         {\n             debug!(\"read_map()\");\n             self.push_doc(EsMap, move |d| {\n-                let len = try!(d._next_uint(EsMapLen));\n+                let len = try!(d._next_sub());\n                 debug!(\"  len={}\", len);\n                 f(d, len)\n             })\n@@ -701,21 +840,39 @@ pub mod writer {\n     use std::num::Int;\n     use std::old_io::{Writer, Seek};\n     use std::old_io;\n+    use std::slice::bytes;\n+    use std::num::ToPrimitive;\n \n-    use super::{ EsVec, EsMap, EsEnum, EsVecLen, EsVecElt, EsMapLen, EsMapKey,\n-        EsEnumVid, EsU64, EsU32, EsU16, EsU8, EsInt, EsI64, EsI32, EsI16, EsI8,\n-        EsBool, EsF64, EsF32, EsChar, EsStr, EsMapVal, EsEnumBody, EsUint,\n-        EsOpaque, EsLabel, EbmlEncoderTag };\n+    use super::{ EsVec, EsMap, EsEnum, EsSub8, EsSub32, EsVecElt, EsMapKey,\n+        EsU64, EsU32, EsU16, EsU8, EsI64, EsI32, EsI16, EsI8,\n+        EsBool, EsF64, EsF32, EsChar, EsStr, EsMapVal,\n+        EsOpaque, NUM_IMPLICIT_TAGS, NUM_TAGS };\n+    use super::io::SeekableMemWriter;\n \n     use serialize;\n \n \n     pub type EncodeResult = old_io::IoResult<()>;\n \n     // rbml writing\n-    pub struct Encoder<'a, W:'a> {\n-        pub writer: &'a mut W,\n+    pub struct Encoder<'a> {\n+        pub writer: &'a mut SeekableMemWriter,\n         size_positions: Vec<uint>,\n+        relax_limit: u64, // do not move encoded bytes before this position\n+    }\n+\n+    fn write_tag<W: Writer>(w: &mut W, n: uint) -> EncodeResult {\n+        if n < 0xf0 {\n+            w.write_all(&[n as u8])\n+        } else if 0x100 <= n && n < NUM_TAGS {\n+            w.write_all(&[0xf0 | (n >> 8) as u8, n as u8])\n+        } else {\n+            Err(old_io::IoError {\n+                kind: old_io::OtherIoError,\n+                desc: \"invalid tag\",\n+                detail: Some(format!(\"{}\", n))\n+            })\n+        }\n     }\n \n     fn write_sized_vuint<W: Writer>(w: &mut W, n: uint, size: uint) -> EncodeResult {\n@@ -746,27 +903,30 @@ pub mod writer {\n         })\n     }\n \n-    impl<'a, W: Writer + Seek> Encoder<'a, W> {\n-        pub fn new(w: &'a mut W) -> Encoder<'a, W> {\n+    impl<'a> Encoder<'a> {\n+        pub fn new(w: &'a mut SeekableMemWriter) -> Encoder<'a> {\n             Encoder {\n                 writer: w,\n                 size_positions: vec!(),\n+                relax_limit: 0,\n             }\n         }\n \n         /// FIXME(pcwalton): Workaround for badness in trans. DO NOT USE ME.\n-        pub unsafe fn unsafe_clone(&self) -> Encoder<'a, W> {\n+        pub unsafe fn unsafe_clone(&self) -> Encoder<'a> {\n             Encoder {\n                 writer: mem::transmute_copy(&self.writer),\n                 size_positions: self.size_positions.clone(),\n+                relax_limit: self.relax_limit,\n             }\n         }\n \n         pub fn start_tag(&mut self, tag_id: uint) -> EncodeResult {\n             debug!(\"Start tag {:?}\", tag_id);\n+            assert!(tag_id >= NUM_IMPLICIT_TAGS);\n \n             // Write the enum ID:\n-            try!(write_vuint(self.writer, tag_id));\n+            try!(write_tag(self.writer, tag_id));\n \n             // Write a placeholder four-byte size.\n             self.size_positions.push(try!(self.writer.tell()) as uint);\n@@ -779,11 +939,29 @@ pub mod writer {\n             let cur_pos = try!(self.writer.tell());\n             try!(self.writer.seek(last_size_pos as i64, old_io::SeekSet));\n             let size = cur_pos as uint - last_size_pos - 4;\n-            try!(write_sized_vuint(self.writer, size, 4));\n-            let r = try!(self.writer.seek(cur_pos as i64, old_io::SeekSet));\n+\n+            // relax the size encoding for small tags (bigger tags are costly to move).\n+            // we should never try to move the stable positions, however.\n+            const RELAX_MAX_SIZE: uint = 0x100;\n+            if size <= RELAX_MAX_SIZE && last_size_pos >= self.relax_limit as uint {\n+                // we can't alter the buffer in place, so have a temporary buffer\n+                let mut buf = [0u8; RELAX_MAX_SIZE];\n+                {\n+                    let data = &self.writer.get_ref()[last_size_pos+4..cur_pos as uint];\n+                    bytes::copy_memory(&mut buf, data);\n+                }\n+\n+                // overwrite the size and data and continue\n+                try!(write_vuint(self.writer, size));\n+                try!(self.writer.write_all(&buf[..size]));\n+            } else {\n+                // overwrite the size with an overlong encoding and skip past the data\n+                try!(write_sized_vuint(self.writer, size, 4));\n+                try!(self.writer.seek(cur_pos as i64, old_io::SeekSet));\n+            }\n \n             debug!(\"End tag (size = {:?})\", size);\n-            Ok(r)\n+            Ok(())\n         }\n \n         pub fn wr_tag<F>(&mut self, tag_id: uint, blk: F) -> EncodeResult where\n@@ -795,7 +973,8 @@ pub mod writer {\n         }\n \n         pub fn wr_tagged_bytes(&mut self, tag_id: uint, b: &[u8]) -> EncodeResult {\n-            try!(write_vuint(self.writer, tag_id));\n+            assert!(tag_id >= NUM_IMPLICIT_TAGS);\n+            try!(write_tag(self.writer, tag_id));\n             try!(write_vuint(self.writer, b.len()));\n             self.writer.write_all(b)\n         }\n@@ -839,6 +1018,47 @@ pub mod writer {\n             self.wr_tagged_bytes(tag_id, v.as_bytes())\n         }\n \n+        // for auto-serialization\n+        fn wr_tagged_raw_bytes(&mut self, tag_id: uint, b: &[u8]) -> EncodeResult {\n+            try!(write_tag(self.writer, tag_id));\n+            self.writer.write_all(b)\n+        }\n+\n+        fn wr_tagged_raw_u64(&mut self, tag_id: uint, v: u64) -> EncodeResult {\n+            let bytes: [u8; 8] = unsafe { mem::transmute(v.to_be()) };\n+            self.wr_tagged_raw_bytes(tag_id, &bytes)\n+        }\n+\n+        fn wr_tagged_raw_u32(&mut self, tag_id: uint, v: u32)  -> EncodeResult{\n+            let bytes: [u8; 4] = unsafe { mem::transmute(v.to_be()) };\n+            self.wr_tagged_raw_bytes(tag_id, &bytes)\n+        }\n+\n+        fn wr_tagged_raw_u16(&mut self, tag_id: uint, v: u16) -> EncodeResult {\n+            let bytes: [u8; 2] = unsafe { mem::transmute(v.to_be()) };\n+            self.wr_tagged_raw_bytes(tag_id, &bytes)\n+        }\n+\n+        fn wr_tagged_raw_u8(&mut self, tag_id: uint, v: u8) -> EncodeResult {\n+            self.wr_tagged_raw_bytes(tag_id, &[v])\n+        }\n+\n+        fn wr_tagged_raw_i64(&mut self, tag_id: uint, v: i64) -> EncodeResult {\n+            self.wr_tagged_raw_u64(tag_id, v as u64)\n+        }\n+\n+        fn wr_tagged_raw_i32(&mut self, tag_id: uint, v: i32) -> EncodeResult {\n+            self.wr_tagged_raw_u32(tag_id, v as u32)\n+        }\n+\n+        fn wr_tagged_raw_i16(&mut self, tag_id: uint, v: i16) -> EncodeResult {\n+            self.wr_tagged_raw_u16(tag_id, v as u16)\n+        }\n+\n+        fn wr_tagged_raw_i8(&mut self, tag_id: uint, v: i8) -> EncodeResult {\n+            self.wr_tagged_raw_bytes(tag_id, &[v as u8])\n+        }\n+\n         pub fn wr_bytes(&mut self, b: &[u8]) -> EncodeResult {\n             debug!(\"Write {:?} bytes\", b.len());\n             self.writer.write_all(b)\n@@ -848,108 +1068,123 @@ pub mod writer {\n             debug!(\"Write str: {:?}\", s);\n             self.writer.write_all(s.as_bytes())\n         }\n-    }\n-\n-    // FIXME (#2743): optionally perform \"relaxations\" on end_tag to more\n-    // efficiently encode sizes; this is a fixed point iteration\n-\n-    // Set to true to generate more debugging in EBML code.\n-    // Totally lame approach.\n-    #[cfg(not(ndebug))]\n-    static DEBUG: bool = true;\n-    #[cfg(ndebug)]\n-    static DEBUG: bool = false;\n \n-    impl<'a, W: Writer + Seek> Encoder<'a, W> {\n-        // used internally to emit things like the vector length and so on\n-        fn _emit_tagged_uint(&mut self, t: EbmlEncoderTag, v: uint) -> EncodeResult {\n-            assert!(v <= 0xFFFF_FFFF);\n-            self.wr_tagged_u32(t as uint, v as u32)\n+        /// Returns the current position while marking it stable, i.e.\n+        /// generated bytes so far woundn't be affected by relaxation.\n+        pub fn mark_stable_position(&mut self) -> u64 {\n+            let pos = self.writer.tell().unwrap();\n+            if self.relax_limit < pos {\n+                self.relax_limit = pos;\n+            }\n+            pos\n         }\n+    }\n \n-        fn _emit_label(&mut self, label: &str) -> EncodeResult {\n-            // There are various strings that we have access to, such as\n-            // the name of a record field, which do not actually appear in\n-            // the encoded EBML (normally).  This is just for\n-            // efficiency.  When debugging, though, we can emit such\n-            // labels and then they will be checked by decoder to\n-            // try and check panics more quickly.\n-            if DEBUG { self.wr_tagged_str(EsLabel as uint, label) }\n-            else { Ok(()) }\n+    impl<'a> Encoder<'a> {\n+        // used internally to emit things like the vector length and so on\n+        fn _emit_tagged_sub(&mut self, v: uint) -> EncodeResult {\n+            if let Some(v) = v.to_u8() {\n+                self.wr_tagged_raw_u8(EsSub8 as uint, v)\n+            } else if let Some(v) = v.to_u32() {\n+                self.wr_tagged_raw_u32(EsSub32 as uint, v)\n+            } else {\n+                Err(old_io::IoError {\n+                    kind: old_io::OtherIoError,\n+                    desc: \"length or variant id too big\",\n+                    detail: Some(format!(\"{}\", v))\n+                })\n+            }\n         }\n \n         pub fn emit_opaque<F>(&mut self, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder) -> EncodeResult,\n         {\n             try!(self.start_tag(EsOpaque as uint));\n             try!(f(self));\n             self.end_tag()\n         }\n     }\n \n-    impl<'a, W: Writer + Seek> serialize::Encoder for Encoder<'a, W> {\n+    impl<'a> serialize::Encoder for Encoder<'a> {\n         type Error = old_io::IoError;\n \n         fn emit_nil(&mut self) -> EncodeResult {\n             Ok(())\n         }\n \n         fn emit_uint(&mut self, v: uint) -> EncodeResult {\n-            self.wr_tagged_u64(EsUint as uint, v as u64)\n+            self.emit_u64(v as u64)\n         }\n         fn emit_u64(&mut self, v: u64) -> EncodeResult {\n-            self.wr_tagged_u64(EsU64 as uint, v)\n+            match v.to_u32() {\n+                Some(v) => self.emit_u32(v),\n+                None => self.wr_tagged_raw_u64(EsU64 as uint, v)\n+            }\n         }\n         fn emit_u32(&mut self, v: u32) -> EncodeResult {\n-            self.wr_tagged_u32(EsU32 as uint, v)\n+            match v.to_u16() {\n+                Some(v) => self.emit_u16(v),\n+                None => self.wr_tagged_raw_u32(EsU32 as uint, v)\n+            }\n         }\n         fn emit_u16(&mut self, v: u16) -> EncodeResult {\n-            self.wr_tagged_u16(EsU16 as uint, v)\n+            match v.to_u8() {\n+                Some(v) => self.emit_u8(v),\n+                None => self.wr_tagged_raw_u16(EsU16 as uint, v)\n+            }\n         }\n         fn emit_u8(&mut self, v: u8) -> EncodeResult {\n-            self.wr_tagged_u8(EsU8 as uint, v)\n+            self.wr_tagged_raw_u8(EsU8 as uint, v)\n         }\n \n         fn emit_int(&mut self, v: int) -> EncodeResult {\n-            self.wr_tagged_i64(EsInt as uint, v as i64)\n+            self.emit_i64(v as i64)\n         }\n         fn emit_i64(&mut self, v: i64) -> EncodeResult {\n-            self.wr_tagged_i64(EsI64 as uint, v)\n+            match v.to_i32() {\n+                Some(v) => self.emit_i32(v),\n+                None => self.wr_tagged_raw_i64(EsI64 as uint, v)\n+            }\n         }\n         fn emit_i32(&mut self, v: i32) -> EncodeResult {\n-            self.wr_tagged_i32(EsI32 as uint, v)\n+            match v.to_i16() {\n+                Some(v) => self.emit_i16(v),\n+                None => self.wr_tagged_raw_i32(EsI32 as uint, v)\n+            }\n         }\n         fn emit_i16(&mut self, v: i16) -> EncodeResult {\n-            self.wr_tagged_i16(EsI16 as uint, v)\n+            match v.to_i8() {\n+                Some(v) => self.emit_i8(v),\n+                None => self.wr_tagged_raw_i16(EsI16 as uint, v)\n+            }\n         }\n         fn emit_i8(&mut self, v: i8) -> EncodeResult {\n-            self.wr_tagged_i8(EsI8 as uint, v)\n+            self.wr_tagged_raw_i8(EsI8 as uint, v)\n         }\n \n         fn emit_bool(&mut self, v: bool) -> EncodeResult {\n-            self.wr_tagged_u8(EsBool as uint, v as u8)\n+            self.wr_tagged_raw_u8(EsBool as uint, v as u8)\n         }\n \n         fn emit_f64(&mut self, v: f64) -> EncodeResult {\n             let bits = unsafe { mem::transmute(v) };\n-            self.wr_tagged_u64(EsF64 as uint, bits)\n+            self.wr_tagged_raw_u64(EsF64 as uint, bits)\n         }\n         fn emit_f32(&mut self, v: f32) -> EncodeResult {\n             let bits = unsafe { mem::transmute(v) };\n-            self.wr_tagged_u32(EsF32 as uint, bits)\n+            self.wr_tagged_raw_u32(EsF32 as uint, bits)\n         }\n         fn emit_char(&mut self, v: char) -> EncodeResult {\n-            self.wr_tagged_u32(EsChar as uint, v as u32)\n+            self.wr_tagged_raw_u32(EsChar as uint, v as u32)\n         }\n \n         fn emit_str(&mut self, v: &str) -> EncodeResult {\n             self.wr_tagged_str(EsStr as uint, v)\n         }\n \n-        fn emit_enum<F>(&mut self, name: &str, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n-            try!(self._emit_label(name));\n             try!(self.start_tag(EsEnum as uint));\n             try!(f(self));\n             self.end_tag()\n@@ -960,16 +1195,14 @@ pub mod writer {\n                                 v_id: uint,\n                                 _: uint,\n                                 f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n-            try!(self._emit_tagged_uint(EsEnumVid, v_id));\n-            try!(self.start_tag(EsEnumBody as uint));\n-            try!(f(self));\n-            self.end_tag()\n+            try!(self._emit_tagged_sub(v_id));\n+            f(self)\n         }\n \n         fn emit_enum_variant_arg<F>(&mut self, _: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             f(self)\n         }\n@@ -979,7 +1212,7 @@ pub mod writer {\n                                        v_id: uint,\n                                        cnt: uint,\n                                        f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             self.emit_enum_variant(v_name, v_id, cnt, f)\n         }\n@@ -988,73 +1221,76 @@ pub mod writer {\n                                              _: &str,\n                                              idx: uint,\n                                              f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             self.emit_enum_variant_arg(idx, f)\n         }\n \n         fn emit_struct<F>(&mut self, _: &str, _len: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             f(self)\n         }\n \n-        fn emit_struct_field<F>(&mut self, name: &str, _: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        fn emit_struct_field<F>(&mut self, _name: &str, _: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n-            try!(self._emit_label(name));\n             f(self)\n         }\n \n         fn emit_tuple<F>(&mut self, len: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             self.emit_seq(len, f)\n         }\n         fn emit_tuple_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             self.emit_seq_elt(idx, f)\n         }\n \n         fn emit_tuple_struct<F>(&mut self, _: &str, len: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             self.emit_seq(len, f)\n         }\n         fn emit_tuple_struct_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             self.emit_seq_elt(idx, f)\n         }\n \n         fn emit_option<F>(&mut self, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             self.emit_enum(\"Option\", f)\n         }\n         fn emit_option_none(&mut self) -> EncodeResult {\n             self.emit_enum_variant(\"None\", 0, 0, |_| Ok(()))\n         }\n         fn emit_option_some<F>(&mut self, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n \n             self.emit_enum_variant(\"Some\", 1, 1, f)\n         }\n \n         fn emit_seq<F>(&mut self, len: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n+            if len == 0 {\n+                // empty vector optimization\n+                return self.wr_tagged_bytes(EsVec as uint, &[]);\n+            }\n \n             try!(self.start_tag(EsVec as uint));\n-            try!(self._emit_tagged_uint(EsVecLen, len));\n+            try!(self._emit_tagged_sub(len));\n             try!(f(self));\n             self.end_tag()\n         }\n \n         fn emit_seq_elt<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n \n             try!(self.start_tag(EsVecElt as uint));\n@@ -1063,17 +1299,21 @@ pub mod writer {\n         }\n \n         fn emit_map<F>(&mut self, len: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n+            if len == 0 {\n+                // empty map optimization\n+                return self.wr_tagged_bytes(EsMap as uint, &[]);\n+            }\n \n             try!(self.start_tag(EsMap as uint));\n-            try!(self._emit_tagged_uint(EsMapLen, len));\n+            try!(self._emit_tagged_sub(len));\n             try!(f(self));\n             self.end_tag()\n         }\n \n         fn emit_map_elt_key<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n \n             try!(self.start_tag(EsMapKey as uint));\n@@ -1082,7 +1322,7 @@ pub mod writer {\n         }\n \n         fn emit_map_elt_val<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             try!(self.start_tag(EsMapVal as uint));\n             try!(f(self));"}, {"sha": "a58ef53de9a7135591de41d12b98c66777411a62", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 139, "deletions": 141, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/24a840d4897f0853cb034e5a1b51fb28cd450f11/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a840d4897f0853cb034e5a1b51fb28cd450f11/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=24a840d4897f0853cb034e5a1b51fb28cd450f11", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -14,85 +14,90 @@ pub use self::astencode_tag::*;\n \n use back::svh::Svh;\n \n-// EBML enum definitions and utils shared by the encoder and decoder\n+// RBML enum definitions and utils shared by the encoder and decoder\n+//\n+// 0x00..0x1f: reserved for RBML generic type tags\n+// 0x20..0xef: free for use, preferred for frequent tags\n+// 0xf0..0xff: internally used by RBML to encode 0x100..0xfff in two bytes\n+// 0x100..0xfff: free for use, preferred for infrequent tags\n \n-pub const tag_items: uint = 0x00;\n+pub const tag_items: uint = 0x100; // top-level only\n \n-pub const tag_paths_data_name: uint = 0x01;\n+pub const tag_paths_data_name: uint = 0x20;\n \n-pub const tag_def_id: uint = 0x02;\n+pub const tag_def_id: uint = 0x21;\n \n-pub const tag_items_data: uint = 0x03;\n+pub const tag_items_data: uint = 0x22;\n \n-pub const tag_items_data_item: uint = 0x04;\n+pub const tag_items_data_item: uint = 0x23;\n \n-pub const tag_items_data_item_family: uint = 0x05;\n+pub const tag_items_data_item_family: uint = 0x24;\n \n-pub const tag_items_data_item_type: uint = 0x07;\n+pub const tag_items_data_item_type: uint = 0x25;\n \n-pub const tag_items_data_item_symbol: uint = 0x08;\n+pub const tag_items_data_item_symbol: uint = 0x26;\n \n-pub const tag_items_data_item_variant: uint = 0x09;\n+pub const tag_items_data_item_variant: uint = 0x27;\n \n-pub const tag_items_data_parent_item: uint = 0x0a;\n+pub const tag_items_data_parent_item: uint = 0x28;\n \n-pub const tag_items_data_item_is_tuple_struct_ctor: uint = 0x0b;\n+pub const tag_items_data_item_is_tuple_struct_ctor: uint = 0x29;\n \n-pub const tag_index: uint = 0x0c;\n+pub const tag_index: uint = 0x2a;\n \n-pub const tag_index_buckets: uint = 0x0d;\n+pub const tag_index_buckets: uint = 0x2b;\n \n-pub const tag_index_buckets_bucket: uint = 0x0e;\n+pub const tag_index_buckets_bucket: uint = 0x2c;\n \n-pub const tag_index_buckets_bucket_elt: uint = 0x0f;\n+pub const tag_index_buckets_bucket_elt: uint = 0x2d;\n \n-pub const tag_index_table: uint = 0x10;\n+pub const tag_index_table: uint = 0x2e;\n \n-pub const tag_meta_item_name_value: uint = 0x11;\n+pub const tag_meta_item_name_value: uint = 0x2f;\n \n-pub const tag_meta_item_name: uint = 0x12;\n+pub const tag_meta_item_name: uint = 0x30;\n \n-pub const tag_meta_item_value: uint = 0x13;\n+pub const tag_meta_item_value: uint = 0x31;\n \n-pub const tag_attributes: uint = 0x14;\n+pub const tag_attributes: uint = 0x101; // top-level only\n \n-pub const tag_attribute: uint = 0x15;\n+pub const tag_attribute: uint = 0x32;\n \n-pub const tag_meta_item_word: uint = 0x16;\n+pub const tag_meta_item_word: uint = 0x33;\n \n-pub const tag_meta_item_list: uint = 0x17;\n+pub const tag_meta_item_list: uint = 0x34;\n \n // The list of crates that this crate depends on\n-pub const tag_crate_deps: uint = 0x18;\n+pub const tag_crate_deps: uint = 0x102; // top-level only\n \n // A single crate dependency\n-pub const tag_crate_dep: uint = 0x19;\n+pub const tag_crate_dep: uint = 0x35;\n \n-pub const tag_crate_hash: uint = 0x1a;\n-pub const tag_crate_crate_name: uint = 0x1b;\n+pub const tag_crate_hash: uint = 0x103; // top-level only\n+pub const tag_crate_crate_name: uint = 0x104; // top-level only\n \n-pub const tag_crate_dep_crate_name: uint = 0x1d;\n-pub const tag_crate_dep_hash: uint = 0x1e;\n+pub const tag_crate_dep_crate_name: uint = 0x36;\n+pub const tag_crate_dep_hash: uint = 0x37;\n \n-pub const tag_mod_impl: uint = 0x1f;\n+pub const tag_mod_impl: uint = 0x38;\n \n-pub const tag_item_trait_item: uint = 0x20;\n+pub const tag_item_trait_item: uint = 0x39;\n \n-pub const tag_item_trait_ref: uint = 0x21;\n-pub const tag_item_super_trait_ref: uint = 0x22;\n+pub const tag_item_trait_ref: uint = 0x3a;\n+pub const tag_item_super_trait_ref: uint = 0x3b;\n \n // discriminator value for variants\n-pub const tag_disr_val: uint = 0x23;\n+pub const tag_disr_val: uint = 0x3c;\n \n // used to encode ast_map::PathElem\n-pub const tag_path: uint = 0x24;\n-pub const tag_path_len: uint = 0x25;\n-pub const tag_path_elem_mod: uint = 0x26;\n-pub const tag_path_elem_name: uint = 0x27;\n-pub const tag_item_field: uint = 0x28;\n-pub const tag_item_field_origin: uint = 0x29;\n-\n-pub const tag_item_variances: uint = 0x2a;\n+pub const tag_path: uint = 0x3d;\n+pub const tag_path_len: uint = 0x3e;\n+pub const tag_path_elem_mod: uint = 0x3f;\n+pub const tag_path_elem_name: uint = 0x40;\n+pub const tag_item_field: uint = 0x41;\n+pub const tag_item_field_origin: uint = 0x42;\n+\n+pub const tag_item_variances: uint = 0x43;\n /*\n   trait items contain tag_item_trait_item elements,\n   impl items contain tag_item_impl_item elements, and classes\n@@ -101,60 +106,59 @@ pub const tag_item_variances: uint = 0x2a;\n   both, tag_item_trait_item and tag_item_impl_item have to be two\n   different tags.\n  */\n-pub const tag_item_impl_item: uint = 0x30;\n-pub const tag_item_trait_method_explicit_self: uint = 0x31;\n+pub const tag_item_impl_item: uint = 0x44;\n+pub const tag_item_trait_method_explicit_self: uint = 0x45;\n \n \n // Reexports are found within module tags. Each reexport contains def_ids\n // and names.\n-pub const tag_items_data_item_reexport: uint = 0x38;\n-pub const tag_items_data_item_reexport_def_id: uint = 0x39;\n-pub const tag_items_data_item_reexport_name: uint = 0x3a;\n+pub const tag_items_data_item_reexport: uint = 0x46;\n+pub const tag_items_data_item_reexport_def_id: uint = 0x47;\n+pub const tag_items_data_item_reexport_name: uint = 0x48;\n \n // used to encode crate_ctxt side tables\n #[derive(Copy, PartialEq, FromPrimitive)]\n #[repr(uint)]\n-pub enum astencode_tag { // Reserves 0x40 -- 0x5f\n-    tag_ast = 0x40,\n-\n-    tag_tree = 0x41,\n-\n-    tag_id_range = 0x42,\n-\n-    tag_table = 0x43,\n-    tag_table_id = 0x44,\n-    tag_table_val = 0x45,\n-    tag_table_def = 0x46,\n-    tag_table_node_type = 0x47,\n-    tag_table_item_subst = 0x48,\n-    tag_table_freevars = 0x49,\n-    tag_table_tcache = 0x4a,\n-    tag_table_param_defs = 0x4b,\n-    tag_table_mutbl = 0x4c,\n-    tag_table_last_use = 0x4d,\n-    tag_table_spill = 0x4e,\n-    tag_table_method_map = 0x4f,\n-    tag_table_vtable_map = 0x50,\n-    tag_table_adjustments = 0x51,\n-    tag_table_moves_map = 0x52,\n-    tag_table_capture_map = 0x53,\n-    tag_table_closure_tys = 0x54,\n-    tag_table_closure_kinds = 0x55,\n-    tag_table_upvar_capture_map = 0x56,\n-    tag_table_capture_modes = 0x57,\n-    tag_table_object_cast_map = 0x58,\n-    tag_table_const_qualif = 0x59,\n+pub enum astencode_tag { // Reserves 0x50 -- 0x6f\n+    tag_ast = 0x50,\n+\n+    tag_tree = 0x51,\n+\n+    tag_id_range = 0x52,\n+\n+    tag_table = 0x53,\n+    // GAP 0x54, 0x55\n+    tag_table_def = 0x56,\n+    tag_table_node_type = 0x57,\n+    tag_table_item_subst = 0x58,\n+    tag_table_freevars = 0x59,\n+    tag_table_tcache = 0x5a,\n+    tag_table_param_defs = 0x5b,\n+    tag_table_mutbl = 0x5c,\n+    tag_table_last_use = 0x5d,\n+    tag_table_spill = 0x5e,\n+    tag_table_method_map = 0x5f,\n+    tag_table_vtable_map = 0x60,\n+    tag_table_adjustments = 0x61,\n+    tag_table_moves_map = 0x62,\n+    tag_table_capture_map = 0x63,\n+    tag_table_closure_tys = 0x64,\n+    tag_table_closure_kinds = 0x65,\n+    tag_table_upvar_capture_map = 0x66,\n+    tag_table_capture_modes = 0x67,\n+    tag_table_object_cast_map = 0x68,\n+    tag_table_const_qualif = 0x69,\n }\n \n-pub const tag_item_trait_item_sort: uint = 0x60;\n+pub const tag_item_trait_item_sort: uint = 0x70;\n \n-pub const tag_item_trait_parent_sort: uint = 0x61;\n+pub const tag_item_trait_parent_sort: uint = 0x71;\n \n-pub const tag_item_impl_type_basename: uint = 0x62;\n+pub const tag_item_impl_type_basename: uint = 0x72;\n \n-pub const tag_crate_triple: uint = 0x66;\n+pub const tag_crate_triple: uint = 0x105; // top-level only\n \n-pub const tag_dylib_dependency_formats: uint = 0x67;\n+pub const tag_dylib_dependency_formats: uint = 0x106; // top-level only\n \n // Language items are a top-level directory (for speed). Hierarchy:\n //\n@@ -163,94 +167,88 @@ pub const tag_dylib_dependency_formats: uint = 0x67;\n //   - tag_lang_items_item_id: u32\n //   - tag_lang_items_item_node_id: u32\n \n-pub const tag_lang_items: uint = 0x70;\n-pub const tag_lang_items_item: uint = 0x71;\n-pub const tag_lang_items_item_id: uint = 0x72;\n-pub const tag_lang_items_item_node_id: uint = 0x73;\n-pub const tag_lang_items_missing: uint = 0x74;\n+pub const tag_lang_items: uint = 0x107; // top-level only\n+pub const tag_lang_items_item: uint = 0x73;\n+pub const tag_lang_items_item_id: uint = 0x74;\n+pub const tag_lang_items_item_node_id: uint = 0x75;\n+pub const tag_lang_items_missing: uint = 0x76;\n \n-pub const tag_item_unnamed_field: uint = 0x75;\n-pub const tag_items_data_item_visibility: uint = 0x76;\n+pub const tag_item_unnamed_field: uint = 0x77;\n+pub const tag_items_data_item_visibility: uint = 0x78;\n \n pub const tag_item_method_tps: uint = 0x79;\n pub const tag_item_method_fty: uint = 0x7a;\n \n pub const tag_mod_child: uint = 0x7b;\n-pub const tag_misc_info: uint = 0x7c;\n-pub const tag_misc_info_crate_items: uint = 0x7d;\n-\n-pub const tag_item_method_provided_source: uint = 0x7e;\n-pub const tag_item_impl_vtables: uint = 0x7f;\n+pub const tag_misc_info: uint = 0x108; // top-level only\n+pub const tag_misc_info_crate_items: uint = 0x7c;\n \n-pub const tag_impls: uint = 0x80;\n-pub const tag_impls_impl: uint = 0x81;\n+pub const tag_item_method_provided_source: uint = 0x7d;\n+pub const tag_item_impl_vtables: uint = 0x7e;\n \n-pub const tag_items_data_item_inherent_impl: uint = 0x82;\n-pub const tag_items_data_item_extension_impl: uint = 0x83;\n+pub const tag_impls: uint = 0x109; // top-level only\n+pub const tag_impls_impl: uint = 0x7f;\n \n-// GAP 0x84, 0x85, 0x86\n+pub const tag_items_data_item_inherent_impl: uint = 0x80;\n+pub const tag_items_data_item_extension_impl: uint = 0x81;\n \n-pub const tag_native_libraries: uint = 0x87;\n-pub const tag_native_libraries_lib: uint = 0x88;\n-pub const tag_native_libraries_name: uint = 0x89;\n-pub const tag_native_libraries_kind: uint = 0x8a;\n+pub const tag_native_libraries: uint = 0x10a; // top-level only\n+pub const tag_native_libraries_lib: uint = 0x82;\n+pub const tag_native_libraries_name: uint = 0x83;\n+pub const tag_native_libraries_kind: uint = 0x84;\n \n-pub const tag_plugin_registrar_fn: uint = 0x8b;\n+pub const tag_plugin_registrar_fn: uint = 0x10b; // top-level only\n \n-// GAP 0x8c, 0x8d\n+pub const tag_method_argument_names: uint = 0x85;\n+pub const tag_method_argument_name: uint = 0x86;\n \n-pub const tag_method_argument_names: uint = 0x8e;\n-pub const tag_method_argument_name: uint = 0x8f;\n+pub const tag_reachable_extern_fns: uint = 0x10c; // top-level only\n+pub const tag_reachable_extern_fn_id: uint = 0x87;\n \n-pub const tag_reachable_extern_fns: uint = 0x90;\n-pub const tag_reachable_extern_fn_id: uint = 0x91;\n+pub const tag_items_data_item_stability: uint = 0x88;\n \n-pub const tag_items_data_item_stability: uint = 0x92;\n-\n-pub const tag_items_data_item_repr: uint = 0x93;\n+pub const tag_items_data_item_repr: uint = 0x89;\n \n #[derive(Clone, Debug)]\n pub struct LinkMeta {\n     pub crate_name: String,\n     pub crate_hash: Svh,\n }\n \n-// GAP 0x94...0x98\n-\n-pub const tag_struct_fields: uint = 0x99;\n-pub const tag_struct_field: uint = 0x9a;\n-pub const tag_struct_field_id: uint = 0x9b;\n+pub const tag_struct_fields: uint = 0x10d; // top-level only\n+pub const tag_struct_field: uint = 0x8a;\n+pub const tag_struct_field_id: uint = 0x8b;\n \n-pub const tag_attribute_is_sugared_doc: uint = 0x9c;\n+pub const tag_attribute_is_sugared_doc: uint = 0x8c;\n \n-pub const tag_trait_def_bounds: uint = 0x9d;\n+pub const tag_trait_def_bounds: uint = 0x8d;\n \n-pub const tag_items_data_region: uint = 0x9e;\n+pub const tag_items_data_region: uint = 0x8e;\n \n-pub const tag_region_param_def: uint = 0xa0;\n-pub const tag_region_param_def_ident: uint = 0xa1;\n-pub const tag_region_param_def_def_id: uint = 0xa2;\n-pub const tag_region_param_def_space: uint = 0xa3;\n-pub const tag_region_param_def_index: uint = 0xa4;\n+pub const tag_region_param_def: uint = 0x8f;\n+pub const tag_region_param_def_ident: uint = 0x90;\n+pub const tag_region_param_def_def_id: uint = 0x91;\n+pub const tag_region_param_def_space: uint = 0x92;\n+pub const tag_region_param_def_index: uint = 0x93;\n \n-pub const tag_type_param_def: uint = 0xa5;\n+pub const tag_type_param_def: uint = 0x94;\n \n-pub const tag_item_generics: uint = 0xa6;\n-pub const tag_method_ty_generics: uint = 0xa7;\n+pub const tag_item_generics: uint = 0x95;\n+pub const tag_method_ty_generics: uint = 0x96;\n \n-pub const tag_predicate: uint = 0xa8;\n-pub const tag_predicate_space: uint = 0xa9;\n-pub const tag_predicate_data: uint = 0xb0;\n+pub const tag_predicate: uint = 0x97;\n+pub const tag_predicate_space: uint = 0x98;\n+pub const tag_predicate_data: uint = 0x99;\n \n-pub const tag_unsafety: uint = 0xb1;\n+pub const tag_unsafety: uint = 0x9a;\n \n-pub const tag_associated_type_names: uint = 0xb2;\n-pub const tag_associated_type_name: uint = 0xb3;\n+pub const tag_associated_type_names: uint = 0x9b;\n+pub const tag_associated_type_name: uint = 0x9c;\n \n-pub const tag_polarity: uint = 0xb4;\n+pub const tag_polarity: uint = 0x9d;\n \n-pub const tag_macro_defs: uint = 0xb5;\n-pub const tag_macro_def: uint = 0xb6;\n-pub const tag_macro_def_body: uint = 0xb7;\n+pub const tag_macro_defs: uint = 0x10e; // top-level only\n+pub const tag_macro_def: uint = 0x9e;\n+pub const tag_macro_def_body: uint = 0x9f;\n \n-pub const tag_paren_sugar: uint = 0xb8;\n+pub const tag_paren_sugar: uint = 0xa0;"}, {"sha": "131a299cc500fc9af6e4fd5ad050be88e6b274c4", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 102, "deletions": 178, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/24a840d4897f0853cb034e5a1b51fb28cd450f11/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a840d4897f0853cb034e5a1b51fb28cd450f11/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=24a840d4897f0853cb034e5a1b51fb28cd450f11", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -46,7 +46,7 @@ use syntax::ptr::P;\n use syntax::visit::Visitor;\n use syntax::visit;\n use syntax;\n-use rbml::writer;\n+use rbml::writer::Encoder;\n use rbml::io::SeekableMemWriter;\n \n /// A borrowed version of `ast::InlinedItem`.\n@@ -57,8 +57,6 @@ pub enum InlinedItemRef<'a> {\n     IIForeignRef(&'a ast::ForeignItem)\n }\n \n-pub type Encoder<'a> = writer::Encoder<'a, SeekableMemWriter>;\n-\n pub type EncodeInlinedItem<'a> =\n     Box<FnMut(&EncodeContext, &mut Encoder, InlinedItemRef) + 'a>;\n \n@@ -115,15 +113,13 @@ fn encode_trait_ref<'a, 'tcx>(rbml_w: &mut Encoder,\n     };\n \n     rbml_w.start_tag(tag);\n-    tyencode::enc_trait_ref(rbml_w.writer, ty_str_ctxt, trait_ref);\n+    tyencode::enc_trait_ref(rbml_w, ty_str_ctxt, trait_ref);\n     rbml_w.end_tag();\n }\n \n // Item info table encoding\n fn encode_family(rbml_w: &mut Encoder, c: char) {\n-    rbml_w.start_tag(tag_items_data_item_family);\n-    rbml_w.writer.write_all(&[c as u8]);\n-    rbml_w.end_tag();\n+    rbml_w.wr_tagged_u8(tag_items_data_item_family, c as u8);\n }\n \n pub fn def_to_string(did: DefId) -> String {\n@@ -157,14 +153,9 @@ fn encode_bounds_and_type<'a, 'tcx>(rbml_w: &mut Encoder,\n }\n \n fn encode_variant_id(rbml_w: &mut Encoder, vid: DefId) {\n-    rbml_w.start_tag(tag_items_data_item_variant);\n     let s = def_to_string(vid);\n-    rbml_w.writer.write_all(s.as_bytes());\n-    rbml_w.end_tag();\n-\n-    rbml_w.start_tag(tag_mod_child);\n-    rbml_w.wr_str(&s[..]);\n-    rbml_w.end_tag();\n+    rbml_w.wr_tagged_str(tag_items_data_item_variant, &s[..]);\n+    rbml_w.wr_tagged_str(tag_mod_child, &s[..]);\n }\n \n pub fn write_closure_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n@@ -176,7 +167,7 @@ pub fn write_closure_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         tcx: ecx.tcx,\n         abbrevs: &ecx.type_abbrevs\n     };\n-    tyencode::enc_closure_ty(rbml_w.writer, ty_str_ctxt, closure_type);\n+    tyencode::enc_closure_ty(rbml_w, ty_str_ctxt, closure_type);\n }\n \n pub fn write_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n@@ -188,7 +179,7 @@ pub fn write_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         tcx: ecx.tcx,\n         abbrevs: &ecx.type_abbrevs\n     };\n-    tyencode::enc_ty(rbml_w.writer, ty_str_ctxt, typ);\n+    tyencode::enc_ty(rbml_w, ty_str_ctxt, typ);\n }\n \n pub fn write_trait_ref<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n@@ -200,7 +191,7 @@ pub fn write_trait_ref<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         tcx: ecx.tcx,\n         abbrevs: &ecx.type_abbrevs\n     };\n-    tyencode::enc_trait_ref(rbml_w.writer, ty_str_ctxt, trait_ref);\n+    tyencode::enc_trait_ref(rbml_w, ty_str_ctxt, trait_ref);\n }\n \n pub fn write_region(ecx: &EncodeContext,\n@@ -212,7 +203,7 @@ pub fn write_region(ecx: &EncodeContext,\n         tcx: ecx.tcx,\n         abbrevs: &ecx.type_abbrevs\n     };\n-    tyencode::enc_region(rbml_w.writer, ty_str_ctxt, r);\n+    tyencode::enc_region(rbml_w, ty_str_ctxt, r);\n }\n \n fn encode_bounds<'a, 'tcx>(rbml_w: &mut Encoder,\n@@ -225,7 +216,7 @@ fn encode_bounds<'a, 'tcx>(rbml_w: &mut Encoder,\n                                         ds: def_to_string,\n                                         tcx: ecx.tcx,\n                                         abbrevs: &ecx.type_abbrevs };\n-    tyencode::enc_bounds(rbml_w.writer, ty_str_ctxt, bounds);\n+    tyencode::enc_bounds(rbml_w, ty_str_ctxt, bounds);\n \n     rbml_w.end_tag();\n }\n@@ -257,42 +248,34 @@ fn encode_method_fty<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         tcx: ecx.tcx,\n         abbrevs: &ecx.type_abbrevs\n     };\n-    tyencode::enc_bare_fn_ty(rbml_w.writer, ty_str_ctxt, typ);\n+    tyencode::enc_bare_fn_ty(rbml_w, ty_str_ctxt, typ);\n \n     rbml_w.end_tag();\n }\n \n fn encode_symbol(ecx: &EncodeContext,\n                  rbml_w: &mut Encoder,\n                  id: NodeId) {\n-    rbml_w.start_tag(tag_items_data_item_symbol);\n     match ecx.item_symbols.borrow().get(&id) {\n         Some(x) => {\n             debug!(\"encode_symbol(id={}, str={})\", id, *x);\n-            rbml_w.writer.write_all(x.as_bytes());\n+            rbml_w.wr_tagged_str(tag_items_data_item_symbol, x);\n         }\n         None => {\n             ecx.diag.handler().bug(\n                 &format!(\"encode_symbol: id not found {}\", id));\n         }\n     }\n-    rbml_w.end_tag();\n }\n \n fn encode_disr_val(_: &EncodeContext,\n                    rbml_w: &mut Encoder,\n                    disr_val: ty::Disr) {\n-    rbml_w.start_tag(tag_disr_val);\n-    let s = disr_val.to_string();\n-    rbml_w.writer.write_all(s.as_bytes());\n-    rbml_w.end_tag();\n+    rbml_w.wr_tagged_str(tag_disr_val, &disr_val.to_string());\n }\n \n fn encode_parent_item(rbml_w: &mut Encoder, id: DefId) {\n-    rbml_w.start_tag(tag_items_data_parent_item);\n-    let s = def_to_string(id);\n-    rbml_w.writer.write_all(s.as_bytes());\n-    rbml_w.end_tag();\n+    rbml_w.wr_tagged_str(tag_items_data_parent_item, &def_to_string(id));\n }\n \n fn encode_struct_fields(rbml_w: &mut Encoder,\n@@ -307,10 +290,7 @@ fn encode_struct_fields(rbml_w: &mut Encoder,\n         }\n         encode_struct_field_family(rbml_w, f.vis);\n         encode_def_id(rbml_w, f.id);\n-        rbml_w.start_tag(tag_item_field_origin);\n-        let s = def_to_string(origin);\n-        rbml_w.writer.write_all(s.as_bytes());\n-        rbml_w.end_tag();\n+        rbml_w.wr_tagged_str(tag_item_field_origin, &def_to_string(origin));\n         rbml_w.end_tag();\n     }\n }\n@@ -330,7 +310,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n         let def_id = local_def(variant.node.id);\n         index.push(entry {\n             val: variant.node.id as i64,\n-            pos: rbml_w.writer.tell().unwrap(),\n+            pos: rbml_w.mark_stable_position(),\n         });\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n@@ -393,14 +373,11 @@ fn encode_reexported_static_method(rbml_w: &mut Encoder,\n     debug!(\"(encode reexported static method) {}::{}\",\n             exp.name, token::get_name(method_name));\n     rbml_w.start_tag(tag_items_data_item_reexport);\n-    rbml_w.start_tag(tag_items_data_item_reexport_def_id);\n-    rbml_w.wr_str(&def_to_string(method_def_id));\n-    rbml_w.end_tag();\n-    rbml_w.start_tag(tag_items_data_item_reexport_name);\n-    rbml_w.wr_str(&format!(\"{}::{}\",\n-                          exp.name,\n-                          token::get_name(method_name)));\n-    rbml_w.end_tag();\n+    rbml_w.wr_tagged_str(tag_items_data_item_reexport_def_id,\n+                         &def_to_string(method_def_id));\n+    rbml_w.wr_tagged_str(tag_items_data_item_reexport_name,\n+                         &format!(\"{}::{}\", exp.name,\n+                                            token::get_name(method_name)));\n     rbml_w.end_tag();\n }\n \n@@ -536,12 +513,10 @@ fn encode_reexports(ecx: &EncodeContext,\n                        exp.def_id.node,\n                        id);\n                 rbml_w.start_tag(tag_items_data_item_reexport);\n-                rbml_w.start_tag(tag_items_data_item_reexport_def_id);\n-                rbml_w.wr_str(&def_to_string(exp.def_id));\n-                rbml_w.end_tag();\n-                rbml_w.start_tag(tag_items_data_item_reexport_name);\n-                rbml_w.wr_str(exp.name.as_str());\n-                rbml_w.end_tag();\n+                rbml_w.wr_tagged_str(tag_items_data_item_reexport_def_id,\n+                                     &def_to_string(exp.def_id));\n+                rbml_w.wr_tagged_str(tag_items_data_item_reexport_name,\n+                                     exp.name.as_str());\n                 rbml_w.end_tag();\n                 encode_reexported_static_methods(ecx, rbml_w, path.clone(), exp);\n             }\n@@ -569,15 +544,12 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n \n     // Encode info about all the module children.\n     for item in &md.items {\n-        rbml_w.start_tag(tag_mod_child);\n-        rbml_w.wr_str(&def_to_string(local_def(item.id)));\n-        rbml_w.end_tag();\n+        rbml_w.wr_tagged_str(tag_mod_child,\n+                             &def_to_string(local_def(item.id)));\n \n         each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n-            rbml_w.start_tag(tag_mod_child);\n-            rbml_w.wr_str(&def_to_string(local_def(\n-                        auxiliary_node_id)));\n-            rbml_w.end_tag();\n+            rbml_w.wr_tagged_str(tag_mod_child,\n+                                 &def_to_string(local_def(auxiliary_node_id)));\n             true\n         });\n \n@@ -587,9 +559,8 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                    token::get_ident(ident),\n                    did, ecx.tcx.map.node_to_string(did));\n \n-            rbml_w.start_tag(tag_mod_impl);\n-            rbml_w.wr_str(&def_to_string(local_def(did)));\n-            rbml_w.end_tag();\n+            rbml_w.wr_tagged_str(tag_mod_impl,\n+                                 &def_to_string(local_def(did)));\n         }\n     }\n \n@@ -618,67 +589,56 @@ fn encode_struct_field_family(rbml_w: &mut Encoder,\n }\n \n fn encode_visibility(rbml_w: &mut Encoder, visibility: ast::Visibility) {\n-    rbml_w.start_tag(tag_items_data_item_visibility);\n     let ch = match visibility {\n         ast::Public => 'y',\n         ast::Inherited => 'i',\n     };\n-    rbml_w.wr_str(&ch.to_string());\n-    rbml_w.end_tag();\n+    rbml_w.wr_tagged_u8(tag_items_data_item_visibility, ch as u8);\n }\n \n fn encode_explicit_self(rbml_w: &mut Encoder,\n                         explicit_self: &ty::ExplicitSelfCategory) {\n-    rbml_w.start_tag(tag_item_trait_method_explicit_self);\n+    let tag = tag_item_trait_method_explicit_self;\n \n     // Encode the base self type.\n     match *explicit_self {\n         ty::StaticExplicitSelfCategory => {\n-            rbml_w.writer.write_all(&[ 's' as u8 ]);\n+            rbml_w.wr_tagged_bytes(tag, &['s' as u8]);\n         }\n         ty::ByValueExplicitSelfCategory => {\n-            rbml_w.writer.write_all(&[ 'v' as u8 ]);\n+            rbml_w.wr_tagged_bytes(tag, &['v' as u8]);\n         }\n         ty::ByBoxExplicitSelfCategory => {\n-            rbml_w.writer.write_all(&[ '~' as u8 ]);\n+            rbml_w.wr_tagged_bytes(tag, &['~' as u8]);\n         }\n         ty::ByReferenceExplicitSelfCategory(_, m) => {\n             // FIXME(#4846) encode custom lifetime\n-            rbml_w.writer.write_all(&['&' as u8]);\n-            encode_mutability(rbml_w, m);\n+            let ch = encode_mutability(m);\n+            rbml_w.wr_tagged_bytes(tag, &['&' as u8, ch]);\n         }\n     }\n \n-    rbml_w.end_tag();\n-\n-    fn encode_mutability(rbml_w: &mut Encoder,\n-                         m: ast::Mutability) {\n+    fn encode_mutability(m: ast::Mutability) -> u8 {\n         match m {\n-            ast::MutImmutable => { rbml_w.writer.write_all(&[ 'i' as u8 ]); }\n-            ast::MutMutable => { rbml_w.writer.write_all(&[ 'm' as u8 ]); }\n+            ast::MutImmutable => 'i' as u8,\n+            ast::MutMutable => 'm' as u8,\n         }\n     }\n }\n \n fn encode_item_sort(rbml_w: &mut Encoder, sort: char) {\n-    rbml_w.start_tag(tag_item_trait_item_sort);\n-    rbml_w.writer.write_all(&[ sort as u8 ]);\n-    rbml_w.end_tag();\n+    rbml_w.wr_tagged_u8(tag_item_trait_item_sort, sort as u8);\n }\n \n fn encode_parent_sort(rbml_w: &mut Encoder, sort: char) {\n-    rbml_w.start_tag(tag_item_trait_parent_sort);\n-    rbml_w.writer.write_all(&[ sort as u8 ]);\n-    rbml_w.end_tag();\n+    rbml_w.wr_tagged_u8(tag_item_trait_parent_sort, sort as u8);\n }\n \n fn encode_provided_source(rbml_w: &mut Encoder,\n                           source_opt: Option<DefId>) {\n     if let Some(source) = source_opt {\n-        rbml_w.start_tag(tag_item_method_provided_source);\n-        let s = def_to_string(source);\n-        rbml_w.writer.write_all(s.as_bytes());\n-        rbml_w.end_tag();\n+        rbml_w.wr_tagged_str(tag_item_method_provided_source,\n+                             &def_to_string(source));\n     }\n }\n \n@@ -697,10 +657,11 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n         let nm = field.name;\n         let id = field.id.node;\n \n-        index.push(entry {val: id as i64, pos: rbml_w.writer.tell().unwrap()});\n+        let pos = rbml_w.mark_stable_position();\n+        index.push(entry {val: id as i64, pos: pos});\n         global_index.push(entry {\n             val: id as i64,\n-            pos: rbml_w.writer.tell().unwrap(),\n+            pos: pos,\n         });\n         rbml_w.start_tag(tag_items_data_item);\n         debug!(\"encode_info_for_struct: doing {} {}\",\n@@ -726,7 +687,7 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n                                struct_id: NodeId) {\n     index.push(entry {\n         val: ctor_id as i64,\n-        pos: rbml_w.writer.tell().unwrap(),\n+        pos: rbml_w.mark_stable_position(),\n     });\n \n     rbml_w.start_tag(tag_items_data_item);\n@@ -747,8 +708,7 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n     // indicate that this is a tuple struct ctor, because downstream users will normally want\n     // the tuple struct definition, but without this there is no way for them to tell that\n     // they actually have a ctor rather than a normal function\n-    rbml_w.start_tag(tag_items_data_item_is_tuple_struct_ctor);\n-    rbml_w.end_tag();\n+    rbml_w.wr_tagged_bytes(tag_items_data_item_is_tuple_struct_ctor, &[]);\n \n     rbml_w.end_tag();\n }\n@@ -770,7 +730,7 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n     };\n     for param in generics.types.iter() {\n         rbml_w.start_tag(tag_type_param_def);\n-        tyencode::enc_type_param_def(rbml_w.writer, ty_str_ctxt, param);\n+        tyencode::enc_type_param_def(rbml_w, ty_str_ctxt, param);\n         rbml_w.end_tag();\n     }\n \n@@ -804,7 +764,7 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n         rbml_w.wr_tagged_u8(tag_predicate_space, space as u8);\n \n         rbml_w.start_tag(tag_predicate_data);\n-        tyencode::enc_predicate(rbml_w.writer, ty_str_ctxt, predicate);\n+        tyencode::enc_predicate(rbml_w, ty_str_ctxt, predicate);\n         rbml_w.end_tag();\n \n         rbml_w.end_tag();\n@@ -919,12 +879,13 @@ fn encode_method_argument_names(rbml_w: &mut Encoder,\n                                 decl: &ast::FnDecl) {\n     rbml_w.start_tag(tag_method_argument_names);\n     for arg in &decl.inputs {\n-        rbml_w.start_tag(tag_method_argument_name);\n+        let tag = tag_method_argument_name;\n         if let ast::PatIdent(_, ref path1, _) = arg.pat.node {\n             let name = token::get_ident(path1.node);\n-            rbml_w.writer.write_all(name.as_bytes());\n+            rbml_w.wr_tagged_bytes(tag, name.as_bytes());\n+        } else {\n+            rbml_w.wr_tagged_bytes(tag, &[]);\n         }\n-        rbml_w.end_tag();\n     }\n     rbml_w.end_tag();\n }\n@@ -1002,11 +963,11 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                         vis: ast::Visibility) {\n     let tcx = ecx.tcx;\n \n-    fn add_to_index(item: &ast::Item, rbml_w: &Encoder,\n+    fn add_to_index(item: &ast::Item, rbml_w: &mut Encoder,\n                     index: &mut Vec<entry<i64>>) {\n         index.push(entry {\n             val: item.id as i64,\n-            pos: rbml_w.writer.tell().unwrap(),\n+            pos: rbml_w.mark_stable_position(),\n         });\n     }\n \n@@ -1091,9 +1052,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n         // Encode all the items in this module.\n         for foreign_item in &fm.items {\n-            rbml_w.start_tag(tag_mod_child);\n-            rbml_w.wr_str(&def_to_string(local_def(foreign_item.id)));\n-            rbml_w.end_tag();\n+            rbml_w.wr_tagged_str(tag_mod_child,\n+                                 &def_to_string(local_def(foreign_item.id)));\n         }\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n@@ -1263,7 +1223,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n             index.push(entry {\n                 val: trait_item_def_id.def_id().node as i64,\n-                pos: rbml_w.writer.tell().unwrap(),\n+                pos: rbml_w.mark_stable_position(),\n             });\n \n             let trait_item_type =\n@@ -1339,9 +1299,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n             rbml_w.end_tag();\n \n-            rbml_w.start_tag(tag_mod_child);\n-            rbml_w.wr_str(&def_to_string(method_def_id.def_id()));\n-            rbml_w.end_tag();\n+            rbml_w.wr_tagged_str(tag_mod_child,\n+                                 &def_to_string(method_def_id.def_id()));\n         }\n         encode_path(rbml_w, path.clone());\n \n@@ -1362,7 +1321,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n             index.push(entry {\n                 val: item_def_id.def_id().node as i64,\n-                pos: rbml_w.writer.tell().unwrap(),\n+                pos: rbml_w.mark_stable_position(),\n             });\n \n             rbml_w.start_tag(tag_items_data_item);\n@@ -1467,7 +1426,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n                                 abi: abi::Abi) {\n     index.push(entry {\n         val: nitem.id as i64,\n-        pos: rbml_w.writer.tell().unwrap(),\n+        pos: rbml_w.mark_stable_position(),\n     });\n \n     rbml_w.start_tag(tag_items_data_item);\n@@ -1567,7 +1526,7 @@ fn encode_info_for_items(ecx: &EncodeContext,\n     rbml_w.start_tag(tag_items_data);\n     index.push(entry {\n         val: ast::CRATE_NODE_ID as i64,\n-        pos: rbml_w.writer.tell().unwrap(),\n+        pos: rbml_w.mark_stable_position(),\n     });\n     encode_info_for_mod(ecx,\n                         rbml_w,\n@@ -1607,7 +1566,7 @@ fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn:\n     let mut bucket_locs = Vec::new();\n     rbml_w.start_tag(tag_index_buckets);\n     for bucket in &buckets {\n-        bucket_locs.push(rbml_w.writer.tell().unwrap());\n+        bucket_locs.push(rbml_w.mark_stable_position());\n         rbml_w.start_tag(tag_index_buckets_bucket);\n         for elt in bucket {\n             rbml_w.start_tag(tag_index_buckets_bucket_elt);\n@@ -1642,31 +1601,23 @@ fn encode_meta_item(rbml_w: &mut Encoder, mi: &ast::MetaItem) {\n     match mi.node {\n       ast::MetaWord(ref name) => {\n         rbml_w.start_tag(tag_meta_item_word);\n-        rbml_w.start_tag(tag_meta_item_name);\n-        rbml_w.writer.write_all(name.as_bytes());\n-        rbml_w.end_tag();\n+        rbml_w.wr_tagged_str(tag_meta_item_name, name);\n         rbml_w.end_tag();\n       }\n       ast::MetaNameValue(ref name, ref value) => {\n         match value.node {\n           ast::LitStr(ref value, _) => {\n             rbml_w.start_tag(tag_meta_item_name_value);\n-            rbml_w.start_tag(tag_meta_item_name);\n-            rbml_w.writer.write_all(name.as_bytes());\n-            rbml_w.end_tag();\n-            rbml_w.start_tag(tag_meta_item_value);\n-            rbml_w.writer.write_all(value.as_bytes());\n-            rbml_w.end_tag();\n+            rbml_w.wr_tagged_str(tag_meta_item_name, name);\n+            rbml_w.wr_tagged_str(tag_meta_item_value, value);\n             rbml_w.end_tag();\n           }\n           _ => {/* FIXME (#623): encode other variants */ }\n         }\n       }\n       ast::MetaList(ref name, ref items) => {\n         rbml_w.start_tag(tag_meta_item_list);\n-        rbml_w.start_tag(tag_meta_item_name);\n-        rbml_w.writer.write_all(name.as_bytes());\n-        rbml_w.end_tag();\n+        rbml_w.wr_tagged_str(tag_meta_item_name, name);\n         for inner_item in items {\n             encode_meta_item(rbml_w, &**inner_item);\n         }\n@@ -1760,22 +1711,9 @@ fn encode_lang_items(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n         if let Some(id) = def_id {\n             if id.krate == ast::LOCAL_CRATE {\n                 rbml_w.start_tag(tag_lang_items_item);\n-\n-                rbml_w.start_tag(tag_lang_items_item_id);\n-                {\n-                    let wr: &mut SeekableMemWriter = rbml_w.writer;\n-                    wr.write_be_u32(i as u32);\n-                }\n-                rbml_w.end_tag();   // tag_lang_items_item_id\n-\n-                rbml_w.start_tag(tag_lang_items_item_node_id);\n-                {\n-                    let wr: &mut SeekableMemWriter = rbml_w.writer;\n-                    wr.write_be_u32(id.node as u32);\n-                }\n-                rbml_w.end_tag();   // tag_lang_items_item_node_id\n-\n-                rbml_w.end_tag();   // tag_lang_items_item\n+                rbml_w.wr_tagged_u32(tag_lang_items_item_id, i as u32);\n+                rbml_w.wr_tagged_u32(tag_lang_items_item_node_id, id.node as u32);\n+                rbml_w.end_tag();\n             }\n         }\n     }\n@@ -1796,15 +1734,8 @@ fn encode_native_libraries(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n             cstore::NativeStatic => {} // these libraries are not propagated\n             cstore::NativeFramework | cstore::NativeUnknown => {\n                 rbml_w.start_tag(tag_native_libraries_lib);\n-\n-                rbml_w.start_tag(tag_native_libraries_kind);\n-                rbml_w.writer.write_be_u32(kind as u32);\n-                rbml_w.end_tag();\n-\n-                rbml_w.start_tag(tag_native_libraries_name);\n-                rbml_w.writer.write_all(lib.as_bytes());\n-                rbml_w.end_tag();\n-\n+                rbml_w.wr_tagged_u32(tag_native_libraries_kind, kind as u32);\n+                rbml_w.wr_tagged_str(tag_native_libraries_name, lib);\n                 rbml_w.end_tag();\n             }\n         }\n@@ -1830,9 +1761,8 @@ fn encode_macro_defs(rbml_w: &mut Encoder,\n         encode_name(rbml_w, def.ident.name);\n         encode_attributes(rbml_w, &def.attrs);\n \n-        rbml_w.start_tag(tag_macro_def_body);\n-        rbml_w.wr_str(&pprust::tts_to_string(&def.body));\n-        rbml_w.end_tag();\n+        rbml_w.wr_tagged_str(tag_macro_def_body,\n+                             &pprust::tts_to_string(&def.body));\n \n         rbml_w.end_tag();\n     }\n@@ -1917,15 +1847,12 @@ fn encode_misc_info(ecx: &EncodeContext,\n     rbml_w.start_tag(tag_misc_info);\n     rbml_w.start_tag(tag_misc_info_crate_items);\n     for item in &krate.module.items {\n-        rbml_w.start_tag(tag_mod_child);\n-        rbml_w.wr_str(&def_to_string(local_def(item.id)));\n-        rbml_w.end_tag();\n+        rbml_w.wr_tagged_str(tag_mod_child,\n+                             &def_to_string(local_def(item.id)));\n \n         each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n-            rbml_w.start_tag(tag_mod_child);\n-            rbml_w.wr_str(&def_to_string(local_def(\n-                        auxiliary_node_id)));\n-            rbml_w.end_tag();\n+            rbml_w.wr_tagged_str(tag_mod_child,\n+                                 &def_to_string(local_def(auxiliary_node_id)));\n             true\n         });\n     }\n@@ -1956,35 +1883,25 @@ fn encode_reachable_extern_fns(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n fn encode_crate_dep(rbml_w: &mut Encoder,\n                     dep: decoder::CrateDep) {\n     rbml_w.start_tag(tag_crate_dep);\n-    rbml_w.start_tag(tag_crate_dep_crate_name);\n-    rbml_w.writer.write_all(dep.name.as_bytes());\n-    rbml_w.end_tag();\n-    rbml_w.start_tag(tag_crate_dep_hash);\n-    rbml_w.writer.write_all(dep.hash.as_str().as_bytes());\n-    rbml_w.end_tag();\n+    rbml_w.wr_tagged_str(tag_crate_dep_crate_name, &dep.name);\n+    rbml_w.wr_tagged_str(tag_crate_dep_hash, dep.hash.as_str());\n     rbml_w.end_tag();\n }\n \n fn encode_hash(rbml_w: &mut Encoder, hash: &Svh) {\n-    rbml_w.start_tag(tag_crate_hash);\n-    rbml_w.writer.write_all(hash.as_str().as_bytes());\n-    rbml_w.end_tag();\n+    rbml_w.wr_tagged_str(tag_crate_hash, hash.as_str());\n }\n \n fn encode_crate_name(rbml_w: &mut Encoder, crate_name: &str) {\n-    rbml_w.start_tag(tag_crate_crate_name);\n-    rbml_w.writer.write_all(crate_name.as_bytes());\n-    rbml_w.end_tag();\n+    rbml_w.wr_tagged_str(tag_crate_crate_name, crate_name);\n }\n \n fn encode_crate_triple(rbml_w: &mut Encoder, triple: &str) {\n-    rbml_w.start_tag(tag_crate_triple);\n-    rbml_w.writer.write_all(triple.as_bytes());\n-    rbml_w.end_tag();\n+    rbml_w.wr_tagged_str(tag_crate_triple, triple);\n }\n \n fn encode_dylib_dependency_formats(rbml_w: &mut Encoder, ecx: &EncodeContext) {\n-    rbml_w.start_tag(tag_dylib_dependency_formats);\n+    let tag = tag_dylib_dependency_formats;\n     match ecx.tcx.dependency_formats.borrow().get(&config::CrateTypeDylib) {\n         Some(arr) => {\n             let s = arr.iter().enumerate().filter_map(|(i, slot)| {\n@@ -1993,21 +1910,28 @@ fn encode_dylib_dependency_formats(rbml_w: &mut Encoder, ecx: &EncodeContext) {\n                     cstore::RequireStatic => \"s\",\n                 })).to_string())\n             }).collect::<Vec<String>>();\n-            rbml_w.writer.write_all(s.connect(\",\").as_bytes());\n+            rbml_w.wr_tagged_str(tag, &s.connect(\",\"));\n+        }\n+        None => {\n+            rbml_w.wr_tagged_str(tag, \"\");\n         }\n-        None => {}\n     }\n-    rbml_w.end_tag();\n }\n \n // NB: Increment this as you change the metadata encoding version.\n #[allow(non_upper_case_globals)]\n-pub const metadata_encoding_version : &'static [u8] = &[b'r', b'u', b's', b't', 0, 0, 0, 1 ];\n+pub const metadata_encoding_version : &'static [u8] = &[b'r', b'u', b's', b't', 0, 0, 0, 2 ];\n \n pub fn encode_metadata(parms: EncodeParams, krate: &ast::Crate) -> Vec<u8> {\n     let mut wr = SeekableMemWriter::new();\n     encode_metadata_inner(&mut wr, parms, krate);\n+\n+    // RBML compacts the encoded bytes whenever appropriate,\n+    // so there are some garbages left after the end of the data.\n+    let metalen = wr.tell().unwrap() as uint;\n     let mut v = wr.unwrap();\n+    v.truncate(metalen);\n+    assert_eq!(v.len(), metalen);\n \n     // And here we run into yet another obscure archive bug: in which metadata\n     // loaded from archives may have trailing garbage bytes. Awhile back one of\n@@ -2089,7 +2013,7 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n         reachable: reachable,\n      };\n \n-    let mut rbml_w = writer::Encoder::new(wr);\n+    let mut rbml_w = Encoder::new(wr);\n \n     encode_crate_name(&mut rbml_w, &ecx.link_meta.crate_name);\n     encode_crate_triple(&mut rbml_w,\n@@ -2180,7 +2104,7 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n // Get the encoded string for a type\n pub fn encoded_ty<'tcx>(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>) -> String {\n     let mut wr = SeekableMemWriter::new();\n-    tyencode::enc_ty(&mut wr, &tyencode::ctxt {\n+    tyencode::enc_ty(&mut Encoder::new(&mut wr), &tyencode::ctxt {\n         diag: tcx.sess.diagnostic(),\n         ds: def_to_string,\n         tcx: tcx,"}, {"sha": "86f1605b8bfaa706fa0de0f511703893d3f1c9a6", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 35, "deletions": 33, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/24a840d4897f0853cb034e5a1b51fb28cd450f11/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a840d4897f0853cb034e5a1b51fb28cd450f11/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=24a840d4897f0853cb034e5a1b51fb28cd450f11", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -27,9 +27,9 @@ use syntax::ast;\n use syntax::diagnostic::SpanHandler;\n use syntax::parse::token;\n \n-use rbml::io::SeekableMemWriter;\n+use rbml::writer::Encoder;\n \n-macro_rules! mywrite { ($($arg:tt)*) => ({ write!($($arg)*); }) }\n+macro_rules! mywrite { ($w:expr, $($arg:tt)*) => ({ write!($w.writer, $($arg)*); }) }\n \n pub struct ctxt<'a, 'tcx: 'a> {\n     pub diag: &'a SpanHandler,\n@@ -49,12 +49,14 @@ pub struct ty_abbrev {\n \n pub type abbrev_map<'tcx> = RefCell<FnvHashMap<Ty<'tcx>, ty_abbrev>>;\n \n-pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n+pub fn enc_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n     match cx.abbrevs.borrow_mut().get(&t) {\n-        Some(a) => { w.write_all(a.s.as_bytes()); return; }\n+        Some(a) => { w.writer.write_all(a.s.as_bytes()); return; }\n         None => {}\n     }\n-    let pos = w.tell().unwrap();\n+\n+    // type abbreviations needs a stable position\n+    let pos = w.mark_stable_position();\n \n     match t.sty {\n         ty::ty_bool => mywrite!(w, \"b\"),\n@@ -154,7 +156,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'t\n         }\n     }\n \n-    let end = w.tell().unwrap();\n+    let end = w.mark_stable_position();\n     let len = end - pos;\n     fn estimate_sz(u: u64) -> u64 {\n         let mut n = u;\n@@ -171,21 +173,21 @@ pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'t\n     }\n }\n \n-fn enc_mutability(w: &mut SeekableMemWriter, mt: ast::Mutability) {\n+fn enc_mutability(w: &mut Encoder, mt: ast::Mutability) {\n     match mt {\n         ast::MutImmutable => (),\n         ast::MutMutable => mywrite!(w, \"m\"),\n     }\n }\n \n-fn enc_mt<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n+fn enc_mt<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n                     mt: ty::mt<'tcx>) {\n     enc_mutability(w, mt.mutbl);\n     enc_ty(w, cx, mt.ty);\n }\n \n-fn enc_opt<T, F>(w: &mut SeekableMemWriter, t: Option<T>, enc_f: F) where\n-    F: FnOnce(&mut SeekableMemWriter, T),\n+fn enc_opt<T, F>(w: &mut Encoder, t: Option<T>, enc_f: F) where\n+    F: FnOnce(&mut Encoder, T),\n {\n     match t {\n         None => mywrite!(w, \"n\"),\n@@ -196,11 +198,11 @@ fn enc_opt<T, F>(w: &mut SeekableMemWriter, t: Option<T>, enc_f: F) where\n     }\n }\n \n-fn enc_vec_per_param_space<'a, 'tcx, T, F>(w: &mut SeekableMemWriter,\n+fn enc_vec_per_param_space<'a, 'tcx, T, F>(w: &mut Encoder,\n                                            cx: &ctxt<'a, 'tcx>,\n                                            v: &VecPerParamSpace<T>,\n                                            mut op: F) where\n-    F: FnMut(&mut SeekableMemWriter, &ctxt<'a, 'tcx>, &T),\n+    F: FnMut(&mut Encoder, &ctxt<'a, 'tcx>, &T),\n {\n     for &space in &subst::ParamSpace::all() {\n         mywrite!(w, \"[\");\n@@ -211,14 +213,14 @@ fn enc_vec_per_param_space<'a, 'tcx, T, F>(w: &mut SeekableMemWriter,\n     }\n }\n \n-pub fn enc_substs<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n+pub fn enc_substs<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n                             substs: &subst::Substs<'tcx>) {\n     enc_region_substs(w, cx, &substs.regions);\n     enc_vec_per_param_space(w, cx, &substs.types,\n                             |w, cx, &ty| enc_ty(w, cx, ty));\n }\n \n-fn enc_region_substs(w: &mut SeekableMemWriter, cx: &ctxt, substs: &subst::RegionSubsts) {\n+fn enc_region_substs(w: &mut Encoder, cx: &ctxt, substs: &subst::RegionSubsts) {\n     match *substs {\n         subst::ErasedRegions => {\n             mywrite!(w, \"e\");\n@@ -231,7 +233,7 @@ fn enc_region_substs(w: &mut SeekableMemWriter, cx: &ctxt, substs: &subst::Regio\n     }\n }\n \n-pub fn enc_region(w: &mut SeekableMemWriter, cx: &ctxt, r: ty::Region) {\n+pub fn enc_region(w: &mut Encoder, cx: &ctxt, r: ty::Region) {\n     match r {\n         ty::ReLateBound(id, br) => {\n             mywrite!(w, \"b[{}|\", id.depth);\n@@ -270,7 +272,7 @@ pub fn enc_region(w: &mut SeekableMemWriter, cx: &ctxt, r: ty::Region) {\n     }\n }\n \n-fn enc_scope(w: &mut SeekableMemWriter, _cx: &ctxt, scope: region::CodeExtent) {\n+fn enc_scope(w: &mut Encoder, _cx: &ctxt, scope: region::CodeExtent) {\n     match scope {\n         region::CodeExtent::Misc(node_id) => mywrite!(w, \"M{}\", node_id),\n         region::CodeExtent::Remainder(region::BlockRemainder {\n@@ -279,12 +281,12 @@ fn enc_scope(w: &mut SeekableMemWriter, _cx: &ctxt, scope: region::CodeExtent) {\n     }\n }\n \n-fn enc_destruction_scope_data(w: &mut SeekableMemWriter,\n+fn enc_destruction_scope_data(w: &mut Encoder,\n                               d: region::DestructionScopeData) {\n     mywrite!(w, \"{}\", d.node_id);\n }\n \n-fn enc_bound_region(w: &mut SeekableMemWriter, cx: &ctxt, br: ty::BoundRegion) {\n+fn enc_bound_region(w: &mut Encoder, cx: &ctxt, br: ty::BoundRegion) {\n     match br {\n         ty::BrAnon(idx) => {\n             mywrite!(w, \"a{}|\", idx);\n@@ -303,40 +305,40 @@ fn enc_bound_region(w: &mut SeekableMemWriter, cx: &ctxt, br: ty::BoundRegion) {\n     }\n }\n \n-pub fn enc_trait_ref<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n+pub fn enc_trait_ref<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n                                s: &ty::TraitRef<'tcx>) {\n     mywrite!(w, \"{}|\", (cx.ds)(s.def_id));\n     enc_substs(w, cx, s.substs);\n }\n \n-fn enc_unsafety(w: &mut SeekableMemWriter, p: ast::Unsafety) {\n+fn enc_unsafety(w: &mut Encoder, p: ast::Unsafety) {\n     match p {\n         ast::Unsafety::Normal => mywrite!(w, \"n\"),\n         ast::Unsafety::Unsafe => mywrite!(w, \"u\"),\n     }\n }\n \n-fn enc_abi(w: &mut SeekableMemWriter, abi: Abi) {\n+fn enc_abi(w: &mut Encoder, abi: Abi) {\n     mywrite!(w, \"[\");\n     mywrite!(w, \"{}\", abi.name());\n     mywrite!(w, \"]\")\n }\n \n-pub fn enc_bare_fn_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n+pub fn enc_bare_fn_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n                                 ft: &ty::BareFnTy<'tcx>) {\n     enc_unsafety(w, ft.unsafety);\n     enc_abi(w, ft.abi);\n     enc_fn_sig(w, cx, &ft.sig);\n }\n \n-pub fn enc_closure_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n+pub fn enc_closure_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n                                 ft: &ty::ClosureTy<'tcx>) {\n     enc_unsafety(w, ft.unsafety);\n     enc_fn_sig(w, cx, &ft.sig);\n     enc_abi(w, ft.abi);\n }\n \n-fn enc_fn_sig<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n+fn enc_fn_sig<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n                         fsig: &ty::PolyFnSig<'tcx>) {\n     mywrite!(w, \"[\");\n     for ty in &fsig.0.inputs {\n@@ -358,7 +360,7 @@ fn enc_fn_sig<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n     }\n }\n \n-pub fn enc_builtin_bounds(w: &mut SeekableMemWriter, _cx: &ctxt, bs: &ty::BuiltinBounds) {\n+pub fn enc_builtin_bounds(w: &mut Encoder, _cx: &ctxt, bs: &ty::BuiltinBounds) {\n     for bound in bs {\n         match bound {\n             ty::BoundSend => mywrite!(w, \"S\"),\n@@ -371,7 +373,7 @@ pub fn enc_builtin_bounds(w: &mut SeekableMemWriter, _cx: &ctxt, bs: &ty::Builti\n     mywrite!(w, \".\");\n }\n \n-pub fn enc_existential_bounds<'a,'tcx>(w: &mut SeekableMemWriter,\n+pub fn enc_existential_bounds<'a,'tcx>(w: &mut Encoder,\n                                        cx: &ctxt<'a,'tcx>,\n                                        bs: &ty::ExistentialBounds<'tcx>) {\n     let param_bounds = ty::ParamBounds { trait_bounds: vec!(),\n@@ -381,7 +383,7 @@ pub fn enc_existential_bounds<'a,'tcx>(w: &mut SeekableMemWriter,\n     enc_bounds(w, cx, &param_bounds);\n }\n \n-pub fn enc_bounds<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n+pub fn enc_bounds<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n                             bs: &ty::ParamBounds<'tcx>) {\n     enc_builtin_bounds(w, cx, &bs.builtin_bounds);\n \n@@ -400,7 +402,7 @@ pub fn enc_bounds<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n     mywrite!(w, \".\");\n }\n \n-pub fn enc_region_bounds<'a, 'tcx>(w: &mut SeekableMemWriter,\n+pub fn enc_region_bounds<'a, 'tcx>(w: &mut Encoder,\n                             cx: &ctxt<'a, 'tcx>,\n                             rs: &[ty::Region]) {\n     for &r in rs {\n@@ -411,7 +413,7 @@ pub fn enc_region_bounds<'a, 'tcx>(w: &mut SeekableMemWriter,\n     mywrite!(w, \".\");\n }\n \n-pub fn enc_type_param_def<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n+pub fn enc_type_param_def<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n                                     v: &ty::TypeParameterDef<'tcx>) {\n     mywrite!(w, \"{}:{}|{}|{}|\",\n              token::get_name(v.name), (cx.ds)(v.def_id),\n@@ -420,7 +422,7 @@ pub fn enc_type_param_def<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tc\n     enc_object_lifetime_default(w, cx, v.object_lifetime_default);\n }\n \n-fn enc_object_lifetime_default<'a, 'tcx>(w: &mut SeekableMemWriter,\n+fn enc_object_lifetime_default<'a, 'tcx>(w: &mut Encoder,\n                                          cx: &ctxt<'a, 'tcx>,\n                                          default: Option<ty::ObjectLifetimeDefault>)\n {\n@@ -434,7 +436,7 @@ fn enc_object_lifetime_default<'a, 'tcx>(w: &mut SeekableMemWriter,\n     }\n }\n \n-pub fn enc_predicate<'a, 'tcx>(w: &mut SeekableMemWriter,\n+pub fn enc_predicate<'a, 'tcx>(w: &mut Encoder,\n                                cx: &ctxt<'a, 'tcx>,\n                                p: &ty::Predicate<'tcx>)\n {\n@@ -465,7 +467,7 @@ pub fn enc_predicate<'a, 'tcx>(w: &mut SeekableMemWriter,\n     }\n }\n \n-fn enc_projection_predicate<'a, 'tcx>(w: &mut SeekableMemWriter,\n+fn enc_projection_predicate<'a, 'tcx>(w: &mut Encoder,\n                                       cx: &ctxt<'a, 'tcx>,\n                                       data: &ty::ProjectionPredicate<'tcx>) {\n     enc_trait_ref(w, cx, &*data.projection_ty.trait_ref);"}, {"sha": "599dde4b70155affa34456593f110b4f4f1675e3", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 44, "deletions": 74, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/24a840d4897f0853cb034e5a1b51fb28cd450f11/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a840d4897f0853cb034e5a1b51fb28cd450f11/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=24a840d4897f0853cb034e5a1b51fb28cd450f11", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -43,13 +43,14 @@ use std::old_io::Seek;\n use std::num::FromPrimitive;\n use std::rc::Rc;\n \n-use rbml::io::SeekableMemWriter;\n-use rbml::{reader, writer};\n+use rbml::reader;\n+use rbml::writer::Encoder;\n use rbml;\n use serialize;\n use serialize::{Decodable, Decoder, DecoderHelpers, Encodable};\n use serialize::{EncoderHelpers};\n \n+#[cfg(test)] use rbml::io::SeekableMemWriter;\n #[cfg(test)] use syntax::parse;\n #[cfg(test)] use syntax::print::pprust;\n \n@@ -68,8 +69,6 @@ trait tr_intern {\n     fn tr_intern(&self, dcx: &DecodeContext) -> ast::DefId;\n }\n \n-pub type Encoder<'a> = writer::Encoder<'a, SeekableMemWriter>;\n-\n // ______________________________________________________________________\n // Top-level methods.\n \n@@ -414,9 +413,8 @@ fn decode_ast(par_doc: rbml::Doc) -> ast::InlinedItem {\n // ______________________________________________________________________\n // Encoding and decoding of ast::def\n \n-fn decode_def(dcx: &DecodeContext, doc: rbml::Doc) -> def::Def {\n-    let mut dsr = reader::Decoder::new(doc);\n-    let def: def::Def = Decodable::decode(&mut dsr).unwrap();\n+fn decode_def(dcx: &DecodeContext, dsr: &mut reader::Decoder) -> def::Def {\n+    let def: def::Def = Decodable::decode(dsr).unwrap();\n     def.tr(dcx)\n }\n \n@@ -911,7 +909,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n     fn emit_type_param_def<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n                                type_param_def: &ty::TypeParameterDef<'tcx>) {\n         self.emit_opaque(|this| {\n-            Ok(tyencode::enc_type_param_def(this.writer,\n+            Ok(tyencode::enc_type_param_def(this,\n                                          &ecx.ty_str_ctxt(),\n                                          type_param_def))\n         });\n@@ -920,7 +918,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n     fn emit_predicate<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n                           predicate: &ty::Predicate<'tcx>) {\n         self.emit_opaque(|this| {\n-            Ok(tyencode::enc_predicate(this.writer,\n+            Ok(tyencode::enc_predicate(this,\n                                        &ecx.ty_str_ctxt(),\n                                        predicate))\n         });\n@@ -954,20 +952,20 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n \n     fn emit_existential_bounds<'b>(&mut self, ecx: &e::EncodeContext<'b,'tcx>,\n                                    bounds: &ty::ExistentialBounds<'tcx>) {\n-        self.emit_opaque(|this| Ok(tyencode::enc_existential_bounds(this.writer,\n+        self.emit_opaque(|this| Ok(tyencode::enc_existential_bounds(this,\n                                                                     &ecx.ty_str_ctxt(),\n                                                                     bounds)));\n     }\n \n     fn emit_builtin_bounds(&mut self, ecx: &e::EncodeContext, bounds: &ty::BuiltinBounds) {\n-        self.emit_opaque(|this| Ok(tyencode::enc_builtin_bounds(this.writer,\n+        self.emit_opaque(|this| Ok(tyencode::enc_builtin_bounds(this,\n                                                                 &ecx.ty_str_ctxt(),\n                                                                 bounds)));\n     }\n \n     fn emit_substs<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n                        substs: &subst::Substs<'tcx>) {\n-        self.emit_opaque(|this| Ok(tyencode::enc_substs(this.writer,\n+        self.emit_opaque(|this| Ok(tyencode::enc_substs(this,\n                                                            &ecx.ty_str_ctxt(),\n                                                            substs)));\n     }\n@@ -1115,7 +1113,7 @@ impl<'a> write_tag_and_id for Encoder<'a> {\n     }\n \n     fn id(&mut self, id: ast::NodeId) {\n-        self.wr_tagged_u64(c::tag_table_id as uint, id as u64);\n+        id.encode(self).unwrap();\n     }\n }\n \n@@ -1152,51 +1150,44 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     if let Some(def) = tcx.def_map.borrow().get(&id).map(|d| d.full_def()) {\n         rbml_w.tag(c::tag_table_def, |rbml_w| {\n             rbml_w.id(id);\n-            rbml_w.tag(c::tag_table_val, |rbml_w| def.encode(rbml_w).unwrap());\n+            def.encode(rbml_w).unwrap();\n         })\n     }\n \n     if let Some(ty) = tcx.node_types.borrow().get(&id) {\n         rbml_w.tag(c::tag_table_node_type, |rbml_w| {\n             rbml_w.id(id);\n-            rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                rbml_w.emit_ty(ecx, *ty);\n-            })\n+            rbml_w.emit_ty(ecx, *ty);\n         })\n     }\n \n     if let Some(item_substs) = tcx.item_substs.borrow().get(&id) {\n         rbml_w.tag(c::tag_table_item_subst, |rbml_w| {\n             rbml_w.id(id);\n-            rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                rbml_w.emit_substs(ecx, &item_substs.substs);\n-            })\n+            rbml_w.emit_substs(ecx, &item_substs.substs);\n         })\n     }\n \n     if let Some(fv) = tcx.freevars.borrow().get(&id) {\n         rbml_w.tag(c::tag_table_freevars, |rbml_w| {\n             rbml_w.id(id);\n-            rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                rbml_w.emit_from_vec(fv, |rbml_w, fv_entry| {\n-                    Ok(encode_freevar_entry(rbml_w, fv_entry))\n-                });\n-            })\n+            rbml_w.emit_from_vec(fv, |rbml_w, fv_entry| {\n+                Ok(encode_freevar_entry(rbml_w, fv_entry))\n+            });\n         });\n \n         for freevar in fv {\n             rbml_w.tag(c::tag_table_upvar_capture_map, |rbml_w| {\n                 rbml_w.id(id);\n-                rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                    let var_id = freevar.def.def_id().node;\n-                    let upvar_id = ty::UpvarId {\n-                        var_id: var_id,\n-                        closure_expr_id: id\n-                    };\n-                    let upvar_capture = tcx.upvar_capture_map.borrow()[upvar_id].clone();\n-                    var_id.encode(rbml_w);\n-                    upvar_capture.encode(rbml_w);\n-                })\n+\n+                let var_id = freevar.def.def_id().node;\n+                let upvar_id = ty::UpvarId {\n+                    var_id: var_id,\n+                    closure_expr_id: id\n+                };\n+                let upvar_capture = tcx.upvar_capture_map.borrow()[upvar_id].clone();\n+                var_id.encode(rbml_w);\n+                upvar_capture.encode(rbml_w);\n             })\n         }\n     }\n@@ -1205,37 +1196,29 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     if let Some(type_scheme) = tcx.tcache.borrow().get(&lid) {\n         rbml_w.tag(c::tag_table_tcache, |rbml_w| {\n             rbml_w.id(id);\n-            rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                rbml_w.emit_type_scheme(ecx, type_scheme.clone());\n-            })\n+            rbml_w.emit_type_scheme(ecx, type_scheme.clone());\n         })\n     }\n \n     if let Some(type_param_def) = tcx.ty_param_defs.borrow().get(&id) {\n         rbml_w.tag(c::tag_table_param_defs, |rbml_w| {\n             rbml_w.id(id);\n-            rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                rbml_w.emit_type_param_def(ecx, type_param_def)\n-            })\n+            rbml_w.emit_type_param_def(ecx, type_param_def)\n         })\n     }\n \n     let method_call = MethodCall::expr(id);\n     if let Some(method) = tcx.method_map.borrow().get(&method_call) {\n         rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n             rbml_w.id(id);\n-            rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                encode_method_callee(ecx, rbml_w, method_call.adjustment, method)\n-            })\n+            encode_method_callee(ecx, rbml_w, method_call.adjustment, method)\n         })\n     }\n \n     if let Some(trait_ref) = tcx.object_cast_map.borrow().get(&id) {\n         rbml_w.tag(c::tag_table_object_cast_map, |rbml_w| {\n             rbml_w.id(id);\n-            rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                rbml_w.emit_trait_ref(ecx, &*trait_ref.0);\n-            })\n+            rbml_w.emit_trait_ref(ecx, &*trait_ref.0);\n         })\n     }\n \n@@ -1246,9 +1229,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                 if let Some(method) = tcx.method_map.borrow().get(&method_call) {\n                     rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n                         rbml_w.id(id);\n-                        rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                            encode_method_callee(ecx, rbml_w, method_call.adjustment, method)\n-                        })\n+                        encode_method_callee(ecx, rbml_w, method_call.adjustment, method)\n                     })\n                 }\n             }\n@@ -1259,10 +1240,8 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                     if let Some(method) = tcx.method_map.borrow().get(&method_call) {\n                         rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n                             rbml_w.id(id);\n-                            rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                                encode_method_callee(ecx, rbml_w,\n-                                                     method_call.adjustment, method)\n-                            })\n+                            encode_method_callee(ecx, rbml_w,\n+                                                 method_call.adjustment, method)\n                         })\n                     }\n                 }\n@@ -1274,36 +1253,28 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n         rbml_w.tag(c::tag_table_adjustments, |rbml_w| {\n             rbml_w.id(id);\n-            rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                rbml_w.emit_auto_adjustment(ecx, adjustment);\n-            })\n+            rbml_w.emit_auto_adjustment(ecx, adjustment);\n         })\n     }\n \n     if let Some(closure_type) = tcx.closure_tys.borrow().get(&ast_util::local_def(id)) {\n         rbml_w.tag(c::tag_table_closure_tys, |rbml_w| {\n             rbml_w.id(id);\n-            rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                rbml_w.emit_closure_type(ecx, closure_type);\n-            })\n+            rbml_w.emit_closure_type(ecx, closure_type);\n         })\n     }\n \n     if let Some(closure_kind) = tcx.closure_kinds.borrow().get(&ast_util::local_def(id)) {\n         rbml_w.tag(c::tag_table_closure_kinds, |rbml_w| {\n             rbml_w.id(id);\n-            rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                encode_closure_kind(rbml_w, *closure_kind)\n-            })\n+            encode_closure_kind(rbml_w, *closure_kind)\n         })\n     }\n \n     for &qualif in tcx.const_qualif_map.borrow().get(&id).iter() {\n         rbml_w.tag(c::tag_table_const_qualif, |rbml_w| {\n             rbml_w.id(id);\n-            rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                qualif.encode(rbml_w).unwrap()\n-            })\n+            qualif.encode(rbml_w).unwrap()\n         })\n     }\n }\n@@ -1831,8 +1802,9 @@ fn decode_side_tables(dcx: &DecodeContext,\n                       ast_doc: rbml::Doc) {\n     let tbl_doc = ast_doc.get(c::tag_table as uint);\n     reader::docs(tbl_doc, |tag, entry_doc| {\n-        let id0 = entry_doc.get(c::tag_table_id as uint).as_int();\n-        let id = dcx.tr_id(id0 as ast::NodeId);\n+        let mut entry_dsr = reader::Decoder::new(entry_doc);\n+        let id0: ast::NodeId = Decodable::decode(&mut entry_dsr).unwrap();\n+        let id = dcx.tr_id(id0);\n \n         debug!(\">> Side table document with tag 0x{:x} \\\n                 found for id {} (orig {})\",\n@@ -1845,13 +1817,11 @@ fn decode_side_tables(dcx: &DecodeContext,\n                             tag));\n             }\n             Some(value) => {\n-                let val_doc = entry_doc.get(c::tag_table_val as uint);\n-                let mut val_dsr = reader::Decoder::new(val_doc);\n-                let val_dsr = &mut val_dsr;\n+                let val_dsr = &mut entry_dsr;\n \n                 match value {\n                     c::tag_table_def => {\n-                        let def = decode_def(dcx, val_doc);\n+                        let def = decode_def(dcx, val_dsr);\n                         dcx.tcx.def_map.borrow_mut().insert(id, def::PathResolution {\n                             base_def: def,\n                             // This doesn't matter cross-crate.\n@@ -1995,7 +1965,7 @@ fn mk_ctxt() -> parse::ParseSess {\n fn roundtrip(in_item: Option<P<ast::Item>>) {\n     let in_item = in_item.unwrap();\n     let mut wr = SeekableMemWriter::new();\n-    encode_item_ast(&mut writer::Encoder::new(&mut wr), &*in_item);\n+    encode_item_ast(&mut Encoder::new(&mut wr), &*in_item);\n     let rbml_doc = rbml::Doc::new(wr.get_ref());\n     let out_item = decode_item_ast(rbml_doc);\n "}]}