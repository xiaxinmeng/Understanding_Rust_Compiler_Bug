{"sha": "5169a9d498c82ffd0a24a4cc640eb8232a3f7e21", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxNjlhOWQ0OThjODJmZmQwYTI0YTRjYzY0MGViODIzMmEzZjdlMjE=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2019-07-26T11:10:29Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2019-07-26T15:06:31Z"}, "message": "Improve inlay hinting for types\n\nAdd hints for types in for loop expressions.\nResolve types for every tuple parameter.\nRefactor the code.", "tree": {"sha": "efa51b228f5f8785bc46b2620ad766deeea7d877", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efa51b228f5f8785bc46b2620ad766deeea7d877"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5169a9d498c82ffd0a24a4cc640eb8232a3f7e21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5169a9d498c82ffd0a24a4cc640eb8232a3f7e21", "html_url": "https://github.com/rust-lang/rust/commit/5169a9d498c82ffd0a24a4cc640eb8232a3f7e21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5169a9d498c82ffd0a24a4cc640eb8232a3f7e21/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4647e89defd367a92d00d3bbb11c2463408bb3ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/4647e89defd367a92d00d3bbb11c2463408bb3ad", "html_url": "https://github.com/rust-lang/rust/commit/4647e89defd367a92d00d3bbb11c2463408bb3ad"}], "stats": {"total": 186, "additions": 125, "deletions": 61}, "files": [{"sha": "95289f01663a306a4a0307c633a68b6b7e83453b", "filename": "crates/ra_ide_api/src/inlay_hints.rs", "status": "modified", "additions": 121, "deletions": 61, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/5169a9d498c82ffd0a24a4cc640eb8232a3f7e21/crates%2Fra_ide_api%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5169a9d498c82ffd0a24a4cc640eb8232a3f7e21/crates%2Fra_ide_api%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Finlay_hints.rs?ref=5169a9d498c82ffd0a24a4cc640eb8232a3f7e21", "patch": "@@ -1,16 +1,17 @@\n use crate::{db::RootDatabase, FileId};\n-use hir::{HirDisplay, Ty};\n+use hir::{HirDisplay, SourceAnalyzer, Ty};\n use ra_syntax::ast::Pat;\n use ra_syntax::{\n     algo::visit::{visitor, Visitor},\n     ast::{self, PatKind, TypeAscriptionOwner},\n     AstNode, SmolStr, SourceFile, SyntaxNode, TextRange,\n };\n \n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Debug, PartialEq, Eq, Clone)]\n pub enum InlayKind {\n     LetBindingType,\n     ClosureParameterType,\n+    ForExpressionBindingType,\n }\n \n #[derive(Debug)]\n@@ -35,67 +36,89 @@ fn get_inlay_hints(\n ) -> Option<Vec<InlayHint>> {\n     visitor()\n         .visit(|let_statement: ast::LetStmt| {\n-            let let_syntax = let_statement.syntax();\n-\n             if let_statement.ascribed_type().is_some() {\n                 return None;\n             }\n-\n-            let let_pat = let_statement.pat()?;\n-            let inlay_type_string = get_node_displayable_type(db, file_id, let_syntax, &let_pat)?\n-                .display(db)\n-                .to_string()\n-                .into();\n-\n-            let pat_range = match let_pat.kind() {\n-                PatKind::BindPat(bind_pat) => bind_pat.syntax().text_range(),\n-                PatKind::TuplePat(tuple_pat) => tuple_pat.syntax().text_range(),\n-                _ => return None,\n-            };\n-\n-            Some(vec![InlayHint {\n-                range: pat_range,\n-                kind: InlayKind::LetBindingType,\n-                label: inlay_type_string,\n-            }])\n+            let analyzer = SourceAnalyzer::new(db, file_id, let_statement.syntax(), None);\n+            Some(get_pat_hints(db, &analyzer, let_statement.pat()?, InlayKind::LetBindingType))\n         })\n-        .visit(|closure_parameter: ast::LambdaExpr| match closure_parameter.param_list() {\n-            Some(param_list) => Some(\n+        .visit(|closure_parameter: ast::LambdaExpr| {\n+            let analyzer = SourceAnalyzer::new(db, file_id, closure_parameter.syntax(), None);\n+            closure_parameter.param_list().map(|param_list| {\n                 param_list\n                     .params()\n                     .filter(|closure_param| closure_param.ascribed_type().is_none())\n-                    .filter_map(|closure_param| {\n-                        let closure_param_syntax = closure_param.syntax();\n-                        let inlay_type_string = get_node_displayable_type(\n-                            db,\n-                            file_id,\n-                            closure_param_syntax,\n-                            &closure_param.pat()?,\n-                        )?\n-                        .display(db)\n-                        .to_string()\n-                        .into();\n-\n-                        Some(InlayHint {\n-                            range: closure_param_syntax.text_range(),\n-                            kind: InlayKind::ClosureParameterType,\n-                            label: inlay_type_string,\n-                        })\n+                    .filter_map(|closure_param| closure_param.pat())\n+                    .map(|root_pat| {\n+                        get_pat_hints(db, &analyzer, root_pat, InlayKind::ClosureParameterType)\n                     })\n-                    .collect(),\n-            ),\n-            None => None,\n+                    .flatten()\n+                    .collect()\n+            })\n+        })\n+        .visit(|for_expression: ast::ForExpr| {\n+            let analyzer = SourceAnalyzer::new(db, file_id, for_expression.syntax(), None);\n+            Some(get_pat_hints(\n+                db,\n+                &analyzer,\n+                for_expression.pat()?,\n+                InlayKind::ForExpressionBindingType,\n+            ))\n         })\n         .accept(&node)?\n }\n \n+fn get_pat_hints(\n+    db: &RootDatabase,\n+    analyzer: &SourceAnalyzer,\n+    root_pat: Pat,\n+    kind: InlayKind,\n+) -> Vec<InlayHint> {\n+    get_leaf_pats(root_pat)\n+        .into_iter()\n+        .filter_map(|pat| {\n+            get_node_displayable_type(db, &analyzer, &pat)\n+                .map(|pat_type| (pat.syntax().text_range(), pat_type))\n+        })\n+        .map(|(range, pat_type)| InlayHint {\n+            range,\n+            kind: kind.clone(),\n+            label: pat_type.display(db).to_string().into(),\n+        })\n+        .collect()\n+}\n+\n+fn get_leaf_pats(root_pat: Pat) -> Vec<Pat> {\n+    let mut pats_to_process = std::collections::VecDeque::<Pat>::new();\n+    pats_to_process.push_back(root_pat);\n+\n+    let mut leaf_pats = Vec::new();\n+\n+    while let Some(maybe_leaf_pat) = pats_to_process.pop_front() {\n+        match maybe_leaf_pat.kind() {\n+            PatKind::BindPat(bind_pat) => {\n+                if let Some(pat) = bind_pat.pat() {\n+                    pats_to_process.push_back(pat);\n+                } else {\n+                    leaf_pats.push(maybe_leaf_pat);\n+                }\n+            }\n+            PatKind::TuplePat(tuple_pat) => {\n+                for arg_pat in tuple_pat.args() {\n+                    pats_to_process.push_back(arg_pat);\n+                }\n+            }\n+            _ => (),\n+        }\n+    }\n+    leaf_pats\n+}\n+\n fn get_node_displayable_type(\n     db: &RootDatabase,\n-    file_id: FileId,\n-    node_syntax: &SyntaxNode,\n+    analyzer: &SourceAnalyzer,\n     node_pat: &Pat,\n ) -> Option<Ty> {\n-    let analyzer = hir::SourceAnalyzer::new(db, file_id, node_syntax, None);\n     analyzer.type_of_pat(db, node_pat).and_then(|resolved_type| {\n         if let Ty::Apply(_) = resolved_type {\n             Some(resolved_type)\n@@ -120,25 +143,32 @@ fn main() {\n     struct InnerStruct {}\n \n     let test = 54;\n+    let test: i32 = 33;\n+    let mut test = 33;\n+    let _ = 22;\n+    let test = \"test\";\n     let test = InnerStruct {};\n     let test = OuterStruct {};\n+\n     let test = vec![222];\n+    let test: Vec<_> = (0..3).collect();\n+\n     let mut test = Vec::new();\n     test.push(333);\n+\n     let test = test.into_iter().map(|i| i * i).collect::<Vec<_>>();\n-    let mut test = 33;\n-    let _ = 22;\n-    let test: Vec<_> = (0..3).collect();\n+    let test = test.into_iter().map(|i| i * i).collect::<Vec<u128>>();\n \n     let _ = (0..23).map(|i: u32| {\n         let i_squared = i * i;\n         i_squared\n     });\n \n-    let test: i32 = 33;\n-\n-    let (x, c) = (42, 'a');\n     let test = (42, 'a');\n+    let (a, (b, c, (d, e), f)) = (2, (3, 4, (6.6, 7.7), 5));\n+\n+    let test = Some((2, 3));\n+    for (i, j) in test {}\n }\n \"#,\n         );\n@@ -150,29 +180,59 @@ fn main() {\n         label: \"i32\",\n     },\n     InlayHint {\n-        range: [121; 125),\n+        range: [114; 122),\n         kind: LetBindingType,\n-        label: \"OuterStruct\",\n+        label: \"i32\",\n     },\n     InlayHint {\n-        range: [297; 305),\n+        range: [153; 157),\n         kind: LetBindingType,\n-        label: \"i32\",\n+        label: \"&str\",\n     },\n     InlayHint {\n-        range: [417; 426),\n+        range: [207; 211),\n+        kind: LetBindingType,\n+        label: \"OuterStruct\",\n+    },\n+    InlayHint {\n+        range: [538; 547),\n         kind: LetBindingType,\n         label: \"u32\",\n     },\n     InlayHint {\n-        range: [496; 502),\n+        range: [592; 596),\n         kind: LetBindingType,\n         label: \"(i32, char)\",\n     },\n     InlayHint {\n-        range: [524; 528),\n+        range: [619; 620),\n         kind: LetBindingType,\n-        label: \"(i32, char)\",\n+        label: \"i32\",\n+    },\n+    InlayHint {\n+        range: [623; 624),\n+        kind: LetBindingType,\n+        label: \"i32\",\n+    },\n+    InlayHint {\n+        range: [626; 627),\n+        kind: LetBindingType,\n+        label: \"i32\",\n+    },\n+    InlayHint {\n+        range: [637; 638),\n+        kind: LetBindingType,\n+        label: \"i32\",\n+    },\n+    InlayHint {\n+        range: [630; 631),\n+        kind: LetBindingType,\n+        label: \"f64\",\n+    },\n+    InlayHint {\n+        range: [633; 634),\n+        kind: LetBindingType,\n+        label: \"f64\",\n     },\n ]\"#\n         );"}, {"sha": "0b4493ce2f509c0f737f04914864fb27f9771997", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5169a9d498c82ffd0a24a4cc640eb8232a3f7e21/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5169a9d498c82ffd0a24a4cc640eb8232a3f7e21/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=5169a9d498c82ffd0a24a4cc640eb8232a3f7e21", "patch": "@@ -897,6 +897,9 @@ pub fn handle_inlay_hints(\n             kind: match api_type.kind {\n                 ra_ide_api::InlayKind::LetBindingType => InlayKind::LetBindingType,\n                 ra_ide_api::InlayKind::ClosureParameterType => InlayKind::ClosureParameterType,\n+                ra_ide_api::InlayKind::ForExpressionBindingType => {\n+                    InlayKind::ForExpressionBindingType\n+                }\n             },\n         })\n         .collect())"}, {"sha": "96f6b1bc5ff9a552f0b7e183e0157430be5d9681", "filename": "crates/ra_lsp_server/src/req.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5169a9d498c82ffd0a24a4cc640eb8232a3f7e21/crates%2Fra_lsp_server%2Fsrc%2Freq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5169a9d498c82ffd0a24a4cc640eb8232a3f7e21/crates%2Fra_lsp_server%2Fsrc%2Freq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Freq.rs?ref=5169a9d498c82ffd0a24a4cc640eb8232a3f7e21", "patch": "@@ -215,6 +215,7 @@ pub struct InlayHintsParams {\n pub enum InlayKind {\n     LetBindingType,\n     ClosureParameterType,\n+    ForExpressionBindingType,\n }\n \n #[derive(Debug, Deserialize, Serialize)]"}]}