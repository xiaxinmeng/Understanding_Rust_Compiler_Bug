{"sha": "7a0774defa1f485788a5ad2150a3e045a8dc8be3", "node_id": "C_kwDOAAsO6NoAKDdhMDc3NGRlZmExZjQ4NTc4OGE1YWQyMTUwYTNlMDQ1YThkYzhiZTM", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-06-20T19:55:33Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-06-20T19:55:33Z"}, "message": "internal: Simplify some completions", "tree": {"sha": "dd4538f3fcdb09d9f00216a6bd49921b22359b95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd4538f3fcdb09d9f00216a6bd49921b22359b95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a0774defa1f485788a5ad2150a3e045a8dc8be3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a0774defa1f485788a5ad2150a3e045a8dc8be3", "html_url": "https://github.com/rust-lang/rust/commit/7a0774defa1f485788a5ad2150a3e045a8dc8be3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a0774defa1f485788a5ad2150a3e045a8dc8be3/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b078986dc2453f0dbe27f0e77fe8f8a511fe4c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b078986dc2453f0dbe27f0e77fe8f8a511fe4c0", "html_url": "https://github.com/rust-lang/rust/commit/8b078986dc2453f0dbe27f0e77fe8f8a511fe4c0"}], "stats": {"total": 367, "additions": 146, "deletions": 221}, "files": [{"sha": "aa10b0f878fdea6fc246986dae4332c22be9c2b7", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7a0774defa1f485788a5ad2150a3e045a8dc8be3/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0774defa1f485788a5ad2150a3e045a8dc8be3/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=7a0774defa1f485788a5ad2150a3e045a8dc8be3", "patch": "@@ -2,7 +2,7 @@\n \n mod source_to_def;\n \n-use std::{cell::RefCell, fmt, iter};\n+use std::{cell::RefCell, fmt, iter, ops};\n \n use base_db::{FileId, FileRange};\n use hir_def::{\n@@ -1449,3 +1449,11 @@ impl<'a> SemanticsScope<'a> {\n }\n \n pub struct VisibleTraits(pub FxHashSet<TraitId>);\n+\n+impl ops::Deref for VisibleTraits {\n+    type Target = FxHashSet<TraitId>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}"}, {"sha": "81bb59681baf9dae8892e3de9d1f703657728b40", "filename": "crates/ide-completion/src/completions.rs", "status": "modified", "additions": 14, "deletions": 26, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7a0774defa1f485788a5ad2150a3e045a8dc8be3/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0774defa1f485788a5ad2150a3e045a8dc8be3/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions.rs?ref=7a0774defa1f485788a5ad2150a3e045a8dc8be3", "patch": "@@ -36,7 +36,7 @@ use crate::{\n         const_::render_const,\n         function::{render_fn, render_method},\n         literal::{render_struct_literal, render_variant_lit},\n-        macro_::{render_macro, render_macro_pat},\n+        macro_::render_macro,\n         pattern::{render_struct_pat, render_variant_pat},\n         render_field, render_path_resolution, render_pattern_resolution, render_tuple_field,\n         type_alias::{render_type_alias, render_type_alias_with_eq},\n@@ -101,15 +101,15 @@ impl Completions {\n     pub(crate) fn add_keyword_snippet_expr(\n         &mut self,\n         ctx: &CompletionContext,\n+        incomplete_let: bool,\n         kw: &str,\n         snippet: &str,\n-        incomplete_let: bool,\n     ) {\n         let mut item = CompletionItem::new(CompletionItemKind::Keyword, ctx.source_range(), kw);\n \n         match ctx.config.snippet_cap {\n             Some(cap) => {\n-                if snippet.ends_with('}') && incomplete_let {\n+                if incomplete_let && snippet.ends_with('}') {\n                     // complete block expression snippets with a trailing semicolon, if inside an incomplete let\n                     cov_mark::hit!(let_semi);\n                     item.insert_snippet(cap, format!(\"{};\", snippet));\n@@ -181,6 +181,17 @@ impl Completions {\n         );\n     }\n \n+    pub(crate) fn add_enum_variants(\n+        &mut self,\n+        ctx: &CompletionContext,\n+        path_ctx: &PathCompletionCtx,\n+        e: hir::Enum,\n+    ) {\n+        e.variants(ctx.db)\n+            .into_iter()\n+            .for_each(|variant| self.add_enum_variant(ctx, path_ctx, variant, None));\n+    }\n+\n     pub(crate) fn add_module(\n         &mut self,\n         ctx: &CompletionContext,\n@@ -219,29 +230,6 @@ impl Completions {\n         );\n     }\n \n-    pub(crate) fn add_macro_pat(\n-        &mut self,\n-        ctx: &CompletionContext,\n-        pattern_ctx: &PatternContext,\n-        mac: hir::Macro,\n-        local_name: hir::Name,\n-    ) {\n-        let is_private_editable = match ctx.is_visible(&mac) {\n-            Visible::Yes => false,\n-            Visible::Editable => true,\n-            Visible::No => return,\n-        };\n-        self.add(\n-            render_macro_pat(\n-                RenderContext::new(ctx).private_editable(is_private_editable),\n-                pattern_ctx,\n-                local_name,\n-                mac,\n-            )\n-            .build(),\n-        );\n-    }\n-\n     pub(crate) fn add_function(\n         &mut self,\n         ctx: &CompletionContext,"}, {"sha": "911ef60930653ebbd7af64b85ea87c0ccbdc8616", "filename": "crates/ide-completion/src/completions/dot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a0774defa1f485788a5ad2150a3e045a8dc8be3/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0774defa1f485788a5ad2150a3e045a8dc8be3/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=7a0774defa1f485788a5ad2150a3e045a8dc8be3", "patch": "@@ -121,7 +121,7 @@ fn complete_methods(\n     receiver.iterate_method_candidates(\n         ctx.db,\n         &ctx.scope,\n-        &ctx.traits_in_scope().0,\n+        &ctx.traits_in_scope(),\n         Some(ctx.module),\n         None,\n         |func| {"}, {"sha": "058d0ab7bb5683a41d505005916a3e52750ea32c", "filename": "crates/ide-completion/src/completions/expr.rs", "status": "modified", "additions": 30, "deletions": 81, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/7a0774defa1f485788a5ad2150a3e045a8dc8be3/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0774defa1f485788a5ad2150a3e045a8dc8be3/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs?ref=7a0774defa1f485788a5ad2150a3e045a8dc8be3", "patch": "@@ -1,7 +1,6 @@\n //! Completion of names from the current scope in expression position.\n \n use hir::ScopeDef;\n-use ide_db::FxHashSet;\n \n use crate::{\n     context::{ExprCtx, PathCompletionCtx, Qualified},\n@@ -33,24 +32,24 @@ pub(crate) fn complete_expr_path(\n     let wants_mut_token =\n         ref_expr_parent.as_ref().map(|it| it.mut_token().is_none()).unwrap_or(false);\n \n-    let scope_def_applicable = |def| {\n-        match def {\n-            ScopeDef::GenericParam(hir::GenericParam::LifetimeParam(_)) | ScopeDef::Label(_) => {\n-                false\n-            }\n-            // Don't suggest attribute macros and derives.\n-            ScopeDef::ModuleDef(hir::ModuleDef::Macro(mac)) => mac.is_fn_like(ctx.db),\n-            _ => true,\n-        }\n+    let scope_def_applicable = |def| match def {\n+        ScopeDef::GenericParam(hir::GenericParam::LifetimeParam(_)) | ScopeDef::Label(_) => false,\n+        ScopeDef::ModuleDef(hir::ModuleDef::Macro(mac)) => mac.is_fn_like(ctx.db),\n+        _ => true,\n+    };\n+\n+    let add_assoc_item = |acc: &mut Completions, item| match item {\n+        hir::AssocItem::Function(func) => acc.add_function(ctx, path_ctx, func, None),\n+        hir::AssocItem::Const(ct) => acc.add_const(ctx, ct),\n+        hir::AssocItem::TypeAlias(ty) => acc.add_type_alias(ctx, ty),\n     };\n \n     match qualified {\n         Qualified::Infer => ctx\n             .traits_in_scope()\n-            .0\n-            .into_iter()\n-            .flat_map(|it| hir::Trait::from(it).items(ctx.sema.db))\n-            .for_each(|item| add_assoc_item(acc, ctx, path_ctx, item)),\n+            .iter()\n+            .flat_map(|&it| hir::Trait::from(it).items(ctx.sema.db))\n+            .for_each(|item| add_assoc_item(acc, item)),\n         Qualified::With { resolution: None, .. } => {}\n         Qualified::With { resolution: Some(resolution), .. } => {\n             // Add associated types on type parameters and `Self`.\n@@ -67,46 +66,32 @@ pub(crate) fn complete_expr_path(\n                         }\n                     }\n                 }\n-\n                 hir::PathResolution::Def(\n                     def @ (hir::ModuleDef::Adt(_)\n                     | hir::ModuleDef::TypeAlias(_)\n                     | hir::ModuleDef::BuiltinType(_)),\n                 ) => {\n-                    if let &hir::ModuleDef::Adt(hir::Adt::Enum(e)) = def {\n-                        add_enum_variants(acc, ctx, path_ctx, e);\n-                    }\n                     let ty = match def {\n                         hir::ModuleDef::Adt(adt) => adt.ty(ctx.db),\n-                        hir::ModuleDef::TypeAlias(a) => {\n-                            let ty = a.ty(ctx.db);\n-                            if let Some(hir::Adt::Enum(e)) = ty.as_adt() {\n-                                cov_mark::hit!(completes_variant_through_alias);\n-                                add_enum_variants(acc, ctx, path_ctx, e);\n-                            }\n-                            ty\n-                        }\n+                        hir::ModuleDef::TypeAlias(a) => a.ty(ctx.db),\n                         hir::ModuleDef::BuiltinType(builtin) => {\n                             cov_mark::hit!(completes_primitive_assoc_const);\n                             builtin.ty(ctx.db)\n                         }\n-                        _ => unreachable!(),\n+                        _ => return,\n                     };\n \n+                    if let Some(hir::Adt::Enum(e)) = ty.as_adt() {\n+                        cov_mark::hit!(completes_variant_through_alias);\n+                        acc.add_enum_variants(ctx, path_ctx, e);\n+                    }\n+\n                     // XXX: For parity with Rust bug #22519, this does not complete Ty::AssocType.\n                     // (where AssocType is defined on a trait, not an inherent impl)\n \n-                    ty.iterate_path_candidates(\n-                        ctx.db,\n-                        &ctx.scope,\n-                        &ctx.traits_in_scope().0,\n-                        Some(ctx.module),\n-                        None,\n-                        |item| {\n-                            add_assoc_item(acc, ctx, path_ctx, item);\n-                            None::<()>\n-                        },\n-                    );\n+                    ctx.iterate_path_candidates(&ty, |item| {\n+                        add_assoc_item(acc, item);\n+                    });\n \n                     // Iterate assoc types separately\n                     ty.iterate_assoc_items(ctx.db, ctx.krate, |item| {\n@@ -119,7 +104,7 @@ pub(crate) fn complete_expr_path(\n                 hir::PathResolution::Def(hir::ModuleDef::Trait(t)) => {\n                     // Handles `Trait::assoc` as well as `<Ty as Trait>::assoc`.\n                     for item in t.items(ctx.db) {\n-                        add_assoc_item(acc, ctx, path_ctx, item);\n+                        add_assoc_item(acc, item);\n                     }\n                 }\n                 hir::PathResolution::TypeParam(_) | hir::PathResolution::SelfType(_) => {\n@@ -130,24 +115,12 @@ pub(crate) fn complete_expr_path(\n                     };\n \n                     if let Some(hir::Adt::Enum(e)) = ty.as_adt() {\n-                        add_enum_variants(acc, ctx, path_ctx, e);\n+                        acc.add_enum_variants(ctx, path_ctx, e);\n                     }\n-                    let mut seen = FxHashSet::default();\n-                    ty.iterate_path_candidates(\n-                        ctx.db,\n-                        &ctx.scope,\n-                        &ctx.traits_in_scope().0,\n-                        Some(ctx.module),\n-                        None,\n-                        |item| {\n-                            // We might iterate candidates of a trait multiple times here, so deduplicate\n-                            // them.\n-                            if seen.insert(item) {\n-                                add_assoc_item(acc, ctx, path_ctx, item);\n-                            }\n-                            None::<()>\n-                        },\n-                    );\n+\n+                    ctx.iterate_path_candidates(&ty, |item| {\n+                        add_assoc_item(acc, item);\n+                    });\n                 }\n                 _ => (),\n             }\n@@ -212,7 +185,7 @@ pub(crate) fn complete_expr_path(\n \n             if is_func_update.is_none() {\n                 let mut add_keyword =\n-                    |kw, snippet| acc.add_keyword_snippet_expr(ctx, kw, snippet, incomplete_let);\n+                    |kw, snippet| acc.add_keyword_snippet_expr(ctx, incomplete_let, kw, snippet);\n \n                 if !in_block_expr {\n                     add_keyword(\"unsafe\", \"unsafe {\\n    $0\\n}\");\n@@ -265,27 +238,3 @@ pub(crate) fn complete_expr_path(\n         }\n     }\n }\n-\n-fn add_assoc_item(\n-    acc: &mut Completions,\n-    ctx: &CompletionContext,\n-    path_ctx: &PathCompletionCtx,\n-    item: hir::AssocItem,\n-) {\n-    match item {\n-        hir::AssocItem::Function(func) => acc.add_function(ctx, path_ctx, func, None),\n-        hir::AssocItem::Const(ct) => acc.add_const(ctx, ct),\n-        hir::AssocItem::TypeAlias(ty) => acc.add_type_alias(ctx, ty),\n-    }\n-}\n-\n-fn add_enum_variants(\n-    acc: &mut Completions,\n-    ctx: &CompletionContext,\n-    path_ctx: &PathCompletionCtx,\n-    e: hir::Enum,\n-) {\n-    e.variants(ctx.db)\n-        .into_iter()\n-        .for_each(|variant| acc.add_enum_variant(ctx, path_ctx, variant, None));\n-}"}, {"sha": "7a344c2c7b39efc04e1c840723c87578fe86bae0", "filename": "crates/ide-completion/src/completions/pattern.rs", "status": "modified", "additions": 23, "deletions": 43, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/7a0774defa1f485788a5ad2150a3e045a8dc8be3/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0774defa1f485788a5ad2150a3e045a8dc8be3/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=7a0774defa1f485788a5ad2150a3e045a8dc8be3", "patch": "@@ -1,7 +1,6 @@\n //! Completes constants and paths in unqualified patterns.\n \n use hir::{db::DefDatabase, AssocItem, ScopeDef};\n-use ide_db::FxHashSet;\n use syntax::ast::Pat;\n \n use crate::{\n@@ -81,9 +80,7 @@ pub(crate) fn complete_pattern(\n                 hir::ModuleDef::Adt(hir::Adt::Enum(e)) => refutable || single_variant_enum(e),\n                 hir::ModuleDef::Const(..) => refutable,\n                 hir::ModuleDef::Module(..) => true,\n-                hir::ModuleDef::Macro(mac) if mac.is_fn_like(ctx.db) => {\n-                    return acc.add_macro_pat(ctx, pattern_ctx, mac, name);\n-                }\n+                hir::ModuleDef::Macro(mac) => mac.is_fn_like(ctx.db),\n                 _ => false,\n             },\n             hir::ScopeDef::ImplSelfType(impl_) => match impl_.self_ty(ctx.db).as_adt() {\n@@ -136,23 +133,14 @@ pub(crate) fn complete_pattern_path(\n                         }\n                     }\n                 }\n-                res @ (hir::PathResolution::TypeParam(_)\n-                | hir::PathResolution::SelfType(_)\n-                | hir::PathResolution::Def(hir::ModuleDef::Adt(hir::Adt::Struct(_)))\n-                | hir::PathResolution::Def(hir::ModuleDef::Adt(hir::Adt::Enum(_)))\n-                | hir::PathResolution::Def(hir::ModuleDef::Adt(hir::Adt::Union(_)))\n-                | hir::PathResolution::Def(hir::ModuleDef::BuiltinType(_))) => {\n+                res => {\n                     let ty = match res {\n                         hir::PathResolution::TypeParam(param) => param.ty(ctx.db),\n                         hir::PathResolution::SelfType(impl_def) => impl_def.self_ty(ctx.db),\n                         hir::PathResolution::Def(hir::ModuleDef::Adt(hir::Adt::Struct(s))) => {\n                             s.ty(ctx.db)\n                         }\n                         hir::PathResolution::Def(hir::ModuleDef::Adt(hir::Adt::Enum(e))) => {\n-                            cov_mark::hit!(enum_plain_qualified_use_tree);\n-                            e.variants(ctx.db).into_iter().for_each(|variant| {\n-                                acc.add_enum_variant(ctx, path_ctx, variant, None)\n-                            });\n                             e.ty(ctx.db)\n                         }\n                         hir::PathResolution::Def(hir::ModuleDef::Adt(hir::Adt::Union(u))) => {\n@@ -162,41 +150,33 @@ pub(crate) fn complete_pattern_path(\n                         _ => return,\n                     };\n \n-                    let mut seen = FxHashSet::default();\n-                    ty.iterate_path_candidates(\n-                        ctx.db,\n-                        &ctx.scope,\n-                        &ctx.scope.visible_traits().0,\n-                        Some(ctx.module),\n-                        None,\n-                        |item| {\n-                            match item {\n-                                AssocItem::TypeAlias(ta) => {\n-                                    // We might iterate candidates of a trait multiple times here, so deduplicate them.\n-                                    if seen.insert(item) {\n-                                        acc.add_type_alias(ctx, ta);\n-                                    }\n-                                }\n-                                AssocItem::Const(c) => {\n-                                    if seen.insert(item) {\n-                                        acc.add_const(ctx, c);\n-                                    }\n-                                }\n-                                _ => {}\n-                            }\n-                            None::<()>\n-                        },\n-                    );\n+                    if let Some(hir::Adt::Enum(e)) = ty.as_adt() {\n+                        cov_mark::hit!(enum_plain_qualified_use_tree);\n+                        acc.add_enum_variants(ctx, path_ctx, e);\n+                    }\n+\n+                    ctx.iterate_path_candidates(&ty, |item| match item {\n+                        AssocItem::TypeAlias(ta) => acc.add_type_alias(ctx, ta),\n+                        AssocItem::Const(c) => acc.add_const(ctx, c),\n+                        _ => {}\n+                    });\n                 }\n-                _ => {}\n             }\n         }\n-        // qualifier can only be none here if we are in a TuplePat or RecordPat in which case special characters have to follow the path\n         Qualified::Absolute => acc.add_crate_roots(ctx, path_ctx),\n         Qualified::No => {\n+            // this will only be hit if there are brackets or braces, otherwise this will be parsed as an ident pattern\n             ctx.process_all_names(&mut |name, res| {\n-                // FIXME: properly filter here\n-                if let ScopeDef::ModuleDef(_) = res {\n+                // FIXME: we should check what kind of pattern we are in and filter accordingly\n+                let add_completion = match res {\n+                    ScopeDef::ModuleDef(hir::ModuleDef::Macro(mac)) => mac.is_fn_like(ctx.db),\n+                    ScopeDef::ModuleDef(hir::ModuleDef::Adt(_)) => true,\n+                    ScopeDef::ModuleDef(hir::ModuleDef::Variant(_)) => true,\n+                    ScopeDef::ModuleDef(hir::ModuleDef::Module(_)) => true,\n+                    ScopeDef::ImplSelfType(_) => true,\n+                    _ => false,\n+                };\n+                if add_completion {\n                     acc.add_path_resolution(ctx, path_ctx, name, res);\n                 }\n             });"}, {"sha": "9f5922c5b0ba7032b37ccb68005a8ed7ab5d800a", "filename": "crates/ide-completion/src/completions/record.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7a0774defa1f485788a5ad2150a3e045a8dc8be3/crates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0774defa1f485788a5ad2150a3e045a8dc8be3/crates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs?ref=7a0774defa1f485788a5ad2150a3e045a8dc8be3", "patch": "@@ -17,6 +17,7 @@ pub(crate) fn complete_record_pattern_fields(\n         complete_fields(acc, ctx, ctx.sema.record_pattern_missing_fields(record_pat));\n     }\n }\n+\n pub(crate) fn complete_record_expr_fields(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n@@ -41,7 +42,6 @@ pub(crate) fn complete_record_expr_fields(\n         }\n         _ => {\n             let missing_fields = ctx.sema.record_literal_missing_fields(record_expr);\n-\n             add_default_update(acc, ctx, ty, &missing_fields);\n             if dot_prefix {\n                 let mut item =\n@@ -56,6 +56,29 @@ pub(crate) fn complete_record_expr_fields(\n     complete_fields(acc, ctx, missing_fields);\n }\n \n+// FIXME: This should probably be part of complete_path_expr\n+pub(crate) fn complete_record_expr_func_update(\n+    acc: &mut Completions,\n+    ctx: &CompletionContext,\n+    path_ctx: &PathCompletionCtx,\n+    expr_ctx: &ExprCtx,\n+) {\n+    if !matches!(path_ctx.qualified, Qualified::No) {\n+        return;\n+    }\n+    if let ExprCtx { is_func_update: Some(record_expr), .. } = expr_ctx {\n+        let ty = ctx.sema.type_of_expr(&Expr::RecordExpr(record_expr.clone()));\n+\n+        match ty.as_ref().and_then(|t| t.original.as_adt()) {\n+            Some(hir::Adt::Union(_)) => (),\n+            _ => {\n+                let missing_fields = ctx.sema.record_literal_missing_fields(record_expr);\n+                add_default_update(acc, ctx, ty, &missing_fields);\n+            }\n+        };\n+    }\n+}\n+\n fn add_default_update(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n@@ -67,6 +90,7 @@ fn add_default_update(\n         .zip(ty.as_ref())\n         .map_or(false, |(default_trait, ty)| ty.original.impls_trait(ctx.db, default_trait, &[]));\n     if impl_default_trait && !missing_fields.is_empty() {\n+        // FIXME: This should make use of scope_def like completions so we get all the other goodies\n         let completion_text = \"..Default::default()\";\n         let mut item = CompletionItem::new(SymbolKind::Field, ctx.source_range(), completion_text);\n         let completion_text =\n@@ -79,28 +103,6 @@ fn add_default_update(\n     }\n }\n \n-pub(crate) fn complete_record_expr_func_update(\n-    acc: &mut Completions,\n-    ctx: &CompletionContext,\n-    path_ctx: &PathCompletionCtx,\n-    expr_ctx: &ExprCtx,\n-) {\n-    if !matches!(path_ctx.qualified, Qualified::No) {\n-        return;\n-    }\n-    if let ExprCtx { is_func_update: Some(record_expr), .. } = expr_ctx {\n-        let ty = ctx.sema.type_of_expr(&Expr::RecordExpr(record_expr.clone()));\n-\n-        match ty.as_ref().and_then(|t| t.original.as_adt()) {\n-            Some(hir::Adt::Union(_)) => (),\n-            _ => {\n-                let missing_fields = ctx.sema.record_literal_missing_fields(record_expr);\n-                add_default_update(acc, ctx, ty, &missing_fields);\n-            }\n-        };\n-    }\n-}\n-\n fn complete_fields(\n     acc: &mut Completions,\n     ctx: &CompletionContext,"}, {"sha": "a530f4262ea980cb8e49243299860059740a5bf6", "filename": "crates/ide-completion/src/completions/snippet.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7a0774defa1f485788a5ad2150a3e045a8dc8be3/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0774defa1f485788a5ad2150a3e045a8dc8be3/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fsnippet.rs?ref=7a0774defa1f485788a5ad2150a3e045a8dc8be3", "patch": "@@ -9,12 +9,6 @@ use crate::{\n     CompletionContext, CompletionItem, CompletionItemKind, Completions, SnippetScope,\n };\n \n-fn snippet(ctx: &CompletionContext, cap: SnippetCap, label: &str, snippet: &str) -> Builder {\n-    let mut item = CompletionItem::new(CompletionItemKind::Snippet, ctx.source_range(), label);\n-    item.insert_snippet(cap, snippet);\n-    item\n-}\n-\n pub(crate) fn complete_expr_snippet(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n@@ -124,6 +118,12 @@ macro_rules! $1 {\n     }\n }\n \n+fn snippet(ctx: &CompletionContext, cap: SnippetCap, label: &str, snippet: &str) -> Builder {\n+    let mut item = CompletionItem::new(CompletionItemKind::Snippet, ctx.source_range(), label);\n+    item.insert_snippet(cap, snippet);\n+    item\n+}\n+\n fn add_custom_completions(\n     acc: &mut Completions,\n     ctx: &CompletionContext,"}, {"sha": "616d8621543797dab9929c89a96eaa0133b682e3", "filename": "crates/ide-completion/src/completions/type.rs", "status": "modified", "additions": 8, "deletions": 31, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7a0774defa1f485788a5ad2150a3e045a8dc8be3/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0774defa1f485788a5ad2150a3e045a8dc8be3/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs?ref=7a0774defa1f485788a5ad2150a3e045a8dc8be3", "patch": "@@ -1,7 +1,6 @@\n //! Completion of names from the current scope in type position.\n \n use hir::{HirDisplay, ScopeDef};\n-use ide_db::FxHashSet;\n use syntax::{ast, AstNode};\n \n use crate::{\n@@ -52,9 +51,8 @@ pub(crate) fn complete_type_path(\n     match qualified {\n         Qualified::Infer => ctx\n             .traits_in_scope()\n-            .0\n-            .into_iter()\n-            .flat_map(|it| hir::Trait::from(it).items(ctx.sema.db))\n+            .iter()\n+            .flat_map(|&it| hir::Trait::from(it).items(ctx.sema.db))\n             .for_each(|item| add_assoc_item(acc, item)),\n         Qualified::With { resolution: None, .. } => {}\n         Qualified::With { resolution: Some(resolution), .. } => {\n@@ -88,17 +86,9 @@ pub(crate) fn complete_type_path(\n                     // XXX: For parity with Rust bug #22519, this does not complete Ty::AssocType.\n                     // (where AssocType is defined on a trait, not an inherent impl)\n \n-                    ty.iterate_path_candidates(\n-                        ctx.db,\n-                        &ctx.scope,\n-                        &ctx.traits_in_scope().0,\n-                        Some(ctx.module),\n-                        None,\n-                        |item| {\n-                            add_assoc_item(acc, item);\n-                            None::<()>\n-                        },\n-                    );\n+                    ctx.iterate_path_candidates(&ty, |item| {\n+                        add_assoc_item(acc, item);\n+                    });\n \n                     // Iterate assoc types separately\n                     ty.iterate_assoc_items(ctx.db, ctx.krate, |item| {\n@@ -121,22 +111,9 @@ pub(crate) fn complete_type_path(\n                         _ => return,\n                     };\n \n-                    let mut seen = FxHashSet::default();\n-                    ty.iterate_path_candidates(\n-                        ctx.db,\n-                        &ctx.scope,\n-                        &ctx.traits_in_scope().0,\n-                        Some(ctx.module),\n-                        None,\n-                        |item| {\n-                            // We might iterate candidates of a trait multiple times here, so deduplicate\n-                            // them.\n-                            if seen.insert(item) {\n-                                add_assoc_item(acc, item);\n-                            }\n-                            None::<()>\n-                        },\n-                    );\n+                    ctx.iterate_path_candidates(&ty, |item| {\n+                        add_assoc_item(acc, item);\n+                    });\n                 }\n                 _ => (),\n             }"}, {"sha": "01a2f96fd12d637a371f4f55dd829ce9c17e8b93", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7a0774defa1f485788a5ad2150a3e045a8dc8be3/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0774defa1f485788a5ad2150a3e045a8dc8be3/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=7a0774defa1f485788a5ad2150a3e045a8dc8be3", "patch": "@@ -371,7 +371,9 @@ impl<'a> CompletionContext<'a> {\n     where\n         I: hir::HasVisibility + hir::HasAttrs + hir::HasCrate + Copy,\n     {\n-        self.is_visible_impl(&item.visibility(self.db), &item.attrs(self.db), item.krate(self.db))\n+        let vis = item.visibility(self.db);\n+        let attrs = item.attrs(self.db);\n+        self.is_visible_impl(&vis, &attrs, item.krate(self.db))\n     }\n \n     pub(crate) fn is_scope_def_hidden(&self, scope_def: ScopeDef) -> bool {\n@@ -391,6 +393,7 @@ impl<'a> CompletionContext<'a> {\n             _ => false,\n         }\n     }\n+\n     /// Whether the given trait is an operator trait or not.\n     pub(crate) fn is_ops_trait(&self, trait_: hir::Trait) -> bool {\n         match trait_.attrs(self.db).lang() {\n@@ -408,6 +411,29 @@ impl<'a> CompletionContext<'a> {\n         traits_in_scope\n     }\n \n+    pub(crate) fn iterate_path_candidates(\n+        &self,\n+        ty: &hir::Type,\n+        mut cb: impl FnMut(hir::AssocItem),\n+    ) {\n+        let mut seen = FxHashSet::default();\n+        ty.iterate_path_candidates(\n+            self.db,\n+            &self.scope,\n+            &self.traits_in_scope(),\n+            Some(self.module),\n+            None,\n+            |item| {\n+                // We might iterate candidates of a trait multiple times here, so deduplicate\n+                // them.\n+                if seen.insert(item) {\n+                    cb(item)\n+                }\n+                None::<()>\n+            },\n+        );\n+    }\n+\n     /// A version of [`SemanticsScope::process_all_names`] that filters out `#[doc(hidden)]` items.\n     pub(crate) fn process_all_names(&self, f: &mut dyn FnMut(Name, ScopeDef)) {\n         let _p = profile::span(\"CompletionContext::process_all_names\");"}, {"sha": "b806d955d99e3dcacf56310d9ecb5f8fe757f93b", "filename": "crates/ide-completion/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a0774defa1f485788a5ad2150a3e045a8dc8be3/crates%2Fide-completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0774defa1f485788a5ad2150a3e045a8dc8be3/crates%2Fide-completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Flib.rs?ref=7a0774defa1f485788a5ad2150a3e045a8dc8be3", "patch": "@@ -148,7 +148,7 @@ pub fn completions(\n     config: &CompletionConfig,\n     position: FilePosition,\n     trigger_character: Option<char>,\n-) -> Option<Completions> {\n+) -> Option<Vec<CompletionItem>> {\n     let (ctx, analysis) = &CompletionContext::new(db, position, config)?;\n     let mut completions = Completions::default();\n \n@@ -163,7 +163,7 @@ pub fn completions(\n             }\n         }\n         // prevent `(` from triggering unwanted completion noise\n-        return Some(completions);\n+        return Some(completions.into());\n     }\n \n     {\n@@ -197,7 +197,7 @@ pub fn completions(\n         }\n     }\n \n-    Some(completions)\n+    Some(completions.into())\n }\n \n /// Resolves additional completion data at the position given."}, {"sha": "7169209d810ed852dadb9bbdd510cb7d7df79f28", "filename": "crates/ide-completion/src/tests/pattern.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a0774defa1f485788a5ad2150a3e045a8dc8be3/crates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0774defa1f485788a5ad2150a3e045a8dc8be3/crates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs?ref=7a0774defa1f485788a5ad2150a3e045a8dc8be3", "patch": "@@ -399,7 +399,6 @@ fn foo() {\n \n #[test]\n fn completes_no_delims_if_existing() {\n-    // FIXME: We should not complete functions here\n     check_empty(\n         r#\"\n struct Bar(u32);\n@@ -410,9 +409,7 @@ fn foo() {\n }\n \"#,\n         expect![[r#\"\n-            fn foo     fn()\n             st Bar\n-            bt u32\n             kw crate::\n             kw self::\n             kw super::\n@@ -428,9 +425,7 @@ fn foo() {\n }\n \"#,\n         expect![[r#\"\n-            fn foo     fn()\n             st Foo\n-            bt u32\n             kw crate::\n             kw self::\n             kw super::"}]}