{"sha": "c61c776308d5b0a57bcb11e43077cf037a1190a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2MWM3NzYzMDhkNWIwYTU3YmNiMTFlNDMwNzdjZjAzN2ExMTkwYTA=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-11-25T05:07:09Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-11-25T05:07:09Z"}, "message": "Merge pull request #470 from sanxiyn/match-ref-pats\n\nExtend match_ref_pats to desugared matches", "tree": {"sha": "e32921170fdd93567892ba000bd2f635e7b98bcf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e32921170fdd93567892ba000bd2f635e7b98bcf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c61c776308d5b0a57bcb11e43077cf037a1190a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c61c776308d5b0a57bcb11e43077cf037a1190a0", "html_url": "https://github.com/rust-lang/rust/commit/c61c776308d5b0a57bcb11e43077cf037a1190a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c61c776308d5b0a57bcb11e43077cf037a1190a0/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b40e80f039afb01fefca508e7f7c5d31fa280a6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b40e80f039afb01fefca508e7f7c5d31fa280a6a", "html_url": "https://github.com/rust-lang/rust/commit/b40e80f039afb01fefca508e7f7c5d31fa280a6a"}, {"sha": "b1a0abe404740e1425a8586c7519114578d20372", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1a0abe404740e1425a8586c7519114578d20372", "html_url": "https://github.com/rust-lang/rust/commit/b1a0abe404740e1425a8586c7519114578d20372"}], "stats": {"total": 113, "additions": 74, "deletions": 39}, "files": [{"sha": "9d1d51444fad8c28df42e10c227b06b3d884b1ef", "filename": "src/approx_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c61c776308d5b0a57bcb11e43077cf037a1190a0/src%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c61c776308d5b0a57bcb11e43077cf037a1190a0/src%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fapprox_const.rs?ref=c61c776308d5b0a57bcb11e43077cf037a1190a0", "patch": "@@ -44,7 +44,7 @@ impl LintPass for ApproxConstant {\n \n impl LateLintPass for ApproxConstant {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n-        if let &ExprLit(ref lit) = &e.node {\n+        if let ExprLit(ref lit) = e.node {\n             check_lit(cx, lit, e);\n         }\n     }"}, {"sha": "f4a5b4c15174a184575bcff30002ee81a85dde73", "filename": "src/attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c61c776308d5b0a57bcb11e43077cf037a1190a0/src%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c61c776308d5b0a57bcb11e43077cf037a1190a0/src%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattrs.rs?ref=c61c776308d5b0a57bcb11e43077cf037a1190a0", "patch": "@@ -42,7 +42,7 @@ impl LateLintPass for AttrPass {\n }\n \n fn is_relevant_item(item: &Item) -> bool {\n-    if let &ItemFn(_, _, _, _, _, ref block) = &item.node {\n+    if let ItemFn(_, _, _, _, _, ref block) = item.node {\n         is_relevant_block(block)\n     } else { false }\n }"}, {"sha": "ab73086d07bfa155b80c12118c0775662f90cbbc", "filename": "src/bit_mask.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c61c776308d5b0a57bcb11e43077cf037a1190a0/src%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c61c776308d5b0a57bcb11e43077cf037a1190a0/src%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbit_mask.rs?ref=c61c776308d5b0a57bcb11e43077cf037a1190a0", "patch": "@@ -182,7 +182,7 @@ fn check_ineffective_gt(cx: &LateContext, span: Span, m: u64, c: u64, op: &str)\n fn fetch_int_literal(cx: &LateContext, lit : &Expr) -> Option<u64> {\n     match lit.node {\n         ExprLit(ref lit_ptr) => {\n-            if let &LitInt(value, _) = &lit_ptr.node {\n+            if let LitInt(value, _) = lit_ptr.node {\n                 Option::Some(value) //TODO: Handle sign\n             } else { Option::None }\n         }"}, {"sha": "9ac4ab1e0e0d3aceb14499763fe5bad32328b562", "filename": "src/len_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c61c776308d5b0a57bcb11e43077cf037a1190a0/src%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c61c776308d5b0a57bcb11e43077cf037a1190a0/src%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flen_zero.rs?ref=c61c776308d5b0a57bcb11e43077cf037a1190a0", "patch": "@@ -125,7 +125,7 @@ fn check_len_zero(cx: &LateContext, span: Span, name: &Name,\n fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n     /// get a ImplOrTraitItem and return true if it matches is_empty(self)\n     fn is_is_empty(cx: &LateContext, id: &ImplOrTraitItemId) -> bool {\n-        if let &MethodTraitItemId(def_id) = id {\n+        if let MethodTraitItemId(def_id) = *id {\n             if let ty::MethodTraitItem(ref method) =\n                 cx.tcx.impl_or_trait_item(def_id) {\n                     method.name.as_str() == \"is_empty\""}, {"sha": "acc7b0140529a4584182558990fe71ab07014231", "filename": "src/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c61c776308d5b0a57bcb11e43077cf037a1190a0/src%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c61c776308d5b0a57bcb11e43077cf037a1190a0/src%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flifetimes.rs?ref=c61c776308d5b0a57bcb11e43077cf037a1190a0", "patch": "@@ -168,7 +168,7 @@ impl <'v, 't> RefVisitor<'v, 't>  {\n     }\n \n     fn record(&mut self, lifetime: &Option<Lifetime>) {\n-        if let &Some(ref lt) = lifetime {\n+        if let Some(ref lt) = *lifetime {\n             if lt.name.as_str() == \"'static\" {\n                 self.lts.push(Static);\n             } else {"}, {"sha": "ec118052fbc2aff229ddfb496b1d232b4a1869c0", "filename": "src/matches.rs", "status": "modified", "additions": 40, "deletions": 15, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c61c776308d5b0a57bcb11e43077cf037a1190a0/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c61c776308d5b0a57bcb11e43077cf037a1190a0/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=c61c776308d5b0a57bcb11e43077cf037a1190a0", "patch": "@@ -2,6 +2,7 @@ use rustc::lint::*;\n use rustc_front::hir::*;\n use rustc::middle::ty;\n use syntax::ast::Lit_::LitBool;\n+use syntax::codemap::Span;\n \n use utils::{snippet, span_lint, span_help_and_lint, in_external_macro, expr_block};\n \n@@ -25,9 +26,8 @@ impl LintPass for MatchPass {\n \n impl LateLintPass for MatchPass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+        if in_external_macro(cx, expr.span) { return; }\n         if let ExprMatch(ref ex, ref arms, MatchSource::Normal) = expr.node {\n-            if in_external_macro(cx, expr.span) { return; }\n-\n             // check preconditions for SINGLE_MATCH\n                 // only two arms\n             if arms.len() == 2 &&\n@@ -53,19 +53,6 @@ impl LateLintPass for MatchPass {\n                                             expr_block(cx, &arms[0].body, None, \"..\")));\n             }\n \n-            // check preconditions for MATCH_REF_PATS\n-            if has_only_ref_pats(arms) {\n-                if let ExprAddrOf(Mutability::MutImmutable, ref inner) = ex.node {\n-                    span_lint(cx, MATCH_REF_PATS, expr.span, &format!(\n-                        \"you don't need to add `&` to both the expression to match \\\n-                         and the patterns: use `match {} {{ ...`\", snippet(cx, inner.span, \"..\")));\n-                } else {\n-                    span_lint(cx, MATCH_REF_PATS, expr.span, &format!(\n-                        \"instead of prefixing all patterns with `&`, you can dereference the \\\n-                         expression to match: `match *{} {{ ...`\", snippet(cx, ex.span, \"..\")));\n-                }\n-            }\n-\n             // check preconditions for MATCH_BOOL\n             // type of expression == bool\n             if cx.tcx.expr_ty(ex).sty == ty::TyBool {\n@@ -123,6 +110,22 @@ impl LateLintPass for MatchPass {\n                 }\n             }\n         }\n+        if let ExprMatch(ref ex, ref arms, source) = expr.node {\n+            // check preconditions for MATCH_REF_PATS\n+            if has_only_ref_pats(arms) {\n+                if let ExprAddrOf(Mutability::MutImmutable, ref inner) = ex.node {\n+                    let template = match_template(cx, expr.span, source, \"\", inner);\n+                    span_lint(cx, MATCH_REF_PATS, expr.span, &format!(\n+                        \"you don't need to add `&` to both the expression \\\n+                         and the patterns: use `{}`\", template));\n+                } else {\n+                    let template = match_template(cx, expr.span, source, \"*\", ex);\n+                    span_lint(cx, MATCH_REF_PATS, expr.span, &format!(\n+                        \"instead of prefixing all patterns with `&`, you can dereference the \\\n+                         expression: `{}`\", template));\n+                }\n+            }\n+        }\n     }\n }\n \n@@ -143,3 +146,25 @@ fn has_only_ref_pats(arms: &[Arm]) -> bool {\n     // look for Some(v) where there's at least one true element\n     mapped.map_or(false, |v| v.iter().any(|el| *el))\n }\n+\n+fn match_template(cx: &LateContext,\n+                  span: Span,\n+                  source: MatchSource,\n+                  op: &str,\n+                  expr: &Expr) -> String {\n+    let expr_snippet = snippet(cx, expr.span, \"..\");\n+    match source {\n+        MatchSource::Normal => {\n+            format!(\"match {}{} {{ ...\", op, expr_snippet)\n+        }\n+        MatchSource::IfLetDesugar { .. } => {\n+            format!(\"if let ... = {}{} {{\", op, expr_snippet)\n+        }\n+        MatchSource::WhileLetDesugar => {\n+            format!(\"while let ... = {}{} {{\", op, expr_snippet)\n+        }\n+        MatchSource::ForLoopDesugar => {\n+            cx.sess().span_bug(span, \"for loop desugared to match with &-patterns!\")\n+        }\n+    }\n+}"}, {"sha": "9df751d49b7e4162fc6b2bf837efca602c54357a", "filename": "src/misc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c61c776308d5b0a57bcb11e43077cf037a1190a0/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c61c776308d5b0a57bcb11e43077cf037a1190a0/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=c61c776308d5b0a57bcb11e43077cf037a1190a0", "patch": "@@ -84,10 +84,10 @@ impl LateLintPass for CmpNan {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprBinary(ref cmp, ref left, ref right) = expr.node {\n             if is_comparison_binop(cmp.node) {\n-                if let &ExprPath(_, ref path) = &left.node {\n+                if let ExprPath(_, ref path) = left.node {\n                     check_nan(cx, path, expr.span);\n                 }\n-                if let &ExprPath(_, ref path) = &right.node {\n+                if let ExprPath(_, ref path) = right.node {\n                     check_nan(cx, path, expr.span);\n                 }\n             }\n@@ -189,7 +189,7 @@ fn check_to_owned(cx: &LateContext, expr: &Expr, other_span: Span, left: bool, o\n                 }\n         }\n         ExprCall(ref path, ref v) if v.len() == 1 => {\n-            if let &ExprPath(None, ref path) = &path.node {\n+            if let ExprPath(None, ref path) = path.node {\n                 if match_path(path, &[\"String\", \"from_str\"]) ||\n                     match_path(path, &[\"String\", \"from\"]) {\n                             snippet(cx, v[0].span, \"..\")\n@@ -235,7 +235,7 @@ impl LintPass for ModuloOne {\n impl LateLintPass for ModuloOne {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprBinary(ref cmp, _, ref right) = expr.node {\n-            if let &Spanned {node: BinOp_::BiRem, ..} = cmp {\n+            if let Spanned {node: BinOp_::BiRem, ..} = *cmp {\n                 if is_integer_literal(right, 1) {\n                     cx.span_lint(MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n                 }"}, {"sha": "e6d1fc8a888a67db306434cad95f70b67470ef5a", "filename": "src/mutex_atomic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c61c776308d5b0a57bcb11e43077cf037a1190a0/src%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c61c776308d5b0a57bcb11e43077cf037a1190a0/src%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmutex_atomic.rs?ref=c61c776308d5b0a57bcb11e43077cf037a1190a0", "patch": "@@ -34,7 +34,7 @@ pub struct MutexAtomic;\n impl LateLintPass for MutexAtomic {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         let ty = cx.tcx.expr_ty(expr);\n-        if let &ty::TyStruct(_, subst) = &ty.sty {\n+        if let ty::TyStruct(_, subst) = ty.sty {\n             if match_type(cx, ty, &MUTEX_PATH) {\n                 let mutex_param = &subst.types.get(ParamSpace::TypeSpace, 0).sty;\n                 if let Some(atomic_name) = get_atomic_name(mutex_param) {"}, {"sha": "6946d0549d01a4da6ef044801f705b980fed3a7e", "filename": "src/ptr_arg.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c61c776308d5b0a57bcb11e43077cf037a1190a0/src%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c61c776308d5b0a57bcb11e43077cf037a1190a0/src%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fptr_arg.rs?ref=c61c776308d5b0a57bcb11e43077cf037a1190a0", "patch": "@@ -28,13 +28,13 @@ impl LintPass for PtrArg {\n \n impl LateLintPass for PtrArg {\n     fn check_item(&mut self, cx: &LateContext, item: &Item) {\n-        if let &ItemFn(ref decl, _, _, _, _, _) = &item.node {\n+        if let ItemFn(ref decl, _, _, _, _, _) = item.node {\n             check_fn(cx, decl);\n         }\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext, item: &ImplItem) {\n-        if let &ImplItemKind::Method(ref sig, _) = &item.node {\n+        if let ImplItemKind::Method(ref sig, _) = item.node {\n             if let Some(Node::NodeItem(it)) = cx.tcx.map.find(cx.tcx.map.get_parent(item.id)) {\n                 if let ItemImpl(_, _, _, Some(_), _, _) = it.node {\n                     return; // ignore trait impls\n@@ -45,7 +45,7 @@ impl LateLintPass for PtrArg {\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n-        if let &MethodTraitItem(ref sig, _) = &item.node {\n+        if let MethodTraitItem(ref sig, _) = item.node {\n             check_fn(cx, &sig.decl);\n         }\n     }"}, {"sha": "31bb985230d69d7a252f93877f67f963f7ca5367", "filename": "src/ranges.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c61c776308d5b0a57bcb11e43077cf037a1190a0/src%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c61c776308d5b0a57bcb11e43077cf037a1190a0/src%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Franges.rs?ref=c61c776308d5b0a57bcb11e43077cf037a1190a0", "patch": "@@ -40,10 +40,10 @@ impl LateLintPass for StepByZero {\n                 if_let_chain! {\n                     [\n                         // .iter() call\n-                        let &ExprMethodCall( Spanned { node: ref iter_name, .. }, _, ref iter_args ) = iter,\n+                        let ExprMethodCall( Spanned { node: ref iter_name, .. }, _, ref iter_args ) = *iter,\n                         iter_name.as_str() == \"iter\",\n                         // range expression in .zip() call: 0..x.len()\n-                        let &ExprRange(Some(ref from), Some(ref to)) = zip_arg,\n+                        let ExprRange(Some(ref from), Some(ref to)) = *zip_arg,\n                         is_integer_literal(from, 0),\n                         // .len() call\n                         let ExprMethodCall(Spanned { node: ref len_name, .. }, _, ref len_args) = to.node,"}, {"sha": "5fb27f75c3ce4f067b51424167d77c08b966912b", "filename": "src/shadow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c61c776308d5b0a57bcb11e43077cf037a1190a0/src%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c61c776308d5b0a57bcb11e43077cf037a1190a0/src%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshadow.rs?ref=c61c776308d5b0a57bcb11e43077cf037a1190a0", "patch": "@@ -63,8 +63,8 @@ fn check_decl(cx: &LateContext, decl: &Decl, bindings: &mut Vec<(Name, Span)>) {\n     if is_from_for_desugar(decl) { return; }\n     if let DeclLocal(ref local) = decl.node {\n         let Local{ ref pat, ref ty, ref init, id: _, span } = **local;\n-        if let &Some(ref t) = ty { check_ty(cx, t, bindings) }\n-        if let &Some(ref o) = init {\n+        if let Some(ref t) = *ty { check_ty(cx, t, bindings) }\n+        if let Some(ref o) = *init {\n             check_expr(cx, o, bindings);\n             check_pat(cx, pat, &Some(o), span, bindings);\n         } else {\n@@ -210,7 +210,7 @@ fn check_expr(cx: &LateContext, expr: &Expr, bindings: &mut Vec<(Name, Span)>) {\n         ExprIf(ref cond, ref then, ref otherwise) => {\n             check_expr(cx, cond, bindings);\n             check_block(cx, then, bindings);\n-            if let &Some(ref o) = otherwise { check_expr(cx, o, bindings); }\n+            if let Some(ref o) = *otherwise { check_expr(cx, o, bindings); }\n         }\n         ExprWhile(ref cond, ref block, _) => {\n             check_expr(cx, cond, bindings);"}, {"sha": "3c34e188d11dd7501e19c66fdfa9ba890e891789", "filename": "src/strings.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c61c776308d5b0a57bcb11e43077cf037a1190a0/src%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c61c776308d5b0a57bcb11e43077cf037a1190a0/src%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstrings.rs?ref=c61c776308d5b0a57bcb11e43077cf037a1190a0", "patch": "@@ -34,14 +34,14 @@ impl LintPass for StringAdd {\n \n impl LateLintPass for StringAdd {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n-        if let &ExprBinary(Spanned{ node: BiAdd, .. }, ref left, _) = &e.node {\n+        if let ExprBinary(Spanned{ node: BiAdd, .. }, ref left, _) = e.node {\n             if is_string(cx, left) {\n                 if let Allow = cx.current_level(STRING_ADD_ASSIGN) {\n                     // the string_add_assign is allow, so no duplicates\n                 } else {\n                     let parent = get_parent_expr(cx, e);\n                     if let Some(ref p) = parent {\n-                        if let &ExprAssign(ref target, _) = &p.node {\n+                        if let ExprAssign(ref target, _) = p.node {\n                             // avoid duplicate matches\n                             if is_exp_equal(cx, target, left) { return; }\n                         }\n@@ -51,7 +51,7 @@ impl LateLintPass for StringAdd {\n                     \"you added something to a string. \\\n                      Consider using `String::push_str()` instead\")\n             }\n-        } else if let &ExprAssign(ref target, ref src) = &e.node {\n+        } else if let ExprAssign(ref target, ref src) = e.node {\n             if is_string(cx, target) && is_add(cx, src, target) {\n                 span_lint(cx, STRING_ADD_ASSIGN, e.span,\n                     \"you assigned the result of adding something to this string. \\"}, {"sha": "ea3a48a94f5d24066bd578900d12a116569d521f", "filename": "tests/compile-fail/matches.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c61c776308d5b0a57bcb11e43077cf037a1190a0/tests%2Fcompile-fail%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c61c776308d5b0a57bcb11e43077cf037a1190a0/tests%2Fcompile-fail%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmatches.rs?ref=c61c776308d5b0a57bcb11e43077cf037a1190a0", "patch": "@@ -78,7 +78,7 @@ fn match_bool() {\n fn ref_pats() {\n     {\n         let v = &Some(0);\n-        match v {  //~ERROR instead of prefixing all patterns with `&`\n+        match v {  //~ERROR dereference the expression: `match *v { ...`\n             &Some(v) => println!(\"{:?}\", v),\n             &None => println!(\"none\"),\n         }\n@@ -88,13 +88,13 @@ fn ref_pats() {\n         }\n     }\n     let tup =& (1, 2);\n-    match tup {  //~ERROR instead of prefixing all patterns with `&`\n+    match tup {  //~ERROR dereference the expression: `match *tup { ...`\n         &(v, 1) => println!(\"{}\", v),\n         _ => println!(\"none\"),\n     }\n     // special case: using & both in expr and pats\n     let w = Some(0);\n-    match &w {  //~ERROR you don't need to add `&` to both\n+    match &w {  //~ERROR use `match w { ...`\n         &Some(v) => println!(\"{:?}\", v),\n         &None => println!(\"none\"),\n     }\n@@ -103,6 +103,16 @@ fn ref_pats() {\n     match w {\n         _ => println!(\"none\"),\n     }\n+\n+    let a = &Some(0);\n+    if let &None = a { //~ERROR dereference the expression: `if let ... = *a {`\n+        println!(\"none\");\n+    }\n+\n+    let b = Some(0);\n+    if let &None = &b { //~ERROR use `if let ... = b {`\n+        println!(\"none\");\n+    }\n }\n \n fn main() {"}]}