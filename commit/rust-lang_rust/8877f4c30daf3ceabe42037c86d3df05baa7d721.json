{"sha": "8877f4c30daf3ceabe42037c86d3df05baa7d721", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4NzdmNGMzMGRhZjNjZWFiZTQyMDM3Yzg2ZDNkZjA1YmFhN2Q3MjE=", "commit": {"author": {"name": "Andreas Molzer", "email": "andreas.molzer@gmx.de", "date": "2019-05-21T07:42:49Z"}, "committer": {"name": "Andreas Molzer", "email": "andreas.molzer@gmx.de", "date": "2019-05-22T15:44:14Z"}, "message": "Improve union of sparse and dense hybrid set\n\nThis optimization speeds up the union of a hybrid bitset when that\nswitches it from a sparse representation to a dense bitset. It now\nclones the dense bitset and integrate only the spare elements instead of\ndensifying the sparse bitset, initializing all elements, and then a\nunion on two dense bitset, touching all words a second time.", "tree": {"sha": "463c6dab793ecfc52fe03c975a62e85f384700f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/463c6dab793ecfc52fe03c975a62e85f384700f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8877f4c30daf3ceabe42037c86d3df05baa7d721", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8877f4c30daf3ceabe42037c86d3df05baa7d721", "html_url": "https://github.com/rust-lang/rust/commit/8877f4c30daf3ceabe42037c86d3df05baa7d721", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8877f4c30daf3ceabe42037c86d3df05baa7d721/comments", "author": {"login": "HeroicKatora", "id": 5550310, "node_id": "MDQ6VXNlcjU1NTAzMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/5550310?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HeroicKatora", "html_url": "https://github.com/HeroicKatora", "followers_url": "https://api.github.com/users/HeroicKatora/followers", "following_url": "https://api.github.com/users/HeroicKatora/following{/other_user}", "gists_url": "https://api.github.com/users/HeroicKatora/gists{/gist_id}", "starred_url": "https://api.github.com/users/HeroicKatora/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HeroicKatora/subscriptions", "organizations_url": "https://api.github.com/users/HeroicKatora/orgs", "repos_url": "https://api.github.com/users/HeroicKatora/repos", "events_url": "https://api.github.com/users/HeroicKatora/events{/privacy}", "received_events_url": "https://api.github.com/users/HeroicKatora/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HeroicKatora", "id": 5550310, "node_id": "MDQ6VXNlcjU1NTAzMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/5550310?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HeroicKatora", "html_url": "https://github.com/HeroicKatora", "followers_url": "https://api.github.com/users/HeroicKatora/followers", "following_url": "https://api.github.com/users/HeroicKatora/following{/other_user}", "gists_url": "https://api.github.com/users/HeroicKatora/gists{/gist_id}", "starred_url": "https://api.github.com/users/HeroicKatora/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HeroicKatora/subscriptions", "organizations_url": "https://api.github.com/users/HeroicKatora/orgs", "repos_url": "https://api.github.com/users/HeroicKatora/repos", "events_url": "https://api.github.com/users/HeroicKatora/events{/privacy}", "received_events_url": "https://api.github.com/users/HeroicKatora/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fa6e878be86490168c23de7added219e8aa0860", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fa6e878be86490168c23de7added219e8aa0860", "html_url": "https://github.com/rust-lang/rust/commit/7fa6e878be86490168c23de7added219e8aa0860"}], "stats": {"total": 49, "additions": 45, "deletions": 4}, "files": [{"sha": "08b7185dbe2141c3707bfcd193046878d5d076ef", "filename": "src/librustc_data_structures/bit_set.rs", "status": "modified", "additions": 45, "deletions": 4, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/8877f4c30daf3ceabe42037c86d3df05baa7d721/src%2Flibrustc_data_structures%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8877f4c30daf3ceabe42037c86d3df05baa7d721/src%2Flibrustc_data_structures%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbit_set.rs?ref=8877f4c30daf3ceabe42037c86d3df05baa7d721", "patch": "@@ -181,6 +181,45 @@ impl<T: Idx> BitSet<T> {\n         // Note: we currently don't bother trying to make a Sparse set.\n         HybridBitSet::Dense(self.to_owned())\n     }\n+\n+    /// Set `self = self | other`. In contrast to `union` returns `true` if the set contains at\n+    /// least one bit that is not in `other` (i.e. `other` is not a superset of `self`).\n+    ///\n+    /// This is an optimization for union of a hybrid bitset.\n+    fn reverse_union_sparse(&mut self, sparse: &SparseBitSet<T>) -> bool {\n+        assert!(sparse.domain_size == self.domain_size);\n+        self.clear_excess_bits();\n+\n+        let mut not_already = false;\n+        // Index of the current word not yet merged.\n+        let mut current_index = 0;\n+        // Mask of bits that came from the sparse set in the current word.\n+        let mut new_bit_mask = 0;\n+        for (word_index, mask) in sparse.iter().map(|x| word_index_and_mask(*x)) {\n+            // Next bit is in a word not inspected yet.\n+            if word_index > current_index {\n+                self.words[current_index] |= new_bit_mask;\n+                // Were there any bits in the old word that did not occur in the sparse set?\n+                not_already |= (self.words[current_index] ^ new_bit_mask) != 0;\n+                // Check all words we skipped for any set bit.\n+                not_already |= self.words[current_index+1..word_index].iter().any(|&x| x != 0);\n+                // Update next word.\n+                current_index = word_index;\n+                // Reset bit mask, no bits have been merged yet.\n+                new_bit_mask = 0;\n+            }\n+            // Add bit and mark it as coming from the sparse set.\n+            // self.words[word_index] |= mask;\n+            new_bit_mask |= mask;\n+        }\n+        self.words[current_index] |= new_bit_mask;\n+        // Any bits in the last inspected word that were not in the sparse set?\n+        not_already |= (self.words[current_index] ^ new_bit_mask) != 0;\n+        // Any bits in the tail? Note `clear_excess_bits` before.\n+        not_already |= self.words[current_index+1..].iter().any(|&x| x != 0);\n+\n+        not_already\n+    }\n }\n \n /// This is implemented by all the bitsets so that BitSet::union() can be\n@@ -518,10 +557,12 @@ impl<T: Idx> HybridBitSet<T> {\n                         changed\n                     }\n                     HybridBitSet::Dense(other_dense) => {\n-                        // `self` is sparse and `other` is dense. Densify\n-                        // `self` and then do the bitwise union.\n-                        let mut new_dense = self_sparse.to_dense();\n-                        let changed = new_dense.union(other_dense);\n+                        // `self` is sparse and `other` is dense. Clone the\n+                        // other set and do the bitwise union with sparse\n+                        // `self`. This avoids traversing the dense\n+                        // representation twice.\n+                        let mut new_dense = other_dense.clone();\n+                        let changed = new_dense.reverse_union_sparse(self_sparse);\n                         *self = HybridBitSet::Dense(new_dense);\n                         changed\n                     }"}]}