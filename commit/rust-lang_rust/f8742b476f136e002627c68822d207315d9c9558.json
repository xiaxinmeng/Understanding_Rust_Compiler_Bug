{"sha": "f8742b476f136e002627c68822d207315d9c9558", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4NzQyYjQ3NmYxMzZlMDAyNjI3YzY4ODIyZDIwNzMxNWQ5Yzk1NTg=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-03T02:33:25Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-04T05:56:17Z"}, "message": "rustdoc: Introduce the concept of a 'page'", "tree": {"sha": "fea02f94ecb922f9b6ce09b52e9aa32166be33ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fea02f94ecb922f9b6ce09b52e9aa32166be33ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8742b476f136e002627c68822d207315d9c9558", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8742b476f136e002627c68822d207315d9c9558", "html_url": "https://github.com/rust-lang/rust/commit/f8742b476f136e002627c68822d207315d9c9558", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8742b476f136e002627c68822d207315d9c9558/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "481d27a65d57e02fbc5bddf4375831715cab0179", "url": "https://api.github.com/repos/rust-lang/rust/commits/481d27a65d57e02fbc5bddf4375831715cab0179", "html_url": "https://github.com/rust-lang/rust/commit/481d27a65d57e02fbc5bddf4375831715cab0179"}], "stats": {"total": 695, "additions": 381, "deletions": 314}, "files": [{"sha": "237a8d7de7733fdde1c73241e67319aba683ead2", "filename": "src/rustdoc/attr_pass.rs", "status": "modified", "additions": 38, "deletions": 37, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_pass.rs?ref=f8742b476f136e002627c68822d207315d9c9558", "patch": "@@ -20,8 +20,8 @@ fn mk_pass() -> pass {\n \n fn run(\n     srv: astsrv::srv,\n-    doc: doc::cratedoc\n-) -> doc::cratedoc {\n+    doc: doc::doc\n+) -> doc::doc {\n     let fold = fold::fold({\n         fold_crate: fold_crate,\n         fold_item: fold_item,\n@@ -32,7 +32,7 @@ fn run(\n         fold_impl: fold_impl\n         with *fold::default_any_fold(srv)\n     });\n-    fold.fold_crate(fold, doc)\n+    fold.fold_doc(fold, doc)\n }\n \n fn fold_crate(\n@@ -62,7 +62,7 @@ fn fold_crate(\n #[test]\n fn should_replace_top_module_name_with_crate_name() {\n     let doc = test::mk_doc(\"#[link(name = \\\"bond\\\")];\");\n-    assert doc.topmod.name() == \"bond\";\n+    assert doc.cratemod().name() == \"bond\";\n }\n \n fn fold_item(\n@@ -108,25 +108,25 @@ fn parse_item_attrs<T:send>(\n #[test]\n fn should_should_extract_mod_attributes() {\n     let doc = test::mk_doc(\"#[doc = \\\"test\\\"] mod a { }\");\n-    assert doc.topmod.mods()[0].desc() == some(\"test\");\n+    assert doc.cratemod().mods()[0].desc() == some(\"test\");\n }\n \n #[test]\n fn should_extract_top_mod_attributes() {\n     let doc = test::mk_doc(\"#[doc = \\\"test\\\"];\");\n-    assert doc.topmod.desc() == some(\"test\");\n+    assert doc.cratemod().desc() == some(\"test\");\n }\n \n #[test]\n fn should_extract_native_mod_attributes() {\n     let doc = test::mk_doc(\"#[doc = \\\"test\\\"] native mod a { }\");\n-    assert doc.topmod.nmods()[0].desc() == some(\"test\");\n+    assert doc.cratemod().nmods()[0].desc() == some(\"test\");\n }\n \n #[test]\n fn should_extract_native_fn_attributes() {\n     let doc = test::mk_doc(\"native mod a { #[doc = \\\"test\\\"] fn a(); }\");\n-    assert doc.topmod.nmods()[0].fns[0].desc() == some(\"test\");\n+    assert doc.cratemod().nmods()[0].fns[0].desc() == some(\"test\");\n }\n \n fn fold_fn(\n@@ -187,13 +187,13 @@ fn merge_ret_attrs(\n #[test]\n fn should_extract_fn_attributes() {\n     let doc = test::mk_doc(\"#[doc = \\\"test\\\"] fn a() -> int { }\");\n-    assert doc.topmod.fns()[0].desc() == some(\"test\");\n+    assert doc.cratemod().fns()[0].desc() == some(\"test\");\n }\n \n #[test]\n fn should_extract_fn_arg_attributes() {\n     let doc = test::mk_doc(\"#[doc(args(a = \\\"b\\\"))] fn c(a: bool) { }\");\n-    assert doc.topmod.fns()[0].args[0].desc == some(\"b\");\n+    assert doc.cratemod().fns()[0].args[0].desc == some(\"b\");\n }\n \n #[test]\n@@ -203,7 +203,7 @@ fn should_extract_fn_return_attributes() {\n         let doc = extract::from_srv(srv, \"\");\n         let doc = tystr_pass::mk_pass().f(srv, doc);\n         let fold = fold::default_any_fold(srv);\n-        let doc = fold_fn(fold, doc.topmod.fns()[0]);\n+        let doc = fold_fn(fold, doc.cratemod().fns()[0]);\n         assert doc.return.desc == some(\"what\");\n     }\n }\n@@ -215,23 +215,23 @@ fn should_preserve_fn_sig() {\n         let doc = extract::from_srv(srv, \"\");\n         let doc = tystr_pass::mk_pass().f(srv, doc);\n         let fold = fold::default_any_fold(srv);\n-        let doc = fold_fn(fold, doc.topmod.fns()[0]);\n+        let doc = fold_fn(fold, doc.cratemod().fns()[0]);\n         assert doc.sig == some(\"fn a() -> int\");\n     }\n }\n \n #[test]\n fn should_extract_fn_failure_conditions() {\n     let doc = test::mk_doc(\"#[doc(failure = \\\"what\\\")] fn a() { }\");\n-    assert doc.topmod.fns()[0].failure == some(\"what\");\n+    assert doc.cratemod().fns()[0].failure == some(\"what\");\n }\n \n #[test]\n fn should_extract_const_docs() {\n     let doc = test::mk_doc(\"#[doc(brief = \\\"foo\\\", desc = \\\"bar\\\")]\\\n                             const a: bool = true;\");\n-    assert doc.topmod.consts()[0].brief() == some(\"foo\");\n-    assert doc.topmod.consts()[0].desc() == some(\"bar\");\n+    assert doc.cratemod().consts()[0].brief() == some(\"foo\");\n+    assert doc.cratemod().consts()[0].desc() == some(\"bar\");\n }\n \n fn fold_enum(\n@@ -273,14 +273,14 @@ fn fold_enum(\n fn should_extract_enum_docs() {\n     let doc = test::mk_doc(\"#[doc(brief = \\\"a\\\", desc = \\\"b\\\")]\\\n                             enum a { v }\");\n-    assert doc.topmod.enums()[0].brief() == some(\"a\");\n-    assert doc.topmod.enums()[0].desc() == some(\"b\");\n+    assert doc.cratemod().enums()[0].brief() == some(\"a\");\n+    assert doc.cratemod().enums()[0].desc() == some(\"b\");\n }\n \n #[test]\n fn should_extract_variant_docs() {\n     let doc = test::mk_doc(\"enum a { #[doc = \\\"c\\\"] v }\");\n-    assert doc.topmod.enums()[0].variants[0].desc == some(\"c\");\n+    assert doc.cratemod().enums()[0].variants[0].desc == some(\"c\");\n }\n \n fn fold_res(\n@@ -314,16 +314,16 @@ fn fold_res(\n fn should_extract_res_docs() {\n     let doc = test::mk_doc(\"#[doc(brief = \\\"a\\\", desc = \\\"b\\\")]\\\n                             resource r(b: bool) { }\");\n-    assert doc.topmod.resources()[0].brief() == some(\"a\");\n-    assert doc.topmod.resources()[0].desc() == some(\"b\");\n+    assert doc.cratemod().resources()[0].brief() == some(\"a\");\n+    assert doc.cratemod().resources()[0].desc() == some(\"b\");\n }\n \n #[test]\n fn should_extract_res_arg_docs() {\n     let doc = test::mk_doc(\"#[doc(args(a = \\\"b\\\"))]\\\n                             resource r(a: bool) { }\");\n-    assert doc.topmod.resources()[0].args[0].name == \"a\";\n-    assert doc.topmod.resources()[0].args[0].desc == some(\"b\");\n+    assert doc.cratemod().resources()[0].args[0].name == \"a\";\n+    assert doc.cratemod().resources()[0].args[0].desc == some(\"b\");\n }\n \n fn fold_iface(\n@@ -394,7 +394,7 @@ fn merge_method_attrs(\n #[test]\n fn should_extract_iface_docs() {\n     let doc = test::mk_doc(\"#[doc = \\\"whatever\\\"] iface i { fn a(); }\");\n-    assert doc.topmod.ifaces()[0].desc() == some(\"whatever\");\n+    assert doc.cratemod().ifaces()[0].desc() == some(\"whatever\");\n }\n \n #[test]\n@@ -409,11 +409,12 @@ fn should_extract_iface_method_docs() {\n          failure = \\\"failure\\\")]\\\n          fn f(a: bool) -> bool;\\\n          }\");\n-    assert doc.topmod.ifaces()[0].methods[0].brief == some(\"brief\");\n-    assert doc.topmod.ifaces()[0].methods[0].desc == some(\"desc\");\n-    assert doc.topmod.ifaces()[0].methods[0].args[0].desc == some(\"a\");\n-    assert doc.topmod.ifaces()[0].methods[0].return.desc == some(\"return\");\n-    assert doc.topmod.ifaces()[0].methods[0].failure == some(\"failure\");\n+    assert doc.cratemod().ifaces()[0].methods[0].brief == some(\"brief\");\n+    assert doc.cratemod().ifaces()[0].methods[0].desc == some(\"desc\");\n+    assert doc.cratemod().ifaces()[0].methods[0].args[0].desc == some(\"a\");\n+    assert doc.cratemod().ifaces()[0].methods[0].return.desc\n+        == some(\"return\");\n+    assert doc.cratemod().ifaces()[0].methods[0].failure == some(\"failure\");\n }\n \n \n@@ -434,7 +435,7 @@ fn fold_impl(\n fn should_extract_impl_docs() {\n     let doc = test::mk_doc(\n         \"#[doc = \\\"whatever\\\"] impl i for int { fn a() { } }\");\n-    assert doc.topmod.impls()[0].desc() == some(\"whatever\");\n+    assert doc.cratemod().impls()[0].desc() == some(\"whatever\");\n }\n \n #[test]\n@@ -449,25 +450,25 @@ fn should_extract_impl_method_docs() {\n          failure = \\\"failure\\\")]\\\n          fn f(a: bool) -> bool { }\\\n          }\");\n-    assert doc.topmod.impls()[0].methods[0].brief == some(\"brief\");\n-    assert doc.topmod.impls()[0].methods[0].desc == some(\"desc\");\n-    assert doc.topmod.impls()[0].methods[0].args[0].desc == some(\"a\");\n-    assert doc.topmod.impls()[0].methods[0].return.desc == some(\"return\");\n-    assert doc.topmod.impls()[0].methods[0].failure == some(\"failure\");\n+    assert doc.cratemod().impls()[0].methods[0].brief == some(\"brief\");\n+    assert doc.cratemod().impls()[0].methods[0].desc == some(\"desc\");\n+    assert doc.cratemod().impls()[0].methods[0].args[0].desc == some(\"a\");\n+    assert doc.cratemod().impls()[0].methods[0].return.desc == some(\"return\");\n+    assert doc.cratemod().impls()[0].methods[0].failure == some(\"failure\");\n }\n \n #[test]\n fn should_extract_type_docs() {\n     let doc = test::mk_doc(\n         \"#[doc(brief = \\\"brief\\\", desc = \\\"desc\\\")]\\\n          type t = int;\");\n-    assert doc.topmod.types()[0].brief() == some(\"brief\");\n-    assert doc.topmod.types()[0].desc() == some(\"desc\");\n+    assert doc.cratemod().types()[0].brief() == some(\"brief\");\n+    assert doc.cratemod().types()[0].desc() == some(\"desc\");\n }\n \n #[cfg(test)]\n mod test {\n-    fn mk_doc(source: str) -> doc::cratedoc {\n+    fn mk_doc(source: str) -> doc::doc {\n         astsrv::from_str(source) {|srv|\n             let doc = extract::from_srv(srv, \"\");\n             run(srv, doc)"}, {"sha": "847c99803b6cc1bde5b8f14b53d9040d28363e94", "filename": "src/rustdoc/desc_pass.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Fdesc_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Fdesc_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdesc_pass.rs?ref=f8742b476f136e002627c68822d207315d9c9558", "patch": "@@ -5,7 +5,7 @@ export mk_pass;\n fn mk_pass(name: str, op: fn~(str) -> str) -> pass {\n     {\n         name: name,\n-        f: fn~(srv: astsrv::srv, doc: doc::cratedoc) -> doc::cratedoc {\n+        f: fn~(srv: astsrv::srv, doc: doc::doc) -> doc::doc {\n             run(srv, doc, op)\n         }\n     }\n@@ -15,9 +15,9 @@ type op = fn~(str) -> str;\n \n fn run(\n     _srv: astsrv::srv,\n-    doc: doc::cratedoc,\n+    doc: doc::doc,\n     op: op\n-) -> doc::cratedoc {\n+) -> doc::doc {\n     let fold = fold::fold({\n         fold_item: fold_item,\n         fold_fn: fold_fn,\n@@ -27,7 +27,7 @@ fn run(\n         fold_impl: fold_impl\n         with *fold::default_any_fold(op)\n     });\n-    fold.fold_crate(fold, doc)\n+    fold.fold_doc(fold, doc)\n }\n \n fn maybe_apply_op(op: op, s: option<str>) -> option<str> {\n@@ -136,155 +136,155 @@ fn fold_impl(fold: fold::fold<op>, doc: doc::impldoc) -> doc::impldoc {\n #[test]\n fn should_execute_op_on_enum_brief() {\n     let doc = test::mk_doc(\"#[doc(brief = \\\" a \\\")] enum a { b }\");\n-    assert doc.topmod.enums()[0].brief() == some(\"a\");\n+    assert doc.cratemod().enums()[0].brief() == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_enum_desc() {\n     let doc = test::mk_doc(\"#[doc(desc = \\\" a \\\")] enum a { b }\");\n-    assert doc.topmod.enums()[0].desc() == some(\"a\");\n+    assert doc.cratemod().enums()[0].desc() == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_variant_desc() {\n     let doc = test::mk_doc(\"enum a { #[doc = \\\" a \\\"] b }\");\n-    assert doc.topmod.enums()[0].variants[0].desc == some(\"a\");\n+    assert doc.cratemod().enums()[0].variants[0].desc == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_resource_brief() {\n     let doc = test::mk_doc(\"#[doc(brief = \\\" a \\\")] resource r(a: bool) { }\");\n-    assert doc.topmod.resources()[0].brief() == some(\"a\");\n+    assert doc.cratemod().resources()[0].brief() == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_resource_desc() {\n     let doc = test::mk_doc(\"#[doc(desc = \\\" a \\\")] resource r(a: bool) { }\");\n-    assert doc.topmod.resources()[0].desc() == some(\"a\");\n+    assert doc.cratemod().resources()[0].desc() == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_resource_args() {\n     let doc = test::mk_doc(\n         \"#[doc(args(a = \\\" a \\\"))] resource r(a: bool) { }\");\n-    assert doc.topmod.resources()[0].args[0].desc == some(\"a\");\n+    assert doc.cratemod().resources()[0].args[0].desc == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_iface_brief() {\n     let doc = test::mk_doc(\n         \"#[doc(brief = \\\" a \\\")] iface i { fn a(); }\");\n-    assert doc.topmod.ifaces()[0].brief() == some(\"a\");\n+    assert doc.cratemod().ifaces()[0].brief() == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_iface_desc() {\n     let doc = test::mk_doc(\n         \"#[doc(desc = \\\" a \\\")] iface i { fn a(); }\");\n-    assert doc.topmod.ifaces()[0].desc() == some(\"a\");\n+    assert doc.cratemod().ifaces()[0].desc() == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_iface_method_brief() {\n     let doc = test::mk_doc(\n         \"iface i { #[doc(brief = \\\" a \\\")] fn a(); }\");\n-    assert doc.topmod.ifaces()[0].methods[0].brief == some(\"a\");\n+    assert doc.cratemod().ifaces()[0].methods[0].brief == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_iface_method_desc() {\n     let doc = test::mk_doc(\n         \"iface i { #[doc(desc = \\\" a \\\")] fn a(); }\");\n-    assert doc.topmod.ifaces()[0].methods[0].desc == some(\"a\");\n+    assert doc.cratemod().ifaces()[0].methods[0].desc == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_iface_method_args() {\n     let doc = test::mk_doc(\n         \"iface i { #[doc(args(a = \\\" a \\\"))] fn a(a: bool); }\");\n-    assert doc.topmod.ifaces()[0].methods[0].args[0].desc == some(\"a\");\n+    assert doc.cratemod().ifaces()[0].methods[0].args[0].desc == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_iface_method_return() {\n     let doc = test::mk_doc(\n         \"iface i { #[doc(return = \\\" a \\\")] fn a() -> int; }\");\n-    assert doc.topmod.ifaces()[0].methods[0].return.desc == some(\"a\");\n+    assert doc.cratemod().ifaces()[0].methods[0].return.desc == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_iface_method_failure_condition() {\n     let doc = test::mk_doc(\"iface i { #[doc(failure = \\\" a \\\")] fn a(); }\");\n-    assert doc.topmod.ifaces()[0].methods[0].failure == some(\"a\");\n+    assert doc.cratemod().ifaces()[0].methods[0].failure == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_impl_brief() {\n     let doc = test::mk_doc(\n         \"#[doc(brief = \\\" a \\\")] impl i for int { fn a() { } }\");\n-    assert doc.topmod.impls()[0].brief() == some(\"a\");\n+    assert doc.cratemod().impls()[0].brief() == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_impl_desc() {\n     let doc = test::mk_doc(\n         \"#[doc(desc = \\\" a \\\")] impl i for int { fn a() { } }\");\n-    assert doc.topmod.impls()[0].desc() == some(\"a\");\n+    assert doc.cratemod().impls()[0].desc() == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_impl_method_brief() {\n     let doc = test::mk_doc(\n         \"impl i for int { #[doc(brief = \\\" a \\\")] fn a() { } }\");\n-    assert doc.topmod.impls()[0].methods[0].brief == some(\"a\");\n+    assert doc.cratemod().impls()[0].methods[0].brief == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_impl_method_desc() {\n     let doc = test::mk_doc(\n         \"impl i for int { #[doc(desc = \\\" a \\\")] fn a() { } }\");\n-    assert doc.topmod.impls()[0].methods[0].desc == some(\"a\");\n+    assert doc.cratemod().impls()[0].methods[0].desc == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_impl_method_args() {\n     let doc = test::mk_doc(\n         \"impl i for int { #[doc(args(a = \\\" a \\\"))] fn a(a: bool) { } }\");\n-    assert doc.topmod.impls()[0].methods[0].args[0].desc == some(\"a\");\n+    assert doc.cratemod().impls()[0].methods[0].args[0].desc == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_impl_method_return() {\n     let doc = test::mk_doc(\n         \"impl i for int { #[doc(return = \\\" a \\\")] fn a() -> int { fail } }\");\n-    assert doc.topmod.impls()[0].methods[0].return.desc == some(\"a\");\n+    assert doc.cratemod().impls()[0].methods[0].return.desc == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_impl_method_failure_condition() {\n     let doc = test::mk_doc(\n         \"impl i for int { #[doc(failure = \\\" a \\\")] fn a() { } }\");\n-    assert doc.topmod.impls()[0].methods[0].failure == some(\"a\");\n+    assert doc.cratemod().impls()[0].methods[0].failure == some(\"a\");\n }\n \n \n #[test]\n fn should_execute_op_on_type_brief() {\n     let doc = test::mk_doc(\n         \"#[doc(brief = \\\" a \\\")] type t = int;\");\n-    assert doc.topmod.types()[0].brief() == some(\"a\");\n+    assert doc.cratemod().types()[0].brief() == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_type_desc() {\n     let doc = test::mk_doc(\n         \"#[doc(desc = \\\" a \\\")] type t = int;\");\n-    assert doc.topmod.types()[0].desc() == some(\"a\");\n+    assert doc.cratemod().types()[0].desc() == some(\"a\");\n }\n \n #[cfg(test)]\n mod test {\n-    fn mk_doc(source: str) -> doc::cratedoc {\n+    fn mk_doc(source: str) -> doc::doc {\n         astsrv::from_str(source) {|srv|\n             let doc = extract::from_srv(srv, \"\");\n             let doc = attr_pass::mk_pass().f(srv, doc);"}, {"sha": "695742cbebce816132522c62320d88d84b8360d6", "filename": "src/rustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdesc_to_brief_pass.rs?ref=f8742b476f136e002627c68822d207315d9c9558", "patch": "@@ -18,15 +18,15 @@ fn mk_pass() -> pass {\n \n fn run(\n     _srv: astsrv::srv,\n-    doc: doc::cratedoc\n-) -> doc::cratedoc {\n+    doc: doc::doc\n+) -> doc::doc {\n     let fold = fold::fold({\n         fold_item: fold_item,\n         fold_iface: fold_iface,\n         fold_impl: fold_impl\n         with *fold::default_any_fold(())\n     });\n-    fold.fold_crate(fold, doc)\n+    fold.fold_doc(fold, doc)\n }\n \n fn fold_item(fold: fold::fold<()>, doc: doc::itemdoc) -> doc::itemdoc {\n@@ -77,79 +77,79 @@ fn fold_impl(fold: fold::fold<()>, doc: doc::impldoc) -> doc::impldoc {\n #[test]\n fn should_promote_mod_desc() {\n     let doc = test::mk_doc(\"#[doc(desc = \\\"desc\\\")] mod m { }\");\n-    assert doc.topmod.mods()[0].brief() == some(\"desc\");\n-    assert doc.topmod.mods()[0].desc() == none;\n+    assert doc.cratemod().mods()[0].brief() == some(\"desc\");\n+    assert doc.cratemod().mods()[0].desc() == none;\n }\n \n #[test]\n fn should_promote_const_desc() {\n     let doc = test::mk_doc(\"#[doc(desc = \\\"desc\\\")] const a: bool = true;\");\n-    assert doc.topmod.consts()[0].brief() == some(\"desc\");\n-    assert doc.topmod.consts()[0].desc() == none;\n+    assert doc.cratemod().consts()[0].brief() == some(\"desc\");\n+    assert doc.cratemod().consts()[0].desc() == none;\n }\n \n #[test]\n fn should_promote_fn_desc() {\n     let doc = test::mk_doc(\"#[doc(desc = \\\"desc\\\")] fn a() { }\");\n-    assert doc.topmod.fns()[0].brief() == some(\"desc\");\n-    assert doc.topmod.fns()[0].desc() == none;\n+    assert doc.cratemod().fns()[0].brief() == some(\"desc\");\n+    assert doc.cratemod().fns()[0].desc() == none;\n }\n \n #[test]\n fn should_promote_enum_desc() {\n     let doc = test::mk_doc(\"#[doc(desc = \\\"desc\\\")] enum a { b }\");\n-    assert doc.topmod.enums()[0].brief() == some(\"desc\");\n-    assert doc.topmod.enums()[0].desc() == none;\n+    assert doc.cratemod().enums()[0].brief() == some(\"desc\");\n+    assert doc.cratemod().enums()[0].desc() == none;\n }\n \n #[test]\n fn should_promote_resource_desc() {\n     let doc = test::mk_doc(\n         \"#[doc(desc = \\\"desc\\\")] resource r(a: bool) { }\");\n-    assert doc.topmod.resources()[0].brief() == some(\"desc\");\n-    assert doc.topmod.resources()[0].desc() == none;\n+    assert doc.cratemod().resources()[0].brief() == some(\"desc\");\n+    assert doc.cratemod().resources()[0].desc() == none;\n }\n \n #[test]\n fn should_promote_iface_desc() {\n     let doc = test::mk_doc(\"#[doc(desc = \\\"desc\\\")] iface i { fn a(); }\");\n-    assert doc.topmod.ifaces()[0].brief() == some(\"desc\");\n-    assert doc.topmod.ifaces()[0].desc() == none;\n+    assert doc.cratemod().ifaces()[0].brief() == some(\"desc\");\n+    assert doc.cratemod().ifaces()[0].desc() == none;\n }\n \n #[test]\n fn should_promote_iface_method_desc() {\n     let doc = test::mk_doc(\"iface i { #[doc(desc = \\\"desc\\\")] fn a(); }\");\n-    assert doc.topmod.ifaces()[0].methods[0].brief == some(\"desc\");\n-    assert doc.topmod.ifaces()[0].methods[0].desc == none;\n+    assert doc.cratemod().ifaces()[0].methods[0].brief == some(\"desc\");\n+    assert doc.cratemod().ifaces()[0].methods[0].desc == none;\n }\n \n #[test]\n fn should_promote_impl_desc() {\n     let doc = test::mk_doc(\n         \"#[doc(desc = \\\"desc\\\")] impl i for int { fn a() { } }\");\n-    assert doc.topmod.impls()[0].brief() == some(\"desc\");\n-    assert doc.topmod.impls()[0].desc() == none;\n+    assert doc.cratemod().impls()[0].brief() == some(\"desc\");\n+    assert doc.cratemod().impls()[0].desc() == none;\n }\n \n #[test]\n fn should_promote_impl_method_desc() {\n     let doc = test::mk_doc(\n         \"impl i for int { #[doc(desc = \\\"desc\\\")] fn a() { } }\");\n-    assert doc.topmod.impls()[0].methods[0].brief == some(\"desc\");\n-    assert doc.topmod.impls()[0].methods[0].desc == none;\n+    assert doc.cratemod().impls()[0].methods[0].brief == some(\"desc\");\n+    assert doc.cratemod().impls()[0].methods[0].desc == none;\n }\n \n #[test]\n fn should_promote_type_desc() {\n     let doc = test::mk_doc(\"#[doc(desc = \\\"desc\\\")] type t = int;\");\n-    assert doc.topmod.types()[0].brief() == some(\"desc\");\n-    assert doc.topmod.types()[0].desc() == none;\n+    assert doc.cratemod().types()[0].brief() == some(\"desc\");\n+    assert doc.cratemod().types()[0].desc() == none;\n }\n \n #[cfg(test)]\n mod test {\n-    fn mk_doc(source: str) -> doc::cratedoc {\n+    fn mk_doc(source: str) -> doc::doc {\n         astsrv::from_str(source) {|srv|\n             let doc = extract::from_srv(srv, \"\");\n             let doc = attr_pass::mk_pass().f(srv, doc);"}, {"sha": "b7a7fb4dd88e1856caa8972aaf31030fcb8d89be", "filename": "src/rustdoc/doc.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdoc.rs?ref=f8742b476f136e002627c68822d207315d9c9558", "patch": "@@ -2,6 +2,15 @@\n \n type ast_id = int;\n \n+type doc = {\n+    pages: [page]\n+};\n+\n+enum page {\n+    cratepage(cratedoc),\n+    itempage(itemtag)\n+}\n+\n // FIXME: We currently give topmod the name of the crate.  There would\n // probably be fewer special cases if the crate had its own name and\n // topmod's name was the empty string.\n@@ -131,6 +140,21 @@ type index_entry = {\n     link: str\n };\n \n+impl util for doc {\n+    fn cratedoc() -> cratedoc {\n+        option::get(vec::foldl(none, self.pages) {|_m, page|\n+            alt page {\n+              doc::cratepage(doc) { some(doc) }\n+              _ { none }\n+            }\n+        })\n+    }\n+\n+    fn cratemod() -> moddoc {\n+        self.cratedoc().topmod\n+    }\n+}\n+\n #[doc = \"Some helper methods on moddoc, mostly for testing\"]\n impl util for moddoc {\n "}, {"sha": "9340d15d47438a8bd39bc1f1d9be7919e5bd27f8", "filename": "src/rustdoc/extract.rs", "status": "modified", "additions": 39, "deletions": 35, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fextract.rs?ref=f8742b476f136e002627c68822d207315d9c9558", "patch": "@@ -7,7 +7,7 @@ export from_srv, extract;\n fn from_srv(\n     srv: astsrv::srv,\n     default_name: str\n-) -> doc::cratedoc {\n+) -> doc::doc {\n \n     #[doc = \"Use the AST service to create a document tree\"];\n \n@@ -19,9 +19,13 @@ fn from_srv(\n fn extract(\n     crate: @ast::crate,\n     default_name: str\n-) -> doc::cratedoc {\n+) -> doc::doc {\n     {\n-        topmod: top_moddoc_from_crate(crate, default_name),\n+        pages: [\n+            doc::cratepage({\n+                topmod: top_moddoc_from_crate(crate, default_name),\n+            })\n+        ]\n     }\n }\n \n@@ -145,7 +149,7 @@ fn should_extract_fn_args() {\n     let source = \"fn a(b: int, c: int) { }\";\n     let ast = parse::from_str(source);\n     let doc = extract(ast, \"\");\n-    let fn_ = doc.topmod.fns()[0];\n+    let fn_ = doc.cratemod().fns()[0];\n     assert fn_.args[0].name == \"b\";\n     assert fn_.args[1].name == \"c\";\n }\n@@ -172,8 +176,8 @@ fn constdoc_from_const(itemdoc: doc::itemdoc) -> doc::constdoc {\n #[test]\n fn should_extract_const_name_and_id() {\n     let doc = test::mk_doc(\"const a: int = 0;\");\n-    assert doc.topmod.consts()[0].id() != 0;\n-    assert doc.topmod.consts()[0].name() == \"a\";\n+    assert doc.cratemod().consts()[0].id() != 0;\n+    assert doc.cratemod().consts()[0].name() == \"a\";\n }\n \n fn enumdoc_from_enum(\n@@ -203,14 +207,14 @@ fn variantdoc_from_variant(variant: ast::variant) -> doc::variantdoc {\n #[test]\n fn should_extract_enums() {\n     let doc = test::mk_doc(\"enum e { v }\");\n-    assert doc.topmod.enums()[0].id() != 0;\n-    assert doc.topmod.enums()[0].name() == \"e\";\n+    assert doc.cratemod().enums()[0].id() != 0;\n+    assert doc.cratemod().enums()[0].name() == \"e\";\n }\n \n #[test]\n fn should_extract_enum_variants() {\n     let doc = test::mk_doc(\"enum e { v }\");\n-    assert doc.topmod.enums()[0].variants[0].name == \"v\";\n+    assert doc.cratemod().enums()[0].variants[0].name == \"v\";\n }\n \n fn resdoc_from_resource(\n@@ -227,14 +231,14 @@ fn resdoc_from_resource(\n #[test]\n fn should_extract_resources() {\n     let doc = test::mk_doc(\"resource r(b: bool) { }\");\n-    assert doc.topmod.resources()[0].id() != 0;\n-    assert doc.topmod.resources()[0].name() == \"r\";\n+    assert doc.cratemod().resources()[0].id() != 0;\n+    assert doc.cratemod().resources()[0].name() == \"r\";\n }\n \n #[test]\n fn should_extract_resource_args() {\n     let doc = test::mk_doc(\"resource r(b: bool) { }\");\n-    assert doc.topmod.resources()[0].args[0].name == \"b\";\n+    assert doc.cratemod().resources()[0].args[0].name == \"b\";\n }\n \n fn ifacedoc_from_iface(\n@@ -263,19 +267,19 @@ fn ifacedoc_from_iface(\n #[test]\n fn should_extract_ifaces() {\n     let doc = test::mk_doc(\"iface i { fn f(); }\");\n-    assert doc.topmod.ifaces()[0].name() == \"i\";\n+    assert doc.cratemod().ifaces()[0].name() == \"i\";\n }\n \n #[test]\n fn should_extract_iface_methods() {\n     let doc = test::mk_doc(\"iface i { fn f(); }\");\n-    assert doc.topmod.ifaces()[0].methods[0].name == \"f\";\n+    assert doc.cratemod().ifaces()[0].methods[0].name == \"f\";\n }\n \n #[test]\n fn should_extract_iface_method_args() {\n     let doc = test::mk_doc(\"iface i { fn f(a: bool); }\");\n-    assert doc.topmod.ifaces()[0].methods[0].args[0].name == \"a\";\n+    assert doc.cratemod().ifaces()[0].methods[0].args[0].name == \"a\";\n }\n \n fn impldoc_from_impl(\n@@ -306,25 +310,25 @@ fn impldoc_from_impl(\n #[test]\n fn should_extract_impls_with_names() {\n     let doc = test::mk_doc(\"impl i for int { fn a() { } }\");\n-    assert doc.topmod.impls()[0].name() == \"i\";\n+    assert doc.cratemod().impls()[0].name() == \"i\";\n }\n \n #[test]\n fn should_extract_impls_without_names() {\n     let doc = test::mk_doc(\"impl of i for int { fn a() { } }\");\n-    assert doc.topmod.impls()[0].name() == \"i\";\n+    assert doc.cratemod().impls()[0].name() == \"i\";\n }\n \n #[test]\n fn should_extract_impl_methods() {\n     let doc = test::mk_doc(\"impl i for int { fn f() { } }\");\n-    assert doc.topmod.impls()[0].methods[0].name == \"f\";\n+    assert doc.cratemod().impls()[0].methods[0].name == \"f\";\n }\n \n #[test]\n fn should_extract_impl_method_args() {\n     let doc = test::mk_doc(\"impl i for int { fn f(a: bool) { } }\");\n-    assert doc.topmod.impls()[0].methods[0].args[0].name == \"a\";\n+    assert doc.cratemod().impls()[0].methods[0].args[0].name == \"a\";\n }\n \n fn tydoc_from_ty(\n@@ -339,85 +343,85 @@ fn tydoc_from_ty(\n #[test]\n fn should_extract_tys() {\n     let doc = test::mk_doc(\"type a = int;\");\n-    assert doc.topmod.types()[0].name() == \"a\";\n+    assert doc.cratemod().types()[0].name() == \"a\";\n }\n \n #[cfg(test)]\n mod test {\n \n-    fn mk_doc(source: str) -> doc::cratedoc {\n+    fn mk_doc(source: str) -> doc::doc {\n         let ast = parse::from_str(source);\n         extract(ast, \"\")\n     }\n \n     #[test]\n     fn extract_empty_crate() {\n         let doc = mk_doc(\"\");\n-        assert vec::is_empty(doc.topmod.mods());\n-        assert vec::is_empty(doc.topmod.fns());\n+        assert vec::is_empty(doc.cratemod().mods());\n+        assert vec::is_empty(doc.cratemod().fns());\n     }\n \n     #[test]\n     fn extract_mods() {\n         let doc = mk_doc(\"mod a { mod b { } mod c { } }\");\n-        assert doc.topmod.mods()[0].name() == \"a\";\n-        assert doc.topmod.mods()[0].mods()[0].name() == \"b\";\n-        assert doc.topmod.mods()[0].mods()[1].name() == \"c\";\n+        assert doc.cratemod().mods()[0].name() == \"a\";\n+        assert doc.cratemod().mods()[0].mods()[0].name() == \"b\";\n+        assert doc.cratemod().mods()[0].mods()[1].name() == \"c\";\n     }\n \n     #[test]\n     fn extract_native_mods() {\n         let doc = mk_doc(\"native mod a { }\");\n-        assert doc.topmod.nmods()[0].name() == \"a\";\n+        assert doc.cratemod().nmods()[0].name() == \"a\";\n     }\n \n     #[test]\n     fn extract_fns_from_native_mods() {\n         let doc = mk_doc(\"native mod a { fn a(); }\");\n-        assert doc.topmod.nmods()[0].fns[0].name() == \"a\";\n+        assert doc.cratemod().nmods()[0].fns[0].name() == \"a\";\n     }\n \n     #[test]\n     fn extract_mods_deep() {\n         let doc = mk_doc(\"mod a { mod b { mod c { } } }\");\n-        assert doc.topmod.mods()[0].mods()[0].mods()[0].name() == \"c\";\n+        assert doc.cratemod().mods()[0].mods()[0].mods()[0].name() == \"c\";\n     }\n \n     #[test]\n     fn extract_should_set_mod_ast_id() {\n         let doc = mk_doc(\"mod a { }\");\n-        assert doc.topmod.mods()[0].id() != 0;\n+        assert doc.cratemod().mods()[0].id() != 0;\n     }\n \n     #[test]\n     fn extract_fns() {\n         let doc = mk_doc(\n             \"fn a() { } \\\n              mod b { fn c() { } }\");\n-        assert doc.topmod.fns()[0].name() == \"a\";\n-        assert doc.topmod.mods()[0].fns()[0].name() == \"c\";\n+        assert doc.cratemod().fns()[0].name() == \"a\";\n+        assert doc.cratemod().mods()[0].fns()[0].name() == \"c\";\n     }\n \n     #[test]\n     fn extract_should_set_fn_ast_id() {\n         let doc = mk_doc(\"fn a() { }\");\n-        assert doc.topmod.fns()[0].id() != 0;\n+        assert doc.cratemod().fns()[0].id() != 0;\n     }\n \n     #[test]\n     fn extract_should_use_default_crate_name() {\n         let source = \"\";\n         let ast = parse::from_str(source);\n         let doc = extract(ast, \"burp\");\n-        assert doc.topmod.name() == \"burp\";\n+        assert doc.cratemod().name() == \"burp\";\n     }\n \n     #[test]\n     fn extract_from_seq_srv() {\n         let source = \"\";\n         astsrv::from_str(source) {|srv|\n             let doc = from_srv(srv, \"name\");\n-            assert doc.topmod.name() == \"name\";\n+            assert doc.cratemod().name() == \"name\";\n         }\n     }\n }\n\\ No newline at end of file"}, {"sha": "87b9d85637c369bd22150fa9e41fb49c3cbe9954", "filename": "src/rustdoc/fold.rs", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ffold.rs?ref=f8742b476f136e002627c68822d207315d9c9558", "patch": "@@ -1,5 +1,6 @@\n export fold;\n export default_seq_fold;\n+export default_seq_fold_doc;\n export default_seq_fold_crate;\n export default_seq_fold_item;\n export default_seq_fold_mod;\n@@ -20,6 +21,7 @@ export default_any_fold_nmod;\n \n enum fold<T> = t<T>;\n \n+type fold_doc<T> = fn~(fold: fold<T>, doc: doc::doc) -> doc::doc;\n type fold_crate<T> = fn~(fold: fold<T>, doc: doc::cratedoc) -> doc::cratedoc;\n type fold_item<T> = fn~(fold: fold<T>, doc: doc::itemdoc) -> doc::itemdoc;\n type fold_mod<T> = fn~(fold: fold<T>, doc: doc::moddoc) -> doc::moddoc;\n@@ -34,6 +36,7 @@ type fold_type<T> = fn~(fold: fold<T>, doc: doc::tydoc) -> doc::tydoc;\n \n type t<T> = {\n     ctxt: T,\n+    fold_doc: fold_doc<T>,\n     fold_crate: fold_crate<T>,\n     fold_item: fold_item<T>,\n     fold_mod: fold_mod<T>,\n@@ -52,6 +55,7 @@ type t<T> = {\n // initializers, but they do as function arguments\n fn mk_fold<T:copy>(\n     ctxt: T,\n+    fold_doc: fold_doc<T>,\n     fold_crate: fold_crate<T>,\n     fold_item: fold_item<T>,\n     fold_mod: fold_mod<T>,\n@@ -66,6 +70,7 @@ fn mk_fold<T:copy>(\n ) -> fold<T> {\n     fold({\n         ctxt: ctxt,\n+        fold_doc: fold_doc,\n         fold_crate: fold_crate,\n         fold_item: fold_item,\n         fold_mod: fold_mod,\n@@ -83,6 +88,7 @@ fn mk_fold<T:copy>(\n fn default_any_fold<T:send>(ctxt: T) -> fold<T> {\n     mk_fold(\n         ctxt,\n+        {|f, d| default_seq_fold_doc(f, d)},\n         {|f, d| default_seq_fold_crate(f, d)},\n         {|f, d| default_seq_fold_item(f, d)},\n         {|f, d| default_any_fold_mod(f, d)},\n@@ -100,6 +106,7 @@ fn default_any_fold<T:send>(ctxt: T) -> fold<T> {\n fn default_seq_fold<T:copy>(ctxt: T) -> fold<T> {\n     mk_fold(\n         ctxt,\n+        {|f, d| default_seq_fold_doc(f, d)},\n         {|f, d| default_seq_fold_crate(f, d)},\n         {|f, d| default_seq_fold_item(f, d)},\n         {|f, d| default_seq_fold_mod(f, d)},\n@@ -117,6 +124,7 @@ fn default_seq_fold<T:copy>(ctxt: T) -> fold<T> {\n fn default_par_fold<T:send>(ctxt: T) -> fold<T> {\n     mk_fold(\n         ctxt,\n+        {|f, d| default_seq_fold_doc(f, d)},\n         {|f, d| default_seq_fold_crate(f, d)},\n         {|f, d| default_seq_fold_item(f, d)},\n         {|f, d| default_par_fold_mod(f, d)},\n@@ -131,6 +139,22 @@ fn default_par_fold<T:send>(ctxt: T) -> fold<T> {\n     )\n }\n \n+fn default_seq_fold_doc<T>(fold: fold<T>, doc: doc::doc) -> doc::doc {\n+    {\n+        pages: par::seqmap(doc.pages) {|page|\n+            alt page {\n+              doc::cratepage(doc) {\n+                doc::cratepage(fold.fold_crate(fold, doc))\n+              }\n+              doc::itempage(doc) {\n+                doc::itempage(fold_itemtag(fold, doc))\n+              }\n+            }\n+        }\n+        with doc\n+    }\n+}\n+\n fn default_seq_fold_crate<T>(\n     fold: fold<T>,\n     doc: doc::cratedoc\n@@ -333,7 +357,7 @@ fn default_fold_should_produce_same_doc() {\n     let ast = parse::from_str(source);\n     let doc = extract::extract(ast, \"\");\n     let fld = default_seq_fold(());\n-    let folded = fld.fold_crate(fld, doc);\n+    let folded = fld.fold_doc(fld, doc);\n     assert doc == folded;\n }\n \n@@ -343,7 +367,7 @@ fn default_fold_should_produce_same_consts() {\n     let ast = parse::from_str(source);\n     let doc = extract::extract(ast, \"\");\n     let fld = default_seq_fold(());\n-    let folded = fld.fold_crate(fld, doc);\n+    let folded = fld.fold_doc(fld, doc);\n     assert doc == folded;\n }\n \n@@ -353,7 +377,7 @@ fn default_fold_should_produce_same_enums() {\n     let ast = parse::from_str(source);\n     let doc = extract::extract(ast, \"\");\n     let fld = default_seq_fold(());\n-    let folded = fld.fold_crate(fld, doc);\n+    let folded = fld.fold_doc(fld, doc);\n     assert doc == folded;\n }\n \n@@ -363,6 +387,6 @@ fn default_parallel_fold_should_produce_same_doc() {\n     let ast = parse::from_str(source);\n     let doc = extract::extract(ast, \"\");\n     let fld = default_par_fold(());\n-    let folded = fld.fold_crate(fld, doc);\n+    let folded = fld.fold_doc(fld, doc);\n     assert doc == folded;\n }"}, {"sha": "09bc8fd0eae6c05b4159b49d6a54a1022e657fe9", "filename": "src/rustdoc/markdown_index_pass.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_index_pass.rs?ref=f8742b476f136e002627c68822d207315d9c9558", "patch": "@@ -9,12 +9,12 @@ fn mk_pass() -> pass {\n     }\n }\n \n-fn run(_srv: astsrv::srv, doc: doc::cratedoc) -> doc::cratedoc {\n+fn run(_srv: astsrv::srv, doc: doc::doc) -> doc::doc {\n     let fold = fold::fold({\n         fold_mod: fold_mod\n             with *fold::default_any_fold(())\n     });\n-    fold.fold_crate(fold, doc)\n+    fold.fold_doc(fold, doc)\n }\n \n fn fold_mod(fold: fold::fold<()>, doc: doc::moddoc) -> doc::moddoc {\n@@ -68,12 +68,12 @@ fn pandoc_header_id(header: str) -> str {\n #[test]\n fn should_index_mod_contents() {\n     let doc = test::mk_doc(\"mod a { } fn b() { }\");\n-    assert option::get(doc.topmod.index).entries[0] == {\n+    assert option::get(doc.cratemod().index).entries[0] == {\n         kind: \"Module\",\n         name: \"a\",\n         link: \"module-a\"\n     };\n-    assert option::get(doc.topmod.index).entries[1] == {\n+    assert option::get(doc.cratemod().index).entries[1] == {\n         kind: \"Function\",\n         name: \"b\",\n         link: \"function-b\"\n@@ -82,7 +82,7 @@ fn should_index_mod_contents() {\n \n #[cfg(test)]\n mod test {\n-    fn mk_doc(source: str) -> doc::cratedoc {\n+    fn mk_doc(source: str) -> doc::doc {\n         astsrv::from_str(source) {|srv|\n             let doc = extract::from_srv(srv, \"\");\n             let doc = path_pass::mk_pass().f(srv, doc);"}, {"sha": "dcf81442620867470cacc06b60b1529f33379b50", "filename": "src/rustdoc/markdown_pass.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_pass.rs?ref=f8742b476f136e002627c68822d207315d9c9558", "patch": "@@ -17,7 +17,7 @@ fn mk_pass_(\n     config: config::config,\n     writer: writer\n ) -> pass {\n-    let f = fn~(srv: astsrv::srv, doc: doc::cratedoc) -> doc::cratedoc {\n+    let f = fn~(srv: astsrv::srv, doc: doc::doc) -> doc::doc {\n         run(srv, doc, config, writer)\n     };\n \n@@ -29,10 +29,10 @@ fn mk_pass_(\n \n fn run(\n     srv: astsrv::srv,\n-    doc: doc::cratedoc,\n+    doc: doc::doc,\n     _config: config::config,\n     writer: writer\n-) -> doc::cratedoc {\n+) -> doc::doc {\n \n     fn mods_last(item1: doc::itemtag, item2: doc::itemtag) -> bool {\n         fn is_mod(item: doc::itemtag) -> bool {\n@@ -89,14 +89,14 @@ type ctxt = {\n };\n \n fn write_markdown(\n-    doc: doc::cratedoc,\n+    doc: doc::doc,\n     writer: writer\n ) {\n     let ctxt = {\n         w: writer\n     };\n \n-    write_crate(ctxt, doc);\n+    write_crate(ctxt, doc.cratedoc());\n     ctxt.w.write_done();\n }\n \n@@ -378,14 +378,18 @@ fn should_insert_blank_line_after_fn_signature() {\n fn should_correctly_indent_fn_signature() {\n     let doc = test::create_doc(\"fn a() { }\");\n     let doc = {\n-        topmod: {\n-            items: [doc::fntag({\n-                sig: some(\"line 1\\nline 2\")\n-                with doc.topmod.fns()[0]\n-            })]\n-            with doc.topmod\n-        }\n-        with doc\n+        pages: [\n+            doc::cratepage({\n+                topmod: {\n+                    items: [doc::fntag({\n+                        sig: some(\"line 1\\nline 2\")\n+                        with doc.cratemod().fns()[0]\n+                    })]\n+                    with doc.cratemod()\n+                }\n+                with doc.cratedoc()\n+            })\n+        ]\n     };\n     let markdown = test::write_markdown_str(doc);\n     assert str::contains(markdown, \"    line 1\\n    line 2\");\n@@ -927,7 +931,7 @@ mod test {\n         markdown\n     }\n \n-    fn create_doc_srv(source: str) -> (astsrv::srv, doc::cratedoc) {\n+    fn create_doc_srv(source: str) -> (astsrv::srv, doc::doc) {\n         astsrv::from_str(source) {|srv|\n             let doc = extract::from_srv(srv, \"\");\n             #debug(\"doc (extract): %?\", doc);\n@@ -943,13 +947,13 @@ mod test {\n         }\n     }\n \n-    fn create_doc(source: str) -> doc::cratedoc {\n+    fn create_doc(source: str) -> doc::doc {\n         let (_, doc) = create_doc_srv(source);\n         doc\n     }\n \n     fn write_markdown_str(\n-        doc: doc::cratedoc\n+        doc: doc::doc\n     ) -> str {\n         let (writer, future) = markdown_writer::future_writer();\n         write_markdown(doc, writer);\n@@ -958,7 +962,7 @@ mod test {\n \n     fn write_markdown_str_srv(\n         srv: astsrv::srv,\n-        doc: doc::cratedoc\n+        doc: doc::doc\n     ) -> str {\n         let config = {\n             output_style: config::doc_per_crate"}, {"sha": "9aa8877482206fc5fcb3816f32874f171a082a77", "filename": "src/rustdoc/path_pass.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Fpath_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Fpath_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fpath_pass.rs?ref=f8742b476f136e002627c68822d207315d9c9558", "patch": "@@ -14,7 +14,7 @@ type ctxt = {\n     mutable path: [str]\n };\n \n-fn run(srv: astsrv::srv, doc: doc::cratedoc) -> doc::cratedoc {\n+fn run(srv: astsrv::srv, doc: doc::doc) -> doc::doc {\n     let ctxt = {\n         srv: srv,\n         mutable path: []\n@@ -25,7 +25,7 @@ fn run(srv: astsrv::srv, doc: doc::cratedoc) -> doc::cratedoc {\n         fold_nmod: fold_nmod\n         with *fold::default_any_fold(ctxt)\n     });\n-    fold.fold_crate(fold, doc)\n+    fold.fold_doc(fold, doc)\n }\n \n fn fold_item(fold: fold::fold<ctxt>, doc: doc::itemdoc) -> doc::itemdoc {\n@@ -65,8 +65,10 @@ fn should_record_mod_paths() {\n     astsrv::from_str(source) {|srv|\n         let doc = extract::from_srv(srv, \"\");\n         let doc = run(srv, doc);\n-        assert doc.topmod.mods()[0].mods()[0].mods()[0].path() == [\"a\", \"b\"];\n-        assert doc.topmod.mods()[0].mods()[1].mods()[0].path() == [\"a\", \"d\"];\n+        assert doc.cratemod().mods()[0].mods()[0].mods()[0].path()\n+            == [\"a\", \"b\"];\n+        assert doc.cratemod().mods()[0].mods()[1].mods()[0].path()\n+            == [\"a\", \"d\"];\n     }\n }\n \n@@ -76,7 +78,7 @@ fn should_record_fn_paths() {\n     astsrv::from_str(source) {|srv|\n         let doc = extract::from_srv(srv, \"\");\n         let doc = run(srv, doc);\n-        assert doc.topmod.mods()[0].fns()[0].path() == [\"a\"];\n+        assert doc.cratemod().mods()[0].fns()[0].path() == [\"a\"];\n     }\n }\n \n@@ -86,7 +88,7 @@ fn should_record_native_mod_paths() {\n     astsrv::from_str(source) {|srv|\n         let doc = extract::from_srv(srv, \"\");\n         let doc = run(srv, doc);\n-        assert doc.topmod.mods()[0].nmods()[0].path() == [\"a\"];\n+        assert doc.cratemod().mods()[0].nmods()[0].path() == [\"a\"];\n     }\n }\n \n@@ -96,6 +98,6 @@ fn should_record_native_fn_paths() {\n     astsrv::from_str(source) {|srv|\n         let doc = extract::from_srv(srv, \"\");\n         let doc = run(srv, doc);\n-        assert doc.topmod.nmods()[0].fns[0].path() == [\"a\"];\n+        assert doc.cratemod().nmods()[0].fns[0].path() == [\"a\"];\n     }\n }\n\\ No newline at end of file"}, {"sha": "24855db7872408c93fb51978c7d1554a4f2969c3", "filename": "src/rustdoc/prune_undoc_details_pass.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Fprune_undoc_details_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Fprune_undoc_details_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_undoc_details_pass.rs?ref=f8742b476f136e002627c68822d207315d9c9558", "patch": "@@ -12,16 +12,16 @@ fn mk_pass() -> pass {\n \n fn run(\n     _srv: astsrv::srv,\n-    doc: doc::cratedoc\n-) -> doc::cratedoc {\n+    doc: doc::doc\n+) -> doc::doc {\n     let fold = fold::fold({\n         fold_fn: fold_fn,\n         fold_res: fold_res,\n         fold_iface: fold_iface,\n         fold_impl: fold_impl\n         with *fold::default_any_fold(())\n     });\n-    fold.fold_crate(fold, doc)\n+    fold.fold_doc(fold, doc)\n }\n \n fn fold_fn(\n@@ -61,7 +61,7 @@ fn prune_return(doc: doc::retdoc) -> doc::retdoc {\n #[test]\n fn should_elide_undocumented_arguments() {\n     let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] fn a(b: int) { }\");\n-    assert vec::is_empty(doc.topmod.fns()[0].args);\n+    assert vec::is_empty(doc.cratemod().fns()[0].args);\n }\n \n #[test]\n@@ -72,7 +72,7 @@ fn should_elide_undocumented_return_values() {\n         let doc = tystr_pass::mk_pass().f(srv, doc);\n         let doc = attr_pass::mk_pass().f(srv, doc);\n         let doc = run(srv, doc);\n-        assert doc.topmod.fns()[0].return.ty == none;\n+        assert doc.cratemod().fns()[0].return.ty == none;\n     }\n }\n \n@@ -92,7 +92,7 @@ fn fold_res(\n fn should_elide_undocumented_resource_args() {\n     let doc = test::mk_doc(\"#[doc = \\\"drunk\\\"]\\\n                             resource r(a: bool) { }\");\n-    assert vec::is_empty(doc.topmod.resources()[0].args);\n+    assert vec::is_empty(doc.cratemod().resources()[0].args);\n }\n \n fn fold_iface(\n@@ -120,13 +120,13 @@ fn prune_methods(docs: [doc::methoddoc]) -> [doc::methoddoc] {\n #[test]\n fn should_elide_undocumented_iface_method_args() {\n     let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] iface i { fn a(); }\");\n-    assert vec::is_empty(doc.topmod.ifaces()[0].methods[0].args);\n+    assert vec::is_empty(doc.cratemod().ifaces()[0].methods[0].args);\n }\n \n #[test]\n fn should_elide_undocumented_iface_method_return_values() {\n     let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] iface i { fn a() -> int; }\");\n-    assert doc.topmod.ifaces()[0].methods[0].return.ty == none;\n+    assert doc.cratemod().ifaces()[0].methods[0].return.ty == none;\n }\n \n fn fold_impl(\n@@ -145,19 +145,19 @@ fn fold_impl(\n fn should_elide_undocumented_impl_method_args() {\n     let doc = test::mk_doc(\n         \"#[doc = \\\"hey\\\"] impl i for int { fn a(b: bool) { } }\");\n-    assert vec::is_empty(doc.topmod.impls()[0].methods[0].args);\n+    assert vec::is_empty(doc.cratemod().impls()[0].methods[0].args);\n }\n \n #[test]\n fn should_elide_undocumented_impl_method_return_values() {\n     let doc = test::mk_doc(\n         \"#[doc = \\\"hey\\\"] impl i for int { fn a() -> int { } }\");\n-    assert doc.topmod.impls()[0].methods[0].return.ty == none;\n+    assert doc.cratemod().impls()[0].methods[0].return.ty == none;\n }\n \n #[cfg(test)]\n mod test {\n-    fn mk_doc(source: str) -> doc::cratedoc {\n+    fn mk_doc(source: str) -> doc::doc {\n         astsrv::from_str(source) {|srv|\n             let doc = extract::from_srv(srv, \"\");\n             let doc = attr_pass::mk_pass().f(srv, doc);"}, {"sha": "ca7287cb8fc5bcd539225a58f11f156b47be4230", "filename": "src/rustdoc/prune_undoc_items_pass.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Fprune_undoc_items_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Fprune_undoc_items_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_undoc_items_pass.rs?ref=f8742b476f136e002627c68822d207315d9c9558", "patch": "@@ -15,8 +15,8 @@ type ctxt = {\n \n fn run(\n     _srv: astsrv::srv,\n-    doc: doc::cratedoc\n-) -> doc::cratedoc {\n+    doc: doc::doc\n+) -> doc::doc {\n     let ctxt = {\n         mutable have_docs: true\n     };\n@@ -31,7 +31,7 @@ fn run(\n         fold_type: fold_type\n         with *fold::default_any_fold(ctxt)\n     });\n-    fold.fold_crate(fold, doc)\n+    fold.fold_doc(fold, doc)\n }\n \n fn fold_mod(\n@@ -141,43 +141,43 @@ fn args_have_docs(docs: [doc::argdoc]) -> bool {\n #[test]\n fn should_elide_fns_with_undocumented_arguments() {\n     let doc = test::mk_doc(\"fn a(a: int) { }\");\n-    assert vec::is_empty(doc.topmod.fns());\n+    assert vec::is_empty(doc.cratemod().fns());\n }\n \n #[test]\n fn should_not_elide_fns_with_documented_arguments() {\n     let doc = test::mk_doc(\"#[doc(args(a = \\\"b\\\"))] fn a(a: int) { }\");\n-    assert vec::is_not_empty(doc.topmod.fns());\n+    assert vec::is_not_empty(doc.cratemod().fns());\n }\n \n #[test]\n fn should_not_elide_fns_with_documented_failure_conditions() {\n     let doc = test::mk_doc(\"#[doc(failure = \\\"yup\\\")] fn a() { }\");\n-    assert vec::is_not_empty(doc.topmod.fns());\n+    assert vec::is_not_empty(doc.cratemod().fns());\n }\n \n #[test]\n fn should_elide_undocumented_mods() {\n     let doc = test::mk_doc(\"mod a { }\");\n-    assert vec::is_empty(doc.topmod.mods());\n+    assert vec::is_empty(doc.cratemod().mods());\n }\n \n #[test]\n fn should_not_elide_undocument_mods_with_documented_mods() {\n     let doc = test::mk_doc(\"mod a { #[doc = \\\"b\\\"] mod b { } }\");\n-    assert vec::is_not_empty(doc.topmod.mods());\n+    assert vec::is_not_empty(doc.cratemod().mods());\n }\n \n #[test]\n fn should_not_elide_undocument_mods_with_documented_fns() {\n     let doc = test::mk_doc(\"mod a { #[doc = \\\"b\\\"] fn b() { } }\");\n-    assert vec::is_not_empty(doc.topmod.mods());\n+    assert vec::is_not_empty(doc.cratemod().mods());\n }\n \n #[test]\n fn should_elide_undocumented_fns() {\n     let doc = test::mk_doc(\"fn a() { }\");\n-    assert vec::is_empty(doc.topmod.fns());\n+    assert vec::is_empty(doc.cratemod().fns());\n }\n \n fn fold_const(\n@@ -194,7 +194,7 @@ fn fold_const(\n #[test]\n fn should_elide_undocumented_consts() {\n     let doc = test::mk_doc(\"const a: bool = true;\");\n-    assert vec::is_empty(doc.topmod.consts());\n+    assert vec::is_empty(doc.cratemod().consts());\n }\n \n fn fold_enum(fold: fold::fold<ctxt>, doc: doc::enumdoc) -> doc::enumdoc {\n@@ -218,19 +218,19 @@ fn fold_enum(fold: fold::fold<ctxt>, doc: doc::enumdoc) -> doc::enumdoc {\n #[test]\n fn should_elide_undocumented_enums() {\n     let doc = test::mk_doc(\"enum a { b }\");\n-    assert vec::is_empty(doc.topmod.enums());\n+    assert vec::is_empty(doc.cratemod().enums());\n }\n \n #[test]\n fn should_elide_undocumented_variants() {\n     let doc = test::mk_doc(\"#[doc = \\\"a\\\"] enum a { b }\");\n-    assert vec::is_empty(doc.topmod.enums()[0].variants);\n+    assert vec::is_empty(doc.cratemod().enums()[0].variants);\n }\n \n #[test]\n fn should_not_elide_enums_with_documented_variants() {\n     let doc = test::mk_doc(\"enum a { #[doc = \\\"a\\\"] b }\");\n-    assert vec::is_not_empty(doc.topmod.enums());\n+    assert vec::is_not_empty(doc.cratemod().enums());\n }\n \n fn fold_res(fold: fold::fold<ctxt>, doc: doc::resdoc) -> doc::resdoc {\n@@ -246,14 +246,14 @@ fn fold_res(fold: fold::fold<ctxt>, doc: doc::resdoc) -> doc::resdoc {\n #[test]\n fn should_elide_undocumented_resources() {\n     let doc = test::mk_doc(\"resource r(a: bool) { }\");\n-    assert vec::is_empty(doc.topmod.resources());\n+    assert vec::is_empty(doc.cratemod().resources());\n }\n \n #[test]\n fn should_not_elide_resources_with_documented_args() {\n     let doc = test::mk_doc(\"#[doc(args(a = \\\"drunk\\\"))]\\\n                             resource r(a: bool) { }\");\n-    assert vec::is_not_empty(doc.topmod.resources());\n+    assert vec::is_not_empty(doc.cratemod().resources());\n }\n \n fn fold_iface(\n@@ -283,31 +283,31 @@ fn methods_have_docs(docs: [doc::methoddoc]) -> bool {\n #[test]\n fn should_elide_undocumented_ifaces() {\n     let doc = test::mk_doc(\"iface i { fn a(); }\");\n-    assert vec::is_empty(doc.topmod.ifaces());\n+    assert vec::is_empty(doc.cratemod().ifaces());\n }\n \n #[test]\n fn should_not_elide_documented_ifaces() {\n     let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] iface i { fn a(); }\");\n-    assert vec::is_not_empty(doc.topmod.ifaces());\n+    assert vec::is_not_empty(doc.cratemod().ifaces());\n }\n \n #[test]\n fn should_elide_ifaces_with_undocumented_args() {\n     let doc = test::mk_doc(\"iface i { fn a(b: bool); }\");\n-    assert vec::is_empty(doc.topmod.ifaces());\n+    assert vec::is_empty(doc.cratemod().ifaces());\n }\n \n #[test]\n fn should_not_elide_ifaces_with_documented_methods() {\n     let doc = test::mk_doc(\"iface i { #[doc = \\\"hey\\\"] fn a(); }\");\n-    assert vec::is_not_empty(doc.topmod.ifaces());\n+    assert vec::is_not_empty(doc.cratemod().ifaces());\n }\n \n #[test]\n fn should_not_elide_undocumented_iface_methods() {\n     let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] iface i { fn a(); }\");\n-    assert vec::is_not_empty(doc.topmod.ifaces()[0].methods);\n+    assert vec::is_not_empty(doc.cratemod().ifaces()[0].methods);\n }\n \n fn fold_impl(\n@@ -326,25 +326,25 @@ fn fold_impl(\n #[test]\n fn should_elide_undocumented_impls() {\n     let doc = test::mk_doc(\"impl i for int { fn a() { } }\");\n-    assert vec::is_empty(doc.topmod.impls());\n+    assert vec::is_empty(doc.cratemod().impls());\n }\n \n #[test]\n fn should_not_elide_documented_impls() {\n     let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] impl i for int { fn a() { } }\");\n-    assert vec::is_not_empty(doc.topmod.impls());\n+    assert vec::is_not_empty(doc.cratemod().impls());\n }\n \n #[test]\n fn should_not_elide_impls_with_documented_methods() {\n     let doc = test::mk_doc(\"impl i for int { #[doc = \\\"hey\\\"] fn a() { } }\");\n-    assert vec::is_not_empty(doc.topmod.impls());\n+    assert vec::is_not_empty(doc.cratemod().impls());\n }\n \n #[test]\n fn should_not_elide_undocumented_impl_methods() {\n     let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] impl i for int { fn a() { } }\");\n-    assert vec::is_not_empty(doc.topmod.impls()[0].methods);\n+    assert vec::is_not_empty(doc.cratemod().impls()[0].methods);\n }\n \n fn fold_type(\n@@ -362,12 +362,12 @@ fn fold_type(\n #[test]\n fn should_elide_undocumented_types() {\n     let doc = test::mk_doc(\"type t = int;\");\n-    assert vec::is_empty(doc.topmod.types());\n+    assert vec::is_empty(doc.cratemod().types());\n }\n \n #[cfg(test)]\n mod test {\n-    fn mk_doc(source: str) -> doc::cratedoc {\n+    fn mk_doc(source: str) -> doc::doc {\n         astsrv::from_str(source) {|srv|\n             let doc = extract::from_srv(srv, \"\");\n             let doc = attr_pass::mk_pass().f(srv, doc);"}, {"sha": "fcd24bebbb4a84bcddbc9a922d2fa6c4863f73fa", "filename": "src/rustdoc/prune_unexported_pass.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Fprune_unexported_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Fprune_unexported_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_unexported_pass.rs?ref=f8742b476f136e002627c68822d207315d9c9558", "patch": "@@ -13,12 +13,12 @@ fn mk_pass() -> pass {\n     }\n }\n \n-fn run(srv: astsrv::srv, doc: doc::cratedoc) -> doc::cratedoc {\n+fn run(srv: astsrv::srv, doc: doc::doc) -> doc::doc {\n     let fold = fold::fold({\n         fold_mod: fold_mod\n         with *fold::default_any_fold(srv)\n     });\n-    fold.fold_crate(fold, doc)\n+    fold.fold_doc(fold, doc)\n }\n \n fn fold_mod(fold: fold::fold<astsrv::srv>, doc: doc::moddoc) -> doc::moddoc {\n@@ -137,25 +137,25 @@ fn is_exported_from_crate(\n #[test]\n fn should_prune_unexported_fns() {\n     let doc = test::mk_doc(\"mod b { export a; fn a() { } fn b() { } }\");\n-    assert vec::len(doc.topmod.mods()[0].fns()) == 1u;\n+    assert vec::len(doc.cratemod().mods()[0].fns()) == 1u;\n }\n \n #[test]\n fn should_prune_unexported_fns_from_top_mod() {\n     let doc = test::mk_doc(\"export a; fn a() { } fn b() { }\");\n-    assert vec::len(doc.topmod.fns()) == 1u;\n+    assert vec::len(doc.cratemod().fns()) == 1u;\n }\n \n #[test]\n fn should_prune_unexported_modules() {\n     let doc = test::mk_doc(\"mod a { export a; mod a { } mod b { } }\");\n-    assert vec::len(doc.topmod.mods()[0].mods()) == 1u;\n+    assert vec::len(doc.cratemod().mods()[0].mods()) == 1u;\n }\n \n #[test]\n fn should_prune_unexported_modules_from_top_mod() {\n     let doc = test::mk_doc(\"export a; mod a { } mod b { }\");\n-    assert vec::len(doc.topmod.mods()) == 1u;\n+    assert vec::len(doc.cratemod().mods()) == 1u;\n }\n \n #[test]\n@@ -164,75 +164,75 @@ fn should_prune_unexported_consts() {\n         \"mod a { export a; \\\n          const a: bool = true; \\\n          const b: bool = true; }\");\n-    assert vec::len(doc.topmod.mods()[0].consts()) == 1u;\n+    assert vec::len(doc.cratemod().mods()[0].consts()) == 1u;\n }\n \n #[test]\n fn should_prune_unexported_consts_from_top_mod() {\n     let doc = test::mk_doc(\n         \"export a; const a: bool = true; const b: bool = true;\");\n-    assert vec::len(doc.topmod.consts()) == 1u;\n+    assert vec::len(doc.cratemod().consts()) == 1u;\n }\n \n #[test]\n fn should_prune_unexported_enums_from_top_mod() {\n     let doc = test::mk_doc(\"export a; mod a { } enum b { c }\");\n-    assert vec::len(doc.topmod.enums()) == 0u;\n+    assert vec::len(doc.cratemod().enums()) == 0u;\n }\n \n #[test]\n fn should_prune_unexported_enums() {\n     let doc = test::mk_doc(\"mod a { export a; mod a { } enum b { c } }\");\n-    assert vec::len(doc.topmod.mods()[0].enums()) == 0u;\n+    assert vec::len(doc.cratemod().mods()[0].enums()) == 0u;\n }\n \n #[test]\n fn should_prune_unexported_variants_from_top_mod() {\n     let doc = test::mk_doc(\"export b::{}; enum b { c }\");\n-    assert vec::len(doc.topmod.enums()[0].variants) == 0u;\n+    assert vec::len(doc.cratemod().enums()[0].variants) == 0u;\n }\n \n #[test]\n fn should_prune_unexported_variants() {\n     let doc = test::mk_doc(\"mod a { export b::{}; enum b { c } }\");\n-    assert vec::len(doc.topmod.mods()[0].enums()[0].variants) == 0u;\n+    assert vec::len(doc.cratemod().mods()[0].enums()[0].variants) == 0u;\n }\n \n #[test]\n fn should_prune_unexported_resources_from_top_mod() {\n     let doc = test::mk_doc(\"export a; mod a { } resource r(a: bool) { }\");\n-    assert vec::is_empty(doc.topmod.resources());\n+    assert vec::is_empty(doc.cratemod().resources());\n }\n \n #[test]\n fn should_prune_unexported_resources() {\n     let doc = test::mk_doc(\n         \"mod a { export a; mod a { } resource r(a: bool) { } }\");\n-    assert vec::is_empty(doc.topmod.mods()[0].resources());\n+    assert vec::is_empty(doc.cratemod().mods()[0].resources());\n }\n \n #[test]\n fn should_prune_unexported_ifaces_from_top_mod() {\n     let doc = test::mk_doc(\"export a; mod a { } iface b { fn c(); }\");\n-    assert vec::is_empty(doc.topmod.ifaces());\n+    assert vec::is_empty(doc.cratemod().ifaces());\n }\n \n #[test]\n fn should_prune_unexported_impls_from_top_mod() {\n     let doc = test::mk_doc(\n         \"export a; mod a { } impl b for int { fn c() { } }\");\n-    assert vec::is_empty(doc.topmod.impls())\n+    assert vec::is_empty(doc.cratemod().impls())\n }\n \n #[test]\n fn should_prune_unexported_types() {\n     let doc = test::mk_doc(\"export a; mod a { } type b = int;\");\n-    assert vec::is_empty(doc.topmod.types());\n+    assert vec::is_empty(doc.cratemod().types());\n }\n \n #[test]\n fn should_not_prune_reexports() {\n-    fn mk_doc(source: str) -> doc::cratedoc {\n+    fn mk_doc(source: str) -> doc::doc {\n         astsrv::from_str(source) {|srv|\n             let doc = extract::from_srv(srv, \"\");\n             let doc = reexport_pass::mk_pass().f(srv, doc);\n@@ -242,12 +242,12 @@ fn should_not_prune_reexports() {\n     let doc = mk_doc(\"import a::b; \\\n                       export b; \\\n                       mod a { fn b() { } }\");\n-    assert vec::is_not_empty(doc.topmod.fns());\n+    assert vec::is_not_empty(doc.cratemod().fns());\n }\n \n #[cfg(test)]\n mod test {\n-    fn mk_doc(source: str) -> doc::cratedoc {\n+    fn mk_doc(source: str) -> doc::doc {\n         astsrv::from_str(source) {|srv|\n             let doc = extract::from_srv(srv, \"\");\n             run(srv, doc)"}, {"sha": "d5e61692719e5941c39b15607d5d342a457e6778", "filename": "src/rustdoc/reexport_pass.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Freexport_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Freexport_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Freexport_pass.rs?ref=f8742b476f136e002627c68822d207315d9c9558", "patch": "@@ -18,7 +18,7 @@ type def_set = map::set<ast::def_id>;\n type def_map = map::hashmap<ast::def_id, doc::itemtag>;\n type path_map = map::hashmap<str, [(str, doc::itemtag)]>;\n \n-fn run(srv: astsrv::srv, doc: doc::cratedoc) -> doc::cratedoc {\n+fn run(srv: astsrv::srv, doc: doc::doc) -> doc::doc {\n \n     // First gather the set of defs that are used as reexports\n     let def_set = build_reexport_def_set(srv);\n@@ -89,7 +89,7 @@ fn build_reexport_def_set(srv: astsrv::srv) -> def_set {\n \n fn build_reexport_def_map(\n     srv: astsrv::srv,\n-    doc: doc::cratedoc,\n+    doc: doc::doc,\n     def_set: def_set\n ) -> def_map {\n \n@@ -112,7 +112,7 @@ fn build_reexport_def_map(\n         with *fold::default_seq_fold(ctxt)\n     });\n \n-    fold.fold_crate(fold, doc);\n+    fold.fold_doc(fold, doc);\n \n     ret ctxt.def_map;\n \n@@ -190,16 +190,16 @@ fn build_reexport_path_map(srv: astsrv::srv, -def_map: def_map) -> path_map {\n }\n \n fn merge_reexports(\n-    doc: doc::cratedoc,\n+    doc: doc::doc,\n     path_map: path_map\n-) -> doc::cratedoc {\n+) -> doc::doc {\n \n     let fold = fold::fold({\n         fold_mod: fold_mod\n         with *fold::default_seq_fold(path_map)\n     });\n \n-    ret fold.fold_crate(fold, doc);\n+    ret fold.fold_doc(fold, doc);\n \n     fn fold_mod(fold: fold::fold<path_map>, doc: doc::moddoc) -> doc::moddoc {\n         let doc = fold::default_seq_fold_mod(fold, doc);\n@@ -304,23 +304,23 @@ fn should_duplicate_reexported_items() {\n     let source = \"mod a { export b; fn b() { } } \\\n                   mod c { import a::b; export b; }\";\n     let doc = test::mk_doc(source);\n-    assert doc.topmod.mods()[1].fns()[0].name() == \"b\";\n+    assert doc.cratemod().mods()[1].fns()[0].name() == \"b\";\n }\n \n #[test]\n fn should_mark_reepxorts_as_such() {\n     let source = \"mod a { export b; fn b() { } } \\\n                   mod c { import a::b; export b; }\";\n     let doc = test::mk_doc(source);\n-    assert doc.topmod.mods()[1].fns()[0].item.reexport == true;\n+    assert doc.cratemod().mods()[1].fns()[0].item.reexport == true;\n }\n \n #[test]\n fn should_duplicate_reexported_native_fns() {\n     let source = \"native mod a { fn b(); } \\\n                   mod c { import a::b; export b; }\";\n     let doc = test::mk_doc(source);\n-    assert doc.topmod.mods()[0].fns()[0].name() == \"b\";\n+    assert doc.cratemod().mods()[0].fns()[0].name() == \"b\";\n }\n \n #[test]\n@@ -339,8 +339,8 @@ fn should_duplicate_multiple_reexported_items() {\n         let doc = run(srv, doc);\n         // Reexports may not be in any specific order\n         let doc = sort_item_name_pass::mk_pass().f(srv, doc);\n-        assert doc.topmod.mods()[1].fns()[0].name() == \"b\";\n-        assert doc.topmod.mods()[1].fns()[1].name() == \"c\";\n+        assert doc.cratemod().mods()[1].fns()[0].name() == \"b\";\n+        assert doc.cratemod().mods()[1].fns()[1].name() == \"c\";\n     }\n }\n \n@@ -349,12 +349,12 @@ fn should_rename_items_reexported_with_different_names() {\n     let source = \"mod a { export b; fn b() { } } \\\n                   mod c { import x = a::b; export x; }\";\n     let doc = test::mk_doc(source);\n-    assert doc.topmod.mods()[1].fns()[0].name() == \"x\";\n+    assert doc.cratemod().mods()[1].fns()[0].name() == \"x\";\n }\n \n #[test]\n fn should_reexport_in_topmod() {\n-    fn mk_doc(source: str) -> doc::cratedoc {\n+    fn mk_doc(source: str) -> doc::doc {\n         astsrv::from_str(source) {|srv|\n             let doc = extract::from_srv(srv, \"core\");\n             let doc = path_pass::mk_pass().f(srv, doc);\n@@ -368,7 +368,7 @@ fn should_reexport_in_topmod() {\n                   enum t { some, none } \\\n                   }\";\n     let doc = mk_doc(source);\n-    assert doc.topmod.enums()[0].name() == \"option\";\n+    assert doc.cratemod().enums()[0].name() == \"option\";\n }\n \n #[test]\n@@ -380,12 +380,12 @@ fn should_not_reexport_multiple_times() {\n                   enum t { none, some } \\\n                   }\";\n     let doc = test::mk_doc(source);\n-    assert vec::len(doc.topmod.enums()) == 1u;\n+    assert vec::len(doc.cratemod().enums()) == 1u;\n }\n \n #[cfg(test)]\n mod test {\n-    fn mk_doc(source: str) -> doc::cratedoc {\n+    fn mk_doc(source: str) -> doc::doc {\n         astsrv::from_str(source) {|srv|\n             let doc = extract::from_srv(srv, \"\");\n             let doc = path_pass::mk_pass().f(srv, doc);"}, {"sha": "db83b5c2ca5a1b60704731cd987ed5352d22ae6a", "filename": "src/rustdoc/rustdoc.rs", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rs?ref=f8742b476f136e002627c68822d207315d9c9558", "patch": "@@ -9,14 +9,14 @@ import doc::util;\n #[doc = \"A single operation on the document model\"]\n type pass = {\n     name: str,\n-    f: fn~(srv: astsrv::srv, doc: doc::cratedoc) -> doc::cratedoc\n+    f: fn~(srv: astsrv::srv, doc: doc::doc) -> doc::doc\n };\n \n fn run_passes(\n     srv: astsrv::srv,\n-    doc: doc::cratedoc,\n+    doc: doc::doc,\n     passes: [pass]\n-) -> doc::cratedoc {\n+) -> doc::doc {\n \n     #[doc(\n         brief =\n@@ -49,32 +49,40 @@ fn run_passes(\n fn test_run_passes() {\n     fn pass1(\n         _srv: astsrv::srv,\n-        doc: doc::cratedoc\n-    ) -> doc::cratedoc {\n+        doc: doc::doc\n+    ) -> doc::doc {\n         {\n-            topmod: {\n-                item: {\n-                    name: doc.topmod.name() + \"two\"\n-                    with doc.topmod.item\n-                },\n-                items: [],\n-                index: none\n-            }\n+            pages: [\n+                doc::cratepage({\n+                    topmod: {\n+                        item: {\n+                            name: doc.cratemod().name() + \"two\"\n+                            with doc.cratemod().item\n+                        },\n+                        items: [],\n+                        index: none\n+                    }\n+                })\n+            ]\n         }\n     }\n     fn pass2(\n         _srv: astsrv::srv,\n-        doc: doc::cratedoc\n-    ) -> doc::cratedoc {\n+        doc: doc::doc\n+    ) -> doc::doc {\n         {\n-            topmod: {\n-                item: {\n-                    name: doc.topmod.name() + \"three\"\n-                    with doc.topmod.item\n-                },\n-                items: [],\n-                index: none\n-            }\n+            pages: [\n+                doc::cratepage({\n+                    topmod: {\n+                        item: {\n+                            name: doc.cratemod().name() + \"three\"\n+                            with doc.cratemod().item\n+                        },\n+                        items: [],\n+                        index: none\n+                    }\n+                })\n+            ]\n         }\n     }\n     let source = \"\";\n@@ -91,7 +99,7 @@ fn test_run_passes() {\n         ];\n         let doc = extract::from_srv(srv, \"one\");\n         let doc = run_passes(srv, doc, passes);\n-        assert doc.topmod.name() == \"onetwothree\";\n+        assert doc.cratemod().name() == \"onetwothree\";\n     }\n }\n "}, {"sha": "8ed03f56d23331d66e6339ddf3266feb9c3bf044", "filename": "src/rustdoc/sort_item_name_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Fsort_item_name_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Fsort_item_name_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsort_item_name_pass.rs?ref=f8742b476f136e002627c68822d207315d9c9558", "patch": "@@ -14,7 +14,7 @@ fn test() {\n     astsrv::from_str(source) {|srv|\n         let doc = extract::from_srv(srv, \"\");\n         let doc = mk_pass().f(srv, doc);\n-        assert doc.topmod.items[0].name() == \"y\";\n-        assert doc.topmod.items[1].name() == \"z\";\n+        assert doc.cratemod().items[0].name() == \"y\";\n+        assert doc.cratemod().items[1].name() == \"z\";\n     }\n }"}, {"sha": "a01c914b8a4d71cefb86ecb65697866952167b09", "filename": "src/rustdoc/sort_item_type_pass.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Fsort_item_type_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Fsort_item_type_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsort_item_type_pass.rs?ref=f8742b476f136e002627c68822d207315d9c9558", "patch": "@@ -37,14 +37,14 @@ fn test() {\n     astsrv::from_str(source) {|srv|\n         let doc = extract::from_srv(srv, \"\");\n         let doc = mk_pass().f(srv, doc);\n-        assert doc.topmod.items[0].name() == \"iconst\";\n-        assert doc.topmod.items[1].name() == \"itype\";\n-        assert doc.topmod.items[2].name() == \"ienum\";\n-        assert doc.topmod.items[3].name() == \"ires\";\n-        assert doc.topmod.items[4].name() == \"iiface\";\n-        assert doc.topmod.items[5].name() == \"iimpl\";\n-        assert doc.topmod.items[6].name() == \"ifn\";\n-        assert doc.topmod.items[7].name() == \"imod\";\n-        assert doc.topmod.items[8].name() == \"inmod\";\n+        assert doc.cratemod().items[0].name() == \"iconst\";\n+        assert doc.cratemod().items[1].name() == \"itype\";\n+        assert doc.cratemod().items[2].name() == \"ienum\";\n+        assert doc.cratemod().items[3].name() == \"ires\";\n+        assert doc.cratemod().items[4].name() == \"iiface\";\n+        assert doc.cratemod().items[5].name() == \"iimpl\";\n+        assert doc.cratemod().items[6].name() == \"ifn\";\n+        assert doc.cratemod().items[7].name() == \"imod\";\n+        assert doc.cratemod().items[8].name() == \"inmod\";\n     }\n }"}, {"sha": "53b9ca1fcfd9b029319b6a0397110d237bca31d4", "filename": "src/rustdoc/sort_pass.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Fsort_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Fsort_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsort_pass.rs?ref=f8742b476f136e002627c68822d207315d9c9558", "patch": "@@ -9,22 +9,22 @@ type item_lteq = fn~(doc::itemtag, doc::itemtag) -> bool;\n fn mk_pass(name: str, lteq: item_lteq) -> pass {\n     {\n         name: name,\n-        f: fn~(srv: astsrv::srv, doc: doc::cratedoc) -> doc::cratedoc {\n+        f: fn~(srv: astsrv::srv, doc: doc::doc) -> doc::doc {\n             run(srv, doc, lteq)\n         }\n     }\n }\n \n fn run(\n     _srv: astsrv::srv,\n-    doc: doc::cratedoc,\n+    doc: doc::doc,\n     lteq: item_lteq\n-) -> doc::cratedoc {\n+) -> doc::doc {\n     let fold = fold::fold({\n         fold_mod: fold_mod\n         with *fold::default_any_fold(lteq)\n     });\n-    fold.fold_crate(fold, doc)\n+    fold.fold_doc(fold, doc)\n }\n \n fn fold_mod(\n@@ -48,10 +48,10 @@ fn test() {\n     astsrv::from_str(source) {|srv|\n         let doc = extract::from_srv(srv, \"\");\n         let doc = mk_pass(\"\", name_lteq).f(srv, doc);\n-        assert doc.topmod.mods()[0].name() == \"w\";\n-        assert doc.topmod.mods()[1].items[0].name() == \"x\";\n-        assert doc.topmod.mods()[1].items[1].name() == \"y\";\n-        assert doc.topmod.mods()[1].name() == \"z\";\n+        assert doc.cratemod().mods()[0].name() == \"w\";\n+        assert doc.cratemod().mods()[1].items[0].name() == \"x\";\n+        assert doc.cratemod().mods()[1].items[1].name() == \"y\";\n+        assert doc.cratemod().mods()[1].name() == \"z\";\n     }\n }\n \n@@ -65,10 +65,10 @@ fn should_be_stable() {\n     astsrv::from_str(source) {|srv|\n         let doc = extract::from_srv(srv, \"\");\n         let doc = mk_pass(\"\", always_eq).f(srv, doc);\n-        assert doc.topmod.mods()[0].items[0].name() == \"b\";\n-        assert doc.topmod.mods()[1].items[0].name() == \"d\";\n+        assert doc.cratemod().mods()[0].items[0].name() == \"b\";\n+        assert doc.cratemod().mods()[1].items[0].name() == \"d\";\n         let doc = mk_pass(\"\", always_eq).f(srv, doc);\n-        assert doc.topmod.mods()[0].items[0].name() == \"b\";\n-        assert doc.topmod.mods()[1].items[0].name() == \"d\";\n+        assert doc.cratemod().mods()[0].items[0].name() == \"b\";\n+        assert doc.cratemod().mods()[1].items[0].name() == \"d\";\n     }\n }"}, {"sha": "d236821e6cb31da749580fe52681ec11447f4db4", "filename": "src/rustdoc/trim_pass.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Ftrim_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Ftrim_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftrim_pass.rs?ref=f8742b476f136e002627c68822d207315d9c9558", "patch": "@@ -18,49 +18,49 @@ fn should_trim_mod() {\n     let doc = test::mk_doc(\"#[doc(brief = \\\"\\nbrief\\n\\\", \\\n                             desc = \\\"\\ndesc\\n\\\")] \\\n                             mod m { }\");\n-    assert doc.topmod.mods()[0].brief() == some(\"brief\");\n-    assert doc.topmod.mods()[0].desc() == some(\"desc\");\n+    assert doc.cratemod().mods()[0].brief() == some(\"brief\");\n+    assert doc.cratemod().mods()[0].desc() == some(\"desc\");\n }\n \n #[test]\n fn should_trim_const() {\n     let doc = test::mk_doc(\"#[doc(brief = \\\"\\nbrief\\n\\\", \\\n                             desc = \\\"\\ndesc\\n\\\")] \\\n                             const a: bool = true;\");\n-    assert doc.topmod.consts()[0].brief() == some(\"brief\");\n-    assert doc.topmod.consts()[0].desc() == some(\"desc\");\n+    assert doc.cratemod().consts()[0].brief() == some(\"brief\");\n+    assert doc.cratemod().consts()[0].desc() == some(\"desc\");\n }\n \n #[test]\n fn should_trim_fn() {\n     let doc = test::mk_doc(\"#[doc(brief = \\\"\\nbrief\\n\\\", \\\n                             desc = \\\"\\ndesc\\n\\\")] \\\n                             fn a() { }\");\n-    assert doc.topmod.fns()[0].brief() == some(\"brief\");\n-    assert doc.topmod.fns()[0].desc() == some(\"desc\");\n+    assert doc.cratemod().fns()[0].brief() == some(\"brief\");\n+    assert doc.cratemod().fns()[0].desc() == some(\"desc\");\n }\n \n #[test]\n fn should_trim_args() {\n     let doc = test::mk_doc(\"#[doc(args(a = \\\"\\na\\n\\\"))] fn a(a: int) { }\");\n-    assert doc.topmod.fns()[0].args[0].desc == some(\"a\");\n+    assert doc.cratemod().fns()[0].args[0].desc == some(\"a\");\n }\n \n #[test]\n fn should_trim_ret() {\n     let doc = test::mk_doc(\"#[doc(return = \\\"\\na\\n\\\")] fn a() -> int { }\");\n-    assert doc.topmod.fns()[0].return.desc == some(\"a\");\n+    assert doc.cratemod().fns()[0].return.desc == some(\"a\");\n }\n \n #[test]\n fn should_trim_failure_conditions() {\n     let doc = test::mk_doc(\"#[doc(failure = \\\"\\na\\n\\\")] fn a() -> int { }\");\n-    assert doc.topmod.fns()[0].failure == some(\"a\");\n+    assert doc.cratemod().fns()[0].failure == some(\"a\");\n }\n \n #[cfg(test)]\n mod test {\n-    fn mk_doc(source: str) -> doc::cratedoc {\n+    fn mk_doc(source: str) -> doc::doc {\n         astsrv::from_str(source) {|srv|\n             let doc = extract::from_srv(srv, \"\");\n             let doc = attr_pass::mk_pass().f(srv, doc);"}, {"sha": "a7af2bb13bac284f1d5e4ded3cdc80de66dd09a9", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8742b476f136e002627c68822d207315d9c9558/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=f8742b476f136e002627c68822d207315d9c9558", "patch": "@@ -16,8 +16,8 @@ fn mk_pass() -> pass {\n \n fn run(\n     srv: astsrv::srv,\n-    doc: doc::cratedoc\n-) -> doc::cratedoc {\n+    doc: doc::doc\n+) -> doc::doc {\n     let fold = fold::fold({\n         fold_fn: fold_fn,\n         fold_const: fold_const,\n@@ -28,7 +28,7 @@ fn run(\n         fold_type: fold_type\n         with *fold::default_any_fold(srv)\n     });\n-    fold.fold_crate(fold, doc)\n+    fold.fold_doc(fold, doc)\n }\n \n fn fold_fn(\n@@ -66,13 +66,13 @@ fn get_fn_sig(srv: astsrv::srv, fn_id: doc::ast_id) -> option<str> {\n #[test]\n fn should_add_fn_sig() {\n     let doc = test::mk_doc(\"fn a() -> int { }\");\n-    assert doc.topmod.fns()[0].sig == some(\"fn a() -> int\");\n+    assert doc.cratemod().fns()[0].sig == some(\"fn a() -> int\");\n }\n \n #[test]\n fn should_add_native_fn_sig() {\n     let doc = test::mk_doc(\"native mod a { fn a() -> int; }\");\n-    assert doc.topmod.nmods()[0].fns[0].sig == some(\"fn a() -> int\");\n+    assert doc.cratemod().nmods()[0].fns[0].sig == some(\"fn a() -> int\");\n }\n \n fn merge_ret_ty(\n@@ -118,19 +118,19 @@ fn ret_ty_to_str(decl: ast::fn_decl) -> option<str> {\n #[test]\n fn should_add_fn_ret_types() {\n     let doc = test::mk_doc(\"fn a() -> int { }\");\n-    assert doc.topmod.fns()[0].return.ty == some(\"int\");\n+    assert doc.cratemod().fns()[0].return.ty == some(\"int\");\n }\n \n #[test]\n fn should_not_add_nil_ret_type() {\n     let doc = test::mk_doc(\"fn a() { }\");\n-    assert doc.topmod.fns()[0].return.ty == none;\n+    assert doc.cratemod().fns()[0].return.ty == none;\n }\n \n #[test]\n fn should_add_native_fn_ret_types() {\n     let doc = test::mk_doc(\"native mod a { fn a() -> int; }\");\n-    assert doc.topmod.nmods()[0].fns[0].return.ty == some(\"int\");\n+    assert doc.cratemod().nmods()[0].fns[0].return.ty == some(\"int\");\n }\n \n fn merge_arg_tys(\n@@ -176,15 +176,15 @@ fn decl_arg_tys(decl: ast::fn_decl) -> [(str, str)] {\n #[test]\n fn should_add_arg_types() {\n     let doc = test::mk_doc(\"fn a(b: int, c: bool) { }\");\n-    let fn_ = doc.topmod.fns()[0];\n+    let fn_ = doc.cratemod().fns()[0];\n     assert fn_.args[0].ty == some(\"int\");\n     assert fn_.args[1].ty == some(\"bool\");\n }\n \n #[test]\n fn should_add_native_fn_arg_types() {\n     let doc = test::mk_doc(\"native mod a { fn a(b: int); }\");\n-    assert doc.topmod.nmods()[0].fns[0].args[0].ty == some(\"int\");\n+    assert doc.cratemod().nmods()[0].fns[0].args[0].ty == some(\"int\");\n }\n \n fn fold_const(\n@@ -210,7 +210,7 @@ fn fold_const(\n #[test]\n fn should_add_const_types() {\n     let doc = test::mk_doc(\"const a: bool = true;\");\n-    assert doc.topmod.consts()[0].ty == some(\"bool\");\n+    assert doc.cratemod().consts()[0].ty == some(\"bool\");\n }\n \n fn fold_enum(\n@@ -249,7 +249,7 @@ fn fold_enum(\n #[test]\n fn should_add_variant_sigs() {\n     let doc = test::mk_doc(\"enum a { b(int) }\");\n-    assert doc.topmod.enums()[0].variants[0].sig == some(\"b(int)\");\n+    assert doc.cratemod().enums()[0].variants[0].sig == some(\"b(int)\");\n }\n \n fn fold_res(\n@@ -276,13 +276,13 @@ fn fold_res(\n #[test]\n fn should_add_resource_sigs() {\n     let doc = test::mk_doc(\"resource r(b: bool) { }\");\n-    assert doc.topmod.resources()[0].sig == some(\"resource r(b: bool)\");\n+    assert doc.cratemod().resources()[0].sig == some(\"resource r(b: bool)\");\n }\n \n #[test]\n fn should_add_resource_arg_tys() {\n     let doc = test::mk_doc(\"resource r(a: bool) { }\");\n-    assert doc.topmod.resources()[0].args[0].ty == some(\"bool\");\n+    assert doc.cratemod().resources()[0].args[0].ty == some(\"bool\");\n }\n \n fn fold_iface(\n@@ -457,25 +457,25 @@ fn get_method_arg_tys(\n #[test]\n fn should_add_iface_method_sigs() {\n     let doc = test::mk_doc(\"iface i { fn a() -> int; }\");\n-    assert doc.topmod.ifaces()[0].methods[0].sig == some(\"fn a() -> int\");\n+    assert doc.cratemod().ifaces()[0].methods[0].sig == some(\"fn a() -> int\");\n }\n \n #[test]\n fn should_add_iface_method_ret_types() {\n     let doc = test::mk_doc(\"iface i { fn a() -> int; }\");\n-    assert doc.topmod.ifaces()[0].methods[0].return.ty == some(\"int\");\n+    assert doc.cratemod().ifaces()[0].methods[0].return.ty == some(\"int\");\n }\n \n #[test]\n fn should_not_add_iface_method_nil_ret_type() {\n     let doc = test::mk_doc(\"iface i { fn a(); }\");\n-    assert doc.topmod.ifaces()[0].methods[0].return.ty == none;\n+    assert doc.cratemod().ifaces()[0].methods[0].return.ty == none;\n }\n \n #[test]\n fn should_add_iface_method_arg_types() {\n     let doc = test::mk_doc(\"iface i { fn a(b: int, c: bool); }\");\n-    let fn_ = doc.topmod.ifaces()[0].methods[0];\n+    let fn_ = doc.cratemod().ifaces()[0].methods[0];\n     assert fn_.args[0].ty == some(\"int\");\n     assert fn_.args[1].ty == some(\"bool\");\n }\n@@ -512,43 +512,43 @@ fn fold_impl(\n #[test]\n fn should_add_impl_iface_ty() {\n     let doc = test::mk_doc(\"impl i of j for int { fn a() { } }\");\n-    assert doc.topmod.impls()[0].iface_ty == some(\"j\");\n+    assert doc.cratemod().impls()[0].iface_ty == some(\"j\");\n }\n \n #[test]\n fn should_not_add_impl_iface_ty_if_none() {\n     let doc = test::mk_doc(\"impl i for int { fn a() { } }\");\n-    assert doc.topmod.impls()[0].iface_ty == none;\n+    assert doc.cratemod().impls()[0].iface_ty == none;\n }\n \n #[test]\n fn should_add_impl_self_ty() {\n     let doc = test::mk_doc(\"impl i for int { fn a() { } }\");\n-    assert doc.topmod.impls()[0].self_ty == some(\"int\");\n+    assert doc.cratemod().impls()[0].self_ty == some(\"int\");\n }\n \n #[test]\n fn should_add_impl_method_sigs() {\n     let doc = test::mk_doc(\"impl i for int { fn a() -> int { fail } }\");\n-    assert doc.topmod.impls()[0].methods[0].sig == some(\"fn a() -> int\");\n+    assert doc.cratemod().impls()[0].methods[0].sig == some(\"fn a() -> int\");\n }\n \n #[test]\n fn should_add_impl_method_ret_types() {\n     let doc = test::mk_doc(\"impl i for int { fn a() -> int { fail } }\");\n-    assert doc.topmod.impls()[0].methods[0].return.ty == some(\"int\");\n+    assert doc.cratemod().impls()[0].methods[0].return.ty == some(\"int\");\n }\n \n #[test]\n fn should_not_add_impl_method_nil_ret_type() {\n     let doc = test::mk_doc(\"impl i for int { fn a() { } }\");\n-    assert doc.topmod.impls()[0].methods[0].return.ty == none;\n+    assert doc.cratemod().impls()[0].methods[0].return.ty == none;\n }\n \n #[test]\n fn should_add_impl_method_arg_types() {\n     let doc = test::mk_doc(\"impl i for int { fn a(b: int, c: bool) { } }\");\n-    let fn_ = doc.topmod.impls()[0].methods[0];\n+    let fn_ = doc.cratemod().impls()[0].methods[0];\n     assert fn_.args[0].ty == some(\"int\");\n     assert fn_.args[1].ty == some(\"bool\");\n }\n@@ -584,12 +584,12 @@ fn fold_type(\n #[test]\n fn should_add_type_signatures() {\n     let doc = test::mk_doc(\"type t<T> = int;\");\n-    assert doc.topmod.types()[0].sig == some(\"type t<T> = int\");\n+    assert doc.cratemod().types()[0].sig == some(\"type t<T> = int\");\n }\n \n #[cfg(test)]\n mod test {\n-    fn mk_doc(source: str) -> doc::cratedoc {\n+    fn mk_doc(source: str) -> doc::doc {\n         astsrv::from_str(source) {|srv|\n             let doc = extract::from_srv(srv, \"\");\n             run(srv, doc)"}]}