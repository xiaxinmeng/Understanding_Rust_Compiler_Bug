{"sha": "227285fd86a6d1849cad0ec39e0d0d1e6790ba5c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyNzI4NWZkODZhNmQxODQ5Y2FkMGVjMzllMGQwZDFlNjc5MGJhNWM=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-02-28T13:33:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-02-28T13:33:00Z"}, "message": "Rollup merge of #39977 - frewsxcv:error-reporting-cleanup, r=eddyb\n\nlibrustc error_reporting.rs cleanup.\n\nRead some code in librustc, mainly in error_reporting.rs, and cleaned up some things along the way. I recommend looking at each commit individually or looking at the [whitespace insensitive diff](https://github.com/rust-lang/rust/pull/39977/files?w=1).", "tree": {"sha": "6a92d156e7ec23c820a1b861c6bc228432db1877", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a92d156e7ec23c820a1b861c6bc228432db1877"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/227285fd86a6d1849cad0ec39e0d0d1e6790ba5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/227285fd86a6d1849cad0ec39e0d0d1e6790ba5c", "html_url": "https://github.com/rust-lang/rust/commit/227285fd86a6d1849cad0ec39e0d0d1e6790ba5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/227285fd86a6d1849cad0ec39e0d0d1e6790ba5c/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5872a8d78bfa6b94187af0e72cff063259d74531", "url": "https://api.github.com/repos/rust-lang/rust/commits/5872a8d78bfa6b94187af0e72cff063259d74531", "html_url": "https://github.com/rust-lang/rust/commit/5872a8d78bfa6b94187af0e72cff063259d74531"}, {"sha": "a754ea6d0a6bc901e1c2dd58e3c0d0e283f8ae17", "url": "https://api.github.com/repos/rust-lang/rust/commits/a754ea6d0a6bc901e1c2dd58e3c0d0e283f8ae17", "html_url": "https://github.com/rust-lang/rust/commit/a754ea6d0a6bc901e1c2dd58e3c0d0e283f8ae17"}], "stats": {"total": 514, "additions": 235, "deletions": 279}, "files": [{"sha": "f850fd97727810ca3230bed219a0d9e2b579443b", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 197, "deletions": 261, "changes": 458, "blob_url": "https://github.com/rust-lang/rust/blob/227285fd86a6d1849cad0ec39e0d0d1e6790ba5c/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/227285fd86a6d1849cad0ec39e0d0d1e6790ba5c/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=227285fd86a6d1849cad0ec39e0d0d1e6790ba5c", "patch": "@@ -21,7 +21,6 @@ use super::{\n     SelectionContext,\n     SelectionError,\n     ObjectSafetyViolation,\n-    MethodViolationCode,\n };\n \n use fmt_macros::{Parser, Piece, Position};\n@@ -267,61 +266,63 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         let span = obligation.cause.span;\n         let mut report = None;\n-        for item in self.tcx.get_attrs(def_id).iter() {\n-            if item.check_name(\"rustc_on_unimplemented\") {\n-                let err_sp = item.meta().span.substitute_dummy(span);\n-                let trait_str = self.tcx.item_path_str(trait_ref.def_id);\n-                if let Some(istring) = item.value_str() {\n-                    let istring = &*istring.as_str();\n-                    let generics = self.tcx.item_generics(trait_ref.def_id);\n-                    let generic_map = generics.types.iter().map(|param| {\n-                        (param.name.as_str().to_string(),\n-                         trait_ref.substs.type_for_def(param).to_string())\n-                    }).collect::<FxHashMap<String, String>>();\n-                    let parser = Parser::new(istring);\n-                    let mut errored = false;\n-                    let err: String = parser.filter_map(|p| {\n-                        match p {\n-                            Piece::String(s) => Some(s),\n-                            Piece::NextArgument(a) => match a.position {\n-                                Position::ArgumentNamed(s) => match generic_map.get(s) {\n-                                    Some(val) => Some(val),\n-                                    None => {\n-                                        span_err!(self.tcx.sess, err_sp, E0272,\n-                                                       \"the #[rustc_on_unimplemented] \\\n-                                                                attribute on \\\n-                                                                trait definition for {} refers to \\\n-                                                                non-existent type parameter {}\",\n-                                                               trait_str, s);\n-                                        errored = true;\n-                                        None\n-                                    }\n-                                },\n-                                _ => {\n-                                    span_err!(self.tcx.sess, err_sp, E0273,\n-                                              \"the #[rustc_on_unimplemented] attribute \\\n-                                               on trait definition for {} must have \\\n-                                               named format arguments, eg \\\n-                                               `#[rustc_on_unimplemented = \\\n-                                                \\\"foo {{T}}\\\"]`\", trait_str);\n+        if let Some(item) = self.tcx\n+            .get_attrs(def_id)\n+            .into_iter()\n+            .filter(|a| a.check_name(\"rustc_on_unimplemented\"))\n+            .next()\n+        {\n+            let err_sp = item.meta().span.substitute_dummy(span);\n+            let trait_str = self.tcx.item_path_str(trait_ref.def_id);\n+            if let Some(istring) = item.value_str() {\n+                let istring = &*istring.as_str();\n+                let generics = self.tcx.item_generics(trait_ref.def_id);\n+                let generic_map = generics.types.iter().map(|param| {\n+                    (param.name.as_str().to_string(),\n+                        trait_ref.substs.type_for_def(param).to_string())\n+                }).collect::<FxHashMap<String, String>>();\n+                let parser = Parser::new(istring);\n+                let mut errored = false;\n+                let err: String = parser.filter_map(|p| {\n+                    match p {\n+                        Piece::String(s) => Some(s),\n+                        Piece::NextArgument(a) => match a.position {\n+                            Position::ArgumentNamed(s) => match generic_map.get(s) {\n+                                Some(val) => Some(val),\n+                                None => {\n+                                    span_err!(self.tcx.sess, err_sp, E0272,\n+                                                    \"the #[rustc_on_unimplemented] \\\n+                                                            attribute on \\\n+                                                            trait definition for {} refers to \\\n+                                                            non-existent type parameter {}\",\n+                                                            trait_str, s);\n                                     errored = true;\n                                     None\n                                 }\n+                            },\n+                            _ => {\n+                                span_err!(self.tcx.sess, err_sp, E0273,\n+                                            \"the #[rustc_on_unimplemented] attribute \\\n+                                            on trait definition for {} must have \\\n+                                            named format arguments, eg \\\n+                                            `#[rustc_on_unimplemented = \\\n+                                            \\\"foo {{T}}\\\"]`\", trait_str);\n+                                errored = true;\n+                                None\n                             }\n                         }\n-                    }).collect();\n-                    // Report only if the format string checks out\n-                    if !errored {\n-                        report = Some(err);\n                     }\n-                } else {\n-                    span_err!(self.tcx.sess, err_sp, E0274,\n-                                            \"the #[rustc_on_unimplemented] attribute on \\\n-                                                     trait definition for {} must have a value, \\\n-                                                     eg `#[rustc_on_unimplemented = \\\"foo\\\"]`\",\n-                                                     trait_str);\n+                }).collect();\n+                // Report only if the format string checks out\n+                if !errored {\n+                    report = Some(err);\n                 }\n-                break;\n+            } else {\n+                span_err!(self.tcx.sess, err_sp, E0274,\n+                                        \"the #[rustc_on_unimplemented] attribute on \\\n+                                                    trait definition for {} must have a value, \\\n+                                                    eg `#[rustc_on_unimplemented = \\\"foo\\\"]`\",\n+                                                    trait_str);\n             }\n         }\n         report\n@@ -359,34 +360,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn report_similar_impl_candidates(&self,\n-                                      trait_ref: ty::PolyTraitRef<'tcx>,\n+                                      impl_candidates: Vec<ty::TraitRef<'tcx>>,\n                                       err: &mut DiagnosticBuilder)\n     {\n-        let simp = fast_reject::simplify_type(self.tcx,\n-                                              trait_ref.skip_binder().self_ty(),\n-                                              true);\n-        let mut impl_candidates = Vec::new();\n-        let trait_def = self.tcx.lookup_trait_def(trait_ref.def_id());\n-\n-        match simp {\n-            Some(simp) => trait_def.for_each_impl(self.tcx, |def_id| {\n-                let imp = self.tcx.impl_trait_ref(def_id).unwrap();\n-                let imp_simp = fast_reject::simplify_type(self.tcx,\n-                                                          imp.self_ty(),\n-                                                          true);\n-                if let Some(imp_simp) = imp_simp {\n-                    if simp != imp_simp {\n-                        return;\n-                    }\n-                }\n-                impl_candidates.push(imp);\n-            }),\n-            None => trait_def.for_each_impl(self.tcx, |def_id| {\n-                impl_candidates.push(\n-                    self.tcx.impl_trait_ref(def_id).unwrap());\n-            })\n-        };\n-\n         if impl_candidates.is_empty() {\n             return;\n         }\n@@ -525,127 +501,118 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         lint_id)\n                         .emit();\n                     return;\n-                } else {\n-                    match obligation.predicate {\n-                        ty::Predicate::Trait(ref trait_predicate) => {\n-                            let trait_predicate =\n-                                self.resolve_type_vars_if_possible(trait_predicate);\n-\n-                            if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n-                                return;\n-                            } else {\n-                                let trait_ref = trait_predicate.to_poly_trait_ref();\n-                                let (post_message, pre_message) = match self.get_parent_trait_ref(\n-                                    &obligation.cause.code)\n-                                {\n-                                    Some(t) => {\n-                                        (format!(\" in `{}`\", t), format!(\"within `{}`, \", t))\n-                                    }\n-                                    None => (String::new(), String::new()),\n-                                };\n-                                let mut err = struct_span_err!(\n-                                    self.tcx.sess,\n-                                    span,\n-                                    E0277,\n-                                    \"the trait bound `{}` is not satisfied{}\",\n-                                    trait_ref.to_predicate(),\n-                                    post_message);\n-                                err.span_label(span,\n-                                               &format!(\"{}the trait `{}` is not \\\n-                                                         implemented for `{}`\",\n-                                                        pre_message,\n-                                                        trait_ref,\n-                                                        trait_ref.self_ty()));\n-\n-                                // Try to report a help message\n-\n-                                if !trait_ref.has_infer_types() &&\n-                                    self.predicate_can_apply(trait_ref) {\n-                                    // If a where-clause may be useful, remind the\n-                                    // user that they can add it.\n-                                    //\n-                                    // don't display an on-unimplemented note, as\n-                                    // these notes will often be of the form\n-                                    //     \"the type `T` can't be frobnicated\"\n-                                    // which is somewhat confusing.\n-                                    err.help(&format!(\"consider adding a `where {}` bound\",\n-                                                      trait_ref.to_predicate()));\n-                                } else if let Some(s) = self.on_unimplemented_note(trait_ref,\n-                                                                                   obligation) {\n-                                    // If it has a custom \"#[rustc_on_unimplemented]\"\n-                                    // error message, let's display it!\n-                                    err.note(&s);\n-                                } else {\n-                                    // If we can't show anything useful, try to find\n-                                    // similar impls.\n-                                    let impl_candidates =\n-                                        self.find_similar_impl_candidates(trait_ref);\n-                                    if impl_candidates.len() > 0 {\n-                                        self.report_similar_impl_candidates(trait_ref, &mut err);\n-                                    }\n-                                }\n-                                err\n-                            }\n-                        }\n+                }\n+                match obligation.predicate {\n+                    ty::Predicate::Trait(ref trait_predicate) => {\n+                        let trait_predicate =\n+                            self.resolve_type_vars_if_possible(trait_predicate);\n \n-                        ty::Predicate::Equate(ref predicate) => {\n-                            let predicate = self.resolve_type_vars_if_possible(predicate);\n-                            let err = self.equality_predicate(&obligation.cause,\n-                                                              &predicate).err().unwrap();\n-                            struct_span_err!(self.tcx.sess, span, E0278,\n-                                \"the requirement `{}` is not satisfied (`{}`)\",\n-                                predicate, err)\n+                        if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n+                            return;\n                         }\n-\n-                        ty::Predicate::RegionOutlives(ref predicate) => {\n-                            let predicate = self.resolve_type_vars_if_possible(predicate);\n-                            let err = self.region_outlives_predicate(&obligation.cause,\n-                                                                     &predicate).err().unwrap();\n-                            struct_span_err!(self.tcx.sess, span, E0279,\n-                                \"the requirement `{}` is not satisfied (`{}`)\",\n-                                predicate, err)\n+                        let trait_ref = trait_predicate.to_poly_trait_ref();\n+                        let (post_message, pre_message) =\n+                            self.get_parent_trait_ref(&obligation.cause.code)\n+                                .map(|t| (format!(\" in `{}`\", t), format!(\"within `{}`, \", t)))\n+                                .unwrap_or((String::new(), String::new()));\n+                        let mut err = struct_span_err!(\n+                            self.tcx.sess,\n+                            span,\n+                            E0277,\n+                            \"the trait bound `{}` is not satisfied{}\",\n+                            trait_ref.to_predicate(),\n+                            post_message);\n+                        err.span_label(span,\n+                                        &format!(\"{}the trait `{}` is not \\\n+                                                    implemented for `{}`\",\n+                                                pre_message,\n+                                                trait_ref,\n+                                                trait_ref.self_ty()));\n+\n+                        // Try to report a help message\n+\n+                        if !trait_ref.has_infer_types() &&\n+                            self.predicate_can_apply(trait_ref) {\n+                            // If a where-clause may be useful, remind the\n+                            // user that they can add it.\n+                            //\n+                            // don't display an on-unimplemented note, as\n+                            // these notes will often be of the form\n+                            //     \"the type `T` can't be frobnicated\"\n+                            // which is somewhat confusing.\n+                            err.help(&format!(\"consider adding a `where {}` bound\",\n+                                                trait_ref.to_predicate()));\n+                        } else if let Some(s) = self.on_unimplemented_note(trait_ref,\n+                                                                            obligation) {\n+                            // If it has a custom \"#[rustc_on_unimplemented]\"\n+                            // error message, let's display it!\n+                            err.note(&s);\n+                        } else {\n+                            // If we can't show anything useful, try to find\n+                            // similar impls.\n+                            let impl_candidates = self.find_similar_impl_candidates(trait_ref);\n+                            self.report_similar_impl_candidates(impl_candidates, &mut err);\n                         }\n+                        err\n+                    }\n \n-                        ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n-                            let predicate =\n-                                self.resolve_type_vars_if_possible(&obligation.predicate);\n-                            struct_span_err!(self.tcx.sess, span, E0280,\n-                                \"the requirement `{}` is not satisfied\",\n-                                predicate)\n-                        }\n+                    ty::Predicate::Equate(ref predicate) => {\n+                        let predicate = self.resolve_type_vars_if_possible(predicate);\n+                        let err = self.equality_predicate(&obligation.cause,\n+                                                            &predicate).err().unwrap();\n+                        struct_span_err!(self.tcx.sess, span, E0278,\n+                            \"the requirement `{}` is not satisfied (`{}`)\",\n+                            predicate, err)\n+                    }\n \n-                        ty::Predicate::ObjectSafe(trait_def_id) => {\n-                            let violations = self.tcx.object_safety_violations(trait_def_id);\n-                            self.tcx.report_object_safety_error(span,\n-                                                                trait_def_id,\n-                                                                violations)\n-                        }\n+                    ty::Predicate::RegionOutlives(ref predicate) => {\n+                        let predicate = self.resolve_type_vars_if_possible(predicate);\n+                        let err = self.region_outlives_predicate(&obligation.cause,\n+                                                                    &predicate).err().unwrap();\n+                        struct_span_err!(self.tcx.sess, span, E0279,\n+                            \"the requirement `{}` is not satisfied (`{}`)\",\n+                            predicate, err)\n+                    }\n \n-                        ty::Predicate::ClosureKind(closure_def_id, kind) => {\n-                            let found_kind = self.closure_kind(closure_def_id).unwrap();\n-                            let closure_span = self.tcx.hir.span_if_local(closure_def_id).unwrap();\n-                            let mut err = struct_span_err!(\n-                                self.tcx.sess, closure_span, E0525,\n-                                \"expected a closure that implements the `{}` trait, \\\n-                                 but this closure only implements `{}`\",\n-                                kind,\n-                                found_kind);\n-                            err.span_note(\n-                                obligation.cause.span,\n-                                &format!(\"the requirement to implement \\\n-                                          `{}` derives from here\", kind));\n-                            err.emit();\n-                            return;\n-                        }\n+                    ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n+                        let predicate =\n+                            self.resolve_type_vars_if_possible(&obligation.predicate);\n+                        struct_span_err!(self.tcx.sess, span, E0280,\n+                            \"the requirement `{}` is not satisfied\",\n+                            predicate)\n+                    }\n \n-                        ty::Predicate::WellFormed(ty) => {\n-                            // WF predicates cannot themselves make\n-                            // errors. They can only block due to\n-                            // ambiguity; otherwise, they always\n-                            // degenerate into other obligations\n-                            // (which may fail).\n-                            span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n-                        }\n+                    ty::Predicate::ObjectSafe(trait_def_id) => {\n+                        let violations = self.tcx.object_safety_violations(trait_def_id);\n+                        self.tcx.report_object_safety_error(span,\n+                                                            trait_def_id,\n+                                                            violations)\n+                    }\n+\n+                    ty::Predicate::ClosureKind(closure_def_id, kind) => {\n+                        let found_kind = self.closure_kind(closure_def_id).unwrap();\n+                        let closure_span = self.tcx.hir.span_if_local(closure_def_id).unwrap();\n+                        let mut err = struct_span_err!(\n+                            self.tcx.sess, closure_span, E0525,\n+                            \"expected a closure that implements the `{}` trait, \\\n+                                but this closure only implements `{}`\",\n+                            kind,\n+                            found_kind);\n+                        err.span_note(\n+                            obligation.cause.span,\n+                            &format!(\"the requirement to implement \\\n+                                        `{}` derives from here\", kind));\n+                        err.emit();\n+                        return;\n+                    }\n+\n+                    ty::Predicate::WellFormed(ty) => {\n+                        // WF predicates cannot themselves make\n+                        // errors. They can only block due to\n+                        // ambiguity; otherwise, they always\n+                        // degenerate into other obligations\n+                        // (which may fail).\n+                        span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n                     }\n                 }\n             }\n@@ -713,38 +680,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             if !reported_violations.insert(violation.clone()) {\n                 continue;\n             }\n-            let buf;\n-            let note = match violation {\n-                ObjectSafetyViolation::SizedSelf => {\n-                    \"the trait cannot require that `Self : Sized`\"\n-                }\n-\n-                ObjectSafetyViolation::SupertraitSelf => {\n-                    \"the trait cannot use `Self` as a type parameter \\\n-                         in the supertrait listing\"\n-                }\n-\n-                ObjectSafetyViolation::Method(name,\n-                                              MethodViolationCode::StaticMethod) => {\n-                    buf = format!(\"method `{}` has no receiver\", name);\n-                    &buf\n-                }\n-\n-                ObjectSafetyViolation::Method(name,\n-                                              MethodViolationCode::ReferencesSelf) => {\n-                    buf = format!(\"method `{}` references the `Self` type \\\n-                                       in its arguments or return type\",\n-                                  name);\n-                    &buf\n-                }\n-\n-                ObjectSafetyViolation::Method(name,\n-                                              MethodViolationCode::Generic) => {\n-                    buf = format!(\"method `{}` has generic type parameters\", name);\n-                    &buf\n-                }\n-            };\n-            err.note(note);\n+            err.note(&violation.error_msg());\n         }\n         err\n     }\n@@ -774,46 +710,46 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 let trait_ref = data.to_poly_trait_ref();\n                 let self_ty = trait_ref.self_ty();\n                 if predicate.references_error() {\n-                } else {\n-                    // Typically, this ambiguity should only happen if\n-                    // there are unresolved type inference variables\n-                    // (otherwise it would suggest a coherence\n-                    // failure). But given #21974 that is not necessarily\n-                    // the case -- we can have multiple where clauses that\n-                    // are only distinguished by a region, which results\n-                    // in an ambiguity even when all types are fully\n-                    // known, since we don't dispatch based on region\n-                    // relationships.\n-\n-                    // This is kind of a hack: it frequently happens that some earlier\n-                    // error prevents types from being fully inferred, and then we get\n-                    // a bunch of uninteresting errors saying something like \"<generic\n-                    // #0> doesn't implement Sized\".  It may even be true that we\n-                    // could just skip over all checks where the self-ty is an\n-                    // inference variable, but I was afraid that there might be an\n-                    // inference variable created, registered as an obligation, and\n-                    // then never forced by writeback, and hence by skipping here we'd\n-                    // be ignoring the fact that we don't KNOW the type works\n-                    // out. Though even that would probably be harmless, given that\n-                    // we're only talking about builtin traits, which are known to be\n-                    // inhabited. But in any case I just threw in this check for\n-                    // has_errors() to be sure that compilation isn't happening\n-                    // anyway. In that case, why inundate the user.\n-                    if !self.tcx.sess.has_errors() {\n-                        if\n-                            self.tcx.lang_items.sized_trait()\n-                            .map_or(false, |sized_id| sized_id == trait_ref.def_id())\n-                        {\n-                            self.need_type_info(obligation, self_ty);\n-                        } else {\n-                            let mut err = struct_span_err!(self.tcx.sess,\n-                                                           obligation.cause.span, E0283,\n-                                                           \"type annotations required: \\\n-                                                            cannot resolve `{}`\",\n-                                                           predicate);\n-                            self.note_obligation_cause(&mut err, obligation);\n-                            err.emit();\n-                        }\n+                    return;\n+                }\n+                // Typically, this ambiguity should only happen if\n+                // there are unresolved type inference variables\n+                // (otherwise it would suggest a coherence\n+                // failure). But given #21974 that is not necessarily\n+                // the case -- we can have multiple where clauses that\n+                // are only distinguished by a region, which results\n+                // in an ambiguity even when all types are fully\n+                // known, since we don't dispatch based on region\n+                // relationships.\n+\n+                // This is kind of a hack: it frequently happens that some earlier\n+                // error prevents types from being fully inferred, and then we get\n+                // a bunch of uninteresting errors saying something like \"<generic\n+                // #0> doesn't implement Sized\".  It may even be true that we\n+                // could just skip over all checks where the self-ty is an\n+                // inference variable, but I was afraid that there might be an\n+                // inference variable created, registered as an obligation, and\n+                // then never forced by writeback, and hence by skipping here we'd\n+                // be ignoring the fact that we don't KNOW the type works\n+                // out. Though even that would probably be harmless, given that\n+                // we're only talking about builtin traits, which are known to be\n+                // inhabited. But in any case I just threw in this check for\n+                // has_errors() to be sure that compilation isn't happening\n+                // anyway. In that case, why inundate the user.\n+                if !self.tcx.sess.has_errors() {\n+                    if\n+                        self.tcx.lang_items.sized_trait()\n+                        .map_or(false, |sized_id| sized_id == trait_ref.def_id())\n+                    {\n+                        self.need_type_info(obligation, self_ty);\n+                    } else {\n+                        let mut err = struct_span_err!(self.tcx.sess,\n+                                                        obligation.cause.span, E0283,\n+                                                        \"type annotations required: \\\n+                                                        cannot resolve `{}`\",\n+                                                        predicate);\n+                        self.note_obligation_cause(&mut err, obligation);\n+                        err.emit();\n                     }\n                 }\n             }"}, {"sha": "2ebe0d459fab1453451b02f4bc7fd208224ac76b", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/227285fd86a6d1849cad0ec39e0d0d1e6790ba5c/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/227285fd86a6d1849cad0ec39e0d0d1e6790ba5c/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=227285fd86a6d1849cad0ec39e0d0d1e6790ba5c", "patch": "@@ -23,6 +23,7 @@ use hir::def_id::DefId;\n use traits;\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::subst::Substs;\n+use std::borrow::Cow;\n use syntax::ast;\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n@@ -38,6 +39,25 @@ pub enum ObjectSafetyViolation {\n     Method(ast::Name, MethodViolationCode),\n }\n \n+impl ObjectSafetyViolation {\n+    pub fn error_msg(&self) -> Cow<'static, str> {\n+        match *self {\n+            ObjectSafetyViolation::SizedSelf =>\n+                \"the trait cannot require that `Self : Sized`\".into(),\n+            ObjectSafetyViolation::SupertraitSelf =>\n+                \"the trait cannot use `Self` as a type parameter \\\n+                 in the supertrait listing\".into(),\n+            ObjectSafetyViolation::Method(name, MethodViolationCode::StaticMethod) =>\n+                format!(\"method `{}` has no receiver\", name).into(),\n+            ObjectSafetyViolation::Method(name, MethodViolationCode::ReferencesSelf) =>\n+                format!(\"method `{}` references the `Self` type \\\n+                         in its arguments or return type\", name).into(),\n+            ObjectSafetyViolation::Method(name, MethodViolationCode::Generic) =>\n+                format!(\"method `{}` has generic type parameters\", name).into(),\n+        }\n+    }\n+}\n+\n /// Reasons a method might not be object-safe.\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum MethodViolationCode {"}, {"sha": "656d0ddf09a52782862113f528fff3225f8ec758", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/227285fd86a6d1849cad0ec39e0d0d1e6790ba5c/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/227285fd86a6d1849cad0ec39e0d0d1e6790ba5c/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=227285fd86a6d1849cad0ec39e0d0d1e6790ba5c", "patch": "@@ -1097,24 +1097,6 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n     }\n }\n \n-impl<'tcx> TraitRef<'tcx> {\n-    pub fn new(def_id: DefId, substs: &'tcx Substs<'tcx>) -> TraitRef<'tcx> {\n-        TraitRef { def_id: def_id, substs: substs }\n-    }\n-\n-    pub fn self_ty(&self) -> Ty<'tcx> {\n-        self.substs.type_at(0)\n-    }\n-\n-    pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n-        // Select only the \"input types\" from a trait-reference. For\n-        // now this is all the types that appear in the\n-        // trait-reference, but it should eventually exclude\n-        // associated types.\n-        self.substs.types()\n-    }\n-}\n-\n /// When type checking, we use the `ParameterEnvironment` to track\n /// details about the type/lifetime parameters that are in scope.\n /// It primarily stores the bounds information."}, {"sha": "e686d62019145bc13d7aaadb1d955a4116d0a86b", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/227285fd86a6d1849cad0ec39e0d0d1e6790ba5c/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/227285fd86a6d1849cad0ec39e0d0d1e6790ba5c/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=227285fd86a6d1849cad0ec39e0d0d1e6790ba5c", "patch": "@@ -389,6 +389,24 @@ pub struct TraitRef<'tcx> {\n     pub substs: &'tcx Substs<'tcx>,\n }\n \n+impl<'tcx> TraitRef<'tcx> {\n+    pub fn new(def_id: DefId, substs: &'tcx Substs<'tcx>) -> TraitRef<'tcx> {\n+        TraitRef { def_id: def_id, substs: substs }\n+    }\n+\n+    pub fn self_ty(&self) -> Ty<'tcx> {\n+        self.substs.type_at(0)\n+    }\n+\n+    pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n+        // Select only the \"input types\" from a trait-reference. For\n+        // now this is all the types that appear in the\n+        // trait-reference, but it should eventually exclude\n+        // associated types.\n+        self.substs.types()\n+    }\n+}\n+\n pub type PolyTraitRef<'tcx> = Binder<TraitRef<'tcx>>;\n \n impl<'tcx> PolyTraitRef<'tcx> {"}]}