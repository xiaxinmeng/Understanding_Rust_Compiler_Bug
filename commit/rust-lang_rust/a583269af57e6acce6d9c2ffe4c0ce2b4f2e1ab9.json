{"sha": "a583269af57e6acce6d9c2ffe4c0ce2b4f2e1ab9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1ODMyNjlhZjU3ZTZhY2NlNmQ5YzJmZmU0YzBjZTJiNGYyZTFhYjk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-19T14:01:08Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-26T17:18:25Z"}, "message": "add a streamlined `instantiate_query_result` method for NLL queries", "tree": {"sha": "2fef3c06840d27c1658e0afad42dfa078687b343", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2fef3c06840d27c1658e0afad42dfa078687b343"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a583269af57e6acce6d9c2ffe4c0ce2b4f2e1ab9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a583269af57e6acce6d9c2ffe4c0ce2b4f2e1ab9", "html_url": "https://github.com/rust-lang/rust/commit/a583269af57e6acce6d9c2ffe4c0ce2b4f2e1ab9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a583269af57e6acce6d9c2ffe4c0ce2b4f2e1ab9/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e895f3aded36fd69f78232d4aca230a236948b8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e895f3aded36fd69f78232d4aca230a236948b8f", "html_url": "https://github.com/rust-lang/rust/commit/e895f3aded36fd69f78232d4aca230a236948b8f"}], "stats": {"total": 89, "additions": 87, "deletions": 2}, "files": [{"sha": "f8551dffcf4bf19e86f21141b2ae5b59d3e29cf5", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a583269af57e6acce6d9c2ffe4c0ce2b4f2e1ab9/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a583269af57e6acce6d9c2ffe4c0ce2b4f2e1ab9/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=a583269af57e6acce6d9c2ffe4c0ce2b4f2e1ab9", "patch": "@@ -1781,6 +1781,7 @@ dependencies = [\n  \"bitflags 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"byteorder 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"chalk-engine 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"either 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flate2 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fmt_macros 0.0.0\",\n  \"graphviz 0.0.0\","}, {"sha": "542ee9f02c909809962f652902470230e14d113a", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a583269af57e6acce6d9c2ffe4c0ce2b4f2e1ab9/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a583269af57e6acce6d9c2ffe4c0ce2b4f2e1ab9/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=a583269af57e6acce6d9c2ffe4c0ce2b4f2e1ab9", "patch": "@@ -11,6 +11,7 @@ crate-type = [\"dylib\"]\n [dependencies]\n arena = { path = \"../libarena\" }\n bitflags = \"1.0\"\n+either = \"1.5.0\"\n fmt_macros = { path = \"../libfmt_macros\" }\n graphviz = { path = \"../libgraphviz\" }\n jobserver = \"0.1\""}, {"sha": "d512bb5268da3c66e16f9d6aa4d56fc350ee1375", "filename": "src/librustc/infer/canonical/query_result.rs", "status": "modified", "additions": 84, "deletions": 2, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/a583269af57e6acce6d9c2ffe4c0ce2b4f2e1ab9/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a583269af57e6acce6d9c2ffe4c0ce2b4f2e1ab9/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs?ref=a583269af57e6acce6d9c2ffe4c0ce2b4f2e1ab9", "patch": "@@ -17,17 +17,19 @@\n //!\n //! [c]: https://rust-lang-nursery.github.io/rustc-guide/traits/canonicalization.html\n \n+use either::Either;\n use infer::canonical::substitute::substitute_value;\n use infer::canonical::{\n-    Canonical, CanonicalVarValues, CanonicalizedQueryResult, Certainty, QueryRegionConstraint,\n-    QueryResult,\n+    Canonical, CanonicalVarKind, CanonicalVarValues, CanonicalizedQueryResult, Certainty,\n+    QueryRegionConstraint, QueryResult,\n };\n use infer::region_constraints::{Constraint, RegionConstraintData};\n use infer::{InferCtxt, InferOk, InferResult, RegionObligation};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::sync::Lrc;\n use std::fmt::Debug;\n+use std::iter::once;\n use syntax::ast;\n use traits::query::NoSolution;\n use traits::{FulfillmentContext, TraitEngine};\n@@ -176,6 +178,86 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         })\n     }\n \n+    /// NLL does a lot of queries that have a particular form that we\n+    /// can take advantage of to be more efficient. These queries do\n+    /// not have any *type* inference variables, only region inference\n+    /// variables. Therefore, when we instantiate the query result, we\n+    /// only ever produce new *region constraints* and never other\n+    /// forms of obligations (moreover, since we only determine\n+    /// satisfiability modulo region constraints, instantiation is\n+    /// infallible). Therefore, the return value need only be a larger\n+    /// set of query region constraints. These constraints can then be\n+    /// added directly to the NLL inference context.\n+    pub fn instantiate_nll_query_result_and_region_obligations<R>(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        original_values: &CanonicalVarValues<'tcx>,\n+        query_result: &Canonical<'tcx, QueryResult<'tcx, R>>,\n+    ) -> Vec<QueryRegionConstraint<'tcx>>\n+    where\n+        R: Debug + TypeFoldable<'tcx>,\n+    {\n+        // In an NLL query, there should be no type variables in the\n+        // query, only region variables.\n+        debug_assert!(query_result.variables.iter().all(|v| match v.kind {\n+            CanonicalVarKind::Ty(_) => false,\n+            CanonicalVarKind::Region => true,\n+        }));\n+\n+        let result_subst =\n+            self.query_result_substitution_guess(cause, original_values, query_result);\n+\n+        // Compute `QueryRegionConstraint` values that unify each of\n+        // the original values `v_o` that was canonicalized into a\n+        // variable...\n+        let qrc_from_unify = original_values.var_values.iter_enumerated().flat_map(\n+            |(index, original_value)| {\n+                // ...with the value `v_r` of that variable from the query.\n+                let result_value =\n+                    query_result\n+                        .substitute_projected(self.tcx, &result_subst, |v| &v.var_values[index]);\n+                match (original_value.unpack(), result_value.unpack()) {\n+                    (\n+                        UnpackedKind::Lifetime(ty::ReErased),\n+                        UnpackedKind::Lifetime(ty::ReErased),\n+                    ) => {\n+                        // no action needed\n+                        Either::Left(None.into_iter())\n+                    }\n+\n+                    (UnpackedKind::Lifetime(v_o), UnpackedKind::Lifetime(v_r)) => {\n+                        // To make `v_o = v_r`, we emit `v_o: v_r` and `v_r: v_o`.\n+                        Either::Right(\n+                            once(ty::OutlivesPredicate(v_o.into(), v_r))\n+                                .chain(once(ty::OutlivesPredicate(v_r.into(), v_o)))\n+                                .map(ty::Binder::dummy),\n+                        )\n+                    }\n+\n+                    (UnpackedKind::Type(_), _) | (_, UnpackedKind::Type(_)) => {\n+                        // in NLL queries, we do not expect `type` results.\n+                        bug!(\n+                            \"unexpected type in NLL query: cannot unify {:?} and {:?}\",\n+                            original_value,\n+                            result_value,\n+                        );\n+                    }\n+                }\n+            },\n+        );\n+\n+        // ...also include the other query region constraints from the query.\n+        let qrc_from_result = query_result.value.region_constraints.iter().map(|r_c| {\n+            r_c.map_bound(|ty::OutlivesPredicate(k1, r2)| {\n+                let k1 = substitute_value(self.tcx, &result_subst, &k1);\n+                let r2 = substitute_value(self.tcx, &result_subst, &r2);\n+                ty::OutlivesPredicate(k1, r2)\n+            })\n+        });\n+\n+        qrc_from_unify.chain(qrc_from_result).collect()\n+    }\n+\n     /// Given the original values and the (canonicalized) result from\n     /// computing a query, returns a substitution that can be applied\n     /// to the query result to convert the result back into the"}, {"sha": "7c3d3414846de2f292c6537b5e3dc4dc46cabf43", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a583269af57e6acce6d9c2ffe4c0ce2b4f2e1ab9/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a583269af57e6acce6d9c2ffe4c0ce2b4f2e1ab9/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=a583269af57e6acce6d9c2ffe4c0ce2b4f2e1ab9", "patch": "@@ -79,6 +79,7 @@\n extern crate arena;\n #[macro_use] extern crate bitflags;\n extern crate core;\n+extern crate either;\n extern crate fmt_macros;\n extern crate getopts;\n extern crate graphviz;"}]}