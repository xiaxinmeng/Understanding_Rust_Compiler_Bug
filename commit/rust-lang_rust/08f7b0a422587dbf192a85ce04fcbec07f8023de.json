{"sha": "08f7b0a422587dbf192a85ce04fcbec07f8023de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4ZjdiMGE0MjI1ODdkYmYxOTJhODVjZTA0ZmNiZWMwN2Y4MDIzZGU=", "commit": {"author": {"name": "D\u00e1niel Buga", "email": "bugadani@gmail.com", "date": "2020-12-31T09:07:19Z"}, "committer": {"name": "D\u00e1niel Buga", "email": "bugadani@gmail.com", "date": "2020-12-31T09:40:37Z"}, "message": "Use ranges returned by pulldown\n\nCo-authored-by: Joshua Nelson <joshua@yottadb.com>", "tree": {"sha": "f7f709922980f6b053eac94683c2dc36fad16127", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7f709922980f6b053eac94683c2dc36fad16127"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08f7b0a422587dbf192a85ce04fcbec07f8023de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08f7b0a422587dbf192a85ce04fcbec07f8023de", "html_url": "https://github.com/rust-lang/rust/commit/08f7b0a422587dbf192a85ce04fcbec07f8023de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08f7b0a422587dbf192a85ce04fcbec07f8023de/comments", "author": {"login": "bugadani", "id": 977627, "node_id": "MDQ6VXNlcjk3NzYyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/977627?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bugadani", "html_url": "https://github.com/bugadani", "followers_url": "https://api.github.com/users/bugadani/followers", "following_url": "https://api.github.com/users/bugadani/following{/other_user}", "gists_url": "https://api.github.com/users/bugadani/gists{/gist_id}", "starred_url": "https://api.github.com/users/bugadani/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bugadani/subscriptions", "organizations_url": "https://api.github.com/users/bugadani/orgs", "repos_url": "https://api.github.com/users/bugadani/repos", "events_url": "https://api.github.com/users/bugadani/events{/privacy}", "received_events_url": "https://api.github.com/users/bugadani/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bugadani", "id": 977627, "node_id": "MDQ6VXNlcjk3NzYyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/977627?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bugadani", "html_url": "https://github.com/bugadani", "followers_url": "https://api.github.com/users/bugadani/followers", "following_url": "https://api.github.com/users/bugadani/following{/other_user}", "gists_url": "https://api.github.com/users/bugadani/gists{/gist_id}", "starred_url": "https://api.github.com/users/bugadani/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bugadani/subscriptions", "organizations_url": "https://api.github.com/users/bugadani/orgs", "repos_url": "https://api.github.com/users/bugadani/repos", "events_url": "https://api.github.com/users/bugadani/events{/privacy}", "received_events_url": "https://api.github.com/users/bugadani/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "923e3d2400e9a56fed70d377db5e7728ed3e5192", "url": "https://api.github.com/repos/rust-lang/rust/commits/923e3d2400e9a56fed70d377db5e7728ed3e5192", "html_url": "https://github.com/rust-lang/rust/commit/923e3d2400e9a56fed70d377db5e7728ed3e5192"}], "stats": {"total": 66, "additions": 35, "deletions": 31}, "files": [{"sha": "7a922f570dadde2233a662d0591cc09cf230d057", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 35, "deletions": 31, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/08f7b0a422587dbf192a85ce04fcbec07f8023de/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f7b0a422587dbf192a85ce04fcbec07f8023de/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=08f7b0a422587dbf192a85ce04fcbec07f8023de", "patch": "@@ -414,11 +414,13 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for LinkReplacer<'a, I> {\n     }\n }\n \n+type SpannedEvent<'a> = (Event<'a>, Range<usize>);\n+\n /// Make headings links with anchor IDs and build up TOC.\n struct HeadingLinks<'a, 'b, 'ids, I> {\n     inner: I,\n     toc: Option<&'b mut TocBuilder>,\n-    buf: VecDeque<Event<'a>>,\n+    buf: VecDeque<SpannedEvent<'a>>,\n     id_map: &'ids mut IdMap,\n }\n \n@@ -428,48 +430,48 @@ impl<'a, 'b, 'ids, I> HeadingLinks<'a, 'b, 'ids, I> {\n     }\n }\n \n-impl<'a, 'b, 'ids, I: Iterator<Item = Event<'a>>> Iterator for HeadingLinks<'a, 'b, 'ids, I> {\n-    type Item = Event<'a>;\n+impl<'a, 'b, 'ids, I: Iterator<Item = SpannedEvent<'a>>> Iterator\n+    for HeadingLinks<'a, 'b, 'ids, I>\n+{\n+    type Item = SpannedEvent<'a>;\n \n     fn next(&mut self) -> Option<Self::Item> {\n         if let Some(e) = self.buf.pop_front() {\n             return Some(e);\n         }\n \n         let event = self.inner.next();\n-        if let Some(Event::Start(Tag::Heading(level))) = event {\n+        if let Some((Event::Start(Tag::Heading(level)), _)) = event {\n             let mut id = String::new();\n             for event in &mut self.inner {\n-                match &event {\n+                match &event.0 {\n                     Event::End(Tag::Heading(..)) => break,\n+                    Event::Start(Tag::Link(_, _, _)) | Event::End(Tag::Link(..)) => {}\n                     Event::Text(text) | Event::Code(text) => {\n                         id.extend(text.chars().filter_map(slugify));\n+                        self.buf.push_back(event);\n                     }\n-                    _ => {}\n-                }\n-                match event {\n-                    Event::Start(Tag::Link(_, _, _)) | Event::End(Tag::Link(..)) => {}\n-                    event => self.buf.push_back(event),\n+                    _ => self.buf.push_back(event),\n                 }\n             }\n             let id = self.id_map.derive(id);\n \n             if let Some(ref mut builder) = self.toc {\n                 let mut html_header = String::new();\n-                html::push_html(&mut html_header, self.buf.iter().cloned());\n+                html::push_html(&mut html_header, self.buf.iter().map(|(ev, _)| ev.clone()));\n                 let sec = builder.push(level as u32, html_header, id.clone());\n-                self.buf.push_front(Event::Html(format!(\"{} \", sec).into()));\n+                self.buf.push_front((Event::Html(format!(\"{} \", sec).into()), 0..0));\n             }\n \n-            self.buf.push_back(Event::Html(format!(\"</a></h{}>\", level).into()));\n+            self.buf.push_back((Event::Html(format!(\"</a></h{}>\", level).into()), 0..0));\n \n             let start_tags = format!(\n                 \"<h{level} id=\\\"{id}\\\" class=\\\"section-header\\\">\\\n                     <a href=\\\"#{id}\\\">\",\n                 id = id,\n                 level = level\n             );\n-            return Some(Event::Html(start_tags.into()));\n+            return Some((Event::Html(start_tags.into()), 0..0));\n         }\n         event\n     }\n@@ -560,23 +562,23 @@ impl<'a, I> Footnotes<'a, I> {\n     }\n }\n \n-impl<'a, I: Iterator<Item = Event<'a>>> Iterator for Footnotes<'a, I> {\n-    type Item = Event<'a>;\n+impl<'a, I: Iterator<Item = SpannedEvent<'a>>> Iterator for Footnotes<'a, I> {\n+    type Item = SpannedEvent<'a>;\n \n     fn next(&mut self) -> Option<Self::Item> {\n         loop {\n             match self.inner.next() {\n-                Some(Event::FootnoteReference(ref reference)) => {\n+                Some((Event::FootnoteReference(ref reference), range)) => {\n                     let entry = self.get_entry(&reference);\n                     let reference = format!(\n                         \"<sup id=\\\"fnref{0}\\\"><a href=\\\"#fn{0}\\\">{0}</a></sup>\",\n                         (*entry).1\n                     );\n-                    return Some(Event::Html(reference.into()));\n+                    return Some((Event::Html(reference.into()), range));\n                 }\n-                Some(Event::Start(Tag::FootnoteDefinition(def))) => {\n+                Some((Event::Start(Tag::FootnoteDefinition(def)), _)) => {\n                     let mut content = Vec::new();\n-                    for event in &mut self.inner {\n+                    for (event, _) in &mut self.inner {\n                         if let Event::End(Tag::FootnoteDefinition(..)) = event {\n                             break;\n                         }\n@@ -607,7 +609,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for Footnotes<'a, I> {\n                             ret.push_str(\"</li>\");\n                         }\n                         ret.push_str(\"</ol></div>\");\n-                        return Some(Event::Html(ret.into()));\n+                        return Some((Event::Html(ret.into()), 0..0));\n                     } else {\n                         return None;\n                     }\n@@ -917,13 +919,14 @@ impl Markdown<'_> {\n         };\n \n         let p = Parser::new_with_broken_link_callback(md, opts(), Some(&mut replacer));\n+        let p = p.into_offset_iter();\n \n         let mut s = String::with_capacity(md.len() * 3 / 2);\n \n         let p = HeadingLinks::new(p, None, &mut ids);\n-        let p = LinkReplacer::new(p, links);\n-        let p = CodeBlocks::new(p, codes, edition, playground);\n         let p = Footnotes::new(p);\n+        let p = LinkReplacer::new(p.map(|(ev, _)| ev), links);\n+        let p = CodeBlocks::new(p, codes, edition, playground);\n         html::push_html(&mut s, p);\n \n         s\n@@ -934,16 +937,16 @@ impl MarkdownWithToc<'_> {\n     crate fn into_string(self) -> String {\n         let MarkdownWithToc(md, mut ids, codes, edition, playground) = self;\n \n-        let p = Parser::new_ext(md, opts());\n+        let p = Parser::new_ext(md, opts()).into_offset_iter();\n \n         let mut s = String::with_capacity(md.len() * 3 / 2);\n \n         let mut toc = TocBuilder::new();\n \n         {\n             let p = HeadingLinks::new(p, Some(&mut toc), &mut ids);\n-            let p = CodeBlocks::new(p, codes, edition, playground);\n             let p = Footnotes::new(p);\n+            let p = CodeBlocks::new(p.map(|(ev, _)| ev), codes, edition, playground);\n             html::push_html(&mut s, p);\n         }\n \n@@ -959,19 +962,19 @@ impl MarkdownHtml<'_> {\n         if md.is_empty() {\n             return String::new();\n         }\n-        let p = Parser::new_ext(md, opts());\n+        let p = Parser::new_ext(md, opts()).into_offset_iter();\n \n         // Treat inline HTML as plain text.\n-        let p = p.map(|event| match event {\n-            Event::Html(text) => Event::Text(text),\n+        let p = p.map(|event| match event.0 {\n+            Event::Html(text) => (Event::Text(text), event.1),\n             _ => event,\n         });\n \n         let mut s = String::with_capacity(md.len() * 3 / 2);\n \n         let p = HeadingLinks::new(p, None, &mut ids);\n-        let p = CodeBlocks::new(p, codes, edition, playground);\n         let p = Footnotes::new(p);\n+        let p = CodeBlocks::new(p.map(|(ev, _)| ev), codes, edition, playground);\n         html::push_html(&mut s, p);\n \n         s\n@@ -1153,15 +1156,16 @@ crate fn markdown_links(md: &str) -> Vec<(String, Option<Range<usize>>)> {\n             shortcut_links.push((link.reference.to_owned(), locate(link.reference)));\n             None\n         };\n-        let p = Parser::new_with_broken_link_callback(md, opts(), Some(&mut push));\n+        let p =\n+            Parser::new_with_broken_link_callback(md, opts(), Some(&mut push)).into_offset_iter();\n \n         // There's no need to thread an IdMap through to here because\n         // the IDs generated aren't going to be emitted anywhere.\n         let mut ids = IdMap::new();\n         let iter = Footnotes::new(HeadingLinks::new(p, None, &mut ids));\n \n         for ev in iter {\n-            if let Event::Start(Tag::Link(_, dest, _)) = ev {\n+            if let Event::Start(Tag::Link(_, dest, _)) = ev.0 {\n                 debug!(\"found link: {}\", dest);\n                 links.push(match dest {\n                     CowStr::Borrowed(s) => (s.to_owned(), locate(s)),"}]}