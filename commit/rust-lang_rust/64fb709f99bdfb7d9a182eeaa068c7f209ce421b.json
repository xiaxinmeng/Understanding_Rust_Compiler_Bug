{"sha": "64fb709f99bdfb7d9a182eeaa068c7f209ce421b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0ZmI3MDlmOTliZGZiN2Q5YTE4MmVlYWEwNjhjN2YyMDljZTQyMWI=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-09-20T11:00:18Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-09-22T16:53:53Z"}, "message": "Use Names in hir::{Field, ExprMethodCall, ExprField}", "tree": {"sha": "0889ebc296016118f1c76f37c974b386f94fe7d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0889ebc296016118f1c76f37c974b386f94fe7d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64fb709f99bdfb7d9a182eeaa068c7f209ce421b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64fb709f99bdfb7d9a182eeaa068c7f209ce421b", "html_url": "https://github.com/rust-lang/rust/commit/64fb709f99bdfb7d9a182eeaa068c7f209ce421b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4af95878630688f9c24a1170f73561f0f15397e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4af95878630688f9c24a1170f73561f0f15397e", "html_url": "https://github.com/rust-lang/rust/commit/a4af95878630688f9c24a1170f73561f0f15397e"}], "stats": {"total": 170, "additions": 79, "deletions": 91}, "files": [{"sha": "9e7ef0187c2718b1c38b26960c7fc8972413dd03", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=64fb709f99bdfb7d9a182eeaa068c7f209ce421b", "patch": "@@ -314,7 +314,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<hir::Pat>\n             let field_pats = fields.iter().map(|field| codemap::Spanned {\n                 span: codemap::DUMMY_SP,\n                 node: hir::FieldPat {\n-                    ident: field.ident.node,\n+                    ident: ast::Ident::new(field.name.node),\n                     pat: const_expr_to_pat(tcx, &*field.expr, span),\n                     is_shorthand: false,\n                 },\n@@ -1040,8 +1040,8 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                 if let hir::ExprStruct(_, ref fields, _) = tcx.map.expect_expr(struct_id).node {\n                     // Check that the given field exists and evaluate it\n                     // if the idents are compared run-pass/issue-19244 fails\n-                    if let Some(f) = fields.iter().find(|f| f.ident.node.name\n-                                                         == field_name.node.name) {\n+                    if let Some(f) = fields.iter().find(|f| f.name.node\n+                                                         == field_name.node) {\n                         return eval_const_expr_partial(tcx, &*f.expr, base_hint)\n                     } else {\n                         signal!(e, MissingStructField);"}, {"sha": "b234a6166a41c1100d5b4431c593627b576f878d", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=64fb709f99bdfb7d9a182eeaa068c7f209ce421b", "patch": "@@ -227,8 +227,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n             hir::ExprMethodCall(..) => {\n                 self.lookup_and_handle_method(expr.id);\n             }\n-            hir::ExprField(ref lhs, ref ident) => {\n-                self.handle_field_access(&**lhs, ident.node.name);\n+            hir::ExprField(ref lhs, ref name) => {\n+                self.handle_field_access(&**lhs, name.node);\n             }\n             hir::ExprTupField(ref lhs, idx) => {\n                 self.handle_tup_field_access(&**lhs, idx.node);"}, {"sha": "a8eb109398a78395af9ec8fe99644a69536ce481", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=64fb709f99bdfb7d9a182eeaa068c7f209ce421b", "patch": "@@ -710,7 +710,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                                 -> bool\n         {\n             fields.iter().any(\n-                |f| f.ident.node.name == field.name)\n+                |f| f.name.node == field.name)\n         }\n     }\n "}, {"sha": "f3629c6641697824562ed1456ae46b7eaebb749b", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=64fb709f99bdfb7d9a182eeaa068c7f209ce421b", "patch": "@@ -474,7 +474,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n                    expr.id,\n                    expr,\n                    base_cmt);\n-            Ok(self.cat_field(expr, base_cmt, f_name.node.name, expr_ty))\n+            Ok(self.cat_field(expr, base_cmt, f_name.node, expr_ty))\n           }\n \n           hir::ExprTupField(ref base, idx) => {"}, {"sha": "6f55ddfdfd2017dc013a2c20a78d1c469c8aec19", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=64fb709f99bdfb7d9a182eeaa068c7f209ce421b", "patch": "@@ -16,7 +16,7 @@ use util::nodemap::FnvHashMap;\n use syntax::ast;\n use rustc_front::hir;\n use rustc_front::util::walk_pat;\n-use syntax::codemap::{Span, DUMMY_SP};\n+use syntax::codemap::{Span, Spanned, DUMMY_SP};\n \n pub type PatIdMap = FnvHashMap<ast::Ident, ast::NodeId>;\n \n@@ -109,7 +109,7 @@ pub fn pat_is_binding_or_wild(dm: &DefMap, pat: &hir::Pat) -> bool {\n /// Call `it` on every \"binding\" in a pattern, e.g., on `a` in\n /// `match foo() { Some(a) => (), None => () }`\n pub fn pat_bindings<I>(dm: &DefMap, pat: &hir::Pat, mut it: I) where\n-    I: FnMut(hir::BindingMode, ast::NodeId, Span, &hir::SpannedIdent),\n+    I: FnMut(hir::BindingMode, ast::NodeId, Span, &Spanned<ast::Ident>),\n {\n     walk_pat(pat, |p| {\n         match p.node {"}, {"sha": "6ff6e8e3d0f11e423d7296b3d1db19d318f5e9a1", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=64fb709f99bdfb7d9a182eeaa068c7f209ce421b", "patch": "@@ -418,7 +418,7 @@ pub fn check_expr(tcx: &ty::ctxt, e: &hir::Expr,\n         hir::ExprField(ref base_e, ref field) => {\n             span = field.span;\n             match tcx.expr_ty_adjusted(base_e).sty {\n-                ty::TyStruct(def, _) => def.struct_variant().field_named(field.node.name).did,\n+                ty::TyStruct(def, _) => def.struct_variant().field_named(field.node).did,\n                 _ => tcx.sess.span_bug(e.span,\n                                        \"stability::check_expr: named field access on non-struct\")\n             }\n@@ -441,7 +441,7 @@ pub fn check_expr(tcx: &ty::ctxt, e: &hir::Expr,\n                     // in the construction expression.\n                     for field in expr_fields {\n                         let did = def.struct_variant()\n-                            .field_named(field.ident.node.name)\n+                            .field_named(field.name.node)\n                             .did;\n                         maybe_do_stability_check(tcx, did, field.span, cb);\n                     }"}, {"sha": "7004e72f8f581685a0533a31f94cf21172ba797d", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=64fb709f99bdfb7d9a182eeaa068c7f209ce421b", "patch": "@@ -270,7 +270,7 @@ mod svh_visitor {\n             ExprBlock(..)            => SawExprBlock,\n             ExprAssign(..)           => SawExprAssign,\n             ExprAssignOp(op, _, _)   => SawExprAssignOp(op.node),\n-            ExprField(_, id)         => SawExprField(id.node.name.as_str()),\n+            ExprField(_, name)       => SawExprField(name.node.as_str()),\n             ExprTupField(_, id)      => SawExprTupField(id.node),\n             ExprIndex(..)            => SawExprIndex,\n             ExprRange(..)            => SawExprRange,"}, {"sha": "e0e4539872ec191a8de1923a89cfb450ddb10d0a", "filename": "src/librustc_front/fold.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc_front%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc_front%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Ffold.rs?ref=64fb709f99bdfb7d9a182eeaa068c7f209ce421b", "patch": "@@ -721,9 +721,9 @@ pub fn noop_fold_struct_field<T: Folder>(f: StructField, fld: &mut T) -> StructF\n     }\n }\n \n-pub fn noop_fold_field<T: Folder>(Field {ident, expr, span}: Field, folder: &mut T) -> Field {\n+pub fn noop_fold_field<T: Folder>(Field {name, expr, span}: Field, folder: &mut T) -> Field {\n     Field {\n-        ident: respan(ident.span, fold_ident(folder, ident.node)),\n+        name: respan(folder.new_span(name.span), folder.fold_name(name.node)),\n         expr: folder.fold_expr(expr),\n         span: folder.new_span(span)\n     }\n@@ -1050,9 +1050,9 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n                 ExprCall(folder.fold_expr(f),\n                          args.move_map(|x| folder.fold_expr(x)))\n             }\n-            ExprMethodCall(i, tps, args) => {\n+            ExprMethodCall(name, tps, args) => {\n                 ExprMethodCall(\n-                    respan(folder.new_span(i.span), fold_ident(folder, i.node)),\n+                    respan(folder.new_span(name.span), folder.fold_name(name.node)),\n                     tps.move_map(|x| folder.fold_ty(x)),\n                     args.move_map(|x| folder.fold_expr(x)))\n             }\n@@ -1102,10 +1102,10 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n                             folder.fold_expr(el),\n                             folder.fold_expr(er))\n             }\n-            ExprField(el, ident) => {\n+            ExprField(el, name) => {\n                 ExprField(folder.fold_expr(el),\n-                          respan(folder.new_span(ident.span),\n-                                 fold_ident(folder, ident.node)))\n+                          respan(folder.new_span(name.span),\n+                                 folder.fold_name(name.node)))\n             }\n             ExprTupField(el, ident) => {\n                 ExprTupField(folder.fold_expr(el),"}, {"sha": "5585833a39ffd5f07de88e4958b1735eb03544a8", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=64fb709f99bdfb7d9a182eeaa068c7f209ce421b", "patch": "@@ -52,10 +52,6 @@ use util;\n use std::fmt;\n use serialize::{Encodable, Encoder, Decoder};\n \n-\n-/// Function name (not all functions have names)\n-pub type FnIdent = Option<Ident>;\n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct Lifetime {\n     pub id: NodeId,\n@@ -416,7 +412,7 @@ pub enum Pat_ {\n     /// which it is. The resolver determines this, and\n     /// records this pattern's NodeId in an auxiliary\n     /// set (of \"PatIdents that refer to nullary enums\")\n-    PatIdent(BindingMode, SpannedIdent, Option<P<Pat>>),\n+    PatIdent(BindingMode, Spanned<Ident>, Option<P<Pat>>),\n \n     /// \"None\" means a * pattern where we don't bind the fields to names.\n     PatEnum(Path, Option<Vec<P<Pat>>>),\n@@ -564,13 +560,11 @@ pub struct Arm {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Field {\n-    pub ident: SpannedIdent,\n+    pub name: Spanned<Name>,\n     pub expr: P<Expr>,\n     pub span: Span,\n }\n \n-pub type SpannedIdent = Spanned<Ident>;\n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum BlockCheckMode {\n     DefaultBlock,\n@@ -612,7 +606,7 @@ pub enum Expr_ {\n     ExprCall(P<Expr>, Vec<P<Expr>>),\n     /// A method call (`x.foo::<Bar, Baz>(a, b, c, d)`)\n     ///\n-    /// The `SpannedIdent` is the identifier for the method name.\n+    /// The `Spanned<Name>` is the identifier for the method name.\n     /// The vector of `Ty`s are the ascripted type parameters for the method\n     /// (within the angle brackets).\n     ///\n@@ -622,7 +616,7 @@ pub enum Expr_ {\n     ///\n     /// Thus, `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n     /// `ExprMethodCall(foo, [Bar, Baz], [x, a, b, c, d])`.\n-    ExprMethodCall(SpannedIdent, Vec<P<Ty>>, Vec<P<Expr>>),\n+    ExprMethodCall(Spanned<Name>, Vec<P<Ty>>, Vec<P<Expr>>),\n     /// A tuple (`(a, b, c ,d)`)\n     ExprTup(Vec<P<Expr>>),\n     /// A binary operation (For example: `a + b`, `a * b`)\n@@ -662,7 +656,7 @@ pub enum Expr_ {\n     /// For example, `a += 1`.\n     ExprAssignOp(BinOp, P<Expr>, P<Expr>),\n     /// Access of a named struct field (`obj.foo`)\n-    ExprField(P<Expr>, SpannedIdent),\n+    ExprField(P<Expr>, Spanned<Name>),\n     /// Access of an unnamed field of a struct or tuple-struct\n     ///\n     /// For example, `foo.0`.\n@@ -682,9 +676,9 @@ pub enum Expr_ {\n     /// A referencing operation (`&a` or `&mut a`)\n     ExprAddrOf(Mutability, P<Expr>),\n     /// A `break`, with an optional label to break\n-    ExprBreak(Option<SpannedIdent>),\n+    ExprBreak(Option<Spanned<Ident>>),\n     /// A `continue`, with an optional label\n-    ExprAgain(Option<SpannedIdent>),\n+    ExprAgain(Option<Spanned<Ident>>),\n     /// A `return`, with an optional value to be returned\n     ExprRet(Option<P<Expr>>),\n \n@@ -744,13 +738,6 @@ pub struct MutTy {\n     pub mutbl: Mutability,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct TypeField {\n-    pub ident: Ident,\n-    pub mt: MutTy,\n-    pub span: Span,\n-}\n-\n /// Represents a method's signature in a trait declaration,\n /// or in an implementation.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]"}, {"sha": "2ce80e95302e88a2d83800c256723893a7aab73f", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=64fb709f99bdfb7d9a182eeaa068c7f209ce421b", "patch": "@@ -14,7 +14,7 @@ use hir;\n \n use syntax::ast::*;\n use syntax::ptr::P;\n-use syntax::codemap::Spanned;\n+use syntax::codemap::{respan, Spanned};\n use syntax::owned_slice::OwnedSlice;\n \n \n@@ -370,7 +370,10 @@ pub fn lower_struct_field(f: &StructField) -> hir::StructField {\n }\n \n pub fn lower_field(f: &Field) -> hir::Field {\n-    hir::Field { ident: f.ident, expr: lower_expr(&f.expr), span: f.span }\n+    hir::Field {\n+        name: respan(f.ident.span, f.ident.node.name),\n+        expr: lower_expr(&f.expr), span: f.span\n+    }\n }\n \n pub fn lower_mt(mt: &MutTy) -> hir::MutTy {\n@@ -704,7 +707,7 @@ pub fn lower_expr(e: &Expr) -> P<hir::Expr> {\n                 }\n                 ExprMethodCall(i, ref tps, ref args) => {\n                     hir::ExprMethodCall(\n-                        i,\n+                        respan(i.span, i.node.name),\n                         tps.iter().map(|x| lower_ty(x)).collect(),\n                         args.iter().map(|x| lower_expr(x)).collect())\n                 }\n@@ -755,7 +758,7 @@ pub fn lower_expr(e: &Expr) -> P<hir::Expr> {\n                                 lower_expr(er))\n                 }\n                 ExprField(ref el, ident) => {\n-                    hir::ExprField(lower_expr(el), ident)\n+                    hir::ExprField(lower_expr(el), respan(ident.span, ident.node.name))\n                 }\n                 ExprTupField(ref el, ident) => {\n                     hir::ExprTupField(lower_expr(el), ident)"}, {"sha": "ba4c61c83a02ed18b9f2fa550f23d65ee5f19981", "filename": "src/librustc_front/print/pprust.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpprust.rs?ref=64fb709f99bdfb7d9a182eeaa068c7f209ce421b", "patch": "@@ -13,7 +13,7 @@ pub use self::AnnNode::*;\n use syntax::abi;\n use syntax::ast;\n use syntax::owned_slice::OwnedSlice;\n-use syntax::codemap::{self, CodeMap, BytePos};\n+use syntax::codemap::{self, CodeMap, BytePos, Spanned};\n use syntax::diagnostic;\n use syntax::parse::token::{self, BinOpToken};\n use syntax::parse::lexer::comments;\n@@ -1223,7 +1223,7 @@ impl<'a> State<'a> {\n             &fields[..],\n             |s, field| {\n                 try!(s.ibox(indent_unit));\n-                try!(s.print_ident(field.ident.node));\n+                try!(s.print_name(field.name.node));\n                 try!(s.word_space(\":\"));\n                 try!(s.print_expr(&*field.expr));\n                 s.end()\n@@ -1265,13 +1265,13 @@ impl<'a> State<'a> {\n     }\n \n     fn print_expr_method_call(&mut self,\n-                              ident: hir::SpannedIdent,\n+                              name: Spanned<ast::Name>,\n                               tys: &[P<hir::Ty>],\n                               args: &[P<hir::Expr>]) -> io::Result<()> {\n         let base_args = &args[1..];\n         try!(self.print_expr(&*args[0]));\n         try!(word(&mut self.s, \".\"));\n-        try!(self.print_ident(ident.node));\n+        try!(self.print_name(name.node));\n         if !tys.is_empty() {\n             try!(word(&mut self.s, \"::<\"));\n             try!(self.commasep(Inconsistent, tys,\n@@ -1329,8 +1329,8 @@ impl<'a> State<'a> {\n             hir::ExprCall(ref func, ref args) => {\n                 try!(self.print_expr_call(&**func, &args[..]));\n             }\n-            hir::ExprMethodCall(ident, ref tys, ref args) => {\n-                try!(self.print_expr_method_call(ident, &tys[..], &args[..]));\n+            hir::ExprMethodCall(name, ref tys, ref args) => {\n+                try!(self.print_expr_method_call(name, &tys[..], &args[..]));\n             }\n             hir::ExprBinary(op, ref lhs, ref rhs) => {\n                 try!(self.print_expr_binary(op, &**lhs, &**rhs));\n@@ -1435,10 +1435,10 @@ impl<'a> State<'a> {\n                 try!(self.word_space(\"=\"));\n                 try!(self.print_expr(&**rhs));\n             }\n-            hir::ExprField(ref expr, id) => {\n+            hir::ExprField(ref expr, name) => {\n                 try!(self.print_expr(&**expr));\n                 try!(word(&mut self.s, \".\"));\n-                try!(self.print_ident(id.node));\n+                try!(self.print_name(name.node));\n             }\n             hir::ExprTupField(ref expr, id) => {\n                 try!(self.print_expr(&**expr));"}, {"sha": "78f23fcd71ceb4326995cb7034f15e58f7d631d4", "filename": "src/librustc_mir/tcx/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs?ref=64fb709f99bdfb7d9a182eeaa068c7f209ce421b", "patch": "@@ -288,9 +288,9 @@ impl<'a,'tcx:'a> Mirror<Cx<'a,'tcx>> for &'tcx hir::Expr {\n             hir::ExprLoop(ref body, _) =>\n                 ExprKind::Loop { condition: None,\n                                  body: block::to_expr_ref(cx, body) },\n-            hir::ExprField(ref source, ident) =>\n+            hir::ExprField(ref source, name) =>\n                 ExprKind::Field { lhs: source.to_ref(),\n-                                  name: Field::Named(ident.node.name) },\n+                                  name: Field::Named(name.node) },\n             hir::ExprTupField(ref source, ident) =>\n                 ExprKind::Field { lhs: source.to_ref(),\n                                   name: Field::Indexed(ident.node) },"}, {"sha": "3c8a5534e1ade4b0fb57854232f46e7844625fa9", "filename": "src/librustc_mir/tcx/to_ref.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc_mir%2Ftcx%2Fto_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc_mir%2Ftcx%2Fto_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fto_ref.rs?ref=64fb709f99bdfb7d9a182eeaa068c7f209ce421b", "patch": "@@ -86,9 +86,8 @@ impl<'a,'tcx:'a> ToRef<Cx<'a,'tcx>> for &'tcx hir::Field {\n \n     fn to_ref(self) -> FieldExprRef<Cx<'a,'tcx>> {\n         FieldExprRef {\n-            name: Field::Named(self.ident.node.name),\n+            name: Field::Named(self.name.node),\n             expr: self.expr.to_ref()\n         }\n     }\n }\n-"}, {"sha": "d077ee451fb801c798c8c218db0e537a938c0882", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=64fb709f99bdfb7d9a182eeaa068c7f209ce421b", "patch": "@@ -866,12 +866,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &hir::Expr) {\n         match expr.node {\n-            hir::ExprField(ref base, ident) => {\n+            hir::ExprField(ref base, name) => {\n                 if let ty::TyStruct(def, _) = self.tcx.expr_ty_adjusted(&**base).sty {\n                     self.check_field(expr.span,\n                                      def,\n                                      def.struct_variant(),\n-                                     NamedField(ident.node.name));\n+                                     NamedField(name.node));\n                 }\n             }\n             hir::ExprTupField(ref base, idx) => {\n@@ -882,11 +882,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                                      UnnamedField(idx.node));\n                 }\n             }\n-            hir::ExprMethodCall(ident, _, _) => {\n+            hir::ExprMethodCall(name, _, _) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n                 let method = self.tcx.tables.borrow().method_map[&method_call];\n                 debug!(\"(privacy checking) checking impl method\");\n-                self.check_method(expr.span, method.def_id, ident.node.name);\n+                self.check_method(expr.span, method.def_id, name.node);\n             }\n             hir::ExprStruct(..) => {\n                 let adt = self.tcx.expr_ty(expr).ty_adt_def().unwrap();"}, {"sha": "04e90be5363a4c8f6538d96b36965d4075f575cc", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=64fb709f99bdfb7d9a182eeaa068c7f209ce421b", "patch": "@@ -3817,19 +3817,19 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn record_candidate_traits_for_expr_if_necessary(&mut self, expr: &Expr) {\n         match expr.node {\n-            ExprField(_, ident) => {\n+            ExprField(_, name) => {\n                 // FIXME(#6890): Even though you can't treat a method like a\n                 // field, we need to add any trait methods we find that match\n                 // the field name so that we can do some nice error reporting\n                 // later on in typeck.\n-                let traits = self.get_traits_containing_item(ident.node.name);\n+                let traits = self.get_traits_containing_item(name.node);\n                 self.trait_map.insert(expr.id, traits);\n             }\n-            ExprMethodCall(ident, _, _) => {\n+            ExprMethodCall(name, _, _) => {\n                 debug!(\"(recording candidate traits for expr) recording \\\n                         traits for {}\",\n                        expr.id);\n-                let traits = self.get_traits_containing_item(ident.node.name);\n+                let traits = self.get_traits_containing_item(name.node);\n                 self.trait_map.insert(expr.id, traits);\n             }\n             _ => {"}, {"sha": "cccc610601c8e8fc0392e2672082c31a5e00815a", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=64fb709f99bdfb7d9a182eeaa068c7f209ce421b", "patch": "@@ -1436,7 +1436,7 @@ fn is_discr_reassigned(bcx: Block, discr: &hir::Expr, body: &hir::Expr) -> bool\n                 Some(def::DefLocal(vid)) | Some(def::DefUpvar(vid, _, _)) => vid,\n                 _ => return false\n             };\n-            (vid, Some(mc::NamedField(field.node.name)))\n+            (vid, Some(mc::NamedField(field.node)))\n         },\n         hir::ExprTupField(ref base, field) => {\n             let vid = match bcx.tcx().def_map.borrow().get(&base.id).map(|d| d.full_def()) {"}, {"sha": "ccf602126eb2c72defbd19f333cb7c5bef95c343", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=64fb709f99bdfb7d9a182eeaa068c7f209ce421b", "patch": "@@ -574,7 +574,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let (bv, bt) = const_expr(cx, &**base, param_substs, fn_args);\n             let brepr = adt::represent_type(cx, bt);\n             let vinfo = VariantInfo::from_ty(cx.tcx(), bt, None);\n-            let ix = vinfo.field_index(field.node.name);\n+            let ix = vinfo.field_index(field.node);\n             adt::const_get_field(cx, &*brepr, bv, vinfo.discr, ix)\n         },\n         hir::ExprTupField(ref base, idx) => {\n@@ -742,7 +742,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             let VariantInfo { discr, fields } = VariantInfo::of_node(cx.tcx(), ety, e.id);\n             let cs = fields.iter().enumerate().map(|(ix, &Field(f_name, _))| {\n-                match (fs.iter().find(|f| f_name == f.ident.node.name), base_val) {\n+                match (fs.iter().find(|f| f_name == f.name.node), base_val) {\n                     (Some(ref f), _) => const_expr(cx, &*f.expr, param_substs, fn_args).0,\n                     (_, Some((bv, _))) => adt::const_get_field(cx, &*repr, bv, discr, ix),\n                     (_, None) => cx.sess().span_bug(e.span, \"missing struct field\"),"}, {"sha": "f2dcf84d41920448498fae36ed2b641711f0817f", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=64fb709f99bdfb7d9a182eeaa068c7f209ce421b", "patch": "@@ -664,8 +664,8 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         hir::ExprPath(..) => {\n             trans_def(bcx, expr, bcx.def(expr.id))\n         }\n-        hir::ExprField(ref base, ident) => {\n-            trans_rec_field(bcx, &**base, ident.node.name)\n+        hir::ExprField(ref base, name) => {\n+            trans_rec_field(bcx, &**base, name.node)\n         }\n         hir::ExprTupField(ref base, idx) => {\n             trans_rec_tup_field(bcx, &**base, idx.node)\n@@ -1114,7 +1114,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             // trans. Shudder.\n             fn make_field(field_name: &str, expr: P<hir::Expr>) -> hir::Field {\n                 hir::Field {\n-                    ident: codemap::dummy_spanned(token::str_to_ident(field_name)),\n+                    name: codemap::dummy_spanned(token::str_to_ident(field_name).name),\n                     expr: expr,\n                     span: codemap::DUMMY_SP,\n                 }\n@@ -1408,7 +1408,7 @@ fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let mut need_base = vec![true; vinfo.fields.len()];\n \n     let numbered_fields = fields.iter().map(|field| {\n-        let pos = vinfo.field_index(field.ident.node.name);\n+        let pos = vinfo.field_index(field.name.node);\n         need_base[pos] = false;\n         (pos, &*field.expr)\n     }).collect::<Vec<_>>();"}, {"sha": "ff7acbf741c82096682ede1cff5e5f2515e5d69f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64fb709f99bdfb7d9a182eeaa068c7f209ce421b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=64fb709f99bdfb7d9a182eeaa068c7f209ce421b", "patch": "@@ -119,7 +119,7 @@ use syntax::abi;\n use syntax::ast;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n-use syntax::codemap::{self, Span};\n+use syntax::codemap::{self, Span, Spanned};\n use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token::{self, InternedString};\n use syntax::ptr::P;\n@@ -2820,7 +2820,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n     // Checks a method call.\n     fn check_method_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                    expr: &'tcx hir::Expr,\n-                                   method_name: hir::SpannedIdent,\n+                                   method_name: Spanned<ast::Name>,\n                                    args: &'tcx [P<hir::Expr>],\n                                    tps: &[P<hir::Ty>],\n                                    expected: Expectation<'tcx>,\n@@ -2836,7 +2836,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let tps = tps.iter().map(|ast_ty| fcx.to_ty(&**ast_ty)).collect::<Vec<_>>();\n         let fn_ty = match method::lookup(fcx,\n                                          method_name.span,\n-                                         method_name.node.name,\n+                                         method_name.node,\n                                          expr_t,\n                                          tps,\n                                          expr,\n@@ -2849,7 +2849,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n             Err(error) => {\n                 method::report_error(fcx, method_name.span, expr_t,\n-                                     method_name.node.name, Some(rcvr), error);\n+                                     method_name.node, Some(rcvr), error);\n                 fcx.write_error(expr.id);\n                 fcx.tcx().types.err\n             }\n@@ -2916,7 +2916,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                             expr: &'tcx hir::Expr,\n                             lvalue_pref: LvaluePreference,\n                             base: &'tcx hir::Expr,\n-                            field: &hir::SpannedIdent) {\n+                            field: &Spanned<ast::Name>) {\n         let tcx = fcx.ccx.tcx;\n         check_expr_with_lvalue_pref(fcx, base, lvalue_pref);\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n@@ -2933,7 +2933,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     ty::TyStruct(base_def, substs) => {\n                         debug!(\"struct named {:?}\",  base_t);\n                         base_def.struct_variant()\n-                                .find_field_named(field.node.name)\n+                                .find_field_named(field.node)\n                                 .map(|f| fcx.field_ty(expr.span, f, substs))\n                     }\n                     _ => None\n@@ -2948,7 +2948,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             None => {}\n         }\n \n-        if method::exists(fcx, field.span, field.node.name, expr_t, expr.id) {\n+        if method::exists(fcx, field.span, field.node, expr_t, expr.id) {\n             fcx.type_error_message(\n                 field.span,\n                 |actual| {\n@@ -2981,10 +2981,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n     // displays hints about the closest matches in field names\n     fn suggest_field_names<'tcx>(variant: ty::VariantDef<'tcx>,\n-                                 field: &hir::SpannedIdent,\n+                                 field: &Spanned<ast::Name>,\n                                  tcx: &ty::ctxt<'tcx>,\n                                  skip : Vec<InternedString>) {\n-        let name = field.node.name.as_str();\n+        let name = field.node.as_str();\n         // only find fits with at least one matching letter\n         let mut best_dist = name.len();\n         let mut best = None;\n@@ -3082,22 +3082,21 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                       field: &hir::Field,\n                                       skip_fields: &[hir::Field]) {\n         fcx.type_error_message(\n-            field.ident.span,\n+            field.name.span,\n             |actual| if let ty::TyEnum(..) = ty.sty {\n                 format!(\"struct variant `{}::{}` has no field named `{}`\",\n-                        actual, variant.name.as_str(), field.ident.node)\n+                        actual, variant.name.as_str(), field.name.node)\n             } else {\n                 format!(\"structure `{}` has no field named `{}`\",\n-                        actual, field.ident.node)\n+                        actual, field.name.node)\n             },\n             ty,\n             None);\n         // prevent all specified fields from being suggested\n-        let skip_fields = skip_fields.iter().map(|ref x| x.ident.node.name.as_str());\n-        suggest_field_names(variant, &field.ident, fcx.tcx(), skip_fields.collect());\n+        let skip_fields = skip_fields.iter().map(|ref x| x.name.node.as_str());\n+        suggest_field_names(variant, &field.name, fcx.tcx(), skip_fields.collect());\n     }\n \n-\n     fn check_expr_struct_fields<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                           adt_ty: Ty<'tcx>,\n                                           span: Span,\n@@ -3121,15 +3120,15 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         for field in ast_fields {\n             let expected_field_type;\n \n-            if let Some(v_field) = remaining_fields.remove(&field.ident.node.name) {\n+            if let Some(v_field) = remaining_fields.remove(&field.name.node) {\n                 expected_field_type = fcx.field_ty(field.span, v_field, substs);\n             } else {\n                 error_happened = true;\n                 expected_field_type = tcx.types.err;\n-                if let Some(_) = variant.find_field_named(field.ident.node.name) {\n-                    span_err!(fcx.tcx().sess, field.ident.span, E0062,\n+                if let Some(_) = variant.find_field_named(field.name.node) {\n+                    span_err!(fcx.tcx().sess, field.name.span, E0062,\n                         \"field `{}` specified more than once\",\n-                        field.ident.node);\n+                        field.name.node);\n                 } else {\n                     report_unknown_field(fcx, adt_ty, variant, field, ast_fields);\n                 }\n@@ -3506,8 +3505,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           let ret_ty = fcx.expr_ty(expr);\n           fcx.register_wf_obligation(ret_ty, expr.span, traits::MiscObligation);\n       }\n-      hir::ExprMethodCall(ident, ref tps, ref args) => {\n-          check_method_call(fcx, expr, ident, &args[..], &tps[..], expected, lvalue_pref);\n+      hir::ExprMethodCall(name, ref tps, ref args) => {\n+          check_method_call(fcx, expr, name, &args[..], &tps[..], expected, lvalue_pref);\n           let arg_tys = args.iter().map(|a| fcx.expr_ty(&**a));\n           let args_err = arg_tys.fold(false, |rest_err, a| rest_err || a.references_error());\n           if args_err {"}]}