{"sha": "f424e931da4c04e410b003f48503acee92720ffb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0MjRlOTMxZGE0YzA0ZTQxMGIwMDNmNDg1MDNhY2VlOTI3MjBmZmI=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-06-28T15:11:50Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-07-19T05:55:24Z"}, "message": "debuginfo: Refactoring of composite type info generation done.\n\nThere is no more StructContext now. Better support for boxed vectors in there too.", "tree": {"sha": "90e6cac9c518e7a83f1f2c293c4a862f5501c338", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90e6cac9c518e7a83f1f2c293c4a862f5501c338"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f424e931da4c04e410b003f48503acee92720ffb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f424e931da4c04e410b003f48503acee92720ffb", "html_url": "https://github.com/rust-lang/rust/commit/f424e931da4c04e410b003f48503acee92720ffb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f424e931da4c04e410b003f48503acee92720ffb/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36ea75683105447cb9f8338cd2a70493f4eb2c70", "url": "https://api.github.com/repos/rust-lang/rust/commits/36ea75683105447cb9f8338cd2a70493f4eb2c70", "html_url": "https://github.com/rust-lang/rust/commit/36ea75683105447cb9f8338cd2a70493f4eb2c70"}], "stats": {"total": 381, "additions": 153, "deletions": 228}, "files": [{"sha": "a535333a19f92a255d77ed77549bd9c4fa1e9a06", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 119, "deletions": 228, "changes": 347, "blob_url": "https://github.com/rust-lang/rust/blob/f424e931da4c04e410b003f48503acee92720ffb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f424e931da4c04e410b003f48503acee92720ffb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=f424e931da4c04e410b003f48503acee92720ffb", "patch": "@@ -55,9 +55,7 @@ use middle::ty;\n use util::ppaux::ty_to_str;\n \n use std::hashmap::HashMap;\n-use std::libc;\n-use std::libc::{c_uint, c_ulonglong};\n-use std::cmp;\n+use std::libc::{c_uint, c_ulonglong, c_longlong};\n use std::ptr;\n use std::str::as_c_str;\n use std::sys;\n@@ -148,7 +146,7 @@ pub fn create_local_var(bcx: block, local: @ast::local) -> DIVariable {\n \n     let loc = span_start(cx, local.span);\n     let ty = node_id_type(bcx, local.node.id);\n-    let tymd = create_ty(cx, ty, local.node.ty.span);\n+    let tymd = get_or_create_ty(cx, ty, local.node.ty.span);\n     let filemd = get_or_create_file(cx, loc.file.name);\n     let context = match bcx.parent {\n         None => create_function(bcx.fcx),\n@@ -202,7 +200,7 @@ pub fn create_arg(bcx: block, arg: &ast::arg, span: span) -> Option<DIVariable>\n     }\n \n     let ty = node_id_type(bcx, arg.id);\n-    let tymd = create_ty(cx, ty, arg.ty.span);\n+    let tymd = get_or_create_ty(cx, ty, arg.ty.span);\n     let filemd = get_or_create_file(cx, loc.file.name);\n     let context = create_function(fcx);\n \n@@ -302,7 +300,7 @@ pub fn create_function(fcx: fn_ctxt) -> DISubprogram {\n     let ret_ty_md = if cx.sess.opts.extra_debuginfo {\n         match ret_ty.node {\n           ast::ty_nil => ptr::null(),\n-          _ => create_ty(cx, ty::node_id_to_type(cx.tcx, id), ret_ty.span)\n+          _ => get_or_create_ty(cx, ty::node_id_to_type(cx.tcx, id), ret_ty.span)\n         }\n     } else {\n         ptr::null()\n@@ -445,11 +443,6 @@ fn create_block(bcx: block) -> DILexicalBlock {\n \n \n fn create_basic_type(cx: &mut CrateContext, t: ty::t, _span: span) -> DIType {\n-    let ty_id = ty::type_id(t);\n-    match dbg_cx(cx).created_types.find(&ty_id) {\n-        Some(ty_md) => return *ty_md,\n-        None => ()\n-    }\n \n     debug!(\"create_basic_type: %?\", ty::get(t));\n \n@@ -489,10 +482,6 @@ fn create_basic_type(cx: &mut CrateContext, t: ty::t, _span: span) -> DIType {\n                 encoding as c_uint)\n         }};\n \n-    // One could think that this call is not necessary, as the create_ty() function will insert the\n-    // type descriptor into the cache anyway. Mind, however, that create_basic_type() is also called\n-    // directly from other functions (e.g. create_boxed_type()).\n-    dbg_cx(cx).created_types.insert(ty_id, ty_md);\n     return ty_md;\n }\n \n@@ -510,99 +499,19 @@ fn create_pointer_type(cx: &mut CrateContext, t: ty::t, _span: span, pointee: DI\n     return ptr_md;\n }\n \n-struct StructContext {\n-    builder: DIBuilderRef,\n-    file: DIFile,\n-    name: ~str,\n-    line: uint,\n-    members: ~[DIDerivedType],\n-    total_size: uint,\n-    align: uint\n-}\n-\n-impl StructContext {\n-    fn new(cx: &CrateContext, name: ~str, file: DIFile, line: uint) -> StructContext {\n-        debug!(\"StructContext::create: %s\", name);\n-        return StructContext {\n-            builder: DIB(cx),\n-            file: file,\n-            name: name,\n-            line: line,\n-            members: ~[],\n-            total_size: 0,\n-            align: 1\n-        };\n-    }\n-\n-    fn add_member(&mut self, name: &str, line: uint, size: uint, align: uint, ty: DIType) {\n-        let offset = roundup(self.total_size, align);\n-\n-        debug!(\"StructContext(%s)::add_member: %s, size=%u, align=%u, offset=%u\",\n-                self.name, name, size, align, offset);\n-\n-        let mem_t = do as_c_str(name) |name| { unsafe {\n-            llvm::LLVMDIBuilderCreateMemberType(\n-                self.builder,\n-                self.file,\n-                name,\n-                self.file,\n-                line as c_uint,\n-                bytes_to_bits(size),\n-                bytes_to_bits(align),\n-                bytes_to_bits(offset),\n-                0,\n-                ty)\n-            }};\n-        self.members.push(mem_t);\n-        self.total_size = offset + size;\n-        // struct alignment is the max alignment of its' members\n-        self.align = cmp::max(self.align, align);\n-    }\n-\n-    fn get_total_size_with_alignment(&self) -> uint {\n-        roundup(self.total_size, self.align)\n-    }\n-\n-    fn finalize(&self) -> DICompositeType {\n-        debug!(\"StructContext(%s)::finalize: total_size=%u, align=%u\",\n-                self.name, self.total_size, self.align);\n-        let members_md = create_DIArray(self.builder, self.members);\n-\n-        // The size of the struct/tuple must be rounded to the next multiple of its alignment.\n-        // Otherwise gdb has trouble reading the struct correctly when it is embedded into another\n-        // data structure. This is also the value `sizeof` in C would give.\n-        let actual_total_size = self.get_total_size_with_alignment();\n-\n-        let struct_md =\n-            do as_c_str(self.name) |name| { unsafe {\n-                llvm::LLVMDIBuilderCreateStructType(\n-                    self.builder,\n-                    self.file,\n-                    name,\n-                    self.file,\n-                    self.line as c_uint,\n-                    bytes_to_bits(actual_total_size),\n-                    bytes_to_bits(self.align),\n-                    0,\n-                    ptr::null(),\n-                    members_md,\n-                    0,\n-                    ptr::null())\n-            }};\n-        return struct_md;\n-    }\n-}\n-\n-fn create_struct(cx: &mut CrateContext, struct_type: ty::t, fields: ~[ty::field], span: span)\n-                -> DICompositeType {\n+fn create_struct(cx: &mut CrateContext,\n+                 struct_type: ty::t,\n+                 fields: ~[ty::field],\n+                 span: span)\n+              -> DICompositeType {\n     debug!(\"create_struct: %?\", ty::get(struct_type));\n \n     let struct_name = ty_to_str(cx.tcx, struct_type);\n     let struct_llvm_type = type_of::type_of(cx, struct_type);\n \n     let field_llvm_types = fields.map(|field| type_of::type_of(cx, field.mt.ty));\n     let field_names = fields.map(|field| cx.sess.str_of(field.ident).to_owned());\n-    let field_types_metadata = fields.map(|field| create_ty(cx, field.mt.ty, span));\n+    let field_types_metadata = fields.map(|field| get_or_create_ty(cx, field.mt.ty, span));\n \n     return create_composite_type(\n         cx,\n@@ -620,14 +529,14 @@ fn create_tuple(cx: &mut CrateContext,\n                 span: span)\n              -> DICompositeType {\n \n-    let tuple_name = (cx.sess.str_of((dbg_cx(cx).names)(\"tuple\"))).to_owned();\n+    let tuple_name = \"tuple\"; // TODO: better type name\n     let tuple_llvm_type = type_of::type_of(cx, tuple_type);\n     // Create a vec of empty strings. A vec::build_n() function would be nice for this.\n     let mut component_names : ~[~str] = vec::with_capacity(component_types.len());\n     component_names.grow_fn(component_types.len(), |_| ~\"\");\n \n     let component_llvm_types = component_types.map(|it| type_of::type_of(cx, *it));\n-    let component_types_metadata = component_types.map(|it| create_ty(cx, *it, span));\n+    let component_types_metadata = component_types.map(|it| get_or_create_ty(cx, *it, span));\n \n     return create_composite_type(\n         cx,\n@@ -641,7 +550,7 @@ fn create_tuple(cx: &mut CrateContext,\n \n /// Creates debug information for a composite type, that is, anything that results in a LLVM struct.\n ///\n-/// Examples of Rust types to use this are: structs, tuples, boxes, and enums.\n+/// Examples of Rust types to use this are: structs, tuples, boxes, vecs, and enums.\n fn create_composite_type(cx: &mut CrateContext,\n                          composite_llvm_type: Type,\n                          composite_type_name: &str,\n@@ -657,10 +566,10 @@ fn create_composite_type(cx: &mut CrateContext,\n     let composite_size = machine::llsize_of_alloc(cx, composite_llvm_type);\n     let composite_align = machine::llalign_of_min(cx, composite_llvm_type);\n \n-    let member_metadata = create_DIArray(\n-        DIB(cx),\n-        // transform the ty::t array of components into an array of DIEs\n-        do vec::mapi(member_llvm_types) |i, member_llvm_type| {\n+    let xxx : ~[DIDescriptor] = member_llvm_types\n+        .iter()\n+        .enumerate()\n+        .transform(|(i, member_llvm_type)| {\n             let member_size = machine::llsize_of_alloc(cx, *member_llvm_type);\n             let member_align = machine::llalign_of_min(cx, *member_llvm_type);\n             let member_offset = machine::llelement_offset(cx, composite_llvm_type, i);\n@@ -678,8 +587,32 @@ fn create_composite_type(cx: &mut CrateContext,\n                     bytes_to_bits(member_offset),\n                     0,\n                     member_type_metadata[i])\n-            }}\n-        });\n+            }}})\n+        .collect();\n+\n+    let member_metadata = create_DIArray(DIB(cx), xxx);\n+        // transform the ty::t array of components into an array of DIEs\n+        // do vec::mapi(member_llvm_types) |i, member_llvm_type| {\n+        // do member_llvm_types.iter().enumerate().transform |(i, member_llvm_type)| {\n+        //     let member_size = machine::llsize_of_alloc(cx, *member_llvm_type);\n+        //     let member_align = machine::llalign_of_min(cx, *member_llvm_type);\n+        //     let member_offset = machine::llelement_offset(cx, composite_llvm_type, i);\n+        //     let member_name : &str = member_names[i];\n+\n+        //     do member_name.as_c_str |member_name| { unsafe {\n+        //         llvm::LLVMDIBuilderCreateMemberType(\n+        //             DIB(cx),\n+        //             file_metadata,\n+        //             member_name,\n+        //             file_metadata,\n+        //             loc.line as c_uint,\n+        //             bytes_to_bits(member_size),\n+        //             bytes_to_bits(member_align),\n+        //             bytes_to_bits(member_offset),\n+        //             0,\n+        //             member_type_metadata[i])\n+        //     }}\n+        // }.collect());\n \n     return do composite_type_name.as_c_str |name| { unsafe {\n         llvm::LLVMDIBuilderCreateStructType(\n@@ -713,33 +646,12 @@ fn voidptr(cx: &mut CrateContext) -> (DIDerivedType, uint, uint) {\n     return (vp, size, align);\n }\n \n-fn create_tuple(cx: &mut CrateContext, tuple_type: ty::t, elements: &[ty::t], span: span)\n-                -> DICompositeType {\n-    debug!(\"create_tuple: %?\", ty::get(tuple_type));\n-\n-    let loc = span_start(cx, span);\n-    let file_md = create_file(cx, loc.file.name);\n-\n-    let name = fmt!(\"tuple_%u\", token::gensym(\"tuple\"));\n-    let mut scx = StructContext::new(cx, name, file_md, loc.line);\n-    for elements.iter().advance |element| {\n-        let ty_md = create_ty(cx, *element, span);\n-        let (size, align) = size_and_align_of(cx, *element);\n-        scx.add_member(\"\", loc.line, size, align, ty_md);\n-    }\n-    return scx.finalize();\n-}\n-\n fn create_boxed_type(cx: &mut CrateContext,\n-                     content_type: ty::t,\n+                     content_llvm_type: Type,\n+                     content_type_metadata: DIType,\n                      span: span)\n                   -> DICompositeType {\n \n-    debug!(\"create_boxed_type: %?\", ty::get(content_type));\n-\n-    let content_llvm_type = type_of::type_of(cx, content_type);\n-    let content_type_metadata = create_ty(cx, content_type, span);\n-\n     let box_llvm_type = Type::box(cx, &content_llvm_type);\n     let member_llvm_types = box_llvm_type.field_types();\n     let member_names = [~\"refcnt\", ~\"tydesc\", ~\"prev\", ~\"next\", ~\"val\"];\n@@ -750,10 +662,10 @@ fn create_boxed_type(cx: &mut CrateContext,\n     let nil_pointer_type = ty::mk_nil_ptr(cx.tcx);\n \n     let member_types_metadata = [\n-        create_ty(cx, int_type, span),\n-        create_ty(cx, nil_pointer_type, span),\n-        create_ty(cx, nil_pointer_type, span),\n-        create_ty(cx, nil_pointer_type, span),\n+        get_or_create_ty(cx, int_type, span),\n+        get_or_create_ty(cx, nil_pointer_type, span),\n+        get_or_create_ty(cx, nil_pointer_type, span),\n+        get_or_create_ty(cx, nil_pointer_type, span),\n         content_type_metadata\n     ];\n \n@@ -785,92 +697,60 @@ fn create_fixed_vec(cx: &mut CrateContext, _vec_t: ty::t, elem_t: ty::t,\n                     len: uint, span: span) -> DIType {\n     debug!(\"create_fixed_vec: %?\", ty::get(_vec_t));\n \n-    let elem_ty_md = create_ty(cx, elem_t, span);\n+    let elem_ty_md = get_or_create_ty(cx, elem_t, span);\n     let (size, align) = size_and_align_of(cx, elem_t);\n \n-    let subrange = unsafe {\n-        llvm::LLVMDIBuilderGetOrCreateSubrange(DIB(cx), 0_i64, len as i64)\n-    };\n+    let subrange = unsafe { llvm::LLVMDIBuilderGetOrCreateSubrange(\n+        DIB(cx),\n+        0,\n+        len as c_longlong\n+    )};\n \n     let subscripts = create_DIArray(DIB(cx), [subrange]);\n-    return unsafe {\n-        llvm::LLVMDIBuilderCreateArrayType(\n+    return unsafe { llvm::LLVMDIBuilderCreateArrayType(\n             DIB(cx),\n             bytes_to_bits(size * len),\n             bytes_to_bits(align),\n             elem_ty_md,\n-            subscripts)\n-    };\n+            subscripts\n+    )};\n }\n \n-fn create_boxed_vec(cx: &mut CrateContext, vec_t: ty::t, elem_t: ty::t,\n-                    vec_ty_span: span) -> DICompositeType {\n-    debug!(\"create_boxed_vec: %?\", ty::get(vec_t));\n-\n-    let loc = span_start(cx, vec_ty_span);\n-    let file_md = get_or_create_file(cx, loc.file.name);\n-    let elem_ty_md = create_ty(cx, elem_t, vec_ty_span);\n-\n-    let mut vec_scx = StructContext::new(cx, ty_to_str(cx.tcx, vec_t), file_md, 0);\n-    let size_t_type = create_basic_type(cx, ty::mk_uint(), vec_ty_span);\n+fn create_boxed_vec(cx: &mut CrateContext,\n+                    element_type: ty::t,\n+                    span: span)\n+                 -> DICompositeType {\n \n-    vec_scx.add_member(\n-        \"fill\",\n-        0,\n-        sys::size_of::<libc::size_t>(),\n-        sys::min_align_of::<libc::size_t>(),\n-        size_t_type);\n+    let element_type_metadata = get_or_create_ty(cx, element_type, span);\n+    let element_llvm_type = type_of::type_of(cx, element_type);\n+    let vec_llvm_type = Type::vec(cx.sess.targ_cfg.arch, &element_llvm_type);\n+    let vec_type_name = &\"vec\";\n \n-    vec_scx.add_member(\n-        \"alloc\",\n-        0,\n-        sys::size_of::<libc::size_t>(),\n-        sys::min_align_of::<libc::size_t>(),\n-        size_t_type);\n+    let member_llvm_types = vec_llvm_type.field_types();\n+    let member_names = &[~\"fill\", ~\"alloc\", ~\"elements\"];\n \n-    let subrange = unsafe {\n-        llvm::LLVMDIBuilderGetOrCreateSubrange(DIB(cx), 0_i64, 0_i64)\n-    };\n-    let (arr_size, arr_align) = size_and_align_of(cx, elem_t);\n-    let name = fmt!(\"[%s]\", ty_to_str(cx.tcx, elem_t));\n-\n-    let subscripts = create_DIArray(DIB(cx), [subrange]);\n-    let data_ptr = unsafe {\n-        llvm::LLVMDIBuilderCreateArrayType(\n-            DIB(cx),\n-            bytes_to_bits(arr_size),\n-            bytes_to_bits(arr_align),\n-            elem_ty_md,\n-            subscripts)\n+    let int_type_md = get_or_create_ty(cx, ty::mk_int(), span);\n+    let array_type_md = unsafe { llvm::LLVMDIBuilderCreateArrayType(\n+        DIB(cx),\n+        bytes_to_bits(machine::llsize_of_alloc(cx, element_llvm_type)),\n+        bytes_to_bits(machine::llalign_of_min(cx, element_llvm_type)),\n+        element_type_metadata,\n+        create_DIArray(DIB(cx), [llvm::LLVMDIBuilderGetOrCreateSubrange(DIB(cx), 0, 0)]))\n     };\n-    vec_scx.add_member(\n-        \"data\",\n-        0,\n-        0, // clang says the size should be 0\n-        sys::min_align_of::<u8>(), data_ptr);\n \n-    let vec_md = vec_scx.finalize();\n+    //                           fill         alloc        elements\n+    let member_type_metadata = &[int_type_md, int_type_md, array_type_md];\n \n-    let mut box_scx = StructContext::new(cx, fmt!(\"box<%s>\", name), file_md, 0);\n-    let int_t = ty::mk_int();\n-    let refcount_type = create_basic_type(cx, int_t, vec_ty_span);\n+    let vec_md = create_composite_type(\n+        cx,\n+        vec_llvm_type,\n+        vec_type_name,\n+        member_llvm_types,\n+        member_names,\n+        member_type_metadata,\n+        span);\n \n-    box_scx.add_member(\n-        \"refcnt\",\n-        0,\n-        sys::size_of::<uint>(),\n-        sys::min_align_of::<uint>(),\n-        refcount_type);\n-\n-    let (vp, vpsize, vpalign) = voidptr(cx);\n-    box_scx.add_member(\"tydesc\", 0, vpsize, vpalign, vp);\n-    box_scx.add_member(\"prev\", 0, vpsize, vpalign, vp);\n-    box_scx.add_member(\"next\", 0, vpsize, vpalign, vp);\n-    let size = 2 * sys::size_of::<int>();\n-    let align = sys::min_align_of::<int>();\n-    box_scx.add_member(\"boxed\", 0, size, align, vec_md);\n-    let mdval = box_scx.finalize();\n-    return mdval;\n+    return create_boxed_type(cx, vec_llvm_type, vec_md, span);\n }\n \n fn create_vec_slice(cx: &mut CrateContext,\n@@ -892,8 +772,8 @@ fn create_vec_slice(cx: &mut CrateContext,\n     let data_ptr_type = ty::mk_ptr(cx.tcx, ty::mt { ty: element_type, mutbl: ast::m_const });\n \n     let member_type_metadata = &[\n-        create_ty(cx, data_ptr_type, span),\n-        create_ty(cx, ty::mk_uint(), span)\n+        get_or_create_ty(cx, data_ptr_type, span),\n+        get_or_create_ty(cx, ty::mk_uint(), span)\n         ];\n \n     return create_composite_type(\n@@ -922,9 +802,9 @@ fn create_fn_ty(cx: &mut CrateContext, _fn_ty: ty::t, inputs: ~[ty::t], output:\n     let loc = span_start(cx, span);\n     let file_md = get_or_create_file(cx, loc.file.name);\n     let (vp, _, _) = voidptr(cx);\n-    let output_md = create_ty(cx, output, span);\n+    let output_md = get_or_create_ty(cx, output, span);\n     let output_ptr_md = create_pointer_type(cx, output, span, output_md);\n-    let inputs_vals = do inputs.map |arg| { create_ty(cx, *arg, span) };\n+    let inputs_vals = do inputs.map |arg| { get_or_create_ty(cx, *arg, span) };\n     let members = ~[output_ptr_md, vp] + inputs_vals;\n \n     return unsafe {\n@@ -950,27 +830,34 @@ fn create_unimpl_ty(cx: &mut CrateContext, t: ty::t) -> DIType {\n     return md;\n }\n \n-fn create_ty(cx: &mut CrateContext, t: ty::t, span: span) -> DIType {\n+fn get_or_create_ty(cx: &mut CrateContext, t: ty::t, span: span) -> DIType {\n     let ty_id = ty::type_id(t);\n     match dbg_cx(cx).created_types.find(&ty_id) {\n         Some(ty_md) => return *ty_md,\n         None => ()\n     }\n \n-    debug!(\"create_ty: %?\", ty::get(t));\n-\n-    let sty = &ty::get(t).sty;\n-    let ty_md = match *sty {\n-        ty::ty_nil | ty::ty_bot | ty::ty_bool | ty::ty_int(_) | ty::ty_uint(_)\n-        | ty::ty_float(_) => create_basic_type(cx, t, span),\n+    debug!(\"get_or_create_ty: %?\", ty::get(t));\n+\n+    let sty = copy ty::get(t).sty;\n+    let ty_md = match sty {\n+        ty::ty_nil      |\n+        ty::ty_bot      |\n+        ty::ty_bool     |\n+        ty::ty_int(_)   |\n+        ty::ty_uint(_)  |\n+        ty::ty_float(_) => {\n+            create_basic_type(cx, t, span)\n+        },\n         ty::ty_estr(ref vstore) => {\n             let i8_t = ty::mk_i8();\n             match *vstore {\n                 ty::vstore_fixed(len) => {\n                     create_fixed_vec(cx, t, i8_t, len + 1, span)\n                 },\n-                ty::vstore_uniq | ty::vstore_box => {\n-                    let box_md = create_boxed_vec(cx, t, i8_t, span);\n+                ty::vstore_uniq |\n+                ty::vstore_box => {\n+                    let box_md = create_boxed_vec(cx, i8_t, span);\n                     create_pointer_type(cx, t, span, box_md)\n                 }\n                 ty::vstore_slice(_region) => {\n@@ -981,28 +868,32 @@ fn create_ty(cx: &mut CrateContext, t: ty::t, span: span) -> DIType {\n         ty::ty_enum(_did, ref _substs) => {\n             cx.sess.span_note(span, \"debuginfo for enum NYI\");\n             create_unimpl_ty(cx, t)\n-        }\n-        ty::ty_box(ref mt) | ty::ty_uniq(ref mt) => {\n-            let box_metadata = create_boxed_type(cx, mt.ty, span);\n+        },\n+        ty::ty_box(ref mt) |\n+        ty::ty_uniq(ref mt) => {\n+            let content_llvm_type = type_of::type_of(cx, mt.ty);\n+            let content_type_metadata = get_or_create_ty(cx, mt.ty, span);\n+            let box_metadata = create_boxed_type(cx, content_llvm_type, content_type_metadata, span);\n             create_pointer_type(cx, t, span, box_metadata)\n         },\n         ty::ty_evec(ref mt, ref vstore) => {\n             match *vstore {\n                 ty::vstore_fixed(len) => {\n                     create_fixed_vec(cx, t, mt.ty, len, span)\n                 },\n-                ty::vstore_uniq | ty::vstore_box => {\n-                    let box_md = create_boxed_vec(cx, t, mt.ty, span);\n+                ty::vstore_uniq |\n+                ty::vstore_box  => {\n+                    let box_md = create_boxed_vec(cx, mt.ty, span);\n                     create_pointer_type(cx, t, span, box_md)\n                 },\n-                ty::vstore_slice(_region) => {\n+                ty::vstore_slice(_) => {\n                     create_vec_slice(cx, t, mt.ty, span)\n                 }\n             }\n         },\n         ty::ty_ptr(ref mt) |\n         ty::ty_rptr(_, ref mt) => {\n-            let pointee = create_ty(cx, mt.ty, span);\n+            let pointee = get_or_create_ty(cx, mt.ty, span);\n             create_pointer_type(cx, t, span, pointee)\n         },\n         ty::ty_bare_fn(ref barefnty) => {\n@@ -1025,7 +916,7 @@ fn create_ty(cx: &mut CrateContext, t: ty::t, span: span) -> DIType {\n         ty::ty_tup(ref elements) => {\n             create_tuple(cx, t, *elements, span)\n         },\n-        _ => cx.sess.bug(\"debuginfo: unexpected type in create_ty\")\n+        _ => cx.sess.bug(\"debuginfo: unexpected type in get_or_create_ty\")\n     };\n \n     dbg_cx(cx).created_types.insert(ty_id, ty_md);\n@@ -1067,7 +958,7 @@ fn span_start(cx: &CrateContext, span: span) -> codemap::Loc {\n \n fn size_and_align_of(cx: &mut CrateContext, t: ty::t) -> (uint, uint) {\n     let llty = type_of::type_of(cx, t);\n-    (machine::llsize_of_real(cx, llty), machine::llalign_of_min(cx, llty))\n+    (machine::llsize_of_alloc(cx, llty), machine::llalign_of_min(cx, llty))\n }\n \n fn bytes_to_bits(bytes: uint) -> c_ulonglong {"}, {"sha": "aeb081981c2d5a7b1e592a18d4db5b4cf7175d25", "filename": "src/test/debug-info/boxed-vec.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f424e931da4c04e410b003f48503acee92720ffb/src%2Ftest%2Fdebug-info%2Fboxed-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f424e931da4c04e410b003f48503acee92720ffb/src%2Ftest%2Fdebug-info%2Fboxed-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fboxed-vec.rs?ref=f424e931da4c04e410b003f48503acee92720ffb", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print managed->val.fill\n+// check:$1 = 24\n+// debugger:print *((uint64_t[3]*)(managed->val.elements))\n+// check:$2 = {7, 8, 9}\n+\n+// debugger:print unique->val.fill\n+// check:$3 = 32\n+// debugger:print *((uint64_t[4]*)(unique->val.elements))\n+// check:$4 = {10, 11, 12, 13}\n+\n+fn main() {\n+\n+    let managed : @[i64] = @[7, 8, 9];\n+    let unique : ~[i64] = ~[10, 11, 12, 13];\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}]}