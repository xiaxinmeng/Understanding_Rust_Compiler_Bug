{"sha": "e72f307f15138a8bb4fd1ae9ef3256fe1fa9dd94", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3MmYzMDdmMTUxMzhhOGJiNGZkMWFlOWVmMzI1NmZlMWZhOWRkOTQ=", "commit": {"author": {"name": "Caleb Cartwright", "email": "caleb.cartwright@outlook.com", "date": "2020-02-09T04:47:48Z"}, "committer": {"name": "Caleb Cartwright", "email": "caleb.cartwright@outlook.com", "date": "2020-02-09T04:47:48Z"}, "message": "fix: backport parse bug fix\n\nBackport the fix for the parser bug where the messages from\nfatal/non-recoverable parser errors were being silently eaten by\nrustfmt.", "tree": {"sha": "1d2e9efb44366b0fd1ab29de07d4db988effaa45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d2e9efb44366b0fd1ab29de07d4db988effaa45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e72f307f15138a8bb4fd1ae9ef3256fe1fa9dd94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e72f307f15138a8bb4fd1ae9ef3256fe1fa9dd94", "html_url": "https://github.com/rust-lang/rust/commit/e72f307f15138a8bb4fd1ae9ef3256fe1fa9dd94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e72f307f15138a8bb4fd1ae9ef3256fe1fa9dd94/comments", "author": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c60416ed2167716dd6e7141573fbc6dde42e09e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/c60416ed2167716dd6e7141573fbc6dde42e09e3", "html_url": "https://github.com/rust-lang/rust/commit/c60416ed2167716dd6e7141573fbc6dde42e09e3"}], "stats": {"total": 251, "additions": 215, "deletions": 36}, "files": [{"sha": "bed87748253e446069fdb6ff97e76043741ab340", "filename": "src/formatting.rs", "status": "modified", "additions": 215, "deletions": 36, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/e72f307f15138a8bb4fd1ae9ef3256fe1fa9dd94/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72f307f15138a8bb4fd1ae9ef3256fe1fa9dd94/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=e72f307f15138a8bb4fd1ae9ef3256fe1fa9dd94", "patch": "@@ -715,37 +715,43 @@ fn parse_crate(\n struct SilentOnIgnoredFilesEmitter {\n     ignore_path_set: Rc<IgnorePathSet>,\n     source_map: Rc<SourceMap>,\n-    emitter: EmitterWriter,\n+    emitter: Box<dyn Emitter + Send>,\n     has_non_ignorable_parser_errors: bool,\n     can_reset: Rc<RefCell<bool>>,\n }\n \n+impl SilentOnIgnoredFilesEmitter {\n+    fn handle_non_ignoreable_error(&mut self, db: &Diagnostic) {\n+        self.has_non_ignorable_parser_errors = true;\n+        *self.can_reset.borrow_mut() = false;\n+        self.emitter.emit_diagnostic(db);\n+    }\n+}\n+\n impl Emitter for SilentOnIgnoredFilesEmitter {\n     fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n         None\n     }\n+\n     fn emit_diagnostic(&mut self, db: &Diagnostic) {\n+        if db.level == DiagnosticLevel::Fatal {\n+            return self.handle_non_ignoreable_error(db);\n+        }\n         if let Some(primary_span) = &db.span.primary_span() {\n             let file_name = self.source_map.span_to_filename(*primary_span);\n-            match file_name {\n-                rustc_span::FileName::Real(ref path) => {\n-                    if self\n-                        .ignore_path_set\n-                        .is_match(&FileName::Real(path.to_path_buf()))\n-                    {\n-                        if !self.has_non_ignorable_parser_errors {\n-                            *self.can_reset.borrow_mut() = true;\n-                        }\n-                        return;\n+            if let rustc_span::FileName::Real(ref path) = file_name {\n+                if self\n+                    .ignore_path_set\n+                    .is_match(&FileName::Real(path.to_path_buf()))\n+                {\n+                    if !self.has_non_ignorable_parser_errors {\n+                        *self.can_reset.borrow_mut() = true;\n                     }\n+                    return;\n                 }\n-                _ => (),\n             };\n         }\n-\n-        self.has_non_ignorable_parser_errors = true;\n-        *self.can_reset.borrow_mut() = false;\n-        self.emitter.emit_diagnostic(db);\n+        self.handle_non_ignoreable_error(db);\n     }\n }\n \n@@ -759,7 +765,7 @@ impl Emitter for SilentEmitter {\n     fn emit_diagnostic(&mut self, _db: &Diagnostic) {}\n }\n \n-fn silent_emitter() -> Box<SilentEmitter> {\n+fn silent_emitter() -> Box<dyn Emitter + Send> {\n     Box::new(SilentEmitter {})\n }\n \n@@ -769,36 +775,38 @@ fn make_parse_sess(\n     ignore_path_set: Rc<IgnorePathSet>,\n     can_reset: Rc<RefCell<bool>>,\n ) -> ParseSess {\n-    let tty_handler = if config.hide_parse_errors() {\n-        let silent_emitter = silent_emitter();\n-        Handler::with_emitter(true, None, silent_emitter)\n+    let supports_color = term::stderr().map_or(false, |term| term.supports_color());\n+    let color_cfg = if supports_color {\n+        ColorConfig::Auto\n     } else {\n-        let supports_color = term::stderr().map_or(false, |term| term.supports_color());\n-        let color_cfg = if supports_color {\n-            ColorConfig::Auto\n-        } else {\n-            ColorConfig::Never\n-        };\n+        ColorConfig::Never\n+    };\n \n-        let emitter_writer = EmitterWriter::stderr(\n+    let emitter = if config.hide_parse_errors() {\n+        silent_emitter()\n+    } else {\n+        Box::new(EmitterWriter::stderr(\n             color_cfg,\n             Some(source_map.clone()),\n             false,\n             false,\n             None,\n             false,\n-        );\n-        let emitter = Box::new(SilentOnIgnoredFilesEmitter {\n+        ))\n+    };\n+    let handler = Handler::with_emitter(\n+        true,\n+        None,\n+        Box::new(SilentOnIgnoredFilesEmitter {\n             has_non_ignorable_parser_errors: false,\n-            ignore_path_set: ignore_path_set,\n-            source_map: Rc::clone(&source_map),\n-            emitter: emitter_writer,\n+            source_map: source_map.clone(),\n+            emitter,\n+            ignore_path_set,\n             can_reset,\n-        });\n-        Handler::with_emitter(true, None, emitter)\n-    };\n+        }),\n+    );\n \n-    ParseSess::with_span_handler(tty_handler, source_map)\n+    ParseSess::with_span_handler(handler, source_map)\n }\n \n fn should_emit_verbose<F>(is_stdin: bool, config: &Config, f: F)\n@@ -809,3 +817,174 @@ where\n         f();\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    mod emitter {\n+        use super::*;\n+        use crate::config::IgnoreList;\n+        use crate::is_nightly_channel;\n+        use crate::utils::mk_sp;\n+        use rustc_span::{BytePos, FileName as SourceMapFileName, MultiSpan, DUMMY_SP};\n+        use std::path::{Path, PathBuf};\n+\n+        struct TestEmitter {\n+            num_emitted_errors: Rc<RefCell<u32>>,\n+        }\n+\n+        impl Emitter for TestEmitter {\n+            fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n+                None\n+            }\n+            fn emit_diagnostic(&mut self, _db: &Diagnostic) {\n+                *self.num_emitted_errors.borrow_mut() += 1;\n+            }\n+        }\n+\n+        fn build_diagnostic(level: DiagnosticLevel, span: Option<MultiSpan>) -> Diagnostic {\n+            Diagnostic {\n+                level,\n+                code: None,\n+                message: vec![],\n+                children: vec![],\n+                suggestions: vec![],\n+                span: span.unwrap_or_else(MultiSpan::new),\n+                sort_span: DUMMY_SP,\n+            }\n+        }\n+\n+        fn build_emitter(\n+            num_emitted_errors: Rc<RefCell<u32>>,\n+            can_reset: Rc<RefCell<bool>>,\n+            source_map: Option<Rc<SourceMap>>,\n+            ignore_list: Option<IgnoreList>,\n+        ) -> SilentOnIgnoredFilesEmitter {\n+            let emitter_writer = TestEmitter { num_emitted_errors };\n+            let source_map =\n+                source_map.unwrap_or_else(|| Rc::new(SourceMap::new(FilePathMapping::empty())));\n+            let ignore_path_set =\n+                Rc::new(IgnorePathSet::from_ignore_list(&ignore_list.unwrap_or_default()).unwrap());\n+            SilentOnIgnoredFilesEmitter {\n+                has_non_ignorable_parser_errors: false,\n+                source_map,\n+                emitter: Box::new(emitter_writer),\n+                ignore_path_set,\n+                can_reset,\n+            }\n+        }\n+\n+        fn get_ignore_list(config: &str) -> IgnoreList {\n+            Config::from_toml(config, Path::new(\"\")).unwrap().ignore()\n+        }\n+\n+        #[test]\n+        fn handles_fatal_parse_error_in_ignored_file() {\n+            let num_emitted_errors = Rc::new(RefCell::new(0));\n+            let can_reset_errors = Rc::new(RefCell::new(false));\n+            let ignore_list = get_ignore_list(r#\"ignore = [\"foo.rs\"]\"#);\n+            let source_map = Rc::new(SourceMap::new(FilePathMapping::empty()));\n+            let source =\n+                String::from(r#\"extern \"system\" fn jni_symbol!( funcName ) ( ... ) -> {} \"#);\n+            source_map.new_source_file(SourceMapFileName::Real(PathBuf::from(\"foo.rs\")), source);\n+            let mut emitter = build_emitter(\n+                Rc::clone(&num_emitted_errors),\n+                Rc::clone(&can_reset_errors),\n+                Some(Rc::clone(&source_map)),\n+                Some(ignore_list),\n+            );\n+            let span = MultiSpan::from_span(mk_sp(BytePos(0), BytePos(1)));\n+            let fatal_diagnostic = build_diagnostic(DiagnosticLevel::Fatal, Some(span));\n+            emitter.emit_diagnostic(&fatal_diagnostic);\n+            assert_eq!(*num_emitted_errors.borrow(), 1);\n+            assert_eq!(*can_reset_errors.borrow(), false);\n+        }\n+\n+        #[test]\n+        fn handles_recoverable_parse_error_in_ignored_file() {\n+            if !is_nightly_channel!() {\n+                return;\n+            }\n+            let num_emitted_errors = Rc::new(RefCell::new(0));\n+            let can_reset_errors = Rc::new(RefCell::new(false));\n+            let ignore_list = get_ignore_list(r#\"ignore = [\"foo.rs\"]\"#);\n+            let source_map = Rc::new(SourceMap::new(FilePathMapping::empty()));\n+            let source = String::from(r#\"pub fn bar() { 1x; }\"#);\n+            source_map.new_source_file(SourceMapFileName::Real(PathBuf::from(\"foo.rs\")), source);\n+            let mut emitter = build_emitter(\n+                Rc::clone(&num_emitted_errors),\n+                Rc::clone(&can_reset_errors),\n+                Some(Rc::clone(&source_map)),\n+                Some(ignore_list),\n+            );\n+            let span = MultiSpan::from_span(mk_sp(BytePos(0), BytePos(1)));\n+            let non_fatal_diagnostic = build_diagnostic(DiagnosticLevel::Warning, Some(span));\n+            emitter.emit_diagnostic(&non_fatal_diagnostic);\n+            assert_eq!(*num_emitted_errors.borrow(), 0);\n+            assert_eq!(*can_reset_errors.borrow(), true);\n+        }\n+\n+        #[test]\n+        fn handles_recoverable_parse_error_in_non_ignored_file() {\n+            if !is_nightly_channel!() {\n+                return;\n+            }\n+            let num_emitted_errors = Rc::new(RefCell::new(0));\n+            let can_reset_errors = Rc::new(RefCell::new(false));\n+            let source_map = Rc::new(SourceMap::new(FilePathMapping::empty()));\n+            let source = String::from(r#\"pub fn bar() { 1x; }\"#);\n+            source_map.new_source_file(SourceMapFileName::Real(PathBuf::from(\"foo.rs\")), source);\n+            let mut emitter = build_emitter(\n+                Rc::clone(&num_emitted_errors),\n+                Rc::clone(&can_reset_errors),\n+                Some(Rc::clone(&source_map)),\n+                None,\n+            );\n+            let span = MultiSpan::from_span(mk_sp(BytePos(0), BytePos(1)));\n+            let non_fatal_diagnostic = build_diagnostic(DiagnosticLevel::Warning, Some(span));\n+            emitter.emit_diagnostic(&non_fatal_diagnostic);\n+            assert_eq!(*num_emitted_errors.borrow(), 1);\n+            assert_eq!(*can_reset_errors.borrow(), false);\n+        }\n+\n+        #[test]\n+        fn handles_mix_of_recoverable_parse_error() {\n+            if !is_nightly_channel!() {\n+                return;\n+            }\n+            let num_emitted_errors = Rc::new(RefCell::new(0));\n+            let can_reset_errors = Rc::new(RefCell::new(false));\n+            let source_map = Rc::new(SourceMap::new(FilePathMapping::empty()));\n+            let ignore_list = get_ignore_list(r#\"ignore = [\"foo.rs\"]\"#);\n+            let bar_source = String::from(r#\"pub fn bar() { 1x; }\"#);\n+            let foo_source = String::from(r#\"pub fn foo() { 1x; }\"#);\n+            let fatal_source =\n+                String::from(r#\"extern \"system\" fn jni_symbol!( funcName ) ( ... ) -> {} \"#);\n+            source_map\n+                .new_source_file(SourceMapFileName::Real(PathBuf::from(\"bar.rs\")), bar_source);\n+            source_map\n+                .new_source_file(SourceMapFileName::Real(PathBuf::from(\"foo.rs\")), foo_source);\n+            source_map.new_source_file(\n+                SourceMapFileName::Real(PathBuf::from(\"fatal.rs\")),\n+                fatal_source,\n+            );\n+            let mut emitter = build_emitter(\n+                Rc::clone(&num_emitted_errors),\n+                Rc::clone(&can_reset_errors),\n+                Some(Rc::clone(&source_map)),\n+                Some(ignore_list),\n+            );\n+            let bar_span = MultiSpan::from_span(mk_sp(BytePos(0), BytePos(1)));\n+            let foo_span = MultiSpan::from_span(mk_sp(BytePos(21), BytePos(22)));\n+            let bar_diagnostic = build_diagnostic(DiagnosticLevel::Warning, Some(bar_span));\n+            let foo_diagnostic = build_diagnostic(DiagnosticLevel::Warning, Some(foo_span));\n+            let fatal_diagnostic = build_diagnostic(DiagnosticLevel::Fatal, None);\n+            emitter.emit_diagnostic(&bar_diagnostic);\n+            emitter.emit_diagnostic(&foo_diagnostic);\n+            emitter.emit_diagnostic(&fatal_diagnostic);\n+            assert_eq!(*num_emitted_errors.borrow(), 2);\n+            assert_eq!(*can_reset_errors.borrow(), false);\n+        }\n+    }\n+}"}]}