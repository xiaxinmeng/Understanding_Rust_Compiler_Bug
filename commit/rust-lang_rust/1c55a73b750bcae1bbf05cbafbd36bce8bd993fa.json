{"sha": "1c55a73b750bcae1bbf05cbafbd36bce8bd993fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjNTVhNzNiNzUwYmNhZTFiYmYwNWNiYWZiZDM2YmNlOGJkOTkzZmE=", "commit": {"author": {"name": "Cl\u00e9ment Renault", "email": "clement@meilisearch.com", "date": "2020-12-10T10:17:41Z"}, "committer": {"name": "Cl\u00e9ment Renault", "email": "clement@meilisearch.com", "date": "2020-12-10T10:20:15Z"}, "message": "Implement it with only safe code", "tree": {"sha": "e186648709f70bb4890fac8a38d7aeff5e52904d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e186648709f70bb4890fac8a38d7aeff5e52904d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c55a73b750bcae1bbf05cbafbd36bce8bd993fa", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEAUNXpSBlykwfjB4xkq2k6TXnH6QFAl/R9l8ACgkQkq2k6TXn\nH6QhCw//b0Zy+5pAcgqfoNAkSBtY7hDxbkZV4NC6lsKVlKs1vrQo8Kl3QZVSSYnh\n196BIlYOv4BIRenSTy9i+suyY2TtA/edxaqdmlb/uWnACt10+8aku5+GV2WcYf8p\n2FNHmSrmqBTU2uXUNmTD6Oj7o6ZPQp201ksTzLYV7IrQj+PI9+ZyYd63+XXMSPiE\nCBvOtvLHAJ4oV70yGuoQiuOi1mXwqmqF09cRSKzovI/JOHNRxiIgoAbR7c/isoAK\n+lvr9e8Ng71jWtQOQ52ryYDqRvVZyynRPT8XnpX7yeAXMGQPDPf6TJ/nR746AaCy\nEwd8VPNCb4Y7qMUUZE7rbsKpg7Il7ZmqoHXqoJennLrKnOkA9TAaMVT9F1GyCVPT\nZkaTHiJgKR+d4IPaJlJJYlMrFEyRcnD377CYygzaji8CLRN/0RN6KhJXrMFJmsbP\nMr76uI6Nw0GLqLx9VpB8yNJqgn9X6Qqo558TS61aiPHk4jPhed86ZjX+Il7HhgFu\nEh0vpVDduvKl/6sroVcQZrFfFc41Zj6QzGZFAE2ZJCoD124t41bEcPB5rONWIm7i\nYSqYtv89EbmJ9Q4bt1J0mq475UXMu4XfTcXo02OxqmcMWDq0kBSZN0Qob4cST5Xp\nlBpKBDU8h4Kp2jvSpKd5qALnUEoWmKqS9Fl8byqDgVwBaCxIkZg=\n=x0dd\n-----END PGP SIGNATURE-----", "payload": "tree e186648709f70bb4890fac8a38d7aeff5e52904d\nparent a891f6edfeb4d7b061a215ba160fca0e4804ffd2\nauthor Cl\u00e9ment Renault <clement@meilisearch.com> 1607595461 +0100\ncommitter Cl\u00e9ment Renault <clement@meilisearch.com> 1607595615 +0100\n\nImplement it with only safe code\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c55a73b750bcae1bbf05cbafbd36bce8bd993fa", "html_url": "https://github.com/rust-lang/rust/commit/1c55a73b750bcae1bbf05cbafbd36bce8bd993fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c55a73b750bcae1bbf05cbafbd36bce8bd993fa/comments", "author": {"login": "Kerollmops", "id": 3610253, "node_id": "MDQ6VXNlcjM2MTAyNTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3610253?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kerollmops", "html_url": "https://github.com/Kerollmops", "followers_url": "https://api.github.com/users/Kerollmops/followers", "following_url": "https://api.github.com/users/Kerollmops/following{/other_user}", "gists_url": "https://api.github.com/users/Kerollmops/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kerollmops/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kerollmops/subscriptions", "organizations_url": "https://api.github.com/users/Kerollmops/orgs", "repos_url": "https://api.github.com/users/Kerollmops/repos", "events_url": "https://api.github.com/users/Kerollmops/events{/privacy}", "received_events_url": "https://api.github.com/users/Kerollmops/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kerollmops", "id": 3610253, "node_id": "MDQ6VXNlcjM2MTAyNTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3610253?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kerollmops", "html_url": "https://github.com/Kerollmops", "followers_url": "https://api.github.com/users/Kerollmops/followers", "following_url": "https://api.github.com/users/Kerollmops/following{/other_user}", "gists_url": "https://api.github.com/users/Kerollmops/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kerollmops/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kerollmops/subscriptions", "organizations_url": "https://api.github.com/users/Kerollmops/orgs", "repos_url": "https://api.github.com/users/Kerollmops/repos", "events_url": "https://api.github.com/users/Kerollmops/events{/privacy}", "received_events_url": "https://api.github.com/users/Kerollmops/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a891f6edfeb4d7b061a215ba160fca0e4804ffd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/a891f6edfeb4d7b061a215ba160fca0e4804ffd2", "html_url": "https://github.com/rust-lang/rust/commit/a891f6edfeb4d7b061a215ba160fca0e4804ffd2"}], "stats": {"total": 291, "additions": 128, "deletions": 163}, "files": [{"sha": "8f03a9240e2803e5f3b4c64c52ec386915b399ed", "filename": "library/alloc/tests/slice.rs", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/1c55a73b750bcae1bbf05cbafbd36bce8bd993fa/library%2Falloc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c55a73b750bcae1bbf05cbafbd36bce8bd993fa/library%2Falloc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fslice.rs?ref=1c55a73b750bcae1bbf05cbafbd36bce8bd993fa", "patch": "@@ -1904,24 +1904,43 @@ fn test_group_by() {\n     let slice = &[1, 1, 1, 3, 3, 2, 2, 2];\n \n     let mut iter = slice.group_by(|a, b| a == b);\n-\n     assert_eq!(iter.next(), Some(&[1, 1, 1][..]));\n-\n-    assert_eq!(iter.remaining(), &[3, 3, 2, 2, 2]);\n-\n     assert_eq!(iter.next(), Some(&[3, 3][..]));\n     assert_eq!(iter.next(), Some(&[2, 2, 2][..]));\n     assert_eq!(iter.next(), None);\n-}\n-\n-#[test]\n-fn test_group_by_rev() {\n-    let slice = &[1, 1, 1, 3, 3, 2, 2, 2];\n \n     let mut iter = slice.group_by(|a, b| a == b);\n-\n     assert_eq!(iter.next_back(), Some(&[2, 2, 2][..]));\n     assert_eq!(iter.next_back(), Some(&[3, 3][..]));\n     assert_eq!(iter.next_back(), Some(&[1, 1, 1][..]));\n     assert_eq!(iter.next_back(), None);\n+\n+    let mut iter = slice.group_by(|a, b| a == b);\n+    assert_eq!(iter.next(), Some(&[1, 1, 1][..]));\n+    assert_eq!(iter.next_back(), Some(&[2, 2, 2][..]));\n+    assert_eq!(iter.next(), Some(&[3, 3][..]));\n+    assert_eq!(iter.next_back(), None);\n+}\n+\n+#[test]\n+fn test_group_by_mut() {\n+    let slice = &mut [1, 1, 1, 3, 3, 2, 2, 2];\n+\n+    let mut iter = slice.group_by_mut(|a, b| a == b);\n+    assert_eq!(iter.next(), Some(&mut [1, 1, 1][..]));\n+    assert_eq!(iter.next(), Some(&mut [3, 3][..]));\n+    assert_eq!(iter.next(), Some(&mut [2, 2, 2][..]));\n+    assert_eq!(iter.next(), None);\n+\n+    let mut iter = slice.group_by_mut(|a, b| a == b);\n+    assert_eq!(iter.next_back(), Some(&mut [2, 2, 2][..]));\n+    assert_eq!(iter.next_back(), Some(&mut [3, 3][..]));\n+    assert_eq!(iter.next_back(), Some(&mut [1, 1, 1][..]));\n+    assert_eq!(iter.next_back(), None);\n+\n+    let mut iter = slice.group_by_mut(|a, b| a == b);\n+    assert_eq!(iter.next(), Some(&mut [1, 1, 1][..]));\n+    assert_eq!(iter.next_back(), Some(&mut [2, 2, 2][..]));\n+    assert_eq!(iter.next(), Some(&mut [3, 3][..]));\n+    assert_eq!(iter.next_back(), None);\n }"}, {"sha": "8f52fa852ba9dde627df8e8d182c19c525f6c9a2", "filename": "library/core/src/slice/iter.rs", "status": "modified", "additions": 97, "deletions": 141, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/1c55a73b750bcae1bbf05cbafbd36bce8bd993fa/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c55a73b750bcae1bbf05cbafbd36bce8bd993fa/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs?ref=1c55a73b750bcae1bbf05cbafbd36bce8bd993fa", "patch": "@@ -2968,127 +2968,6 @@ unsafe impl<'a, T> TrustedRandomAccess for IterMut<'a, T> {\n     }\n }\n \n-macro_rules! group_by {\n-    (struct $name:ident, $elem:ty, $mkslice:ident) => {\n-        #[unstable(feature = \"slice_group_by\", issue = \"0\")]\n-        impl<'a, T: 'a, P> $name<'a, T, P> {\n-            #[inline]\n-            fn is_empty(&self) -> bool {\n-                self.ptr == self.end\n-            }\n-\n-            #[inline]\n-            fn remaining_len(&self) -> usize {\n-                unsafe { self.end.offset_from(self.ptr) as usize }\n-            }\n-        }\n-\n-        #[unstable(feature = \"slice_group_by\", issue = \"0\")]\n-        impl<'a, T: 'a, P> Iterator for $name<'a, T, P>\n-        where P: FnMut(&T, &T) -> bool,\n-        {\n-            type Item = $elem;\n-\n-            fn next(&mut self) -> Option<Self::Item> {\n-                // we use an unsafe block to avoid bounds checking here.\n-                // this is safe because the only thing we do here is to get\n-                // two elements at `ptr` and `ptr + 1`, bounds checking is done by hand.\n-                unsafe {\n-                    if self.is_empty() { return None }\n-\n-                    let mut i = 0;\n-                    let mut ptr = self.ptr;\n-\n-                    // we need to get *two* contiguous elements so we check that:\n-                    //  - the first element is at the `end - 1` position because\n-                    //  - the second one will be read from `ptr + 1` that must\n-                    //    be lower or equal to `end`\n-                    while ptr != self.end.sub(1) {\n-                        let a = &*ptr;\n-                        ptr = ptr.add(1);\n-                        let b = &*ptr;\n-\n-                        i += 1;\n-\n-                        if !(self.predicate)(a, b) {\n-                            let slice = $mkslice(self.ptr, i);\n-                            self.ptr = ptr;\n-                            return Some(slice)\n-                        }\n-                    }\n-\n-                    // `i` is either `0` or the slice `length - 1` because either:\n-                    //  - we have not entered the loop and so `i` is equal to `0`\n-                    //    the slice length is necessarily `1` because we ensure it is not empty\n-                    //  - we have entered the loop and we have not early returned\n-                    //    so `i` is equal to the slice `length - 1`\n-                    let slice = $mkslice(self.ptr, i + 1);\n-                    self.ptr = self.end;\n-                    Some(slice)\n-                }\n-            }\n-\n-            fn size_hint(&self) -> (usize, Option<usize>) {\n-                if self.is_empty() { return (0, Some(0)) }\n-                let len = self.remaining_len();\n-                (1, Some(len))\n-            }\n-\n-            fn last(mut self) -> Option<Self::Item> {\n-                self.next_back()\n-            }\n-        }\n-\n-        #[unstable(feature = \"slice_group_by\", issue = \"0\")]\n-        impl<'a, T: 'a, P> DoubleEndedIterator for $name<'a, T, P>\n-        where P: FnMut(&T, &T) -> bool,\n-        {\n-            fn next_back(&mut self) -> Option<Self::Item> {\n-                // during the loop we retrieve two elements at `ptr` and `ptr - 1`.\n-                unsafe {\n-                    if self.is_empty() { return None }\n-\n-                    let mut i = 0;\n-                    // we ensure that the first element that will be read\n-                    // is not under `end` because `end` is out of bound.\n-                    let mut ptr = self.end.sub(1);\n-\n-                    while ptr != self.ptr {\n-                        // we first get `a` that is at the left of `ptr`\n-                        // then `b` that is under the `ptr` position.\n-                        let a = &*ptr.sub(1);\n-                        let b = &*ptr;\n-\n-                        i += 1;\n-\n-                        if !(self.predicate)(a, b) {\n-                            // the slice to return starts at the `ptr` position\n-                            // and `i` is the length of it.\n-                            let slice = $mkslice(ptr, i);\n-\n-                            // because `end` is always an invalid bound\n-                            // we use `ptr` as `end` for the future call to `next`.\n-                            self.end = ptr;\n-                            return Some(slice)\n-                        }\n-\n-                        ptr = ptr.sub(1);\n-                    }\n-\n-                    let slice = $mkslice(self.ptr, i + 1);\n-                    self.ptr = self.end;\n-                    Some(slice)\n-                }\n-            }\n-        }\n-\n-        #[unstable(feature = \"slice_group_by\", issue = \"0\")]\n-        impl<'a, T: 'a, P> FusedIterator for $name<'a, T, P>\n-        where P: FnMut(&T, &T) -> bool,\n-        { }\n-    }\n-}\n-\n /// An iterator over slice in (non-overlapping) chunks separated by a predicate.\n ///\n /// This struct is created by the [`group_by`] method on [slices].\n@@ -3098,25 +2977,65 @@ macro_rules! group_by {\n #[unstable(feature = \"slice_group_by\", issue = \"0\")]\n #[derive(Debug)] // FIXME implement Debug to be more user friendly\n pub struct GroupBy<'a, T: 'a, P> {\n-    ptr: *const T,\n-    end: *const T,\n+    slice: &'a [T],\n     predicate: P,\n-    _phantom: marker::PhantomData<&'a T>,\n }\n \n #[unstable(feature = \"slice_group_by\", issue = \"0\")]\n-impl<'a, T: 'a, P> GroupBy<'a, T, P>\n+impl<'a, T: 'a, P> GroupBy<'a, T, P> {\n+    pub(super) fn new(slice: &'a [T], predicate: P) -> Self {\n+        GroupBy { slice, predicate }\n+    }\n+}\n+\n+#[unstable(feature = \"slice_group_by\", issue = \"0\")]\n+impl<'a, T: 'a, P> Iterator for GroupBy<'a, T, P>\n where P: FnMut(&T, &T) -> bool,\n {\n-    /// Returns the remainder of the original slice that is going to be\n-    /// returned by the iterator.\n-    pub fn remaining(&self) -> &[T] {\n-        let len = self.remaining_len();\n-        unsafe { from_raw_parts(self.ptr, len) }\n+    type Item = &'a [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if self.slice.is_empty() {\n+            None\n+        } else {\n+            let mut len = 1;\n+            let mut iter = self.slice.windows(2);\n+            while let Some([l, r]) = iter.next() {\n+                if (self.predicate)(l, r) { len += 1 } else { break }\n+            }\n+            let (head, tail) = self.slice.split_at(len);\n+            self.slice = tail;\n+            Some(head)\n+        }\n     }\n }\n \n-group_by!{ struct GroupBy, &'a [T], from_raw_parts }\n+#[unstable(feature = \"slice_group_by\", issue = \"0\")]\n+impl<'a, T: 'a, P> DoubleEndedIterator for GroupBy<'a, T, P>\n+where P: FnMut(&T, &T) -> bool,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        if self.slice.is_empty() {\n+            None\n+        } else {\n+            let mut len = 1;\n+            let mut iter = self.slice.windows(2);\n+            while let Some([l, r]) = iter.next_back() {\n+                if (self.predicate)(l, r) { len += 1 } else { break }\n+            }\n+            let (head, tail) = self.slice.split_at(self.slice.len() - len);\n+            self.slice = head;\n+            Some(tail)\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"slice_group_by\", issue = \"0\")]\n+impl<'a, T: 'a, P> FusedIterator for GroupBy<'a, T, P>\n+where P: FnMut(&T, &T) -> bool,\n+{ }\n \n /// An iterator over slice in (non-overlapping) mutable chunks separated\n /// by a predicate.\n@@ -3128,22 +3047,59 @@ group_by!{ struct GroupBy, &'a [T], from_raw_parts }\n #[unstable(feature = \"slice_group_by\", issue = \"0\")]\n #[derive(Debug)] // FIXME implement Debug to be more user friendly\n pub struct GroupByMut<'a, T: 'a, P> {\n-    ptr: *mut T,\n-    end: *mut T,\n+    slice: &'a mut [T],\n     predicate: P,\n-    _phantom: marker::PhantomData<&'a T>,\n }\n \n #[unstable(feature = \"slice_group_by\", issue = \"0\")]\n-impl<'a, T: 'a, P> GroupByMut<'a, T, P>\n+impl<'a, T: 'a, P> GroupByMut<'a, T, P> {\n+    pub(super) fn new(slice: &'a mut [T], predicate: P) -> Self {\n+        GroupByMut { slice, predicate }\n+    }\n+}\n+\n+#[unstable(feature = \"slice_group_by\", issue = \"0\")]\n+impl<'a, T: 'a, P> Iterator for GroupByMut<'a, T, P>\n where P: FnMut(&T, &T) -> bool,\n {\n-    /// Returns the remainder of the original slice that is going to be\n-    /// returned by the iterator.\n-    pub fn into_remaining(self) -> &'a mut [T] {\n-        let len = self.remaining_len();\n-        unsafe { from_raw_parts_mut(self.ptr, len) }\n+    type Item = &'a mut [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if self.slice.is_empty() {\n+            None\n+        } else {\n+            let mut len = 1;\n+            let mut iter = self.slice.windows(2);\n+            while let Some([l, r]) = iter.next() {\n+                if (self.predicate)(l, r) { len += 1 } else { break }\n+            }\n+            let slice = mem::take(&mut self.slice);\n+            let (head, tail) = slice.split_at_mut(len);\n+            self.slice = tail;\n+            Some(head)\n+        }\n     }\n }\n \n-group_by!{ struct GroupByMut, &'a mut [T], from_raw_parts_mut }\n+#[unstable(feature = \"slice_group_by\", issue = \"0\")]\n+impl<'a, T: 'a, P> DoubleEndedIterator for GroupByMut<'a, T, P>\n+where P: FnMut(&T, &T) -> bool,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        if self.slice.is_empty() {\n+            None\n+        } else {\n+            let mut len = 1;\n+            let mut iter = self.slice.windows(2);\n+            while let Some([l, r]) = iter.next_back() {\n+                if (self.predicate)(l, r) { len += 1 } else { break }\n+            }\n+            let slice = mem::take(&mut self.slice);\n+            let (head, tail) = slice.split_at_mut(slice.len() - len);\n+            self.slice = head;\n+            Some(tail)\n+        }\n+    }\n+}"}, {"sha": "2e304cc5d2ea49f980fe8feb0e3310ccd866e952", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1c55a73b750bcae1bbf05cbafbd36bce8bd993fa/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c55a73b750bcae1bbf05cbafbd36bce8bd993fa/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=1c55a73b750bcae1bbf05cbafbd36bce8bd993fa", "patch": "@@ -1233,12 +1233,7 @@ impl<T> [T] {\n     pub fn group_by<F>(&self, pred: F) -> GroupBy<T, F>\n     where F: FnMut(&T, &T) -> bool\n     {\n-        GroupBy {\n-            ptr: self.as_ptr(),\n-            end: unsafe { self.as_ptr().add(self.len()) },\n-            predicate: pred,\n-            _phantom: marker::PhantomData,\n-        }\n+        GroupBy::new(self, pred)\n     }\n \n     /// Returns an iterator over the slice producing non-overlapping mutable\n@@ -1267,12 +1262,7 @@ impl<T> [T] {\n     pub fn group_by_mut<F>(&mut self, pred: F) -> GroupByMut<T, F>\n     where F: FnMut(&T, &T) -> bool\n     {\n-        GroupByMut {\n-            ptr: self.as_mut_ptr(),\n-            end: unsafe { self.as_mut_ptr().add(self.len()) },\n-            predicate: pred,\n-            _phantom: marker::PhantomData,\n-        }\n+        GroupByMut::new(self, pred)\n     }\n \n     /// Divides one slice into two at an index."}]}