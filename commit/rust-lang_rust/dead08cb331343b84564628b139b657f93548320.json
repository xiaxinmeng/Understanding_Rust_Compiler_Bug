{"sha": "dead08cb331343b84564628b139b657f93548320", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlYWQwOGNiMzMxMzQzYjg0NTY0NjI4YjEzOWI2NTdmOTM1NDgzMjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-08T09:47:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-08T09:47:58Z"}, "message": "Auto merge of #44142 - alexcrichton:dllimport-query, r=nikomatsakis\n\nMigrate a slew of metadata methods to queries\n\nThis PR intends to make more progress on #41417, knocking off some low-hanging fruit.\n\nCloses #44190\ncc #44137", "tree": {"sha": "ed670fa4db3d6ee3b74301b1728cbb37ecc424c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed670fa4db3d6ee3b74301b1728cbb37ecc424c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dead08cb331343b84564628b139b657f93548320", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dead08cb331343b84564628b139b657f93548320", "html_url": "https://github.com/rust-lang/rust/commit/dead08cb331343b84564628b139b657f93548320", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dead08cb331343b84564628b139b657f93548320/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6ad402a644d9e57f1a6d6c579fe04acf00e0e2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6ad402a644d9e57f1a6d6c579fe04acf00e0e2e", "html_url": "https://github.com/rust-lang/rust/commit/d6ad402a644d9e57f1a6d6c579fe04acf00e0e2e"}, {"sha": "fd0aa647f3abaf6667dcde5b44e673e172c8a63b", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd0aa647f3abaf6667dcde5b44e673e172c8a63b", "html_url": "https://github.com/rust-lang/rust/commit/fd0aa647f3abaf6667dcde5b44e673e172c8a63b"}], "stats": {"total": 3314, "additions": 1854, "deletions": 1460}, "files": [{"sha": "caa912c7c8bafde6fd3588d05be5f77bc40d141e", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 51, "deletions": 7, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -511,8 +511,8 @@ define_dep_nodes!( <'tcx>\n     [] ParamEnv(DefId),\n     [] DescribeDef(DefId),\n     [] DefSpan(DefId),\n-    [] Stability(DefId),\n-    [] Deprecation(DefId),\n+    [] LookupStability(DefId),\n+    [] LookupDeprecationEntry(DefId),\n     [] ItemBodyNestedBodies(DefId),\n     [] ConstIsRvaluePromotableToStatic(DefId),\n     [] ImplParent(DefId),\n@@ -521,16 +521,60 @@ define_dep_nodes!( <'tcx>\n     [] IsMirAvailable(DefId),\n     [] ItemAttrs(DefId),\n     [] FnArgNames(DefId),\n-    [] DylibDepFormats(DefId),\n-    [] IsAllocator(DefId),\n-    [] IsPanicRuntime(DefId),\n-    [] IsCompilerBuiltins(DefId),\n-    [] HasGlobalAllocator(DefId),\n+    [] DylibDepFormats(CrateNum),\n+    [] IsPanicRuntime(CrateNum),\n+    [] IsCompilerBuiltins(CrateNum),\n+    [] HasGlobalAllocator(CrateNum),\n     [] ExternCrate(DefId),\n     [] LintLevels,\n     [] Specializes { impl1: DefId, impl2: DefId },\n     [] InScopeTraits(HirId),\n     [] ModuleExports(HirId),\n+    [] IsSanitizerRuntime(CrateNum),\n+    [] IsProfilerRuntime(CrateNum),\n+    [] GetPanicStrategy(CrateNum),\n+    [] IsNoBuiltins(CrateNum),\n+    [] ImplDefaultness(DefId),\n+    [] ExportedSymbols(CrateNum),\n+    [] NativeLibraries(CrateNum),\n+    [] PluginRegistrarFn(CrateNum),\n+    [] DeriveRegistrarFn(CrateNum),\n+    [] CrateDisambiguator(CrateNum),\n+    [] CrateHash(CrateNum),\n+    [] OriginalCrateName(CrateNum),\n+\n+    [] ImplementationsOfTrait { krate: CrateNum, trait_id: DefId },\n+    [] AllTraitImplementations(CrateNum),\n+\n+    [] IsDllimportForeignItem(DefId),\n+    [] IsStaticallyIncludedForeignItem(DefId),\n+    [] NativeLibraryKind(DefId),\n+    [] LinkArgs,\n+\n+    [] NamedRegion(HirId),\n+    [] IsLateBound(HirId),\n+    [] ObjectLifetimeDefaults(HirId),\n+\n+    [] Visibility(DefId),\n+    [] DepKind(CrateNum),\n+    [] CrateName(CrateNum),\n+    [] ItemChildren(DefId),\n+    [] ExternModStmtCnum(HirId),\n+    [] GetLangItems,\n+    [] DefinedLangItems(CrateNum),\n+    [] MissingLangItems(CrateNum),\n+    [] ExternConstBody(DefId),\n+    [] VisibleParentMap,\n+    [] IsDirectExternCrate(CrateNum),\n+    [] MissingExternCrateItem(CrateNum),\n+    [] UsedCrateSource(CrateNum),\n+    [] PostorderCnums,\n+\n+    [] Freevars(HirId),\n+    [] MaybeUnusedTraitImport(HirId),\n+    [] MaybeUnusedExternCrates,\n+    [] StabilityIndex,\n+    [] AllCrateNums,\n );\n \n trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> : fmt::Debug {"}, {"sha": "34cb1d2a6d7957278c8b02f3c9cffec7130a71ad", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -235,10 +235,13 @@ impl DepGraph {\n                                           debug_str_gen: F)\n         where F: FnOnce() -> String\n     {\n-        let mut dep_node_debug = self.data.as_ref().unwrap().dep_node_debug.borrow_mut();\n+        let dep_node_debug = &self.data.as_ref().unwrap().dep_node_debug;\n \n-        dep_node_debug.entry(dep_node)\n-                      .or_insert_with(debug_str_gen);\n+        if dep_node_debug.borrow().contains_key(&dep_node) {\n+            return\n+        }\n+        let debug_str = debug_str_gen();\n+        dep_node_debug.borrow_mut().insert(dep_node, debug_str);\n     }\n \n     pub(super) fn dep_node_debug_str(&self, dep_node: DepNode) -> Option<String> {"}, {"sha": "db86c4f93ee5269a6739f23e041e2539d3df9b33", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -787,7 +787,7 @@ impl<'a> LoweringContext<'a> {\n                         return n;\n                     }\n                     assert!(!def_id.is_local());\n-                    let n = self.sess.cstore.item_generics_cloned(def_id).regions.len();\n+                    let n = self.sess.cstore.item_generics_cloned_untracked(def_id).regions.len();\n                     self.type_def_lifetime_params.insert(def_id, n);\n                     n\n                 });\n@@ -2863,7 +2863,7 @@ impl<'a> LoweringContext<'a> {\n         let parent_def = self.parent_def.unwrap();\n         let def_id = {\n             let defs = self.resolver.definitions();\n-            let def_path_data = DefPathData::Binding(name);\n+            let def_path_data = DefPathData::Binding(name.as_str());\n             let def_index = defs.create_def_with_parent(parent_def,\n                                                         node_id,\n                                                         def_path_data,"}, {"sha": "af027e321c6a1da4e4f235e607d0898466eee3e0", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -104,14 +104,14 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                 DefPathData::Impl,\n             ItemKind::Enum(..) | ItemKind::Struct(..) | ItemKind::Union(..) | ItemKind::Trait(..) |\n             ItemKind::ExternCrate(..) | ItemKind::ForeignMod(..) | ItemKind::Ty(..) =>\n-                DefPathData::TypeNs(i.ident.name),\n+                DefPathData::TypeNs(i.ident.name.as_str()),\n             ItemKind::Mod(..) if i.ident == keywords::Invalid.ident() => {\n                 return visit::walk_item(self, i);\n             }\n-            ItemKind::Mod(..) => DefPathData::Module(i.ident.name),\n+            ItemKind::Mod(..) => DefPathData::Module(i.ident.name.as_str()),\n             ItemKind::Static(..) | ItemKind::Const(..) | ItemKind::Fn(..) =>\n-                DefPathData::ValueNs(i.ident.name),\n-            ItemKind::MacroDef(..) => DefPathData::MacroDef(i.ident.name),\n+                DefPathData::ValueNs(i.ident.name.as_str()),\n+            ItemKind::MacroDef(..) => DefPathData::MacroDef(i.ident.name.as_str()),\n             ItemKind::Mac(..) => return self.visit_macro_invoc(i.id, false),\n             ItemKind::GlobalAsm(..) => DefPathData::Misc,\n             ItemKind::Use(ref view_path) => {\n@@ -139,13 +139,15 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                     for v in &enum_definition.variants {\n                         let variant_def_index =\n                             this.create_def(v.node.data.id(),\n-                                            DefPathData::EnumVariant(v.node.name.name),\n+                                            DefPathData::EnumVariant(v.node.name.name.as_str()),\n                                             REGULAR_SPACE);\n                         this.with_parent(variant_def_index, |this| {\n                             for (index, field) in v.node.data.fields().iter().enumerate() {\n                                 let name = field.ident.map(|ident| ident.name)\n                                     .unwrap_or_else(|| Symbol::intern(&index.to_string()));\n-                                this.create_def(field.id, DefPathData::Field(name), REGULAR_SPACE);\n+                                this.create_def(field.id,\n+                                                DefPathData::Field(name.as_str()),\n+                                                REGULAR_SPACE);\n                             }\n \n                             if let Some(ref expr) = v.node.disr_expr {\n@@ -165,7 +167,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                     for (index, field) in struct_def.fields().iter().enumerate() {\n                         let name = field.ident.map(|ident| ident.name)\n                             .unwrap_or_else(|| Symbol::intern(&index.to_string()));\n-                        this.create_def(field.id, DefPathData::Field(name), REGULAR_SPACE);\n+                        this.create_def(field.id, DefPathData::Field(name.as_str()), REGULAR_SPACE);\n                     }\n                 }\n                 _ => {}\n@@ -176,7 +178,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n     fn visit_foreign_item(&mut self, foreign_item: &'a ForeignItem) {\n         let def = self.create_def(foreign_item.id,\n-                                  DefPathData::ValueNs(foreign_item.ident.name),\n+                                  DefPathData::ValueNs(foreign_item.ident.name.as_str()),\n                                   REGULAR_SPACE);\n \n         self.with_parent(def, |this| {\n@@ -187,7 +189,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     fn visit_generics(&mut self, generics: &'a Generics) {\n         for ty_param in generics.ty_params.iter() {\n             self.create_def(ty_param.id,\n-                            DefPathData::TypeParam(ty_param.ident.name),\n+                            DefPathData::TypeParam(ty_param.ident.name.as_str()),\n                             REGULAR_SPACE);\n         }\n \n@@ -197,8 +199,8 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     fn visit_trait_item(&mut self, ti: &'a TraitItem) {\n         let def_data = match ti.node {\n             TraitItemKind::Method(..) | TraitItemKind::Const(..) =>\n-                DefPathData::ValueNs(ti.ident.name),\n-            TraitItemKind::Type(..) => DefPathData::TypeNs(ti.ident.name),\n+                DefPathData::ValueNs(ti.ident.name.as_str()),\n+            TraitItemKind::Type(..) => DefPathData::TypeNs(ti.ident.name.as_str()),\n             TraitItemKind::Macro(..) => return self.visit_macro_invoc(ti.id, false),\n         };\n \n@@ -215,8 +217,8 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n         let def_data = match ii.node {\n             ImplItemKind::Method(..) | ImplItemKind::Const(..) =>\n-                DefPathData::ValueNs(ii.ident.name),\n-            ImplItemKind::Type(..) => DefPathData::TypeNs(ii.ident.name),\n+                DefPathData::ValueNs(ii.ident.name.as_str()),\n+            ImplItemKind::Type(..) => DefPathData::TypeNs(ii.ident.name.as_str()),\n             ImplItemKind::Macro(..) => return self.visit_macro_invoc(ii.id, false),\n         };\n \n@@ -237,7 +239,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             PatKind::Mac(..) => return self.visit_macro_invoc(pat.id, false),\n             PatKind::Ident(_, id, _) => {\n                 let def = self.create_def(pat.id,\n-                                          DefPathData::Binding(id.node.name),\n+                                          DefPathData::Binding(id.node.name.as_str()),\n                                           REGULAR_SPACE);\n                 self.parent_def = Some(def);\n             }\n@@ -282,7 +284,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n     fn visit_lifetime_def(&mut self, def: &'a LifetimeDef) {\n         self.create_def(def.lifetime.id,\n-                        DefPathData::LifetimeDef(def.lifetime.ident.name),\n+                        DefPathData::LifetimeDef(def.lifetime.ident.name.as_str()),\n                         REGULAR_SPACE);\n     }\n "}, {"sha": "7bd2e5eceaec6faa8c974236e83323e1a26cc288", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -80,8 +80,10 @@ impl DefPathTable {\n \n     #[inline(always)]\n     pub fn def_path_hash(&self, index: DefIndex) -> DefPathHash {\n-        self.def_path_hashes[index.address_space().index()]\n-                            [index.as_array_index()]\n+        let ret = self.def_path_hashes[index.address_space().index()]\n+                                      [index.as_array_index()];\n+        debug!(\"def_path_hash({:?}) = {:?}\", index, ret);\n+        return ret\n     }\n \n     pub fn add_def_path_hashes_to(&self,\n@@ -213,7 +215,7 @@ impl DefKey {\n             DefPathData::Binding(name) |\n             DefPathData::Field(name) |\n             DefPathData::GlobalMetaData(name) => {\n-                (*name.as_str()).hash(&mut hasher);\n+                name.hash(&mut hasher);\n             }\n \n             DefPathData::Impl |\n@@ -347,31 +349,31 @@ pub enum DefPathData {\n     /// An impl\n     Impl,\n     /// Something in the type NS\n-    TypeNs(Symbol),\n+    TypeNs(InternedString),\n     /// Something in the value NS\n-    ValueNs(Symbol),\n+    ValueNs(InternedString),\n     /// A module declaration\n-    Module(Symbol),\n+    Module(InternedString),\n     /// A macro rule\n-    MacroDef(Symbol),\n+    MacroDef(InternedString),\n     /// A closure expression\n     ClosureExpr,\n \n     // Subportions of items\n     /// A type parameter (generic parameter)\n-    TypeParam(Symbol),\n+    TypeParam(InternedString),\n     /// A lifetime definition\n-    LifetimeDef(Symbol),\n+    LifetimeDef(InternedString),\n     /// A variant of a enum\n-    EnumVariant(Symbol),\n+    EnumVariant(InternedString),\n     /// A struct field\n-    Field(Symbol),\n+    Field(InternedString),\n     /// Implicit ctor for a tuple-like struct\n     StructCtor,\n     /// Initializer for a const\n     Initializer,\n     /// Pattern binding\n-    Binding(Symbol),\n+    Binding(InternedString),\n     /// An `impl Trait` type node.\n     ImplTrait,\n     /// A `typeof` type node.\n@@ -380,7 +382,7 @@ pub enum DefPathData {\n     /// GlobalMetaData identifies a piece of crate metadata that is global to\n     /// a whole crate (as opposed to just one item). GlobalMetaData components\n     /// are only supposed to show up right below the crate root.\n-    GlobalMetaData(Symbol)\n+    GlobalMetaData(InternedString)\n }\n \n #[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug,\n@@ -601,7 +603,7 @@ impl Definitions {\n }\n \n impl DefPathData {\n-    pub fn get_opt_name(&self) -> Option<Symbol> {\n+    pub fn get_opt_name(&self) -> Option<InternedString> {\n         use self::DefPathData::*;\n         match *self {\n             TypeNs(name) |\n@@ -639,7 +641,7 @@ impl DefPathData {\n             Binding(name) |\n             Field(name) |\n             GlobalMetaData(name) => {\n-                return name.as_str();\n+                return name\n             }\n \n             // note that this does not show up in user printouts\n@@ -684,7 +686,7 @@ macro_rules! define_global_metadata_kind {\n                     definitions.create_def_with_parent(\n                         CRATE_DEF_INDEX,\n                         ast::DUMMY_NODE_ID,\n-                        DefPathData::GlobalMetaData(instance.name()),\n+                        DefPathData::GlobalMetaData(instance.name().as_str()),\n                         GLOBAL_MD_ADDRESS_SPACE,\n                         Mark::root()\n                     );\n@@ -698,7 +700,7 @@ macro_rules! define_global_metadata_kind {\n                 let def_key = DefKey {\n                     parent: Some(CRATE_DEF_INDEX),\n                     disambiguated_data: DisambiguatedDefPathData {\n-                        data: DefPathData::GlobalMetaData(self.name()),\n+                        data: DefPathData::GlobalMetaData(self.name().as_str()),\n                         disambiguator: 0,\n                     }\n                 };"}, {"sha": "d043d8346e6a850a781a3849b160c74f79a17a62", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -878,7 +878,17 @@ impl<'hir> Map<'hir> {\n \n             Some(RootCrate(_)) => self.forest.krate.span,\n             Some(NotPresent) | None => {\n-                bug!(\"hir::map::Map::span: id not in map: {:?}\", id)\n+                // Some nodes, notably macro definitions, are not\n+                // present in the map for whatever reason, but\n+                // they *do* have def-ids. So if we encounter an\n+                // empty hole, check for that case.\n+                if let Some(def_index) = self.definitions.opt_def_index(id) {\n+                    let def_path_hash = self.definitions.def_path_hash(def_index);\n+                    self.dep_graph.read(def_path_hash.to_dep_node(DepKind::Hir));\n+                    DUMMY_SP\n+                } else {\n+                    bug!(\"hir::map::Map::span: id not in map: {:?}\", id)\n+                }\n             }\n         }\n     }"}, {"sha": "d3fff4c66af07850ccd08623776ad07d4c7ccfbb", "filename": "src/librustc/infer/error_reporting/anon_anon_conflict.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fanon_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fanon_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fanon_anon_conflict.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -209,18 +209,19 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n \n         match arg.node {\n             hir::TyRptr(ref lifetime, _) => {\n-                match self.infcx.tcx.named_region_map.defs.get(&lifetime.id) {\n+                let hir_id = self.infcx.tcx.hir.node_to_hir_id(lifetime.id);\n+                match self.infcx.tcx.named_region(hir_id) {\n                     // the lifetime of the TyRptr\n-                    Some(&rl::Region::LateBoundAnon(debruijn_index, anon_index)) => {\n+                    Some(rl::Region::LateBoundAnon(debruijn_index, anon_index)) => {\n                         if debruijn_index.depth == 1 && anon_index == br_index {\n                             self.found_type = Some(arg);\n                             return; // we can stop visiting now\n                         }\n                     }\n-                    Some(&rl::Region::Static) |\n-                    Some(&rl::Region::EarlyBound(_, _)) |\n-                    Some(&rl::Region::LateBound(_, _)) |\n-                    Some(&rl::Region::Free(_, _)) |\n+                    Some(rl::Region::Static) |\n+                    Some(rl::Region::EarlyBound(_, _)) |\n+                    Some(rl::Region::LateBound(_, _)) |\n+                    Some(rl::Region::Free(_, _)) |\n                     None => {\n                         debug!(\"no arg found\");\n                     }\n@@ -272,17 +273,18 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for TyPathVisitor<'a, 'gcx, 'tcx> {\n             _ => return,\n         };\n \n-        match self.infcx.tcx.named_region_map.defs.get(&lifetime.id) {\n+        let hir_id = self.infcx.tcx.hir.node_to_hir_id(lifetime.id);\n+        match self.infcx.tcx.named_region(hir_id) {\n             // the lifetime of the TyPath!\n-            Some(&rl::Region::LateBoundAnon(debruijn_index, anon_index)) => {\n+            Some(rl::Region::LateBoundAnon(debruijn_index, anon_index)) => {\n                 if debruijn_index.depth == 1 && anon_index == br_index {\n                     self.found_it = true;\n                 }\n             }\n-            Some(&rl::Region::Static) |\n-            Some(&rl::Region::EarlyBound(_, _)) |\n-            Some(&rl::Region::LateBound(_, _)) |\n-            Some(&rl::Region::Free(_, _)) |\n+            Some(rl::Region::Static) |\n+            Some(rl::Region::EarlyBound(_, _)) |\n+            Some(rl::Region::LateBound(_, _)) |\n+            Some(rl::Region::Free(_, _)) |\n             None => {\n                 debug!(\"no arg found\");\n             }"}, {"sha": "ff52f1e4e39ff785cfc35f4efbbc5594d818aa7e", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -357,7 +357,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 // for imported and non-imported crates\n                 if exp_path == found_path\n                 || exp_abs_path == found_abs_path {\n-                    let crate_name = self.tcx.sess.cstore.crate_name(did1.krate);\n+                    let crate_name = self.tcx.crate_name(did1.krate);\n                     err.span_note(sp, &format!(\"Perhaps two different versions \\\n                                                 of crate `{}` are being used?\",\n                                                crate_name));"}, {"sha": "a7d874386d1c9c82b4fff0385449a7c1e6ce14e3", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 81, "deletions": 120, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -23,16 +23,15 @@\n //! probably get a better home if someone can find one.\n \n use hir::def;\n-use hir::def_id::{CrateNum, DefId, DefIndex};\n+use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use hir::map as hir_map;\n use hir::map::definitions::{Definitions, DefKey, DefPathTable};\n use hir::svh::Svh;\n use ich;\n-use middle::lang_items;\n use ty::{self, TyCtxt};\n use session::Session;\n use session::search_paths::PathKind;\n-use util::nodemap::{NodeSet, DefIdMap};\n+use util::nodemap::NodeSet;\n \n use std::any::Any;\n use std::path::{Path, PathBuf};\n@@ -43,8 +42,6 @@ use syntax::ext::base::SyntaxExtension;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use rustc_back::target::Target;\n-use hir;\n-use rustc_back::PanicStrategy;\n \n pub use self::NativeLibraryKind::*;\n \n@@ -223,75 +220,44 @@ pub trait MetadataLoader {\n \n /// A store of Rust crates, through with their metadata\n /// can be accessed.\n+///\n+/// Note that this trait should probably not be expanding today. All new\n+/// functionality should be driven through queries instead!\n+///\n+/// If you find a method on this trait named `{name}_untracked` it signifies\n+/// that it's *not* tracked for dependency information throughout compilation\n+/// (it'd break incremental compilation) and should only be called pre-HIR (e.g.\n+/// during resolve)\n pub trait CrateStore {\n     fn crate_data_as_rc_any(&self, krate: CrateNum) -> Rc<Any>;\n \n     // access to the metadata loader\n     fn metadata_loader(&self) -> &MetadataLoader;\n \n-    // item info\n-    fn visibility(&self, def: DefId) -> ty::Visibility;\n-    fn visible_parent_map<'a>(&'a self, sess: &Session) -> ::std::cell::Ref<'a, DefIdMap<DefId>>;\n-    fn item_generics_cloned(&self, def: DefId) -> ty::Generics;\n-\n-    // trait info\n-    fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId>;\n-\n-    // impl info\n-    fn impl_defaultness(&self, def: DefId) -> hir::Defaultness;\n-\n-    // trait/impl-item info\n-    fn associated_item_cloned(&self, def: DefId) -> ty::AssociatedItem;\n-\n-    // flags\n-    fn is_dllimport_foreign_item(&self, def: DefId) -> bool;\n-    fn is_statically_included_foreign_item(&self, def_id: DefId) -> bool;\n-\n-    // crate metadata\n-    fn dep_kind(&self, cnum: CrateNum) -> DepKind;\n-    fn export_macros(&self, cnum: CrateNum);\n-    fn lang_items(&self, cnum: CrateNum) -> Vec<(DefIndex, usize)>;\n-    fn missing_lang_items(&self, cnum: CrateNum) -> Vec<lang_items::LangItem>;\n-    fn is_compiler_builtins(&self, cnum: CrateNum) -> bool;\n-    fn is_sanitizer_runtime(&self, cnum: CrateNum) -> bool;\n-    fn is_profiler_runtime(&self, cnum: CrateNum) -> bool;\n-    fn panic_strategy(&self, cnum: CrateNum) -> PanicStrategy;\n-    /// The name of the crate as it is referred to in source code of the current\n-    /// crate.\n-    fn crate_name(&self, cnum: CrateNum) -> Symbol;\n-    /// The name of the crate as it is stored in the crate's metadata.\n-    fn original_crate_name(&self, cnum: CrateNum) -> Symbol;\n-    fn crate_hash(&self, cnum: CrateNum) -> Svh;\n-    fn crate_disambiguator(&self, cnum: CrateNum) -> Symbol;\n-    fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>;\n-    fn derive_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>;\n-    fn native_libraries(&self, cnum: CrateNum) -> Vec<NativeLibrary>;\n-    fn exported_symbols(&self, cnum: CrateNum) -> Vec<DefId>;\n-    fn is_no_builtins(&self, cnum: CrateNum) -> bool;\n-\n     // resolve\n     fn def_key(&self, def: DefId) -> DefKey;\n     fn def_path(&self, def: DefId) -> hir_map::DefPath;\n     fn def_path_hash(&self, def: DefId) -> hir_map::DefPathHash;\n     fn def_path_table(&self, cnum: CrateNum) -> Rc<DefPathTable>;\n-    fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>;\n-    fn item_children(&self, did: DefId, sess: &Session) -> Vec<def::Export>;\n-    fn load_macro(&self, did: DefId, sess: &Session) -> LoadedMacro;\n \n-    // misc. metadata\n-    fn item_body<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                           -> &'tcx hir::Body;\n+    // \"queries\" used in resolve that aren't tracked for incremental compilation\n+    fn visibility_untracked(&self, def: DefId) -> ty::Visibility;\n+    fn export_macros_untracked(&self, cnum: CrateNum);\n+    fn dep_kind_untracked(&self, cnum: CrateNum) -> DepKind;\n+    fn crate_name_untracked(&self, cnum: CrateNum) -> Symbol;\n+    fn struct_field_names_untracked(&self, def: DefId) -> Vec<ast::Name>;\n+    fn item_children_untracked(&self, did: DefId, sess: &Session) -> Vec<def::Export>;\n+    fn load_macro_untracked(&self, did: DefId, sess: &Session) -> LoadedMacro;\n+    fn extern_mod_stmt_cnum_untracked(&self, emod_id: ast::NodeId) -> Option<CrateNum>;\n+    fn item_generics_cloned_untracked(&self, def: DefId) -> ty::Generics;\n+    fn associated_item_cloned_untracked(&self, def: DefId) -> ty::AssociatedItem;\n+    fn postorder_cnums_untracked(&self) -> Vec<CrateNum>;\n \n     // This is basically a 1-based range of ints, which is a little\n     // silly - I may fix that.\n-    fn crates(&self) -> Vec<CrateNum>;\n-    fn used_libraries(&self) -> Vec<NativeLibrary>;\n-    fn used_link_args(&self) -> Vec<String>;\n+    fn crates_untracked(&self) -> Vec<CrateNum>;\n \n     // utility functions\n-    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>;\n-    fn used_crate_source(&self, cnum: CrateNum) -> CrateSource;\n-    fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum>;\n     fn encode_metadata<'a, 'tcx>(&self,\n                                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  link_meta: &LinkMeta,\n@@ -336,57 +302,18 @@ impl CrateStore for DummyCrateStore {\n     fn crate_data_as_rc_any(&self, krate: CrateNum) -> Rc<Any>\n         { bug!(\"crate_data_as_rc_any\") }\n     // item info\n-    fn visibility(&self, def: DefId) -> ty::Visibility { bug!(\"visibility\") }\n-    fn visible_parent_map<'a>(&'a self, session: &Session)\n-        -> ::std::cell::Ref<'a, DefIdMap<DefId>>\n-    {\n-        bug!(\"visible_parent_map\")\n-    }\n-    fn item_generics_cloned(&self, def: DefId) -> ty::Generics\n+    fn visibility_untracked(&self, def: DefId) -> ty::Visibility { bug!(\"visibility\") }\n+    fn item_generics_cloned_untracked(&self, def: DefId) -> ty::Generics\n         { bug!(\"item_generics_cloned\") }\n \n-    // trait info\n-    fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId> { vec![] }\n-\n-    // impl info\n-    fn impl_defaultness(&self, def: DefId) -> hir::Defaultness { bug!(\"impl_defaultness\") }\n-\n     // trait/impl-item info\n-    fn associated_item_cloned(&self, def: DefId) -> ty::AssociatedItem\n+    fn associated_item_cloned_untracked(&self, def: DefId) -> ty::AssociatedItem\n         { bug!(\"associated_item_cloned\") }\n \n-    // flags\n-    fn is_dllimport_foreign_item(&self, id: DefId) -> bool { false }\n-    fn is_statically_included_foreign_item(&self, def_id: DefId) -> bool { false }\n-\n     // crate metadata\n-    fn lang_items(&self, cnum: CrateNum) -> Vec<(DefIndex, usize)>\n-        { bug!(\"lang_items\") }\n-    fn missing_lang_items(&self, cnum: CrateNum) -> Vec<lang_items::LangItem>\n-        { bug!(\"missing_lang_items\") }\n-    fn dep_kind(&self, cnum: CrateNum) -> DepKind { bug!(\"is_explicitly_linked\") }\n-    fn export_macros(&self, cnum: CrateNum) { bug!(\"export_macros\") }\n-    fn is_compiler_builtins(&self, cnum: CrateNum) -> bool { bug!(\"is_compiler_builtins\") }\n-    fn is_profiler_runtime(&self, cnum: CrateNum) -> bool { bug!(\"is_profiler_runtime\") }\n-    fn is_sanitizer_runtime(&self, cnum: CrateNum) -> bool { bug!(\"is_sanitizer_runtime\") }\n-    fn panic_strategy(&self, cnum: CrateNum) -> PanicStrategy {\n-        bug!(\"panic_strategy\")\n-    }\n-    fn crate_name(&self, cnum: CrateNum) -> Symbol { bug!(\"crate_name\") }\n-    fn original_crate_name(&self, cnum: CrateNum) -> Symbol {\n-        bug!(\"original_crate_name\")\n-    }\n-    fn crate_hash(&self, cnum: CrateNum) -> Svh { bug!(\"crate_hash\") }\n-    fn crate_disambiguator(&self, cnum: CrateNum)\n-                           -> Symbol { bug!(\"crate_disambiguator\") }\n-    fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>\n-        { bug!(\"plugin_registrar_fn\") }\n-    fn derive_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>\n-        { bug!(\"derive_registrar_fn\") }\n-    fn native_libraries(&self, cnum: CrateNum) -> Vec<NativeLibrary>\n-        { bug!(\"native_libraries\") }\n-    fn exported_symbols(&self, cnum: CrateNum) -> Vec<DefId> { bug!(\"exported_symbols\") }\n-    fn is_no_builtins(&self, cnum: CrateNum) -> bool { bug!(\"is_no_builtins\") }\n+    fn dep_kind_untracked(&self, cnum: CrateNum) -> DepKind { bug!(\"is_explicitly_linked\") }\n+    fn export_macros_untracked(&self, cnum: CrateNum) { bug!(\"export_macros\") }\n+    fn crate_name_untracked(&self, cnum: CrateNum) -> Symbol { bug!(\"crate_name\") }\n \n     // resolve\n     fn def_key(&self, def: DefId) -> DefKey { bug!(\"def_key\") }\n@@ -399,29 +326,18 @@ impl CrateStore for DummyCrateStore {\n     fn def_path_table(&self, cnum: CrateNum) -> Rc<DefPathTable> {\n         bug!(\"def_path_table\")\n     }\n-    fn struct_field_names(&self, def: DefId) -> Vec<ast::Name> { bug!(\"struct_field_names\") }\n-    fn item_children(&self, did: DefId, sess: &Session) -> Vec<def::Export> {\n+    fn struct_field_names_untracked(&self, def: DefId) -> Vec<ast::Name> {\n+        bug!(\"struct_field_names\")\n+    }\n+    fn item_children_untracked(&self, did: DefId, sess: &Session) -> Vec<def::Export> {\n         bug!(\"item_children\")\n     }\n-    fn load_macro(&self, did: DefId, sess: &Session) -> LoadedMacro { bug!(\"load_macro\") }\n+    fn load_macro_untracked(&self, did: DefId, sess: &Session) -> LoadedMacro { bug!(\"load_macro\") }\n \n-    // misc. metadata\n-    fn item_body<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                           -> &'tcx hir::Body {\n-        bug!(\"item_body\")\n-    }\n-\n-    // This is basically a 1-based range of ints, which is a little\n-    // silly - I may fix that.\n-    fn crates(&self) -> Vec<CrateNum> { vec![] }\n-    fn used_libraries(&self) -> Vec<NativeLibrary> { vec![] }\n-    fn used_link_args(&self) -> Vec<String> { vec![] }\n+    fn crates_untracked(&self) -> Vec<CrateNum> { vec![] }\n \n     // utility functions\n-    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>\n-        { vec![] }\n-    fn used_crate_source(&self, cnum: CrateNum) -> CrateSource { bug!(\"used_crate_source\") }\n-    fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum> { None }\n+    fn extern_mod_stmt_cnum_untracked(&self, emod_id: ast::NodeId) -> Option<CrateNum> { None }\n     fn encode_metadata<'a, 'tcx>(&self,\n                                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  link_meta: &LinkMeta,\n@@ -430,6 +346,7 @@ impl CrateStore for DummyCrateStore {\n         bug!(\"encode_metadata\")\n     }\n     fn metadata_encoding_version(&self) -> &[u8] { bug!(\"metadata_encoding_version\") }\n+    fn postorder_cnums_untracked(&self) -> Vec<CrateNum> { bug!(\"postorder_cnums_untracked\") }\n \n     // access to the metadata loader\n     fn metadata_loader(&self) -> &MetadataLoader { bug!(\"metadata_loader\") }\n@@ -439,3 +356,47 @@ pub trait CrateLoader {\n     fn process_item(&mut self, item: &ast::Item, defs: &Definitions);\n     fn postprocess(&mut self, krate: &ast::Crate);\n }\n+\n+// This method is used when generating the command line to pass through to\n+// system linker. The linker expects undefined symbols on the left of the\n+// command line to be defined in libraries on the right, not the other way\n+// around. For more info, see some comments in the add_used_library function\n+// below.\n+//\n+// In order to get this left-to-right dependency ordering, we perform a\n+// topological sort of all crates putting the leaves at the right-most\n+// positions.\n+pub fn used_crates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)> {\n+    let mut libs = tcx.crates()\n+        .iter()\n+        .cloned()\n+        .filter_map(|cnum| {\n+            if tcx.dep_kind(cnum).macros_only() {\n+                return None\n+            }\n+            let source = tcx.used_crate_source(cnum);\n+            let path = match prefer {\n+                LinkagePreference::RequireDynamic => source.dylib.clone().map(|p| p.0),\n+                LinkagePreference::RequireStatic => source.rlib.clone().map(|p| p.0),\n+            };\n+            let path = match path {\n+                Some(p) => LibSource::Some(p),\n+                None => {\n+                    if source.rmeta.is_some() {\n+                        LibSource::MetadataOnly\n+                    } else {\n+                        LibSource::None\n+                    }\n+                }\n+            };\n+            Some((cnum, path))\n+        })\n+        .collect::<Vec<_>>();\n+    let mut ordering = tcx.postorder_cnums(LOCAL_CRATE);\n+    Rc::make_mut(&mut ordering).reverse();\n+    libs.sort_by_key(|&(a, _)| {\n+        ordering.iter().position(|x| *x == a)\n+    });\n+    libs\n+}"}, {"sha": "d79e90690cac2fe24d07d97589067cd2a8409df5", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -469,7 +469,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     fn should_warn_about_field(&mut self, field: &hir::StructField) -> bool {\n         let field_type = self.tcx.type_of(self.tcx.hir.local_def_id(field.id));\n         let is_marker_field = match field_type.ty_to_def_id() {\n-            Some(def_id) => self.tcx.lang_items.items().iter().any(|item| *item == Some(def_id)),\n+            Some(def_id) => self.tcx.lang_items().items().iter().any(|item| *item == Some(def_id)),\n             _ => false\n         };\n         !field.is_positional()"}, {"sha": "1c7d0b76a643ea17e8b5a40c4cf02363345155dc", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 37, "deletions": 38, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -66,7 +66,7 @@ use hir::def_id::CrateNum;\n use session;\n use session::config;\n use ty::TyCtxt;\n-use middle::cstore::DepKind;\n+use middle::cstore::{self, DepKind};\n use middle::cstore::LinkagePreference::{self, RequireStatic, RequireDynamic};\n use util::nodemap::FxHashMap;\n use rustc_back::PanicStrategy;\n@@ -132,12 +132,12 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             if let Some(v) = attempt_static(tcx) {\n                 return v;\n             }\n-            for cnum in sess.cstore.crates() {\n-                if sess.cstore.dep_kind(cnum).macros_only() { continue }\n-                let src = sess.cstore.used_crate_source(cnum);\n+            for &cnum in tcx.crates().iter() {\n+                if tcx.dep_kind(cnum).macros_only() { continue }\n+                let src = tcx.used_crate_source(cnum);\n                 if src.rlib.is_some() { continue }\n                 sess.err(&format!(\"dependency `{}` not found in rlib format\",\n-                                  sess.cstore.crate_name(cnum)));\n+                                  tcx.crate_name(cnum)));\n             }\n             return Vec::new();\n         }\n@@ -165,24 +165,23 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Sweep all crates for found dylibs. Add all dylibs, as well as their\n     // dependencies, ensuring there are no conflicts. The only valid case for a\n     // dependency to be relied upon twice is for both cases to rely on a dylib.\n-    for cnum in sess.cstore.crates() {\n-        if sess.cstore.dep_kind(cnum).macros_only() { continue }\n-        let name = sess.cstore.crate_name(cnum);\n-        let src = sess.cstore.used_crate_source(cnum);\n+    for &cnum in tcx.crates().iter() {\n+        if tcx.dep_kind(cnum).macros_only() { continue }\n+        let name = tcx.crate_name(cnum);\n+        let src = tcx.used_crate_source(cnum);\n         if src.dylib.is_some() {\n             info!(\"adding dylib: {}\", name);\n-            add_library(sess, cnum, RequireDynamic, &mut formats);\n-            let deps = tcx.dylib_dependency_formats(cnum.as_def_id());\n+            add_library(tcx, cnum, RequireDynamic, &mut formats);\n+            let deps = tcx.dylib_dependency_formats(cnum);\n             for &(depnum, style) in deps.iter() {\n-                info!(\"adding {:?}: {}\", style,\n-                      sess.cstore.crate_name(depnum));\n-                add_library(sess, depnum, style, &mut formats);\n+                info!(\"adding {:?}: {}\", style, tcx.crate_name(depnum));\n+                add_library(tcx, depnum, style, &mut formats);\n             }\n         }\n     }\n \n     // Collect what we've got so far in the return vector.\n-    let last_crate = sess.cstore.crates().len();\n+    let last_crate = tcx.crates().len();\n     let mut ret = (1..last_crate+1).map(|cnum| {\n         match formats.get(&CrateNum::new(cnum)) {\n             Some(&RequireDynamic) => Linkage::Dynamic,\n@@ -196,14 +195,14 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     //\n     // If the crate hasn't been included yet and it's not actually required\n     // (e.g. it's an allocator) then we skip it here as well.\n-    for cnum in sess.cstore.crates() {\n-        let src = sess.cstore.used_crate_source(cnum);\n+    for &cnum in tcx.crates().iter() {\n+        let src = tcx.used_crate_source(cnum);\n         if src.dylib.is_none() &&\n            !formats.contains_key(&cnum) &&\n-           sess.cstore.dep_kind(cnum) == DepKind::Explicit {\n+           tcx.dep_kind(cnum) == DepKind::Explicit {\n             assert!(src.rlib.is_some() || src.rmeta.is_some());\n-            info!(\"adding staticlib: {}\", sess.cstore.crate_name(cnum));\n-            add_library(sess, cnum, RequireStatic, &mut formats);\n+            info!(\"adding staticlib: {}\", tcx.crate_name(cnum));\n+            add_library(tcx, cnum, RequireStatic, &mut formats);\n             ret[cnum.as_usize() - 1] = Linkage::Static;\n         }\n     }\n@@ -215,7 +214,7 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Things like allocators and panic runtimes may not have been activated\n     // quite yet, so do so here.\n     activate_injected_dep(sess.injected_panic_runtime.get(), &mut ret,\n-                          &|cnum| tcx.is_panic_runtime(cnum.as_def_id()));\n+                          &|cnum| tcx.is_panic_runtime(cnum));\n     activate_injected_allocator(sess, &mut ret);\n \n     // When dylib B links to dylib A, then when using B we must also link to A.\n@@ -226,7 +225,7 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // making sure that everything is available in the requested format.\n     for (cnum, kind) in ret.iter().enumerate() {\n         let cnum = CrateNum::new(cnum + 1);\n-        let src = sess.cstore.used_crate_source(cnum);\n+        let src = tcx.used_crate_source(cnum);\n         match *kind {\n             Linkage::NotLinked |\n             Linkage::IncludedFromDylib => {}\n@@ -237,7 +236,7 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     Linkage::Static => \"rlib\",\n                     _ => \"dylib\",\n                 };\n-                let name = sess.cstore.crate_name(cnum);\n+                let name = tcx.crate_name(cnum);\n                 sess.err(&format!(\"crate `{}` required to be available in {}, \\\n                                   but it was not available in this form\",\n                                   name, kind));\n@@ -248,7 +247,7 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     return ret;\n }\n \n-fn add_library(sess: &session::Session,\n+fn add_library(tcx: TyCtxt,\n                cnum: CrateNum,\n                link: LinkagePreference,\n                m: &mut FxHashMap<CrateNum, LinkagePreference>) {\n@@ -262,8 +261,8 @@ fn add_library(sess: &session::Session,\n             // This error is probably a little obscure, but I imagine that it\n             // can be refined over time.\n             if link2 != link || link == RequireStatic {\n-                sess.struct_err(&format!(\"cannot satisfy dependencies so `{}` only \\\n-                                          shows up once\", sess.cstore.crate_name(cnum)))\n+                tcx.sess.struct_err(&format!(\"cannot satisfy dependencies so `{}` only \\\n+                                              shows up once\", tcx.crate_name(cnum)))\n                     .help(\"having upstream crates all available in one format \\\n                            will likely make this go away\")\n                     .emit();\n@@ -275,16 +274,16 @@ fn add_library(sess: &session::Session,\n \n fn attempt_static<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<DependencyList> {\n     let sess = &tcx.sess;\n-    let crates = sess.cstore.used_crates(RequireStatic);\n+    let crates = cstore::used_crates(tcx, RequireStatic);\n     if !crates.iter().by_ref().all(|&(_, ref p)| p.is_some()) {\n         return None\n     }\n \n     // All crates are available in an rlib format, so we're just going to link\n     // everything in explicitly so long as it's actually required.\n-    let last_crate = sess.cstore.crates().len();\n+    let last_crate = tcx.crates().len();\n     let mut ret = (1..last_crate+1).map(|cnum| {\n-        if sess.cstore.dep_kind(CrateNum::new(cnum)) == DepKind::Explicit {\n+        if tcx.dep_kind(CrateNum::new(cnum)) == DepKind::Explicit {\n             Linkage::Static\n         } else {\n             Linkage::NotLinked\n@@ -295,7 +294,7 @@ fn attempt_static<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<DependencyLis\n     // explicitly linked, which is the case for any injected dependency. Handle\n     // that here and activate them.\n     activate_injected_dep(sess.injected_panic_runtime.get(), &mut ret,\n-                          &|cnum| tcx.is_panic_runtime(cnum.as_def_id()));\n+                          &|cnum| tcx.is_panic_runtime(cnum));\n     activate_injected_allocator(sess, &mut ret);\n \n     Some(ret)\n@@ -355,15 +354,15 @@ fn verify_ok<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, list: &[Linkage]) {\n         }\n         let cnum = CrateNum::new(i + 1);\n \n-        if tcx.is_panic_runtime(cnum.as_def_id()) {\n+        if tcx.is_panic_runtime(cnum) {\n             if let Some((prev, _)) = panic_runtime {\n-                let prev_name = sess.cstore.crate_name(prev);\n-                let cur_name = sess.cstore.crate_name(cnum);\n+                let prev_name = tcx.crate_name(prev);\n+                let cur_name = tcx.crate_name(cnum);\n                 sess.err(&format!(\"cannot link together two \\\n                                    panic runtimes: {} and {}\",\n                                   prev_name, cur_name));\n             }\n-            panic_runtime = Some((cnum, sess.cstore.panic_strategy(cnum)));\n+            panic_runtime = Some((cnum, tcx.panic_strategy(cnum)));\n         }\n     }\n \n@@ -379,7 +378,7 @@ fn verify_ok<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, list: &[Linkage]) {\n             sess.err(&format!(\"the linked panic runtime `{}` is \\\n                                not compiled with this crate's \\\n                                panic strategy `{}`\",\n-                              sess.cstore.crate_name(cnum),\n+                              tcx.crate_name(cnum),\n                               desired_strategy.desc()));\n         }\n \n@@ -395,8 +394,8 @@ fn verify_ok<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, list: &[Linkage]) {\n                 continue\n             }\n             let cnum = CrateNum::new(i + 1);\n-            let found_strategy = sess.cstore.panic_strategy(cnum);\n-            let is_compiler_builtins = sess.cstore.is_compiler_builtins(cnum);\n+            let found_strategy = tcx.panic_strategy(cnum);\n+            let is_compiler_builtins = tcx.is_compiler_builtins(cnum);\n             if is_compiler_builtins || desired_strategy == found_strategy {\n                 continue\n             }\n@@ -405,7 +404,7 @@ fn verify_ok<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, list: &[Linkage]) {\n                                panic strategy `{}` which is \\\n                                incompatible with this crate's \\\n                                strategy of `{}`\",\n-                              sess.cstore.crate_name(cnum),\n+                              tcx.crate_name(cnum),\n                               found_strategy.desc(),\n                               desired_strategy.desc()));\n         }"}, {"sha": "73f78477b0a3f191788b3500c31e432f22c30cd2", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -211,9 +211,9 @@ enum OverloadedCallType {\n impl OverloadedCallType {\n     fn from_trait_id(tcx: TyCtxt, trait_id: DefId) -> OverloadedCallType {\n         for &(maybe_function_trait, overloaded_call_type) in &[\n-            (tcx.lang_items.fn_once_trait(), FnOnceOverloadedCall),\n-            (tcx.lang_items.fn_mut_trait(), FnMutOverloadedCall),\n-            (tcx.lang_items.fn_trait(), FnOverloadedCall)\n+            (tcx.lang_items().fn_once_trait(), FnOnceOverloadedCall),\n+            (tcx.lang_items().fn_mut_trait(), FnMutOverloadedCall),\n+            (tcx.lang_items().fn_trait(), FnOverloadedCall)\n         ] {\n             match maybe_function_trait {\n                 Some(function_trait) if function_trait == trait_id => {"}, {"sha": "cb59d9870faacfd3042e0979c1af4b5258f38153", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 26, "deletions": 50, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -21,10 +21,8 @@\n \n pub use self::LangItem::*;\n \n-use hir::map as hir_map;\n-use session::Session;\n use hir::def_id::DefId;\n-use ty;\n+use ty::{self, TyCtxt};\n use middle::weak_lang_items;\n use util::nodemap::FxHashMap;\n \n@@ -116,9 +114,7 @@ impl LanguageItems {\n struct LanguageItemCollector<'a, 'tcx: 'a> {\n     items: LanguageItems,\n \n-    hir_map: &'a hir_map::Map<'tcx>,\n-\n-    session: &'a Session,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     item_refs: FxHashMap<&'static str, usize>,\n }\n@@ -129,10 +125,11 @@ impl<'a, 'v, 'tcx> ItemLikeVisitor<'v> for LanguageItemCollector<'a, 'tcx> {\n             let item_index = self.item_refs.get(&*value.as_str()).cloned();\n \n             if let Some(item_index) = item_index {\n-                self.collect_item(item_index, self.hir_map.local_def_id(item.id))\n+                let def_id = self.tcx.hir.local_def_id(item.id);\n+                self.collect_item(item_index, def_id);\n             } else {\n-                let span = self.hir_map.span(item.id);\n-                span_err!(self.session, span, E0522,\n+                let span = self.tcx.hir.span(item.id);\n+                span_err!(self.tcx.sess, span, E0522,\n                           \"definition of an unknown language item: `{}`.\",\n                           value);\n             }\n@@ -149,45 +146,41 @@ impl<'a, 'v, 'tcx> ItemLikeVisitor<'v> for LanguageItemCollector<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n-    pub fn new(session: &'a Session, hir_map: &'a hir_map::Map<'tcx>)\n-               -> LanguageItemCollector<'a, 'tcx> {\n+    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> LanguageItemCollector<'a, 'tcx> {\n         let mut item_refs = FxHashMap();\n \n         $( item_refs.insert($name, $variant as usize); )*\n \n         LanguageItemCollector {\n-            session,\n-            hir_map,\n+            tcx,\n             items: LanguageItems::new(),\n             item_refs,\n         }\n     }\n \n-    pub fn collect_item(&mut self, item_index: usize,\n-                        item_def_id: DefId) {\n+    fn collect_item(&mut self, item_index: usize, item_def_id: DefId) {\n         // Check for duplicates.\n         match self.items.items[item_index] {\n             Some(original_def_id) if original_def_id != item_def_id => {\n-                let cstore = &self.session.cstore;\n                 let name = LanguageItems::item_name(item_index);\n-                let mut err = match self.hir_map.span_if_local(item_def_id) {\n+                let mut err = match self.tcx.hir.span_if_local(item_def_id) {\n                     Some(span) => struct_span_err!(\n-                        self.session,\n+                        self.tcx.sess,\n                         span,\n                         E0152,\n                         \"duplicate lang item found: `{}`.\",\n                         name),\n-                    None => self.session.struct_err(&format!(\n+                    None => self.tcx.sess.struct_err(&format!(\n                             \"duplicate lang item in crate `{}`: `{}`.\",\n-                            cstore.crate_name(item_def_id.krate),\n+                            self.tcx.crate_name(item_def_id.krate),\n                             name)),\n                 };\n-                if let Some(span) = self.hir_map.span_if_local(original_def_id) {\n+                if let Some(span) = self.tcx.hir.span_if_local(original_def_id) {\n                     span_note!(&mut err, span,\n                                \"first defined here.\");\n                 } else {\n                     err.note(&format!(\"first defined in crate `{}`.\",\n-                                      cstore.crate_name(original_def_id.krate)));\n+                                      self.tcx.crate_name(original_def_id.krate)));\n                 }\n                 err.emit();\n             }\n@@ -199,26 +192,6 @@ impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n         // Matched.\n         self.items.items[item_index] = Some(item_def_id);\n     }\n-\n-    pub fn collect_local_language_items(&mut self, krate: &hir::Crate) {\n-        krate.visit_all_item_likes(self);\n-    }\n-\n-    pub fn collect_external_language_items(&mut self) {\n-        let cstore = &self.session.cstore;\n-\n-        for cnum in cstore.crates() {\n-            for (index, item_index) in cstore.lang_items(cnum) {\n-                let def_id = DefId { krate: cnum, index: index };\n-                self.collect_item(item_index, def_id);\n-            }\n-        }\n-    }\n-\n-    pub fn collect(&mut self, krate: &hir::Crate) {\n-        self.collect_external_language_items();\n-        self.collect_local_language_items(krate);\n-    }\n }\n \n pub fn extract(attrs: &[ast::Attribute]) -> Option<Symbol> {\n@@ -233,14 +206,17 @@ pub fn extract(attrs: &[ast::Attribute]) -> Option<Symbol> {\n     return None;\n }\n \n-pub fn collect_language_items(session: &Session,\n-                              map: &hir_map::Map)\n-                              -> LanguageItems {\n-    let krate: &hir::Crate = map.krate();\n-    let mut collector = LanguageItemCollector::new(session, map);\n-    collector.collect(krate);\n+pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> LanguageItems {\n+    let mut collector = LanguageItemCollector::new(tcx);\n+    for &cnum in tcx.crates().iter() {\n+        for &(index, item_index) in tcx.defined_lang_items(cnum).iter() {\n+            let def_id = DefId { krate: cnum, index: index };\n+            collector.collect_item(item_index, def_id);\n+        }\n+    }\n+    tcx.hir.krate().visit_all_item_likes(&mut collector);\n     let LanguageItemCollector { mut items, .. } = collector;\n-    weak_lang_items::check_crate(krate, session, &mut items);\n+    weak_lang_items::check_crate(tcx, &mut items);\n     items\n }\n \n@@ -366,7 +342,7 @@ language_item_table! {\n \n impl<'a, 'tcx, 'gcx> ty::TyCtxt<'a, 'tcx, 'gcx> {\n     pub fn require_lang_item(&self, lang_item: LangItem) -> DefId {\n-        self.lang_items.require(lang_item).unwrap_or_else(|msg| {\n+        self.lang_items().require(lang_item).unwrap_or_else(|msg| {\n             self.sess.fatal(&msg)\n         })\n     }"}, {"sha": "33f4d4093fe174ca07ea9f0e64e769b6deedfd90", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -392,7 +392,7 @@ fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) ->\n     for (id, _) in &access_levels.map {\n         reachable_context.worklist.push(*id);\n     }\n-    for item in tcx.lang_items.items().iter() {\n+    for item in tcx.lang_items().items().iter() {\n         if let Some(did) = *item {\n             if let Some(node_id) = tcx.hir.as_local_node_id(did) {\n                 reachable_context.worklist.push(node_id);"}, {"sha": "c53e255f0cdab5e5b3fa6ee27dbb77fa585f3197", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -978,7 +978,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             } else {\n                 let cstore = &self.sess.cstore;\n                 self.xcrate_object_lifetime_defaults.entry(def_id).or_insert_with(|| {\n-                    cstore.item_generics_cloned(def_id).types.into_iter().map(|def| {\n+                    cstore.item_generics_cloned_untracked(def_id).types.into_iter().map(|def| {\n                         def.object_lifetime_default\n                     }).collect()\n                 })"}, {"sha": "ecf3aab05d858d60e91b665e820bcba0d8f48ab1", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 104, "deletions": 147, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -15,20 +15,19 @@ pub use self::StabilityLevel::*;\n \n use lint;\n use hir::def::Def;\n-use hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, DefIndex, LOCAL_CRATE};\n+use hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, LOCAL_CRATE};\n use ty::{self, TyCtxt};\n use middle::privacy::AccessLevels;\n-use session::Session;\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, DUMMY_SP};\n use syntax::ast;\n use syntax::ast::{NodeId, Attribute};\n use syntax::feature_gate::{GateIssue, emit_feature_err, find_lang_feature_accepted_version};\n use syntax::attr::{self, Stability, Deprecation};\n-use util::nodemap::{DefIdMap, FxHashSet, FxHashMap};\n+use util::nodemap::{FxHashSet, FxHashMap};\n \n use hir;\n-use hir::{Item, Generics, StructField, Variant};\n+use hir::{Item, Generics, StructField, Variant, HirId};\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n \n use std::mem::replace;\n@@ -63,19 +62,18 @@ pub struct DeprecationEntry {\n     pub attr: Deprecation,\n     /// The def id where the attr was originally attached. `None` for non-local\n     /// `DefId`'s.\n-    origin: Option<DefIndex>,\n+    origin: Option<HirId>,\n }\n \n impl DeprecationEntry {\n-    fn local(attr: Deprecation, id: DefId) -> DeprecationEntry {\n-        assert!(id.is_local());\n+    fn local(attr: Deprecation, id: HirId) -> DeprecationEntry {\n         DeprecationEntry {\n             attr,\n-            origin: Some(id.index),\n+            origin: Some(id),\n         }\n     }\n \n-    fn external(attr: Deprecation) -> DeprecationEntry {\n+    pub fn external(attr: Deprecation) -> DeprecationEntry {\n         DeprecationEntry {\n             attr,\n             origin: None,\n@@ -94,17 +92,14 @@ impl DeprecationEntry {\n pub struct Index<'tcx> {\n     /// This is mostly a cache, except the stabilities of local items\n     /// are filled by the annotator.\n-    stab_map: DefIdMap<Option<&'tcx Stability>>,\n-    depr_map: DefIdMap<Option<DeprecationEntry>>,\n+    stab_map: FxHashMap<HirId, &'tcx Stability>,\n+    depr_map: FxHashMap<HirId, DeprecationEntry>,\n \n     /// Maps for each crate whether it is part of the staged API.\n     staged_api: FxHashMap<CrateNum, bool>,\n \n     /// Features enabled for this crate.\n     active_features: FxHashSet<Symbol>,\n-\n-    /// Features used by this crate. Updated before and during typeck.\n-    used_features: FxHashMap<Symbol, attr::StabilityLevel>\n }\n \n // A private tree-walker for producing an Index.\n@@ -178,8 +173,8 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                     }\n                 }\n \n-                let def_id = self.tcx.hir.local_def_id(id);\n-                self.index.stab_map.insert(def_id, Some(stab));\n+                let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                self.index.stab_map.insert(hir_id, stab);\n \n                 let orig_parent_stab = replace(&mut self.parent_stab, Some(stab));\n                 visit_children(self);\n@@ -188,8 +183,8 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                 debug!(\"annotate: not found, parent = {:?}\", self.parent_stab);\n                 if let Some(stab) = self.parent_stab {\n                     if stab.level.is_unstable() {\n-                        let def_id = self.tcx.hir.local_def_id(id);\n-                        self.index.stab_map.insert(def_id, Some(stab));\n+                        let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                        self.index.stab_map.insert(hir_id, stab);\n                     }\n                 }\n                 visit_children(self);\n@@ -209,8 +204,8 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n             // -Zforce-unstable-if-unmarked is set.\n             if let Some(stab) = self.parent_stab {\n                 if stab.level.is_unstable() {\n-                    let def_id = self.tcx.hir.local_def_id(id);\n-                    self.index.stab_map.insert(def_id, Some(stab));\n+                    let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                    self.index.stab_map.insert(hir_id, stab);\n                 }\n             }\n \n@@ -220,16 +215,17 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                 }\n \n                 // `Deprecation` is just two pointers, no need to intern it\n-                let def_id = self.tcx.hir.local_def_id(id);\n-                let depr_entry = Some(DeprecationEntry::local(depr, def_id));\n-                self.index.depr_map.insert(def_id, depr_entry.clone());\n+                let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                let depr_entry = DeprecationEntry::local(depr, hir_id);\n+                self.index.depr_map.insert(hir_id, depr_entry.clone());\n \n-                let orig_parent_depr = replace(&mut self.parent_depr, depr_entry);\n+                let orig_parent_depr = replace(&mut self.parent_depr,\n+                                               Some(depr_entry));\n                 visit_children(self);\n                 self.parent_depr = orig_parent_depr;\n-            } else if let parent_depr @ Some(_) = self.parent_depr.clone() {\n-                let def_id = self.tcx.hir.local_def_id(id);\n-                self.index.depr_map.insert(def_id, parent_depr);\n+            } else if let Some(parent_depr) = self.parent_depr.clone() {\n+                let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                self.index.depr_map.insert(hir_id, parent_depr);\n                 visit_children(self);\n             } else {\n                 visit_children(self);\n@@ -322,10 +318,10 @@ struct MissingStabilityAnnotations<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx: 'a> MissingStabilityAnnotations<'a, 'tcx> {\n     fn check_missing_stability(&self, id: NodeId, span: Span) {\n-        let def_id = self.tcx.hir.local_def_id(id);\n-        let stab = self.tcx.stability.borrow().stab_map.get(&def_id).cloned();\n+        let hir_id = self.tcx.hir.node_to_hir_id(id);\n+        let stab = self.tcx.stability().local_stability(hir_id);\n         let is_error = !self.tcx.sess.opts.test &&\n-                        (stab == None || stab == Some(None)) &&\n+                        stab.is_none() &&\n                         self.access_levels.is_reachable(id);\n         if is_error {\n             self.tcx.sess.span_err(span, \"This node does not have a stability attribute\");\n@@ -386,60 +382,70 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Index<'tcx> {\n-    /// Construct the stability index for a crate being compiled.\n-    pub fn build(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Index<'tcx> {\n+        let is_staged_api =\n+            tcx.sess.opts.debugging_opts.force_unstable_if_unmarked ||\n+            tcx.sess.features.borrow().staged_api;\n+        let mut staged_api = FxHashMap();\n+        staged_api.insert(LOCAL_CRATE, is_staged_api);\n+        let mut index = Index {\n+            staged_api,\n+            stab_map: FxHashMap(),\n+            depr_map: FxHashMap(),\n+            active_features: FxHashSet(),\n+        };\n+\n         let ref active_lib_features = tcx.sess.features.borrow().declared_lib_features;\n \n         // Put the active features into a map for quick lookup\n-        self.active_features = active_lib_features.iter().map(|&(ref s, _)| s.clone()).collect();\n+        index.active_features = active_lib_features.iter().map(|&(ref s, _)| s.clone()).collect();\n+\n+        {\n+            let krate = tcx.hir.krate();\n+            let mut annotator = Annotator {\n+                tcx,\n+                index: &mut index,\n+                parent_stab: None,\n+                parent_depr: None,\n+                in_trait_impl: false,\n+            };\n \n-        let krate = tcx.hir.krate();\n-        let mut annotator = Annotator {\n-            tcx,\n-            index: self,\n-            parent_stab: None,\n-            parent_depr: None,\n-            in_trait_impl: false,\n-        };\n+            // If the `-Z force-unstable-if-unmarked` flag is passed then we provide\n+            // a parent stability annotation which indicates that this is private\n+            // with the `rustc_private` feature. This is intended for use when\n+            // compiling librustc crates themselves so we can leverage crates.io\n+            // while maintaining the invariant that all sysroot crates are unstable\n+            // by default and are unable to be used.\n+            if tcx.sess.opts.debugging_opts.force_unstable_if_unmarked {\n+                let reason = \"this crate is being loaded from the sysroot, and \\\n+                              unstable location; did you mean to load this crate \\\n+                              from crates.io via `Cargo.toml` instead?\";\n+                let stability = tcx.intern_stability(Stability {\n+                    level: attr::StabilityLevel::Unstable {\n+                        reason: Some(Symbol::intern(reason)),\n+                        issue: 27812,\n+                    },\n+                    feature: Symbol::intern(\"rustc_private\"),\n+                    rustc_depr: None,\n+                });\n+                annotator.parent_stab = Some(stability);\n+            }\n \n-        // If the `-Z force-unstable-if-unmarked` flag is passed then we provide\n-        // a parent stability annotation which indicates that this is private\n-        // with the `rustc_private` feature. This is intended for use when\n-        // compiling librustc crates themselves so we can leverage crates.io\n-        // while maintaining the invariant that all sysroot crates are unstable\n-        // by default and are unable to be used.\n-        if tcx.sess.opts.debugging_opts.force_unstable_if_unmarked {\n-            let reason = \"this crate is being loaded from the sysroot, and \\\n-                          unstable location; did you mean to load this crate \\\n-                          from crates.io via `Cargo.toml` instead?\";\n-            let stability = tcx.intern_stability(Stability {\n-                level: attr::StabilityLevel::Unstable {\n-                    reason: Some(Symbol::intern(reason)),\n-                    issue: 27812,\n-                },\n-                feature: Symbol::intern(\"rustc_private\"),\n-                rustc_depr: None,\n-            });\n-            annotator.parent_stab = Some(stability);\n+            annotator.annotate(ast::CRATE_NODE_ID,\n+                               &krate.attrs,\n+                               krate.span,\n+                               AnnotationKind::Required,\n+                               |v| intravisit::walk_crate(v, krate));\n         }\n+        return index\n+    }\n \n-        annotator.annotate(ast::CRATE_NODE_ID, &krate.attrs, krate.span, AnnotationKind::Required,\n-                           |v| intravisit::walk_crate(v, krate));\n+    pub fn local_stability(&self, id: HirId) -> Option<&'tcx Stability> {\n+        self.stab_map.get(&id).cloned()\n     }\n \n-    pub fn new(sess: &Session) -> Index<'tcx> {\n-        let is_staged_api =\n-            sess.opts.debugging_opts.force_unstable_if_unmarked ||\n-            sess.features.borrow().staged_api;\n-        let mut staged_api = FxHashMap();\n-        staged_api.insert(LOCAL_CRATE, is_staged_api);\n-        Index {\n-            staged_api,\n-            stab_map: DefIdMap(),\n-            depr_map: DefIdMap(),\n-            active_features: FxHashSet(),\n-            used_features: FxHashMap(),\n-        }\n+    pub fn local_deprecation_entry(&self, id: HirId) -> Option<DeprecationEntry> {\n+        self.depr_map.get(&id).cloned()\n     }\n }\n \n@@ -476,7 +482,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             _ => {}\n         }\n \n-        let visibility = self.sess.cstore.visibility(def_id);\n+        let visibility = self.visibility(def_id);\n \n         match visibility {\n             // must check stability for pub items.\n@@ -547,18 +553,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             return\n         }\n \n-        if let Some(&Stability { ref level, ref feature, .. }) = stability {\n-            self.stability.borrow_mut().used_features.insert(feature.clone(), level.clone());\n-        }\n-\n         // Issue 38412: private items lack stability markers.\n         if self.skip_stability_check_due_to_privacy(def_id) {\n             return\n         }\n \n         match stability {\n             Some(&Stability { level: attr::Unstable {ref reason, issue}, ref feature, .. }) => {\n-                if self.stability.borrow().active_features.contains(feature) {\n+                if self.stability().active_features.contains(feature) {\n                     return\n                 }\n \n@@ -610,7 +612,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 // compiler-generated `extern crate` items have a dummy span.\n                 if item.span == DUMMY_SP { return }\n \n-                let cnum = match self.tcx.sess.cstore.extern_mod_stmt_cnum(item.id) {\n+                let hir_id = self.tcx.hir.node_to_hir_id(item.id);\n+                let cnum = match self.tcx.extern_mod_stmt_cnum(hir_id) {\n                     Some(cnum) => cnum,\n                     None => return,\n                 };\n@@ -671,49 +674,9 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    /// Lookup the stability for a node, loading external crate\n-    /// metadata as necessary.\n-    pub fn lookup_stability(self, id: DefId) -> Option<&'gcx Stability> {\n-        if let Some(st) = self.stability.borrow().stab_map.get(&id) {\n-            return *st;\n-        }\n-\n-        let st = self.lookup_stability_uncached(id);\n-        self.stability.borrow_mut().stab_map.insert(id, st);\n-        st\n-    }\n-\n     pub fn lookup_deprecation(self, id: DefId) -> Option<Deprecation> {\n         self.lookup_deprecation_entry(id).map(|depr| depr.attr)\n     }\n-\n-    pub fn lookup_deprecation_entry(self, id: DefId) -> Option<DeprecationEntry> {\n-        if let Some(depr) = self.stability.borrow().depr_map.get(&id) {\n-            return depr.clone();\n-        }\n-\n-        let depr = self.lookup_deprecation_uncached(id);\n-        self.stability.borrow_mut().depr_map.insert(id, depr.clone());\n-        depr\n-    }\n-\n-    fn lookup_stability_uncached(self, id: DefId) -> Option<&'gcx Stability> {\n-        debug!(\"lookup(id={:?})\", id);\n-        if id.is_local() {\n-            None // The stability cache is filled partially lazily\n-        } else {\n-            self.stability(id).map(|st| self.intern_stability(st))\n-        }\n-    }\n-\n-    fn lookup_deprecation_uncached(self, id: DefId) -> Option<DeprecationEntry> {\n-        debug!(\"lookup(id={:?})\", id);\n-        if id.is_local() {\n-            None // The stability cache is filled partially lazily\n-        } else {\n-            self.deprecation(id).map(DeprecationEntry::external)\n-        }\n-    }\n }\n \n /// Given the list of enabled features that were not language features (i.e. that\n@@ -724,7 +687,7 @@ pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n \n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n \n-    if tcx.stability.borrow().staged_api[&LOCAL_CRATE] {\n+    if tcx.stability().staged_api[&LOCAL_CRATE] {\n         let krate = tcx.hir.krate();\n         let mut missing = MissingStabilityAnnotations {\n             tcx,\n@@ -740,10 +703,6 @@ pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         = declared_lib_features.clone().into_iter().collect();\n     remaining_lib_features.remove(&Symbol::intern(\"proc_macro\"));\n \n-    fn format_stable_since_msg(version: &str) -> String {\n-        format!(\"this feature has been stable since {}. Attribute no longer needed\", version)\n-    }\n-\n     for &(ref stable_lang_feature, span) in &sess.features.borrow().declared_stable_lang_features {\n         let version = find_lang_feature_accepted_version(&stable_lang_feature.as_str())\n             .expect(\"unexpectedly couldn't find version feature was stabilized\");\n@@ -753,25 +712,23 @@ pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n                       &format_stable_since_msg(version));\n     }\n \n-    let index = tcx.stability.borrow();\n-    for (used_lib_feature, level) in &index.used_features {\n-        match remaining_lib_features.remove(used_lib_feature) {\n-            Some(span) => {\n-                if let &attr::StabilityLevel::Stable { since: ref version } = level {\n-                    tcx.lint_node(lint::builtin::STABLE_FEATURES,\n-                                  ast::CRATE_NODE_ID,\n-                                  span,\n-                                  &format_stable_since_msg(&version.as_str()));\n-                }\n-            }\n-            None => ( /* used but undeclared, handled during the previous ast visit */ )\n-        }\n-    }\n+    // FIXME(#44232) the `used_features` table no longer exists, so we don't\n+    //               lint about unknown or unused features. We should reenable\n+    //               this one day!\n+    //\n+    // let index = tcx.stability();\n+    // for (used_lib_feature, level) in &index.used_features {\n+    //     remaining_lib_features.remove(used_lib_feature);\n+    // }\n+    //\n+    // for &span in remaining_lib_features.values() {\n+    //     tcx.lint_node(lint::builtin::UNUSED_FEATURES,\n+    //                   ast::CRATE_NODE_ID,\n+    //                   span,\n+    //                   \"unused or unknown feature\");\n+    // }\n+}\n \n-    for &span in remaining_lib_features.values() {\n-        tcx.lint_node(lint::builtin::UNUSED_FEATURES,\n-                      ast::CRATE_NODE_ID,\n-                      span,\n-                      \"unused or unknown feature\");\n-    }\n+fn format_stable_since_msg(version: &str) -> String {\n+    format!(\"this feature has been stable since {}. Attribute no longer needed\", version)\n }"}, {"sha": "50fb584070262f9f5e9c5a58c84486109085f453", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -11,7 +11,6 @@\n //! Validity checking for weak lang items\n \n use session::config;\n-use session::Session;\n use middle::lang_items;\n \n use rustc_back::PanicStrategy;\n@@ -21,38 +20,38 @@ use syntax_pos::Span;\n use hir::intravisit::{Visitor, NestedVisitorMap};\n use hir::intravisit;\n use hir;\n+use ty::TyCtxt;\n \n use std::collections::HashSet;\n \n macro_rules! weak_lang_items {\n     ($($name:ident, $item:ident, $sym:ident;)*) => (\n \n-struct Context<'a> {\n-    sess: &'a Session,\n+struct Context<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     items: &'a mut lang_items::LanguageItems,\n }\n \n /// Checks the crate for usage of weak lang items, returning a vector of all the\n /// language items required by this crate, but not defined yet.\n-pub fn check_crate(krate: &hir::Crate,\n-                   sess: &Session,\n-                   items: &mut lang_items::LanguageItems) {\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             items: &mut lang_items::LanguageItems) {\n     // These are never called by user code, they're generated by the compiler.\n     // They will never implicitly be added to the `missing` array unless we do\n     // so here.\n     if items.eh_personality().is_none() {\n         items.missing.push(lang_items::EhPersonalityLangItem);\n     }\n-    if sess.target.target.options.custom_unwind_resume &\n+    if tcx.sess.target.target.options.custom_unwind_resume &\n        items.eh_unwind_resume().is_none() {\n         items.missing.push(lang_items::EhUnwindResumeLangItem);\n     }\n \n     {\n-        let mut cx = Context { sess: sess, items: items };\n-        krate.visit_all_item_likes(&mut cx.as_deep_visitor());\n+        let mut cx = Context { tcx, items };\n+        tcx.hir.krate().visit_all_item_likes(&mut cx.as_deep_visitor());\n     }\n-    verify(sess, items);\n+    verify(tcx, items);\n }\n \n pub fn link_name(attrs: &[ast::Attribute]) -> Option<Symbol> {\n@@ -65,10 +64,11 @@ pub fn link_name(attrs: &[ast::Attribute]) -> Option<Symbol> {\n     })\n }\n \n-fn verify(sess: &Session, items: &lang_items::LanguageItems) {\n+fn verify<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    items: &lang_items::LanguageItems) {\n     // We only need to check for the presence of weak lang items if we're\n     // emitting something that's not an rlib.\n-    let needs_check = sess.crate_types.borrow().iter().any(|kind| {\n+    let needs_check = tcx.sess.crate_types.borrow().iter().any(|kind| {\n         match *kind {\n             config::CrateTypeDylib |\n             config::CrateTypeProcMacro |\n@@ -83,8 +83,8 @@ fn verify(sess: &Session, items: &lang_items::LanguageItems) {\n     }\n \n     let mut missing = HashSet::new();\n-    for cnum in sess.cstore.crates() {\n-        for item in sess.cstore.missing_lang_items(cnum) {\n+    for &cnum in tcx.crates().iter() {\n+        for &item in tcx.missing_lang_items(cnum).iter() {\n             missing.insert(item);\n         }\n     }\n@@ -93,7 +93,7 @@ fn verify(sess: &Session, items: &lang_items::LanguageItems) {\n     // symbols. Other panic runtimes ensure that the relevant symbols are\n     // available to link things together, but they're never exercised.\n     let mut whitelisted = HashSet::new();\n-    if sess.panic_strategy() != PanicStrategy::Unwind {\n+    if tcx.sess.panic_strategy() != PanicStrategy::Unwind {\n         whitelisted.insert(lang_items::EhPersonalityLangItem);\n         whitelisted.insert(lang_items::EhUnwindResumeLangItem);\n     }\n@@ -102,28 +102,28 @@ fn verify(sess: &Session, items: &lang_items::LanguageItems) {\n         if missing.contains(&lang_items::$item) &&\n            !whitelisted.contains(&lang_items::$item) &&\n            items.$name().is_none() {\n-            sess.err(&format!(\"language item required, but not found: `{}`\",\n-                              stringify!($name)));\n+            tcx.sess.err(&format!(\"language item required, but not found: `{}`\",\n+                                  stringify!($name)));\n \n         }\n     )*\n }\n \n-impl<'a> Context<'a> {\n+impl<'a, 'tcx> Context<'a, 'tcx> {\n     fn register(&mut self, name: &str, span: Span) {\n         $(if name == stringify!($name) {\n             if self.items.$name().is_none() {\n                 self.items.missing.push(lang_items::$item);\n             }\n         } else)* {\n-            span_err!(self.sess, span, E0264,\n+            span_err!(self.tcx.sess, span, E0264,\n                       \"unknown external lang item: `{}`\",\n                       name);\n         }\n     }\n }\n \n-impl<'a, 'v> Visitor<'v> for Context<'a> {\n+impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v> {\n         NestedVisitorMap::None\n     }"}, {"sha": "cfbd4ba055e3c3827e27fa68319ba19f2a194a33", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -348,7 +348,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             //\n             // Currently I'm leaving it for what I need for `try`.\n             if self.tcx.trait_of_item(item) == Some(trait_ref.def_id) {\n-                method = self.tcx.item_name(item).as_str();\n+                method = self.tcx.item_name(item);\n                 flags.push((\"from_method\", None));\n                 flags.push((\"from_method\", Some(&*method)));\n             }\n@@ -919,7 +919,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 // anyway. In that case, why inundate the user.\n                 if !self.tcx.sess.has_errors() {\n                     if\n-                        self.tcx.lang_items.sized_trait()\n+                        self.tcx.lang_items().sized_trait()\n                         .map_or(false, |sized_id| sized_id == trait_ref.def_id())\n                     {\n                         self.need_type_info(body_id, span, self_ty);"}, {"sha": "fd6d5a86a7fd1ed98f243459fe1ea3f2ce591e75", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -181,7 +181,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn generics_require_sized_self(self, def_id: DefId) -> bool {\n-        let sized_def_id = match self.lang_items.sized_trait() {\n+        let sized_def_id = match self.lang_items().sized_trait() {\n             Some(def_id) => def_id,\n             None => { return false; /* No Sized trait, can't require it! */ }\n         };"}, {"sha": "94f6efcad4adc7efdee2cd0ed6e47edf74f229f4", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -227,7 +227,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n               span: Span)\n               -> Result<(), ErrorReported>\n     {\n-        let name = tcx.item_name(trait_def_id).as_str();\n+        let name = tcx.item_name(trait_def_id);\n         let generics = tcx.generics_of(trait_def_id);\n         let parser = Parser::new(&self.0);\n         let types = &generics.types;\n@@ -272,7 +272,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n                   trait_ref: ty::TraitRef<'tcx>)\n                   -> String\n     {\n-        let name = tcx.item_name(trait_ref.def_id).as_str();\n+        let name = tcx.item_name(trait_ref.def_id);\n         let trait_str = tcx.item_path_str(trait_ref.def_id);\n         let generics = tcx.generics_of(trait_ref.def_id);\n         let generic_map = generics.types.iter().map(|param| {"}, {"sha": "1088ada667fbb3cb16634d84bc01083f3ca4ede5", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -1155,7 +1155,7 @@ fn confirm_generator_candidate<'cx, 'gcx, 'tcx>(\n \n     let tcx = selcx.tcx();\n \n-    let gen_def_id = tcx.lang_items.gen_trait().unwrap();\n+    let gen_def_id = tcx.lang_items().gen_trait().unwrap();\n \n     // Note: we unwrap the binder here but re-create it below (1)\n     let ty::Binder((trait_ref, yield_ty, return_ty)) =\n@@ -1252,7 +1252,7 @@ fn confirm_callable_candidate<'cx, 'gcx, 'tcx>(\n            fn_sig);\n \n     // the `Output` associated type is declared on `FnOnce`\n-    let fn_once_def_id = tcx.lang_items.fn_once_trait().unwrap();\n+    let fn_once_def_id = tcx.lang_items().fn_once_trait().unwrap();\n \n     // Note: we unwrap the binder here but re-create it below (1)\n     let ty::Binder((trait_ref, ret_type)) ="}, {"sha": "98bb3fb0ba94abf0399f412d380032bc3d3f38ed", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -1315,7 +1315,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // and applicable impls. There is a certain set of precedence rules here.\n \n         let def_id = obligation.predicate.def_id();\n-        if self.tcx().lang_items.copy_trait() == Some(def_id) {\n+        let lang_items = self.tcx().lang_items();\n+        if lang_items.copy_trait() == Some(def_id) {\n             debug!(\"obligation self ty is {:?}\",\n                    obligation.predicate.0.self_ty());\n \n@@ -1326,16 +1327,16 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // For other types, we'll use the builtin rules.\n             let copy_conditions = self.copy_conditions(obligation);\n             self.assemble_builtin_bound_candidates(copy_conditions, &mut candidates)?;\n-        } else if self.tcx().lang_items.sized_trait() == Some(def_id) {\n+        } else if lang_items.sized_trait() == Some(def_id) {\n             // Sized is never implementable by end-users, it is\n             // always automatically computed.\n             let sized_conditions = self.sized_conditions(obligation);\n             self.assemble_builtin_bound_candidates(sized_conditions,\n                                                    &mut candidates)?;\n-         } else if self.tcx().lang_items.unsize_trait() == Some(def_id) {\n+         } else if lang_items.unsize_trait() == Some(def_id) {\n              self.assemble_candidates_for_unsizing(obligation, &mut candidates);\n          } else {\n-             if self.tcx().lang_items.clone_trait() == Some(def_id) {\n+             if lang_items.clone_trait() == Some(def_id) {\n                  // Same builtin conditions as `Copy`, i.e. every type which has builtin support\n                  // for `Copy` also has builtin support for `Clone`, + tuples and arrays of `Clone`\n                  // types have builtin support for `Clone`.\n@@ -1533,7 +1534,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                    candidates: &mut SelectionCandidateSet<'tcx>)\n                                    -> Result<(),SelectionError<'tcx>>\n     {\n-        if self.tcx().lang_items.gen_trait() != Some(obligation.predicate.def_id()) {\n+        if self.tcx().lang_items().gen_trait() != Some(obligation.predicate.def_id()) {\n             return Ok(());\n         }\n \n@@ -1570,7 +1571,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                    candidates: &mut SelectionCandidateSet<'tcx>)\n                                    -> Result<(),SelectionError<'tcx>>\n     {\n-        let kind = match self.tcx().lang_items.fn_trait_kind(obligation.predicate.0.def_id()) {\n+        let kind = match self.tcx().lang_items().fn_trait_kind(obligation.predicate.0.def_id()) {\n             Some(k) => k,\n             None => { return Ok(()); }\n         };\n@@ -1612,7 +1613,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                       -> Result<(),SelectionError<'tcx>>\n     {\n         // We provide impl of all fn traits for fn pointers.\n-        if self.tcx().lang_items.fn_trait_kind(obligation.predicate.def_id()).is_none() {\n+        if self.tcx().lang_items().fn_trait_kind(obligation.predicate.def_id()).is_none() {\n             return Ok(());\n         }\n \n@@ -2346,16 +2347,17 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         debug!(\"confirm_builtin_candidate({:?}, {:?})\",\n                obligation, has_nested);\n \n+        let lang_items = self.tcx().lang_items();\n         let obligations = if has_nested {\n             let trait_def = obligation.predicate.def_id();\n             let conditions = match trait_def {\n-                _ if Some(trait_def) == self.tcx().lang_items.sized_trait() => {\n+                _ if Some(trait_def) == lang_items.sized_trait() => {\n                     self.sized_conditions(obligation)\n                 }\n-                _ if Some(trait_def) == self.tcx().lang_items.copy_trait() => {\n+                _ if Some(trait_def) == lang_items.copy_trait() => {\n                     self.copy_conditions(obligation)\n                 }\n-                _ if Some(trait_def) == self.tcx().lang_items.clone_trait() => {\n+                _ if Some(trait_def) == lang_items.clone_trait() => {\n                     self.copy_conditions(obligation)\n                 }\n                 _ => bug!(\"unexpected builtin trait {:?}\", trait_def)\n@@ -2658,7 +2660,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     {\n         debug!(\"confirm_closure_candidate({:?})\", obligation);\n \n-        let kind = match self.tcx().lang_items.fn_trait_kind(obligation.predicate.0.def_id()) {\n+        let kind = match self.tcx().lang_items().fn_trait_kind(obligation.predicate.0.def_id()) {\n             Some(k) => k,\n             None => bug!(\"closure candidate for non-fn trait {:?}\", obligation)\n         };"}, {"sha": "b0d6f4d5a31305f35a57802cf85af6bc7f07ade4", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -538,8 +538,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             }\n             None => {\n                 self.global_tcx()\n-                    .sess\n-                    .cstore\n                     .impl_defaultness(node_item_def_id)\n                     .is_default()\n             }"}, {"sha": "349d77cfc1b244fcbeefd8f30a4baa1f6b7628c1", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -110,8 +110,8 @@ impl<'a, 'gcx, 'tcx> OverloadedDeref<'tcx> {\n     pub fn method_call(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, source: Ty<'tcx>)\n                        -> (DefId, &'tcx Substs<'tcx>) {\n         let trait_def_id = match self.mutbl {\n-            hir::MutImmutable => tcx.lang_items.deref_trait(),\n-            hir::MutMutable => tcx.lang_items.deref_mut_trait()\n+            hir::MutImmutable => tcx.lang_items().deref_trait(),\n+            hir::MutMutable => tcx.lang_items().deref_mut_trait()\n         };\n         let method_def_id = tcx.associated_items(trait_def_id.unwrap())\n             .find(|m| m.kind == ty::AssociatedKind::Method).unwrap().def_id;"}, {"sha": "18f286ebf55760d312af3c9e05e5f2fa63ad6c67", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 108, "deletions": 57, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -23,7 +23,7 @@ use lint::{self, Lint};\n use ich::{self, StableHashingContext, NodeIdHashingMode};\n use middle::free_region::FreeRegionMap;\n use middle::lang_items;\n-use middle::resolve_lifetime;\n+use middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use middle::stability;\n use mir::Mir;\n use mir::transform::Passes;\n@@ -33,7 +33,6 @@ use traits;\n use ty::{self, Ty, TypeAndMut};\n use ty::{TyS, TypeVariants, Slice};\n use ty::{AdtKind, AdtDef, ClosureSubsts, GeneratorInterior, Region};\n-use hir::FreevarMap;\n use ty::{PolyFnSig, InferTy, ParamTy, ProjectionTy, ExistentialPredicate, Predicate};\n use ty::RegionKind;\n use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n@@ -822,7 +821,7 @@ pub struct GlobalCtxt<'tcx> {\n     /// Export map produced by name resolution.\n     export_map: FxHashMap<HirId, Rc<Vec<Export>>>,\n \n-    pub named_region_map: resolve_lifetime::NamedRegionMap,\n+    named_region_map: NamedRegionMap,\n \n     pub hir: hir_map::Map<'tcx>,\n \n@@ -837,11 +836,11 @@ pub struct GlobalCtxt<'tcx> {\n     // Records the free variables refrenced by every closure\n     // expression. Do not track deps for this, just recompute it from\n     // scratch every time.\n-    pub freevars: RefCell<FreevarMap>,\n+    freevars: FxHashMap<HirId, Rc<Vec<hir::Freevar>>>,\n \n-    pub maybe_unused_trait_imports: NodeSet,\n+    maybe_unused_trait_imports: FxHashSet<HirId>,\n \n-    pub maybe_unused_extern_crates: Vec<(NodeId, Span)>,\n+    maybe_unused_extern_crates: Vec<(HirId, Span)>,\n \n     // Internal cache for metadata decoding. No need to track deps on this.\n     pub rcache: RefCell<FxHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n@@ -851,16 +850,11 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub inhabitedness_cache: RefCell<FxHashMap<Ty<'tcx>, DefIdForest>>,\n \n-    pub lang_items: middle::lang_items::LanguageItems,\n-\n     /// Set of nodes which mark locals as mutable which end up getting used at\n     /// some point. Local variable definitions not in this set can be warned\n     /// about.\n     pub used_mut_nodes: RefCell<NodeSet>,\n \n-    /// Maps any item's def-id to its stability index.\n-    pub stability: RefCell<stability::Index<'tcx>>,\n-\n     /// Caches the results of trait selection. This cache is used\n     /// for things that do not have to do with the parameters in scope.\n     pub selection_cache: traits::SelectionCache<'tcx>,\n@@ -909,30 +903,6 @@ impl<'tcx> GlobalCtxt<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn crate_name(self, cnum: CrateNum) -> Symbol {\n-        if cnum == LOCAL_CRATE {\n-            self.crate_name\n-        } else {\n-            self.sess.cstore.crate_name(cnum)\n-        }\n-    }\n-\n-    pub fn original_crate_name(self, cnum: CrateNum) -> Symbol {\n-        if cnum == LOCAL_CRATE {\n-            self.crate_name.clone()\n-        } else {\n-            self.sess.cstore.original_crate_name(cnum)\n-        }\n-    }\n-\n-    pub fn crate_disambiguator(self, cnum: CrateNum) -> Symbol {\n-        if cnum == LOCAL_CRATE {\n-            self.sess.local_crate_disambiguator()\n-        } else {\n-            self.sess.cstore.crate_disambiguator(cnum)\n-        }\n-    }\n-\n     pub fn alloc_generics(self, generics: ty::Generics) -> &'gcx ty::Generics {\n         self.global_arenas.generics.alloc(generics)\n     }\n@@ -1016,8 +986,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                   resolutions: ty::Resolutions,\n                                   named_region_map: resolve_lifetime::NamedRegionMap,\n                                   hir: hir_map::Map<'tcx>,\n-                                  lang_items: middle::lang_items::LanguageItems,\n-                                  stability: stability::Index<'tcx>,\n                                   crate_name: &str,\n                                   f: F) -> R\n                                   where F: for<'b> FnOnce(TyCtxt<'b, 'tcx, 'tcx>) -> R\n@@ -1026,14 +994,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let interners = CtxtInterners::new(arena);\n         let common_types = CommonTypes::new(&interners);\n         let dep_graph = hir.dep_graph.clone();\n-        let max_cnum = s.cstore.crates().iter().map(|c| c.as_usize()).max().unwrap_or(0);\n+        let max_cnum = s.cstore.crates_untracked().iter().map(|c| c.as_usize()).max().unwrap_or(0);\n         let mut providers = IndexVec::from_elem_n(extern_providers, max_cnum + 1);\n         providers[LOCAL_CRATE] = local_providers;\n \n         let def_path_hash_to_def_id = if s.opts.build_dep_graph() {\n             let upstream_def_path_tables: Vec<(CrateNum, Rc<_>)> = s\n                 .cstore\n-                .crates()\n+                .crates_untracked()\n                 .iter()\n                 .map(|&cnum| (cnum, s.cstore.def_path_table(cnum)))\n                 .collect();\n@@ -1070,26 +1038,50 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             global_interners: interners,\n             dep_graph: dep_graph.clone(),\n             types: common_types,\n-            named_region_map,\n+            named_region_map: NamedRegionMap {\n+                defs:\n+                    named_region_map.defs\n+                        .into_iter()\n+                        .map(|(k, v)| (hir.node_to_hir_id(k), v))\n+                        .collect(),\n+                late_bound:\n+                    named_region_map.late_bound\n+                        .into_iter()\n+                        .map(|k| hir.node_to_hir_id(k))\n+                        .collect(),\n+                object_lifetime_defaults:\n+                    named_region_map.object_lifetime_defaults\n+                        .into_iter()\n+                        .map(|(k, v)| (hir.node_to_hir_id(k), Rc::new(v)))\n+                        .collect(),\n+            },\n             trait_map: resolutions.trait_map.into_iter().map(|(k, v)| {\n                 (hir.node_to_hir_id(k), Rc::new(v))\n             }).collect(),\n             export_map: resolutions.export_map.into_iter().map(|(k, v)| {\n                 (hir.node_to_hir_id(k), Rc::new(v))\n             }).collect(),\n+            freevars: resolutions.freevars.into_iter().map(|(k, v)| {\n+                (hir.node_to_hir_id(k), Rc::new(v))\n+            }).collect(),\n+            maybe_unused_trait_imports:\n+                resolutions.maybe_unused_trait_imports\n+                    .into_iter()\n+                    .map(|id| hir.node_to_hir_id(id))\n+                    .collect(),\n+            maybe_unused_extern_crates:\n+                resolutions.maybe_unused_extern_crates\n+                    .into_iter()\n+                    .map(|(id, sp)| (hir.node_to_hir_id(id), sp))\n+                    .collect(),\n             hir,\n             def_path_hash_to_def_id,\n             maps: maps::Maps::new(providers),\n             mir_passes,\n-            freevars: RefCell::new(resolutions.freevars),\n-            maybe_unused_trait_imports: resolutions.maybe_unused_trait_imports,\n-            maybe_unused_extern_crates: resolutions.maybe_unused_extern_crates,\n             rcache: RefCell::new(FxHashMap()),\n             normalized_cache: RefCell::new(FxHashMap()),\n             inhabitedness_cache: RefCell::new(FxHashMap()),\n-            lang_items,\n             used_mut_nodes: RefCell::new(NodeSet()),\n-            stability: RefCell::new(stability),\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n             rvalue_promotable_to_static: RefCell::new(NodeMap()),\n@@ -1107,6 +1099,32 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let cname = self.crate_name(LOCAL_CRATE).as_str();\n         self.sess.consider_optimizing(&cname, msg)\n     }\n+\n+    pub fn lang_items(self) -> Rc<middle::lang_items::LanguageItems> {\n+        // FIXME(#42293) Right now we insert a `with_ignore` node in the dep\n+        // graph here to ignore the fact that `get_lang_items` below depends on\n+        // the entire crate.  For now this'll prevent false positives of\n+        // recompiling too much when anything changes.\n+        //\n+        // Once red/green incremental compilation lands we should be able to\n+        // remove this because while the crate changes often the lint level map\n+        // will change rarely.\n+        self.dep_graph.with_ignore(|| {\n+            self.get_lang_items(LOCAL_CRATE)\n+        })\n+    }\n+\n+    pub fn stability(self) -> Rc<stability::Index<'tcx>> {\n+        // FIXME(#42293) we should actually track this, but fails too many tests\n+        // today.\n+        self.dep_graph.with_ignore(|| {\n+            self.stability_index(LOCAL_CRATE)\n+        })\n+    }\n+\n+    pub fn crates(self) -> Rc<Vec<CrateNum>> {\n+        self.all_crate_nums(LOCAL_CRATE)\n+    }\n }\n \n impl<'gcx: 'tcx, 'tcx> GlobalCtxt<'gcx> {\n@@ -1994,19 +2012,52 @@ impl<T, R, E> InternIteratorElement<T, R> for Result<T, E> {\n     }\n }\n \n-fn in_scope_traits<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: HirId)\n-    -> Option<Rc<Vec<TraitCandidate>>>\n-{\n-    tcx.gcx.trait_map.get(&id).cloned()\n-}\n-\n-fn module_exports<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: HirId)\n-    -> Option<Rc<Vec<Export>>>\n-{\n-    tcx.gcx.export_map.get(&id).cloned()\n+struct NamedRegionMap {\n+    defs: FxHashMap<HirId, resolve_lifetime::Region>,\n+    late_bound: FxHashSet<HirId>,\n+    object_lifetime_defaults: FxHashMap<HirId, Rc<Vec<ObjectLifetimeDefault>>>,\n }\n \n pub fn provide(providers: &mut ty::maps::Providers) {\n-    providers.in_scope_traits = in_scope_traits;\n-    providers.module_exports = module_exports;\n+    // FIXME(#44234) - almost all of these queries have no sub-queries and\n+    // therefore no actual inputs, they're just reading tables calculated in\n+    // resolve! Does this work? Unsure! That's what the issue is about\n+    providers.in_scope_traits = |tcx, id| tcx.gcx.trait_map.get(&id).cloned();\n+    providers.module_exports = |tcx, id| tcx.gcx.export_map.get(&id).cloned();\n+    providers.named_region = |tcx, id| tcx.gcx.named_region_map.defs.get(&id).cloned();\n+    providers.is_late_bound = |tcx, id| tcx.gcx.named_region_map.late_bound.contains(&id);\n+    providers.object_lifetime_defaults = |tcx, id| {\n+        tcx.gcx.named_region_map.object_lifetime_defaults.get(&id).cloned()\n+    };\n+    providers.crate_name = |tcx, id| {\n+        assert_eq!(id, LOCAL_CRATE);\n+        tcx.crate_name\n+    };\n+    providers.get_lang_items = |tcx, id| {\n+        assert_eq!(id, LOCAL_CRATE);\n+        Rc::new(middle::lang_items::collect(tcx))\n+    };\n+    providers.freevars = |tcx, id| tcx.gcx.freevars.get(&id).cloned();\n+    providers.maybe_unused_trait_import = |tcx, id| {\n+        tcx.maybe_unused_trait_imports.contains(&id)\n+    };\n+    providers.maybe_unused_extern_crates = |tcx, cnum| {\n+        assert_eq!(cnum, LOCAL_CRATE);\n+        Rc::new(tcx.maybe_unused_extern_crates.clone())\n+    };\n+\n+    providers.stability_index = |tcx, cnum| {\n+        assert_eq!(cnum, LOCAL_CRATE);\n+        Rc::new(stability::Index::new(tcx))\n+    };\n+    providers.lookup_stability = |tcx, id| {\n+        assert_eq!(id.krate, LOCAL_CRATE);\n+        let id = tcx.hir.definitions().def_index_to_hir_id(id.index);\n+        tcx.stability().local_stability(id)\n+    };\n+    providers.lookup_deprecation_entry = |tcx, id| {\n+        assert_eq!(id.krate, LOCAL_CRATE);\n+        let id = tcx.hir.definitions().def_index_to_hir_id(id.index);\n+        tcx.stability().local_deprecation_entry(id)\n+    };\n }"}, {"sha": "d9d311b14a36ec78f36c0238ff3f6b08cc94410a", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -13,6 +13,7 @@ use hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use ty::{self, Ty, TyCtxt};\n use syntax::ast;\n use syntax::symbol::Symbol;\n+use syntax::symbol::InternedString;\n \n use std::cell::Cell;\n \n@@ -128,22 +129,22 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn try_push_visible_item_path<T>(self, buffer: &mut T, external_def_id: DefId) -> bool\n         where T: ItemPathBuffer\n     {\n-        let visible_parent_map = self.sess.cstore.visible_parent_map(self.sess);\n+        let visible_parent_map = self.visible_parent_map(LOCAL_CRATE);\n \n-        let (mut cur_def, mut cur_path) = (external_def_id, Vec::<ast::Name>::new());\n+        let (mut cur_def, mut cur_path) = (external_def_id, Vec::<InternedString>::new());\n         loop {\n             // If `cur_def` is a direct or injected extern crate, push the path to the crate\n             // followed by the path to the item within the crate and return.\n             if cur_def.index == CRATE_DEF_INDEX {\n                 match *self.extern_crate(cur_def) {\n                     Some(ref extern_crate) if extern_crate.direct => {\n                         self.push_item_path(buffer, extern_crate.def_id);\n-                        cur_path.iter().rev().map(|segment| buffer.push(&segment.as_str())).count();\n+                        cur_path.iter().rev().map(|segment| buffer.push(&segment)).count();\n                         return true;\n                     }\n                     None => {\n                         buffer.push(&self.crate_name(cur_def.krate).as_str());\n-                        cur_path.iter().rev().map(|segment| buffer.push(&segment.as_str())).count();\n+                        cur_path.iter().rev().map(|segment| buffer.push(&segment)).count();\n                         return true;\n                     }\n                     _ => {},\n@@ -152,7 +153,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n             cur_path.push(self.sess.cstore.def_key(cur_def)\n                               .disambiguated_data.data.get_opt_name().unwrap_or_else(||\n-                Symbol::intern(\"<unnamed>\")));\n+                Symbol::intern(\"<unnamed>\").as_str()));\n             match visible_parent_map.get(&cur_def) {\n                 Some(&def) => cur_def = def,\n                 None => return false,"}, {"sha": "2348c4ae76731e84e9496f448e15133d57d4d91b", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -1344,7 +1344,7 @@ impl<'a, 'tcx> Layout {\n                     } else {\n                         let st = Struct::new(dl, &fields, &def.repr,\n                           kind, ty)?;\n-                        let non_zero = Some(def.did) == tcx.lang_items.non_zero();\n+                        let non_zero = Some(def.did) == tcx.lang_items().non_zero();\n                         Univariant { variant: st, non_zero: non_zero }\n                     };\n                     return success(layout);\n@@ -2043,7 +2043,7 @@ impl<'a, 'tcx> SizeSkeleton<'tcx> {\n                     if let Some(SizeSkeleton::Pointer { non_zero, tail }) = v0 {\n                         return Ok(SizeSkeleton::Pointer {\n                             non_zero: non_zero ||\n-                                Some(def.did) == tcx.lang_items.non_zero(),\n+                                Some(def.did) == tcx.lang_items().non_zero(),\n                             tail,\n                         });\n                     } else {"}, {"sha": "48b92d101edb3f8e07ed1d3fbfc42e4f619ab217", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 302, "deletions": 25, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -10,14 +10,19 @@\n \n use dep_graph::{DepConstructor, DepNode, DepNodeIndex};\n use errors::{Diagnostic, DiagnosticBuilder};\n-use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use hir::def_id::{CrateNum, DefId, LOCAL_CRATE, DefIndex};\n use hir::def::{Def, Export};\n use hir::{self, TraitCandidate, HirId};\n+use hir::svh::Svh;\n use lint;\n use middle::const_val;\n-use middle::cstore::{ExternCrate, LinkagePreference};\n+use middle::cstore::{ExternCrate, LinkagePreference, NativeLibrary};\n+use middle::cstore::{NativeLibraryKind, DepKind, CrateSource};\n use middle::privacy::AccessLevels;\n use middle::region;\n+use middle::resolve_lifetime::{Region, ObjectLifetimeDefault};\n+use middle::stability::{self, DeprecationEntry};\n+use middle::lang_items::{LanguageItems, LangItem};\n use mir;\n use mir::transform::{MirSuite, MirPassIndex};\n use session::CompileResult;\n@@ -28,10 +33,11 @@ use ty::item_path;\n use ty::steal::Steal;\n use ty::subst::Substs;\n use ty::fast_reject::SimplifiedType;\n-use util::nodemap::{DefIdSet, NodeSet};\n+use util::nodemap::{DefIdSet, NodeSet, DefIdMap};\n use util::common::{profq_msg, ProfileQueriesMsg};\n \n use rustc_data_structures::indexed_set::IdxSetBuf;\n+use rustc_back::PanicStrategy;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::FxHashMap;\n use std::cell::{RefCell, RefMut, Cell};\n@@ -428,13 +434,13 @@ impl<'tcx> QueryDescription for queries::def_span<'tcx> {\n }\n \n \n-impl<'tcx> QueryDescription for queries::stability<'tcx> {\n+impl<'tcx> QueryDescription for queries::lookup_stability<'tcx> {\n     fn describe(_: TyCtxt, _: DefId) -> String {\n         bug!(\"stability\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::deprecation<'tcx> {\n+impl<'tcx> QueryDescription for queries::lookup_deprecation_entry<'tcx> {\n     fn describe(_: TyCtxt, _: DefId) -> String {\n         bug!(\"deprecation\")\n     }\n@@ -509,31 +515,25 @@ impl<'tcx> QueryDescription for queries::is_const_fn<'tcx> {\n }\n \n impl<'tcx> QueryDescription for queries::dylib_dependency_formats<'tcx> {\n-    fn describe(_: TyCtxt, _: DefId) -> String {\n+    fn describe(_: TyCtxt, _: CrateNum) -> String {\n         \"dylib dependency formats of crate\".to_string()\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::is_allocator<'tcx> {\n-    fn describe(_: TyCtxt, _: DefId) -> String {\n-        \"checking if the crate is_allocator\".to_string()\n-    }\n-}\n-\n impl<'tcx> QueryDescription for queries::is_panic_runtime<'tcx> {\n-    fn describe(_: TyCtxt, _: DefId) -> String {\n+    fn describe(_: TyCtxt, _: CrateNum) -> String {\n         \"checking if the crate is_panic_runtime\".to_string()\n     }\n }\n \n impl<'tcx> QueryDescription for queries::is_compiler_builtins<'tcx> {\n-    fn describe(_: TyCtxt, _: DefId) -> String {\n+    fn describe(_: TyCtxt, _: CrateNum) -> String {\n         \"checking if the crate is_compiler_builtins\".to_string()\n     }\n }\n \n impl<'tcx> QueryDescription for queries::has_global_allocator<'tcx> {\n-    fn describe(_: TyCtxt, _: DefId) -> String {\n+    fn describe(_: TyCtxt, _: CrateNum) -> String {\n         \"checking if the crate has_global_allocator\".to_string()\n     }\n }\n@@ -568,6 +568,198 @@ impl<'tcx> QueryDescription for queries::module_exports<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::is_no_builtins<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"test whether a crate has #![no_builtins]\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::panic_strategy<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"query a crate's configured panic strategy\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_profiler_runtime<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"query a crate is #![profiler_runtime]\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_sanitizer_runtime<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"query a crate is #![sanitizer_runtime]\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::exported_symbols<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up the exported symbols of a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::native_libraries<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up the native libraries of a linked crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::plugin_registrar_fn<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up the plugin registrar for a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::derive_registrar_fn<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up the derive registrar for a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::crate_disambiguator<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up the disambiguator a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::crate_hash<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up the hash a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::original_crate_name<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up the original name a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::implementations_of_trait<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: (CrateNum, DefId)) -> String {\n+        format!(\"looking up implementations of a trait in a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::all_trait_implementations<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up all (?) trait implementations\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::link_args<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up link arguments for a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::named_region<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: HirId) -> String {\n+        format!(\"fetching info about a named region\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_late_bound<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: HirId) -> String {\n+        format!(\"testing whether a lifetime is late bound\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::object_lifetime_defaults<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: HirId) -> String {\n+        format!(\"fetching a list of ObjectLifetimeDefault for a lifetime\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::dep_kind<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"fetching what a dependency looks like\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::crate_name<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"fetching what a crate is named\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::extern_mod_stmt_cnum<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: HirId) -> String {\n+        format!(\"looking up the CrateNum for an `extern mod` statement\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::get_lang_items<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"calculating the lang items map\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::defined_lang_items<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"calculating the lang items defined in a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::missing_lang_items<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"calculating the missing lang items in a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::visible_parent_map<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"calculating the visible parent map\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::missing_extern_crate_item<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"seeing if we're missing an `extern crate` item for this crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::used_crate_source<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking at the source for a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::postorder_cnums<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"generating a postorder list of CrateNums\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::freevars<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: HirId) -> String {\n+        format!(\"looking up free variables for a node\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::maybe_unused_trait_import<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: HirId) -> String {\n+        format!(\"testing if a trait import is unused\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::maybe_unused_extern_crates<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up all possibly unused extern crates\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::stability_index<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"calculating the stability index for the local crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::all_crate_nums<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"fetching all foreign CrateNum instances\")\n+    }\n+}\n+\n // If enabled, send a message to the profile-queries thread\n macro_rules! profq_msg {\n     ($tcx:expr, $msg:expr) => {\n@@ -1092,8 +1284,8 @@ define_maps! { <'tcx>\n \n     [] fn describe_def: DescribeDef(DefId) -> Option<Def>,\n     [] fn def_span: DefSpan(DefId) -> Span,\n-    [] fn stability: Stability(DefId) -> Option<attr::Stability>,\n-    [] fn deprecation: Deprecation(DefId) -> Option<attr::Deprecation>,\n+    [] fn lookup_stability: LookupStability(DefId) -> Option<&'tcx attr::Stability>,\n+    [] fn lookup_deprecation_entry: LookupDeprecationEntry(DefId) -> Option<DeprecationEntry>,\n     [] fn item_attrs: ItemAttrs(DefId) -> Rc<[ast::Attribute]>,\n     [] fn fn_arg_names: FnArgNames(DefId) -> Vec<ast::Name>,\n     [] fn impl_parent: ImplParent(DefId) -> Option<DefId>,\n@@ -1125,21 +1317,72 @@ define_maps! { <'tcx>\n     [] fn layout_raw: layout_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n                                   -> Result<&'tcx Layout, LayoutError<'tcx>>,\n \n-    [] fn dylib_dependency_formats: DylibDepFormats(DefId)\n+    [] fn dylib_dependency_formats: DylibDepFormats(CrateNum)\n                                     -> Rc<Vec<(CrateNum, LinkagePreference)>>,\n \n-    [] fn is_allocator: IsAllocator(DefId) -> bool,\n-    [] fn is_panic_runtime: IsPanicRuntime(DefId) -> bool,\n-    [] fn is_compiler_builtins: IsCompilerBuiltins(DefId) -> bool,\n-    [] fn has_global_allocator: HasGlobalAllocator(DefId) -> bool,\n+    [] fn is_panic_runtime: IsPanicRuntime(CrateNum) -> bool,\n+    [] fn is_compiler_builtins: IsCompilerBuiltins(CrateNum) -> bool,\n+    [] fn has_global_allocator: HasGlobalAllocator(CrateNum) -> bool,\n+    [] fn is_sanitizer_runtime: IsSanitizerRuntime(CrateNum) -> bool,\n+    [] fn is_profiler_runtime: IsProfilerRuntime(CrateNum) -> bool,\n+    [] fn panic_strategy: GetPanicStrategy(CrateNum) -> PanicStrategy,\n+    [] fn is_no_builtins: IsNoBuiltins(CrateNum) -> bool,\n \n     [] fn extern_crate: ExternCrate(DefId) -> Rc<Option<ExternCrate>>,\n \n-    [] fn lint_levels: lint_levels(CrateNum) -> Rc<lint::LintLevelMap>,\n-\n     [] fn specializes: specializes_node((DefId, DefId)) -> bool,\n     [] fn in_scope_traits: InScopeTraits(HirId) -> Option<Rc<Vec<TraitCandidate>>>,\n     [] fn module_exports: ModuleExports(HirId) -> Option<Rc<Vec<Export>>>,\n+    [] fn lint_levels: lint_levels_node(CrateNum) -> Rc<lint::LintLevelMap>,\n+\n+    [] fn impl_defaultness: ImplDefaultness(DefId) -> hir::Defaultness,\n+    [] fn exported_symbols: ExportedSymbols(CrateNum) -> Rc<Vec<DefId>>,\n+    [] fn native_libraries: NativeLibraries(CrateNum) -> Rc<Vec<NativeLibrary>>,\n+    [] fn plugin_registrar_fn: PluginRegistrarFn(CrateNum) -> Option<DefId>,\n+    [] fn derive_registrar_fn: DeriveRegistrarFn(CrateNum) -> Option<DefId>,\n+    [] fn crate_disambiguator: CrateDisambiguator(CrateNum) -> Symbol,\n+    [] fn crate_hash: CrateHash(CrateNum) -> Svh,\n+    [] fn original_crate_name: OriginalCrateName(CrateNum) -> Symbol,\n+\n+    [] fn implementations_of_trait: implementations_of_trait_node((CrateNum, DefId))\n+        -> Rc<Vec<DefId>>,\n+    [] fn all_trait_implementations: AllTraitImplementations(CrateNum)\n+        -> Rc<Vec<DefId>>,\n+\n+    [] fn is_dllimport_foreign_item: IsDllimportForeignItem(DefId) -> bool,\n+    [] fn is_statically_included_foreign_item: IsStaticallyIncludedForeignItem(DefId) -> bool,\n+    [] fn native_library_kind: NativeLibraryKind(DefId)\n+        -> Option<NativeLibraryKind>,\n+    [] fn link_args: link_args_node(CrateNum) -> Rc<Vec<String>>,\n+\n+    [] fn named_region: NamedRegion(HirId) -> Option<Region>,\n+    [] fn is_late_bound: IsLateBound(HirId) -> bool,\n+    [] fn object_lifetime_defaults: ObjectLifetimeDefaults(HirId)\n+        -> Option<Rc<Vec<ObjectLifetimeDefault>>>,\n+\n+    [] fn visibility: Visibility(DefId) -> ty::Visibility,\n+    [] fn dep_kind: DepKind(CrateNum) -> DepKind,\n+    [] fn crate_name: CrateName(CrateNum) -> Symbol,\n+    [] fn item_children: ItemChildren(DefId) -> Rc<Vec<Export>>,\n+    [] fn extern_mod_stmt_cnum: ExternModStmtCnum(HirId) -> Option<CrateNum>,\n+\n+    [] fn get_lang_items: get_lang_items_node(CrateNum) -> Rc<LanguageItems>,\n+    [] fn defined_lang_items: DefinedLangItems(CrateNum) -> Rc<Vec<(DefIndex, usize)>>,\n+    [] fn missing_lang_items: MissingLangItems(CrateNum) -> Rc<Vec<LangItem>>,\n+    [] fn extern_const_body: ExternConstBody(DefId) -> &'tcx hir::Body,\n+    [] fn visible_parent_map: visible_parent_map_node(CrateNum)\n+        -> Rc<DefIdMap<DefId>>,\n+    [] fn missing_extern_crate_item: MissingExternCrateItem(CrateNum) -> bool,\n+    [] fn used_crate_source: UsedCrateSource(CrateNum) -> Rc<CrateSource>,\n+    [] fn postorder_cnums: postorder_cnums_node(CrateNum) -> Rc<Vec<CrateNum>>,\n+\n+    [] fn freevars: Freevars(HirId) -> Option<Rc<Vec<hir::Freevar>>>,\n+    [] fn maybe_unused_trait_import: MaybeUnusedTraitImport(HirId) -> bool,\n+    [] fn maybe_unused_extern_crates: maybe_unused_extern_crates_node(CrateNum)\n+        -> Rc<Vec<(HirId, Span)>>,\n+\n+    [] fn stability_index: stability_index_node(CrateNum) -> Rc<stability::Index<'tcx>>,\n+    [] fn all_crate_nums: all_crate_nums_node(CrateNum) -> Rc<Vec<CrateNum>>,\n }\n \n fn type_param_predicates<'tcx>((item_id, param_id): (DefId, DefId)) -> DepConstructor<'tcx> {\n@@ -1212,10 +1455,44 @@ fn layout_dep_node<'tcx>(_: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'\n     DepConstructor::Layout\n }\n \n-fn lint_levels<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+fn lint_levels_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n     DepConstructor::LintLevels\n }\n \n fn specializes_node<'tcx>((a, b): (DefId, DefId)) -> DepConstructor<'tcx> {\n     DepConstructor::Specializes { impl1: a, impl2: b }\n }\n+\n+fn implementations_of_trait_node<'tcx>((krate, trait_id): (CrateNum, DefId))\n+    -> DepConstructor<'tcx>\n+{\n+    DepConstructor::ImplementationsOfTrait { krate, trait_id }\n+}\n+\n+fn link_args_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::LinkArgs\n+}\n+\n+fn get_lang_items_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::GetLangItems\n+}\n+\n+fn visible_parent_map_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::VisibleParentMap\n+}\n+\n+fn postorder_cnums_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::PostorderCnums\n+}\n+\n+fn maybe_unused_extern_crates_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::MaybeUnusedExternCrates\n+}\n+\n+fn stability_index_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::StabilityIndex\n+}\n+\n+fn all_crate_nums_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::AllCrateNums\n+}"}, {"sha": "ef0d844be957f0569062d667770e96d540eded3c", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -1447,10 +1447,10 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         if attr::contains_name(&attrs, \"fundamental\") {\n             flags = flags | AdtFlags::IS_FUNDAMENTAL;\n         }\n-        if Some(did) == tcx.lang_items.phantom_data() {\n+        if Some(did) == tcx.lang_items().phantom_data() {\n             flags = flags | AdtFlags::IS_PHANTOM_DATA;\n         }\n-        if Some(did) == tcx.lang_items.owned_box() {\n+        if Some(did) == tcx.lang_items().owned_box() {\n             flags = flags | AdtFlags::IS_BOX;\n         }\n         match kind {\n@@ -1746,7 +1746,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                 // we know that `T` is Sized and do not need to check\n                 // it on the impl.\n \n-                let sized_trait = match tcx.lang_items.sized_trait() {\n+                let sized_trait = match tcx.lang_items().sized_trait() {\n                     Some(x) => x,\n                     _ => return vec![ty]\n                 };\n@@ -2206,11 +2206,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn item_name(self, id: DefId) -> ast::Name {\n+    pub fn item_name(self, id: DefId) -> InternedString {\n         if let Some(id) = self.hir.as_local_node_id(id) {\n-            self.hir.name(id)\n+            self.hir.name(id).as_str()\n         } else if id.index == CRATE_DEF_INDEX {\n-            self.sess.cstore.original_crate_name(id.krate)\n+            self.original_crate_name(id.krate).as_str()\n         } else {\n             let def_key = self.sess.cstore.def_key(id);\n             // The name of a StructCtor is that of its struct parent.\n@@ -2315,7 +2315,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             let node_id = self.hir.as_local_node_id(impl_did).unwrap();\n             Ok(self.hir.span(node_id))\n         } else {\n-            Err(self.sess.cstore.crate_name(impl_did.krate))\n+            Err(self.crate_name(impl_did.krate))\n         }\n     }\n \n@@ -2340,9 +2340,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn with_freevars<T, F>(self, fid: NodeId, f: F) -> T where\n         F: FnOnce(&[hir::Freevar]) -> T,\n     {\n-        match self.freevars.borrow().get(&fid) {\n+        let hir_id = self.hir.node_to_hir_id(fid);\n+        match self.freevars(hir_id) {\n             None => f(&[]),\n-            Some(d) => f(&d[..])\n+            Some(d) => f(&d),\n         }\n     }\n }\n@@ -2510,6 +2511,18 @@ fn param_env<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     traits::normalize_param_env_or_error(tcx, def_id, unnormalized_env, cause)\n }\n \n+fn crate_disambiguator<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 crate_num: CrateNum) -> Symbol {\n+    assert_eq!(crate_num, LOCAL_CRATE);\n+    tcx.sess.local_crate_disambiguator()\n+}\n+\n+fn original_crate_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 crate_num: CrateNum) -> Symbol {\n+    assert_eq!(crate_num, LOCAL_CRATE);\n+    tcx.crate_name.clone()\n+}\n+\n pub fn provide(providers: &mut ty::maps::Providers) {\n     util::provide(providers);\n     context::provide(providers);\n@@ -2521,6 +2534,8 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n         def_span,\n         param_env,\n         trait_of_item,\n+        crate_disambiguator,\n+        original_crate_name,\n         trait_impls_of: trait_def::trait_impls_of_provider,\n         ..*providers\n     };"}, {"sha": "3aadacfe826fd2ea1a1b8f4a9d475cb873dc3b83", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -141,13 +141,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n pub(super) fn trait_impls_of_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                 trait_id: DefId)\n                                                 -> Rc<TraitImpls> {\n-    let remote_impls = if trait_id.is_local() {\n-        // Traits defined in the current crate can't have impls in upstream\n-        // crates, so we don't bother querying the cstore.\n-        Vec::new()\n-    } else {\n-        tcx.sess.cstore.implementations_of_trait(Some(trait_id))\n-    };\n+    let mut remote_impls = Vec::new();\n+\n+    // Traits defined in the current crate can't have impls in upstream\n+    // crates, so we don't bother querying the cstore.\n+    if !trait_id.is_local() {\n+        for &cnum in tcx.crates().iter() {\n+            let impls = tcx.implementations_of_trait((cnum, trait_id));\n+            remote_impls.extend(impls.iter().cloned());\n+        }\n+    }\n \n     let mut blanket_impls = Vec::new();\n     let mut non_blanket_impls = FxHashMap();"}, {"sha": "f21fc8414e78b9c63e59930714a130fdd9dffaa9", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -418,7 +418,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         adt_did: DefId,\n         validate: &mut FnMut(Self, DefId) -> Result<(), ErrorReported>\n     ) -> Option<ty::Destructor> {\n-        let drop_trait = if let Some(def_id) = self.lang_items.drop_trait() {\n+        let drop_trait = if let Some(def_id) = self.lang_items().drop_trait() {\n             def_id\n         } else {\n             return None;"}, {"sha": "c48bd5ac5be267bc8b287d6c2622e2b487076e2d", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -159,7 +159,7 @@ pub fn parameterized(f: &mut fmt::Formatter,\n         }\n \n         write!(f, \"{}\", tcx.item_path_str(path_def_id))?;\n-        Ok(tcx.lang_items.fn_trait_kind(path_def_id))\n+        Ok(tcx.lang_items().fn_trait_kind(path_def_id))\n     })?;\n \n     if !verbose && fn_trait_kind.is_some() && projections.len() == 1 {\n@@ -802,7 +802,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                     for predicate in bounds.predicates {\n                         if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n                             // Don't print +Sized, but rather +?Sized if absent.\n-                            if Some(trait_ref.def_id()) == tcx.lang_items.sized_trait() {\n+                            if Some(trait_ref.def_id()) == tcx.lang_items().sized_trait() {\n                                 is_sized = true;\n                                 continue;\n                             }"}, {"sha": "ea6e1d4cddcca8b5d8dd7caab5213e7fd25130ca", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -327,7 +327,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n                     ConstEvalErr { span: e.span, kind: LayoutError(err) }\n                 })\n             };\n-            match &tcx.item_name(def_id).as_str()[..] {\n+            match &tcx.item_name(def_id)[..] {\n                 \"size_of\" => {\n                     let size = layout_of(substs.type_at(0))?.size(tcx);\n                     return Ok(Integral(Usize(ConstUsize::new(size.bytes(),\n@@ -354,7 +354,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n             }\n           } else {\n             if tcx.is_const_fn(def_id) {\n-                tcx.sess.cstore.item_body(tcx, def_id)\n+                tcx.extern_const_body(def_id)\n             } else {\n                 signal!(e, TypeckError)\n             }\n@@ -774,7 +774,7 @@ fn const_eval<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         tcx.mir_const_qualif(def_id);\n         tcx.hir.body(tcx.hir.body_owned_by(id))\n     } else {\n-        tcx.sess.cstore.item_body(tcx, def_id)\n+        tcx.extern_const_body(def_id)\n     };\n     ConstContext::new(tcx, key.param_env.and(substs), tables).eval(&body.value)\n }"}, {"sha": "5e1fbbc9ca2cf2b2faf37bcb6a1d49cbaacf1022", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -609,7 +609,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                         let body = if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n                             self.tcx.hir.body(self.tcx.hir.body_owned_by(id))\n                         } else {\n-                            self.tcx.sess.cstore.item_body(self.tcx, def_id)\n+                            self.tcx.extern_const_body(def_id)\n                         };\n                         let pat = self.lower_const_expr(&body.value, pat_id, span);\n                         self.tables = old_tables;"}, {"sha": "b4dde2120a840bcad56ef8146be35f133397982e", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -694,7 +694,6 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n     // this back at some point.\n     let _ignore = sess.dep_graph.in_ignore();\n     let mut crate_loader = CrateLoader::new(sess, &cstore, crate_name);\n-    crate_loader.preprocess(&krate);\n     let resolver_arenas = Resolver::arenas();\n     let mut resolver = Resolver::new(sess,\n                                      &krate,\n@@ -914,12 +913,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     let time_passes = sess.time_passes();\n \n-    let lang_items = time(time_passes, \"language item collection\", || {\n-        sess.track_errors(|| {\n-            middle::lang_items::collect_language_items(&sess, &hir_map)\n-        })\n-    })?;\n-\n     let named_region_map = time(time_passes,\n                                 \"lifetime resolution\",\n                                 || middle::resolve_lifetime::krate(sess, &hir_map))?;\n@@ -941,8 +934,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n               \"static item recursion checking\",\n               || static_recursion::check_crate(sess, &hir_map))?;\n \n-    let index = stability::Index::new(&sess);\n-\n     let mut local_providers = ty::maps::Providers::default();\n     borrowck::provide(&mut local_providers);\n     mir::provide(&mut local_providers);\n@@ -1029,8 +1020,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                              resolutions,\n                              named_region_map,\n                              hir_map,\n-                             lang_items,\n-                             index,\n                              name,\n                              |tcx| {\n         let incremental_hashes_map =\n@@ -1042,10 +1031,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              \"load_dep_graph\",\n              || rustc_incremental::load_dep_graph(tcx, &incremental_hashes_map));\n \n-        time(time_passes, \"stability index\", || {\n-            tcx.stability.borrow_mut().build(tcx)\n-        });\n-\n         time(time_passes,\n              \"stability checking\",\n              || stability::check_unstable_api_usage(tcx));"}, {"sha": "de710942ca189595855fb2f205fd6555fc1ab7fe", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -15,11 +15,9 @@ use rustc::dep_graph::DepGraph;\n use rustc_lint;\n use rustc_resolve::MakeGlobMap;\n use rustc_trans;\n-use rustc::middle::lang_items;\n use rustc::middle::free_region::FreeRegionMap;\n use rustc::middle::region;\n use rustc::middle::resolve_lifetime;\n-use rustc::middle::stability;\n use rustc::ty::subst::{Kind, Subst};\n use rustc::traits::{ObligationCause, Reveal};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n@@ -140,9 +138,7 @@ fn test_env<F>(source_string: &str,\n     let hir_map = hir_map::map_crate(&mut hir_forest, defs);\n \n     // run just enough stuff to build a tcx:\n-    let lang_items = lang_items::collect_language_items(&sess, &hir_map);\n     let named_region_map = resolve_lifetime::krate(&sess, &hir_map);\n-    let index = stability::Index::new(&sess);\n     TyCtxt::create_and_enter(&sess,\n                              ty::maps::Providers::default(),\n                              ty::maps::Providers::default(),\n@@ -152,8 +148,6 @@ fn test_env<F>(source_string: &str,\n                              resolutions,\n                              named_region_map.unwrap(),\n                              hir_map,\n-                             lang_items,\n-                             index,\n                              \"test_crate\",\n                              |tcx| {\n         tcx.infer_ctxt().enter(|infcx| {"}, {"sha": "434c82095bd9a98d0e21cbf8a3639d934646202c", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -632,7 +632,7 @@ pub fn find_metadata_hashes_for(tcx: TyCtxt, cnum: CrateNum) -> Option<PathBuf>\n         }\n     };\n \n-    let target_svh = tcx.sess.cstore.crate_hash(cnum);\n+    let target_svh = tcx.crate_hash(cnum);\n     let target_svh = base_n::encode(target_svh.as_u64(), INT_ENCODE_BASE);\n \n     let sub_dir = find_metadata_hashes_iter(&target_svh, dir_entries.filter_map(|e| {"}, {"sha": "44d6788c773651569c5164b90d9fe5eabf177f28", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -133,7 +133,7 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n     fn load_data(&mut self, cnum: CrateNum) {\n         debug!(\"load_data(cnum={})\", cnum);\n \n-        let svh = self.tcx.sess.cstore.crate_hash(cnum);\n+        let svh = self.tcx.crate_hash(cnum);\n         let old = self.crate_hashes.insert(cnum, svh);\n         debug!(\"load_data: svh={}\", svh);\n         assert!(old.is_none(), \"loaded data for crate {:?} twice\", cnum);"}, {"sha": "e0d82f3dafc0daab76f6246016d932926577c5ca", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -547,7 +547,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDebugImplementations {\n             _ => return,\n         }\n \n-        let debug = match cx.tcx.lang_items.debug_trait() {\n+        let debug = match cx.tcx.lang_items().debug_trait() {\n             Some(debug) => debug,\n             None => return,\n         };\n@@ -1063,8 +1063,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PluginAsLibrary {\n             _ => return,\n         };\n \n-        let prfn = match cx.sess().cstore.extern_mod_stmt_cnum(it.id) {\n-            Some(cnum) => cx.sess().cstore.plugin_registrar_fn(cnum),\n+        let hir_id = cx.tcx.hir.node_to_hir_id(it.id);\n+        let prfn = match cx.tcx.extern_mod_stmt_cnum(hir_id) {\n+            Some(cnum) => cx.tcx.plugin_registrar_fn(cnum),\n             None => {\n                 // Probably means we aren't linking the crate for some reason.\n                 //"}, {"sha": "7f018a7f5a6d54dbfeec2f1c2427a482cc5f77a2", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 222, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -12,6 +12,7 @@\n \n use cstore::{self, CStore, CrateSource, MetadataBlob};\n use locator::{self, CratePaths};\n+use native_libs::relevant_lib;\n use schema::{CrateRoot, Tracked};\n \n use rustc::hir::def_id::{CrateNum, DefIndex};\n@@ -23,10 +24,9 @@ use rustc::session::config::{Sanitizer, self};\n use rustc_back::PanicStrategy;\n use rustc::session::search_paths::PathKind;\n use rustc::middle;\n-use rustc::middle::cstore::{CrateStore, validate_crate_name, ExternCrate};\n+use rustc::middle::cstore::{validate_crate_name, ExternCrate};\n use rustc::util::common::record_time;\n use rustc::util::nodemap::FxHashSet;\n-use rustc::middle::cstore::NativeLibrary;\n use rustc::hir::map::Definitions;\n \n use std::cell::{RefCell, Cell};\n@@ -36,10 +36,8 @@ use std::rc::Rc;\n use std::{cmp, fs};\n \n use syntax::ast;\n-use syntax::abi::Abi;\n use syntax::attr;\n use syntax::ext::base::SyntaxExtension;\n-use syntax::feature_gate::{self, GateIssue};\n use syntax::symbol::Symbol;\n use syntax::visit;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -81,56 +79,6 @@ struct ExternCrateInfo {\n     dep_kind: DepKind,\n }\n \n-fn register_native_lib(sess: &Session,\n-                       cstore: &CStore,\n-                       span: Option<Span>,\n-                       lib: NativeLibrary) {\n-    if lib.name.as_str().is_empty() {\n-        match span {\n-            Some(span) => {\n-                struct_span_err!(sess, span, E0454,\n-                                 \"#[link(name = \\\"\\\")] given with empty name\")\n-                    .span_label(span, \"empty name given\")\n-                    .emit();\n-            }\n-            None => {\n-                sess.err(\"empty library name given via `-l`\");\n-            }\n-        }\n-        return\n-    }\n-    let is_osx = sess.target.target.options.is_like_osx;\n-    if lib.kind == cstore::NativeFramework && !is_osx {\n-        let msg = \"native frameworks are only available on macOS targets\";\n-        match span {\n-            Some(span) => span_err!(sess, span, E0455, \"{}\", msg),\n-            None => sess.err(msg),\n-        }\n-    }\n-    if lib.cfg.is_some() && !sess.features.borrow().link_cfg {\n-        feature_gate::emit_feature_err(&sess.parse_sess,\n-                                       \"link_cfg\",\n-                                       span.unwrap(),\n-                                       GateIssue::Language,\n-                                       \"is feature gated\");\n-    }\n-    if lib.kind == cstore::NativeStaticNobundle && !sess.features.borrow().static_nobundle {\n-        feature_gate::emit_feature_err(&sess.parse_sess,\n-                                       \"static_nobundle\",\n-                                       span.unwrap(),\n-                                       GateIssue::Language,\n-                                       \"kind=\\\"static-nobundle\\\" is feature gated\");\n-    }\n-    cstore.add_used_library(lib);\n-}\n-\n-fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n-    match lib.cfg {\n-        Some(ref cfg) => attr::cfg_matches(cfg, &sess.parse_sess, None),\n-        None => true,\n-    }\n-}\n-\n // Extra info about a crate loaded for plugins or exported macros.\n struct ExtensionCrate {\n     metadata: PMDSource,\n@@ -218,7 +166,7 @@ impl<'a> CrateLoader<'a> {\n             // We're also sure to compare *paths*, not actual byte slices. The\n             // `source` stores paths which are normalized which may be different\n             // from the strings on the command line.\n-            let source = self.cstore.used_crate_source(cnum);\n+            let source = &self.cstore.get_crate_data(cnum).source;\n             if let Some(locs) = self.sess.opts.externs.get(&*name.as_str()) {\n                 let found = locs.iter().any(|l| {\n                     let l = fs::canonicalize(l).ok();\n@@ -721,33 +669,6 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    fn get_foreign_items_of_kind(&self, kind: cstore::NativeLibraryKind) -> Vec<DefIndex> {\n-        let mut items = vec![];\n-        let libs = self.cstore.get_used_libraries();\n-        for lib in libs.borrow().iter() {\n-            if relevant_lib(self.sess, lib) && lib.kind == kind {\n-                items.extend(&lib.foreign_items);\n-            }\n-        }\n-        items\n-    }\n-\n-    fn register_statically_included_foreign_items(&mut self) {\n-        for id in self.get_foreign_items_of_kind(cstore::NativeStatic) {\n-            self.cstore.add_statically_included_foreign_item(id);\n-        }\n-        for id in self.get_foreign_items_of_kind(cstore::NativeStaticNobundle) {\n-            self.cstore.add_statically_included_foreign_item(id);\n-        }\n-    }\n-\n-    fn register_dllimport_foreign_items(&mut self) {\n-        let mut dllimports = self.cstore.dllimport_foreign_items.borrow_mut();\n-        for id in self.get_foreign_items_of_kind(cstore::NativeUnknown) {\n-            dllimports.insert(id);\n-        }\n-    }\n-\n     fn inject_panic_runtime(&mut self, krate: &ast::Crate) {\n         // If we're only compiling an rlib, then there's no need to select a\n         // panic runtime, so we just skip this section entirely.\n@@ -1152,84 +1073,6 @@ impl<'a> CrateLoader<'a> {\n     }\n }\n \n-impl<'a> CrateLoader<'a> {\n-    pub fn preprocess(&mut self, krate: &ast::Crate) {\n-        for attr in &krate.attrs {\n-            if attr.path == \"link_args\" {\n-                if let Some(linkarg) = attr.value_str() {\n-                    self.cstore.add_used_link_args(&linkarg.as_str());\n-                }\n-            }\n-        }\n-    }\n-\n-    fn process_foreign_mod(&mut self, i: &ast::Item, fm: &ast::ForeignMod,\n-                           definitions: &Definitions) {\n-        if fm.abi == Abi::Rust || fm.abi == Abi::RustIntrinsic || fm.abi == Abi::PlatformIntrinsic {\n-            return;\n-        }\n-\n-        // First, add all of the custom #[link_args] attributes\n-        for m in i.attrs.iter().filter(|a| a.check_name(\"link_args\")) {\n-            if let Some(linkarg) = m.value_str() {\n-                self.cstore.add_used_link_args(&linkarg.as_str());\n-            }\n-        }\n-\n-        // Next, process all of the #[link(..)]-style arguments\n-        for m in i.attrs.iter().filter(|a| a.check_name(\"link\")) {\n-            let items = match m.meta_item_list() {\n-                Some(item) => item,\n-                None => continue,\n-            };\n-            let kind = items.iter().find(|k| {\n-                k.check_name(\"kind\")\n-            }).and_then(|a| a.value_str()).map(Symbol::as_str);\n-            let kind = match kind.as_ref().map(|s| &s[..]) {\n-                Some(\"static\") => cstore::NativeStatic,\n-                Some(\"static-nobundle\") => cstore::NativeStaticNobundle,\n-                Some(\"dylib\") => cstore::NativeUnknown,\n-                Some(\"framework\") => cstore::NativeFramework,\n-                Some(k) => {\n-                    struct_span_err!(self.sess, m.span, E0458,\n-                              \"unknown kind: `{}`\", k)\n-                        .span_label(m.span, \"unknown kind\").emit();\n-                    cstore::NativeUnknown\n-                }\n-                None => cstore::NativeUnknown\n-            };\n-            let n = items.iter().find(|n| {\n-                n.check_name(\"name\")\n-            }).and_then(|a| a.value_str());\n-            let n = match n {\n-                Some(n) => n,\n-                None => {\n-                    struct_span_err!(self.sess, m.span, E0459,\n-                                     \"#[link(...)] specified without `name = \\\"foo\\\"`\")\n-                        .span_label(m.span, \"missing `name` argument\").emit();\n-                    Symbol::intern(\"foo\")\n-                }\n-            };\n-            let cfg = items.iter().find(|k| {\n-                k.check_name(\"cfg\")\n-            }).and_then(|a| a.meta_item_list());\n-            let cfg = cfg.map(|list| {\n-                list[0].meta_item().unwrap().clone()\n-            });\n-            let foreign_items = fm.items.iter()\n-                .map(|it| definitions.opt_def_index(it.id).unwrap())\n-                .collect();\n-            let lib = NativeLibrary {\n-                name: n,\n-                kind,\n-                cfg,\n-                foreign_items,\n-            };\n-            register_native_lib(self.sess, self.cstore, Some(m.span), lib);\n-        }\n-    }\n-}\n-\n impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n     fn postprocess(&mut self, krate: &ast::Crate) {\n         // inject the sanitizer runtime before the allocator runtime because all\n@@ -1242,72 +1085,10 @@ impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n         if log_enabled!(log::LogLevel::Info) {\n             dump_crates(&self.cstore);\n         }\n-\n-        // Process libs passed on the command line\n-        // First, check for errors\n-        let mut renames = FxHashSet();\n-        for &(ref name, ref new_name, _) in &self.sess.opts.libs {\n-            if let &Some(ref new_name) = new_name {\n-                if new_name.is_empty() {\n-                    self.sess.err(\n-                        &format!(\"an empty renaming target was specified for library `{}`\",name));\n-                } else if !self.cstore.get_used_libraries().borrow().iter()\n-                                                           .any(|lib| lib.name == name as &str) {\n-                    self.sess.err(&format!(\"renaming of the library `{}` was specified, \\\n-                                            however this crate contains no #[link(...)] \\\n-                                            attributes referencing this library.\", name));\n-                } else if renames.contains(name) {\n-                    self.sess.err(&format!(\"multiple renamings were specified for library `{}` .\",\n-                                            name));\n-                } else {\n-                    renames.insert(name);\n-                }\n-            }\n-        }\n-        // Update kind and, optionally, the name of all native libaries\n-        // (there may be more than one) with the specified name.\n-        for &(ref name, ref new_name, kind) in &self.sess.opts.libs {\n-            let mut found = false;\n-            for lib in self.cstore.get_used_libraries().borrow_mut().iter_mut() {\n-                if lib.name == name as &str {\n-                    let mut changed = false;\n-                    if let Some(k) = kind {\n-                        lib.kind = k;\n-                        changed = true;\n-                    }\n-                    if let &Some(ref new_name) = new_name {\n-                        lib.name = Symbol::intern(new_name);\n-                        changed = true;\n-                    }\n-                    if !changed {\n-                        self.sess.warn(&format!(\"redundant linker flag specified for library `{}`\",\n-                                                name));\n-                    }\n-\n-                    found = true;\n-                }\n-            }\n-            if !found {\n-                // Add if not found\n-                let new_name = new_name.as_ref().map(|s| &**s); // &Option<String> -> Option<&str>\n-                let lib = NativeLibrary {\n-                    name: Symbol::intern(new_name.unwrap_or(name)),\n-                    kind: if let Some(k) = kind { k } else { cstore::NativeUnknown },\n-                    cfg: None,\n-                    foreign_items: Vec::new(),\n-                };\n-                register_native_lib(self.sess, self.cstore, None, lib);\n-            }\n-        }\n-        self.register_statically_included_foreign_items();\n-        self.register_dllimport_foreign_items();\n     }\n \n     fn process_item(&mut self, item: &ast::Item, definitions: &Definitions) {\n         match item.node {\n-            ast::ItemKind::ForeignMod(ref fm) => {\n-                self.process_foreign_mod(item, fm, definitions)\n-            },\n             ast::ItemKind::ExternCrate(_) => {\n                 let info = self.extract_crate_info(item).unwrap();\n                 let (cnum, ..) = self.resolve_crate("}, {"sha": "2d10dadaf64150563147e47231ef733600e265c6", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 4, "deletions": 86, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -14,13 +14,13 @@\n use schema::{self, Tracked};\n \n use rustc::dep_graph::DepGraph;\n-use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, CrateNum, DefIndex, DefId};\n+use rustc::hir::def_id::{CRATE_DEF_INDEX, CrateNum, DefIndex, DefId};\n use rustc::hir::map::definitions::{DefPathTable, GlobalMetaDataKind};\n use rustc::hir::svh::Svh;\n use rustc::middle::cstore::{DepKind, ExternCrate, MetadataLoader};\n use rustc_back::PanicStrategy;\n use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc::util::nodemap::{FxHashMap, FxHashSet, NodeMap, DefIdMap};\n+use rustc::util::nodemap::{FxHashMap, FxHashSet, NodeMap};\n \n use std::cell::{RefCell, Cell};\n use std::rc::Rc;\n@@ -95,11 +95,6 @@ pub struct CStore {\n     metas: RefCell<FxHashMap<CrateNum, Rc<CrateMetadata>>>,\n     /// Map from NodeId's of local extern crate statements to crate numbers\n     extern_mod_crate_map: RefCell<NodeMap<CrateNum>>,\n-    used_libraries: RefCell<Vec<NativeLibrary>>,\n-    used_link_args: RefCell<Vec<String>>,\n-    statically_included_foreign_items: RefCell<FxHashSet<DefIndex>>,\n-    pub dllimport_foreign_items: RefCell<FxHashSet<DefIndex>>,\n-    pub visible_parent_map: RefCell<DefIdMap<DefId>>,\n     pub metadata_loader: Box<MetadataLoader>,\n }\n \n@@ -109,11 +104,6 @@ impl CStore {\n             dep_graph: dep_graph.clone(),\n             metas: RefCell::new(FxHashMap()),\n             extern_mod_crate_map: RefCell::new(FxHashMap()),\n-            used_libraries: RefCell::new(Vec::new()),\n-            used_link_args: RefCell::new(Vec::new()),\n-            statically_included_foreign_items: RefCell::new(FxHashSet()),\n-            dllimport_foreign_items: RefCell::new(FxHashSet()),\n-            visible_parent_map: RefCell::new(FxHashMap()),\n             metadata_loader,\n         }\n     }\n@@ -126,10 +116,6 @@ impl CStore {\n         self.metas.borrow().get(&cnum).unwrap().clone()\n     }\n \n-    pub fn get_crate_hash(&self, cnum: CrateNum) -> Svh {\n-        self.get_crate_data(cnum).hash()\n-    }\n-\n     pub fn set_crate_data(&self, cnum: CrateNum, data: Rc<CrateMetadata>) {\n         self.metas.borrow_mut().insert(cnum, data);\n     }\n@@ -164,86 +150,18 @@ impl CStore {\n         ordering.push(krate);\n     }\n \n-    // This method is used when generating the command line to pass through to\n-    // system linker. The linker expects undefined symbols on the left of the\n-    // command line to be defined in libraries on the right, not the other way\n-    // around. For more info, see some comments in the add_used_library function\n-    // below.\n-    //\n-    // In order to get this left-to-right dependency ordering, we perform a\n-    // topological sort of all crates putting the leaves at the right-most\n-    // positions.\n-    pub fn do_get_used_crates(&self,\n-                              prefer: LinkagePreference)\n-                              -> Vec<(CrateNum, LibSource)> {\n+    pub fn do_postorder_cnums_untracked(&self) -> Vec<CrateNum> {\n         let mut ordering = Vec::new();\n         for (&num, _) in self.metas.borrow().iter() {\n             self.push_dependencies_in_postorder(&mut ordering, num);\n         }\n-        info!(\"topological ordering: {:?}\", ordering);\n-        ordering.reverse();\n-        let mut libs = self.metas\n-            .borrow()\n-            .iter()\n-            .filter_map(|(&cnum, data)| {\n-                if data.dep_kind.get().macros_only() { return None; }\n-                let path = match prefer {\n-                    LinkagePreference::RequireDynamic => data.source.dylib.clone().map(|p| p.0),\n-                    LinkagePreference::RequireStatic => data.source.rlib.clone().map(|p| p.0),\n-                };\n-                let path = match path {\n-                    Some(p) => LibSource::Some(p),\n-                    None => {\n-                        if data.source.rmeta.is_some() {\n-                            LibSource::MetadataOnly\n-                        } else {\n-                            LibSource::None\n-                        }\n-                    }\n-                };\n-                Some((cnum, path))\n-            })\n-            .collect::<Vec<_>>();\n-        libs.sort_by(|&(a, _), &(b, _)| {\n-            let a = ordering.iter().position(|x| *x == a);\n-            let b = ordering.iter().position(|x| *x == b);\n-            a.cmp(&b)\n-        });\n-        libs\n-    }\n-\n-    pub fn add_used_library(&self, lib: NativeLibrary) {\n-        assert!(!lib.name.as_str().is_empty());\n-        self.used_libraries.borrow_mut().push(lib);\n-    }\n-\n-    pub fn get_used_libraries(&self) -> &RefCell<Vec<NativeLibrary>> {\n-        &self.used_libraries\n-    }\n-\n-    pub fn add_used_link_args(&self, args: &str) {\n-        for s in args.split(' ').filter(|s| !s.is_empty()) {\n-            self.used_link_args.borrow_mut().push(s.to_string());\n-        }\n-    }\n-\n-    pub fn get_used_link_args<'a>(&'a self) -> &'a RefCell<Vec<String>> {\n-        &self.used_link_args\n+        return ordering\n     }\n \n     pub fn add_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId, cnum: CrateNum) {\n         self.extern_mod_crate_map.borrow_mut().insert(emod_id, cnum);\n     }\n \n-    pub fn add_statically_included_foreign_item(&self, id: DefIndex) {\n-        self.statically_included_foreign_items.borrow_mut().insert(id);\n-    }\n-\n-    pub fn do_is_statically_included_foreign_item(&self, def_id: DefId) -> bool {\n-        assert!(def_id.krate == LOCAL_CRATE);\n-        self.statically_included_foreign_items.borrow().contains(&def_id.index)\n-    }\n-\n     pub fn do_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum> {\n         self.extern_mod_crate_map.borrow().get(&emod_id).cloned()\n     }"}, {"sha": "776fd3582900049fbcc7d3218e97374141d1be4f", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 217, "deletions": 224, "changes": 441, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -10,24 +10,25 @@\n \n use cstore;\n use encoder;\n+use link_args;\n+use native_libs;\n use schema;\n \n use rustc::ty::maps::QueryConfig;\n-use rustc::middle::cstore::{CrateStore, CrateSource, LibSource, DepKind,\n-                            NativeLibrary, MetadataLoader, LinkMeta,\n-                            LinkagePreference, LoadedMacro, EncodedMetadata,\n-                            EncodedMetadataHashes};\n+use rustc::middle::cstore::{CrateStore, DepKind,\n+                            MetadataLoader, LinkMeta,\n+                            LoadedMacro, EncodedMetadata,\n+                            EncodedMetadataHashes, NativeLibraryKind};\n+use rustc::middle::stability::DeprecationEntry;\n use rustc::hir::def;\n-use rustc::middle::lang_items;\n use rustc::session::Session;\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::maps::Providers;\n-use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE, CRATE_DEF_INDEX};\n use rustc::hir::map::{DefKey, DefPath, DefPathHash};\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::hir::map::definitions::{DefPathTable, GlobalMetaDataKind};\n use rustc::util::nodemap::{NodeSet, DefIdMap};\n-use rustc_back::PanicStrategy;\n \n use std::any::Any;\n use std::rc::Rc;\n@@ -39,15 +40,19 @@ use syntax::parse::filemap_to_stream;\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, NO_EXPANSION};\n use rustc_data_structures::indexed_set::IdxSetBuf;\n-use rustc::hir::svh::Svh;\n use rustc::hir;\n \n macro_rules! provide {\n-    (<$lt:tt> $tcx:ident, $def_id:ident, $cdata:ident, $($name:ident => $compute:block)*) => {\n+    (<$lt:tt> $tcx:ident, $def_id:ident, $other:ident, $cdata:ident,\n+      $($name:ident => $compute:block)*) => {\n         pub fn provide<$lt>(providers: &mut Providers<$lt>) {\n-            $(fn $name<'a, $lt:$lt>($tcx: TyCtxt<'a, $lt, $lt>, $def_id: DefId)\n+            $(fn $name<'a, $lt:$lt, T>($tcx: TyCtxt<'a, $lt, $lt>, def_id_arg: T)\n                                     -> <ty::queries::$name<$lt> as\n-                                        QueryConfig>::Value {\n+                                        QueryConfig>::Value\n+                where T: IntoArgs,\n+            {\n+                #[allow(unused_variables)]\n+                let ($def_id, $other) = def_id_arg.into_args();\n                 assert!(!$def_id.is_local());\n \n                 let def_path_hash = $tcx.def_path_hash($def_id);\n@@ -69,7 +74,25 @@ macro_rules! provide {\n     }\n }\n \n-provide! { <'tcx> tcx, def_id, cdata,\n+// small trait to work around different signature queries all being defined via\n+// the macro above.\n+trait IntoArgs {\n+    fn into_args(self) -> (DefId, DefId);\n+}\n+\n+impl IntoArgs for DefId {\n+    fn into_args(self) -> (DefId, DefId) { (self, self) }\n+}\n+\n+impl IntoArgs for CrateNum {\n+    fn into_args(self) -> (DefId, DefId) { (self.as_def_id(), self.as_def_id()) }\n+}\n+\n+impl IntoArgs for (CrateNum, DefId) {\n+    fn into_args(self) -> (DefId, DefId) { (self.0.as_def_id(), self.1) }\n+}\n+\n+provide! { <'tcx> tcx, def_id, other, cdata,\n     type_of => { cdata.get_type(def_id.index, tcx) }\n     generics_of => { tcx.alloc_generics(cdata.get_generics(def_id.index)) }\n     predicates_of => { cdata.get_predicates(def_id.index, tcx) }\n@@ -119,8 +142,12 @@ provide! { <'tcx> tcx, def_id, cdata,\n     is_default_impl => { cdata.is_default_impl(def_id.index) }\n     describe_def => { cdata.get_def(def_id.index) }\n     def_span => { cdata.get_span(def_id.index, &tcx.sess) }\n-    stability => { cdata.get_stability(def_id.index) }\n-    deprecation => { cdata.get_deprecation(def_id.index) }\n+    lookup_stability => {\n+        cdata.get_stability(def_id.index).map(|s| tcx.intern_stability(s))\n+    }\n+    lookup_deprecation_entry => {\n+        cdata.get_deprecation(def_id.index).map(DeprecationEntry::external)\n+    }\n     item_attrs => { cdata.get_item_attrs(def_id.index, &tcx.dep_graph) }\n     // FIXME(#38501) We've skipped a `read` on the `HirBody` of\n     // a `fn` when encoding, so the dep-tracking wouldn't work.\n@@ -143,7 +170,68 @@ provide! { <'tcx> tcx, def_id, cdata,\n     is_panic_runtime => { cdata.is_panic_runtime(&tcx.dep_graph) }\n     is_compiler_builtins => { cdata.is_compiler_builtins(&tcx.dep_graph) }\n     has_global_allocator => { cdata.has_global_allocator(&tcx.dep_graph) }\n+    is_sanitizer_runtime => { cdata.is_sanitizer_runtime(&tcx.dep_graph) }\n+    is_profiler_runtime => { cdata.is_profiler_runtime(&tcx.dep_graph) }\n+    panic_strategy => { cdata.panic_strategy(&tcx.dep_graph) }\n     extern_crate => { Rc::new(cdata.extern_crate.get()) }\n+    is_no_builtins => { cdata.is_no_builtins(&tcx.dep_graph) }\n+    impl_defaultness => { cdata.get_impl_defaultness(def_id.index) }\n+    exported_symbols => { Rc::new(cdata.get_exported_symbols(&tcx.dep_graph)) }\n+    native_libraries => { Rc::new(cdata.get_native_libraries(&tcx.dep_graph)) }\n+    plugin_registrar_fn => {\n+        cdata.root.plugin_registrar_fn.map(|index| {\n+            DefId { krate: def_id.krate, index }\n+        })\n+    }\n+    derive_registrar_fn => {\n+        cdata.root.macro_derive_registrar.map(|index| {\n+            DefId { krate: def_id.krate, index }\n+        })\n+    }\n+    crate_disambiguator => { cdata.disambiguator() }\n+    crate_hash => { cdata.hash() }\n+    original_crate_name => { cdata.name() }\n+\n+    implementations_of_trait => {\n+        let mut result = vec![];\n+        let filter = Some(other);\n+        cdata.get_implementations_for_trait(filter, &tcx.dep_graph, &mut result);\n+        Rc::new(result)\n+    }\n+\n+    all_trait_implementations => {\n+        let mut result = vec![];\n+        cdata.get_implementations_for_trait(None, &tcx.dep_graph, &mut result);\n+        Rc::new(result)\n+    }\n+\n+    is_dllimport_foreign_item => {\n+        cdata.is_dllimport_foreign_item(def_id.index, &tcx.dep_graph)\n+    }\n+    visibility => { cdata.get_visibility(def_id.index) }\n+    dep_kind => { cdata.dep_kind.get() }\n+    crate_name => { cdata.name }\n+    item_children => {\n+        let mut result = vec![];\n+        cdata.each_child_of_item(def_id.index, |child| result.push(child), tcx.sess);\n+        Rc::new(result)\n+    }\n+    defined_lang_items => { Rc::new(cdata.get_lang_items(&tcx.dep_graph)) }\n+    missing_lang_items => { Rc::new(cdata.get_missing_lang_items(&tcx.dep_graph)) }\n+\n+    extern_const_body => {\n+        debug!(\"item_body({:?}): inlining item\", def_id);\n+        cdata.extern_const_body(tcx, def_id.index)\n+    }\n+\n+    missing_extern_crate_item => {\n+        match cdata.extern_crate.get() {\n+            Some(extern_crate) if !extern_crate.direct => true,\n+            _ => false,\n+        }\n+    }\n+\n+    used_crate_source => { Rc::new(cdata.source.clone()) }\n }\n \n pub fn provide_local<'tcx>(providers: &mut Providers<'tcx>) {\n@@ -158,8 +246,108 @@ pub fn provide_local<'tcx>(providers: &mut Providers<'tcx>) {\n         }\n     }\n \n+    // FIXME(#44234) - almost all of these queries have no sub-queries and\n+    // therefore no actual inputs, they're just reading tables calculated in\n+    // resolve! Does this work? Unsure! That's what the issue is about\n     *providers = Providers {\n         is_const_fn,\n+        is_dllimport_foreign_item: |tcx, id| {\n+            tcx.native_library_kind(id) == Some(NativeLibraryKind::NativeUnknown)\n+        },\n+        is_statically_included_foreign_item: |tcx, id| {\n+            match tcx.native_library_kind(id) {\n+                Some(NativeLibraryKind::NativeStatic) |\n+                Some(NativeLibraryKind::NativeStaticNobundle) => true,\n+                _ => false,\n+            }\n+        },\n+        native_library_kind: |tcx, id| {\n+            tcx.native_libraries(id.krate)\n+                .iter()\n+                .filter(|lib| native_libs::relevant_lib(&tcx.sess, lib))\n+                .find(|l| l.foreign_items.contains(&id.index))\n+                .map(|l| l.kind)\n+        },\n+        native_libraries: |tcx, cnum| {\n+            assert_eq!(cnum, LOCAL_CRATE);\n+            Rc::new(native_libs::collect(tcx))\n+        },\n+        link_args: |tcx, cnum| {\n+            assert_eq!(cnum, LOCAL_CRATE);\n+            Rc::new(link_args::collect(tcx))\n+        },\n+        extern_mod_stmt_cnum: |tcx, id| {\n+            let id = tcx.hir.definitions().find_node_for_hir_id(id);\n+            tcx.sess.cstore.extern_mod_stmt_cnum_untracked(id)\n+        },\n+\n+        all_crate_nums: |tcx, cnum| {\n+            assert_eq!(cnum, LOCAL_CRATE);\n+            Rc::new(tcx.sess.cstore.crates_untracked())\n+        },\n+\n+        // Returns a map from a sufficiently visible external item (i.e. an\n+        // external item that is visible from at least one local module) to a\n+        // sufficiently visible parent (considering modules that re-export the\n+        // external item to be parents).\n+        visible_parent_map: |tcx, cnum| {\n+            use std::collections::vec_deque::VecDeque;\n+            use std::collections::hash_map::Entry;\n+\n+            assert_eq!(cnum, LOCAL_CRATE);\n+            let mut visible_parent_map: DefIdMap<DefId> = DefIdMap();\n+\n+            for &cnum in tcx.crates().iter() {\n+                // Ignore crates without a corresponding local `extern crate` item.\n+                if tcx.missing_extern_crate_item(cnum) {\n+                    continue\n+                }\n+\n+                let bfs_queue = &mut VecDeque::new();\n+                let visible_parent_map = &mut visible_parent_map;\n+                let mut add_child = |bfs_queue: &mut VecDeque<_>,\n+                                     child: &def::Export,\n+                                     parent: DefId| {\n+                    let child = child.def.def_id();\n+\n+                    if tcx.visibility(child) != ty::Visibility::Public {\n+                        return;\n+                    }\n+\n+                    match visible_parent_map.entry(child) {\n+                        Entry::Occupied(mut entry) => {\n+                            // If `child` is defined in crate `cnum`, ensure\n+                            // that it is mapped to a parent in `cnum`.\n+                            if child.krate == cnum && entry.get().krate != cnum {\n+                                entry.insert(parent);\n+                            }\n+                        }\n+                        Entry::Vacant(entry) => {\n+                            entry.insert(parent);\n+                            bfs_queue.push_back(child);\n+                        }\n+                    }\n+                };\n+\n+                bfs_queue.push_back(DefId {\n+                    krate: cnum,\n+                    index: CRATE_DEF_INDEX\n+                });\n+                while let Some(def) = bfs_queue.pop_front() {\n+                    for child in tcx.item_children(def).iter() {\n+                        add_child(bfs_queue, child, def);\n+                    }\n+                }\n+            }\n+\n+            Rc::new(visible_parent_map)\n+        },\n+\n+        postorder_cnums: |tcx, cnum| {\n+            assert_eq!(cnum, LOCAL_CRATE);\n+            Rc::new(tcx.sess.cstore.postorder_cnums_untracked())\n+        },\n+\n         ..*providers\n     };\n }\n@@ -173,61 +361,31 @@ impl CrateStore for cstore::CStore {\n         &*self.metadata_loader\n     }\n \n-    fn visibility(&self, def: DefId) -> ty::Visibility {\n+    fn visibility_untracked(&self, def: DefId) -> ty::Visibility {\n         self.read_dep_node(def);\n         self.get_crate_data(def.krate).get_visibility(def.index)\n     }\n \n-    fn item_generics_cloned(&self, def: DefId) -> ty::Generics {\n+    fn item_generics_cloned_untracked(&self, def: DefId) -> ty::Generics {\n         self.read_dep_node(def);\n         self.get_crate_data(def.krate).get_generics(def.index)\n     }\n \n-    fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId>\n-    {\n-        let mut result = vec![];\n-\n-        self.iter_crate_data(|_, cdata| {\n-            cdata.get_implementations_for_trait(filter, &self.dep_graph, &mut result)\n-        });\n-        result\n-    }\n-\n-    fn impl_defaultness(&self, def: DefId) -> hir::Defaultness\n-    {\n-        self.read_dep_node(def);\n-        self.get_crate_data(def.krate).get_impl_defaultness(def.index)\n-    }\n-\n-    fn associated_item_cloned(&self, def: DefId) -> ty::AssociatedItem\n+    fn associated_item_cloned_untracked(&self, def: DefId) -> ty::AssociatedItem\n     {\n         self.read_dep_node(def);\n         self.get_crate_data(def.krate).get_associated_item(def.index)\n     }\n \n-    fn is_statically_included_foreign_item(&self, def_id: DefId) -> bool\n-    {\n-        self.do_is_statically_included_foreign_item(def_id)\n-    }\n-\n-    fn is_dllimport_foreign_item(&self, def_id: DefId) -> bool {\n-        if def_id.krate == LOCAL_CRATE {\n-            self.dllimport_foreign_items.borrow().contains(&def_id.index)\n-        } else {\n-            self.get_crate_data(def_id.krate)\n-                .is_dllimport_foreign_item(def_id.index, &self.dep_graph)\n-        }\n-    }\n-\n-    fn dep_kind(&self, cnum: CrateNum) -> DepKind\n+    fn dep_kind_untracked(&self, cnum: CrateNum) -> DepKind\n     {\n         let data = self.get_crate_data(cnum);\n         let dep_node = data.metadata_dep_node(GlobalMetaDataKind::CrateDeps);\n         self.dep_graph.read(dep_node);\n         data.dep_kind.get()\n     }\n \n-    fn export_macros(&self, cnum: CrateNum) {\n+    fn export_macros_untracked(&self, cnum: CrateNum) {\n         let data = self.get_crate_data(cnum);\n         let dep_node = data.metadata_dep_node(GlobalMetaDataKind::CrateDeps);\n \n@@ -237,83 +395,11 @@ impl CrateStore for cstore::CStore {\n         }\n     }\n \n-    fn lang_items(&self, cnum: CrateNum) -> Vec<(DefIndex, usize)>\n-    {\n-        self.get_crate_data(cnum).get_lang_items(&self.dep_graph)\n-    }\n-\n-    fn missing_lang_items(&self, cnum: CrateNum)\n-                          -> Vec<lang_items::LangItem>\n-    {\n-        self.get_crate_data(cnum).get_missing_lang_items(&self.dep_graph)\n-    }\n-\n-    fn is_compiler_builtins(&self, cnum: CrateNum) -> bool {\n-        self.get_crate_data(cnum).is_compiler_builtins(&self.dep_graph)\n-    }\n-\n-    fn is_sanitizer_runtime(&self, cnum: CrateNum) -> bool {\n-        self.get_crate_data(cnum).is_sanitizer_runtime(&self.dep_graph)\n-    }\n-\n-    fn is_profiler_runtime(&self, cnum: CrateNum) -> bool {\n-        self.get_crate_data(cnum).is_profiler_runtime(&self.dep_graph)\n-    }\n-\n-    fn panic_strategy(&self, cnum: CrateNum) -> PanicStrategy {\n-        self.get_crate_data(cnum).panic_strategy(&self.dep_graph)\n-    }\n-\n-    fn crate_name(&self, cnum: CrateNum) -> Symbol\n+    fn crate_name_untracked(&self, cnum: CrateNum) -> Symbol\n     {\n         self.get_crate_data(cnum).name\n     }\n \n-    fn original_crate_name(&self, cnum: CrateNum) -> Symbol\n-    {\n-        self.get_crate_data(cnum).name()\n-    }\n-\n-    fn crate_hash(&self, cnum: CrateNum) -> Svh\n-    {\n-        self.get_crate_hash(cnum)\n-    }\n-\n-    fn crate_disambiguator(&self, cnum: CrateNum) -> Symbol\n-    {\n-        self.get_crate_data(cnum).disambiguator()\n-    }\n-\n-    fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>\n-    {\n-        self.get_crate_data(cnum).root.plugin_registrar_fn.map(|index| DefId {\n-            krate: cnum,\n-            index,\n-        })\n-    }\n-\n-    fn derive_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>\n-    {\n-        self.get_crate_data(cnum).root.macro_derive_registrar.map(|index| DefId {\n-            krate: cnum,\n-            index,\n-        })\n-    }\n-\n-    fn native_libraries(&self, cnum: CrateNum) -> Vec<NativeLibrary>\n-    {\n-        self.get_crate_data(cnum).get_native_libraries(&self.dep_graph)\n-    }\n-\n-    fn exported_symbols(&self, cnum: CrateNum) -> Vec<DefId>\n-    {\n-        self.get_crate_data(cnum).get_exported_symbols(&self.dep_graph)\n-    }\n-\n-    fn is_no_builtins(&self, cnum: CrateNum) -> bool {\n-        self.get_crate_data(cnum).is_no_builtins(&self.dep_graph)\n-    }\n-\n     /// Returns the `DefKey` for a given `DefId`. This indicates the\n     /// parent `DefId` as well as some idea of what kind of data the\n     /// `DefId` refers to.\n@@ -343,13 +429,13 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(cnum).def_path_table.clone()\n     }\n \n-    fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>\n+    fn struct_field_names_untracked(&self, def: DefId) -> Vec<ast::Name>\n     {\n         self.read_dep_node(def);\n         self.get_crate_data(def.krate).get_struct_field_names(def.index)\n     }\n \n-    fn item_children(&self, def_id: DefId, sess: &Session) -> Vec<def::Export>\n+    fn item_children_untracked(&self, def_id: DefId, sess: &Session) -> Vec<def::Export>\n     {\n         self.read_dep_node(def_id);\n         let mut result = vec![];\n@@ -358,7 +444,7 @@ impl CrateStore for cstore::CStore {\n         result\n     }\n \n-    fn load_macro(&self, id: DefId, sess: &Session) -> LoadedMacro {\n+    fn load_macro_untracked(&self, id: DefId, sess: &Session) -> LoadedMacro {\n         let data = self.get_crate_data(id.krate);\n         if let Some(ref proc_macros) = data.proc_macros {\n             return LoadedMacro::ProcMacro(proc_macros[id.index.as_usize() - 1].1.clone());\n@@ -387,7 +473,7 @@ impl CrateStore for cstore::CStore {\n             .insert(local_span, (name.to_string(), data.get_span(id.index, sess)));\n \n         LoadedMacro::MacroDef(ast::Item {\n-            ident: ast::Ident::with_empty_ctxt(name),\n+            ident: ast::Ident::from_str(&name),\n             id: ast::DUMMY_NODE_ID,\n             span: local_span,\n             attrs: attrs.iter().cloned().collect(),\n@@ -400,50 +486,20 @@ impl CrateStore for cstore::CStore {\n         })\n     }\n \n-    fn item_body<'a, 'tcx>(&self,\n-                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           def_id: DefId)\n-                           -> &'tcx hir::Body {\n-        self.read_dep_node(def_id);\n-\n-        if let Some(cached) = tcx.hir.get_inlined_body_untracked(def_id) {\n-            return cached;\n-        }\n-\n-        debug!(\"item_body({:?}): inlining item\", def_id);\n-\n-        self.get_crate_data(def_id.krate).item_body(tcx, def_id.index)\n-    }\n-\n-    fn crates(&self) -> Vec<CrateNum>\n+    fn crates_untracked(&self) -> Vec<CrateNum>\n     {\n         let mut result = vec![];\n         self.iter_crate_data(|cnum, _| result.push(cnum));\n         result\n     }\n \n-    fn used_libraries(&self) -> Vec<NativeLibrary>\n-    {\n-        self.get_used_libraries().borrow().clone()\n-    }\n-\n-    fn used_link_args(&self) -> Vec<String>\n-    {\n-        self.get_used_link_args().borrow().clone()\n-    }\n-    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>\n-    {\n-        self.do_get_used_crates(prefer)\n-    }\n-\n-    fn used_crate_source(&self, cnum: CrateNum) -> CrateSource\n+    fn extern_mod_stmt_cnum_untracked(&self, emod_id: ast::NodeId) -> Option<CrateNum>\n     {\n-        self.get_crate_data(cnum).source.clone()\n+        self.do_extern_mod_stmt_cnum(emod_id)\n     }\n \n-    fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum>\n-    {\n-        self.do_extern_mod_stmt_cnum(emod_id)\n+    fn postorder_cnums_untracked(&self) -> Vec<CrateNum> {\n+        self.do_postorder_cnums_untracked()\n     }\n \n     fn encode_metadata<'a, 'tcx>(&self,\n@@ -459,67 +515,4 @@ impl CrateStore for cstore::CStore {\n     {\n         schema::METADATA_HEADER\n     }\n-\n-    /// Returns a map from a sufficiently visible external item (i.e. an external item that is\n-    /// visible from at least one local module) to a sufficiently visible parent (considering\n-    /// modules that re-export the external item to be parents).\n-    fn visible_parent_map<'a>(&'a self, sess: &Session) -> ::std::cell::Ref<'a, DefIdMap<DefId>> {\n-        {\n-            let visible_parent_map = self.visible_parent_map.borrow();\n-            if !visible_parent_map.is_empty() {\n-                return visible_parent_map;\n-            }\n-        }\n-\n-        use std::collections::vec_deque::VecDeque;\n-        use std::collections::hash_map::Entry;\n-\n-        let mut visible_parent_map = self.visible_parent_map.borrow_mut();\n-\n-        for cnum in (1 .. self.next_crate_num().as_usize()).map(CrateNum::new) {\n-            let cdata = self.get_crate_data(cnum);\n-\n-            match cdata.extern_crate.get() {\n-                // Ignore crates without a corresponding local `extern crate` item.\n-                Some(extern_crate) if !extern_crate.direct => continue,\n-                _ => {},\n-            }\n-\n-            let bfs_queue = &mut VecDeque::new();\n-            let mut add_child = |bfs_queue: &mut VecDeque<_>, child: def::Export, parent: DefId| {\n-                let child = child.def.def_id();\n-\n-                if self.visibility(child) != ty::Visibility::Public {\n-                    return;\n-                }\n-\n-                match visible_parent_map.entry(child) {\n-                    Entry::Occupied(mut entry) => {\n-                        // If `child` is defined in crate `cnum`, ensure\n-                        // that it is mapped to a parent in `cnum`.\n-                        if child.krate == cnum && entry.get().krate != cnum {\n-                            entry.insert(parent);\n-                        }\n-                    }\n-                    Entry::Vacant(entry) => {\n-                        entry.insert(parent);\n-                        bfs_queue.push_back(child);\n-                    }\n-                }\n-            };\n-\n-            bfs_queue.push_back(DefId {\n-                krate: cnum,\n-                index: CRATE_DEF_INDEX\n-            });\n-            while let Some(def) = bfs_queue.pop_front() {\n-                for child in self.item_children(def, sess) {\n-                    add_child(bfs_queue, child, def);\n-                }\n-            }\n-        }\n-\n-        drop(visible_parent_map);\n-        self.visible_parent_map.borrow()\n-    }\n }"}, {"sha": "324bab369dc7d1dc38eb463133c84eeb5cb31f97", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -41,6 +41,7 @@ use rustc_serialize::{Decodable, Decoder, SpecializedDecoder, opaque};\n use syntax::attr;\n use syntax::ast::{self, Ident};\n use syntax::codemap;\n+use syntax::symbol::{InternedString, Symbol};\n use syntax::ext::base::MacroKind;\n use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP, NO_EXPANSION};\n \n@@ -473,7 +474,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn item_name(&self, item_index: DefIndex) -> ast::Name {\n+    pub fn item_name(&self, item_index: DefIndex) -> InternedString {\n         self.def_key(item_index)\n             .disambiguated_data\n             .data\n@@ -520,12 +521,12 @@ impl<'a, 'tcx> CrateMetadata {\n \n         ty::VariantDef {\n             did: self.local_def_id(data.struct_ctor.unwrap_or(index)),\n-            name: self.item_name(index),\n+            name: Symbol::intern(&self.item_name(index)),\n             fields: item.children.decode(self).map(|index| {\n                 let f = self.entry(index);\n                 ty::FieldDef {\n                     did: self.local_def_id(index),\n-                    name: self.item_name(index),\n+                    name: Symbol::intern(&self.item_name(index)),\n                     vis: f.visibility.decode(self)\n                 }\n             }).collect(),\n@@ -705,7 +706,7 @@ impl<'a, 'tcx> CrateMetadata {\n                             if let Some(def) = self.get_def(child_index) {\n                                 callback(def::Export {\n                                     def,\n-                                    ident: Ident::with_empty_ctxt(self.item_name(child_index)),\n+                                    ident: Ident::from_str(&self.item_name(child_index)),\n                                     span: self.entry(child_index).span.decode((self, sess)),\n                                 });\n                             }\n@@ -722,7 +723,7 @@ impl<'a, 'tcx> CrateMetadata {\n                 let span = child.span.decode((self, sess));\n                 if let (Some(def), Some(name)) =\n                     (self.get_def(child_index), def_key.disambiguated_data.data.get_opt_name()) {\n-                    let ident = Ident::with_empty_ctxt(name);\n+                    let ident = Ident::from_str(&name);\n                     callback(def::Export { def: def, ident: ident, span: span });\n                     // For non-reexport structs and variants add their constructors to children.\n                     // Reexport lists automatically contain constructors when necessary.\n@@ -759,10 +760,10 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn item_body(&self,\n-                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                     id: DefIndex)\n-                     -> &'tcx hir::Body {\n+    pub fn extern_const_body(&self,\n+                             tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             id: DefIndex)\n+                             -> &'tcx hir::Body {\n         assert!(!self.is_proc_macro(id));\n         let ast = self.entry(id).ast.unwrap();\n         let def_id = self.local_def_id(id);\n@@ -836,7 +837,7 @@ impl<'a, 'tcx> CrateMetadata {\n         };\n \n         ty::AssociatedItem {\n-            name,\n+            name: Symbol::intern(&name),\n             kind,\n             vis: item.visibility.decode(self),\n             defaultness: container.defaultness(),\n@@ -906,7 +907,7 @@ impl<'a, 'tcx> CrateMetadata {\n         self.entry(id)\n             .children\n             .decode(self)\n-            .map(|index| self.item_name(index))\n+            .map(|index| Symbol::intern(&self.item_name(index)))\n             .collect()\n     }\n \n@@ -1038,7 +1039,7 @@ impl<'a, 'tcx> CrateMetadata {\n             .collect()\n     }\n \n-    pub fn get_macro(&self, id: DefIndex) -> (ast::Name, MacroDef) {\n+    pub fn get_macro(&self, id: DefIndex) -> (InternedString, MacroDef) {\n         let entry = self.entry(id);\n         match entry.kind {\n             EntryKind::MacroDef(macro_def) => (self.item_name(id), macro_def.decode(self)),"}, {"sha": "0a1662dd42d909eae0c8147e7795880c26aae5b5", "filename": "src/librustc_metadata/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_metadata%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_metadata%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdiagnostics.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -14,7 +14,7 @@ register_long_diagnostics! {\n E0454: r##\"\n A link name was given with an empty name. Erroneous code example:\n \n-```compile_fail,E0454\n+```ignore (cannot-test-this-because-rustdoc-stops-compile-fail-before-trans)\n #[link(name = \"\")] extern {} // error: #[link(name = \"\")] given with empty name\n ```\n \n@@ -51,7 +51,7 @@ https://doc.rust-lang.org/book/first-edition/conditional-compilation.html\n E0458: r##\"\n An unknown \"kind\" was specified for a link attribute. Erroneous code example:\n \n-```compile_fail,E0458\n+```ignore (cannot-test-this-because-rustdoc-stops-compile-fail-before-trans)\n #[link(kind = \"wonderful_unicorn\")] extern {}\n // error: unknown kind: `wonderful_unicorn`\n ```\n@@ -67,7 +67,7 @@ Please specify a valid \"kind\" value, from one of the following:\n E0459: r##\"\n A link was used without a name parameter. Erroneous code example:\n \n-```compile_fail,E0459\n+```ignore (cannot-test-this-because-rustdoc-stops-compile-fail-before-trans)\n #[link(kind = \"dylib\")] extern {}\n // error: #[link(...)] specified without `name = \"foo\"`\n ```"}, {"sha": "a27a85a63e8a72545635d2e166ab87d88837d3cc", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -991,7 +991,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 // \"unsized info\", else just store None\n                 let coerce_unsized_info =\n                     trait_ref.and_then(|t| {\n-                        if Some(t.def_id) == tcx.lang_items.coerce_unsized_trait() {\n+                        if Some(t.def_id) == tcx.lang_items().coerce_unsized_trait() {\n                             Some(tcx.at(item.span).coerce_unsized_info(def_id))\n                         } else {\n                             None\n@@ -1283,21 +1283,20 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_native_libraries(&mut self, _: ()) -> LazySeq<NativeLibrary> {\n-        let used_libraries = self.tcx.sess.cstore.used_libraries();\n-        self.lazy_seq(used_libraries)\n+        let used_libraries = self.tcx.native_libraries(LOCAL_CRATE);\n+        self.lazy_seq(used_libraries.iter().cloned())\n     }\n \n     fn encode_crate_deps(&mut self, _: ()) -> LazySeq<CrateDep> {\n-        let cstore = &*self.tcx.sess.cstore;\n-        let crates = cstore.crates();\n+        let crates = self.tcx.crates();\n \n         let mut deps = crates\n             .iter()\n             .map(|&cnum| {\n                 let dep = CrateDep {\n-                    name: cstore.original_crate_name(cnum),\n-                    hash: cstore.crate_hash(cnum),\n-                    kind: cstore.dep_kind(cnum),\n+                    name: self.tcx.original_crate_name(cnum),\n+                    hash: self.tcx.crate_hash(cnum),\n+                    kind: self.tcx.dep_kind(cnum),\n                 };\n                 (cnum, dep)\n             })\n@@ -1323,7 +1322,8 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n     fn encode_lang_items(&mut self, _: ()) -> LazySeq<(DefIndex, usize)> {\n         let tcx = self.tcx;\n-        let lang_items = tcx.lang_items.items().iter();\n+        let lang_items = tcx.lang_items();\n+        let lang_items = lang_items.items().iter();\n         self.lazy_seq(lang_items.enumerate().filter_map(|(i, &opt_def_id)| {\n             if let Some(def_id) = opt_def_id {\n                 if def_id.is_local() {\n@@ -1336,7 +1336,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n     fn encode_lang_items_missing(&mut self, _: ()) -> LazySeq<lang_items::LangItem> {\n         let tcx = self.tcx;\n-        self.lazy_seq_ref(&tcx.lang_items.missing)\n+        self.lazy_seq_ref(&tcx.lang_items().missing)\n     }\n \n     /// Encodes an index, mapping each trait to its (local) implementations."}, {"sha": "54dbb68667b3a4aabeb268103806471d1b88bbf5", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -50,6 +50,8 @@ mod decoder;\n mod cstore_impl;\n mod isolated_encoder;\n mod schema;\n+mod native_libs;\n+mod link_args;\n \n pub mod creader;\n pub mod cstore;"}, {"sha": "6fafde0d09c16f04e8f2e62e6a071db442cbc2c1", "filename": "src/librustc_metadata/link_args.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_metadata%2Flink_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_metadata%2Flink_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flink_args.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -0,0 +1,65 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::hir;\n+use rustc::ty::TyCtxt;\n+use syntax::abi::Abi;\n+\n+pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Vec<String> {\n+    let mut collector = Collector {\n+        args: Vec::new(),\n+    };\n+    tcx.hir.krate().visit_all_item_likes(&mut collector);\n+\n+    for attr in tcx.hir.krate().attrs.iter() {\n+        if attr.path == \"link_args\" {\n+            if let Some(linkarg) = attr.value_str() {\n+                collector.add_link_args(&linkarg.as_str());\n+            }\n+        }\n+    }\n+\n+    return collector.args\n+}\n+\n+struct Collector {\n+    args: Vec<String>,\n+}\n+\n+impl<'tcx> ItemLikeVisitor<'tcx> for Collector {\n+    fn visit_item(&mut self, it: &'tcx hir::Item) {\n+        let fm = match it.node {\n+            hir::ItemForeignMod(ref fm) => fm,\n+            _ => return,\n+        };\n+        if fm.abi == Abi::Rust ||\n+            fm.abi == Abi::RustIntrinsic ||\n+            fm.abi == Abi::PlatformIntrinsic {\n+            return\n+        }\n+\n+        // First, add all of the custom #[link_args] attributes\n+        for m in it.attrs.iter().filter(|a| a.check_name(\"link_args\")) {\n+            if let Some(linkarg) = m.value_str() {\n+                self.add_link_args(&linkarg.as_str());\n+            }\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, _it: &'tcx hir::TraitItem) {}\n+    fn visit_impl_item(&mut self, _it: &'tcx hir::ImplItem) {}\n+}\n+\n+impl Collector {\n+    fn add_link_args(&mut self, args: &str) {\n+        self.args.extend(args.split(' ').filter(|s| !s.is_empty()).map(|s| s.to_string()))\n+    }\n+}"}, {"sha": "669681d2aadde5ea71d462fedc11bdba0ef761e5", "filename": "src/librustc_metadata/native_libs.rs", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -0,0 +1,217 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::hir;\n+use rustc::middle::cstore::{self, NativeLibrary};\n+use rustc::session::Session;\n+use rustc::ty::TyCtxt;\n+use rustc::util::nodemap::FxHashSet;\n+use syntax::abi::Abi;\n+use syntax::attr;\n+use syntax::codemap::Span;\n+use syntax::feature_gate::{self, GateIssue};\n+use syntax::symbol::Symbol;\n+\n+pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Vec<NativeLibrary> {\n+    let mut collector = Collector {\n+        tcx,\n+        libs: Vec::new(),\n+    };\n+    tcx.hir.krate().visit_all_item_likes(&mut collector);\n+    collector.process_command_line();\n+    return collector.libs\n+}\n+\n+pub fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n+    match lib.cfg {\n+        Some(ref cfg) => attr::cfg_matches(cfg, &sess.parse_sess, None),\n+        None => true,\n+    }\n+}\n+\n+struct Collector<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    libs: Vec<NativeLibrary>,\n+}\n+\n+impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n+    fn visit_item(&mut self, it: &'tcx hir::Item) {\n+        let fm = match it.node {\n+            hir::ItemForeignMod(ref fm) => fm,\n+            _ => return,\n+        };\n+\n+        if fm.abi == Abi::Rust ||\n+            fm.abi == Abi::RustIntrinsic ||\n+            fm.abi == Abi::PlatformIntrinsic {\n+            return\n+        }\n+\n+        // Process all of the #[link(..)]-style arguments\n+        for m in it.attrs.iter().filter(|a| a.check_name(\"link\")) {\n+            let items = match m.meta_item_list() {\n+                Some(item) => item,\n+                None => continue,\n+            };\n+            let kind = items.iter().find(|k| {\n+                k.check_name(\"kind\")\n+            }).and_then(|a| a.value_str()).map(Symbol::as_str);\n+            let kind = match kind.as_ref().map(|s| &s[..]) {\n+                Some(\"static\") => cstore::NativeStatic,\n+                Some(\"static-nobundle\") => cstore::NativeStaticNobundle,\n+                Some(\"dylib\") => cstore::NativeUnknown,\n+                Some(\"framework\") => cstore::NativeFramework,\n+                Some(k) => {\n+                    struct_span_err!(self.tcx.sess, m.span, E0458,\n+                              \"unknown kind: `{}`\", k)\n+                        .span_label(m.span, \"unknown kind\").emit();\n+                    cstore::NativeUnknown\n+                }\n+                None => cstore::NativeUnknown\n+            };\n+            let n = items.iter().find(|n| {\n+                n.check_name(\"name\")\n+            }).and_then(|a| a.value_str());\n+            let n = match n {\n+                Some(n) => n,\n+                None => {\n+                    struct_span_err!(self.tcx.sess, m.span, E0459,\n+                                     \"#[link(...)] specified without `name = \\\"foo\\\"`\")\n+                        .span_label(m.span, \"missing `name` argument\").emit();\n+                    Symbol::intern(\"foo\")\n+                }\n+            };\n+            let cfg = items.iter().find(|k| {\n+                k.check_name(\"cfg\")\n+            }).and_then(|a| a.meta_item_list());\n+            let cfg = cfg.map(|list| {\n+                list[0].meta_item().unwrap().clone()\n+            });\n+            let foreign_items = fm.items.iter()\n+                .map(|it| self.tcx.hir.local_def_id(it.id).index)\n+                .collect();\n+            let lib = NativeLibrary {\n+                name: n,\n+                kind,\n+                cfg,\n+                foreign_items,\n+            };\n+            self.register_native_lib(Some(m.span), lib);\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, _it: &'tcx hir::TraitItem) {}\n+    fn visit_impl_item(&mut self, _it: &'tcx hir::ImplItem) {}\n+}\n+\n+impl<'a, 'tcx> Collector<'a, 'tcx> {\n+    fn register_native_lib(&mut self, span: Option<Span>, lib: NativeLibrary) {\n+        if lib.name.as_str().is_empty() {\n+            match span {\n+                Some(span) => {\n+                    struct_span_err!(self.tcx.sess, span, E0454,\n+                                     \"#[link(name = \\\"\\\")] given with empty name\")\n+                        .span_label(span, \"empty name given\")\n+                        .emit();\n+                }\n+                None => {\n+                    self.tcx.sess.err(\"empty library name given via `-l`\");\n+                }\n+            }\n+            return\n+        }\n+        let is_osx = self.tcx.sess.target.target.options.is_like_osx;\n+        if lib.kind == cstore::NativeFramework && !is_osx {\n+            let msg = \"native frameworks are only available on macOS targets\";\n+            match span {\n+                Some(span) => span_err!(self.tcx.sess, span, E0455, \"{}\", msg),\n+                None => self.tcx.sess.err(msg),\n+            }\n+        }\n+        if lib.cfg.is_some() && !self.tcx.sess.features.borrow().link_cfg {\n+            feature_gate::emit_feature_err(&self.tcx.sess.parse_sess,\n+                                           \"link_cfg\",\n+                                           span.unwrap(),\n+                                           GateIssue::Language,\n+                                           \"is feature gated\");\n+        }\n+        if lib.kind == cstore::NativeStaticNobundle &&\n+           !self.tcx.sess.features.borrow().static_nobundle {\n+            feature_gate::emit_feature_err(&self.tcx.sess.parse_sess,\n+                                           \"static_nobundle\",\n+                                           span.unwrap(),\n+                                           GateIssue::Language,\n+                                           \"kind=\\\"static-nobundle\\\" is feature gated\");\n+        }\n+        self.libs.push(lib);\n+    }\n+\n+    // Process libs passed on the command line\n+    fn process_command_line(&mut self) {\n+        // First, check for errors\n+        let mut renames = FxHashSet();\n+        for &(ref name, ref new_name, _) in &self.tcx.sess.opts.libs {\n+            if let &Some(ref new_name) = new_name {\n+                if new_name.is_empty() {\n+                    self.tcx.sess.err(\n+                        &format!(\"an empty renaming target was specified for library `{}`\",name));\n+                } else if !self.libs.iter().any(|lib| lib.name == name as &str) {\n+                    self.tcx.sess.err(&format!(\"renaming of the library `{}` was specified, \\\n+                                                however this crate contains no #[link(...)] \\\n+                                                attributes referencing this library.\", name));\n+                } else if renames.contains(name) {\n+                    self.tcx.sess.err(&format!(\"multiple renamings were \\\n+                                                specified for library `{}` .\",\n+                                               name));\n+                } else {\n+                    renames.insert(name);\n+                }\n+            }\n+        }\n+\n+        // Update kind and, optionally, the name of all native libaries\n+        // (there may be more than one) with the specified name.\n+        for &(ref name, ref new_name, kind) in &self.tcx.sess.opts.libs {\n+            let mut found = false;\n+            for lib in self.libs.iter_mut() {\n+                if lib.name == name as &str {\n+                    let mut changed = false;\n+                    if let Some(k) = kind {\n+                        lib.kind = k;\n+                        changed = true;\n+                    }\n+                    if let &Some(ref new_name) = new_name {\n+                        lib.name = Symbol::intern(new_name);\n+                        changed = true;\n+                    }\n+                    if !changed {\n+                        let msg = format!(\"redundant linker flag specified for \\\n+                                           library `{}`\", name);\n+                        self.tcx.sess.warn(&msg);\n+                    }\n+\n+                    found = true;\n+                }\n+            }\n+            if !found {\n+                // Add if not found\n+                let new_name = new_name.as_ref().map(|s| &**s); // &Option<String> -> Option<&str>\n+                let lib = NativeLibrary {\n+                    name: Symbol::intern(new_name.unwrap_or(name)),\n+                    kind: if let Some(k) = kind { k } else { cstore::NativeUnknown },\n+                    cfg: None,\n+                    foreign_items: Vec::new(),\n+                };\n+                self.register_native_lib(None, lib);\n+            }\n+        }\n+    }\n+}"}, {"sha": "ec06e474980a63478a68a681e3a2f30dab256ad7", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -209,7 +209,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         let f = ty.fn_sig(this.hir.tcx());\n                         if f.abi() == Abi::RustIntrinsic ||\n                            f.abi() == Abi::PlatformIntrinsic {\n-                            Some(this.hir.tcx().item_name(def_id).as_str())\n+                            Some(this.hir.tcx().item_name(def_id))\n                         } else {\n                             None\n                         }"}, {"sha": "0b91e08fc6d70c8e80c898ca909180f9844d588f", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -299,7 +299,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let fail = self.cfg.start_new_block();\n                 if let ty::TyRef(_, mt) = ty.sty {\n                     assert!(ty.is_slice());\n-                    let eq_def_id = self.hir.tcx().lang_items.eq_trait().unwrap();\n+                    let eq_def_id = self.hir.tcx().lang_items().eq_trait().unwrap();\n                     let ty = mt.ty;\n                     let (mty, method) = self.hir.trait_method(eq_def_id, \"eq\", ty, &[ty]);\n "}, {"sha": "ec545443bcd9040629bbbea6b2521e3b827ec57b", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -47,7 +47,7 @@ fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n             bug!(\"item {:?} passed to make_shim\", instance),\n         ty::InstanceDef::FnPtrShim(def_id, ty) => {\n             let trait_ = tcx.trait_of_item(def_id).unwrap();\n-            let adjustment = match tcx.lang_items.fn_trait_kind(trait_) {\n+            let adjustment = match tcx.lang_items().fn_trait_kind(trait_) {\n                 Some(ty::ClosureKind::FnOnce) => Adjustment::Identity,\n                 Some(ty::ClosureKind::FnMut) |\n                 Some(ty::ClosureKind::Fn) => Adjustment::Deref,\n@@ -82,7 +82,7 @@ fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n             )\n         }\n         ty::InstanceDef::ClosureOnceShim { call_once } => {\n-            let fn_mut = tcx.lang_items.fn_mut_trait().unwrap();\n+            let fn_mut = tcx.lang_items().fn_mut_trait().unwrap();\n             let call_mut = tcx.global_tcx()\n                 .associated_items(fn_mut)\n                 .find(|it| it.kind == ty::AssociatedKind::Method)\n@@ -100,7 +100,7 @@ fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n             build_drop_shim(tcx, def_id, ty)\n         }\n         ty::InstanceDef::CloneShim(def_id, ty) => {\n-            let name = tcx.item_name(def_id).as_str();\n+            let name = tcx.item_name(def_id);\n             if name == \"clone\" {\n                 build_clone_shim(tcx, def_id, ty)\n             } else if name == \"clone_from\" {"}, {"sha": "0fb34c96b062d1763a64b4474398427405da575a", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -715,7 +715,7 @@ impl MirPass for StateTransform {\n         let gen_ty = mir.local_decls.raw[1].ty;\n \n         // Compute GeneratorState<yield_ty, return_ty>\n-        let state_did = tcx.lang_items.gen_state().unwrap();\n+        let state_did = tcx.lang_items().gen_state().unwrap();\n         let state_adt_ref = tcx.adt_def(state_did);\n         let state_substs = tcx.mk_substs([Kind::from(yield_ty),\n             Kind::from(mir.return_ty)].iter());"}, {"sha": "6e49c444195badd5e8875ef3a53435292df4da68", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -338,7 +338,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             TerminatorKind::Call { args, destination: Some(destination), cleanup, .. } => {\n                 debug!(\"Inlined {:?} into {:?}\", callsite.callee, self.source);\n \n-                let is_box_free = Some(callsite.callee) == self.tcx.lang_items.box_free_fn();\n+                let is_box_free = Some(callsite.callee) == self.tcx.lang_items().box_free_fn();\n \n                 let mut local_map = IndexVec::with_capacity(callee_mir.local_decls.len());\n                 let mut scope_map = IndexVec::with_capacity(callee_mir.visibility_scopes.len());"}, {"sha": "ded97275468b9170d0ae2cb45a025ac285f5d804", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -252,7 +252,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n     }\n \n     fn find_drop_implementation_method_span(&self) -> Option<Span> {\n-        self.tcx.lang_items\n+        self.tcx.lang_items()\n             .drop_trait()\n             .and_then(|drop_trait_id| {\n                 let mut span = None;\n@@ -795,7 +795,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                         self.deny_drop();\n                     }\n \n-                    if Some(def.did) == self.tcx.lang_items.unsafe_cell_type() {\n+                    if Some(def.did) == self.tcx.lang_items().unsafe_cell_type() {\n                         let ty = rvalue.ty(self.mir, self.tcx);\n                         self.add_type(ty);\n                         assert!(self.qualif.intersects(Qualif::MUTABLE_INTERIOR));\n@@ -824,7 +824,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     Abi::RustIntrinsic |\n                     Abi::PlatformIntrinsic => {\n                         assert!(!self.tcx.is_const_fn(def_id));\n-                        match &self.tcx.item_name(def_id).as_str()[..] {\n+                        match &self.tcx.item_name(def_id)[..] {\n                             \"size_of\" | \"min_align_of\" => is_const_fn = true,\n \n                             name if name.starts_with(\"simd_shuffle\") => {"}, {"sha": "7fbeb9610f4719f6d9e4d3fb23743eedb2fe720c", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -575,7 +575,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     value: ConstVal::Function(def_id, _), ..\n                 }, ..\n             }) => {\n-                Some(def_id) == self.tcx().lang_items.box_free_fn()\n+                Some(def_id) == self.tcx().lang_items().box_free_fn()\n             }\n             _ => false,\n         }"}, {"sha": "8ea47c2991009c3e2e0d75d86cb09bbae29f0582", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -515,7 +515,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     {\n         debug!(\"destructor_call_block({:?}, {:?})\", self, succ);\n         let tcx = self.tcx();\n-        let drop_trait = tcx.lang_items.drop_trait().unwrap();\n+        let drop_trait = tcx.lang_items().drop_trait().unwrap();\n         let drop_fn = tcx.associated_items(drop_trait).next().unwrap();\n         let ty = self.lvalue_ty(self.lvalue);\n         let substs = tcx.mk_substs(iter::once(Kind::from(ty)));"}, {"sha": "6f2c448ceb6f91abeafabc8335852dd9d35ff4c6", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -401,7 +401,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n         hir::ExprStruct(..) => {\n             if let ty::TyAdt(adt, ..) = v.tables.expr_ty(e).sty {\n                 // unsafe_cell_type doesn't necessarily exist with no_core\n-                if Some(adt.did) == v.tcx.lang_items.unsafe_cell_type() {\n+                if Some(adt.did) == v.tcx.lang_items().unsafe_cell_type() {\n                     v.promotable = false;\n                 }\n             }"}, {"sha": "139cb61bd9bd72a2a175f5ac14ddccb682d0b35e", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -630,7 +630,7 @@ impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n                 };\n                 ty::Visibility::from_hir(vis, node_id, self.tcx)\n             }\n-            None => self.tcx.sess.cstore.visibility(did),\n+            None => self.tcx.visibility(did),\n         }\n     }\n "}, {"sha": "35e7522db0184435b6a2aedc1ca408d765add146", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -42,6 +42,7 @@ use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n use syntax::parse::token;\n use syntax::symbol::keywords;\n+use syntax::symbol::Symbol;\n use syntax::visit::{self, Visitor};\n \n use syntax_pos::{Span, DUMMY_SP};\n@@ -253,7 +254,7 @@ impl<'a> Resolver<'a> {\n                 self.crate_loader.process_item(item, &self.definitions);\n \n                 // n.b. we don't need to look at the path option here, because cstore already did\n-                let crate_id = self.session.cstore.extern_mod_stmt_cnum(item.id).unwrap();\n+                let crate_id = self.session.cstore.extern_mod_stmt_cnum_untracked(item.id).unwrap();\n                 let module =\n                     self.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX });\n                 self.populate_module_if_necessary(module);\n@@ -449,7 +450,7 @@ impl<'a> Resolver<'a> {\n         let ident = child.ident;\n         let def = child.def;\n         let def_id = def.def_id();\n-        let vis = self.session.cstore.visibility(def_id);\n+        let vis = self.session.cstore.visibility_untracked(def_id);\n         let span = child.span;\n         let expansion = Mark::root(); // FIXME(jseyfried) intercrate hygiene\n         match def {\n@@ -485,12 +486,12 @@ impl<'a> Resolver<'a> {\n                                              span);\n                 self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, expansion));\n \n-                for child in self.session.cstore.item_children(def_id, self.session) {\n+                for child in self.session.cstore.item_children_untracked(def_id, self.session) {\n                     let ns = if let Def::AssociatedTy(..) = child.def { TypeNS } else { ValueNS };\n                     self.define(module, child.ident, ns,\n                                 (child.def, ty::Visibility::Public, DUMMY_SP, expansion));\n \n-                    if self.session.cstore.associated_item_cloned(child.def.def_id())\n+                    if self.session.cstore.associated_item_cloned_untracked(child.def.def_id())\n                            .method_has_self_argument {\n                         self.has_self.insert(child.def.def_id());\n                     }\n@@ -501,7 +502,7 @@ impl<'a> Resolver<'a> {\n                 self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, expansion));\n \n                 // Record field names for error reporting.\n-                let field_names = self.session.cstore.struct_field_names(def_id);\n+                let field_names = self.session.cstore.struct_field_names_untracked(def_id);\n                 self.insert_field_names(def_id, field_names);\n             }\n             Def::Macro(..) => {\n@@ -516,20 +517,20 @@ impl<'a> Resolver<'a> {\n             return self.module_map[&def_id]\n         }\n \n-        let macros_only = self.session.cstore.dep_kind(def_id.krate).macros_only();\n+        let macros_only = self.session.cstore.dep_kind_untracked(def_id.krate).macros_only();\n         if let Some(&module) = self.extern_module_map.get(&(def_id, macros_only)) {\n             return module;\n         }\n \n         let (name, parent) = if def_id.index == CRATE_DEF_INDEX {\n-            (self.session.cstore.crate_name(def_id.krate), None)\n+            (self.session.cstore.crate_name_untracked(def_id.krate).as_str(), None)\n         } else {\n             let def_key = self.session.cstore.def_key(def_id);\n             (def_key.disambiguated_data.data.get_opt_name().unwrap(),\n              Some(self.get_module(DefId { index: def_key.parent.unwrap(), ..def_id })))\n         };\n \n-        let kind = ModuleKind::Def(Def::Mod(def_id), name);\n+        let kind = ModuleKind::Def(Def::Mod(def_id), Symbol::intern(&name));\n         let module =\n             self.arenas.alloc_module(ModuleData::new(parent, kind, def_id, Mark::root(), DUMMY_SP));\n         self.extern_module_map.insert((def_id, macros_only), module);\n@@ -558,7 +559,7 @@ impl<'a> Resolver<'a> {\n             return ext.clone();\n         }\n \n-        let macro_def = match self.session.cstore.load_macro(def_id, &self.session) {\n+        let macro_def = match self.session.cstore.load_macro_untracked(def_id, &self.session) {\n             LoadedMacro::MacroDef(macro_def) => macro_def,\n             LoadedMacro::ProcMacro(ext) => return ext,\n         };\n@@ -574,7 +575,8 @@ impl<'a> Resolver<'a> {\n     /// is built, building it if it is not.\n     pub fn populate_module_if_necessary(&mut self, module: Module<'a>) {\n         if module.populated.get() { return }\n-        for child in self.session.cstore.item_children(module.def_id().unwrap(), self.session) {\n+        let def_id = module.def_id().unwrap();\n+        for child in self.session.cstore.item_children_untracked(def_id, self.session) {\n             self.build_reduced_graph_for_external_crate_def(module, child);\n         }\n         module.populated.set(true)\n@@ -605,7 +607,8 @@ impl<'a> Resolver<'a> {\n             span_err!(self.session, item.span, E0468,\n                       \"an `extern crate` loading macros must be at the crate root\");\n         } else if !self.use_extern_macros && !used &&\n-                  self.session.cstore.dep_kind(module.def_id().unwrap().krate).macros_only() {\n+                  self.session.cstore.dep_kind_untracked(module.def_id().unwrap().krate)\n+                      .macros_only() {\n             let msg = \"proc macro crates and `#[no_link]` crates have no effect without \\\n                        `#[macro_use]`\";\n             self.session.span_warn(item.span, msg);\n@@ -648,7 +651,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n         for (name, span) in legacy_imports.reexports {\n-            self.session.cstore.export_macros(module.def_id().unwrap().krate);\n+            self.session.cstore.export_macros_untracked(module.def_id().unwrap().krate);\n             let ident = Ident::with_empty_ctxt(name);\n             let result = self.resolve_ident_in_module(module, ident, MacroNS, false, false, span);\n             if let Ok(binding) = result {"}, {"sha": "c083a0ff58855a51eaddc86d508a0300ee087ffb", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -778,7 +778,7 @@ impl<'a> Resolver<'a> {\n             _ => return,\n         };\n \n-        let crate_name = self.session.cstore.crate_name(krate);\n+        let crate_name = self.session.cstore.crate_name_untracked(krate);\n \n         self.session.struct_span_err(use_span, warn_msg)\n             .help(&format!(\"instead, import the procedural macro like any other item: \\"}, {"sha": "7524b7e8c6c215fab11417b379e1e3d07117f60d", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -844,7 +844,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 let def = binding.def();\n                 if def != Def::Err {\n                     if !def.def_id().is_local() {\n-                        self.session.cstore.export_macros(def.def_id().krate);\n+                        self.session.cstore.export_macros_untracked(def.def_id().krate);\n                     }\n                     if let Def::Macro(..) = def {\n                         if let Some(&span) = exported_macro_names.get(&ident.modern()) {"}, {"sha": "3de5fda0d45c102c0f9fd52524c26942fed733c7", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -109,7 +109,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     pub fn get_external_crates(&self) -> Vec<ExternalCrateData> {\n         let mut result = Vec::new();\n \n-        for n in self.tcx.sess.cstore.crates() {\n+        for &n in self.tcx.crates().iter() {\n             let span = match *self.tcx.extern_crate(n.as_def_id()) {\n                 Some(ref c) => c.span,\n                 None => {\n@@ -119,7 +119,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             };\n             let lo_loc = self.span_utils.sess.codemap().lookup_char_pos(span.lo());\n             result.push(ExternalCrateData {\n-                name: self.tcx.sess.cstore.crate_name(n).to_string(),\n+                name: self.tcx.crate_name(n).to_string(),\n                 num: n.as_u32(),\n                 file_name: SpanUtils::make_path_string(&lo_loc.file.name),\n             });"}, {"sha": "5d45aafe78d2510ddd63c342a3a1e078ba9e56c7", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 54, "deletions": 46, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -20,10 +20,9 @@ use rustc::session::config::{self, NoDebugInfo, OutputFilenames, OutputType, Pri\n use rustc::session::filesearch;\n use rustc::session::search_paths::PathKind;\n use rustc::session::Session;\n-use rustc::middle::cstore::{LinkMeta, NativeLibrary, LibSource, LinkagePreference,\n-                            NativeLibraryKind};\n+use rustc::middle::cstore::{LinkMeta, NativeLibrary, LibSource, NativeLibraryKind};\n use rustc::middle::dependency_format::Linkage;\n-use CrateTranslation;\n+use {CrateTranslation, CrateInfo};\n use rustc::util::common::time;\n use rustc::util::fs::fix_windows_verbatim_for_gcc;\n use rustc::dep_graph::{DepKind, DepNode};\n@@ -223,8 +222,9 @@ fn filename_for_metadata(sess: &Session, crate_name: &str, outputs: &OutputFilen\n }\n \n pub fn each_linked_rlib(sess: &Session,\n+                        info: &CrateInfo,\n                         f: &mut FnMut(CrateNum, &Path)) -> Result<(), String> {\n-    let crates = sess.cstore.used_crates(LinkagePreference::RequireStatic).into_iter();\n+    let crates = info.used_crates_static.iter();\n     let fmts = sess.dependency_formats.borrow();\n     let fmts = fmts.get(&config::CrateTypeExecutable)\n                    .or_else(|| fmts.get(&config::CrateTypeStaticlib))\n@@ -234,16 +234,16 @@ pub fn each_linked_rlib(sess: &Session,\n         Some(f) => f,\n         None => return Err(format!(\"could not find formats for rlibs\"))\n     };\n-    for (cnum, path) in crates {\n+    for &(cnum, ref path) in crates {\n         match fmts.get(cnum.as_usize() - 1) {\n             Some(&Linkage::NotLinked) |\n             Some(&Linkage::IncludedFromDylib) => continue,\n             Some(_) => {}\n             None => return Err(format!(\"could not find formats for rlibs\"))\n         }\n-        let name = sess.cstore.crate_name(cnum).clone();\n-        let path = match path {\n-            LibSource::Some(p) => p,\n+        let name = &info.crate_name[&cnum];\n+        let path = match *path {\n+            LibSource::Some(ref p) => p,\n             LibSource::MetadataOnly => {\n                 return Err(format!(\"could not find rlib for: `{}`, found rmeta (metadata) file\",\n                                    name))\n@@ -267,12 +267,12 @@ pub fn each_linked_rlib(sess: &Session,\n /// It's unusual for a crate to not participate in LTO. Typically only\n /// compiler-specific and unstable crates have a reason to not participate in\n /// LTO.\n-pub fn ignored_for_lto(sess: &Session, cnum: CrateNum) -> bool {\n+pub fn ignored_for_lto(info: &CrateInfo, cnum: CrateNum) -> bool {\n     // `#![no_builtins]` crates don't participate in LTO because the state\n     // of builtins gets messed up (our crate isn't tagged with no builtins).\n     // Similarly `#![compiler_builtins]` doesn't participate because we want\n     // those builtins!\n-    sess.cstore.is_no_builtins(cnum) || sess.cstore.is_compiler_builtins(cnum)\n+    info.is_no_builtins.contains(&cnum) || info.compiler_builtins == Some(cnum)\n }\n \n fn out_filename(sess: &Session,\n@@ -438,7 +438,7 @@ fn link_rlib<'a>(sess: &'a Session,\n     // feature then we'll need to figure out how to record what objects were\n     // loaded from the libraries found here and then encode that into the\n     // metadata of the rlib we're generating somehow.\n-    for lib in sess.cstore.used_libraries() {\n+    for lib in trans.crate_info.used_libraries.iter() {\n         match lib.kind {\n             NativeLibraryKind::NativeStatic => {}\n             NativeLibraryKind::NativeStaticNobundle |\n@@ -618,9 +618,9 @@ fn link_staticlib(sess: &Session,\n                            tempdir);\n     let mut all_native_libs = vec![];\n \n-    let res = each_linked_rlib(sess, &mut |cnum, path| {\n-        let name = sess.cstore.crate_name(cnum);\n-        let native_libs = sess.cstore.native_libraries(cnum);\n+    let res = each_linked_rlib(sess, &trans.crate_info, &mut |cnum, path| {\n+        let name = &trans.crate_info.crate_name[&cnum];\n+        let native_libs = &trans.crate_info.native_libraries[&cnum];\n \n         // Here when we include the rlib into our staticlib we need to make a\n         // decision whether to include the extra object files along the way.\n@@ -641,10 +641,10 @@ fn link_staticlib(sess: &Session,\n         });\n         ab.add_rlib(path,\n                     &name.as_str(),\n-                    sess.lto() && !ignored_for_lto(sess, cnum),\n+                    sess.lto() && !ignored_for_lto(&trans.crate_info, cnum),\n                     skip_object_files).unwrap();\n \n-        all_native_libs.extend(sess.cstore.native_libraries(cnum));\n+        all_native_libs.extend(trans.crate_info.native_libraries[&cnum].iter().cloned());\n     });\n     if let Err(e) = res {\n         sess.fatal(&e);\n@@ -1031,7 +1031,7 @@ fn link_args(cmd: &mut Linker,\n         cmd.gc_sections(keep_metadata);\n     }\n \n-    let used_link_args = sess.cstore.used_link_args();\n+    let used_link_args = &trans.crate_info.link_args;\n \n     if crate_type == config::CrateTypeExecutable &&\n        t.options.position_independent_executables {\n@@ -1101,9 +1101,9 @@ fn link_args(cmd: &mut Linker,\n     // link line. And finally upstream native libraries can't depend on anything\n     // in this DAG so far because they're only dylibs and dylibs can only depend\n     // on other dylibs (e.g. other native deps).\n-    add_local_native_libraries(cmd, sess);\n-    add_upstream_rust_crates(cmd, sess, crate_type, tmpdir);\n-    add_upstream_native_libraries(cmd, sess, crate_type);\n+    add_local_native_libraries(cmd, sess, trans);\n+    add_upstream_rust_crates(cmd, sess, trans, crate_type, tmpdir);\n+    add_upstream_native_libraries(cmd, sess, trans, crate_type);\n \n     // Tell the linker what we're doing.\n     if crate_type != config::CrateTypeExecutable {\n@@ -1128,7 +1128,7 @@ fn link_args(cmd: &mut Linker,\n             path\n         };\n         let mut rpath_config = RPathConfig {\n-            used_crates: sess.cstore.used_crates(LinkagePreference::RequireDynamic),\n+            used_crates: &trans.crate_info.used_crates_dynamic,\n             out_filename: out_filename.to_path_buf(),\n             has_rpath: sess.target.target.options.has_rpath,\n             is_like_osx: sess.target.target.options.is_like_osx,\n@@ -1158,15 +1158,17 @@ fn link_args(cmd: &mut Linker,\n // Also note that the native libraries linked here are only the ones located\n // in the current crate. Upstream crates with native library dependencies\n // may have their native library pulled in above.\n-fn add_local_native_libraries(cmd: &mut Linker, sess: &Session) {\n+fn add_local_native_libraries(cmd: &mut Linker,\n+                              sess: &Session,\n+                              trans: &CrateTranslation) {\n     sess.target_filesearch(PathKind::All).for_each_lib_search_path(|path, k| {\n         match k {\n             PathKind::Framework => { cmd.framework_path(path); }\n             _ => { cmd.include_path(&fix_windows_verbatim_for_gcc(path)); }\n         }\n     });\n \n-    let relevant_libs = sess.cstore.used_libraries().into_iter().filter(|l| {\n+    let relevant_libs = trans.crate_info.used_libraries.iter().filter(|l| {\n         relevant_lib(sess, l)\n     });\n \n@@ -1189,6 +1191,7 @@ fn add_local_native_libraries(cmd: &mut Linker, sess: &Session) {\n // the intermediate rlib version)\n fn add_upstream_rust_crates(cmd: &mut Linker,\n                             sess: &Session,\n+                            trans: &CrateTranslation,\n                             crate_type: config::CrateType,\n                             tmpdir: &Path) {\n     // All of the heavy lifting has previously been accomplished by the\n@@ -1204,35 +1207,35 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n \n     // Invoke get_used_crates to ensure that we get a topological sorting of\n     // crates.\n-    let deps = sess.cstore.used_crates(LinkagePreference::RequireDynamic);\n+    let deps = &trans.crate_info.used_crates_dynamic;\n \n     let mut compiler_builtins = None;\n \n-    for &(cnum, _) in &deps {\n+    for &(cnum, _) in deps.iter() {\n         // We may not pass all crates through to the linker. Some crates may\n         // appear statically in an existing dylib, meaning we'll pick up all the\n         // symbols from the dylib.\n-        let src = sess.cstore.used_crate_source(cnum);\n+        let src = &trans.crate_info.used_crate_source[&cnum];\n         match data[cnum.as_usize() - 1] {\n-            _ if sess.cstore.is_profiler_runtime(cnum) => {\n-                add_static_crate(cmd, sess, tmpdir, crate_type, cnum);\n+            _ if trans.crate_info.profiler_runtime == Some(cnum) => {\n+                add_static_crate(cmd, sess, trans, tmpdir, crate_type, cnum);\n             }\n-            _ if sess.cstore.is_sanitizer_runtime(cnum) => {\n-                link_sanitizer_runtime(cmd, sess, tmpdir, cnum);\n+            _ if trans.crate_info.sanitizer_runtime == Some(cnum) => {\n+                link_sanitizer_runtime(cmd, sess, trans, tmpdir, cnum);\n             }\n             // compiler-builtins are always placed last to ensure that they're\n             // linked correctly.\n-            _ if sess.cstore.is_compiler_builtins(cnum) => {\n+            _ if trans.crate_info.compiler_builtins == Some(cnum) => {\n                 assert!(compiler_builtins.is_none());\n                 compiler_builtins = Some(cnum);\n             }\n             Linkage::NotLinked |\n             Linkage::IncludedFromDylib => {}\n             Linkage::Static => {\n-                add_static_crate(cmd, sess, tmpdir, crate_type, cnum);\n+                add_static_crate(cmd, sess, trans, tmpdir, crate_type, cnum);\n             }\n             Linkage::Dynamic => {\n-                add_dynamic_crate(cmd, sess, &src.dylib.unwrap().0)\n+                add_dynamic_crate(cmd, sess, &src.dylib.as_ref().unwrap().0)\n             }\n         }\n     }\n@@ -1243,7 +1246,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n     // was already \"included\" in a dylib (e.g. `libstd` when `-C prefer-dynamic`\n     // is used)\n     if let Some(cnum) = compiler_builtins {\n-        add_static_crate(cmd, sess, tmpdir, crate_type, cnum);\n+        add_static_crate(cmd, sess, trans, tmpdir, crate_type, cnum);\n     }\n \n     // Converts a library file-stem into a cc -l argument\n@@ -1261,10 +1264,11 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n     // linking it.\n     fn link_sanitizer_runtime(cmd: &mut Linker,\n                               sess: &Session,\n+                              trans: &CrateTranslation,\n                               tmpdir: &Path,\n                               cnum: CrateNum) {\n-        let src = sess.cstore.used_crate_source(cnum);\n-        let cratepath = &src.rlib.unwrap().0;\n+        let src = &trans.crate_info.used_crate_source[&cnum];\n+        let cratepath = &src.rlib.as_ref().unwrap().0;\n \n         if sess.target.target.options.is_like_osx {\n             // On Apple platforms, the sanitizer is always built as a dylib, and\n@@ -1329,21 +1333,22 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n     // we're at the end of the dependency chain.\n     fn add_static_crate(cmd: &mut Linker,\n                         sess: &Session,\n+                        trans: &CrateTranslation,\n                         tmpdir: &Path,\n                         crate_type: config::CrateType,\n                         cnum: CrateNum) {\n-        let src = sess.cstore.used_crate_source(cnum);\n-        let cratepath = &src.rlib.unwrap().0;\n+        let src = &trans.crate_info.used_crate_source[&cnum];\n+        let cratepath = &src.rlib.as_ref().unwrap().0;\n \n         // See the comment above in `link_staticlib` and `link_rlib` for why if\n         // there's a static library that's not relevant we skip all object\n         // files.\n-        let native_libs = sess.cstore.native_libraries(cnum);\n+        let native_libs = &trans.crate_info.native_libraries[&cnum];\n         let skip_native = native_libs.iter().any(|lib| {\n             lib.kind == NativeLibraryKind::NativeStatic && !relevant_lib(sess, lib)\n         });\n \n-        if (!sess.lto() || ignored_for_lto(sess, cnum)) &&\n+        if (!sess.lto() || ignored_for_lto(&trans.crate_info, cnum)) &&\n            crate_type != config::CrateTypeDylib &&\n            !skip_native {\n             cmd.link_rlib(&fix_windows_verbatim_for_gcc(cratepath));\n@@ -1385,7 +1390,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n                 // LTO module. Note that `#![no_builtins]` is excluded from LTO,\n                 // though, so we let that object file slide.\n                 let skip_because_lto = sess.lto() && is_rust_object &&\n-                                        !sess.cstore.is_no_builtins(cnum);\n+                                        !trans.crate_info.is_no_builtins.contains(&cnum);\n \n                 if skip_because_cfg_say_so || skip_because_lto {\n                     archive.remove_file(&f);\n@@ -1407,7 +1412,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n             // compiler-builtins crate (e.g. compiler-rt) because it'll get\n             // repeatedly linked anyway.\n             if crate_type == config::CrateTypeDylib &&\n-               !sess.cstore.is_compiler_builtins(cnum) {\n+                trans.crate_info.compiler_builtins != Some(cnum) {\n                 cmd.link_whole_rlib(&fix_windows_verbatim_for_gcc(&dst));\n             } else {\n                 cmd.link_rlib(&fix_windows_verbatim_for_gcc(&dst));\n@@ -1451,7 +1456,10 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n // generic function calls a native function, then the generic function must\n // be instantiated in the target crate, meaning that the native symbol must\n // also be resolved in the target crate.\n-fn add_upstream_native_libraries(cmd: &mut Linker, sess: &Session, crate_type: config::CrateType) {\n+fn add_upstream_native_libraries(cmd: &mut Linker,\n+                                 sess: &Session,\n+                                 trans: &CrateTranslation,\n+                                 crate_type: config::CrateType) {\n     // Be sure to use a topological sorting of crates because there may be\n     // interdependencies between native libraries. When passing -nodefaultlibs,\n     // for example, almost all native libraries depend on libc, so we have to\n@@ -1464,9 +1472,9 @@ fn add_upstream_native_libraries(cmd: &mut Linker, sess: &Session, crate_type: c\n     let formats = sess.dependency_formats.borrow();\n     let data = formats.get(&crate_type).unwrap();\n \n-    let crates = sess.cstore.used_crates(LinkagePreference::RequireStatic);\n-    for (cnum, _) in crates {\n-        for lib in sess.cstore.native_libraries(cnum) {\n+    let crates = &trans.crate_info.used_crates_static;\n+    for &(cnum, _) in crates {\n+        for lib in trans.crate_info.native_libraries[&cnum].iter() {\n             if !relevant_lib(sess, &lib) {\n                 continue\n             }"}, {"sha": "8e5e7d376488b7df5b69af8b100b736f6fe15a8d", "filename": "src/librustc_trans/back/rpath.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Frpath.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -17,7 +17,7 @@ use rustc::hir::def_id::CrateNum;\n use rustc::middle::cstore::LibSource;\n \n pub struct RPathConfig<'a> {\n-    pub used_crates: Vec<(CrateNum, LibSource)>,\n+    pub used_crates: &'a [(CrateNum, LibSource)],\n     pub out_filename: PathBuf,\n     pub is_like_osx: bool,\n     pub has_rpath: bool,\n@@ -36,7 +36,7 @@ pub fn get_rpath_flags(config: &mut RPathConfig) -> Vec<String> {\n     debug!(\"preparing the RPATH!\");\n \n     let libs = config.used_crates.clone();\n-    let libs = libs.into_iter().filter_map(|(_, l)| l.option()).collect::<Vec<_>>();\n+    let libs = libs.iter().filter_map(|&(_, ref l)| l.option()).collect::<Vec<_>>();\n     let rpaths = get_rpaths(config, &libs);\n     flags.extend_from_slice(&rpaths_to_flags(&rpaths));\n "}, {"sha": "b546059b4c51d1fcbdf7d96eefa0587a2038bcf7", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -110,13 +110,13 @@ impl ExportedSymbols {\n         let mut exports = FxHashMap();\n         exports.insert(LOCAL_CRATE, local_crate);\n \n-        for cnum in tcx.sess.cstore.crates() {\n+        for &cnum in tcx.crates().iter() {\n             debug_assert!(cnum != LOCAL_CRATE);\n \n             // If this crate is a plugin and/or a custom derive crate, then\n             // we're not even going to link those in so we skip those crates.\n-            if tcx.sess.cstore.plugin_registrar_fn(cnum).is_some() ||\n-               tcx.sess.cstore.derive_registrar_fn(cnum).is_some() {\n+            if tcx.plugin_registrar_fn(cnum).is_some() ||\n+               tcx.derive_registrar_fn(cnum).is_some() {\n                 continue;\n             }\n \n@@ -128,12 +128,9 @@ impl ExportedSymbols {\n             // Down below we'll hardwire all of the symbols to the `Rust` export\n             // level instead.\n             let special_runtime_crate =\n-                tcx.is_panic_runtime(cnum.as_def_id()) ||\n-                tcx.sess.cstore.is_compiler_builtins(cnum);\n+                tcx.is_panic_runtime(cnum) || tcx.is_compiler_builtins(cnum);\n \n             let crate_exports = tcx\n-                .sess\n-                .cstore\n                 .exported_symbols(cnum)\n                 .iter()\n                 .map(|&def_id| {"}, {"sha": "abeb2568cbe1eea17f1645ace755b12fa35d7055", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -242,7 +242,7 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n             return name.to_string();\n         }\n         // Don't mangle foreign items.\n-        return tcx.item_name(def_id).as_str().to_string();\n+        return tcx.item_name(def_id).to_string();\n     }\n \n     if let Some(name) = attr::find_export_name_attr(tcx.sess.diagnostic(), &attrs) {\n@@ -252,7 +252,7 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n \n     if attr::contains_name(&attrs, \"no_mangle\") {\n         // Don't mangle\n-        return tcx.item_name(def_id).as_str().to_string();\n+        return tcx.item_name(def_id).to_string();\n     }\n \n     // We want to compute the \"type\" of this item. Unfortunately, some"}, {"sha": "72e1fc34789540b7e055f4f4ae66da7ff69521ba", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -22,6 +22,7 @@ use llvm;\n use llvm::{ModuleRef, TargetMachineRef, PassManagerRef, DiagnosticInfoRef};\n use llvm::SMDiagnosticRef;\n use {CrateTranslation, ModuleSource, ModuleTranslation, CompiledModule, ModuleKind};\n+use CrateInfo;\n use rustc::hir::def_id::CrateNum;\n use rustc::util::common::{time, time_depth, set_time_depth, path2cstr, print_time_passes_entry};\n use rustc::util::fs::{link_or_copy, rename_or_copy_remove};\n@@ -675,6 +676,7 @@ pub fn start_async_translation(sess: &Session,\n                                no_builtins: bool,\n                                windows_subsystem: Option<String>,\n                                linker_info: LinkerInfo,\n+                               crate_info: CrateInfo,\n                                no_integrated_as: bool)\n                                -> OngoingCrateTranslation {\n     let output_types_override = if no_integrated_as {\n@@ -774,6 +776,7 @@ pub fn start_async_translation(sess: &Session,\n     let (coordinator_send, coordinator_receive) = channel();\n \n     let coordinator_thread = start_executing_work(sess,\n+                                                  &crate_info,\n                                                   shared_emitter,\n                                                   trans_worker_send,\n                                                   coordinator_send.clone(),\n@@ -788,6 +791,7 @@ pub fn start_async_translation(sess: &Session,\n         windows_subsystem,\n         linker_info,\n         no_integrated_as,\n+        crate_info,\n \n         regular_module_config: modules_config,\n         metadata_module_config: metadata_config,\n@@ -1101,6 +1105,7 @@ enum MainThreadWorkerState {\n }\n \n fn start_executing_work(sess: &Session,\n+                        crate_info: &CrateInfo,\n                         shared_emitter: SharedEmitter,\n                         trans_worker_send: Sender<Message>,\n                         coordinator_send: Sender<Message>,\n@@ -1125,8 +1130,8 @@ fn start_executing_work(sess: &Session,\n     }).expect(\"failed to spawn helper thread\");\n \n     let mut each_linked_rlib_for_lto = Vec::new();\n-    drop(link::each_linked_rlib(sess, &mut |cnum, path| {\n-        if link::ignored_for_lto(sess, cnum) {\n+    drop(link::each_linked_rlib(sess, crate_info, &mut |cnum, path| {\n+        if link::ignored_for_lto(crate_info, cnum) {\n             return\n         }\n         each_linked_rlib_for_lto.push((cnum, path.to_path_buf()));\n@@ -1802,6 +1807,7 @@ pub struct OngoingCrateTranslation {\n     windows_subsystem: Option<String>,\n     linker_info: LinkerInfo,\n     no_integrated_as: bool,\n+    crate_info: CrateInfo,\n \n     output_filenames: OutputFilenames,\n     regular_module_config: ModuleConfig,\n@@ -1850,6 +1856,7 @@ impl OngoingCrateTranslation {\n             metadata: self.metadata,\n             windows_subsystem: self.windows_subsystem,\n             linker_info: self.linker_info,\n+            crate_info: self.crate_info,\n \n             modules: compiled_modules.modules,\n             allocator_module: compiled_modules.allocator_module,"}, {"sha": "6cfde9c7bbc7382db30f3852198eba31ad558d90", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 49, "deletions": 2, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -41,7 +41,7 @@ use rustc::middle::lang_items::StartFnLangItem;\n use rustc::middle::cstore::{EncodedMetadata, EncodedMetadataHashes};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::dep_graph::AssertDepGraphSafe;\n-use rustc::middle::cstore::LinkMeta;\n+use rustc::middle::cstore::{self, LinkMeta, LinkagePreference};\n use rustc::hir::map as hir_map;\n use rustc::util::common::{time, print_time_passes_entry};\n use rustc::session::config::{self, NoDebugInfo, OutputFilenames, OutputType};\n@@ -75,6 +75,7 @@ use type_::Type;\n use type_of;\n use value::Value;\n use rustc::util::nodemap::{NodeSet, FxHashMap, FxHashSet};\n+use CrateInfo;\n \n use libc::c_uint;\n use std::ffi::{CStr, CString};\n@@ -904,7 +905,7 @@ pub fn find_exported_symbols(tcx: TyCtxt, reachable: &NodeSet) -> NodeSet {\n         match tcx.hir.get(id) {\n             hir_map::NodeForeignItem(..) => {\n                 let def_id = tcx.hir.local_def_id(id);\n-                tcx.sess.cstore.is_statically_included_foreign_item(def_id)\n+                tcx.is_statically_included_foreign_item(def_id)\n             }\n \n             // Only consider nodes that actually have exported symbols.\n@@ -970,6 +971,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     } else {\n         None\n     };\n+    let crate_info = CrateInfo::new(tcx);\n \n     // Skip crate items and just output metadata in -Z no-trans mode.\n     if tcx.sess.opts.debugging_opts.no_trans ||\n@@ -987,6 +989,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             no_builtins,\n             None,\n             linker_info,\n+            crate_info,\n             false);\n \n         ongoing_translation.submit_pre_translated_module_to_llvm(tcx.sess, metadata_module, true);\n@@ -1039,6 +1042,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         no_builtins,\n         windows_subsystem,\n         linker_info,\n+        crate_info,\n         no_integrated_as);\n \n     // Translate an allocator shim, if any\n@@ -1502,3 +1506,46 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n \n     (translation_items, codegen_units)\n }\n+\n+impl CrateInfo {\n+    pub fn new<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CrateInfo {\n+        let mut info = CrateInfo {\n+            panic_runtime: None,\n+            compiler_builtins: None,\n+            profiler_runtime: None,\n+            sanitizer_runtime: None,\n+            is_no_builtins: FxHashSet(),\n+            native_libraries: FxHashMap(),\n+            used_libraries: tcx.native_libraries(LOCAL_CRATE),\n+            link_args: tcx.link_args(LOCAL_CRATE),\n+            crate_name: FxHashMap(),\n+            used_crates_dynamic: cstore::used_crates(tcx, LinkagePreference::RequireDynamic),\n+            used_crates_static: cstore::used_crates(tcx, LinkagePreference::RequireStatic),\n+            used_crate_source: FxHashMap(),\n+        };\n+\n+        for &cnum in tcx.crates().iter() {\n+            info.native_libraries.insert(cnum, tcx.native_libraries(cnum));\n+            info.crate_name.insert(cnum, tcx.crate_name(cnum).to_string());\n+            info.used_crate_source.insert(cnum, tcx.used_crate_source(cnum));\n+            if tcx.is_panic_runtime(cnum) {\n+                info.panic_runtime = Some(cnum);\n+            }\n+            if tcx.is_compiler_builtins(cnum) {\n+                info.compiler_builtins = Some(cnum);\n+            }\n+            if tcx.is_profiler_runtime(cnum) {\n+                info.profiler_runtime = Some(cnum);\n+            }\n+            if tcx.is_sanitizer_runtime(cnum) {\n+                info.sanitizer_runtime = Some(cnum);\n+            }\n+            if tcx.is_no_builtins(cnum) {\n+                info.is_no_builtins.insert(cnum);\n+            }\n+        }\n+\n+\n+        return info\n+    }\n+}"}, {"sha": "246eb49ffa674ee0a33b8cd380b4f362844d4dd4", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -124,13 +124,17 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             }\n         }\n \n-        if ccx.use_dll_storage_attrs() &&\n-            ccx.sess().cstore.is_dllimport_foreign_item(instance_def_id)\n-        {\n-            unsafe {\n-                llvm::LLVMSetDLLStorageClass(llfn, llvm::DLLStorageClass::DllImport);\n+        // FIXME(#42293) we should actually track this, but fails too many tests\n+        // today.\n+        tcx.dep_graph.with_ignore(|| {\n+            if ccx.use_dll_storage_attrs() &&\n+                tcx.is_dllimport_foreign_item(instance_def_id)\n+            {\n+                unsafe {\n+                    llvm::LLVMSetDLLStorageClass(llfn, llvm::DLLStorageClass::DllImport);\n+                }\n             }\n-        }\n+        });\n         llfn\n     };\n "}, {"sha": "b56fa34e348e5f7f8b3abd140e1c7a6c444c2987", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -432,7 +432,7 @@ fn check_recursion_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let recursion_depth = recursion_depths.get(&def_id).cloned().unwrap_or(0);\n     debug!(\" => recursion depth={}\", recursion_depth);\n \n-    let recursion_depth = if Some(def_id) == tcx.lang_items.drop_in_place_fn() {\n+    let recursion_depth = if Some(def_id) == tcx.lang_items().drop_in_place_fn() {\n         // HACK: drop_in_place creates tight monomorphization loops. Give\n         // it more margin.\n         recursion_depth / 4\n@@ -550,7 +550,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             mir::Rvalue::NullaryOp(mir::NullOp::Box, _) => {\n                 let tcx = self.scx.tcx();\n                 let exchange_malloc_fn_def_id = tcx\n-                    .lang_items\n+                    .lang_items()\n                     .require(ExchangeMallocFnLangItem)\n                     .unwrap_or_else(|e| self.scx.sess().fatal(&e));\n                 let instance = Instance::mono(tcx, exchange_malloc_fn_def_id);"}, {"sha": "d947cd8e71974a57789b8005912e623290bc6a4f", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -423,7 +423,7 @@ pub fn langcall(tcx: TyCtxt,\n                 msg: &str,\n                 li: LangItem)\n                 -> DefId {\n-    match tcx.lang_items.require(li) {\n+    match tcx.lang_items().require(li) {\n         Ok(id) => id,\n         Err(s) => {\n             let msg = format!(\"{} {}\", msg, s);\n@@ -530,7 +530,7 @@ pub fn ty_fn_sig<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             let env_ty = tcx.mk_mut_ref(tcx.mk_region(env_region), ty);\n \n             sig.map_bound(|sig| {\n-                let state_did = tcx.lang_items.gen_state().unwrap();\n+                let state_did = tcx.lang_items().gen_state().unwrap();\n                 let state_adt_ref = tcx.adt_def(state_did);\n                 let state_substs = tcx.mk_substs([Kind::from(sig.yield_ty),\n                     Kind::from(sig.return_ty)].iter());"}, {"sha": "a30a15f75b3afc13e742806c13e4e42969947ce6", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -211,12 +211,17 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n         g\n     };\n \n-    if ccx.use_dll_storage_attrs() && ccx.sess().cstore.is_dllimport_foreign_item(def_id) {\n-        // For foreign (native) libs we know the exact storage type to use.\n-        unsafe {\n-            llvm::LLVMSetDLLStorageClass(g, llvm::DLLStorageClass::DllImport);\n+\n+    // FIXME(#42293) we should actually track this, but fails too many tests\n+    // today.\n+    ccx.tcx().dep_graph.with_ignore(|| {\n+        if ccx.use_dll_storage_attrs() && ccx.tcx().is_dllimport_foreign_item(def_id) {\n+            // For foreign (native) libs we know the exact storage type to use.\n+            unsafe {\n+                llvm::LLVMSetDLLStorageClass(g, llvm::DLLStorageClass::DllImport);\n+            }\n         }\n-    }\n+    });\n     ccx.instances().borrow_mut().insert(instance, g);\n     ccx.statics().borrow_mut().insert(g, def_id);\n     g"}, {"sha": "a5830eb17edb14c95e007c7cd06361ec3e3c6c88", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -616,7 +616,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n             return llpersonality\n         }\n         let tcx = self.tcx();\n-        let llfn = match tcx.lang_items.eh_personality() {\n+        let llfn = match tcx.lang_items().eh_personality() {\n             Some(def_id) if !base::wants_msvc_seh(self.sess()) => {\n                 callee::resolve_and_get_fn(self, def_id, tcx.intern_substs(&[]))\n             }\n@@ -645,7 +645,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n \n         let tcx = self.tcx();\n         assert!(self.sess().target.target.options.custom_unwind_resume);\n-        if let Some(def_id) = tcx.lang_items.eh_unwind_resume() {\n+        if let Some(def_id) = tcx.lang_items().eh_unwind_resume() {\n             let llfn = callee::resolve_and_get_fn(self, def_id, tcx.intern_substs(&[]));\n             unwresume.set(Some(llfn));\n             return llfn;"}, {"sha": "8bd835ac5d114564f1f53b3c572e9a27ed653e08", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -1612,7 +1612,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     fn get_enum_discriminant_name(cx: &CrateContext,\n                                   def_id: DefId)\n                                   -> InternedString {\n-        cx.tcx().item_name(def_id).as_str()\n+        cx.tcx().item_name(def_id)\n     }\n }\n "}, {"sha": "6eda86575193371c4baf04f53212eb1a8dc74450", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -189,7 +189,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 output.push_str(&path_element.data.as_interned_str());\n             }\n         } else {\n-            output.push_str(&cx.tcx().item_name(def_id).as_str());\n+            output.push_str(&cx.tcx().item_name(def_id));\n         }\n     }\n "}, {"sha": "8f968a8a6c60977779d028fcc726d2d16741b4a9", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -104,7 +104,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n     let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n     let arg_tys = sig.inputs();\n     let ret_ty = sig.output();\n-    let name = &*tcx.item_name(def_id).as_str();\n+    let name = &*tcx.item_name(def_id);\n \n     let llret_ty = type_of::type_of(ccx, ret_ty);\n \n@@ -822,7 +822,7 @@ fn trans_msvc_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         catchswitch.add_handler(cs, catchpad.llbb());\n \n         let tcx = ccx.tcx();\n-        let tydesc = match tcx.lang_items.msvc_try_filter() {\n+        let tydesc = match tcx.lang_items().msvc_try_filter() {\n             Some(did) => ::consts::get_static(ccx, did),\n             None => bug!(\"msvc_try_filter not defined\"),\n         };"}, {"sha": "63fd37c2b98bf62816b9f61cf23cca78b02937f8", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -66,6 +66,12 @@ pub use back::symbol_names::provide;\n pub use metadata::LlvmMetadataLoader;\n pub use llvm_util::{init, target_features, print_version, print_passes, print, enable_llvm_debug};\n \n+use std::rc::Rc;\n+\n+use rustc::hir::def_id::CrateNum;\n+use rustc::util::nodemap::{FxHashSet, FxHashMap};\n+use rustc::middle::cstore::{NativeLibrary, CrateSource, LibSource};\n+\n pub mod back {\n     mod archive;\n     mod command;\n@@ -217,7 +223,24 @@ pub struct CrateTranslation {\n     pub link: rustc::middle::cstore::LinkMeta,\n     pub metadata: rustc::middle::cstore::EncodedMetadata,\n     windows_subsystem: Option<String>,\n-    linker_info: back::linker::LinkerInfo\n+    linker_info: back::linker::LinkerInfo,\n+    crate_info: CrateInfo,\n+}\n+\n+// Misc info we load from metadata to persist beyond the tcx\n+pub struct CrateInfo {\n+    panic_runtime: Option<CrateNum>,\n+    compiler_builtins: Option<CrateNum>,\n+    profiler_runtime: Option<CrateNum>,\n+    sanitizer_runtime: Option<CrateNum>,\n+    is_no_builtins: FxHashSet<CrateNum>,\n+    native_libraries: FxHashMap<CrateNum, Rc<Vec<NativeLibrary>>>,\n+    crate_name: FxHashMap<CrateNum, String>,\n+    used_libraries: Rc<Vec<NativeLibrary>>,\n+    link_args: Rc<Vec<String>>,\n+    used_crate_source: FxHashMap<CrateNum, Rc<CrateSource>>,\n+    used_crates_static: Vec<(CrateNum, LibSource)>,\n+    used_crates_dynamic: Vec<(CrateNum, LibSource)>,\n }\n \n __build_diagnostic_array! { librustc_trans, DIAGNOSTICS }"}, {"sha": "949b9fe71ca64eb7c37b90175d6e379eb6c80cd7", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -114,7 +114,7 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n                     }, ..\n                 }),\n                 ref args, ..\n-            } if Some(def_id) == self.cx.ccx.tcx().lang_items.box_free_fn() => {\n+            } if Some(def_id) == self.cx.ccx.tcx().lang_items().box_free_fn() => {\n                 // box_free(x) shares with `drop x` the property that it\n                 // is not guaranteed to be statically dominated by the\n                 // definition of x, so x must always be in an alloca."}, {"sha": "0f42a244a1ff906ef4e6a543c66eb5b6ef612f6a", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -445,7 +445,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 // Handle intrinsics old trans wants Expr's for, ourselves.\n                 let intrinsic = match def {\n                     Some(ty::InstanceDef::Intrinsic(def_id))\n-                        => Some(bcx.tcx().item_name(def_id).as_str()),\n+                        => Some(bcx.tcx().item_name(def_id)),\n                     _ => None\n                 };\n                 let intrinsic = intrinsic.as_ref().map(|s| &s[..]);"}, {"sha": "1109f34a1482e16a834a5f3ad1b6aaedc98ecfd5", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -365,7 +365,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     }\n                     if let Some((ref dest, target)) = *destination {\n                         let result = if fn_ty.fn_sig(tcx).abi() == Abi::RustIntrinsic {\n-                            match &tcx.item_name(def_id).as_str()[..] {\n+                            match &tcx.item_name(def_id)[..] {\n                                 \"size_of\" => {\n                                     let llval = C_uint(self.ccx,\n                                         self.ccx.size_of(substs.type_at(0)));\n@@ -610,7 +610,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         match operand.ty.sty {\n                             ty::TyClosure(def_id, substs) => {\n                                 // Get the def_id for FnOnce::call_once\n-                                let fn_once = tcx.lang_items.fn_once_trait().unwrap();\n+                                let fn_once = tcx.lang_items().fn_once_trait().unwrap();\n                                 let call_once = tcx\n                                     .global_tcx().associated_items(fn_once)\n                                     .find(|it| it.kind == ty::AssociatedKind::Method)"}, {"sha": "34dec57543a2b467d1800761cea56a926509fafc", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -482,7 +482,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let box_ty = bcx.tcx().mk_box(content_ty);\n \n                 // Allocate space:\n-                let def_id = match bcx.tcx().lang_items.require(ExchangeMallocFnLangItem) {\n+                let def_id = match bcx.tcx().lang_items().require(ExchangeMallocFnLangItem) {\n                     Ok(id) => id,\n                     Err(s) => {\n                         bcx.sess().fatal(&format!(\"allocation of `{}` {}\", box_ty, s));"}, {"sha": "9a7f1524d209f7b0b16e82c159f1197395577acb", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -31,7 +31,7 @@ fn fn_once_adapter_instance<'a, 'tcx>(\n     debug!(\"fn_once_adapter_shim({:?}, {:?})\",\n            closure_did,\n            substs);\n-    let fn_once = tcx.lang_items.fn_once_trait().unwrap();\n+    let fn_once = tcx.lang_items().fn_once_trait().unwrap();\n     let call_once = tcx.associated_items(fn_once)\n         .find(|it| it.kind == ty::AssociatedKind::Method)\n         .unwrap().def_id;\n@@ -132,7 +132,7 @@ fn resolve_associated_item<'a, 'tcx>(\n             }\n         }\n         traits::VtableClosure(closure_data) => {\n-            let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n+            let trait_closure_kind = tcx.lang_items().fn_trait_kind(trait_id).unwrap();\n             resolve_closure(scx, closure_data.closure_def_id, closure_data.substs,\n                             trait_closure_kind)\n         }\n@@ -149,7 +149,7 @@ fn resolve_associated_item<'a, 'tcx>(\n                 substs: rcvr_substs\n             }\n         }\n-        traits::VtableBuiltin(..) if Some(trait_id) == tcx.lang_items.clone_trait() => {\n+        traits::VtableBuiltin(..) if Some(trait_id) == tcx.lang_items().clone_trait() => {\n             Instance {\n                 def: ty::InstanceDef::CloneShim(def_id, trait_ref.self_ty()),\n                 substs: rcvr_substs\n@@ -187,7 +187,7 @@ pub fn resolve<'a, 'tcx>(\n                 ty::InstanceDef::Intrinsic(def_id)\n             }\n             _ => {\n-                if Some(def_id) == scx.tcx().lang_items.drop_in_place_fn() {\n+                if Some(def_id) == scx.tcx().lang_items().drop_in_place_fn() {\n                     let ty = substs.type_at(0);\n                     if glue::needs_drop_glue(scx, ty) {\n                         debug!(\" => nontrivial drop glue\");\n@@ -224,7 +224,7 @@ pub fn custom_coerce_unsize_info<'scx, 'tcx>(scx: &SharedCrateContext<'scx, 'tcx\n                                              target_ty: Ty<'tcx>)\n                                              -> CustomCoerceUnsized {\n     let trait_ref = ty::Binder(ty::TraitRef {\n-        def_id: scx.tcx().lang_items.coerce_unsized_trait().unwrap(),\n+        def_id: scx.tcx().lang_items().coerce_unsized_trait().unwrap(),\n         substs: scx.tcx().mk_substs_trait(source_ty, &[target_ty])\n     });\n "}, {"sha": "2583d18652dc5dee818e174178bb75f609120034", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -96,22 +96,23 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         -> ty::Region<'tcx>\n     {\n         let tcx = self.tcx();\n-        let r = match tcx.named_region_map.defs.get(&lifetime.id) {\n-            Some(&rl::Region::Static) => {\n+        let hir_id = tcx.hir.node_to_hir_id(lifetime.id);\n+        let r = match tcx.named_region(hir_id) {\n+            Some(rl::Region::Static) => {\n                 tcx.types.re_static\n             }\n \n-            Some(&rl::Region::LateBound(debruijn, id)) => {\n+            Some(rl::Region::LateBound(debruijn, id)) => {\n                 let name = tcx.hir.name(id);\n                 tcx.mk_region(ty::ReLateBound(debruijn,\n                     ty::BrNamed(tcx.hir.local_def_id(id), name)))\n             }\n \n-            Some(&rl::Region::LateBoundAnon(debruijn, index)) => {\n+            Some(rl::Region::LateBoundAnon(debruijn, index)) => {\n                 tcx.mk_region(ty::ReLateBound(debruijn, ty::BrAnon(index)))\n             }\n \n-            Some(&rl::Region::EarlyBound(index, id)) => {\n+            Some(rl::Region::EarlyBound(index, id)) => {\n                 let name = tcx.hir.name(id);\n                 tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n                     def_id: tcx.hir.local_def_id(id),\n@@ -120,7 +121,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 }))\n             }\n \n-            Some(&rl::Region::Free(scope, id)) => {\n+            Some(rl::Region::Free(scope, id)) => {\n                 let name = tcx.hir.name(id);\n                 tcx.mk_region(ty::ReFree(ty::FreeRegion {\n                     scope,\n@@ -627,7 +628,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             self.ast_region_to_region(lifetime, None)\n         } else {\n             self.compute_object_lifetime_bound(span, existential_predicates).unwrap_or_else(|| {\n-                if tcx.named_region_map.defs.contains_key(&lifetime.id) {\n+                let hir_id = tcx.hir.node_to_hir_id(lifetime.id);\n+                if tcx.named_region(hir_id).is_some() {\n                     self.ast_region_to_region(lifetime, None)\n                 } else {\n                     self.re_infer(span, None).unwrap_or_else(|| {\n@@ -1286,8 +1288,8 @@ fn split_auto_traits<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n             Def::Trait(trait_did) => {\n                 // Checks whether `trait_did` refers to one of the builtin\n                 // traits, like `Send`, and adds it to `auto_traits` if so.\n-                if Some(trait_did) == tcx.lang_items.send_trait() ||\n-                    Some(trait_did) == tcx.lang_items.sync_trait() {\n+                if Some(trait_did) == tcx.lang_items().send_trait() ||\n+                    Some(trait_did) == tcx.lang_items().sync_trait() {\n                     let segments = &bound.trait_ref.path.segments;\n                     let parameters = &segments[segments.len() - 1].parameters;\n                     if !parameters.types.is_empty() {\n@@ -1400,7 +1402,7 @@ impl<'a, 'gcx, 'tcx> Bounds<'tcx> {\n \n         // If it could be sized, and is, add the sized predicate\n         if self.implicitly_sized {\n-            if let Some(sized) = tcx.lang_items.sized_trait() {\n+            if let Some(sized) = tcx.lang_items().sized_trait() {\n                 let trait_ref = ty::TraitRef {\n                     def_id: sized,\n                     substs: tcx.mk_substs_trait(param_ty, &[])"}, {"sha": "a25deb7685af5902d7722ba4158fd9fc150f664c", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -108,7 +108,7 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n \n         // <cur_ty as Deref>\n         let trait_ref = TraitRef {\n-            def_id: match tcx.lang_items.deref_trait() {\n+            def_id: match tcx.lang_items().deref_trait() {\n                 Some(f) => f,\n                 None => return None,\n             },"}, {"sha": "866949220b5dfba64c3265a415b41018a523003e", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -28,7 +28,7 @@ use rustc::hir;\n /// to `trait_id` (this only cares about the trait, not the specific\n /// method that is called)\n pub fn check_legal_trait_for_method_call(tcx: TyCtxt, span: Span, trait_id: DefId) {\n-    if tcx.lang_items.drop_trait() == Some(trait_id) {\n+    if tcx.lang_items().drop_trait() == Some(trait_id) {\n         struct_span_err!(tcx.sess, span, E0040, \"explicit use of destructor method\")\n             .span_label(span, \"explicit destructor calls not allowed\")\n             .emit();\n@@ -157,9 +157,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                              MethodCallee<'tcx>)> {\n         // Try the options that are least restrictive on the caller first.\n         for &(opt_trait_def_id, method_name, borrow) in\n-            &[(self.tcx.lang_items.fn_trait(), Symbol::intern(\"call\"), true),\n-              (self.tcx.lang_items.fn_mut_trait(), Symbol::intern(\"call_mut\"), true),\n-              (self.tcx.lang_items.fn_once_trait(), Symbol::intern(\"call_once\"), false)] {\n+            &[(self.tcx.lang_items().fn_trait(), Symbol::intern(\"call\"), true),\n+              (self.tcx.lang_items().fn_mut_trait(), Symbol::intern(\"call_mut\"), true),\n+              (self.tcx.lang_items().fn_once_trait(), Symbol::intern(\"call_once\"), false)] {\n             let trait_def_id = match opt_trait_def_id {\n                 Some(def_id) => def_id,\n                 None => continue,"}, {"sha": "aa2b9c1e0381534240adce13ae3e840c3e97d310", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -139,7 +139,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     })\n                     .next();\n                 let kind = object_type.principal()\n-                    .and_then(|p| self.tcx.lang_items.fn_trait_kind(p.def_id()));\n+                    .and_then(|p| self.tcx.lang_items().fn_trait_kind(p.def_id()));\n                 (sig, kind)\n             }\n             ty::TyInfer(ty::TyVar(vid)) => self.deduce_expectations_from_obligations(vid),\n@@ -204,7 +204,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     ty::Predicate::ClosureKind(..) => None,\n                 };\n                 opt_trait_ref.and_then(|tr| self.self_type_matches_expected_vid(tr, expected_vid))\n-                    .and_then(|tr| self.tcx.lang_items.fn_trait_kind(tr.def_id()))\n+                    .and_then(|tr| self.tcx.lang_items().fn_trait_kind(tr.def_id()))\n             })\n             .fold(None,\n                   |best, cur| Some(best.map_or(cur, |best| cmp::min(best, cur))));\n@@ -223,7 +223,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let trait_ref = projection.to_poly_trait_ref(tcx);\n \n-        if tcx.lang_items.fn_trait_kind(trait_ref.def_id()).is_none() {\n+        if tcx.lang_items().fn_trait_kind(trait_ref.def_id()).is_none() {\n             return None;\n         }\n "}, {"sha": "cfcdbcc11959bdba6664f2a9f7d12d4135f6cf34", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -438,8 +438,8 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n     fn coerce_unsized(&self, source: Ty<'tcx>, target: Ty<'tcx>) -> CoerceResult<'tcx> {\n         debug!(\"coerce_unsized(source={:?}, target={:?})\", source, target);\n \n-        let traits = (self.tcx.lang_items.unsize_trait(),\n-                      self.tcx.lang_items.coerce_unsized_trait());\n+        let traits = (self.tcx.lang_items().unsize_trait(),\n+                      self.tcx.lang_items().coerce_unsized_trait());\n         let (unsize_did, coerce_unsized_did) = if let (Some(u), Some(cu)) = traits {\n             (u, cu)\n         } else {"}, {"sha": "852134bbee3154e516d59a08a0b37259a2fec744", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -540,7 +540,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     fn predicates_require_illegal_sized_bound(&self,\n                                               predicates: &ty::InstantiatedPredicates<'tcx>)\n                                               -> bool {\n-        let sized_def_id = match self.tcx.lang_items.sized_trait() {\n+        let sized_def_id = match self.tcx.lang_items().sized_trait() {\n             Some(def_id) => def_id,\n             None => return false,\n         };"}, {"sha": "3771d330f6dd39a025a9f6b57643cad1b3251961", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -393,6 +393,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     fn assemble_probe(&mut self, self_ty: Ty<'tcx>) {\n         debug!(\"assemble_probe: self_ty={:?}\", self_ty);\n+        let lang_items = self.tcx.lang_items();\n \n         match self_ty.sty {\n             ty::TyDynamic(ref data, ..) => {\n@@ -408,79 +409,79 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 self.assemble_inherent_candidates_from_param(self_ty, p);\n             }\n             ty::TyChar => {\n-                let lang_def_id = self.tcx.lang_items.char_impl();\n+                let lang_def_id = lang_items.char_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyStr => {\n-                let lang_def_id = self.tcx.lang_items.str_impl();\n+                let lang_def_id = lang_items.str_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TySlice(_) => {\n-                let lang_def_id = self.tcx.lang_items.slice_impl();\n+                let lang_def_id = lang_items.slice_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n-                let lang_def_id = self.tcx.lang_items.const_ptr_impl();\n+                let lang_def_id = lang_items.const_ptr_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n-                let lang_def_id = self.tcx.lang_items.mut_ptr_impl();\n+                let lang_def_id = lang_items.mut_ptr_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyInt(ast::IntTy::I8) => {\n-                let lang_def_id = self.tcx.lang_items.i8_impl();\n+                let lang_def_id = lang_items.i8_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyInt(ast::IntTy::I16) => {\n-                let lang_def_id = self.tcx.lang_items.i16_impl();\n+                let lang_def_id = lang_items.i16_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyInt(ast::IntTy::I32) => {\n-                let lang_def_id = self.tcx.lang_items.i32_impl();\n+                let lang_def_id = lang_items.i32_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyInt(ast::IntTy::I64) => {\n-                let lang_def_id = self.tcx.lang_items.i64_impl();\n+                let lang_def_id = lang_items.i64_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyInt(ast::IntTy::I128) => {\n-                let lang_def_id = self.tcx.lang_items.i128_impl();\n+                let lang_def_id = lang_items.i128_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyInt(ast::IntTy::Is) => {\n-                let lang_def_id = self.tcx.lang_items.isize_impl();\n+                let lang_def_id = lang_items.isize_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyUint(ast::UintTy::U8) => {\n-                let lang_def_id = self.tcx.lang_items.u8_impl();\n+                let lang_def_id = lang_items.u8_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyUint(ast::UintTy::U16) => {\n-                let lang_def_id = self.tcx.lang_items.u16_impl();\n+                let lang_def_id = lang_items.u16_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyUint(ast::UintTy::U32) => {\n-                let lang_def_id = self.tcx.lang_items.u32_impl();\n+                let lang_def_id = lang_items.u32_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyUint(ast::UintTy::U64) => {\n-                let lang_def_id = self.tcx.lang_items.u64_impl();\n+                let lang_def_id = lang_items.u64_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyUint(ast::UintTy::U128) => {\n-                let lang_def_id = self.tcx.lang_items.u128_impl();\n+                let lang_def_id = lang_items.u128_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyUint(ast::UintTy::Us) => {\n-                let lang_def_id = self.tcx.lang_items.usize_impl();\n+                let lang_def_id = lang_items.usize_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyFloat(ast::FloatTy::F32) => {\n-                let lang_def_id = self.tcx.lang_items.f32_impl();\n+                let lang_def_id = lang_items.f32_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyFloat(ast::FloatTy::F64) => {\n-                let lang_def_id = self.tcx.lang_items.f64_impl();\n+                let lang_def_id = lang_items.f64_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             _ => {}"}, {"sha": "7fa3dd7472db804dbf623914a610d439d943a13b", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -45,7 +45,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             ty::TyFnPtr(_) => true,\n             // If it's not a simple function, look for things which implement FnOnce\n             _ => {\n-                let fn_once = match tcx.lang_items.require(FnOnceTraitLangItem) {\n+                let fn_once = match tcx.lang_items().require(FnOnceTraitLangItem) {\n                     Ok(fn_once) => fn_once,\n                     Err(..) => return false,\n                 };\n@@ -552,14 +552,14 @@ pub fn all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> AllTraits<'a>\n                     if !external_mods.insert(def_id) {\n                         return;\n                     }\n-                    for child in tcx.sess.cstore.item_children(def_id, tcx.sess) {\n+                    for child in tcx.item_children(def_id).iter() {\n                         handle_external_def(tcx, traits, external_mods, child.def)\n                     }\n                 }\n                 _ => {}\n             }\n         }\n-        for cnum in tcx.sess.cstore.crates() {\n+        for &cnum in tcx.crates().iter() {\n             let def_id = DefId {\n                 krate: cnum,\n                 index: CRATE_DEF_INDEX,"}, {"sha": "0a8d2129a890d2331f0c65edde3044e9f7b3cd0a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -2296,13 +2296,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn resolve_lvalue_op(&self, op: LvalueOp, is_mut: bool) -> (Option<DefId>, Symbol) {\n         let (tr, name) = match (op, is_mut) {\n             (LvalueOp::Deref, false) =>\n-                (self.tcx.lang_items.deref_trait(), \"deref\"),\n+                (self.tcx.lang_items().deref_trait(), \"deref\"),\n             (LvalueOp::Deref, true) =>\n-                (self.tcx.lang_items.deref_mut_trait(), \"deref_mut\"),\n+                (self.tcx.lang_items().deref_mut_trait(), \"deref_mut\"),\n             (LvalueOp::Index, false) =>\n-                (self.tcx.lang_items.index_trait(), \"index\"),\n+                (self.tcx.lang_items().index_trait(), \"index\"),\n             (LvalueOp::Index, true) =>\n-                (self.tcx.lang_items.index_mut_trait(), \"index_mut\"),\n+                (self.tcx.lang_items().index_mut_trait(), \"index_mut\"),\n         };\n         (tr, Symbol::intern(name))\n     }"}, {"sha": "a3dd81fdddee33d78a664faa7786ce3e749648b4", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -362,7 +362,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn lookup_op_method(&self, lhs_ty: Ty<'tcx>, other_tys: &[Ty<'tcx>], op: Op)\n                         -> Result<MethodCallee<'tcx>, ()>\n     {\n-        let lang = &self.tcx.lang_items;\n+        let lang = self.tcx.lang_items();\n \n         let span = match op {\n             Op::Binary(op, _) => op.span,"}, {"sha": "9c19aef5992e698bd324f5e56199200eacee4de3", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -539,7 +539,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n     {\n         let mut err = error_392(self.tcx, span, param_name);\n \n-        let suggested_marker_id = self.tcx.lang_items.phantom_data();\n+        let suggested_marker_id = self.tcx.lang_items().phantom_data();\n         match suggested_marker_id {\n             Some(def_id) => {\n                 err.help("}, {"sha": "93f15775b15606b00052cd0572981391281e30dd", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -14,8 +14,9 @@ use rustc::ty::TyCtxt;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n \n-use rustc::hir;\n+use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::hir;\n use rustc::util::nodemap::DefIdSet;\n \n struct CheckVisitor<'a, 'tcx: 'a> {\n@@ -25,7 +26,8 @@ struct CheckVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> CheckVisitor<'a, 'tcx> {\n     fn check_import(&self, id: ast::NodeId, span: Span) {\n-        if !self.tcx.maybe_unused_trait_imports.contains(&id) {\n+        let hir_id = self.tcx.hir.node_to_hir_id(id);\n+        if !self.tcx.maybe_unused_trait_import(hir_id) {\n             return;\n         }\n \n@@ -73,14 +75,20 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut visitor = CheckVisitor { tcx, used_trait_imports };\n     tcx.hir.krate().visit_all_item_likes(&mut visitor);\n \n-    for &(id, span) in &tcx.maybe_unused_extern_crates {\n-        let cnum = tcx.sess.cstore.extern_mod_stmt_cnum(id).unwrap().as_def_id();\n-        if !tcx.is_compiler_builtins(cnum)\n-            && !tcx.is_panic_runtime(cnum)\n-            && !tcx.has_global_allocator(cnum) {\n-                let lint = lint::builtin::UNUSED_EXTERN_CRATES;\n-                let msg = \"unused extern crate\";\n-                tcx.lint_node(lint, id, span, msg);\n-            }\n+    for &(hir_id, span) in tcx.maybe_unused_extern_crates(LOCAL_CRATE).iter() {\n+        let cnum = tcx.extern_mod_stmt_cnum(hir_id).unwrap();\n+        if tcx.is_compiler_builtins(cnum) {\n+            continue\n+        }\n+        if tcx.is_panic_runtime(cnum) {\n+            continue\n+        }\n+        if tcx.has_global_allocator(cnum) {\n+            continue\n+        }\n+        let id = tcx.hir.definitions().find_node_for_hir_id(hir_id);\n+        let lint = lint::builtin::UNUSED_EXTERN_CRATES;\n+        let msg = \"unused extern crate\";\n+        tcx.lint_node(lint, id, span, msg);\n     }\n }"}, {"sha": "fedfa51d61d115efde45a784e9a5e6c73e55e233", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -28,9 +28,9 @@ use rustc::hir::{self, ItemImpl};\n \n pub fn check_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_def_id: DefId) {\n     Checker { tcx, trait_def_id }\n-        .check(tcx.lang_items.drop_trait(), visit_implementation_of_drop)\n-        .check(tcx.lang_items.copy_trait(), visit_implementation_of_copy)\n-        .check(tcx.lang_items.coerce_unsized_trait(),\n+        .check(tcx.lang_items().drop_trait(), visit_implementation_of_drop)\n+        .check(tcx.lang_items().copy_trait(), visit_implementation_of_copy)\n+        .check(tcx.lang_items().coerce_unsized_trait(),\n                visit_implementation_of_coerce_unsized);\n }\n \n@@ -176,9 +176,9 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      impl_did: DefId)\n                                      -> CoerceUnsizedInfo {\n     debug!(\"compute_coerce_unsized_info(impl_did={:?})\", impl_did);\n-    let coerce_unsized_trait = tcx.lang_items.coerce_unsized_trait().unwrap();\n+    let coerce_unsized_trait = tcx.lang_items().coerce_unsized_trait().unwrap();\n \n-    let unsize_trait = match tcx.lang_items.require(UnsizeTraitLangItem) {\n+    let unsize_trait = match tcx.lang_items().require(UnsizeTraitLangItem) {\n         Ok(id) => id,\n         Err(err) => {\n             tcx.sess.fatal(&format!(\"`CoerceUnsized` implementation {}\", err));"}, {"sha": "15e15abfb3606d4c5fcf1da5e2589dbc209626b2", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -112,6 +112,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n \n         let def_id = self.tcx.hir.local_def_id(item.id);\n         let self_ty = self.tcx.type_of(def_id);\n+        let lang_items = self.tcx.lang_items();\n         match self_ty.sty {\n             ty::TyAdt(def, _) => {\n                 self.check_def_id(item, def.did);\n@@ -121,133 +122,133 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n             }\n             ty::TyChar => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.char_impl(),\n+                                          lang_items.char_impl(),\n                                           \"char\",\n                                           \"char\",\n                                           item.span);\n             }\n             ty::TyStr => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.str_impl(),\n+                                          lang_items.str_impl(),\n                                           \"str\",\n                                           \"str\",\n                                           item.span);\n             }\n             ty::TySlice(_) => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.slice_impl(),\n+                                          lang_items.slice_impl(),\n                                           \"slice\",\n                                           \"[T]\",\n                                           item.span);\n             }\n             ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.const_ptr_impl(),\n+                                          lang_items.const_ptr_impl(),\n                                           \"const_ptr\",\n                                           \"*const T\",\n                                           item.span);\n             }\n             ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.mut_ptr_impl(),\n+                                          lang_items.mut_ptr_impl(),\n                                           \"mut_ptr\",\n                                           \"*mut T\",\n                                           item.span);\n             }\n             ty::TyInt(ast::IntTy::I8) => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.i8_impl(),\n+                                          lang_items.i8_impl(),\n                                           \"i8\",\n                                           \"i8\",\n                                           item.span);\n             }\n             ty::TyInt(ast::IntTy::I16) => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.i16_impl(),\n+                                          lang_items.i16_impl(),\n                                           \"i16\",\n                                           \"i16\",\n                                           item.span);\n             }\n             ty::TyInt(ast::IntTy::I32) => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.i32_impl(),\n+                                          lang_items.i32_impl(),\n                                           \"i32\",\n                                           \"i32\",\n                                           item.span);\n             }\n             ty::TyInt(ast::IntTy::I64) => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.i64_impl(),\n+                                          lang_items.i64_impl(),\n                                           \"i64\",\n                                           \"i64\",\n                                           item.span);\n             }\n             ty::TyInt(ast::IntTy::I128) => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.i128_impl(),\n+                                          lang_items.i128_impl(),\n                                           \"i128\",\n                                           \"i128\",\n                                           item.span);\n             }\n             ty::TyInt(ast::IntTy::Is) => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.isize_impl(),\n+                                          lang_items.isize_impl(),\n                                           \"isize\",\n                                           \"isize\",\n                                           item.span);\n             }\n             ty::TyUint(ast::UintTy::U8) => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.u8_impl(),\n+                                          lang_items.u8_impl(),\n                                           \"u8\",\n                                           \"u8\",\n                                           item.span);\n             }\n             ty::TyUint(ast::UintTy::U16) => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.u16_impl(),\n+                                          lang_items.u16_impl(),\n                                           \"u16\",\n                                           \"u16\",\n                                           item.span);\n             }\n             ty::TyUint(ast::UintTy::U32) => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.u32_impl(),\n+                                          lang_items.u32_impl(),\n                                           \"u32\",\n                                           \"u32\",\n                                           item.span);\n             }\n             ty::TyUint(ast::UintTy::U64) => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.u64_impl(),\n+                                          lang_items.u64_impl(),\n                                           \"u64\",\n                                           \"u64\",\n                                           item.span);\n             }\n             ty::TyUint(ast::UintTy::U128) => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.u128_impl(),\n+                                          lang_items.u128_impl(),\n                                           \"u128\",\n                                           \"u128\",\n                                           item.span);\n             }\n             ty::TyUint(ast::UintTy::Us) => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.usize_impl(),\n+                                          lang_items.usize_impl(),\n                                           \"usize\",\n                                           \"usize\",\n                                           item.span);\n             }\n             ty::TyFloat(ast::FloatTy::F32) => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.f32_impl(),\n+                                          lang_items.f32_impl(),\n                                           \"f32\",\n                                           \"f32\",\n                                           item.span);\n             }\n             ty::TyFloat(ast::FloatTy::F64) => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.f64_impl(),\n+                                          lang_items.f64_impl(),\n                                           \"f64\",\n                                           \"f64\",\n                                           item.span);"}, {"sha": "6109fc57b0dfccfa5f6041e627d5e7d304ccc5f0", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -51,7 +51,7 @@ fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeId) {\n \n fn enforce_trait_manually_implementable(tcx: TyCtxt, impl_def_id: DefId, trait_def_id: DefId) {\n     let did = Some(trait_def_id);\n-    let li = &tcx.lang_items;\n+    let li = tcx.lang_items();\n \n     // Disallow *all* explicit impls of `Sized` and `Unsize` for now.\n     if did == li.sized_trait() {"}, {"sha": "e4ca0f82ea1a003a3810bb7c55f2a5f5188f2b72", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -812,7 +812,8 @@ fn has_late_bound_regions<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         fn visit_lifetime(&mut self, lt: &'tcx hir::Lifetime) {\n             if self.has_late_bound_regions.is_some() { return }\n \n-            match self.tcx.named_region_map.defs.get(&lt.id).cloned() {\n+            let hir_id = self.tcx.hir.node_to_hir_id(lt.id);\n+            match self.tcx.named_region(hir_id) {\n                 Some(rl::Region::Static) | Some(rl::Region::EarlyBound(..)) => {}\n                 Some(rl::Region::LateBound(debruijn, _)) |\n                 Some(rl::Region::LateBoundAnon(debruijn, _))\n@@ -830,7 +831,8 @@ fn has_late_bound_regions<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             tcx, binder_depth: 1, has_late_bound_regions: None\n         };\n         for lifetime in &generics.lifetimes {\n-            if tcx.named_region_map.late_bound.contains(&lifetime.lifetime.id) {\n+            let hir_id = tcx.hir.node_to_hir_id(lifetime.lifetime.id);\n+            if tcx.is_late_bound(hir_id) {\n                 return Some(lifetime.lifetime.span);\n             }\n         }\n@@ -987,8 +989,8 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }).collect::<Vec<_>>();\n \n-    let object_lifetime_defaults =\n-        tcx.named_region_map.object_lifetime_defaults.get(&node_id);\n+    let hir_id = tcx.hir.node_to_hir_id(node_id);\n+    let object_lifetime_defaults = tcx.object_lifetime_defaults(hir_id);\n \n     // Now create the real type parameters.\n     let type_start = own_start + regions.len() as u32;\n@@ -1014,7 +1016,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             def_id: tcx.hir.local_def_id(p.id),\n             has_default: p.default.is_some(),\n             object_lifetime_default:\n-                object_lifetime_defaults.map_or(rl::Set1::Empty, |o| o[i]),\n+                object_lifetime_defaults.as_ref().map_or(rl::Set1::Empty, |o| o[i]),\n             pure_wrt_drop: p.pure_wrt_drop,\n         }\n     });\n@@ -1307,7 +1309,7 @@ fn is_unsized<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n         }\n     }\n \n-    let kind_id = tcx.lang_items.require(SizedTraitLangItem);\n+    let kind_id = tcx.lang_items().require(SizedTraitLangItem);\n     match unbound {\n         Some(ref tpb) => {\n             // FIXME(#8559) currently requires the unbound to be built-in.\n@@ -1343,7 +1345,10 @@ fn early_bound_lifetimes_from_generics<'a, 'tcx>(\n     ast_generics\n         .lifetimes\n         .iter()\n-        .filter(move |l| !tcx.named_region_map.late_bound.contains(&l.lifetime.id))\n+        .filter(move |l| {\n+            let hir_id = tcx.hir.node_to_hir_id(l.lifetime.id);\n+            !tcx.is_late_bound(hir_id)\n+        })\n }\n \n fn predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "6062ac96ada787624dd189a60c0c0699c824db3b", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -94,17 +94,18 @@ pub fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n }\n \n fn lang_items(tcx: TyCtxt) -> Vec<(ast::NodeId, Vec<ty::Variance>)> {\n+    let lang_items = tcx.lang_items();\n     let all = vec![\n-        (tcx.lang_items.phantom_data(), vec![ty::Covariant]),\n-        (tcx.lang_items.unsafe_cell_type(), vec![ty::Invariant]),\n+        (lang_items.phantom_data(), vec![ty::Covariant]),\n+        (lang_items.unsafe_cell_type(), vec![ty::Invariant]),\n \n         // Deprecated:\n-        (tcx.lang_items.covariant_type(), vec![ty::Covariant]),\n-        (tcx.lang_items.contravariant_type(), vec![ty::Contravariant]),\n-        (tcx.lang_items.invariant_type(), vec![ty::Invariant]),\n-        (tcx.lang_items.covariant_lifetime(), vec![ty::Covariant]),\n-        (tcx.lang_items.contravariant_lifetime(), vec![ty::Contravariant]),\n-        (tcx.lang_items.invariant_lifetime(), vec![ty::Invariant]),\n+        (lang_items.covariant_type(), vec![ty::Covariant]),\n+        (lang_items.contravariant_type(), vec![ty::Contravariant]),\n+        (lang_items.invariant_type(), vec![ty::Invariant]),\n+        (lang_items.covariant_lifetime(), vec![ty::Covariant]),\n+        (lang_items.contravariant_lifetime(), vec![ty::Contravariant]),\n+        (lang_items.invariant_lifetime(), vec![ty::Invariant]),\n \n         ];\n "}, {"sha": "70563b3d267132762b31352c5fa2f6656d4442f1", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -120,7 +120,7 @@ pub fn load_attrs(cx: &DocContext, did: DefId) -> clean::Attributes {\n /// These names are used later on by HTML rendering to generate things like\n /// source links back to the original item.\n pub fn record_extern_fqn(cx: &DocContext, did: DefId, kind: clean::TypeKind) {\n-    let crate_name = cx.tcx.sess.cstore.crate_name(did.krate).to_string();\n+    let crate_name = cx.tcx.crate_name(did.krate).to_string();\n     let relative = cx.tcx.def_path(did).data.into_iter().filter_map(|elem| {\n         // extern blocks have an empty name\n         let s = elem.data.to_string();\n@@ -236,31 +236,34 @@ pub fn build_impls(cx: &DocContext, did: DefId) -> Vec<clean::Item> {\n \n     cx.populated_all_crate_impls.set(true);\n \n-    for did in tcx.sess.cstore.implementations_of_trait(None) {\n-        build_impl(cx, did, &mut impls);\n+    for &cnum in tcx.crates().iter() {\n+        for did in tcx.all_trait_implementations(cnum).iter() {\n+            build_impl(cx, *did, &mut impls);\n+        }\n     }\n \n     // Also try to inline primitive impls from other crates.\n+    let lang_items = tcx.lang_items();\n     let primitive_impls = [\n-        tcx.lang_items.isize_impl(),\n-        tcx.lang_items.i8_impl(),\n-        tcx.lang_items.i16_impl(),\n-        tcx.lang_items.i32_impl(),\n-        tcx.lang_items.i64_impl(),\n-        tcx.lang_items.i128_impl(),\n-        tcx.lang_items.usize_impl(),\n-        tcx.lang_items.u8_impl(),\n-        tcx.lang_items.u16_impl(),\n-        tcx.lang_items.u32_impl(),\n-        tcx.lang_items.u64_impl(),\n-        tcx.lang_items.u128_impl(),\n-        tcx.lang_items.f32_impl(),\n-        tcx.lang_items.f64_impl(),\n-        tcx.lang_items.char_impl(),\n-        tcx.lang_items.str_impl(),\n-        tcx.lang_items.slice_impl(),\n-        tcx.lang_items.const_ptr_impl(),\n-        tcx.lang_items.mut_ptr_impl(),\n+        lang_items.isize_impl(),\n+        lang_items.i8_impl(),\n+        lang_items.i16_impl(),\n+        lang_items.i32_impl(),\n+        lang_items.i64_impl(),\n+        lang_items.i128_impl(),\n+        lang_items.usize_impl(),\n+        lang_items.u8_impl(),\n+        lang_items.u16_impl(),\n+        lang_items.u32_impl(),\n+        lang_items.u64_impl(),\n+        lang_items.u128_impl(),\n+        lang_items.f32_impl(),\n+        lang_items.f64_impl(),\n+        lang_items.char_impl(),\n+        lang_items.str_impl(),\n+        lang_items.slice_impl(),\n+        lang_items.const_ptr_impl(),\n+        lang_items.mut_ptr_impl(),\n     ];\n \n     for def_id in primitive_impls.iter().filter_map(|&def_id| def_id) {\n@@ -399,7 +402,7 @@ pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n             clean::RegionBound(..) => unreachable!(),\n         }\n     });\n-    if trait_.def_id() == tcx.lang_items.deref_trait() {\n+    if trait_.def_id() == tcx.lang_items().deref_trait() {\n         super::build_deref_target_impls(cx, &trait_items, ret);\n     }\n \n@@ -443,9 +446,9 @@ fn build_module(cx: &DocContext, did: DefId) -> clean::Module {\n         // two namespaces, so the target may be listed twice. Make sure we only\n         // visit each node at most once.\n         let mut visited = FxHashSet();\n-        for item in cx.tcx.sess.cstore.item_children(did, cx.tcx.sess) {\n+        for &item in cx.tcx.item_children(did).iter() {\n             let def_id = item.def.def_id();\n-            if cx.tcx.sess.cstore.visibility(def_id) == ty::Visibility::Public {\n+            if cx.tcx.visibility(def_id) == ty::Visibility::Public {\n                 if !visited.insert(def_id) { continue }\n                 if let Some(i) = try_inline(cx, item.def, item.ident.name) {\n                     items.extend(i)\n@@ -471,7 +474,7 @@ impl hir::print::PpAnn for InlinedConst {\n }\n \n fn print_inlined_const(cx: &DocContext, did: DefId) -> String {\n-    let body = cx.tcx.sess.cstore.item_body(cx.tcx, did);\n+    let body = cx.tcx.extern_const_body(did);\n     let inlined = InlinedConst {\n         nested_bodies: cx.tcx.item_body_nested_bodies(did)\n     };"}, {"sha": "88a0d3ad4ac1e84c72732a48a9b6d5993524c0a8", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -125,13 +125,13 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n \n         {\n             let mut r = cx.renderinfo.borrow_mut();\n-            r.deref_trait_did = cx.tcx.lang_items.deref_trait();\n-            r.deref_mut_trait_did = cx.tcx.lang_items.deref_mut_trait();\n-            r.owned_box_did = cx.tcx.lang_items.owned_box();\n+            r.deref_trait_did = cx.tcx.lang_items().deref_trait();\n+            r.deref_mut_trait_did = cx.tcx.lang_items().deref_mut_trait();\n+            r.owned_box_did = cx.tcx.lang_items().owned_box();\n         }\n \n         let mut externs = Vec::new();\n-        for cnum in cx.sess().cstore.crates() {\n+        for &cnum in cx.tcx.crates().iter() {\n             externs.push((cnum, cnum.clean(cx)));\n             // Analyze doc-reachability for extern items\n             LibEmbargoVisitor::new(cx).visit_lib(cnum);\n@@ -244,7 +244,7 @@ impl Clean<ExternalCrate> for CrateNum {\n                 }\n             }).collect()\n         } else {\n-            cx.tcx.sess.cstore.item_children(root, cx.tcx.sess).iter().map(|item| item.def)\n+            cx.tcx.item_children(root).iter().map(|item| item.def)\n               .filter_map(as_primitive).collect()\n         };\n \n@@ -672,7 +672,7 @@ impl TyParamBound {\n     fn maybe_sized(cx: &DocContext) -> TyParamBound {\n         let did = cx.tcx.require_lang_item(lang_items::SizedTraitLangItem);\n         let empty = cx.tcx.intern_substs(&[]);\n-        let path = external_path(cx, &cx.tcx.item_name(did).as_str(),\n+        let path = external_path(cx, &cx.tcx.item_name(did),\n             Some(did), false, vec![], empty);\n         inline::record_extern_fqn(cx, did, TypeKind::Trait);\n         TraitBound(PolyTrait {\n@@ -689,7 +689,7 @@ impl TyParamBound {\n     fn is_sized_bound(&self, cx: &DocContext) -> bool {\n         use rustc::hir::TraitBoundModifier as TBM;\n         if let TyParamBound::TraitBound(PolyTrait { ref trait_, .. }, TBM::None) = *self {\n-            if trait_.def_id() == cx.tcx.lang_items.sized_trait() {\n+            if trait_.def_id() == cx.tcx.lang_items().sized_trait() {\n                 return true;\n             }\n         }\n@@ -713,7 +713,7 @@ fn external_path_params(cx: &DocContext, trait_did: Option<DefId>, has_self: boo\n \n     match trait_did {\n         // Attempt to sugar an external path like Fn<(A, B,), C> to Fn(A, B) -> C\n-        Some(did) if cx.tcx.lang_items.fn_trait_kind(did).is_some() => {\n+        Some(did) if cx.tcx.lang_items().fn_trait_kind(did).is_some() => {\n             assert_eq!(types.len(), 1);\n             let inputs = match types[0].sty {\n                 ty::TyTuple(ref tys, _) => tys.iter().map(|t| t.clean(cx)).collect(),\n@@ -763,7 +763,7 @@ fn external_path(cx: &DocContext, name: &str, trait_did: Option<DefId>, has_self\n impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n     fn clean(&self, cx: &DocContext) -> TyParamBound {\n         inline::record_extern_fqn(cx, self.def_id, TypeKind::Trait);\n-        let path = external_path(cx, &cx.tcx.item_name(self.def_id).as_str(),\n+        let path = external_path(cx, &cx.tcx.item_name(self.def_id),\n                                  Some(self.def_id), true, vec![], self.substs);\n \n         debug!(\"ty::TraitRef\\n  subst: {:?}\\n\", self.substs);\n@@ -830,7 +830,8 @@ impl Lifetime {\n \n impl Clean<Lifetime> for hir::Lifetime {\n     fn clean(&self, cx: &DocContext) -> Lifetime {\n-        let def = cx.tcx.named_region_map.defs.get(&self.id).cloned();\n+        let hir_id = cx.tcx.hir.node_to_hir_id(self.id);\n+        let def = cx.tcx.named_region(hir_id);\n         match def {\n             Some(rl::Region::EarlyBound(_, node_id)) |\n             Some(rl::Region::LateBound(_, node_id)) |\n@@ -1924,7 +1925,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                     AdtKind::Enum => TypeKind::Enum,\n                 };\n                 inline::record_extern_fqn(cx, did, kind);\n-                let path = external_path(cx, &cx.tcx.item_name(did).as_str(),\n+                let path = external_path(cx, &cx.tcx.item_name(did),\n                                          None, false, vec![], substs);\n                 ResolvedPath {\n                     path,\n@@ -1942,7 +1943,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                     reg.clean(cx).map(|b| typarams.push(RegionBound(b)));\n                     for did in obj.auto_traits() {\n                         let empty = cx.tcx.intern_substs(&[]);\n-                        let path = external_path(cx, &cx.tcx.item_name(did).as_str(),\n+                        let path = external_path(cx, &cx.tcx.item_name(did),\n                             Some(did), false, vec![], empty);\n                         inline::record_extern_fqn(cx, did, TypeKind::Trait);\n                         let bound = TraitBound(PolyTrait {\n@@ -1965,7 +1966,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                         });\n                     }\n \n-                    let path = external_path(cx, &cx.tcx.item_name(did).as_str(), Some(did),\n+                    let path = external_path(cx, &cx.tcx.item_name(did), Some(did),\n                         false, bindings, principal.0.substs);\n                     ResolvedPath {\n                         path,\n@@ -2535,7 +2536,7 @@ impl Clean<Vec<Item>> for doctree::Impl {\n \n         // If this impl block is an implementation of the Deref trait, then we\n         // need to try inlining the target's inherent impl blocks as well.\n-        if trait_.def_id() == cx.tcx.lang_items.deref_trait() {\n+        if trait_.def_id() == cx.tcx.lang_items().deref_trait() {\n             build_deref_target_impls(cx, &items, &mut ret);\n         }\n \n@@ -2591,27 +2592,27 @@ fn build_deref_target_impls(cx: &DocContext,\n             }\n         };\n         let did = match primitive {\n-            Isize => tcx.lang_items.isize_impl(),\n-            I8 => tcx.lang_items.i8_impl(),\n-            I16 => tcx.lang_items.i16_impl(),\n-            I32 => tcx.lang_items.i32_impl(),\n-            I64 => tcx.lang_items.i64_impl(),\n-            I128 => tcx.lang_items.i128_impl(),\n-            Usize => tcx.lang_items.usize_impl(),\n-            U8 => tcx.lang_items.u8_impl(),\n-            U16 => tcx.lang_items.u16_impl(),\n-            U32 => tcx.lang_items.u32_impl(),\n-            U64 => tcx.lang_items.u64_impl(),\n-            U128 => tcx.lang_items.u128_impl(),\n-            F32 => tcx.lang_items.f32_impl(),\n-            F64 => tcx.lang_items.f64_impl(),\n-            Char => tcx.lang_items.char_impl(),\n+            Isize => tcx.lang_items().isize_impl(),\n+            I8 => tcx.lang_items().i8_impl(),\n+            I16 => tcx.lang_items().i16_impl(),\n+            I32 => tcx.lang_items().i32_impl(),\n+            I64 => tcx.lang_items().i64_impl(),\n+            I128 => tcx.lang_items().i128_impl(),\n+            Usize => tcx.lang_items().usize_impl(),\n+            U8 => tcx.lang_items().u8_impl(),\n+            U16 => tcx.lang_items().u16_impl(),\n+            U32 => tcx.lang_items().u32_impl(),\n+            U64 => tcx.lang_items().u64_impl(),\n+            U128 => tcx.lang_items().u128_impl(),\n+            F32 => tcx.lang_items().f32_impl(),\n+            F64 => tcx.lang_items().f64_impl(),\n+            Char => tcx.lang_items().char_impl(),\n             Bool => None,\n-            Str => tcx.lang_items.str_impl(),\n-            Slice => tcx.lang_items.slice_impl(),\n-            Array => tcx.lang_items.slice_impl(),\n+            Str => tcx.lang_items().str_impl(),\n+            Slice => tcx.lang_items().slice_impl(),\n+            Array => tcx.lang_items().slice_impl(),\n             Tuple => None,\n-            RawPointer => tcx.lang_items.const_ptr_impl(),\n+            RawPointer => tcx.lang_items().const_ptr_impl(),\n             Reference => None,\n             Fn => None,\n         };"}, {"sha": "d354d726ff703ec2598bf604e0b052bcd88507ee", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -207,8 +207,9 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                         continue // These are `krate.exported_macros`, handled in `self.visit()`.\n                     }\n \n-                    let imported_from = self.cx.sess().cstore.original_crate_name(def_id.krate);\n-                    let def = match self.cx.sess().cstore.load_macro(def_id, self.cx.sess()) {\n+                    let imported_from = self.cx.tcx.original_crate_name(def_id.krate);\n+                    let cstore = &self.cx.sess().cstore;\n+                    let def = match cstore.load_macro_untracked(def_id, self.cx.sess()) {\n                         LoadedMacro::MacroDef(macro_def) => macro_def,\n                         // FIXME(jseyfried): document proc macro reexports\n                         LoadedMacro::ProcMacro(..) => continue,\n@@ -371,9 +372,9 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             _ if self.inlining && item.vis != hir::Public => {}\n             hir::ItemGlobalAsm(..) => {}\n             hir::ItemExternCrate(ref p) => {\n-                let cstore = &self.cx.sess().cstore;\n+                let hir_id = self.cx.tcx.hir.node_to_hir_id(item.id);\n                 om.extern_crates.push(ExternCrate {\n-                    cnum: cstore.extern_mod_stmt_cnum(item.id)\n+                    cnum: self.cx.tcx.extern_mod_stmt_cnum(hir_id)\n                                 .unwrap_or(LOCAL_CRATE),\n                     name,\n                     path: p.map(|x|x.to_string()),"}, {"sha": "9f75388238f0c0785bafb78d1659c389fc80a759", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::middle::cstore::CrateStore;\n use rustc::middle::privacy::{AccessLevels, AccessLevel};\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n@@ -25,7 +24,6 @@ use clean::{AttributesExt, NestedAttributesExt};\n /// specific rustdoc annotations into account (i.e. `doc(hidden)`)\n pub struct LibEmbargoVisitor<'a, 'b: 'a, 'tcx: 'b> {\n     cx: &'a ::core::DocContext<'b, 'tcx>,\n-    cstore: &'a CrateStore,\n     // Accessibility levels for reachable nodes\n     access_levels: RefMut<'a, AccessLevels<DefId>>,\n     // Previous accessibility level, None means unreachable\n@@ -38,7 +36,6 @@ impl<'a, 'b, 'tcx> LibEmbargoVisitor<'a, 'b, 'tcx> {\n     pub fn new(cx: &'a ::core::DocContext<'b, 'tcx>) -> LibEmbargoVisitor<'a, 'b, 'tcx> {\n         LibEmbargoVisitor {\n             cx,\n-            cstore: &*cx.sess().cstore,\n             access_levels: cx.access_levels.borrow_mut(),\n             prev_level: Some(AccessLevel::Public),\n             visited_mods: FxHashSet()\n@@ -70,14 +67,14 @@ impl<'a, 'b, 'tcx> LibEmbargoVisitor<'a, 'b, 'tcx> {\n             return;\n         }\n \n-        for item in self.cstore.item_children(def_id, self.cx.tcx.sess) {\n+        for item in self.cx.tcx.item_children(def_id).iter() {\n             self.visit_item(item.def);\n         }\n     }\n \n     fn visit_item(&mut self, def: Def) {\n         let def_id = def.def_id();\n-        let vis = self.cstore.visibility(def_id);\n+        let vis = self.cx.tcx.visibility(def_id);\n         let inherited_item_level = if vis == Visibility::Public {\n             self.prev_level\n         } else {"}, {"sha": "20e0f9cd0b2516d6dbffee47c3e09f8b0196a009", "filename": "src/test/compile-fail/empty-linkname.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Ftest%2Fcompile-fail%2Fempty-linkname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Ftest%2Fcompile-fail%2Fempty-linkname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-linkname.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -11,3 +11,5 @@\n #[link(name = \"\")] //~ ERROR: given with empty name\n extern {\n }\n+\n+fn main() {}"}, {"sha": "0d13a4937c468ccb397a1e8cefe68687e4709323", "filename": "src/test/compile-fail/feature-gate-static-nobundle.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Ftest%2Fcompile-fail%2Ffeature-gate-static-nobundle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Ftest%2Fcompile-fail%2Ffeature-gate-static-nobundle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-static-nobundle.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -11,3 +11,5 @@\n #[link(name=\"foo\", kind=\"static-nobundle\")]\n //~^ ERROR: kind=\"static-nobundle\" is feature gated\n extern {}\n+\n+fn main() {}"}, {"sha": "06b872066695393aed63937490d1779dc88bc952", "filename": "src/test/compile-fail/feature-gate/issue-43106-gating-of-builtin-attrs.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Ftest%2Fcompile-fail%2Ffeature-gate%2Fissue-43106-gating-of-builtin-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Ftest%2Fcompile-fail%2Ffeature-gate%2Fissue-43106-gating-of-builtin-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate%2Fissue-43106-gating-of-builtin-attrs.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -99,7 +99,8 @@\n \n // For #![crate_id], see issue #43142. (I cannot bear to enshrine current behavior in a test)\n \n-#![feature                    ( x0600)] //~ WARN unused or unknown feature\n+// FIXME(#44232) we should warn that this isn't used.\n+#![feature                    ( x0600)]\n \n // For #![no_start], see issue #43144. (I cannot bear to enshrine current behavior in a test)\n "}, {"sha": "ef072d4bbb3916f424f6f69ade886c88938f5f26", "filename": "src/test/compile-fail/lint-output-format-2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Ftest%2Fcompile-fail%2Flint-output-format-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Ftest%2Fcompile-fail%2Flint-output-format-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-output-format-2.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -8,21 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -F unused_features\n // aux-build:lint_output_format.rs\n \n+// FIXME(#44232) we should warn that this isn't used.\n #![feature(foo)]\n-//~^ ERROR unused or unknown feature\n-//~| NOTE requested on the command line with `-F unused-features`\n \n #![feature(test_feature)]\n+#![feature(rustc_attrs)]\n \n extern crate lint_output_format;\n use lint_output_format::{foo, bar};\n //~^ WARNING use of deprecated item: text\n //~| NOTE #[warn(deprecated)] on by default\n \n-fn main() {\n+#[rustc_error]\n+fn main() { //~ ERROR: compilation successful\n     let _x = foo();\n     //~^ WARNING use of deprecated item: text\n     //~| NOTE #[warn(deprecated)] on by default"}, {"sha": "79ba3ea45e1878ed20b54fcb2d64edae800e041e", "filename": "src/test/compile-fail/lint-unknown-feature-default.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Ftest%2Fcompile-fail%2Flint-unknown-feature-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Ftest%2Fcompile-fail%2Flint-unknown-feature-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unknown-feature-default.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -10,8 +10,10 @@\n \n // Tests the default for the unused_features lint\n \n-#![deny(warnings)]\n+// FIXME(#44232) we should warn that this isn't used.\n+#![feature(this_is_not_a_feature)]\n \n-#![feature(this_is_not_a_feature)] //~ ERROR: unused or unknown feature\n+#![feature(rustc_attrs)]\n \n-fn main() { }\n+#[rustc_error]\n+fn main() { } //~ ERROR: compilation successful"}, {"sha": "d230297aaba01cbd108e4502bee0cd7023fd1569", "filename": "src/test/compile-fail/lint-unknown-feature.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Ftest%2Fcompile-fail%2Flint-unknown-feature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Ftest%2Fcompile-fail%2Flint-unknown-feature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unknown-feature.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -8,8 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![deny(unused_features)]\n+#![warn(unused_features)]\n \n-#![feature(this_is_not_a_feature)] //~ ERROR: unused or unknown feature\n+// FIXME(#44232) we should warn that this isn't used.\n+#![feature(this_is_not_a_feature)]\n \n-fn main() {}\n+#![feature(rustc_attrs)]\n+\n+#[rustc_error]\n+fn main() {} //~ ERROR: compilation successful"}, {"sha": "5993f4b5a0941add1e740afb04eb490c68f2e6b2", "filename": "src/test/compile-fail/stable-features.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Ftest%2Fcompile-fail%2Fstable-features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Ftest%2Fcompile-fail%2Fstable-features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstable-features.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -12,8 +12,11 @@\n // language and lib features.\n \n #![deny(stable_features)]\n+\n #![feature(test_accepted_feature)] //~ ERROR this feature has been stable since 1.0.0\n-#![feature(rust1)] //~ ERROR this feature has been stable since 1.0.0\n+\n+// FIXME(#44232) we should error that this isn't used.\n+#![feature(rust1)]\n \n fn main() {\n     let _foo: Vec<()> = Vec::new();"}, {"sha": "8eac959fc1e900c0f574397526afc322c966f980", "filename": "src/test/compile-fail/weak-lang-item.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Ftest%2Fcompile-fail%2Fweak-lang-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Ftest%2Fcompile-fail%2Fweak-lang-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fweak-lang-item.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -16,3 +16,5 @@\n \n extern crate core;\n extern crate weak_lang_items;\n+\n+fn main() {}"}, {"sha": "875aa3293650823d554b9a3e89f00ec5c4dc7fa9", "filename": "src/test/incremental/add_private_fn_at_krate_root_cc/struct_point.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Ftest%2Fincremental%2Fadd_private_fn_at_krate_root_cc%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Ftest%2Fincremental%2Fadd_private_fn_at_krate_root_cc%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fadd_private_fn_at_krate_root_cc%2Fstruct_point.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -15,6 +15,7 @@\n // revisions:rpass1 rpass2\n // compile-flags: -Z query-dep-graph\n // aux-build:point.rs\n+// ignore-test FIXME(#42293) this regressed in #44142 but should get fixed with red/green\n \n #![feature(rustc_attrs)]\n #![feature(stmt_expr_attributes)]"}, {"sha": "58fb8bc3c889f4f4f6550ff93bbad4288891ff80", "filename": "src/test/incremental/remapped_paths_cc/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fmain.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -11,6 +11,7 @@\n // revisions:rpass1 rpass2 rpass3\n // compile-flags: -Z query-dep-graph -g -Zincremental-cc\n // aux-build:extern_crate.rs\n+// ignore-test FIXME(#42293) this regressed in #44142 but should get fixed with red/green\n \n \n // This test case makes sure that we detect if paths emitted into debuginfo"}, {"sha": "24fa1502b9224e5138868a4ded92a41cbf19e658", "filename": "src/test/incremental/remove-private-item-cross-crate/main.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dead08cb331343b84564628b139b657f93548320/src%2Ftest%2Fincremental%2Fremove-private-item-cross-crate%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dead08cb331343b84564628b139b657f93548320/src%2Ftest%2Fincremental%2Fremove-private-item-cross-crate%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fremove-private-item-cross-crate%2Fmain.rs?ref=dead08cb331343b84564628b139b657f93548320", "patch": "@@ -16,7 +16,9 @@\n \n #![feature(rustc_attrs)]\n #![crate_type = \"bin\"]\n-#![rustc_partition_reused(module=\"main\", cfg=\"rpass2\")]\n+\n+// FIXME(#42293) this regressed in #44142 but should get fixed with red/green\n+// #![rustc_partition_reused(module=\"main\", cfg=\"rpass2\")]\n \n extern crate a;\n "}]}