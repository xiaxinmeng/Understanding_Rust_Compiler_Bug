{"sha": "c0b8c438203ada8768f2f8ea7c750131744f97ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwYjhjNDM4MjAzYWRhODc2OGYyZjhlYTdjNzUwMTMxNzQ0Zjk3ZWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-03T15:58:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-03T15:58:59Z"}, "message": "Auto merge of #32210 - Aatch:mir-traversal, r=nikomatsakis\n\nrBreak Critical Edges and other MIR work\n\nThis PR is built on top of #32080.\n\nThis adds the basic depth-first traversals for MIR, preorder, postorder and reverse postorder. The MIR blocks are now translated using reverse postorder. There is also a transform for breaking critical edges, which includes the edges from `invoke`d calls (`Drop` and `Call`), to account for the fact that we can't add code after an `invoke`. It also stops generating the intermediate block (since the transform essentially does it if necessary already).\n\nThe kinds of cases this deals with are difficult to produce, so the test is the one I managed to get. However, it seems to bootstrap with `-Z orbit`, which it didn't before my changes.", "tree": {"sha": "48617c9ddf0453fb8b1c557f6d8f22bc45cc196e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48617c9ddf0453fb8b1c557f6d8f22bc45cc196e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0b8c438203ada8768f2f8ea7c750131744f97ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0b8c438203ada8768f2f8ea7c750131744f97ef", "html_url": "https://github.com/rust-lang/rust/commit/c0b8c438203ada8768f2f8ea7c750131744f97ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0b8c438203ada8768f2f8ea7c750131744f97ef/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0894b06283ac513bd4b6351aa9065fa515e2a71d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0894b06283ac513bd4b6351aa9065fa515e2a71d", "html_url": "https://github.com/rust-lang/rust/commit/0894b06283ac513bd4b6351aa9065fa515e2a71d"}, {"sha": "605bc042646ef0dc0bd6e0420e6bd5a4715c93df", "url": "https://api.github.com/repos/rust-lang/rust/commits/605bc042646ef0dc0bd6e0420e6bd5a4715c93df", "html_url": "https://github.com/rust-lang/rust/commit/605bc042646ef0dc0bd6e0420e6bd5a4715c93df"}], "stats": {"total": 588, "additions": 539, "deletions": 49}, "files": [{"sha": "092b406ae9e3e23c474d7cae419e8e6a208b93a1", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c0b8c438203ada8768f2f8ea7c750131744f97ef/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b8c438203ada8768f2f8ea7c750131744f97ef/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=c0b8c438203ada8768f2f8ea7c750131744f97ef", "patch": "@@ -8,7 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::iter::FromIterator;\n+\n /// A very simple BitVector type.\n+#[derive(Clone)]\n pub struct BitVector {\n     data: Vec<u64>,\n }\n@@ -50,7 +53,9 @@ impl BitVector {\n     pub fn grow(&mut self, num_bits: usize) {\n         let num_words = u64s(num_bits);\n         let extra_words = self.data.len() - num_words;\n-        self.data.extend((0..extra_words).map(|_| 0));\n+        if extra_words > 0 {\n+            self.data.extend((0..extra_words).map(|_| 0));\n+        }\n     }\n \n     /// Iterates over indexes of set bits in a sorted order\n@@ -93,6 +98,27 @@ impl<'a> Iterator for BitVectorIter<'a> {\n     }\n }\n \n+impl FromIterator<bool> for BitVector {\n+    fn from_iter<I>(iter: I) -> BitVector where I: IntoIterator<Item=bool> {\n+        let iter = iter.into_iter();\n+        let (len, _) = iter.size_hint();\n+        // Make the minimum length for the bitvector 64 bits since that's\n+        // the smallest non-zero size anyway.\n+        let len = if len < 64 { 64 } else { len };\n+        let mut bv = BitVector::new(len);\n+        for (idx, val) in iter.enumerate() {\n+            if idx > len {\n+                bv.grow(idx);\n+            }\n+            if val {\n+                bv.insert(idx);\n+            }\n+        }\n+\n+        bv\n+    }\n+}\n+\n /// A \"bit matrix\" is basically a square matrix of booleans\n /// represented as one gigantic bitvector. In other words, it is as if\n /// you have N bitvectors, each of length N. Note that `elements` here is `N`/"}, {"sha": "4255d4fc8b0113148fbd08300852344ed6f282be", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c0b8c438203ada8768f2f8ea7c750131744f97ef/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b8c438203ada8768f2f8ea7c750131744f97ef/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=c0b8c438203ada8768f2f8ea7c750131744f97ef", "patch": "@@ -881,10 +881,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n             passes.push_pass(box mir::transform::remove_dead_blocks::RemoveDeadBlocks);\n             passes.push_pass(box mir::transform::type_check::TypeckMir);\n             passes.push_pass(box mir::transform::simplify_cfg::SimplifyCfg);\n-            // Late passes\n-            passes.push_pass(box mir::transform::no_landing_pads::NoLandingPads);\n             passes.push_pass(box mir::transform::remove_dead_blocks::RemoveDeadBlocks);\n-            passes.push_pass(box mir::transform::erase_regions::EraseRegions);\n             // And run everything.\n             passes.run_passes(tcx, &mut mir_map);\n         });\n@@ -937,16 +934,25 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n pub fn phase_4_translate_to_llvm<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                       mir_map: MirMap<'tcx>,\n-                                       analysis: ty::CrateAnalysis)\n-                                       -> trans::CrateTranslation {\n+                                       mut mir_map: MirMap<'tcx>,\n+                                       analysis: ty::CrateAnalysis) -> trans::CrateTranslation {\n     let time_passes = tcx.sess.time_passes();\n \n     time(time_passes,\n          \"resolving dependency formats\",\n          || dependency_format::calculate(&tcx.sess));\n \n-    // Option dance to work around the lack of stack once closures.\n+    // Run the passes that transform the MIR into a more suitable for translation\n+    // to LLVM code.\n+    time(time_passes, \"Prepare MIR codegen passes\", || {\n+        let mut passes = ::rustc::mir::transform::Passes::new();\n+        passes.push_pass(box mir::transform::no_landing_pads::NoLandingPads);\n+        passes.push_pass(box mir::transform::remove_dead_blocks::RemoveDeadBlocks);\n+        passes.push_pass(box mir::transform::erase_regions::EraseRegions);\n+        passes.push_pass(box mir::transform::break_critical_edges::BreakCriticalEdges);\n+        passes.run_passes(tcx, &mut mir_map);\n+    });\n+\n     time(time_passes,\n          \"translation\",\n          move || trans::trans_crate(tcx, &mir_map, analysis))"}, {"sha": "dd81895ebeccbaf006d46f5b5a3cbb59116353b7", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0b8c438203ada8768f2f8ea7c750131744f97ef/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b8c438203ada8768f2f8ea7c750131744f97ef/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=c0b8c438203ada8768f2f8ea7c750131744f97ef", "patch": "@@ -42,3 +42,4 @@ mod hair;\n pub mod mir_map;\n pub mod pretty;\n pub mod transform;\n+pub mod traversal;"}, {"sha": "e1fb5dfd4374cfc176b1900f236240e0e7ad1bc8", "filename": "src/librustc_mir/transform/break_critical_edges.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/c0b8c438203ada8768f2f8ea7c750131744f97ef/src%2Flibrustc_mir%2Ftransform%2Fbreak_critical_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b8c438203ada8768f2f8ea7c750131744f97ef/src%2Flibrustc_mir%2Ftransform%2Fbreak_critical_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fbreak_critical_edges.rs?ref=c0b8c438203ada8768f2f8ea7c750131744f97ef", "patch": "@@ -0,0 +1,117 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::ty::TyCtxt;\n+use rustc::mir::repr::*;\n+use rustc::mir::transform::{MirPass, Pass};\n+use syntax::ast::NodeId;\n+\n+use rustc_data_structures::bitvec::BitVector;\n+\n+use traversal;\n+\n+pub struct BreakCriticalEdges;\n+\n+/**\n+ * Breaks critical edges in the MIR.\n+ *\n+ * Critical edges are edges that are neither the only edge leaving a\n+ * block, nor the only edge entering one.\n+ *\n+ * When you want something to happen \"along\" an edge, you can either\n+ * do at the end of the predecessor block, or at the start of the\n+ * successor block. Critical edges have to be broken in order to prevent\n+ * \"edge actions\" from affecting other edges.\n+ *\n+ * This function will break those edges by inserting new blocks along them.\n+ *\n+ * A special case is Drop and Call terminators with unwind/cleanup successors,\n+ * They use `invoke` in LLVM, which terminates a block, meaning that code cannot\n+ * be inserted after them, so even if an edge is the only edge leaving a block\n+ * like that, we still insert blocks if the edge is one of many entering the\n+ * target.\n+ *\n+ * NOTE: Simplify CFG will happily undo most of the work this pass does.\n+ *\n+ */\n+\n+impl<'tcx> MirPass<'tcx> for BreakCriticalEdges {\n+    fn run_pass(&mut self, _: &TyCtxt<'tcx>, _: NodeId, mir: &mut Mir<'tcx>) {\n+        break_critical_edges(mir);\n+    }\n+}\n+\n+impl Pass for BreakCriticalEdges {}\n+\n+fn break_critical_edges(mir: &mut Mir) {\n+    let mut pred_count = vec![0u32; mir.basic_blocks.len()];\n+\n+    // Build the precedecessor map for the MIR\n+    for (_, data) in traversal::preorder(mir) {\n+        if let Some(ref term) = data.terminator {\n+            for &tgt in term.successors().iter() {\n+                pred_count[tgt.index()] += 1;\n+            }\n+        }\n+    }\n+\n+    let cleanup_map : BitVector = mir.basic_blocks\n+        .iter().map(|bb| bb.is_cleanup).collect();\n+\n+    // We need a place to store the new blocks generated\n+    let mut new_blocks = Vec::new();\n+\n+    let bbs = mir.all_basic_blocks();\n+    let cur_len = mir.basic_blocks.len();\n+\n+    for &bb in &bbs {\n+        let data = mir.basic_block_data_mut(bb);\n+\n+        if let Some(ref mut term) = data.terminator {\n+            let is_invoke = term_is_invoke(term);\n+            let term_span = term.span;\n+            let term_scope = term.scope;\n+            let succs = term.successors_mut();\n+            if succs.len() > 1 || (succs.len() > 0 && is_invoke) {\n+                for tgt in succs {\n+                    let num_preds = pred_count[tgt.index()];\n+                    if num_preds > 1 {\n+                        // It's a critical edge, break it\n+                        let goto = Terminator {\n+                            span: term_span,\n+                            scope: term_scope,\n+                            kind: TerminatorKind::Goto { target: *tgt }\n+                        };\n+                        let mut data = BasicBlockData::new(Some(goto));\n+                        data.is_cleanup = cleanup_map.contains(tgt.index());\n+\n+                        // Get the index it will be when inserted into the MIR\n+                        let idx = cur_len + new_blocks.len();\n+                        new_blocks.push(data);\n+                        *tgt = BasicBlock::new(idx);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    debug!(\"Broke {} N edges\", new_blocks.len());\n+\n+    mir.basic_blocks.extend_from_slice(&new_blocks);\n+}\n+\n+// Returns true if the terminator would use an invoke in LLVM.\n+fn term_is_invoke(term: &Terminator) -> bool {\n+    match term.kind {\n+        TerminatorKind::Call { cleanup: Some(_), .. } |\n+        TerminatorKind::Drop { unwind: Some(_), .. } => true,\n+        _ => false\n+    }\n+}"}, {"sha": "a52a8edc211730eb31b5b5a6e20c11a3b8ead040", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0b8c438203ada8768f2f8ea7c750131744f97ef/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b8c438203ada8768f2f8ea7c750131744f97ef/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=c0b8c438203ada8768f2f8ea7c750131744f97ef", "patch": "@@ -13,3 +13,4 @@ pub mod simplify_cfg;\n pub mod erase_regions;\n pub mod no_landing_pads;\n pub mod type_check;\n+pub mod break_critical_edges;"}, {"sha": "8b6821136f511962dc796ddfd98ecd28d8b57a07", "filename": "src/librustc_mir/traversal.rs", "status": "added", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/c0b8c438203ada8768f2f8ea7c750131744f97ef/src%2Flibrustc_mir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b8c438203ada8768f2f8ea7c750131744f97ef/src%2Flibrustc_mir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftraversal.rs?ref=c0b8c438203ada8768f2f8ea7c750131744f97ef", "patch": "@@ -0,0 +1,276 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::vec;\n+\n+use rustc_data_structures::bitvec::BitVector;\n+\n+use rustc::mir::repr::*;\n+\n+/// Preorder traversal of a graph.\n+///\n+/// Preorder traversal is when each node is visited before an of it's\n+/// successors\n+///\n+///         A\n+///        / \\\n+///       /   \\\n+///      B     C\n+///       \\   /\n+///        \\ /\n+///         D\n+///\n+/// A preorder traversal of this graph is either `A B D C` or `A C D B`\n+#[derive(Clone)]\n+pub struct Preorder<'a, 'tcx: 'a> {\n+    mir: &'a Mir<'tcx>,\n+    visited: BitVector,\n+    worklist: Vec<BasicBlock>,\n+}\n+\n+impl<'a, 'tcx> Preorder<'a, 'tcx> {\n+    pub fn new(mir: &'a Mir<'tcx>, root: BasicBlock) -> Preorder<'a, 'tcx> {\n+        let worklist = vec![root];\n+\n+        Preorder {\n+            mir: mir,\n+            visited: BitVector::new(mir.basic_blocks.len()),\n+            worklist: worklist\n+        }\n+    }\n+}\n+\n+pub fn preorder<'a, 'tcx>(mir: &'a Mir<'tcx>) -> Preorder<'a, 'tcx> {\n+    Preorder::new(mir, START_BLOCK)\n+}\n+\n+impl<'a, 'tcx> Iterator for Preorder<'a, 'tcx> {\n+    type Item = (BasicBlock, &'a BasicBlockData<'tcx>);\n+\n+    fn next(&mut self) -> Option<(BasicBlock, &'a BasicBlockData<'tcx>)> {\n+        while let Some(idx) = self.worklist.pop() {\n+            if !self.visited.insert(idx.index()) {\n+                continue;\n+            }\n+\n+            let data = self.mir.basic_block_data(idx);\n+\n+            if let Some(ref term) = data.terminator {\n+                for &succ in term.successors().iter() {\n+                    self.worklist.push(succ);\n+                }\n+            }\n+\n+            return Some((idx, data));\n+        }\n+\n+        None\n+    }\n+}\n+\n+/// Postorder traversal of a graph.\n+///\n+/// Postorder traversal is when each node is visited after all of it's\n+/// successors, except when the successor is only reachable by a back-edge\n+///\n+///         A\n+///        / \\\n+///       /   \\\n+///      B     C\n+///       \\   /\n+///        \\ /\n+///         D\n+///\n+/// A Postorder traversal of this graph is `D B C A` or `D C B A`\n+pub struct Postorder<'a, 'tcx: 'a> {\n+    mir: &'a Mir<'tcx>,\n+    visited: BitVector,\n+    visit_stack: Vec<(BasicBlock, vec::IntoIter<BasicBlock>)>\n+}\n+\n+impl<'a, 'tcx> Postorder<'a, 'tcx> {\n+    pub fn new(mir: &'a Mir<'tcx>, root: BasicBlock) -> Postorder<'a, 'tcx> {\n+        let mut po = Postorder {\n+            mir: mir,\n+            visited: BitVector::new(mir.basic_blocks.len()),\n+            visit_stack: Vec::new()\n+        };\n+\n+\n+        let data = po.mir.basic_block_data(root);\n+\n+        if let Some(ref term) = data.terminator {\n+            po.visited.insert(root.index());\n+\n+            let succs = term.successors().into_owned().into_iter();\n+\n+            po.visit_stack.push((root, succs));\n+            po.traverse_successor();\n+        }\n+\n+        po\n+    }\n+\n+    fn traverse_successor(&mut self) {\n+        // This is quite a complex loop due to 1. the borrow checker not liking it much\n+        // and 2. what exactly is going on is not clear\n+        //\n+        // It does the actual traversal of the graph, while the `next` method on the iterator\n+        // just pops off of the stack. `visit_stack` is a stack containing pairs of nodes and\n+        // iterators over the sucessors of those nodes. Each iteration attempts to get the next\n+        // node from the top of the stack, then pushes that node and an iterator over the\n+        // successors to the top of the stack. This loop only grows `visit_stack`, stopping when\n+        // we reach a child that has no children that we haven't already visited.\n+        //\n+        // For a graph that looks like this:\n+        //\n+        //         A\n+        //        / \\\n+        //       /   \\\n+        //      B     C\n+        //      |     |\n+        //      |     |\n+        //      D     |\n+        //       \\   /\n+        //        \\ /\n+        //         E\n+        //\n+        // The state of the stack starts out with just the root node (`A` in this case);\n+        //     [(A, [B, C])]\n+        //\n+        // When the first call to `traverse_sucessor` happens, the following happens:\n+        //\n+        //     [(B, [D]),  // `B` taken from the successors of `A`, pushed to the\n+        //                 // top of the stack along with the successors of `B`\n+        //      (A, [C])]\n+        //\n+        //     [(D, [E]),  // `D` taken from successors of `B`, pushed to stack\n+        //      (B, []),\n+        //      (A, [C])]\n+        //\n+        //     [(E, []),   // `E` taken from successors of `D`, pushed to stack\n+        //      (D, []),\n+        //      (B, []),\n+        //      (A, [C])]\n+        //\n+        // Now that the top of the stack has no successors we can traverse, each item will\n+        // be popped off during iteration until we get back to `A`. This yeilds [E, D, B].\n+        //\n+        // When we yield `B` and call `traverse_successor`, we push `C` to the stack, but\n+        // since we've already visited `E`, that child isn't added to the stack. The last\n+        // two iterations yield `C` and finally `A` for a final traversal of [E, D, B, C, A]\n+        loop {\n+            let bb = if let Some(&mut (_, ref mut iter)) = self.visit_stack.last_mut() {\n+                if let Some(bb) = iter.next() {\n+                    bb\n+                } else {\n+                    break;\n+                }\n+            } else {\n+                break;\n+            };\n+\n+            if self.visited.insert(bb.index()) {\n+                let data = self.mir.basic_block_data(bb);\n+\n+                if let Some(ref term) = data.terminator {\n+                    let succs = term.successors().into_owned().into_iter();\n+                    self.visit_stack.push((bb, succs));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub fn postorder<'a, 'tcx>(mir: &'a Mir<'tcx>) -> Postorder<'a, 'tcx> {\n+    Postorder::new(mir, START_BLOCK)\n+}\n+\n+impl<'a, 'tcx> Iterator for Postorder<'a, 'tcx> {\n+    type Item = (BasicBlock, &'a BasicBlockData<'tcx>);\n+\n+    fn next(&mut self) -> Option<(BasicBlock, &'a BasicBlockData<'tcx>)> {\n+        let next = self.visit_stack.pop();\n+        if next.is_some() {\n+            self.traverse_successor();\n+        }\n+\n+        next.map(|(bb, _)| {\n+            let data = self.mir.basic_block_data(bb);\n+            (bb, data)\n+        })\n+    }\n+}\n+\n+/// Reverse postorder traversal of a graph\n+///\n+/// Reverse postorder is the reverse order of a postorder traversal.\n+/// This is different to a preorder traversal and represents a natural\n+/// linearisation of control-flow.\n+///\n+///         A\n+///        / \\\n+///       /   \\\n+///      B     C\n+///       \\   /\n+///        \\ /\n+///         D\n+///\n+/// A reverse postorder traversal of this graph is either `A B C D` or `A C B D`\n+/// Note that for a graph containing no loops (i.e. A DAG), this is equivalent to\n+/// a topological sort.\n+///\n+/// Construction of a `ReversePostorder` traversal requires doing a full\n+/// postorder traversal of the graph, therefore this traversal should be\n+/// constructed as few times as possible. Use the `reset` method to be able\n+/// to re-use the traversal\n+#[derive(Clone)]\n+pub struct ReversePostorder<'a, 'tcx: 'a> {\n+    mir: &'a Mir<'tcx>,\n+    blocks: Vec<BasicBlock>,\n+    idx: usize\n+}\n+\n+impl<'a, 'tcx> ReversePostorder<'a, 'tcx> {\n+    pub fn new(mir: &'a Mir<'tcx>, root: BasicBlock) -> ReversePostorder<'a, 'tcx> {\n+        let blocks : Vec<_> = Postorder::new(mir, root).map(|(bb, _)| bb).collect();\n+\n+        let len = blocks.len();\n+\n+        ReversePostorder {\n+            mir: mir,\n+            blocks: blocks,\n+            idx: len\n+        }\n+    }\n+\n+    pub fn reset(&mut self) {\n+        self.idx = self.blocks.len();\n+    }\n+}\n+\n+\n+pub fn reverse_postorder<'a, 'tcx>(mir: &'a Mir<'tcx>) -> ReversePostorder<'a, 'tcx> {\n+    ReversePostorder::new(mir, START_BLOCK)\n+}\n+\n+impl<'a, 'tcx> Iterator for ReversePostorder<'a, 'tcx> {\n+    type Item = (BasicBlock, &'a BasicBlockData<'tcx>);\n+\n+    fn next(&mut self) -> Option<(BasicBlock, &'a BasicBlockData<'tcx>)> {\n+        if self.idx == 0 { return None; }\n+        self.idx -= 1;\n+\n+        self.blocks.get(self.idx).map(|&bb| {\n+            let data = self.mir.basic_block_data(bb);\n+            (bb, data)\n+        })\n+    }\n+}"}, {"sha": "60bd3fb8ef1b8db10ed2417a2a6db484d5e8e73a", "filename": "src/librustc_trans/basic_block.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0b8c438203ada8768f2f8ea7c750131744f97ef/src%2Flibrustc_trans%2Fbasic_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b8c438203ada8768f2f8ea7c750131744f97ef/src%2Flibrustc_trans%2Fbasic_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbasic_block.rs?ref=c0b8c438203ada8768f2f8ea7c750131744f97ef", "patch": "@@ -49,4 +49,10 @@ impl BasicBlock {\n             _ => None\n         }\n     }\n+\n+    pub fn delete(self) {\n+        unsafe {\n+            llvm::LLVMDeleteBasicBlock(self.0);\n+        }\n+    }\n }"}, {"sha": "3fabdd8fd4226027e315c5078c8ac0e71c1d2d18", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 11, "deletions": 35, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c0b8c438203ada8768f2f8ea7c750131744f97ef/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b8c438203ada8768f2f8ea7c750131744f97ef/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=c0b8c438203ada8768f2f8ea7c750131744f97ef", "patch": "@@ -300,33 +300,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n                 // Many different ways to call a function handled here\n                 if let Some(cleanup) = cleanup.map(|bb| self.bcx(bb)) {\n-                    // We translate the copy into a temporary block. The temporary block is\n-                    // necessary because the current block has already been terminated (by\n-                    // `invoke`) and we cannot really translate into the target block\n-                    // because:\n-                    //  * The target block may have more than a single precedesor;\n-                    //  * Some LLVM insns cannot have a preceeding store insn (phi,\n-                    //    cleanuppad), and adding/prepending the store now may render\n-                    //    those other instructions invalid.\n-                    //\n-                    // NB: This approach still may break some LLVM code. For example if the\n-                    // target block starts with a `phi` (which may only match on immediate\n-                    // precedesors), it cannot know about this temporary block thus\n-                    // resulting in an invalid code:\n-                    //\n-                    // this:\n-                    //     \u2026\n-                    //     %0 = \u2026\n-                    //     %1 = invoke to label %temp \u2026\n-                    // temp:\n-                    //     store ty %1, ty* %dest\n-                    //     br label %actualtargetblock\n-                    // actualtargetblock:            ; preds: %temp, \u2026\n-                    //     phi \u2026 [%this, \u2026], [%0, \u2026] ; ERROR: phi requires to match only on\n-                    //                               ; immediate precedesors\n-\n-                    let ret_bcx = if destination.is_some() {\n-                        self.fcx.new_block(\"\", None)\n+                    let ret_bcx = if let Some((_, target)) = *destination {\n+                        self.blocks[target.index()]\n                     } else {\n                         self.unreachable_block()\n                     };\n@@ -343,15 +318,16 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         self.set_operand_dropped(bcx, op);\n                     });\n \n-                    if let Some((_, target)) = *destination {\n+                    if destination.is_some() {\n                         let ret_bcx = ret_bcx.build();\n-                        if let Some(ret_dest) = ret_dest {\n-                            fn_ty.ret.store(&ret_bcx, invokeret, ret_dest.llval);\n-                        }\n-                        for op in args {\n-                            self.set_operand_dropped(&ret_bcx, op);\n-                        }\n-                        ret_bcx.br(self.llblock(target));\n+                        ret_bcx.at_start(|ret_bcx| {\n+                            if let Some(ret_dest) = ret_dest {\n+                                fn_ty.ret.store(&ret_bcx, invokeret, ret_dest.llval);\n+                            }\n+                            for op in args {\n+                                self.set_operand_dropped(&ret_bcx, op);\n+                            }\n+                        });\n                     }\n                 } else {\n                     let llret = bcx.call(fn_ptr, &llargs, cleanup_bundle.as_ref());"}, {"sha": "7e44b72db7f8d6eac1e24e6b78fab97c59f1b876", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c0b8c438203ada8768f2f8ea7c750131744f97ef/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b8c438203ada8768f2f8ea7c750131744f97ef/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=c0b8c438203ada8768f2f8ea7c750131744f97ef", "patch": "@@ -19,7 +19,13 @@ use common::{self, Block, BlockAndBuilder, FunctionContext};\n use std::ops::Deref;\n use std::rc::Rc;\n \n+use basic_block::BasicBlock;\n+\n+use rustc_data_structures::bitvec::BitVector;\n+\n use self::lvalue::{LvalueRef, get_dataptr, get_meta};\n+use rustc_mir::traversal;\n+\n use self::operand::OperandRef;\n \n #[derive(Clone)]\n@@ -95,7 +101,7 @@ enum TempRef<'tcx> {\n \n ///////////////////////////////////////////////////////////////////////////\n \n-pub fn trans_mir<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n+pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n     let bcx = fcx.init(false, None).build();\n     let mir = bcx.mir();\n \n@@ -132,8 +138,13 @@ pub fn trans_mir<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n     let block_bcxs: Vec<Block<'blk,'tcx>> =\n         mir_blocks.iter()\n                   .map(|&bb|{\n-                      // FIXME(#30941) this doesn't handle msvc-style exceptions\n-                      fcx.new_block(&format!(\"{:?}\", bb), None)\n+                      if bb == mir::START_BLOCK {\n+                          fcx.new_block(\"start\", None)\n+                      } else if bb == mir::END_BLOCK {\n+                          fcx.new_block(\"end\", None)\n+                      } else {\n+                          fcx.new_block(&format!(\"{:?}\", bb), None)\n+                      }\n                   })\n                   .collect();\n \n@@ -142,7 +153,7 @@ pub fn trans_mir<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n     bcx.br(start_bcx.llbb);\n \n     let mut mircx = MirContext {\n-        mir: mir,\n+        mir: mir.clone(),\n         fcx: fcx,\n         llpersonalityslot: None,\n         blocks: block_bcxs,\n@@ -152,11 +163,28 @@ pub fn trans_mir<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n         args: args,\n     };\n \n-    // Translate the body of each block\n-    for &bb in &mir_blocks {\n+    let mut visited = BitVector::new(mir_blocks.len());\n+\n+    let rpo = traversal::reverse_postorder(&mir);\n+    // Translate the body of each block using reverse postorder\n+    for (bb, _) in rpo {\n+        visited.insert(bb.index());\n         mircx.trans_block(bb);\n     }\n \n+    // Remove blocks that haven't been visited, or have no\n+    // predecessors.\n+    for &bb in &mir_blocks {\n+        let block = mircx.blocks[bb.index()];\n+        let block = BasicBlock(block.llbb);\n+        // Unreachable block\n+        if !visited.contains(bb.index()) {\n+            block.delete();\n+        } else if block.pred_iter().count() == 0 {\n+            block.delete();\n+        }\n+    }\n+\n     fcx.cleanup();\n }\n "}, {"sha": "320f40175926dfc2e4ed233726648ae6c356ddb8", "filename": "src/test/run-pass/mir_trans_critical_edge.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c0b8c438203ada8768f2f8ea7c750131744f97ef/src%2Ftest%2Frun-pass%2Fmir_trans_critical_edge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b8c438203ada8768f2f8ea7c750131744f97ef/src%2Ftest%2Frun-pass%2Fmir_trans_critical_edge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_trans_critical_edge.rs?ref=c0b8c438203ada8768f2f8ea7c750131744f97ef", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This code produces a CFG with critical edges that, if we don't\n+// handle properly, will cause invalid codegen.\n+\n+#![feature(rustc_attrs)]\n+\n+enum State {\n+    Both,\n+    Front,\n+    Back\n+}\n+\n+pub struct Foo<A: Iterator, B: Iterator> {\n+    state: State,\n+    a: A,\n+    b: B\n+}\n+\n+impl<A, B> Foo<A, B>\n+where A: Iterator, B: Iterator<Item=A::Item>\n+{\n+    // This is the function we care about\n+    #[rustc_mir]\n+    fn next(&mut self) -> Option<A::Item> {\n+        match self.state {\n+            State::Both => match self.a.next() {\n+                elt @ Some(..) => elt,\n+                None => {\n+                    self.state = State::Back;\n+                    self.b.next()\n+                }\n+            },\n+            State::Front => self.a.next(),\n+            State::Back => self.b.next(),\n+        }\n+    }\n+}\n+\n+// Make sure we actually translate a version of the function\n+pub fn do_stuff(mut f: Foo<Box<Iterator<Item=u32>>, Box<Iterator<Item=u32>>>) {\n+    let _x = f.next();\n+}\n+\n+fn main() {}"}]}