{"sha": "e46b790b9deb8f0c4db0a052f3cd9a875fc70d3b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0NmI3OTBiOWRlYjhmMGM0ZGIwYTA1MmYzY2Q5YTg3NWZjNzBkM2I=", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2021-07-12T23:54:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-12T23:54:39Z"}, "message": "Rollup merge of #87089 - RalfJung:ctfe-memory-cleanup, r=oli-obk\n\nCTFE engine: small cleanups\n\nI noticed these while preparing a large PR, and figured I'd better send them ahead to not muddy the diff unnecessarily.\n\n- remove remaining use of Pointer in Allocation API (I missed those in https://github.com/rust-lang/rust/pull/85472)\n- remove unnecessary deallocate_local hack (this logic does not seem necessary any more)\n\nr? `@oli-obk`", "tree": {"sha": "949fecdc1d86b57eaaa140b1c5e4adb703763cac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/949fecdc1d86b57eaaa140b1c5e4adb703763cac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e46b790b9deb8f0c4db0a052f3cd9a875fc70d3b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg7NY/CRBK7hj4Ov3rIwAAtoUIAB8NBvH6inBlDjBP7bxiQSBe\nx7kzuCiHKc3yOPNlXDMQE+vr9DYcArXx98CAz/FsYmdqiGA4jVKUw+WqEg37Oa5T\nBF43gysfPy6Bb+gc/zoeBtGkdNS7yrUPZ2PHe6bDdPfq7Mri4pHAxIEuwp9nOCFs\n8C7wBLDE5QThPAWQ4DLBW9/FrNCbwbRJ0c5NdUOsgjP5KhhrmSgvFEoaaNZoXVne\ndBV//DTO77AhZvyArddq14wiXYVAgnZLsAdfoEifmacX1fs3O/715q7swNkoLM26\no2kd6soK2iXvOAfYduWqQ1SI1sAn2j4o0zW4d1Zyz04/YTbfZQP6+oIJXcDLLE8=\n=cfHQ\n-----END PGP SIGNATURE-----\n", "payload": "tree 949fecdc1d86b57eaaa140b1c5e4adb703763cac\nparent 15af98d0700a340eaef8d44de58edb5f1a54b4d2\nparent 6b26640583649b6e688f7c1d82778a555bf66b79\nauthor Yuki Okushi <jtitor@2k36.org> 1626134079 +0900\ncommitter GitHub <noreply@github.com> 1626134079 +0900\n\nRollup merge of #87089 - RalfJung:ctfe-memory-cleanup, r=oli-obk\n\nCTFE engine: small cleanups\n\nI noticed these while preparing a large PR, and figured I'd better send them ahead to not muddy the diff unnecessarily.\n\n- remove remaining use of Pointer in Allocation API (I missed those in https://github.com/rust-lang/rust/pull/85472)\n- remove unnecessary deallocate_local hack (this logic does not seem necessary any more)\n\nr? `@oli-obk`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e46b790b9deb8f0c4db0a052f3cd9a875fc70d3b", "html_url": "https://github.com/rust-lang/rust/commit/e46b790b9deb8f0c4db0a052f3cd9a875fc70d3b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e46b790b9deb8f0c4db0a052f3cd9a875fc70d3b/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15af98d0700a340eaef8d44de58edb5f1a54b4d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/15af98d0700a340eaef8d44de58edb5f1a54b4d2", "html_url": "https://github.com/rust-lang/rust/commit/15af98d0700a340eaef8d44de58edb5f1a54b4d2"}, {"sha": "6b26640583649b6e688f7c1d82778a555bf66b79", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b26640583649b6e688f7c1d82778a555bf66b79", "html_url": "https://github.com/rust-lang/rust/commit/6b26640583649b6e688f7c1d82778a555bf66b79"}], "stats": {"total": 44, "additions": 18, "deletions": 26}, "files": [{"sha": "75cbb55239c8b21ff8a10ffb566732e724862548", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e46b790b9deb8f0c4db0a052f3cd9a875fc70d3b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e46b790b9deb8f0c4db0a052f3cd9a875fc70d3b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=e46b790b9deb8f0c4db0a052f3cd9a875fc70d3b", "patch": "@@ -512,7 +512,7 @@ impl InitMaskCompressed {\n /// Transferring the initialization mask to other allocations.\n impl<Tag, Extra> Allocation<Tag, Extra> {\n     /// Creates a run-length encoding of the initialization mask.\n-    pub fn compress_uninit_range(&self, src: Pointer<Tag>, size: Size) -> InitMaskCompressed {\n+    pub fn compress_uninit_range(&self, range: AllocRange) -> InitMaskCompressed {\n         // Since we are copying `size` bytes from `src` to `dest + i * size` (`for i in 0..repeat`),\n         // a naive initialization mask copying algorithm would repeatedly have to read the initialization mask from\n         // the source and write it to the destination. Even if we optimized the memory accesses,\n@@ -526,13 +526,13 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n         // where each element toggles the state.\n \n         let mut ranges = smallvec::SmallVec::<[u64; 1]>::new();\n-        let initial = self.init_mask.get(src.offset);\n+        let initial = self.init_mask.get(range.start);\n         let mut cur_len = 1;\n         let mut cur = initial;\n \n-        for i in 1..size.bytes() {\n+        for i in 1..range.size.bytes() {\n             // FIXME: optimize to bitshift the current uninitialized block's bits and read the top bit.\n-            if self.init_mask.get(src.offset + Size::from_bytes(i)) == cur {\n+            if self.init_mask.get(range.start + Size::from_bytes(i)) == cur {\n                 cur_len += 1;\n             } else {\n                 ranges.push(cur_len);\n@@ -550,24 +550,23 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n     pub fn mark_compressed_init_range(\n         &mut self,\n         defined: &InitMaskCompressed,\n-        dest: Pointer<Tag>,\n-        size: Size,\n+        range: AllocRange,\n         repeat: u64,\n     ) {\n         // An optimization where we can just overwrite an entire range of initialization\n         // bits if they are going to be uniformly `1` or `0`.\n         if defined.ranges.len() <= 1 {\n             self.init_mask.set_range_inbounds(\n-                dest.offset,\n-                dest.offset + size * repeat, // `Size` operations\n+                range.start,\n+                range.start + range.size * repeat, // `Size` operations\n                 defined.initial,\n             );\n             return;\n         }\n \n         for mut j in 0..repeat {\n-            j *= size.bytes();\n-            j += dest.offset.bytes();\n+            j *= range.size.bytes();\n+            j += range.start.bytes();\n             let mut cur = defined.initial;\n             for range in &defined.ranges {\n                 let old_j = j;"}, {"sha": "8cd459265dfc54fe2a1f81170068eddab5dfdbfc", "filename": "compiler/rustc_mir/src/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e46b790b9deb8f0c4db0a052f3cd9a875fc70d3b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e46b790b9deb8f0c4db0a052f3cd9a875fc70d3b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs?ref=e46b790b9deb8f0c4db0a052f3cd9a875fc70d3b", "patch": "@@ -18,8 +18,8 @@ use rustc_span::{Pos, Span};\n use rustc_target::abi::{Align, HasDataLayout, LayoutOf, Size, TargetDataLayout};\n \n use super::{\n-    Immediate, MPlaceTy, Machine, MemPlace, MemPlaceMeta, Memory, Operand, Place, PlaceTy,\n-    ScalarMaybeUninit, StackPopJump,\n+    Immediate, MPlaceTy, Machine, MemPlace, MemPlaceMeta, Memory, MemoryKind, Operand, Place,\n+    PlaceTy, ScalarMaybeUninit, StackPopJump,\n };\n use crate::transform::validate::equal_up_to_regions;\n use crate::util::storage::AlwaysLiveLocals;\n@@ -900,7 +900,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // due to the local having ZST type.\n             let ptr = ptr.assert_ptr();\n             trace!(\"deallocating local: {:?}\", self.memory.dump_alloc(ptr.alloc_id));\n-            self.memory.deallocate_local(ptr)?;\n+            self.memory.deallocate(ptr, None, MemoryKind::Stack)?;\n         };\n         Ok(())\n     }"}, {"sha": "5f719cc160706d09aa3fa9d1e0cee62a7ac00d46", "filename": "compiler/rustc_mir/src/interpret/memory.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e46b790b9deb8f0c4db0a052f3cd9a875fc70d3b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e46b790b9deb8f0c4db0a052f3cd9a875fc70d3b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs?ref=e46b790b9deb8f0c4db0a052f3cd9a875fc70d3b", "patch": "@@ -276,17 +276,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         Ok(new_ptr)\n     }\n \n-    /// Deallocate a local, or do nothing if that local has been made into a global.\n-    pub fn deallocate_local(&mut self, ptr: Pointer<M::PointerTag>) -> InterpResult<'tcx> {\n-        // The allocation might be already removed by global interning.\n-        // This can only really happen in the CTFE instance, not in miri.\n-        if self.alloc_map.contains_key(&ptr.alloc_id) {\n-            self.deallocate(ptr, None, MemoryKind::Stack)\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n     pub fn deallocate(\n         &mut self,\n         ptr: Pointer<M::PointerTag>,\n@@ -1049,7 +1038,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             num_copies,\n         );\n         // Prepare a copy of the initialization mask.\n-        let compressed = src_alloc.compress_uninit_range(src, size);\n+        let compressed = src_alloc.compress_uninit_range(alloc_range(src.offset, size));\n         // This checks relocation edges on the src.\n         let src_bytes = src_alloc\n             .get_bytes_with_uninit_and_ptr(&tcx, alloc_range(src.offset, size))\n@@ -1110,7 +1099,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         }\n \n         // now fill in all the \"init\" data\n-        dest_alloc.mark_compressed_init_range(&compressed, dest, size, num_copies);\n+        dest_alloc.mark_compressed_init_range(\n+            &compressed,\n+            alloc_range(dest.offset, size),\n+            num_copies,\n+        );\n         // copy the relocations to the destination\n         dest_alloc.mark_relocation_range(relocations);\n "}]}