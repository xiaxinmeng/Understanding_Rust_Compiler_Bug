{"sha": "4e1927db3c399fa34dc71992bd5dbec09f945c3d", "node_id": "C_kwDOAAsO6NoAKDRlMTkyN2RiM2MzOTlmYTM0ZGM3MTk5MmJkNWRiZWMwOWY5NDVjM2Q", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-12T05:54:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-12T05:54:50Z"}, "message": "Auto merge of #95399 - gilescope:plan_b, r=scottmcm\n\nFaster parsing for lower numbers for radix up to 16 (cont.)\n\n( Continuation of https://github.com/rust-lang/rust/pull/83371 )\n\nWith LingMan's change I think this is potentially ready.", "tree": {"sha": "f9ce63e98594822d07fdb7873185a363e2701d6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9ce63e98594822d07fdb7873185a363e2701d6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e1927db3c399fa34dc71992bd5dbec09f945c3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e1927db3c399fa34dc71992bd5dbec09f945c3d", "html_url": "https://github.com/rust-lang/rust/commit/4e1927db3c399fa34dc71992bd5dbec09f945c3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e1927db3c399fa34dc71992bd5dbec09f945c3d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8f4cb6231dc7d4ff9afe62de798af0dc18ae835", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8f4cb6231dc7d4ff9afe62de798af0dc18ae835", "html_url": "https://github.com/rust-lang/rust/commit/b8f4cb6231dc7d4ff9afe62de798af0dc18ae835"}, {"sha": "3ee7bb19c62761f5387c463a804d970c1ea3db72", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ee7bb19c62761f5387c463a804d970c1ea3db72", "html_url": "https://github.com/rust-lang/rust/commit/3ee7bb19c62761f5387c463a804d970c1ea3db72"}], "stats": {"total": 174, "additions": 136, "deletions": 38}, "files": [{"sha": "f45b73b053364442ce346e03f5aec2ae4b09e61b", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 65, "deletions": 37, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/4e1927db3c399fa34dc71992bd5dbec09f945c3d/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e1927db3c399fa34dc71992bd5dbec09f945c3d/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=4e1927db3c399fa34dc71992bd5dbec09f945c3d", "patch": "@@ -5,6 +5,7 @@\n use crate::ascii;\n use crate::intrinsics;\n use crate::mem;\n+use crate::ops::{Add, Mul, Sub};\n use crate::str::FromStr;\n \n // Used because the `?` operator is not allowed in a const context.\n@@ -954,9 +955,10 @@ pub enum FpCategory {\n }\n \n #[doc(hidden)]\n-trait FromStrRadixHelper: PartialOrd + Copy {\n-    fn min_value() -> Self;\n-    fn max_value() -> Self;\n+trait FromStrRadixHelper:\n+    PartialOrd + Copy + Add<Output = Self> + Sub<Output = Self> + Mul<Output = Self>\n+{\n+    const MIN: Self;\n     fn from_u32(u: u32) -> Self;\n     fn checked_mul(&self, other: u32) -> Option<Self>;\n     fn checked_sub(&self, other: u32) -> Option<Self>;\n@@ -976,12 +978,9 @@ macro_rules! from_str_radix_int_impl {\n }\n from_str_radix_int_impl! { isize i8 i16 i32 i64 i128 usize u8 u16 u32 u64 u128 }\n \n-macro_rules! doit {\n+macro_rules! impl_helper_for {\n     ($($t:ty)*) => ($(impl FromStrRadixHelper for $t {\n-        #[inline]\n-        fn min_value() -> Self { Self::MIN }\n-        #[inline]\n-        fn max_value() -> Self { Self::MAX }\n+        const MIN: Self = Self::MIN;\n         #[inline]\n         fn from_u32(u: u32) -> Self { u as Self }\n         #[inline]\n@@ -998,7 +997,18 @@ macro_rules! doit {\n         }\n     })*)\n }\n-doit! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize }\n+impl_helper_for! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize }\n+\n+/// Determins if a string of text of that length of that radix could be guaranteed to be\n+/// stored in the given type T.\n+/// Note that if the radix is known to the compiler, it is just the check of digits.len that\n+/// is done at runtime.\n+#[doc(hidden)]\n+#[inline(always)]\n+#[unstable(issue = \"none\", feature = \"std_internals\")]\n+pub fn can_not_overflow<T>(radix: u32, is_signed_ty: bool, digits: &[u8]) -> bool {\n+    radix <= 16 && digits.len() <= mem::size_of::<T>() * 2 - is_signed_ty as usize\n+}\n \n fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32) -> Result<T, ParseIntError> {\n     use self::IntErrorKind::*;\n@@ -1014,7 +1024,7 @@ fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32) -> Result<T, Par\n         return Err(PIE { kind: Empty });\n     }\n \n-    let is_signed_ty = T::from_u32(0) > T::min_value();\n+    let is_signed_ty = T::from_u32(0) > T::MIN;\n \n     // all valid digits are ascii, so we will just iterate over the utf8 bytes\n     // and cast them to chars. .to_digit() will safely return None for anything\n@@ -1032,38 +1042,56 @@ fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32) -> Result<T, Par\n     };\n \n     let mut result = T::from_u32(0);\n-    if is_positive {\n-        // The number is positive\n-        for &c in digits {\n-            let x = match (c as char).to_digit(radix) {\n-                Some(x) => x,\n-                None => return Err(PIE { kind: InvalidDigit }),\n-            };\n-            result = match result.checked_mul(radix) {\n-                Some(result) => result,\n-                None => return Err(PIE { kind: PosOverflow }),\n-            };\n-            result = match result.checked_add(x) {\n-                Some(result) => result,\n-                None => return Err(PIE { kind: PosOverflow }),\n+\n+    if can_not_overflow::<T>(radix, is_signed_ty, digits) {\n+        // If the len of the str is short compared to the range of the type\n+        // we are parsing into, then we can be certain that an overflow will not occur.\n+        // This bound is when `radix.pow(digits.len()) - 1 <= T::MAX` but the condition\n+        // above is a faster (conservative) approximation of this.\n+        //\n+        // Consider radix 16 as it has the highest information density per digit and will thus overflow the earliest:\n+        // `u8::MAX` is `ff` - any str of len 2 is guaranteed to not overflow.\n+        // `i8::MAX` is `7f` - only a str of len 1 is guaranteed to not overflow.\n+        macro_rules! run_unchecked_loop {\n+            ($unchecked_additive_op:expr) => {\n+                for &c in digits {\n+                    result = result * T::from_u32(radix);\n+                    let x = (c as char).to_digit(radix).ok_or(PIE { kind: InvalidDigit })?;\n+                    result = $unchecked_additive_op(result, T::from_u32(x));\n+                }\n             };\n         }\n+        if is_positive {\n+            run_unchecked_loop!(<T as core::ops::Add>::add)\n+        } else {\n+            run_unchecked_loop!(<T as core::ops::Sub>::sub)\n+        };\n     } else {\n-        // The number is negative\n-        for &c in digits {\n-            let x = match (c as char).to_digit(radix) {\n-                Some(x) => x,\n-                None => return Err(PIE { kind: InvalidDigit }),\n-            };\n-            result = match result.checked_mul(radix) {\n-                Some(result) => result,\n-                None => return Err(PIE { kind: NegOverflow }),\n-            };\n-            result = match result.checked_sub(x) {\n-                Some(result) => result,\n-                None => return Err(PIE { kind: NegOverflow }),\n+        macro_rules! run_checked_loop {\n+            ($checked_additive_op:ident, $overflow_err:expr) => {\n+                for &c in digits {\n+                    // When `radix` is passed in as a literal, rather than doing a slow `imul`\n+                    // the compiler can use shifts if `radix` can be expressed as a\n+                    // sum of powers of 2 (x*10 can be written as x*8 + x*2).\n+                    // When the compiler can't use these optimisations,\n+                    // the latency of the multiplication can be hidden by issuing it\n+                    // before the result is needed to improve performance on\n+                    // modern out-of-order CPU as multiplication here is slower\n+                    // than the other instructions, we can get the end result faster\n+                    // doing multiplication first and let the CPU spends other cycles\n+                    // doing other computation and get multiplication result later.\n+                    let mul = result.checked_mul(radix);\n+                    let x = (c as char).to_digit(radix).ok_or(PIE { kind: InvalidDigit })?;\n+                    result = mul.ok_or_else($overflow_err)?;\n+                    result = T::$checked_additive_op(&result, x).ok_or_else($overflow_err)?;\n+                }\n             };\n         }\n+        if is_positive {\n+            run_checked_loop!(checked_add, || PIE { kind: PosOverflow })\n+        } else {\n+            run_checked_loop!(checked_sub, || PIE { kind: NegOverflow })\n+        };\n     }\n     Ok(result)\n }"}, {"sha": "447a6fcf7567e5c4242676c32fe0a4d6a3f7bae8", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4e1927db3c399fa34dc71992bd5dbec09f945c3d/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e1927db3c399fa34dc71992bd5dbec09f945c3d/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=4e1927db3c399fa34dc71992bd5dbec09f945c3d", "patch": "@@ -53,6 +53,7 @@\n #![feature(numfmt)]\n #![feature(step_trait)]\n #![feature(str_internals)]\n+#![feature(std_internals)]\n #![feature(test)]\n #![feature(trusted_len)]\n #![feature(try_blocks)]"}, {"sha": "49580cdcc481a98e690a56f33f0538975e111db3", "filename": "library/core/tests/num/mod.rs", "status": "modified", "additions": 70, "deletions": 1, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/4e1927db3c399fa34dc71992bd5dbec09f945c3d/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e1927db3c399fa34dc71992bd5dbec09f945c3d/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fmod.rs?ref=4e1927db3c399fa34dc71992bd5dbec09f945c3d", "patch": "@@ -2,7 +2,7 @@ use core::cmp::PartialEq;\n use core::convert::{TryFrom, TryInto};\n use core::fmt::Debug;\n use core::marker::Copy;\n-use core::num::{IntErrorKind, ParseIntError, TryFromIntError};\n+use core::num::{can_not_overflow, IntErrorKind, ParseIntError, TryFromIntError};\n use core::ops::{Add, Div, Mul, Rem, Sub};\n use core::option::Option;\n use core::option::Option::None;\n@@ -120,6 +120,75 @@ fn test_int_from_str_overflow() {\n     test_parse::<i64>(\"-9223372036854775809\", Err(IntErrorKind::NegOverflow));\n }\n \n+#[test]\n+fn test_can_not_overflow() {\n+    fn can_overflow<T>(radix: u32, input: &str) -> bool\n+    where\n+        T: std::convert::TryFrom<i8>,\n+    {\n+        !can_not_overflow::<T>(radix, T::try_from(-1_i8).is_ok(), input.as_bytes())\n+    }\n+\n+    // Positive tests:\n+    assert!(!can_overflow::<i8>(16, \"F\"));\n+    assert!(!can_overflow::<u8>(16, \"FF\"));\n+\n+    assert!(!can_overflow::<i8>(10, \"9\"));\n+    assert!(!can_overflow::<u8>(10, \"99\"));\n+\n+    // Negative tests:\n+\n+    // Not currently in std lib (issue: #27728)\n+    fn format_radix<T>(mut x: T, radix: T) -> String\n+    where\n+        T: std::ops::Rem<Output = T>,\n+        T: std::ops::Div<Output = T>,\n+        T: std::cmp::PartialEq,\n+        T: std::default::Default,\n+        T: Copy,\n+        T: Default,\n+        u32: TryFrom<T>,\n+    {\n+        let mut result = vec![];\n+\n+        loop {\n+            let m = x % radix;\n+            x = x / radix;\n+            result.push(\n+                std::char::from_digit(m.try_into().ok().unwrap(), radix.try_into().ok().unwrap())\n+                    .unwrap(),\n+            );\n+            if x == T::default() {\n+                break;\n+            }\n+        }\n+        result.into_iter().rev().collect()\n+    }\n+\n+    macro_rules! check {\n+        ($($t:ty)*) => ($(\n+        for base in 2..=36 {\n+            let num = (<$t>::MAX as u128) + 1;\n+\n+           // Calcutate the string length for the smallest overflowing number:\n+           let max_len_string = format_radix(num, base as u128);\n+           // Ensure that that string length is deemed to potentially overflow:\n+           assert!(can_overflow::<$t>(base, &max_len_string));\n+        }\n+        )*)\n+    }\n+\n+    check! { i8 i16 i32 i64 i128 isize usize u8 u16 u32 u64 }\n+\n+    // Check u128 separately:\n+    for base in 2..=36 {\n+        let num = u128::MAX as u128;\n+        let max_len_string = format_radix(num, base as u128);\n+        // base 16 fits perfectly for u128 and won't overflow:\n+        assert_eq!(can_overflow::<u128>(base, &max_len_string), base != 16);\n+    }\n+}\n+\n #[test]\n fn test_leading_plus() {\n     test_parse::<u8>(\"+127\", Ok(127));"}]}