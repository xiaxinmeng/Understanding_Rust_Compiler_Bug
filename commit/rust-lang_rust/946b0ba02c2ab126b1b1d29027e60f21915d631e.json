{"sha": "946b0ba02c2ab126b1b1d29027e60f21915d631e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0NmIwYmEwMmMyYWIxMjZiMWIxZDI5MDI3ZTYwZjIxOTE1ZDYzMWU=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-01-08T13:40:41Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-01-08T14:16:24Z"}, "message": "Fix name resolution across source roots\n\nIt was using the wrong name in that case.", "tree": {"sha": "c1f4896435ecfa48470e08787a24a5e3b73cc4fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1f4896435ecfa48470e08787a24a5e3b73cc4fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/946b0ba02c2ab126b1b1d29027e60f21915d631e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/946b0ba02c2ab126b1b1d29027e60f21915d631e", "html_url": "https://github.com/rust-lang/rust/commit/946b0ba02c2ab126b1b1d29027e60f21915d631e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/946b0ba02c2ab126b1b1d29027e60f21915d631e/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4b44a092f1fd5267a02719667d8d5e22ba0d904", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4b44a092f1fd5267a02719667d8d5e22ba0d904", "html_url": "https://github.com/rust-lang/rust/commit/d4b44a092f1fd5267a02719667d8d5e22ba0d904"}], "stats": {"total": 192, "additions": 173, "deletions": 19}, "files": [{"sha": "c9af38009d7f1b61b1029d2f25f43529e3b87b2e", "filename": "crates/ra_hir/src/mock.rs", "status": "modified", "additions": 36, "deletions": 11, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/946b0ba02c2ab126b1b1d29027e60f21915d631e/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946b0ba02c2ab126b1b1d29027e60f21915d631e/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=946b0ba02c2ab126b1b1d29027e60f21915d631e", "patch": "@@ -15,6 +15,7 @@ pub(crate) struct MockDatabase {\n     events: Mutex<Option<Vec<salsa::Event<MockDatabase>>>>,\n     runtime: salsa::Runtime<MockDatabase>,\n     id_maps: Arc<IdMaps>,\n+    file_counter: u32,\n }\n \n impl MockDatabase {\n@@ -27,7 +28,7 @@ impl MockDatabase {\n     pub(crate) fn with_single_file(text: &str) -> (MockDatabase, SourceRoot, FileId) {\n         let mut db = MockDatabase::default();\n         let mut source_root = SourceRoot::default();\n-        let file_id = db.add_file(&mut source_root, \"/main.rs\", text);\n+        let file_id = db.add_file(WORKSPACE, &mut source_root, \"/main.rs\", text);\n         db.query_mut(ra_db::SourceRootQuery)\n             .set(WORKSPACE, Arc::new(source_root.clone()));\n \n@@ -51,6 +52,16 @@ impl MockDatabase {\n     fn from_fixture(fixture: &str) -> (MockDatabase, SourceRoot, Option<FilePosition>) {\n         let mut db = MockDatabase::default();\n \n+        let (source_root, pos) = db.add_fixture(WORKSPACE, fixture);\n+\n+        (db, source_root, pos)\n+    }\n+\n+    pub fn add_fixture(\n+        &mut self,\n+        source_root_id: SourceRootId,\n+        fixture: &str,\n+    ) -> (SourceRoot, Option<FilePosition>) {\n         let mut position = None;\n         let mut source_root = SourceRoot::default();\n         for entry in parse_fixture(fixture) {\n@@ -59,39 +70,51 @@ impl MockDatabase {\n                     position.is_none(),\n                     \"only one marker (<|>) per fixture is allowed\"\n                 );\n-                position =\n-                    Some(db.add_file_with_position(&mut source_root, &entry.meta, &entry.text));\n+                position = Some(self.add_file_with_position(\n+                    source_root_id,\n+                    &mut source_root,\n+                    &entry.meta,\n+                    &entry.text,\n+                ));\n             } else {\n-                db.add_file(&mut source_root, &entry.meta, &entry.text);\n+                self.add_file(source_root_id, &mut source_root, &entry.meta, &entry.text);\n             }\n         }\n-        db.query_mut(ra_db::SourceRootQuery)\n-            .set(WORKSPACE, Arc::new(source_root.clone()));\n-        (db, source_root, position)\n+        self.query_mut(ra_db::SourceRootQuery)\n+            .set(source_root_id, Arc::new(source_root.clone()));\n+        (source_root, position)\n     }\n \n-    fn add_file(&mut self, source_root: &mut SourceRoot, path: &str, text: &str) -> FileId {\n+    fn add_file(\n+        &mut self,\n+        source_root_id: SourceRootId,\n+        source_root: &mut SourceRoot,\n+        path: &str,\n+        text: &str,\n+    ) -> FileId {\n         assert!(path.starts_with('/'));\n         let path = RelativePathBuf::from_path(&path[1..]).unwrap();\n-        let file_id = FileId(source_root.files.len() as u32);\n+        let file_id = FileId(self.file_counter);\n+        self.file_counter += 1;\n         let text = Arc::new(text.to_string());\n         self.query_mut(ra_db::FileTextQuery).set(file_id, text);\n         self.query_mut(ra_db::FileRelativePathQuery)\n             .set(file_id, path.clone());\n         self.query_mut(ra_db::FileSourceRootQuery)\n-            .set(file_id, WORKSPACE);\n+            .set(file_id, source_root_id);\n         source_root.files.insert(path, file_id);\n         file_id\n     }\n \n     fn add_file_with_position(\n         &mut self,\n+        source_root_id: SourceRootId,\n         source_root: &mut SourceRoot,\n         path: &str,\n         text: &str,\n     ) -> FilePosition {\n         let (offset, text) = extract_offset(text);\n-        let file_id = self.add_file(source_root, path, &text);\n+        let file_id = self.add_file(source_root_id, source_root, path, &text);\n         FilePosition { file_id, offset }\n     }\n }\n@@ -121,6 +144,7 @@ impl Default for MockDatabase {\n             events: Default::default(),\n             runtime: salsa::Runtime::default(),\n             id_maps: Default::default(),\n+            file_counter: 0,\n         };\n         db.query_mut(ra_db::CrateGraphQuery)\n             .set((), Default::default());\n@@ -138,6 +162,7 @@ impl salsa::ParallelDatabase for MockDatabase {\n             events: Default::default(),\n             runtime: self.runtime.snapshot(self),\n             id_maps: self.id_maps.clone(),\n+            file_counter: self.file_counter,\n         })\n     }\n }"}, {"sha": "20adc9ec48814dde717225da433a7d64d955e1c4", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 41, "deletions": 7, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/946b0ba02c2ab126b1b1d29027e60f21915d631e/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946b0ba02c2ab126b1b1d29027e60f21915d631e/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=946b0ba02c2ab126b1b1d29027e60f21915d631e", "patch": "@@ -433,13 +433,15 @@ where\n                 continue;\n             }\n             if self.resolve_import(module_id, import)? {\n+                log::debug!(\"import {:?} resolved (or definite error)\", import);\n                 self.processed_imports.insert((module_id, i));\n             }\n         }\n         Ok(())\n     }\n \n     fn resolve_import(&mut self, module_id: ModuleId, import: &Import) -> Cancelable<bool> {\n+        log::debug!(\"resolving import: {:?}\", import);\n         let ptr = match import.kind {\n             ImportKind::Glob => return Ok(false),\n             ImportKind::Named(ptr) => ptr,\n@@ -450,8 +452,11 @@ where\n             PathKind::Super => {\n                 match module_id.parent(&self.module_tree) {\n                     Some(it) => it,\n-                    // TODO: error\n-                    None => return Ok(true), // this can't suddenly resolve if we just resolve some other imports\n+                    None => {\n+                        // TODO: error\n+                        log::debug!(\"super path in root module\");\n+                        return Ok(true); // this can't suddenly resolve if we just resolve some other imports\n+                    }\n                 }\n             }\n             PathKind::Crate => module_id.crate_root(&self.module_tree),\n@@ -462,13 +467,20 @@ where\n \n             let def_id = match self.result.per_module[&curr].items.get(name) {\n                 Some(res) if !res.def_id.is_none() => res.def_id,\n-                _ => return Ok(false),\n+                _ => {\n+                    log::debug!(\"path segment {:?} not found\", name);\n+                    return Ok(false);\n+                }\n             };\n \n             if !is_last {\n                 let type_def_id = if let Some(d) = def_id.take(Namespace::Types) {\n                     d\n                 } else {\n+                    log::debug!(\n+                        \"path segment {:?} resolved to value only, but is not last\",\n+                        name\n+                    );\n                     return Ok(false);\n                 };\n                 curr = match type_def_id.loc(self.db) {\n@@ -486,27 +498,49 @@ where\n                                 segments: import.path.segments[i + 1..].iter().cloned().collect(),\n                                 kind: PathKind::Crate,\n                             };\n+                            log::debug!(\"resolving {:?} in other source root\", path);\n                             let def_id = module.resolve_path(self.db, &path)?;\n                             if !def_id.is_none() {\n+                                let name = path.segments.last().unwrap();\n                                 self.update(module_id, |items| {\n                                     let res = Resolution {\n-                                        def_id: def_id,\n+                                        def_id,\n                                         import: Some(ptr),\n                                     };\n                                     items.items.insert(name.clone(), res);\n                                 });\n+                                log::debug!(\n+                                    \"resolved import {:?} ({:?}) cross-source root to {:?}\",\n+                                    name,\n+                                    import,\n+                                    def_id.map(|did| did.loc(self.db))\n+                                );\n                                 return Ok(true);\n                             } else {\n-                                return Ok(false);\n+                                log::debug!(\"rest of path did not resolve in other source root\");\n+                                return Ok(true);\n                             }\n                         }\n                     }\n-                    _ => return Ok(true), // this resolved to a non-module, so the path won't ever resolve\n+                    _ => {\n+                        log::debug!(\n+                            \"path segment {:?} resolved to non-module {:?}, but is not last\",\n+                            name,\n+                            type_def_id.loc(self.db)\n+                        );\n+                        return Ok(true); // this resolved to a non-module, so the path won't ever resolve\n+                    }\n                 }\n             } else {\n+                log::debug!(\n+                    \"resolved import {:?} ({:?}) within source root to {:?}\",\n+                    name,\n+                    import,\n+                    def_id.map(|did| did.loc(self.db))\n+                );\n                 self.update(module_id, |items| {\n                     let res = Resolution {\n-                        def_id: def_id,\n+                        def_id,\n                         import: Some(ptr),\n                     };\n                     items.items.insert(name.clone(), res);"}, {"sha": "c511c40b25e83b2ff73bb736b23e36ae42f46660", "filename": "crates/ra_hir/src/nameres/tests.rs", "status": "modified", "additions": 96, "deletions": 1, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/946b0ba02c2ab126b1b1d29027e60f21915d631e/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946b0ba02c2ab126b1b1d29027e60f21915d631e/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs?ref=946b0ba02c2ab126b1b1d29027e60f21915d631e", "patch": "@@ -1,7 +1,7 @@\n use std::sync::Arc;\n \n use salsa::Database;\n-use ra_db::{FilesDatabase, CrateGraph};\n+use ra_db::{FilesDatabase, CrateGraph, SourceRootId};\n use relative_path::RelativePath;\n use test_utils::assert_eq_text;\n \n@@ -227,6 +227,101 @@ fn item_map_across_crates() {\n     );\n }\n \n+#[test]\n+fn import_across_source_roots() {\n+    let (mut db, sr) = MockDatabase::with_files(\n+        \"\n+        //- /lib.rs\n+        pub mod a {\n+            pub mod b {\n+                pub struct C;\n+            }\n+        }\n+    \",\n+    );\n+    let lib_id = sr.files[RelativePath::new(\"/lib.rs\")];\n+\n+    let source_root = SourceRootId(1);\n+\n+    let (sr2, pos) = db.add_fixture(\n+        source_root,\n+        \"\n+        //- /main.rs\n+        use test_crate::a::b::C;\n+    \",\n+    );\n+    assert!(pos.is_none());\n+\n+    let main_id = sr2.files[RelativePath::new(\"/main.rs\")];\n+\n+    eprintln!(\"lib = {:?}, main = {:?}\", lib_id, main_id);\n+\n+    let mut crate_graph = CrateGraph::default();\n+    let main_crate = crate_graph.add_crate_root(main_id);\n+    let lib_crate = crate_graph.add_crate_root(lib_id);\n+    crate_graph.add_dep(main_crate, \"test_crate\".into(), lib_crate);\n+\n+    db.set_crate_graph(crate_graph);\n+\n+    let module = crate::source_binder::module_from_file_id(&db, main_id)\n+        .unwrap()\n+        .unwrap();\n+    let module_id = module.def_id.loc(&db).module_id;\n+    let item_map = db.item_map(source_root).unwrap();\n+\n+    check_module_item_map(\n+        &item_map,\n+        module_id,\n+        \"\n+            C: t v\n+            test_crate: t\n+        \",\n+    );\n+}\n+\n+#[test]\n+fn reexport_across_crates() {\n+    let (mut db, sr) = MockDatabase::with_files(\n+        \"\n+        //- /main.rs\n+        use test_crate::Baz;\n+\n+        //- /lib.rs\n+        pub use foo::Baz;\n+\n+        mod foo;\n+\n+        //- /foo.rs\n+        pub struct Baz;\n+    \",\n+    );\n+    let main_id = sr.files[RelativePath::new(\"/main.rs\")];\n+    let lib_id = sr.files[RelativePath::new(\"/lib.rs\")];\n+\n+    let mut crate_graph = CrateGraph::default();\n+    let main_crate = crate_graph.add_crate_root(main_id);\n+    let lib_crate = crate_graph.add_crate_root(lib_id);\n+    crate_graph.add_dep(main_crate, \"test_crate\".into(), lib_crate);\n+\n+    db.set_crate_graph(crate_graph);\n+\n+    let source_root = db.file_source_root(main_id);\n+    let module = crate::source_binder::module_from_file_id(&db, main_id)\n+        .unwrap()\n+        .unwrap();\n+    let module_id = module.def_id.loc(&db).module_id;\n+    let item_map = db.item_map(source_root).unwrap();\n+\n+    check_module_item_map(\n+        &item_map,\n+        module_id,\n+        \"\n+            Baz: t v\n+            test_crate: t\n+        \",\n+    );\n+}\n+\n #[test]\n fn typing_inside_a_function_should_not_invalidate_item_map() {\n     let (mut db, pos) = MockDatabase::with_position("}]}