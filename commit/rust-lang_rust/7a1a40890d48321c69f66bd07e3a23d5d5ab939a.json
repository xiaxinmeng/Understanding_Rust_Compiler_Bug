{"sha": "7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhMWE0MDg5MGQ0ODMyMWM2OWY2NmJkMDdlM2EyM2Q1ZDVhYjkzOWE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-29T23:59:33Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-30T19:20:36Z"}, "message": "Remove copy bindings from patterns.", "tree": {"sha": "54eb8701f89acc95b05a2de5cfcd5c9be2742a3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54eb8701f89acc95b05a2de5cfcd5c9be2742a3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "html_url": "https://github.com/rust-lang/rust/commit/7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5209709e46ecfac2fd4db527952fe7ef96400801", "url": "https://api.github.com/repos/rust-lang/rust/commits/5209709e46ecfac2fd4db527952fe7ef96400801", "html_url": "https://github.com/rust-lang/rust/commit/5209709e46ecfac2fd4db527952fe7ef96400801"}], "stats": {"total": 377, "additions": 176, "deletions": 201}, "files": [{"sha": "eb8c27e9902b5bb047b247f49e5dc0ab5143236a", "filename": "src/libextra/fun_treemap.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibextra%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibextra%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffun_treemap.rs?ref=7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "patch": "@@ -35,13 +35,13 @@ enum TreeNode<K, V> {\n pub fn init<K, V>() -> Treemap<K, V> { @Empty }\n \n /// Insert a value into the map\n-pub fn insert<K:Copy + Eq + Ord,V:Copy>(m: Treemap<K, V>, k: K, v: V) -> Treemap<K, V> {\n+pub fn insert<K:Eq + Ord,V>(m: Treemap<K, V>, k: K, v: V) -> Treemap<K, V> {\n     @match m {\n         @Empty => Node(@k, @v, @Empty, @Empty),\n-        @Node(@copy kk, vv, left, right) => cond!(\n-            (k <  kk) { Node(@kk, vv, insert(left, k, v), right) }\n-            (k == kk) { Node(@kk, @v, left, right)               }\n-            _         { Node(@kk, vv, left, insert(right, k, v)) }\n+        @Node(kk, vv, left, right) => cond!(\n+            (k <  *kk) { Node(kk, vv, insert(left, k, v), right) }\n+            (k == *kk) { Node(kk, @v, left, right)               }\n+            _          { Node(kk, vv, left, insert(right, k, v)) }\n         )\n     }\n }\n@@ -50,8 +50,8 @@ pub fn insert<K:Copy + Eq + Ord,V:Copy>(m: Treemap<K, V>, k: K, v: V) -> Treemap\n pub fn find<K:Eq + Ord,V:Copy>(m: Treemap<K, V>, k: K) -> Option<V> {\n     match *m {\n         Empty => None,\n-        Node(@ref kk, @copy v, left, right) => cond!(\n-            (k == *kk) { Some(v)        }\n+        Node(kk, v, left, right) => cond!(\n+            (k == *kk) { Some(copy *v)  }\n             (k <  *kk) { find(left, k)  }\n             _          { find(right, k) }\n         )"}, {"sha": "eb5699df77f6d0aebbbd181170ddf28488dbdd1a", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "patch": "@@ -171,7 +171,7 @@ fn is_arg(arg: &str) -> bool {\n fn name_str(nm: &Name) -> ~str {\n     return match *nm {\n       Short(ch) => str::from_char(ch),\n-      Long(copy s) => s\n+      Long(ref s) => copy *s\n     };\n }\n \n@@ -390,7 +390,7 @@ pub fn opts_present(mm: &Matches, names: &[~str]) -> bool {\n  * argument\n  */\n pub fn opt_str(mm: &Matches, nm: &str) -> ~str {\n-    return match opt_val(mm, nm) { Val(copy s) => s, _ => fail!() };\n+    return match opt_val(mm, nm) { Val(s) => s, _ => fail!() };\n }\n \n /**\n@@ -402,7 +402,7 @@ pub fn opt_str(mm: &Matches, nm: &str) -> ~str {\n pub fn opts_str(mm: &Matches, names: &[~str]) -> ~str {\n     for names.each |nm| {\n         match opt_val(mm, *nm) {\n-          Val(copy s) => return s,\n+          Val(ref s) => return copy *s,\n           _ => ()\n         }\n     }\n@@ -419,7 +419,7 @@ pub fn opts_str(mm: &Matches, names: &[~str]) -> ~str {\n pub fn opt_strs(mm: &Matches, nm: &str) -> ~[~str] {\n     let mut acc: ~[~str] = ~[];\n     for vec::each(opt_vals(mm, nm)) |v| {\n-        match *v { Val(copy s) => acc.push(s), _ => () }\n+        match *v { Val(ref s) => acc.push(copy *s), _ => () }\n     }\n     return acc;\n }\n@@ -429,7 +429,7 @@ pub fn opt_maybe_str(mm: &Matches, nm: &str) -> Option<~str> {\n     let vals = opt_vals(mm, nm);\n     if vec::len::<Optval>(vals) == 0u { return None::<~str>; }\n     return match vals[0] {\n-        Val(copy s) => Some(s),\n+        Val(ref s) => Some(copy *s),\n         _ => None\n     };\n }\n@@ -445,7 +445,7 @@ pub fn opt_maybe_str(mm: &Matches, nm: &str) -> Option<~str> {\n pub fn opt_default(mm: &Matches, nm: &str, def: &str) -> Option<~str> {\n     let vals = opt_vals(mm, nm);\n     if vec::len::<Optval>(vals) == 0u { return None::<~str>; }\n-    return match vals[0] { Val(copy s) => Some::<~str>(s),\n+    return match vals[0] { Val(ref s) => Some::<~str>(copy *s),\n                            _      => Some::<~str>(str::to_owned(def)) }\n }\n \n@@ -701,7 +701,7 @@ mod tests {\n         let opts = ~[reqopt(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, OptionMissing_),\n+          Err(f) => check_fail_type(f, OptionMissing_),\n           _ => fail!()\n         }\n     }\n@@ -712,7 +712,7 @@ mod tests {\n         let opts = ~[reqopt(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, ArgumentMissing_),\n+          Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n     }\n@@ -723,7 +723,7 @@ mod tests {\n         let opts = ~[reqopt(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, OptionDuplicated_),\n+          Err(f) => check_fail_type(f, OptionDuplicated_),\n           _ => fail!()\n         }\n     }\n@@ -748,7 +748,7 @@ mod tests {\n         let opts = ~[reqopt(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, OptionMissing_),\n+          Err(f) => check_fail_type(f, OptionMissing_),\n           _ => fail!()\n         }\n     }\n@@ -759,7 +759,7 @@ mod tests {\n         let opts = ~[reqopt(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, ArgumentMissing_),\n+          Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n     }\n@@ -770,7 +770,7 @@ mod tests {\n         let opts = ~[reqopt(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, OptionDuplicated_),\n+          Err(f) => check_fail_type(f, OptionDuplicated_),\n           _ => fail!()\n         }\n     }\n@@ -808,7 +808,7 @@ mod tests {\n         let opts = ~[optopt(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, ArgumentMissing_),\n+          Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n     }\n@@ -819,7 +819,7 @@ mod tests {\n         let opts = ~[optopt(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, OptionDuplicated_),\n+          Err(f) => check_fail_type(f, OptionDuplicated_),\n           _ => fail!()\n         }\n     }\n@@ -855,7 +855,7 @@ mod tests {\n         let opts = ~[optopt(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, ArgumentMissing_),\n+          Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n     }\n@@ -866,7 +866,7 @@ mod tests {\n         let opts = ~[optopt(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, OptionDuplicated_),\n+          Err(f) => check_fail_type(f, OptionDuplicated_),\n           _ => fail!()\n         }\n     }\n@@ -901,7 +901,7 @@ mod tests {\n         let opts = ~[optflag(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => {\n+          Err(f) => {\n             error!(fail_str(copy f));\n             check_fail_type(f, UnexpectedArgument_);\n           }\n@@ -915,7 +915,7 @@ mod tests {\n         let opts = ~[optflag(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, OptionDuplicated_),\n+          Err(f) => check_fail_type(f, OptionDuplicated_),\n           _ => fail!()\n         }\n     }\n@@ -963,7 +963,7 @@ mod tests {\n         let opts = ~[optflag(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, OptionDuplicated_),\n+          Err(f) => check_fail_type(f, OptionDuplicated_),\n           _ => fail!()\n         }\n     }\n@@ -1066,7 +1066,7 @@ mod tests {\n         let opts = ~[optmulti(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, ArgumentMissing_),\n+          Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n     }\n@@ -1119,7 +1119,7 @@ mod tests {\n         let opts = ~[optmulti(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, ArgumentMissing_),\n+          Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n     }\n@@ -1147,7 +1147,7 @@ mod tests {\n         let opts = ~[optmulti(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, UnrecognizedOption_),\n+          Err(f) => check_fail_type(f, UnrecognizedOption_),\n           _ => fail!()\n         }\n     }\n@@ -1158,7 +1158,7 @@ mod tests {\n         let opts = ~[optmulti(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, UnrecognizedOption_),\n+          Err(f) => check_fail_type(f, UnrecognizedOption_),\n           _ => fail!()\n         }\n     }"}, {"sha": "d69548c6f9d2d2192840660640675f40746105fe", "filename": "src/libextra/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "patch": "@@ -1384,7 +1384,7 @@ mod tests {\n \n         for items.each |item| {\n             match *item {\n-                (copy key, copy value) => { d.insert(key, value); },\n+                (ref key, ref value) => { d.insert(copy *key, copy *value); },\n             }\n         };\n "}, {"sha": "7a38be8944f974ec4f26dae7a012fefcb116c642", "filename": "src/libextra/list.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibextra%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibextra%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flist.rs?ref=7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "patch": "@@ -104,7 +104,7 @@ pub fn tail<T:Copy>(ls: @List<T>) -> @List<T> {\n /// Returns the first element of a list\n pub fn head<T:Copy>(ls: @List<T>) -> T {\n     match *ls {\n-      Cons(copy hd, _) => hd,\n+      Cons(ref hd, _) => copy *hd,\n       // makes me sad\n       _ => fail!(\"head invoked on empty list\")\n     }\n@@ -114,9 +114,9 @@ pub fn head<T:Copy>(ls: @List<T>) -> T {\n pub fn append<T:Copy>(l: @List<T>, m: @List<T>) -> @List<T> {\n     match *l {\n       Nil => return m,\n-      Cons(copy x, xs) => {\n+      Cons(ref x, xs) => {\n         let rest = append(xs, m);\n-        return @Cons(x, rest);\n+        return @Cons(copy *x, rest);\n       }\n     }\n }"}, {"sha": "ddbf09e40eb92a75bee5cb83d0acb8787af9c6f1", "filename": "src/libextra/net_ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibextra%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibextra%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_ip.rs?ref=7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "patch": "@@ -278,7 +278,7 @@ pub mod v6 {\n     pub fn parse_addr(ip: &str) -> IpAddr {\n         match try_parse_addr(ip) {\n           result::Ok(addr) => addr,\n-          result::Err(copy err_data) => fail!(copy err_data.err_msg)\n+          result::Err(err_data) => fail!(copy err_data.err_msg)\n         }\n     }\n     pub fn try_parse_addr(ip: &str) -> result::Result<IpAddr,ParseAddrErr> {"}, {"sha": "d658ad6551f241bae06bfa064c349709473df014", "filename": "src/libextra/net_tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibextra%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibextra%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_tcp.rs?ref=7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "patch": "@@ -595,7 +595,7 @@ pub fn accept(new_conn: TcpNewConnection)\n                 }\n                 // UNSAFE LIBUV INTERACTION END\n                 match result_po.recv() {\n-                    Some(copy err_data) => result::Err(err_data),\n+                    Some(err_data) => result::Err(err_data),\n                     None => result::Ok(TcpSocket(client_socket_data))\n                 }\n             }"}, {"sha": "375b4cd5fb551c6ae2496f7f59b6b8072475c054", "filename": "src/libextra/test.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "patch": "@@ -223,7 +223,7 @@ pub fn run_tests_console(opts: &TestOpts,\n           }\n           TeWait(ref test) => st.out.write_str(\n               fmt!(\"test %s ... \", test.name.to_str())),\n-          TeResult(copy test, result) => {\n+          TeResult(test, result) => {\n             match st.log_out {\n                 Some(f) => write_log(f, copy result, &test),\n                 None => ()\n@@ -504,9 +504,8 @@ pub fn filter_tests(\n     filtered = if opts.filter.is_none() {\n         filtered\n     } else {\n-        let filter_str =\n-            match opts.filter {\n-          option::Some(copy f) => f,\n+        let filter_str = match opts.filter {\n+          option::Some(ref f) => copy *f,\n           option::None => ~\"\"\n         };\n \n@@ -866,7 +865,7 @@ mod tests {\n     fn first_free_arg_should_be_a_filter() {\n         let args = ~[~\"progname\", ~\"filter\"];\n         let opts = match parse_opts(args) {\n-          either::Left(copy o) => o,\n+          either::Left(o) => o,\n           _ => fail!(\"Malformed arg in first_free_arg_should_be_a_filter\")\n         };\n         assert!(\"filter\" == (copy opts.filter).get());\n@@ -876,7 +875,7 @@ mod tests {\n     fn parse_ignored_flag() {\n         let args = ~[~\"progname\", ~\"filter\", ~\"--ignored\"];\n         let opts = match parse_opts(args) {\n-          either::Left(copy o) => o,\n+          either::Left(o) => o,\n           _ => fail!(\"Malformed arg in parse_ignored_flag\")\n         };\n         assert!((opts.run_ignored));"}, {"sha": "1a3a5db66aef9b67c1e75468cedbda4f0bf6a901", "filename": "src/libextra/time.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "patch": "@@ -275,10 +275,12 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n         let mut i = 0u;\n         let len = strs.len();\n         while i < len {\n-            let &(needle, value) = &strs[i];\n-\n-            if match_str(ss, pos, needle) {\n-                return Some((value, pos + str::len(needle)));\n+            match strs[i] { // can't use let due to stage0 bugs\n+                (ref needle, value) => {\n+                    if match_str(ss, pos, *needle) {\n+                        return Some((value, pos + str::len(*needle)));\n+                    }\n+                }\n             }\n             i += 1u;\n         }\n@@ -1007,7 +1009,7 @@ mod tests {\n             == Err(~\"Invalid time\"));\n \n         match strptime(\"Fri Feb 13 15:31:30 2009\", format) {\n-          Err(copy e) => fail!(e),\n+          Err(e) => fail!(e),\n           Ok(ref tm) => {\n             assert!(tm.tm_sec == 30_i32);\n             assert!(tm.tm_min == 31_i32);\n@@ -1027,7 +1029,7 @@ mod tests {\n         fn test(s: &str, format: &str) -> bool {\n             match strptime(s, format) {\n               Ok(ref tm) => tm.strftime(format) == str::to_owned(s),\n-              Err(copy e) => fail!(e)\n+              Err(e) => fail!(e)\n             }\n         }\n "}, {"sha": "472ce5c926e5b25e9a7b15afe9d2078dce2f18c3", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "patch": "@@ -375,8 +375,8 @@ pub mod write {\n \n     pub fn run_ndk(sess: Session, assembly: &Path, object: &Path) {\n         let cc_prog: ~str = match &sess.opts.android_cross_path {\n-            &Some(copy path) => {\n-                fmt!(\"%s/bin/arm-linux-androideabi-gcc\", path)\n+            &Some(ref path) => {\n+                fmt!(\"%s/bin/arm-linux-androideabi-gcc\", *path)\n             }\n             &None => {\n                 sess.fatal(\"need Android NDK path for building \\\n@@ -763,12 +763,12 @@ pub fn link_binary(sess: Session,\n     // For win32, there is no cc command,\n     // so we add a condition to make it use gcc.\n     let cc_prog: ~str = match sess.opts.linker {\n-        Some(copy linker) => linker,\n+        Some(ref linker) => copy *linker,\n         None => {\n             if sess.targ_cfg.os == session::os_android {\n                 match &sess.opts.android_cross_path {\n-                    &Some(copy path) => {\n-                        fmt!(\"%s/bin/arm-linux-androideabi-gcc\", path)\n+                    &Some(ref path) => {\n+                        fmt!(\"%s/bin/arm-linux-androideabi-gcc\", *path)\n                     }\n                     &None => {\n                         sess.fatal(\"need Android NDK path for linking \\"}, {"sha": "5e33a8f78fea81f0023d9cdf3bd3a2aec662ca76", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "patch": "@@ -956,8 +956,8 @@ mod test {\n     fn test_switch_implies_cfg_test() {\n         let matches =\n             &match getopts([~\"--test\"], optgroups()) {\n-              Ok(copy m) => m,\n-              Err(copy f) => fail!(\"test_switch_implies_cfg_test: %s\", getopts::fail_str(f))\n+              Ok(m) => m,\n+              Err(f) => fail!(\"test_switch_implies_cfg_test: %s\", getopts::fail_str(f))\n             };\n         let sessopts = build_session_options(\n             @~\"rustc\", matches, diagnostic::emit);\n@@ -972,8 +972,8 @@ mod test {\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n         let matches =\n             &match getopts([~\"--test\", ~\"--cfg=test\"], optgroups()) {\n-              Ok(copy m) => m,\n-              Err(copy f) => {\n+              Ok(m) => m,\n+              Err(f) => {\n                 fail!(\"test_switch_implies_cfg_test_unless_cfg_test: %s\", getopts::fail_str(f));\n               }\n             };"}, {"sha": "0e263c78bfe22f0c887b3f5d8f429f592a65b12e", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "patch": "@@ -141,10 +141,10 @@ fn visit_crate(e: @mut Env, c: &ast::crate) {\n \n fn visit_view_item(e: @mut Env, i: @ast::view_item) {\n     match i.node {\n-      ast::view_item_extern_mod(ident, /*bad*/copy meta_items, id) => {\n+      ast::view_item_extern_mod(ident, ref meta_items, id) => {\n         debug!(\"resolving extern mod stmt. ident: %?, meta: %?\",\n-               ident, meta_items);\n-        let cnum = resolve_crate(e, ident, meta_items, @~\"\", i.span);\n+               ident, *meta_items);\n+        let cnum = resolve_crate(e, ident, copy *meta_items, @~\"\", i.span);\n         cstore::add_extern_mod_stmt_cnum(e.cstore, id, cnum);\n       }\n       _ => ()"}, {"sha": "552476d25d6f4bcff2ea6950036c736ced8e32bc", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "patch": "@@ -623,7 +623,7 @@ pub impl GatherLoanCtxt {\n                                              cmt, mutbl, scope_r);\n                     }\n                   }\n-                  ast::bind_by_copy | ast::bind_infer => {\n+                  ast::bind_infer => {\n                       // No borrows here, but there may be moves\n                       if self.bccx.is_move(pat.id) {\n                           gather_moves::gather_move_from_pat("}, {"sha": "035d6a5cc459a214cde71471623cbec30af5339d", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "patch": "@@ -827,7 +827,6 @@ pub fn check_legality_of_move_bindings(cx: @MatchCheckCtxt,\n     for pats.each |pat| {\n         do pat_bindings(def_map, *pat) |bm, id, span, _path| {\n             match bm {\n-                bind_by_copy => {}\n                 bind_by_ref(_) => {\n                     by_ref_span = Some(span);\n                 }"}, {"sha": "1959f01daf5137e1d8b1a84c2d803124cda073fe", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "patch": "@@ -71,7 +71,6 @@ pub fn check_crate(tcx: ty::ctxt,\n         current_item: -1\n     };\n     let visit = visit::mk_vt(@visit::Visitor {\n-        visit_arm: check_arm,\n         visit_expr: check_expr,\n         visit_fn: check_fn,\n         visit_ty: check_ty,\n@@ -238,19 +237,6 @@ fn check_fn(\n     visit::visit_fn(fk, decl, body, sp, fn_id, cx, v);\n }\n \n-fn check_arm(a: &arm, cx: Context, v: visit::vt<Context>) {\n-    for a.pats.each |p| {\n-        do pat_util::pat_bindings(cx.tcx.def_map, *p) |mode, id, span, _pth| {\n-            if mode == bind_by_copy {\n-                let t = ty::node_id_to_type(cx.tcx, id);\n-                let reason = \"consider binding with `ref` or `move` instead\";\n-                check_copy(cx, t, span, reason);\n-            }\n-        }\n-    }\n-    visit::visit_arm(a, cx, v);\n-}\n-\n pub fn check_expr(e: @expr, cx: Context, v: visit::vt<Context>) {\n     debug!(\"kind::check_expr(%s)\", expr_to_str(e, cx.tcx.sess.intr()));\n "}, {"sha": "d2f6d6527738885cda6979fa57520cc6f7efe005", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "patch": "@@ -576,14 +576,18 @@ pub impl VisitContext {\n \n         do pat_bindings(self.tcx.def_map, pat) |bm, id, _span, _path| {\n             let binding_moves = match bm {\n-                bind_by_copy => false,\n                 bind_by_ref(_) => false,\n                 bind_infer => {\n                     let pat_ty = ty::node_id_to_type(self.tcx, id);\n+                    debug!(\"pattern %? type is %s\",\n+                           id, pat_ty.repr(self.tcx));\n                     ty::type_moves_by_default(self.tcx, pat_ty)\n                 }\n             };\n \n+            debug!(\"pattern binding %?: bm=%?, binding_moves=%b\",\n+                   id, bm, binding_moves);\n+\n             if binding_moves {\n                 self.move_maps.moves_map.insert(id);\n             }"}, {"sha": "23645f7f04a3c10a7fd7ce92d0b282151341aef8", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "patch": "@@ -520,12 +520,12 @@ pub impl NameBindings {\n                     type_span: Some(sp)\n                 });\n             }\n-            Some(copy type_def) => {\n+            Some(type_def) => {\n                 self.type_def = Some(TypeNsDef {\n                     privacy: privacy,\n                     module_def: Some(module_),\n                     type_span: Some(sp),\n-                    .. type_def\n+                    type_def: type_def.type_def\n                 });\n             }\n         }\n@@ -577,12 +577,12 @@ pub impl NameBindings {\n                     type_span: Some(sp)\n                 });\n             }\n-            Some(copy type_def) => {\n+            Some(type_def) => {\n                 self.type_def = Some(TypeNsDef {\n                     privacy: privacy,\n                     type_def: Some(def),\n                     type_span: Some(sp),\n-                    .. type_def\n+                    module_def: type_def.module_def\n                 });\n             }\n         }\n@@ -1566,7 +1566,7 @@ pub impl Resolver {\n         match def {\n           def_mod(def_id) | def_foreign_mod(def_id) => {\n             match child_name_bindings.type_def {\n-              Some(TypeNsDef { module_def: Some(copy module_def), _ }) => {\n+              Some(TypeNsDef { module_def: Some(module_def), _ }) => {\n                 debug!(\"(building reduced graph for external crate) \\\n                         already created module\");\n                 module_def.def_id = Some(def_id);\n@@ -1745,7 +1745,7 @@ pub impl Resolver {\n                                                           NormalModuleKind,\n                                                           dummy_sp());\n                     }\n-                    Some(copy type_ns_def)\n+                    Some(type_ns_def)\n                             if type_ns_def.module_def.is_none() => {\n                         debug!(\"(building reduced graph for external crate) \\\n                                 autovivifying missing module def %s\",\n@@ -1812,7 +1812,7 @@ pub impl Resolver {\n                                     let type_module;\n                                     match child_name_bindings.type_def {\n                                         Some(TypeNsDef {\n-                                            module_def: Some(copy module_def),\n+                                            module_def: Some(module_def),\n                                             _\n                                         }) => {\n                                             // We already have a module. This\n@@ -2445,7 +2445,7 @@ pub impl Resolver {\n                         None => {\n                             // Continue.\n                         }\n-                        Some(copy value_target) => {\n+                        Some(value_target) => {\n                             dest_import_resolution.value_target =\n                                 Some(value_target);\n                         }\n@@ -2454,7 +2454,7 @@ pub impl Resolver {\n                         None => {\n                             // Continue.\n                         }\n-                        Some(copy type_target) => {\n+                        Some(type_target) => {\n                             dest_import_resolution.type_target =\n                                 Some(type_target);\n                         }\n@@ -2566,7 +2566,7 @@ pub impl Resolver {\n                     // Check to see whether there are type bindings, and, if\n                     // so, whether there is a module within.\n                     match target.bindings.type_def {\n-                        Some(copy type_def) => {\n+                        Some(type_def) => {\n                             match type_def.module_def {\n                                 None => {\n                                     // Not a module.\n@@ -5170,12 +5170,6 @@ pub impl Resolver {\n                                     descr: &str) {\n         match pat_binding_mode {\n             bind_infer => {}\n-            bind_by_copy => {\n-                self.session.span_err(\n-                    pat.span,\n-                    fmt!(\"cannot use `copy` binding mode with %s\",\n-                         descr));\n-            }\n             bind_by_ref(*) => {\n                 self.session.span_err(\n                     pat.span,\n@@ -5316,7 +5310,7 @@ pub fn resolve_crate(session: Session,\n                   -> CrateMap {\n     let resolver = @mut Resolver(session, lang_items, crate);\n     resolver.resolve();\n-    let @Resolver{def_map, export_map2, trait_map, _} = resolver;\n+    let Resolver{def_map, export_map2, trait_map, _} = copy *resolver;\n     CrateMap {\n         def_map: def_map,\n         exp_map2: export_map2,"}, {"sha": "b142dc1ef28d233726ba551bc3a754033308d7fe", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "patch": "@@ -1640,7 +1640,7 @@ fn create_bindings_map(bcx: block, pat: @ast::pat) -> BindingsMap {\n \n         let llmatch, trmode;\n         match bm {\n-            ast::bind_by_copy | ast::bind_infer => {\n+            ast::bind_infer => {\n                 // in this case, the final type of the variable will be T,\n                 // but during matching we need to store a *T as explained\n                 // above"}, {"sha": "13102093cd6403ef861c6bc6f58fcfe7b5779777", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "patch": "@@ -450,7 +450,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             demand::eqtype(fcx, pat.span, region_ty, typ);\n           }\n           // otherwise the type of x is the expected type T\n-          ast::bind_by_copy | ast::bind_infer => {\n+          ast::bind_infer => {\n             demand::eqtype(fcx, pat.span, expected, typ);\n           }\n         }"}, {"sha": "3cb028b811e22d9262adfa5c0362da6cb6c95bb3", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "patch": "@@ -308,7 +308,7 @@ pub impl CoherenceChecker {\n                             implementation =\n                                 self.create_impl_from_item(item);\n                         }\n-                        Some(copy existing_implementation) => {\n+                        Some(existing_implementation) => {\n                             implementation = existing_implementation;\n                         }\n                     }"}, {"sha": "bfe82a015cd0e16b1f8d5178c9df081b0438ab25", "filename": "src/libstd/io.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "patch": "@@ -1933,7 +1933,7 @@ mod tests {\n     #[test]\n     fn file_reader_not_exist() {\n         match io::file_reader(&Path(\"not a file\")) {\n-          result::Err(copy e) => {\n+          result::Err(e) => {\n             assert_eq!(e, ~\"error opening not a file\");\n           }\n           result::Ok(_) => fail!()\n@@ -1974,7 +1974,7 @@ mod tests {\n     #[test]\n     fn file_writer_bad_name() {\n         match io::file_writer(&Path(\"?/?\"), []) {\n-          result::Err(copy e) => {\n+          result::Err(e) => {\n             assert!(str::starts_with(e, \"error opening\"));\n           }\n           result::Ok(_) => fail!()\n@@ -1984,7 +1984,7 @@ mod tests {\n     #[test]\n     fn buffered_file_writer_bad_name() {\n         match io::buffered_file_writer(&Path(\"?/?\")) {\n-          result::Err(copy e) => {\n+          result::Err(e) => {\n             assert!(str::starts_with(e, \"error opening\"));\n           }\n           result::Ok(_) => fail!()"}, {"sha": "ee6e37aeb783ee13f94972b7e747796bd8f51f86", "filename": "src/libstd/option.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "patch": "@@ -341,15 +341,15 @@ pub impl<T:Copy> Option<T> {\n     #[inline(always)]\n     fn get(self) -> T {\n         match self {\n-          Some(copy x) => return x,\n+          Some(x) => return x,\n           None => fail!(\"option::get none\")\n         }\n     }\n \n     /// Returns the contained value or a default\n     #[inline(always)]\n     fn get_or_default(self, def: T) -> T {\n-        match self { Some(copy x) => x, None => def }\n+        match self { Some(x) => x, None => def }\n     }\n \n     /// Applies a function zero or more times until the result is none.\n@@ -366,7 +366,7 @@ pub impl<T:Copy + Zero> Option<T> {\n     /// Returns the contained value or zero (for this type)\n     #[inline(always)]\n     fn get_or_zero(self) -> T {\n-        match self { Some(copy x) => x, None => Zero::zero() }\n+        match self { Some(x) => x, None => Zero::zero() }\n     }\n }\n "}, {"sha": "9eb7b54f009a7d18e7f16d42f26bb55928feae42", "filename": "src/libstd/path.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "patch": "@@ -774,9 +774,9 @@ impl GenericPath for WindowsPath {\n \n         /* if rhs has a host set, then the whole thing wins */\n         match other.host {\n-            Some(copy host) => {\n+            Some(ref host) => {\n                 return WindowsPath {\n-                    host: Some(host),\n+                    host: Some(copy *host),\n                     device: copy other.device,\n                     is_absolute: true,\n                     components: copy other.components,\n@@ -787,10 +787,10 @@ impl GenericPath for WindowsPath {\n \n         /* if rhs has a device set, then a part wins */\n         match other.device {\n-            Some(copy device) => {\n+            Some(ref device) => {\n                 return WindowsPath {\n                     host: None,\n-                    device: Some(device),\n+                    device: Some(copy *device),\n                     is_absolute: true,\n                     components: copy other.components,\n                 };"}, {"sha": "5b40b09e98e84f8c41de73676d4903617c09fd87", "filename": "src/libstd/result.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "patch": "@@ -40,7 +40,7 @@ pub enum Result<T, U> {\n #[inline(always)]\n pub fn get<T:Copy,U>(res: &Result<T, U>) -> T {\n     match *res {\n-      Ok(copy t) => t,\n+      Ok(ref t) => copy *t,\n       Err(ref the_err) =>\n         fail!(\"get called on error result: %?\", *the_err)\n     }\n@@ -72,7 +72,7 @@ pub fn get_ref<'a, T, U>(res: &'a Result<T, U>) -> &'a T {\n #[inline(always)]\n pub fn get_err<T, U: Copy>(res: &Result<T, U>) -> U {\n     match *res {\n-      Err(copy u) => u,\n+      Err(ref u) => copy *u,\n       Ok(_) => fail!(\"get_err called on ok result\")\n     }\n }\n@@ -102,8 +102,8 @@ pub fn is_err<T, U>(res: &Result<T, U>) -> bool {\n pub fn to_either<T:Copy,U:Copy>(res: &Result<U, T>)\n     -> Either<T, U> {\n     match *res {\n-      Ok(copy res) => either::Right(res),\n-      Err(copy fail_) => either::Left(fail_)\n+      Ok(ref res) => either::Right(copy *res),\n+      Err(ref fail_) => either::Left(copy *fail_)\n     }\n }\n \n@@ -206,7 +206,7 @@ pub fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: &fn(&T) -> U)\n   -> Result<U, E> {\n     match *res {\n       Ok(ref t) => Ok(op(t)),\n-      Err(copy e) => Err(e)\n+      Err(ref e) => Err(copy *e)\n     }\n }\n \n@@ -222,7 +222,7 @@ pub fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: &fn(&T) -> U)\n pub fn map_err<T:Copy,E,F:Copy>(res: &Result<T, E>, op: &fn(&E) -> F)\n   -> Result<T, F> {\n     match *res {\n-      Ok(copy t) => Ok(t),\n+      Ok(ref t) => Ok(copy *t),\n       Err(ref e) => Err(op(e))\n     }\n }\n@@ -304,8 +304,8 @@ pub fn map_vec<T,U:Copy,V:Copy>(\n     let mut vs: ~[V] = vec::with_capacity(vec::len(ts));\n     for ts.each |t| {\n         match op(t) {\n-          Ok(copy v) => vs.push(v),\n-          Err(copy u) => return Err(u)\n+          Ok(v) => vs.push(v),\n+          Err(u) => return Err(u)\n         }\n     }\n     return Ok(vs);\n@@ -319,8 +319,8 @@ pub fn map_opt<T,U:Copy,V:Copy>(\n     match *o_t {\n       None => Ok(None),\n       Some(ref t) => match op(t) {\n-        Ok(copy v) => Ok(Some(v)),\n-        Err(copy e) => Err(e)\n+        Ok(v) => Ok(Some(v)),\n+        Err(e) => Err(e)\n       }\n     }\n }\n@@ -344,8 +344,8 @@ pub fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n     let mut i = 0u;\n     while i < n {\n         match op(&ss[i],&ts[i]) {\n-          Ok(copy v) => vs.push(v),\n-          Err(copy u) => return Err(u)\n+          Ok(v) => vs.push(v),\n+          Err(u) => return Err(u)\n         }\n         i += 1u;\n     }\n@@ -367,7 +367,7 @@ pub fn iter_vec2<S,T,U:Copy>(ss: &[S], ts: &[T],\n     while i < n {\n         match op(&ss[i],&ts[i]) {\n           Ok(()) => (),\n-          Err(copy u) => return Err(u)\n+          Err(u) => return Err(u)\n         }\n         i += 1u;\n     }"}, {"sha": "676a57e38daa39080a9f8bc485aca4e3fff1d1f1", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "patch": "@@ -257,21 +257,20 @@ pub struct field_pat {\n \n #[deriving(Eq, Encodable, Decodable)]\n pub enum binding_mode {\n-    bind_by_copy,\n     bind_by_ref(mutability),\n     bind_infer\n }\n \n impl to_bytes::IterBytes for binding_mode {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         match *self {\n-          bind_by_copy => 0u8.iter_bytes(lsb0, f),\n-\n           bind_by_ref(ref m) => {\n-              1u8.iter_bytes(lsb0, f) && m.iter_bytes(lsb0, f)\n+              0u8.iter_bytes(lsb0, f) && m.iter_bytes(lsb0, f)\n           }\n \n-          bind_infer => 2u8.iter_bytes(lsb0, f),\n+          bind_infer => {\n+              1u8.iter_bytes(lsb0, f)\n+          }\n         }\n     }\n }"}, {"sha": "deff6dc5ba9667315549151bbf43346849913124", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "patch": "@@ -233,7 +233,7 @@ pub fn ident_to_path(s: span, i: ident) -> @Path {\n \n pub fn ident_to_pat(id: node_id, s: span, i: ident) -> @pat {\n     @ast::pat { id: id,\n-                node: pat_ident(bind_by_copy, ident_to_path(s, i), None),\n+                node: pat_ident(bind_infer, ident_to_path(s, i), None),\n                 span: s }\n }\n "}, {"sha": "85bebebf0f63fc724363b7e2c09845b023994ab8", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "patch": "@@ -560,7 +560,7 @@ impl AstBuilder for @ExtCtxt {\n         self.pat(span, ast::pat_lit(expr))\n     }\n     fn pat_ident(&self, span: span, ident: ast::ident) -> @ast::pat {\n-        self.pat_ident_binding_mode(span, ident, ast::bind_by_copy)\n+        self.pat_ident_binding_mode(span, ident, ast::bind_infer)\n     }\n \n     fn pat_ident_binding_mode(&self,"}, {"sha": "10fb4b8ecd4a2f8800e52574c61a4e6898116e0f", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "patch": "@@ -62,11 +62,11 @@ fn iter_bytes_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @\n         Struct(ref fs) => {\n             fields = fs\n         }\n-        EnumMatching(copy index, ref variant, ref fs) => {\n+        EnumMatching(index, ref variant, ref fs) => {\n             // Determine the discriminant. We will feed this value to the byte\n             // iteration function.\n             let discriminant = match variant.node.disr_expr {\n-                Some(copy d)=> d,\n+                Some(d)=> d,\n                 None => cx.expr_uint(span, index)\n             };\n "}, {"sha": "54d31de7c50d4c3f3bb4937dc58fb76cdd7bbbbf", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "patch": "@@ -119,7 +119,7 @@ fn rand_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n                   summary: &Either<uint, ~[ident]>,\n                   rand_call: &fn() -> @expr) -> @expr {\n         match *summary {\n-            Left(copy count) => {\n+            Left(count) => {\n                 if count == 0 {\n                     cx.expr_ident(span, ctor_ident)\n                 } else {"}, {"sha": "91fad0c22a676f9c4487245a14fa8ac67e21f54d", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "patch": "@@ -58,8 +58,8 @@ pub fn expand_file(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     base::check_zero_tts(cx, sp, tts, \"file!\");\n \n     let topmost = topmost_expn_info(cx.backtrace().get());\n-    let Loc { file: @FileMap { name: filename, _ }, _ } =\n-        cx.codemap().lookup_char_pos(topmost.call_site.lo);\n+    let loc = cx.codemap().lookup_char_pos(topmost.call_site.lo);\n+    let filename = copy loc.file.name;\n     base::MRExpr(cx.expr_str(topmost.call_site, filename))\n }\n "}, {"sha": "ec63b5a7f74740e2187570815cf9538d3e174edb", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "patch": "@@ -423,7 +423,7 @@ pub fn parse_nt(p: &Parser, name: &str) -> nonterminal {\n       },\n       \"block\" => token::nt_block(p.parse_block()),\n       \"stmt\" => token::nt_stmt(p.parse_stmt(~[])),\n-      \"pat\" => token::nt_pat(p.parse_pat(true)),\n+      \"pat\" => token::nt_pat(p.parse_pat()),\n       \"expr\" => token::nt_expr(p.parse_expr()),\n       \"ty\" => token::nt_ty(p.parse_ty(false /* no need to disambiguate*/)),\n       // this could be handled like a token, since it is one"}, {"sha": "4a6a070df50add6188202d63cd4f6c60c6817c99", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "patch": "@@ -207,8 +207,8 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n         } else { /* repeat */\n             r.stack.idx = 0u;\n             r.repeat_idx[r.repeat_idx.len() - 1u] += 1u;\n-            match r.stack.sep {\n-              Some(copy tk) => {\n+            match copy r.stack.sep {\n+              Some(tk) => {\n                 r.cur_tok = tk; /* repeat same span, I guess */\n                 return ret_val;\n               }\n@@ -218,8 +218,8 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n     }\n     loop { /* because it's easiest, this handles `tt_delim` not starting\n     with a `tt_tok`, even though it won't happen */\n-        match r.stack.forest[r.stack.idx] {\n-          tt_delim(copy tts) => {\n+        match copy r.stack.forest[r.stack.idx] {\n+          tt_delim(tts) => {\n             r.stack = @mut TtFrame {\n                 forest: @mut tts,\n                 idx: 0u,\n@@ -229,13 +229,13 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n             };\n             // if this could be 0-length, we'd need to potentially recur here\n           }\n-          tt_tok(sp, copy tok) => {\n+          tt_tok(sp, tok) => {\n             r.cur_span = sp;\n             r.cur_tok = tok;\n             r.stack.idx += 1u;\n             return ret_val;\n           }\n-          tt_seq(sp, copy tts, copy sep, zerok) => {\n+          tt_seq(sp, tts, sep, zerok) => {\n             let t = tt_seq(sp, copy tts, copy sep, zerok);\n             match lockstep_iter_size(&t, r) {\n               lis_unconstrained => {"}, {"sha": "c054bf5527409cddef405343e29d202311355e37", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "patch": "@@ -487,7 +487,7 @@ mod test {\n         let parser = string_to_parser(@~\"b\");\n         assert_eq!(parser.parse_pat(false),\n                    @ast::pat{id:1, // fixme\n-                             node: ast::pat_ident(ast::bind_by_copy,\n+                             node: ast::pat_ident(ast::bind_infer,\n                                                   @ast::Path{\n                                                       span:sp(0,1),\n                                                       global:false,\n@@ -516,7 +516,7 @@ mod test {\n                                                        2),\n                                     span:sp(4,7)},\n                        pat: @ast::pat{id:1,\n-                                      node: ast::pat_ident(ast::bind_by_copy,\n+                                      node: ast::pat_ident(ast::bind_infer,\n                                                            @ast::Path{\n                                                                span:sp(0,1),\n                                                                global:false,\n@@ -553,7 +553,7 @@ mod test {\n                                                 span:sp(10,13)},\n                                     pat: @ast::pat{id:1, // fixme\n                                                    node: ast::pat_ident(\n-                                                       ast::bind_by_copy,\n+                                                       ast::bind_infer,\n                                                        @ast::Path{\n                                                            span:sp(6,7),\n                                                            global:false,"}, {"sha": "29f565851b41148c69732a4867c225680c4cd27a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 51, "deletions": 56, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "patch": "@@ -18,7 +18,7 @@ use ast::{TyBareFn, TyClosure};\n use ast::{RegionTyParamBound, TraitTyParamBound};\n use ast::{provided, public, purity};\n use ast::{_mod, add, arg, arm, attribute, bind_by_ref, bind_infer};\n-use ast::{bind_by_copy, bitand, bitor, bitxor, blk};\n+use ast::{bitand, bitor, bitxor, blk};\n use ast::{blk_check_mode, box};\n use ast::{crate, crate_cfg, decl, decl_item};\n use ast::{decl_local, default_blk, deref, div, enum_def, explicit_self};\n@@ -131,11 +131,11 @@ at INTERPOLATED tokens */\n macro_rules! maybe_whole_expr (\n     ($p:expr) => (\n         match *($p).token {\n-            INTERPOLATED(token::nt_expr(copy e)) => {\n+            INTERPOLATED(token::nt_expr(e)) => {\n                 $p.bump();\n                 return e;\n             }\n-            INTERPOLATED(token::nt_path(copy pt)) => {\n+            INTERPOLATED(token::nt_path(pt)) => {\n                 $p.bump();\n                 return $p.mk_expr(\n                     ($p).span.lo,\n@@ -150,44 +150,44 @@ macro_rules! maybe_whole_expr (\n \n macro_rules! maybe_whole (\n     ($p:expr, $constructor:ident) => (\n-        match *($p).token {\n-            INTERPOLATED(token::$constructor(copy x)) => {\n+        match copy *($p).token {\n+            INTERPOLATED(token::$constructor(x)) => {\n                 $p.bump();\n                 return x;\n             }\n             _ => ()\n        }\n     );\n     (deref $p:expr, $constructor:ident) => (\n-        match *($p).token {\n-            INTERPOLATED(token::$constructor(copy x)) => {\n+        match copy *($p).token {\n+            INTERPOLATED(token::$constructor(x)) => {\n                 $p.bump();\n                 return copy *x;\n             }\n             _ => ()\n         }\n     );\n     (Some $p:expr, $constructor:ident) => (\n-        match *($p).token {\n-            INTERPOLATED(token::$constructor(copy x)) => {\n+        match copy *($p).token {\n+            INTERPOLATED(token::$constructor(x)) => {\n                 $p.bump();\n                 return Some(x);\n             }\n             _ => ()\n         }\n     );\n     (iovi $p:expr, $constructor:ident) => (\n-        match *($p).token {\n-            INTERPOLATED(token::$constructor(copy x)) => {\n+        match copy *($p).token {\n+            INTERPOLATED(token::$constructor(x)) => {\n                 $p.bump();\n                 return iovi_item(x);\n             }\n             _ => ()\n         }\n     );\n     (pair_empty $p:expr, $constructor:ident) => (\n-        match *($p).token {\n-            INTERPOLATED(token::$constructor(copy x)) => {\n+        match copy *($p).token {\n+            INTERPOLATED(token::$constructor(x)) => {\n                 $p.bump();\n                 return (~[], x);\n             }\n@@ -825,7 +825,7 @@ pub impl Parser {\n         let pat = if require_name || self.is_named_argument() {\n             self.parse_arg_mode();\n             is_mutbl = self.eat_keyword(keywords::Mut);\n-            let pat = self.parse_pat(false);\n+            let pat = self.parse_pat();\n             self.expect(&token::COLON);\n             pat\n         } else {\n@@ -853,7 +853,7 @@ pub impl Parser {\n     fn parse_fn_block_arg(&self) -> arg_or_capture_item {\n         self.parse_arg_mode();\n         let is_mutbl = self.eat_keyword(keywords::Mut);\n-        let pat = self.parse_pat(false);\n+        let pat = self.parse_pat();\n         let t = if self.eat(&token::COLON) {\n             self.parse_ty(false)\n         } else {\n@@ -1992,28 +1992,29 @@ pub impl Parser {\n         // them as the lambda arguments\n         let e = self.parse_expr_res(RESTRICT_NO_BAR_OR_DOUBLEBAR_OP);\n         match e.node {\n-            expr_call(f, /*bad*/ copy args, NoSugar) => {\n+            expr_call(f, ref args, NoSugar) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n-                let args = vec::append(args, [last_arg]);\n+                let args = vec::append(copy *args, [last_arg]);\n                 self.mk_expr(lo.lo, block.span.hi, expr_call(f, args, sugar))\n             }\n-            expr_method_call(f, i, /*bad*/ copy tps,\n-                             /*bad*/ copy args, NoSugar) => {\n+            expr_method_call(f, i, ref tps, ref args, NoSugar) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n-                let args = vec::append(args, [last_arg]);\n+                let args = vec::append(copy *args, [last_arg]);\n                 self.mk_expr(lo.lo, block.span.hi,\n-                             expr_method_call(f, i, tps, args, sugar))\n+                             expr_method_call(f, i, copy *tps,\n+                                              args, sugar))\n             }\n-            expr_field(f, i, /*bad*/ copy tps) => {\n+            expr_field(f, i, ref tps) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n                 self.mk_expr(lo.lo, block.span.hi,\n-                             expr_method_call(f, i, tps, ~[last_arg], sugar))\n+                             expr_method_call(f, i,\n+                                              copy *tps, ~[last_arg], sugar))\n             }\n             expr_path(*) | expr_call(*) | expr_method_call(*) |\n                 expr_paren(*) => {\n@@ -2162,15 +2163,14 @@ pub impl Parser {\n     fn parse_pats(&self) -> ~[@pat] {\n         let mut pats = ~[];\n         loop {\n-            pats.push(self.parse_pat(true));\n+            pats.push(self.parse_pat());\n             if *self.token == token::BINOP(token::OR) { self.bump(); }\n             else { return pats; }\n         };\n     }\n \n     fn parse_pat_vec_elements(\n         &self,\n-        refutable: bool\n     ) -> (~[@pat], Option<@pat>, ~[@pat]) {\n         let mut before = ~[];\n         let mut slice = None;\n@@ -2191,7 +2191,7 @@ pub impl Parser {\n                 }\n             }\n \n-            let subpat = self.parse_pat(refutable);\n+            let subpat = self.parse_pat();\n             if is_slice {\n                 match subpat {\n                     @ast::pat { node: pat_wild, _ } => (),\n@@ -2214,7 +2214,7 @@ pub impl Parser {\n     }\n \n     // parse the fields of a struct-like pattern\n-    fn parse_pat_fields(&self, refutable: bool) -> (~[ast::field_pat], bool) {\n+    fn parse_pat_fields(&self) -> (~[ast::field_pat], bool) {\n         let mut fields = ~[];\n         let mut etc = false;\n         let mut first = true;\n@@ -2244,7 +2244,7 @@ pub impl Parser {\n             let subpat;\n             if *self.token == token::COLON {\n                 self.bump();\n-                subpat = self.parse_pat(refutable);\n+                subpat = self.parse_pat();\n             } else {\n                 subpat = @ast::pat {\n                     id: self.get_id(),\n@@ -2257,10 +2257,8 @@ pub impl Parser {\n         return (fields, etc);\n     }\n \n-    // parse a pattern. The 'refutable' argument\n-    // appears to control whether the binding_mode\n-    // 'bind_infer' or 'bind_by_copy' is used.\n-    fn parse_pat(&self, refutable: bool) -> @pat {\n+    // parse a pattern.\n+    fn parse_pat(&self) -> @pat {\n         maybe_whole!(self, nt_pat);\n \n         let lo = self.span.lo;\n@@ -2272,7 +2270,7 @@ pub impl Parser {\n             // parse @pat\n           token::AT => {\n             self.bump();\n-            let sub = self.parse_pat(refutable);\n+            let sub = self.parse_pat();\n             hi = sub.span.hi;\n             // HACK: parse @\"...\" as a literal of a vstore @str\n             pat = match sub.node {\n@@ -2295,7 +2293,7 @@ pub impl Parser {\n           token::TILDE => {\n             // parse ~pat\n             self.bump();\n-            let sub = self.parse_pat(refutable);\n+            let sub = self.parse_pat();\n             hi = sub.span.hi;\n             // HACK: parse ~\"...\" as a literal of a vstore ~str\n             pat = match sub.node {\n@@ -2319,7 +2317,7 @@ pub impl Parser {\n               // parse &pat\n               let lo = self.span.lo;\n               self.bump();\n-              let sub = self.parse_pat(refutable);\n+              let sub = self.parse_pat();\n               hi = sub.span.hi;\n               // HACK: parse &\"...\" as a literal of a borrowed str\n               pat = match sub.node {\n@@ -2340,7 +2338,7 @@ pub impl Parser {\n           }\n           token::LBRACE => {\n             self.bump();\n-            let (_, _) = self.parse_pat_fields(refutable);\n+            let (_, _) = self.parse_pat_fields();\n             hi = self.span.hi;\n             self.bump();\n             self.obsolete(*self.span, ObsoleteRecordPattern);\n@@ -2358,11 +2356,11 @@ pub impl Parser {\n                 let expr = self.mk_expr(lo, hi, expr_lit(lit));\n                 pat = pat_lit(expr);\n             } else {\n-                let mut fields = ~[self.parse_pat(refutable)];\n+                let mut fields = ~[self.parse_pat()];\n                 if self.look_ahead(1) != token::RPAREN {\n                     while *self.token == token::COMMA {\n                         self.bump();\n-                        fields.push(self.parse_pat(refutable));\n+                        fields.push(self.parse_pat());\n                     }\n                 }\n                 if fields.len() == 1 { self.expect(&token::COMMA); }\n@@ -2375,7 +2373,7 @@ pub impl Parser {\n             // parse [pat,pat,...] as vector pattern\n             self.bump();\n             let (before, slice, after) =\n-                self.parse_pat_vec_elements(refutable);\n+                self.parse_pat_vec_elements();\n             hi = self.span.hi;\n             self.expect(&token::RBRACKET);\n             pat = ast::pat_vec(before, slice, after);\n@@ -2405,15 +2403,13 @@ pub impl Parser {\n             } else if self.eat_keyword(keywords::Ref) {\n                 // parse ref pat\n                 let mutbl = self.parse_mutability();\n-                pat = self.parse_pat_ident(refutable, bind_by_ref(mutbl));\n+                pat = self.parse_pat_ident(bind_by_ref(mutbl));\n             } else if self.eat_keyword(keywords::Copy) {\n                 // parse copy pat\n-                pat = self.parse_pat_ident(refutable, bind_by_copy);\n+                self.warn(\"copy keyword in patterns no longer has any effect, \\\n+                           remove it\");\n+                pat = self.parse_pat_ident(bind_infer);\n             } else {\n-                // XXX---refutable match bindings should work same as let\n-                let binding_mode =\n-                    if refutable {bind_infer} else {bind_by_copy};\n-\n                 let can_be_enum_or_struct;\n                 match self.look_ahead(1) {\n                     token::LPAREN | token::LBRACKET | token::LT |\n@@ -2434,20 +2430,20 @@ pub impl Parser {\n                     let sub;\n                     if self.eat(&token::AT) {\n                         // parse foo @ pat\n-                        sub = Some(self.parse_pat(refutable));\n+                        sub = Some(self.parse_pat());\n                     } else {\n                         // or just foo\n                         sub = None;\n                     }\n-                    pat = pat_ident(binding_mode, name, sub);\n+                    pat = pat_ident(bind_infer, name, sub);\n                 } else {\n                     // parse an enum pat\n                     let enum_path = self.parse_path_with_tps(true);\n                     match *self.token {\n                         token::LBRACE => {\n                             self.bump();\n                             let (fields, etc) =\n-                                self.parse_pat_fields(refutable);\n+                                self.parse_pat_fields();\n                             self.bump();\n                             pat = pat_struct(enum_path, fields, etc);\n                         }\n@@ -2468,7 +2464,7 @@ pub impl Parser {\n                                         seq_sep_trailing_disallowed(\n                                             token::COMMA\n                                         ),\n-                                        |p| p.parse_pat(refutable)\n+                                        |p| p.parse_pat()\n                                     );\n                                     pat = pat_enum(enum_path, Some(args));\n                                   }\n@@ -2478,7 +2474,7 @@ pub impl Parser {\n                                       // it could still be either an enum\n                                       // or an identifier pattern, resolve\n                                       // will sort it out:\n-                                      pat = pat_ident(binding_mode,\n+                                      pat = pat_ident(bind_infer,\n                                                       enum_path,\n                                                       None);\n                                   } else {\n@@ -2500,7 +2496,6 @@ pub impl Parser {\n     // used by the copy foo and ref foo patterns to give a good\n     // error message when parsing mistakes like ref foo(a,b)\n     fn parse_pat_ident(&self,\n-                       refutable: bool,\n                        binding_mode: ast::binding_mode)\n                        -> ast::pat_ {\n         if !is_plain_ident(&*self.token) {\n@@ -2510,7 +2505,7 @@ pub impl Parser {\n         // why a path here, and not just an identifier?\n         let name = self.parse_path_without_tps();\n         let sub = if self.eat(&token::AT) {\n-            Some(self.parse_pat(refutable))\n+            Some(self.parse_pat())\n         } else {\n             None\n         };\n@@ -2533,7 +2528,7 @@ pub impl Parser {\n     // parse a local variable declaration\n     fn parse_local(&self, is_mutbl: bool) -> @local {\n         let lo = self.span.lo;\n-        let pat = self.parse_pat(false);\n+        let pat = self.parse_pat();\n         let mut ty = @Ty {\n             id: self.get_id(),\n             node: ty_infer,\n@@ -2760,7 +2755,7 @@ pub impl Parser {\n                     match stmt.node {\n                         stmt_expr(e, stmt_id) => {\n                             // expression without semicolon\n-                            match *self.token {\n+                            match copy *self.token {\n                                 token::SEMI => {\n                                     self.bump();\n                                     stmts.push(@codemap::spanned {\n@@ -2770,7 +2765,7 @@ pub impl Parser {\n                                 token::RBRACE => {\n                                     expr = Some(e);\n                                 }\n-                                copy t => {\n+                                t => {\n                                     if classify::stmt_ends_with_semi(stmt) {\n                                         self.fatal(\n                                             fmt!(\n@@ -2880,7 +2875,7 @@ pub impl Parser {\n                 token::MOD_SEP | token::IDENT(*) => {\n                     let obsolete_bound = match *self.token {\n                         token::MOD_SEP => false,\n-                        token::IDENT(copy sid, _) => {\n+                        token::IDENT(sid, _) => {\n                             match *self.id_to_str(sid) {\n                                 ~\"send\" |\n                                 ~\"copy\" |"}, {"sha": "f29876b87087a8917e3a55b9300cfeace6627866", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1a40890d48321c69f66bd07e3a23d5d5ab939a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=7a1a40890d48321c69f66bd07e3a23d5d5ab939a", "patch": "@@ -1537,9 +1537,6 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n                       word_nbsp(s, \"ref\");\n                       print_mutability(s, mutbl);\n                   }\n-                  ast::bind_by_copy => {\n-                      word_nbsp(s, \"copy\");\n-                  }\n                   ast::bind_infer => {}\n               }\n           }"}]}