{"sha": "c3ada00316f4d204512aa1ac14450a94fa16b2ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzYWRhMDAzMTZmNGQyMDQ1MTJhYTFhYzE0NDUwYTk0ZmExNmIyZWY=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-03-02T19:53:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-03-02T19:53:41Z"}, "message": "Rollup merge of #39832 - phil-opp:x86-interrupt-calling-convention, r=nagisa\n\nAdd support for the x86-interrupt calling convention\n\nThis calling convention can be used for definining interrupt handlers on 32-bit and 64-bit x86 targets. The compiler then uses `iret` instead of `ret` for returning and ensures that all registers are restored to their\noriginal values.\n\nUsage:\n\n```rust\nextern \"x86-interrupt\" fn handler(stack_frame: &ExceptionStackFrame) {\u2026}\n```\n\nfor interrupts and exceptions without error code and\n\n```rust\nextern \"x86-interrupt\" fn handler_with_err_code(stack_frame: &ExceptionStackFrame,\n                                                error_code: u64) {\u2026}\n```\n\nfor exceptions that push an error code (e.g., page faults or general protection faults). The programmer must ensure that the correct version is used for each interrupt.\n\nFor more details see the [LLVM PR][1] and the corresponding [proposal][2].\n\n[1]: https://reviews.llvm.org/D15567\n[2]: http://lists.llvm.org/pipermail/cfe-dev/2015-September/045171.html\n\nIt is also possible to implement interrupt handlers on x86 through [naked functions](https://github.com/rust-lang/rfcs/blob/master/text/1201-naked-fns.md). In fact, almost all existing Rust OS projects for x86 use naked functions for this, including [Redox](https://github.com/redox-os/kernel/blob/b9793deb59c7650f0805dea96adb6b773ad99336/arch/x86_64/src/lib.rs#L109-L147), [IntermezzOS](https://github.com/intermezzOS/kernel/blob/f959cc18c78b1ba153f3ff7039d9ecc07f397628/interrupts/src/lib.rs#L28-L72), and [blog_os](https://github.com/phil-opp/blog_os/blob/844d739379ffdea6a7ede88365ec6e21a725bbf5/src/interrupts/mod.rs#L49-L64). So support for the `x86-interrupt` calling convention isn't absolutely needed.\n\nHowever, it has a number of benefits to naked functions:\n\n- **No inline assembly needed**: [Inline assembly](https://doc.rust-lang.org/book/inline-assembly.html) is highly unstable and dangerous. It's pretty easy to mess things up. Also, it uses an arcane syntax and requires that the programmer knows x86 assembly.\n- **Higher performance**: A naked wrapper function always saves _all_ registers before calling the Rust function. This isn't needed for a compiler supported calling convention, since the compiler knows which registers are clobbered by the interrupt handler. Thus, only these registers need to be saved and restored.\n- **Safer interfaces**: We can write a `set_handler` function that takes a `extern \"x86-interrupt\" fn(&ExceptionStackFrame)` and the compiler ensures that we always use the right function type for all handler functions. This isn't possible with the `#[naked]` attribute.\n- **More convenient**: Instead of writing [tons of assembly boilerplate](https://github.com/redox-os/kernel/blob/b9793deb59c7650f0805dea96adb6b773ad99336/arch/x86_64/src/lib.rs#L109-L147) and desperately trying to improve things [through macros](https://github.com/phil-opp/blog_os/blob/844d739379ffdea6a7ede88365ec6e21a725bbf5/src/interrupts/mod.rs#L17-L92), we can just write [code like this](https://github.com/phil-opp/blog_os/blob/e6a61f9507a4c4fef6fb4e3474bc596391bc97d2/src/interrupts/mod.rs#L85-L89).\n- **Naked functions are unreliable**: It is allowed to use Rust code inside a naked function, which sometimes works and sometimes not. For example, [calling a function](https://github.com/redox-os/kernel/blob/b9793deb59c7650f0805dea96adb6b773ad99336/arch/x86_64/src/lib.rs#L132) through Rust code seems to work fine without function prologue, but [code declaring a variable](https://is.gd/NQYXqE) silently adds a prologue even though the function is naked (look at the generated assembly, there is a `movl` instruction before the `nop`).\n\n**Edit**: See the [tracking issue](https://github.com/rust-lang/rust/issues/40180) for an updated list of issues.\n\nUnfortunately, the implementation of the `x86-interrupt` calling convention in LLVM has some issues that make it unsuitable for 64-bit kernels at the moment:\n\n- LLVM always tries to backup the `xmm` registers on 64-bit platforms even if the target doesn't support SSE. This leads to invalid opcode exceptions whenever an interrupt handler is invoked. I submitted a fix to LLVM in [D29959](https://reviews.llvm.org/D29959). The fix is really small (<10 lines), so maybe we could backport it to [Rust's LLVM fork](https://github.com/rust-lang/llvm)?. **Edit**: The fix was merged to LLVM trunk in [rL295347](https://reviews.llvm.org/rL295347). Backported in https://github.com/rust-lang/llvm/pull/63.\n\n- On targets with SSE support, LLVM uses the `movaps` instruction for saving the `xmm` registers, which requires an alignment of 16. For handlers with error codes, however, the stack alignment is only 8, so a alignment exception occurs. This issue is tracked in [bug 26413](https://bugs.llvm.org/show_bug.cgi?id=26413). ~~Unfortunately, I don't know enough about LLVM to fix this.~~ **Edit**: Fix submitted in [D30049](https://reviews.llvm.org/D30049).\n\nThis PR adds experimental support for this calling convention under the `abi_x86_interrupt` feature gate. The implementation is very similar to #38465 and was surprisingly simple :).\n\nThere is no accepted RFC for this change. In fact, the [RFC for interrupt calling convention](https://github.com/rust-lang/rfcs/pull/1275) from 2015 was closed in favor of naked functions. However, the reactions to the recent [PR](https://github.com/rust-lang/rust/pull/38465) for a MSP430 interrupt calling convention were [in favor of experimental interrupt ABIs](https://github.com/rust-lang/rust/pull/38465#issuecomment-270015470).\n\n- [x] Add compile-fail tests for the feature gate.\n- [x] Create tracking issue for the `abi_x86_interrupt` feature (and link it in code). **Edit**: Tracking issue: #40180\n- [x] Backport [rL295347](https://reviews.llvm.org/rL295347) to Rust's LLVM fork. **Edit**: Done in https://github.com/rust-lang/llvm/pull/63\n\n@tari @steveklabnik @jackpot51 @ticki @hawkw @thepowersgang, you might be interested in this.", "tree": {"sha": "c6eedc21329a98d87ab6331fbe78fbc3984562c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6eedc21329a98d87ab6331fbe78fbc3984562c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3ada00316f4d204512aa1ac14450a94fa16b2ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3ada00316f4d204512aa1ac14450a94fa16b2ef", "html_url": "https://github.com/rust-lang/rust/commit/c3ada00316f4d204512aa1ac14450a94fa16b2ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3ada00316f4d204512aa1ac14450a94fa16b2ef/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ae411e1b342bb1756f620b0c97bfa9e4eef4e47", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ae411e1b342bb1756f620b0c97bfa9e4eef4e47", "html_url": "https://github.com/rust-lang/rust/commit/8ae411e1b342bb1756f620b0c97bfa9e4eef4e47"}, {"sha": "b44805875e3d2e7ac42052cf90d3d7dade90567c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b44805875e3d2e7ac42052cf90d3d7dade90567c", "html_url": "https://github.com/rust-lang/rust/commit/b44805875e3d2e7ac42052cf90d3d7dade90567c"}], "stats": {"total": 49, "additions": 48, "deletions": 1}, "files": [{"sha": "26c7a9166e68e9280ed8a683cc421944d530de60", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c3ada00316f4d204512aa1ac14450a94fa16b2ef/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3ada00316f4d204512aa1ac14450a94fa16b2ef/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=c3ada00316f4d204512aa1ac14450a94fa16b2ef", "patch": "@@ -53,6 +53,7 @@ pub enum CallConv {\n     X86_64_SysV = 78,\n     X86_64_Win64 = 79,\n     X86_VectorCall = 80,\n+    X86_Intr = 83,\n }\n \n /// LLVMRustLinkage"}, {"sha": "0bbe981f2f72c816bd50b38695693d25101450fb", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c3ada00316f4d204512aa1ac14450a94fa16b2ef/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3ada00316f4d204512aa1ac14450a94fa16b2ef/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=c3ada00316f4d204512aa1ac14450a94fa16b2ef", "patch": "@@ -355,6 +355,7 @@ impl FnType {\n             Aapcs => llvm::ArmAapcsCallConv,\n             PtxKernel => llvm::PtxKernel,\n             Msp430Interrupt => llvm::Msp430Intr,\n+            X86Interrupt => llvm::X86_Intr,\n \n             // These API constants ought to be more specific...\n             Cdecl => llvm::CCallConv,"}, {"sha": "30641515a41dd0ca3e3400ba7911bbd2cce70a15", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3ada00316f4d204512aa1ac14450a94fa16b2ef/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3ada00316f4d204512aa1ac14450a94fa16b2ef/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=c3ada00316f4d204512aa1ac14450a94fa16b2ef", "patch": "@@ -25,6 +25,7 @@ pub enum Abi {\n     SysV64,\n     PtxKernel,\n     Msp430Interrupt,\n+    X86Interrupt,\n \n     // Multiplatform / generic ABIs\n     Rust,\n@@ -59,6 +60,7 @@ const AbiDatas: &'static [AbiData] = &[\n     AbiData {abi: Abi::SysV64, name: \"sysv64\", generic: false },\n     AbiData {abi: Abi::PtxKernel, name: \"ptx-kernel\", generic: false },\n     AbiData {abi: Abi::Msp430Interrupt, name: \"msp430-interrupt\", generic: false },\n+    AbiData {abi: Abi::X86Interrupt, name: \"x86-interrupt\", generic: false },\n \n     // Cross-platform ABIs\n     AbiData {abi: Abi::Rust, name: \"Rust\", generic: true },"}, {"sha": "78f13c18dc104c163c469ee3afcff849346ef005", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c3ada00316f4d204512aa1ac14450a94fa16b2ef/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3ada00316f4d204512aa1ac14450a94fa16b2ef/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=c3ada00316f4d204512aa1ac14450a94fa16b2ef", "patch": "@@ -330,6 +330,9 @@ declare_features! (\n     // Used to identify crates that contain sanitizer runtimes\n     // rustc internal\n     (active, sanitizer_runtime, \"1.17.0\", None),\n+\n+    // `extern \"x86-interrupt\" fn()`\n+    (active, abi_x86_interrupt, \"1.17.0\", Some(40180)),\n );\n \n declare_features! (\n@@ -1036,6 +1039,10 @@ impl<'a> PostExpansionVisitor<'a> {\n                 gate_feature_post!(&self, abi_msp430_interrupt, span,\n                                    \"msp430-interrupt ABI is experimental and subject to change\");\n             },\n+            Abi::X86Interrupt => {\n+                gate_feature_post!(&self, abi_x86_interrupt, span,\n+                                   \"x86-interrupt ABI is experimental and subject to change\");\n+            },\n             // Stable\n             Abi::Cdecl |\n             Abi::Stdcall |"}, {"sha": "838cd4bf6d745625c3320c01b1ae593f7416c916", "filename": "src/test/codegen/abi-x86-interrupt.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c3ada00316f4d204512aa1ac14450a94fa16b2ef/src%2Ftest%2Fcodegen%2Fabi-x86-interrupt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3ada00316f4d204512aa1ac14450a94fa16b2ef/src%2Ftest%2Fcodegen%2Fabi-x86-interrupt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fabi-x86-interrupt.rs?ref=c3ada00316f4d204512aa1ac14450a94fa16b2ef", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Checks if the correct annotation for the x86-interrupt ABI is passed to\n+// llvm. Also checks that the abi_x86_interrupt feature gate allows usage\n+// of the x86-interrupt abi.\n+\n+// ignore-arm\n+// ignore-aarch64\n+// min-llvm-version 3.8\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+#![feature(abi_x86_interrupt)]\n+\n+// CHECK: define x86_intrcc i64 @has_x86_interrupt_abi\n+#[no_mangle]\n+pub extern \"x86-interrupt\" fn has_x86_interrupt_abi(a: i64) -> i64 {\n+    a * 2\n+}"}, {"sha": "b77c9fab7169f6add4cedb9cecc13ee304495b8d", "filename": "src/test/compile-fail/feature-gate-abi.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c3ada00316f4d204512aa1ac14450a94fa16b2ef/src%2Ftest%2Fcompile-fail%2Ffeature-gate-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3ada00316f4d204512aa1ac14450a94fa16b2ef/src%2Ftest%2Fcompile-fail%2Ffeature-gate-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-abi.rs?ref=c3ada00316f4d204512aa1ac14450a94fa16b2ef", "patch": "@@ -12,6 +12,7 @@\n // gate-test-platform_intrinsics\n // gate-test-abi_vectorcall\n // gate-test-abi_ptx\n+// gate-test-abi_x86_interrupt\n \n // Functions\n extern \"rust-intrinsic\" fn f1() {} //~ ERROR intrinsics are subject to change\n@@ -20,6 +21,7 @@ extern \"vectorcall\" fn f3() {} //~ ERROR vectorcall is experimental and subject\n extern \"rust-call\" fn f4() {} //~ ERROR rust-call ABI is subject to change\n extern \"msp430-interrupt\" fn f5() {} //~ ERROR msp430-interrupt ABI is experimental\n extern \"ptx-kernel\" fn f6() {} //~ ERROR PTX ABIs are experimental and subject to change\n+extern \"x86-interrupt\" fn f7() {} //~ ERROR x86-interrupt ABI is experimental\n \n // Methods in trait definition\n trait Tr {\n@@ -29,13 +31,15 @@ trait Tr {\n     extern \"rust-call\" fn m4(); //~ ERROR rust-call ABI is subject to change\n     extern \"msp430-interrupt\" fn m5(); //~ ERROR msp430-interrupt ABI is experimental\n     extern \"ptx-kernel\" fn m6(); //~ ERROR PTX ABIs are experimental and subject to change\n+    extern \"x86-interrupt\" fn m7(); //~ ERROR x86-interrupt ABI is experimental\n \n     extern \"rust-intrinsic\" fn dm1() {} //~ ERROR intrinsics are subject to change\n     extern \"platform-intrinsic\" fn dm2() {} //~ ERROR platform intrinsics are experimental\n     extern \"vectorcall\" fn dm3() {} //~ ERROR vectorcall is experimental and subject to change\n     extern \"rust-call\" fn dm4() {} //~ ERROR rust-call ABI is subject to change\n     extern \"msp430-interrupt\" fn dm5() {} //~ ERROR msp430-interrupt ABI is experimental\n     extern \"ptx-kernel\" fn dm6() {} //~ ERROR PTX ABIs are experimental and subject to change\n+    extern \"x86-interrupt\" fn dm7() {} //~ ERROR x86-interrupt ABI is experimental\n }\n \n struct S;\n@@ -48,6 +52,7 @@ impl Tr for S {\n     extern \"rust-call\" fn m4() {} //~ ERROR rust-call ABI is subject to change\n     extern \"msp430-interrupt\" fn m5() {} //~ ERROR msp430-interrupt ABI is experimental\n     extern \"ptx-kernel\" fn m6() {} //~ ERROR PTX ABIs are experimental and subject to change\n+    extern \"x86-interrupt\" fn m7() {} //~ ERROR x86-interrupt ABI is experimental\n }\n \n // Methods in inherent impl\n@@ -58,6 +63,7 @@ impl S {\n     extern \"rust-call\" fn im4() {} //~ ERROR rust-call ABI is subject to change\n     extern \"msp430-interrupt\" fn im5() {} //~ ERROR msp430-interrupt ABI is experimental\n     extern \"ptx-kernel\" fn im6() {} //~ ERROR PTX ABIs are experimental and subject to change\n+    extern \"x86-interrupt\" fn im7() {} //~ ERROR x86-interrupt ABI is experimental\n }\n \n // Function pointer types\n@@ -67,6 +73,7 @@ type A3 = extern \"vectorcall\" fn(); //~ ERROR vectorcall is experimental and sub\n type A4 = extern \"rust-call\" fn(); //~ ERROR rust-call ABI is subject to change\n type A5 = extern \"msp430-interrupt\" fn(); //~ ERROR msp430-interrupt ABI is experimental\n type A6 = extern \"ptx-kernel\" fn (); //~ ERROR PTX ABIs are experimental and subject to change\n+type A7 = extern \"x86-interrupt\" fn(); //~ ERROR x86-interrupt ABI is experimental\n \n // Foreign modules\n extern \"rust-intrinsic\" {} //~ ERROR intrinsics are subject to change\n@@ -75,5 +82,6 @@ extern \"vectorcall\" {} //~ ERROR vectorcall is experimental and subject to chang\n extern \"rust-call\" {} //~ ERROR rust-call ABI is subject to change\n extern \"msp430-interrupt\" {} //~ ERROR msp430-interrupt ABI is experimental\n extern \"ptx-kernel\" {} //~ ERROR PTX ABIs are experimental and subject to change\n+extern \"x86-interrupt\" {} //~ ERROR x86-interrupt ABI is experimental\n \n fn main() {}"}, {"sha": "eef8793511529fab5d904d6b766ce8b8a263d96b", "filename": "src/test/ui/codemap_tests/unicode.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3ada00316f4d204512aa1ac14450a94fa16b2ef/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c3ada00316f4d204512aa1ac14450a94fa16b2ef/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.stderr?ref=c3ada00316f4d204512aa1ac14450a94fa16b2ef", "patch": "@@ -1,4 +1,4 @@\n-error: invalid ABI: expected one of [cdecl, stdcall, fastcall, vectorcall, aapcs, win64, sysv64, ptx-kernel, msp430-interrupt, Rust, C, system, rust-intrinsic, rust-call, platform-intrinsic, unadjusted], found `\u8def\u6feb\u72fc\u00e1\u0301\u0301`\n+error: invalid ABI: expected one of [cdecl, stdcall, fastcall, vectorcall, aapcs, win64, sysv64, ptx-kernel, msp430-interrupt, x86-interrupt, Rust, C, system, rust-intrinsic, rust-call, platform-intrinsic, unadjusted], found `\u8def\u6feb\u72fc\u00e1\u0301\u0301`\n   --> $DIR/unicode.rs:11:8\n    |\n 11 | extern \"\u8def\u6feb\u72fc\u00e1\u0301\u0301\" fn foo() {}"}]}