{"sha": "556c9cebdb91278702263df4ac8c99ec24ab331a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1NmM5Y2ViZGI5MTI3ODcwMjI2M2RmNGFjOGM5OWVjMjRhYjMzMWE=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-05-21T15:41:20Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-05-21T16:23:03Z"}, "message": "Refactor expectation handling\n\nSo as to not use `TyKind::Error` as \"no expectation\".", "tree": {"sha": "d1895aa19a6ec1b7532871e171f1c37870298f58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1895aa19a6ec1b7532871e171f1c37870298f58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/556c9cebdb91278702263df4ac8c99ec24ab331a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/556c9cebdb91278702263df4ac8c99ec24ab331a", "html_url": "https://github.com/rust-lang/rust/commit/556c9cebdb91278702263df4ac8c99ec24ab331a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/556c9cebdb91278702263df4ac8c99ec24ab331a/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99c73537faba59c881805573442562418e0b650a", "url": "https://api.github.com/repos/rust-lang/rust/commits/99c73537faba59c881805573442562418e0b650a", "html_url": "https://github.com/rust-lang/rust/commit/99c73537faba59c881805573442562418e0b650a"}], "stats": {"total": 142, "additions": 88, "deletions": 54}, "files": [{"sha": "a137c0f92827dfa92d0a1ab60b2c246b72df2ae7", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/556c9cebdb91278702263df4ac8c99ec24ab331a/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/556c9cebdb91278702263df4ac8c99ec24ab331a/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=556c9cebdb91278702263df4ac8c99ec24ab331a", "patch": "@@ -370,10 +370,6 @@ impl<'a> InferenceContext<'a> {\n     }\n \n     fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n-        // TODO handle expectations properly\n-        if ty2.is_unknown() {\n-            return true;\n-        }\n         self.table.unify(ty1, ty2)\n     }\n \n@@ -679,17 +675,23 @@ impl<'a> InferenceContext<'a> {\n /// When inferring an expression, we propagate downward whatever type hint we\n /// are able in the form of an `Expectation`.\n #[derive(Clone, PartialEq, Eq, Debug)]\n-struct Expectation {\n-    ty: Ty,\n-    /// See the `rvalue_hint` method.\n-    rvalue_hint: bool,\n+enum Expectation {\n+    None,\n+    HasType(Ty),\n+    // Castable(Ty), // rustc has this, we currently just don't propagate an expectation for casts\n+    RValueLikeUnsized(Ty),\n }\n \n impl Expectation {\n     /// The expectation that the type of the expression needs to equal the given\n     /// type.\n     fn has_type(ty: Ty) -> Self {\n-        Expectation { ty, rvalue_hint: false }\n+        if ty.is_unknown() {\n+            // FIXME: get rid of this?\n+            Expectation::None\n+        } else {\n+            Expectation::HasType(ty)\n+        }\n     }\n \n     /// The following explanation is copied straight from rustc:\n@@ -713,24 +715,41 @@ impl Expectation {\n     /// See the test case `test/ui/coerce-expect-unsized.rs` and #20169\n     /// for examples of where this comes up,.\n     fn rvalue_hint(ty: Ty) -> Self {\n-        Expectation { ty, rvalue_hint: true }\n+        match ty.strip_references().kind(&Interner) {\n+            TyKind::Slice(_) | TyKind::Str | TyKind::Dyn(_) => Expectation::RValueLikeUnsized(ty),\n+            _ => Expectation::has_type(ty),\n+        }\n     }\n \n     /// This expresses no expectation on the type.\n     fn none() -> Self {\n-        Expectation {\n-            // FIXME\n-            ty: TyKind::Error.intern(&Interner),\n-            rvalue_hint: false,\n+        Expectation::None\n+    }\n+\n+    fn resolve(&self, table: &mut unify::InferenceTable) -> Expectation {\n+        match self {\n+            Expectation::None => Expectation::None,\n+            Expectation::HasType(t) => Expectation::HasType(table.resolve_ty_shallow(t)),\n+            Expectation::RValueLikeUnsized(t) => {\n+                Expectation::RValueLikeUnsized(table.resolve_ty_shallow(t))\n+            }\n         }\n     }\n \n-    fn coercion_target(&self) -> Ty {\n-        if self.rvalue_hint {\n-            // FIXME\n-            TyKind::Error.intern(&Interner)\n-        } else {\n-            self.ty.clone()\n+    fn to_option(&self, table: &mut unify::InferenceTable) -> Option<Ty> {\n+        match self.resolve(table) {\n+            Expectation::None => None,\n+            Expectation::HasType(t) |\n+            // Expectation::Castable(t) |\n+            Expectation::RValueLikeUnsized(t) => Some(t),\n+        }\n+    }\n+\n+    fn only_has_type(&self, table: &mut unify::InferenceTable) -> Option<Ty> {\n+        match self {\n+            Expectation::HasType(t) => Some(table.resolve_ty_shallow(t)),\n+            // Expectation::Castable(_) |\n+            Expectation::RValueLikeUnsized(_) | Expectation::None => None,\n         }\n     }\n }"}, {"sha": "03dd6ae763b6e9b8a0d5957615249d2d533ab16a", "filename": "crates/hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/556c9cebdb91278702263df4ac8c99ec24ab331a/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/556c9cebdb91278702263df4ac8c99ec24ab331a/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=556c9cebdb91278702263df4ac8c99ec24ab331a", "patch": "@@ -21,10 +21,6 @@ impl<'a> InferenceContext<'a> {\n     pub(super) fn coerce(&mut self, from_ty: &Ty, to_ty: &Ty) -> bool {\n         let from_ty = self.resolve_ty_shallow(from_ty);\n         let to_ty = self.resolve_ty_shallow(to_ty);\n-        // TODO handle expectations properly\n-        if to_ty.is_unknown() {\n-            return true;\n-        }\n         match self.coerce_inner(from_ty, &to_ty) {\n             Ok(result) => {\n                 self.table.register_infer_ok(result);"}, {"sha": "4ef847d3a5360c71baa3272fc9d4d6e790804fa3", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 49, "deletions": 30, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/556c9cebdb91278702263df4ac8c99ec24ab331a/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/556c9cebdb91278702263df4ac8c99ec24ab331a/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=556c9cebdb91278702263df4ac8c99ec24ab331a", "patch": "@@ -39,12 +39,14 @@ impl<'a> InferenceContext<'a> {\n             // Any expression that produces a value of type `!` must have diverged\n             self.diverges = Diverges::Always;\n         }\n-        let could_unify = self.unify(&ty, &expected.ty);\n-        if !could_unify {\n-            self.result.type_mismatches.insert(\n-                tgt_expr.into(),\n-                TypeMismatch { expected: expected.ty.clone(), actual: ty.clone() },\n-            );\n+        if let Some(expected_ty) = expected.only_has_type(&mut self.table) {\n+            let could_unify = self.unify(&ty, &expected_ty);\n+            if !could_unify {\n+                self.result.type_mismatches.insert(\n+                    tgt_expr.into(),\n+                    TypeMismatch { expected: expected_ty.clone(), actual: ty.clone() },\n+                );\n+            }\n         }\n         ty\n     }\n@@ -53,18 +55,20 @@ impl<'a> InferenceContext<'a> {\n     /// Return the type after possible coercion.\n     pub(super) fn infer_expr_coerce(&mut self, expr: ExprId, expected: &Expectation) -> Ty {\n         let ty = self.infer_expr_inner(expr, &expected);\n-        let ty = if !self.coerce(&ty, &expected.coercion_target()) {\n-            self.result.type_mismatches.insert(\n-                expr.into(),\n-                TypeMismatch { expected: expected.ty.clone(), actual: ty.clone() },\n-            );\n-            // Return actual type when type mismatch.\n-            // This is needed for diagnostic when return type mismatch.\n-            ty\n-        } else if expected.coercion_target().is_unknown() {\n-            ty\n+        let ty = if let Some(target) = expected.only_has_type(&mut self.table) {\n+            if !self.coerce(&ty, &target) {\n+                self.result.type_mismatches.insert(\n+                    expr.into(),\n+                    TypeMismatch { expected: target.clone(), actual: ty.clone() },\n+                );\n+                // Return actual type when type mismatch.\n+                // This is needed for diagnostic when return type mismatch.\n+                ty\n+            } else {\n+                target.clone()\n+            }\n         } else {\n-            expected.ty.clone()\n+            ty\n         };\n \n         ty\n@@ -280,7 +284,9 @@ impl<'a> InferenceContext<'a> {\n                 // Eagerly try to relate the closure type with the expected\n                 // type, otherwise we often won't have enough information to\n                 // infer the body.\n-                self.coerce(&closure_ty, &expected.ty);\n+                if let Some(t) = expected.only_has_type(&mut self.table) {\n+                    self.coerce(&closure_ty, &t);\n+                }\n \n                 // Now go through the argument patterns\n                 for (arg_pat, arg_ty) in args.iter().zip(sig_tys) {\n@@ -413,7 +419,9 @@ impl<'a> InferenceContext<'a> {\n                     self.write_variant_resolution(tgt_expr.into(), variant);\n                 }\n \n-                self.unify(&ty, &expected.ty);\n+                if let Some(t) = expected.only_has_type(&mut self.table) {\n+                    self.unify(&ty, &t);\n+                }\n \n                 let substs = ty\n                     .as_adt()\n@@ -516,21 +524,24 @@ impl<'a> InferenceContext<'a> {\n                 self.resolve_associated_type(inner_ty, self.resolve_ops_try_ok())\n             }\n             Expr::Cast { expr, type_ref } => {\n+                // FIXME: propagate the \"castable to\" expectation (and find a test case that shows this is necessary)\n                 let _inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n                 let cast_ty = self.make_ty(type_ref);\n                 // FIXME check the cast...\n                 cast_ty\n             }\n             Expr::Ref { expr, rawness, mutability } => {\n                 let mutability = lower_to_chalk_mutability(*mutability);\n-                let expectation = if let Some((exp_inner, exp_rawness, exp_mutability)) =\n-                    &self.resolve_ty_shallow(&expected.ty).as_reference_or_ptr()\n+                let expectation = if let Some((exp_inner, exp_rawness, exp_mutability)) = expected\n+                    .only_has_type(&mut self.table)\n+                    .as_ref()\n+                    .and_then(|t| t.as_reference_or_ptr())\n                 {\n-                    if *exp_mutability == Mutability::Mut && mutability == Mutability::Not {\n+                    if exp_mutability == Mutability::Mut && mutability == Mutability::Not {\n                         // FIXME: record type error - expected mut reference but found shared ref,\n                         // which cannot be coerced\n                     }\n-                    if *exp_rawness == Rawness::Ref && *rawness == Rawness::RawPtr {\n+                    if exp_rawness == Rawness::Ref && *rawness == Rawness::RawPtr {\n                         // FIXME: record type error - expected reference but found ptr,\n                         // which cannot be coerced\n                     }\n@@ -701,8 +712,12 @@ impl<'a> InferenceContext<'a> {\n                 }\n             }\n             Expr::Tuple { exprs } => {\n-                let mut tys = match self.resolve_ty_shallow(&expected.ty).kind(&Interner) {\n-                    TyKind::Tuple(_, substs) => substs\n+                let mut tys = match expected\n+                    .only_has_type(&mut self.table)\n+                    .as_ref()\n+                    .map(|t| t.kind(&Interner))\n+                {\n+                    Some(TyKind::Tuple(_, substs)) => substs\n                         .iter(&Interner)\n                         .map(|a| a.assert_ty_ref(&Interner).clone())\n                         .chain(repeat_with(|| self.table.new_type_var()))\n@@ -718,14 +733,16 @@ impl<'a> InferenceContext<'a> {\n                 TyKind::Tuple(tys.len(), Substitution::from_iter(&Interner, tys)).intern(&Interner)\n             }\n             Expr::Array(array) => {\n-                let elem_ty = match self.resolve_ty_shallow(&expected.ty).kind(&Interner) {\n-                    TyKind::Array(st, _) | TyKind::Slice(st) => st.clone(),\n-                    _ => self.table.new_type_var(),\n-                };\n+                let elem_ty =\n+                    match expected.to_option(&mut self.table).as_ref().map(|t| t.kind(&Interner)) {\n+                        Some(TyKind::Array(st, _)) | Some(TyKind::Slice(st)) => st.clone(),\n+                        _ => self.table.new_type_var(),\n+                    };\n \n                 let len = match array {\n                     Array::ElementList(items) => {\n                         for expr in items.iter() {\n+                            // FIXME: use CoerceMany (coerce_merge_branch)\n                             self.infer_expr_coerce(*expr, &Expectation::has_type(elem_ty.clone()));\n                         }\n                         Some(items.len() as u64)\n@@ -839,7 +856,9 @@ impl<'a> InferenceContext<'a> {\n                 // we don't even make an attempt at coercion\n                 self.table.new_maybe_never_var()\n             } else {\n-                self.coerce(&TyBuilder::unit(), &expected.coercion_target());\n+                if let Some(t) = expected.only_has_type(&mut self.table) {\n+                    self.coerce(&TyBuilder::unit(), &t);\n+                }\n                 TyBuilder::unit()\n             }\n         };"}]}