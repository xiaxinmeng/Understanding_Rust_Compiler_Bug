{"sha": "87788097b776f8e3662f76627944230684b671bd", "node_id": "C_kwDOAAsO6NoAKDg3Nzg4MDk3Yjc3NmY4ZTM2NjJmNzY2Mjc5NDQyMzA2ODRiNjcxYmQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-08T15:53:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-08T15:53:14Z"}, "message": "Auto merge of #101577 - Dylan-DPC:rollup-l9xw7i7, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #98933 (Opaque types' generic params do not imply anything about their hidden type's lifetimes)\n - #101041 (translations(rustc_session): migrates rustc_session to use SessionDiagnostic - Pt. 2)\n - #101424 (Adjust and slightly generalize operator error suggestion)\n - #101496 (Allow lower_lifetime_binder receive a closure)\n - #101501 (Allow lint passes to be bound by `TyCtxt`)\n - #101515 (Recover from typo where == is used in place of =)\n - #101545 (Remove unnecessary `PartialOrd` and `Ord`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "d9dcf415e1876695a0a26f483a6dba10d66d4917", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9dcf415e1876695a0a26f483a6dba10d66d4917"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87788097b776f8e3662f76627944230684b671bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87788097b776f8e3662f76627944230684b671bd", "html_url": "https://github.com/rust-lang/rust/commit/87788097b776f8e3662f76627944230684b671bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87788097b776f8e3662f76627944230684b671bd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24d69920201563f0ee7b530f1cda0f171b205cc2", "url": "https://api.github.com/repos/rust-lang/rust/commits/24d69920201563f0ee7b530f1cda0f171b205cc2", "html_url": "https://github.com/rust-lang/rust/commit/24d69920201563f0ee7b530f1cda0f171b205cc2"}, {"sha": "720a82dd52609f0dd90a51da4dd53fb51116241e", "url": "https://api.github.com/repos/rust-lang/rust/commits/720a82dd52609f0dd90a51da4dd53fb51116241e", "html_url": "https://github.com/rust-lang/rust/commit/720a82dd52609f0dd90a51da4dd53fb51116241e"}], "stats": {"total": 1700, "additions": 1038, "deletions": 662}, "files": [{"sha": "5346f1ced829477a0e022726268ab621202a37c0", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -849,21 +849,22 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             (body_id, generator_option)\n         });\n \n-        let bound_generic_params = self.lower_lifetime_binder(closure_id, generic_params);\n-        // Lower outside new scope to preserve `is_in_loop_condition`.\n-        let fn_decl = self.lower_fn_decl(decl, None, FnDeclKind::Closure, None);\n-\n-        let c = self.arena.alloc(hir::Closure {\n-            binder: binder_clause,\n-            capture_clause,\n-            bound_generic_params,\n-            fn_decl,\n-            body: body_id,\n-            fn_decl_span: self.lower_span(fn_decl_span),\n-            movability: generator_option,\n-        });\n+        self.lower_lifetime_binder(closure_id, generic_params, |lctx, bound_generic_params| {\n+            // Lower outside new scope to preserve `is_in_loop_condition`.\n+            let fn_decl = lctx.lower_fn_decl(decl, None, FnDeclKind::Closure, None);\n+\n+            let c = lctx.arena.alloc(hir::Closure {\n+                binder: binder_clause,\n+                capture_clause,\n+                bound_generic_params,\n+                fn_decl,\n+                body: body_id,\n+                fn_decl_span: lctx.lower_span(fn_decl_span),\n+                movability: generator_option,\n+            });\n \n-        hir::ExprKind::Closure(c)\n+            hir::ExprKind::Closure(c)\n+        })\n     }\n \n     fn generator_movability_for_fn(\n@@ -950,23 +951,23 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             body_id\n         });\n \n-        let bound_generic_params = self.lower_lifetime_binder(closure_id, generic_params);\n-\n-        // We need to lower the declaration outside the new scope, because we\n-        // have to conserve the state of being inside a loop condition for the\n-        // closure argument types.\n-        let fn_decl = self.lower_fn_decl(&outer_decl, None, FnDeclKind::Closure, None);\n-\n-        let c = self.arena.alloc(hir::Closure {\n-            binder: binder_clause,\n-            capture_clause,\n-            bound_generic_params,\n-            fn_decl,\n-            body,\n-            fn_decl_span: self.lower_span(fn_decl_span),\n-            movability: None,\n-        });\n-        hir::ExprKind::Closure(c)\n+        self.lower_lifetime_binder(closure_id, generic_params, |lctx, bound_generic_params| {\n+            // We need to lower the declaration outside the new scope, because we\n+            // have to conserve the state of being inside a loop condition for the\n+            // closure argument types.\n+            let fn_decl = lctx.lower_fn_decl(&outer_decl, None, FnDeclKind::Closure, None);\n+\n+            let c = lctx.arena.alloc(hir::Closure {\n+                binder: binder_clause,\n+                capture_clause,\n+                bound_generic_params,\n+                fn_decl,\n+                body,\n+                fn_decl_span: lctx.lower_span(fn_decl_span),\n+                movability: None,\n+            });\n+            hir::ExprKind::Closure(c)\n+        })\n     }\n \n     /// Destructure the LHS of complex assignments."}, {"sha": "04cf8f6411c2c81794759a38bda75f85548e9af5", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 33, "deletions": 20, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -810,23 +810,31 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// name resolver owing to lifetime elision; this also populates the resolver's node-id->def-id\n     /// map, so that later calls to `opt_node_id_to_def_id` that refer to these extra lifetime\n     /// parameters will be successful.\n-    #[instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self, in_binder))]\n     #[inline]\n-    fn lower_lifetime_binder(\n+    fn lower_lifetime_binder<R>(\n         &mut self,\n         binder: NodeId,\n         generic_params: &[GenericParam],\n-    ) -> &'hir [hir::GenericParam<'hir>] {\n-        let mut generic_params: Vec<_> = self.lower_generic_params_mut(generic_params).collect();\n+        in_binder: impl FnOnce(&mut Self, &'hir [hir::GenericParam<'hir>]) -> R,\n+    ) -> R {\n         let extra_lifetimes = self.resolver.take_extra_lifetime_params(binder);\n         debug!(?extra_lifetimes);\n-        generic_params.extend(extra_lifetimes.into_iter().filter_map(|(ident, node_id, res)| {\n-            self.lifetime_res_to_generic_param(ident, node_id, res)\n-        }));\n+        let extra_lifetimes: Vec<_> = extra_lifetimes\n+            .into_iter()\n+            .filter_map(|(ident, node_id, res)| {\n+                self.lifetime_res_to_generic_param(ident, node_id, res)\n+            })\n+            .collect();\n+\n+        let generic_params: Vec<_> = self\n+            .lower_generic_params_mut(generic_params)\n+            .chain(extra_lifetimes.into_iter())\n+            .collect();\n         let generic_params = self.arena.alloc_from_iter(generic_params);\n         debug!(?generic_params);\n \n-        generic_params\n+        in_binder(self, generic_params)\n     }\n \n     fn with_dyn_type_scope<T>(&mut self, in_scope: bool, f: impl FnOnce(&mut Self) -> T) -> T {\n@@ -1236,14 +1244,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 hir::TyKind::Rptr(lifetime, self.lower_mt(mt, itctx))\n             }\n             TyKind::BareFn(ref f) => {\n-                let generic_params = self.lower_lifetime_binder(t.id, &f.generic_params);\n-                hir::TyKind::BareFn(self.arena.alloc(hir::BareFnTy {\n-                    generic_params,\n-                    unsafety: self.lower_unsafety(f.unsafety),\n-                    abi: self.lower_extern(f.ext),\n-                    decl: self.lower_fn_decl(&f.decl, None, FnDeclKind::Pointer, None),\n-                    param_names: self.lower_fn_params_to_names(&f.decl),\n-                }))\n+                self.lower_lifetime_binder(t.id, &f.generic_params, |lctx, generic_params| {\n+                    hir::TyKind::BareFn(lctx.arena.alloc(hir::BareFnTy {\n+                        generic_params,\n+                        unsafety: lctx.lower_unsafety(f.unsafety),\n+                        abi: lctx.lower_extern(f.ext),\n+                        decl: lctx.lower_fn_decl(&f.decl, None, FnDeclKind::Pointer, None),\n+                        param_names: lctx.lower_fn_params_to_names(&f.decl),\n+                    }))\n+                })\n             }\n             TyKind::Never => hir::TyKind::Never,\n             TyKind::Tup(ref tys) => hir::TyKind::Tup(\n@@ -2143,10 +2152,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         p: &PolyTraitRef,\n         itctx: &mut ImplTraitContext,\n     ) -> hir::PolyTraitRef<'hir> {\n-        let bound_generic_params =\n-            self.lower_lifetime_binder(p.trait_ref.ref_id, &p.bound_generic_params);\n-        let trait_ref = self.lower_trait_ref(&p.trait_ref, itctx);\n-        hir::PolyTraitRef { bound_generic_params, trait_ref, span: self.lower_span(p.span) }\n+        self.lower_lifetime_binder(\n+            p.trait_ref.ref_id,\n+            &p.bound_generic_params,\n+            |lctx, bound_generic_params| {\n+                let trait_ref = lctx.lower_trait_ref(&p.trait_ref, itctx);\n+                hir::PolyTraitRef { bound_generic_params, trait_ref, span: lctx.lower_span(p.span) }\n+            },\n+        )\n     }\n \n     fn lower_mt(&mut self, mt: &MutTy, itctx: &mut ImplTraitContext) -> hir::MutTy<'hir> {"}, {"sha": "de70b17e44ccd77204faa0d68b6be9091c984f91", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -135,7 +135,6 @@ pub struct RegionInferenceContext<'tcx> {\n /// adds a new lower bound to the SCC it is analyzing: so you wind up\n /// with `'R: 'O` where `'R` is the pick-region and `'O` is the\n /// minimal viable option.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]\n pub(crate) struct AppliedMemberConstraint {\n     /// The SCC that was affected. (The \"member region\".)\n     ///"}, {"sha": "f74df3d9746aec4173e0d566dc53c13d8198f055", "filename": "compiler/rustc_error_messages/locales/en-US/parser.ftl", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -153,3 +153,6 @@ parser_left_arrow_operator = unexpected token: `<-`\n \n parser_remove_let = expected pattern, found `let`\n     .suggestion = remove the unnecessary `let` keyword\n+\n+parser_use_eq_instead = unexpected `==`\n+    .suggestion = try using `=` instead"}, {"sha": "d2a2958f62436180cee3436fec51d91694485772", "filename": "compiler/rustc_error_messages/locales/en-US/session.ftl", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -14,3 +14,45 @@ session_feature_diagnostic_for_issue =\n \n session_feature_diagnostic_help =\n     add `#![feature({$feature})]` to the crate attributes to enable\n+\n+session_not_circumvent_feature = `-Zunleash-the-miri-inside-of-you` may not be used to circumvent feature gates, except when testing error paths in the CTFE engine\n+\n+session_profile_use_file_does_not_exist = file `{$path}` passed to `-C profile-use` does not exist.\n+\n+session_linker_plugin_lto_windows_not_supported = linker plugin based LTO is not supported together with `-C prefer-dynamic` when targeting Windows-like targets\n+\n+session_profile_sample_use_file_does_not_exist = file `{$path}` passed to `-C profile-sample-use` does not exist.\n+\n+session_target_requires_unwind_tables = target requires unwind tables, they cannot be disabled with `-C force-unwind-tables=no`\n+\n+session_sanitizer_not_supported = {$us} sanitizer is not supported for this target\n+\n+session_sanitizers_not_supported = {$us} sanitizers are not supported for this target\n+\n+session_cannot_mix_and_match_sanitizers = `-Zsanitizer={$first}` is incompatible with `-Zsanitizer={$second}`\n+\n+session_cannot_enable_crt_static_linux = sanitizer is incompatible with statically linked libc, disable it using `-C target-feature=-crt-static`\n+\n+session_sanitizer_cfi_enabled = `-Zsanitizer=cfi` requires `-Clto`\n+\n+session_unstable_virtual_function_elimination = `-Zvirtual-function-elimination` requires `-Clto`\n+\n+session_unsupported_dwarf_version = requested DWARF version {$dwarf_version} is greater than 5\n+\n+session_target_invalid_address_space = invalid address space `{$addr_space}` for `{$cause}` in \"data-layout\": {$err}\n+\n+session_target_invalid_bits = invalid {$kind} `{$bit}` for `{$cause}` in \"data-layout\": {$err}\n+\n+session_target_missing_alignment = missing alignment for `{$cause}` in \"data-layout\"\n+\n+session_target_invalid_alignment = invalid alignment for `{$cause}` in \"data-layout\": {$err}\n+\n+session_target_inconsistent_architecture = inconsistent target specification: \"data-layout\" claims architecture is {$dl}-endian, while \"target-endian\" is `{$target}`\n+\n+session_target_inconsistent_pointer_width = inconsistent target specification: \"data-layout\" claims pointers are {$pointer_size}-bit, while \"target-pointer-width\" is `{$target}`\n+\n+session_target_invalid_bits_size = {$err}\n+\n+session_target_stack_protector_not_supported = `-Z stack-protector={$stack_protector}` is not supported for target {$target_triple} and will be ignored\n+\n+session_split_debuginfo_unstable_platform = `-Csplit-debuginfo={$debuginfo}` is unstable on this platform"}, {"sha": "a774b52c8a592e75a321efa8b377c04167b2fd92", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -10,10 +10,11 @@ use rustc_lint_defs::{Applicability, LintExpectationId};\n use rustc_span::edition::LATEST_STABLE_EDITION;\n use rustc_span::symbol::{Ident, MacroRulesNormalizedIdent, Symbol};\n use rustc_span::{edition::Edition, Span, DUMMY_SP};\n-use rustc_target::spec::PanicStrategy;\n+use rustc_target::spec::{PanicStrategy, SplitDebuginfo, StackProtector, TargetTriple};\n use std::borrow::Cow;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n+use std::num::ParseIntError;\n use std::path::{Path, PathBuf};\n \n /// Error type for `Diagnostic`'s `suggestions` field, indicating that\n@@ -91,6 +92,10 @@ into_diagnostic_arg_using_display!(\n     Edition,\n     Ident,\n     MacroRulesNormalizedIdent,\n+    ParseIntError,\n+    StackProtector,\n+    &TargetTriple,\n+    SplitDebuginfo\n );\n \n impl IntoDiagnosticArg for bool {"}, {"sha": "3e02d2ebb7e3e05bc207fc72d01fb657e5c5a2d7", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -456,7 +456,7 @@ struct HandlerInner {\n }\n \n /// A key denoting where from a diagnostic was stashed.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub enum StashKey {\n     ItemNoType,\n     UnderscoreForArrayLengths,"}, {"sha": "b44ee02cfe3bb2af57d692d79c892054af5ed815", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -457,7 +457,7 @@ impl PartialRes {\n \n /// Different kinds of symbols can coexist even if they share the same textual name.\n /// Therefore, they each have a separate universe (known as a \"namespace\").\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub enum Namespace {\n     /// The type namespace includes `struct`s, `enum`s, `union`s, `trait`s, and `mod`s\n     /// (and, by extension, crates)."}, {"sha": "a79c982649afca775168aa27d61a4a875bad075a", "filename": "compiler/rustc_lexer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Flib.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -141,7 +141,7 @@ pub enum TokenKind {\n     Unknown,\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n pub enum DocStyle {\n     Outer,\n     Inner,"}, {"sha": "7ca6ec5d9623475eaeabb13eba62360d85cd7d8c", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -50,6 +50,10 @@ use std::cell::Cell;\n use std::iter;\n use std::slice;\n \n+type EarlyLintPassFactory = dyn Fn() -> EarlyLintPassObject + sync::Send + sync::Sync;\n+type LateLintPassFactory =\n+    dyn for<'tcx> Fn(TyCtxt<'tcx>) -> LateLintPassObject<'tcx> + sync::Send + sync::Sync;\n+\n /// Information about the registered lints.\n ///\n /// This is basically the subset of `Context` that we can\n@@ -64,11 +68,11 @@ pub struct LintStore {\n     /// interior mutability, we don't enforce this (and lints should, in theory,\n     /// be compatible with being constructed more than once, though not\n     /// necessarily in a sane manner. This is safe though.)\n-    pub pre_expansion_passes: Vec<Box<dyn Fn() -> EarlyLintPassObject + sync::Send + sync::Sync>>,\n-    pub early_passes: Vec<Box<dyn Fn() -> EarlyLintPassObject + sync::Send + sync::Sync>>,\n-    pub late_passes: Vec<Box<dyn Fn() -> LateLintPassObject + sync::Send + sync::Sync>>,\n+    pub pre_expansion_passes: Vec<Box<EarlyLintPassFactory>>,\n+    pub early_passes: Vec<Box<EarlyLintPassFactory>>,\n+    pub late_passes: Vec<Box<LateLintPassFactory>>,\n     /// This is unique in that we construct them per-module, so not once.\n-    pub late_module_passes: Vec<Box<dyn Fn() -> LateLintPassObject + sync::Send + sync::Sync>>,\n+    pub late_module_passes: Vec<Box<LateLintPassFactory>>,\n \n     /// Lints indexed by name.\n     by_name: FxHashMap<String, TargetLint>,\n@@ -186,14 +190,20 @@ impl LintStore {\n \n     pub fn register_late_pass(\n         &mut self,\n-        pass: impl Fn() -> LateLintPassObject + 'static + sync::Send + sync::Sync,\n+        pass: impl for<'tcx> Fn(TyCtxt<'tcx>) -> LateLintPassObject<'tcx>\n+        + 'static\n+        + sync::Send\n+        + sync::Sync,\n     ) {\n         self.late_passes.push(Box::new(pass));\n     }\n \n     pub fn register_late_mod_pass(\n         &mut self,\n-        pass: impl Fn() -> LateLintPassObject + 'static + sync::Send + sync::Sync,\n+        pass: impl for<'tcx> Fn(TyCtxt<'tcx>) -> LateLintPassObject<'tcx>\n+        + 'static\n+        + sync::Send\n+        + sync::Sync,\n     ) {\n         self.late_module_passes.push(Box::new(pass));\n     }\n@@ -558,7 +568,7 @@ pub trait LintPassObject: Sized {}\n \n impl LintPassObject for EarlyLintPassObject {}\n \n-impl LintPassObject for LateLintPassObject {}\n+impl LintPassObject for LateLintPassObject<'_> {}\n \n pub trait LintContext: Sized {\n     type PassObject: LintPassObject;\n@@ -949,8 +959,8 @@ impl<'a> EarlyContext<'a> {\n     }\n }\n \n-impl LintContext for LateContext<'_> {\n-    type PassObject = LateLintPassObject;\n+impl<'tcx> LintContext for LateContext<'tcx> {\n+    type PassObject = LateLintPassObject<'tcx>;\n \n     /// Gets the overall compiler `Session` object.\n     fn sess(&self) -> &Session {"}, {"sha": "66dc3ed59a3841b00b64b19196f14151382ab1e7", "filename": "compiler/rustc_lint/src/late.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flate.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -306,12 +306,12 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n     }\n }\n \n-struct LateLintPassObjects<'a> {\n-    lints: &'a mut [LateLintPassObject],\n+struct LateLintPassObjects<'a, 'tcx> {\n+    lints: &'a mut [LateLintPassObject<'tcx>],\n }\n \n #[allow(rustc::lint_pass_impl_without_macro)]\n-impl LintPass for LateLintPassObjects<'_> {\n+impl LintPass for LateLintPassObjects<'_, '_> {\n     fn name(&self) -> &'static str {\n         panic!()\n     }\n@@ -329,7 +329,7 @@ macro_rules! expand_late_lint_pass_impl_methods {\n \n macro_rules! late_lint_pass_impl {\n     ([], [$hir:tt], $methods:tt) => {\n-        impl<$hir> LateLintPass<$hir> for LateLintPassObjects<'_> {\n+        impl<$hir> LateLintPass<$hir> for LateLintPassObjects<'_, $hir> {\n             expand_late_lint_pass_impl_methods!([$hir], $methods);\n         }\n     };\n@@ -382,7 +382,7 @@ pub fn late_lint_mod<'tcx, T: LateLintPass<'tcx>>(\n     late_lint_mod_pass(tcx, module_def_id, builtin_lints);\n \n     let mut passes: Vec<_> =\n-        unerased_lint_store(tcx).late_module_passes.iter().map(|pass| (pass)()).collect();\n+        unerased_lint_store(tcx).late_module_passes.iter().map(|pass| (pass)(tcx)).collect();\n \n     if !passes.is_empty() {\n         late_lint_mod_pass(tcx, module_def_id, LateLintPassObjects { lints: &mut passes[..] });\n@@ -418,7 +418,8 @@ fn late_lint_pass_crate<'tcx, T: LateLintPass<'tcx>>(tcx: TyCtxt<'tcx>, pass: T)\n }\n \n fn late_lint_crate<'tcx, T: LateLintPass<'tcx>>(tcx: TyCtxt<'tcx>, builtin_lints: T) {\n-    let mut passes = unerased_lint_store(tcx).late_passes.iter().map(|p| (p)()).collect::<Vec<_>>();\n+    let mut passes =\n+        unerased_lint_store(tcx).late_passes.iter().map(|p| (p)(tcx)).collect::<Vec<_>>();\n \n     if !tcx.sess.opts.unstable_opts.no_interleave_lints {\n         if !passes.is_empty() {\n@@ -434,7 +435,7 @@ fn late_lint_crate<'tcx, T: LateLintPass<'tcx>>(tcx: TyCtxt<'tcx>, builtin_lints\n         }\n \n         let mut passes: Vec<_> =\n-            unerased_lint_store(tcx).late_module_passes.iter().map(|pass| (pass)()).collect();\n+            unerased_lint_store(tcx).late_module_passes.iter().map(|pass| (pass)(tcx)).collect();\n \n         for pass in &mut passes {\n             tcx.sess.prof.extra_verbose_generic_activity(\"run_late_module_lint\", pass.name()).run("}, {"sha": "e0e6f1a8c080caf0b3dbbe2748262041acd6ca2b", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -260,26 +260,41 @@ fn register_builtins(store: &mut LintStore, no_interleave_lints: bool) {\n         )\n     }\n \n-    macro_rules! register_pass {\n+    macro_rules! register_early_pass {\n         ($method:ident, $ty:ident, $constructor:expr) => {\n             store.register_lints(&$ty::get_lints());\n             store.$method(|| Box::new($constructor));\n         };\n     }\n \n-    macro_rules! register_passes {\n+    macro_rules! register_late_pass {\n+        ($method:ident, $ty:ident, $constructor:expr) => {\n+            store.register_lints(&$ty::get_lints());\n+            store.$method(|_| Box::new($constructor));\n+        };\n+    }\n+\n+    macro_rules! register_early_passes {\n+        ($method:ident, [$($passes:ident: $constructor:expr,)*]) => (\n+            $(\n+                register_early_pass!($method, $passes, $constructor);\n+            )*\n+        )\n+    }\n+\n+    macro_rules! register_late_passes {\n         ($method:ident, [$($passes:ident: $constructor:expr,)*]) => (\n             $(\n-                register_pass!($method, $passes, $constructor);\n+                register_late_pass!($method, $passes, $constructor);\n             )*\n         )\n     }\n \n     if no_interleave_lints {\n-        pre_expansion_lint_passes!(register_passes, register_pre_expansion_pass);\n-        early_lint_passes!(register_passes, register_early_pass);\n-        late_lint_passes!(register_passes, register_late_pass);\n-        late_lint_mod_passes!(register_passes, register_late_mod_pass);\n+        pre_expansion_lint_passes!(register_early_passes, register_pre_expansion_pass);\n+        early_lint_passes!(register_early_passes, register_early_pass);\n+        late_lint_passes!(register_late_passes, register_late_pass);\n+        late_lint_mod_passes!(register_late_passes, register_late_mod_pass);\n     } else {\n         store.register_lints(&BuiltinCombinedPreExpansionLintPass::get_lints());\n         store.register_lints(&BuiltinCombinedEarlyLintPass::get_lints());\n@@ -510,19 +525,19 @@ fn register_internals(store: &mut LintStore) {\n     store.register_lints(&LintPassImpl::get_lints());\n     store.register_early_pass(|| Box::new(LintPassImpl));\n     store.register_lints(&DefaultHashTypes::get_lints());\n-    store.register_late_pass(|| Box::new(DefaultHashTypes));\n+    store.register_late_pass(|_| Box::new(DefaultHashTypes));\n     store.register_lints(&QueryStability::get_lints());\n-    store.register_late_pass(|| Box::new(QueryStability));\n+    store.register_late_pass(|_| Box::new(QueryStability));\n     store.register_lints(&ExistingDocKeyword::get_lints());\n-    store.register_late_pass(|| Box::new(ExistingDocKeyword));\n+    store.register_late_pass(|_| Box::new(ExistingDocKeyword));\n     store.register_lints(&TyTyKind::get_lints());\n-    store.register_late_pass(|| Box::new(TyTyKind));\n+    store.register_late_pass(|_| Box::new(TyTyKind));\n     store.register_lints(&Diagnostics::get_lints());\n-    store.register_late_pass(|| Box::new(Diagnostics));\n+    store.register_late_pass(|_| Box::new(Diagnostics));\n     store.register_lints(&BadOptAccess::get_lints());\n-    store.register_late_pass(|| Box::new(BadOptAccess));\n+    store.register_late_pass(|_| Box::new(BadOptAccess));\n     store.register_lints(&PassByValue::get_lints());\n-    store.register_late_pass(|| Box::new(PassByValue));\n+    store.register_late_pass(|_| Box::new(PassByValue));\n     // FIXME(davidtwco): deliberately do not include `UNTRANSLATABLE_DIAGNOSTIC` and\n     // `DIAGNOSTIC_OUTSIDE_OF_IMPL` here because `-Wrustc::internal` is provided to every crate and\n     // these lints will trigger all of the time - change this once migration to diagnostic structs"}, {"sha": "666e61b85acfc8c21eeaac9705da51e98f5678d0", "filename": "compiler/rustc_lint/src/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -244,4 +244,4 @@ macro_rules! declare_combined_early_lint_pass {\n \n /// A lint pass boxed up as a trait object.\n pub type EarlyLintPassObject = Box<dyn EarlyLintPass + sync::Send + 'static>;\n-pub type LateLintPassObject = Box<dyn for<'tcx> LateLintPass<'tcx> + sync::Send + 'static>;\n+pub type LateLintPassObject<'tcx> = Box<dyn LateLintPass<'tcx> + sync::Send + 'tcx>;"}, {"sha": "1f7643a76afe505a3ab21c71399a36b439a9d837", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -741,7 +741,7 @@ pub enum TerminatorKind<'tcx> {\n }\n \n /// Information about an assertion failure.\n-#[derive(Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq, PartialOrd)]\n+#[derive(Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq)]\n pub enum AssertKind<O> {\n     BoundsCheck { len: O, index: O },\n     Overflow(BinOp, O, O),"}, {"sha": "02a9958525b2229ebd8fc3d825a2449ffee2ef10", "filename": "compiler/rustc_middle/src/mir/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -14,7 +14,7 @@ use std::slice;\n \n pub use super::query::*;\n \n-#[derive(Debug, Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq, PartialOrd)]\n+#[derive(Debug, Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq)]\n pub struct SwitchTargets {\n     /// Possible values. The locations to branch to in each case\n     /// are found in the corresponding indices from the `targets` vector."}, {"sha": "a56fac7c4dd2ca8bd7b8a1beee419a7b195aff2d", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -12,7 +12,7 @@ pub mod util;\n use crate::infer::canonical::Canonical;\n use crate::ty::abstract_const::NotConstEvaluatable;\n use crate::ty::subst::SubstsRef;\n-use crate::ty::{self, AdtKind, Predicate, Ty, TyCtxt};\n+use crate::ty::{self, AdtKind, Ty, TyCtxt};\n \n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, Diagnostic};\n@@ -416,7 +416,7 @@ pub enum ObligationCauseCode<'tcx> {\n     BinOp {\n         rhs_span: Option<Span>,\n         is_lit: bool,\n-        output_pred: Option<Predicate<'tcx>>,\n+        output_ty: Option<Ty<'tcx>>,\n     },\n }\n "}, {"sha": "53e91e48c24d013275e5de85b3edd8ffa5fc9414", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -1252,7 +1252,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         output_filenames: OutputFilenames,\n     ) -> GlobalCtxt<'tcx> {\n         let data_layout = TargetDataLayout::parse(&s.target).unwrap_or_else(|err| {\n-            s.fatal(&err);\n+            s.emit_fatal(err);\n         });\n         let interners = CtxtInterners::new(arena);\n         let common_types = CommonTypes::new("}, {"sha": "e4ad96b659b0813f4b20df58cb7fe146ab56ce91", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -102,13 +102,25 @@ pub fn suggest_arbitrary_trait_bound<'tcx>(\n     generics: &hir::Generics<'_>,\n     err: &mut Diagnostic,\n     trait_pred: PolyTraitPredicate<'tcx>,\n+    associated_ty: Option<(&'static str, Ty<'tcx>)>,\n ) -> bool {\n     if !trait_pred.is_suggestable(tcx, false) {\n         return false;\n     }\n \n     let param_name = trait_pred.skip_binder().self_ty().to_string();\n-    let constraint = trait_pred.print_modifiers_and_trait_path().to_string();\n+    let mut constraint = trait_pred.print_modifiers_and_trait_path().to_string();\n+\n+    if let Some((name, term)) = associated_ty {\n+        // FIXME: this case overlaps with code in TyCtxt::note_and_explain_type_err.\n+        // That should be extracted into a helper function.\n+        if constraint.ends_with('>') {\n+            constraint = format!(\"{}, {} = {}>\", &constraint[..constraint.len() - 1], name, term);\n+        } else {\n+            constraint.push_str(&format!(\"<{} = {}>\", name, term));\n+        }\n+    }\n+\n     let param = generics.params.iter().find(|p| p.name.ident().as_str() == param_name);\n \n     // Skip, there is a param named Self"}, {"sha": "5f8cb578202103e26f38aca5f58639f022af4913", "filename": "compiler/rustc_middle/src/ty/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -666,7 +666,7 @@ impl<'tcx> TypeVisitor<'tcx> for LateBoundRegionsCollector {\n         // ignore the inputs to a projection, as they may not appear\n         // in the normalized form\n         if self.just_constrained {\n-            if let ty::Projection(..) = t.kind() {\n+            if let ty::Projection(..) | ty::Opaque(..) = t.kind() {\n                 return ControlFlow::CONTINUE;\n             }\n         }"}, {"sha": "be524db785bc0bfd84d87371d28ab1e7625879a3", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -713,6 +713,14 @@ pub(crate) struct RemoveLet {\n     pub span: Span,\n }\n \n+#[derive(SessionDiagnostic)]\n+#[diag(parser::use_eq_instead)]\n+pub(crate) struct UseEqInstead {\n+    #[primary_span]\n+    #[suggestion_short(applicability = \"machine-applicable\", code = \"=\")]\n+    pub span: Span,\n+}\n+\n // SnapshotParser is used to create a snapshot of the parser\n // without causing duplicate errors being emitted when the `Parser`\n // is dropped.\n@@ -957,6 +965,14 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n+        if self.token.kind == TokenKind::EqEq\n+            && self.prev_token.is_ident()\n+            && expected.iter().any(|tok| matches!(tok, TokenType::Token(TokenKind::Eq)))\n+        {\n+            // Likely typo: `=` \u2192 `==` in let expr or enum item\n+            return Err(self.sess.create_err(UseEqInstead { span: self.token.span }));\n+        }\n+\n         let expect = tokens_to_string(&expected);\n         let actual = super::token_descr(&self.token);\n         let (msg_exp, (label_sp, label_exp)) = if expected.len() > 1 {"}, {"sha": "749a78a7552ed366f9463672d1c59d4df3bf5ccd", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -57,7 +57,7 @@ use rustc_span::{Span, DUMMY_SP};\n use smallvec::{smallvec, SmallVec};\n use std::cell::{Cell, RefCell};\n use std::collections::BTreeSet;\n-use std::{cmp, fmt, ptr};\n+use std::{fmt, ptr};\n \n use diagnostics::{ImportSuggestion, LabelSuggestion, Suggestion};\n use imports::{Import, ImportKind, ImportResolver, NameResolution};\n@@ -163,32 +163,13 @@ enum ImplTraitContext {\n     Universal(LocalDefId),\n }\n \n-#[derive(Eq)]\n struct BindingError {\n     name: Symbol,\n     origin: BTreeSet<Span>,\n     target: BTreeSet<Span>,\n     could_be_path: bool,\n }\n \n-impl PartialOrd for BindingError {\n-    fn partial_cmp(&self, other: &BindingError) -> Option<cmp::Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-impl PartialEq for BindingError {\n-    fn eq(&self, other: &BindingError) -> bool {\n-        self.name == other.name\n-    }\n-}\n-\n-impl Ord for BindingError {\n-    fn cmp(&self, other: &BindingError) -> cmp::Ordering {\n-        self.name.cmp(&other.name)\n-    }\n-}\n-\n enum ResolutionError<'a> {\n     /// Error E0401: can't use type or const parameters from outer function.\n     GenericParamsFromOuterFunction(Res, HasGenericParams),\n@@ -845,7 +826,7 @@ impl<'a> NameBinding<'a> {\n     }\n }\n \n-#[derive(Debug, Default, Clone)]\n+#[derive(Default, Clone)]\n pub struct ExternPreludeEntry<'a> {\n     extern_crate_item: Option<&'a NameBinding<'a>>,\n     pub introduced_by_item: bool,"}, {"sha": "8bb3878fbbb4752c8d7f4371cab537ba6b39a658", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -898,7 +898,7 @@ fn default_configuration(sess: &Session) -> CrateConfig {\n     let max_atomic_width = sess.target.max_atomic_width();\n     let atomic_cas = sess.target.atomic_cas;\n     let layout = TargetDataLayout::parse(&sess.target).unwrap_or_else(|err| {\n-        sess.fatal(&err);\n+        sess.emit_fatal(err);\n     });\n \n     let mut ret = CrateConfig::default();"}, {"sha": "3c93cfab183d24206e796c2ebd9e0e808fc00e0a", "filename": "compiler/rustc_session/src/errors.rs", "status": "modified", "additions": 129, "deletions": 2, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ferrors.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -1,10 +1,12 @@\n use std::num::NonZeroU32;\n \n-use crate as rustc_session;\n use crate::cgu_reuse_tracker::CguReuse;\n-use rustc_errors::MultiSpan;\n+use crate::{self as rustc_session, SessionDiagnostic};\n+use rustc_errors::{fluent, DiagnosticBuilder, Handler, MultiSpan};\n use rustc_macros::SessionDiagnostic;\n use rustc_span::{Span, Symbol};\n+use rustc_target::abi::TargetDataLayoutErrors;\n+use rustc_target::spec::{SplitDebuginfo, StackProtector, TargetTriple};\n \n #[derive(SessionDiagnostic)]\n #[diag(session::incorrect_cgu_reuse_type)]\n@@ -43,3 +45,128 @@ pub struct FeatureDiagnosticForIssue {\n pub struct FeatureDiagnosticHelp {\n     pub feature: Symbol,\n }\n+\n+impl SessionDiagnostic<'_, !> for TargetDataLayoutErrors<'_> {\n+    fn into_diagnostic(self, sess: &Handler) -> DiagnosticBuilder<'_, !> {\n+        let mut diag;\n+        match self {\n+            TargetDataLayoutErrors::InvalidAddressSpace { addr_space, err, cause } => {\n+                diag = sess.struct_fatal(fluent::session::target_invalid_address_space);\n+                diag.set_arg(\"addr_space\", addr_space);\n+                diag.set_arg(\"cause\", cause);\n+                diag.set_arg(\"err\", err);\n+                diag\n+            }\n+            TargetDataLayoutErrors::InvalidBits { kind, bit, cause, err } => {\n+                diag = sess.struct_fatal(fluent::session::target_invalid_bits);\n+                diag.set_arg(\"kind\", kind);\n+                diag.set_arg(\"bit\", bit);\n+                diag.set_arg(\"cause\", cause);\n+                diag.set_arg(\"err\", err);\n+                diag\n+            }\n+            TargetDataLayoutErrors::MissingAlignment { cause } => {\n+                diag = sess.struct_fatal(fluent::session::target_missing_alignment);\n+                diag.set_arg(\"cause\", cause);\n+                diag\n+            }\n+            TargetDataLayoutErrors::InvalidAlignment { cause, err } => {\n+                diag = sess.struct_fatal(fluent::session::target_invalid_alignment);\n+                diag.set_arg(\"cause\", cause);\n+                diag.set_arg(\"err\", err);\n+                diag\n+            }\n+            TargetDataLayoutErrors::InconsistentTargetArchitecture { dl, target } => {\n+                diag = sess.struct_fatal(fluent::session::target_inconsistent_architecture);\n+                diag.set_arg(\"dl\", dl);\n+                diag.set_arg(\"target\", target);\n+                diag\n+            }\n+            TargetDataLayoutErrors::InconsistentTargetPointerWidth { pointer_size, target } => {\n+                diag = sess.struct_fatal(fluent::session::target_inconsistent_pointer_width);\n+                diag.set_arg(\"pointer_size\", pointer_size);\n+                diag.set_arg(\"target\", target);\n+                diag\n+            }\n+            TargetDataLayoutErrors::InvalidBitsSize { err } => {\n+                diag = sess.struct_fatal(fluent::session::target_invalid_bits_size);\n+                diag.set_arg(\"err\", err);\n+                diag\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(session::not_circumvent_feature)]\n+pub struct NotCircumventFeature;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(session::linker_plugin_lto_windows_not_supported)]\n+pub struct LinkerPluginToWindowsNotSupported;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(session::profile_use_file_does_not_exist)]\n+pub struct ProfileUseFileDoesNotExist<'a> {\n+    pub path: &'a std::path::Path,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(session::profile_sample_use_file_does_not_exist)]\n+pub struct ProfileSampleUseFileDoesNotExist<'a> {\n+    pub path: &'a std::path::Path,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(session::target_requires_unwind_tables)]\n+pub struct TargetRequiresUnwindTables;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(session::sanitizer_not_supported)]\n+pub struct SanitizerNotSupported {\n+    pub us: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(session::sanitizers_not_supported)]\n+pub struct SanitizersNotSupported {\n+    pub us: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(session::cannot_mix_and_match_sanitizers)]\n+pub struct CannotMixAndMatchSanitizers {\n+    pub first: String,\n+    pub second: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(session::cannot_enable_crt_static_linux)]\n+pub struct CannotEnableCrtStaticLinux;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(session::sanitizer_cfi_enabled)]\n+pub struct SanitizerCfiEnabled;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(session::unstable_virtual_function_elimination)]\n+pub struct UnstableVirtualFunctionElimination;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(session::unsupported_dwarf_version)]\n+pub struct UnsupportedDwarfVersion {\n+    pub dwarf_version: u32,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(session::target_stack_protector_not_supported)]\n+pub struct StackProtectorNotSupportedForTarget<'a> {\n+    pub stack_protector: StackProtector,\n+    pub target_triple: &'a TargetTriple,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(session::split_debuginfo_unstable_platform)]\n+pub struct SplitDebugInfoUnstablePlatform {\n+    pub debuginfo: SplitDebuginfo,\n+}"}, {"sha": "caf9d582ab09970db94218b3da91b47994f89fe6", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 42, "deletions": 44, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -2,6 +2,13 @@ use crate::cgu_reuse_tracker::CguReuseTracker;\n use crate::code_stats::CodeStats;\n pub use crate::code_stats::{DataTypeKind, FieldInfo, SizeKind, VariantInfo};\n use crate::config::{self, CrateType, InstrumentCoverage, OptLevel, OutputType, SwitchWithOptPath};\n+use crate::errors::{\n+    CannotEnableCrtStaticLinux, CannotMixAndMatchSanitizers, LinkerPluginToWindowsNotSupported,\n+    NotCircumventFeature, ProfileSampleUseFileDoesNotExist, ProfileUseFileDoesNotExist,\n+    SanitizerCfiEnabled, SanitizerNotSupported, SanitizersNotSupported,\n+    SplitDebugInfoUnstablePlatform, StackProtectorNotSupportedForTarget,\n+    TargetRequiresUnwindTables, UnstableVirtualFunctionElimination, UnsupportedDwarfVersion,\n+};\n use crate::parse::{add_feature_diagnostics, ParseSess};\n use crate::search_paths::{PathKind, SearchPath};\n use crate::{filesearch, lint};\n@@ -235,6 +242,9 @@ impl Session {\n         if !unleashed_features.is_empty() {\n             let mut must_err = false;\n             // Create a diagnostic pointing at where things got unleashed.\n+            // FIXME(#100717): needs eager translation/lists\n+            #[allow(rustc::untranslatable_diagnostic)]\n+            #[allow(rustc::diagnostic_outside_of_impl)]\n             let mut diag = self.struct_warn(\"skipping const checks\");\n             for &(span, feature_gate) in unleashed_features.iter() {\n                 // FIXME: `span_label` doesn't do anything, so we use \"help\" as a hack.\n@@ -250,10 +260,7 @@ impl Session {\n             // If we should err, make sure we did.\n             if must_err && self.has_errors().is_none() {\n                 // We have skipped a feature gate, and not run into other errors... reject.\n-                self.err(\n-                    \"`-Zunleash-the-miri-inside-of-you` may not be used to circumvent feature \\\n-                     gates, except when testing error paths in the CTFE engine\",\n-                );\n+                self.emit_err(NotCircumventFeature);\n             }\n         }\n     }\n@@ -534,9 +541,13 @@ impl Session {\n             Err(ErrorGuaranteed::unchecked_claim_error_was_emitted())\n         }\n     }\n+    #[allow(rustc::untranslatable_diagnostic)]\n+    #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: impl Into<DiagnosticMessage>) {\n         self.diagnostic().span_warn(sp, msg)\n     }\n+    #[allow(rustc::untranslatable_diagnostic)]\n+    #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn span_warn_with_code<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n@@ -585,6 +596,8 @@ impl Session {\n     ) {\n         self.diagnostic().span_note_without_error(sp, msg)\n     }\n+    #[allow(rustc::untranslatable_diagnostic)]\n+    #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn struct_note_without_error(\n         &self,\n         msg: impl Into<DiagnosticMessage>,\n@@ -1469,40 +1482,28 @@ fn validate_commandline_args_with_session_available(sess: &Session) {\n         && sess.opts.cg.prefer_dynamic\n         && sess.target.is_like_windows\n     {\n-        sess.err(\n-            \"Linker plugin based LTO is not supported together with \\\n-                  `-C prefer-dynamic` when targeting Windows-like targets\",\n-        );\n+        sess.emit_err(LinkerPluginToWindowsNotSupported);\n     }\n \n     // Make sure that any given profiling data actually exists so LLVM can't\n     // decide to silently skip PGO.\n     if let Some(ref path) = sess.opts.cg.profile_use {\n         if !path.exists() {\n-            sess.err(&format!(\n-                \"File `{}` passed to `-C profile-use` does not exist.\",\n-                path.display()\n-            ));\n+            sess.emit_err(ProfileUseFileDoesNotExist { path });\n         }\n     }\n \n     // Do the same for sample profile data.\n     if let Some(ref path) = sess.opts.unstable_opts.profile_sample_use {\n         if !path.exists() {\n-            sess.err(&format!(\n-                \"File `{}` passed to `-C profile-sample-use` does not exist.\",\n-                path.display()\n-            ));\n+            sess.emit_err(ProfileSampleUseFileDoesNotExist { path });\n         }\n     }\n \n     // Unwind tables cannot be disabled if the target requires them.\n     if let Some(include_uwtables) = sess.opts.cg.force_unwind_tables {\n         if sess.target.requires_uwtable && !include_uwtables {\n-            sess.err(\n-                \"target requires unwind tables, they cannot be disabled with \\\n-                     `-C force-unwind-tables=no`.\",\n-            );\n+            sess.emit_err(TargetRequiresUnwindTables);\n         }\n     }\n \n@@ -1512,64 +1513,55 @@ fn validate_commandline_args_with_session_available(sess: &Session) {\n     match unsupported_sanitizers.into_iter().count() {\n         0 => {}\n         1 => {\n-            sess.err(&format!(\n-                \"{} sanitizer is not supported for this target\",\n-                unsupported_sanitizers\n-            ));\n+            sess.emit_err(SanitizerNotSupported { us: unsupported_sanitizers.to_string() });\n         }\n         _ => {\n-            sess.err(&format!(\n-                \"{} sanitizers are not supported for this target\",\n-                unsupported_sanitizers\n-            ));\n+            sess.emit_err(SanitizersNotSupported { us: unsupported_sanitizers.to_string() });\n         }\n     }\n     // Cannot mix and match sanitizers.\n     let mut sanitizer_iter = sess.opts.unstable_opts.sanitizer.into_iter();\n     if let (Some(first), Some(second)) = (sanitizer_iter.next(), sanitizer_iter.next()) {\n-        sess.err(&format!(\"`-Zsanitizer={first}` is incompatible with `-Zsanitizer={second}`\"));\n+        sess.emit_err(CannotMixAndMatchSanitizers {\n+            first: first.to_string(),\n+            second: second.to_string(),\n+        });\n     }\n \n     // Cannot enable crt-static with sanitizers on Linux\n     if sess.crt_static(None) && !sess.opts.unstable_opts.sanitizer.is_empty() {\n-        sess.err(\n-            \"sanitizer is incompatible with statically linked libc, \\\n-                                disable it using `-C target-feature=-crt-static`\",\n-        );\n+        sess.emit_err(CannotEnableCrtStaticLinux);\n     }\n \n     // LLVM CFI and VFE both require LTO.\n     if sess.lto() != config::Lto::Fat {\n         if sess.is_sanitizer_cfi_enabled() {\n-            sess.err(\"`-Zsanitizer=cfi` requires `-Clto`\");\n+            sess.emit_err(SanitizerCfiEnabled);\n         }\n         if sess.opts.unstable_opts.virtual_function_elimination {\n-            sess.err(\"`-Zvirtual-function-elimination` requires `-Clto`\");\n+            sess.emit_err(UnstableVirtualFunctionElimination);\n         }\n     }\n \n     if sess.opts.unstable_opts.stack_protector != StackProtector::None {\n         if !sess.target.options.supports_stack_protector {\n-            sess.warn(&format!(\n-                \"`-Z stack-protector={}` is not supported for target {} and will be ignored\",\n-                sess.opts.unstable_opts.stack_protector, sess.opts.target_triple\n-            ))\n+            sess.emit_warning(StackProtectorNotSupportedForTarget {\n+                stack_protector: sess.opts.unstable_opts.stack_protector,\n+                target_triple: &sess.opts.target_triple,\n+            });\n         }\n     }\n \n     if let Some(dwarf_version) = sess.opts.unstable_opts.dwarf_version {\n         if dwarf_version > 5 {\n-            sess.err(&format!(\"requested DWARF version {} is greater than 5\", dwarf_version));\n+            sess.emit_err(UnsupportedDwarfVersion { dwarf_version });\n         }\n     }\n \n     if !sess.target.options.supported_split_debuginfo.contains(&sess.split_debuginfo())\n         && !sess.opts.unstable_opts.unstable_options\n     {\n-        sess.err(&format!(\n-            \"`-Csplit-debuginfo={}` is unstable on this platform\",\n-            sess.split_debuginfo()\n-        ));\n+        sess.emit_err(SplitDebugInfoUnstablePlatform { debuginfo: sess.split_debuginfo() });\n     }\n }\n \n@@ -1614,14 +1606,20 @@ fn early_error_handler(output: config::ErrorOutputType) -> rustc_errors::Handler\n     rustc_errors::Handler::with_emitter(true, None, emitter)\n }\n \n+#[allow(rustc::untranslatable_diagnostic)]\n+#[allow(rustc::diagnostic_outside_of_impl)]\n pub fn early_error_no_abort(output: config::ErrorOutputType, msg: &str) -> ErrorGuaranteed {\n     early_error_handler(output).struct_err(msg).emit()\n }\n \n+#[allow(rustc::untranslatable_diagnostic)]\n+#[allow(rustc::diagnostic_outside_of_impl)]\n pub fn early_error(output: config::ErrorOutputType, msg: &str) -> ! {\n     early_error_handler(output).struct_fatal(msg).emit()\n }\n \n+#[allow(rustc::untranslatable_diagnostic)]\n+#[allow(rustc::diagnostic_outside_of_impl)]\n pub fn early_warn(output: config::ErrorOutputType, msg: &str) {\n     early_error_handler(output).struct_warn(msg).emit()\n }"}, {"sha": "ec334e5887ab765bfcacababdd2823bfe026a7f1", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 37, "deletions": 26, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -7,7 +7,7 @@ use crate::spec::Target;\n use std::convert::{TryFrom, TryInto};\n use std::fmt;\n use std::iter::Step;\n-use std::num::NonZeroUsize;\n+use std::num::{NonZeroUsize, ParseIntError};\n use std::ops::{Add, AddAssign, Deref, Mul, RangeInclusive, Sub};\n use std::str::FromStr;\n \n@@ -69,34 +69,46 @@ impl Default for TargetDataLayout {\n     }\n }\n \n+pub enum TargetDataLayoutErrors<'a> {\n+    InvalidAddressSpace { addr_space: &'a str, cause: &'a str, err: ParseIntError },\n+    InvalidBits { kind: &'a str, bit: &'a str, cause: &'a str, err: ParseIntError },\n+    MissingAlignment { cause: &'a str },\n+    InvalidAlignment { cause: &'a str, err: String },\n+    InconsistentTargetArchitecture { dl: &'a str, target: &'a str },\n+    InconsistentTargetPointerWidth { pointer_size: u64, target: u32 },\n+    InvalidBitsSize { err: String },\n+}\n+\n impl TargetDataLayout {\n-    pub fn parse(target: &Target) -> Result<TargetDataLayout, String> {\n+    pub fn parse<'a>(target: &'a Target) -> Result<TargetDataLayout, TargetDataLayoutErrors<'a>> {\n         // Parse an address space index from a string.\n-        let parse_address_space = |s: &str, cause: &str| {\n+        let parse_address_space = |s: &'a str, cause: &'a str| {\n             s.parse::<u32>().map(AddressSpace).map_err(|err| {\n-                format!(\"invalid address space `{}` for `{}` in \\\"data-layout\\\": {}\", s, cause, err)\n+                TargetDataLayoutErrors::InvalidAddressSpace { addr_space: s, cause, err }\n             })\n         };\n \n         // Parse a bit count from a string.\n-        let parse_bits = |s: &str, kind: &str, cause: &str| {\n-            s.parse::<u64>().map_err(|err| {\n-                format!(\"invalid {} `{}` for `{}` in \\\"data-layout\\\": {}\", kind, s, cause, err)\n+        let parse_bits = |s: &'a str, kind: &'a str, cause: &'a str| {\n+            s.parse::<u64>().map_err(|err| TargetDataLayoutErrors::InvalidBits {\n+                kind,\n+                bit: s,\n+                cause,\n+                err,\n             })\n         };\n \n         // Parse a size string.\n-        let size = |s: &str, cause: &str| parse_bits(s, \"size\", cause).map(Size::from_bits);\n+        let size = |s: &'a str, cause: &'a str| parse_bits(s, \"size\", cause).map(Size::from_bits);\n \n         // Parse an alignment string.\n-        let align = |s: &[&str], cause: &str| {\n+        let align = |s: &[&'a str], cause: &'a str| {\n             if s.is_empty() {\n-                return Err(format!(\"missing alignment for `{}` in \\\"data-layout\\\"\", cause));\n+                return Err(TargetDataLayoutErrors::MissingAlignment { cause });\n             }\n             let align_from_bits = |bits| {\n-                Align::from_bits(bits).map_err(|err| {\n-                    format!(\"invalid alignment for `{}` in \\\"data-layout\\\": {}\", cause, err)\n-                })\n+                Align::from_bits(bits)\n+                    .map_err(|err| TargetDataLayoutErrors::InvalidAlignment { cause, err })\n             };\n             let abi = parse_bits(s[0], \"alignment\", cause)?;\n             let pref = s.get(1).map_or(Ok(abi), |pref| parse_bits(pref, \"alignment\", cause))?;\n@@ -158,25 +170,24 @@ impl TargetDataLayout {\n \n         // Perform consistency checks against the Target information.\n         if dl.endian != target.endian {\n-            return Err(format!(\n-                \"inconsistent target specification: \\\"data-layout\\\" claims \\\n-                 architecture is {}-endian, while \\\"target-endian\\\" is `{}`\",\n-                dl.endian.as_str(),\n-                target.endian.as_str(),\n-            ));\n+            return Err(TargetDataLayoutErrors::InconsistentTargetArchitecture {\n+                dl: dl.endian.as_str(),\n+                target: target.endian.as_str(),\n+            });\n         }\n \n         let target_pointer_width: u64 = target.pointer_width.into();\n         if dl.pointer_size.bits() != target_pointer_width {\n-            return Err(format!(\n-                \"inconsistent target specification: \\\"data-layout\\\" claims \\\n-                 pointers are {}-bit, while \\\"target-pointer-width\\\" is `{}`\",\n-                dl.pointer_size.bits(),\n-                target.pointer_width\n-            ));\n+            return Err(TargetDataLayoutErrors::InconsistentTargetPointerWidth {\n+                pointer_size: dl.pointer_size.bits(),\n+                target: target.pointer_width,\n+            });\n         }\n \n-        dl.c_enum_min_size = Integer::from_size(Size::from_bits(target.c_enum_min_bits))?;\n+        dl.c_enum_min_size = match Integer::from_size(Size::from_bits(target.c_enum_min_bits)) {\n+            Ok(bits) => bits,\n+            Err(err) => return Err(TargetDataLayoutErrors::InvalidBitsSize { err }),\n+        };\n \n         Ok(dl)\n     }"}, {"sha": "ecbeb9d79b118923057e35e56b48e91f911e1de2", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -25,8 +25,7 @@ use rustc_middle::hir::map;\n use rustc_middle::ty::{\n     self, suggest_arbitrary_trait_bound, suggest_constraining_type_param, AdtKind, DefIdTree,\n     GeneratorDiagnosticData, GeneratorInteriorTypeCause, Infer, InferTy, IsSuggestable,\n-    ProjectionPredicate, ToPredicate, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable,\n-    TypeVisitable,\n+    ToPredicate, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable, TypeVisitable,\n };\n use rustc_middle::ty::{TypeAndMut, TypeckResults};\n use rustc_session::Limit;\n@@ -174,7 +173,7 @@ pub trait InferCtxtExt<'tcx> {\n         &self,\n         err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n-        proj_pred: Option<ty::PolyProjectionPredicate<'tcx>>,\n+        associated_item: Option<(&'static str, Ty<'tcx>)>,\n         body_id: hir::HirId,\n     );\n \n@@ -467,7 +466,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         &self,\n         mut err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n-        proj_pred: Option<ty::PolyProjectionPredicate<'tcx>>,\n+        associated_ty: Option<(&'static str, Ty<'tcx>)>,\n         body_id: hir::HirId,\n     ) {\n         let trait_pred = self.resolve_numeric_literals_with_default(trait_pred);\n@@ -604,21 +603,18 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         trait_pred.print_modifiers_and_trait_path().to_string()\n                     );\n \n-                    if let Some(proj_pred) = proj_pred {\n-                        let ProjectionPredicate { projection_ty, term } = proj_pred.skip_binder();\n-                        let item = self.tcx.associated_item(projection_ty.item_def_id);\n-\n+                    if let Some((name, term)) = associated_ty {\n                         // FIXME: this case overlaps with code in TyCtxt::note_and_explain_type_err.\n                         // That should be extracted into a helper function.\n                         if constraint.ends_with('>') {\n                             constraint = format!(\n-                                \"{}, {}={}>\",\n+                                \"{}, {} = {}>\",\n                                 &constraint[..constraint.len() - 1],\n-                                item.name,\n+                                name,\n                                 term\n                             );\n                         } else {\n-                            constraint.push_str(&format!(\"<{}={}>\", item.name, term));\n+                            constraint.push_str(&format!(\"<{} = {}>\", name, term));\n                         }\n                     }\n \n@@ -648,7 +644,13 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     ..\n                 }) if !param_ty => {\n                     // Missing generic type parameter bound.\n-                    if suggest_arbitrary_trait_bound(self.tcx, generics, &mut err, trait_pred) {\n+                    if suggest_arbitrary_trait_bound(\n+                        self.tcx,\n+                        generics,\n+                        &mut err,\n+                        trait_pred,\n+                        associated_ty,\n+                    ) {\n                         return;\n                     }\n                 }"}, {"sha": "d66cf6d099ad538a3e570326131b2418b2032858", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -2940,8 +2940,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // though we can easily give a hint that ought to be\n                 // relevant.\n                 err.note(\n-                    \"lifetimes appearing in an associated type are not considered constrained\",\n+                    \"lifetimes appearing in an associated or opaque type are not considered constrained\",\n                 );\n+                err.note(\"consider introducing a named lifetime parameter\");\n             }\n \n             err.emit();"}, {"sha": "a40478db96901719f5392fff5481c634f393aaaa", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -409,7 +409,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     rhs_span: opt_input_expr.map(|expr| expr.span),\n                     is_lit: opt_input_expr\n                         .map_or(false, |expr| matches!(expr.kind, ExprKind::Lit(_))),\n-                    output_pred: None,\n+                    output_ty: None,\n                 },\n             ),\n             self.param_env,"}, {"sha": "249e9c66ba72ad958334b0613d826abefdaee4a7", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 4, "deletions": 22, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -20,10 +20,7 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::infer::{self, InferOk};\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n-use rustc_middle::ty::{\n-    self, AssocKind, DefIdTree, GenericParamDefKind, ProjectionPredicate, ProjectionTy,\n-    ToPredicate, Ty, TypeVisitable,\n-};\n+use rustc_middle::ty::{self, DefIdTree, GenericParamDefKind, ToPredicate, Ty, TypeVisitable};\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n use rustc_trait_selection::traits;\n@@ -337,22 +334,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Construct an obligation\n         let poly_trait_ref = ty::Binder::dummy(trait_ref);\n-        let opt_output_ty =\n-            expected.only_has_type(self).and_then(|ty| (!ty.needs_infer()).then(|| ty));\n-        let opt_output_assoc_item = self.tcx.associated_items(trait_def_id).find_by_name_and_kind(\n-            self.tcx,\n-            Ident::from_str(\"Output\"),\n-            AssocKind::Type,\n-            trait_def_id,\n-        );\n-        let output_pred =\n-            opt_output_ty.zip(opt_output_assoc_item).map(|(output_ty, output_assoc_item)| {\n-                ty::Binder::dummy(ty::PredicateKind::Projection(ProjectionPredicate {\n-                    projection_ty: ProjectionTy { substs, item_def_id: output_assoc_item.def_id },\n-                    term: output_ty.into(),\n-                }))\n-                .to_predicate(self.tcx)\n-            });\n+        let output_ty = expected.only_has_type(self).and_then(|ty| (!ty.needs_infer()).then(|| ty));\n \n         (\n             traits::Obligation::new(\n@@ -363,7 +345,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         rhs_span: opt_input_expr.map(|expr| expr.span),\n                         is_lit: opt_input_expr\n                             .map_or(false, |expr| matches!(expr.kind, hir::ExprKind::Lit(_))),\n-                        output_pred,\n+                        output_ty,\n                     },\n                 ),\n                 self.param_env,\n@@ -518,7 +500,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     rhs_span: opt_input_expr.map(|expr| expr.span),\n                     is_lit: opt_input_expr\n                         .map_or(false, |expr| matches!(expr.kind, hir::ExprKind::Lit(_))),\n-                    output_pred: None,\n+                    output_ty: None,\n                 },\n             )\n         } else {"}, {"sha": "4754717c29aba777494a494f9822e8f7b9cfdad9", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 149, "deletions": 203, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -11,9 +11,8 @@ use rustc_infer::traits::ObligationCauseCode;\n use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability,\n };\n-use rustc_middle::ty::{\n-    self, Ty, TyCtxt, TypeFolder, TypeSuperFoldable, TypeSuperVisitable, TypeVisitable, TypeVisitor,\n-};\n+use rustc_middle::ty::print::with_no_trimmed_paths;\n+use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt, TypeFolder, TypeSuperFoldable, TypeVisitable};\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n@@ -22,8 +21,6 @@ use rustc_trait_selection::traits::error_reporting::suggestions::InferCtxtExt as\n use rustc_trait_selection::traits::{FulfillmentError, TraitEngine, TraitEngineExt};\n use rustc_type_ir::sty::TyKind::*;\n \n-use std::ops::ControlFlow;\n-\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Checks a `a <op>= b`\n     pub fn check_binop_assign(\n@@ -313,8 +310,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // error types are considered \"builtin\"\n             Err(_) if lhs_ty.references_error() || rhs_ty.references_error() => self.tcx.ty_error(),\n             Err(errors) => {\n-                let source_map = self.tcx.sess.source_map();\n-                let (mut err, missing_trait, use_output) = match is_assign {\n+                let (_, trait_def_id) =\n+                    lang_item_for_op(self.tcx, Op::Binary(op, is_assign), op.span);\n+                let missing_trait = trait_def_id\n+                    .map(|def_id| with_no_trimmed_paths!(self.tcx.def_path_str(def_id)));\n+                let (mut err, output_def_id) = match is_assign {\n                     IsAssign::Yes => {\n                         let mut err = struct_span_err!(\n                             self.tcx.sess,\n@@ -328,112 +328,63 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             lhs_expr.span,\n                             format!(\"cannot use `{}=` on type `{}`\", op.node.as_str(), lhs_ty),\n                         );\n-                        let missing_trait = match op.node {\n-                            hir::BinOpKind::Add => Some(\"std::ops::AddAssign\"),\n-                            hir::BinOpKind::Sub => Some(\"std::ops::SubAssign\"),\n-                            hir::BinOpKind::Mul => Some(\"std::ops::MulAssign\"),\n-                            hir::BinOpKind::Div => Some(\"std::ops::DivAssign\"),\n-                            hir::BinOpKind::Rem => Some(\"std::ops::RemAssign\"),\n-                            hir::BinOpKind::BitAnd => Some(\"std::ops::BitAndAssign\"),\n-                            hir::BinOpKind::BitXor => Some(\"std::ops::BitXorAssign\"),\n-                            hir::BinOpKind::BitOr => Some(\"std::ops::BitOrAssign\"),\n-                            hir::BinOpKind::Shl => Some(\"std::ops::ShlAssign\"),\n-                            hir::BinOpKind::Shr => Some(\"std::ops::ShrAssign\"),\n-                            _ => None,\n-                        };\n                         self.note_unmet_impls_on_type(&mut err, errors);\n-                        (err, missing_trait, false)\n+                        (err, None)\n                     }\n                     IsAssign::No => {\n-                        let (message, missing_trait, use_output) = match op.node {\n-                            hir::BinOpKind::Add => (\n-                                format!(\"cannot add `{rhs_ty}` to `{lhs_ty}`\"),\n-                                Some(\"std::ops::Add\"),\n-                                true,\n-                            ),\n-                            hir::BinOpKind::Sub => (\n-                                format!(\"cannot subtract `{rhs_ty}` from `{lhs_ty}`\"),\n-                                Some(\"std::ops::Sub\"),\n-                                true,\n-                            ),\n-                            hir::BinOpKind::Mul => (\n-                                format!(\"cannot multiply `{lhs_ty}` by `{rhs_ty}`\"),\n-                                Some(\"std::ops::Mul\"),\n-                                true,\n-                            ),\n-                            hir::BinOpKind::Div => (\n-                                format!(\"cannot divide `{lhs_ty}` by `{rhs_ty}`\"),\n-                                Some(\"std::ops::Div\"),\n-                                true,\n-                            ),\n-                            hir::BinOpKind::Rem => (\n-                                format!(\"cannot mod `{lhs_ty}` by `{rhs_ty}`\"),\n-                                Some(\"std::ops::Rem\"),\n-                                true,\n-                            ),\n-                            hir::BinOpKind::BitAnd => (\n-                                format!(\"no implementation for `{lhs_ty} & {rhs_ty}`\"),\n-                                Some(\"std::ops::BitAnd\"),\n-                                true,\n-                            ),\n-                            hir::BinOpKind::BitXor => (\n-                                format!(\"no implementation for `{lhs_ty} ^ {rhs_ty}`\"),\n-                                Some(\"std::ops::BitXor\"),\n-                                true,\n-                            ),\n-                            hir::BinOpKind::BitOr => (\n-                                format!(\"no implementation for `{lhs_ty} | {rhs_ty}`\"),\n-                                Some(\"std::ops::BitOr\"),\n-                                true,\n-                            ),\n-                            hir::BinOpKind::Shl => (\n-                                format!(\"no implementation for `{lhs_ty} << {rhs_ty}`\"),\n-                                Some(\"std::ops::Shl\"),\n-                                true,\n-                            ),\n-                            hir::BinOpKind::Shr => (\n-                                format!(\"no implementation for `{lhs_ty} >> {rhs_ty}`\"),\n-                                Some(\"std::ops::Shr\"),\n-                                true,\n-                            ),\n-                            hir::BinOpKind::Eq | hir::BinOpKind::Ne => (\n-                                format!(\n-                                    \"binary operation `{}` cannot be applied to type `{}`\",\n-                                    op.node.as_str(),\n-                                    lhs_ty\n-                                ),\n-                                Some(\"std::cmp::PartialEq\"),\n-                                false,\n-                            ),\n-                            hir::BinOpKind::Lt\n-                            | hir::BinOpKind::Le\n-                            | hir::BinOpKind::Gt\n-                            | hir::BinOpKind::Ge => (\n-                                format!(\n-                                    \"binary operation `{}` cannot be applied to type `{}`\",\n-                                    op.node.as_str(),\n-                                    lhs_ty\n-                                ),\n-                                Some(\"std::cmp::PartialOrd\"),\n-                                false,\n-                            ),\n-                            _ => (\n-                                format!(\n-                                    \"binary operation `{}` cannot be applied to type `{}`\",\n-                                    op.node.as_str(),\n-                                    lhs_ty\n-                                ),\n-                                None,\n-                                false,\n+                        let message = match op.node {\n+                            hir::BinOpKind::Add => {\n+                                format!(\"cannot add `{rhs_ty}` to `{lhs_ty}`\")\n+                            }\n+                            hir::BinOpKind::Sub => {\n+                                format!(\"cannot subtract `{rhs_ty}` from `{lhs_ty}`\")\n+                            }\n+                            hir::BinOpKind::Mul => {\n+                                format!(\"cannot multiply `{lhs_ty}` by `{rhs_ty}`\")\n+                            }\n+                            hir::BinOpKind::Div => {\n+                                format!(\"cannot divide `{lhs_ty}` by `{rhs_ty}`\")\n+                            }\n+                            hir::BinOpKind::Rem => {\n+                                format!(\"cannot mod `{lhs_ty}` by `{rhs_ty}`\")\n+                            }\n+                            hir::BinOpKind::BitAnd => {\n+                                format!(\"no implementation for `{lhs_ty} & {rhs_ty}`\")\n+                            }\n+                            hir::BinOpKind::BitXor => {\n+                                format!(\"no implementation for `{lhs_ty} ^ {rhs_ty}`\")\n+                            }\n+                            hir::BinOpKind::BitOr => {\n+                                format!(\"no implementation for `{lhs_ty} | {rhs_ty}`\")\n+                            }\n+                            hir::BinOpKind::Shl => {\n+                                format!(\"no implementation for `{lhs_ty} << {rhs_ty}`\")\n+                            }\n+                            hir::BinOpKind::Shr => {\n+                                format!(\"no implementation for `{lhs_ty} >> {rhs_ty}`\")\n+                            }\n+                            _ => format!(\n+                                \"binary operation `{}` cannot be applied to type `{}`\",\n+                                op.node.as_str(),\n+                                lhs_ty\n                             ),\n                         };\n+                        let output_def_id = trait_def_id.and_then(|def_id| {\n+                            self.tcx\n+                                .associated_item_def_ids(def_id)\n+                                .iter()\n+                                .find(|item_def_id| {\n+                                    self.tcx.associated_item(*item_def_id).name == sym::Output\n+                                })\n+                                .cloned()\n+                        });\n                         let mut err = struct_span_err!(self.tcx.sess, op.span, E0369, \"{message}\");\n                         if !lhs_expr.span.eq(&rhs_expr.span) {\n                             err.span_label(lhs_expr.span, lhs_ty.to_string());\n                             err.span_label(rhs_expr.span, rhs_ty.to_string());\n                         }\n                         self.note_unmet_impls_on_type(&mut err, errors);\n-                        (err, missing_trait, use_output)\n+                        (err, output_def_id)\n                     }\n                 };\n \n@@ -448,24 +399,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         )\n                         .is_ok()\n                     {\n-                        if let Ok(lstring) = source_map.span_to_snippet(lhs_expr.span) {\n-                            let msg = &format!(\n-                                \"`{}{}` can be used on `{}`, you can dereference `{}`\",\n-                                op.node.as_str(),\n-                                match is_assign {\n-                                    IsAssign::Yes => \"=\",\n-                                    IsAssign::No => \"\",\n-                                },\n-                                lhs_deref_ty.peel_refs(),\n-                                lstring,\n-                            );\n-                            err.span_suggestion_verbose(\n-                                lhs_expr.span.shrink_to_lo(),\n-                                msg,\n-                                \"*\",\n-                                rustc_errors::Applicability::MachineApplicable,\n-                            );\n-                        }\n+                        let msg = &format!(\n+                            \"`{}{}` can be used on `{}` if you dereference the left-hand side\",\n+                            op.node.as_str(),\n+                            match is_assign {\n+                                IsAssign::Yes => \"=\",\n+                                IsAssign::No => \"\",\n+                            },\n+                            lhs_deref_ty,\n+                        );\n+                        err.span_suggestion_verbose(\n+                            lhs_expr.span.shrink_to_lo(),\n+                            msg,\n+                            \"*\",\n+                            rustc_errors::Applicability::MachineApplicable,\n+                        );\n                     }\n                 };\n \n@@ -514,9 +462,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n \n                 if let Some(missing_trait) = missing_trait {\n-                    let mut visitor = TypeParamVisitor(vec![]);\n-                    visitor.visit_ty(lhs_ty);\n-\n                     if op.node == hir::BinOpKind::Add\n                         && self.check_str_addition(\n                             lhs_expr, rhs_expr, lhs_ty, rhs_ty, &mut err, is_assign, op,\n@@ -525,7 +470,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // This has nothing here because it means we did string\n                         // concatenation (e.g., \"Hello \" + \"World!\"). This means\n                         // we don't want the note in the else clause to be emitted\n-                    } else if let [ty] = &visitor.0[..] {\n+                    } else if lhs_ty.has_param_types_or_consts() {\n                         // Look for a TraitPredicate in the Fulfillment errors,\n                         // and use it to generate a suggestion.\n                         //\n@@ -547,25 +492,34 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 if let Some(trait_pred) =\n                                     error.obligation.predicate.to_opt_poly_trait_pred()\n                                 {\n-                                    let proj_pred = match error.obligation.cause.code() {\n+                                    let output_associated_item = match error.obligation.cause.code()\n+                                    {\n                                         ObligationCauseCode::BinOp {\n-                                            output_pred: Some(output_pred),\n+                                            output_ty: Some(output_ty),\n                                             ..\n-                                        } if use_output => {\n-                                            output_pred.to_opt_poly_projection_pred()\n+                                        } => {\n+                                            // Make sure that we're attaching `Output = ..` to the right trait predicate\n+                                            if let Some(output_def_id) = output_def_id\n+                                                && let Some(trait_def_id) = trait_def_id\n+                                                && self.tcx.parent(output_def_id) == trait_def_id\n+                                            {\n+                                                Some((\"Output\", *output_ty))\n+                                            } else {\n+                                                None\n+                                            }\n                                         }\n                                         _ => None,\n                                     };\n \n                                     self.suggest_restricting_param_bound(\n                                         &mut err,\n                                         trait_pred,\n-                                        proj_pred,\n+                                        output_associated_item,\n                                         self.body_id,\n                                     );\n                                 }\n                             }\n-                        } else if *ty != lhs_ty {\n+                        } else {\n                             // When we know that a missing bound is responsible, we don't show\n                             // this note as it is redundant.\n                             err.note(&format!(\n@@ -702,14 +656,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         format!(\"cannot apply unary operator `{}`\", op.as_str()),\n                     );\n \n-                    let mut visitor = TypeParamVisitor(vec![]);\n-                    visitor.visit_ty(operand_ty);\n-                    if let [_] = &visitor.0[..] && let ty::Param(_) = *operand_ty.kind() {\n-                        let predicates = errors\n-                            .iter()\n-                            .filter_map(|error| {\n-                                error.obligation.predicate.to_opt_poly_trait_pred()\n-                            });\n+                    if operand_ty.has_param_types_or_consts() {\n+                        let predicates = errors.iter().filter_map(|error| {\n+                            error.obligation.predicate.to_opt_poly_trait_pred()\n+                        });\n                         for pred in predicates {\n                             self.suggest_restricting_param_bound(\n                                 &mut err,\n@@ -777,64 +727,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         op: Op,\n         expected: Expectation<'tcx>,\n     ) -> Result<MethodCallee<'tcx>, Vec<FulfillmentError<'tcx>>> {\n-        let lang = self.tcx.lang_items();\n-\n         let span = match op {\n             Op::Binary(op, _) => op.span,\n             Op::Unary(_, span) => span,\n         };\n-        let (opname, trait_did) = if let Op::Binary(op, IsAssign::Yes) = op {\n-            match op.node {\n-                hir::BinOpKind::Add => (sym::add_assign, lang.add_assign_trait()),\n-                hir::BinOpKind::Sub => (sym::sub_assign, lang.sub_assign_trait()),\n-                hir::BinOpKind::Mul => (sym::mul_assign, lang.mul_assign_trait()),\n-                hir::BinOpKind::Div => (sym::div_assign, lang.div_assign_trait()),\n-                hir::BinOpKind::Rem => (sym::rem_assign, lang.rem_assign_trait()),\n-                hir::BinOpKind::BitXor => (sym::bitxor_assign, lang.bitxor_assign_trait()),\n-                hir::BinOpKind::BitAnd => (sym::bitand_assign, lang.bitand_assign_trait()),\n-                hir::BinOpKind::BitOr => (sym::bitor_assign, lang.bitor_assign_trait()),\n-                hir::BinOpKind::Shl => (sym::shl_assign, lang.shl_assign_trait()),\n-                hir::BinOpKind::Shr => (sym::shr_assign, lang.shr_assign_trait()),\n-                hir::BinOpKind::Lt\n-                | hir::BinOpKind::Le\n-                | hir::BinOpKind::Ge\n-                | hir::BinOpKind::Gt\n-                | hir::BinOpKind::Eq\n-                | hir::BinOpKind::Ne\n-                | hir::BinOpKind::And\n-                | hir::BinOpKind::Or => {\n-                    span_bug!(span, \"impossible assignment operation: {}=\", op.node.as_str())\n-                }\n-            }\n-        } else if let Op::Binary(op, IsAssign::No) = op {\n-            match op.node {\n-                hir::BinOpKind::Add => (sym::add, lang.add_trait()),\n-                hir::BinOpKind::Sub => (sym::sub, lang.sub_trait()),\n-                hir::BinOpKind::Mul => (sym::mul, lang.mul_trait()),\n-                hir::BinOpKind::Div => (sym::div, lang.div_trait()),\n-                hir::BinOpKind::Rem => (sym::rem, lang.rem_trait()),\n-                hir::BinOpKind::BitXor => (sym::bitxor, lang.bitxor_trait()),\n-                hir::BinOpKind::BitAnd => (sym::bitand, lang.bitand_trait()),\n-                hir::BinOpKind::BitOr => (sym::bitor, lang.bitor_trait()),\n-                hir::BinOpKind::Shl => (sym::shl, lang.shl_trait()),\n-                hir::BinOpKind::Shr => (sym::shr, lang.shr_trait()),\n-                hir::BinOpKind::Lt => (sym::lt, lang.partial_ord_trait()),\n-                hir::BinOpKind::Le => (sym::le, lang.partial_ord_trait()),\n-                hir::BinOpKind::Ge => (sym::ge, lang.partial_ord_trait()),\n-                hir::BinOpKind::Gt => (sym::gt, lang.partial_ord_trait()),\n-                hir::BinOpKind::Eq => (sym::eq, lang.eq_trait()),\n-                hir::BinOpKind::Ne => (sym::ne, lang.eq_trait()),\n-                hir::BinOpKind::And | hir::BinOpKind::Or => {\n-                    span_bug!(span, \"&& and || are not overloadable\")\n-                }\n-            }\n-        } else if let Op::Unary(hir::UnOp::Not, _) = op {\n-            (sym::not, lang.not_trait())\n-        } else if let Op::Unary(hir::UnOp::Neg, _) = op {\n-            (sym::neg, lang.neg_trait())\n-        } else {\n-            bug!(\"lookup_op_method: op not supported: {:?}\", op)\n-        };\n+        let (opname, trait_did) = lang_item_for_op(self.tcx, op, span);\n \n         debug!(\n             \"lookup_op_method(lhs_ty={:?}, op={:?}, opname={:?}, trait_did={:?})\",\n@@ -895,6 +792,66 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n }\n \n+fn lang_item_for_op(\n+    tcx: TyCtxt<'_>,\n+    op: Op,\n+    span: Span,\n+) -> (rustc_span::Symbol, Option<hir::def_id::DefId>) {\n+    let lang = tcx.lang_items();\n+    if let Op::Binary(op, IsAssign::Yes) = op {\n+        match op.node {\n+            hir::BinOpKind::Add => (sym::add_assign, lang.add_assign_trait()),\n+            hir::BinOpKind::Sub => (sym::sub_assign, lang.sub_assign_trait()),\n+            hir::BinOpKind::Mul => (sym::mul_assign, lang.mul_assign_trait()),\n+            hir::BinOpKind::Div => (sym::div_assign, lang.div_assign_trait()),\n+            hir::BinOpKind::Rem => (sym::rem_assign, lang.rem_assign_trait()),\n+            hir::BinOpKind::BitXor => (sym::bitxor_assign, lang.bitxor_assign_trait()),\n+            hir::BinOpKind::BitAnd => (sym::bitand_assign, lang.bitand_assign_trait()),\n+            hir::BinOpKind::BitOr => (sym::bitor_assign, lang.bitor_assign_trait()),\n+            hir::BinOpKind::Shl => (sym::shl_assign, lang.shl_assign_trait()),\n+            hir::BinOpKind::Shr => (sym::shr_assign, lang.shr_assign_trait()),\n+            hir::BinOpKind::Lt\n+            | hir::BinOpKind::Le\n+            | hir::BinOpKind::Ge\n+            | hir::BinOpKind::Gt\n+            | hir::BinOpKind::Eq\n+            | hir::BinOpKind::Ne\n+            | hir::BinOpKind::And\n+            | hir::BinOpKind::Or => {\n+                span_bug!(span, \"impossible assignment operation: {}=\", op.node.as_str())\n+            }\n+        }\n+    } else if let Op::Binary(op, IsAssign::No) = op {\n+        match op.node {\n+            hir::BinOpKind::Add => (sym::add, lang.add_trait()),\n+            hir::BinOpKind::Sub => (sym::sub, lang.sub_trait()),\n+            hir::BinOpKind::Mul => (sym::mul, lang.mul_trait()),\n+            hir::BinOpKind::Div => (sym::div, lang.div_trait()),\n+            hir::BinOpKind::Rem => (sym::rem, lang.rem_trait()),\n+            hir::BinOpKind::BitXor => (sym::bitxor, lang.bitxor_trait()),\n+            hir::BinOpKind::BitAnd => (sym::bitand, lang.bitand_trait()),\n+            hir::BinOpKind::BitOr => (sym::bitor, lang.bitor_trait()),\n+            hir::BinOpKind::Shl => (sym::shl, lang.shl_trait()),\n+            hir::BinOpKind::Shr => (sym::shr, lang.shr_trait()),\n+            hir::BinOpKind::Lt => (sym::lt, lang.partial_ord_trait()),\n+            hir::BinOpKind::Le => (sym::le, lang.partial_ord_trait()),\n+            hir::BinOpKind::Ge => (sym::ge, lang.partial_ord_trait()),\n+            hir::BinOpKind::Gt => (sym::gt, lang.partial_ord_trait()),\n+            hir::BinOpKind::Eq => (sym::eq, lang.eq_trait()),\n+            hir::BinOpKind::Ne => (sym::ne, lang.eq_trait()),\n+            hir::BinOpKind::And | hir::BinOpKind::Or => {\n+                span_bug!(span, \"&& and || are not overloadable\")\n+            }\n+        }\n+    } else if let Op::Unary(hir::UnOp::Not, _) = op {\n+        (sym::not, lang.not_trait())\n+    } else if let Op::Unary(hir::UnOp::Neg, _) = op {\n+        (sym::neg, lang.neg_trait())\n+    } else {\n+        bug!(\"lookup_op_method: op not supported: {:?}\", op)\n+    }\n+}\n+\n // Binary operator categories. These categories summarize the behavior\n // with respect to the builtin operations supported.\n enum BinOpCategory {\n@@ -1017,17 +974,6 @@ fn is_builtin_binop<'tcx>(lhs: Ty<'tcx>, rhs: Ty<'tcx>, op: hir::BinOp) -> bool\n     }\n }\n \n-struct TypeParamVisitor<'tcx>(Vec<Ty<'tcx>>);\n-\n-impl<'tcx> TypeVisitor<'tcx> for TypeParamVisitor<'tcx> {\n-    fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        if let ty::Param(_) = ty.kind() {\n-            self.0.push(ty);\n-        }\n-        ty.super_visit_with(self)\n-    }\n-}\n-\n struct TypeParamEraser<'a, 'tcx>(&'a FnCtxt<'a, 'tcx>, Span);\n \n impl<'tcx> TypeFolder<'tcx> for TypeParamEraser<'_, 'tcx> {"}, {"sha": "03ad3ca826146a9b47aeb37e638cbcba272c66b7", "filename": "src/test/ui-fulldeps/auxiliary/issue-40001-plugin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -21,7 +21,7 @@ use rustc_span::source_map;\n #[no_mangle]\n fn __rustc_plugin_registrar(reg: &mut Registry) {\n     reg.lint_store.register_lints(&[&MISSING_ALLOWED_ATTR]);\n-    reg.lint_store.register_late_pass(|| Box::new(MissingAllowedAttrPass));\n+    reg.lint_store.register_late_pass(|_| Box::new(MissingAllowedAttrPass));\n }\n \n declare_lint! {"}, {"sha": "a3b570ad8c40c5e572ba483eb4963980dfda68af", "filename": "src/test/ui-fulldeps/auxiliary/lint-for-crate-rpass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -74,7 +74,7 @@ fn __rustc_plugin_registrar(reg: &mut Registry) {\n         &CRATE_NOT_GREY,\n         &CRATE_NOT_GREEN,\n     ]);\n-    reg.lint_store.register_late_pass(|| Box::new(PassOkay));\n-    reg.lint_store.register_late_pass(|| Box::new(PassRedBlue));\n-    reg.lint_store.register_late_pass(|| Box::new(PassGreyGreen));\n+    reg.lint_store.register_late_pass(|_| Box::new(PassOkay));\n+    reg.lint_store.register_late_pass(|_| Box::new(PassRedBlue));\n+    reg.lint_store.register_late_pass(|_| Box::new(PassGreyGreen));\n }"}, {"sha": "0b1534939b778fdbdd3be1e68b5a4950f9b37d11", "filename": "src/test/ui-fulldeps/auxiliary/lint-for-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -39,5 +39,5 @@ impl<'tcx> LateLintPass<'tcx> for Pass {\n #[no_mangle]\n fn __rustc_plugin_registrar(reg: &mut Registry) {\n     reg.lint_store.register_lints(&[&CRATE_NOT_OKAY]);\n-    reg.lint_store.register_late_pass(|| Box::new(Pass));\n+    reg.lint_store.register_late_pass(|_| Box::new(Pass));\n }"}, {"sha": "2d41b5f30e975e2f7c330da40962f54dcd2d8af1", "filename": "src/test/ui-fulldeps/auxiliary/lint-group-plugin-test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-group-plugin-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-group-plugin-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-group-plugin-test.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -36,7 +36,7 @@ impl<'tcx> LateLintPass<'tcx> for Pass {\n #[no_mangle]\n fn __rustc_plugin_registrar(reg: &mut Registry) {\n     reg.lint_store.register_lints(&[&TEST_LINT, &PLEASE_LINT]);\n-    reg.lint_store.register_late_pass(|| Box::new(Pass));\n+    reg.lint_store.register_late_pass(|_| Box::new(Pass));\n     reg.lint_store.register_group(\n         true,\n         \"lint_me\","}, {"sha": "499bbd6b6fad2e1a6cdcf821cbe26c39a2254487", "filename": "src/test/ui/associated-types/issue-62200.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Fassociated-types%2Fissue-62200.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Fassociated-types%2Fissue-62200.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-62200.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -10,6 +10,7 @@ impl T<'_> for S {\n \n fn foo(x: impl Fn(<S as T<'_>>::A) -> <S as T<'_>>::A) {}\n //~^ ERROR binding for associated type `Output` references an anonymous lifetime\n-//~^^ NOTE lifetimes appearing in an associated type are not considered constrained\n+//~| NOTE lifetimes appearing in an associated or opaque type are not considered constrained\n+//~| NOTE consider introducing a named lifetime parameter\n \n fn main() {}"}, {"sha": "04f0728f58ea86bb68a6d0df3130080757797c79", "filename": "src/test/ui/associated-types/issue-62200.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Fassociated-types%2Fissue-62200.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Fassociated-types%2Fissue-62200.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-62200.stderr?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -4,7 +4,8 @@ error[E0582]: binding for associated type `Output` references an anonymous lifet\n LL | fn foo(x: impl Fn(<S as T<'_>>::A) -> <S as T<'_>>::A) {}\n    |                                       ^^^^^^^^^^^^^^^\n    |\n-   = note: lifetimes appearing in an associated type are not considered constrained\n+   = note: lifetimes appearing in an associated or opaque type are not considered constrained\n+   = note: consider introducing a named lifetime parameter\n \n error: aborting due to previous error\n "}, {"sha": "34826d2f4bf7ab2932657a08c53a606ded25d406", "filename": "src/test/ui/binop/binary-op-on-double-ref.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Fbinop%2Fbinary-op-on-double-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Fbinop%2Fbinary-op-on-double-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fbinary-op-on-double-ref.stderr?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -6,7 +6,7 @@ LL |         x % 2 == 0\n    |         |\n    |         &&{integer}\n    |\n-help: `%` can be used on `{integer}`, you can dereference `x`\n+help: `%` can be used on `&{integer}` if you dereference the left-hand side\n    |\n LL |         *x % 2 == 0\n    |         +"}, {"sha": "ee758f19ec105345066f5437ce2e17aaf125cc63", "filename": "src/test/ui/generic-associated-types/missing-bounds.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.fixed?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -24,7 +24,7 @@ impl<B: Add + Add<Output = B>> Add for C<B> {\n \n struct D<B>(B);\n \n-impl<B: std::ops::Add<Output=B>> Add for D<B> {\n+impl<B: std::ops::Add<Output = B>> Add for D<B> {\n     type Output = Self;\n \n     fn add(self, rhs: Self) -> Self {"}, {"sha": "c913483a8747c15ef849f859570306d64a177578", "filename": "src/test/ui/generic-associated-types/missing-bounds.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -66,8 +66,8 @@ LL |         Self(self.0 + rhs.0)\n    |\n help: consider restricting type parameter `B`\n    |\n-LL | impl<B: std::ops::Add<Output=B>> Add for D<B> {\n-   |       +++++++++++++++++++++++++\n+LL | impl<B: std::ops::Add<Output = B>> Add for D<B> {\n+   |       +++++++++++++++++++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/missing-bounds.rs:42:14"}, {"sha": "9998ee0e8d0c69c801528a509eb6371d10af4f86", "filename": "src/test/ui/issues/issue-47511.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Fissues%2Fissue-47511.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Fissues%2Fissue-47511.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-47511.stderr?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -4,7 +4,8 @@ error[E0581]: return type references an anonymous lifetime, which is not constra\n LL | fn f(_: X) -> X {\n    |               ^\n    |\n-   = note: lifetimes appearing in an associated type are not considered constrained\n+   = note: lifetimes appearing in an associated or opaque type are not considered constrained\n+   = note: consider introducing a named lifetime parameter\n \n error[E0581]: return type references lifetime `'a`, which is not constrained by the fn input types\n   --> $DIR/issue-47511.rs:12:23"}, {"sha": "1dfeae22aea2f53f4d9969238e1a1ce6160ad1d4", "filename": "src/test/ui/parser/issue-101477-enum.fixed", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Fparser%2Fissue-101477-enum.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Fparser%2Fissue-101477-enum.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-101477-enum.fixed?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -0,0 +1,10 @@\n+// run-rustfix\n+\n+#[allow(dead_code)]\n+enum Demo {\n+    A = 1,\n+    B = 2 //~ ERROR unexpected `==`\n+    //~^ expected item, found `==`\n+}\n+\n+fn main() {}"}, {"sha": "ea7051d69a4c7f0230e18070bf7659d0880e90e3", "filename": "src/test/ui/parser/issue-101477-enum.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Fparser%2Fissue-101477-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Fparser%2Fissue-101477-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-101477-enum.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -0,0 +1,10 @@\n+// run-rustfix\n+\n+#[allow(dead_code)]\n+enum Demo {\n+    A = 1,\n+    B == 2 //~ ERROR unexpected `==`\n+    //~^ expected item, found `==`\n+}\n+\n+fn main() {}"}, {"sha": "bffc881bdc84b84623c84aadab53c60b6ca8b0d7", "filename": "src/test/ui/parser/issue-101477-enum.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Fparser%2Fissue-101477-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Fparser%2Fissue-101477-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-101477-enum.stderr?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -0,0 +1,14 @@\n+error: unexpected `==`\n+  --> $DIR/issue-101477-enum.rs:6:7\n+   |\n+LL |     B == 2\n+   |       ^^ help: try using `=` instead\n+\n+error: expected item, found `==`\n+  --> $DIR/issue-101477-enum.rs:6:7\n+   |\n+LL |     B == 2\n+   |       ^^ expected item\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "9989ad81524e1937b6ccdec21ad1947a2fe93dbc", "filename": "src/test/ui/parser/issue-101477-let.fixed", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Fparser%2Fissue-101477-let.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Fparser%2Fissue-101477-let.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-101477-let.fixed?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -0,0 +1,6 @@\n+// run-rustfix\n+\n+fn main() {\n+    let x = 2; //~ ERROR unexpected `==`\n+    println!(\"x: {}\", x)\n+}"}, {"sha": "8b0e8bee1799d87ded6920f5ce6ec4d2bb26530e", "filename": "src/test/ui/parser/issue-101477-let.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Fparser%2Fissue-101477-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Fparser%2Fissue-101477-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-101477-let.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -0,0 +1,6 @@\n+// run-rustfix\n+\n+fn main() {\n+    let x == 2; //~ ERROR unexpected `==`\n+    println!(\"x: {}\", x)\n+}"}, {"sha": "1b30d4b17861af658a8c62c3a23d9c3fbf0374e3", "filename": "src/test/ui/parser/issue-101477-let.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Fparser%2Fissue-101477-let.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Fparser%2Fissue-101477-let.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-101477-let.stderr?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -0,0 +1,8 @@\n+error: unexpected `==`\n+  --> $DIR/issue-101477-let.rs:4:11\n+   |\n+LL |     let x == 2;\n+   |           ^^ help: try using `=` instead\n+\n+error: aborting due to previous error\n+"}, {"sha": "1e7569fa45106c60b8660a83af58f6c6c3757648", "filename": "src/test/ui/suggestions/issue-97677.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97677.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97677.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97677.fixed?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-fn add_ten<N: std::ops::Add<i32, Output=N>>(n: N) -> N {\n+fn add_ten<N: std::ops::Add<i32, Output = N>>(n: N) -> N {\n     n + 10\n     //~^ ERROR cannot add `{integer}` to `N`\n }"}, {"sha": "575d79267f20d718957f456241a28b7ec1c3d66a", "filename": "src/test/ui/suggestions/issue-97677.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97677.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97677.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97677.stderr?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -8,8 +8,8 @@ LL |     n + 10\n    |\n help: consider restricting type parameter `N`\n    |\n-LL | fn add_ten<N: std::ops::Add<i32, Output=N>>(n: N) -> N {\n-   |             ++++++++++++++++++++++++++++++\n+LL | fn add_ten<N: std::ops::Add<i32, Output = N>>(n: N) -> N {\n+   |             ++++++++++++++++++++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "60f5ba45c268d1ae6463509a16cc32c8b4f0e5e1", "filename": "src/test/ui/suggestions/restrict-type-not-param.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Fsuggestions%2Frestrict-type-not-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Fsuggestions%2Frestrict-type-not-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Frestrict-type-not-param.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -0,0 +1,12 @@\n+use std::ops::Add;\n+\n+struct Wrapper<T>(T);\n+\n+trait Foo {}\n+\n+fn qux<T>(a: Wrapper<T>, b: T) -> T {\n+    a + b\n+    //~^ ERROR cannot add `T` to `Wrapper<T>`\n+}\n+\n+fn main() {}"}, {"sha": "e7d9c5ecbe48208a720fac6deb23cfff4778b96a", "filename": "src/test/ui/suggestions/restrict-type-not-param.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Fsuggestions%2Frestrict-type-not-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Fsuggestions%2Frestrict-type-not-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Frestrict-type-not-param.stderr?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -0,0 +1,26 @@\n+error[E0369]: cannot add `T` to `Wrapper<T>`\n+  --> $DIR/restrict-type-not-param.rs:8:7\n+   |\n+LL |     a + b\n+   |     - ^ - T\n+   |     |\n+   |     Wrapper<T>\n+   |\n+note: an implementation of `Add<_>` might be missing for `Wrapper<T>`\n+  --> $DIR/restrict-type-not-param.rs:3:1\n+   |\n+LL | struct Wrapper<T>(T);\n+   | ^^^^^^^^^^^^^^^^^ must implement `Add<_>`\n+note: the following trait must be implemented\n+  --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+   |\n+LL | pub trait Add<Rhs = Self> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n+   |\n+LL | fn qux<T>(a: Wrapper<T>, b: T) -> T where Wrapper<T>: Add<T, Output = T> {\n+   |                                     ++++++++++++++++++++++++++++++++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0369`."}, {"sha": "fe5e1d6d2854de0b98f0588d188734ff3404213b", "filename": "src/test/ui/traits/resolution-in-overloaded-op.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Ftraits%2Fresolution-in-overloaded-op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Ftraits%2Fresolution-in-overloaded-op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fresolution-in-overloaded-op.stderr?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -8,8 +8,8 @@ LL |     a * b\n    |\n help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n    |\n-LL | fn foo<T: MyMul<f64, f64>>(a: &T, b: f64) -> f64 where &T: Mul<f64> {\n-   |                                                  ++++++++++++++++++\n+LL | fn foo<T: MyMul<f64, f64>>(a: &T, b: f64) -> f64 where &T: Mul<f64, Output = f64> {\n+   |                                                  ++++++++++++++++++++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "03fb64b7b94d7ea02224ae7cc4b5060e847a1133", "filename": "src/test/ui/type-alias-impl-trait/constrain_inputs.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fconstrain_inputs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fconstrain_inputs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fconstrain_inputs.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -1,17 +1,33 @@\n-// check-pass\n-\n #![feature(type_alias_impl_trait)]\n \n-mod foo {\n+mod lifetime_params {\n     type Ty<'a> = impl Sized;\n     fn defining(s: &str) -> Ty<'_> { s }\n     fn execute(ty: Ty<'_>) -> &str { todo!() }\n+    //~^ ERROR return type references an anonymous lifetime, which is not constrained by the fn input types\n+\n+    type BadFnSig = fn(Ty<'_>) -> &str;\n+    //~^ ERROR return type references an anonymous lifetime, which is not constrained by the fn input types\n+    type BadTraitRef = dyn Fn(Ty<'_>) -> &str;\n+    //~^ ERROR binding for associated type `Output` references an anonymous lifetime\n }\n \n-mod bar {\n+mod lifetime_params_2 {\n     type Ty<'a> = impl FnOnce() -> &'a str;\n     fn defining(s: &str) -> Ty<'_> { move || s }\n     fn execute(ty: Ty<'_>) -> &str { ty() }\n+    //~^ ERROR return type references an anonymous lifetime, which is not constrained by the fn input types\n+}\n+\n+// regression test for https://github.com/rust-lang/rust/issues/97104\n+mod type_params {\n+    type Ty<T> = impl Sized;\n+    fn define<T>(s: T) -> Ty<T> { s }\n+\n+    type BadFnSig = fn(Ty<&str>) -> &str;\n+    //~^ ERROR return type references an anonymous lifetime, which is not constrained by the fn input types\n+    type BadTraitRef = dyn Fn(Ty<&str>) -> &str;\n+    //~^ ERROR binding for associated type `Output` references an anonymous lifetime\n }\n \n fn main() {}"}, {"sha": "93953fd06d1fd70687432f25f19f175edcafcfb3", "filename": "src/test/ui/type-alias-impl-trait/constrain_inputs.stderr", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fconstrain_inputs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fconstrain_inputs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fconstrain_inputs.stderr?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -0,0 +1,58 @@\n+error[E0581]: return type references an anonymous lifetime, which is not constrained by the fn input types\n+  --> $DIR/constrain_inputs.rs:6:31\n+   |\n+LL |     fn execute(ty: Ty<'_>) -> &str { todo!() }\n+   |                               ^^^^\n+   |\n+   = note: lifetimes appearing in an associated or opaque type are not considered constrained\n+   = note: consider introducing a named lifetime parameter\n+\n+error[E0581]: return type references an anonymous lifetime, which is not constrained by the fn input types\n+  --> $DIR/constrain_inputs.rs:9:35\n+   |\n+LL |     type BadFnSig = fn(Ty<'_>) -> &str;\n+   |                                   ^^^^\n+   |\n+   = note: lifetimes appearing in an associated or opaque type are not considered constrained\n+   = note: consider introducing a named lifetime parameter\n+\n+error[E0582]: binding for associated type `Output` references an anonymous lifetime, which does not appear in the trait input types\n+  --> $DIR/constrain_inputs.rs:11:42\n+   |\n+LL |     type BadTraitRef = dyn Fn(Ty<'_>) -> &str;\n+   |                                          ^^^^\n+   |\n+   = note: lifetimes appearing in an associated or opaque type are not considered constrained\n+   = note: consider introducing a named lifetime parameter\n+\n+error[E0581]: return type references an anonymous lifetime, which is not constrained by the fn input types\n+  --> $DIR/constrain_inputs.rs:18:31\n+   |\n+LL |     fn execute(ty: Ty<'_>) -> &str { ty() }\n+   |                               ^^^^\n+   |\n+   = note: lifetimes appearing in an associated or opaque type are not considered constrained\n+   = note: consider introducing a named lifetime parameter\n+\n+error[E0581]: return type references an anonymous lifetime, which is not constrained by the fn input types\n+  --> $DIR/constrain_inputs.rs:27:37\n+   |\n+LL |     type BadFnSig = fn(Ty<&str>) -> &str;\n+   |                                     ^^^^\n+   |\n+   = note: lifetimes appearing in an associated or opaque type are not considered constrained\n+   = note: consider introducing a named lifetime parameter\n+\n+error[E0582]: binding for associated type `Output` references an anonymous lifetime, which does not appear in the trait input types\n+  --> $DIR/constrain_inputs.rs:29:44\n+   |\n+LL |     type BadTraitRef = dyn Fn(Ty<&str>) -> &str;\n+   |                                            ^^^^\n+   |\n+   = note: lifetimes appearing in an associated or opaque type are not considered constrained\n+   = note: consider introducing a named lifetime parameter\n+\n+error: aborting due to 6 previous errors\n+\n+Some errors have detailed explanations: E0581, E0582.\n+For more information about an error, try `rustc --explain E0581`."}, {"sha": "3bae0f1730994d50d4d69450ab309422938165eb", "filename": "src/test/ui/type-alias-impl-trait/constrain_inputs_unsound.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fconstrain_inputs_unsound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fconstrain_inputs_unsound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fconstrain_inputs_unsound.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -0,0 +1,31 @@\n+#![feature(type_alias_impl_trait)]\n+\n+trait Static: 'static {}\n+impl Static for () {}\n+\n+type Gal<T> = impl Static;\n+fn _defining<T>() -> Gal<T> {}\n+\n+trait Callable<Arg> { type Output; }\n+\n+/// We can infer `<C as Callable<Arg>>::Output: 'static`,\n+/// because we know `C: 'static` and `Arg: 'static`,\n+fn box_str<C, Arg>(s: C::Output) -> Box<dyn AsRef<str> + 'static>\n+where\n+    Arg: Static,\n+    C: ?Sized + Callable<Arg> + 'static,\n+    C::Output: AsRef<str>,\n+{\n+    Box::new(s)\n+}\n+\n+fn extend_lifetime(s: &str) -> Box<dyn AsRef<str> + 'static> {\n+    type MalformedTy = dyn for<'a> Callable<Gal<&'a ()>, Output = &'a str>;\n+    //~^ ERROR binding for associated type `Output` references lifetime `'a`\n+    box_str::<MalformedTy, _>(s)\n+}\n+\n+fn main() {\n+    let extended = extend_lifetime(&String::from(\"hello\"));\n+    println!(\"{}\", extended.as_ref().as_ref());\n+}"}, {"sha": "d5fc46cb1f596d01c889402106e20d229205c6e9", "filename": "src/test/ui/type-alias-impl-trait/constrain_inputs_unsound.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fconstrain_inputs_unsound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fconstrain_inputs_unsound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fconstrain_inputs_unsound.stderr?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -0,0 +1,9 @@\n+error[E0582]: binding for associated type `Output` references lifetime `'a`, which does not appear in the trait input types\n+  --> $DIR/constrain_inputs_unsound.rs:23:58\n+   |\n+LL |     type MalformedTy = dyn for<'a> Callable<Gal<&'a ()>, Output = &'a str>;\n+   |                                                          ^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0582`."}, {"sha": "e394cf8206edef45077760f28886f310e09c0e3c", "filename": "src/test/ui/typeck/assign-non-lval-derefmut.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-derefmut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-derefmut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-derefmut.stderr?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -19,7 +19,7 @@ LL |     x.lock().unwrap() += 1;\n    |     |\n    |     cannot use `+=` on type `MutexGuard<'_, usize>`\n    |\n-help: `+=` can be used on `usize`, you can dereference `x.lock().unwrap()`\n+help: `+=` can be used on `usize` if you dereference the left-hand side\n    |\n LL |     *x.lock().unwrap() += 1;\n    |     +\n@@ -47,7 +47,7 @@ LL |     y += 1;\n    |     |\n    |     cannot use `+=` on type `MutexGuard<'_, usize>`\n    |\n-help: `+=` can be used on `usize`, you can dereference `y`\n+help: `+=` can be used on `usize` if you dereference the left-hand side\n    |\n LL |     *y += 1;\n    |     +"}, {"sha": "cbdc960baab8e7cafaa456825299b800c3c122ad", "filename": "src/test/ui/typeck/assign-non-lval-mut-ref.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-mut-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-mut-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-mut-ref.stderr?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -19,7 +19,7 @@ LL |     x.last_mut().unwrap() += 1;\n    |     |\n    |     cannot use `+=` on type `&mut usize`\n    |\n-help: `+=` can be used on `usize`, you can dereference `x.last_mut().unwrap()`\n+help: `+=` can be used on `usize` if you dereference the left-hand side\n    |\n LL |     *x.last_mut().unwrap() += 1;\n    |     +\n@@ -45,7 +45,7 @@ LL |     y += 1;\n    |     |\n    |     cannot use `+=` on type `&mut usize`\n    |\n-help: `+=` can be used on `usize`, you can dereference `y`\n+help: `+=` can be used on `usize` if you dereference the left-hand side\n    |\n LL |     *y += 1;\n    |     +"}, {"sha": "331b76484b8a5d5f62992a34d73de6fadbf72c93", "filename": "src/tools/clippy/clippy_dev/src/new_lint.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fnew_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fnew_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fnew_lint.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -120,15 +120,17 @@ fn add_lint(lint: &LintData<'_>, enable_msrv: bool) -> io::Result<()> {\n \n     let new_lint = if enable_msrv {\n         format!(\n-            \"store.register_{lint_pass}_pass(move || Box::new({module_name}::{camel_name}::new(msrv)));\\n    \",\n+            \"store.register_{lint_pass}_pass(move |{ctor_arg}| Box::new({module_name}::{camel_name}::new(msrv)));\\n    \",\n             lint_pass = lint.pass,\n+            ctor_arg = if lint.pass == \"late\" { \"_\" } else { \"\" },\n             module_name = lint.name,\n             camel_name = to_camel_case(lint.name),\n         )\n     } else {\n         format!(\n-            \"store.register_{lint_pass}_pass(|| Box::new({module_name}::{camel_name}));\\n    \",\n+            \"store.register_{lint_pass}_pass(|{ctor_arg}| Box::new({module_name}::{camel_name}));\\n    \",\n             lint_pass = lint.pass,\n+            ctor_arg = if lint.pass == \"late\" { \"_\" } else { \"\" },\n             module_name = lint.name,\n             camel_name = to_camel_case(lint.name),\n         )"}, {"sha": "c70aa79ac8dcffdcfcece1c391a850f547a3e61b", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "modified", "additions": 207, "deletions": 207, "changes": 414, "blob_url": "https://github.com/rust-lang/rust/blob/87788097b776f8e3662f76627944230684b671bd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87788097b776f8e3662f76627944230684b671bd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=87788097b776f8e3662f76627944230684b671bd", "patch": "@@ -523,7 +523,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     #[cfg(feature = \"internal\")]\n     {\n         if std::env::var(\"ENABLE_METADATA_COLLECTION\").eq(&Ok(\"1\".to_string())) {\n-            store.register_late_pass(|| Box::new(utils::internal_lints::metadata_collector::MetadataCollector::new()));\n+            store.register_late_pass(|_| Box::new(utils::internal_lints::metadata_collector::MetadataCollector::new()));\n             return;\n         }\n     }\n@@ -533,218 +533,218 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     {\n         store.register_early_pass(|| Box::new(utils::internal_lints::ClippyLintsInternal));\n         store.register_early_pass(|| Box::new(utils::internal_lints::ProduceIce));\n-        store.register_late_pass(|| Box::new(utils::internal_lints::CollapsibleCalls));\n-        store.register_late_pass(|| Box::new(utils::internal_lints::CompilerLintFunctions::new()));\n-        store.register_late_pass(|| Box::new(utils::internal_lints::IfChainStyle));\n-        store.register_late_pass(|| Box::new(utils::internal_lints::InvalidPaths));\n-        store.register_late_pass(|| Box::new(utils::internal_lints::InterningDefinedSymbol::default()));\n-        store.register_late_pass(|| Box::new(utils::internal_lints::LintWithoutLintPass::default()));\n-        store.register_late_pass(|| Box::new(utils::internal_lints::MatchTypeOnDiagItem));\n-        store.register_late_pass(|| Box::new(utils::internal_lints::OuterExpnDataPass));\n-        store.register_late_pass(|| Box::new(utils::internal_lints::MsrvAttrImpl));\n+        store.register_late_pass(|_| Box::new(utils::internal_lints::CollapsibleCalls));\n+        store.register_late_pass(|_| Box::new(utils::internal_lints::CompilerLintFunctions::new()));\n+        store.register_late_pass(|_| Box::new(utils::internal_lints::IfChainStyle));\n+        store.register_late_pass(|_| Box::new(utils::internal_lints::InvalidPaths));\n+        store.register_late_pass(|_| Box::new(utils::internal_lints::InterningDefinedSymbol::default()));\n+        store.register_late_pass(|_| Box::new(utils::internal_lints::LintWithoutLintPass::default()));\n+        store.register_late_pass(|_| Box::new(utils::internal_lints::MatchTypeOnDiagItem));\n+        store.register_late_pass(|_| Box::new(utils::internal_lints::OuterExpnDataPass));\n+        store.register_late_pass(|_| Box::new(utils::internal_lints::MsrvAttrImpl));\n     }\n \n     let arithmetic_allowed = conf.arithmetic_allowed.clone();\n-    store.register_late_pass(move || Box::new(operators::arithmetic::Arithmetic::new(arithmetic_allowed.clone())));\n-    store.register_late_pass(|| Box::new(utils::dump_hir::DumpHir));\n-    store.register_late_pass(|| Box::new(utils::author::Author));\n+    store.register_late_pass(move |_| Box::new(operators::arithmetic::Arithmetic::new(arithmetic_allowed.clone())));\n+    store.register_late_pass(|_| Box::new(utils::dump_hir::DumpHir));\n+    store.register_late_pass(|_| Box::new(utils::author::Author));\n     let await_holding_invalid_types = conf.await_holding_invalid_types.clone();\n-    store.register_late_pass(move || {\n+    store.register_late_pass(move |_| {\n         Box::new(await_holding_invalid::AwaitHolding::new(\n             await_holding_invalid_types.clone(),\n         ))\n     });\n-    store.register_late_pass(|| Box::new(serde_api::SerdeApi));\n+    store.register_late_pass(|_| Box::new(serde_api::SerdeApi));\n     let vec_box_size_threshold = conf.vec_box_size_threshold;\n     let type_complexity_threshold = conf.type_complexity_threshold;\n     let avoid_breaking_exported_api = conf.avoid_breaking_exported_api;\n-    store.register_late_pass(move || {\n+    store.register_late_pass(move |_| {\n         Box::new(types::Types::new(\n             vec_box_size_threshold,\n             type_complexity_threshold,\n             avoid_breaking_exported_api,\n         ))\n     });\n-    store.register_late_pass(|| Box::new(booleans::NonminimalBool));\n-    store.register_late_pass(|| Box::new(enum_clike::UnportableVariant));\n-    store.register_late_pass(|| Box::new(float_literal::FloatLiteral));\n-    store.register_late_pass(|| Box::new(ptr::Ptr));\n-    store.register_late_pass(|| Box::new(needless_bool::NeedlessBool));\n-    store.register_late_pass(|| Box::new(needless_bool::BoolComparison));\n-    store.register_late_pass(|| Box::new(needless_for_each::NeedlessForEach));\n-    store.register_late_pass(|| Box::new(misc::MiscLints));\n-    store.register_late_pass(|| Box::new(eta_reduction::EtaReduction));\n-    store.register_late_pass(|| Box::new(mut_mut::MutMut));\n-    store.register_late_pass(|| Box::new(mut_reference::UnnecessaryMutPassed));\n-    store.register_late_pass(|| Box::new(len_zero::LenZero));\n-    store.register_late_pass(|| Box::new(attrs::Attributes));\n-    store.register_late_pass(|| Box::new(blocks_in_if_conditions::BlocksInIfConditions));\n-    store.register_late_pass(|| Box::new(unicode::Unicode));\n-    store.register_late_pass(|| Box::new(uninit_vec::UninitVec));\n-    store.register_late_pass(|| Box::new(unit_return_expecting_ord::UnitReturnExpectingOrd));\n-    store.register_late_pass(|| Box::new(strings::StringAdd));\n-    store.register_late_pass(|| Box::new(implicit_return::ImplicitReturn));\n-    store.register_late_pass(|| Box::new(implicit_saturating_sub::ImplicitSaturatingSub));\n-    store.register_late_pass(|| Box::new(default_numeric_fallback::DefaultNumericFallback));\n-    store.register_late_pass(|| Box::new(inconsistent_struct_constructor::InconsistentStructConstructor));\n-    store.register_late_pass(|| Box::new(non_octal_unix_permissions::NonOctalUnixPermissions));\n+    store.register_late_pass(|_| Box::new(booleans::NonminimalBool));\n+    store.register_late_pass(|_| Box::new(enum_clike::UnportableVariant));\n+    store.register_late_pass(|_| Box::new(float_literal::FloatLiteral));\n+    store.register_late_pass(|_| Box::new(ptr::Ptr));\n+    store.register_late_pass(|_| Box::new(needless_bool::NeedlessBool));\n+    store.register_late_pass(|_| Box::new(needless_bool::BoolComparison));\n+    store.register_late_pass(|_| Box::new(needless_for_each::NeedlessForEach));\n+    store.register_late_pass(|_| Box::new(misc::MiscLints));\n+    store.register_late_pass(|_| Box::new(eta_reduction::EtaReduction));\n+    store.register_late_pass(|_| Box::new(mut_mut::MutMut));\n+    store.register_late_pass(|_| Box::new(mut_reference::UnnecessaryMutPassed));\n+    store.register_late_pass(|_| Box::new(len_zero::LenZero));\n+    store.register_late_pass(|_| Box::new(attrs::Attributes));\n+    store.register_late_pass(|_| Box::new(blocks_in_if_conditions::BlocksInIfConditions));\n+    store.register_late_pass(|_| Box::new(unicode::Unicode));\n+    store.register_late_pass(|_| Box::new(uninit_vec::UninitVec));\n+    store.register_late_pass(|_| Box::new(unit_return_expecting_ord::UnitReturnExpectingOrd));\n+    store.register_late_pass(|_| Box::new(strings::StringAdd));\n+    store.register_late_pass(|_| Box::new(implicit_return::ImplicitReturn));\n+    store.register_late_pass(|_| Box::new(implicit_saturating_sub::ImplicitSaturatingSub));\n+    store.register_late_pass(|_| Box::new(default_numeric_fallback::DefaultNumericFallback));\n+    store.register_late_pass(|_| Box::new(inconsistent_struct_constructor::InconsistentStructConstructor));\n+    store.register_late_pass(|_| Box::new(non_octal_unix_permissions::NonOctalUnixPermissions));\n     store.register_early_pass(|| Box::new(unnecessary_self_imports::UnnecessarySelfImports));\n \n     let msrv = read_msrv(conf, sess);\n     let avoid_breaking_exported_api = conf.avoid_breaking_exported_api;\n     let allow_expect_in_tests = conf.allow_expect_in_tests;\n     let allow_unwrap_in_tests = conf.allow_unwrap_in_tests;\n-    store.register_late_pass(move || Box::new(approx_const::ApproxConstant::new(msrv)));\n-    store.register_late_pass(move || {\n+    store.register_late_pass(move |_| Box::new(approx_const::ApproxConstant::new(msrv)));\n+    store.register_late_pass(move |_| {\n         Box::new(methods::Methods::new(\n             avoid_breaking_exported_api,\n             msrv,\n             allow_expect_in_tests,\n             allow_unwrap_in_tests,\n         ))\n     });\n-    store.register_late_pass(move || Box::new(matches::Matches::new(msrv)));\n+    store.register_late_pass(move |_| Box::new(matches::Matches::new(msrv)));\n     store.register_early_pass(move || Box::new(manual_non_exhaustive::ManualNonExhaustiveStruct::new(msrv)));\n-    store.register_late_pass(move || Box::new(manual_non_exhaustive::ManualNonExhaustiveEnum::new(msrv)));\n-    store.register_late_pass(move || Box::new(manual_strip::ManualStrip::new(msrv)));\n+    store.register_late_pass(move |_| Box::new(manual_non_exhaustive::ManualNonExhaustiveEnum::new(msrv)));\n+    store.register_late_pass(move |_| Box::new(manual_strip::ManualStrip::new(msrv)));\n     store.register_early_pass(move || Box::new(redundant_static_lifetimes::RedundantStaticLifetimes::new(msrv)));\n     store.register_early_pass(move || Box::new(redundant_field_names::RedundantFieldNames::new(msrv)));\n-    store.register_late_pass(move || Box::new(checked_conversions::CheckedConversions::new(msrv)));\n-    store.register_late_pass(move || Box::new(mem_replace::MemReplace::new(msrv)));\n-    store.register_late_pass(move || Box::new(ranges::Ranges::new(msrv)));\n-    store.register_late_pass(move || Box::new(from_over_into::FromOverInto::new(msrv)));\n-    store.register_late_pass(move || Box::new(use_self::UseSelf::new(msrv)));\n-    store.register_late_pass(move || Box::new(missing_const_for_fn::MissingConstForFn::new(msrv)));\n-    store.register_late_pass(move || Box::new(needless_question_mark::NeedlessQuestionMark));\n-    store.register_late_pass(move || Box::new(casts::Casts::new(msrv)));\n+    store.register_late_pass(move |_| Box::new(checked_conversions::CheckedConversions::new(msrv)));\n+    store.register_late_pass(move |_| Box::new(mem_replace::MemReplace::new(msrv)));\n+    store.register_late_pass(move |_| Box::new(ranges::Ranges::new(msrv)));\n+    store.register_late_pass(move |_| Box::new(from_over_into::FromOverInto::new(msrv)));\n+    store.register_late_pass(move |_| Box::new(use_self::UseSelf::new(msrv)));\n+    store.register_late_pass(move |_| Box::new(missing_const_for_fn::MissingConstForFn::new(msrv)));\n+    store.register_late_pass(move |_| Box::new(needless_question_mark::NeedlessQuestionMark));\n+    store.register_late_pass(move |_| Box::new(casts::Casts::new(msrv)));\n     store.register_early_pass(move || Box::new(unnested_or_patterns::UnnestedOrPatterns::new(msrv)));\n-    store.register_late_pass(|| Box::new(size_of_in_element_count::SizeOfInElementCount));\n-    store.register_late_pass(|| Box::new(same_name_method::SameNameMethod));\n+    store.register_late_pass(|_| Box::new(size_of_in_element_count::SizeOfInElementCount));\n+    store.register_late_pass(|_| Box::new(same_name_method::SameNameMethod));\n     let max_suggested_slice_pattern_length = conf.max_suggested_slice_pattern_length;\n-    store.register_late_pass(move || {\n+    store.register_late_pass(move |_| {\n         Box::new(index_refutable_slice::IndexRefutableSlice::new(\n             max_suggested_slice_pattern_length,\n             msrv,\n         ))\n     });\n-    store.register_late_pass(|| Box::new(shadow::Shadow::default()));\n-    store.register_late_pass(|| Box::new(unit_types::UnitTypes));\n-    store.register_late_pass(|| Box::new(loops::Loops));\n-    store.register_late_pass(|| Box::new(main_recursion::MainRecursion::default()));\n-    store.register_late_pass(|| Box::new(lifetimes::Lifetimes));\n-    store.register_late_pass(|| Box::new(entry::HashMapPass));\n-    store.register_late_pass(|| Box::new(minmax::MinMaxPass));\n-    store.register_late_pass(|| Box::new(zero_div_zero::ZeroDiv));\n-    store.register_late_pass(|| Box::new(mutex_atomic::Mutex));\n-    store.register_late_pass(|| Box::new(needless_update::NeedlessUpdate));\n-    store.register_late_pass(|| Box::new(needless_borrowed_ref::NeedlessBorrowedRef));\n-    store.register_late_pass(|| Box::new(borrow_deref_ref::BorrowDerefRef));\n-    store.register_late_pass(|| Box::new(no_effect::NoEffect));\n-    store.register_late_pass(|| Box::new(temporary_assignment::TemporaryAssignment));\n-    store.register_late_pass(move || Box::new(transmute::Transmute::new(msrv)));\n+    store.register_late_pass(|_| Box::new(shadow::Shadow::default()));\n+    store.register_late_pass(|_| Box::new(unit_types::UnitTypes));\n+    store.register_late_pass(|_| Box::new(loops::Loops));\n+    store.register_late_pass(|_| Box::new(main_recursion::MainRecursion::default()));\n+    store.register_late_pass(|_| Box::new(lifetimes::Lifetimes));\n+    store.register_late_pass(|_| Box::new(entry::HashMapPass));\n+    store.register_late_pass(|_| Box::new(minmax::MinMaxPass));\n+    store.register_late_pass(|_| Box::new(zero_div_zero::ZeroDiv));\n+    store.register_late_pass(|_| Box::new(mutex_atomic::Mutex));\n+    store.register_late_pass(|_| Box::new(needless_update::NeedlessUpdate));\n+    store.register_late_pass(|_| Box::new(needless_borrowed_ref::NeedlessBorrowedRef));\n+    store.register_late_pass(|_| Box::new(borrow_deref_ref::BorrowDerefRef));\n+    store.register_late_pass(|_| Box::new(no_effect::NoEffect));\n+    store.register_late_pass(|_| Box::new(temporary_assignment::TemporaryAssignment));\n+    store.register_late_pass(move |_| Box::new(transmute::Transmute::new(msrv)));\n     let cognitive_complexity_threshold = conf.cognitive_complexity_threshold;\n-    store.register_late_pass(move || {\n+    store.register_late_pass(move |_| {\n         Box::new(cognitive_complexity::CognitiveComplexity::new(\n             cognitive_complexity_threshold,\n         ))\n     });\n     let too_large_for_stack = conf.too_large_for_stack;\n-    store.register_late_pass(move || Box::new(escape::BoxedLocal { too_large_for_stack }));\n-    store.register_late_pass(move || Box::new(vec::UselessVec { too_large_for_stack }));\n-    store.register_late_pass(|| Box::new(panic_unimplemented::PanicUnimplemented));\n-    store.register_late_pass(|| Box::new(strings::StringLitAsBytes));\n-    store.register_late_pass(|| Box::new(derive::Derive));\n-    store.register_late_pass(|| Box::new(derivable_impls::DerivableImpls));\n-    store.register_late_pass(|| Box::new(drop_forget_ref::DropForgetRef));\n-    store.register_late_pass(|| Box::new(empty_enum::EmptyEnum));\n-    store.register_late_pass(|| Box::new(invalid_upcast_comparisons::InvalidUpcastComparisons));\n-    store.register_late_pass(|| Box::new(regex::Regex));\n-    store.register_late_pass(|| Box::new(copies::CopyAndPaste));\n-    store.register_late_pass(|| Box::new(copy_iterator::CopyIterator));\n-    store.register_late_pass(|| Box::new(format::UselessFormat));\n-    store.register_late_pass(|| Box::new(swap::Swap));\n-    store.register_late_pass(|| Box::new(overflow_check_conditional::OverflowCheckConditional));\n-    store.register_late_pass(|| Box::new(new_without_default::NewWithoutDefault::default()));\n+    store.register_late_pass(move |_| Box::new(escape::BoxedLocal { too_large_for_stack }));\n+    store.register_late_pass(move |_| Box::new(vec::UselessVec { too_large_for_stack }));\n+    store.register_late_pass(|_| Box::new(panic_unimplemented::PanicUnimplemented));\n+    store.register_late_pass(|_| Box::new(strings::StringLitAsBytes));\n+    store.register_late_pass(|_| Box::new(derive::Derive));\n+    store.register_late_pass(|_| Box::new(derivable_impls::DerivableImpls));\n+    store.register_late_pass(|_| Box::new(drop_forget_ref::DropForgetRef));\n+    store.register_late_pass(|_| Box::new(empty_enum::EmptyEnum));\n+    store.register_late_pass(|_| Box::new(invalid_upcast_comparisons::InvalidUpcastComparisons));\n+    store.register_late_pass(|_| Box::new(regex::Regex));\n+    store.register_late_pass(|_| Box::new(copies::CopyAndPaste));\n+    store.register_late_pass(|_| Box::new(copy_iterator::CopyIterator));\n+    store.register_late_pass(|_| Box::new(format::UselessFormat));\n+    store.register_late_pass(|_| Box::new(swap::Swap));\n+    store.register_late_pass(|_| Box::new(overflow_check_conditional::OverflowCheckConditional));\n+    store.register_late_pass(|_| Box::new(new_without_default::NewWithoutDefault::default()));\n     let disallowed_names = conf.disallowed_names.iter().cloned().collect::<FxHashSet<_>>();\n-    store.register_late_pass(move || Box::new(disallowed_names::DisallowedNames::new(disallowed_names.clone())));\n+    store.register_late_pass(move |_| Box::new(disallowed_names::DisallowedNames::new(disallowed_names.clone())));\n     let too_many_arguments_threshold = conf.too_many_arguments_threshold;\n     let too_many_lines_threshold = conf.too_many_lines_threshold;\n     let large_error_threshold = conf.large_error_threshold;\n-    store.register_late_pass(move || {\n+    store.register_late_pass(move |_| {\n         Box::new(functions::Functions::new(\n             too_many_arguments_threshold,\n             too_many_lines_threshold,\n             large_error_threshold,\n         ))\n     });\n     let doc_valid_idents = conf.doc_valid_idents.iter().cloned().collect::<FxHashSet<_>>();\n-    store.register_late_pass(move || Box::new(doc::DocMarkdown::new(doc_valid_idents.clone())));\n-    store.register_late_pass(|| Box::new(neg_multiply::NegMultiply));\n-    store.register_late_pass(|| Box::new(mem_forget::MemForget));\n-    store.register_late_pass(|| Box::new(let_if_seq::LetIfSeq));\n-    store.register_late_pass(|| Box::new(mixed_read_write_in_expression::EvalOrderDependence));\n-    store.register_late_pass(|| Box::new(missing_doc::MissingDoc::new()));\n-    store.register_late_pass(|| Box::new(missing_inline::MissingInline));\n-    store.register_late_pass(move || Box::new(exhaustive_items::ExhaustiveItems));\n-    store.register_late_pass(|| Box::new(match_result_ok::MatchResultOk));\n-    store.register_late_pass(|| Box::new(partialeq_ne_impl::PartialEqNeImpl));\n-    store.register_late_pass(|| Box::new(unused_io_amount::UnusedIoAmount));\n+    store.register_late_pass(move |_| Box::new(doc::DocMarkdown::new(doc_valid_idents.clone())));\n+    store.register_late_pass(|_| Box::new(neg_multiply::NegMultiply));\n+    store.register_late_pass(|_| Box::new(mem_forget::MemForget));\n+    store.register_late_pass(|_| Box::new(let_if_seq::LetIfSeq));\n+    store.register_late_pass(|_| Box::new(mixed_read_write_in_expression::EvalOrderDependence));\n+    store.register_late_pass(|_| Box::new(missing_doc::MissingDoc::new()));\n+    store.register_late_pass(|_| Box::new(missing_inline::MissingInline));\n+    store.register_late_pass(move |_| Box::new(exhaustive_items::ExhaustiveItems));\n+    store.register_late_pass(|_| Box::new(match_result_ok::MatchResultOk));\n+    store.register_late_pass(|_| Box::new(partialeq_ne_impl::PartialEqNeImpl));\n+    store.register_late_pass(|_| Box::new(unused_io_amount::UnusedIoAmount));\n     let enum_variant_size_threshold = conf.enum_variant_size_threshold;\n-    store.register_late_pass(move || Box::new(large_enum_variant::LargeEnumVariant::new(enum_variant_size_threshold)));\n-    store.register_late_pass(|| Box::new(explicit_write::ExplicitWrite));\n-    store.register_late_pass(|| Box::new(needless_pass_by_value::NeedlessPassByValue));\n+    store.register_late_pass(move |_| Box::new(large_enum_variant::LargeEnumVariant::new(enum_variant_size_threshold)));\n+    store.register_late_pass(|_| Box::new(explicit_write::ExplicitWrite));\n+    store.register_late_pass(|_| Box::new(needless_pass_by_value::NeedlessPassByValue));\n     let pass_by_ref_or_value = pass_by_ref_or_value::PassByRefOrValue::new(\n         conf.trivial_copy_size_limit,\n         conf.pass_by_value_size_limit,\n         conf.avoid_breaking_exported_api,\n         &sess.target,\n     );\n-    store.register_late_pass(move || Box::new(pass_by_ref_or_value));\n-    store.register_late_pass(|| Box::new(ref_option_ref::RefOptionRef));\n-    store.register_late_pass(|| Box::new(infinite_iter::InfiniteIter));\n-    store.register_late_pass(|| Box::new(inline_fn_without_body::InlineFnWithoutBody));\n-    store.register_late_pass(|| Box::new(useless_conversion::UselessConversion::default()));\n-    store.register_late_pass(|| Box::new(implicit_hasher::ImplicitHasher));\n-    store.register_late_pass(|| Box::new(fallible_impl_from::FallibleImplFrom));\n-    store.register_late_pass(|| Box::new(question_mark::QuestionMark));\n+    store.register_late_pass(move |_| Box::new(pass_by_ref_or_value));\n+    store.register_late_pass(|_| Box::new(ref_option_ref::RefOptionRef));\n+    store.register_late_pass(|_| Box::new(infinite_iter::InfiniteIter));\n+    store.register_late_pass(|_| Box::new(inline_fn_without_body::InlineFnWithoutBody));\n+    store.register_late_pass(|_| Box::new(useless_conversion::UselessConversion::default()));\n+    store.register_late_pass(|_| Box::new(implicit_hasher::ImplicitHasher));\n+    store.register_late_pass(|_| Box::new(fallible_impl_from::FallibleImplFrom));\n+    store.register_late_pass(|_| Box::new(question_mark::QuestionMark));\n     store.register_early_pass(|| Box::new(suspicious_operation_groupings::SuspiciousOperationGroupings));\n-    store.register_late_pass(|| Box::new(suspicious_trait_impl::SuspiciousImpl));\n-    store.register_late_pass(|| Box::new(map_unit_fn::MapUnit));\n-    store.register_late_pass(|| Box::new(inherent_impl::MultipleInherentImpl));\n-    store.register_late_pass(|| Box::new(neg_cmp_op_on_partial_ord::NoNegCompOpForPartialOrd));\n-    store.register_late_pass(|| Box::new(unwrap::Unwrap));\n-    store.register_late_pass(|| Box::new(indexing_slicing::IndexingSlicing));\n-    store.register_late_pass(|| Box::new(non_copy_const::NonCopyConst));\n-    store.register_late_pass(|| Box::new(ptr_offset_with_cast::PtrOffsetWithCast));\n-    store.register_late_pass(|| Box::new(redundant_clone::RedundantClone));\n-    store.register_late_pass(|| Box::new(slow_vector_initialization::SlowVectorInit));\n-    store.register_late_pass(move || Box::new(unnecessary_wraps::UnnecessaryWraps::new(avoid_breaking_exported_api)));\n-    store.register_late_pass(|| Box::new(assertions_on_constants::AssertionsOnConstants));\n-    store.register_late_pass(|| Box::new(assertions_on_result_states::AssertionsOnResultStates));\n-    store.register_late_pass(|| Box::new(inherent_to_string::InherentToString));\n+    store.register_late_pass(|_| Box::new(suspicious_trait_impl::SuspiciousImpl));\n+    store.register_late_pass(|_| Box::new(map_unit_fn::MapUnit));\n+    store.register_late_pass(|_| Box::new(inherent_impl::MultipleInherentImpl));\n+    store.register_late_pass(|_| Box::new(neg_cmp_op_on_partial_ord::NoNegCompOpForPartialOrd));\n+    store.register_late_pass(|_| Box::new(unwrap::Unwrap));\n+    store.register_late_pass(|_| Box::new(indexing_slicing::IndexingSlicing));\n+    store.register_late_pass(|_| Box::new(non_copy_const::NonCopyConst));\n+    store.register_late_pass(|_| Box::new(ptr_offset_with_cast::PtrOffsetWithCast));\n+    store.register_late_pass(|_| Box::new(redundant_clone::RedundantClone));\n+    store.register_late_pass(|_| Box::new(slow_vector_initialization::SlowVectorInit));\n+    store.register_late_pass(move |_| Box::new(unnecessary_wraps::UnnecessaryWraps::new(avoid_breaking_exported_api)));\n+    store.register_late_pass(|_| Box::new(assertions_on_constants::AssertionsOnConstants));\n+    store.register_late_pass(|_| Box::new(assertions_on_result_states::AssertionsOnResultStates));\n+    store.register_late_pass(|_| Box::new(inherent_to_string::InherentToString));\n     let max_trait_bounds = conf.max_trait_bounds;\n-    store.register_late_pass(move || Box::new(trait_bounds::TraitBounds::new(max_trait_bounds)));\n-    store.register_late_pass(|| Box::new(comparison_chain::ComparisonChain));\n-    store.register_late_pass(|| Box::new(mut_key::MutableKeyType));\n+    store.register_late_pass(move |_| Box::new(trait_bounds::TraitBounds::new(max_trait_bounds)));\n+    store.register_late_pass(|_| Box::new(comparison_chain::ComparisonChain));\n+    store.register_late_pass(|_| Box::new(mut_key::MutableKeyType));\n     store.register_early_pass(|| Box::new(reference::DerefAddrOf));\n     store.register_early_pass(|| Box::new(double_parens::DoubleParens));\n-    store.register_late_pass(|| Box::new(format_impl::FormatImpl::new()));\n+    store.register_late_pass(|_| Box::new(format_impl::FormatImpl::new()));\n     store.register_early_pass(|| Box::new(unsafe_removed_from_name::UnsafeNameRemoval));\n     store.register_early_pass(|| Box::new(else_if_without_else::ElseIfWithoutElse));\n     store.register_early_pass(|| Box::new(int_plus_one::IntPlusOne));\n     store.register_early_pass(|| Box::new(formatting::Formatting));\n     store.register_early_pass(|| Box::new(misc_early::MiscEarlyLints));\n     store.register_early_pass(|| Box::new(redundant_closure_call::RedundantClosureCall));\n-    store.register_late_pass(|| Box::new(redundant_closure_call::RedundantClosureCall));\n+    store.register_late_pass(|_| Box::new(redundant_closure_call::RedundantClosureCall));\n     store.register_early_pass(|| Box::new(unused_unit::UnusedUnit));\n-    store.register_late_pass(|| Box::new(returns::Return));\n+    store.register_late_pass(|_| Box::new(returns::Return));\n     store.register_early_pass(|| Box::new(collapsible_if::CollapsibleIf));\n     store.register_early_pass(|| Box::new(items_after_statements::ItemsAfterStatements));\n     store.register_early_pass(|| Box::new(precedence::Precedence));\n-    store.register_late_pass(|| Box::new(needless_parens_on_range_literals::NeedlessParensOnRangeLiterals));\n+    store.register_late_pass(|_| Box::new(needless_parens_on_range_literals::NeedlessParensOnRangeLiterals));\n     store.register_early_pass(|| Box::new(needless_continue::NeedlessContinue));\n     store.register_early_pass(|| Box::new(redundant_else::RedundantElse));\n-    store.register_late_pass(|| Box::new(create_dir::CreateDir));\n+    store.register_late_pass(|_| Box::new(create_dir::CreateDir));\n     store.register_early_pass(|| Box::new(needless_arbitrary_self_type::NeedlessArbitrarySelfType));\n     let literal_representation_lint_fraction_readability = conf.unreadable_literal_lint_fractions;\n     store.register_early_pass(move || {\n@@ -759,31 +759,31 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         ))\n     });\n     let enum_variant_name_threshold = conf.enum_variant_name_threshold;\n-    store.register_late_pass(move || {\n+    store.register_late_pass(move |_| {\n         Box::new(enum_variants::EnumVariantNames::new(\n             enum_variant_name_threshold,\n             avoid_breaking_exported_api,\n         ))\n     });\n     store.register_early_pass(|| Box::new(tabs_in_doc_comments::TabsInDocComments));\n     let upper_case_acronyms_aggressive = conf.upper_case_acronyms_aggressive;\n-    store.register_late_pass(move || {\n+    store.register_late_pass(move |_| {\n         Box::new(upper_case_acronyms::UpperCaseAcronyms::new(\n             avoid_breaking_exported_api,\n             upper_case_acronyms_aggressive,\n         ))\n     });\n-    store.register_late_pass(|| Box::new(default::Default::default()));\n-    store.register_late_pass(move || Box::new(unused_self::UnusedSelf::new(avoid_breaking_exported_api)));\n-    store.register_late_pass(|| Box::new(mutable_debug_assertion::DebugAssertWithMutCall));\n-    store.register_late_pass(|| Box::new(exit::Exit));\n-    store.register_late_pass(|| Box::new(to_digit_is_some::ToDigitIsSome));\n+    store.register_late_pass(|_| Box::new(default::Default::default()));\n+    store.register_late_pass(move |_| Box::new(unused_self::UnusedSelf::new(avoid_breaking_exported_api)));\n+    store.register_late_pass(|_| Box::new(mutable_debug_assertion::DebugAssertWithMutCall));\n+    store.register_late_pass(|_| Box::new(exit::Exit));\n+    store.register_late_pass(|_| Box::new(to_digit_is_some::ToDigitIsSome));\n     let array_size_threshold = conf.array_size_threshold;\n-    store.register_late_pass(move || Box::new(large_stack_arrays::LargeStackArrays::new(array_size_threshold)));\n-    store.register_late_pass(move || Box::new(large_const_arrays::LargeConstArrays::new(array_size_threshold)));\n-    store.register_late_pass(|| Box::new(floating_point_arithmetic::FloatingPointArithmetic));\n+    store.register_late_pass(move |_| Box::new(large_stack_arrays::LargeStackArrays::new(array_size_threshold)));\n+    store.register_late_pass(move |_| Box::new(large_const_arrays::LargeConstArrays::new(array_size_threshold)));\n+    store.register_late_pass(|_| Box::new(floating_point_arithmetic::FloatingPointArithmetic));\n     store.register_early_pass(|| Box::new(as_conversions::AsConversions));\n-    store.register_late_pass(|| Box::new(let_underscore::LetUnderscore));\n+    store.register_late_pass(|_| Box::new(let_underscore::LetUnderscore));\n     store.register_early_pass(|| Box::new(single_component_path_imports::SingleComponentPathImports));\n     let max_fn_params_bools = conf.max_fn_params_bools;\n     let max_struct_bools = conf.max_struct_bools;\n@@ -795,17 +795,17 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     });\n     store.register_early_pass(|| Box::new(option_env_unwrap::OptionEnvUnwrap));\n     let warn_on_all_wildcard_imports = conf.warn_on_all_wildcard_imports;\n-    store.register_late_pass(move || Box::new(wildcard_imports::WildcardImports::new(warn_on_all_wildcard_imports)));\n-    store.register_late_pass(|| Box::new(redundant_pub_crate::RedundantPubCrate::default()));\n-    store.register_late_pass(|| Box::new(unnamed_address::UnnamedAddress));\n-    store.register_late_pass(move || Box::new(dereference::Dereferencing::new(msrv)));\n-    store.register_late_pass(|| Box::new(option_if_let_else::OptionIfLetElse));\n-    store.register_late_pass(|| Box::new(future_not_send::FutureNotSend));\n-    store.register_late_pass(|| Box::new(if_let_mutex::IfLetMutex));\n-    store.register_late_pass(|| Box::new(if_not_else::IfNotElse));\n-    store.register_late_pass(|| Box::new(equatable_if_let::PatternEquality));\n-    store.register_late_pass(|| Box::new(manual_async_fn::ManualAsyncFn));\n-    store.register_late_pass(|| Box::new(panic_in_result_fn::PanicInResultFn));\n+    store.register_late_pass(move |_| Box::new(wildcard_imports::WildcardImports::new(warn_on_all_wildcard_imports)));\n+    store.register_late_pass(|_| Box::new(redundant_pub_crate::RedundantPubCrate::default()));\n+    store.register_late_pass(|_| Box::new(unnamed_address::UnnamedAddress));\n+    store.register_late_pass(move |_| Box::new(dereference::Dereferencing::new(msrv)));\n+    store.register_late_pass(|_| Box::new(option_if_let_else::OptionIfLetElse));\n+    store.register_late_pass(|_| Box::new(future_not_send::FutureNotSend));\n+    store.register_late_pass(|_| Box::new(if_let_mutex::IfLetMutex));\n+    store.register_late_pass(|_| Box::new(if_not_else::IfNotElse));\n+    store.register_late_pass(|_| Box::new(equatable_if_let::PatternEquality));\n+    store.register_late_pass(|_| Box::new(manual_async_fn::ManualAsyncFn));\n+    store.register_late_pass(|_| Box::new(panic_in_result_fn::PanicInResultFn));\n     let single_char_binding_names_threshold = conf.single_char_binding_names_threshold;\n     store.register_early_pass(move || {\n         Box::new(non_expressive_names::NonExpressiveNames {\n@@ -814,92 +814,92 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     });\n     let macro_matcher = conf.standard_macro_braces.iter().cloned().collect::<FxHashSet<_>>();\n     store.register_early_pass(move || Box::new(nonstandard_macro_braces::MacroBraces::new(&macro_matcher)));\n-    store.register_late_pass(|| Box::new(macro_use::MacroUseImports::default()));\n-    store.register_late_pass(|| Box::new(pattern_type_mismatch::PatternTypeMismatch));\n-    store.register_late_pass(|| Box::new(unwrap_in_result::UnwrapInResult));\n-    store.register_late_pass(|| Box::new(semicolon_if_nothing_returned::SemicolonIfNothingReturned));\n-    store.register_late_pass(|| Box::new(async_yields_async::AsyncYieldsAsync));\n+    store.register_late_pass(|_| Box::new(macro_use::MacroUseImports::default()));\n+    store.register_late_pass(|_| Box::new(pattern_type_mismatch::PatternTypeMismatch));\n+    store.register_late_pass(|_| Box::new(unwrap_in_result::UnwrapInResult));\n+    store.register_late_pass(|_| Box::new(semicolon_if_nothing_returned::SemicolonIfNothingReturned));\n+    store.register_late_pass(|_| Box::new(async_yields_async::AsyncYieldsAsync));\n     let disallowed_methods = conf.disallowed_methods.clone();\n-    store.register_late_pass(move || Box::new(disallowed_methods::DisallowedMethods::new(disallowed_methods.clone())));\n+    store.register_late_pass(move |_| Box::new(disallowed_methods::DisallowedMethods::new(disallowed_methods.clone())));\n     store.register_early_pass(|| Box::new(asm_syntax::InlineAsmX86AttSyntax));\n     store.register_early_pass(|| Box::new(asm_syntax::InlineAsmX86IntelSyntax));\n-    store.register_late_pass(|| Box::new(empty_drop::EmptyDrop));\n-    store.register_late_pass(|| Box::new(strings::StrToString));\n-    store.register_late_pass(|| Box::new(strings::StringToString));\n-    store.register_late_pass(|| Box::new(zero_sized_map_values::ZeroSizedMapValues));\n-    store.register_late_pass(|| Box::new(vec_init_then_push::VecInitThenPush::default()));\n-    store.register_late_pass(|| Box::new(redundant_slicing::RedundantSlicing));\n-    store.register_late_pass(|| Box::new(from_str_radix_10::FromStrRadix10));\n-    store.register_late_pass(move || Box::new(if_then_some_else_none::IfThenSomeElseNone::new(msrv)));\n-    store.register_late_pass(|| Box::new(bool_assert_comparison::BoolAssertComparison));\n+    store.register_late_pass(|_| Box::new(empty_drop::EmptyDrop));\n+    store.register_late_pass(|_| Box::new(strings::StrToString));\n+    store.register_late_pass(|_| Box::new(strings::StringToString));\n+    store.register_late_pass(|_| Box::new(zero_sized_map_values::ZeroSizedMapValues));\n+    store.register_late_pass(|_| Box::new(vec_init_then_push::VecInitThenPush::default()));\n+    store.register_late_pass(|_| Box::new(redundant_slicing::RedundantSlicing));\n+    store.register_late_pass(|_| Box::new(from_str_radix_10::FromStrRadix10));\n+    store.register_late_pass(move |_| Box::new(if_then_some_else_none::IfThenSomeElseNone::new(msrv)));\n+    store.register_late_pass(|_| Box::new(bool_assert_comparison::BoolAssertComparison));\n     store.register_early_pass(move || Box::new(module_style::ModStyle));\n-    store.register_late_pass(|| Box::new(unused_async::UnusedAsync));\n+    store.register_late_pass(|_| Box::new(unused_async::UnusedAsync));\n     let disallowed_types = conf.disallowed_types.clone();\n-    store.register_late_pass(move || Box::new(disallowed_types::DisallowedTypes::new(disallowed_types.clone())));\n+    store.register_late_pass(move |_| Box::new(disallowed_types::DisallowedTypes::new(disallowed_types.clone())));\n     let import_renames = conf.enforced_import_renames.clone();\n-    store.register_late_pass(move || {\n+    store.register_late_pass(move |_| {\n         Box::new(missing_enforced_import_rename::ImportRename::new(\n             import_renames.clone(),\n         ))\n     });\n     let scripts = conf.allowed_scripts.clone();\n     store.register_early_pass(move || Box::new(disallowed_script_idents::DisallowedScriptIdents::new(&scripts)));\n-    store.register_late_pass(|| Box::new(strlen_on_c_strings::StrlenOnCStrings));\n-    store.register_late_pass(move || Box::new(self_named_constructors::SelfNamedConstructors));\n-    store.register_late_pass(move || Box::new(iter_not_returning_iterator::IterNotReturningIterator));\n-    store.register_late_pass(move || Box::new(manual_assert::ManualAssert));\n+    store.register_late_pass(|_| Box::new(strlen_on_c_strings::StrlenOnCStrings));\n+    store.register_late_pass(move |_| Box::new(self_named_constructors::SelfNamedConstructors));\n+    store.register_late_pass(move |_| Box::new(iter_not_returning_iterator::IterNotReturningIterator));\n+    store.register_late_pass(move |_| Box::new(manual_assert::ManualAssert));\n     let enable_raw_pointer_heuristic_for_send = conf.enable_raw_pointer_heuristic_for_send;\n-    store.register_late_pass(move || {\n+    store.register_late_pass(move |_| {\n         Box::new(non_send_fields_in_send_ty::NonSendFieldInSendTy::new(\n             enable_raw_pointer_heuristic_for_send,\n         ))\n     });\n-    store.register_late_pass(move || Box::new(undocumented_unsafe_blocks::UndocumentedUnsafeBlocks));\n-    store.register_late_pass(move || Box::new(format_args::FormatArgs));\n-    store.register_late_pass(|| Box::new(trailing_empty_array::TrailingEmptyArray));\n+    store.register_late_pass(move |_| Box::new(undocumented_unsafe_blocks::UndocumentedUnsafeBlocks));\n+    store.register_late_pass(move |_| Box::new(format_args::FormatArgs));\n+    store.register_late_pass(|_| Box::new(trailing_empty_array::TrailingEmptyArray));\n     store.register_early_pass(|| Box::new(octal_escapes::OctalEscapes));\n-    store.register_late_pass(|| Box::new(needless_late_init::NeedlessLateInit));\n-    store.register_late_pass(|| Box::new(return_self_not_must_use::ReturnSelfNotMustUse));\n-    store.register_late_pass(|| Box::new(init_numbered_fields::NumberedFields));\n+    store.register_late_pass(|_| Box::new(needless_late_init::NeedlessLateInit));\n+    store.register_late_pass(|_| Box::new(return_self_not_must_use::ReturnSelfNotMustUse));\n+    store.register_late_pass(|_| Box::new(init_numbered_fields::NumberedFields));\n     store.register_early_pass(|| Box::new(single_char_lifetime_names::SingleCharLifetimeNames));\n-    store.register_late_pass(move || Box::new(manual_bits::ManualBits::new(msrv)));\n-    store.register_late_pass(|| Box::new(default_union_representation::DefaultUnionRepresentation));\n+    store.register_late_pass(move |_| Box::new(manual_bits::ManualBits::new(msrv)));\n+    store.register_late_pass(|_| Box::new(default_union_representation::DefaultUnionRepresentation));\n     store.register_early_pass(|| Box::new(doc_link_with_quotes::DocLinkWithQuotes));\n-    store.register_late_pass(|| Box::new(only_used_in_recursion::OnlyUsedInRecursion::default()));\n+    store.register_late_pass(|_| Box::new(only_used_in_recursion::OnlyUsedInRecursion::default()));\n     let allow_dbg_in_tests = conf.allow_dbg_in_tests;\n-    store.register_late_pass(move || Box::new(dbg_macro::DbgMacro::new(allow_dbg_in_tests)));\n+    store.register_late_pass(move |_| Box::new(dbg_macro::DbgMacro::new(allow_dbg_in_tests)));\n     let cargo_ignore_publish = conf.cargo_ignore_publish;\n-    store.register_late_pass(move || {\n+    store.register_late_pass(move |_| {\n         Box::new(cargo::Cargo {\n             ignore_publish: cargo_ignore_publish,\n         })\n     });\n     store.register_early_pass(|| Box::new(crate_in_macro_def::CrateInMacroDef));\n     store.register_early_pass(|| Box::new(empty_structs_with_brackets::EmptyStructsWithBrackets));\n-    store.register_late_pass(|| Box::new(unnecessary_owned_empty_strings::UnnecessaryOwnedEmptyStrings));\n+    store.register_late_pass(|_| Box::new(unnecessary_owned_empty_strings::UnnecessaryOwnedEmptyStrings));\n     store.register_early_pass(|| Box::new(pub_use::PubUse));\n-    store.register_late_pass(|| Box::new(format_push_string::FormatPushString));\n+    store.register_late_pass(|_| Box::new(format_push_string::FormatPushString));\n     let max_include_file_size = conf.max_include_file_size;\n-    store.register_late_pass(move || Box::new(large_include_file::LargeIncludeFile::new(max_include_file_size)));\n-    store.register_late_pass(|| Box::new(strings::TrimSplitWhitespace));\n-    store.register_late_pass(|| Box::new(rc_clone_in_vec_init::RcCloneInVecInit));\n+    store.register_late_pass(move |_| Box::new(large_include_file::LargeIncludeFile::new(max_include_file_size)));\n+    store.register_late_pass(|_| Box::new(strings::TrimSplitWhitespace));\n+    store.register_late_pass(|_| Box::new(rc_clone_in_vec_init::RcCloneInVecInit));\n     store.register_early_pass(|| Box::new(duplicate_mod::DuplicateMod::default()));\n     store.register_early_pass(|| Box::new(unused_rounding::UnusedRounding));\n     store.register_early_pass(move || Box::new(almost_complete_letter_range::AlmostCompleteLetterRange::new(msrv)));\n-    store.register_late_pass(|| Box::new(swap_ptr_to_ref::SwapPtrToRef));\n-    store.register_late_pass(|| Box::new(mismatching_type_param_order::TypeParamMismatch));\n-    store.register_late_pass(|| Box::new(read_zero_byte_vec::ReadZeroByteVec));\n-    store.register_late_pass(|| Box::new(default_instead_of_iter_empty::DefaultIterEmpty));\n-    store.register_late_pass(move || Box::new(manual_rem_euclid::ManualRemEuclid::new(msrv)));\n-    store.register_late_pass(move || Box::new(manual_retain::ManualRetain::new(msrv)));\n+    store.register_late_pass(|_| Box::new(swap_ptr_to_ref::SwapPtrToRef));\n+    store.register_late_pass(|_| Box::new(mismatching_type_param_order::TypeParamMismatch));\n+    store.register_late_pass(|_| Box::new(read_zero_byte_vec::ReadZeroByteVec));\n+    store.register_late_pass(|_| Box::new(default_instead_of_iter_empty::DefaultIterEmpty));\n+    store.register_late_pass(move |_| Box::new(manual_rem_euclid::ManualRemEuclid::new(msrv)));\n+    store.register_late_pass(move |_| Box::new(manual_retain::ManualRetain::new(msrv)));\n     let verbose_bit_mask_threshold = conf.verbose_bit_mask_threshold;\n-    store.register_late_pass(move || Box::new(operators::Operators::new(verbose_bit_mask_threshold)));\n-    store.register_late_pass(|| Box::new(invalid_utf8_in_unchecked::InvalidUtf8InUnchecked));\n-    store.register_late_pass(|| Box::new(std_instead_of_core::StdReexports::default()));\n-    store.register_late_pass(|| Box::new(manual_instant_elapsed::ManualInstantElapsed));\n-    store.register_late_pass(|| Box::new(partialeq_to_none::PartialeqToNone));\n-    store.register_late_pass(|| Box::new(manual_string_new::ManualStringNew));\n-    store.register_late_pass(|| Box::new(unused_peekable::UnusedPeekable));\n+    store.register_late_pass(move |_| Box::new(operators::Operators::new(verbose_bit_mask_threshold)));\n+    store.register_late_pass(|_| Box::new(invalid_utf8_in_unchecked::InvalidUtf8InUnchecked));\n+    store.register_late_pass(|_| Box::new(std_instead_of_core::StdReexports::default()));\n+    store.register_late_pass(|_| Box::new(manual_instant_elapsed::ManualInstantElapsed));\n+    store.register_late_pass(|_| Box::new(partialeq_to_none::PartialeqToNone));\n+    store.register_late_pass(|_| Box::new(manual_string_new::ManualStringNew));\n+    store.register_late_pass(|_| Box::new(unused_peekable::UnusedPeekable));\n     store.register_early_pass(|| Box::new(multi_assignments::MultiAssignments));\n     // add lints here, do not remove this comment, it's used in `new_lint`\n }"}]}