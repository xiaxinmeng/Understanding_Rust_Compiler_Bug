{"sha": "6c49da45441d29aadd5935dabbaa8dc09ebad33a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjNDlkYTQ1NDQxZDI5YWFkZDU5MzVkYWJiYWE4ZGMwOWViYWQzM2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-30T08:32:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-30T08:32:13Z"}, "message": "Auto merge of #59550 - Centril:rollup, r=Centril\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #59376 (RFC 2008: Enum Variants)\n - #59453 (Recover from parse error in tuple syntax)\n - #59455 (Account for short-hand field syntax when suggesting borrow)\n - #59499 (Fix broken download link in the armhf-gnu image)\n - #59512 (implement `AsRawFd` for stdio locks)\n - #59525 (Whitelist some rustc attrs)\n - #59528 (Improve the dbg! macro docs )\n - #59532 (In doc examples, don't ignore read/write results)\n - #59534 (rustdoc: collapse blanket impls in the same way as normal impls)\n - #59537 (Fix OnceWith docstring.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "e3d8f54b557abdf322de702d4757293149e687c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3d8f54b557abdf322de702d4757293149e687c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c49da45441d29aadd5935dabbaa8dc09ebad33a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c49da45441d29aadd5935dabbaa8dc09ebad33a", "html_url": "https://github.com/rust-lang/rust/commit/6c49da45441d29aadd5935dabbaa8dc09ebad33a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c49da45441d29aadd5935dabbaa8dc09ebad33a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "709b72e7a73cbb798b728fd84c384bd0ad8ebf6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/709b72e7a73cbb798b728fd84c384bd0ad8ebf6c", "html_url": "https://github.com/rust-lang/rust/commit/709b72e7a73cbb798b728fd84c384bd0ad8ebf6c"}, {"sha": "62a78c4fcfca82cbdcdd13a5298885bd21e5d4d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/62a78c4fcfca82cbdcdd13a5298885bd21e5d4d9", "html_url": "https://github.com/rust-lang/rust/commit/62a78c4fcfca82cbdcdd13a5298885bd21e5d4d9"}], "stats": {"total": 1003, "additions": 722, "deletions": 281}, "files": [{"sha": "e4c2097f970a9b9b6dd84295e96b8342b5f2f9f7", "filename": "src/ci/docker/armhf-gnu/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -71,7 +71,8 @@ COPY scripts/qemu-bare-bones-addentropy.c /tmp/addentropy.c\n RUN arm-linux-gnueabihf-gcc addentropy.c -o rootfs/addentropy -static\n \n # TODO: What is this?!\n-RUN curl -O http://ftp.nl.debian.org/debian/dists/jessie/main/installer-armhf/current/images/device-tree/vexpress-v2p-ca15-tc1.dtb\n+# Source of the file: https://github.com/vfdev-5/qemu-rpi2-vexpress/raw/master/vexpress-v2p-ca15-tc1.dtb\n+RUN curl -O https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/vexpress-v2p-ca15-tc1.dtb\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh"}, {"sha": "907147c17ef8e500260577c1c637d7260bc7bd5b", "filename": "src/doc/unstable-book/src/language-features/non-exhaustive.md", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnon-exhaustive.md", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnon-exhaustive.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnon-exhaustive.md?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -7,10 +7,12 @@ The tracking issue for this feature is: [#44109]\n ------------------------\n \n The `non_exhaustive` gate allows you to use the `#[non_exhaustive]` attribute\n-on structs and enums. When applied within a crate, users of the crate will need\n-to use the `_` pattern when matching enums and use the `..` pattern when\n-matching structs. Structs marked as `non_exhaustive` will not be able to be\n-created normally outside of the defining crate. This is demonstrated below:\n+on structs, enums and enum variants. When applied within a crate, users of the\n+crate will need to use the `_` pattern when matching enums and use the `..`\n+pattern when matching structs. Enum variants cannot be matched against.\n+Structs and enum variants marked as `non_exhaustive` will not be able to\n+be created normally outside of the defining crate. This is demonstrated\n+below:\n \n ```rust,ignore (pseudo-Rust)\n use std::error::Error as StdError;\n@@ -72,4 +74,3 @@ let config = Config { window_width: 640, window_height: 480 };\n // when marked non_exhaustive.\n let &Config { window_width, window_height, .. } = config;\n ```\n-"}, {"sha": "7934e5880d7d29fba1a5790ee1687abddfb23bc0", "filename": "src/libcore/iter/sources.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibcore%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibcore%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fsources.rs?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -375,8 +375,8 @@ pub fn once<T>(value: T) -> Once<T> {\n     Once { inner: Some(value).into_iter() }\n }\n \n-/// An iterator that repeats elements of type `A` endlessly by\n-/// applying the provided closure `F: FnMut() -> A`.\n+/// An iterator that yields a single element of type `A` by\n+/// applying the provided closure `F: FnOnce() -> A`.\n ///\n /// This `struct` is created by the [`once_with`] function.\n /// See its documentation for more."}, {"sha": "102057c1380ac6529bd1165d8836b38544b31301", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -1869,6 +1869,11 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n         if adt_kind == AdtKind::Struct && tcx.has_attr(parent_did, \"non_exhaustive\") {\n             debug!(\"found non-exhaustive field list for {:?}\", parent_did);\n             flags = flags | VariantFlags::IS_FIELD_LIST_NON_EXHAUSTIVE;\n+        } else if let Some(variant_did) = variant_did {\n+            if tcx.has_attr(variant_did, \"non_exhaustive\") {\n+                debug!(\"found non-exhaustive field list for {:?}\", variant_did);\n+                flags = flags | VariantFlags::IS_FIELD_LIST_NON_EXHAUSTIVE;\n+            }\n         }\n \n         VariantDef {\n@@ -2146,6 +2151,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n             debug!(\"found non-exhaustive variant list for {:?}\", did);\n             flags = flags | AdtFlags::IS_VARIANT_LIST_NON_EXHAUSTIVE;\n         }\n+\n         flags |= match kind {\n             AdtKind::Enum => AdtFlags::IS_ENUM,\n             AdtKind::Union => AdtFlags::IS_UNION,\n@@ -2299,21 +2305,25 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n             self.variants.iter().all(|v| v.fields.is_empty())\n     }\n \n+    /// Return a `VariantDef` given a variant id.\n     pub fn variant_with_id(&self, vid: DefId) -> &VariantDef {\n         self.variants.iter().find(|v| v.def_id == vid)\n             .expect(\"variant_with_id: unknown variant\")\n     }\n \n+    /// Return a `VariantDef` given a constructor id.\n     pub fn variant_with_ctor_id(&self, cid: DefId) -> &VariantDef {\n         self.variants.iter().find(|v| v.ctor_def_id == Some(cid))\n             .expect(\"variant_with_ctor_id: unknown variant\")\n     }\n \n+    /// Return the index of `VariantDef` given a variant id.\n     pub fn variant_index_with_id(&self, vid: DefId) -> VariantIdx {\n         self.variants.iter_enumerated().find(|(_, v)| v.def_id == vid)\n             .expect(\"variant_index_with_id: unknown variant\").0\n     }\n \n+    /// Return the index of `VariantDef` given a constructor id.\n     pub fn variant_index_with_ctor_id(&self, cid: DefId) -> VariantIdx {\n         self.variants.iter_enumerated().find(|(_, v)| v.ctor_def_id == Some(cid))\n             .expect(\"variant_index_with_ctor_id: unknown variant\").0\n@@ -2930,8 +2940,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    // Returns `ty::VariantDef` if `def` refers to a struct,\n-    // or variant or their constructors, panics otherwise.\n+    /// Returns `ty::VariantDef` if `def` refers to a struct,\n+    /// or variant or their constructors, panics otherwise.\n     pub fn expect_variant_def(self, def: Def) -> &'tcx VariantDef {\n         match def {\n             Def::Variant(did) => {"}, {"sha": "796d2f6a18ba3aefaa038adaf586ad9200eb35bb", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -643,13 +643,18 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             }\n         };\n \n-        // Variant constructors have the same visibility as the parent enums.\n+        // Variant constructors have the same visibility as the parent enums, unless marked as\n+        // non-exhaustive, in which case they are lowered to `pub(crate)`.\n         let enum_id = tcx.hir().as_local_hir_id(enum_did).unwrap();\n         let enum_vis = &tcx.hir().expect_item_by_hir_id(enum_id).vis;\n+        let mut ctor_vis = ty::Visibility::from_hir(enum_vis, enum_id, tcx);\n+        if variant.is_field_list_non_exhaustive() && ctor_vis == ty::Visibility::Public {\n+            ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n+        }\n \n         Entry {\n             kind: EntryKind::Variant(self.lazy(&data)),\n-            visibility: self.lazy(&ty::Visibility::from_hir(enum_vis, enum_id, tcx)),\n+            visibility: self.lazy(&ctor_vis),\n             span: self.lazy(&tcx.def_span(def_id)),\n             attributes: LazySeq::empty(),\n             children: LazySeq::empty(),"}, {"sha": "741264d1dbe184ee303b5d0cef9c27e97a3ce9e6", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -192,14 +192,6 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n-    fn invalid_non_exhaustive_attribute(&self, variant: &Variant) {\n-        let has_non_exhaustive = attr::contains_name(&variant.node.attrs, \"non_exhaustive\");\n-        if has_non_exhaustive {\n-            self.err_handler().span_err(variant.span,\n-                                        \"#[non_exhaustive] is not yet supported on variants\");\n-        }\n-    }\n-\n     fn invalid_visibility(&self, vis: &Visibility, note: Option<&str>) {\n         if let VisibilityKind::Inherited = vis.node {\n             return\n@@ -608,7 +600,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }\n             ItemKind::Enum(ref def, _) => {\n                 for variant in &def.variants {\n-                    self.invalid_non_exhaustive_attribute(variant);\n                     for field in variant.node.data.fields() {\n                         self.invalid_visibility(&field.vis, None);\n                     }"}, {"sha": "030883c0159fbe5368f3c2d43a45a35bb19bbb07", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -244,7 +244,26 @@ fn def_id_visibility<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                     match tcx.hir().get_by_hir_id(parent_hir_id) {\n                         Node::Variant(..) => {\n                             let parent_did = tcx.hir().local_def_id_from_hir_id(parent_hir_id);\n-                            return def_id_visibility(tcx, parent_did);\n+                            let (mut ctor_vis, mut span, mut descr) = def_id_visibility(\n+                                tcx, parent_did,\n+                            );\n+\n+                            let adt_def = tcx.adt_def(tcx.hir().get_parent_did_by_hir_id(hir_id));\n+                            let ctor_did = tcx.hir().local_def_id_from_hir_id(\n+                                vdata.ctor_hir_id().unwrap());\n+                            let variant = adt_def.variant_with_ctor_id(ctor_did);\n+\n+                            if variant.is_field_list_non_exhaustive() &&\n+                                ctor_vis == ty::Visibility::Public\n+                            {\n+                                ctor_vis = ty::Visibility::Restricted(\n+                                    DefId::local(CRATE_DEF_INDEX));\n+                                let attrs = tcx.get_attrs(variant.def_id);\n+                                span = attr::find_by_name(&attrs, \"non_exhaustive\").unwrap().span;\n+                                descr = \"crate-visible\";\n+                            }\n+\n+                            return (ctor_vis, span, descr);\n                         }\n                         Node::Item(..) => {\n                             let item = match tcx.hir().get_by_hir_id(parent_hir_id) {"}, {"sha": "7ce264db755db267c2e1d17e8eb013c7e7a8174c", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -588,6 +588,14 @@ impl<'a> Resolver<'a> {\n         let def = Def::Variant(def_id);\n         self.define(parent, ident, TypeNS, (def, vis, variant.span, expansion));\n \n+        // If the variant is marked as non_exhaustive then lower the visibility to within the\n+        // crate.\n+        let mut ctor_vis = vis;\n+        let has_non_exhaustive = attr::contains_name(&variant.node.attrs, \"non_exhaustive\");\n+        if has_non_exhaustive && vis == ty::Visibility::Public {\n+            ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n+        }\n+\n         // Define a constructor name in the value namespace.\n         // Braced variants, unlike structs, generate unusable names in\n         // value namespace, they are reserved for possible future use.\n@@ -597,7 +605,7 @@ impl<'a> Resolver<'a> {\n         let ctor_def_id = self.definitions.local_def_id(ctor_node_id);\n         let ctor_kind = CtorKind::from_ast(&variant.node.data);\n         let ctor_def = Def::Ctor(ctor_def_id, CtorOf::Variant, ctor_kind);\n-        self.define(parent, ident, ValueNS, (ctor_def, vis, variant.span, expansion));\n+        self.define(parent, ident, ValueNS, (ctor_def, ctor_vis, variant.span, expansion));\n     }\n \n     /// Constructs the reduced graph for one foreign item."}, {"sha": "8739147c621e6319d047cd4e5a1709f41f1757ea", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 55, "deletions": 16, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -270,6 +270,26 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         None\n     }\n \n+    fn is_hir_id_from_struct_pattern_shorthand_field(&self, hir_id: hir::HirId, sp: Span) -> bool {\n+        let cm = self.sess().source_map();\n+        let parent_id = self.tcx.hir().get_parent_node_by_hir_id(hir_id);\n+        if let Some(parent) = self.tcx.hir().find_by_hir_id(parent_id) {\n+            // Account for fields\n+            if let Node::Expr(hir::Expr {\n+                node: hir::ExprKind::Struct(_, fields, ..), ..\n+            }) = parent {\n+                if let Ok(src) = cm.span_to_snippet(sp) {\n+                    for field in fields {\n+                        if field.ident.as_str() == src.as_str() && field.is_shorthand {\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        false\n+    }\n+\n     /// This function is used to determine potential \"simple\" improvements or users' errors and\n     /// provide them useful help. For example:\n     ///\n@@ -299,6 +319,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             return None;\n         }\n \n+        let is_struct_pat_shorthand_field = self.is_hir_id_from_struct_pattern_shorthand_field(\n+            expr.hir_id,\n+            sp,\n+        );\n+\n         match (&expected.sty, &checked_ty.sty) {\n             (&ty::Ref(_, exp, _), &ty::Ref(_, check, _)) => match (&exp.sty, &check.sty) {\n                 (&ty::Str, &ty::Array(arr, _)) |\n@@ -337,12 +362,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // bar(&x); // error, expected &mut\n                 // ```\n                 let ref_ty = match mutability {\n-                    hir::Mutability::MutMutable => self.tcx.mk_mut_ref(\n-                                                       self.tcx.mk_region(ty::ReStatic),\n-                                                       checked_ty),\n-                    hir::Mutability::MutImmutable => self.tcx.mk_imm_ref(\n-                                                       self.tcx.mk_region(ty::ReStatic),\n-                                                       checked_ty),\n+                    hir::Mutability::MutMutable => {\n+                        self.tcx.mk_mut_ref(self.tcx.mk_region(ty::ReStatic), checked_ty)\n+                    }\n+                    hir::Mutability::MutImmutable => {\n+                        self.tcx.mk_imm_ref(self.tcx.mk_region(ty::ReStatic), checked_ty)\n+                    }\n                 };\n                 if self.can_coerce(ref_ty, expected) {\n                     if let Ok(src) = cm.span_to_snippet(sp) {\n@@ -363,14 +388,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         if let Some(sugg) = self.can_use_as_ref(expr) {\n                             return Some(sugg);\n                         }\n+                        let field_name = if is_struct_pat_shorthand_field {\n+                            format!(\"{}: \", sugg_expr)\n+                        } else {\n+                            String::new()\n+                        };\n                         return Some(match mutability {\n-                            hir::Mutability::MutMutable => {\n-                                (sp, \"consider mutably borrowing here\", format!(\"&mut {}\",\n-                                                                                sugg_expr))\n-                            }\n-                            hir::Mutability::MutImmutable => {\n-                                (sp, \"consider borrowing here\", format!(\"&{}\", sugg_expr))\n-                            }\n+                            hir::Mutability::MutMutable => (\n+                                sp,\n+                                \"consider mutably borrowing here\",\n+                                format!(\"{}&mut {}\", field_name, sugg_expr),\n+                            ),\n+                            hir::Mutability::MutImmutable => (\n+                                sp,\n+                                \"consider borrowing here\",\n+                                format!(\"{}&{}\", field_name, sugg_expr),\n+                            ),\n                         });\n                     }\n                 }\n@@ -411,12 +444,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                                       checked,\n                                                                       sp) {\n                                 // do not suggest if the span comes from a macro (#52783)\n-                                if let (Ok(code),\n-                                        true) = (cm.span_to_snippet(sp), sp == expr.span) {\n+                                if let (Ok(code), true) = (\n+                                    cm.span_to_snippet(sp),\n+                                    sp == expr.span,\n+                                ) {\n                                     return Some((\n                                         sp,\n                                         \"consider dereferencing the borrow\",\n-                                        format!(\"*{}\", code),\n+                                        if is_struct_pat_shorthand_field {\n+                                            format!(\"{}: *{}\", code, code)\n+                                        } else {\n+                                            format!(\"*{}\", code)\n+                                        },\n                                     ));\n                                 }\n                             }"}, {"sha": "22f24df450f462377f91ff9acd7d355f951fdaed", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -4341,11 +4341,12 @@ foo.method(); // Ok!\n \"##,\n \n E0638: r##\"\n-This error indicates that the struct or enum must be matched non-exhaustively\n-as it has been marked as `non_exhaustive`.\n+This error indicates that the struct, enum or enum variant must be matched\n+non-exhaustively as it has been marked as `non_exhaustive`.\n \n When applied within a crate, downstream users of the crate will need to use the\n `_` pattern when matching enums and use the `..` pattern when matching structs.\n+Downstream crates cannot match against non-exhaustive enum variants.\n \n For example, in the below example, since the enum is marked as\n `non_exhaustive`, it is required that downstream crates match non-exhaustively\n@@ -4390,10 +4391,10 @@ Similarly, for structs, match with `..` to avoid this error.\n \"##,\n \n E0639: r##\"\n-This error indicates that the struct or enum cannot be instantiated from\n-outside of the defining crate as it has been marked as `non_exhaustive` and as\n-such more fields/variants may be added in future that could cause adverse side\n-effects for this code.\n+This error indicates that the struct, enum or enum variant cannot be\n+instantiated from outside of the defining crate as it has been marked\n+as `non_exhaustive` and as such more fields/variants may be added in\n+future that could cause adverse side effects for this code.\n \n It is recommended that you look for a `new` function or equivalent in the\n crate's documentation."}, {"sha": "a403f0845ceef387b85efd016ee6e91a8171c35e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -421,6 +421,9 @@ impl Item {\n     pub fn is_enum(&self) -> bool {\n         self.type_() == ItemType::Enum\n     }\n+    pub fn is_variant(&self) -> bool {\n+        self.type_() == ItemType::Variant\n+    }\n     pub fn is_associated_type(&self) -> bool {\n         self.type_() == ItemType::AssociatedType\n     }"}, {"sha": "9220d2feed2d2d20e0824bbd91d627026793f846", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -2604,7 +2604,15 @@ fn document_non_exhaustive_header(item: &clean::Item) -> &str {\n fn document_non_exhaustive(w: &mut fmt::Formatter<'_>, item: &clean::Item) -> fmt::Result {\n     if item.is_non_exhaustive() {\n         write!(w, \"<div class='docblock non-exhaustive non-exhaustive-{}'>\", {\n-            if item.is_struct() { \"struct\" } else if item.is_enum() { \"enum\" } else { \"type\" }\n+            if item.is_struct() {\n+                \"struct\"\n+            } else if item.is_enum() {\n+                \"enum\"\n+            } else if item.is_variant() {\n+                \"variant\"\n+            } else {\n+                \"type\"\n+            }\n         })?;\n \n         if item.is_struct() {\n@@ -2617,6 +2625,10 @@ fn document_non_exhaustive(w: &mut fmt::Formatter<'_>, item: &clean::Item) -> fm\n             write!(w, \"Non-exhaustive enums could have additional variants added in future. \\\n                        Therefore, when matching against variants of non-exhaustive enums, an \\\n                        extra wildcard arm must be added to account for any future variants.\")?;\n+        } else if item.is_variant() {\n+            write!(w, \"Non-exhaustive enum variants could have additional fields added in future. \\\n+                       Therefore, non-exhaustive enum variants cannot be constructed in external \\\n+                       crates and cannot be matched against.\")?;\n         } else {\n             write!(w, \"This type will require a wildcard arm in any match statements or \\\n                        constructors.\")?;\n@@ -3679,6 +3691,7 @@ fn item_enum(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n             }\n             write!(w, \"</code></span>\")?;\n             document(w, cx, variant)?;\n+            document_non_exhaustive(w, variant)?;\n \n             use crate::clean::{Variant, VariantKind};\n             if let clean::VariantItem(Variant {"}, {"sha": "412029cf3765f63fcc44f1fb84a62a0df59f24a5", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -2071,6 +2071,14 @@ if (!DOMTokenList.prototype.remove) {\n                     collapser(e, collapse);\n                 });\n             }\n+\n+            var blanket_list = document.getElementById(\"blanket-implementations-list\");\n+\n+            if (blanket_list !== null) {\n+                onEachLazy(blanket_list.getElementsByClassName(\"collapse-toggle\"), function(e) {\n+                    collapser(e, collapse);\n+                });\n+            }\n         }\n     }\n \n@@ -2263,6 +2271,8 @@ if (!DOMTokenList.prototype.remove) {\n                     otherMessage += \"struct\";\n                 } else if (hasClass(e, \"non-exhaustive-enum\")) {\n                     otherMessage += \"enum\";\n+                } else if (hasClass(e, \"non-exhaustive-variant\")) {\n+                    otherMessage += \"enum variant\";\n                 } else if (hasClass(e, \"non-exhaustive-type\")) {\n                     otherMessage += \"type\";\n                 }\n@@ -2280,6 +2290,9 @@ if (!DOMTokenList.prototype.remove) {\n             if (hasClass(e, \"type-decl\") === true && showItemDeclarations === true) {\n                 collapseDocs(e.previousSibling.childNodes[0], \"toggle\");\n             }\n+            if (hasClass(e, \"non-exhaustive\") === true) {\n+                collapseDocs(e.previousSibling.childNodes[0], \"toggle\");\n+            }\n         }\n     }\n "}, {"sha": "14a16f3fc0f045dde8e1bf29b3e7895e6ac4d7d7", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -24,9 +24,9 @@\n //!     let mut buffer = [0; 10];\n //!\n //!     // read up to 10 bytes\n-//!     f.read(&mut buffer)?;\n+//!     let n = f.read(&mut buffer)?;\n //!\n-//!     println!(\"The bytes: {:?}\", buffer);\n+//!     println!(\"The bytes: {:?}\", &buffer[..n]);\n //!     Ok(())\n //! }\n //! ```\n@@ -56,9 +56,9 @@\n //!     f.seek(SeekFrom::End(-10))?;\n //!\n //!     // read up to 10 bytes\n-//!     f.read(&mut buffer)?;\n+//!     let n = f.read(&mut buffer)?;\n //!\n-//!     println!(\"The bytes: {:?}\", buffer);\n+//!     println!(\"The bytes: {:?}\", &buffer[..n]);\n //!     Ok(())\n //! }\n //! ```\n@@ -537,7 +537,9 @@ pub trait Read {\n     ///     let mut buffer = [0; 10];\n     ///\n     ///     // read up to 10 bytes\n-    ///     f.read(&mut buffer[..])?;\n+    ///     let n = f.read(&mut buffer[..])?;\n+    ///\n+    ///     println!(\"The bytes: {:?}\", &buffer[..n]);\n     ///     Ok(())\n     /// }\n     /// ```\n@@ -1062,12 +1064,23 @@ impl Initializer {\n /// use std::fs::File;\n ///\n /// fn main() -> std::io::Result<()> {\n+///     let data = b\"some bytes\";\n+///\n+///     let mut pos = 0;\n ///     let mut buffer = File::create(\"foo.txt\")?;\n ///\n-///     buffer.write(b\"some bytes\")?;\n+///     while pos < data.len() {\n+///         let bytes_written = buffer.write(&data[pos..])?;\n+///         pos += bytes_written;\n+///     }\n ///     Ok(())\n /// }\n /// ```\n+///\n+/// The trait also provides convenience methods like [`write_all`], which calls\n+/// `write` in a loop until its entire input has been written.\n+///\n+/// [`write_all`]: #method.write_all\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(spotlight)]\n pub trait Write {"}, {"sha": "0e0292277e19f5f19c1f37914703f62ff9df9ba9", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -233,10 +233,14 @@ macro_rules! eprintln {\n /// to give up ownership, you can instead borrow with `dbg!(&expr)`\n /// for some expression `expr`.\n ///\n+/// The `dbg!` macro works exactly the same in release builds.\n+/// This is useful when debugging issues that only occur in release\n+/// builds or when debugging in release mode is significantly faster.\n+///\n /// Note that the macro is intended as a debugging tool and therefore you\n /// should avoid having uses of it in version control for longer periods.\n /// Use cases involving debug output that should be added to version control\n-/// may be better served by macros such as `debug!` from the `log` crate.\n+/// are better served by macros such as [`debug!`][debug-log] from the [`log`][log] crate.\n ///\n /// # Stability\n ///\n@@ -311,6 +315,8 @@ macro_rules! eprintln {\n /// file and line whenever it's reached.\n ///\n /// [stderr]: https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)\n+/// [debug-log]: https://docs.rs/log/*/log/macro.debug.html\n+/// [log]: https://docs.rs/log/\n #[macro_export]\n #[stable(feature = \"dbg_macro\", since = \"1.32.0\")]\n macro_rules! dbg {"}, {"sha": "c21d216478fb7a2c8e3d8482fb2d2556cc742725", "filename": "src/libstd/sys/redox/ext/io.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fio.rs?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -115,6 +115,21 @@ impl AsRawFd for io::Stderr {\n     fn as_raw_fd(&self) -> RawFd { 2 }\n }\n \n+#[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n+impl<'a> AsRawFd for io::StdinLock<'a> {\n+    fn as_raw_fd(&self) -> RawFd { 0 }\n+}\n+\n+#[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n+impl<'a> AsRawFd for io::StdoutLock<'a> {\n+    fn as_raw_fd(&self) -> RawFd { 1 }\n+}\n+\n+#[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n+impl<'a> AsRawFd for io::StderrLock<'a> {\n+    fn as_raw_fd(&self) -> RawFd { 2 }\n+}\n+\n #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n impl FromRawFd for net::TcpStream {\n     unsafe fn from_raw_fd(fd: RawFd) -> net::TcpStream {"}, {"sha": "6bcc59495e3635511bd7d63bbf807d8ec44e8a33", "filename": "src/libstd/sys/unix/ext/io.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibstd%2Fsys%2Funix%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibstd%2Fsys%2Funix%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fio.rs?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -95,3 +95,18 @@ impl AsRawFd for io::Stdout {\n impl AsRawFd for io::Stderr {\n     fn as_raw_fd(&self) -> RawFd { libc::STDERR_FILENO }\n }\n+\n+#[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n+impl<'a> AsRawFd for io::StdinLock<'a> {\n+    fn as_raw_fd(&self) -> RawFd { libc::STDIN_FILENO }\n+}\n+\n+#[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n+impl<'a> AsRawFd for io::StdoutLock<'a> {\n+    fn as_raw_fd(&self) -> RawFd { libc::STDOUT_FILENO }\n+}\n+\n+#[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n+impl<'a> AsRawFd for io::StderrLock<'a> {\n+    fn as_raw_fd(&self) -> RawFd { libc::STDERR_FILENO }\n+}"}, {"sha": "ec47c2e9d5afd0153fbbc8bbfc777eb5f875b821", "filename": "src/libstd/sys/windows/ext/io.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fio.rs?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -83,6 +83,27 @@ impl AsRawHandle for io::Stderr {\n     }\n }\n \n+#[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n+impl<'a> AsRawHandle for io::StdinLock<'a> {\n+    fn as_raw_handle(&self) -> RawHandle {\n+        unsafe { c::GetStdHandle(c::STD_INPUT_HANDLE) as RawHandle }\n+    }\n+}\n+\n+#[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n+impl<'a> AsRawHandle for io::StdoutLock<'a> {\n+    fn as_raw_handle(&self) -> RawHandle {\n+        unsafe { c::GetStdHandle(c::STD_OUTPUT_HANDLE) as RawHandle }\n+    }\n+}\n+\n+#[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n+impl<'a> AsRawHandle for io::StderrLock<'a> {\n+    fn as_raw_handle(&self) -> RawHandle {\n+        unsafe { c::GetStdHandle(c::STD_ERROR_HANDLE) as RawHandle }\n+    }\n+}\n+\n #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n impl FromRawHandle for fs::File {\n     unsafe fn from_raw_handle(handle: RawHandle) -> fs::File {"}, {"sha": "dcb55fb572f33533a8f9cdf7975f2fa73d6ad6b3", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -906,7 +906,7 @@ pub const BUILTIN_ATTRIBUTES: &[(&str, AttributeType, AttributeTemplate, Attribu\n                                          not currently handle destructors.\",\n                                         cfg_fn!(thread_local))),\n \n-    (\"rustc_on_unimplemented\", Normal, template!(List:\n+    (\"rustc_on_unimplemented\", Whitelisted, template!(List:\n                           r#\"/*opt*/ message = \"...\", /*opt*/ label = \"...\", /*opt*/ note = \"...\"\"#,\n                           NameValueStr: \"message\"),\n                                              Gated(Stability::Unstable,\n@@ -962,6 +962,20 @@ pub const BUILTIN_ATTRIBUTES: &[(&str, AttributeType, AttributeTemplate, Attribu\n             is just used for rustc unit tests \\\n             and will never be stable\",\n            cfg_fn!(rustc_attrs))),\n+    (\"rustc_layout_scalar_valid_range_start\", Whitelisted, template!(List: \"value\"),\n+     Gated(Stability::Unstable,\n+           \"rustc_attrs\",\n+           \"the `#[rustc_layout_scalar_valid_range_start]` attribute \\\n+            is just used to enable niche optimizations in libcore \\\n+            and will never be stable\",\n+           cfg_fn!(rustc_attrs))),\n+    (\"rustc_layout_scalar_valid_range_end\", Whitelisted, template!(List: \"value\"),\n+     Gated(Stability::Unstable,\n+           \"rustc_attrs\",\n+           \"the `#[rustc_layout_scalar_valid_range_end]` attribute \\\n+            is just used to enable niche optimizations in libcore \\\n+            and will never be stable\",\n+           cfg_fn!(rustc_attrs))),\n     (\"rustc_regions\", Normal, template!(Word), Gated(Stability::Unstable,\n                                     \"rustc_attrs\",\n                                     \"the `#[rustc_regions]` attribute \\"}, {"sha": "ae8e57d54de31c67443b3a8c50517f1cfa3b0254", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 57, "deletions": 26, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -2626,7 +2626,13 @@ impl<'a> Parser<'a> {\n                 let mut trailing_comma = false;\n                 let mut recovered = false;\n                 while self.token != token::CloseDelim(token::Paren) {\n-                    es.push(self.parse_expr()?);\n+                    es.push(match self.parse_expr() {\n+                        Ok(es) => es,\n+                        Err(err) => {\n+                            // recover from parse error in tuple list\n+                            return Ok(self.recover_seq_parse_error(token::Paren, lo, Err(err)));\n+                        }\n+                    });\n                     recovered = self.expect_one_of(\n                         &[],\n                         &[token::Comma, token::CloseDelim(token::Paren)],\n@@ -3237,36 +3243,54 @@ impl<'a> Parser<'a> {\n             }\n             if self.expr_is_complete(&e) { break; }\n             match self.token {\n-              // expr(...)\n-              token::OpenDelim(token::Paren) => {\n-                let es = self.parse_unspanned_seq(\n-                    &token::OpenDelim(token::Paren),\n-                    &token::CloseDelim(token::Paren),\n-                    SeqSep::trailing_allowed(token::Comma),\n-                    |p| Ok(p.parse_expr()?)\n-                )?;\n-                hi = self.prev_span;\n-\n-                let nd = self.mk_call(e, es);\n-                e = self.mk_expr(lo.to(hi), nd, ThinVec::new());\n-              }\n+                // expr(...)\n+                token::OpenDelim(token::Paren) => {\n+                    let seq = self.parse_unspanned_seq(\n+                        &token::OpenDelim(token::Paren),\n+                        &token::CloseDelim(token::Paren),\n+                        SeqSep::trailing_allowed(token::Comma),\n+                        |p| Ok(p.parse_expr()?)\n+                    ).map(|es| {\n+                        let nd = self.mk_call(e, es);\n+                        let hi = self.prev_span;\n+                        self.mk_expr(lo.to(hi), nd, ThinVec::new())\n+                    });\n+                    e = self.recover_seq_parse_error(token::Paren, lo, seq);\n+                }\n \n-              // expr[...]\n-              // Could be either an index expression or a slicing expression.\n-              token::OpenDelim(token::Bracket) => {\n-                self.bump();\n-                let ix = self.parse_expr()?;\n-                hi = self.span;\n-                self.expect(&token::CloseDelim(token::Bracket))?;\n-                let index = self.mk_index(e, ix);\n-                e = self.mk_expr(lo.to(hi), index, ThinVec::new())\n-              }\n-              _ => return Ok(e)\n+                // expr[...]\n+                // Could be either an index expression or a slicing expression.\n+                token::OpenDelim(token::Bracket) => {\n+                    self.bump();\n+                    let ix = self.parse_expr()?;\n+                    hi = self.span;\n+                    self.expect(&token::CloseDelim(token::Bracket))?;\n+                    let index = self.mk_index(e, ix);\n+                    e = self.mk_expr(lo.to(hi), index, ThinVec::new())\n+                }\n+                _ => return Ok(e)\n             }\n         }\n         return Ok(e);\n     }\n \n+    fn recover_seq_parse_error(\n+        &mut self,\n+        delim: token::DelimToken,\n+        lo: Span,\n+        result: PResult<'a, P<Expr>>,\n+    ) -> P<Expr> {\n+        match result {\n+            Ok(x) => x,\n+            Err(mut err) => {\n+                err.emit();\n+                // recover from parse error\n+                self.consume_block(delim);\n+                self.mk_expr(lo.to(self.prev_span), ExprKind::Err, ThinVec::new())\n+            }\n+        }\n+    }\n+\n     crate fn process_potential_macro_variable(&mut self) {\n         let (token, span) = match self.token {\n             token::Dollar if self.span.ctxt() != syntax_pos::hygiene::SyntaxContext::empty() &&\n@@ -4253,7 +4277,14 @@ impl<'a> Parser<'a> {\n     // Trailing commas are significant because (p) and (p,) are different patterns.\n     fn parse_parenthesized_pat_list(&mut self) -> PResult<'a, (Vec<P<Pat>>, Option<usize>, bool)> {\n         self.expect(&token::OpenDelim(token::Paren))?;\n-        let result = self.parse_pat_list()?;\n+        let result = match self.parse_pat_list() {\n+            Ok(result) => result,\n+            Err(mut err) => { // recover from parse error in tuple pattern list\n+                err.emit();\n+                self.consume_block(token::Paren);\n+                return Ok((vec![], Some(0), false));\n+            }\n+        };\n         self.expect(&token::CloseDelim(token::Paren))?;\n         Ok(result)\n     }"}, {"sha": "3d16a1543f43a13a01853a1d08ddcc6a6ad41aca", "filename": "src/test/incremental/issue-59523-on-implemented-is-not-unused.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fincremental%2Fissue-59523-on-implemented-is-not-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fincremental%2Fissue-59523-on-implemented-is-not-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-59523-on-implemented-is-not-unused.rs?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -0,0 +1,27 @@\n+// We should not see the unused_attributes lint fire for\n+// rustc_on_unimplemented, but with this bug we are seeing it fire (on\n+// subsequent runs) if incremental compilation is enabled.\n+\n+// revisions: rpass1 rpass2\n+// compile-pass\n+\n+#![feature(on_unimplemented)]\n+#![deny(unused_attributes)]\n+\n+#[rustc_on_unimplemented = \"invalid\"]\n+trait Index<Idx: ?Sized> {\n+    type Output: ?Sized;\n+    fn index(&self, index: Idx) -> &Self::Output;\n+}\n+\n+#[rustc_on_unimplemented = \"a usize is required to index into a slice\"]\n+impl Index<usize> for [i32] {\n+    type Output = i32;\n+    fn index(&self, index: usize) -> &i32 {\n+        &self[index]\n+    }\n+}\n+\n+fn main() {\n+    Index::<usize>::index(&[1, 2, 3] as &[i32], 2);\n+}"}, {"sha": "e4802cba9b6d75241b1757a199959a784c4ed67f", "filename": "src/test/incremental/issue-59524-layout-scalar-valid-range-is-not-unused.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fincremental%2Fissue-59524-layout-scalar-valid-range-is-not-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fincremental%2Fissue-59524-layout-scalar-valid-range-is-not-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-59524-layout-scalar-valid-range-is-not-unused.rs?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -0,0 +1,19 @@\n+// We should not see the unused_attributes lint fire for\n+// rustc_layout_scalar_valid_range_start, but with this bug we are\n+// seeing it fire (on subsequent runs) if incremental compilation is\n+// enabled.\n+\n+// revisions: rpass1 rpass2\n+// compile-pass\n+\n+#![feature(rustc_attrs)]\n+#![deny(unused_attributes)]\n+\n+#[rustc_layout_scalar_valid_range_start(10)]\n+#[rustc_layout_scalar_valid_range_end(30)]\n+struct RestrictedRange(u32);\n+const OKAY_RANGE: RestrictedRange = unsafe { RestrictedRange(20) };\n+\n+fn main() {\n+    OKAY_RANGE.0;\n+}"}, {"sha": "b3e2fa2c6208e9b6ed04b3f76c70ea61d2f99a76", "filename": "src/test/run-pass/rfcs/rfc-2008-non-exhaustive/auxiliary/enums.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/709b72e7a73cbb798b728fd84c384bd0ad8ebf6c/src%2Ftest%2Frun-pass%2Frfcs%2Frfc-2008-non-exhaustive%2Fauxiliary%2Fenums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/709b72e7a73cbb798b728fd84c384bd0ad8ebf6c/src%2Ftest%2Frun-pass%2Frfcs%2Frfc-2008-non-exhaustive%2Fauxiliary%2Fenums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfcs%2Frfc-2008-non-exhaustive%2Fauxiliary%2Fenums.rs?ref=709b72e7a73cbb798b728fd84c384bd0ad8ebf6c", "patch": "@@ -1,10 +0,0 @@\n-// run-pass\n-#![crate_type = \"rlib\"]\n-#![feature(non_exhaustive)]\n-\n-#[non_exhaustive]\n-pub enum NonExhaustiveEnum {\n-    Unit,\n-    Tuple(u32),\n-    Struct { field: u32 }\n-}"}, {"sha": "08b14d0df940850ead6d6c78bdd7d9b93c9bddca", "filename": "src/test/run-pass/rfcs/rfc-2008-non-exhaustive/auxiliary/structs.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/709b72e7a73cbb798b728fd84c384bd0ad8ebf6c/src%2Ftest%2Frun-pass%2Frfcs%2Frfc-2008-non-exhaustive%2Fauxiliary%2Fstructs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/709b72e7a73cbb798b728fd84c384bd0ad8ebf6c/src%2Ftest%2Frun-pass%2Frfcs%2Frfc-2008-non-exhaustive%2Fauxiliary%2Fstructs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfcs%2Frfc-2008-non-exhaustive%2Fauxiliary%2Fstructs.rs?ref=709b72e7a73cbb798b728fd84c384bd0ad8ebf6c", "patch": "@@ -1,14 +0,0 @@\n-// run-pass\n-#![feature(non_exhaustive)]\n-\n-#[non_exhaustive]\n-pub struct NormalStruct {\n-    pub first_field: u16,\n-    pub second_field: u16,\n-}\n-\n-#[non_exhaustive]\n-pub struct UnitStruct;\n-\n-#[non_exhaustive]\n-pub struct TupleStruct (pub u16, pub u16);"}, {"sha": "56a73d8ab608896b1e4a98d475a975071354c9a4", "filename": "src/test/run-pass/rfcs/rfc-2008-non-exhaustive/auxiliary/variants.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/709b72e7a73cbb798b728fd84c384bd0ad8ebf6c/src%2Ftest%2Frun-pass%2Frfcs%2Frfc-2008-non-exhaustive%2Fauxiliary%2Fvariants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/709b72e7a73cbb798b728fd84c384bd0ad8ebf6c/src%2Ftest%2Frun-pass%2Frfcs%2Frfc-2008-non-exhaustive%2Fauxiliary%2Fvariants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfcs%2Frfc-2008-non-exhaustive%2Fauxiliary%2Fvariants.rs?ref=709b72e7a73cbb798b728fd84c384bd0ad8ebf6c", "patch": "@@ -1,9 +0,0 @@\n-// run-pass\n-#![crate_type = \"rlib\"]\n-#![feature(non_exhaustive)]\n-\n-pub enum NonExhaustiveVariants {\n-    #[non_exhaustive] Unit,\n-    #[non_exhaustive] Tuple(u32),\n-    #[non_exhaustive] Struct { field: u32 }\n-}"}, {"sha": "f7e9c5384961205e26619eca7ff5c643ea82cc73", "filename": "src/test/run-pass/rfcs/rfc-2008-non-exhaustive/enums.rs", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/709b72e7a73cbb798b728fd84c384bd0ad8ebf6c/src%2Ftest%2Frun-pass%2Frfcs%2Frfc-2008-non-exhaustive%2Fenums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/709b72e7a73cbb798b728fd84c384bd0ad8ebf6c/src%2Ftest%2Frun-pass%2Frfcs%2Frfc-2008-non-exhaustive%2Fenums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfcs%2Frfc-2008-non-exhaustive%2Fenums.rs?ref=709b72e7a73cbb798b728fd84c384bd0ad8ebf6c", "patch": "@@ -1,53 +0,0 @@\n-// run-pass\n-// aux-build:enums.rs\n-extern crate enums;\n-\n-// ignore-pretty issue #37199\n-\n-use enums::NonExhaustiveEnum;\n-\n-fn main() {\n-    let enum_unit = NonExhaustiveEnum::Unit;\n-\n-    match enum_unit {\n-        NonExhaustiveEnum::Unit => 1,\n-        NonExhaustiveEnum::Tuple(_) => 2,\n-        // This particular arm tests that a enum marked as non-exhaustive\n-        // will not error if its variants are matched exhaustively.\n-        NonExhaustiveEnum::Struct { field } => field,\n-        _ => 0 // no error with wildcard\n-    };\n-\n-    match enum_unit {\n-        _ => \"no error with only wildcard\"\n-    };\n-\n-\n-    // issue #53549 - check that variant constructors can still be called normally.\n-\n-    match NonExhaustiveEnum::Unit {\n-        NonExhaustiveEnum::Unit => {},\n-        _ => {}\n-    };\n-\n-    match NonExhaustiveEnum::Tuple(2) {\n-        NonExhaustiveEnum::Tuple(2) => {},\n-        _ => {}\n-    };\n-\n-    match (NonExhaustiveEnum::Unit {}) {\n-        NonExhaustiveEnum::Unit {} => {},\n-        _ => {}\n-    };\n-\n-    match (NonExhaustiveEnum::Tuple { 0: 2 }) {\n-        NonExhaustiveEnum::Tuple { 0: 2 } => {},\n-        _ => {}\n-    };\n-\n-    match (NonExhaustiveEnum::Struct { field: 2 }) {\n-        NonExhaustiveEnum::Struct { field: 2 } => {},\n-        _ => {}\n-    };\n-\n-}"}, {"sha": "3cd7234269e1d7c181f89f2622f856d238d675ee", "filename": "src/test/run-pass/rfcs/rfc-2008-non-exhaustive/structs.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/709b72e7a73cbb798b728fd84c384bd0ad8ebf6c/src%2Ftest%2Frun-pass%2Frfcs%2Frfc-2008-non-exhaustive%2Fstructs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/709b72e7a73cbb798b728fd84c384bd0ad8ebf6c/src%2Ftest%2Frun-pass%2Frfcs%2Frfc-2008-non-exhaustive%2Fstructs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfcs%2Frfc-2008-non-exhaustive%2Fstructs.rs?ref=709b72e7a73cbb798b728fd84c384bd0ad8ebf6c", "patch": "@@ -1,20 +0,0 @@\n-// run-pass\n-#![allow(dead_code)]\n-#![allow(unused_variables)]\n-// aux-build:structs.rs\n-extern crate structs;\n-\n-use structs::{NormalStruct, UnitStruct, TupleStruct};\n-\n-// We only test matching here as we cannot create non-exhaustive\n-// structs from another crate. ie. they'll never pass in run-pass tests.\n-\n-fn match_structs(ns: NormalStruct, ts: TupleStruct, us: UnitStruct) {\n-    let NormalStruct { first_field, second_field, .. } = ns;\n-\n-    let TupleStruct { 0: first, 1: second, .. } = ts;\n-\n-    let UnitStruct { .. } = us;\n-}\n-\n-fn main() { }"}, {"sha": "90b8219e2a3c0ebc1721405e07952874b5db47cc", "filename": "src/test/run-pass/rfcs/rfc-2008-non-exhaustive/variants.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/709b72e7a73cbb798b728fd84c384bd0ad8ebf6c/src%2Ftest%2Frun-pass%2Frfcs%2Frfc-2008-non-exhaustive%2Fvariants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/709b72e7a73cbb798b728fd84c384bd0ad8ebf6c/src%2Ftest%2Frun-pass%2Frfcs%2Frfc-2008-non-exhaustive%2Fvariants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfcs%2Frfc-2008-non-exhaustive%2Fvariants.rs?ref=709b72e7a73cbb798b728fd84c384bd0ad8ebf6c", "patch": "@@ -1,22 +0,0 @@\n-// run-pass\n-// aux-build:variants.rs\n-extern crate variants;\n-\n-use variants::NonExhaustiveVariants;\n-\n-/*\n- * The initial implementation of #[non_exhaustive] (RFC 2008) does not include support for\n- * variants. See issue #44109 and PR 45394.\n- */\n-// ignore-test\n-\n-fn main() {\n-    let variant_tuple = NonExhaustiveVariants::Tuple { 0: 340 };\n-    let variant_struct = NonExhaustiveVariants::Struct { field: 340 };\n-\n-    match variant_struct {\n-        NonExhaustiveVariants::Unit => \"\",\n-        NonExhaustiveVariants::Struct { field, .. } => \"\",\n-        NonExhaustiveVariants::Tuple(fe_tpl, ..) => \"\"\n-    };\n-}"}, {"sha": "580410aecf4f8b0180cd796ac14a4c43db952926", "filename": "src/test/ui/deref-suggestion.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Fderef-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Fderef-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderef-suggestion.rs?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -15,6 +15,14 @@ fn foo4(u: &u32) {\n     //~^ ERROR mismatched types\n }\n \n+struct S<'a> {\n+    u: &'a u32,\n+}\n+\n+struct R {\n+    i: u32,\n+}\n+\n fn main() {\n     let s = String::new();\n     let r_s = &s;\n@@ -27,4 +35,14 @@ fn main() {\n     foo4(&0);\n     assert_eq!(3i32, &3i32);\n     //~^ ERROR mismatched types\n+    let u = 3;\n+    let s = S { u };\n+    //~^ ERROR mismatched types\n+    let s = S { u: u };\n+    //~^ ERROR mismatched types\n+    let i = &4;\n+    let r = R { i };\n+    //~^ ERROR mismatched types\n+    let r = R { i: i };\n+    //~^ ERROR mismatched types\n }"}, {"sha": "9c49f541c9309b0c8ed4364cde7fd672b3a8e426", "filename": "src/test/ui/deref-suggestion.stderr", "status": "modified", "additions": 52, "deletions": 4, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Fderef-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Fderef-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderef-suggestion.stderr?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -23,7 +23,7 @@ LL |     foo3(u);\n               found type `&u32`\n \n error[E0308]: mismatched types\n-  --> $DIR/deref-suggestion.rs:22:9\n+  --> $DIR/deref-suggestion.rs:30:9\n    |\n LL |     foo(&\"aaa\".to_owned());\n    |         ^^^^^^^^^^^^^^^^^\n@@ -35,7 +35,7 @@ LL |     foo(&\"aaa\".to_owned());\n               found type `&std::string::String`\n \n error[E0308]: mismatched types\n-  --> $DIR/deref-suggestion.rs:24:9\n+  --> $DIR/deref-suggestion.rs:32:9\n    |\n LL |     foo(&mut \"aaa\".to_owned());\n    |         ^^^^^^^^^^^^^^^^^^^^^\n@@ -59,7 +59,7 @@ LL |     foo3(borrow!(0));\n               found type `&{integer}`\n \n error[E0308]: mismatched types\n-  --> $DIR/deref-suggestion.rs:28:5\n+  --> $DIR/deref-suggestion.rs:36:5\n    |\n LL |     assert_eq!(3i32, &3i32);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^ expected i32, found &i32\n@@ -68,6 +68,54 @@ LL |     assert_eq!(3i32, &3i32);\n               found type `&i32`\n    = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n-error: aborting due to 6 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/deref-suggestion.rs:39:17\n+   |\n+LL |     let s = S { u };\n+   |                 ^\n+   |                 |\n+   |                 expected &u32, found integer\n+   |                 help: consider borrowing here: `u: &u`\n+   |\n+   = note: expected type `&u32`\n+              found type `{integer}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/deref-suggestion.rs:41:20\n+   |\n+LL |     let s = S { u: u };\n+   |                    ^\n+   |                    |\n+   |                    expected &u32, found integer\n+   |                    help: consider borrowing here: `&u`\n+   |\n+   = note: expected type `&u32`\n+              found type `{integer}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/deref-suggestion.rs:44:17\n+   |\n+LL |     let r = R { i };\n+   |                 ^\n+   |                 |\n+   |                 expected u32, found &{integer}\n+   |                 help: consider dereferencing the borrow: `i: *i`\n+   |\n+   = note: expected type `u32`\n+              found type `&{integer}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/deref-suggestion.rs:46:20\n+   |\n+LL |     let r = R { i: i };\n+   |                    ^\n+   |                    |\n+   |                    expected u32, found &{integer}\n+   |                    help: consider dereferencing the borrow: `*i`\n+   |\n+   = note: expected type `u32`\n+              found type `&{integer}`\n+\n+error: aborting due to 10 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "928d217441ef2f2685477c731520b9db497dd78b", "filename": "src/test/ui/issues/issue-34334.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Fissues%2Fissue-34334.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Fissues%2Fissue-34334.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-34334.rs?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -1,4 +1,10 @@\n fn main () {\n-    let sr: Vec<(u32, _, _) = vec![]; //~ ERROR expected one of `,` or `>`, found `=`\n+    let sr: Vec<(u32, _, _) = vec![];\n+    //~^ ERROR expected one of `,` or `>`, found `=`\n+    //~| ERROR expected value, found struct `Vec`\n+    //~| ERROR mismatched types\n+    //~| ERROR invalid left-hand side expression\n+    //~| ERROR expected expression, found reserved identifier `_`\n     let sr2: Vec<(u32, _, _)> = sr.iter().map(|(faction, th_sender, th_receiver)| {}).collect();\n+    //~^ ERROR no method named `iter` found for type `()` in the current scope\n }"}, {"sha": "51ea0c6a908947dd55ee08bdbde177c33d9c5af8", "filename": "src/test/ui/issues/issue-34334.stderr", "status": "modified", "additions": 40, "deletions": 3, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Fissues%2Fissue-34334.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Fissues%2Fissue-34334.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-34334.stderr?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -1,10 +1,47 @@\n+error: expected expression, found reserved identifier `_`\n+  --> $DIR/issue-34334.rs:2:23\n+   |\n+LL |     let sr: Vec<(u32, _, _) = vec![];\n+   |                       ^ expected expression\n+\n error: expected one of `,` or `>`, found `=`\n   --> $DIR/issue-34334.rs:2:29\n    |\n LL |     let sr: Vec<(u32, _, _) = vec![];\n-   |         --                  ^ expected one of `,` or `>` here\n-   |         |\n+   |         ---                 ^ expected one of `,` or `>` here\n+   |         | |\n+   |         | help: use `=` if you meant to assign\n    |         while parsing the type for `sr`\n \n-error: aborting due to previous error\n+error[E0423]: expected value, found struct `Vec`\n+  --> $DIR/issue-34334.rs:2:13\n+   |\n+LL |     let sr: Vec<(u32, _, _) = vec![];\n+   |             ^^^ did you mean `Vec { /* fields */ }`?\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-34334.rs:2:31\n+   |\n+LL |     let sr: Vec<(u32, _, _) = vec![];\n+   |                               ^^^^^^ expected bool, found struct `std::vec::Vec`\n+   |\n+   = note: expected type `bool`\n+              found type `std::vec::Vec<_>`\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+error[E0070]: invalid left-hand side expression\n+  --> $DIR/issue-34334.rs:2:13\n+   |\n+LL |     let sr: Vec<(u32, _, _) = vec![];\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^ left-hand of expression not valid\n+\n+error[E0599]: no method named `iter` found for type `()` in the current scope\n+  --> $DIR/issue-34334.rs:8:36\n+   |\n+LL |     let sr2: Vec<(u32, _, _)> = sr.iter().map(|(faction, th_sender, th_receiver)| {}).collect();\n+   |                                    ^^^^\n+\n+error: aborting due to 6 previous errors\n \n+Some errors occurred: E0070, E0308, E0423, E0599.\n+For more information about an error, try `rustc --explain E0070`."}, {"sha": "0e49b547f7d0f08d0ce0b51f6fdff8bf00ca435e", "filename": "src/test/ui/parser/pat-tuple-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-1.rs?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n-    match 0 {\n+    match (0, 1) {\n         (, ..) => {} //~ ERROR expected pattern, found `,`\n     }\n }"}, {"sha": "d4f05a5eb523ee6053a2b4e3e7ff1d8b6bea8670", "filename": "src/test/ui/parser/pat-tuple-5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-5.rs?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n-    match 0 {\n+    match (0, 1) {\n         (pat ..) => {} //~ ERROR unexpected token: `)`\n     }\n }"}, {"sha": "35088fb3068824d10637e0bca92d49f4b2b2ad00", "filename": "src/test/ui/parser/recover-from-bad-variant.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Fparser%2Frecover-from-bad-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Fparser%2Frecover-from-bad-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-from-bad-variant.rs?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -0,0 +1,14 @@\n+enum Enum {\n+    Foo { a: usize, b: usize },\n+    Bar(usize, usize),\n+}\n+\n+fn main() {\n+    let x = Enum::Foo(a: 3, b: 4);\n+    //~^ ERROR expected type, found `3`\n+    match x {\n+        Enum::Foo(a, b) => {}\n+        //~^ ERROR expected tuple struct/variant, found struct variant `Enum::Foo`\n+        Enum::Bar(a, b) => {}\n+    }\n+}"}, {"sha": "1eba6d7d52877fa80ff1dc22e06aad06e3794433", "filename": "src/test/ui/parser/recover-from-bad-variant.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Fparser%2Frecover-from-bad-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Fparser%2Frecover-from-bad-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-from-bad-variant.stderr?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -0,0 +1,23 @@\n+error: expected type, found `3`\n+  --> $DIR/recover-from-bad-variant.rs:7:26\n+   |\n+LL |     let x = Enum::Foo(a: 3, b: 4);\n+   |                          ^ expecting a type here because of type ascription\n+   |\n+   = note: type ascription is a nightly-only feature that lets you annotate an expression with a type: `<expr>: <type>`\n+note: this expression expects an ascribed type after the colon\n+  --> $DIR/recover-from-bad-variant.rs:7:23\n+   |\n+LL |     let x = Enum::Foo(a: 3, b: 4);\n+   |                       ^\n+   = help: this might be indicative of a syntax error elsewhere\n+\n+error[E0532]: expected tuple struct/variant, found struct variant `Enum::Foo`\n+  --> $DIR/recover-from-bad-variant.rs:10:9\n+   |\n+LL |         Enum::Foo(a, b) => {}\n+   |         ^^^^^^^^^ did you mean `Enum::Foo { /* fields */ }`?\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0532`."}, {"sha": "488e8db6b878979e11f42b7c1866f4ae838875d8", "filename": "src/test/ui/parser/recover-tuple-pat.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Fparser%2Frecover-tuple-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Fparser%2Frecover-tuple-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-tuple-pat.rs?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -0,0 +1,12 @@\n+fn main() {\n+    let x = (1, 2, 3, 4);\n+    match x {\n+        (1, .., 4) => {}\n+        (1, .=., 4) => { let _: usize = \"\"; }\n+        //~^ ERROR expected pattern, found `.`\n+        //~| ERROR mismatched types\n+        (.=., 4) => {}\n+        //~^ ERROR expected pattern, found `.`\n+        (1, 2, 3, 4) => {}\n+    }\n+}"}, {"sha": "5919aa72355acd43ddea3cdcc5e90f10c1191d6c", "filename": "src/test/ui/parser/recover-tuple-pat.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Fparser%2Frecover-tuple-pat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Fparser%2Frecover-tuple-pat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-tuple-pat.stderr?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -0,0 +1,24 @@\n+error: expected pattern, found `.`\n+  --> $DIR/recover-tuple-pat.rs:5:13\n+   |\n+LL |         (1, .=., 4) => { let _: usize = \"\"; }\n+   |             ^ expected pattern\n+\n+error: expected pattern, found `.`\n+  --> $DIR/recover-tuple-pat.rs:8:10\n+   |\n+LL |         (.=., 4) => {}\n+   |          ^ expected pattern\n+\n+error[E0308]: mismatched types\n+  --> $DIR/recover-tuple-pat.rs:5:41\n+   |\n+LL |         (1, .=., 4) => { let _: usize = \"\"; }\n+   |                                         ^^ expected usize, found reference\n+   |\n+   = note: expected type `usize`\n+              found type `&'static str`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "59e2695dec6dcfcd406b78ee0b95795d0645ff1f", "filename": "src/test/ui/parser/recover-tuple.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Fparser%2Frecover-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Fparser%2Frecover-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-tuple.rs?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -0,0 +1,11 @@\n+fn main() {\n+    // no complaints about the tuple not matching the expected type\n+    let x: (usize, usize, usize) = (3, .=.);\n+    //~^ ERROR expected expression, found `.`\n+    // verify that the parser recovers:\n+    let y: usize = \"\"; //~ ERROR mismatched types\n+    // no complaints about the type\n+    foo(x);\n+}\n+\n+fn foo(_: (usize, usize, usize)) {}"}, {"sha": "4252fc1fd1e1b6cd7c9229a9c2e4defb60619404", "filename": "src/test/ui/parser/recover-tuple.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Fparser%2Frecover-tuple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Fparser%2Frecover-tuple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-tuple.stderr?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -0,0 +1,18 @@\n+error: expected expression, found `.`\n+  --> $DIR/recover-tuple.rs:3:40\n+   |\n+LL |     let x: (usize, usize, usize) = (3, .=.);\n+   |                                        ^ expected expression\n+\n+error[E0308]: mismatched types\n+  --> $DIR/recover-tuple.rs:6:20\n+   |\n+LL |     let y: usize = \"\";\n+   |                    ^^ expected usize, found reference\n+   |\n+   = note: expected type `usize`\n+              found type `&'static str`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "43f6497f7e71cfa2b7c59e8e81aacadd2431e31d", "filename": "src/test/ui/parser/trait-object-lifetime-parens.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Fparser%2Ftrait-object-lifetime-parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Fparser%2Ftrait-object-lifetime-parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ftrait-object-lifetime-parens.rs?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -6,7 +6,10 @@ fn f<'a, T: Trait + ('a)>() {} //~ ERROR parenthesized lifetime bounds are not s\n \n fn check<'a>() {\n     let _: Box<Trait + ('a)>; //~ ERROR parenthesized lifetime bounds are not supported\n-    let _: Box<('a) + Trait>; //~ ERROR expected type, found `'a`\n+    let _: Box<('a) + Trait>;\n+    //~^ ERROR expected type, found `'a`\n+    //~| ERROR expected `:`, found `)`\n+    //~| ERROR chained comparison operators require parentheses\n }\n \n fn main() {}"}, {"sha": "a31b7aea8fee6f9d0117aece4e62e45dfa6e2462", "filename": "src/test/ui/parser/trait-object-lifetime-parens.stderr", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Fparser%2Ftrait-object-lifetime-parens.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Fparser%2Ftrait-object-lifetime-parens.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ftrait-object-lifetime-parens.stderr?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -10,6 +10,21 @@ error: parenthesized lifetime bounds are not supported\n LL |     let _: Box<Trait + ('a)>;\n    |                        ^^^^ help: remove the parentheses\n \n+error: expected `:`, found `)`\n+  --> $DIR/trait-object-lifetime-parens.rs:9:19\n+   |\n+LL |     let _: Box<('a) + Trait>;\n+   |                   ^ expected `:`\n+\n+error: chained comparison operators require parentheses\n+  --> $DIR/trait-object-lifetime-parens.rs:9:15\n+   |\n+LL |     let _: Box<('a) + Trait>;\n+   |               ^^^^^^^^^^^^^^^\n+   |\n+   = help: use `::<...>` instead of `<...>` if you meant to specify type arguments\n+   = help: or use `(...)` if you meant to specify fn arguments\n+\n error: expected type, found `'a`\n   --> $DIR/trait-object-lifetime-parens.rs:9:17\n    |\n@@ -18,5 +33,5 @@ LL |     let _: Box<('a) + Trait>;\n    |         |\n    |         while parsing the type for `_`\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 5 previous errors\n "}, {"sha": "7423a970e2e3bd43ddf3efa6331ccf580283c819", "filename": "src/test/ui/rfc-2008-non-exhaustive/enum.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum.rs?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -12,4 +12,48 @@ fn main() {\n         NonExhaustiveEnum::Tuple(_) => \"second\",\n         NonExhaustiveEnum::Struct { .. } => \"third\"\n     };\n+\n+    // Everything below this is expected to compile successfully.\n+\n+    let enum_unit = NonExhaustiveEnum::Unit;\n+\n+    match enum_unit {\n+        NonExhaustiveEnum::Unit => 1,\n+        NonExhaustiveEnum::Tuple(_) => 2,\n+        // This particular arm tests that a enum marked as non-exhaustive\n+        // will not error if its variants are matched exhaustively.\n+        NonExhaustiveEnum::Struct { field } => field,\n+        _ => 0 // no error with wildcard\n+    };\n+\n+    match enum_unit {\n+        _ => \"no error with only wildcard\"\n+    };\n+\n+    // #53549: Check that variant constructors can still be called normally.\n+    match NonExhaustiveEnum::Unit {\n+        NonExhaustiveEnum::Unit => {},\n+        _ => {}\n+    };\n+\n+    match NonExhaustiveEnum::Tuple(2) {\n+        NonExhaustiveEnum::Tuple(2) => {},\n+        _ => {}\n+    };\n+\n+    match (NonExhaustiveEnum::Unit {}) {\n+        NonExhaustiveEnum::Unit {} => {},\n+        _ => {}\n+    };\n+\n+    match (NonExhaustiveEnum::Tuple { 0: 2 }) {\n+        NonExhaustiveEnum::Tuple { 0: 2 } => {},\n+        _ => {}\n+    };\n+\n+    match (NonExhaustiveEnum::Struct { field: 2 }) {\n+        NonExhaustiveEnum::Struct { field: 2 } => {},\n+        _ => {}\n+    };\n+\n }"}, {"sha": "a3626bf60b2609642497c6dc6f30898b4692e19d", "filename": "src/test/ui/rfc-2008-non-exhaustive/enum_same_crate.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate.rs?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -1,4 +1,5 @@\n // run-pass\n+\n #![feature(non_exhaustive)]\n \n #[non_exhaustive]", "previous_filename": "src/test/run-pass/rfcs/rfc-2008-non-exhaustive/enums_same_crate.rs"}, {"sha": "94ac588d24083d92a8ee1a0370f7e6d469d9bbbe", "filename": "src/test/ui/rfc-2008-non-exhaustive/struct.rs", "status": "renamed", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstruct.rs?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -35,3 +35,15 @@ fn main() {\n     let UnitStruct { } = us;\n     //~^ ERROR `..` required with struct marked as non-exhaustive\n }\n+\n+// Everything below this is expected to compile successfully.\n+\n+// We only test matching here as we cannot create non-exhaustive\n+// structs from another crate. ie. they'll never pass in run-pass tests.\n+fn match_structs(ns: NormalStruct, ts: TupleStruct, us: UnitStruct) {\n+    let NormalStruct { first_field, second_field, .. } = ns;\n+\n+    let TupleStruct { 0: first, 1: second, .. } = ts;\n+\n+    let UnitStruct { .. } = us;\n+}", "previous_filename": "src/test/ui/rfc-2008-non-exhaustive/structs.rs"}, {"sha": "ecfad88a825520c4923d4685d603baf45cc1b456", "filename": "src/test/ui/rfc-2008-non-exhaustive/struct.stderr", "status": "renamed", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstruct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstruct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstruct.stderr?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -1,29 +1,29 @@\n error[E0423]: expected function, found struct `TupleStruct`\n-  --> $DIR/structs.rs:20:14\n+  --> $DIR/struct.rs:20:14\n    |\n LL |     let ts = TupleStruct(640, 480);\n    |              ^^^^^^^^^^^ constructor is not visible here due to private fields\n \n error[E0423]: expected value, found struct `UnitStruct`\n-  --> $DIR/structs.rs:29:14\n+  --> $DIR/struct.rs:29:14\n    |\n LL |     let us = UnitStruct;\n    |              ^^^^^^^^^^ constructor is not visible here due to private fields\n \n error[E0603]: tuple struct `TupleStruct` is private\n-  --> $DIR/structs.rs:23:32\n+  --> $DIR/struct.rs:23:32\n    |\n LL |     let ts_explicit = structs::TupleStruct(640, 480);\n    |                                ^^^^^^^^^^^\n \n error[E0603]: unit struct `UnitStruct` is private\n-  --> $DIR/structs.rs:32:32\n+  --> $DIR/struct.rs:32:32\n    |\n LL |     let us_explicit = structs::UnitStruct;\n    |                                ^^^^^^^^^^\n \n error[E0639]: cannot create non-exhaustive struct using struct expression\n-  --> $DIR/structs.rs:7:14\n+  --> $DIR/struct.rs:7:14\n    |\n LL |       let fr = FunctionalRecord {\n    |  ______________^\n@@ -35,25 +35,25 @@ LL | |     };\n    | |_____^\n \n error[E0639]: cannot create non-exhaustive struct using struct expression\n-  --> $DIR/structs.rs:14:14\n+  --> $DIR/struct.rs:14:14\n    |\n LL |     let ns = NormalStruct { first_field: 640, second_field: 480 };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0638]: `..` required with struct marked as non-exhaustive\n-  --> $DIR/structs.rs:17:9\n+  --> $DIR/struct.rs:17:9\n    |\n LL |     let NormalStruct { first_field, second_field } = ns;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0638]: `..` required with struct marked as non-exhaustive\n-  --> $DIR/structs.rs:26:9\n+  --> $DIR/struct.rs:26:9\n    |\n LL |     let TupleStruct { 0: first_field, 1: second_field } = ts;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0638]: `..` required with struct marked as non-exhaustive\n-  --> $DIR/structs.rs:35:9\n+  --> $DIR/struct.rs:35:9\n    |\n LL |     let UnitStruct { } = us;\n    |         ^^^^^^^^^^^^^^", "previous_filename": "src/test/ui/rfc-2008-non-exhaustive/structs.stderr"}, {"sha": "2b1d7d9ac503015ba7d7f5ccf6a7103ed6931c75", "filename": "src/test/ui/rfc-2008-non-exhaustive/structs_same_crate.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstructs_same_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstructs_same_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstructs_same_crate.rs?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -1,4 +1,5 @@\n // run-pass\n+\n #![allow(unused_variables)]\n #![feature(non_exhaustive)]\n ", "previous_filename": "src/test/run-pass/rfcs/rfc-2008-non-exhaustive/structs_same_crate.rs"}, {"sha": "bc346aea51cfc33748d6cc1d80731ad3ab4754e8", "filename": "src/test/ui/rfc-2008-non-exhaustive/variant.rs", "status": "renamed", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fvariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fvariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fvariant.rs?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -1,26 +1,33 @@\n // aux-build:variants.rs\n+\n extern crate variants;\n \n use variants::NonExhaustiveVariants;\n \n-/*\n- * The initial implementation of #[non_exhaustive] (RFC 2008) does not include support for\n- * variants. See issue #44109 and PR 45394.\n- */\n-// ignore-test\n-\n fn main() {\n     let variant_struct = NonExhaustiveVariants::Struct { field: 640 };\n     //~^ ERROR cannot create non-exhaustive variant\n \n-    let variant_tuple = NonExhaustiveVariants::Tuple { 0: 640 };\n-    //~^ ERROR cannot create non-exhaustive variant\n+    let variant_tuple = NonExhaustiveVariants::Tuple(640);\n+    //~^ ERROR tuple variant `Tuple` is private [E0603]\n+\n+    let variant_unit = NonExhaustiveVariants::Unit;\n+    //~^ ERROR unit variant `Unit` is private [E0603]\n \n     match variant_struct {\n         NonExhaustiveVariants::Unit => \"\",\n+        //~^ ERROR unit variant `Unit` is private [E0603]\n         NonExhaustiveVariants::Tuple(fe_tpl) => \"\",\n-        //~^ ERROR `..` required with variant marked as non-exhaustive\n+        //~^ ERROR tuple variant `Tuple` is private [E0603]\n         NonExhaustiveVariants::Struct { field } => \"\"\n         //~^ ERROR `..` required with variant marked as non-exhaustive\n     };\n+\n+    if let NonExhaustiveVariants::Tuple(fe_tpl) = variant_struct {\n+        //~^ ERROR tuple variant `Tuple` is private [E0603]\n+    }\n+\n+    if let NonExhaustiveVariants::Struct { field } = variant_struct {\n+        //~^ ERROR `..` required with variant marked as non-exhaustive\n+    }\n }", "previous_filename": "src/test/ui/rfc-2008-non-exhaustive/variants.rs"}, {"sha": "edfca78915017858585c7ec7c59a49ae61e2fe60", "filename": "src/test/ui/rfc-2008-non-exhaustive/variant.stderr", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fvariant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fvariant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fvariant.stderr?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -0,0 +1,52 @@\n+error[E0603]: tuple variant `Tuple` is private\n+  --> $DIR/variant.rs:11:48\n+   |\n+LL |     let variant_tuple = NonExhaustiveVariants::Tuple(640);\n+   |                                                ^^^^^\n+\n+error[E0603]: unit variant `Unit` is private\n+  --> $DIR/variant.rs:14:47\n+   |\n+LL |     let variant_unit = NonExhaustiveVariants::Unit;\n+   |                                               ^^^^\n+\n+error[E0603]: unit variant `Unit` is private\n+  --> $DIR/variant.rs:18:32\n+   |\n+LL |         NonExhaustiveVariants::Unit => \"\",\n+   |                                ^^^^\n+\n+error[E0603]: tuple variant `Tuple` is private\n+  --> $DIR/variant.rs:20:32\n+   |\n+LL |         NonExhaustiveVariants::Tuple(fe_tpl) => \"\",\n+   |                                ^^^^^\n+\n+error[E0603]: tuple variant `Tuple` is private\n+  --> $DIR/variant.rs:26:35\n+   |\n+LL |     if let NonExhaustiveVariants::Tuple(fe_tpl) = variant_struct {\n+   |                                   ^^^^^\n+\n+error[E0639]: cannot create non-exhaustive variant using struct expression\n+  --> $DIR/variant.rs:8:26\n+   |\n+LL |     let variant_struct = NonExhaustiveVariants::Struct { field: 640 };\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0638]: `..` required with variant marked as non-exhaustive\n+  --> $DIR/variant.rs:22:9\n+   |\n+LL |         NonExhaustiveVariants::Struct { field } => \"\"\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0638]: `..` required with variant marked as non-exhaustive\n+  --> $DIR/variant.rs:30:12\n+   |\n+LL |     if let NonExhaustiveVariants::Struct { field } = variant_struct {\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 8 previous errors\n+\n+Some errors occurred: E0603, E0638, E0639.\n+For more information about an error, try `rustc --explain E0603`."}, {"sha": "9ed244144dff93fe1ba8e2654a716847cc1039fc", "filename": "src/test/ui/rfc-2008-non-exhaustive/variants_create.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/709b72e7a73cbb798b728fd84c384bd0ad8ebf6c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fvariants_create.rs", "raw_url": "https://github.com/rust-lang/rust/raw/709b72e7a73cbb798b728fd84c384bd0ad8ebf6c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fvariants_create.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fvariants_create.rs?ref=709b72e7a73cbb798b728fd84c384bd0ad8ebf6c", "patch": "@@ -1,17 +0,0 @@\n-#![feature(non_exhaustive)]\n-\n-/*\n- * The initial implementation of #[non_exhaustive] (RFC 2008) does not include support for\n- * variants. See issue #44109 and PR 45394.\n- */\n-\n-pub enum NonExhaustiveVariants {\n-    #[non_exhaustive] Unit,\n-    //~^ ERROR #[non_exhaustive] is not yet supported on variants\n-    #[non_exhaustive] Tuple(u32),\n-    //~^ ERROR #[non_exhaustive] is not yet supported on variants\n-    #[non_exhaustive] Struct { field: u32 }\n-    //~^ ERROR #[non_exhaustive] is not yet supported on variants\n-}\n-\n-fn main() { }"}, {"sha": "5b099d58ec467ef4b313ac3629127317d09e7163", "filename": "src/test/ui/rfc-2008-non-exhaustive/variants_create.stderr", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/709b72e7a73cbb798b728fd84c384bd0ad8ebf6c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fvariants_create.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/709b72e7a73cbb798b728fd84c384bd0ad8ebf6c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fvariants_create.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fvariants_create.stderr?ref=709b72e7a73cbb798b728fd84c384bd0ad8ebf6c", "patch": "@@ -1,20 +0,0 @@\n-error: #[non_exhaustive] is not yet supported on variants\n-  --> $DIR/variants_create.rs:9:23\n-   |\n-LL |     #[non_exhaustive] Unit,\n-   |                       ^^^^\n-\n-error: #[non_exhaustive] is not yet supported on variants\n-  --> $DIR/variants_create.rs:11:23\n-   |\n-LL |     #[non_exhaustive] Tuple(u32),\n-   |                       ^^^^^^^^^^\n-\n-error: #[non_exhaustive] is not yet supported on variants\n-  --> $DIR/variants_create.rs:13:23\n-   |\n-LL |     #[non_exhaustive] Struct { field: u32 }\n-   |                       ^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 3 previous errors\n-"}, {"sha": "470a5ea9833adafb95b7e566e94468277e25c623", "filename": "src/test/ui/rfc-2008-non-exhaustive/variants_same_crate.rs", "status": "renamed", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fvariants_same_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49da45441d29aadd5935dabbaa8dc09ebad33a/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fvariants_same_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fvariants_same_crate.rs?ref=6c49da45441d29aadd5935dabbaa8dc09ebad33a", "patch": "@@ -1,11 +1,6 @@\n // run-pass\n-#![feature(non_exhaustive)]\n \n-/*\n- * The initial implementation of #[non_exhaustive] (RFC 2008) does not include support for\n- * variants. See issue #44109 and PR 45394.\n- */\n-// ignore-test\n+#![feature(non_exhaustive)]\n \n pub enum NonExhaustiveVariants {\n     #[non_exhaustive] Unit,", "previous_filename": "src/test/run-pass/rfcs/rfc-2008-non-exhaustive/variants_same_crate.rs"}]}