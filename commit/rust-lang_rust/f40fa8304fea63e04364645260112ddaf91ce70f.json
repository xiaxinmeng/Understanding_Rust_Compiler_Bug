{"sha": "f40fa8304fea63e04364645260112ddaf91ce70f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0MGZhODMwNGZlYTYzZTA0MzY0NjQ1MjYwMTEyZGRhZjkxY2U3MGY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-11-26T17:44:33Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-11-27T00:49:36Z"}, "message": "rollup merge of #19288: steveklabnik/doc_style_cleanup\n\nThis is considered good convention.\n\nThis is about half of them in total, I just don't want an impossible to land patch. :smile:", "tree": {"sha": "d1809a9e7677512378a32cb89bed64602a789296", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1809a9e7677512378a32cb89bed64602a789296"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f40fa8304fea63e04364645260112ddaf91ce70f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f40fa8304fea63e04364645260112ddaf91ce70f", "html_url": "https://github.com/rust-lang/rust/commit/f40fa8304fea63e04364645260112ddaf91ce70f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f40fa8304fea63e04364645260112ddaf91ce70f/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34b98b306ad23ab895f701de1d009ff026a1d2b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/34b98b306ad23ab895f701de1d009ff026a1d2b1", "html_url": "https://github.com/rust-lang/rust/commit/34b98b306ad23ab895f701de1d009ff026a1d2b1"}, {"sha": "f38e4e6d97bf1691858d007afd36b1f356de4774", "url": "https://api.github.com/repos/rust-lang/rust/commits/f38e4e6d97bf1691858d007afd36b1f356de4774", "html_url": "https://github.com/rust-lang/rust/commit/f38e4e6d97bf1691858d007afd36b1f356de4774"}], "stats": {"total": 3019, "additions": 1361, "deletions": 1658}, "files": [{"sha": "d21465c822f4745875a2155b1d7920278dbf1cdc", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -42,27 +42,25 @@ impl<E:CLike+fmt::Show> fmt::Show for EnumSet<E> {\n     }\n }\n \n-/**\n-An interface for casting C-like enum to uint and back.\n-A typically implementation is as below.\n-\n-```{rust,ignore}\n-#[repr(uint)]\n-enum Foo {\n-    A, B, C\n-}\n-\n-impl CLike for Foo {\n-    fn to_uint(&self) -> uint {\n-        *self as uint\n-    }\n-\n-    fn from_uint(v: uint) -> Foo {\n-        unsafe { mem::transmute(v) }\n-    }\n-}\n-```\n-*/\n+/// An interface for casting C-like enum to uint and back.\n+/// A typically implementation is as below.\n+///\n+/// ```{rust,ignore}\n+/// #[repr(uint)]\n+/// enum Foo {\n+///     A, B, C\n+/// }\n+///\n+/// impl CLike for Foo {\n+///     fn to_uint(&self) -> uint {\n+///         *self as uint\n+///     }\n+///\n+///     fn from_uint(v: uint) -> Foo {\n+///         unsafe { mem::transmute(v) }\n+///     }\n+/// }\n+/// ```\n pub trait CLike {\n     /// Converts a C-like enum to a `uint`.\n     fn to_uint(&self) -> uint;"}, {"sha": "e1e409fbaeb72e2ee59041cb19199155780fb18a", "filename": "src/libcore/finally.rs", "status": "modified", "additions": 30, "deletions": 32, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibcore%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibcore%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffinally.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -58,38 +58,36 @@ impl<T> Finally<T> for fn() -> T {\n     }\n }\n \n-/**\n- * The most general form of the `finally` functions. The function\n- * `try_fn` will be invoked first; whether or not it panics, the\n- * function `finally_fn` will be invoked next. The two parameters\n- * `mutate` and `drop` are used to thread state through the two\n- * closures. `mutate` is used for any shared, mutable state that both\n- * closures require access to; `drop` is used for any state that the\n- * `try_fn` requires ownership of.\n- *\n- * **WARNING:** While shared, mutable state between the try and finally\n- * function is often necessary, one must be very careful; the `try`\n- * function could have panicked at any point, so the values of the shared\n- * state may be inconsistent.\n- *\n- * # Example\n- *\n- * ```\n- * use std::finally::try_finally;\n- *\n- * struct State<'a> { buffer: &'a mut [u8], len: uint }\n- * # let mut buf = [];\n- * let mut state = State { buffer: &mut buf, len: 0 };\n- * try_finally(\n- *     &mut state, (),\n- *     |state, ()| {\n- *         // use state.buffer, state.len\n- *     },\n- *     |state| {\n- *         // use state.buffer, state.len to cleanup\n- *     })\n- * ```\n- */\n+/// The most general form of the `finally` functions. The function\n+/// `try_fn` will be invoked first; whether or not it panics, the\n+/// function `finally_fn` will be invoked next. The two parameters\n+/// `mutate` and `drop` are used to thread state through the two\n+/// closures. `mutate` is used for any shared, mutable state that both\n+/// closures require access to; `drop` is used for any state that the\n+/// `try_fn` requires ownership of.\n+///\n+/// **WARNING:** While shared, mutable state between the try and finally\n+/// function is often necessary, one must be very careful; the `try`\n+/// function could have panicked at any point, so the values of the shared\n+/// state may be inconsistent.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::finally::try_finally;\n+///\n+/// struct State<'a> { buffer: &'a mut [u8], len: uint }\n+/// # let mut buf = [];\n+/// let mut state = State { buffer: &mut buf, len: 0 };\n+/// try_finally(\n+///     &mut state, (),\n+///     |state, ()| {\n+///         // use state.buffer, state.len\n+///     },\n+///     |state| {\n+///         // use state.buffer, state.len to cleanup\n+///     })\n+/// ```\n pub fn try_finally<T,U,R>(mutate: &mut T,\n                           drop: U,\n                           try_fn: |&mut T, U| -> R,"}, {"sha": "1e31df837794273f0ed9fd27b7ad7970671e27ec", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -54,36 +54,36 @@ pub enum SignFormat {\n \n static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n \n-/**\n- * Converts a number to its string representation as a byte vector.\n- * This is meant to be a common base implementation for all numeric string\n- * conversion functions like `to_string()` or `to_str_radix()`.\n- *\n- * # Arguments\n- * - `num`           - The number to convert. Accepts any number that\n- *                     implements the numeric traits.\n- * - `radix`         - Base to use. Accepts only the values 2-36. If the exponential notation\n- *                     is used, then this base is only used for the significand. The exponent\n- *                     itself always printed using a base of 10.\n- * - `negative_zero` - Whether to treat the special value `-0` as\n- *                     `-0` or as `+0`.\n- * - `sign`          - How to emit the sign. See `SignFormat`.\n- * - `digits`        - The amount of digits to use for emitting the fractional\n- *                     part, if any. See `SignificantDigits`.\n- * - `exp_format`   - Whether or not to use the exponential (scientific) notation.\n- *                    See `ExponentFormat`.\n- * - `exp_capital`   - Whether or not to use a capital letter for the exponent sign, if\n- *                     exponential notation is desired.\n- * - `f`             - A closure to invoke with the bytes representing the\n- *                     float.\n- *\n- * # Panics\n- * - Panics if `radix` < 2 or `radix` > 36.\n- * - Panics if `radix` > 14 and `exp_format` is `ExpDec` due to conflict\n- *   between digit and exponent sign `'e'`.\n- * - Panics if `radix` > 25 and `exp_format` is `ExpBin` due to conflict\n- *   between digit and exponent sign `'p'`.\n- */\n+/// Converts a number to its string representation as a byte vector.\n+/// This is meant to be a common base implementation for all numeric string\n+/// conversion functions like `to_string()` or `to_str_radix()`.\n+///\n+/// # Arguments\n+///\n+/// - `num`           - The number to convert. Accepts any number that\n+///                     implements the numeric traits.\n+/// - `radix`         - Base to use. Accepts only the values 2-36. If the exponential notation\n+///                     is used, then this base is only used for the significand. The exponent\n+///                     itself always printed using a base of 10.\n+/// - `negative_zero` - Whether to treat the special value `-0` as\n+///                     `-0` or as `+0`.\n+/// - `sign`          - How to emit the sign. See `SignFormat`.\n+/// - `digits`        - The amount of digits to use for emitting the fractional\n+///                     part, if any. See `SignificantDigits`.\n+/// - `exp_format`   - Whether or not to use the exponential (scientific) notation.\n+///                    See `ExponentFormat`.\n+/// - `exp_capital`   - Whether or not to use a capital letter for the exponent sign, if\n+///                     exponential notation is desired.\n+/// - `f`             - A closure to invoke with the bytes representing the\n+///                     float.\n+///\n+/// # Panics\n+///\n+/// - Panics if `radix` < 2 or `radix` > 36.\n+/// - Panics if `radix` > 14 and `exp_format` is `ExpDec` due to conflict\n+///   between digit and exponent sign `'e'`.\n+/// - Panics if `radix` > 25 and `exp_format` is `ExpBin` due to conflict\n+///   between digit and exponent sign `'p'`.\n pub fn float_to_str_bytes_common<T: Float, U>(\n     num: T,\n     radix: uint,"}, {"sha": "b2749ca054ad170cd9ba8453ba8e1816d3c68ad0", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 440, "deletions": 497, "changes": 937, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -57,60 +57,54 @@\n \n use kinds::Sized;\n \n-/**\n- *\n- * The `Drop` trait is used to run some code when a value goes out of scope. This\n- * is sometimes called a 'destructor'.\n- *\n- * # Example\n- *\n- * A trivial implementation of `Drop`. The `drop` method is called when `_x` goes\n- * out of scope, and therefore `main` prints `Dropping!`.\n- *\n- * ```rust\n- * struct HasDrop;\n- *\n- * impl Drop for HasDrop {\n- *   fn drop(&mut self) {\n- *       println!(\"Dropping!\");\n- *   }\n- * }\n- *\n- * fn main() {\n- *   let _x = HasDrop;\n- * }\n- * ```\n- */\n+/// The `Drop` trait is used to run some code when a value goes out of scope. This\n+/// is sometimes called a 'destructor'.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `Drop`. The `drop` method is called when `_x` goes\n+/// out of scope, and therefore `main` prints `Dropping!`.\n+///\n+/// ```rust\n+/// struct HasDrop;\n+///\n+/// impl Drop for HasDrop {\n+///   fn drop(&mut self) {\n+///       println!(\"Dropping!\");\n+///   }\n+/// }\n+///\n+/// fn main() {\n+///   let _x = HasDrop;\n+/// }\n+/// ```\n #[lang=\"drop\"]\n pub trait Drop {\n     /// The `drop` method, called when the value goes out of scope.\n     fn drop(&mut self);\n }\n \n-/**\n- *\n- * The `Add` trait is used to specify the functionality of `+`.\n- *\n- * # Example\n- *\n- * A trivial implementation of `Add`. When `Foo + Foo` happens, it ends up\n- * calling `add`, and therefore, `main` prints `Adding!`.\n- *\n- * ```rust\n- * struct Foo;\n- *\n- * impl Add<Foo, Foo> for Foo {\n- *     fn add(&self, _rhs: &Foo) -> Foo {\n- *       println!(\"Adding!\");\n- *       *self\n- *   }\n- * }\n- *\n- * fn main() {\n- *   Foo + Foo;\n- * }\n- * ```\n- */\n+/// The `Add` trait is used to specify the functionality of `+`.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `Add`. When `Foo + Foo` happens, it ends up\n+/// calling `add`, and therefore, `main` prints `Adding!`.\n+///\n+/// ```rust\n+/// struct Foo;\n+///\n+/// impl Add<Foo, Foo> for Foo {\n+///     fn add(&self, _rhs: &Foo) -> Foo {\n+///       println!(\"Adding!\");\n+///       *self\n+///   }\n+/// }\n+///\n+/// fn main() {\n+///   Foo + Foo;\n+/// }\n+/// ```\n #[lang=\"add\"]\n pub trait Add<Sized? RHS,Result> for Sized? {\n     /// The method for the `+` operator\n@@ -128,30 +122,27 @@ macro_rules! add_impl(\n \n add_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n \n-/**\n- *\n- * The `Sub` trait is used to specify the functionality of `-`.\n- *\n- * # Example\n- *\n- * A trivial implementation of `Sub`. When `Foo - Foo` happens, it ends up\n- * calling `sub`, and therefore, `main` prints `Subtracting!`.\n- *\n- * ```rust\n- * struct Foo;\n- *\n- * impl Sub<Foo, Foo> for Foo {\n- *     fn sub(&self, _rhs: &Foo) -> Foo {\n- *         println!(\"Subtracting!\");\n- *         *self\n- *     }\n- * }\n- *\n- * fn main() {\n- *     Foo - Foo;\n- * }\n- * ```\n- */\n+/// The `Sub` trait is used to specify the functionality of `-`.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `Sub`. When `Foo - Foo` happens, it ends up\n+/// calling `sub`, and therefore, `main` prints `Subtracting!`.\n+///\n+/// ```rust\n+/// struct Foo;\n+///\n+/// impl Sub<Foo, Foo> for Foo {\n+///     fn sub(&self, _rhs: &Foo) -> Foo {\n+///         println!(\"Subtracting!\");\n+///         *self\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     Foo - Foo;\n+/// }\n+/// ```\n #[lang=\"sub\"]\n pub trait Sub<Sized? RHS, Result> for Sized? {\n     /// The method for the `-` operator\n@@ -169,30 +160,27 @@ macro_rules! sub_impl(\n \n sub_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n \n-/**\n- *\n- * The `Mul` trait is used to specify the functionality of `*`.\n- *\n- * # Example\n- *\n- * A trivial implementation of `Mul`. When `Foo * Foo` happens, it ends up\n- * calling `mul`, and therefore, `main` prints `Multiplying!`.\n- *\n- * ```rust\n- * struct Foo;\n- *\n- * impl Mul<Foo, Foo> for Foo {\n- *     fn mul(&self, _rhs: &Foo) -> Foo {\n- *         println!(\"Multiplying!\");\n- *         *self\n- *     }\n- * }\n- *\n- * fn main() {\n- *     Foo * Foo;\n- * }\n- * ```\n- */\n+/// The `Mul` trait is used to specify the functionality of `*`.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `Mul`. When `Foo * Foo` happens, it ends up\n+/// calling `mul`, and therefore, `main` prints `Multiplying!`.\n+///\n+/// ```rust\n+/// struct Foo;\n+///\n+/// impl Mul<Foo, Foo> for Foo {\n+///     fn mul(&self, _rhs: &Foo) -> Foo {\n+///         println!(\"Multiplying!\");\n+///         *self\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     Foo * Foo;\n+/// }\n+/// ```\n #[lang=\"mul\"]\n pub trait Mul<Sized? RHS, Result>  for Sized? {\n     /// The method for the `*` operator\n@@ -210,30 +198,27 @@ macro_rules! mul_impl(\n \n mul_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n \n-/**\n- *\n- * The `Div` trait is used to specify the functionality of `/`.\n- *\n- * # Example\n- *\n- * A trivial implementation of `Div`. When `Foo / Foo` happens, it ends up\n- * calling `div`, and therefore, `main` prints `Dividing!`.\n- *\n- * ```\n- * struct Foo;\n- *\n- * impl Div<Foo, Foo> for Foo {\n- *     fn div(&self, _rhs: &Foo) -> Foo {\n- *         println!(\"Dividing!\");\n- *         *self\n- *     }\n- * }\n- *\n- * fn main() {\n- *     Foo / Foo;\n- * }\n- * ```\n- */\n+/// The `Div` trait is used to specify the functionality of `/`.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `Div`. When `Foo / Foo` happens, it ends up\n+/// calling `div`, and therefore, `main` prints `Dividing!`.\n+///\n+/// ```\n+/// struct Foo;\n+///\n+/// impl Div<Foo, Foo> for Foo {\n+///     fn div(&self, _rhs: &Foo) -> Foo {\n+///         println!(\"Dividing!\");\n+///         *self\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     Foo / Foo;\n+/// }\n+/// ```\n #[lang=\"div\"]\n pub trait Div<Sized? RHS, Result> for Sized? {\n     /// The method for the `/` operator\n@@ -251,30 +236,27 @@ macro_rules! div_impl(\n \n div_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n \n-/**\n- *\n- * The `Rem` trait is used to specify the functionality of `%`.\n- *\n- * # Example\n- *\n- * A trivial implementation of `Rem`. When `Foo % Foo` happens, it ends up\n- * calling `rem`, and therefore, `main` prints `Remainder-ing!`.\n- *\n- * ```\n- * struct Foo;\n- *\n- * impl Rem<Foo, Foo> for Foo {\n- *     fn rem(&self, _rhs: &Foo) -> Foo {\n- *         println!(\"Remainder-ing!\");\n- *         *self\n- *     }\n- * }\n- *\n- * fn main() {\n- *     Foo % Foo;\n- * }\n- * ```\n- */\n+/// The `Rem` trait is used to specify the functionality of `%`.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `Rem`. When `Foo % Foo` happens, it ends up\n+/// calling `rem`, and therefore, `main` prints `Remainder-ing!`.\n+///\n+/// ```\n+/// struct Foo;\n+///\n+/// impl Rem<Foo, Foo> for Foo {\n+///     fn rem(&self, _rhs: &Foo) -> Foo {\n+///         println!(\"Remainder-ing!\");\n+///         *self\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     Foo % Foo;\n+/// }\n+/// ```\n #[lang=\"rem\"]\n pub trait Rem<Sized? RHS, Result>  for Sized? {\n     /// The method for the `%` operator\n@@ -306,30 +288,27 @@ rem_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64)\n rem_float_impl!(f32, fmodf)\n rem_float_impl!(f64, fmod)\n \n-/**\n- *\n- * The `Neg` trait is used to specify the functionality of unary `-`.\n- *\n- * # Example\n- *\n- * A trivial implementation of `Neg`. When `-Foo` happens, it ends up calling\n- * `neg`, and therefore, `main` prints `Negating!`.\n- *\n- * ```\n- * struct Foo;\n- *\n- * impl Neg<Foo> for Foo {\n- *     fn neg(&self) -> Foo {\n- *         println!(\"Negating!\");\n- *         *self\n- *     }\n- * }\n- *\n- * fn main() {\n- *     -Foo;\n- * }\n- * ```\n- */\n+/// The `Neg` trait is used to specify the functionality of unary `-`.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `Neg`. When `-Foo` happens, it ends up calling\n+/// `neg`, and therefore, `main` prints `Negating!`.\n+///\n+/// ```\n+/// struct Foo;\n+///\n+/// impl Neg<Foo> for Foo {\n+///     fn neg(&self) -> Foo {\n+///         println!(\"Negating!\");\n+///         *self\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     -Foo;\n+/// }\n+/// ```\n #[lang=\"neg\"]\n pub trait Neg<Result> for Sized? {\n     /// The method for the unary `-` operator\n@@ -363,30 +342,27 @@ neg_uint_impl!(u32, i32)\n neg_uint_impl!(u64, i64)\n \n \n-/**\n- *\n- * The `Not` trait is used to specify the functionality of unary `!`.\n- *\n- * # Example\n- *\n- * A trivial implementation of `Not`. When `!Foo` happens, it ends up calling\n- * `not`, and therefore, `main` prints `Not-ing!`.\n- *\n- * ```\n- * struct Foo;\n- *\n- * impl Not<Foo> for Foo {\n- *     fn not(&self) -> Foo {\n- *         println!(\"Not-ing!\");\n- *         *self\n- *     }\n- * }\n- *\n- * fn main() {\n- *     !Foo;\n- * }\n- * ```\n- */\n+/// The `Not` trait is used to specify the functionality of unary `!`.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `Not`. When `!Foo` happens, it ends up calling\n+/// `not`, and therefore, `main` prints `Not-ing!`.\n+///\n+/// ```\n+/// struct Foo;\n+///\n+/// impl Not<Foo> for Foo {\n+///     fn not(&self) -> Foo {\n+///         println!(\"Not-ing!\");\n+///         *self\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     !Foo;\n+/// }\n+/// ```\n #[lang=\"not\"]\n pub trait Not<Result> for Sized? {\n     /// The method for the unary `!` operator\n@@ -405,30 +381,27 @@ macro_rules! not_impl(\n \n not_impl!(bool uint u8 u16 u32 u64 int i8 i16 i32 i64)\n \n-/**\n- *\n- * The `BitAnd` trait is used to specify the functionality of `&`.\n- *\n- * # Example\n- *\n- * A trivial implementation of `BitAnd`. When `Foo & Foo` happens, it ends up\n- * calling `bitand`, and therefore, `main` prints `Bitwise And-ing!`.\n- *\n- * ```\n- * struct Foo;\n- *\n- * impl BitAnd<Foo, Foo> for Foo {\n- *     fn bitand(&self, _rhs: &Foo) -> Foo {\n- *         println!(\"Bitwise And-ing!\");\n- *         *self\n- *     }\n- * }\n- *\n- * fn main() {\n- *     Foo & Foo;\n- * }\n- * ```\n- */\n+/// The `BitAnd` trait is used to specify the functionality of `&`.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `BitAnd`. When `Foo & Foo` happens, it ends up\n+/// calling `bitand`, and therefore, `main` prints `Bitwise And-ing!`.\n+///\n+/// ```\n+/// struct Foo;\n+///\n+/// impl BitAnd<Foo, Foo> for Foo {\n+///     fn bitand(&self, _rhs: &Foo) -> Foo {\n+///         println!(\"Bitwise And-ing!\");\n+///         *self\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     Foo & Foo;\n+/// }\n+/// ```\n #[lang=\"bitand\"]\n pub trait BitAnd<Sized? RHS, Result> for Sized? {\n     /// The method for the `&` operator\n@@ -446,30 +419,27 @@ macro_rules! bitand_impl(\n \n bitand_impl!(bool uint u8 u16 u32 u64 int i8 i16 i32 i64)\n \n-/**\n- *\n- * The `BitOr` trait is used to specify the functionality of `|`.\n- *\n- * # Example\n- *\n- * A trivial implementation of `BitOr`. When `Foo | Foo` happens, it ends up\n- * calling `bitor`, and therefore, `main` prints `Bitwise Or-ing!`.\n- *\n- * ```\n- * struct Foo;\n- *\n- * impl BitOr<Foo, Foo> for Foo {\n- *     fn bitor(&self, _rhs: &Foo) -> Foo {\n- *         println!(\"Bitwise Or-ing!\");\n- *         *self\n- *     }\n- * }\n- *\n- * fn main() {\n- *     Foo | Foo;\n- * }\n- * ```\n- */\n+/// The `BitOr` trait is used to specify the functionality of `|`.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `BitOr`. When `Foo | Foo` happens, it ends up\n+/// calling `bitor`, and therefore, `main` prints `Bitwise Or-ing!`.\n+///\n+/// ```\n+/// struct Foo;\n+///\n+/// impl BitOr<Foo, Foo> for Foo {\n+///     fn bitor(&self, _rhs: &Foo) -> Foo {\n+///         println!(\"Bitwise Or-ing!\");\n+///         *self\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     Foo | Foo;\n+/// }\n+/// ```\n #[lang=\"bitor\"]\n pub trait BitOr<Sized? RHS, Result> for Sized? {\n     /// The method for the `|` operator\n@@ -487,30 +457,27 @@ macro_rules! bitor_impl(\n \n bitor_impl!(bool uint u8 u16 u32 u64 int i8 i16 i32 i64)\n \n-/**\n- *\n- * The `BitXor` trait is used to specify the functionality of `^`.\n- *\n- * # Example\n- *\n- * A trivial implementation of `BitXor`. When `Foo ^ Foo` happens, it ends up\n- * calling `bitxor`, and therefore, `main` prints `Bitwise Xor-ing!`.\n- *\n- * ```\n- * struct Foo;\n- *\n- * impl BitXor<Foo, Foo> for Foo {\n- *     fn bitxor(&self, _rhs: &Foo) -> Foo {\n- *         println!(\"Bitwise Xor-ing!\");\n- *         *self\n- *     }\n- * }\n- *\n- * fn main() {\n- *     Foo ^ Foo;\n- * }\n- * ```\n- */\n+/// The `BitXor` trait is used to specify the functionality of `^`.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `BitXor`. When `Foo ^ Foo` happens, it ends up\n+/// calling `bitxor`, and therefore, `main` prints `Bitwise Xor-ing!`.\n+///\n+/// ```\n+/// struct Foo;\n+///\n+/// impl BitXor<Foo, Foo> for Foo {\n+///     fn bitxor(&self, _rhs: &Foo) -> Foo {\n+///         println!(\"Bitwise Xor-ing!\");\n+///         *self\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     Foo ^ Foo;\n+/// }\n+/// ```\n #[lang=\"bitxor\"]\n pub trait BitXor<Sized? RHS, Result> for Sized? {\n     /// The method for the `^` operator\n@@ -528,30 +495,27 @@ macro_rules! bitxor_impl(\n \n bitxor_impl!(bool uint u8 u16 u32 u64 int i8 i16 i32 i64)\n \n-/**\n- *\n- * The `Shl` trait is used to specify the functionality of `<<`.\n- *\n- * # Example\n- *\n- * A trivial implementation of `Shl`. When `Foo << Foo` happens, it ends up\n- * calling `shl`, and therefore, `main` prints `Shifting left!`.\n- *\n- * ```\n- * struct Foo;\n- *\n- * impl Shl<Foo, Foo> for Foo {\n- *     fn shl(&self, _rhs: &Foo) -> Foo {\n- *         println!(\"Shifting left!\");\n- *         *self\n- *     }\n- * }\n- *\n- * fn main() {\n- *     Foo << Foo;\n- * }\n- * ```\n- */\n+/// The `Shl` trait is used to specify the functionality of `<<`.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `Shl`. When `Foo << Foo` happens, it ends up\n+/// calling `shl`, and therefore, `main` prints `Shifting left!`.\n+///\n+/// ```\n+/// struct Foo;\n+///\n+/// impl Shl<Foo, Foo> for Foo {\n+///     fn shl(&self, _rhs: &Foo) -> Foo {\n+///         println!(\"Shifting left!\");\n+///         *self\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     Foo << Foo;\n+/// }\n+/// ```\n #[lang=\"shl\"]\n pub trait Shl<Sized? RHS, Result> for Sized? {\n     /// The method for the `<<` operator\n@@ -571,30 +535,27 @@ macro_rules! shl_impl(\n \n shl_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64)\n \n-/**\n- *\n- * The `Shr` trait is used to specify the functionality of `>>`.\n- *\n- * # Example\n- *\n- * A trivial implementation of `Shr`. When `Foo >> Foo` happens, it ends up\n- * calling `shr`, and therefore, `main` prints `Shifting right!`.\n- *\n- * ```\n- * struct Foo;\n- *\n- * impl Shr<Foo, Foo> for Foo {\n- *     fn shr(&self, _rhs: &Foo) -> Foo {\n- *         println!(\"Shifting right!\");\n- *         *self\n- *     }\n- * }\n- *\n- * fn main() {\n- *     Foo >> Foo;\n- * }\n- * ```\n- */\n+/// The `Shr` trait is used to specify the functionality of `>>`.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `Shr`. When `Foo >> Foo` happens, it ends up\n+/// calling `shr`, and therefore, `main` prints `Shifting right!`.\n+///\n+/// ```\n+/// struct Foo;\n+///\n+/// impl Shr<Foo, Foo> for Foo {\n+///     fn shr(&self, _rhs: &Foo) -> Foo {\n+///         println!(\"Shifting right!\");\n+///         *self\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     Foo >> Foo;\n+/// }\n+/// ```\n #[lang=\"shr\"]\n pub trait Shr<Sized? RHS, Result> for Sized? {\n     /// The method for the `>>` operator\n@@ -612,105 +573,96 @@ macro_rules! shr_impl(\n \n shr_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64)\n \n-/**\n- *\n- * The `Index` trait is used to specify the functionality of indexing operations\n- * like `arr[idx]` when used in an immutable context.\n- *\n- * # Example\n- *\n- * A trivial implementation of `Index`. When `Foo[Foo]` happens, it ends up\n- * calling `index`, and therefore, `main` prints `Indexing!`.\n- *\n- * ```\n- * struct Foo;\n- *\n- * impl Index<Foo, Foo> for Foo {\n- *     fn index<'a>(&'a self, _index: &Foo) -> &'a Foo {\n- *         println!(\"Indexing!\");\n- *         self\n- *     }\n- * }\n- *\n- * fn main() {\n- *     Foo[Foo];\n- * }\n- * ```\n- */\n+/// The `Index` trait is used to specify the functionality of indexing operations\n+/// like `arr[idx]` when used in an immutable context.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `Index`. When `Foo[Foo]` happens, it ends up\n+/// calling `index`, and therefore, `main` prints `Indexing!`.\n+///\n+/// ```\n+/// struct Foo;\n+///\n+/// impl Index<Foo, Foo> for Foo {\n+///     fn index<'a>(&'a self, _index: &Foo) -> &'a Foo {\n+///         println!(\"Indexing!\");\n+///         self\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     Foo[Foo];\n+/// }\n+/// ```\n #[lang=\"index\"]\n pub trait Index<Sized? Index, Sized? Result> for Sized? {\n     /// The method for the indexing (`Foo[Bar]`) operation\n     fn index<'a>(&'a self, index: &Index) -> &'a Result;\n }\n \n-/**\n- *\n- * The `IndexMut` trait is used to specify the functionality of indexing\n- * operations like `arr[idx]`, when used in a mutable context.\n- *\n- * # Example\n- *\n- * A trivial implementation of `IndexMut`. When `Foo[Foo]` happens, it ends up\n- * calling `index_mut`, and therefore, `main` prints `Indexing!`.\n- *\n- * ```\n- * struct Foo;\n- *\n- * impl IndexMut<Foo, Foo> for Foo {\n- *     fn index_mut<'a>(&'a mut self, _index: &Foo) -> &'a mut Foo {\n- *         println!(\"Indexing!\");\n- *         self\n- *     }\n- * }\n- *\n- * fn main() {\n- *     &mut Foo[Foo];\n- * }\n- * ```\n- */\n+/// The `IndexMut` trait is used to specify the functionality of indexing\n+/// operations like `arr[idx]`, when used in a mutable context.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `IndexMut`. When `Foo[Foo]` happens, it ends up\n+/// calling `index_mut`, and therefore, `main` prints `Indexing!`.\n+///\n+/// ```\n+/// struct Foo;\n+///\n+/// impl IndexMut<Foo, Foo> for Foo {\n+///     fn index_mut<'a>(&'a mut self, _index: &Foo) -> &'a mut Foo {\n+///         println!(\"Indexing!\");\n+///         self\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     &mut Foo[Foo];\n+/// }\n+/// ```\n #[lang=\"index_mut\"]\n pub trait IndexMut<Sized? Index, Sized? Result> for Sized? {\n     /// The method for the indexing (`Foo[Bar]`) operation\n     fn index_mut<'a>(&'a mut self, index: &Index) -> &'a mut Result;\n }\n \n-/**\n- *\n- * The `Slice` trait is used to specify the functionality of slicing operations\n- * like `arr[from..to]` when used in an immutable context.\n- *\n- * # Example\n- *\n- * A trivial implementation of `Slice`. When `Foo[..Foo]` happens, it ends up\n- * calling `slice_to`, and therefore, `main` prints `Slicing!`.\n- *\n- * ```ignore\n- * struct Foo;\n- *\n- * impl Slice<Foo, Foo> for Foo {\n- *     fn as_slice_<'a>(&'a self) -> &'a Foo {\n- *         println!(\"Slicing!\");\n- *         self\n- *     }\n- *     fn slice_from_or_fail<'a>(&'a self, _from: &Foo) -> &'a Foo {\n- *         println!(\"Slicing!\");\n- *         self\n- *     }\n- *     fn slice_to_or_fail<'a>(&'a self, _to: &Foo) -> &'a Foo {\n- *         println!(\"Slicing!\");\n- *         self\n- *     }\n- *     fn slice_or_fail<'a>(&'a self, _from: &Foo, _to: &Foo) -> &'a Foo {\n- *         println!(\"Slicing!\");\n- *         self\n- *     }\n- * }\n- *\n- * fn main() {\n- *     Foo[..Foo];\n- * }\n- * ```\n- */\n+/// The `Slice` trait is used to specify the functionality of slicing operations\n+/// like `arr[from..to]` when used in an immutable context.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `Slice`. When `Foo[..Foo]` happens, it ends up\n+/// calling `slice_to`, and therefore, `main` prints `Slicing!`.\n+///\n+/// ```ignore\n+/// struct Foo;\n+///\n+/// impl Slice<Foo, Foo> for Foo {\n+///     fn as_slice_<'a>(&'a self) -> &'a Foo {\n+///         println!(\"Slicing!\");\n+///         self\n+///     }\n+///     fn slice_from_or_fail<'a>(&'a self, _from: &Foo) -> &'a Foo {\n+///         println!(\"Slicing!\");\n+///         self\n+///     }\n+///     fn slice_to_or_fail<'a>(&'a self, _to: &Foo) -> &'a Foo {\n+///         println!(\"Slicing!\");\n+///         self\n+///     }\n+///     fn slice_or_fail<'a>(&'a self, _from: &Foo, _to: &Foo) -> &'a Foo {\n+///         println!(\"Slicing!\");\n+///         self\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     Foo[..Foo];\n+/// }\n+/// ```\n #[lang=\"slice\"]\n pub trait Slice<Sized? Idx, Sized? Result> for Sized? {\n     /// The method for the slicing operation foo[]\n@@ -723,43 +675,40 @@ pub trait Slice<Sized? Idx, Sized? Result> for Sized? {\n     fn slice_or_fail<'a>(&'a self, from: &Idx, to: &Idx) -> &'a Result;\n }\n \n-/**\n- *\n- * The `SliceMut` trait is used to specify the functionality of slicing\n- * operations like `arr[from..to]`, when used in a mutable context.\n- *\n- * # Example\n- *\n- * A trivial implementation of `SliceMut`. When `Foo[Foo..]` happens, it ends up\n- * calling `slice_from_mut`, and therefore, `main` prints `Slicing!`.\n- *\n- * ```ignore\n- * struct Foo;\n- *\n- * impl SliceMut<Foo, Foo> for Foo {\n- *     fn as_mut_slice_<'a>(&'a mut self) -> &'a mut Foo {\n- *         println!(\"Slicing!\");\n- *         self\n- *     }\n- *     fn slice_from_or_fail_mut<'a>(&'a mut self, _from: &Foo) -> &'a mut Foo {\n- *         println!(\"Slicing!\");\n- *         self\n- *     }\n- *     fn slice_to_or_fail_mut<'a>(&'a mut self, _to: &Foo) -> &'a mut Foo {\n- *         println!(\"Slicing!\");\n- *         self\n- *     }\n- *     fn slice_or_fail_mut<'a>(&'a mut self, _from: &Foo, _to: &Foo) -> &'a mut Foo {\n- *         println!(\"Slicing!\");\n- *         self\n- *     }\n- * }\n- *\n- * pub fn main() {\n- *     Foo[mut Foo..];\n- * }\n- * ```\n- */\n+/// The `SliceMut` trait is used to specify the functionality of slicing\n+/// operations like `arr[from..to]`, when used in a mutable context.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `SliceMut`. When `Foo[Foo..]` happens, it ends up\n+/// calling `slice_from_mut`, and therefore, `main` prints `Slicing!`.\n+///\n+/// ```ignore\n+/// struct Foo;\n+///\n+/// impl SliceMut<Foo, Foo> for Foo {\n+///     fn as_mut_slice_<'a>(&'a mut self) -> &'a mut Foo {\n+///         println!(\"Slicing!\");\n+///         self\n+///     }\n+///     fn slice_from_or_fail_mut<'a>(&'a mut self, _from: &Foo) -> &'a mut Foo {\n+///         println!(\"Slicing!\");\n+///         self\n+///     }\n+///     fn slice_to_or_fail_mut<'a>(&'a mut self, _to: &Foo) -> &'a mut Foo {\n+///         println!(\"Slicing!\");\n+///         self\n+///     }\n+///     fn slice_or_fail_mut<'a>(&'a mut self, _from: &Foo, _to: &Foo) -> &'a mut Foo {\n+///         println!(\"Slicing!\");\n+///         self\n+///     }\n+/// }\n+///\n+/// pub fn main() {\n+///     Foo[mut Foo..];\n+/// }\n+/// ```\n #[lang=\"slice_mut\"]\n pub trait SliceMut<Sized? Idx, Sized? Result> for Sized? {\n     /// The method for the slicing operation foo[]\n@@ -772,33 +721,30 @@ pub trait SliceMut<Sized? Idx, Sized? Result> for Sized? {\n     fn slice_or_fail_mut<'a>(&'a mut self, from: &Idx, to: &Idx) -> &'a mut Result;\n }\n \n-/**\n- *\n- * The `Deref` trait is used to specify the functionality of dereferencing\n- * operations like `*v`.\n- *\n- * # Example\n- *\n- * A struct with a single field which is accessible via dereferencing the\n- * struct.\n- *\n- * ```\n- * struct DerefExample<T> {\n- *     value: T\n- * }\n- *\n- * impl<T> Deref<T> for DerefExample<T> {\n- *     fn deref<'a>(&'a self) -> &'a T {\n- *         &self.value\n- *     }\n- * }\n- *\n- * fn main() {\n- *     let x = DerefExample { value: 'a' };\n- *     assert_eq!('a', *x);\n- * }\n- * ```\n- */\n+/// The `Deref` trait is used to specify the functionality of dereferencing\n+/// operations like `*v`.\n+///\n+/// # Example\n+///\n+/// A struct with a single field which is accessible via dereferencing the\n+/// struct.\n+///\n+/// ```\n+/// struct DerefExample<T> {\n+///     value: T\n+/// }\n+///\n+/// impl<T> Deref<T> for DerefExample<T> {\n+///     fn deref<'a>(&'a self) -> &'a T {\n+///         &self.value\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let x = DerefExample { value: 'a' };\n+///     assert_eq!('a', *x);\n+/// }\n+/// ```\n #[lang=\"deref\"]\n pub trait Deref<Sized? Result> for Sized? {\n     /// The method called to dereference a value\n@@ -813,40 +759,37 @@ impl<'a, Sized? T> Deref<T> for &'a mut T {\n     fn deref(&self) -> &T { *self }\n }\n \n-/**\n- *\n- * The `DerefMut` trait is used to specify the functionality of dereferencing\n- * mutably like `*v = 1;`\n- *\n- * # Example\n- *\n- * A struct with a single field which is modifiable via dereferencing the\n- * struct.\n- *\n- * ```\n- * struct DerefMutExample<T> {\n- *     value: T\n- * }\n- *\n- * impl<T> Deref<T> for DerefMutExample<T> {\n- *     fn deref<'a>(&'a self) -> &'a T {\n- *         &self.value\n- *     }\n- * }\n- *\n- * impl<T> DerefMut<T> for DerefMutExample<T> {\n- *     fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n- *         &mut self.value\n- *     }\n- * }\n- *\n- * fn main() {\n- *     let mut x = DerefMutExample { value: 'a' };\n- *     *x = 'b';\n- *     assert_eq!('b', *x);\n- * }\n- * ```\n- */\n+/// The `DerefMut` trait is used to specify the functionality of dereferencing\n+/// mutably like `*v = 1;`\n+///\n+/// # Example\n+///\n+/// A struct with a single field which is modifiable via dereferencing the\n+/// struct.\n+///\n+/// ```\n+/// struct DerefMutExample<T> {\n+///     value: T\n+/// }\n+///\n+/// impl<T> Deref<T> for DerefMutExample<T> {\n+///     fn deref<'a>(&'a self) -> &'a T {\n+///         &self.value\n+///     }\n+/// }\n+///\n+/// impl<T> DerefMut<T> for DerefMutExample<T> {\n+///     fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n+///         &mut self.value\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let mut x = DerefMutExample { value: 'a' };\n+///     *x = 'b';\n+///     assert_eq!('b', *x);\n+/// }\n+/// ```\n #[lang=\"deref_mut\"]\n pub trait DerefMut<Sized? Result>: Deref<Result> {\n     /// The method called to mutably dereference a value"}, {"sha": "950f04a5d97e384062c8a3a92ec5cfb3862adec7", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 13, "deletions": 25, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -1632,19 +1632,15 @@ impl BinarySearchResult {\n // Free functions\n //\n \n-/**\n- * Converts a pointer to A into a slice of length 1 (without copying).\n- */\n+/// Converts a pointer to A into a slice of length 1 (without copying).\n #[unstable = \"waiting for DST\"]\n pub fn ref_slice<'a, A>(s: &'a A) -> &'a [A] {\n     unsafe {\n         transmute(RawSlice { data: s, len: 1 })\n     }\n }\n \n-/**\n- * Converts a pointer to A into a slice of length 1 (without copying).\n- */\n+/// Converts a pointer to A into a slice of length 1 (without copying).\n #[unstable = \"waiting for DST\"]\n pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n     unsafe {\n@@ -1708,10 +1704,8 @@ pub mod raw {\n     use raw::Slice;\n     use option::{None, Option, Some};\n \n-    /**\n-     * Form a slice from a pointer and length (as a number of units,\n-     * not bytes).\n-     */\n+    /// Form a slice from a pointer and length (as a number of units,\n+    /// not bytes).\n     #[inline]\n     #[deprecated = \"renamed to slice::from_raw_buf\"]\n     pub unsafe fn buf_as_slice<T,U>(p: *const T, len: uint, f: |v: &[T]| -> U)\n@@ -1722,10 +1716,8 @@ pub mod raw {\n         }))\n     }\n \n-    /**\n-     * Form a slice from a pointer and length (as a number of units,\n-     * not bytes).\n-     */\n+    /// Form a slice from a pointer and length (as a number of units,\n+    /// not bytes).\n     #[inline]\n     #[deprecated = \"renamed to slice::from_raw_mut_buf\"]\n     pub unsafe fn mut_buf_as_slice<T,\n@@ -1740,12 +1732,10 @@ pub mod raw {\n         }))\n     }\n \n-    /**\n-     * Returns a pointer to first element in slice and adjusts\n-     * slice so it no longer contains that element. Returns None\n-     * if the slice is empty. O(1).\n-     */\n-     #[inline]\n+    /// Returns a pointer to first element in slice and adjusts\n+    /// slice so it no longer contains that element. Returns None\n+    /// if the slice is empty. O(1).\n+    #[inline]\n     #[deprecated = \"inspect `Slice::{data, len}` manually (increment data by 1)\"]\n     pub unsafe fn shift_ptr<T>(slice: &mut Slice<T>) -> Option<*const T> {\n         if slice.len == 0 { return None; }\n@@ -1755,11 +1745,9 @@ pub mod raw {\n         Some(head)\n     }\n \n-    /**\n-     * Returns a pointer to last element in slice and adjusts\n-     * slice so it no longer contains that element. Returns None\n-     * if the slice is empty. O(1).\n-     */\n+    /// Returns a pointer to last element in slice and adjusts\n+    /// slice so it no longer contains that element. Returns None\n+    /// if the slice is empty. O(1).\n     #[inline]\n     #[deprecated = \"inspect `Slice::{data, len}` manually (decrement len by 1)\"]\n     pub unsafe fn pop_ptr<T>(slice: &mut Slice<T>) -> Option<*const T> {"}, {"sha": "55f483682b75ecf7c647dc16a0776408fbecf5c8", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -329,20 +329,18 @@ pub mod types {\n     // Standard types that are opaque or common, so are not per-target.\n     pub mod common {\n         pub mod c95 {\n-            /**\n-            Type used to construct void pointers for use with C.\n-\n-            This type is only useful as a pointer target. Do not use it as a\n-            return type for FFI functions which have the `void` return type in\n-            C. Use the unit type `()` or omit the return type instead.\n-\n-            For LLVM to recognize the void pointer type and by extension\n-            functions like malloc(), we need to have it represented as i8* in\n-            LLVM bitcode. The enum used here ensures this and prevents misuse\n-            of the \"raw\" type by only having private variants.. We need two\n-            variants, because the compiler complains about the repr attribute\n-            otherwise.\n-            */\n+            /// Type used to construct void pointers for use with C.\n+            ///\n+            /// This type is only useful as a pointer target. Do not use it as a\n+            /// return type for FFI functions which have the `void` return type in\n+            /// C. Use the unit type `()` or omit the return type instead.\n+            ///\n+            /// For LLVM to recognize the void pointer type and by extension\n+            /// functions like malloc(), we need to have it represented as i8* in\n+            /// LLVM bitcode. The enum used here ensures this and prevents misuse\n+            /// of the \"raw\" type by only having private variants.. We need two\n+            /// variants, because the compiler complains about the repr attribute\n+            /// otherwise.\n             #[repr(u8)]\n             pub enum c_void {\n                 __variant1,"}, {"sha": "c7bed838eb91927991e59fb66f8e7239873043db", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -464,11 +464,9 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n         self.lookup_and_emit(lint, Some(span), msg);\n     }\n \n-    /**\n-     * Merge the lints specified by any lint attributes into the\n-     * current lint context, call the provided function, then reset the\n-     * lints in effect to their previous state.\n-     */\n+    /// Merge the lints specified by any lint attributes into the\n+    /// current lint context, call the provided function, then reset the\n+    /// lints in effect to their previous state.\n     fn with_lint_attrs(&mut self,\n                        attrs: &[ast::Attribute],\n                        f: |&mut Context|) {"}, {"sha": "593ec949035627233ff7531b16d9a5a7de179558", "filename": "src/librustc/middle/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -13,7 +13,7 @@ use syntax::ast;\n \n use self::SimplifiedType::*;\n \n-/** See `simplify_type */\n+/// See `simplify_type\n #[deriving(Clone, PartialEq, Eq, Hash)]\n pub enum SimplifiedType {\n     BoolSimplifiedType,"}, {"sha": "d0b2f5c1b6ec18c2dca1f3581fb5da4f5f17a5a0", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -266,24 +266,22 @@ pub struct MemCategorizationContext<'t,TYPER:'t> {\n \n pub type McResult<T> = Result<T, ()>;\n \n-/**\n- * The `Typer` trait provides the interface for the mem-categorization\n- * module to the results of the type check. It can be used to query\n- * the type assigned to an expression node, to inquire after adjustments,\n- * and so on.\n- *\n- * This interface is needed because mem-categorization is used from\n- * two places: `regionck` and `borrowck`. `regionck` executes before\n- * type inference is complete, and hence derives types and so on from\n- * intermediate tables.  This also implies that type errors can occur,\n- * and hence `node_ty()` and friends return a `Result` type -- any\n- * error will propagate back up through the mem-categorization\n- * routines.\n- *\n- * In the borrow checker, in contrast, type checking is complete and we\n- * know that no errors have occurred, so we simply consult the tcx and we\n- * can be sure that only `Ok` results will occur.\n- */\n+/// The `Typer` trait provides the interface for the mem-categorization\n+/// module to the results of the type check. It can be used to query\n+/// the type assigned to an expression node, to inquire after adjustments,\n+/// and so on.\n+///\n+/// This interface is needed because mem-categorization is used from\n+/// two places: `regionck` and `borrowck`. `regionck` executes before\n+/// type inference is complete, and hence derives types and so on from\n+/// intermediate tables.  This also implies that type errors can occur,\n+/// and hence `node_ty()` and friends return a `Result` type -- any\n+/// error will propagate back up through the mem-categorization\n+/// routines.\n+///\n+/// In the borrow checker, in contrast, type checking is complete and we\n+/// know that no errors have occurred, so we simply consult the tcx and we\n+/// can be sure that only `Ok` results will occur.\n pub trait Typer<'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n     fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>>;"}, {"sha": "3684f64ebe53710ee1287f910773115189d433f9", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 36, "deletions": 38, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -72,46 +72,44 @@ impl CodeExtent {\n     }\n }\n \n-/**\n The region maps encode information about region relationships.\n \n-- `scope_map` maps from a scope id to the enclosing scope id; this is\n-  usually corresponding to the lexical nesting, though in the case of\n-  closures the parent scope is the innermost conditional expression or repeating\n-  block\n-\n-- `var_map` maps from a variable or binding id to the block in which\n-  that variable is declared.\n-\n-- `free_region_map` maps from a free region `a` to a list of free\n-  regions `bs` such that `a <= b for all b in bs`\n-  - the free region map is populated during type check as we check\n-    each function. See the function `relate_free_regions` for\n-    more information.\n-\n-- `rvalue_scopes` includes entries for those expressions whose cleanup\n-  scope is larger than the default. The map goes from the expression\n-  id to the cleanup scope id. For rvalues not present in this table,\n-  the appropriate cleanup scope is the innermost enclosing statement,\n-  conditional expression, or repeating block (see `terminating_scopes`).\n-\n-- `terminating_scopes` is a set containing the ids of each statement,\n-  or conditional/repeating expression. These scopes are calling \"terminating\n-  scopes\" because, when attempting to find the scope of a temporary, by\n-  default we search up the enclosing scopes until we encounter the\n-  terminating scope. A conditional/repeating\n-  expression is one which is not guaranteed to execute exactly once\n-  upon entering the parent scope. This could be because the expression\n-  only executes conditionally, such as the expression `b` in `a && b`,\n-  or because the expression may execute many times, such as a loop\n-  body. The reason that we distinguish such expressions is that, upon\n-  exiting the parent scope, we cannot statically know how many times\n-  the expression executed, and thus if the expression creates\n-  temporaries we cannot know statically how many such temporaries we\n-  would have to cleanup. Therefore we ensure that the temporaries never\n-  outlast the conditional/repeating expression, preventing the need\n-  for dynamic checks and/or arbitrary amounts of stack space.\n-*/\n+/// - `scope_map` maps from a scope id to the enclosing scope id; this is\n+///   usually corresponding to the lexical nesting, though in the case of\n+///   closures the parent scope is the innermost conditional expression or repeating\n+///   block\n+///\n+/// - `var_map` maps from a variable or binding id to the block in which\n+///   that variable is declared.\n+///\n+/// - `free_region_map` maps from a free region `a` to a list of free\n+///   regions `bs` such that `a <= b for all b in bs`\n+///   - the free region map is populated during type check as we check\n+///     each function. See the function `relate_free_regions` for\n+///     more information.\n+///\n+/// - `rvalue_scopes` includes entries for those expressions whose cleanup\n+///   scope is larger than the default. The map goes from the expression\n+///   id to the cleanup scope id. For rvalues not present in this table,\n+///   the appropriate cleanup scope is the innermost enclosing statement,\n+///   conditional expression, or repeating block (see `terminating_scopes`).\n+///\n+/// - `terminating_scopes` is a set containing the ids of each statement,\n+///   or conditional/repeating expression. These scopes are calling \"terminating\n+///   scopes\" because, when attempting to find the scope of a temporary, by\n+///   default we search up the enclosing scopes until we encounter the\n+///   terminating scope. A conditional/repeating\n+///   expression is one which is not guaranteed to execute exactly once\n+///   upon entering the parent scope. This could be because the expression\n+///   only executes conditionally, such as the expression `b` in `a && b`,\n+///   or because the expression may execute many times, such as a loop\n+///   body. The reason that we distinguish such expressions is that, upon\n+///   exiting the parent scope, we cannot statically know how many times\n+///   the expression executed, and thus if the expression creates\n+///   temporaries we cannot know statically how many such temporaries we\n+///   would have to cleanup. Therefore we ensure that the temporaries never\n+///   outlast the conditional/repeating expression, preventing the need\n+///   for dynamic checks and/or arbitrary amounts of stack space.\n pub struct RegionMaps {\n     scope_map: RefCell<FnvHashMap<CodeExtent, CodeExtent>>,\n     var_map: RefCell<NodeMap<CodeExtent>>,"}, {"sha": "3fcaa43c2433cece600b6c18534728a4263cea1c", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -761,10 +761,8 @@ impl NameBindings {\n         }\n     }\n \n-    /**\n-     * Returns the module node. Panics if this node does not have a module\n-     * definition.\n-     */\n+    /// Returns the module node. Panics if this node does not have a module\n+    /// definition.\n     fn get_module(&self) -> Rc<Module> {\n         match self.get_module_if_available() {\n             None => {\n@@ -1098,18 +1096,16 @@ impl<'a> Resolver<'a> {\n         visit::walk_crate(&mut visitor, krate);\n     }\n \n-    /**\n-     * Adds a new child item to the module definition of the parent node and\n-     * returns its corresponding name bindings as well as the current parent.\n-     * Or, if we're inside a block, creates (or reuses) an anonymous module\n-     * corresponding to the innermost block ID and returns the name bindings\n-     * as well as the newly-created parent.\n-     *\n-     * # Panics\n-     *\n-     * Panics if this node does not have a module definition and we are not inside\n-     * a block.\n-     */\n+    /// Adds a new child item to the module definition of the parent node and\n+    /// returns its corresponding name bindings as well as the current parent.\n+    /// Or, if we're inside a block, creates (or reuses) an anonymous module\n+    /// corresponding to the innermost block ID and returns the name bindings\n+    /// as well as the newly-created parent.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if this node does not have a module definition and we are not inside\n+    /// a block.\n     fn add_child(&self,\n                  name: Name,\n                  reduced_graph_parent: ReducedGraphParent,"}, {"sha": "e4bf5fec2ca957491fbaf4eff250ed750ca1b1d2", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -24,22 +24,19 @@ use syntax::codemap::{Span, DUMMY_SP};\n \n ///////////////////////////////////////////////////////////////////////////\n \n-/**\n- * A substitution mapping type/region parameters to new values. We\n- * identify each in-scope parameter by an *index* and a *parameter\n- * space* (which indices where the parameter is defined; see\n- * `ParamSpace`).\n- */\n+/// A substitution mapping type/region parameters to new values. We\n+/// identify each in-scope parameter by an *index* and a *parameter\n+/// space* (which indices where the parameter is defined; see\n+/// `ParamSpace`).\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct Substs<'tcx> {\n     pub types: VecPerParamSpace<Ty<'tcx>>,\n     pub regions: RegionSubsts,\n }\n \n-/**\n- * Represents the values to use when substituting lifetime parameters.\n- * If the value is `ErasedRegions`, then this subst is occurring during\n- * trans, and all region parameters will be replaced with `ty::ReStatic`. */\n+/// Represents the values to use when substituting lifetime parameters.\n+/// If the value is `ErasedRegions`, then this subst is occurring during\n+/// trans, and all region parameters will be replaced with `ty::ReStatic`.\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub enum RegionSubsts {\n     ErasedRegions,\n@@ -226,11 +223,9 @@ impl ParamSpace {\n     }\n }\n \n-/**\n- * Vector of things sorted by param space. Used to keep\n- * the set of things declared on the type, self, or method\n- * distinct.\n- */\n+/// Vector of things sorted by param space. Used to keep\n+/// the set of things declared on the type, self, or method\n+/// distinct.\n #[deriving(PartialEq, Eq, Clone, Hash, Encodable, Decodable)]\n pub struct VecPerParamSpace<T> {\n     // This was originally represented as a tuple with one Vec<T> for\n@@ -250,10 +245,8 @@ pub struct VecPerParamSpace<T> {\n     content: Vec<T>,\n }\n \n-/**\n- * The `split` function converts one `VecPerParamSpace` into this\n- * `SeparateVecsPerParamSpace` structure.\n- */\n+/// The `split` function converts one `VecPerParamSpace` into this\n+/// `SeparateVecsPerParamSpace` structure.\n pub struct SeparateVecsPerParamSpace<T> {\n     pub types: Vec<T>,\n     pub selfs: Vec<T>,"}, {"sha": "5b4ac509ccc01ee80c6f3c5c06d57f7d2633db63", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -19,18 +19,16 @@ use super::FulfillmentError;\n use super::CodeSelectionError;\n use super::select::SelectionContext;\n \n-/**\n- * The fulfillment context is used to drive trait resolution.  It\n- * consists of a list of obligations that must be (eventually)\n- * satisfied. The job is to track which are satisfied, which yielded\n- * errors, and which are still pending. At any point, users can call\n- * `select_where_possible`, and the fulfilment context will try to do\n- * selection, retaining only those obligations that remain\n- * ambiguous. This may be helpful in pushing type inference\n- * along. Once all type inference constraints have been generated, the\n- * method `select_all_or_error` can be used to report any remaining\n- * ambiguous cases as errors.\n- */\n+/// The fulfillment context is used to drive trait resolution.  It\n+/// consists of a list of obligations that must be (eventually)\n+/// satisfied. The job is to track which are satisfied, which yielded\n+/// errors, and which are still pending. At any point, users can call\n+/// `select_where_possible`, and the fulfilment context will try to do\n+/// selection, retaining only those obligations that remain\n+/// ambiguous. This may be helpful in pushing type inference\n+/// along. Once all type inference constraints have been generated, the\n+/// method `select_all_or_error` can be used to report any remaining\n+/// ambiguous cases as errors.\n pub struct FulfillmentContext<'tcx> {\n     // A list of all obligations that have been registered with this\n     // fulfillment context."}, {"sha": "9845a371e3478b84a535293ad71c7afe564f2b28", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 65, "deletions": 77, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -42,24 +42,20 @@ mod fulfill;\n mod select;\n mod util;\n \n-/**\n- * An `Obligation` represents some trait reference (e.g. `int:Eq`) for\n- * which the vtable must be found.  The process of finding a vtable is\n- * called \"resolving\" the `Obligation`. This process consists of\n- * either identifying an `impl` (e.g., `impl Eq for int`) that\n- * provides the required vtable, or else finding a bound that is in\n- * scope. The eventual result is usually a `Selection` (defined below).\n- */\n+/// An `Obligation` represents some trait reference (e.g. `int:Eq`) for\n+/// which the vtable must be found.  The process of finding a vtable is\n+/// called \"resolving\" the `Obligation`. This process consists of\n+/// either identifying an `impl` (e.g., `impl Eq for int`) that\n+/// provides the required vtable, or else finding a bound that is in\n+/// scope. The eventual result is usually a `Selection` (defined below).\n #[deriving(Clone)]\n pub struct Obligation<'tcx> {\n     pub cause: ObligationCause<'tcx>,\n     pub recursion_depth: uint,\n     pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n }\n \n-/**\n- * Why did we incur this obligation? Used for error reporting.\n- */\n+/// Why did we incur this obligation? Used for error reporting.\n #[deriving(Clone)]\n pub struct ObligationCause<'tcx> {\n     pub span: Span,\n@@ -121,57 +117,53 @@ pub enum FulfillmentErrorCode<'tcx> {\n     CodeAmbiguity,\n }\n \n-/**\n- * When performing resolution, it is typically the case that there\n- * can be one of three outcomes:\n- *\n- * - `Ok(Some(r))`: success occurred with result `r`\n- * - `Ok(None)`: could not definitely determine anything, usually due\n- *   to inconclusive type inference.\n- * - `Err(e)`: error `e` occurred\n- */\n+/// When performing resolution, it is typically the case that there\n+/// can be one of three outcomes:\n+///\n+/// - `Ok(Some(r))`: success occurred with result `r`\n+/// - `Ok(None)`: could not definitely determine anything, usually due\n+///   to inconclusive type inference.\n+/// - `Err(e)`: error `e` occurred\n pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n \n-/**\n- * Given the successful resolution of an obligation, the `Vtable`\n- * indicates where the vtable comes from. Note that while we call this\n- * a \"vtable\", it does not necessarily indicate dynamic dispatch at\n- * runtime. `Vtable` instances just tell the compiler where to find\n- * methods, but in generic code those methods are typically statically\n- * dispatched -- only when an object is constructed is a `Vtable`\n- * instance reified into an actual vtable.\n- *\n- * For example, the vtable may be tied to a specific impl (case A),\n- * or it may be relative to some bound that is in scope (case B).\n- *\n- *\n- * ```\n- * impl<T:Clone> Clone<T> for Option<T> { ... } // Impl_1\n- * impl<T:Clone> Clone<T> for Box<T> { ... }    // Impl_2\n- * impl Clone for int { ... }             // Impl_3\n- *\n- * fn foo<T:Clone>(concrete: Option<Box<int>>,\n- *                 param: T,\n- *                 mixed: Option<T>) {\n- *\n- *    // Case A: Vtable points at a specific impl. Only possible when\n- *    // type is concretely known. If the impl itself has bounded\n- *    // type parameters, Vtable will carry resolutions for those as well:\n- *    concrete.clone(); // Vtable(Impl_1, [Vtable(Impl_2, [Vtable(Impl_3)])])\n- *\n- *    // Case B: Vtable must be provided by caller. This applies when\n- *    // type is a type parameter.\n- *    param.clone();    // VtableParam(Oblig_1)\n- *\n- *    // Case C: A mix of cases A and B.\n- *    mixed.clone();    // Vtable(Impl_1, [VtableParam(Oblig_1)])\n- * }\n- * ```\n- *\n- * ### The type parameter `N`\n- *\n- * See explanation on `VtableImplData`.\n- */\n+/// Given the successful resolution of an obligation, the `Vtable`\n+/// indicates where the vtable comes from. Note that while we call this\n+/// a \"vtable\", it does not necessarily indicate dynamic dispatch at\n+/// runtime. `Vtable` instances just tell the compiler where to find\n+/// methods, but in generic code those methods are typically statically\n+/// dispatched -- only when an object is constructed is a `Vtable`\n+/// instance reified into an actual vtable.\n+///\n+/// For example, the vtable may be tied to a specific impl (case A),\n+/// or it may be relative to some bound that is in scope (case B).\n+///\n+///\n+/// ```\n+/// impl<T:Clone> Clone<T> for Option<T> { ... } // Impl_1\n+/// impl<T:Clone> Clone<T> for Box<T> { ... }    // Impl_2\n+/// impl Clone for int { ... }             // Impl_3\n+///\n+/// fn foo<T:Clone>(concrete: Option<Box<int>>,\n+///                 param: T,\n+///                 mixed: Option<T>) {\n+///\n+///    // Case A: Vtable points at a specific impl. Only possible when\n+///    // type is concretely known. If the impl itself has bounded\n+///    // type parameters, Vtable will carry resolutions for those as well:\n+///    concrete.clone(); // Vtable(Impl_1, [Vtable(Impl_2, [Vtable(Impl_3)])])\n+///\n+///    // Case B: Vtable must be provided by caller. This applies when\n+///    // type is a type parameter.\n+///    param.clone();    // VtableParam(Oblig_1)\n+///\n+///    // Case C: A mix of cases A and B.\n+///    mixed.clone();    // Vtable(Impl_1, [VtableParam(Oblig_1)])\n+/// }\n+/// ```\n+///\n+/// ### The type parameter `N`\n+///\n+/// See explanation on `VtableImplData`.\n #[deriving(Show,Clone)]\n pub enum Vtable<'tcx, N> {\n     /// Vtable identifying a particular impl.\n@@ -191,18 +183,16 @@ pub enum Vtable<'tcx, N> {\n     VtableBuiltin(VtableBuiltinData<N>),\n }\n \n-/**\n- * Identifies a particular impl in the source, along with a set of\n- * substitutions from the impl's type/lifetime parameters. The\n- * `nested` vector corresponds to the nested obligations attached to\n- * the impl's type parameters.\n- *\n- * The type parameter `N` indicates the type used for \"nested\n- * obligations\" that are required by the impl. During type check, this\n- * is `Obligation`, as one might expect. During trans, however, this\n- * is `()`, because trans only requires a shallow resolution of an\n- * impl, and nested obligations are satisfied later.\n- */\n+/// Identifies a particular impl in the source, along with a set of\n+/// substitutions from the impl's type/lifetime parameters. The\n+/// `nested` vector corresponds to the nested obligations attached to\n+/// the impl's type parameters.\n+///\n+/// The type parameter `N` indicates the type used for \"nested\n+/// obligations\" that are required by the impl. During type check, this\n+/// is `Obligation`, as one might expect. During trans, however, this\n+/// is `()`, because trans only requires a shallow resolution of an\n+/// impl, and nested obligations are satisfied later.\n #[deriving(Clone)]\n pub struct VtableImplData<'tcx, N> {\n     pub impl_def_id: ast::DefId,\n@@ -215,11 +205,9 @@ pub struct VtableBuiltinData<N> {\n     pub nested: subst::VecPerParamSpace<N>\n }\n \n-/**\n- * A vtable provided as a parameter by the caller. For example, in a\n- * function like `fn foo<T:Eq>(...)`, if the `eq()` method is invoked\n- * on an instance of `T`, the vtable would be of type `VtableParam`.\n- */\n+/// A vtable provided as a parameter by the caller. For example, in a\n+/// function like `fn foo<T:Eq>(...)`, if the `eq()` method is invoked\n+/// on an instance of `T`, the vtable would be of type `VtableParam`.\n #[deriving(PartialEq,Eq,Clone)]\n pub struct VtableParamData<'tcx> {\n     // In the above example, this would `Eq`"}, {"sha": "dd6b1ffd1a559fa1590a12cdb8d7f912bcaf1d10", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -102,32 +102,30 @@ pub enum MethodMatchedData {\n     CoerciveMethodMatch(/* impl we matched */ ast::DefId)\n }\n \n-/**\n- * The selection process begins by considering all impls, where\n- * clauses, and so forth that might resolve an obligation.  Sometimes\n- * we'll be able to say definitively that (e.g.) an impl does not\n- * apply to the obligation: perhaps it is defined for `uint` but the\n- * obligation is for `int`. In that case, we drop the impl out of the\n- * list.  But the other cases are considered *candidates*.\n- *\n- * Candidates can either be definitive or ambiguous. An ambiguous\n- * candidate is one that might match or might not, depending on how\n- * type variables wind up being resolved. This only occurs during inference.\n- *\n- * For selection to suceed, there must be exactly one non-ambiguous\n- * candidate.  Usually, it is not possible to have more than one\n- * definitive candidate, due to the coherence rules. However, there is\n- * one case where it could occur: if there is a blanket impl for a\n- * trait (that is, an impl applied to all T), and a type parameter\n- * with a where clause. In that case, we can have a candidate from the\n- * where clause and a second candidate from the impl. This is not a\n- * problem because coherence guarantees us that the impl which would\n- * be used to satisfy the where clause is the same one that we see\n- * now. To resolve this issue, therefore, we ignore impls if we find a\n- * matching where clause. Part of the reason for this is that where\n- * clauses can give additional information (like, the types of output\n- * parameters) that would have to be inferred from the impl.\n- */\n+/// The selection process begins by considering all impls, where\n+/// clauses, and so forth that might resolve an obligation.  Sometimes\n+/// we'll be able to say definitively that (e.g.) an impl does not\n+/// apply to the obligation: perhaps it is defined for `uint` but the\n+/// obligation is for `int`. In that case, we drop the impl out of the\n+/// list.  But the other cases are considered *candidates*.\n+///\n+/// Candidates can either be definitive or ambiguous. An ambiguous\n+/// candidate is one that might match or might not, depending on how\n+/// type variables wind up being resolved. This only occurs during inference.\n+///\n+/// For selection to suceed, there must be exactly one non-ambiguous\n+/// candidate.  Usually, it is not possible to have more than one\n+/// definitive candidate, due to the coherence rules. However, there is\n+/// one case where it could occur: if there is a blanket impl for a\n+/// trait (that is, an impl applied to all T), and a type parameter\n+/// with a where clause. In that case, we can have a candidate from the\n+/// where clause and a second candidate from the impl. This is not a\n+/// problem because coherence guarantees us that the impl which would\n+/// be used to satisfy the where clause is the same one that we see\n+/// now. To resolve this issue, therefore, we ignore impls if we find a\n+/// matching where clause. Part of the reason for this is that where\n+/// clauses can give additional information (like, the types of output\n+/// parameters) that would have to be inferred from the impl.\n #[deriving(PartialEq,Eq,Show,Clone)]\n enum Candidate<'tcx> {\n     BuiltinCandidate(ty::BuiltinBound),"}, {"sha": "d71c5e3db68e5c63951faa93da104b8486fd17bd", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 149, "deletions": 165, "changes": 314, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -743,18 +743,16 @@ impl<'tcx> FnOutput<'tcx> {\n     }\n }\n \n-/**\n- * Signature of a function type, which I have arbitrarily\n- * decided to use to refer to the input/output types.\n- *\n- * - `inputs` is the list of arguments and their modes.\n- * - `output` is the return type.\n- * - `variadic` indicates whether this is a varidic function. (only true for foreign fns)\n- *\n- * Note that a `FnSig` introduces a level of region binding, to\n- * account for late-bound parameters that appear in the types of the\n- * fn's arguments or the fn's return type.\n- */\n+/// Signature of a function type, which I have arbitrarily\n+/// decided to use to refer to the input/output types.\n+///\n+/// - `inputs` is the list of arguments and their modes.\n+/// - `output` is the return type.\n+/// - `variadic` indicates whether this is a varidic function. (only true for foreign fns)\n+///\n+/// Note that a `FnSig` introduces a level of region binding, to\n+/// account for late-bound parameters that appear in the types of the\n+/// fn's arguments or the fn's return type.\n #[deriving(Clone, PartialEq, Eq, Hash)]\n pub struct FnSig<'tcx> {\n     pub inputs: Vec<Ty<'tcx>>,\n@@ -769,47 +767,45 @@ pub struct ParamTy {\n     pub def_id: DefId\n }\n \n-/**\n- * A [De Bruijn index][dbi] is a standard means of representing\n- * regions (and perhaps later types) in a higher-ranked setting. In\n- * particular, imagine a type like this:\n- *\n- *     for<'a> fn(for<'b> fn(&'b int, &'a int), &'a char)\n- *     ^          ^            |        |         |\n- *     |          |            |        |         |\n- *     |          +------------+ 1      |         |\n- *     |                                |         |\n- *     +--------------------------------+ 2       |\n- *     |                                          |\n- *     +------------------------------------------+ 1\n- *\n- * In this type, there are two binders (the outer fn and the inner\n- * fn). We need to be able to determine, for any given region, which\n- * fn type it is bound by, the inner or the outer one. There are\n- * various ways you can do this, but a De Bruijn index is one of the\n- * more convenient and has some nice properties. The basic idea is to\n- * count the number of binders, inside out. Some examples should help\n- * clarify what I mean.\n- *\n- * Let's start with the reference type `&'b int` that is the first\n- * argument to the inner function. This region `'b` is assigned a De\n- * Bruijn index of 1, meaning \"the innermost binder\" (in this case, a\n- * fn). The region `'a` that appears in the second argument type (`&'a\n- * int`) would then be assigned a De Bruijn index of 2, meaning \"the\n- * second-innermost binder\". (These indices are written on the arrays\n- * in the diagram).\n- *\n- * What is interesting is that De Bruijn index attached to a particular\n- * variable will vary depending on where it appears. For example,\n- * the final type `&'a char` also refers to the region `'a` declared on\n- * the outermost fn. But this time, this reference is not nested within\n- * any other binders (i.e., it is not an argument to the inner fn, but\n- * rather the outer one). Therefore, in this case, it is assigned a\n- * De Bruijn index of 1, because the innermost binder in that location\n- * is the outer fn.\n- *\n- * [dbi]: http://en.wikipedia.org/wiki/De_Bruijn_index\n- */\n+/// A [De Bruijn index][dbi] is a standard means of representing\n+/// regions (and perhaps later types) in a higher-ranked setting. In\n+/// particular, imagine a type like this:\n+///\n+///     for<'a> fn(for<'b> fn(&'b int, &'a int), &'a char)\n+///     ^          ^            |        |         |\n+///     |          |            |        |         |\n+///     |          +------------+ 1      |         |\n+///     |                                |         |\n+///     +--------------------------------+ 2       |\n+///     |                                          |\n+///     +------------------------------------------+ 1\n+///\n+/// In this type, there are two binders (the outer fn and the inner\n+/// fn). We need to be able to determine, for any given region, which\n+/// fn type it is bound by, the inner or the outer one. There are\n+/// various ways you can do this, but a De Bruijn index is one of the\n+/// more convenient and has some nice properties. The basic idea is to\n+/// count the number of binders, inside out. Some examples should help\n+/// clarify what I mean.\n+///\n+/// Let's start with the reference type `&'b int` that is the first\n+/// argument to the inner function. This region `'b` is assigned a De\n+/// Bruijn index of 1, meaning \"the innermost binder\" (in this case, a\n+/// fn). The region `'a` that appears in the second argument type (`&'a\n+/// int`) would then be assigned a De Bruijn index of 2, meaning \"the\n+/// second-innermost binder\". (These indices are written on the arrays\n+/// in the diagram).\n+///\n+/// What is interesting is that De Bruijn index attached to a particular\n+/// variable will vary depending on where it appears. For example,\n+/// the final type `&'a char` also refers to the region `'a` declared on\n+/// the outermost fn. But this time, this reference is not nested within\n+/// any other binders (i.e., it is not an argument to the inner fn, but\n+/// rather the outer one). Therefore, in this case, it is assigned a\n+/// De Bruijn index of 1, because the innermost binder in that location\n+/// is the outer fn.\n+///\n+/// [dbi]: http://en.wikipedia.org/wiki/De_Bruijn_index\n #[deriving(Clone, PartialEq, Eq, Hash, Encodable, Decodable, Show)]\n pub struct DebruijnIndex {\n     // We maintain the invariant that this is never 0. So 1 indicates\n@@ -856,11 +852,9 @@ pub enum Region {\n     ReEmpty,\n }\n \n-/**\n- * Upvars do not get their own node-id. Instead, we use the pair of\n- * the original var id (that is, the root variable that is referenced\n- * by the upvar) and the id of the closure expression.\n- */\n+/// Upvars do not get their own node-id. Instead, we use the pair of\n+/// the original var id (that is, the root variable that is referenced\n+/// by the upvar) and the id of the closure expression.\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct UpvarId {\n     pub var_id: ast::NodeId,\n@@ -913,55 +907,53 @@ pub enum BorrowKind {\n     MutBorrow\n }\n \n-/**\n- * Information describing the borrowing of an upvar. This is computed\n- * during `typeck`, specifically by `regionck`. The general idea is\n- * that the compiler analyses treat closures like:\n- *\n- *     let closure: &'e fn() = || {\n- *        x = 1;   // upvar x is assigned to\n- *        use(y);  // upvar y is read\n- *        foo(&z); // upvar z is borrowed immutably\n- *     };\n- *\n- * as if they were \"desugared\" to something loosely like:\n- *\n- *     struct Vars<'x,'y,'z> { x: &'x mut int,\n- *                             y: &'y const int,\n- *                             z: &'z int }\n- *     let closure: &'e fn() = {\n- *         fn f(env: &Vars) {\n- *             *env.x = 1;\n- *             use(*env.y);\n- *             foo(env.z);\n- *         }\n- *         let env: &'e mut Vars<'x,'y,'z> = &mut Vars { x: &'x mut x,\n- *                                                       y: &'y const y,\n- *                                                       z: &'z z };\n- *         (env, f)\n- *     };\n- *\n- * This is basically what happens at runtime. The closure is basically\n- * an existentially quantified version of the `(env, f)` pair.\n- *\n- * This data structure indicates the region and mutability of a single\n- * one of the `x...z` borrows.\n- *\n- * It may not be obvious why each borrowed variable gets its own\n- * lifetime (in the desugared version of the example, these are indicated\n- * by the lifetime parameters `'x`, `'y`, and `'z` in the `Vars` definition).\n- * Each such lifetime must encompass the lifetime `'e` of the closure itself,\n- * but need not be identical to it. The reason that this makes sense:\n- *\n- * - Callers are only permitted to invoke the closure, and hence to\n- *   use the pointers, within the lifetime `'e`, so clearly `'e` must\n- *   be a sublifetime of `'x...'z`.\n- * - The closure creator knows which upvars were borrowed by the closure\n- *   and thus `x...z` will be reserved for `'x...'z` respectively.\n- * - Through mutation, the borrowed upvars can actually escape\n- *   the closure, so sometimes it is necessary for them to be larger\n- *   than the closure lifetime itself.\n- */\n+/// Information describing the borrowing of an upvar. This is computed\n+/// during `typeck`, specifically by `regionck`. The general idea is\n+/// that the compiler analyses treat closures like:\n+///\n+///     let closure: &'e fn() = || {\n+///        x = 1;   // upvar x is assigned to\n+///        use(y);  // upvar y is read\n+///        foo(&z); // upvar z is borrowed immutably\n+///     };\n+///\n+/// as if they were \"desugared\" to something loosely like:\n+///\n+///     struct Vars<'x,'y,'z> { x: &'x mut int,\n+///                             y: &'y const int,\n+///                             z: &'z int }\n+///     let closure: &'e fn() = {\n+///         fn f(env: &Vars) {\n+///             *env.x = 1;\n+///             use(*env.y);\n+///             foo(env.z);\n+///         }\n+///         let env: &'e mut Vars<'x,'y,'z> = &mut Vars { x: &'x mut x,\n+///                                                       y: &'y const y,\n+///                                                       z: &'z z };\n+///         (env, f)\n+///     };\n+///\n+/// This is basically what happens at runtime. The closure is basically\n+/// an existentially quantified version of the `(env, f)` pair.\n+///\n+/// This data structure indicates the region and mutability of a single\n+/// one of the `x...z` borrows.\n+///\n+/// It may not be obvious why each borrowed variable gets its own\n+/// lifetime (in the desugared version of the example, these are indicated\n+/// by the lifetime parameters `'x`, `'y`, and `'z` in the `Vars` definition).\n+/// Each such lifetime must encompass the lifetime `'e` of the closure itself,\n+/// but need not be identical to it. The reason that this makes sense:\n+///\n+/// - Callers are only permitted to invoke the closure, and hence to\n+///   use the pointers, within the lifetime `'e`, so clearly `'e` must\n+///   be a sublifetime of `'x...'z`.\n+/// - The closure creator knows which upvars were borrowed by the closure\n+///   and thus `x...z` will be reserved for `'x...'z` respectively.\n+/// - Through mutation, the borrowed upvars can actually escape\n+///   the closure, so sometimes it is necessary for them to be larger\n+///   than the closure lifetime itself.\n #[deriving(PartialEq, Clone, Encodable, Decodable, Show)]\n pub struct UpvarBorrow {\n     pub kind: BorrowKind,\n@@ -1111,37 +1103,33 @@ pub struct TyTrait<'tcx> {\n     pub bounds: ExistentialBounds\n }\n \n-/**\n- * A complete reference to a trait. These take numerous guises in syntax,\n- * but perhaps the most recognizable form is in a where clause:\n- *\n- *     T : Foo<U>\n- *\n- * This would be represented by a trait-reference where the def-id is the\n- * def-id for the trait `Foo` and the substs defines `T` as parameter 0 in the\n- * `SelfSpace` and `U` as parameter 0 in the `TypeSpace`.\n- *\n- * Trait references also appear in object types like `Foo<U>`, but in\n- * that case the `Self` parameter is absent from the substitutions.\n- *\n- * Note that a `TraitRef` introduces a level of region binding, to\n- * account for higher-ranked trait bounds like `T : for<'a> Foo<&'a\n- * U>` or higher-ranked object types.\n- */\n+/// A complete reference to a trait. These take numerous guises in syntax,\n+/// but perhaps the most recognizable form is in a where clause:\n+///\n+///     T : Foo<U>\n+///\n+/// This would be represented by a trait-reference where the def-id is the\n+/// def-id for the trait `Foo` and the substs defines `T` as parameter 0 in the\n+/// `SelfSpace` and `U` as parameter 0 in the `TypeSpace`.\n+///\n+/// Trait references also appear in object types like `Foo<U>`, but in\n+/// that case the `Self` parameter is absent from the substitutions.\n+///\n+/// Note that a `TraitRef` introduces a level of region binding, to\n+/// account for higher-ranked trait bounds like `T : for<'a> Foo<&'a\n+/// U>` or higher-ranked object types.\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct TraitRef<'tcx> {\n     pub def_id: DefId,\n     pub substs: Substs<'tcx>,\n }\n \n-/**\n- * Binder serves as a synthetic binder for lifetimes. It is used when\n- * we wish to replace the escaping higher-ranked lifetimes in a type\n- * or something else that is not itself a binder (this is because the\n- * `replace_late_bound_regions` function replaces all lifetimes bound\n- * by the binder supplied to it; but a type is not a binder, so you\n- * must introduce an artificial one).\n- */\n+/// Binder serves as a synthetic binder for lifetimes. It is used when\n+/// we wish to replace the escaping higher-ranked lifetimes in a type\n+/// or something else that is not itself a binder (this is because the\n+/// `replace_late_bound_regions` function replaces all lifetimes bound\n+/// by the binder supplied to it; but a type is not a binder, so you\n+/// must introduce an artificial one).\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct Binder<T> {\n     pub value: T\n@@ -1425,27 +1413,25 @@ impl<'tcx> Generics<'tcx> {\n     }\n }\n \n-/**\n- * Represents the bounds declared on a particular set of type\n- * parameters.  Should eventually be generalized into a flag list of\n- * where clauses.  You can obtain a `GenericBounds` list from a\n- * `Generics` by using the `to_bounds` method. Note that this method\n- * reflects an important semantic invariant of `GenericBounds`: while\n- * the bounds in a `Generics` are expressed in terms of the bound type\n- * parameters of the impl/trait/whatever, a `GenericBounds` instance\n- * represented a set of bounds for some particular instantiation,\n- * meaning that the generic parameters have been substituted with\n- * their values.\n- *\n- * Example:\n- *\n- *     struct Foo<T,U:Bar<T>> { ... }\n- *\n- * Here, the `Generics` for `Foo` would contain a list of bounds like\n- * `[[], [U:Bar<T>]]`.  Now if there were some particular reference\n- * like `Foo<int,uint>`, then the `GenericBounds` would be `[[],\n- * [uint:Bar<int>]]`.\n- */\n+/// Represents the bounds declared on a particular set of type\n+/// parameters.  Should eventually be generalized into a flag list of\n+/// where clauses.  You can obtain a `GenericBounds` list from a\n+/// `Generics` by using the `to_bounds` method. Note that this method\n+/// reflects an important semantic invariant of `GenericBounds`: while\n+/// the bounds in a `Generics` are expressed in terms of the bound type\n+/// parameters of the impl/trait/whatever, a `GenericBounds` instance\n+/// represented a set of bounds for some particular instantiation,\n+/// meaning that the generic parameters have been substituted with\n+/// their values.\n+///\n+/// Example:\n+///\n+///     struct Foo<T,U:Bar<T>> { ... }\n+///\n+/// Here, the `Generics` for `Foo` would contain a list of bounds like\n+/// `[[], [U:Bar<T>]]`.  Now if there were some particular reference\n+/// like `Foo<int,uint>`, then the `GenericBounds` would be `[[],\n+/// [uint:Bar<int>]]`.\n #[deriving(Clone, Show)]\n pub struct GenericBounds<'tcx> {\n     pub types: VecPerParamSpace<ParamBounds<'tcx>>,\n@@ -2455,18 +2441,16 @@ pub fn type_needs_unwind_cleanup<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     }\n }\n \n-/**\n- * Type contents is how the type checker reasons about kinds.\n- * They track what kinds of things are found within a type.  You can\n- * think of them as kind of an \"anti-kind\".  They track the kinds of values\n- * and thinks that are contained in types.  Having a larger contents for\n- * a type tends to rule that type *out* from various kinds.  For example,\n- * a type that contains a reference is not sendable.\n- *\n- * The reason we compute type contents and not kinds is that it is\n- * easier for me (nmatsakis) to think about what is contained within\n- * a type than to think about what is *not* contained within a type.\n- */\n+/// Type contents is how the type checker reasons about kinds.\n+/// They track what kinds of things are found within a type.  You can\n+/// think of them as kind of an \"anti-kind\".  They track the kinds of values\n+/// and thinks that are contained in types.  Having a larger contents for\n+/// a type tends to rule that type *out* from various kinds.  For example,\n+/// a type that contains a reference is not sendable.\n+///\n+/// The reason we compute type contents and not kinds is that it is\n+/// easier for me (nmatsakis) to think about what is contained within\n+/// a type than to think about what is *not* contained within a type.\n #[deriving(Clone)]\n pub struct TypeContents {\n     pub bits: u64"}, {"sha": "8ba23c3393df22f0904185eaecf98c1d291acae3", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -701,9 +701,7 @@ pub fn super_fold_obligation<'tcx, T:TypeFolder<'tcx>>(this: &mut T,\n ///////////////////////////////////////////////////////////////////////////\n // Higher-ranked things\n \n-/**\n- * Designates a \"binder\" for late-bound regions.\n- */\n+/// Designates a \"binder\" for late-bound regions.\n pub trait HigherRankedFoldable<'tcx>: Repr<'tcx> {\n     /// Folds the contents of `self`, ignoring the region binder created\n     /// by `self`."}, {"sha": "9093ade7e3e7a6bd3acc62d3e76e41034c6b244f", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -897,19 +897,17 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-/**\n- * Checks that a method from an impl conforms to the signature of\n- * the same method as declared in the trait.\n- *\n- * # Parameters\n- *\n- * - impl_generics: the generics declared on the impl itself (not the method!)\n- * - impl_m: type of the method we are checking\n- * - impl_m_span: span to use for reporting errors\n- * - impl_m_body_id: id of the method body\n- * - trait_m: the method in the trait\n- * - trait_to_impl_substs: the substitutions used on the type of the trait\n- */\n+/// Checks that a method from an impl conforms to the signature of\n+/// the same method as declared in the trait.\n+///\n+/// # Parameters\n+///\n+/// - impl_generics: the generics declared on the impl itself (not the method!)\n+/// - impl_m: type of the method we are checking\n+/// - impl_m_span: span to use for reporting errors\n+/// - impl_m_body_id: id of the method body\n+/// - trait_m: the method in the trait\n+/// - trait_to_impl_substs: the substitutions used on the type of the trait\n fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                              impl_m: &ty::Method<'tcx>,\n                              impl_m_span: Span,"}, {"sha": "d68ddb30baa97e952848da4b764d933f89123d15", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -694,13 +694,11 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n     }\n \n-    /**\n-    This function performs the actual region resolution.  It must be\n-    called after all constraints have been added.  It performs a\n-    fixed-point iteration to find region values which satisfy all\n-    constraints, assuming such values can be found; if they cannot,\n-    errors are reported.\n-    */\n+    /// This function performs the actual region resolution.  It must be\n+    /// called after all constraints have been added.  It performs a\n+    /// fixed-point iteration to find region values which satisfy all\n+    /// constraints, assuming such values can be found; if they cannot,\n+    /// errors are reported.\n     pub fn resolve_regions(&self) -> Vec<RegionResolutionError<'tcx>> {\n         debug!(\"RegionVarBindings: resolve_regions()\");\n         let mut errors = vec!();"}, {"sha": "8d3142902be46ae0a2fb00f82640b9627d3fdd21", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 40, "deletions": 65, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -22,85 +22,68 @@ use syntax::ast;\n use util::ppaux::Repr;\n use util::snapshot_vec as sv;\n \n-/**\n- * This trait is implemented by any type that can serve as a type\n- * variable. We call such variables *unification keys*. For example,\n- * this trait is implemented by `IntVid`, which represents integral\n- * variables.\n- *\n- * Each key type has an associated value type `V`. For example, for\n- * `IntVid`, this is `Option<IntVarValue>`, representing some\n- * (possibly not yet known) sort of integer.\n- *\n- * Implementations of this trait are at the end of this file.\n- */\n+/// This trait is implemented by any type that can serve as a type\n+/// variable. We call such variables *unification keys*. For example,\n+/// this trait is implemented by `IntVid`, which represents integral\n+/// variables.\n+///\n+/// Each key type has an associated value type `V`. For example, for\n+/// `IntVid`, this is `Option<IntVarValue>`, representing some\n+/// (possibly not yet known) sort of integer.\n+///\n+/// Implementations of this trait are at the end of this file.\n pub trait UnifyKey<'tcx, V> : Clone + Show + PartialEq + Repr<'tcx> {\n     fn index(&self) -> uint;\n \n     fn from_index(u: uint) -> Self;\n \n-    /**\n-     * Given an inference context, returns the unification table\n-     * appropriate to this key type.\n-     */\n+    // Given an inference context, returns the unification table\n+    // appropriate to this key type.\n     fn unification_table<'v>(infcx: &'v InferCtxt)\n                              -> &'v RefCell<UnificationTable<Self,V>>;\n \n     fn tag(k: Option<Self>) -> &'static str;\n }\n \n-/**\n- * Trait for valid types that a type variable can be set to. Note that\n- * this is typically not the end type that the value will take on, but\n- * rather an `Option` wrapper (where `None` represents a variable\n- * whose value is not yet set).\n- *\n- * Implementations of this trait are at the end of this file.\n- */\n+/// Trait for valid types that a type variable can be set to. Note that\n+/// this is typically not the end type that the value will take on, but\n+/// rather an `Option` wrapper (where `None` represents a variable\n+/// whose value is not yet set).\n+///\n+/// Implementations of this trait are at the end of this file.\n pub trait UnifyValue<'tcx> : Clone + Repr<'tcx> + PartialEq {\n }\n \n-/**\n- * Value of a unification key. We implement Tarjan's union-find\n- * algorithm: when two keys are unified, one of them is converted\n- * into a \"redirect\" pointing at the other. These redirects form a\n- * DAG: the roots of the DAG (nodes that are not redirected) are each\n- * associated with a value of type `V` and a rank. The rank is used\n- * to keep the DAG relatively balanced, which helps keep the running\n- * time of the algorithm under control. For more information, see\n- * <http://en.wikipedia.org/wiki/Disjoint-set_data_structure>.\n- */\n+/// Value of a unification key. We implement Tarjan's union-find\n+/// algorithm: when two keys are unified, one of them is converted\n+/// into a \"redirect\" pointing at the other. These redirects form a\n+/// DAG: the roots of the DAG (nodes that are not redirected) are each\n+/// associated with a value of type `V` and a rank. The rank is used\n+/// to keep the DAG relatively balanced, which helps keep the running\n+/// time of the algorithm under control. For more information, see\n+/// <http://en.wikipedia.org/wiki/Disjoint-set_data_structure>.\n #[deriving(PartialEq,Clone)]\n pub enum VarValue<K,V> {\n     Redirect(K),\n     Root(V, uint),\n }\n \n-/**\n- * Table of unification keys and their values.\n- */\n+/// Table of unification keys and their values.\n pub struct UnificationTable<K,V> {\n-    /**\n-     * Indicates the current value of each key.\n-     */\n-\n+    /// Indicates the current value of each key.\n     values: sv::SnapshotVec<VarValue<K,V>,(),Delegate>,\n }\n \n-/**\n- * At any time, users may snapshot a unification table.  The changes\n- * made during the snapshot may either be *committed* or *rolled back*.\n- */\n+/// At any time, users may snapshot a unification table.  The changes\n+/// made during the snapshot may either be *committed* or *rolled back*.\n pub struct Snapshot<K> {\n     // Link snapshot to the key type `K` of the table.\n     marker: marker::CovariantType<K>,\n     snapshot: sv::Snapshot,\n }\n \n-/**\n- * Internal type used to represent the result of a `get()` operation.\n- * Conveys the current root and value of the key.\n- */\n+/// Internal type used to represent the result of a `get()` operation.\n+/// Conveys the current root and value of the key.\n pub struct Node<K,V> {\n     pub key: K,\n     pub value: V,\n@@ -121,28 +104,22 @@ impl<'tcx, V:PartialEq+Clone+Repr<'tcx>, K:UnifyKey<'tcx, V>> UnificationTable<K\n         }\n     }\n \n-    /**\n-     * Starts a new snapshot. Each snapshot must be either\n-     * rolled back or committed in a \"LIFO\" (stack) order.\n-     */\n+    /// Starts a new snapshot. Each snapshot must be either\n+    /// rolled back or committed in a \"LIFO\" (stack) order.\n     pub fn snapshot(&mut self) -> Snapshot<K> {\n         Snapshot { marker: marker::CovariantType::<K>,\n                    snapshot: self.values.start_snapshot() }\n     }\n \n-    /**\n-     * Reverses all changes since the last snapshot. Also\n-     * removes any keys that have been created since then.\n-     */\n+    /// Reverses all changes since the last snapshot. Also\n+    /// removes any keys that have been created since then.\n     pub fn rollback_to(&mut self, snapshot: Snapshot<K>) {\n         debug!(\"{}: rollback_to()\", UnifyKey::tag(None::<K>));\n         self.values.rollback_to(snapshot.snapshot);\n     }\n \n-    /**\n-     * Commits all changes since the last snapshot. Of course, they\n-     * can still be undone if there is a snapshot further out.\n-     */\n+    /// Commits all changes since the last snapshot. Of course, they\n+    /// can still be undone if there is a snapshot further out.\n     pub fn commit(&mut self, snapshot: Snapshot<K>) {\n         debug!(\"{}: commit()\", UnifyKey::tag(None::<K>));\n         self.values.commit(snapshot.snapshot);\n@@ -255,10 +232,8 @@ impl<K,V> sv::SnapshotVecDelegate<VarValue<K,V>,()> for Delegate {\n // Code to handle simple keys like ints, floats---anything that\n // doesn't have a subtyping relationship we need to worry about.\n \n-/**\n- * Indicates a type that does not have any kind of subtyping\n- * relationship.\n- */\n+/// Indicates a type that does not have any kind of subtyping\n+/// relationship.\n pub trait SimplyUnifiable<'tcx> : Clone + PartialEq + Repr<'tcx> {\n     fn to_type(&self) -> Ty<'tcx>;\n     fn to_type_err(expected_found<Self>) -> ty::type_err<'tcx>;"}, {"sha": "501dfcb2e2d9e150f05d84a77a67aefd0848a1a4", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -150,20 +150,18 @@ pub struct MethodCallee<'tcx> {\n     pub substs: subst::Substs<'tcx>\n }\n \n-/**\n- * With method calls, we store some extra information in\n- * side tables (i.e method_map). We use\n- * MethodCall as a key to index into these tables instead of\n- * just directly using the expression's NodeId. The reason\n- * for this being that we may apply adjustments (coercions)\n- * with the resulting expression also needing to use the\n- * side tables. The problem with this is that we don't\n- * assign a separate NodeId to this new expression\n- * and so it would clash with the base expression if both\n- * needed to add to the side tables. Thus to disambiguate\n- * we also keep track of whether there's an adjustment in\n- * our key.\n- */\n+/// With method calls, we store some extra information in\n+/// side tables (i.e method_map). We use\n+/// MethodCall as a key to index into these tables instead of\n+/// just directly using the expression's NodeId. The reason\n+/// for this being that we may apply adjustments (coercions)\n+/// with the resulting expression also needing to use the\n+/// side tables. The problem with this is that we don't\n+/// assign a separate NodeId to this new expression\n+/// and so it would clash with the base expression if both\n+/// needed to add to the side tables. Thus to disambiguate\n+/// we also keep track of whether there's an adjustment in\n+/// our key.\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct MethodCall {\n     pub expr_id: ast::NodeId,"}, {"sha": "745e6332918adc725df806fdcd9552ed4f8b0db7", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 22, "deletions": 32, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -219,18 +219,16 @@ pub fn infer_variance(tcx: &ty::ctxt) {\n     tcx.variance_computed.set(true);\n }\n \n-/**************************************************************************\n- * Representing terms\n- *\n- * Terms are structured as a straightforward tree. Rather than rely on\n- * GC, we allocate terms out of a bounded arena (the lifetime of this\n- * arena is the lifetime 'a that is threaded around).\n- *\n- * We assign a unique index to each type/region parameter whose variance\n- * is to be inferred. We refer to such variables as \"inferreds\". An\n- * `InferredIndex` is a newtype'd int representing the index of such\n- * a variable.\n- */\n+// Representing terms\n+//\n+// Terms are structured as a straightforward tree. Rather than rely on\n+// GC, we allocate terms out of a bounded arena (the lifetime of this\n+// arena is the lifetime 'a that is threaded around).\n+//\n+// We assign a unique index to each type/region parameter whose variance\n+// is to be inferred. We refer to such variables as \"inferreds\". An\n+// `InferredIndex` is a newtype'd int representing the index of such\n+// a variable.\n \n type VarianceTermPtr<'a> = &'a VarianceTerm<'a>;\n \n@@ -253,9 +251,7 @@ impl<'a> fmt::Show for VarianceTerm<'a> {\n     }\n }\n \n-/**************************************************************************\n- * The first pass over the crate simply builds up the set of inferreds.\n- */\n+// The first pass over the crate simply builds up the set of inferreds.\n \n struct TermsContext<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n@@ -399,12 +395,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for TermsContext<'a, 'tcx> {\n     }\n }\n \n-/**************************************************************************\n- * Constraint construction and representation\n- *\n- * The second pass over the AST determines the set of constraints.\n- * We walk the set of items and, for each member, generate new constraints.\n- */\n+// Constraint construction and representation\n+//\n+// The second pass over the AST determines the set of constraints.\n+// We walk the set of items and, for each member, generate new constraints.\n \n struct ConstraintContext<'a, 'tcx: 'a> {\n     terms_cx: TermsContext<'a, 'tcx>,\n@@ -944,14 +938,12 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     }\n }\n \n-/**************************************************************************\n- * Constraint solving\n- *\n- * The final phase iterates over the constraints, refining the variance\n- * for each inferred until a fixed point is reached. This will be the\n- * optimal solution to the constraints. The final variance for each\n- * inferred is then written into the `variance_map` in the tcx.\n- */\n+// Constraint solving\n+//\n+// The final phase iterates over the constraints, refining the variance\n+// for each inferred until a fixed point is reached. This will be the\n+// optimal solution to the constraints. The final variance for each\n+// inferred is then written into the `variance_map` in the tcx.\n \n struct SolveContext<'a, 'tcx: 'a> {\n     terms_cx: TermsContext<'a, 'tcx>,\n@@ -1086,9 +1078,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n     }\n }\n \n-/**************************************************************************\n- * Miscellany transformations on variance\n- */\n+// Miscellany transformations on variance\n \n trait Xform {\n     fn xform(self, v: Self) -> Self;"}, {"sha": "f6c2694dd2321b9fd7b824dd36a54ab14450da5a", "filename": "src/librustc/util/snapshot_vec.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -177,10 +177,8 @@ impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n         assert!(self.undo_log.len() == snapshot.length);\n     }\n \n-    /**\n-     * Commits all changes since the last snapshot. Of course, they\n-     * can still be undone if there is a snapshot further out.\n-     */\n+    /// Commits all changes since the last snapshot. Of course, they\n+    /// can still be undone if there is a snapshot further out.\n     pub fn commit(&mut self, snapshot: Snapshot) {\n         debug!(\"commit({})\", snapshot.length);\n "}, {"sha": "23726664e3c6beb0473b6de9639967196afc332a", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 39, "deletions": 43, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -520,24 +520,24 @@ extern {\n     pub fn LLVMGetModuleContext(M: ModuleRef) -> ContextRef;\n     pub fn LLVMDisposeModule(M: ModuleRef);\n \n-    /** Data layout. See Module::getDataLayout. */\n+    /// Data layout. See Module::getDataLayout.\n     pub fn LLVMGetDataLayout(M: ModuleRef) -> *const c_char;\n     pub fn LLVMSetDataLayout(M: ModuleRef, Triple: *const c_char);\n \n-    /** Target triple. See Module::getTargetTriple. */\n+    /// Target triple. See Module::getTargetTriple.\n     pub fn LLVMGetTarget(M: ModuleRef) -> *const c_char;\n     pub fn LLVMSetTarget(M: ModuleRef, Triple: *const c_char);\n \n-    /** See Module::dump. */\n+    /// See Module::dump.\n     pub fn LLVMDumpModule(M: ModuleRef);\n \n-    /** See Module::setModuleInlineAsm. */\n+    /// See Module::setModuleInlineAsm.\n     pub fn LLVMSetModuleInlineAsm(M: ModuleRef, Asm: *const c_char);\n \n-    /** See llvm::LLVMTypeKind::getTypeID. */\n+    /// See llvm::LLVMTypeKind::getTypeID.\n     pub fn LLVMGetTypeKind(Ty: TypeRef) -> TypeKind;\n \n-    /** See llvm::LLVMType::getContext. */\n+    /// See llvm::LLVMType::getContext.\n     pub fn LLVMGetTypeContext(Ty: TypeRef) -> ContextRef;\n \n     /* Operations on integer types */\n@@ -1460,30 +1460,29 @@ extern {\n     pub fn LLVMIsATerminatorInst(Inst: ValueRef) -> ValueRef;\n     pub fn LLVMIsAStoreInst(Inst: ValueRef) -> ValueRef;\n \n-    /** Writes a module to the specified path. Returns 0 on success. */\n+    /// Writes a module to the specified path. Returns 0 on success.\n     pub fn LLVMWriteBitcodeToFile(M: ModuleRef, Path: *const c_char) -> c_int;\n \n-    /** Creates target data from a target layout string. */\n+    /// Creates target data from a target layout string.\n     pub fn LLVMCreateTargetData(StringRep: *const c_char) -> TargetDataRef;\n     /// Adds the target data to the given pass manager. The pass manager\n     /// references the target data only weakly.\n     pub fn LLVMAddTargetData(TD: TargetDataRef, PM: PassManagerRef);\n-    /** Number of bytes clobbered when doing a Store to *T. */\n+    /// Number of bytes clobbered when doing a Store to *T.\n     pub fn LLVMStoreSizeOfType(TD: TargetDataRef, Ty: TypeRef)\n                                -> c_ulonglong;\n \n-    /** Number of bytes clobbered when doing a Store to *T. */\n+    /// Number of bytes clobbered when doing a Store to *T.\n     pub fn LLVMSizeOfTypeInBits(TD: TargetDataRef, Ty: TypeRef)\n                                 -> c_ulonglong;\n \n-    /** Distance between successive elements in an array of T.\n-    Includes ABI padding. */\n+    /// Distance between successive elements in an array of T. Includes ABI padding.\n     pub fn LLVMABISizeOfType(TD: TargetDataRef, Ty: TypeRef) -> c_ulonglong;\n \n-    /** Returns the preferred alignment of a type. */\n+    /// Returns the preferred alignment of a type.\n     pub fn LLVMPreferredAlignmentOfType(TD: TargetDataRef, Ty: TypeRef)\n                                         -> c_uint;\n-    /** Returns the minimum alignment of a type. */\n+    /// Returns the minimum alignment of a type.\n     pub fn LLVMABIAlignmentOfType(TD: TargetDataRef, Ty: TypeRef)\n                                   -> c_uint;\n \n@@ -1494,41 +1493,39 @@ extern {\n                                Element: c_uint)\n                                -> c_ulonglong;\n \n-    /**\n-     * Returns the minimum alignment of a type when part of a call frame.\n-     */\n+    /// Returns the minimum alignment of a type when part of a call frame.\n     pub fn LLVMCallFrameAlignmentOfType(TD: TargetDataRef, Ty: TypeRef)\n                                         -> c_uint;\n \n-    /** Disposes target data. */\n+    /// Disposes target data.\n     pub fn LLVMDisposeTargetData(TD: TargetDataRef);\n \n-    /** Creates a pass manager. */\n+    /// Creates a pass manager.\n     pub fn LLVMCreatePassManager() -> PassManagerRef;\n \n-    /** Creates a function-by-function pass manager */\n+    /// Creates a function-by-function pass manager\n     pub fn LLVMCreateFunctionPassManagerForModule(M: ModuleRef)\n                                                   -> PassManagerRef;\n \n-    /** Disposes a pass manager. */\n+    /// Disposes a pass manager.\n     pub fn LLVMDisposePassManager(PM: PassManagerRef);\n \n-    /** Runs a pass manager on a module. */\n+    /// Runs a pass manager on a module.\n     pub fn LLVMRunPassManager(PM: PassManagerRef, M: ModuleRef) -> Bool;\n \n-    /** Runs the function passes on the provided function. */\n+    /// Runs the function passes on the provided function.\n     pub fn LLVMRunFunctionPassManager(FPM: PassManagerRef, F: ValueRef)\n                                       -> Bool;\n \n-    /** Initializes all the function passes scheduled in the manager */\n+    /// Initializes all the function passes scheduled in the manager\n     pub fn LLVMInitializeFunctionPassManager(FPM: PassManagerRef) -> Bool;\n \n-    /** Finalizes all the function passes scheduled in the manager */\n+    /// Finalizes all the function passes scheduled in the manager\n     pub fn LLVMFinalizeFunctionPassManager(FPM: PassManagerRef) -> Bool;\n \n     pub fn LLVMInitializePasses();\n \n-    /** Adds a verification pass. */\n+    /// Adds a verification pass.\n     pub fn LLVMAddVerifierPass(PM: PassManagerRef);\n \n     pub fn LLVMAddGlobalOptimizerPass(PM: PassManagerRef);\n@@ -1598,38 +1595,38 @@ extern {\n         Internalize: Bool,\n         RunInliner: Bool);\n \n-    /** Destroys a memory buffer. */\n+    /// Destroys a memory buffer.\n     pub fn LLVMDisposeMemoryBuffer(MemBuf: MemoryBufferRef);\n \n \n     /* Stuff that's in rustllvm/ because it's not upstream yet. */\n \n-    /** Opens an object file. */\n+    /// Opens an object file.\n     pub fn LLVMCreateObjectFile(MemBuf: MemoryBufferRef) -> ObjectFileRef;\n-    /** Closes an object file. */\n+    /// Closes an object file.\n     pub fn LLVMDisposeObjectFile(ObjFile: ObjectFileRef);\n \n-    /** Enumerates the sections in an object file. */\n+    /// Enumerates the sections in an object file.\n     pub fn LLVMGetSections(ObjFile: ObjectFileRef) -> SectionIteratorRef;\n-    /** Destroys a section iterator. */\n+    /// Destroys a section iterator.\n     pub fn LLVMDisposeSectionIterator(SI: SectionIteratorRef);\n-    /** Returns true if the section iterator is at the end of the section\n-    list: */\n+    /// Returns true if the section iterator is at the end of the section\n+    /// list:\n     pub fn LLVMIsSectionIteratorAtEnd(ObjFile: ObjectFileRef,\n                                       SI: SectionIteratorRef)\n                                       -> Bool;\n-    /** Moves the section iterator to point to the next section. */\n+    /// Moves the section iterator to point to the next section.\n     pub fn LLVMMoveToNextSection(SI: SectionIteratorRef);\n-    /** Returns the current section size. */\n+    /// Returns the current section size.\n     pub fn LLVMGetSectionSize(SI: SectionIteratorRef) -> c_ulonglong;\n-    /** Returns the current section contents as a string buffer. */\n+    /// Returns the current section contents as a string buffer.\n     pub fn LLVMGetSectionContents(SI: SectionIteratorRef) -> *const c_char;\n \n-    /** Reads the given file and returns it as a memory buffer. Use\n-    LLVMDisposeMemoryBuffer() to get rid of it. */\n+    /// Reads the given file and returns it as a memory buffer. Use\n+    /// LLVMDisposeMemoryBuffer() to get rid of it.\n     pub fn LLVMRustCreateMemoryBufferWithContentsOfFile(Path: *const c_char)\n                                                         -> MemoryBufferRef;\n-    /** Borrows the contents of the memory buffer (doesn't copy it) */\n+    /// Borrows the contents of the memory buffer (doesn't copy it)\n     pub fn LLVMCreateMemoryBufferWithMemoryRange(InputData: *const c_char,\n                                                  InputDataLength: size_t,\n                                                  BufferName: *const c_char,\n@@ -1643,8 +1640,7 @@ extern {\n     pub fn LLVMIsMultithreaded() -> Bool;\n     pub fn LLVMStartMultithreaded() -> Bool;\n \n-    /** Returns a string describing the last error caused by an LLVMRust*\n-    call. */\n+    /// Returns a string describing the last error caused by an LLVMRust* call.\n     pub fn LLVMRustGetLastError() -> *const c_char;\n \n     /// Print the pass timings since static dtors aren't picking them up.\n@@ -1662,10 +1658,10 @@ extern {\n                                 Count: c_uint)\n                                 -> ValueRef;\n \n-    /** Enables LLVM debug output. */\n+    /// Enables LLVM debug output.\n     pub fn LLVMSetDebug(Enabled: c_int);\n \n-    /** Prepares inline assembly. */\n+    /// Prepares inline assembly.\n     pub fn LLVMInlineAsm(Ty: TypeRef,\n                          AsmString: *const c_char,\n                          Constraints: *const c_char,"}, {"sha": "a5709a0219ba99cc91a342b4f51dc1020dc8fcdf", "filename": "src/librustc_trans/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc_trans%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc_trans%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdriver%2Fdriver.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -98,10 +98,8 @@ pub fn compile_input(sess: Session,\n     phase_6_link_output(&sess, &trans, &outputs);\n }\n \n-/**\n- * The name used for source code that doesn't originate in a file\n- * (e.g. source from stdin or a string)\n- */\n+/// The name used for source code that doesn't originate in a file\n+/// (e.g. source from stdin or a string)\n pub fn anon_src() -> String {\n     \"<anon>\".to_string()\n }"}, {"sha": "fcbe40acafc5282191bff158239b6ce86c6a2ed2", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -325,15 +325,14 @@ pub enum TransBindingMode {\n     TrByRef,\n }\n \n-/**\n- * Information about a pattern binding:\n- * - `llmatch` is a pointer to a stack slot.  The stack slot contains a\n- *   pointer into the value being matched.  Hence, llmatch has type `T**`\n- *   where `T` is the value being matched.\n- * - `trmode` is the trans binding mode\n- * - `id` is the node id of the binding\n- * - `ty` is the Rust type of the binding */\n- #[deriving(Clone)]\n+/// Information about a pattern binding:\n+/// - `llmatch` is a pointer to a stack slot.  The stack slot contains a\n+///   pointer into the value being matched.  Hence, llmatch has type `T**`\n+///   where `T` is the value being matched.\n+/// - `trmode` is the trans binding mode\n+/// - `id` is the node id of the binding\n+/// - `ty` is the Rust type of the binding\n+#[deriving(Clone)]\n pub struct BindingInfo<'tcx> {\n     pub llmatch: ValueRef,\n     pub trmode: TransBindingMode,\n@@ -350,12 +349,10 @@ struct ArmData<'p, 'blk, 'tcx: 'blk> {\n     bindings_map: BindingsMap<'tcx>\n }\n \n-/**\n- * Info about Match.\n- * If all `pats` are matched then arm `data` will be executed.\n- * As we proceed `bound_ptrs` are filled with pointers to values to be bound,\n- * these pointers are stored in llmatch variables just before executing `data` arm.\n- */\n+/// Info about Match.\n+/// If all `pats` are matched then arm `data` will be executed.\n+/// As we proceed `bound_ptrs` are filled with pointers to values to be bound,\n+/// these pointers are stored in llmatch variables just before executing `data` arm.\n struct Match<'a, 'p: 'a, 'blk: 'a, 'tcx: 'blk> {\n     pats: Vec<&'p ast::Pat>,\n     data: &'a ArmData<'p, 'blk, 'tcx>,"}, {"sha": "e2ce6ee41ee89f020ef3fa4277f7baff0940fa59", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 81, "deletions": 109, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -79,46 +79,38 @@ type Hint = attr::ReprAttr;\n pub enum Repr<'tcx> {\n     /// C-like enums; basically an int.\n     CEnum(IntType, Disr, Disr), // discriminant range (signedness based on the IntType)\n-    /**\n-     * Single-case variants, and structs/tuples/records.\n-     *\n-     * Structs with destructors need a dynamic destroyedness flag to\n-     * avoid running the destructor too many times; this is included\n-     * in the `Struct` if present.\n-     */\n+    /// Single-case variants, and structs/tuples/records.\n+    ///\n+    /// Structs with destructors need a dynamic destroyedness flag to\n+    /// avoid running the destructor too many times; this is included\n+    /// in the `Struct` if present.\n     Univariant(Struct<'tcx>, bool),\n-    /**\n-     * General-case enums: for each case there is a struct, and they\n-     * all start with a field for the discriminant.\n-     *\n-     * Types with destructors need a dynamic destroyedness flag to\n-     * avoid running the destructor too many times; the last argument\n-     * indicates whether such a flag is present.\n-     */\n+    /// General-case enums: for each case there is a struct, and they\n+    /// all start with a field for the discriminant.\n+    ///\n+    /// Types with destructors need a dynamic destroyedness flag to\n+    /// avoid running the destructor too many times; the last argument\n+    /// indicates whether such a flag is present.\n     General(IntType, Vec<Struct<'tcx>>, bool),\n-    /**\n-     * Two cases distinguished by a nullable pointer: the case with discriminant\n-     * `nndiscr` must have single field which is known to be nonnull due to its type.\n-     * The other case is known to be zero sized. Hence we represent the enum\n-     * as simply a nullable pointer: if not null it indicates the `nndiscr` variant,\n-     * otherwise it indicates the other case.\n-     */\n+    /// Two cases distinguished by a nullable pointer: the case with discriminant\n+    /// `nndiscr` must have single field which is known to be nonnull due to its type.\n+    /// The other case is known to be zero sized. Hence we represent the enum\n+    /// as simply a nullable pointer: if not null it indicates the `nndiscr` variant,\n+    /// otherwise it indicates the other case.\n     RawNullablePointer {\n         nndiscr: Disr,\n         nnty: Ty<'tcx>,\n         nullfields: Vec<Ty<'tcx>>\n     },\n-    /**\n-     * Two cases distinguished by a nullable pointer: the case with discriminant\n-     * `nndiscr` is represented by the struct `nonnull`, where the `ptrfield`th\n-     * field is known to be nonnull due to its type; if that field is null, then\n-     * it represents the other case, which is inhabited by at most one value\n-     * (and all other fields are undefined/unused).\n-     *\n-     * For example, `std::option::Option` instantiated at a safe pointer type\n-     * is represented such that `None` is a null pointer and `Some` is the\n-     * identity function.\n-     */\n+    /// Two cases distinguished by a nullable pointer: the case with discriminant\n+    /// `nndiscr` is represented by the struct `nonnull`, where the `ptrfield`th\n+    /// field is known to be nonnull due to its type; if that field is null, then\n+    /// it represents the other case, which is inhabited by at most one value\n+    /// (and all other fields are undefined/unused).\n+    ///\n+    /// For example, `std::option::Option` instantiated at a safe pointer type\n+    /// is represented such that `None` is a null pointer and `Some` is the\n+    /// identity function.\n     StructWrappedNullablePointer {\n         nonnull: Struct<'tcx>,\n         nndiscr: Disr,\n@@ -139,11 +131,9 @@ pub struct Struct<'tcx> {\n     pub fields: Vec<Ty<'tcx>>\n }\n \n-/**\n- * Convenience for `represent_type`.  There should probably be more or\n- * these, for places in trans where the `Ty` isn't directly\n- * available.\n- */\n+/// Convenience for `represent_type`.  There should probably be more or\n+/// these, for places in trans where the `Ty` isn't directly\n+/// available.\n pub fn represent_node<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                   node: ast::NodeId) -> Rc<Repr<'tcx>> {\n     represent_type(bcx.ccx(), node_id_type(bcx, node))\n@@ -514,16 +504,14 @@ fn ensure_enum_fits_in_address_space<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n }\n \n \n-/**\n- * LLVM-level types are a little complicated.\n- *\n- * C-like enums need to be actual ints, not wrapped in a struct,\n- * because that changes the ABI on some platforms (see issue #10308).\n- *\n- * For nominal types, in some cases, we need to use LLVM named structs\n- * and fill in the actual contents in a second pass to prevent\n- * unbounded recursion; see also the comments in `trans::type_of`.\n- */\n+/// LLVM-level types are a little complicated.\n+///\n+/// C-like enums need to be actual ints, not wrapped in a struct,\n+/// because that changes the ABI on some platforms (see issue #10308).\n+///\n+/// For nominal types, in some cases, we need to use LLVM named structs\n+/// and fill in the actual contents in a second pass to prevent\n+/// unbounded recursion; see also the comments in `trans::type_of`.\n pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>) -> Type {\n     generic_type_of(cx, r, None, false, false)\n }\n@@ -620,12 +608,10 @@ fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, st: &Struct<'tcx>,\n     }\n }\n \n-/**\n- * Obtain a representation of the discriminant sufficient to translate\n- * destructuring; this may or may not involve the actual discriminant.\n- *\n- * This should ideally be less tightly tied to `_match`.\n- */\n+/// Obtain a representation of the discriminant sufficient to translate\n+/// destructuring; this may or may not involve the actual discriminant.\n+///\n+/// This should ideally be less tightly tied to `_match`.\n pub fn trans_switch<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                 r: &Repr<'tcx>, scrutinee: ValueRef)\n                                 -> (_match::BranchKind, Option<ValueRef>) {\n@@ -713,12 +699,10 @@ fn load_discr(bcx: Block, ity: IntType, ptr: ValueRef, min: Disr, max: Disr)\n     }\n }\n \n-/**\n- * Yield information about how to dispatch a case of the\n- * discriminant-like value returned by `trans_switch`.\n- *\n- * This should ideally be less tightly tied to `_match`.\n- */\n+/// Yield information about how to dispatch a case of the\n+/// discriminant-like value returned by `trans_switch`.\n+///\n+/// This should ideally be less tightly tied to `_match`.\n pub fn trans_case<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr, discr: Disr)\n                               -> _match::OptResult<'blk, 'tcx> {\n     match *r {\n@@ -741,10 +725,8 @@ pub fn trans_case<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr, discr: Disr)\n     }\n }\n \n-/**\n- * Set the discriminant for a new value of the given case of the given\n- * representation.\n- */\n+/// Set the discriminant for a new value of the given case of the given\n+/// representation.\n pub fn trans_set_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n                                    val: ValueRef, discr: Disr) {\n     match *r {\n@@ -799,10 +781,8 @@ fn assert_discr_in_range(ity: IntType, min: Disr, max: Disr, discr: Disr) {\n     }\n }\n \n-/**\n- * The number of fields in a given case; for use when obtaining this\n- * information from the type or definition is less convenient.\n- */\n+/// The number of fields in a given case; for use when obtaining this\n+/// information from the type or definition is less convenient.\n pub fn num_args(r: &Repr, discr: Disr) -> uint {\n     match *r {\n         CEnum(..) => 0,\n@@ -946,27 +926,25 @@ pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, r: &Repr<'tcx\n     }\n }\n \n-/**\n- * Construct a constant value, suitable for initializing a\n- * GlobalVariable, given a case and constant values for its fields.\n- * Note that this may have a different LLVM type (and different\n- * alignment!) from the representation's `type_of`, so it needs a\n- * pointer cast before use.\n- *\n- * The LLVM type system does not directly support unions, and only\n- * pointers can be bitcast, so a constant (and, by extension, the\n- * GlobalVariable initialized by it) will have a type that can vary\n- * depending on which case of an enum it is.\n- *\n- * To understand the alignment situation, consider `enum E { V64(u64),\n- * V32(u32, u32) }` on Windows.  The type has 8-byte alignment to\n- * accommodate the u64, but `V32(x, y)` would have LLVM type `{i32,\n- * i32, i32}`, which is 4-byte aligned.\n- *\n- * Currently the returned value has the same size as the type, but\n- * this could be changed in the future to avoid allocating unnecessary\n- * space after values of shorter-than-maximum cases.\n- */\n+/// Construct a constant value, suitable for initializing a\n+/// GlobalVariable, given a case and constant values for its fields.\n+/// Note that this may have a different LLVM type (and different\n+/// alignment!) from the representation's `type_of`, so it needs a\n+/// pointer cast before use.\n+///\n+/// The LLVM type system does not directly support unions, and only\n+/// pointers can be bitcast, so a constant (and, by extension, the\n+/// GlobalVariable initialized by it) will have a type that can vary\n+/// depending on which case of an enum it is.\n+///\n+/// To understand the alignment situation, consider `enum E { V64(u64),\n+/// V32(u32, u32) }` on Windows.  The type has 8-byte alignment to\n+/// accommodate the u64, but `V32(x, y)` would have LLVM type `{i32,\n+/// i32, i32}`, which is 4-byte aligned.\n+///\n+/// Currently the returned value has the same size as the type, but\n+/// this could be changed in the future to avoid allocating unnecessary\n+/// space after values of shorter-than-maximum cases.\n pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr: Disr,\n                              vals: &[ValueRef]) -> ValueRef {\n     match *r {\n@@ -1019,9 +997,7 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n     }\n }\n \n-/**\n- * Compute struct field offsets relative to struct begin.\n- */\n+/// Compute struct field offsets relative to struct begin.\n fn compute_struct_field_offsets<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                           st: &Struct<'tcx>) -> Vec<u64> {\n     let mut offsets = vec!();\n@@ -1040,16 +1016,14 @@ fn compute_struct_field_offsets<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     offsets\n }\n \n-/**\n- * Building structs is a little complicated, because we might need to\n- * insert padding if a field's value is less aligned than its type.\n- *\n- * Continuing the example from `trans_const`, a value of type `(u32,\n- * E)` should have the `E` at offset 8, but if that field's\n- * initializer is 4-byte aligned then simply translating the tuple as\n- * a two-element struct will locate it at offset 4, and accesses to it\n- * will read the wrong memory.\n- */\n+/// Building structs is a little complicated, because we might need to\n+/// insert padding if a field's value is less aligned than its type.\n+///\n+/// Continuing the example from `trans_const`, a value of type `(u32,\n+/// E)` should have the `E` at offset 8, but if that field's\n+/// initializer is 4-byte aligned then simply translating the tuple as\n+/// a two-element struct will locate it at offset 4, and accesses to it\n+/// will read the wrong memory.\n fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 st: &Struct<'tcx>, vals: &[ValueRef])\n                                 -> Vec<ValueRef> {\n@@ -1130,13 +1104,11 @@ pub fn const_get_discrim(ccx: &CrateContext, r: &Repr, val: ValueRef)\n     }\n }\n \n-/**\n- * Extract a field of a constant value, as appropriate for its\n- * representation.\n- *\n- * (Not to be confused with `common::const_get_elt`, which operates on\n- * raw LLVM-level structs and arrays.)\n- */\n+/// Extract a field of a constant value, as appropriate for its\n+/// representation.\n+///\n+/// (Not to be confused with `common::const_get_elt`, which operates on\n+/// raw LLVM-level structs and arrays.)\n pub fn const_get_field(ccx: &CrateContext, r: &Repr, val: ValueRef,\n                        _discr: Disr, ix: uint) -> ValueRef {\n     match *r {"}, {"sha": "328c8e616c40b945d6aef7dbfbbebb633b429fd4", "filename": "src/librustc_trans/trans/basic_block.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc_trans%2Ftrans%2Fbasic_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc_trans%2Ftrans%2Fbasic_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbasic_block.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -17,9 +17,7 @@ pub struct BasicBlock(pub BasicBlockRef);\n \n pub type Preds<'a> = Map<'a, Value, BasicBlock, Filter<'a, Value, Users>>;\n \n-/**\n- * Wrapper for LLVM BasicBlockRef\n- */\n+/// Wrapper for LLVM BasicBlockRef\n impl BasicBlock {\n     pub fn get(&self) -> BasicBlockRef {\n         let BasicBlock(v) = *self; v"}, {"sha": "de7924b27eab08852b3dcd385e52945331f57481", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 20, "deletions": 34, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -31,12 +31,10 @@ use util::ppaux::{ty_to_string};\n use std::fmt;\n use syntax::ast;\n \n-/**\n- * A `Datum` encapsulates the result of evaluating an expression.  It\n- * describes where the value is stored, what Rust type the value has,\n- * whether it is addressed by reference, and so forth. Please refer\n- * the section on datums in `doc.rs` for more details.\n- */\n+/// A `Datum` encapsulates the result of evaluating an expression.  It\n+/// describes where the value is stored, what Rust type the value has,\n+/// whether it is addressed by reference, and so forth. Please refer\n+/// the section on datums in `doc.rs` for more details.\n #[deriving(Clone)]\n pub struct Datum<'tcx, K> {\n     /// The llvm value.  This is either a pointer to the Rust value or\n@@ -190,25 +188,19 @@ fn add_rvalue_clean<'a, 'tcx>(mode: RvalueMode,\n \n pub trait KindOps {\n \n-    /**\n-     * Take appropriate action after the value in `datum` has been\n-     * stored to a new location.\n-     */\n+    /// Take appropriate action after the value in `datum` has been\n+    /// stored to a new location.\n     fn post_store<'blk, 'tcx>(&self,\n                               bcx: Block<'blk, 'tcx>,\n                               val: ValueRef,\n                               ty: Ty<'tcx>)\n                               -> Block<'blk, 'tcx>;\n \n-    /**\n-     * True if this mode is a reference mode, meaning that the datum's\n-     * val field is a pointer to the actual value\n-     */\n+    /// True if this mode is a reference mode, meaning that the datum's\n+    /// val field is a pointer to the actual value\n     fn is_by_ref(&self) -> bool;\n \n-    /**\n-     * Converts to an Expr kind\n-     */\n+    /// Converts to an Expr kind\n     fn to_expr_kind(self) -> Expr;\n \n }\n@@ -361,14 +353,12 @@ impl<'tcx> Datum<'tcx, Rvalue> {\n     }\n }\n \n-/**\n- * Methods suitable for \"expr\" datums that could be either lvalues or\n- * rvalues. These include coercions into lvalues/rvalues but also a number\n- * of more general operations. (Some of those operations could be moved to\n- * the more general `impl<K> Datum<K>`, but it's convenient to have them\n- * here since we can `match self.kind` rather than having to implement\n- * generic methods in `KindOps`.)\n- */\n+/// Methods suitable for \"expr\" datums that could be either lvalues or\n+/// rvalues. These include coercions into lvalues/rvalues but also a number\n+/// of more general operations. (Some of those operations could be moved to\n+/// the more general `impl<K> Datum<K>`, but it's convenient to have them\n+/// here since we can `match self.kind` rather than having to implement\n+/// generic methods in `KindOps`.)\n impl<'tcx> Datum<'tcx, Expr> {\n     fn match_kind<R>(self,\n                      if_lvalue: |Datum<'tcx, Lvalue>| -> R,\n@@ -494,12 +484,10 @@ impl<'tcx> Datum<'tcx, Expr> {\n \n }\n \n-/**\n- * Methods suitable only for lvalues. These include the various\n- * operations to extract components out of compound data structures,\n- * such as extracting the field from a struct or a particular element\n- * from an array.\n- */\n+/// Methods suitable only for lvalues. These include the various\n+/// operations to extract components out of compound data structures,\n+/// such as extracting the field from a struct or a particular element\n+/// from an array.\n impl<'tcx> Datum<'tcx, Lvalue> {\n     pub fn to_llref(self) -> ValueRef {\n         /*!\n@@ -542,9 +530,7 @@ impl<'tcx> Datum<'tcx, Lvalue> {\n     }\n }\n \n-/**\n- * Generic methods applicable to any sort of datum.\n- */\n+/// Generic methods applicable to any sort of datum.\n impl<'tcx, K: KindOps + fmt::Show> Datum<'tcx, K> {\n     pub fn new(val: ValueRef, ty: Ty<'tcx>, kind: K) -> Datum<'tcx, K> {\n         Datum { val: val, ty: ty, kind: kind }"}, {"sha": "b39029d3b94c5825fb2e591753a2d5c3dbf3d4ad", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -1377,31 +1377,27 @@ fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     })\n }\n \n-/**\n- * Information that `trans_adt` needs in order to fill in the fields\n- * of a struct copied from a base struct (e.g., from an expression\n- * like `Foo { a: b, ..base }`.\n- *\n- * Note that `fields` may be empty; the base expression must always be\n- * evaluated for side-effects.\n- */\n+/// Information that `trans_adt` needs in order to fill in the fields\n+/// of a struct copied from a base struct (e.g., from an expression\n+/// like `Foo { a: b, ..base }`.\n+///\n+/// Note that `fields` may be empty; the base expression must always be\n+/// evaluated for side-effects.\n pub struct StructBaseInfo<'a, 'tcx> {\n     /// The base expression; will be evaluated after all explicit fields.\n     expr: &'a ast::Expr,\n     /// The indices of fields to copy paired with their types.\n     fields: Vec<(uint, Ty<'tcx>)>\n }\n \n-/**\n- * Constructs an ADT instance:\n- *\n- * - `fields` should be a list of field indices paired with the\n- * expression to store into that field.  The initializers will be\n- * evaluated in the order specified by `fields`.\n- *\n- * - `optbase` contains information on the base struct (if any) from\n- * which remaining fields are copied; see comments on `StructBaseInfo`.\n- */\n+/// Constructs an ADT instance:\n+///\n+/// - `fields` should be a list of field indices paired with the\n+/// expression to store into that field.  The initializers will be\n+/// evaluated in the order specified by `fields`.\n+///\n+/// - `optbase` contains information on the base struct (if any) from\n+/// which remaining fields are copied; see comments on `StructBaseInfo`.\n pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                  ty: Ty<'tcx>,\n                                  discr: ty::Disr,"}, {"sha": "2c0e4d31d97d0e5c119a0dd2b4318081001748f7", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -46,12 +46,10 @@ use syntax::codemap::DUMMY_SP;\n // drop_glue pointer, size, align.\n static VTABLE_OFFSET: uint = 3;\n \n-/**\n-The main \"translation\" pass for methods.  Generates code\n-for non-monomorphized methods only.  Other methods will\n-be generated once they are invoked with specific type parameters,\n-see `trans::base::lval_static_fn()` or `trans::base::monomorphic_fn()`.\n-*/\n+/// The main \"translation\" pass for methods.  Generates code\n+/// for non-monomorphized methods only.  Other methods will\n+/// be generated once they are invoked with specific type parameters,\n+/// see `trans::base::lval_static_fn()` or `trans::base::monomorphic_fn()`.\n pub fn trans_impl(ccx: &CrateContext,\n                   name: ast::Ident,\n                   impl_items: &[ast::ImplItem],"}, {"sha": "8bff7602ddcead23ee8db815f8d61ec9db24b999", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -35,9 +35,7 @@ macro_rules! ty (\n     ($e:expr) => ( Type::from_ref(unsafe { $e }))\n )\n \n-/**\n- * Wrapper for LLVM TypeRef\n- */\n+/// Wrapper for LLVM TypeRef\n impl Type {\n     #[inline(always)]\n     pub fn from_ref(r: TypeRef) -> Type {"}, {"sha": "33ea239412af664401d44c47031aedfc0bf9a804", "filename": "src/librustc_trans/trans/value.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc_trans%2Ftrans%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibrustc_trans%2Ftrans%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fvalue.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -25,9 +25,7 @@ macro_rules! opt_val ( ($e:expr) => (\n     }\n ))\n \n-/**\n- * Wrapper for LLVM ValueRef\n- */\n+/// Wrapper for LLVM ValueRef\n impl Value {\n     /// Returns the native ValueRef\n     pub fn get(&self) -> ValueRef {\n@@ -127,9 +125,7 @@ impl Value {\n \n pub struct Use(UseRef);\n \n-/**\n- * Wrapper for LLVM UseRef\n- */\n+/// Wrapper for LLVM UseRef\n impl Use {\n     pub fn get(&self) -> UseRef {\n         let Use(v) = *self; v"}, {"sha": "b7d8885a5f99313406af29bb65b8d8f999ac2b39", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 39, "deletions": 43, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -64,21 +64,19 @@ pub trait ToBase64 for Sized? {\n }\n \n impl ToBase64 for [u8] {\n-    /**\n-     * Turn a vector of `u8` bytes into a base64 string.\n-     *\n-     * # Example\n-     *\n-     * ```rust\n-     * extern crate serialize;\n-     * use serialize::base64::{ToBase64, STANDARD};\n-     *\n-     * fn main () {\n-     *     let str = [52,32].to_base64(STANDARD);\n-     *     println!(\"base 64 output: {}\", str);\n-     * }\n-     * ```\n-     */\n+    /// Turn a vector of `u8` bytes into a base64 string.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// extern crate serialize;\n+    /// use serialize::base64::{ToBase64, STANDARD};\n+    ///\n+    /// fn main () {\n+    ///     let str = [52,32].to_base64(STANDARD);\n+    ///     println!(\"base 64 output: {}\", str);\n+    /// }\n+    /// ```\n     fn to_base64(&self, config: Config) -> String {\n         let bytes = match config.char_set {\n             Standard => STANDARD_CHARS,\n@@ -194,34 +192,32 @@ impl error::Error for FromBase64Error {\n }\n \n impl FromBase64 for str {\n-    /**\n-     * Convert any base64 encoded string (literal, `@`, `&`, or `~`)\n-     * to the byte values it encodes.\n-     *\n-     * You can use the `String::from_utf8` function to turn a `Vec<u8>` into a\n-     * string with characters corresponding to those values.\n-     *\n-     * # Example\n-     *\n-     * This converts a string literal to base64 and back.\n-     *\n-     * ```rust\n-     * extern crate serialize;\n-     * use serialize::base64::{ToBase64, FromBase64, STANDARD};\n-     *\n-     * fn main () {\n-     *     let hello_str = b\"Hello, World\".to_base64(STANDARD);\n-     *     println!(\"base64 output: {}\", hello_str);\n-     *     let res = hello_str.as_slice().from_base64();\n-     *     if res.is_ok() {\n-     *       let opt_bytes = String::from_utf8(res.unwrap());\n-     *       if opt_bytes.is_ok() {\n-     *         println!(\"decoded from base64: {}\", opt_bytes.unwrap());\n-     *       }\n-     *     }\n-     * }\n-     * ```\n-     */\n+    /// Convert any base64 encoded string (literal, `@`, `&`, or `~`)\n+    /// to the byte values it encodes.\n+    ///\n+    /// You can use the `String::from_utf8` function to turn a `Vec<u8>` into a\n+    /// string with characters corresponding to those values.\n+    ///\n+    /// # Example\n+    ///\n+    /// This converts a string literal to base64 and back.\n+    ///\n+    /// ```rust\n+    /// extern crate serialize;\n+    /// use serialize::base64::{ToBase64, FromBase64, STANDARD};\n+    ///\n+    /// fn main () {\n+    ///     let hello_str = b\"Hello, World\".to_base64(STANDARD);\n+    ///     println!(\"base64 output: {}\", hello_str);\n+    ///     let res = hello_str.as_slice().from_base64();\n+    ///     if res.is_ok() {\n+    ///       let opt_bytes = String::from_utf8(res.unwrap());\n+    ///       if opt_bytes.is_ok() {\n+    ///         println!(\"decoded from base64: {}\", opt_bytes.unwrap());\n+    ///       }\n+    ///     }\n+    /// }\n+    /// ```\n     #[inline]\n     fn from_base64(&self) -> Result<Vec<u8>, FromBase64Error> {\n         self.as_bytes().from_base64()"}, {"sha": "2a3c410ba7c589912c5bd797377552bf7527b5b3", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 36, "deletions": 40, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -27,21 +27,19 @@ pub trait ToHex for Sized? {\n static CHARS: &'static[u8] = b\"0123456789abcdef\";\n \n impl ToHex for [u8] {\n-    /**\n-     * Turn a vector of `u8` bytes into a hexadecimal string.\n-     *\n-     * # Example\n-     *\n-     * ```rust\n-     * extern crate serialize;\n-     * use serialize::hex::ToHex;\n-     *\n-     * fn main () {\n-     *     let str = [52,32].to_hex();\n-     *     println!(\"{}\", str);\n-     * }\n-     * ```\n-     */\n+    /// Turn a vector of `u8` bytes into a hexadecimal string.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// extern crate serialize;\n+    /// use serialize::hex::ToHex;\n+    ///\n+    /// fn main () {\n+    ///     let str = [52,32].to_hex();\n+    ///     println!(\"{}\", str);\n+    /// }\n+    /// ```\n     fn to_hex(&self) -> String {\n         let mut v = Vec::with_capacity(self.len() * 2);\n         for &byte in self.iter() {\n@@ -95,31 +93,29 @@ impl error::Error for FromHexError {\n \n \n impl FromHex for str {\n-    /**\n-     * Convert any hexadecimal encoded string (literal, `@`, `&`, or `~`)\n-     * to the byte values it encodes.\n-     *\n-     * You can use the `String::from_utf8` function to turn a\n-     * `Vec<u8>` into a string with characters corresponding to those values.\n-     *\n-     * # Example\n-     *\n-     * This converts a string literal to hexadecimal and back.\n-     *\n-     * ```rust\n-     * extern crate serialize;\n-     * use serialize::hex::{FromHex, ToHex};\n-     *\n-     * fn main () {\n-     *     let hello_str = \"Hello, World\".as_bytes().to_hex();\n-     *     println!(\"{}\", hello_str);\n-     *     let bytes = hello_str.as_slice().from_hex().unwrap();\n-     *     println!(\"{}\", bytes);\n-     *     let result_str = String::from_utf8(bytes).unwrap();\n-     *     println!(\"{}\", result_str);\n-     * }\n-     * ```\n-     */\n+    /// Convert any hexadecimal encoded string (literal, `@`, `&`, or `~`)\n+    /// to the byte values it encodes.\n+    ///\n+    /// You can use the `String::from_utf8` function to turn a\n+    /// `Vec<u8>` into a string with characters corresponding to those values.\n+    ///\n+    /// # Example\n+    ///\n+    /// This converts a string literal to hexadecimal and back.\n+    ///\n+    /// ```rust\n+    /// extern crate serialize;\n+    /// use serialize::hex::{FromHex, ToHex};\n+    ///\n+    /// fn main () {\n+    ///     let hello_str = \"Hello, World\".as_bytes().to_hex();\n+    ///     println!(\"{}\", hello_str);\n+    ///     let bytes = hello_str.as_slice().from_hex().unwrap();\n+    ///     println!(\"{}\", bytes);\n+    ///     let result_str = String::from_utf8(bytes).unwrap();\n+    ///     println!(\"{}\", result_str);\n+    /// }\n+    /// ```\n     fn from_hex(&self) -> Result<Vec<u8>, FromHexError> {\n         // This may be an overestimate if there is any whitespace\n         let mut b = Vec::with_capacity(self.len() / 2);"}, {"sha": "be6e387ad836d318e52412dd3d1954769f29d428", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -67,31 +67,32 @@ pub enum SignFormat {\n     SignAll,\n }\n \n-/**\n- * Converts an integral number to its string representation as a byte vector.\n- * This is meant to be a common base implementation for all integral string\n- * conversion functions like `to_string()` or `to_str_radix()`.\n- *\n- * # Arguments\n- * - `num`           - The number to convert. Accepts any number that\n- *                     implements the numeric traits.\n- * - `radix`         - Base to use. Accepts only the values 2-36.\n- * - `sign`          - How to emit the sign. Options are:\n- *     - `SignNone`: No sign at all. Basically emits `abs(num)`.\n- *     - `SignNeg`:  Only `-` on negative values.\n- *     - `SignAll`:  Both `+` on positive, and `-` on negative numbers.\n- * - `f`             - a callback which will be invoked for each ascii character\n- *                     which composes the string representation of this integer\n- *\n- * # Return value\n- * A tuple containing the byte vector, and a boolean flag indicating\n- * whether it represents a special value like `inf`, `-inf`, `NaN` or not.\n- * It returns a tuple because there can be ambiguity between a special value\n- * and a number representation at higher bases.\n- *\n- * # Panics\n- * - Panics if `radix` < 2 or `radix` > 36.\n- */\n+/// Converts an integral number to its string representation as a byte vector.\n+/// This is meant to be a common base implementation for all integral string\n+/// conversion functions like `to_string()` or `to_str_radix()`.\n+///\n+/// # Arguments\n+///\n+/// - `num`           - The number to convert. Accepts any number that\n+///                     implements the numeric traits.\n+/// - `radix`         - Base to use. Accepts only the values 2-36.\n+/// - `sign`          - How to emit the sign. Options are:\n+///     - `SignNone`: No sign at all. Basically emits `abs(num)`.\n+///     - `SignNeg`:  Only `-` on negative values.\n+///     - `SignAll`:  Both `+` on positive, and `-` on negative numbers.\n+/// - `f`             - a callback which will be invoked for each ascii character\n+///                     which composes the string representation of this integer\n+///\n+/// # Return value\n+///\n+/// A tuple containing the byte vector, and a boolean flag indicating\n+/// whether it represents a special value like `inf`, `-inf`, `NaN` or not.\n+/// It returns a tuple because there can be ambiguity between a special value\n+/// and a number representation at higher bases.\n+///\n+/// # Panics\n+///\n+/// - Panics if `radix` < 2 or `radix` > 36.\n fn int_to_str_bytes_common<T: Int>(num: T, radix: uint, sign: SignFormat, f: |u8|) {\n     assert!(2 <= radix && radix <= 36);\n "}, {"sha": "87f7c16c17dff9f5d17ef712a7da49cbd6f1908c", "filename": "src/libstd/os.rs", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -793,18 +793,16 @@ pub fn homedir() -> Option<Path> {\n     _homedir()\n }\n \n-/**\n- * Returns the path to a temporary directory.\n- *\n- * On Unix, returns the value of the 'TMPDIR' environment variable if it is\n- * set, otherwise for non-Android it returns '/tmp'. If Android, since there\n- * is no global temporary folder (it is usually allocated per-app), we return\n- * '/data/local/tmp'.\n- *\n- * On Windows, returns the value of, in order, the 'TMP', 'TEMP',\n- * 'USERPROFILE' environment variable  if any are set and not the empty\n- * string. Otherwise, tmpdir returns the path to the Windows directory.\n- */\n+/// Returns the path to a temporary directory.\n+///\n+/// On Unix, returns the value of the 'TMPDIR' environment variable if it is\n+/// set, otherwise for non-Android it returns '/tmp'. If Android, since there\n+/// is no global temporary folder (it is usually allocated per-app), we return\n+/// '/data/local/tmp'.\n+///\n+/// On Windows, returns the value of, in order, the 'TMP', 'TEMP',\n+/// 'USERPROFILE' environment variable  if any are set and not the empty\n+/// string. Otherwise, tmpdir returns the path to the Windows directory.\n pub fn tmpdir() -> Path {\n     return lookup();\n \n@@ -938,16 +936,14 @@ pub fn last_os_error() -> String {\n \n static EXIT_STATUS: AtomicInt = INIT_ATOMIC_INT;\n \n-/**\n- * Sets the process exit code\n- *\n- * Sets the exit code returned by the process if all supervised tasks\n- * terminate successfully (without panicking). If the current root task panics\n- * and is supervised by the scheduler then any user-specified exit status is\n- * ignored and the process exits with the default panic status.\n- *\n- * Note that this is not synchronized against modifications of other threads.\n- */\n+/// Sets the process exit code\n+///\n+/// Sets the exit code returned by the process if all supervised tasks\n+/// terminate successfully (without panicking). If the current root task panics\n+/// and is supervised by the scheduler then any user-specified exit status is\n+/// ignored and the process exits with the default panic status.\n+///\n+/// Note that this is not synchronized against modifications of other threads.\n pub fn set_exit_status(code: int) {\n     EXIT_STATUS.store(code, SeqCst)\n }\n@@ -968,11 +964,9 @@ unsafe fn load_argc_and_argv(argc: int,\n     })\n }\n \n-/**\n- * Returns the command line arguments\n- *\n- * Returns a list of the command line arguments.\n- */\n+/// Returns the command line arguments\n+///\n+/// Returns a list of the command line arguments.\n #[cfg(target_os = \"macos\")]\n fn real_args_as_bytes() -> Vec<Vec<u8>> {\n     unsafe {"}, {"sha": "77f5b01351908c2aa33b123881607c627209654c", "filename": "src/libstd/sync/lock.rs", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibstd%2Fsync%2Flock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibstd%2Fsync%2Flock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Flock.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -29,9 +29,7 @@ use rustrt::task::Task;\n \n use super::raw;\n \n-/****************************************************************************\n- * Poisoning helpers\n- ****************************************************************************/\n+// Poisoning helpers\n \n struct PoisonOnFail<'a> {\n     flag: &'a mut bool,\n@@ -67,9 +65,7 @@ impl<'a> Drop for PoisonOnFail<'a> {\n     }\n }\n \n-/****************************************************************************\n- * Condvar\n- ****************************************************************************/\n+// Condvar\n \n enum Inner<'a> {\n     InnerMutex(raw::MutexGuard<'a>),\n@@ -147,10 +143,6 @@ impl<'a> Condvar<'a> {\n     }\n }\n \n-/****************************************************************************\n- * Mutex\n- ****************************************************************************/\n-\n /// A wrapper type which provides synchronized access to the underlying data, of\n /// type `T`. A mutex always provides exclusive access, and concurrent requests\n /// will block while the mutex is already locked.\n@@ -249,10 +241,6 @@ impl<'a, T: Send> DerefMut<T> for MutexGuard<'a, T> {\n     fn deref_mut<'a>(&'a mut self) -> &'a mut T { &mut *self._data }\n }\n \n-/****************************************************************************\n- * R/W lock protected lock\n- ****************************************************************************/\n-\n /// A dual-mode reader-writer lock. The data can be accessed mutably or\n /// immutably, and immutably-accessing tasks may run concurrently.\n ///\n@@ -387,10 +375,6 @@ impl<'a, T: Send + Sync> DerefMut<T> for RWLockWriteGuard<'a, T> {\n     fn deref_mut<'a>(&'a mut self) -> &'a mut T { &mut *self._data }\n }\n \n-/****************************************************************************\n- * Barrier\n- ****************************************************************************/\n-\n /// A barrier enables multiple tasks to synchronize the beginning\n /// of some computation.\n ///\n@@ -452,10 +436,6 @@ impl Barrier {\n     }\n }\n \n-/****************************************************************************\n- * Tests\n- ****************************************************************************/\n-\n #[cfg(test)]\n mod tests {\n     use prelude::*;\n@@ -795,9 +775,6 @@ mod tests {\n         }\n     }\n \n-    /************************************************************************\n-     * Barrier tests\n-     ************************************************************************/\n     #[test]\n     fn test_barrier() {\n         let barrier = Arc::new(Barrier::new(10));"}, {"sha": "47580a115131bb2e467b3ca2df280992da04b978", "filename": "src/libstd/sync/raw.rs", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibstd%2Fsync%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibstd%2Fsync%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fraw.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -32,10 +32,6 @@ use vec::Vec;\n use super::mutex;\n use comm::{Receiver, Sender, channel};\n \n-/****************************************************************************\n- * Internals\n- ****************************************************************************/\n-\n // Each waiting task receives on one of these.\n type WaitEnd = Receiver<()>;\n type SignalEnd = Sender<()>;\n@@ -353,10 +349,6 @@ struct SemCondGuard<'a> {\n     cvar: Condvar<'a>,\n }\n \n-/****************************************************************************\n- * Semaphores\n- ****************************************************************************/\n-\n /// A counting, blocking, bounded-waiting semaphore.\n pub struct Semaphore {\n     sem: Sem<()>,\n@@ -394,10 +386,6 @@ impl Semaphore {\n     }\n }\n \n-/****************************************************************************\n- * Mutexes\n- ****************************************************************************/\n-\n /// A blocking, bounded-waiting, mutual exclusion lock with an associated\n /// FIFO condition variable.\n ///\n@@ -441,10 +429,6 @@ impl Mutex {\n     }\n }\n \n-/****************************************************************************\n- * Reader-writer locks\n- ****************************************************************************/\n-\n // NB: Wikipedia - Readers-writers_problem#The_third_readers-writers_problem\n \n /// A blocking, no-starvation, reader-writer lock with an associated condvar.\n@@ -618,10 +602,6 @@ impl<'a> Drop for RWLockReadGuard<'a> {\n     }\n }\n \n-/****************************************************************************\n- * Tests\n- ****************************************************************************/\n-\n #[cfg(test)]\n mod tests {\n     pub use self::RWLockMode::*;\n@@ -634,26 +614,26 @@ mod tests {\n     use result;\n     use task;\n \n-    /************************************************************************\n-     * Semaphore tests\n-     ************************************************************************/\n     #[test]\n     fn test_sem_acquire_release() {\n         let s = Semaphore::new(1);\n         s.acquire();\n         s.release();\n         s.acquire();\n     }\n+\n     #[test]\n     fn test_sem_basic() {\n         let s = Semaphore::new(1);\n         let _g = s.access();\n     }\n+\n     #[test]\n     #[should_fail]\n     fn test_sem_basic2() {\n         Semaphore::new(-1);\n     }\n+\n     #[test]\n     fn test_sem_as_mutex() {\n         let s = Arc::new(Semaphore::new(1));\n@@ -665,6 +645,7 @@ mod tests {\n         let _g = s.access();\n         for _ in range(0u, 5) { task::deschedule(); }\n     }\n+\n     #[test]\n     fn test_sem_as_cvar() {\n         /* Child waits and parent signals */\n@@ -691,6 +672,7 @@ mod tests {\n         s.acquire();\n         tx.send(());\n     }\n+\n     #[test]\n     fn test_sem_multi_resource() {\n         // Parent and child both get in the critical section at the same\n@@ -708,6 +690,7 @@ mod tests {\n         tx2.send(());\n         let _ = rx1.recv();\n     }\n+\n     #[test]\n     fn test_sem_runtime_friendly_blocking() {\n         // Force the runtime to schedule two threads on the same sched_loop.\n@@ -727,9 +710,7 @@ mod tests {\n         }\n         rx.recv(); // wait for child to be done\n     }\n-    /************************************************************************\n-     * Mutex tests\n-     ************************************************************************/\n+\n     #[test]\n     fn test_mutex_lock() {\n         // Unsafely achieve shared state, and do the textbook\n@@ -761,6 +742,7 @@ mod tests {\n             }\n         }\n     }\n+\n     #[test]\n     fn test_mutex_cond_wait() {\n         let m = Arc::new(Mutex::new());\n@@ -820,14 +802,17 @@ mod tests {\n         // wait until all children wake up\n         for rx in rxs.iter_mut() { rx.recv(); }\n     }\n+\n     #[test]\n     fn test_mutex_cond_broadcast() {\n         test_mutex_cond_broadcast_helper(12);\n     }\n+\n     #[test]\n     fn test_mutex_cond_broadcast_none() {\n         test_mutex_cond_broadcast_helper(0);\n     }\n+\n     #[test]\n     fn test_mutex_cond_no_waiter() {\n         let m = Arc::new(Mutex::new());\n@@ -838,6 +823,7 @@ mod tests {\n         let lock = m2.lock();\n         assert!(!lock.cond.signal());\n     }\n+\n     #[test]\n     fn test_mutex_killed_simple() {\n         use any::Any;\n@@ -854,6 +840,7 @@ mod tests {\n         // child task must have finished by the time try returns\n         drop(m.lock());\n     }\n+\n     #[test]\n     fn test_mutex_cond_signal_on_0() {\n         // Tests that signal_on(0) is equivalent to signal().\n@@ -866,6 +853,7 @@ mod tests {\n         });\n         lock.cond.wait();\n     }\n+\n     #[test]\n     fn test_mutex_no_condvars() {\n         let result = task::try(proc() {\n@@ -884,11 +872,10 @@ mod tests {\n         });\n         assert!(result.is_err());\n     }\n-    /************************************************************************\n-     * Reader/writer lock tests\n-     ************************************************************************/\n+\n     #[cfg(test)]\n     pub enum RWLockMode { Read, Write, Downgrade, DowngradeRead }\n+\n     #[cfg(test)]\n     fn lock_rwlock_in_mode(x: &Arc<RWLock>, mode: RWLockMode, blk: ||) {\n         match mode {\n@@ -898,6 +885,7 @@ mod tests {\n             DowngradeRead => { let _g = x.write().downgrade(); blk() }\n         }\n     }\n+\n     #[cfg(test)]\n     fn test_rwlock_exclusion(x: Arc<RWLock>,\n                              mode1: RWLockMode,\n@@ -934,6 +922,7 @@ mod tests {\n             }\n         }\n     }\n+\n     #[test]\n     fn test_rwlock_readers_wont_modify_the_data() {\n         test_rwlock_exclusion(Arc::new(RWLock::new()), Read, Write);\n@@ -943,13 +932,15 @@ mod tests {\n         test_rwlock_exclusion(Arc::new(RWLock::new()), Write, DowngradeRead);\n         test_rwlock_exclusion(Arc::new(RWLock::new()), DowngradeRead, Write);\n     }\n+\n     #[test]\n     fn test_rwlock_writers_and_writers() {\n         test_rwlock_exclusion(Arc::new(RWLock::new()), Write, Write);\n         test_rwlock_exclusion(Arc::new(RWLock::new()), Write, Downgrade);\n         test_rwlock_exclusion(Arc::new(RWLock::new()), Downgrade, Write);\n         test_rwlock_exclusion(Arc::new(RWLock::new()), Downgrade, Downgrade);\n     }\n+\n     #[cfg(test)]\n     fn test_rwlock_handshake(x: Arc<RWLock>,\n                              mode1: RWLockMode,\n@@ -982,6 +973,7 @@ mod tests {\n             rx1.recv();\n         })\n     }\n+\n     #[test]\n     fn test_rwlock_readers_and_readers() {\n         test_rwlock_handshake(Arc::new(RWLock::new()), Read, Read, false);\n@@ -991,6 +983,7 @@ mod tests {\n         test_rwlock_handshake(Arc::new(RWLock::new()), Read, DowngradeRead, true);\n         // Two downgrade_reads can never both end up reading at the same time.\n     }\n+\n     #[test]\n     fn test_rwlock_downgrade_unlock() {\n         // Tests that downgrade can unlock the lock in both modes\n@@ -1001,12 +994,14 @@ mod tests {\n         lock_rwlock_in_mode(&y, DowngradeRead, || { });\n         test_rwlock_exclusion(y, Write, Write);\n     }\n+\n     #[test]\n     fn test_rwlock_read_recursive() {\n         let x = RWLock::new();\n         let _g1 = x.read();\n         let _g2 = x.read();\n     }\n+\n     #[test]\n     fn test_rwlock_cond_wait() {\n         // As test_mutex_cond_wait above.\n@@ -1040,6 +1035,7 @@ mod tests {\n         rx.recv(); // Wait until child wakes up\n         drop(x.read()); // Just for good measure\n     }\n+\n     #[cfg(test)]\n     fn test_rwlock_cond_broadcast_helper(num_waiters: uint) {\n         // Much like the mutex broadcast test. Downgrade-enabled.\n@@ -1073,11 +1069,13 @@ mod tests {\n         // wait until all children wake up\n         for rx in rxs.iter_mut() { let _ = rx.recv(); }\n     }\n+\n     #[test]\n     fn test_rwlock_cond_broadcast() {\n         test_rwlock_cond_broadcast_helper(0);\n         test_rwlock_cond_broadcast_helper(12);\n     }\n+\n     #[cfg(test)]\n     fn rwlock_kill_helper(mode1: RWLockMode, mode2: RWLockMode) {\n         use any::Any;\n@@ -1095,22 +1093,27 @@ mod tests {\n         // child task must have finished by the time try returns\n         lock_rwlock_in_mode(&x, mode2, || { })\n     }\n+\n     #[test]\n     fn test_rwlock_reader_killed_writer() {\n         rwlock_kill_helper(Read, Write);\n     }\n+\n     #[test]\n     fn test_rwlock_writer_killed_reader() {\n         rwlock_kill_helper(Write, Read);\n     }\n+\n     #[test]\n     fn test_rwlock_reader_killed_reader() {\n         rwlock_kill_helper(Read, Read);\n     }\n+\n     #[test]\n     fn test_rwlock_writer_killed_writer() {\n         rwlock_kill_helper(Write, Write);\n     }\n+\n     #[test]\n     fn test_rwlock_kill_downgrader() {\n         rwlock_kill_helper(Downgrade, Read);"}, {"sha": "78a8e09dac1a002a14f1945d1ef2792150c50778", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -33,13 +33,11 @@ use string::String;\n \n pub use sys_common::ProcessConfig;\n \n-/**\n- * A value representing a child process.\n- *\n- * The lifetime of this value is linked to the lifetime of the actual\n- * process - the Process destructor calls self.finish() which waits\n- * for the process to terminate.\n- */\n+/// A value representing a child process.\n+///\n+/// The lifetime of this value is linked to the lifetime of the actual\n+/// process - the Process destructor calls self.finish() which waits\n+/// for the process to terminate.\n pub struct Process {\n     /// The unique id of the process (this should never be negative).\n     pid: pid_t,\n@@ -263,16 +261,14 @@ impl Process {\n         }\n     }\n \n-    /**\n-     * Waits for a process to exit and returns the exit code, failing\n-     * if there is no process with the specified id.\n-     *\n-     * Note that this is private to avoid race conditions on unix where if\n-     * a user calls waitpid(some_process.get_id()) then some_process.finish()\n-     * and some_process.destroy() and some_process.finalize() will then either\n-     * operate on a none-existent process or, even worse, on a newer process\n-     * with the same id.\n-     */\n+    /// Waits for a process to exit and returns the exit code, failing\n+    /// if there is no process with the specified id.\n+    ///\n+    /// Note that this is private to avoid race conditions on unix where if\n+    /// a user calls waitpid(some_process.get_id()) then some_process.finish()\n+    /// and some_process.destroy() and some_process.finalize() will then either\n+    /// operate on a none-existent process or, even worse, on a newer process\n+    /// with the same id.\n     pub fn wait(&self, deadline: u64) -> IoResult<ProcessExit> {\n         use libc::types::os::arch::extra::DWORD;\n         use libc::consts::os::extra::{"}, {"sha": "bea7c394e757024290695177cd4dc93d08bd9eb3", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -83,12 +83,10 @@ impl Sub<CharPos,CharPos> for CharPos {\n     }\n }\n \n-/**\n-Spans represent a region of code, used for error reporting. Positions in spans\n-are *absolute* positions from the beginning of the codemap, not positions\n-relative to FileMaps. Methods on the CodeMap can be used to relate spans back\n-to the original source.\n-*/\n+/// Spans represent a region of code, used for error reporting. Positions in spans\n+/// are *absolute* positions from the beginning of the codemap, not positions\n+/// relative to FileMaps. Methods on the CodeMap can be used to relate spans back\n+/// to the original source.\n #[deriving(Clone, Show, Hash)]\n pub struct Span {\n     pub lo: BytePos,"}, {"sha": "e703ac21f2642d14dde8016cba3eb2848caead5a", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -17,16 +17,12 @@ use parse::token::*;\n use parse::token;\n use ptr::P;\n \n-/**\n-*\n-* Quasiquoting works via token trees.\n-*\n-* This is registered as a set of expression syntax extension called quote!\n-* that lifts its argument token-tree to an AST representing the\n-* construction of the same token tree, with token::SubstNt interpreted\n-* as antiquotes (splices).\n-*\n-*/\n+//!  Quasiquoting works via token trees.\n+//!\n+//!  This is registered as a set of expression syntax extension called quote!\n+//!  that lifts its argument token-tree to an AST representing the\n+//!  construction of the same token tree, with token::SubstNt interpreted\n+//!  as antiquotes (splices).\n \n pub mod rt {\n     use ast;"}, {"sha": "583ace977fe4686108e84d643f17795d3a095581", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -421,13 +421,11 @@ macro_rules! declare_special_idents_and_keywords {(\n         )*\n     }\n \n-    /**\n-     * All the valid words that have meaning in the Rust language.\n-     *\n-     * Rust keywords are either 'strict' or 'reserved'.  Strict keywords may not\n-     * appear as identifiers at all. Reserved keywords are not used anywhere in\n-     * the language and may not appear as identifiers.\n-     */\n+    /// All the valid words that have meaning in the Rust language.\n+    ///\n+    /// Rust keywords are either 'strict' or 'reserved'.  Strict keywords may not\n+    /// appear as identifiers at all. Reserved keywords are not used anywhere in\n+    /// the language and may not appear as identifiers.\n     pub mod keywords {\n         pub use self::Keyword::*;\n         use ast;"}, {"sha": "62a49c5d902705a36aa6be92cf9c1255b76d8609", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -80,17 +80,15 @@ impl Variables {\n     }\n }\n \n-/**\n-  Expand a parameterized capability\n-\n-  # Arguments\n-  * `cap`    - string to expand\n-  * `params` - vector of params for %p1 etc\n-  * `vars`   - Variables struct for %Pa etc\n-\n-  To be compatible with ncurses, `vars` should be the same between calls to `expand` for\n-  multiple capabilities for the same terminal.\n-  */\n+/// Expand a parameterized capability\n+///\n+/// # Arguments\n+/// * `cap`    - string to expand\n+/// * `params` - vector of params for %p1 etc\n+/// * `vars`   - Variables struct for %Pa etc\n+///\n+/// To be compatible with ncurses, `vars` should be the same between calls to `expand` for\n+/// multiple capabilities for the same terminal.\n pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n     -> Result<Vec<u8> , String> {\n     let mut state = Nothing;"}, {"sha": "135c8a72808800cd15c1f244d02854ad80bab51a", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 27, "deletions": 43, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40fa8304fea63e04364645260112ddaf91ce70f/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=f40fa8304fea63e04364645260112ddaf91ce70f", "patch": "@@ -123,10 +123,8 @@ impl Sub<Timespec, Duration> for Timespec {\n     }\n }\n \n-/**\n- * Returns the current time as a `timespec` containing the seconds and\n- * nanoseconds since 1970-01-01T00:00:00Z.\n- */\n+/// Returns the current time as a `timespec` containing the seconds and\n+/// nanoseconds since 1970-01-01T00:00:00Z.\n pub fn get_time() -> Timespec {\n     unsafe {\n         let (sec, nsec) = os_get_time();\n@@ -171,10 +169,8 @@ pub fn get_time() -> Timespec {\n }\n \n \n-/**\n- * Returns the current value of a high-resolution performance counter\n- * in nanoseconds since an unspecified epoch.\n- */\n+/// Returns the current value of a high-resolution performance counter\n+/// in nanoseconds since an unspecified epoch.\n pub fn precise_time_ns() -> u64 {\n     return os_precise_time_ns();\n \n@@ -218,10 +214,8 @@ pub fn precise_time_ns() -> u64 {\n }\n \n \n-/**\n- * Returns the current value of a high-resolution performance counter\n- * in seconds since an unspecified epoch.\n- */\n+/// Returns the current value of a high-resolution performance counter\n+/// in seconds since an unspecified epoch.\n pub fn precise_time_s() -> f64 {\n     return (precise_time_ns() as f64) / 1000000000.;\n }\n@@ -346,25 +340,21 @@ impl Tm {\n         at_utc(self.to_timespec())\n     }\n \n-    /**\n-     * Returns a TmFmt that outputs according to the `asctime` format in ISO\n-     * C, in the local timezone.\n-     *\n-     * Example: \"Thu Jan  1 00:00:00 1970\"\n-     */\n+    /// Returns a TmFmt that outputs according to the `asctime` format in ISO\n+    /// C, in the local timezone.\n+    ///\n+    /// Example: \"Thu Jan  1 00:00:00 1970\"\n     pub fn ctime(&self) -> TmFmt {\n         TmFmt {\n             tm: self,\n             format: FmtCtime,\n         }\n     }\n \n-    /**\n-     * Returns a TmFmt that outputs according to the `asctime` format in ISO\n-     * C.\n-     *\n-     * Example: \"Thu Jan  1 00:00:00 1970\"\n-     */\n+    /// Returns a TmFmt that outputs according to the `asctime` format in ISO\n+    /// C.\n+    ///\n+    /// Example: \"Thu Jan  1 00:00:00 1970\"\n     pub fn asctime(&self) -> TmFmt {\n         TmFmt {\n             tm: self,\n@@ -380,12 +370,10 @@ impl Tm {\n         })\n     }\n \n-    /**\n-     * Returns a TmFmt that outputs according to RFC 822.\n-     *\n-     * local: \"Thu, 22 Mar 2012 07:53:18 PST\"\n-     * utc:   \"Thu, 22 Mar 2012 14:53:18 GMT\"\n-     */\n+    /// Returns a TmFmt that outputs according to RFC 822.\n+    ///\n+    /// local: \"Thu, 22 Mar 2012 07:53:18 PST\"\n+    /// utc:   \"Thu, 22 Mar 2012 14:53:18 GMT\"\n     pub fn rfc822(&self) -> TmFmt {\n         if self.tm_gmtoff == 0_i32 {\n             TmFmt {\n@@ -400,26 +388,22 @@ impl Tm {\n         }\n     }\n \n-    /**\n-     * Returns a TmFmt that outputs according to RFC 822 with Zulu time.\n-     *\n-     * local: \"Thu, 22 Mar 2012 07:53:18 -0700\"\n-     * utc:   \"Thu, 22 Mar 2012 14:53:18 -0000\"\n-     */\n+    /// Returns a TmFmt that outputs according to RFC 822 with Zulu time.\n+    ///\n+    /// local: \"Thu, 22 Mar 2012 07:53:18 -0700\"\n+    /// utc:   \"Thu, 22 Mar 2012 14:53:18 -0000\"\n     pub fn rfc822z(&self) -> TmFmt {\n         TmFmt {\n             tm: self,\n             format: FmtStr(\"%a, %d %b %Y %T %z\"),\n         }\n     }\n \n-    /**\n-     * Returns a TmFmt that outputs according to RFC 3339. RFC 3339 is\n-     * compatible with ISO 8601.\n-     *\n-     * local: \"2012-02-22T07:53:18-07:00\"\n-     * utc:   \"2012-02-22T14:53:18Z\"\n-     */\n+    /// Returns a TmFmt that outputs according to RFC 3339. RFC 3339 is\n+    /// compatible with ISO 8601.\n+    ///\n+    /// local: \"2012-02-22T07:53:18-07:00\"\n+    /// utc:   \"2012-02-22T14:53:18Z\"\n     pub fn rfc3339<'a>(&'a self) -> TmFmt {\n         TmFmt {\n             tm: self,"}]}