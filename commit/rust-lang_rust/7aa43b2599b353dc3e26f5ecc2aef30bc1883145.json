{"sha": "7aa43b2599b353dc3e26f5ecc2aef30bc1883145", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhYTQzYjI1OTliMzUzZGMzZTI2ZjVlY2MyYWVmMzBiYzE4ODMxNDU=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-06-29T06:36:00Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-06-29T06:36:00Z"}, "message": "Make fmt use a bitmask instead of a vector of flags. Closes #1993.", "tree": {"sha": "b901ea1c118af1982a03b78d75ac42d5e4e6cbd3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b901ea1c118af1982a03b78d75ac42d5e4e6cbd3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7aa43b2599b353dc3e26f5ecc2aef30bc1883145", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7aa43b2599b353dc3e26f5ecc2aef30bc1883145", "html_url": "https://github.com/rust-lang/rust/commit/7aa43b2599b353dc3e26f5ecc2aef30bc1883145", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7aa43b2599b353dc3e26f5ecc2aef30bc1883145/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "498b3ff57f7269e62765e53c5987791ff5621d6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/498b3ff57f7269e62765e53c5987791ff5621d6a", "html_url": "https://github.com/rust-lang/rust/commit/498b3ff57f7269e62765e53c5987791ff5621d6a"}], "stats": {"total": 48, "additions": 22, "deletions": 26}, "files": [{"sha": "7cfa44f52bd942e6d25660e56589f22ed8add740", "filename": "mk/target.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aa43b2599b353dc3e26f5ecc2aef30bc1883145/mk%2Ftarget.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7aa43b2599b353dc3e26f5ecc2aef30bc1883145/mk%2Ftarget.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftarget.mk?ref=7aa43b2599b353dc3e26f5ecc2aef30bc1883145", "patch": "@@ -9,7 +9,7 @@\n # the snapshot runtime (resp. corelib) rather than the runtime\n # (resp. corelib) from the working directory.\n USE_SNAPSHOT_RUNTIME=0\n-USE_SNAPSHOT_CORELIB=0\n+USE_SNAPSHOT_CORELIB=1\n USE_SNAPSHOT_STDLIB=0\n \n define TARGET_STAGE_N"}, {"sha": "e7263243323d7fc3cddd263bf9a58622af903b00", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7aa43b2599b353dc3e26f5ecc2aef30bc1883145/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa43b2599b353dc3e26f5ecc2aef30bc1883145/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=7aa43b2599b353dc3e26f5ecc2aef30bc1883145", "patch": "@@ -264,19 +264,17 @@ mod ct {\n // conditions can be evaluated at compile-time. For now though it's cleaner to\n // implement it 0this way, I think.\n mod rt {\n-    enum flag {\n-        flag_left_justify,\n-        flag_left_zero_pad,\n-        flag_space_for_sign,\n-        flag_sign_always,\n-        flag_alternate,\n-    }\n+    const flag_none : u32 = 0u32;\n+    const flag_left_justify   : u32 = 0b00000000000000000000000000000001u32;\n+    const flag_left_zero_pad  : u32 = 0b00000000000000000000000000000010u32;\n+    const flag_space_for_sign : u32 = 0b00000000000000000000000000000100u32;\n+    const flag_sign_always    : u32 = 0b00000000000000000000000000001000u32;\n+    const flag_alternate      : u32 = 0b00000000000000000000000000010000u32;\n+\n     enum count { count_is(int), count_implied, }\n     enum ty { ty_default, ty_bits, ty_hex_upper, ty_hex_lower, ty_octal, }\n \n-    // FIXME (#1993): May not want to use a vector here for flags; instead\n-    // just use a bool per flag.\n-    type conv = {flags: [flag]/~, width: count, precision: count, ty: ty};\n+    type conv = {flags: u32, width: count, precision: count, ty: ty};\n \n     fn conv_int(cv: conv, i: int) -> str {\n         let radix = 10u;\n@@ -307,7 +305,6 @@ mod rt {\n         let s = if b { \"true\" } else { \"false\" };\n         // run the boolean conversion through the string conversion logic,\n         // giving it the same rules for precision, etc.\n-\n         ret conv_str(cv, s);\n     }\n     fn conv_char(cv: conv, c: char) -> str {\n@@ -430,9 +427,8 @@ mod rt {\n         }\n         ret padstr + s;\n     }\n-    fn have_flag(flags: [flag]/~, f: flag) -> bool {\n-        for vec::each(flags) {|candidate| if candidate == f { ret true; } }\n-        ret false;\n+    fn have_flag(flags: u32, f: u32) -> bool {\n+        flags & f != 0\n     }\n }\n "}, {"sha": "bac880b60a8c80c30b90585b40f95eae06e5ab16", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7aa43b2599b353dc3e26f5ecc2aef30bc1883145/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa43b2599b353dc3e26f5ecc2aef30bc1883145/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=7aa43b2599b353dc3e26f5ecc2aef30bc1883145", "patch": "@@ -50,19 +50,19 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n \n     fn make_rt_conv_expr(cx: ext_ctxt, sp: span, cnv: conv) -> @ast::expr {\n         fn make_flags(cx: ext_ctxt, sp: span, flags: [flag]/~) -> @ast::expr {\n-            let mut flagexprs: [@ast::expr]/~ = []/~;\n+            let mut tmp_expr = make_rt_path_expr(cx, sp, @\"flag_none\");\n             for flags.each {|f|\n-                let mut fstr;\n-                alt f {\n-                  flag_left_justify { fstr = \"flag_left_justify\"; }\n-                  flag_left_zero_pad { fstr = \"flag_left_zero_pad\"; }\n-                  flag_space_for_sign { fstr = \"flag_space_for_sign\"; }\n-                  flag_sign_always { fstr = \"flag_sign_always\"; }\n-                  flag_alternate { fstr = \"flag_alternate\"; }\n-                }\n-                vec::push(flagexprs, make_rt_path_expr(cx, sp, @fstr));\n+                let fstr = alt f {\n+                  flag_left_justify { \"flag_left_justify\" }\n+                  flag_left_zero_pad { \"flag_left_zero_pad\" }\n+                  flag_space_for_sign { \"flag_space_for_sign\" }\n+                  flag_sign_always { \"flag_sign_always\" }\n+                  flag_alternate { \"flag_alternate\" }\n+                };\n+                tmp_expr = mk_binary(cx, sp, ast::bitor, tmp_expr,\n+                                     make_rt_path_expr(cx, sp, @fstr));\n             }\n-            ret mk_uniq_vec_e(cx, sp, flagexprs);\n+            ret tmp_expr;\n         }\n         fn make_count(cx: ext_ctxt, sp: span, cnt: count) -> @ast::expr {\n             alt cnt {"}]}