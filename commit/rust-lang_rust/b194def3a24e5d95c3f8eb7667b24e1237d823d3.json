{"sha": "b194def3a24e5d95c3f8eb7667b24e1237d823d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxOTRkZWYzYTI0ZTVkOTVjM2Y4ZWI3NjY3YjI0ZTEyMzdkODIzZDM=", "commit": {"author": {"name": "M\u00e1ty\u00e1s Mustoha", "email": "mmatyas@inf.u-szeged.hu", "date": "2017-04-11T10:10:05Z"}, "committer": {"name": "M\u00e1ty\u00e1s Mustoha", "email": "mmatyas@inf.u-szeged.hu", "date": "2017-05-04T10:43:22Z"}, "message": "Add remote device testing support", "tree": {"sha": "6527039d85f7ac1246c5c1564b456cb7202b4c94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6527039d85f7ac1246c5c1564b456cb7202b4c94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b194def3a24e5d95c3f8eb7667b24e1237d823d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b194def3a24e5d95c3f8eb7667b24e1237d823d3", "html_url": "https://github.com/rust-lang/rust/commit/b194def3a24e5d95c3f8eb7667b24e1237d823d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b194def3a24e5d95c3f8eb7667b24e1237d823d3/comments", "author": {"login": "mmatyas", "id": 4354863, "node_id": "MDQ6VXNlcjQzNTQ4NjM=", "avatar_url": "https://avatars.githubusercontent.com/u/4354863?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mmatyas", "html_url": "https://github.com/mmatyas", "followers_url": "https://api.github.com/users/mmatyas/followers", "following_url": "https://api.github.com/users/mmatyas/following{/other_user}", "gists_url": "https://api.github.com/users/mmatyas/gists{/gist_id}", "starred_url": "https://api.github.com/users/mmatyas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mmatyas/subscriptions", "organizations_url": "https://api.github.com/users/mmatyas/orgs", "repos_url": "https://api.github.com/users/mmatyas/repos", "events_url": "https://api.github.com/users/mmatyas/events{/privacy}", "received_events_url": "https://api.github.com/users/mmatyas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mmatyas", "id": 4354863, "node_id": "MDQ6VXNlcjQzNTQ4NjM=", "avatar_url": "https://avatars.githubusercontent.com/u/4354863?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mmatyas", "html_url": "https://github.com/mmatyas", "followers_url": "https://api.github.com/users/mmatyas/followers", "following_url": "https://api.github.com/users/mmatyas/following{/other_user}", "gists_url": "https://api.github.com/users/mmatyas/gists{/gist_id}", "starred_url": "https://api.github.com/users/mmatyas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mmatyas/subscriptions", "organizations_url": "https://api.github.com/users/mmatyas/orgs", "repos_url": "https://api.github.com/users/mmatyas/repos", "events_url": "https://api.github.com/users/mmatyas/events{/privacy}", "received_events_url": "https://api.github.com/users/mmatyas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b16c7a235fa0f57fed6b7ec13ffd3cff1bcdd9ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/b16c7a235fa0f57fed6b7ec13ffd3cff1bcdd9ad", "html_url": "https://github.com/rust-lang/rust/commit/b16c7a235fa0f57fed6b7ec13ffd3cff1bcdd9ad"}], "stats": {"total": 109, "additions": 80, "deletions": 29}, "files": [{"sha": "d24bb074cd374d13bb50ad7cc8ce670f090e65c6", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b194def3a24e5d95c3f8eb7667b24e1237d823d3/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b194def3a24e5d95c3f8eb7667b24e1237d823d3/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=b194def3a24e5d95c3f8eb7667b24e1237d823d3", "patch": "@@ -529,7 +529,7 @@ fn find_tests(dir: &Path,\n     }\n }\n \n-pub fn emulator_copy_libs(build: &Build, compiler: &Compiler, target: &str) {\n+pub fn remote_copy_libs(build: &Build, compiler: &Compiler, target: &str) {\n     if !build.remote_tested(target) {\n         return\n     }"}, {"sha": "970c0bc565d864c533c255483c8a0e63a1d12d8c", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b194def3a24e5d95c3f8eb7667b24e1237d823d3/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b194def3a24e5d95c3f8eb7667b24e1237d823d3/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=b194def3a24e5d95c3f8eb7667b24e1237d823d3", "patch": "@@ -307,7 +307,7 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n                  .dep(|s| s.name(\"libtest\"))\n                  .dep(|s| s.name(\"tool-compiletest\").target(s.host).stage(0))\n                  .dep(|s| s.name(\"test-helpers\"))\n-                 .dep(|s| s.name(\"emulator-copy-libs\"))\n+                 .dep(|s| s.name(\"remote-copy-libs\"))\n                  .default(mode != \"pretty\") // pretty tests don't run everywhere\n                  .run(move |s| {\n                      check::compiletest(build, &s.compiler(), s.target, mode, dir)\n@@ -346,7 +346,7 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n              .dep(|s| s.name(\"tool-compiletest\").target(s.host).stage(0))\n              .dep(|s| s.name(\"test-helpers\"))\n              .dep(|s| s.name(\"debugger-scripts\"))\n-             .dep(|s| s.name(\"emulator-copy-libs\"))\n+             .dep(|s| s.name(\"remote-copy-libs\"))\n              .run(move |s| check::compiletest(build, &s.compiler(), s.target,\n                                          \"debuginfo-gdb\", \"debuginfo\"));\n         let mut rule = rules.test(\"check-debuginfo\", \"src/test/debuginfo\");\n@@ -400,14 +400,14 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     for (krate, path, _default) in krates(\"std\") {\n         rules.test(&krate.test_step, path)\n              .dep(|s| s.name(\"libtest\"))\n-             .dep(|s| s.name(\"emulator-copy-libs\"))\n+             .dep(|s| s.name(\"remote-copy-libs\"))\n              .run(move |s| check::krate(build, &s.compiler(), s.target,\n                                         Mode::Libstd, TestKind::Test,\n                                         Some(&krate.name)));\n     }\n     rules.test(\"check-std-all\", \"path/to/nowhere\")\n          .dep(|s| s.name(\"libtest\"))\n-         .dep(|s| s.name(\"emulator-copy-libs\"))\n+         .dep(|s| s.name(\"remote-copy-libs\"))\n          .default(true)\n          .run(move |s| check::krate(build, &s.compiler(), s.target,\n                                     Mode::Libstd, TestKind::Test, None));\n@@ -416,44 +416,44 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     for (krate, path, _default) in krates(\"std\") {\n         rules.bench(&krate.bench_step, path)\n              .dep(|s| s.name(\"libtest\"))\n-             .dep(|s| s.name(\"emulator-copy-libs\"))\n+             .dep(|s| s.name(\"remote-copy-libs\"))\n              .run(move |s| check::krate(build, &s.compiler(), s.target,\n                                         Mode::Libstd, TestKind::Bench,\n                                         Some(&krate.name)));\n     }\n     rules.bench(\"bench-std-all\", \"path/to/nowhere\")\n          .dep(|s| s.name(\"libtest\"))\n-         .dep(|s| s.name(\"emulator-copy-libs\"))\n+         .dep(|s| s.name(\"remote-copy-libs\"))\n          .default(true)\n          .run(move |s| check::krate(build, &s.compiler(), s.target,\n                                     Mode::Libstd, TestKind::Bench, None));\n \n     for (krate, path, _default) in krates(\"test\") {\n         rules.test(&krate.test_step, path)\n              .dep(|s| s.name(\"libtest\"))\n-             .dep(|s| s.name(\"emulator-copy-libs\"))\n+             .dep(|s| s.name(\"remote-copy-libs\"))\n              .run(move |s| check::krate(build, &s.compiler(), s.target,\n                                         Mode::Libtest, TestKind::Test,\n                                         Some(&krate.name)));\n     }\n     rules.test(\"check-test-all\", \"path/to/nowhere\")\n          .dep(|s| s.name(\"libtest\"))\n-         .dep(|s| s.name(\"emulator-copy-libs\"))\n+         .dep(|s| s.name(\"remote-copy-libs\"))\n          .default(true)\n          .run(move |s| check::krate(build, &s.compiler(), s.target,\n                                     Mode::Libtest, TestKind::Test, None));\n     for (krate, path, _default) in krates(\"rustc-main\") {\n         rules.test(&krate.test_step, path)\n              .dep(|s| s.name(\"librustc\"))\n-             .dep(|s| s.name(\"emulator-copy-libs\"))\n+             .dep(|s| s.name(\"remote-copy-libs\"))\n              .host(true)\n              .run(move |s| check::krate(build, &s.compiler(), s.target,\n                                         Mode::Librustc, TestKind::Test,\n                                         Some(&krate.name)));\n     }\n     rules.test(\"check-rustc-all\", \"path/to/nowhere\")\n          .dep(|s| s.name(\"librustc\"))\n-         .dep(|s| s.name(\"emulator-copy-libs\"))\n+         .dep(|s| s.name(\"remote-copy-libs\"))\n          .default(true)\n          .host(true)\n          .run(move |s| check::krate(build, &s.compiler(), s.target,\n@@ -500,17 +500,17 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     rules.build(\"openssl\", \"path/to/nowhere\")\n          .run(move |s| native::openssl(build, s.target));\n \n-    // Some test suites are run inside emulators, and most of our test binaries\n-    // are linked dynamically which means we need to ship the standard library\n-    // and such to the emulator ahead of time. This step represents this and is\n-    // a dependency of all test suites.\n+    // Some test suites are run inside emulators or on remote devices, and most\n+    // of our test binaries are linked dynamically which means we need to ship\n+    // the standard library and such to the emulator ahead of time. This step\n+    // represents this and is a dependency of all test suites.\n     //\n     // Most of the time this step is a noop (the `check::emulator_copy_libs`\n     // only does work if necessary). For some steps such as shipping data to\n     // QEMU we have to build our own tools so we've got conditional dependencies\n-    // on those programs as well. Note that the QEMU client is built for the\n-    // build target (us) and the server is built for the target.\n-    rules.test(\"emulator-copy-libs\", \"path/to/nowhere\")\n+    // on those programs as well. Note that the remote test client is built for\n+    // the build target (us) and the server is built for the target.\n+    rules.test(\"remote-copy-libs\", \"path/to/nowhere\")\n          .dep(|s| s.name(\"libtest\"))\n          .dep(move |s| {\n              if build.remote_tested(s.target) {\n@@ -526,7 +526,7 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n                  Step::noop()\n              }\n          })\n-         .run(move |s| check::emulator_copy_libs(build, &s.compiler(), s.target));\n+         .run(move |s| check::remote_copy_libs(build, &s.compiler(), s.target));\n \n     rules.test(\"check-bootstrap\", \"src/bootstrap\")\n          .default(true)"}, {"sha": "1a41b2c0f390ee56ba2df7f5241e3b96ea975e45", "filename": "src/tools/remote-test-client/src/main.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b194def3a24e5d95c3f8eb7667b24e1237d823d3/src%2Ftools%2Fremote-test-client%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b194def3a24e5d95c3f8eb7667b24e1237d823d3/src%2Ftools%2Fremote-test-client%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fremote-test-client%2Fsrc%2Fmain.rs?ref=b194def3a24e5d95c3f8eb7667b24e1237d823d3", "patch": "@@ -25,6 +25,8 @@ use std::process::{Command, Stdio};\n use std::thread;\n use std::time::Duration;\n \n+const REMOTE_ADDR_ENV: &'static str = \"TEST_DEVICE_ADDR\";\n+\n macro_rules! t {\n     ($e:expr) => (match $e {\n         Ok(e) => e,\n@@ -56,7 +58,11 @@ fn spawn_emulator(target: &str,\n                   server: &Path,\n                   tmpdir: &Path,\n                   rootfs: Option<PathBuf>) {\n-    if target.contains(\"android\") {\n+    let device_address = env::var(REMOTE_ADDR_ENV).unwrap_or(\"127.0.0.1:12345\".to_string());\n+\n+    if env::var(REMOTE_ADDR_ENV).is_ok() {\n+        println!(\"Connecting to remote device {} ...\", device_address);\n+    } else if target.contains(\"android\") {\n         start_android_emulator(server);\n     } else {\n         let rootfs = rootfs.as_ref().expect(\"need rootfs on non-android\");\n@@ -66,7 +72,7 @@ fn spawn_emulator(target: &str,\n     // Wait for the emulator to come online\n     loop {\n         let dur = Duration::from_millis(100);\n-        if let Ok(mut client) = TcpStream::connect(\"127.0.0.1:12345\") {\n+        if let Ok(mut client) = TcpStream::connect(&device_address) {\n             t!(client.set_read_timeout(Some(dur)));\n             t!(client.set_write_timeout(Some(dur)));\n             if client.write_all(b\"ping\").is_ok() {\n@@ -162,7 +168,8 @@ fn start_qemu_emulator(rootfs: &Path, server: &Path, tmpdir: &Path) {\n }\n \n fn push(path: &Path) {\n-    let client = t!(TcpStream::connect(\"127.0.0.1:12345\"));\n+    let device_address = env::var(REMOTE_ADDR_ENV).unwrap_or(\"127.0.0.1:12345\".to_string());\n+    let client = t!(TcpStream::connect(device_address));\n     let mut client = BufWriter::new(client);\n     t!(client.write_all(b\"push\"));\n     send(path, &mut client);\n@@ -178,7 +185,8 @@ fn push(path: &Path) {\n }\n \n fn run(files: String, args: Vec<String>) {\n-    let client = t!(TcpStream::connect(\"127.0.0.1:12345\"));\n+    let device_address = env::var(REMOTE_ADDR_ENV).unwrap_or(\"127.0.0.1:12345\".to_string());\n+    let client = t!(TcpStream::connect(device_address));\n     let mut client = BufWriter::new(client);\n     t!(client.write_all(b\"run \"));\n "}, {"sha": "ae13acd58bbc287b7f45206d8bf7f8802d6ede3d", "filename": "src/tools/remote-test-server/src/main.rs", "status": "modified", "additions": 49, "deletions": 6, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/b194def3a24e5d95c3f8eb7667b24e1237d823d3/src%2Ftools%2Fremote-test-server%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b194def3a24e5d95c3f8eb7667b24e1237d823d3/src%2Ftools%2Fremote-test-server%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fremote-test-server%2Fsrc%2Fmain.rs?ref=b194def3a24e5d95c3f8eb7667b24e1237d823d3", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/// This is a small server which is intended to run inside of an emulator. This\n-/// server pairs with the `remote-test-client` program in this repository. The\n-/// `remote-test-client` connects to this server over a TCP socket and performs\n-/// work such as:\n+/// This is a small server which is intended to run inside of an emulator or\n+/// on a remote test device. This server pairs with the `remote-test-client`\n+/// program in this repository. The `remote-test-client` connects to this\n+/// server over a TCP socket and performs work such as:\n ///\n /// 1. Pushing shared libraries to the server\n /// 2. Running tests through the server\n@@ -21,6 +21,7 @@\n /// basically custom format suiting our needs.\n \n use std::cmp;\n+use std::env;\n use std::fs::{self, File, Permissions};\n use std::io::prelude::*;\n use std::io::{self, BufReader};\n@@ -42,12 +43,54 @@ macro_rules! t {\n \n static TEST: AtomicUsize = ATOMIC_USIZE_INIT;\n \n+struct Config {\n+    pub remote: bool,\n+    pub verbose: bool,\n+}\n+\n+impl Config {\n+    pub fn default() -> Config {\n+        Config {\n+            remote: false,\n+            verbose: false,\n+        }\n+    }\n+\n+    pub fn parse_args() -> Config {\n+        let mut config = Config::default();\n+\n+        let args = env::args().skip(1);\n+        for argument in args {\n+            match &argument[..] {\n+                \"remote\" => {\n+                    config.remote = true;\n+                },\n+                \"verbose\" | \"-v\" => {\n+                    config.verbose = true;\n+                }\n+                arg => panic!(\"unknown argument: {}\", arg),\n+            }\n+        }\n+\n+        config\n+    }\n+}\n+\n fn main() {\n     println!(\"starting test server\");\n+\n+    let config = Config::parse_args();\n+\n+    let bind_addr = if cfg!(target_os = \"android\") || config.remote {\n+        \"0.0.0.0:12345\"\n+    } else {\n+        \"10.0.2.15:12345\"\n+    };\n+\n     let (listener, work) = if cfg!(target_os = \"android\") {\n-        (t!(TcpListener::bind(\"0.0.0.0:12345\")), \"/data/tmp/work\")\n+        (t!(TcpListener::bind(bind_addr)), \"/data/tmp/work\")\n     } else {\n-        (t!(TcpListener::bind(\"10.0.2.15:12345\")), \"/tmp/work\")\n+        (t!(TcpListener::bind(bind_addr)), \"/tmp/work\")\n     };\n     println!(\"listening!\");\n "}]}