{"sha": "7dc0d335bcc819c770320635a055c9cfe076339a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkYzBkMzM1YmNjODE5Yzc3MDMyMDYzNWEwNTVjOWNmZTA3NjMzOWE=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-09-13T21:04:44Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-09-13T21:04:44Z"}, "message": "Refactor `resolve_with_disambiguator` into a separate function", "tree": {"sha": "eb054682691e797a004d4f9a728e36d729c4ce28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb054682691e797a004d4f9a728e36d729c4ce28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7dc0d335bcc819c770320635a055c9cfe076339a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7dc0d335bcc819c770320635a055c9cfe076339a", "html_url": "https://github.com/rust-lang/rust/commit/7dc0d335bcc819c770320635a055c9cfe076339a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7dc0d335bcc819c770320635a055c9cfe076339a/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "245f69ad3c16c1f7355c3901e131fa01b588bf36", "url": "https://api.github.com/repos/rust-lang/rust/commits/245f69ad3c16c1f7355c3901e131fa01b588bf36", "html_url": "https://github.com/rust-lang/rust/commit/245f69ad3c16c1f7355c3901e131fa01b588bf36"}], "stats": {"total": 353, "additions": 190, "deletions": 163}, "files": [{"sha": "253a2a4b850e17cabbb0a3a28de103d54513476b", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 190, "deletions": 163, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/7dc0d335bcc819c770320635a055c9cfe076339a/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc0d335bcc819c770320635a055c9cfe076339a/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=7dc0d335bcc819c770320635a055c9cfe076339a", "patch": "@@ -998,169 +998,19 @@ impl LinkCollector<'_, '_> {\n                 }\n             }\n \n-            match disambiguator.map(Disambiguator::ns) {\n-                Some(ns @ (ValueNS | TypeNS)) => {\n-                    match self.resolve(path_str, ns, &current_item, base_node, &extra_fragment) {\n-                        Ok(res) => res,\n-                        Err(ErrorKind::Resolve(box mut kind)) => {\n-                            // We only looked in one namespace. Try to give a better error if possible.\n-                            if kind.full_res().is_none() {\n-                                let other_ns = if ns == ValueNS { TypeNS } else { ValueNS };\n-                                for &new_ns in &[other_ns, MacroNS] {\n-                                    if let Some(res) = self.check_full_res(\n-                                        new_ns,\n-                                        path_str,\n-                                        base_node,\n-                                        &current_item,\n-                                        &extra_fragment,\n-                                    ) {\n-                                        kind = ResolutionFailure::WrongNamespace(res, ns);\n-                                        break;\n-                                    }\n-                                }\n-                            }\n-                            resolution_failure(\n-                                self,\n-                                &item,\n-                                path_str,\n-                                disambiguator,\n-                                dox,\n-                                link_range,\n-                                smallvec![kind],\n-                            );\n-                            // This could just be a normal link or a broken link\n-                            // we could potentially check if something is\n-                            // \"intra-doc-link-like\" and warn in that case.\n-                            return;\n-                        }\n-                        Err(ErrorKind::AnchorFailure(msg)) => {\n-                            anchor_failure(cx, &item, &ori_link, dox, link_range, msg);\n-                            return;\n-                        }\n-                    }\n-                }\n-                None => {\n-                    // Try everything!\n-                    let mut candidates = PerNS {\n-                        macro_ns: self\n-                            .macro_resolve(path_str, base_node)\n-                            .map(|res| (res, extra_fragment.clone())),\n-                        type_ns: match self.resolve(\n-                            path_str,\n-                            TypeNS,\n-                            &current_item,\n-                            base_node,\n-                            &extra_fragment,\n-                        ) {\n-                            Ok(res) => {\n-                                debug!(\"got res in TypeNS: {:?}\", res);\n-                                Ok(res)\n-                            }\n-                            Err(ErrorKind::AnchorFailure(msg)) => {\n-                                anchor_failure(cx, &item, &ori_link, dox, link_range, msg);\n-                                return;\n-                            }\n-                            Err(ErrorKind::Resolve(box kind)) => Err(kind),\n-                        },\n-                        value_ns: match self.resolve(\n-                            path_str,\n-                            ValueNS,\n-                            &current_item,\n-                            base_node,\n-                            &extra_fragment,\n-                        ) {\n-                            Ok(res) => Ok(res),\n-                            Err(ErrorKind::AnchorFailure(msg)) => {\n-                                anchor_failure(cx, &item, &ori_link, dox, link_range, msg);\n-                                return;\n-                            }\n-                            Err(ErrorKind::Resolve(box kind)) => Err(kind),\n-                        }\n-                        .and_then(|(res, fragment)| {\n-                            // Constructors are picked up in the type namespace.\n-                            match res {\n-                                Res::Def(DefKind::Ctor(..), _) | Res::SelfCtor(..) => {\n-                                    Err(ResolutionFailure::WrongNamespace(res, TypeNS))\n-                                }\n-                                _ => match (fragment, extra_fragment) {\n-                                    (Some(fragment), Some(_)) => {\n-                                        // Shouldn't happen but who knows?\n-                                        Ok((res, Some(fragment)))\n-                                    }\n-                                    (fragment, None) | (None, fragment) => Ok((res, fragment)),\n-                                },\n-                            }\n-                        }),\n-                    };\n-\n-                    let len = candidates.iter().filter(|res| res.is_ok()).count();\n-\n-                    if len == 0 {\n-                        resolution_failure(\n-                            self,\n-                            &item,\n-                            path_str,\n-                            disambiguator,\n-                            dox,\n-                            link_range,\n-                            candidates.into_iter().filter_map(|res| res.err()).collect(),\n-                        );\n-                        // this could just be a normal link\n-                        return;\n-                    }\n-\n-                    if len == 1 {\n-                        candidates.into_iter().filter_map(|res| res.ok()).next().unwrap()\n-                    } else if len == 2 && is_derive_trait_collision(&candidates) {\n-                        candidates.type_ns.unwrap()\n-                    } else {\n-                        if is_derive_trait_collision(&candidates) {\n-                            candidates.macro_ns = Err(ResolutionFailure::Dummy);\n-                        }\n-                        // If we're reporting an ambiguity, don't mention the namespaces that failed\n-                        let candidates =\n-                            candidates.map(|candidate| candidate.ok().map(|(res, _)| res));\n-                        ambiguity_error(\n-                            cx,\n-                            &item,\n-                            path_str,\n-                            dox,\n-                            link_range,\n-                            candidates.present_items().collect(),\n-                        );\n-                        return;\n-                    }\n-                }\n-                Some(MacroNS) => {\n-                    match self.macro_resolve(path_str, base_node) {\n-                        Ok(res) => (res, extra_fragment),\n-                        Err(mut kind) => {\n-                            // `macro_resolve` only looks in the macro namespace. Try to give a better error if possible.\n-                            for &ns in &[TypeNS, ValueNS] {\n-                                if let Some(res) = self.check_full_res(\n-                                    ns,\n-                                    path_str,\n-                                    base_node,\n-                                    &current_item,\n-                                    &extra_fragment,\n-                                ) {\n-                                    kind = ResolutionFailure::WrongNamespace(res, MacroNS);\n-                                    break;\n-                                }\n-                            }\n-                            resolution_failure(\n-                                self,\n-                                &item,\n-                                path_str,\n-                                disambiguator,\n-                                dox,\n-                                link_range,\n-                                smallvec![kind],\n-                            );\n-                            return;\n-                        }\n-                    }\n-                }\n+            match self.resolve_with_disambiguator(\n+                disambiguator,\n+                item,\n+                dox,\n+                path_str,\n+                current_item,\n+                base_node,\n+                extra_fragment,\n+                &ori_link,\n+                link_range.clone(),\n+            ) {\n+                Some(x) => x,\n+                None => return,\n             }\n         };\n \n@@ -1274,6 +1124,183 @@ impl LinkCollector<'_, '_> {\n             item.attrs.links.push(ItemLink { link: ori_link, link_text, did: Some(id), fragment });\n         }\n     }\n+\n+    fn resolve_with_disambiguator(\n+        &self,\n+        disambiguator: Option<Disambiguator>,\n+        item: &mut Item,\n+        dox: &str,\n+        path_str: &str,\n+        current_item: &Option<String>,\n+        base_node: Option<DefId>,\n+        extra_fragment: Option<String>,\n+        ori_link: &str,\n+        link_range: Option<Range<usize>>,\n+    ) -> Option<(Res, Option<String>)> {\n+        match disambiguator.map(Disambiguator::ns) {\n+            Some(ns @ (ValueNS | TypeNS)) => {\n+                match self.resolve(path_str, ns, &current_item, base_node, &extra_fragment) {\n+                    Ok(res) => Some(res),\n+                    Err(ErrorKind::Resolve(box mut kind)) => {\n+                        // We only looked in one namespace. Try to give a better error if possible.\n+                        if kind.full_res().is_none() {\n+                            let other_ns = if ns == ValueNS { TypeNS } else { ValueNS };\n+                            for &new_ns in &[other_ns, MacroNS] {\n+                                if let Some(res) = self.check_full_res(\n+                                    new_ns,\n+                                    path_str,\n+                                    base_node,\n+                                    &current_item,\n+                                    &extra_fragment,\n+                                ) {\n+                                    kind = ResolutionFailure::WrongNamespace(res, ns);\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                        resolution_failure(\n+                            self,\n+                            &item,\n+                            path_str,\n+                            disambiguator,\n+                            dox,\n+                            link_range,\n+                            smallvec![kind],\n+                        );\n+                        // This could just be a normal link or a broken link\n+                        // we could potentially check if something is\n+                        // \"intra-doc-link-like\" and warn in that case.\n+                        return None;\n+                    }\n+                    Err(ErrorKind::AnchorFailure(msg)) => {\n+                        anchor_failure(self.cx, &item, &ori_link, dox, link_range, msg);\n+                        return None;\n+                    }\n+                }\n+            }\n+            None => {\n+                // Try everything!\n+                let mut candidates = PerNS {\n+                    macro_ns: self\n+                        .macro_resolve(path_str, base_node)\n+                        .map(|res| (res, extra_fragment.clone())),\n+                    type_ns: match self.resolve(\n+                        path_str,\n+                        TypeNS,\n+                        &current_item,\n+                        base_node,\n+                        &extra_fragment,\n+                    ) {\n+                        Ok(res) => {\n+                            debug!(\"got res in TypeNS: {:?}\", res);\n+                            Ok(res)\n+                        }\n+                        Err(ErrorKind::AnchorFailure(msg)) => {\n+                            anchor_failure(self.cx, &item, ori_link, dox, link_range, msg);\n+                            return None;\n+                        }\n+                        Err(ErrorKind::Resolve(box kind)) => Err(kind),\n+                    },\n+                    value_ns: match self.resolve(\n+                        path_str,\n+                        ValueNS,\n+                        &current_item,\n+                        base_node,\n+                        &extra_fragment,\n+                    ) {\n+                        Ok(res) => Ok(res),\n+                        Err(ErrorKind::AnchorFailure(msg)) => {\n+                            anchor_failure(self.cx, &item, ori_link, dox, link_range, msg);\n+                            return None;\n+                        }\n+                        Err(ErrorKind::Resolve(box kind)) => Err(kind),\n+                    }\n+                    .and_then(|(res, fragment)| {\n+                        // Constructors are picked up in the type namespace.\n+                        match res {\n+                            Res::Def(DefKind::Ctor(..), _) | Res::SelfCtor(..) => {\n+                                Err(ResolutionFailure::WrongNamespace(res, TypeNS))\n+                            }\n+                            _ => match (fragment, extra_fragment) {\n+                                (Some(fragment), Some(_)) => {\n+                                    // Shouldn't happen but who knows?\n+                                    Ok((res, Some(fragment)))\n+                                }\n+                                (fragment, None) | (None, fragment) => Ok((res, fragment)),\n+                            },\n+                        }\n+                    }),\n+                };\n+\n+                let len = candidates.iter().filter(|res| res.is_ok()).count();\n+\n+                if len == 0 {\n+                    resolution_failure(\n+                        self,\n+                        &item,\n+                        path_str,\n+                        disambiguator,\n+                        dox,\n+                        link_range,\n+                        candidates.into_iter().filter_map(|res| res.err()).collect(),\n+                    );\n+                    // this could just be a normal link\n+                    return None;\n+                }\n+\n+                if len == 1 {\n+                    Some(candidates.into_iter().filter_map(|res| res.ok()).next().unwrap())\n+                } else if len == 2 && is_derive_trait_collision(&candidates) {\n+                    Some(candidates.type_ns.unwrap())\n+                } else {\n+                    if is_derive_trait_collision(&candidates) {\n+                        candidates.macro_ns = Err(ResolutionFailure::Dummy);\n+                    }\n+                    // If we're reporting an ambiguity, don't mention the namespaces that failed\n+                    let candidates = candidates.map(|candidate| candidate.ok().map(|(res, _)| res));\n+                    ambiguity_error(\n+                        self.cx,\n+                        &item,\n+                        path_str,\n+                        dox,\n+                        link_range,\n+                        candidates.present_items().collect(),\n+                    );\n+                    return None;\n+                }\n+            }\n+            Some(MacroNS) => {\n+                match self.macro_resolve(path_str, base_node) {\n+                    Ok(res) => Some((res, extra_fragment)),\n+                    Err(mut kind) => {\n+                        // `macro_resolve` only looks in the macro namespace. Try to give a better error if possible.\n+                        for &ns in &[TypeNS, ValueNS] {\n+                            if let Some(res) = self.check_full_res(\n+                                ns,\n+                                path_str,\n+                                base_node,\n+                                &current_item,\n+                                &extra_fragment,\n+                            ) {\n+                                kind = ResolutionFailure::WrongNamespace(res, MacroNS);\n+                                break;\n+                            }\n+                        }\n+                        resolution_failure(\n+                            self,\n+                            &item,\n+                            path_str,\n+                            disambiguator,\n+                            dox,\n+                            link_range,\n+                            smallvec![kind],\n+                        );\n+                        return None;\n+                    }\n+                }\n+            }\n+        }\n+    }\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]"}]}