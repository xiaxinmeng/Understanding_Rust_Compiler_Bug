{"sha": "924bb1e5ebeab4189c3c48dabae4915825b097b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyNGJiMWU1ZWJlYWI0MTg5YzNjNDhkYWJhZTQ5MTU4MjViMDk3YjA=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2015-12-19T14:48:49Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-01-06T11:57:51Z"}, "message": "Refine call terminator translation\n\n* Implement landing pads; and\n* Implement DivergingCall translation; and\n* Modernise previous implementation of Call somewhat.", "tree": {"sha": "023cc6ed131eb0a846dff1807b6da945aa132066", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/023cc6ed131eb0a846dff1807b6da945aa132066"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/924bb1e5ebeab4189c3c48dabae4915825b097b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/924bb1e5ebeab4189c3c48dabae4915825b097b0", "html_url": "https://github.com/rust-lang/rust/commit/924bb1e5ebeab4189c3c48dabae4915825b097b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/924bb1e5ebeab4189c3c48dabae4915825b097b0/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1e13983f7d3890c3fb984179925ed8ad2dee31c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1e13983f7d3890c3fb984179925ed8ad2dee31c", "html_url": "https://github.com/rust-lang/rust/commit/a1e13983f7d3890c3fb984179925ed8ad2dee31c"}], "stats": {"total": 141, "additions": 96, "deletions": 45}, "files": [{"sha": "d41c4dec2b28bd906de902c91d12398f89ac6c76", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 96, "deletions": 45, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/924bb1e5ebeab4189c3c48dabae4915825b097b0/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924bb1e5ebeab4189c3c48dabae4915825b097b0/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=924bb1e5ebeab4189c3c48dabae4915825b097b0", "patch": "@@ -80,12 +80,12 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n \n             mir::Terminator::Resume => {\n-                if let Some(llpersonalityslot) = self.llpersonalityslot {\n-                    let lp = build::Load(bcx, llpersonalityslot);\n-                    // FIXME(lifetime) base::call_lifetime_end(bcx, self.personality);\n+                if let Some(personalityslot) = self.llpersonalityslot {\n+                    let lp = build::Load(bcx, personalityslot);\n+                    base::call_lifetime_end(bcx, personalityslot);\n                     build::Resume(bcx, lp);\n                 } else {\n-                    panic!(\"resume terminator without personality slot\")\n+                    panic!(\"resume terminator without personality slot set\")\n                 }\n             }\n \n@@ -94,33 +94,27 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 base::build_return_block(bcx.fcx, bcx, return_ty, DebugLoc::None);\n             }\n \n-            mir::Terminator::Call { ref data, targets } => {\n+            mir::Terminator::Call { ref func, ref args, ref destination, ref targets } => {\n                 // The location we'll write the result of the call into.\n-                let call_dest = self.trans_lvalue(bcx, &data.destination);\n-\n+                let call_dest = self.trans_lvalue(bcx, destination);\n+                let ret_ty = call_dest.ty.to_ty(bcx.tcx());\n                 // Create the callee. This will always be a fn\n                 // ptr and hence a kind of scalar.\n-                let callee = self.trans_operand(bcx, &data.func);\n-                let ret_ty = if let ty::TyBareFn(_, ref f) = callee.ty.sty {\n-                    let sig = bcx.tcx().erase_late_bound_regions(&f.sig);\n-                    let sig = infer::normalize_associated_type(bcx.tcx(), &sig);\n-                    sig.output\n+                let callee = self.trans_operand(bcx, func);\n+\n+                // Does the fn use an outptr? If so, we have an extra first argument.\n+                let return_outptr = type_of::return_uses_outptr(bcx.ccx(), ret_ty);\n+                // The arguments we'll be passing.\n+                let mut llargs = if return_outptr {\n+                    let mut vec = Vec::with_capacity(args.len() + 1);\n+                    vec.push(call_dest.llval);\n+                    vec\n                 } else {\n-                    panic!(\"trans_block: expected TyBareFn as callee\");\n+                    Vec::with_capacity(args.len())\n                 };\n \n-                // The arguments we'll be passing\n-                let mut llargs = vec![];\n-\n-                // Does the fn use an outptr? If so, that's the first arg.\n-                if let ty::FnConverging(ret_ty) = ret_ty {\n-                    if type_of::return_uses_outptr(bcx.ccx(), ret_ty) {\n-                        llargs.push(call_dest.llval);\n-                    }\n-                }\n-\n                 // Process the rest of the args.\n-                for arg in &data.args {\n+                for arg in args {\n                     let arg_op = self.trans_operand(bcx, arg);\n                     match arg_op.val {\n                         Ref(llval) | Immediate(llval) => llargs.push(llval),\n@@ -132,35 +126,92 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     }\n                 }\n \n-                // FIXME: Handle panics\n-                //let panic_bb = self.llblock(targets.1);\n-                //self.make_landing_pad(panic_bb);\n-\n-                // Do the actual call.\n-                let (llret, b) = base::invoke(bcx,\n-                                              callee.immediate(),\n-                                              &llargs[..],\n-                                              callee.ty,\n-                                              DebugLoc::None);\n-                bcx = b;\n-\n-                // Copy the return value into the destination.\n-                if let ty::FnConverging(ret_ty) = ret_ty {\n-                    if !type_of::return_uses_outptr(bcx.ccx(), ret_ty) &&\n-                       !common::type_is_zero_size(bcx.ccx(), ret_ty) {\n-                        base::store_ty(bcx, llret, call_dest.llval, ret_ty);\n+                let debugloc = DebugLoc::None;\n+                let attrs = attributes::from_fn_type(bcx.ccx(), callee.ty);\n+                match *targets {\n+                    mir::CallTargets::Return(ret) => {\n+                        let llret = build::Call(bcx,\n+                                                callee.immediate(),\n+                                                &llargs[..],\n+                                                Some(attrs),\n+                                                debugloc);\n+                        if !return_outptr && !common::type_is_zero_size(bcx.ccx(), ret_ty) {\n+                            base::store_ty(bcx, llret, call_dest.llval, ret_ty);\n+                        }\n+                        build::Br(bcx, self.llblock(ret), debugloc)\n+                    }\n+                    mir::CallTargets::WithCleanup((ret, cleanup)) => {\n+                        let landingpad = self.make_landing_pad(cleanup);\n+                        build::Invoke(bcx,\n+                                      callee.immediate(),\n+                                      &llargs[..],\n+                                      self.llblock(ret),\n+                                      landingpad.llbb,\n+                                      Some(attrs),\n+                                      debugloc);\n+                        if !return_outptr && !common::type_is_zero_size(bcx.ccx(), ret_ty) {\n+                            // FIXME: What do we do here?\n+                            unimplemented!()\n+                        }\n                     }\n                 }\n-\n-                build::Br(bcx, self.llblock(targets.0), DebugLoc::None)\n             },\n \n-            mir::Terminator::DivergingCall { .. } => {\n-                unimplemented!()\n+            mir::Terminator::DivergingCall { ref func, ref args, ref cleanup } => {\n+                let callee = self.trans_operand(bcx, func);\n+                let mut llargs = Vec::with_capacity(args.len());\n+                for arg in args {\n+                    match self.trans_operand(bcx, arg).val {\n+                        Ref(llval) | Immediate(llval) => llargs.push(llval),\n+                        FatPtr(b, e) => {\n+                            llargs.push(b);\n+                            llargs.push(e);\n+                        }\n+                    }\n+                }\n+                let debugloc = DebugLoc::None;\n+                let attrs = attributes::from_fn_type(bcx.ccx(), callee.ty);\n+                match *cleanup {\n+                    None => {\n+                        build::Call(bcx, callee.immediate(), &llargs[..], Some(attrs), debugloc);\n+                        build::Unreachable(bcx);\n+                    }\n+                    Some(cleanup) => {\n+                        let landingpad = self.make_landing_pad(cleanup);\n+                        let unreachable = self.unreachable_block();\n+                        build::Invoke(bcx,\n+                                      callee.immediate(),\n+                                      &llargs[..],\n+                                      unreachable.llbb,\n+                                      landingpad.llbb,\n+                                      Some(attrs),\n+                                      debugloc);\n+                    }\n+                }\n             }\n         }\n     }\n \n+    fn make_landing_pad(&mut self, cleanup: mir::BasicBlock) -> Block<'bcx, 'tcx> {\n+        let bcx = self.bcx(cleanup).fcx.new_block(true, \"cleanup\", None);\n+        let ccx = bcx.ccx();\n+        let llpersonality = bcx.fcx.eh_personality();\n+        let llretty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)], false);\n+        let llretval = build::LandingPad(bcx, llretty, llpersonality, 1);\n+        build::SetCleanup(bcx, llretval);\n+        match self.llpersonalityslot {\n+            Some(slot) => build::Store(bcx, llretval, slot),\n+            None => {\n+                let personalityslot = base::alloca(bcx, llretty, \"personalityslot\");\n+                self.llpersonalityslot = Some(personalityslot);\n+                base::call_lifetime_start(bcx, personalityslot);\n+                build::Store(bcx, llretval, personalityslot)\n+            }\n+        };\n+        build::Br(bcx, self.llblock(cleanup), DebugLoc::None);\n+        bcx\n+    }\n+\n     fn unreachable_block(&mut self) -> Block<'bcx, 'tcx> {\n         match self.unreachable_block {\n             Some(b) => b,"}]}