{"sha": "1d57800236ef113027aea52289c1fcbb949234e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkNTc4MDAyMzZlZjExMzAyN2FlYTUyMjg5YzFmY2JiOTQ5MjM0ZTI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-05T03:37:23Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-06T22:13:54Z"}, "message": "rustc: Migrate tag variants to interior vectors", "tree": {"sha": "26dbf38db29cafc1c31d704e8cf34418efe3bd98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26dbf38db29cafc1c31d704e8cf34418efe3bd98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d57800236ef113027aea52289c1fcbb949234e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d57800236ef113027aea52289c1fcbb949234e2", "html_url": "https://github.com/rust-lang/rust/commit/1d57800236ef113027aea52289c1fcbb949234e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d57800236ef113027aea52289c1fcbb949234e2/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e1aa04fcd587367e42aa18350dc6879a32f9477", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e1aa04fcd587367e42aa18350dc6879a32f9477", "html_url": "https://github.com/rust-lang/rust/commit/2e1aa04fcd587367e42aa18350dc6879a32f9477"}], "stats": {"total": 72, "additions": 35, "deletions": 37}, "files": [{"sha": "441f689447ea8826076368dc4e728ed4968842f5", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1d57800236ef113027aea52289c1fcbb949234e2/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d57800236ef113027aea52289c1fcbb949234e2/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=1d57800236ef113027aea52289c1fcbb949234e2", "patch": "@@ -194,27 +194,27 @@ fn get_symbol(session::session sess, ast::def_id def) -> str {\n     ret item_symbol(lookup_item(def._1, data));\n }\n \n-fn get_tag_variants(ty::ctxt tcx, ast::def_id def) -> vec[ty::variant_info] {\n+fn get_tag_variants(ty::ctxt tcx, ast::def_id def) -> ty::variant_info[] {\n     auto external_crate_id = def._0;\n     auto data = tcx.sess.get_external_crate(external_crate_id).data;\n     auto items = ebml::get_doc(ebml::new_doc(data), tag_items);\n     auto item = find_item(def._1, items);\n-    let vec[ty::variant_info] infos = [];\n+    let ty::variant_info[] infos = ~[];\n     auto variant_ids = tag_variant_ids(item, external_crate_id);\n     for (ast::def_id did in variant_ids) {\n         auto item = find_item(did._1, items);\n         auto ctor_ty = item_type(item, external_crate_id, tcx);\n-        let vec[ty::t] arg_tys = [];\n+        let ty::t[] arg_tys = ~[];\n         alt (ty::struct(tcx, ctor_ty)) {\n             case (ty::ty_fn(_, ?args, _, _, _)) {\n-                for (ty::arg a in args) { arg_tys += [a.ty]; }\n+                for (ty::arg a in args) { arg_tys += ~[a.ty]; }\n             }\n             case (_) {\n                 // Nullary tag variant.\n \n             }\n         }\n-        infos += [rec(args=arg_tys, ctor_ty=ctor_ty, id=did)];\n+        infos += ~[rec(args=arg_tys, ctor_ty=ctor_ty, id=did)];\n     }\n     ret infos;\n }"}, {"sha": "ecea057a5da061670fc01d8b0b32586f16461efe", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1d57800236ef113027aea52289c1fcbb949234e2/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d57800236ef113027aea52289c1fcbb949234e2/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=1d57800236ef113027aea52289c1fcbb949234e2", "patch": "@@ -903,7 +903,7 @@ fn type_of_inner(&@crate_ctxt cx, &span sp, &ty::t t) -> TypeRef {\n \n fn type_of_tag(&@crate_ctxt cx, &span sp, &ast::def_id did, &ty::t t)\n     -> TypeRef {\n-    auto degen = vec::len(ty::tag_variants(cx.tcx, did)) == 1u;\n+    auto degen = std::ivec::len(ty::tag_variants(cx.tcx, did)) == 1u;\n     if (ty::type_has_dynamic_size(cx.tcx, t)) {\n         if (degen) { ret T_i8(); }\n         else { ret T_opaque_tag(cx.tn); }\n@@ -1351,7 +1351,7 @@ fn dynamic_size_of(&@block_ctxt cx, ty::t t) -> result {\n             for (ty::variant_info variant in variants) {\n                 // Perform type substitution on the raw argument types.\n \n-                let vec[ty::t] raw_tys = variant.args;\n+                let ty::t[] raw_tys = variant.args;\n                 let vec[ty::t] tys = [];\n                 for (ty::t raw_ty in raw_tys) {\n                     auto t =\n@@ -1366,7 +1366,7 @@ fn dynamic_size_of(&@block_ctxt cx, ty::t t) -> result {\n                 bcx.build.Store(umax(bcx, this_size, old_max_size), max_size);\n             }\n             auto max_size_val = bcx.build.Load(max_size);\n-            auto total_size = if (vec::len(variants) != 1u) {\n+            auto total_size = if (std::ivec::len(variants) != 1u) {\n                 bcx.build.Add(max_size_val, llsize_of(T_int()))\n             } else { max_size_val };\n             ret rslt(bcx, total_size);\n@@ -2655,7 +2655,7 @@ fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n     fn iter_variant(@block_ctxt cx, ValueRef a_tup, ValueRef b_tup,\n                     &ty::variant_info variant, &ty::t[] tps,\n                     &ast::def_id tid, &val_pair_and_ty_fn f) -> result {\n-        if (vec::len[ty::t](variant.args) == 0u) {\n+        if (std::ivec::len[ty::t](variant.args) == 0u) {\n             ret rslt(cx, C_nil());\n         }\n         auto fn_ty = variant.ctor_ty;\n@@ -2664,12 +2664,10 @@ fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n             case (ty::ty_fn(_, ?args, _, _, _)) {\n                 auto j = 0;\n                 for (ty::arg a in args) {\n-                    auto rslt = GEP_tag(cx, a_tup, tid,\n-                                        variant.id, tps, j);\n+                    auto rslt = GEP_tag(cx, a_tup, tid, variant.id, tps, j);\n                     auto llfldp_a = rslt.val;\n                     cx = rslt.bcx;\n-                    rslt = GEP_tag(cx, b_tup, tid,\n-                                   variant.id, tps, j);\n+                    rslt = GEP_tag(cx, b_tup, tid, variant.id, tps, j);\n                     auto llfldp_b = rslt.val;\n                     cx = rslt.bcx;\n                     auto ty_subst =\n@@ -2730,7 +2728,7 @@ fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n         }\n         case (ty::ty_tag(?tid, ?tps)) {\n             auto variants = ty::tag_variants(cx.fcx.lcx.ccx.tcx, tid);\n-            auto n_variants = vec::len(variants);\n+            auto n_variants = std::ivec::len(variants);\n \n             // Cast the tags to types we can GEP into.\n             if (n_variants == 1u) {\n@@ -4159,8 +4157,8 @@ fn autoderef_lval(&@block_ctxt cx, ValueRef v, &ty::t t, bool is_lval)\n             }\n             case (ty::ty_tag(?did, ?tps)) {\n                 auto variants = ty::tag_variants(ccx.tcx, did);\n-                if (vec::len(variants) != 1u ||\n-                    vec::len(variants.(0).args) != 1u) {\n+                if (std::ivec::len(variants) != 1u ||\n+                    std::ivec::len(variants.(0).args) != 1u) {\n                     break;\n                 }\n                 if (is_lval) { v1 = cx.build.Load(v1); }\n@@ -4700,7 +4698,7 @@ fn trans_pat_match(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n             auto matched_cx = new_sub_block_ctxt(cx, \"matched_cx\");\n             auto llblobptr = llval;\n \n-            if (vec::len(variants) == 1u) {\n+            if (std::ivec::len(variants) == 1u) {\n                 cx.build.Br(matched_cx.llbb);\n             } else {\n                 auto lltagptr =\n@@ -4789,7 +4787,8 @@ fn trans_pat_binding(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n                       \"trans_pat_binding: internal error, unbound var\"); }\n             }\n             auto llblobptr = llval;\n-            if (vec::len(ty::tag_variants(cx.fcx.lcx.ccx.tcx, vdef._0))!=1u) {\n+            if (std::ivec::len(ty::tag_variants(cx.fcx.lcx.ccx.tcx, vdef._0))\n+                    != 1u) {\n                 auto lltagptr = cx.build.PointerCast\n                     (llval, T_opaque_tag_ptr(cx.fcx.lcx.ccx.tn));\n                 llblobptr = cx.build.GEP(lltagptr, [C_int(0), C_int(1)]);\n@@ -4987,7 +4986,8 @@ fn trans_path(&@block_ctxt cx, &ast::path p, ast::node_id id) -> lval_result {\n                     auto bcx = alloc_result.bcx;\n                     auto lltagptr = bcx.build.PointerCast\n                         (lltagblob, T_ptr(lltagty));\n-                    if (vec::len(ty::tag_variants(ccx.tcx, tid)) != 1u) {\n+                    if (std::ivec::len(ty::tag_variants(ccx.tcx, tid))\n+                            != 1u) {\n                         auto lldiscrim_gv =\n                             lookup_discriminant(bcx.fcx.lcx, tid, vid);\n                         auto lldiscrim = bcx.build.Load(lldiscrim_gv);"}, {"sha": "56291c111a1a0e52ba8fdd78b342479e998dfc75", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1d57800236ef113027aea52289c1fcbb949234e2/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d57800236ef113027aea52289c1fcbb949234e2/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=1d57800236ef113027aea52289c1fcbb949234e2", "patch": "@@ -1288,8 +1288,8 @@ fn type_autoderef(&ctxt cx, &ty::t t) -> ty::t {\n             }\n             case (ty::ty_tag(?did, ?tps)) {\n                 auto variants = tag_variants(cx, did);\n-                if (vec::len(variants) != 1u ||\n-                    vec::len(variants.(0).args) != 1u) {\n+                if (ivec::len(variants) != 1u ||\n+                        ivec::len(variants.(0).args) != 1u) {\n                     break;\n                 }\n                 t1 = substitute_type_params(cx, tps, variants.(0).args.(0));\n@@ -2812,12 +2812,10 @@ fn def_has_ty_params(&ast::def def) -> bool {\n \n \n // Tag information\n-type variant_info = rec(vec[ty::t] args, ty::t ctor_ty, ast::def_id id);\n+type variant_info = rec(ty::t[] args, ty::t ctor_ty, ast::def_id id);\n \n-fn tag_variants(&ctxt cx, &ast::def_id id) -> vec[variant_info] {\n-    if (ast::local_crate != id._0) {\n-        ret decoder::get_tag_variants(cx, id);\n-    }\n+fn tag_variants(&ctxt cx, &ast::def_id id) -> variant_info[] {\n+    if (ast::local_crate != id._0) { ret decoder::get_tag_variants(cx, id); }\n     auto item = alt (cx.items.find(id._1)) {\n         case (some(?i)) { i }\n         case (none) {\n@@ -2828,22 +2826,22 @@ fn tag_variants(&ctxt cx, &ast::def_id id) -> vec[variant_info] {\n         case (ast_map::node_item(?item)) {\n             alt (item.node) {\n                 case (ast::item_tag(?variants, _)) {\n-                    let vec[variant_info] result = [];\n+                    let variant_info[] result = ~[];\n                     for (ast::variant variant in variants) {\n                         auto ctor_ty = node_id_to_monotype\n                             (cx, variant.node.id);\n-                        let vec[t] arg_tys = [];\n+                        let t[] arg_tys = ~[];\n                         if (vec::len[ast::variant_arg](variant.node.args) >\n                                 0u) {\n                             for (arg a in ty_fn_args(cx, ctor_ty)) {\n-                                arg_tys += [a.ty];\n+                                arg_tys += ~[a.ty];\n                             }\n                         }\n                         auto did = variant.node.id;\n                         result +=\n-                            [rec(args=arg_tys,\n-                                 ctor_ty=ctor_ty,\n-                                 id=ast::local_def(did))];\n+                            ~[rec(args=arg_tys,\n+                                  ctor_ty=ctor_ty,\n+                                  id=ast::local_def(did))];\n                     }\n                     ret result;\n                 }\n@@ -2858,7 +2856,7 @@ fn tag_variant_with_id(&ctxt cx, &ast::def_id tag_id, &ast::def_id variant_id)\n    -> variant_info {\n     auto variants = tag_variants(cx, tag_id);\n     auto i = 0u;\n-    while (i < vec::len[variant_info](variants)) {\n+    while (i < ivec::len[variant_info](variants)) {\n         auto variant = variants.(i);\n         if (def_eq(variant.id, variant_id)) { ret variant; }\n         i += 1u;"}, {"sha": "ec4a9f042e8230d465c4e3197855645040275874", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1d57800236ef113027aea52289c1fcbb949234e2/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d57800236ef113027aea52289c1fcbb949234e2/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=1d57800236ef113027aea52289c1fcbb949234e2", "patch": "@@ -876,8 +876,8 @@ fn do_autoderef(&@fn_ctxt fcx, &span sp, &ty::t t) -> ty::t {\n             }\n             case (ty::ty_tag(?did, ?tps)) {\n                 auto variants = ty::tag_variants(fcx.ccx.tcx, did);\n-                if (vec::len(variants) != 1u ||\n-                    vec::len(variants.(0).args) != 1u) {\n+                if (ivec::len(variants) != 1u ||\n+                        ivec::len(variants.(0).args) != 1u) {\n                     ret t1;\n                 }\n                 t1 = ty::substitute_type_params(fcx.ccx.tcx, tps,\n@@ -1651,8 +1651,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                         case (ty::ty_res(_, ?inner, _)) { oper_t = inner; }\n                         case (ty::ty_tag(?id, ?tps)) {\n                             auto variants = ty::tag_variants(fcx.ccx.tcx, id);\n-                            if (vec::len(variants) != 1u ||\n-                                vec::len(variants.(0).args) != 1u) {\n+                            if (ivec::len(variants) != 1u ||\n+                                    ivec::len(variants.(0).args) != 1u) {\n                                 fcx.ccx.tcx.sess.span_fatal\n                                     (expr.span, \"can only dereference tags \" +\n                                      \"with a single variant which has a \" +"}]}