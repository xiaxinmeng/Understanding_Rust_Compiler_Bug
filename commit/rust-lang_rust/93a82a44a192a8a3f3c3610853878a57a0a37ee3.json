{"sha": "93a82a44a192a8a3f3c3610853878a57a0a37ee3", "node_id": "C_kwDOAAsO6NoAKDkzYTgyYTQ0YTE5MmE4YTNmM2MzNjEwODUzODc4YTU3YTBhMzdlZTM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-03-21T18:00:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-21T18:00:11Z"}, "message": "Rollup merge of #108164 - joboet:discard_messages_mpmc_array, r=Amanieu\n\nDrop all messages in bounded channel when destroying the last receiver\n\nFixes #107466 by splitting the `disconnect` function for receivers/transmitters and dropping all messages in `disconnect_receivers` like the unbounded channel does. Since all receivers must be dropped before the channel is, the messages will already be discarded at that point, so the `Drop` implementation for the channel can be removed.\n\n``@rustbot`` label +T-libs +A-concurrency", "tree": {"sha": "cd8f577063f6c3d5c81b9eac2b41da9181d939b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd8f577063f6c3d5c81b9eac2b41da9181d939b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93a82a44a192a8a3f3c3610853878a57a0a37ee3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkGfCrCRBK7hj4Ov3rIwAARm4IAAEH4stBqIxu+cIGxrBs+5aL\nH49dsrcLo6zB2Enwe4eE6Tm55qYlV+rjLo/rLx13YuDXUT87YLRiyYiiOrCRVZuT\n56MsTWV/xZjBimlro3hm+mEz5c0AV16g0LTw3Mmfj7canqIZ2y/PkFP3foNPfJAY\nFwIhzAVFyHg9+oRHCxHkxmKuEFqO4cDWSRpKi40i3LGWfa+H40KMfSH1lEldpAbF\nXWiJnRi0r8Rsql5P4YF7cf+nAStEe0hVvmb7rxPYc95XE8hVU3vjdIfH8GT+lLR8\nwbkg+QZxw+NmlvqY9YAG4Jwr4wrF6Fnf4ESVS6pZqxfgUHI2b232w8SSOBNHF4I=\n=6cO/\n-----END PGP SIGNATURE-----\n", "payload": "tree cd8f577063f6c3d5c81b9eac2b41da9181d939b6\nparent 1a43859a747a8916dbec98b8847a237e6caaf994\nparent 34aa87292c5cd45c88a72235dad6e973a9f2b62f\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1679421611 +0100\ncommitter GitHub <noreply@github.com> 1679421611 +0100\n\nRollup merge of #108164 - joboet:discard_messages_mpmc_array, r=Amanieu\n\nDrop all messages in bounded channel when destroying the last receiver\n\nFixes #107466 by splitting the `disconnect` function for receivers/transmitters and dropping all messages in `disconnect_receivers` like the unbounded channel does. Since all receivers must be dropped before the channel is, the messages will already be discarded at that point, so the `Drop` implementation for the channel can be removed.\n\n``@rustbot`` label +T-libs +A-concurrency\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93a82a44a192a8a3f3c3610853878a57a0a37ee3", "html_url": "https://github.com/rust-lang/rust/commit/93a82a44a192a8a3f3c3610853878a57a0a37ee3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93a82a44a192a8a3f3c3610853878a57a0a37ee3/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a43859a747a8916dbec98b8847a237e6caaf994", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a43859a747a8916dbec98b8847a237e6caaf994", "html_url": "https://github.com/rust-lang/rust/commit/1a43859a747a8916dbec98b8847a237e6caaf994"}, {"sha": "34aa87292c5cd45c88a72235dad6e973a9f2b62f", "url": "https://api.github.com/repos/rust-lang/rust/commits/34aa87292c5cd45c88a72235dad6e973a9f2b62f", "html_url": "https://github.com/rust-lang/rust/commit/34aa87292c5cd45c88a72235dad6e973a9f2b62f"}], "stats": {"total": 124, "additions": 98, "deletions": 26}, "files": [{"sha": "492e21d9bdb634b737e1a0d15ff2ba16adf1a732", "filename": "library/std/src/sync/mpmc/array.rs", "status": "modified", "additions": 83, "deletions": 24, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/93a82a44a192a8a3f3c3610853878a57a0a37ee3/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93a82a44a192a8a3f3c3610853878a57a0a37ee3/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs?ref=93a82a44a192a8a3f3c3610853878a57a0a37ee3", "patch": "@@ -25,7 +25,8 @@ struct Slot<T> {\n     /// The current stamp.\n     stamp: AtomicUsize,\n \n-    /// The message in this slot.\n+    /// The message in this slot. Either read out in `read` or dropped through\n+    /// `discard_all_messages`.\n     msg: UnsafeCell<MaybeUninit<T>>,\n }\n \n@@ -439,21 +440,99 @@ impl<T> Channel<T> {\n         Some(self.cap)\n     }\n \n-    /// Disconnects the channel and wakes up all blocked senders and receivers.\n+    /// Disconnects senders and wakes up all blocked receivers.\n     ///\n     /// Returns `true` if this call disconnected the channel.\n-    pub(crate) fn disconnect(&self) -> bool {\n+    pub(crate) fn disconnect_senders(&self) -> bool {\n         let tail = self.tail.fetch_or(self.mark_bit, Ordering::SeqCst);\n \n         if tail & self.mark_bit == 0 {\n-            self.senders.disconnect();\n             self.receivers.disconnect();\n             true\n         } else {\n             false\n         }\n     }\n \n+    /// Disconnects receivers and wakes up all blocked senders.\n+    ///\n+    /// Returns `true` if this call disconnected the channel.\n+    ///\n+    /// # Safety\n+    /// May only be called once upon dropping the last receiver. The\n+    /// destruction of all other receivers must have been observed with acquire\n+    /// ordering or stronger.\n+    pub(crate) unsafe fn disconnect_receivers(&self) -> bool {\n+        let tail = self.tail.fetch_or(self.mark_bit, Ordering::SeqCst);\n+        let disconnected = if tail & self.mark_bit == 0 {\n+            self.senders.disconnect();\n+            true\n+        } else {\n+            false\n+        };\n+\n+        self.discard_all_messages(tail);\n+        disconnected\n+    }\n+\n+    /// Discards all messages.\n+    ///\n+    /// `tail` should be the current (and therefore last) value of `tail`.\n+    ///\n+    /// # Panicking\n+    /// If a destructor panics, the remaining messages are leaked, matching the\n+    /// behaviour of the unbounded channel.\n+    ///\n+    /// # Safety\n+    /// This method must only be called when dropping the last receiver. The\n+    /// destruction of all other receivers must have been observed with acquire\n+    /// ordering or stronger.\n+    unsafe fn discard_all_messages(&self, tail: usize) {\n+        debug_assert!(self.is_disconnected());\n+\n+        // Only receivers modify `head`, so since we are the last one,\n+        // this value will not change and will not be observed (since\n+        // no new messages can be sent after disconnection).\n+        let mut head = self.head.load(Ordering::Relaxed);\n+        let tail = tail & !self.mark_bit;\n+\n+        let backoff = Backoff::new();\n+        loop {\n+            // Deconstruct the head.\n+            let index = head & (self.mark_bit - 1);\n+            let lap = head & !(self.one_lap - 1);\n+\n+            // Inspect the corresponding slot.\n+            debug_assert!(index < self.buffer.len());\n+            let slot = unsafe { self.buffer.get_unchecked(index) };\n+            let stamp = slot.stamp.load(Ordering::Acquire);\n+\n+            // If the stamp is ahead of the head by 1, we may drop the message.\n+            if head + 1 == stamp {\n+                head = if index + 1 < self.cap {\n+                    // Same lap, incremented index.\n+                    // Set to `{ lap: lap, mark: 0, index: index + 1 }`.\n+                    head + 1\n+                } else {\n+                    // One lap forward, index wraps around to zero.\n+                    // Set to `{ lap: lap.wrapping_add(1), mark: 0, index: 0 }`.\n+                    lap.wrapping_add(self.one_lap)\n+                };\n+\n+                unsafe {\n+                    (*slot.msg.get()).assume_init_drop();\n+                }\n+            // If the tail equals the head, that means the channel is empty.\n+            } else if tail == head {\n+                return;\n+            // Otherwise, a sender is about to write into the slot, so we need\n+            // to wait for it to update the stamp.\n+            } else {\n+                backoff.spin_heavy();\n+            }\n+        }\n+    }\n+\n     /// Returns `true` if the channel is disconnected.\n     pub(crate) fn is_disconnected(&self) -> bool {\n         self.tail.load(Ordering::SeqCst) & self.mark_bit != 0\n@@ -483,23 +562,3 @@ impl<T> Channel<T> {\n         head.wrapping_add(self.one_lap) == tail & !self.mark_bit\n     }\n }\n-\n-impl<T> Drop for Channel<T> {\n-    fn drop(&mut self) {\n-        // Get the index of the head.\n-        let hix = self.head.load(Ordering::Relaxed) & (self.mark_bit - 1);\n-\n-        // Loop over all slots that hold a message and drop them.\n-        for i in 0..self.len() {\n-            // Compute the index of the next slot holding a message.\n-            let index = if hix + i < self.cap { hix + i } else { hix + i - self.cap };\n-\n-            unsafe {\n-                debug_assert!(index < self.buffer.len());\n-                let slot = self.buffer.get_unchecked_mut(index);\n-                let msg = &mut *slot.msg.get();\n-                msg.as_mut_ptr().drop_in_place();\n-            }\n-        }\n-    }\n-}"}, {"sha": "2068dda393a2b632952b26e10786c181721975c0", "filename": "library/std/src/sync/mpmc/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/93a82a44a192a8a3f3c3610853878a57a0a37ee3/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93a82a44a192a8a3f3c3610853878a57a0a37ee3/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fmod.rs?ref=93a82a44a192a8a3f3c3610853878a57a0a37ee3", "patch": "@@ -227,7 +227,7 @@ impl<T> Drop for Sender<T> {\n     fn drop(&mut self) {\n         unsafe {\n             match &self.flavor {\n-                SenderFlavor::Array(chan) => chan.release(|c| c.disconnect()),\n+                SenderFlavor::Array(chan) => chan.release(|c| c.disconnect_senders()),\n                 SenderFlavor::List(chan) => chan.release(|c| c.disconnect_senders()),\n                 SenderFlavor::Zero(chan) => chan.release(|c| c.disconnect()),\n             }\n@@ -403,7 +403,7 @@ impl<T> Drop for Receiver<T> {\n     fn drop(&mut self) {\n         unsafe {\n             match &self.flavor {\n-                ReceiverFlavor::Array(chan) => chan.release(|c| c.disconnect()),\n+                ReceiverFlavor::Array(chan) => chan.release(|c| c.disconnect_receivers()),\n                 ReceiverFlavor::List(chan) => chan.release(|c| c.disconnect_receivers()),\n                 ReceiverFlavor::Zero(chan) => chan.release(|c| c.disconnect()),\n             }"}, {"sha": "632709fd98d8691e3fcc64cd56f4792422c03d5f", "filename": "library/std/src/sync/mpsc/sync_tests.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/93a82a44a192a8a3f3c3610853878a57a0a37ee3/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fsync_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93a82a44a192a8a3f3c3610853878a57a0a37ee3/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fsync_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fsync_tests.rs?ref=93a82a44a192a8a3f3c3610853878a57a0a37ee3", "patch": "@@ -1,5 +1,6 @@\n use super::*;\n use crate::env;\n+use crate::rc::Rc;\n use crate::sync::mpmc::SendTimeoutError;\n use crate::thread;\n use crate::time::Duration;\n@@ -656,3 +657,15 @@ fn issue_15761() {\n         repro()\n     }\n }\n+\n+#[test]\n+fn drop_unreceived() {\n+    let (tx, rx) = sync_channel::<Rc<()>>(1);\n+    let msg = Rc::new(());\n+    let weak = Rc::downgrade(&msg);\n+    assert!(tx.send(msg).is_ok());\n+    drop(rx);\n+    // Messages should be dropped immediately when the last receiver is destroyed.\n+    assert!(weak.upgrade().is_none());\n+    drop(tx);\n+}"}]}