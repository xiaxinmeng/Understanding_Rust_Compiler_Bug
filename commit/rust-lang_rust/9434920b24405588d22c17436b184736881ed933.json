{"sha": "9434920b24405588d22c17436b184736881ed933", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0MzQ5MjBiMjQ0MDU1ODhkMjJjMTc0MzZiMTg0NzM2ODgxZWQ5MzM=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-08-13T11:15:31Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-08-13T15:41:35Z"}, "message": "rustc lexer: regression tests for embedded Idents.\n\nI chose to make two of them because I wanted something close to an\n\"end-to-end\" test (*), but at the same time I wanted a test that\nwould run on Windows (**).\n\n(*) The run-make test serves as the end-to-end: It constructs an input\nthat is trying to subvert the hack and we are going to check that it\nfails in the attempt).\n\n(**) The compile-fail-fulldeps test serves as a more narrow test that\nwill be tested on all platforms.  It also attempts to subvert the\nhack, testing that when you use `new_parser_from_tts`, the resulting\nparser does not support reading embedded Idents.", "tree": {"sha": "bd961d09006411460055a96410a407097aac3b1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd961d09006411460055a96410a407097aac3b1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9434920b24405588d22c17436b184736881ed933", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9434920b24405588d22c17436b184736881ed933", "html_url": "https://github.com/rust-lang/rust/commit/9434920b24405588d22c17436b184736881ed933", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9434920b24405588d22c17436b184736881ed933/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3ce245ba68f62edfc5818f003b2b78a02ce5c03", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3ce245ba68f62edfc5818f003b2b78a02ce5c03", "html_url": "https://github.com/rust-lang/rust/commit/c3ce245ba68f62edfc5818f003b2b78a02ce5c03"}], "stats": {"total": 129, "additions": 129, "deletions": 0}, "files": [{"sha": "f6e96cca5c19c91fdd8943cacab42ed8ffaa0ea3", "filename": "src/test/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9434920b24405588d22c17436b184736881ed933/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9434920b24405588d22c17436b184736881ed933/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs?ref=9434920b24405588d22c17436b184736881ed933", "patch": "@@ -31,6 +31,7 @@ macro_rules! unexported_macro (() => (3i))\n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_macro(\"make_a_1\", expand_make_a_1);\n+    reg.register_macro(\"forged_ident\", expand_forged_ident);\n     reg.register_syntax_extension(\n         token::intern(\"into_foo\"),\n         ItemModifier(expand_into_foo));\n@@ -52,4 +53,29 @@ fn expand_into_foo(cx: &mut ExtCtxt, sp: Span, attr: Gc<MetaItem>, it: Gc<Item>)\n     }\n }\n \n+fn expand_forged_ident(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree]) -> Box<MacResult> {\n+    use syntax::ext::quote::rt::*;\n+\n+    if !tts.is_empty() {\n+        cx.span_fatal(sp, \"forged_ident takes no arguments\");\n+    }\n+\n+    // Most of this is modelled after the expansion of the `quote_expr!`\n+    // macro ...\n+    let parse_sess = cx.parse_sess();\n+    let cfg = cx.cfg();\n+\n+    // ... except this is where we inject a forged identifier,\n+    // and deliberately do not call `cx.parse_tts_with_hygiene`\n+    // (because we are testing that this will be *rejected*\n+    //  by the default parser).\n+\n+    let expr = {\n+        let tt = cx.parse_tts(\"\\x00name_2,ctxt_0\\x00\".to_string());\n+        let mut parser = new_parser_from_tts(parse_sess, cfg, tt);\n+        parser.parse_expr()\n+    };\n+    MacExpr::new(expr)\n+}\n+\n pub fn foo() {}"}, {"sha": "268b6e6aa0fa68753535101bcbce8990c3a3aa26", "filename": "src/test/compile-fail-fulldeps/macro-crate-cannot-read-embedded-ident.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9434920b24405588d22c17436b184736881ed933/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-cannot-read-embedded-ident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9434920b24405588d22c17436b184736881ed933/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-cannot-read-embedded-ident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-cannot-read-embedded-ident.rs?ref=9434920b24405588d22c17436b184736881ed933", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:macro_crate_test.rs\n+// ignore-stage1\n+// ignore-android\n+// error-pattern: unknown start of token: \\x00\n+\n+// Issue #15750 and #15962 : this test is checking that the standard\n+// parser rejects embedded idents.  pnkfelix did not want to attempt\n+// to make a test file that itself used the embedded ident input form,\n+// since he worrid that would be difficult to work with in many text\n+// editors, so instead he made a macro that expands into the embedded\n+// ident form.\n+\n+#![feature(phase)]\n+\n+#[phase(plugin)]\n+extern crate macro_crate_test;\n+\n+fn main() {\n+    let x = 0;\n+    assert_eq!(3, forged_ident!());\n+}"}, {"sha": "0d047be02ca1dc7c135392b8765817c8ad7e3b40", "filename": "src/test/run-make/cannot-read-embedded-idents/Makefile", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9434920b24405588d22c17436b184736881ed933/src%2Ftest%2Frun-make%2Fcannot-read-embedded-idents%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/9434920b24405588d22c17436b184736881ed933/src%2Ftest%2Frun-make%2Fcannot-read-embedded-idents%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fcannot-read-embedded-idents%2FMakefile?ref=9434920b24405588d22c17436b184736881ed933", "patch": "@@ -0,0 +1,28 @@\n+-include ../tools.mk\n+\n+# Issue #15750, #15962 : This test ensures that our special embedded\n+# ident syntax hack is not treated as legitimate input by the lexer in\n+# normal mode.\n+#\n+# It is modelled after the `unicode-input/` test, since we need to\n+# create files with syntax that can trip up normal text editting tools\n+# (namely text with embedded nul-bytes).\n+\n+# This test attempts to run rustc itself from the compiled binary; but\n+# that means that you need to set the LD_LIBRARY_PATH for rustc itself\n+# while running create_and_compile, and that won't work for stage1.\n+\n+# FIXME ignore windows\n+ifndef IS_WINDOWS\n+ifeq ($(RUST_BUILD_STAGE),1)\n+DOTEST=\n+else\n+DOTEST=dotest\n+endif\n+endif\n+\n+all: $(DOTEST)\n+\n+dotest:\n+\t$(RUSTC) create_and_compile.rs\n+\t$(call RUN,create_and_compile)  \"$(RUSTC)\" \"$(TMPDIR)\""}, {"sha": "2d8fa352e2713d7fa5a869ade8fd39c4131dd759", "filename": "src/test/run-make/cannot-read-embedded-idents/create_and_compile.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9434920b24405588d22c17436b184736881ed933/src%2Ftest%2Frun-make%2Fcannot-read-embedded-idents%2Fcreate_and_compile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9434920b24405588d22c17436b184736881ed933/src%2Ftest%2Frun-make%2Fcannot-read-embedded-idents%2Fcreate_and_compile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fcannot-read-embedded-idents%2Fcreate_and_compile.rs?ref=9434920b24405588d22c17436b184736881ed933", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::os;\n+use std::io::{File, Command};\n+\n+// creates broken.rs, which has the Ident \\x00name_0,ctxt_0\\x00\n+// embedded within it, and then attempts to compile broken.rs with the\n+// provided `rustc`\n+\n+fn main() {\n+    let args = os::args();\n+    let rustc = args[1].as_slice();\n+    let tmpdir = Path::new(args[2].as_slice());\n+\n+    let main_file = tmpdir.join(\"broken.rs\");\n+    let _ = File::create(&main_file).unwrap()\n+        .write_str(\"pub fn main() {\n+                   let \\x00name_0,ctxt_0\\x00 = 3i;\n+                   println!(\\\"{}\\\", \\x00name_0,ctxt_0\\x00);\n+        }\");\n+\n+    // rustc is passed to us with --out-dir and -L etc., so we\n+    // can't exec it directly\n+    let result = Command::new(\"sh\")\n+        .arg(\"-c\")\n+        .arg(format!(\"{} {}\",\n+                     rustc,\n+                     main_file.as_str()\n+                     .unwrap()).as_slice())\n+        .output().unwrap();\n+    let err = String::from_utf8_lossy(result.error.as_slice());\n+\n+    // positive test so that this test will be updated when the\n+    // compiler changes.\n+    assert!(err.as_slice().contains(\"unknown start of token\"))\n+}"}]}