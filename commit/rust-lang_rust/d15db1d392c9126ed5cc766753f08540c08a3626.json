{"sha": "d15db1d392c9126ed5cc766753f08540c08a3626", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxNWRiMWQzOTJjOTEyNmVkNWNjNzY2NzUzZjA4NTQwYzA4YTM2MjY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-02-04T19:10:37Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-02-10T17:28:48Z"}, "message": "std: Push process stdio setup in std::sys\n\nMost of this is platform-specific anyway, and we generally have to jump through\nfewer hoops to do the equivalent operation on Windows. One benefit for Windows\ntoday is that this new structure avoids an extra `DuplicateHandle` when creating\npipes. For Unix, however, the behavior should be the same.\n\nNote that this is just a pure refactoring, no functionality was added or\nremoved.", "tree": {"sha": "658ca3a080bba616aaeabe4194be4125d78c4737", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/658ca3a080bba616aaeabe4194be4125d78c4737"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d15db1d392c9126ed5cc766753f08540c08a3626", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d15db1d392c9126ed5cc766753f08540c08a3626", "html_url": "https://github.com/rust-lang/rust/commit/d15db1d392c9126ed5cc766753f08540c08a3626", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d15db1d392c9126ed5cc766753f08540c08a3626/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18f9a79c23da8e8920e4c944656b9945f3544337", "url": "https://api.github.com/repos/rust-lang/rust/commits/18f9a79c23da8e8920e4c944656b9945f3544337", "html_url": "https://github.com/rust-lang/rust/commit/18f9a79c23da8e8920e4c944656b9945f3544337"}], "stats": {"total": 807, "additions": 440, "deletions": 367}, "files": [{"sha": "8db8ad324bea984c9fd2b8d64c2e7dd2cbd84ed2", "filename": "src/libstd/process.rs", "status": "modified", "additions": 44, "deletions": 85, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/d15db1d392c9126ed5cc766753f08540c08a3626/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d15db1d392c9126ed5cc766753f08540c08a3626/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=d15db1d392c9126ed5cc766753f08540c08a3626", "patch": "@@ -20,7 +20,7 @@ use fmt;\n use io;\n use path::Path;\n use str;\n-use sys::pipe::{self, AnonPipe};\n+use sys::pipe::AnonPipe;\n use sys::process as imp;\n use sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n use thread::{self, JoinHandle};\n@@ -77,6 +77,17 @@ impl AsInner<imp::Process> for Child {\n     fn as_inner(&self) -> &imp::Process { &self.handle }\n }\n \n+impl FromInner<(imp::Process, imp::StdioPipes)> for Child {\n+    fn from_inner((handle, io): (imp::Process, imp::StdioPipes)) -> Child {\n+        Child {\n+            handle: handle,\n+            stdin: io.stdin.map(ChildStdin::from_inner),\n+            stdout: io.stdout.map(ChildStdout::from_inner),\n+            stderr: io.stderr.map(ChildStderr::from_inner),\n+        }\n+    }\n+}\n+\n impl IntoInner<imp::Process> for Child {\n     fn into_inner(self) -> imp::Process { self.handle }\n }\n@@ -106,6 +117,12 @@ impl IntoInner<AnonPipe> for ChildStdin {\n     fn into_inner(self) -> AnonPipe { self.inner }\n }\n \n+impl FromInner<AnonPipe> for ChildStdin {\n+    fn from_inner(pipe: AnonPipe) -> ChildStdin {\n+        ChildStdin { inner: pipe }\n+    }\n+}\n+\n /// A handle to a child process's stdout\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ChildStdout {\n@@ -127,6 +144,12 @@ impl IntoInner<AnonPipe> for ChildStdout {\n     fn into_inner(self) -> AnonPipe { self.inner }\n }\n \n+impl FromInner<AnonPipe> for ChildStdout {\n+    fn from_inner(pipe: AnonPipe) -> ChildStdout {\n+        ChildStdout { inner: pipe }\n+    }\n+}\n+\n /// A handle to a child process's stderr\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ChildStderr {\n@@ -148,6 +171,12 @@ impl IntoInner<AnonPipe> for ChildStderr {\n     fn into_inner(self) -> AnonPipe { self.inner }\n }\n \n+impl FromInner<AnonPipe> for ChildStderr {\n+    fn from_inner(pipe: AnonPipe) -> ChildStderr {\n+        ChildStderr { inner: pipe }\n+    }\n+}\n+\n /// The `Command` type acts as a process builder, providing fine-grained control\n /// over how a new process should be spawned. A default configuration can be\n /// generated using `Command::new(program)`, where `program` gives a path to the\n@@ -167,11 +196,6 @@ impl IntoInner<AnonPipe> for ChildStderr {\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct Command {\n     inner: imp::Command,\n-\n-    // Details explained in the builder methods\n-    stdin: Option<Stdio>,\n-    stdout: Option<Stdio>,\n-    stderr: Option<Stdio>,\n }\n \n impl Command {\n@@ -187,12 +211,7 @@ impl Command {\n     /// otherwise configure the process.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn new<S: AsRef<OsStr>>(program: S) -> Command {\n-        Command {\n-            inner: imp::Command::new(program.as_ref()),\n-            stdin: None,\n-            stdout: None,\n-            stderr: None,\n-        }\n+        Command { inner: imp::Command::new(program.as_ref()) }\n     }\n \n     /// Add an argument to pass to the program.\n@@ -247,56 +266,30 @@ impl Command {\n     /// Configuration for the child process's stdin handle (file descriptor 0).\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn stdin(&mut self, cfg: Stdio) -> &mut Command {\n-        self.stdin = Some(cfg);\n+        self.inner.stdin(cfg.0);\n         self\n     }\n \n     /// Configuration for the child process's stdout handle (file descriptor 1).\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn stdout(&mut self, cfg: Stdio) -> &mut Command {\n-        self.stdout = Some(cfg);\n+        self.inner.stdout(cfg.0);\n         self\n     }\n \n     /// Configuration for the child process's stderr handle (file descriptor 2).\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn stderr(&mut self, cfg: Stdio) -> &mut Command {\n-        self.stderr = Some(cfg);\n+        self.inner.stderr(cfg.0);\n         self\n     }\n \n-    fn spawn_inner(&mut self, default_io: StdioImp) -> io::Result<Child> {\n-        let default_io = Stdio(default_io);\n-\n-        // See comment on `setup_io` for what `_drop_later` is.\n-        let (their_stdin, our_stdin, _drop_later) = try!(\n-            setup_io(self.stdin.as_ref().unwrap_or(&default_io), true)\n-        );\n-        let (their_stdout, our_stdout, _drop_later) = try!(\n-            setup_io(self.stdout.as_ref().unwrap_or(&default_io), false)\n-        );\n-        let (their_stderr, our_stderr, _drop_later) = try!(\n-            setup_io(self.stderr.as_ref().unwrap_or(&default_io), false)\n-        );\n-\n-        match imp::Process::spawn(&mut self.inner, their_stdin, their_stdout,\n-                                  their_stderr) {\n-            Err(e) => Err(e),\n-            Ok(handle) => Ok(Child {\n-                handle: handle,\n-                stdin: our_stdin.map(|fd| ChildStdin { inner: fd }),\n-                stdout: our_stdout.map(|fd| ChildStdout { inner: fd }),\n-                stderr: our_stderr.map(|fd| ChildStderr { inner: fd }),\n-            })\n-        }\n-    }\n-\n     /// Executes the command as a child process, returning a handle to it.\n     ///\n     /// By default, stdin, stdout and stderr are inherited from the parent.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn spawn(&mut self) -> io::Result<Child> {\n-        self.spawn_inner(StdioImp::Inherit)\n+        self.inner.spawn(imp::Stdio::Inherit).map(Child::from_inner)\n     }\n \n     /// Executes the command as a child process, waiting for it to finish and\n@@ -319,7 +312,8 @@ impl Command {\n     /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn output(&mut self) -> io::Result<Output> {\n-        self.spawn_inner(StdioImp::MakePipe).and_then(|p| p.wait_with_output())\n+        self.inner.spawn(imp::Stdio::MakePipe).map(Child::from_inner)\n+            .and_then(|p| p.wait_with_output())\n     }\n \n     /// Executes a command as a child process, waiting for it to finish and\n@@ -362,33 +356,6 @@ impl AsInnerMut<imp::Command> for Command {\n     fn as_inner_mut(&mut self) -> &mut imp::Command { &mut self.inner }\n }\n \n-// Takes a `Stdio` configuration (this module) and whether the to-be-owned\n-// handle will be readable.\n-//\n-// Returns a triple of (stdio to spawn with, stdio to store, stdio to drop). The\n-// stdio to spawn with is passed down to the `sys` module and indicates how the\n-// stdio stream should be set up. The \"stdio to store\" is an object which\n-// should be returned in the `Child` that makes its way out. The \"stdio to drop\"\n-// represents the raw value of \"stdio to spawn with\", but is the owned variant\n-// for it. This needs to be dropped after the child spawns\n-fn setup_io(io: &Stdio, readable: bool)\n-            -> io::Result<(imp::Stdio, Option<AnonPipe>, Option<AnonPipe>)>\n-{\n-    Ok(match io.0 {\n-        StdioImp::MakePipe => {\n-            let (reader, writer) = try!(pipe::anon_pipe());\n-            if readable {\n-                (imp::Stdio::Raw(reader.raw()), Some(writer), Some(reader))\n-            } else {\n-                (imp::Stdio::Raw(writer.raw()), Some(reader), Some(writer))\n-            }\n-        }\n-        StdioImp::Raw(ref owned) => (imp::Stdio::Raw(owned.raw()), None, None),\n-        StdioImp::Inherit => (imp::Stdio::Inherit, None, None),\n-        StdioImp::Null => (imp::Stdio::Null, None, None),\n-    })\n-}\n-\n /// The output of a finished process.\n #[derive(PartialEq, Eq, Clone)]\n #[stable(feature = \"process\", since = \"1.0.0\")]\n@@ -432,34 +399,26 @@ impl fmt::Debug for Output {\n \n /// Describes what to do with a standard I/O stream for a child process.\n #[stable(feature = \"process\", since = \"1.0.0\")]\n-pub struct Stdio(StdioImp);\n-\n-// The internal enum for stdio setup; see below for descriptions.\n-enum StdioImp {\n-    MakePipe,\n-    Raw(imp::RawStdio),\n-    Inherit,\n-    Null,\n-}\n+pub struct Stdio(imp::Stdio);\n \n impl Stdio {\n     /// A new pipe should be arranged to connect the parent and child processes.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n-    pub fn piped() -> Stdio { Stdio(StdioImp::MakePipe) }\n+    pub fn piped() -> Stdio { Stdio(imp::Stdio::MakePipe) }\n \n     /// The child inherits from the corresponding parent descriptor.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n-    pub fn inherit() -> Stdio { Stdio(StdioImp::Inherit) }\n+    pub fn inherit() -> Stdio { Stdio(imp::Stdio::Inherit) }\n \n     /// This stream will be ignored. This is the equivalent of attaching the\n     /// stream to `/dev/null`\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n-    pub fn null() -> Stdio { Stdio(StdioImp::Null) }\n+    pub fn null() -> Stdio { Stdio(imp::Stdio::Null) }\n }\n \n-impl FromInner<imp::RawStdio> for Stdio {\n-    fn from_inner(inner: imp::RawStdio) -> Stdio {\n-        Stdio(StdioImp::Raw(inner))\n+impl FromInner<imp::Stdio> for Stdio {\n+    fn from_inner(inner: imp::Stdio) -> Stdio {\n+        Stdio(inner)\n     }\n }\n "}, {"sha": "cf72cfd7e507e5bfbd6a813aa2e337e200a1eeb0", "filename": "src/libstd/sys/unix/ext/process.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d15db1d392c9126ed5cc766753f08540c08a3626/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d15db1d392c9126ed5cc766753f08540c08a3626/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs?ref=d15db1d392c9126ed5cc766753f08540c08a3626", "patch": "@@ -120,7 +120,9 @@ impl ExitStatusExt for process::ExitStatus {\n #[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n impl FromRawFd for process::Stdio {\n     unsafe fn from_raw_fd(fd: RawFd) -> process::Stdio {\n-        process::Stdio::from_inner(sys::fd::FileDesc::new(fd))\n+        let fd = sys::fd::FileDesc::new(fd);\n+        let io = sys::process::Stdio::Fd(fd);\n+        process::Stdio::from_inner(io)\n     }\n }\n "}, {"sha": "667f0f9e6bf62044775dbad7850cfcc0b2685db8", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d15db1d392c9126ed5cc766753f08540c08a3626/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d15db1d392c9126ed5cc766753f08540c08a3626/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=d15db1d392c9126ed5cc766753f08540c08a3626", "patch": "@@ -61,7 +61,6 @@ impl AnonPipe {\n         self.0.write(buf)\n     }\n \n-    pub fn raw(&self) -> libc::c_int { self.0.raw() }\n     pub fn fd(&self) -> &FileDesc { &self.0 }\n     pub fn into_fd(self) -> FileDesc { self.0 }\n }"}, {"sha": "4716d25c0b28ff4ccc0503221e5456c69531ff80", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 256, "deletions": 187, "changes": 443, "blob_url": "https://github.com/rust-lang/rust/blob/d15db1d392c9126ed5cc766753f08540c08a3626/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d15db1d392c9126ed5cc766753f08540c08a3626/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=d15db1d392c9126ed5cc766753f08540c08a3626", "patch": "@@ -21,6 +21,7 @@ use mem;\n use ptr;\n use sys::fd::FileDesc;\n use sys::fs::{File, OpenOptions};\n+use sys::pipe::{self, AnonPipe};\n use sys::{self, cvt, cvt_r};\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -57,6 +58,38 @@ pub struct Command {\n     session_leader: bool,\n     saw_nul: bool,\n     closures: Vec<Box<FnMut() -> io::Result<()> + Send + Sync>>,\n+    stdin: Option<Stdio>,\n+    stdout: Option<Stdio>,\n+    stderr: Option<Stdio>,\n+}\n+\n+// passed back to std::process with the pipes connected to the child, if any\n+// were requested\n+pub struct StdioPipes {\n+    pub stdin: Option<AnonPipe>,\n+    pub stdout: Option<AnonPipe>,\n+    pub stderr: Option<AnonPipe>,\n+}\n+\n+// passed to do_exec() with configuration of what the child stdio should look\n+// like\n+struct ChildPipes {\n+    stdin: ChildStdio,\n+    stdout: ChildStdio,\n+    stderr: ChildStdio,\n+}\n+\n+enum ChildStdio {\n+    Inherit,\n+    Explicit(c_int),\n+    Owned(FileDesc),\n+}\n+\n+pub enum Stdio {\n+    Inherit,\n+    Null,\n+    MakePipe,\n+    Fd(FileDesc),\n }\n \n impl Command {\n@@ -75,6 +108,9 @@ impl Command {\n             session_leader: false,\n             saw_nul: saw_nul,\n             closures: Vec::new(),\n+            stdin: None,\n+            stdout: None,\n+            stderr: None,\n         }\n     }\n \n@@ -169,136 +205,32 @@ impl Command {\n                        f: Box<FnMut() -> io::Result<()> + Send + Sync>) {\n         self.closures.push(f);\n     }\n-}\n-\n-fn os2c(s: &OsStr, saw_nul: &mut bool) -> CString {\n-    CString::new(s.as_bytes()).unwrap_or_else(|_e| {\n-        *saw_nul = true;\n-        CString::new(\"<string-with-nul>\").unwrap()\n-    })\n-}\n-\n-fn pair_to_key(key: &OsStr, value: &OsStr, saw_nul: &mut bool) -> CString {\n-    let (key, value) = (key.as_bytes(), value.as_bytes());\n-    let mut v = Vec::with_capacity(key.len() + value.len() + 1);\n-    v.extend(key);\n-    v.push(b'=');\n-    v.extend(value);\n-    CString::new(v).unwrap_or_else(|_e| {\n-        *saw_nul = true;\n-        CString::new(\"foo=bar\").unwrap()\n-    })\n-}\n-\n-impl fmt::Debug for Command {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{:?}\", self.program));\n-        for arg in &self.args {\n-            try!(write!(f, \" {:?}\", arg));\n-        }\n-        Ok(())\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Processes\n-////////////////////////////////////////////////////////////////////////////////\n-\n-/// Unix exit statuses\n-#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n-pub struct ExitStatus(c_int);\n-\n-#[cfg(any(target_os = \"linux\", target_os = \"android\",\n-          target_os = \"nacl\", target_os = \"solaris\",\n-          target_os = \"emscripten\"))]\n-mod status_imp {\n-    pub fn WIFEXITED(status: i32) -> bool { (status & 0xff) == 0 }\n-    pub fn WEXITSTATUS(status: i32) -> i32 { (status >> 8) & 0xff }\n-    pub fn WTERMSIG(status: i32) -> i32 { status & 0x7f }\n-}\n-\n-#[cfg(any(target_os = \"macos\",\n-          target_os = \"ios\",\n-          target_os = \"freebsd\",\n-          target_os = \"dragonfly\",\n-          target_os = \"bitrig\",\n-          target_os = \"netbsd\",\n-          target_os = \"openbsd\"))]\n-mod status_imp {\n-    pub fn WIFEXITED(status: i32) -> bool { (status & 0x7f) == 0 }\n-    pub fn WEXITSTATUS(status: i32) -> i32 { status >> 8 }\n-    pub fn WTERMSIG(status: i32) -> i32 { status & 0o177 }\n-}\n-\n-impl ExitStatus {\n-    fn exited(&self) -> bool {\n-        status_imp::WIFEXITED(self.0)\n-    }\n \n-    pub fn success(&self) -> bool {\n-        self.code() == Some(0)\n+    pub fn stdin(&mut self, stdin: Stdio) {\n+        self.stdin = Some(stdin);\n     }\n-\n-    pub fn code(&self) -> Option<i32> {\n-        if self.exited() {\n-            Some(status_imp::WEXITSTATUS(self.0))\n-        } else {\n-            None\n-        }\n+    pub fn stdout(&mut self, stdout: Stdio) {\n+        self.stdout = Some(stdout);\n     }\n-\n-    pub fn signal(&self) -> Option<i32> {\n-        if !self.exited() {\n-            Some(status_imp::WTERMSIG(self.0))\n-        } else {\n-            None\n-        }\n+    pub fn stderr(&mut self, stderr: Stdio) {\n+        self.stderr = Some(stderr);\n     }\n-}\n \n-impl fmt::Display for ExitStatus {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if let Some(code) = self.code() {\n-            write!(f, \"exit code: {}\", code)\n-        } else {\n-            let signal = self.signal().unwrap();\n-            write!(f, \"signal: {}\", signal)\n-        }\n-    }\n-}\n-\n-/// The unique id of the process (this should never be negative).\n-pub struct Process {\n-    pid: pid_t,\n-    status: Option<ExitStatus>,\n-}\n-\n-pub enum Stdio {\n-    Inherit,\n-    Null,\n-    Raw(c_int),\n-}\n-\n-pub type RawStdio = FileDesc;\n-\n-const CLOEXEC_MSG_FOOTER: &'static [u8] = b\"NOEX\";\n-\n-impl Process {\n-    pub fn spawn(cfg: &mut Command,\n-                 in_fd: Stdio,\n-                 out_fd: Stdio,\n-                 err_fd: Stdio) -> io::Result<Process> {\n-        if cfg.saw_nul {\n-            return Err(io::Error::new(ErrorKind::InvalidInput, \"nul byte found in provided data\"));\n+    pub fn spawn(&mut self, default: Stdio)\n+                 -> io::Result<(Process, StdioPipes)> {\n+        if self.saw_nul {\n+            return Err(io::Error::new(ErrorKind::InvalidInput,\n+                                      \"nul byte found in provided data\"));\n         }\n \n+        let (ours, theirs) = try!(self.setup_io(default));\n         let (input, output) = try!(sys::pipe::anon_pipe());\n \n         let pid = unsafe {\n             match try!(cvt(libc::fork())) {\n                 0 => {\n                     drop(input);\n-                    let err = Process::exec(cfg, in_fd, out_fd, err_fd);\n+                    let err = self.exec(theirs);\n                     let errno = err.raw_os_error().unwrap_or(libc::EINVAL) as u32;\n                     let bytes = [\n                         (errno >> 24) as u8,\n@@ -325,7 +257,7 @@ impl Process {\n         // loop to handle EINTR\n         loop {\n             match input.read(&mut bytes) {\n-                Ok(0) => return Ok(p),\n+                Ok(0) => return Ok((p, ours)),\n                 Ok(8) => {\n                     assert!(combine(CLOEXEC_MSG_FOOTER) == combine(&bytes[4.. 8]),\n                             \"Validation on the CLOEXEC pipe failed: {:?}\", bytes);\n@@ -388,71 +320,28 @@ impl Process {\n     // allocation). Instead we just close it manually. This will never\n     // have the drop glue anyway because this code never returns (the\n     // child will either exec() or invoke libc::exit)\n-    unsafe fn exec(cfg: &mut Command,\n-                   in_fd: Stdio,\n-                   out_fd: Stdio,\n-                   err_fd: Stdio) -> io::Error {\n+    unsafe fn exec(&mut self, stdio: ChildPipes) -> io::Error {\n         macro_rules! try {\n             ($e:expr) => (match $e {\n                 Ok(e) => e,\n                 Err(e) => return e,\n             })\n         }\n \n-        // Make sure that the source descriptors are not an stdio descriptor,\n-        // otherwise the order which we set the child's descriptors may blow\n-        // away a descriptor which we are hoping to save. For example,\n-        // suppose we want the child's stderr to be the parent's stdout, and\n-        // the child's stdout to be the parent's stderr. No matter which we\n-        // dup first, the second will get overwritten prematurely.\n-        let maybe_migrate = |src: Stdio| {\n-            match src {\n-                Stdio::Raw(fd @ libc::STDIN_FILENO) |\n-                Stdio::Raw(fd @ libc::STDOUT_FILENO) |\n-                Stdio::Raw(fd @ libc::STDERR_FILENO) => {\n-                    cvt_r(|| libc::dup(fd)).map(|fd| {\n-                        let fd = FileDesc::new(fd);\n-                        fd.set_cloexec();\n-                        Stdio::Raw(fd.into_raw())\n-                    })\n-                }\n-                s @ Stdio::Null |\n-                s @ Stdio::Inherit |\n-                s @ Stdio::Raw(_) => Ok(s),\n-            }\n-        };\n-        let in_fd = try!(maybe_migrate(in_fd));\n-        let out_fd = try!(maybe_migrate(out_fd));\n-        let err_fd = try!(maybe_migrate(err_fd));\n-\n-        let setup = |src: Stdio, dst: c_int| {\n-            match src {\n-                Stdio::Inherit => Ok(()),\n-                Stdio::Raw(fd) => cvt_r(|| libc::dup2(fd, dst)).map(|_| ()),\n-\n-                // Open up a reference to /dev/null with appropriate read/write\n-                // permissions and then move it into the correct location via\n-                // `dup2`.\n-                Stdio::Null => {\n-                    let mut opts = OpenOptions::new();\n-                    opts.read(dst == libc::STDIN_FILENO);\n-                    opts.write(dst != libc::STDIN_FILENO);\n-                    let devnull = CStr::from_ptr(b\"/dev/null\\0\".as_ptr()\n-                                                    as *const _);\n-                    File::open_c(devnull, &opts).and_then(|f| {\n-                        cvt_r(|| libc::dup2(f.fd().raw(), dst)).map(|_| ())\n-                    })\n-                }\n-            }\n-        };\n-        try!(setup(in_fd, libc::STDIN_FILENO));\n-        try!(setup(out_fd, libc::STDOUT_FILENO));\n-        try!(setup(err_fd, libc::STDERR_FILENO));\n+        if let Some(fd) = stdio.stdin.fd() {\n+            try!(cvt_r(|| libc::dup2(fd, libc::STDIN_FILENO)));\n+        }\n+        if let Some(fd) = stdio.stdout.fd() {\n+            try!(cvt_r(|| libc::dup2(fd, libc::STDOUT_FILENO)));\n+        }\n+        if let Some(fd) = stdio.stderr.fd() {\n+            try!(cvt_r(|| libc::dup2(fd, libc::STDERR_FILENO)));\n+        }\n \n-        if let Some(u) = cfg.gid {\n+        if let Some(u) = self.gid {\n             try!(cvt(libc::setgid(u as gid_t)));\n         }\n-        if let Some(u) = cfg.uid {\n+        if let Some(u) = self.uid {\n             // When dropping privileges from root, the `setgroups` call\n             // will remove any extraneous groups. If we don't call this,\n             // then even though our uid has dropped, we may still have\n@@ -464,16 +353,16 @@ impl Process {\n \n             try!(cvt(libc::setuid(u as uid_t)));\n         }\n-        if cfg.session_leader {\n+        if self.session_leader {\n             // Don't check the error of setsid because it fails if we're the\n             // process leader already. We just forked so it shouldn't return\n             // error, but ignore it anyway.\n             let _ = libc::setsid();\n         }\n-        if let Some(ref cwd) = cfg.cwd {\n+        if let Some(ref cwd) = self.cwd {\n             try!(cvt(libc::chdir(cwd.as_ptr())));\n         }\n-        if let Some(ref envp) = cfg.envp {\n+        if let Some(ref envp) = self.envp {\n             *sys::os::environ() = envp.as_ptr();\n         }\n \n@@ -496,14 +385,195 @@ impl Process {\n             }\n         }\n \n-        for callback in cfg.closures.iter_mut() {\n+        for callback in self.closures.iter_mut() {\n             try!(callback());\n         }\n \n-        libc::execvp(cfg.argv[0], cfg.argv.as_ptr());\n+        libc::execvp(self.argv[0], self.argv.as_ptr());\n         io::Error::last_os_error()\n     }\n \n+\n+    fn setup_io(&self, default: Stdio) -> io::Result<(StdioPipes, ChildPipes)> {\n+        let stdin = self.stdin.as_ref().unwrap_or(&default);\n+        let stdout = self.stdout.as_ref().unwrap_or(&default);\n+        let stderr = self.stderr.as_ref().unwrap_or(&default);\n+        let (their_stdin, our_stdin) = try!(stdin.to_child_stdio(true));\n+        let (their_stdout, our_stdout) = try!(stdout.to_child_stdio(false));\n+        let (their_stderr, our_stderr) = try!(stderr.to_child_stdio(false));\n+        let ours = StdioPipes {\n+            stdin: our_stdin,\n+            stdout: our_stdout,\n+            stderr: our_stderr,\n+        };\n+        let theirs = ChildPipes {\n+            stdin: their_stdin,\n+            stdout: their_stdout,\n+            stderr: their_stderr,\n+        };\n+        Ok((ours, theirs))\n+    }\n+}\n+\n+fn os2c(s: &OsStr, saw_nul: &mut bool) -> CString {\n+    CString::new(s.as_bytes()).unwrap_or_else(|_e| {\n+        *saw_nul = true;\n+        CString::new(\"<string-with-nul>\").unwrap()\n+    })\n+}\n+\n+impl Stdio {\n+    fn to_child_stdio(&self, readable: bool)\n+                      -> io::Result<(ChildStdio, Option<AnonPipe>)> {\n+        match *self {\n+            Stdio::Inherit => Ok((ChildStdio::Inherit, None)),\n+\n+            // Make sure that the source descriptors are not an stdio\n+            // descriptor, otherwise the order which we set the child's\n+            // descriptors may blow away a descriptor which we are hoping to\n+            // save. For example, suppose we want the child's stderr to be the\n+            // parent's stdout, and the child's stdout to be the parent's\n+            // stderr. No matter which we dup first, the second will get\n+            // overwritten prematurely.\n+            Stdio::Fd(ref fd) => {\n+                if fd.raw() >= 0 && fd.raw() <= libc::STDERR_FILENO {\n+                    Ok((ChildStdio::Owned(try!(fd.duplicate())), None))\n+                } else {\n+                    Ok((ChildStdio::Explicit(fd.raw()), None))\n+                }\n+            }\n+\n+            Stdio::MakePipe => {\n+                let (reader, writer) = try!(pipe::anon_pipe());\n+                let (ours, theirs) = if readable {\n+                    (writer, reader)\n+                } else {\n+                    (reader, writer)\n+                };\n+                Ok((ChildStdio::Owned(theirs.into_fd()), Some(ours)))\n+            }\n+\n+            Stdio::Null => {\n+                let mut opts = OpenOptions::new();\n+                opts.read(readable);\n+                opts.write(!readable);\n+                let path = unsafe {\n+                    CStr::from_ptr(\"/dev/null\\0\".as_ptr() as *const _)\n+                };\n+                let fd = try!(File::open_c(&path, &opts));\n+                Ok((ChildStdio::Owned(fd.into_fd()), None))\n+            }\n+        }\n+    }\n+}\n+\n+impl ChildStdio {\n+    fn fd(&self) -> Option<c_int> {\n+        match *self {\n+            ChildStdio::Inherit => None,\n+            ChildStdio::Explicit(fd) => Some(fd),\n+            ChildStdio::Owned(ref fd) => Some(fd.raw()),\n+        }\n+    }\n+}\n+\n+fn pair_to_key(key: &OsStr, value: &OsStr, saw_nul: &mut bool) -> CString {\n+    let (key, value) = (key.as_bytes(), value.as_bytes());\n+    let mut v = Vec::with_capacity(key.len() + value.len() + 1);\n+    v.extend(key);\n+    v.push(b'=');\n+    v.extend(value);\n+    CString::new(v).unwrap_or_else(|_e| {\n+        *saw_nul = true;\n+        CString::new(\"foo=bar\").unwrap()\n+    })\n+}\n+\n+impl fmt::Debug for Command {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"{:?}\", self.program));\n+        for arg in &self.args {\n+            try!(write!(f, \" {:?}\", arg));\n+        }\n+        Ok(())\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Processes\n+////////////////////////////////////////////////////////////////////////////////\n+\n+/// Unix exit statuses\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub struct ExitStatus(c_int);\n+\n+#[cfg(any(target_os = \"linux\", target_os = \"android\",\n+          target_os = \"nacl\"))]\n+mod status_imp {\n+    pub fn WIFEXITED(status: i32) -> bool { (status & 0xff) == 0 }\n+    pub fn WEXITSTATUS(status: i32) -> i32 { (status >> 8) & 0xff }\n+    pub fn WTERMSIG(status: i32) -> i32 { status & 0x7f }\n+}\n+\n+#[cfg(any(target_os = \"macos\",\n+          target_os = \"ios\",\n+          target_os = \"freebsd\",\n+          target_os = \"dragonfly\",\n+          target_os = \"bitrig\",\n+          target_os = \"netbsd\",\n+          target_os = \"openbsd\"))]\n+mod status_imp {\n+    pub fn WIFEXITED(status: i32) -> bool { (status & 0x7f) == 0 }\n+    pub fn WEXITSTATUS(status: i32) -> i32 { status >> 8 }\n+    pub fn WTERMSIG(status: i32) -> i32 { status & 0o177 }\n+}\n+\n+impl ExitStatus {\n+    fn exited(&self) -> bool {\n+        status_imp::WIFEXITED(self.0)\n+    }\n+\n+    pub fn success(&self) -> bool {\n+        self.code() == Some(0)\n+    }\n+\n+    pub fn code(&self) -> Option<i32> {\n+        if self.exited() {\n+            Some(status_imp::WEXITSTATUS(self.0))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn signal(&self) -> Option<i32> {\n+        if !self.exited() {\n+            Some(status_imp::WTERMSIG(self.0))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl fmt::Display for ExitStatus {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        if let Some(code) = self.code() {\n+            write!(f, \"exit code: {}\", code)\n+        } else {\n+            let signal = self.signal().unwrap();\n+            write!(f, \"signal: {}\", signal)\n+        }\n+    }\n+}\n+\n+/// The unique id of the process (this should never be negative).\n+pub struct Process {\n+    pid: pid_t,\n+    status: Option<ExitStatus>,\n+}\n+\n+const CLOEXEC_MSG_FOOTER: &'static [u8] = b\"NOEX\";\n+\n+impl Process {\n     pub fn id(&self) -> u32 {\n         self.pid as u32\n     }\n@@ -540,7 +610,7 @@ mod tests {\n     use mem;\n     use ptr;\n     use libc;\n-    use sys::{self, cvt};\n+    use sys::cvt;\n \n     macro_rules! t {\n         ($e:expr) => {\n@@ -576,21 +646,20 @@ mod tests {\n     fn test_process_mask() {\n         unsafe {\n             // Test to make sure that a signal mask does not get inherited.\n-            let cmd = Command::new(OsStr::new(\"cat\"));\n-            let (stdin_read, stdin_write) = t!(sys::pipe::anon_pipe());\n-            let (stdout_read, stdout_write) = t!(sys::pipe::anon_pipe());\n+            let mut cmd = Command::new(OsStr::new(\"cat\"));\n \n             let mut set: libc::sigset_t = mem::uninitialized();\n             let mut old_set: libc::sigset_t = mem::uninitialized();\n             t!(cvt(libc::sigemptyset(&mut set)));\n             t!(cvt(sigaddset(&mut set, libc::SIGINT)));\n             t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &set, &mut old_set)));\n \n-            let cat = t!(Process::spawn(&cmd, Stdio::Raw(stdin_read.raw()),\n-                                              Stdio::Raw(stdout_write.raw()),\n-                                              Stdio::Null));\n-            drop(stdin_read);\n-            drop(stdout_write);\n+            cmd.stdin(Stdio::MakePipe);\n+            cmd.stdout(Stdio::MakePipe);\n+\n+            let (mut cat, mut pipes) = t!(cmd.spawn(Stdio::Null));\n+            let stdin_write = pipes.stdin.take().unwrap();\n+            let stdout_read = pipes.stdout.take().unwrap();\n \n             t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &old_set,\n                                          ptr::null_mut())));"}, {"sha": "f6ee59eec327ae936f06b95dcaaf4a863e2552ca", "filename": "src/libstd/sys/windows/ext/process.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d15db1d392c9126ed5cc766753f08540c08a3626/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d15db1d392c9126ed5cc766753f08540c08a3626/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fprocess.rs?ref=d15db1d392c9126ed5cc766753f08540c08a3626", "patch": "@@ -21,7 +21,8 @@ use sys_common::{AsInner, FromInner, IntoInner};\n impl FromRawHandle for process::Stdio {\n     unsafe fn from_raw_handle(handle: RawHandle) -> process::Stdio {\n         let handle = sys::handle::Handle::new(handle as *mut _);\n-        process::Stdio::from_inner(handle)\n+        let io = sys::process::Stdio::Handle(handle);\n+        process::Stdio::from_inner(io)\n     }\n }\n "}, {"sha": "aec41885f3b879123c5f624bade4e09f80ce7b03", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d15db1d392c9126ed5cc766753f08540c08a3626/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d15db1d392c9126ed5cc766753f08540c08a3626/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=d15db1d392c9126ed5cc766753f08540c08a3626", "patch": "@@ -37,8 +37,6 @@ impl AnonPipe {\n     pub fn handle(&self) -> &Handle { &self.inner }\n     pub fn into_handle(self) -> Handle { self.inner }\n \n-    pub fn raw(&self) -> c::HANDLE { self.inner.raw() }\n-\n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n         self.inner.read(buf)\n     }"}, {"sha": "fa118be6fe6b19c8908fc61e7ffc6bd4032e19cb", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 135, "deletions": 90, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/d15db1d392c9126ed5cc766753f08540c08a3626/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d15db1d392c9126ed5cc766753f08540c08a3626/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=d15db1d392c9126ed5cc766753f08540c08a3626", "patch": "@@ -26,9 +26,9 @@ use path::Path;\n use ptr;\n use sync::StaticMutex;\n use sys::c;\n-\n use sys::fs::{OpenOptions, File};\n-use sys::handle::{Handle, RawHandle};\n+use sys::handle::Handle;\n+use sys::pipe::{self, AnonPipe};\n use sys::stdio;\n use sys::{self, cvt};\n use sys_common::{AsInner, FromInner};\n@@ -51,13 +51,28 @@ fn ensure_no_nuls<T: AsRef<OsStr>>(str: T) -> io::Result<T> {\n     }\n }\n \n-#[derive(Clone)]\n pub struct Command {\n     program: OsString,\n     args: Vec<OsString>,\n     env: Option<HashMap<OsString, OsString>>,\n     cwd: Option<OsString>,\n     detach: bool, // not currently exposed in std::process\n+    stdin: Option<Stdio>,\n+    stdout: Option<Stdio>,\n+    stderr: Option<Stdio>,\n+}\n+\n+pub enum Stdio {\n+    Inherit,\n+    Null,\n+    MakePipe,\n+    Handle(Handle),\n+}\n+\n+pub struct StdioPipes {\n+    pub stdin: Option<AnonPipe>,\n+    pub stdout: Option<AnonPipe>,\n+    pub stderr: Option<AnonPipe>,\n }\n \n impl Command {\n@@ -68,6 +83,9 @@ impl Command {\n             env: None,\n             cwd: None,\n             detach: false,\n+            stdin: None,\n+            stdout: None,\n+            stderr: None,\n         }\n     }\n \n@@ -95,56 +113,29 @@ impl Command {\n     pub fn cwd(&mut self, dir: &OsStr) {\n         self.cwd = Some(dir.to_os_string())\n     }\n-}\n-\n-impl fmt::Debug for Command {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{:?}\", self.program));\n-        for arg in &self.args {\n-            try!(write!(f, \" {:?}\", arg));\n-        }\n-        Ok(())\n+    pub fn stdin(&mut self, stdin: Stdio) {\n+        self.stdin = Some(stdin);\n+    }\n+    pub fn stdout(&mut self, stdout: Stdio) {\n+        self.stdout = Some(stdout);\n+    }\n+    pub fn stderr(&mut self, stderr: Stdio) {\n+        self.stderr = Some(stderr);\n     }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Processes\n-////////////////////////////////////////////////////////////////////////////////\n-\n-/// A value representing a child process.\n-///\n-/// The lifetime of this value is linked to the lifetime of the actual\n-/// process - the Process destructor calls self.finish() which waits\n-/// for the process to terminate.\n-pub struct Process {\n-    handle: Handle,\n-}\n-\n-pub enum Stdio {\n-    Inherit,\n-    Null,\n-    Raw(c::HANDLE),\n-}\n-\n-pub type RawStdio = Handle;\n \n-impl Process {\n-    pub fn spawn(cfg: &Command,\n-                 in_handle: Stdio,\n-                 out_handle: Stdio,\n-                 err_handle: Stdio) -> io::Result<Process>\n-    {\n+    pub fn spawn(&mut self, default: Stdio)\n+                 -> io::Result<(Process, StdioPipes)> {\n         // To have the spawning semantics of unix/windows stay the same, we need\n         // to read the *child's* PATH if one is provided. See #15149 for more\n         // details.\n-        let program = cfg.env.as_ref().and_then(|env| {\n+        let program = self.env.as_ref().and_then(|env| {\n             for (key, v) in env {\n                 if OsStr::new(\"PATH\") != &**key { continue }\n \n                 // Split the value and test each path to see if the\n                 // program exists.\n                 for path in split_paths(&v) {\n-                    let path = path.join(cfg.program.to_str().unwrap())\n+                    let path = path.join(self.program.to_str().unwrap())\n                                    .with_extension(env::consts::EXE_EXTENSION);\n                     if fs::metadata(&path).is_ok() {\n                         return Some(path.into_os_string())\n@@ -159,18 +150,18 @@ impl Process {\n         si.cb = mem::size_of::<c::STARTUPINFO>() as c::DWORD;\n         si.dwFlags = c::STARTF_USESTDHANDLES;\n \n-        let program = program.as_ref().unwrap_or(&cfg.program);\n-        let mut cmd_str = try!(make_command_line(program, &cfg.args));\n+        let program = program.as_ref().unwrap_or(&self.program);\n+        let mut cmd_str = try!(make_command_line(program, &self.args));\n         cmd_str.push(0); // add null terminator\n \n         // stolen from the libuv code.\n         let mut flags = c::CREATE_UNICODE_ENVIRONMENT;\n-        if cfg.detach {\n+        if self.detach {\n             flags |= c::DETACHED_PROCESS | c::CREATE_NEW_PROCESS_GROUP;\n         }\n \n-        let (envp, _data) = try!(make_envp(cfg.env.as_ref()));\n-        let (dirp, _data) = try!(make_dirp(cfg.cwd.as_ref()));\n+        let (envp, _data) = try!(make_envp(self.env.as_ref()));\n+        let (dirp, _data) = try!(make_dirp(self.cwd.as_ref()));\n         let mut pi = zeroed_process_information();\n \n         // Prepare all stdio handles to be inherited by the child. This\n@@ -185,9 +176,19 @@ impl Process {\n         static CREATE_PROCESS_LOCK: StaticMutex = StaticMutex::new();\n         let _lock = CREATE_PROCESS_LOCK.lock();\n \n-        let stdin = try!(in_handle.to_handle(c::STD_INPUT_HANDLE));\n-        let stdout = try!(out_handle.to_handle(c::STD_OUTPUT_HANDLE));\n-        let stderr = try!(err_handle.to_handle(c::STD_ERROR_HANDLE));\n+        let mut pipes = StdioPipes {\n+            stdin: None,\n+            stdout: None,\n+            stderr: None,\n+        };\n+        let stdin = self.stdin.as_ref().unwrap_or(&default);\n+        let stdout = self.stdout.as_ref().unwrap_or(&default);\n+        let stderr = self.stderr.as_ref().unwrap_or(&default);\n+        let stdin = try!(stdin.to_handle(c::STD_INPUT_HANDLE, &mut pipes.stdin));\n+        let stdout = try!(stdout.to_handle(c::STD_OUTPUT_HANDLE,\n+                                           &mut pipes.stdout));\n+        let stderr = try!(stderr.to_handle(c::STD_ERROR_HANDLE,\n+                                           &mut pipes.stderr));\n         si.hStdInput = stdin.raw();\n         si.hStdOutput = stdout.raw();\n         si.hStdError = stderr.raw();\n@@ -206,9 +207,92 @@ impl Process {\n         // around to be able to close it later.\n         drop(Handle::new(pi.hThread));\n \n-        Ok(Process { handle: Handle::new(pi.hProcess) })\n+        Ok((Process { handle: Handle::new(pi.hProcess) }, pipes))\n+    }\n+\n+}\n+\n+impl fmt::Debug for Command {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"{:?}\", self.program));\n+        for arg in &self.args {\n+            try!(write!(f, \" {:?}\", arg));\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl Stdio {\n+    fn to_handle(&self, stdio_id: c::DWORD, pipe: &mut Option<AnonPipe>)\n+                 -> io::Result<Handle> {\n+        match *self {\n+            // If no stdio handle is available, then inherit means that it\n+            // should still be unavailable so propagate the\n+            // INVALID_HANDLE_VALUE.\n+            Stdio::Inherit => {\n+                match stdio::get(stdio_id) {\n+                    Ok(io) => io.handle().duplicate(0, true,\n+                                                    c::DUPLICATE_SAME_ACCESS),\n+                    Err(..) => Ok(Handle::new(c::INVALID_HANDLE_VALUE)),\n+                }\n+            }\n+\n+            Stdio::MakePipe => {\n+                let (reader, writer) = try!(pipe::anon_pipe());\n+                let (ours, theirs) = if stdio_id == c::STD_INPUT_HANDLE {\n+                    (writer, reader)\n+                } else {\n+                    (reader, writer)\n+                };\n+                *pipe = Some(ours);\n+                try!(cvt(unsafe {\n+                    c::SetHandleInformation(theirs.handle().raw(),\n+                                            c::HANDLE_FLAG_INHERIT,\n+                                            c::HANDLE_FLAG_INHERIT)\n+                }));\n+                Ok(theirs.into_handle())\n+            }\n+\n+            Stdio::Handle(ref handle) => {\n+                handle.duplicate(0, true, c::DUPLICATE_SAME_ACCESS)\n+            }\n+\n+            // Open up a reference to NUL with appropriate read/write\n+            // permissions as well as the ability to be inherited to child\n+            // processes (as this is about to be inherited).\n+            Stdio::Null => {\n+                let size = mem::size_of::<c::SECURITY_ATTRIBUTES>();\n+                let mut sa = c::SECURITY_ATTRIBUTES {\n+                    nLength: size as c::DWORD,\n+                    lpSecurityDescriptor: ptr::null_mut(),\n+                    bInheritHandle: 1,\n+                };\n+                let mut opts = OpenOptions::new();\n+                opts.read(stdio_id == c::STD_INPUT_HANDLE);\n+                opts.write(stdio_id != c::STD_INPUT_HANDLE);\n+                opts.security_attributes(&mut sa);\n+                File::open(Path::new(\"NUL\"), &opts).map(|file| {\n+                    file.into_handle()\n+                })\n+            }\n+        }\n     }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Processes\n+////////////////////////////////////////////////////////////////////////////////\n+\n+/// A value representing a child process.\n+///\n+/// The lifetime of this value is linked to the lifetime of the actual\n+/// process - the Process destructor calls self.finish() which waits\n+/// for the process to terminate.\n+pub struct Process {\n+    handle: Handle,\n+}\n \n+impl Process {\n     pub fn kill(&mut self) -> io::Result<()> {\n         try!(cvt(unsafe {\n             c::TerminateProcess(self.handle.raw(), 1)\n@@ -376,45 +460,6 @@ fn make_dirp(d: Option<&OsString>) -> io::Result<(*const u16, Vec<u16>)> {\n     }\n }\n \n-impl Stdio {\n-    fn to_handle(&self, stdio_id: c::DWORD) -> io::Result<Handle> {\n-        match *self {\n-            // If no stdio handle is available, then inherit means that it\n-            // should still be unavailable so propagate the\n-            // INVALID_HANDLE_VALUE.\n-            Stdio::Inherit => {\n-                match stdio::get(stdio_id) {\n-                    Ok(io) => io.handle().duplicate(0, true,\n-                                                    c::DUPLICATE_SAME_ACCESS),\n-                    Err(..) => Ok(Handle::new(c::INVALID_HANDLE_VALUE)),\n-                }\n-            }\n-            Stdio::Raw(handle) => {\n-                RawHandle::new(handle).duplicate(0, true, c::DUPLICATE_SAME_ACCESS)\n-            }\n-\n-            // Open up a reference to NUL with appropriate read/write\n-            // permissions as well as the ability to be inherited to child\n-            // processes (as this is about to be inherited).\n-            Stdio::Null => {\n-                let size = mem::size_of::<c::SECURITY_ATTRIBUTES>();\n-                let mut sa = c::SECURITY_ATTRIBUTES {\n-                    nLength: size as c::DWORD,\n-                    lpSecurityDescriptor: ptr::null_mut(),\n-                    bInheritHandle: 1,\n-                };\n-                let mut opts = OpenOptions::new();\n-                opts.read(stdio_id == c::STD_INPUT_HANDLE);\n-                opts.write(stdio_id != c::STD_INPUT_HANDLE);\n-                opts.security_attributes(&mut sa);\n-                File::open(Path::new(\"NUL\"), &opts).map(|file| {\n-                    file.into_handle()\n-                })\n-            }\n-        }\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use prelude::v1::*;"}]}