{"sha": "bd03d8167f856044df6430f1dd69142f7511aca8", "node_id": "C_kwDOAAsO6NoAKGJkMDNkODE2N2Y4NTYwNDRkZjY0MzBmMWRkNjkxNDJmNzUxMWFjYTg", "commit": {"author": {"name": "kadmin", "email": "julianknodt@gmail.com", "date": "2022-01-26T17:02:58Z"}, "committer": {"name": "kadmin", "email": "julianknodt@gmail.com", "date": "2022-01-28T00:25:36Z"}, "message": "Remove generalization over projection\n\nInstead, just use a term everywhere.", "tree": {"sha": "c7a85a4397297096fb24bb75ba5862d498c2caf0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7a85a4397297096fb24bb75ba5862d498c2caf0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd03d8167f856044df6430f1dd69142f7511aca8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd03d8167f856044df6430f1dd69142f7511aca8", "html_url": "https://github.com/rust-lang/rust/commit/bd03d8167f856044df6430f1dd69142f7511aca8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd03d8167f856044df6430f1dd69142f7511aca8/comments", "author": {"login": "JulianKnodt", "id": 7675847, "node_id": "MDQ6VXNlcjc2NzU4NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/7675847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JulianKnodt", "html_url": "https://github.com/JulianKnodt", "followers_url": "https://api.github.com/users/JulianKnodt/followers", "following_url": "https://api.github.com/users/JulianKnodt/following{/other_user}", "gists_url": "https://api.github.com/users/JulianKnodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/JulianKnodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JulianKnodt/subscriptions", "organizations_url": "https://api.github.com/users/JulianKnodt/orgs", "repos_url": "https://api.github.com/users/JulianKnodt/repos", "events_url": "https://api.github.com/users/JulianKnodt/events{/privacy}", "received_events_url": "https://api.github.com/users/JulianKnodt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JulianKnodt", "id": 7675847, "node_id": "MDQ6VXNlcjc2NzU4NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/7675847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JulianKnodt", "html_url": "https://github.com/JulianKnodt", "followers_url": "https://api.github.com/users/JulianKnodt/followers", "following_url": "https://api.github.com/users/JulianKnodt/following{/other_user}", "gists_url": "https://api.github.com/users/JulianKnodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/JulianKnodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JulianKnodt/subscriptions", "organizations_url": "https://api.github.com/users/JulianKnodt/orgs", "repos_url": "https://api.github.com/users/JulianKnodt/repos", "events_url": "https://api.github.com/users/JulianKnodt/events{/privacy}", "received_events_url": "https://api.github.com/users/JulianKnodt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c4fe64bdcb0cc27c91c5405430f0ca189fcd065", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c4fe64bdcb0cc27c91c5405430f0ca189fcd065", "html_url": "https://github.com/rust-lang/rust/commit/1c4fe64bdcb0cc27c91c5405430f0ca189fcd065"}], "stats": {"total": 485, "additions": 160, "deletions": 325}, "files": [{"sha": "248e7ef82e481438e50bb30a92f1e26ba7bc2ece", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bd03d8167f856044df6430f1dd69142f7511aca8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd03d8167f856044df6430f1dd69142f7511aca8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=bd03d8167f856044df6430f1dd69142f7511aca8", "patch": "@@ -286,6 +286,26 @@ impl<'tcx> ToTrace<'tcx> for &'tcx Const<'tcx> {\n     }\n }\n \n+impl<'tcx> ToTrace<'tcx> for ty::Term<'tcx> {\n+    fn to_trace(\n+        tcx: TyCtxt<'tcx>,\n+        cause: &ObligationCause<'tcx>,\n+        a_is_expected: bool,\n+        a: Self,\n+        b: Self,\n+    ) -> TypeTrace<'tcx> {\n+        match (a, b) {\n+            (ty::Term::Ty(a), ty::Term::Ty(b)) => {\n+                ToTrace::to_trace(tcx, cause, a_is_expected, a, b)\n+            }\n+            (ty::Term::Const(a), ty::Term::Const(b)) => {\n+                ToTrace::to_trace(tcx, cause, a_is_expected, a, b)\n+            }\n+            (_, _) => span_bug!(cause.span, \"Unexpected type/const mismatch\"),\n+        }\n+    }\n+}\n+\n impl<'tcx> ToTrace<'tcx> for ty::TraitRef<'tcx> {\n     fn to_trace(\n         _: TyCtxt<'tcx>,"}, {"sha": "a1a1168a21d2e8fa216670c452d8d0a7a8407685", "filename": "compiler/rustc_infer/src/traits/project.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bd03d8167f856044df6430f1dd69142f7511aca8/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd03d8167f856044df6430f1dd69142f7511aca8/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fproject.rs?ref=bd03d8167f856044df6430f1dd69142f7511aca8", "patch": "@@ -93,7 +93,7 @@ pub enum ProjectionCacheEntry<'tcx> {\n     Recur,\n     Error,\n     NormalizedTy {\n-        ty: NormalizedTy<'tcx>,\n+        ty: Normalized<'tcx, ty::Term<'tcx>>,\n         /// If we were able to successfully evaluate the\n         /// corresponding cache entry key during predicate\n         /// evaluation, then this field stores the final\n@@ -174,7 +174,11 @@ impl<'tcx> ProjectionCache<'_, 'tcx> {\n     }\n \n     /// Indicates that `key` was normalized to `value`.\n-    pub fn insert_ty(&mut self, key: ProjectionCacheKey<'tcx>, value: NormalizedTy<'tcx>) {\n+    pub fn insert_term(\n+        &mut self,\n+        key: ProjectionCacheKey<'tcx>,\n+        value: Normalized<'tcx, ty::Term<'tcx>>,\n+    ) {\n         debug!(\n             \"ProjectionCacheEntry::insert_ty: adding cache entry: key={:?}, value={:?}\",\n             key, value"}, {"sha": "d06e8496f59b78919fea43c94aabe94d3bbdf438", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bd03d8167f856044df6430f1dd69142f7511aca8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd03d8167f856044df6430f1dd69142f7511aca8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=bd03d8167f856044df6430f1dd69142f7511aca8", "patch": "@@ -1351,19 +1351,31 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                         | ObligationCauseCode::ObjectCastObligation(_)\n                         | ObligationCauseCode::OpaqueType\n                 );\n-                // FIXME(associated_const_equality): Handle Consts here\n-                let data_ty = data.term.ty().unwrap();\n                 if let Err(error) = self.at(&obligation.cause, obligation.param_env).eq_exp(\n                     is_normalized_ty_expected,\n                     normalized_ty,\n-                    data_ty,\n+                    data.term,\n                 ) {\n-                    values = Some(infer::ValuePairs::Types(ExpectedFound::new(\n-                        is_normalized_ty_expected,\n-                        normalized_ty,\n-                        data_ty,\n-                    )));\n-\n+                    values = Some(match (normalized_ty, data.term) {\n+                        (ty::Term::Ty(normalized_ty), ty::Term::Ty(ty)) => {\n+                            infer::ValuePairs::Types(ExpectedFound::new(\n+                                is_normalized_ty_expected,\n+                                normalized_ty,\n+                                ty,\n+                            ))\n+                        }\n+                        (ty::Term::Const(normalized_ct), ty::Term::Const(ct)) => {\n+                            infer::ValuePairs::Consts(ExpectedFound::new(\n+                                is_normalized_ty_expected,\n+                                normalized_ct,\n+                                ct,\n+                            ))\n+                        }\n+                        (_, _) => span_bug!(\n+                            obligation.cause.span,\n+                            \"found const or type where other expected\"\n+                        ),\n+                    });\n                     err_buf = error;\n                     err = &err_buf;\n                 }"}, {"sha": "4bf10edd5cad573b8aba7bb41056b44e6d2cf35c", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd03d8167f856044df6430f1dd69142f7511aca8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd03d8167f856044df6430f1dd69142f7511aca8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=bd03d8167f856044df6430f1dd69142f7511aca8", "patch": "@@ -2496,7 +2496,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 let try_obligation = self.mk_trait_obligation_with_new_self_ty(\n                     obligation.param_env,\n                     trait_pred,\n-                    normalized_ty,\n+                    normalized_ty.ty().unwrap(),\n                 );\n                 debug!(\"suggest_await_before_try: try_trait_obligation {:?}\", try_obligation);\n                 if self.predicate_may_hold(&try_obligation)"}, {"sha": "e7897887df7063896245eacb455be83a41d75f81", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd03d8167f856044df6430f1dd69142f7511aca8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd03d8167f856044df6430f1dd69142f7511aca8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=bd03d8167f856044df6430f1dd69142f7511aca8", "patch": "@@ -200,7 +200,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n \n         debug!(?normalized_ty);\n \n-        normalized_ty\n+        normalized_ty.ty().unwrap()\n     }\n \n     fn register_predicate_obligation("}, {"sha": "ec495bcd6550914c3740ec2bf58405c4ed37dfb7", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 76, "deletions": 309, "changes": 385, "blob_url": "https://github.com/rust-lang/rust/blob/bd03d8167f856044df6430f1dd69142f7511aca8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd03d8167f856044df6430f1dd69142f7511aca8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=bd03d8167f856044df6430f1dd69142f7511aca8", "patch": "@@ -27,7 +27,7 @@ use rustc_hir::lang_items::LangItem;\n use rustc_infer::infer::resolve::OpportunisticRegionResolver;\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n use rustc_middle::ty::subst::Subst;\n-use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Term, ToPredicate, Ty, TyCtxt};\n use rustc_span::symbol::sym;\n \n use std::collections::BTreeMap;\n@@ -200,22 +200,22 @@ fn project_and_unify_type<'cx, 'tcx>(\n     let infcx = selcx.infcx();\n     match obligation.predicate.term {\n         ty::Term::Ty(obligation_pred_ty) => {\n-            let normalized_ty = match opt_normalize_projection_type(\n+            let normalized_ty = match opt_normalize_projection_type::<false>(\n                 selcx,\n                 obligation.param_env,\n                 obligation.predicate.projection_ty,\n                 obligation.cause.clone(),\n                 obligation.recursion_depth,\n                 &mut obligations,\n             ) {\n-                Ok(Some(n)) => n,\n+                Ok(Some(n)) => n.ty().unwrap(),\n                 Ok(None) => return Ok(Ok(None)),\n                 Err(InProgress) => return Ok(Err(InProgress)),\n             };\n             debug!(?normalized_ty, ?obligations, \"project_and_unify_type result\");\n             match infcx\n                 .at(&obligation.cause, obligation.param_env)\n-                .eq(normalized_ty, obligation_pred_ty)\n+                .eq(normalized_ty, obligation_pred_ty.into())\n             {\n                 Ok(InferOk { obligations: inferred_obligations, value: () }) => {\n                     obligations.extend(inferred_obligations);\n@@ -227,25 +227,22 @@ fn project_and_unify_type<'cx, 'tcx>(\n                 }\n             }\n         }\n-        ty::Term::Const(_obligation_pred_const) => {\n-            let normalized_const = match opt_normalize_projection_const(\n+        ty::Term::Const(obligation_pred_const) => {\n+            let normalized_const = match opt_normalize_projection_type::<true>(\n                 selcx,\n                 obligation.param_env,\n                 obligation.predicate.projection_ty,\n                 obligation.cause.clone(),\n                 obligation.recursion_depth,\n                 &mut obligations,\n             ) {\n-                Ok(Some(n)) => n,\n+                Ok(Some(n)) => n.ct().unwrap(),\n                 Ok(None) => return Ok(Ok(None)),\n                 Err(InProgress) => return Ok(Err(InProgress)),\n             };\n-            println!(\"{:?}\", normalized_const);\n-            todo!();\n-            /*\n             match infcx\n                 .at(&obligation.cause, obligation.param_env)\n-                .eq(normalized_ty, obligation_pred_const)\n+                .eq(normalized_const, obligation_pred_const)\n             {\n                 Ok(InferOk { obligations: inferred_obligations, value: () }) => {\n                     obligations.extend(inferred_obligations);\n@@ -256,7 +253,6 @@ fn project_and_unify_type<'cx, 'tcx>(\n                     Err(MismatchedProjectionTypes { err })\n                 }\n             }\n-            */\n         }\n     }\n }\n@@ -476,7 +472,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                     obligations.len = ?self.obligations.len(),\n                     \"AssocTypeNormalizer: normalized type\"\n                 );\n-                normalized_ty\n+                normalized_ty.ty().unwrap()\n             }\n \n             ty::Projection(data) => {\n@@ -496,7 +492,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                 let (data, mapped_regions, mapped_types, mapped_consts) =\n                     BoundVarReplacer::replace_bound_vars(infcx, &mut self.universes, data);\n                 let data = data.super_fold_with(self);\n-                let normalized_ty = opt_normalize_projection_type(\n+                let normalized_ty = opt_normalize_projection_type::<false>(\n                     self.selcx,\n                     self.param_env,\n                     data,\n@@ -506,6 +502,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                 )\n                 .ok()\n                 .flatten()\n+                .map(|term| term.ty().unwrap())\n                 .map(|normalized_ty| {\n                     PlaceholderReplacer::replace_placeholders(\n                         infcx,\n@@ -828,8 +825,8 @@ pub fn normalize_projection_type<'a, 'b, 'tcx>(\n     cause: ObligationCause<'tcx>,\n     depth: usize,\n     obligations: &mut Vec<PredicateObligation<'tcx>>,\n-) -> Ty<'tcx> {\n-    opt_normalize_projection_type(\n+) -> Term<'tcx> {\n+    opt_normalize_projection_type::<false>(\n         selcx,\n         param_env,\n         projection_ty,\n@@ -844,26 +841,13 @@ pub fn normalize_projection_type<'a, 'b, 'tcx>(\n         // and a deferred predicate to resolve this when more type\n         // information is available.\n \n-        selcx.infcx().infer_projection(param_env, projection_ty, cause, depth + 1, obligations)\n+        selcx\n+            .infcx()\n+            .infer_projection(param_env, projection_ty, cause, depth + 1, obligations)\n+            .into()\n     })\n }\n \n-fn opt_normalize_projection_const<'a, 'b, 'tcx>(\n-    selcx: &'a mut SelectionContext<'b, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    projection_const: ty::ProjectionTy<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-    depth: usize,\n-    _obligations: &mut Vec<PredicateObligation<'tcx>>,\n-) -> Result<Option<&'tcx ty::Const<'tcx>>, InProgress> {\n-    let infcx = selcx.infcx();\n-    let projection_const = infcx.resolve_vars_if_possible(projection_const);\n-    let obligation = Obligation::with_depth(cause.clone(), depth, param_env, projection_const);\n-    // TODO continue working on below\n-    let _projected_const = project_const(selcx, &obligation);\n-    //println!(\"{:?}\", projected_const);\n-    todo!();\n-}\n /// The guts of `normalize`: normalize a specific projection like `<T\n /// as Trait>::Item`. The result is always a type (and possibly\n /// additional obligations). Returns `None` in the case of ambiguity,\n@@ -875,14 +859,14 @@ fn opt_normalize_projection_const<'a, 'b, 'tcx>(\n /// function takes an obligations vector and appends to it directly, which is\n /// slightly uglier but avoids the need for an extra short-lived allocation.\n #[instrument(level = \"debug\", skip(selcx, param_env, cause, obligations))]\n-fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n+fn opt_normalize_projection_type<'a, 'b, 'tcx, const INTO_CONST: bool>(\n     selcx: &'a mut SelectionContext<'b, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     projection_ty: ty::ProjectionTy<'tcx>,\n     cause: ObligationCause<'tcx>,\n     depth: usize,\n     obligations: &mut Vec<PredicateObligation<'tcx>>,\n-) -> Result<Option<Ty<'tcx>>, InProgress> {\n+) -> Result<Option<Term<'tcx>>, InProgress> {\n     let infcx = selcx.infcx();\n     // Don't use the projection cache in intercrate mode -\n     // the `infcx` may be re-used between intercrate in non-intercrate\n@@ -949,49 +933,44 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             // created (and hence the new ones will quickly be\n             // discarded as duplicated). But when doing trait\n             // evaluation this is not the case, and dropping the trait\n-            // evaluations can causes ICEs (e.g., #43132).\n-            debug!(?ty, \"found normalized ty\");\n             obligations.extend(ty.obligations);\n             return Ok(Some(ty.value));\n         }\n         Err(ProjectionCacheEntry::Error) => {\n             debug!(\"opt_normalize_projection_type: found error\");\n             let result = normalize_to_error(selcx, param_env, projection_ty, cause, depth);\n             obligations.extend(result.obligations);\n-            return Ok(Some(result.value));\n+            return Ok(Some(result.value.into()));\n         }\n     }\n \n     let obligation = Obligation::with_depth(cause.clone(), depth, param_env, projection_ty);\n \n-    match project_type(selcx, &obligation) {\n+    match project::<INTO_CONST>(selcx, &obligation) {\n         Ok(Projected::Progress(Progress {\n-            term: projected_ty,\n+            term: projected_term,\n             obligations: mut projected_obligations,\n         })) => {\n             // if projection succeeded, then what we get out of this\n             // is also non-normalized (consider: it was derived from\n             // an impl, where-clause etc) and hence we must\n             // re-normalize it\n \n-            let projected_ty = selcx.infcx().resolve_vars_if_possible(projected_ty);\n-            debug!(?projected_ty, ?depth, ?projected_obligations);\n+            let projected_term = selcx.infcx().resolve_vars_if_possible(projected_term);\n \n-            let mut result = if projected_ty.has_projections() {\n+            let mut result = if projected_term.has_projections() {\n                 let mut normalizer = AssocTypeNormalizer::new(\n                     selcx,\n                     param_env,\n                     cause,\n                     depth + 1,\n                     &mut projected_obligations,\n                 );\n-                let normalized_ty = normalizer.fold(projected_ty);\n-\n-                debug!(?normalized_ty, ?depth);\n+                let normalized_ty = normalizer.fold(projected_term);\n \n                 Normalized { value: normalized_ty, obligations: projected_obligations }\n             } else {\n-                Normalized { value: projected_ty, obligations: projected_obligations }\n+                Normalized { value: projected_term, obligations: projected_obligations }\n             };\n \n             let mut deduped: SsoHashSet<_> = Default::default();\n@@ -1003,16 +982,15 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             });\n \n             if use_cache {\n-                infcx.inner.borrow_mut().projection_cache().insert_ty(cache_key, result.clone());\n+                infcx.inner.borrow_mut().projection_cache().insert_term(cache_key, result.clone());\n             }\n             obligations.extend(result.obligations);\n-            Ok(Some(result.value))\n+            Ok(Some(result.value.into()))\n         }\n         Ok(Projected::NoProgress(projected_ty)) => {\n-            debug!(?projected_ty, \"opt_normalize_projection_type: no progress\");\n             let result = Normalized { value: projected_ty, obligations: vec![] };\n             if use_cache {\n-                infcx.inner.borrow_mut().projection_cache().insert_ty(cache_key, result.clone());\n+                infcx.inner.borrow_mut().projection_cache().insert_term(cache_key, result.clone());\n             }\n             // No need to extend `obligations`.\n             Ok(Some(result.value))\n@@ -1036,7 +1014,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             }\n             let result = normalize_to_error(selcx, param_env, projection_ty, cause, depth);\n             obligations.extend(result.obligations);\n-            Ok(Some(result.value))\n+            Ok(Some(result.value.into()))\n         }\n     }\n }\n@@ -1083,22 +1061,19 @@ fn normalize_to_error<'a, 'tcx>(\n     Normalized { value: new_value, obligations: vec![trait_obligation] }\n }\n \n-enum Projected<'tcx, T> {\n-    Progress(Progress<'tcx, T>),\n-    NoProgress(T),\n+enum Projected<'tcx> {\n+    Progress(Progress<'tcx>),\n+    NoProgress(ty::Term<'tcx>),\n }\n \n-struct Progress<'tcx, T>\n-where\n-    T: 'tcx,\n-{\n-    term: T,\n+struct Progress<'tcx> {\n+    term: ty::Term<'tcx>,\n     obligations: Vec<PredicateObligation<'tcx>>,\n }\n \n-impl<'tcx> Progress<'tcx, Ty<'tcx>> {\n+impl<'tcx> Progress<'tcx> {\n     fn error(tcx: TyCtxt<'tcx>) -> Self {\n-        Progress { term: tcx.ty_error(), obligations: vec![] }\n+        Progress { term: tcx.ty_error().into(), obligations: vec![] }\n     }\n \n     fn with_addl_obligations(mut self, mut obligations: Vec<PredicateObligation<'tcx>>) -> Self {\n@@ -1107,61 +1082,15 @@ impl<'tcx> Progress<'tcx, Ty<'tcx>> {\n     }\n }\n \n-impl<'tcx> Progress<'tcx, &'tcx ty::Const<'tcx>> {\n-    fn error_const(tcx: TyCtxt<'tcx>) -> Self {\n-        Progress { term: tcx.const_error(tcx.ty_error()), obligations: vec![] }\n-    }\n-}\n-\n-fn project_const<'cx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'tcx>,\n-    obligation: &ProjectionTyObligation<'tcx>,\n-) -> Result<Projected<'tcx, &'tcx ty::Const<'tcx>>, ProjectionError<'tcx>> {\n-    if !selcx.tcx().recursion_limit().value_within_limit(obligation.recursion_depth) {\n-        return Err(ProjectionError::TraitSelectionError(SelectionError::Overflow));\n-    }\n-\n-    if obligation.predicate.references_error() {\n-        return Ok(Projected::Progress(Progress::error_const(selcx.tcx())));\n-    }\n-\n-    let mut candidates = ProjectionCandidateSet::None;\n-\n-    assemble_candidates_from_param_env(selcx, obligation, &mut candidates);\n-    assemble_candidates_from_trait_def(selcx, obligation, &mut candidates);\n-    assemble_candidates_from_object_ty(selcx, obligation, &mut candidates);\n-    if let ProjectionCandidateSet::Single(ProjectionCandidate::Object(_)) = candidates {\n-    } else {\n-        assemble_candidates_from_impls(selcx, obligation, &mut candidates);\n-    };\n-    match candidates {\n-        ProjectionCandidateSet::Single(candidate) => {\n-            Ok(Projected::Progress(confirm_candidate_const(selcx, obligation, candidate)))\n-        }\n-        ProjectionCandidateSet::None => todo!(),\n-        /*\n-        Ok(Projected::NoProgress(\n-            selcx\n-                .tcx()\n-                .mk_projection(obligation.predicate.item_def_id, obligation.predicate.substs),\n-        )),\n-        */\n-        // Error occurred while trying to processing impls.\n-        ProjectionCandidateSet::Error(e) => Err(ProjectionError::TraitSelectionError(e)),\n-        // Inherent ambiguity that prevents us from even enumerating the candidates.\n-        ProjectionCandidateSet::Ambiguous => Err(ProjectionError::TooManyCandidates),\n-    }\n-}\n-\n /// Computes the result of a projection type (if we can).\n ///\n /// IMPORTANT:\n /// - `obligation` must be fully normalized\n #[tracing::instrument(level = \"info\", skip(selcx))]\n-fn project_type<'cx, 'tcx>(\n+fn project<'cx, 'tcx, const INTO_CONST: bool>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-) -> Result<Projected<'tcx, Ty<'tcx>>, ProjectionError<'tcx>> {\n+) -> Result<Projected<'tcx>, ProjectionError<'tcx>> {\n     if !selcx.tcx().recursion_limit().value_within_limit(obligation.recursion_depth) {\n         // This should really be an immediate error, but some existing code\n         // relies on being able to recover from this.\n@@ -1194,12 +1123,13 @@ fn project_type<'cx, 'tcx>(\n \n     match candidates {\n         ProjectionCandidateSet::Single(candidate) => {\n-            Ok(Projected::Progress(confirm_candidate(selcx, obligation, candidate)))\n+            Ok(Projected::Progress(confirm_candidate::<INTO_CONST>(selcx, obligation, candidate)))\n         }\n         ProjectionCandidateSet::None => Ok(Projected::NoProgress(\n             selcx\n                 .tcx()\n-                .mk_projection(obligation.predicate.item_def_id, obligation.predicate.substs),\n+                .mk_projection(obligation.predicate.item_def_id, obligation.predicate.substs)\n+                .into(),\n         )),\n         // Error occurred while trying to processing impls.\n         ProjectionCandidateSet::Error(e) => Err(ProjectionError::TraitSelectionError(e)),\n@@ -1386,10 +1316,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n             super::ImplSource::Closure(_)\n             | super::ImplSource::Generator(_)\n             | super::ImplSource::FnPointer(_)\n-            | super::ImplSource::TraitAlias(_) => {\n-                debug!(?impl_source);\n-                true\n-            }\n+            | super::ImplSource::TraitAlias(_) => true,\n             super::ImplSource::UserDefined(impl_data) => {\n                 // We have to be careful when projecting out of an\n                 // impl because of specialization. If we are not in\n@@ -1598,11 +1525,11 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n     });\n }\n \n-fn confirm_candidate<'cx, 'tcx>(\n+fn confirm_candidate<'cx, 'tcx, const INTO_CONST: bool>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     candidate: ProjectionCandidate<'tcx>,\n-) -> Progress<'tcx, Ty<'tcx>> {\n+) -> Progress<'tcx> {\n     debug!(?obligation, ?candidate, \"confirm_candidate\");\n     let mut progress = match candidate {\n         ProjectionCandidate::ParamEnv(poly_projection)\n@@ -1615,38 +1542,7 @@ fn confirm_candidate<'cx, 'tcx>(\n         }\n \n         ProjectionCandidate::Select(impl_source) => {\n-            confirm_select_candidate(selcx, obligation, impl_source)\n-        }\n-    };\n-\n-    // When checking for cycle during evaluation, we compare predicates with\n-    // \"syntactic\" equality. Since normalization generally introduces a type\n-    // with new region variables, we need to resolve them to existing variables\n-    // when possible for this to work. See `auto-trait-projection-recursion.rs`\n-    // for a case where this matters.\n-    if progress.term.has_infer_regions() {\n-        progress.term = OpportunisticRegionResolver::new(selcx.infcx()).fold_ty(progress.term);\n-    }\n-    progress\n-}\n-\n-fn confirm_candidate_const<'cx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'tcx>,\n-    obligation: &ProjectionTyObligation<'tcx>,\n-    candidate: ProjectionCandidate<'tcx>,\n-) -> Progress<'tcx, &'tcx ty::Const<'tcx>> {\n-    let mut progress = match candidate {\n-        ProjectionCandidate::ParamEnv(poly_projection)\n-        | ProjectionCandidate::Object(poly_projection) => {\n-            confirm_param_env_candidate_const(selcx, obligation, poly_projection, false)\n-        }\n-\n-        ProjectionCandidate::TraitDef(poly_projection) => {\n-            confirm_param_env_candidate_const(selcx, obligation, poly_projection, true)\n-        }\n-\n-        ProjectionCandidate::Select(impl_source) => {\n-            confirm_select_candidate_const(selcx, obligation, impl_source)\n+            confirm_select_candidate::<INTO_CONST>(selcx, obligation, impl_source)\n         }\n     };\n \n@@ -1656,18 +1552,21 @@ fn confirm_candidate_const<'cx, 'tcx>(\n     // when possible for this to work. See `auto-trait-projection-recursion.rs`\n     // for a case where this matters.\n     if progress.term.has_infer_regions() {\n-        progress.term = OpportunisticRegionResolver::new(selcx.infcx()).fold_const(progress.term);\n+        progress.term =\n+            progress.term.fold_with(&mut OpportunisticRegionResolver::new(selcx.infcx()));\n     }\n     progress\n }\n \n-fn confirm_select_candidate<'cx, 'tcx>(\n+fn confirm_select_candidate<'cx, 'tcx, const INTO_CONST: bool>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     impl_source: Selection<'tcx>,\n-) -> Progress<'tcx, Ty<'tcx>> {\n+) -> Progress<'tcx> {\n     match impl_source {\n-        super::ImplSource::UserDefined(data) => confirm_impl_candidate(selcx, obligation, data),\n+        super::ImplSource::UserDefined(data) => {\n+            confirm_impl_candidate::<INTO_CONST>(selcx, obligation, data)\n+        }\n         super::ImplSource::Generator(data) => confirm_generator_candidate(selcx, obligation, data),\n         super::ImplSource::Closure(data) => confirm_closure_candidate(selcx, obligation, data),\n         super::ImplSource::FnPointer(data) => confirm_fn_pointer_candidate(selcx, obligation, data),\n@@ -1692,42 +1591,11 @@ fn confirm_select_candidate<'cx, 'tcx>(\n     }\n }\n \n-fn confirm_select_candidate_const<'cx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'tcx>,\n-    obligation: &ProjectionTyObligation<'tcx>,\n-    impl_source: Selection<'tcx>,\n-) -> Progress<'tcx, &'tcx ty::Const<'tcx>> {\n-    match impl_source {\n-        super::ImplSource::UserDefined(data) => {\n-            confirm_impl_candidate_const(selcx, obligation, data)\n-        }\n-        super::ImplSource::Generator(_)\n-        | super::ImplSource::Closure(_)\n-        | super::ImplSource::FnPointer(_)\n-        | super::ImplSource::DiscriminantKind(_)\n-        | super::ImplSource::Pointee(_) => todo!(),\n-        super::ImplSource::Object(_)\n-        | super::ImplSource::AutoImpl(..)\n-        | super::ImplSource::Param(..)\n-        | super::ImplSource::Builtin(..)\n-        | super::ImplSource::TraitUpcasting(_)\n-        | super::ImplSource::TraitAlias(..)\n-        | super::ImplSource::ConstDrop(_) => {\n-            // we don't create Select candidates with this kind of resolution\n-            span_bug!(\n-                obligation.cause.span,\n-                \"Cannot project an associated type from `{:?}`\",\n-                impl_source\n-            )\n-        }\n-    }\n-}\n-\n fn confirm_generator_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     impl_source: ImplSourceGeneratorData<'tcx, PredicateObligation<'tcx>>,\n-) -> Progress<'tcx, Ty<'tcx>> {\n+) -> Progress<'tcx> {\n     let gen_sig = impl_source.substs.as_generator().poly_sig();\n     let Normalized { value: gen_sig, obligations } = normalize_with_depth(\n         selcx,\n@@ -1777,7 +1645,7 @@ fn confirm_discriminant_kind_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     _: ImplSourceDiscriminantKindData,\n-) -> Progress<'tcx, Ty<'tcx>> {\n+) -> Progress<'tcx> {\n     let tcx = selcx.tcx();\n \n     let self_ty = selcx.infcx().shallow_resolve(obligation.predicate.self_ty());\n@@ -1802,7 +1670,7 @@ fn confirm_pointee_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     _: ImplSourcePointeeData,\n-) -> Progress<'tcx, Ty<'tcx>> {\n+) -> Progress<'tcx> {\n     let tcx = selcx.tcx();\n     let self_ty = selcx.infcx().shallow_resolve(obligation.predicate.self_ty());\n \n@@ -1834,7 +1702,7 @@ fn confirm_fn_pointer_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     fn_pointer_impl_source: ImplSourceFnPointerData<'tcx, PredicateObligation<'tcx>>,\n-) -> Progress<'tcx, Ty<'tcx>> {\n+) -> Progress<'tcx> {\n     let fn_type = selcx.infcx().shallow_resolve(fn_pointer_impl_source.fn_ty);\n     let sig = fn_type.fn_sig(selcx.tcx());\n     let Normalized { value: sig, obligations } = normalize_with_depth(\n@@ -1854,7 +1722,7 @@ fn confirm_closure_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     impl_source: ImplSourceClosureData<'tcx, PredicateObligation<'tcx>>,\n-) -> Progress<'tcx, Ty<'tcx>> {\n+) -> Progress<'tcx> {\n     let closure_sig = impl_source.substs.as_closure().sig();\n     let Normalized { value: closure_sig, obligations } = normalize_with_depth(\n         selcx,\n@@ -1876,7 +1744,7 @@ fn confirm_callable_candidate<'cx, 'tcx>(\n     obligation: &ProjectionTyObligation<'tcx>,\n     fn_sig: ty::PolyFnSig<'tcx>,\n     flag: util::TupleArgumentsFlag,\n-) -> Progress<'tcx, Ty<'tcx>> {\n+) -> Progress<'tcx> {\n     let tcx = selcx.tcx();\n \n     debug!(?obligation, ?fn_sig, \"confirm_callable_candidate\");\n@@ -1907,7 +1775,7 @@ fn confirm_param_env_candidate<'cx, 'tcx>(\n     obligation: &ProjectionTyObligation<'tcx>,\n     poly_cache_entry: ty::PolyProjectionPredicate<'tcx>,\n     potentially_unnormalized_candidate: bool,\n-) -> Progress<'tcx, Ty<'tcx>> {\n+) -> Progress<'tcx> {\n     let infcx = selcx.infcx();\n     let cause = &obligation.cause;\n     let param_env = obligation.param_env;\n@@ -1954,7 +1822,7 @@ fn confirm_param_env_candidate<'cx, 'tcx>(\n             assoc_ty_own_obligations(selcx, obligation, &mut nested_obligations);\n             // FIXME(associated_const_equality): Handle consts here as well? Maybe this progress type should just take\n             // a term instead.\n-            Progress { term: cache_entry.term.ty().unwrap(), obligations: nested_obligations }\n+            Progress { term: cache_entry.term, obligations: nested_obligations }\n         }\n         Err(e) => {\n             let msg = format!(\n@@ -1963,81 +1831,16 @@ fn confirm_param_env_candidate<'cx, 'tcx>(\n             );\n             debug!(\"confirm_param_env_candidate: {}\", msg);\n             let err = infcx.tcx.ty_error_with_message(obligation.cause.span, &msg);\n-            Progress { term: err, obligations: vec![] }\n+            Progress { term: err.into(), obligations: vec![] }\n         }\n     }\n }\n \n-fn confirm_param_env_candidate_const<'cx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'tcx>,\n-    obligation: &ProjectionTyObligation<'tcx>,\n-    poly_cache_entry: ty::PolyProjectionPredicate<'tcx>,\n-    potentially_unnormalized_candidate: bool,\n-) -> Progress<'tcx, &'tcx ty::Const<'tcx>> {\n-    let infcx = selcx.infcx();\n-    let cause = &obligation.cause;\n-    let param_env = obligation.param_env;\n-\n-    let (cache_entry, _) = infcx.replace_bound_vars_with_fresh_vars(\n-        cause.span,\n-        LateBoundRegionConversionTime::HigherRankedType,\n-        poly_cache_entry,\n-    );\n-\n-    let cache_projection = cache_entry.projection_ty;\n-    let mut nested_obligations = Vec::new();\n-    let obligation_projection = obligation.predicate;\n-    let obligation_projection = ensure_sufficient_stack(|| {\n-        normalize_with_depth_to(\n-            selcx,\n-            obligation.param_env,\n-            obligation.cause.clone(),\n-            obligation.recursion_depth + 1,\n-            obligation_projection,\n-            &mut nested_obligations,\n-        )\n-    });\n-    let cache_projection = if potentially_unnormalized_candidate {\n-        ensure_sufficient_stack(|| {\n-            normalize_with_depth_to(\n-                selcx,\n-                obligation.param_env,\n-                obligation.cause.clone(),\n-                obligation.recursion_depth + 1,\n-                cache_projection,\n-                &mut nested_obligations,\n-            )\n-        })\n-    } else {\n-        cache_projection\n-    };\n-\n-    match infcx.at(cause, param_env).eq(cache_projection, obligation_projection) {\n-        Ok(InferOk { value: _, obligations }) => {\n-            nested_obligations.extend(obligations);\n-            assoc_ty_own_obligations(selcx, obligation, &mut nested_obligations);\n-            Progress { term: cache_entry.term.ct().unwrap(), obligations: nested_obligations }\n-        }\n-        Err(e) => {\n-            let msg = format!(\n-                \"Failed to unify obligation `{:?}` with poly_projection `{:?}`: {:?}\",\n-                obligation, poly_cache_entry, e,\n-            );\n-            let err = infcx.tcx.const_error_with_message(\n-                infcx.tcx.ty_error(),\n-                obligation.cause.span,\n-                &msg,\n-            );\n-            Progress { term: err, obligations: vec![] }\n-        }\n-    }\n-}\n-\n-fn confirm_impl_candidate<'cx, 'tcx>(\n+fn confirm_impl_candidate<'cx, 'tcx, const INTO_CONST: bool>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     impl_impl_source: ImplSourceUserDefinedData<'tcx, PredicateObligation<'tcx>>,\n-) -> Progress<'tcx, Ty<'tcx>> {\n+) -> Progress<'tcx> {\n     let tcx = selcx.tcx();\n \n     let ImplSourceUserDefinedData { impl_def_id, substs, mut nested } = impl_impl_source;\n@@ -2047,7 +1850,7 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n     let param_env = obligation.param_env;\n     let assoc_ty = match assoc_def(selcx, impl_def_id, assoc_item_id) {\n         Ok(assoc_ty) => assoc_ty,\n-        Err(ErrorReported) => return Progress { term: tcx.ty_error(), obligations: nested },\n+        Err(ErrorReported) => return Progress { term: tcx.ty_error().into(), obligations: nested },\n     };\n \n     if !assoc_ty.item.defaultness.has_value() {\n@@ -2059,7 +1862,7 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n             \"confirm_impl_candidate: no associated type {:?} for {:?}\",\n             assoc_ty.item.name, obligation.predicate\n         );\n-        return Progress { term: tcx.ty_error(), obligations: nested };\n+        return Progress { term: tcx.ty_error().into(), obligations: nested };\n     }\n     // If we're trying to normalize `<Vec<u32> as X>::A<S>` using\n     //`impl<T> X for Vec<T> { type A<Y> = Box<Y>; }`, then:\n@@ -2071,59 +1874,23 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n     let substs =\n         translate_substs(selcx.infcx(), param_env, impl_def_id, substs, assoc_ty.defining_node);\n     let ty = tcx.type_of(assoc_ty.item.def_id);\n+    let term: ty::Term<'tcx> = if INTO_CONST {\n+        // FIXME(associated_const_equality): what are the right substs?\n+        let did = ty::WithOptConstParam::unknown(assoc_ty.item.def_id);\n+        let val = ty::ConstKind::Unevaluated(ty::Unevaluated::new(did, substs));\n+        tcx.mk_const(ty::Const { ty, val }).into()\n+    } else {\n+        ty.into()\n+    };\n     if substs.len() != tcx.generics_of(assoc_ty.item.def_id).count() {\n         let err = tcx.ty_error_with_message(\n             obligation.cause.span,\n             \"impl item and trait item have different parameter counts\",\n         );\n-        Progress { term: err, obligations: nested }\n+        Progress { term: err.into(), obligations: nested }\n     } else {\n         assoc_ty_own_obligations(selcx, obligation, &mut nested);\n-        Progress { term: ty.subst(tcx, substs), obligations: nested }\n-    }\n-}\n-\n-fn confirm_impl_candidate_const<'cx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'tcx>,\n-    obligation: &ProjectionTyObligation<'tcx>,\n-    impl_impl_source: ImplSourceUserDefinedData<'tcx, PredicateObligation<'tcx>>,\n-) -> Progress<'tcx, &'tcx ty::Const<'tcx>> {\n-    let tcx = selcx.tcx();\n-\n-    let ImplSourceUserDefinedData { impl_def_id, substs, nested } = impl_impl_source;\n-    let assoc_item_id = obligation.predicate.item_def_id;\n-    let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n-\n-    let param_env = obligation.param_env;\n-    let assoc_ct = match assoc_def(selcx, impl_def_id, assoc_item_id) {\n-        Ok(assoc_ct) => assoc_ct,\n-        Err(ErrorReported) => {\n-            return Progress { term: tcx.const_error(tcx.ty_error()), obligations: nested };\n-        }\n-    };\n-\n-    if !assoc_ct.item.defaultness.has_value() {\n-        return Progress { term: tcx.const_error(tcx.ty_error()), obligations: nested };\n-    }\n-    let substs = obligation.predicate.substs.rebase_onto(tcx, trait_def_id, substs);\n-    let substs =\n-        translate_substs(selcx.infcx(), param_env, impl_def_id, substs, assoc_ct.defining_node);\n-    let _ty = tcx.type_of(assoc_ct.item.def_id);\n-    // TODO need to figure how to get the const of the assoc_ct.item.def_id\n-    // I'm not sure if there's another tcx query for it.\n-    let _ct = ();\n-    if substs.len() != tcx.generics_of(assoc_ct.item.def_id).count() {\n-        let err = tcx.const_error_with_message(\n-            tcx.ty_error(),\n-            obligation.cause.span,\n-            \"impl item and trait item have different parameter counts\",\n-        );\n-        Progress { term: err, obligations: nested }\n-    } else {\n-        // There are no where-clauses on associated consts yet, but if that's\n-        // ever added it would go here.\n-        todo!();\n-        //Progress { term: ct.subst(tcx, substs), obligations: nested }\n+        Progress { term: term.subst(tcx, substs), obligations: nested }\n     }\n }\n "}, {"sha": "1de50bae31b8c73522f3373370351f3e3d2cd198", "filename": "compiler/rustc_traits/src/normalize_projection_ty.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bd03d8167f856044df6430f1dd69142f7511aca8/compiler%2Frustc_traits%2Fsrc%2Fnormalize_projection_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd03d8167f856044df6430f1dd69142f7511aca8/compiler%2Frustc_traits%2Fsrc%2Fnormalize_projection_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_projection_ty.rs?ref=bd03d8167f856044df6430f1dd69142f7511aca8", "patch": "@@ -36,7 +36,10 @@ fn normalize_projection_ty<'tcx>(\n                 &mut obligations,\n             );\n             fulfill_cx.register_predicate_obligations(infcx, obligations);\n-            Ok(NormalizationResult { normalized_ty: answer })\n+            // FIXME(associated_const_equality): All users of normalize_projection_ty expected\n+            // a type, but there is the possibility it could've been a const now. Maybe change\n+            // it to a Term later?\n+            Ok(NormalizationResult { normalized_ty: answer.ty().unwrap() })\n         },\n     )\n }"}, {"sha": "63a8cab3defcc44abd186fa96b548c6a76884c93", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd03d8167f856044df6430f1dd69142f7511aca8/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd03d8167f856044df6430f1dd69142f7511aca8/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=bd03d8167f856044df6430f1dd69142f7511aca8", "patch": "@@ -538,7 +538,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                               })\n                       }) =>\n                 {\n-                  // TODO when does this unwrap fail? I have no idea what case it would.\n+                  // FIXME(associated_const_equality) when does this unwrap fail? I have no idea what case it would.\n                   let trait_def_id = trait_ref.trait_def_id().unwrap();\n                   let assoc_items = tcx.associated_items(trait_def_id);\n                   let assoc_item = assoc_items.find_by_name_and_kind(\n@@ -547,7 +547,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                   if let Some(assoc_item) = assoc_item {\n                     tcx.type_of(assoc_item.def_id)\n                   } else {\n-                      // TODO useful error message here.\n+                      // FIXME(associated_const_equality): add a useful error message here.\n                       tcx.ty_error_with_message(\n                         DUMMY_SP,\n                         &format!(\"Could not find associated const on trait\"),"}, {"sha": "53e49e77b3eea7954ac7ab99e778e5a946a944a6", "filename": "src/test/ui/associated-consts/assoc-const-ty-mismatch.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bd03d8167f856044df6430f1dd69142f7511aca8/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const-ty-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd03d8167f856044df6430f1dd69142f7511aca8/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const-ty-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const-ty-mismatch.rs?ref=bd03d8167f856044df6430f1dd69142f7511aca8", "patch": "@@ -0,0 +1,29 @@\n+#![feature(associated_const_equality)]\n+#![allow(unused)]\n+\n+pub trait Foo {\n+  const N: usize;\n+}\n+\n+pub trait FooTy {\n+  type T;\n+}\n+\n+pub struct Bar;\n+\n+impl Foo for Bar {\n+  const N: usize = 3;\n+}\n+\n+impl FooTy for Bar {\n+  type T = usize;\n+}\n+\n+\n+fn foo<F: Foo<N=usize>>() {}\n+fn foo2<F: FooTy<T=3usize>>() {}\n+\n+fn main() {\n+  foo::<Bar>();\n+  foo2::<Bar>();\n+}"}]}