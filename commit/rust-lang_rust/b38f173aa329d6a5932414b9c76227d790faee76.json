{"sha": "b38f173aa329d6a5932414b9c76227d790faee76", "node_id": "C_kwDOAAsO6NoAKGIzOGYxNzNhYTMyOWQ2YTU5MzI0MTRiOWM3NjIyN2Q3OTBmYWVlNzY", "commit": {"author": {"name": "ThibsG", "email": "thibsg@pm.me", "date": "2021-08-18T14:51:34Z"}, "committer": {"name": "ThibsG", "email": "thibsg@pm.me", "date": "2021-11-20T08:40:10Z"}, "message": "Build suggestion within visitor + add more tests", "tree": {"sha": "b84621c0d2d8ec82b417e686bdb0cf22a1143488", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b84621c0d2d8ec82b417e686bdb0cf22a1143488"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b38f173aa329d6a5932414b9c76227d790faee76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b38f173aa329d6a5932414b9c76227d790faee76", "html_url": "https://github.com/rust-lang/rust/commit/b38f173aa329d6a5932414b9c76227d790faee76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b38f173aa329d6a5932414b9c76227d790faee76/comments", "author": {"login": "ThibsG", "id": 12683889, "node_id": "MDQ6VXNlcjEyNjgzODg5", "avatar_url": "https://avatars.githubusercontent.com/u/12683889?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ThibsG", "html_url": "https://github.com/ThibsG", "followers_url": "https://api.github.com/users/ThibsG/followers", "following_url": "https://api.github.com/users/ThibsG/following{/other_user}", "gists_url": "https://api.github.com/users/ThibsG/gists{/gist_id}", "starred_url": "https://api.github.com/users/ThibsG/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ThibsG/subscriptions", "organizations_url": "https://api.github.com/users/ThibsG/orgs", "repos_url": "https://api.github.com/users/ThibsG/repos", "events_url": "https://api.github.com/users/ThibsG/events{/privacy}", "received_events_url": "https://api.github.com/users/ThibsG/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ThibsG", "id": 12683889, "node_id": "MDQ6VXNlcjEyNjgzODg5", "avatar_url": "https://avatars.githubusercontent.com/u/12683889?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ThibsG", "html_url": "https://github.com/ThibsG", "followers_url": "https://api.github.com/users/ThibsG/followers", "following_url": "https://api.github.com/users/ThibsG/following{/other_user}", "gists_url": "https://api.github.com/users/ThibsG/gists{/gist_id}", "starred_url": "https://api.github.com/users/ThibsG/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ThibsG/subscriptions", "organizations_url": "https://api.github.com/users/ThibsG/orgs", "repos_url": "https://api.github.com/users/ThibsG/repos", "events_url": "https://api.github.com/users/ThibsG/events{/privacy}", "received_events_url": "https://api.github.com/users/ThibsG/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ed93af9c41e552c8d85390e2387d01eb9429174", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ed93af9c41e552c8d85390e2387d01eb9429174", "html_url": "https://github.com/rust-lang/rust/commit/5ed93af9c41e552c8d85390e2387d01eb9429174"}], "stats": {"total": 649, "additions": 355, "deletions": 294}, "files": [{"sha": "ee0e6d3a33f4a95e5baa792440218eb56a32862a", "filename": "clippy_lints/src/methods/search_is_some.rs", "status": "modified", "additions": 102, "deletions": 100, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/b38f173aa329d6a5932414b9c76227d790faee76/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38f173aa329d6a5932414b9c76227d790faee76/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs?ref=b38f173aa329d6a5932414b9c76227d790faee76", "patch": "@@ -1,17 +1,17 @@\n-use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n+use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg};\n use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{is_trait_method, strip_pat_refs};\n+use clippy_utils::{get_parent_expr_for_hir, is_trait_method, strip_pat_refs};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::{self, HirId, HirIdMap, HirIdSet, PatKind};\n+use rustc_hir::{self, Expr, ExprKind, HirId, PatKind};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n use rustc_middle::hir::place::ProjectionKind;\n-use rustc_middle::mir::FakeReadCause;\n+use rustc_middle::mir::{FakeReadCause, Mutability};\n use rustc_middle::ty;\n-use rustc_span::source_map::Span;\n+use rustc_span::source_map::{BytePos, Span};\n use rustc_span::symbol::sym;\n use rustc_typeck::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n \n@@ -46,42 +46,12 @@ pub(super) fn check<'tcx>(\n                 if let hir::ExprKind::Closure(_, _, body_id, ..) = search_arg.kind;\n                 let closure_body = cx.tcx.hir().body(body_id);\n                 if let Some(closure_arg) = closure_body.params.get(0);\n-\n                 then {\n                     if let hir::PatKind::Ref(..) = closure_arg.pat.kind {\n-                        Some((search_snippet.replacen('&', \"\", 1), None))\n+                        Some(search_snippet.replacen('&', \"\", 1))\n                     } else if let PatKind::Binding(..) = strip_pat_refs(closure_arg.pat).kind {\n-                        let mut visitor = DerefDelegate {\n-                            cx,\n-                            set: HirIdSet::default(),\n-                            deref_suggs: HirIdMap::default(),\n-                            borrow_suggs: HirIdMap::default()\n-                        };\n-\n-                        let fn_def_id = cx.tcx.hir().local_def_id(search_arg.hir_id);\n-                        cx.tcx.infer_ctxt().enter(|infcx| {\n-                            ExprUseVisitor::new(\n-                                &mut visitor, &infcx, fn_def_id, cx.param_env, cx.typeck_results()\n-                            ).consume_body(closure_body);\n-                        });\n-\n-                        let replacements = if visitor.set.is_empty() {\n-                            None\n-                        } else {\n-                            let mut deref_suggs = Vec::new();\n-                            let mut borrow_suggs = Vec::new();\n-                            for node in visitor.set {\n-                                let span = cx.tcx.hir().span(node);\n-                                if let Some(sugg) = visitor.deref_suggs.get(&node) {\n-                                    deref_suggs.push((span, sugg.clone()));\n-                                }\n-                                if let Some(sugg) = visitor.borrow_suggs.get(&node) {\n-                                    borrow_suggs.push((span, sugg.clone()));\n-                                }\n-                            }\n-                            Some((deref_suggs, borrow_suggs))\n-                        };\n-                        Some((search_snippet.to_string(), replacements))\n+                        get_closure_suggestion(cx, search_arg, closure_body)\n+                            .or_else(|| Some(search_snippet.to_string()))\n                     } else {\n                         None\n                     }\n@@ -90,38 +60,35 @@ pub(super) fn check<'tcx>(\n                 }\n             };\n             // add note if not multi-line\n-            let (closure_snippet, replacements) = any_search_snippet\n-                .as_ref()\n-                .map_or((&*search_snippet, None), |s| (&s.0, s.1.clone()));\n-            let (span, help, sugg) = if is_some {\n-                (\n+            if is_some {\n+                span_lint_and_sugg(\n+                    cx,\n+                    SEARCH_IS_SOME,\n                     method_span.with_hi(expr.span.hi()),\n+                    &msg,\n                     \"use `any()` instead\",\n-                    format!(\"any({})\", closure_snippet),\n-                )\n+                    format!(\n+                        \"any({})\",\n+                        any_search_snippet.as_ref().map_or(&*search_snippet, String::as_str)\n+                    ),\n+                    Applicability::MachineApplicable,\n+                );\n             } else {\n                 let iter = snippet(cx, search_recv.span, \"..\");\n-                (\n+                span_lint_and_sugg(\n+                    cx,\n+                    SEARCH_IS_SOME,\n                     expr.span,\n+                    &msg,\n                     \"use `!_.any()` instead\",\n-                    format!(\"!{}.any({})\", iter, closure_snippet),\n-                )\n-            };\n-\n-            span_lint_and_then(cx, SEARCH_IS_SOME, span, &msg, |db| {\n-                if let Some((deref_suggs, borrow_suggs)) = replacements {\n-                    db.span_suggestion(span, help, sugg, Applicability::MaybeIncorrect);\n-\n-                    if !deref_suggs.is_empty() {\n-                        db.multipart_suggestion(\"...and remove deref\", deref_suggs, Applicability::MaybeIncorrect);\n-                    }\n-                    if !borrow_suggs.is_empty() {\n-                        db.multipart_suggestion(\"...and borrow variable\", borrow_suggs, Applicability::MaybeIncorrect);\n-                    }\n-                } else {\n-                    db.span_suggestion(span, help, sugg, Applicability::MachineApplicable);\n-                }\n-            });\n+                    format!(\n+                        \"!{}.any({})\",\n+                        iter,\n+                        any_search_snippet.as_ref().map_or(&*search_snippet, String::as_str)\n+                    ),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n         } else {\n             let hint = format!(\n                 \"this is more succinctly expressed by calling `any()`{}\",\n@@ -184,53 +151,86 @@ pub(super) fn check<'tcx>(\n     }\n }\n \n+fn get_closure_suggestion<'tcx>(\n+    cx: &LateContext<'_>,\n+    search_arg: &'tcx hir::Expr<'_>,\n+    closure_body: &hir::Body<'_>,\n+) -> Option<String> {\n+    let mut visitor = DerefDelegate {\n+        cx,\n+        closure_span: search_arg.span,\n+        next_pos: None,\n+        suggestion_start: String::new(),\n+        suggestion_end: String::new(),\n+    };\n+\n+    let fn_def_id = cx.tcx.hir().local_def_id(search_arg.hir_id);\n+    cx.tcx.infer_ctxt().enter(|infcx| {\n+        ExprUseVisitor::new(&mut visitor, &infcx, fn_def_id, cx.param_env, cx.typeck_results())\n+            .consume_body(closure_body);\n+    });\n+\n+    if visitor.suggestion_start.is_empty() {\n+        None\n+    } else {\n+        Some(format!(\"{}{}\", visitor.suggestion_start, visitor.suggestion_end))\n+    }\n+}\n+\n struct DerefDelegate<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n-    set: HirIdSet,\n-    deref_suggs: HirIdMap<String>,\n-    borrow_suggs: HirIdMap<String>,\n+    closure_span: Span,\n+    next_pos: Option<BytePos>,\n+    suggestion_start: String,\n+    suggestion_end: String,\n }\n \n impl<'tcx> Delegate<'tcx> for DerefDelegate<'_, 'tcx> {\n-    fn consume(&mut self, cmt: &PlaceWithHirId<'tcx>, _: HirId) {\n+    fn consume(&mut self, _: &PlaceWithHirId<'tcx>, _: HirId) {}\n+\n+    fn borrow(&mut self, cmt: &PlaceWithHirId<'tcx>, _: HirId, _: ty::BorrowKind) {\n         if let PlaceBase::Local(id) = cmt.place.base {\n             let map = self.cx.tcx.hir();\n-            if cmt.place.projections.is_empty() {\n-                self.set.insert(cmt.hir_id);\n+            let ident_str = map.name(id).to_string();\n+            let span = map.span(cmt.hir_id);\n+            let start_span = if let Some(next_pos) = self.next_pos {\n+                Span::new(next_pos, span.lo(), span.ctxt())\n             } else {\n-                let mut replacement_str = map.name(id).to_string();\n-                let last_deref = cmt\n-                    .place\n-                    .projections\n-                    .iter()\n-                    .rposition(|proj| proj.kind == ProjectionKind::Deref);\n+                self.closure_span.until(span)\n+            };\n+            let start_snip = snippet(self.cx, start_span, \"..\");\n+            let end_span = Span::new(span.hi(), self.closure_span.hi(), span.ctxt());\n+            let end_snip = snippet(self.cx, end_span, \"..\");\n \n-                if let Some(pos) = last_deref {\n-                    let mut projections = cmt.place.projections.clone();\n-                    projections.truncate(pos);\n+            if cmt.place.projections.is_empty() {\n+                self.suggestion_start.push_str(&format!(\"{}&{}\", start_snip, ident_str));\n+            } else {\n+                let parent_expr = get_parent_expr_for_hir(self.cx, cmt.hir_id);\n+                if let Some(Expr { hir_id: _, kind, .. }) = parent_expr {\n+                    if let ExprKind::Call(_, args) | ExprKind::MethodCall(_, _, args, _) = kind {\n+                        let args_to_handle = args.iter().filter(|arg| arg.hir_id == cmt.hir_id).collect::<Vec<_>>();\n+                        if !args_to_handle.is_empty() {\n+                            for arg in &args_to_handle {\n+                                let arg_ty_kind = self.cx.typeck_results().expr_ty(arg).kind();\n+                                if matches!(arg_ty_kind, ty::Ref(_, _, Mutability::Not)) {\n+                                    let start_span = if let Some(next_pos) = self.next_pos {\n+                                        Span::new(next_pos, span.lo(), span.ctxt())\n+                                    } else {\n+                                        self.closure_span.until(span)\n+                                    };\n+                                    let start_snip = snippet(self.cx, start_span, \"..\");\n \n-                    for item in projections {\n-                        if item.kind == ProjectionKind::Deref {\n-                            replacement_str = format!(\"*{}\", replacement_str);\n+                                    self.suggestion_start.push_str(&format!(\"{}&{}\", start_snip, ident_str));\n+                                    self.suggestion_end = end_snip.to_string();\n+                                    self.next_pos = Some(span.hi());\n+                                }\n+                            }\n+                            return;\n                         }\n                     }\n-\n-                    self.set.insert(cmt.hir_id);\n-                    self.deref_suggs.insert(cmt.hir_id, replacement_str);\n                 }\n-            }\n-        }\n-    }\n \n-    fn borrow(&mut self, cmt: &PlaceWithHirId<'tcx>, _: HirId, _: ty::BorrowKind) {\n-        if let PlaceBase::Local(id) = cmt.place.base {\n-            let map = self.cx.tcx.hir();\n-            if cmt.place.projections.is_empty() {\n-                let replacement_str = format!(\"&{}\", map.name(id).to_string());\n-                self.set.insert(cmt.hir_id);\n-                self.borrow_suggs.insert(cmt.hir_id, replacement_str);\n-            } else {\n-                let mut replacement_str = map.name(id).to_string();\n+                let mut replacement_str = ident_str;\n                 let last_deref = cmt\n                     .place\n                     .projections\n@@ -246,11 +246,13 @@ impl<'tcx> Delegate<'tcx> for DerefDelegate<'_, 'tcx> {\n                             replacement_str = format!(\"*{}\", replacement_str);\n                         }\n                     }\n-\n-                    self.set.insert(cmt.hir_id);\n-                    self.deref_suggs.insert(cmt.hir_id, replacement_str);\n                 }\n+\n+                self.suggestion_start\n+                    .push_str(&format!(\"{}{}\", start_snip, replacement_str));\n+                self.suggestion_end = end_snip.to_string();\n             }\n+            self.next_pos = Some(span.hi());\n         }\n     }\n "}, {"sha": "72bc6ef35d317b02f9c5300affc0e6923fdd7790", "filename": "tests/ui/search_is_some.rs", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b38f173aa329d6a5932414b9c76227d790faee76/tests%2Fui%2Fsearch_is_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38f173aa329d6a5932414b9c76227d790faee76/tests%2Fui%2Fsearch_is_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some.rs?ref=b38f173aa329d6a5932414b9c76227d790faee76", "patch": "@@ -36,11 +36,6 @@ fn main() {\n     // check that we don't lint if `find()` is called with\n     // `Pattern` that is not a string\n     let _ = \"hello world\".find(|c: char| c == 'o' || c == 'l').is_some();\n-\n-    // Check `find().is_some()`, single-line case.\n-    let _ = (0..1).find(|x| **y == *x).is_some(); // one dereference less\n-    let _ = (0..1).find(|x| *x == 0).is_some();\n-    let _ = v.iter().find(|x| **x == 0).is_some();\n }\n \n #[rustfmt::skip]\n@@ -75,44 +70,4 @@ fn is_none() {\n     // check that we don't lint if `find()` is called with\n     // `Pattern` that is not a string\n     let _ = \"hello world\".find(|c: char| c == 'o' || c == 'l').is_none();\n-\n-    // Check `find().is_none()`, single-line case.\n-    let _ = (0..1).find(|x| **y == *x).is_none(); // one dereference less\n-    let _ = (0..1).find(|x| *x == 0).is_none();\n-    let _ = v.iter().find(|x| **x == 0).is_none();\n-}\n-\n-#[allow(clippy::clone_on_copy, clippy::map_clone)]\n-mod issue7392 {\n-    struct Player {\n-        hand: Vec<usize>,\n-    }\n-    fn filter() {\n-        let p = Player {\n-            hand: vec![1, 2, 3, 4, 5],\n-        };\n-        let filter_hand = vec![5];\n-        let _ = p\n-            .hand\n-            .iter()\n-            .filter(|c| filter_hand.iter().find(|cc| c == cc).is_none())\n-            .map(|c| c.clone())\n-            .collect::<Vec<_>>();\n-    }\n-\n-    struct PlayerTuple {\n-        hand: Vec<(usize, char)>,\n-    }\n-    fn filter_tuple() {\n-        let p = PlayerTuple {\n-            hand: vec![(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd'), (5, 'e')],\n-        };\n-        let filter_hand = vec![5];\n-        let _ = p\n-            .hand\n-            .iter()\n-            .filter(|(c, _)| filter_hand.iter().find(|cc| c == *cc).is_none())\n-            .map(|c| c.clone())\n-            .collect::<Vec<_>>();\n-    }\n }"}, {"sha": "f3c758e451ef1436047b24be7d696156b4c075fb", "filename": "tests/ui/search_is_some.stderr", "status": "modified", "additions": 4, "deletions": 124, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/b38f173aa329d6a5932414b9c76227d790faee76/tests%2Fui%2Fsearch_is_some.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b38f173aa329d6a5932414b9c76227d790faee76/tests%2Fui%2Fsearch_is_some.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some.stderr?ref=b38f173aa329d6a5932414b9c76227d790faee76", "patch": "@@ -35,53 +35,8 @@ LL | |                    ).is_some();\n    |\n    = help: this is more succinctly expressed by calling `any()`\n \n-error: called `is_some()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some.rs:41:20\n-   |\n-LL |     let _ = (0..1).find(|x| **y == *x).is_some(); // one dereference less\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: use `any()` instead\n-   |\n-LL |     let _ = (0..1).any(|x| **y == *x); // one dereference less\n-   |                    ^^^^^^^^^^^^^^^^^^\n-help: ...and remove deref\n-   |\n-LL |     let _ = (0..1).find(|x| **y == x).is_some(); // one dereference less\n-   |                                    ^\n-\n-error: called `is_some()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some.rs:42:20\n-   |\n-LL |     let _ = (0..1).find(|x| *x == 0).is_some();\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: use `any()` instead\n-   |\n-LL |     let _ = (0..1).any(|x| *x == 0);\n-   |                    ^^^^^^^^^^^^^^^^\n-help: ...and remove deref\n-   |\n-LL |     let _ = (0..1).find(|x| x == 0).is_some();\n-   |                             ^\n-\n-error: called `is_some()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some.rs:43:22\n-   |\n-LL |     let _ = v.iter().find(|x| **x == 0).is_some();\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: use `any()` instead\n-   |\n-LL |     let _ = v.iter().any(|x| **x == 0);\n-   |                      ^^^^^^^^^^^^^^^^^\n-help: ...and remove deref\n-   |\n-LL |     let _ = v.iter().find(|x| *x == 0).is_some();\n-   |                               ^^\n-\n error: called `is_none()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some.rs:53:13\n+  --> $DIR/search_is_some.rs:48:13\n    |\n LL |       let _ = v.iter().find(|&x| {\n    |  _____________^\n@@ -93,7 +48,7 @@ LL | |                    ).is_none();\n    = help: this is more succinctly expressed by calling `any()` with negation\n \n error: called `is_none()` after searching an `Iterator` with `position`\n-  --> $DIR/search_is_some.rs:59:13\n+  --> $DIR/search_is_some.rs:54:13\n    |\n LL |       let _ = v.iter().position(|&x| {\n    |  _____________^\n@@ -105,7 +60,7 @@ LL | |                    ).is_none();\n    = help: this is more succinctly expressed by calling `any()` with negation\n \n error: called `is_none()` after searching an `Iterator` with `rposition`\n-  --> $DIR/search_is_some.rs:65:13\n+  --> $DIR/search_is_some.rs:60:13\n    |\n LL |       let _ = v.iter().rposition(|&x| {\n    |  _____________^\n@@ -116,80 +71,5 @@ LL | |                    ).is_none();\n    |\n    = help: this is more succinctly expressed by calling `any()` with negation\n \n-error: called `is_none()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some.rs:80:13\n-   |\n-LL |     let _ = (0..1).find(|x| **y == *x).is_none(); // one dereference less\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: use `!_.any()` instead\n-   |\n-LL |     let _ = !(0..1).any(|x| **y == *x); // one dereference less\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-help: ...and remove deref\n-   |\n-LL |     let _ = (0..1).find(|x| **y == x).is_none(); // one dereference less\n-   |                                    ^\n-\n-error: called `is_none()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some.rs:81:13\n-   |\n-LL |     let _ = (0..1).find(|x| *x == 0).is_none();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: use `!_.any()` instead\n-   |\n-LL |     let _ = !(0..1).any(|x| *x == 0);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^\n-help: ...and remove deref\n-   |\n-LL |     let _ = (0..1).find(|x| x == 0).is_none();\n-   |                             ^\n-\n-error: called `is_none()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some.rs:82:13\n-   |\n-LL |     let _ = v.iter().find(|x| **x == 0).is_none();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: use `!_.any()` instead\n-   |\n-LL |     let _ = !v.iter().any(|x| **x == 0);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-help: ...and remove deref\n-   |\n-LL |     let _ = v.iter().find(|x| *x == 0).is_none();\n-   |                               ^^\n-\n-error: called `is_none()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some.rs:98:25\n-   |\n-LL |             .filter(|c| filter_hand.iter().find(|cc| c == cc).is_none())\n-   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: use `!_.any()` instead\n-   |\n-LL |             .filter(|c| !filter_hand.iter().any(|cc| c == cc))\n-   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-help: ...and borrow variable\n-   |\n-LL |             .filter(|c| filter_hand.iter().find(|cc| c == &cc).is_none())\n-   |                                                           ^^^\n-\n-error: called `is_none()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some.rs:114:30\n-   |\n-LL |             .filter(|(c, _)| filter_hand.iter().find(|cc| c == *cc).is_none())\n-   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: use `!_.any()` instead\n-   |\n-LL |             .filter(|(c, _)| !filter_hand.iter().any(|cc| c == *cc))\n-   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-help: ...and remove deref\n-   |\n-LL |             .filter(|(c, _)| filter_hand.iter().find(|cc| c == cc).is_none())\n-   |                                                                ^^\n-\n-error: aborting due to 14 previous errors\n+error: aborting due to 6 previous errors\n "}, {"sha": "967b3d1be432cde583865b8ffd921d47c8d285d7", "filename": "tests/ui/search_is_some_fixable.fixed", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b38f173aa329d6a5932414b9c76227d790faee76/tests%2Fui%2Fsearch_is_some_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/b38f173aa329d6a5932414b9c76227d790faee76/tests%2Fui%2Fsearch_is_some_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some_fixable.fixed?ref=b38f173aa329d6a5932414b9c76227d790faee76", "patch": "@@ -4,9 +4,19 @@\n \n fn main() {\n     let v = vec![3, 2, 1, 0, -1, -2, -3];\n+    let y = &&42;\n \n     // Check `find().is_some()`, single-line case.\n     let _ = v.iter().any(|x| *x < 0);\n+    let _ = (0..1).any(|x| **y == x); // one dereference less\n+    let _ = (0..1).any(|x| x == 0);\n+    let _ = v.iter().any(|x| *x == 0);\n+    let _ = (4..5).any(|x| x == 1 || x == 3 || x == 5);\n+    let _ = (1..3).any(|x| [1, 2, 3].contains(&x));\n+    let _ = (1..3).any(|x| x == 0 || [1, 2, 3].contains(&x));\n+    let _ = (1..3).any(|x| [1, 2, 3].contains(&x) || x == 0);\n+    let _ = (1..3)\n+        .any(|x| [1, 2, 3].contains(&x) || x == 0 || [4, 5, 6].contains(&x) || x == -1);\n \n     // Check `position().is_some()`, single-line case.\n     let _ = v.iter().any(|&x| x < 0);\n@@ -32,9 +42,18 @@ fn main() {\n \n fn is_none() {\n     let v = vec![3, 2, 1, 0, -1, -2, -3];\n+    let y = &&42;\n \n     // Check `find().is_none()`, single-line case.\n     let _ = !v.iter().any(|x| *x < 0);\n+    let _ = !(0..1).any(|x| **y == x); // one dereference less\n+    let _ = !(0..1).any(|x| x == 0);\n+    let _ = !v.iter().any(|x| *x == 0);\n+    let _ = !(4..5).any(|x| x == 1 || x == 3 || x == 5);\n+    let _ = !(1..3).any(|x| [1, 2, 3].contains(&x));\n+    let _ = !(1..3).any(|x| x == 0 || [1, 2, 3].contains(&x));\n+    let _ = !(1..3).any(|x| [1, 2, 3].contains(&x) || x == 0);\n+    let _ = !(1..3).any(|x| [1, 2, 3].contains(&x) || x == 0 || [4, 5, 6].contains(&x) || x == -1);\n \n     // Check `position().is_none()`, single-line case.\n     let _ = !v.iter().any(|&x| x < 0);\n@@ -58,3 +77,38 @@ fn is_none() {\n     let _ = !s1[2..].contains(&s2);\n     let _ = !s1[2..].contains(&s2[2..]);\n }\n+\n+#[allow(clippy::clone_on_copy, clippy::map_clone)]\n+mod issue7392 {\n+    struct Player {\n+        hand: Vec<usize>,\n+    }\n+    fn filter() {\n+        let p = Player {\n+            hand: vec![1, 2, 3, 4, 5],\n+        };\n+        let filter_hand = vec![5];\n+        let _ = p\n+            .hand\n+            .iter()\n+            .filter(|c| !filter_hand.iter().any(|cc| c == &cc))\n+            .map(|c| c.clone())\n+            .collect::<Vec<_>>();\n+    }\n+\n+    struct PlayerTuple {\n+        hand: Vec<(usize, char)>,\n+    }\n+    fn filter_tuple() {\n+        let p = PlayerTuple {\n+            hand: vec![(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd'), (5, 'e')],\n+        };\n+        let filter_hand = vec![5];\n+        let _ = p\n+            .hand\n+            .iter()\n+            .filter(|(c, _)| !filter_hand.iter().any(|cc| c == cc))\n+            .map(|c| c.clone())\n+            .collect::<Vec<_>>();\n+    }\n+}"}, {"sha": "e642523a53203aad09d9ac3395c0c4f193cab45c", "filename": "tests/ui/search_is_some_fixable.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/b38f173aa329d6a5932414b9c76227d790faee76/tests%2Fui%2Fsearch_is_some_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38f173aa329d6a5932414b9c76227d790faee76/tests%2Fui%2Fsearch_is_some_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some_fixable.rs?ref=b38f173aa329d6a5932414b9c76227d790faee76", "patch": "@@ -4,9 +4,20 @@\n \n fn main() {\n     let v = vec![3, 2, 1, 0, -1, -2, -3];\n+    let y = &&42;\n \n     // Check `find().is_some()`, single-line case.\n     let _ = v.iter().find(|&x| *x < 0).is_some();\n+    let _ = (0..1).find(|x| **y == *x).is_some(); // one dereference less\n+    let _ = (0..1).find(|x| *x == 0).is_some();\n+    let _ = v.iter().find(|x| **x == 0).is_some();\n+    let _ = (4..5).find(|x| *x == 1 || *x == 3 || *x == 5).is_some();\n+    let _ = (1..3).find(|x| [1, 2, 3].contains(x)).is_some();\n+    let _ = (1..3).find(|x| *x == 0 || [1, 2, 3].contains(x)).is_some();\n+    let _ = (1..3).find(|x| [1, 2, 3].contains(x) || *x == 0).is_some();\n+    let _ = (1..3)\n+        .find(|x| [1, 2, 3].contains(x) || *x == 0 || [4, 5, 6].contains(x) || *x == -1)\n+        .is_some();\n \n     // Check `position().is_some()`, single-line case.\n     let _ = v.iter().position(|&x| x < 0).is_some();\n@@ -32,9 +43,20 @@ fn main() {\n \n fn is_none() {\n     let v = vec![3, 2, 1, 0, -1, -2, -3];\n+    let y = &&42;\n \n     // Check `find().is_none()`, single-line case.\n     let _ = v.iter().find(|&x| *x < 0).is_none();\n+    let _ = (0..1).find(|x| **y == *x).is_none(); // one dereference less\n+    let _ = (0..1).find(|x| *x == 0).is_none();\n+    let _ = v.iter().find(|x| **x == 0).is_none();\n+    let _ = (4..5).find(|x| *x == 1 || *x == 3 || *x == 5).is_none();\n+    let _ = (1..3).find(|x| [1, 2, 3].contains(x)).is_none();\n+    let _ = (1..3).find(|x| *x == 0 || [1, 2, 3].contains(x)).is_none();\n+    let _ = (1..3).find(|x| [1, 2, 3].contains(x) || *x == 0).is_none();\n+    let _ = (1..3)\n+        .find(|x| [1, 2, 3].contains(x) || *x == 0 || [4, 5, 6].contains(x) || *x == -1)\n+        .is_none();\n \n     // Check `position().is_none()`, single-line case.\n     let _ = v.iter().position(|&x| x < 0).is_none();\n@@ -58,3 +80,38 @@ fn is_none() {\n     let _ = s1[2..].find(&s2).is_none();\n     let _ = s1[2..].find(&s2[2..]).is_none();\n }\n+\n+#[allow(clippy::clone_on_copy, clippy::map_clone)]\n+mod issue7392 {\n+    struct Player {\n+        hand: Vec<usize>,\n+    }\n+    fn filter() {\n+        let p = Player {\n+            hand: vec![1, 2, 3, 4, 5],\n+        };\n+        let filter_hand = vec![5];\n+        let _ = p\n+            .hand\n+            .iter()\n+            .filter(|c| filter_hand.iter().find(|cc| c == cc).is_none())\n+            .map(|c| c.clone())\n+            .collect::<Vec<_>>();\n+    }\n+\n+    struct PlayerTuple {\n+        hand: Vec<(usize, char)>,\n+    }\n+    fn filter_tuple() {\n+        let p = PlayerTuple {\n+            hand: vec![(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd'), (5, 'e')],\n+        };\n+        let filter_hand = vec![5];\n+        let _ = p\n+            .hand\n+            .iter()\n+            .filter(|(c, _)| filter_hand.iter().find(|cc| c == *cc).is_none())\n+            .map(|c| c.clone())\n+            .collect::<Vec<_>>();\n+    }\n+}"}, {"sha": "3bb8cc573ec57438839f628a1865a50f62e044c7", "filename": "tests/ui/search_is_some_fixable.stderr", "status": "modified", "additions": 138, "deletions": 25, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/b38f173aa329d6a5932414b9c76227d790faee76/tests%2Fui%2Fsearch_is_some_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b38f173aa329d6a5932414b9c76227d790faee76/tests%2Fui%2Fsearch_is_some_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some_fixable.stderr?ref=b38f173aa329d6a5932414b9c76227d790faee76", "patch": "@@ -1,148 +1,261 @@\n error: called `is_some()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some_fixable.rs:9:22\n+  --> $DIR/search_is_some_fixable.rs:10:22\n    |\n LL |     let _ = v.iter().find(|&x| *x < 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|x| *x < 0)`\n    |\n    = note: `-D clippy::search-is-some` implied by `-D warnings`\n \n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable.rs:11:20\n+   |\n+LL |     let _ = (0..1).find(|x| **y == *x).is_some(); // one dereference less\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|x| **y == x)`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable.rs:12:20\n+   |\n+LL |     let _ = (0..1).find(|x| *x == 0).is_some();\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|x| x == 0)`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable.rs:13:22\n+   |\n+LL |     let _ = v.iter().find(|x| **x == 0).is_some();\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|x| *x == 0)`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable.rs:14:20\n+   |\n+LL |     let _ = (4..5).find(|x| *x == 1 || *x == 3 || *x == 5).is_some();\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|x| x == 1 || x == 3 || x == 5)`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable.rs:15:20\n+   |\n+LL |     let _ = (1..3).find(|x| [1, 2, 3].contains(x)).is_some();\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|x| [1, 2, 3].contains(&x))`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable.rs:16:20\n+   |\n+LL |     let _ = (1..3).find(|x| *x == 0 || [1, 2, 3].contains(x)).is_some();\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|x| x == 0 || [1, 2, 3].contains(&x))`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable.rs:17:20\n+   |\n+LL |     let _ = (1..3).find(|x| [1, 2, 3].contains(x) || *x == 0).is_some();\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|x| [1, 2, 3].contains(&x) || x == 0)`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable.rs:19:10\n+   |\n+LL |           .find(|x| [1, 2, 3].contains(x) || *x == 0 || [4, 5, 6].contains(x) || *x == -1)\n+   |  __________^\n+LL | |         .is_some();\n+   | |__________________^ help: use `any()` instead: `any(|x| [1, 2, 3].contains(&x) || x == 0 || [4, 5, 6].contains(&x) || x == -1)`\n+\n error: called `is_some()` after searching an `Iterator` with `position`\n-  --> $DIR/search_is_some_fixable.rs:12:22\n+  --> $DIR/search_is_some_fixable.rs:23:22\n    |\n LL |     let _ = v.iter().position(|&x| x < 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with `rposition`\n-  --> $DIR/search_is_some_fixable.rs:15:22\n+  --> $DIR/search_is_some_fixable.rs:26:22\n    |\n LL |     let _ = v.iter().rposition(|&x| x < 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|&x| x < 0)`\n \n error: called `is_some()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:20:27\n+  --> $DIR/search_is_some_fixable.rs:31:27\n    |\n LL |     let _ = \"hello world\".find(\"world\").is_some();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^ help: use `contains()` instead: `contains(\"world\")`\n \n error: called `is_some()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:21:27\n+  --> $DIR/search_is_some_fixable.rs:32:27\n    |\n LL |     let _ = \"hello world\".find(&s2).is_some();\n    |                           ^^^^^^^^^^^^^^^^^^^ help: use `contains()` instead: `contains(&s2)`\n \n error: called `is_some()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:22:27\n+  --> $DIR/search_is_some_fixable.rs:33:27\n    |\n LL |     let _ = \"hello world\".find(&s2[2..]).is_some();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^ help: use `contains()` instead: `contains(&s2[2..])`\n \n error: called `is_some()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:24:16\n+  --> $DIR/search_is_some_fixable.rs:35:16\n    |\n LL |     let _ = s1.find(\"world\").is_some();\n    |                ^^^^^^^^^^^^^^^^^^^^^^^ help: use `contains()` instead: `contains(\"world\")`\n \n error: called `is_some()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:25:16\n+  --> $DIR/search_is_some_fixable.rs:36:16\n    |\n LL |     let _ = s1.find(&s2).is_some();\n    |                ^^^^^^^^^^^^^^^^^^^ help: use `contains()` instead: `contains(&s2)`\n \n error: called `is_some()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:26:16\n+  --> $DIR/search_is_some_fixable.rs:37:16\n    |\n LL |     let _ = s1.find(&s2[2..]).is_some();\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^ help: use `contains()` instead: `contains(&s2[2..])`\n \n error: called `is_some()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:28:21\n+  --> $DIR/search_is_some_fixable.rs:39:21\n    |\n LL |     let _ = s1[2..].find(\"world\").is_some();\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^ help: use `contains()` instead: `contains(\"world\")`\n \n error: called `is_some()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:29:21\n+  --> $DIR/search_is_some_fixable.rs:40:21\n    |\n LL |     let _ = s1[2..].find(&s2).is_some();\n    |                     ^^^^^^^^^^^^^^^^^^^ help: use `contains()` instead: `contains(&s2)`\n \n error: called `is_some()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:30:21\n+  --> $DIR/search_is_some_fixable.rs:41:21\n    |\n LL |     let _ = s1[2..].find(&s2[2..]).is_some();\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: use `contains()` instead: `contains(&s2[2..])`\n \n error: called `is_none()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some_fixable.rs:37:13\n+  --> $DIR/search_is_some_fixable.rs:49:13\n    |\n LL |     let _ = v.iter().find(|&x| *x < 0).is_none();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!v.iter().any(|x| *x < 0)`\n \n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable.rs:50:13\n+   |\n+LL |     let _ = (0..1).find(|x| **y == *x).is_none(); // one dereference less\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!(0..1).any(|x| **y == x)`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable.rs:51:13\n+   |\n+LL |     let _ = (0..1).find(|x| *x == 0).is_none();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!(0..1).any(|x| x == 0)`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable.rs:52:13\n+   |\n+LL |     let _ = v.iter().find(|x| **x == 0).is_none();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!v.iter().any(|x| *x == 0)`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable.rs:53:13\n+   |\n+LL |     let _ = (4..5).find(|x| *x == 1 || *x == 3 || *x == 5).is_none();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!(4..5).any(|x| x == 1 || x == 3 || x == 5)`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable.rs:54:13\n+   |\n+LL |     let _ = (1..3).find(|x| [1, 2, 3].contains(x)).is_none();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!(1..3).any(|x| [1, 2, 3].contains(&x))`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable.rs:55:13\n+   |\n+LL |     let _ = (1..3).find(|x| *x == 0 || [1, 2, 3].contains(x)).is_none();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!(1..3).any(|x| x == 0 || [1, 2, 3].contains(&x))`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable.rs:56:13\n+   |\n+LL |     let _ = (1..3).find(|x| [1, 2, 3].contains(x) || *x == 0).is_none();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!(1..3).any(|x| [1, 2, 3].contains(&x) || x == 0)`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable.rs:57:13\n+   |\n+LL |       let _ = (1..3)\n+   |  _____________^\n+LL | |         .find(|x| [1, 2, 3].contains(x) || *x == 0 || [4, 5, 6].contains(x) || *x == -1)\n+LL | |         .is_none();\n+   | |__________________^ help: use `!_.any()` instead: `!(1..3).any(|x| [1, 2, 3].contains(&x) || x == 0 || [4, 5, 6].contains(&x) || x == -1)`\n+\n error: called `is_none()` after searching an `Iterator` with `position`\n-  --> $DIR/search_is_some_fixable.rs:40:13\n+  --> $DIR/search_is_some_fixable.rs:62:13\n    |\n LL |     let _ = v.iter().position(|&x| x < 0).is_none();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!v.iter().any(|&x| x < 0)`\n \n error: called `is_none()` after searching an `Iterator` with `rposition`\n-  --> $DIR/search_is_some_fixable.rs:43:13\n+  --> $DIR/search_is_some_fixable.rs:65:13\n    |\n LL |     let _ = v.iter().rposition(|&x| x < 0).is_none();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!v.iter().any(|&x| x < 0)`\n \n error: called `is_none()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:49:13\n+  --> $DIR/search_is_some_fixable.rs:71:13\n    |\n LL |     let _ = \"hello world\".find(\"world\").is_none();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.contains()` instead: `!\"hello world\".contains(\"world\")`\n \n error: called `is_none()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:50:13\n+  --> $DIR/search_is_some_fixable.rs:72:13\n    |\n LL |     let _ = \"hello world\".find(&s2).is_none();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.contains()` instead: `!\"hello world\".contains(&s2)`\n \n error: called `is_none()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:51:13\n+  --> $DIR/search_is_some_fixable.rs:73:13\n    |\n LL |     let _ = \"hello world\".find(&s2[2..]).is_none();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.contains()` instead: `!\"hello world\".contains(&s2[2..])`\n \n error: called `is_none()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:53:13\n+  --> $DIR/search_is_some_fixable.rs:75:13\n    |\n LL |     let _ = s1.find(\"world\").is_none();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.contains()` instead: `!s1.contains(\"world\")`\n \n error: called `is_none()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:54:13\n+  --> $DIR/search_is_some_fixable.rs:76:13\n    |\n LL |     let _ = s1.find(&s2).is_none();\n    |             ^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.contains()` instead: `!s1.contains(&s2)`\n \n error: called `is_none()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:55:13\n+  --> $DIR/search_is_some_fixable.rs:77:13\n    |\n LL |     let _ = s1.find(&s2[2..]).is_none();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.contains()` instead: `!s1.contains(&s2[2..])`\n \n error: called `is_none()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:57:13\n+  --> $DIR/search_is_some_fixable.rs:79:13\n    |\n LL |     let _ = s1[2..].find(\"world\").is_none();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.contains()` instead: `!s1[2..].contains(\"world\")`\n \n error: called `is_none()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:58:13\n+  --> $DIR/search_is_some_fixable.rs:80:13\n    |\n LL |     let _ = s1[2..].find(&s2).is_none();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.contains()` instead: `!s1[2..].contains(&s2)`\n \n error: called `is_none()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:59:13\n+  --> $DIR/search_is_some_fixable.rs:81:13\n    |\n LL |     let _ = s1[2..].find(&s2[2..]).is_none();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.contains()` instead: `!s1[2..].contains(&s2[2..])`\n \n-error: aborting due to 24 previous errors\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable.rs:97:25\n+   |\n+LL |             .filter(|c| filter_hand.iter().find(|cc| c == cc).is_none())\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!filter_hand.iter().any(|cc| c == &cc)`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable.rs:113:30\n+   |\n+LL |             .filter(|(c, _)| filter_hand.iter().find(|cc| c == *cc).is_none())\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!filter_hand.iter().any(|cc| c == cc)`\n+\n+error: aborting due to 42 previous errors\n "}]}