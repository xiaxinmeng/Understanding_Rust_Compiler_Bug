{"sha": "7adc48527fa0505a0cda6eaf1b6cafb01e434170", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhZGM0ODUyN2ZhMDUwNWEwY2RhNmVhZjFiNmNhZmIwMWU0MzQxNzA=", "commit": {"author": {"name": "Edward Wang", "email": "edward.yu.wang@gmail.com", "date": "2014-05-04T14:08:45Z"}, "committer": {"name": "Edward Wang", "email": "edward.yu.wang@gmail.com", "date": "2014-05-05T12:16:18Z"}, "message": "Reverse #13034\n\nIt has been found that #13034 was flawed and caused regression #13867.\nThis patch reveres the changes made by it except the companion tests.", "tree": {"sha": "76809eb2868479195e41c835057570f04cddfad2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76809eb2868479195e41c835057570f04cddfad2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7adc48527fa0505a0cda6eaf1b6cafb01e434170", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7adc48527fa0505a0cda6eaf1b6cafb01e434170", "html_url": "https://github.com/rust-lang/rust/commit/7adc48527fa0505a0cda6eaf1b6cafb01e434170", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7adc48527fa0505a0cda6eaf1b6cafb01e434170/comments", "author": {"login": "edwardw", "id": 454049, "node_id": "MDQ6VXNlcjQ1NDA0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/454049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwardw", "html_url": "https://github.com/edwardw", "followers_url": "https://api.github.com/users/edwardw/followers", "following_url": "https://api.github.com/users/edwardw/following{/other_user}", "gists_url": "https://api.github.com/users/edwardw/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwardw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwardw/subscriptions", "organizations_url": "https://api.github.com/users/edwardw/orgs", "repos_url": "https://api.github.com/users/edwardw/repos", "events_url": "https://api.github.com/users/edwardw/events{/privacy}", "received_events_url": "https://api.github.com/users/edwardw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwardw", "id": 454049, "node_id": "MDQ6VXNlcjQ1NDA0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/454049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwardw", "html_url": "https://github.com/edwardw", "followers_url": "https://api.github.com/users/edwardw/followers", "following_url": "https://api.github.com/users/edwardw/following{/other_user}", "gists_url": "https://api.github.com/users/edwardw/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwardw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwardw/subscriptions", "organizations_url": "https://api.github.com/users/edwardw/orgs", "repos_url": "https://api.github.com/users/edwardw/repos", "events_url": "https://api.github.com/users/edwardw/events{/privacy}", "received_events_url": "https://api.github.com/users/edwardw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8895f252417495b423796807ba180eb59da5a1c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/8895f252417495b423796807ba180eb59da5a1c1", "html_url": "https://github.com/rust-lang/rust/commit/8895f252417495b423796807ba180eb59da5a1c1"}], "stats": {"total": 74, "additions": 8, "deletions": 66}, "files": [{"sha": "1b61e2bfb08af8d42449dd5b5ec6e97caf6f4a4c", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 8, "deletions": 66, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/7adc48527fa0505a0cda6eaf1b6cafb01e434170/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7adc48527fa0505a0cda6eaf1b6cafb01e434170/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=7adc48527fa0505a0cda6eaf1b6cafb01e434170", "patch": "@@ -289,42 +289,6 @@ fn opt_eq(tcx: &ty::ctxt, a: &Opt, b: &Opt) -> bool {\n     }\n }\n \n-fn opt_overlap(tcx: &ty::ctxt, a: &Opt, b: &Opt) -> bool {\n-    match (a, b) {\n-        (&lit(a), &lit(b)) => {\n-            let a_expr = lit_to_expr(tcx, &a);\n-            let b_expr = lit_to_expr(tcx, &b);\n-            match const_eval::compare_lit_exprs(tcx, a_expr, b_expr) {\n-                Some(val1) => val1 == 0,\n-                None => fail!(\"opt_overlap: type mismatch\"),\n-            }\n-        }\n-\n-        (&range(a1, a2), &range(b1, b2)) => {\n-            let m1 = const_eval::compare_lit_exprs(tcx, a1, b2);\n-            let m2 = const_eval::compare_lit_exprs(tcx, b1, a2);\n-            match (m1, m2) {\n-                // two ranges [a1, a2] and [b1, b2] overlap iff:\n-                //      a1 <= b2 && b1 <= a2\n-                (Some(val1), Some(val2)) => (val1 <= 0 && val2 <= 0),\n-                _ => fail!(\"opt_overlap: type mismatch\"),\n-            }\n-        }\n-\n-        (&range(a1, a2), &lit(b)) | (&lit(b), &range(a1, a2)) => {\n-            let b_expr = lit_to_expr(tcx, &b);\n-            let m1 = const_eval::compare_lit_exprs(tcx, a1, b_expr);\n-            let m2 = const_eval::compare_lit_exprs(tcx, a2, b_expr);\n-            match (m1, m2) {\n-                // b is in range [a1, a2] iff a1 <= b and b <= a2\n-                (Some(val1), Some(val2)) => (val1 <= 0 && 0 <= val2),\n-                _ => fail!(\"opt_overlap: type mismatch\"),\n-            }\n-        }\n-        _ => fail!(\"opt_overlap: expect lit or range\")\n-    }\n-}\n-\n pub enum opt_result<'a> {\n     single_result(Result<'a>),\n     lower_bound(Result<'a>),\n@@ -634,30 +598,16 @@ fn enter_opt<'a, 'b>(\n     let tcx = bcx.tcx();\n     let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n     let mut i = 0;\n-    // By the virtue of fact that we are in `trans` already, `enter_opt` is able\n-    // to prune sub-match tree aggressively based on exact equality. But when it\n-    // comes to literal or range, that strategy may lead to wrong result if there\n-    // are guard function or multiple patterns inside tuple; in that case, pruning\n-    // based on the overlap of patterns is required.\n-    //\n-    // Ideally, when constructing the sub-match tree for certain arm, only those\n-    // arms beneath it matter. But that isn't how algorithm works right now and\n-    // all other arms are taken into consideration when computing `guarded` below.\n-    // That is ok since each round of `compile_submatch` guarantees to trim one\n-    // \"column\" of arm patterns and the algorithm will converge.\n-    let guarded = m.iter().any(|x| x.data.arm.guard.is_some());\n-    let multi_pats = m.len() > 0 && m[0].pats.len() > 1;\n     enter_match(bcx, &tcx.def_map, m, col, val, |p| {\n         let answer = match p.node {\n             ast::PatEnum(..) |\n             ast::PatIdent(_, _, None) if pat_is_const(&tcx.def_map, p) => {\n                 let const_def = tcx.def_map.borrow().get_copy(&p.id);\n                 let const_def_id = ast_util::def_id_of_def(const_def);\n-                let konst = lit(ConstLit(const_def_id));\n-                match guarded || multi_pats {\n-                    false if opt_eq(tcx, &konst, opt) => Some(Vec::new()),\n-                    true if opt_overlap(tcx, &konst, opt) => Some(Vec::new()),\n-                    _ => None,\n+                if opt_eq(tcx, &lit(ConstLit(const_def_id)), opt) {\n+                    Some(Vec::new())\n+                } else {\n+                    None\n                 }\n             }\n             ast::PatEnum(_, ref subpats) => {\n@@ -682,20 +632,12 @@ fn enter_opt<'a, 'b>(\n                 }\n             }\n             ast::PatLit(l) => {\n-                let lit_expr = lit(ExprLit(l));\n-                match guarded || multi_pats {\n-                    false if opt_eq(tcx, &lit_expr, opt) => Some(Vec::new()),\n-                    true if opt_overlap(tcx, &lit_expr, opt) => Some(Vec::new()),\n-                    _ => None,\n-                }\n+                if opt_eq(tcx, &lit(ExprLit(l)), opt) { Some(Vec::new()) }\n+                else { None }\n             }\n             ast::PatRange(l1, l2) => {\n-                let rng = range(l1, l2);\n-                match guarded || multi_pats {\n-                    false if opt_eq(tcx, &rng, opt) => Some(Vec::new()),\n-                    true if opt_overlap(tcx, &rng, opt) => Some(Vec::new()),\n-                    _ => None,\n-                }\n+                if opt_eq(tcx, &range(l1, l2), opt) { Some(Vec::new()) }\n+                else { None }\n             }\n             ast::PatStruct(_, ref field_pats, _) => {\n                 if opt_eq(tcx, &variant_opt(bcx, p.id), opt) {"}]}