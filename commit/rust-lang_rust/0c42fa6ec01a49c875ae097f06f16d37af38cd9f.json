{"sha": "0c42fa6ec01a49c875ae097f06f16d37af38cd9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjNDJmYTZlYzAxYTQ5Yzg3NWFlMDk3ZjA2ZjE2ZDM3YWYzOGNkOWY=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2016-06-07T14:43:56Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2016-06-07T14:43:56Z"}, "message": "Rollup merge of #33945 - srinivasreddy:libpanic_unwind, r=nrc\n\nrun rustfmt on libpanic_unwind folder", "tree": {"sha": "033c3b92e82a64da6f3f6b51828c7e85bfffa6ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/033c3b92e82a64da6f3f6b51828c7e85bfffa6ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c42fa6ec01a49c875ae097f06f16d37af38cd9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c42fa6ec01a49c875ae097f06f16d37af38cd9f", "html_url": "https://github.com/rust-lang/rust/commit/0c42fa6ec01a49c875ae097f06f16d37af38cd9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c42fa6ec01a49c875ae097f06f16d37af38cd9f/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b94d844130b7aeb829228ef3a51444f5f57b2e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b94d844130b7aeb829228ef3a51444f5f57b2e1", "html_url": "https://github.com/rust-lang/rust/commit/2b94d844130b7aeb829228ef3a51444f5f57b2e1"}, {"sha": "00bbc27276a3696522aef1d66bcc955b8e862ae9", "url": "https://api.github.com/repos/rust-lang/rust/commits/00bbc27276a3696522aef1d66bcc955b8e862ae9", "html_url": "https://github.com/rust-lang/rust/commit/00bbc27276a3696522aef1d66bcc955b8e862ae9"}], "stats": {"total": 345, "additions": 155, "deletions": 190}, "files": [{"sha": "0ad6a74d1013c60b562ed1d9ff7467b2bedd5075", "filename": "src/libpanic_unwind/dwarf/eh.rs", "status": "modified", "additions": 40, "deletions": 35, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/0c42fa6ec01a49c875ae097f06f16d37af38cd9f/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c42fa6ec01a49c875ae097f06f16d37af38cd9f/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs?ref=0c42fa6ec01a49c875ae097f06f16d37af38cd9f", "patch": "@@ -24,36 +24,35 @@\n use dwarf::DwarfReader;\n use core::mem;\n \n-pub const DW_EH_PE_omit     : u8 = 0xFF;\n-pub const DW_EH_PE_absptr   : u8 = 0x00;\n-\n-pub const DW_EH_PE_uleb128  : u8 = 0x01;\n-pub const DW_EH_PE_udata2   : u8 = 0x02;\n-pub const DW_EH_PE_udata4   : u8 = 0x03;\n-pub const DW_EH_PE_udata8   : u8 = 0x04;\n-pub const DW_EH_PE_sleb128  : u8 = 0x09;\n-pub const DW_EH_PE_sdata2   : u8 = 0x0A;\n-pub const DW_EH_PE_sdata4   : u8 = 0x0B;\n-pub const DW_EH_PE_sdata8   : u8 = 0x0C;\n-\n-pub const DW_EH_PE_pcrel    : u8 = 0x10;\n-pub const DW_EH_PE_textrel  : u8 = 0x20;\n-pub const DW_EH_PE_datarel  : u8 = 0x30;\n-pub const DW_EH_PE_funcrel  : u8 = 0x40;\n-pub const DW_EH_PE_aligned  : u8 = 0x50;\n-\n-pub const DW_EH_PE_indirect : u8 = 0x80;\n+pub const DW_EH_PE_omit: u8 = 0xFF;\n+pub const DW_EH_PE_absptr: u8 = 0x00;\n+\n+pub const DW_EH_PE_uleb128: u8 = 0x01;\n+pub const DW_EH_PE_udata2: u8 = 0x02;\n+pub const DW_EH_PE_udata4: u8 = 0x03;\n+pub const DW_EH_PE_udata8: u8 = 0x04;\n+pub const DW_EH_PE_sleb128: u8 = 0x09;\n+pub const DW_EH_PE_sdata2: u8 = 0x0A;\n+pub const DW_EH_PE_sdata4: u8 = 0x0B;\n+pub const DW_EH_PE_sdata8: u8 = 0x0C;\n+\n+pub const DW_EH_PE_pcrel: u8 = 0x10;\n+pub const DW_EH_PE_textrel: u8 = 0x20;\n+pub const DW_EH_PE_datarel: u8 = 0x30;\n+pub const DW_EH_PE_funcrel: u8 = 0x40;\n+pub const DW_EH_PE_aligned: u8 = 0x50;\n+\n+pub const DW_EH_PE_indirect: u8 = 0x80;\n \n #[derive(Copy, Clone)]\n pub struct EHContext {\n-    pub ip: usize,         // Current instruction pointer\n+    pub ip: usize, // Current instruction pointer\n     pub func_start: usize, // Address of the current function\n     pub text_start: usize, // Address of the code section\n     pub data_start: usize, // Address of the data section\n }\n \n-pub unsafe fn find_landing_pad(lsda: *const u8, context: &EHContext)\n-                               -> Option<usize> {\n+pub unsafe fn find_landing_pad(lsda: *const u8, context: &EHContext) -> Option<usize> {\n     if lsda.is_null() {\n         return None;\n     }\n@@ -80,7 +79,7 @@ pub unsafe fn find_landing_pad(lsda: *const u8, context: &EHContext)\n     let action_table = reader.ptr.offset(call_site_table_length as isize);\n     // Return addresses point 1 byte past the call instruction, which could\n     // be in the next IP range.\n-    let ip = context.ip-1;\n+    let ip = context.ip - 1;\n \n     while reader.ptr < action_table {\n         let cs_start = read_encoded_pointer(&mut reader, context, call_site_encoding);\n@@ -90,7 +89,7 @@ pub unsafe fn find_landing_pad(lsda: *const u8, context: &EHContext)\n         // Callsite table is sorted by cs_start, so if we've passed the ip, we\n         // may stop searching.\n         if ip < func_start + cs_start {\n-            break\n+            break;\n         }\n         if ip < func_start + cs_start + cs_len {\n             if cs_lpad != 0 {\n@@ -114,13 +113,13 @@ fn round_up(unrounded: usize, align: usize) -> usize {\n \n unsafe fn read_encoded_pointer(reader: &mut DwarfReader,\n                                context: &EHContext,\n-                               encoding: u8) -> usize {\n+                               encoding: u8)\n+                               -> usize {\n     assert!(encoding != DW_EH_PE_omit);\n \n     // DW_EH_PE_aligned implies it's an absolute pointer value\n     if encoding == DW_EH_PE_aligned {\n-        reader.ptr = round_up(reader.ptr as usize,\n-                              mem::size_of::<usize>()) as *const u8;\n+        reader.ptr = round_up(reader.ptr as usize, mem::size_of::<usize>()) as *const u8;\n         return reader.read::<usize>();\n     }\n \n@@ -134,20 +133,26 @@ unsafe fn read_encoded_pointer(reader: &mut DwarfReader,\n         DW_EH_PE_sdata2 => reader.read::<i16>() as usize,\n         DW_EH_PE_sdata4 => reader.read::<i32>() as usize,\n         DW_EH_PE_sdata8 => reader.read::<i64>() as usize,\n-        _ => panic!()\n+        _ => panic!(),\n     };\n \n     result += match encoding & 0x70 {\n         DW_EH_PE_absptr => 0,\n         // relative to address of the encoded value, despite the name\n         DW_EH_PE_pcrel => reader.ptr as usize,\n-        DW_EH_PE_textrel => { assert!(context.text_start != 0);\n-                              context.text_start },\n-        DW_EH_PE_datarel => { assert!(context.data_start != 0);\n-                              context.data_start },\n-        DW_EH_PE_funcrel => { assert!(context.func_start != 0);\n-                              context.func_start },\n-        _ => panic!()\n+        DW_EH_PE_textrel => {\n+            assert!(context.text_start != 0);\n+            context.text_start\n+        }\n+        DW_EH_PE_datarel => {\n+            assert!(context.data_start != 0);\n+            context.data_start\n+        }\n+        DW_EH_PE_funcrel => {\n+            assert!(context.func_start != 0);\n+            context.func_start\n+        }\n+        _ => panic!(),\n     };\n \n     if encoding & DW_EH_PE_indirect != 0 {"}, {"sha": "5c05ac11d307d1c74884c4f18315a6caa0f48991", "filename": "src/libpanic_unwind/dwarf/mod.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0c42fa6ec01a49c875ae097f06f16d37af38cd9f/src%2Flibpanic_unwind%2Fdwarf%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c42fa6ec01a49c875ae097f06f16d37af38cd9f/src%2Flibpanic_unwind%2Fdwarf%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdwarf%2Fmod.rs?ref=0c42fa6ec01a49c875ae097f06f16d37af38cd9f", "patch": "@@ -21,25 +21,22 @@ pub mod eh;\n use core::mem;\n \n pub struct DwarfReader {\n-    pub ptr : *const u8\n+    pub ptr: *const u8,\n }\n \n #[repr(C,packed)]\n struct Unaligned<T>(T);\n \n impl DwarfReader {\n-\n-    pub fn new(ptr : *const u8) -> DwarfReader {\n-        DwarfReader {\n-            ptr : ptr\n-        }\n+    pub fn new(ptr: *const u8) -> DwarfReader {\n+        DwarfReader { ptr: ptr }\n     }\n \n     // DWARF streams are packed, so e.g. a u32 would not necessarily be aligned\n     // on a 4-byte boundary. This may cause problems on platforms with strict\n     // alignment requirements. By wrapping data in a \"packed\" struct, we are\n     // telling the backend to generate \"misalignment-safe\" code.\n-    pub unsafe fn read<T:Copy>(&mut self) -> T {\n+    pub unsafe fn read<T: Copy>(&mut self) -> T {\n         let Unaligned(result) = *(self.ptr as *const Unaligned<T>);\n         self.ptr = self.ptr.offset(mem::size_of::<T>() as isize);\n         result\n@@ -48,9 +45,9 @@ impl DwarfReader {\n     // ULEB128 and SLEB128 encodings are defined in Section 7.6 - \"Variable\n     // Length Data\".\n     pub unsafe fn read_uleb128(&mut self) -> u64 {\n-        let mut shift : usize = 0;\n-        let mut result : u64 = 0;\n-        let mut byte : u8;\n+        let mut shift: usize = 0;\n+        let mut result: u64 = 0;\n+        let mut byte: u8;\n         loop {\n             byte = self.read::<u8>();\n             result |= ((byte & 0x7F) as u64) << shift;\n@@ -63,9 +60,9 @@ impl DwarfReader {\n     }\n \n     pub unsafe fn read_sleb128(&mut self) -> i64 {\n-        let mut shift : usize = 0;\n-        let mut result : u64 = 0;\n-        let mut byte : u8;\n+        let mut shift: usize = 0;\n+        let mut result: u64 = 0;\n+        let mut byte: u8;\n         loop {\n             byte = self.read::<u8>();\n             result |= ((byte & 0x7F) as u64) << shift;\n@@ -84,12 +81,7 @@ impl DwarfReader {\n \n #[test]\n fn dwarf_reader() {\n-    let encoded: &[u8] = &[1,\n-                           2, 3,\n-                           4, 5, 6, 7,\n-                           0xE5, 0x8E, 0x26,\n-                           0x9B, 0xF1, 0x59,\n-                           0xFF, 0xFF];\n+    let encoded: &[u8] = &[1, 2, 3, 4, 5, 6, 7, 0xE5, 0x8E, 0x26, 0x9B, 0xF1, 0x59, 0xFF, 0xFF];\n \n     let mut reader = DwarfReader::new(encoded.as_ptr());\n "}, {"sha": "8df68da3786e2b8d28134447dc65784c85c24e5a", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 70, "deletions": 96, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/0c42fa6ec01a49c875ae097f06f16d37af38cd9f/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c42fa6ec01a49c875ae097f06f16d37af38cd9f/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=0c42fa6ec01a49c875ae097f06f16d37af38cd9f", "patch": "@@ -79,8 +79,8 @@ pub unsafe fn panic(data: Box<Any + Send>) -> u32 {\n     let exception_param = Box::into_raw(exception) as *mut uw::_Unwind_Exception;\n     return uw::_Unwind_RaiseException(exception_param) as u32;\n \n-    extern fn exception_cleanup(_unwind_code: uw::_Unwind_Reason_Code,\n-                                exception: *mut uw::_Unwind_Exception) {\n+    extern \"C\" fn exception_cleanup(_unwind_code: uw::_Unwind_Reason_Code,\n+                                    exception: *mut uw::_Unwind_Exception) {\n         unsafe {\n             let _: Box<Exception> = Box::from_raw(exception as *mut Exception);\n         }\n@@ -130,50 +130,41 @@ pub mod eabi {\n     use unwind as uw;\n     use libc::c_int;\n \n-    extern {\n+    extern \"C\" {\n         fn __gcc_personality_v0(version: c_int,\n                                 actions: uw::_Unwind_Action,\n                                 exception_class: uw::_Unwind_Exception_Class,\n                                 ue_header: *mut uw::_Unwind_Exception,\n                                 context: *mut uw::_Unwind_Context)\n-            -> uw::_Unwind_Reason_Code;\n+                                -> uw::_Unwind_Reason_Code;\n     }\n \n     #[lang = \"eh_personality\"]\n     #[no_mangle]\n-    extern fn rust_eh_personality(\n-        version: c_int,\n-        actions: uw::_Unwind_Action,\n-        exception_class: uw::_Unwind_Exception_Class,\n-        ue_header: *mut uw::_Unwind_Exception,\n-        context: *mut uw::_Unwind_Context\n-    ) -> uw::_Unwind_Reason_Code\n-    {\n-        unsafe {\n-            __gcc_personality_v0(version, actions, exception_class, ue_header,\n-                                 context)\n-        }\n+    extern \"C\" fn rust_eh_personality(version: c_int,\n+                                      actions: uw::_Unwind_Action,\n+                                      exception_class: uw::_Unwind_Exception_Class,\n+                                      ue_header: *mut uw::_Unwind_Exception,\n+                                      context: *mut uw::_Unwind_Context)\n+                                      -> uw::_Unwind_Reason_Code {\n+        unsafe { __gcc_personality_v0(version, actions, exception_class, ue_header, context) }\n     }\n \n     #[lang = \"eh_personality_catch\"]\n     #[no_mangle]\n-    pub extern fn rust_eh_personality_catch(\n-        version: c_int,\n-        actions: uw::_Unwind_Action,\n-        exception_class: uw::_Unwind_Exception_Class,\n-        ue_header: *mut uw::_Unwind_Exception,\n-        context: *mut uw::_Unwind_Context\n-    ) -> uw::_Unwind_Reason_Code\n-    {\n+    pub extern \"C\" fn rust_eh_personality_catch(version: c_int,\n+                                                actions: uw::_Unwind_Action,\n+                                                exception_class: uw::_Unwind_Exception_Class,\n+                                                ue_header: *mut uw::_Unwind_Exception,\n+                                                context: *mut uw::_Unwind_Context)\n+                                                -> uw::_Unwind_Reason_Code {\n \n-        if (actions as c_int & uw::_UA_SEARCH_PHASE as c_int) != 0 { // search phase\n+        if (actions as c_int & uw::_UA_SEARCH_PHASE as c_int) != 0 {\n+            // search phase\n             uw::_URC_HANDLER_FOUND // catch!\n-        }\n-        else { // cleanup phase\n-            unsafe {\n-                __gcc_personality_v0(version, actions, exception_class, ue_header,\n-                                     context)\n-            }\n+        } else {\n+            // cleanup phase\n+            unsafe { __gcc_personality_v0(version, actions, exception_class, ue_header, context) }\n         }\n     }\n }\n@@ -186,49 +177,40 @@ pub mod eabi {\n     use unwind as uw;\n     use libc::c_int;\n \n-    extern {\n+    extern \"C\" {\n         fn __gcc_personality_sj0(version: c_int,\n-                                actions: uw::_Unwind_Action,\n-                                exception_class: uw::_Unwind_Exception_Class,\n-                                ue_header: *mut uw::_Unwind_Exception,\n-                                context: *mut uw::_Unwind_Context)\n-            -> uw::_Unwind_Reason_Code;\n+                                 actions: uw::_Unwind_Action,\n+                                 exception_class: uw::_Unwind_Exception_Class,\n+                                 ue_header: *mut uw::_Unwind_Exception,\n+                                 context: *mut uw::_Unwind_Context)\n+                                 -> uw::_Unwind_Reason_Code;\n     }\n \n     #[lang = \"eh_personality\"]\n     #[no_mangle]\n-    pub extern fn rust_eh_personality(\n-        version: c_int,\n-        actions: uw::_Unwind_Action,\n-        exception_class: uw::_Unwind_Exception_Class,\n-        ue_header: *mut uw::_Unwind_Exception,\n-        context: *mut uw::_Unwind_Context\n-    ) -> uw::_Unwind_Reason_Code\n-    {\n-        unsafe {\n-            __gcc_personality_sj0(version, actions, exception_class, ue_header,\n-                                  context)\n-        }\n+    pub extern \"C\" fn rust_eh_personality(version: c_int,\n+                                          actions: uw::_Unwind_Action,\n+                                          exception_class: uw::_Unwind_Exception_Class,\n+                                          ue_header: *mut uw::_Unwind_Exception,\n+                                          context: *mut uw::_Unwind_Context)\n+                                          -> uw::_Unwind_Reason_Code {\n+        unsafe { __gcc_personality_sj0(version, actions, exception_class, ue_header, context) }\n     }\n \n     #[lang = \"eh_personality_catch\"]\n     #[no_mangle]\n-    pub extern fn rust_eh_personality_catch(\n-        version: c_int,\n-        actions: uw::_Unwind_Action,\n-        exception_class: uw::_Unwind_Exception_Class,\n-        ue_header: *mut uw::_Unwind_Exception,\n-        context: *mut uw::_Unwind_Context\n-    ) -> uw::_Unwind_Reason_Code\n-    {\n-        if (actions as c_int & uw::_UA_SEARCH_PHASE as c_int) != 0 { // search phase\n+    pub extern \"C\" fn rust_eh_personality_catch(version: c_int,\n+                                                actions: uw::_Unwind_Action,\n+                                                exception_class: uw::_Unwind_Exception_Class,\n+                                                ue_header: *mut uw::_Unwind_Exception,\n+                                                context: *mut uw::_Unwind_Context)\n+                                                -> uw::_Unwind_Reason_Code {\n+        if (actions as c_int & uw::_UA_SEARCH_PHASE as c_int) != 0 {\n+            // search phase\n             uw::_URC_HANDLER_FOUND // catch!\n-        }\n-        else { // cleanup phase\n-            unsafe {\n-                __gcc_personality_sj0(version, actions, exception_class, ue_header,\n-                                      context)\n-            }\n+        } else {\n+            // cleanup phase\n+            unsafe { __gcc_personality_sj0(version, actions, exception_class, ue_header, context) }\n         }\n     }\n }\n@@ -241,47 +223,40 @@ pub mod eabi {\n     use unwind as uw;\n     use libc::c_int;\n \n-    extern {\n+    extern \"C\" {\n         fn __gcc_personality_v0(state: uw::_Unwind_State,\n                                 ue_header: *mut uw::_Unwind_Exception,\n                                 context: *mut uw::_Unwind_Context)\n-            -> uw::_Unwind_Reason_Code;\n+                                -> uw::_Unwind_Reason_Code;\n     }\n \n     #[lang = \"eh_personality\"]\n     #[no_mangle]\n-    extern fn rust_eh_personality(\n-        state: uw::_Unwind_State,\n-        ue_header: *mut uw::_Unwind_Exception,\n-        context: *mut uw::_Unwind_Context\n-    ) -> uw::_Unwind_Reason_Code\n-    {\n-        unsafe {\n-            __gcc_personality_v0(state, ue_header, context)\n-        }\n+    extern \"C\" fn rust_eh_personality(state: uw::_Unwind_State,\n+                                      ue_header: *mut uw::_Unwind_Exception,\n+                                      context: *mut uw::_Unwind_Context)\n+                                      -> uw::_Unwind_Reason_Code {\n+        unsafe { __gcc_personality_v0(state, ue_header, context) }\n     }\n \n     #[lang = \"eh_personality_catch\"]\n     #[no_mangle]\n-    pub extern fn rust_eh_personality_catch(\n-        state: uw::_Unwind_State,\n-        ue_header: *mut uw::_Unwind_Exception,\n-        context: *mut uw::_Unwind_Context\n-    ) -> uw::_Unwind_Reason_Code\n-    {\n+    pub extern \"C\" fn rust_eh_personality_catch(state: uw::_Unwind_State,\n+                                                ue_header: *mut uw::_Unwind_Exception,\n+                                                context: *mut uw::_Unwind_Context)\n+                                                -> uw::_Unwind_Reason_Code {\n         // Backtraces on ARM will call the personality routine with\n         // state == _US_VIRTUAL_UNWIND_FRAME | _US_FORCE_UNWIND. In those cases\n         // we want to continue unwinding the stack, otherwise all our backtraces\n         // would end at __rust_try.\n-        if (state as c_int & uw::_US_ACTION_MASK as c_int)\n-                           == uw::_US_VIRTUAL_UNWIND_FRAME as c_int\n-               && (state as c_int & uw::_US_FORCE_UNWIND as c_int) == 0 { // search phase\n+        if (state as c_int & uw::_US_ACTION_MASK as c_int) ==\n+           uw::_US_VIRTUAL_UNWIND_FRAME as c_int &&\n+           (state as c_int & uw::_US_FORCE_UNWIND as c_int) == 0 {\n+            // search phase\n             uw::_URC_HANDLER_FOUND // catch!\n-        }\n-        else { // cleanup phase\n-            unsafe {\n-                __gcc_personality_v0(state, ue_header, context)\n-            }\n+        } else {\n+            // cleanup phase\n+            unsafe { __gcc_personality_v0(state, ue_header, context) }\n         }\n     }\n }\n@@ -290,7 +265,7 @@ pub mod eabi {\n #[cfg(all(target_os=\"windows\", target_arch = \"x86\", target_env=\"gnu\"))]\n #[lang = \"eh_unwind_resume\"]\n #[unwind]\n-unsafe extern fn rust_eh_unwind_resume(panic_ctx: *mut u8) -> ! {\n+unsafe extern \"C\" fn rust_eh_unwind_resume(panic_ctx: *mut u8) -> ! {\n     uw::_Unwind_Resume(panic_ctx as *mut uw::_Unwind_Exception);\n }\n \n@@ -314,22 +289,21 @@ unsafe extern fn rust_eh_unwind_resume(panic_ctx: *mut u8) -> ! {\n pub mod eh_frame_registry {\n     #[link(name = \"gcc_eh\")]\n     #[cfg(not(cargobuild))]\n-    extern {}\n+    extern \"C\" {}\n \n-    extern {\n+    extern \"C\" {\n         fn __register_frame_info(eh_frame_begin: *const u8, object: *mut u8);\n         fn __deregister_frame_info(eh_frame_begin: *const u8, object: *mut u8);\n     }\n \n     #[no_mangle]\n-    pub unsafe extern fn rust_eh_register_frames(eh_frame_begin: *const u8,\n-                                                 object: *mut u8) {\n+    pub unsafe extern \"C\" fn rust_eh_register_frames(eh_frame_begin: *const u8, object: *mut u8) {\n         __register_frame_info(eh_frame_begin, object);\n     }\n \n     #[no_mangle]\n-    pub  unsafe extern fn rust_eh_unregister_frames(eh_frame_begin: *const u8,\n-                                                   object: *mut u8) {\n+    pub unsafe extern \"C\" fn rust_eh_unregister_frames(eh_frame_begin: *const u8,\n+                                                       object: *mut u8) {\n         __deregister_frame_info(eh_frame_begin, object);\n     }\n }"}, {"sha": "b765ee6f81cf9a70468f9e02cfe3849c73a8ff08", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0c42fa6ec01a49c875ae097f06f16d37af38cd9f/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c42fa6ec01a49c875ae097f06f16d37af38cd9f/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=0c42fa6ec01a49c875ae097f06f16d37af38cd9f", "patch": "@@ -82,11 +82,11 @@ mod windows;\n // hairy and tightly coupled, for more information see the compiler's\n // implementation of this.\n #[no_mangle]\n-pub unsafe extern fn __rust_maybe_catch_panic(f: fn(*mut u8),\n-                                              data: *mut u8,\n-                                              data_ptr: *mut usize,\n-                                              vtable_ptr: *mut usize)\n-                                              -> u32 {\n+pub unsafe extern \"C\" fn __rust_maybe_catch_panic(f: fn(*mut u8),\n+                                                  data: *mut u8,\n+                                                  data_ptr: *mut usize,\n+                                                  vtable_ptr: *mut usize)\n+                                                  -> u32 {\n     let mut payload = imp::payload();\n     if intrinsics::try(f, data, &mut payload as *mut _ as *mut _) == 0 {\n         0\n@@ -101,7 +101,7 @@ pub unsafe extern fn __rust_maybe_catch_panic(f: fn(*mut u8),\n // Entry point for raising an exception, just delegates to the platform-specific\n // implementation.\n #[no_mangle]\n-pub unsafe extern fn __rust_start_panic(data: usize, vtable: usize) -> u32 {\n+pub unsafe extern \"C\" fn __rust_start_panic(data: usize, vtable: usize) -> u32 {\n     imp::panic(mem::transmute(raw::TraitObject {\n         data: data as *mut (),\n         vtable: vtable as *mut (),"}, {"sha": "dd6e92fe9ae19efc4779af3f57a773fe46fa8a8a", "filename": "src/libpanic_unwind/seh.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0c42fa6ec01a49c875ae097f06f16d37af38cd9f/src%2Flibpanic_unwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c42fa6ec01a49c875ae097f06f16d37af38cd9f/src%2Flibpanic_unwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh.rs?ref=0c42fa6ec01a49c875ae097f06f16d37af38cd9f", "patch": "@@ -128,7 +128,7 @@ mod imp {\n     pub const NAME1: [u8; 7] = [b'.', b'P', b'E', b'A', b'_', b'K', 0];\n     pub const NAME2: [u8; 7] = [b'.', b'P', b'E', b'A', b'X', 0, 0];\n \n-    extern {\n+    extern \"C\" {\n         pub static __ImageBase: u8;\n     }\n \n@@ -186,10 +186,7 @@ static mut THROW_INFO: _ThrowInfo = _ThrowInfo {\n \n static mut CATCHABLE_TYPE_ARRAY: _CatchableTypeArray = _CatchableTypeArray {\n     nCatchableTypes: 2,\n-    arrayOfCatchableTypes: [\n-        ptr!(0),\n-        ptr!(0),\n-    ],\n+    arrayOfCatchableTypes: [ptr!(0), ptr!(0)],\n };\n \n static mut CATCHABLE_TYPE1: _CatchableType = _CatchableType {\n@@ -216,7 +213,7 @@ static mut CATCHABLE_TYPE2: _CatchableType = _CatchableType {\n     copy_function: ptr!(0),\n };\n \n-extern {\n+extern \"C\" {\n     // The leading `\\x01` byte here is actually a magical signal to LLVM to\n     // *not* apply any other mangling like prefixing with a `_` character.\n     //"}, {"sha": "12e1a764c5f9403865045990f0d4ae4602673a5b", "filename": "src/libpanic_unwind/seh64_gnu.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0c42fa6ec01a49c875ae097f06f16d37af38cd9f/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c42fa6ec01a49c875ae097f06f16d37af38cd9f/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh64_gnu.rs?ref=0c42fa6ec01a49c875ae097f06f16d37af38cd9f", "patch": "@@ -32,11 +32,11 @@ use windows as c;\n const ETYPE: c::DWORD = 0b1110_u32 << 28;\n const MAGIC: c::DWORD = 0x525354; // \"RST\"\n \n-const RUST_PANIC: c::DWORD  = ETYPE | (1 << 24) | MAGIC;\n+const RUST_PANIC: c::DWORD = ETYPE | (1 << 24) | MAGIC;\n \n #[repr(C)]\n struct PanicData {\n-    data: Box<Any + Send>\n+    data: Box<Any + Send>,\n }\n \n pub unsafe fn panic(data: Box<Any + Send>) -> u32 {\n@@ -82,30 +82,29 @@ pub unsafe fn cleanup(ptr: *mut u8) -> Box<Any + Send> {\n \n #[lang = \"eh_personality_catch\"]\n #[cfg(not(test))]\n-unsafe extern fn rust_eh_personality_catch(\n-    exceptionRecord: *mut c::EXCEPTION_RECORD,\n-    establisherFrame: c::LPVOID,\n-    contextRecord: *mut c::CONTEXT,\n-    dispatcherContext: *mut c::DISPATCHER_CONTEXT\n-) -> c::EXCEPTION_DISPOSITION\n-{\n-    rust_eh_personality(exceptionRecord, establisherFrame,\n-                        contextRecord, dispatcherContext)\n+unsafe extern \"C\" fn rust_eh_personality_catch(exceptionRecord: *mut c::EXCEPTION_RECORD,\n+                                               establisherFrame: c::LPVOID,\n+                                               contextRecord: *mut c::CONTEXT,\n+                                               dispatcherContext: *mut c::DISPATCHER_CONTEXT)\n+                                               -> c::EXCEPTION_DISPOSITION {\n+    rust_eh_personality(exceptionRecord,\n+                        establisherFrame,\n+                        contextRecord,\n+                        dispatcherContext)\n }\n \n #[lang = \"eh_personality\"]\n #[cfg(not(test))]\n-unsafe extern fn rust_eh_personality(\n-    exceptionRecord: *mut c::EXCEPTION_RECORD,\n-    establisherFrame: c::LPVOID,\n-    contextRecord: *mut c::CONTEXT,\n-    dispatcherContext: *mut c::DISPATCHER_CONTEXT\n-) -> c::EXCEPTION_DISPOSITION\n-{\n+unsafe extern \"C\" fn rust_eh_personality(exceptionRecord: *mut c::EXCEPTION_RECORD,\n+                                         establisherFrame: c::LPVOID,\n+                                         contextRecord: *mut c::CONTEXT,\n+                                         dispatcherContext: *mut c::DISPATCHER_CONTEXT)\n+                                         -> c::EXCEPTION_DISPOSITION {\n     let er = &*exceptionRecord;\n     let dc = &*dispatcherContext;\n \n-    if er.ExceptionFlags & c::EXCEPTION_UNWIND == 0 { // we are in the dispatch phase\n+    if er.ExceptionFlags & c::EXCEPTION_UNWIND == 0 {\n+        // we are in the dispatch phase\n         if er.ExceptionCode == RUST_PANIC {\n             if let Some(lpad) = find_landing_pad(dc) {\n                 c::RtlUnwindEx(establisherFrame,\n@@ -122,7 +121,7 @@ unsafe extern fn rust_eh_personality(\n \n #[lang = \"eh_unwind_resume\"]\n #[unwind]\n-unsafe extern fn rust_eh_unwind_resume(panic_ctx: c::LPVOID) -> ! {\n+unsafe extern \"C\" fn rust_eh_unwind_resume(panic_ctx: c::LPVOID) -> ! {\n     let params = [panic_ctx as c::ULONG_PTR];\n     c::RaiseException(RUST_PANIC,\n                       c::EXCEPTION_NONCONTINUABLE,\n@@ -136,7 +135,7 @@ unsafe fn find_landing_pad(dc: &c::DISPATCHER_CONTEXT) -> Option<usize> {\n         ip: dc.ControlPc as usize,\n         func_start: dc.ImageBase as usize + (*dc.FunctionEntry).BeginAddress as usize,\n         text_start: dc.ImageBase as usize,\n-        data_start: 0\n+        data_start: 0,\n     };\n     eh::find_landing_pad(dc.HandlerData, &eh_ctx)\n }"}, {"sha": "fd8429d262e6ec2c99d384b7803b1ab33cb1243c", "filename": "src/libpanic_unwind/windows.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0c42fa6ec01a49c875ae097f06f16d37af38cd9f/src%2Flibpanic_unwind%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c42fa6ec01a49c875ae097f06f16d37af38cd9f/src%2Flibpanic_unwind%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fwindows.rs?ref=0c42fa6ec01a49c875ae097f06f16d37af38cd9f", "patch": "@@ -12,7 +12,7 @@\n #![allow(dead_code)]\n #![cfg(windows)]\n \n-use libc::{c_void, c_ulong, c_long, c_ulonglong};\n+use libc::{c_long, c_ulong, c_ulonglong, c_void};\n \n pub type DWORD = c_ulong;\n pub type LONG = c_long;\n@@ -25,8 +25,7 @@ pub const EXCEPTION_UNWINDING: DWORD = 0x2;        // Unwind is in progress\n pub const EXCEPTION_EXIT_UNWIND: DWORD = 0x4;      // Exit unwind is in progress\n pub const EXCEPTION_TARGET_UNWIND: DWORD = 0x20;   // Target unwind in progress\n pub const EXCEPTION_COLLIDED_UNWIND: DWORD = 0x40; // Collided exception handler call\n-pub const EXCEPTION_UNWIND: DWORD = EXCEPTION_UNWINDING |\n-                                    EXCEPTION_EXIT_UNWIND |\n+pub const EXCEPTION_UNWIND: DWORD = EXCEPTION_UNWINDING | EXCEPTION_EXIT_UNWIND |\n                                     EXCEPTION_TARGET_UNWIND |\n                                     EXCEPTION_COLLIDED_UNWIND;\n \n@@ -37,7 +36,7 @@ pub struct EXCEPTION_RECORD {\n     pub ExceptionRecord: *mut EXCEPTION_RECORD,\n     pub ExceptionAddress: LPVOID,\n     pub NumberParameters: DWORD,\n-    pub ExceptionInformation: [LPVOID; EXCEPTION_MAXIMUM_PARAMETERS]\n+    pub ExceptionInformation: [LPVOID; EXCEPTION_MAXIMUM_PARAMETERS],\n }\n \n #[repr(C)]\n@@ -75,7 +74,7 @@ pub enum EXCEPTION_DISPOSITION {\n     ExceptionContinueExecution,\n     ExceptionContinueSearch,\n     ExceptionNestedException,\n-    ExceptionCollidedUnwind\n+    ExceptionCollidedUnwind,\n }\n pub use self::EXCEPTION_DISPOSITION::*;\n \n@@ -93,6 +92,5 @@ extern \"system\" {\n                        OriginalContext: *const CONTEXT,\n                        HistoryTable: *const UNWIND_HISTORY_TABLE);\n     #[unwind]\n-    pub fn _CxxThrowException(pExceptionObject: *mut c_void,\n-                              pThrowInfo: *mut u8);\n+    pub fn _CxxThrowException(pExceptionObject: *mut c_void, pThrowInfo: *mut u8);\n }"}]}