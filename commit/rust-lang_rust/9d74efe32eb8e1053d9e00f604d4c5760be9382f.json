{"sha": "9d74efe32eb8e1053d9e00f604d4c5760be9382f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkNzRlZmUzMmViOGUxMDUzZDllMDBmNjA0ZDRjNTc2MGJlOTM4MmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-25T04:17:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-25T04:17:03Z"}, "message": "Auto merge of #76844 - simonvandel:fix-76803, r=wesleywiser\n\nFix #76803 miscompilation\n\nFixes #76803\nSeems like it was an oversight that the discriminant value being set was not compared to the target value from the SwitchInt, as a comment says this is a requirement for the optimization to be sound.\n\nr? `@wesleywiser` since you are probably familiar with the optimization and made #76837 to workaround the bug", "tree": {"sha": "835cf88b7bbd7c91d4307878fbcc6a0e73914bc4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/835cf88b7bbd7c91d4307878fbcc6a0e73914bc4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d74efe32eb8e1053d9e00f604d4c5760be9382f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d74efe32eb8e1053d9e00f604d4c5760be9382f", "html_url": "https://github.com/rust-lang/rust/commit/9d74efe32eb8e1053d9e00f604d4c5760be9382f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d74efe32eb8e1053d9e00f604d4c5760be9382f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bfeee5fe0140b0c2e5c96b3208c02c4ab04f8b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bfeee5fe0140b0c2e5c96b3208c02c4ab04f8b5", "html_url": "https://github.com/rust-lang/rust/commit/5bfeee5fe0140b0c2e5c96b3208c02c4ab04f8b5"}, {"sha": "a875c7a1ea31f86d4a796209f50303564ce15a16", "url": "https://api.github.com/repos/rust-lang/rust/commits/a875c7a1ea31f86d4a796209f50303564ce15a16", "html_url": "https://github.com/rust-lang/rust/commit/a875c7a1ea31f86d4a796209f50303564ce15a16"}], "stats": {"total": 131, "additions": 96, "deletions": 35}, "files": [{"sha": "4935997eb82a534de4fd1237861f106e22d2105b", "filename": "compiler/rustc_mir/src/transform/simplify_try.rs", "status": "modified", "additions": 34, "deletions": 23, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/9d74efe32eb8e1053d9e00f604d4c5760be9382f/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d74efe32eb8e1053d9e00f604d4c5760be9382f/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_try.rs?ref=9d74efe32eb8e1053d9e00f604d4c5760be9382f", "patch": "@@ -16,7 +16,7 @@ use rustc_middle::mir::visit::{NonUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, List, Ty, TyCtxt};\n use rustc_target::abi::VariantIdx;\n-use std::iter::{Enumerate, Peekable};\n+use std::iter::{once, Enumerate, Peekable};\n use std::slice::Iter;\n \n /// Simplifies arms of form `Variant(x) => Variant(x)` to just a move.\n@@ -551,6 +551,12 @@ struct SimplifyBranchSameOptimization {\n     bb_to_opt_terminator: BasicBlock,\n }\n \n+struct SwitchTargetAndValue {\n+    target: BasicBlock,\n+    // None in case of the `otherwise` case\n+    value: Option<u128>,\n+}\n+\n struct SimplifyBranchSameOptimizationFinder<'a, 'tcx> {\n     body: &'a Body<'tcx>,\n     tcx: TyCtxt<'tcx>,\n@@ -562,8 +568,16 @@ impl<'a, 'tcx> SimplifyBranchSameOptimizationFinder<'a, 'tcx> {\n             .basic_blocks()\n             .iter_enumerated()\n             .filter_map(|(bb_idx, bb)| {\n-                let (discr_switched_on, targets) = match &bb.terminator().kind {\n-                    TerminatorKind::SwitchInt { targets, discr, .. } => (discr, targets),\n+                let (discr_switched_on, targets_and_values) = match &bb.terminator().kind {\n+                    TerminatorKind::SwitchInt { targets, discr, values, .. } => {\n+                        // if values.len() == targets.len() - 1, we need to include None where no value is present\n+                        // such that the zip does not throw away targets. If no `otherwise` case is in targets, the zip will simply throw away the added None\n+                        let values_extended = values.iter().map(|x|Some(*x)).chain(once(None));\n+                        let targets_and_values:Vec<_> = targets.iter().zip(values_extended)\n+                            .map(|(target, value)| SwitchTargetAndValue{target:*target, value})\n+                            .collect();\n+                        assert_eq!(targets.len(), targets_and_values.len());\n+                        (discr, targets_and_values)},\n                     _ => return None,\n                 };\n \n@@ -587,9 +601,9 @@ impl<'a, 'tcx> SimplifyBranchSameOptimizationFinder<'a, 'tcx> {\n                     },\n                 };\n \n-                let mut iter_bbs_reachable = targets\n+                let mut iter_bbs_reachable = targets_and_values\n                     .iter()\n-                    .map(|idx| (*idx, &self.body.basic_blocks()[*idx]))\n+                    .map(|target_and_value| (target_and_value, &self.body.basic_blocks()[target_and_value.target]))\n                     .filter(|(_, bb)| {\n                         // Reaching `unreachable` is UB so assume it doesn't happen.\n                         bb.terminator().kind != TerminatorKind::Unreachable\n@@ -603,16 +617,16 @@ impl<'a, 'tcx> SimplifyBranchSameOptimizationFinder<'a, 'tcx> {\n                     })\n                     .peekable();\n \n-                let bb_first = iter_bbs_reachable.peek().map(|(idx, _)| *idx).unwrap_or(targets[0]);\n+                let bb_first = iter_bbs_reachable.peek().map(|(idx, _)| *idx).unwrap_or(&targets_and_values[0]);\n                 let mut all_successors_equivalent = StatementEquality::TrivialEqual;\n \n                 // All successor basic blocks must be equal or contain statements that are pairwise considered equal.\n-                for ((bb_l_idx,bb_l), (bb_r_idx,bb_r)) in iter_bbs_reachable.tuple_windows() {\n+                for ((target_and_value_l,bb_l), (target_and_value_r,bb_r)) in iter_bbs_reachable.tuple_windows() {\n                     let trivial_checks = bb_l.is_cleanup == bb_r.is_cleanup\n                     && bb_l.terminator().kind == bb_r.terminator().kind;\n                     let statement_check = || {\n                         bb_l.statements.iter().zip(&bb_r.statements).try_fold(StatementEquality::TrivialEqual, |acc,(l,r)| {\n-                            let stmt_equality = self.statement_equality(*adt_matched_on, &l, bb_l_idx, &r, bb_r_idx, self.tcx.sess.opts.debugging_opts.mir_opt_level);\n+                            let stmt_equality = self.statement_equality(*adt_matched_on, &l, target_and_value_l, &r, target_and_value_r);\n                             if matches!(stmt_equality, StatementEquality::NotEqual) {\n                                 // short circuit\n                                 None\n@@ -634,7 +648,7 @@ impl<'a, 'tcx> SimplifyBranchSameOptimizationFinder<'a, 'tcx> {\n                         // statements are trivially equal, so just take first\n                         trace!(\"Statements are trivially equal\");\n                         Some(SimplifyBranchSameOptimization {\n-                            bb_to_goto: bb_first,\n+                            bb_to_goto: bb_first.target,\n                             bb_to_opt_terminator: bb_idx,\n                         })\n                     }\n@@ -669,10 +683,9 @@ impl<'a, 'tcx> SimplifyBranchSameOptimizationFinder<'a, 'tcx> {\n         &self,\n         adt_matched_on: Place<'tcx>,\n         x: &Statement<'tcx>,\n-        x_bb_idx: BasicBlock,\n+        x_target_and_value: &SwitchTargetAndValue,\n         y: &Statement<'tcx>,\n-        y_bb_idx: BasicBlock,\n-        mir_opt_level: usize,\n+        y_target_and_value: &SwitchTargetAndValue,\n     ) -> StatementEquality {\n         let helper = |rhs: &Rvalue<'tcx>,\n                       place: &Place<'tcx>,\n@@ -691,13 +704,7 @@ impl<'a, 'tcx> SimplifyBranchSameOptimizationFinder<'a, 'tcx> {\n \n             match rhs {\n                 Rvalue::Use(operand) if operand.place() == Some(adt_matched_on) => {\n-                    // FIXME(76803): This logic is currently broken because it does not take into\n-                    // account the current discriminant value.\n-                    if mir_opt_level > 2 {\n-                        StatementEquality::ConsideredEqual(side_to_choose)\n-                    } else {\n-                        StatementEquality::NotEqual\n-                    }\n+                    StatementEquality::ConsideredEqual(side_to_choose)\n                 }\n                 _ => {\n                     trace!(\n@@ -717,16 +724,20 @@ impl<'a, 'tcx> SimplifyBranchSameOptimizationFinder<'a, 'tcx> {\n             (\n                 StatementKind::Assign(box (_, rhs)),\n                 StatementKind::SetDiscriminant { place, variant_index },\n-            ) => {\n+            )\n+            // we need to make sure that the switch value that targets the bb with SetDiscriminant (y), is the same as the variant index\n+            if Some(variant_index.index() as u128) == y_target_and_value.value => {\n                 // choose basic block of x, as that has the assign\n-                helper(rhs, place, variant_index, x_bb_idx)\n+                helper(rhs, place, variant_index, x_target_and_value.target)\n             }\n             (\n                 StatementKind::SetDiscriminant { place, variant_index },\n                 StatementKind::Assign(box (_, rhs)),\n-            ) => {\n+            )\n+            // we need to make sure that the switch value that targets the bb with SetDiscriminant (x), is the same as the variant index\n+            if Some(variant_index.index() as u128) == x_target_and_value.value  => {\n                 // choose basic block of y, as that has the assign\n-                helper(rhs, place, variant_index, y_bb_idx)\n+                helper(rhs, place, variant_index, y_target_and_value.target)\n             }\n             _ => {\n                 trace!(\"NO: statements `{:?}` and `{:?}` not considered equal\", x, y);"}, {"sha": "28b8329606c1bcc7fede011e9bb78322b3d5689b", "filename": "src/test/mir-opt/76803_regression.encode.SimplifyBranchSame.diff", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9d74efe32eb8e1053d9e00f604d4c5760be9382f/src%2Ftest%2Fmir-opt%2F76803_regression.encode.SimplifyBranchSame.diff", "raw_url": "https://github.com/rust-lang/rust/raw/9d74efe32eb8e1053d9e00f604d4c5760be9382f/src%2Ftest%2Fmir-opt%2F76803_regression.encode.SimplifyBranchSame.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2F76803_regression.encode.SimplifyBranchSame.diff?ref=9d74efe32eb8e1053d9e00f604d4c5760be9382f", "patch": "@@ -0,0 +1,28 @@\n+- // MIR for `encode` before SimplifyBranchSame\n++ // MIR for `encode` after SimplifyBranchSame\n+  \n+  fn encode(_1: Type) -> Type {\n+      debug v => _1;                       // in scope 0 at $DIR/76803_regression.rs:10:15: 10:16\n+      let mut _0: Type;                    // return place in scope 0 at $DIR/76803_regression.rs:10:27: 10:31\n+      let mut _2: isize;                   // in scope 0 at $DIR/76803_regression.rs:12:9: 12:16\n+  \n+      bb0: {\n+          _2 = discriminant(_1);           // scope 0 at $DIR/76803_regression.rs:12:9: 12:16\n+          switchInt(move _2) -> [0_isize: bb2, otherwise: bb1]; // scope 0 at $DIR/76803_regression.rs:12:9: 12:16\n+      }\n+  \n+      bb1: {\n+          _0 = move _1;                    // scope 0 at $DIR/76803_regression.rs:13:14: 13:15\n+          goto -> bb3;                     // scope 0 at $DIR/76803_regression.rs:11:5: 14:6\n+      }\n+  \n+      bb2: {\n+          discriminant(_0) = 1;            // scope 0 at $DIR/76803_regression.rs:12:20: 12:27\n+          goto -> bb3;                     // scope 0 at $DIR/76803_regression.rs:11:5: 14:6\n+      }\n+  \n+      bb3: {\n+          return;                          // scope 0 at $DIR/76803_regression.rs:15:2: 15:2\n+      }\n+  }\n+  "}, {"sha": "05dc3c97841099c6ff1741fcf55d5504eca1229a", "filename": "src/test/mir-opt/76803_regression.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9d74efe32eb8e1053d9e00f604d4c5760be9382f/src%2Ftest%2Fmir-opt%2F76803_regression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d74efe32eb8e1053d9e00f604d4c5760be9382f/src%2Ftest%2Fmir-opt%2F76803_regression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2F76803_regression.rs?ref=9d74efe32eb8e1053d9e00f604d4c5760be9382f", "patch": "@@ -0,0 +1,19 @@\n+// compile-flags: -Z mir-opt-level=1\n+// EMIT_MIR 76803_regression.encode.SimplifyBranchSame.diff\n+\n+#[derive(Debug, Eq, PartialEq)]\n+pub enum Type {\n+    A,\n+    B,\n+}\n+\n+pub fn encode(v: Type) -> Type {\n+    match v {\n+        Type::A => Type::B,\n+        _ => v,\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(Type::B, encode(Type::A));\n+}"}, {"sha": "81a0e6ba0b4eeb91e6eaad55080564845e5a1979", "filename": "src/test/mir-opt/simplify_arm.id.SimplifyBranchSame.diff", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9d74efe32eb8e1053d9e00f604d4c5760be9382f/src%2Ftest%2Fmir-opt%2Fsimplify_arm.id.SimplifyBranchSame.diff", "raw_url": "https://github.com/rust-lang/rust/raw/9d74efe32eb8e1053d9e00f604d4c5760be9382f/src%2Ftest%2Fmir-opt%2Fsimplify_arm.id.SimplifyBranchSame.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_arm.id.SimplifyBranchSame.diff?ref=9d74efe32eb8e1053d9e00f604d4c5760be9382f", "patch": "@@ -13,24 +13,27 @@\n   \n       bb0: {\n           _2 = discriminant(_1);           // scope 0 at $DIR/simplify-arm.rs:11:9: 11:16\n-          switchInt(move _2) -> [0_isize: bb1, 1_isize: bb3, otherwise: bb2]; // scope 0 at $DIR/simplify-arm.rs:11:9: 11:16\n+-         switchInt(move _2) -> [0_isize: bb1, 1_isize: bb3, otherwise: bb2]; // scope 0 at $DIR/simplify-arm.rs:11:9: 11:16\n++         goto -> bb1;                     // scope 0 at $DIR/simplify-arm.rs:11:9: 11:16\n       }\n   \n       bb1: {\n-          discriminant(_0) = 0;            // scope 0 at $DIR/simplify-arm.rs:12:17: 12:21\n-          goto -> bb4;                     // scope 0 at $DIR/simplify-arm.rs:10:5: 13:6\n-      }\n-  \n-      bb2: {\n-          unreachable;                     // scope 0 at $DIR/simplify-arm.rs:10:11: 10:12\n-      }\n-  \n-      bb3: {\n+-         discriminant(_0) = 0;            // scope 0 at $DIR/simplify-arm.rs:12:17: 12:21\n+-         goto -> bb4;                     // scope 0 at $DIR/simplify-arm.rs:10:5: 13:6\n+-     }\n+- \n+-     bb2: {\n+-         unreachable;                     // scope 0 at $DIR/simplify-arm.rs:10:11: 10:12\n+-     }\n+- \n+-     bb3: {\n           _0 = move _1;                    // scope 1 at $DIR/simplify-arm.rs:11:20: 11:27\n-          goto -> bb4;                     // scope 0 at $DIR/simplify-arm.rs:10:5: 13:6\n+-         goto -> bb4;                     // scope 0 at $DIR/simplify-arm.rs:10:5: 13:6\n++         goto -> bb2;                     // scope 0 at $DIR/simplify-arm.rs:10:5: 13:6\n       }\n   \n-      bb4: {\n+-     bb4: {\n++     bb2: {\n           return;                          // scope 0 at $DIR/simplify-arm.rs:14:2: 14:2\n       }\n   }"}]}