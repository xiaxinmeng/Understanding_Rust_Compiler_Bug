{"sha": "a517343566956fb038b061f31558f088944977c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1MTczNDM1NjY5NTZmYjAzOGIwNjFmMzE1NThmMDg4OTQ0OTc3YzM=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-04-24T16:35:47Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-04-26T14:45:02Z"}, "message": "cache symbol names in ty::maps\n\nthis fixes a performance regression introduced in commit\n39a58c38a0b9ac9e822a1732f073abe8ddf65cfb.", "tree": {"sha": "802c72a419b34fc5028ba56a8a6487bc68983fe6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/802c72a419b34fc5028ba56a8a6487bc68983fe6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a517343566956fb038b061f31558f088944977c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a517343566956fb038b061f31558f088944977c3", "html_url": "https://github.com/rust-lang/rust/commit/a517343566956fb038b061f31558f088944977c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a517343566956fb038b061f31558f088944977c3/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "html_url": "https://github.com/rust-lang/rust/commit/b0a4074c5e87d24ff630f6aa456a64698bff3ed2"}], "stats": {"total": 324, "additions": 148, "deletions": 176}, "files": [{"sha": "31e6a3106a438890a49d7f960e6b6aad12b1caaf", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a517343566956fb038b061f31558f088944977c3/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a517343566956fb038b061f31558f088944977c3/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=a517343566956fb038b061f31558f088944977c3", "patch": "@@ -99,6 +99,7 @@ pub enum DepNode<D: Clone + Debug> {\n     TypeckTables(D),\n     UsedTraitImports(D),\n     ConstEval(D),\n+    SymbolName(D),\n \n     // The set of impls for a given trait. Ultimately, it would be\n     // nice to get more fine-grained here (e.g., to include a\n@@ -236,6 +237,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             TypeckTables(ref d) => op(d).map(TypeckTables),\n             UsedTraitImports(ref d) => op(d).map(UsedTraitImports),\n             ConstEval(ref d) => op(d).map(ConstEval),\n+            SymbolName(ref d) => op(d).map(SymbolName),\n             TraitImpls(ref d) => op(d).map(TraitImpls),\n             TraitItems(ref d) => op(d).map(TraitItems),\n             ReprHints(ref d) => op(d).map(ReprHints),"}, {"sha": "c80ae87d941ffa96dcc308acfc8d49c85ad364dd", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a517343566956fb038b061f31558f088944977c3/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a517343566956fb038b061f31558f088944977c3/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=a517343566956fb038b061f31558f088944977c3", "patch": "@@ -24,6 +24,7 @@ use std::cell::{RefCell, RefMut};\n use std::ops::Deref;\n use std::rc::Rc;\n use syntax_pos::{Span, DUMMY_SP};\n+use syntax::symbol::Symbol;\n \n trait Key {\n     fn map_crate(&self) -> CrateNum;\n@@ -40,6 +41,16 @@ impl<'tcx> Key for ty::InstanceDef<'tcx> {\n     }\n }\n \n+impl<'tcx> Key for ty::Instance<'tcx> {\n+    fn map_crate(&self) -> CrateNum {\n+        LOCAL_CRATE\n+    }\n+\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        tcx.def_span(self.def_id())\n+    }\n+}\n+\n impl Key for CrateNum {\n     fn map_crate(&self) -> CrateNum {\n         *self\n@@ -108,13 +119,18 @@ impl<'tcx> Value<'tcx> for Ty<'tcx> {\n     }\n }\n \n-\n impl<'tcx> Value<'tcx> for ty::DtorckConstraint<'tcx> {\n     fn from_cycle_error<'a>(_: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n         Self::empty()\n     }\n }\n \n+impl<'tcx> Value<'tcx> for ty::SymbolName {\n+    fn from_cycle_error<'a>(_: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n+        ty::SymbolName { name: Symbol::intern(\"<error>\").as_str() }\n+    }\n+}\n+\n pub struct CycleError<'a, 'tcx: 'a> {\n     span: Span,\n     cycle: RefMut<'a, [(Span, Query<'tcx>)]>,\n@@ -242,6 +258,12 @@ impl<'tcx> QueryDescription for queries::const_eval<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::symbol_name<'tcx> {\n+    fn describe(_tcx: TyCtxt, instance: ty::Instance<'tcx>) -> String {\n+        format!(\"computing the symbol for `{}`\", instance)\n+    }\n+}\n+\n macro_rules! define_maps {\n     (<$tcx:tt>\n      $($(#[$attr:meta])*\n@@ -513,7 +535,10 @@ define_maps! { <'tcx>\n \n     pub reachable_set: reachability_dep_node(CrateNum) -> Rc<NodeSet>,\n \n-    pub mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx RefCell<mir::Mir<'tcx>>\n+    pub mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx RefCell<mir::Mir<'tcx>>,\n+\n+    pub def_symbol_name: SymbolName(DefId) -> ty::SymbolName,\n+    pub symbol_name: symbol_name_dep_node(ty::Instance<'tcx>) -> ty::SymbolName\n }\n \n fn coherent_trait_dep_node((_, def_id): (CrateNum, DefId)) -> DepNode<DefId> {\n@@ -532,6 +557,12 @@ fn mir_shim_dep_node(instance: ty::InstanceDef) -> DepNode<DefId> {\n     instance.dep_node()\n }\n \n+fn symbol_name_dep_node(instance: ty::Instance) -> DepNode<DefId> {\n+    // symbol_name uses the substs only to traverse them to find the\n+    // hash, and that does not create any new dep-nodes.\n+    DepNode::SymbolName(instance.def.def_id())\n+}\n+\n fn typeck_item_bodies_dep_node(_: CrateNum) -> DepNode<DefId> {\n     DepNode::TypeckBodiesKrate\n }"}, {"sha": "de207df7d15eb0baf3aed24a42d7b84a2838843b", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a517343566956fb038b061f31558f088944977c3/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a517343566956fb038b061f31558f088944977c3/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=a517343566956fb038b061f31558f088944977c3", "patch": "@@ -38,6 +38,7 @@ use serialize::{self, Encodable, Encoder};\n use std::cell::{Cell, RefCell, Ref};\n use std::collections::BTreeMap;\n use std::cmp;\n+use std::fmt;\n use std::hash::{Hash, Hasher};\n use std::iter::FromIterator;\n use std::ops::Deref;\n@@ -2745,3 +2746,22 @@ impl<'tcx> DtorckConstraint<'tcx> {\n         self.dtorck_types.retain(|&val| dtorck_types.replace(val).is_none());\n     }\n }\n+\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct SymbolName {\n+    // FIXME: we don't rely on interning or equality here - better have\n+    // this be a `&'tcx str`.\n+    pub name: InternedString\n+}\n+\n+impl Deref for SymbolName {\n+    type Target = str;\n+\n+    fn deref(&self) -> &str { &self.name }\n+}\n+\n+impl fmt::Display for SymbolName {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.name, fmt)\n+    }\n+}"}, {"sha": "dab2a0758a2176df55fce2128f6ddefc127800a8", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a517343566956fb038b061f31558f088944977c3/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a517343566956fb038b061f31558f088944977c3/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=a517343566956fb038b061f31558f088944977c3", "patch": "@@ -225,8 +225,6 @@ pub fn compile_input(sess: &Session,\n         sess.code_stats.borrow().print_type_sizes();\n     }\n \n-    if ::std::env::var(\"SKIP_LLVM\").is_ok() { ::std::process::exit(0); }\n-\n     let phase5_result = phase_5_run_llvm_passes(sess, &trans, &outputs);\n \n     controller_entry_point!(after_llvm,\n@@ -895,13 +893,15 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     mir::provide(&mut local_providers);\n     reachable::provide(&mut local_providers);\n     rustc_privacy::provide(&mut local_providers);\n+    trans::provide(&mut local_providers);\n     typeck::provide(&mut local_providers);\n     ty::provide(&mut local_providers);\n     reachable::provide(&mut local_providers);\n     rustc_const_eval::provide(&mut local_providers);\n \n     let mut extern_providers = ty::maps::Providers::default();\n     cstore::provide(&mut extern_providers);\n+    trans::provide(&mut extern_providers);\n     ty::provide_extern(&mut extern_providers);\n     // FIXME(eddyb) get rid of this once we replace const_eval with miri.\n     rustc_const_eval::provide(&mut extern_providers);"}, {"sha": "467bc6cbfc6d27ecae6d1d1a19d741558c0cdb46", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a517343566956fb038b061f31558f088944977c3/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a517343566956fb038b061f31558f088944977c3/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=a517343566956fb038b061f31558f088944977c3", "patch": "@@ -11,7 +11,6 @@\n use context::SharedCrateContext;\n use monomorphize::Instance;\n use symbol_map::SymbolMap;\n-use back::symbol_names::symbol_name;\n use util::nodemap::FxHashMap;\n use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n use rustc::session::config;\n@@ -56,7 +55,7 @@ impl ExportedSymbols {\n                 let name = symbol_for_def_id(scx.tcx(), def_id, symbol_map);\n                 let export_level = export_level(scx, def_id);\n                 debug!(\"EXPORTED SYMBOL (local): {} ({:?})\", name, export_level);\n-                (name, export_level)\n+                (str::to_owned(&name), export_level)\n             })\n             .collect();\n \n@@ -108,7 +107,7 @@ impl ExportedSymbols {\n                 .exported_symbols(cnum)\n                 .iter()\n                 .map(|&def_id| {\n-                    let name = symbol_name(Instance::mono(scx.tcx(), def_id), scx.tcx());\n+                    let name = scx.tcx().symbol_name(Instance::mono(scx.tcx(), def_id));\n                     let export_level = if special_runtime_crate {\n                         // We can probably do better here by just ensuring that\n                         // it has hidden visibility rather than public\n@@ -117,9 +116,9 @@ impl ExportedSymbols {\n                         //\n                         // In general though we won't link right if these\n                         // symbols are stripped, and LTO currently strips them.\n-                        if name == \"rust_eh_personality\" ||\n-                           name == \"rust_eh_register_frames\" ||\n-                           name == \"rust_eh_unregister_frames\" {\n+                        if &*name == \"rust_eh_personality\" ||\n+                           &*name == \"rust_eh_register_frames\" ||\n+                           &*name == \"rust_eh_unregister_frames\" {\n                             SymbolExportLevel::C\n                         } else {\n                             SymbolExportLevel::Rust\n@@ -128,7 +127,7 @@ impl ExportedSymbols {\n                         export_level(scx, def_id)\n                     };\n                     debug!(\"EXPORTED SYMBOL (re-export): {} ({:?})\", name, export_level);\n-                    (name, export_level)\n+                    (str::to_owned(&name), export_level)\n                 })\n                 .collect();\n \n@@ -228,7 +227,5 @@ fn symbol_for_def_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let instance = Instance::mono(tcx, def_id);\n \n-    symbol_map.get(TransItem::Fn(instance))\n-              .map(str::to_owned)\n-              .unwrap_or_else(|| symbol_name(instance, tcx))\n+    str::to_owned(&tcx.symbol_name(instance))\n }"}, {"sha": "53a1ec2bd6c703c9da0f70586130c8805897f963", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 43, "deletions": 7, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a517343566956fb038b061f31558f088944977c3/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a517343566956fb038b061f31558f088944977c3/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=a517343566956fb038b061f31558f088944977c3", "patch": "@@ -105,14 +105,24 @@ use rustc::hir::map as hir_map;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::fold::TypeVisitor;\n use rustc::ty::item_path::{self, ItemPathBuffer, RootMode};\n+use rustc::ty::maps::Providers;\n use rustc::ty::subst::Substs;\n use rustc::hir::map::definitions::DefPathData;\n use rustc::util::common::record_time;\n \n use syntax::attr;\n+use syntax_pos::symbol::Symbol;\n \n use std::fmt::Write;\n \n+pub fn provide(providers: &mut Providers) {\n+    *providers = Providers {\n+        def_symbol_name,\n+        symbol_name,\n+        ..*providers\n+    };\n+}\n+\n fn get_symbol_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n                              // the DefId of the item this name is for\n@@ -165,8 +175,25 @@ fn get_symbol_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     format!(\"h{:016x}\", hasher.finish())\n }\n \n-pub fn symbol_name<'a, 'tcx>(instance: Instance<'tcx>,\n-                             tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n+fn def_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n+                             -> ty::SymbolName\n+{\n+    let mut buffer = SymbolPathBuffer::new();\n+    item_path::with_forced_absolute_paths(|| {\n+        tcx.push_item_path(&mut buffer, def_id);\n+    });\n+    buffer.into_interned()\n+}\n+\n+fn symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance<'tcx>)\n+                         -> ty::SymbolName\n+{\n+    ty::SymbolName { name: Symbol::intern(&compute_symbol_name(tcx, instance)).as_str() }\n+}\n+\n+fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance<'tcx>)\n+    -> String\n+{\n     let def_id = instance.def_id();\n     let substs = instance.substs;\n \n@@ -253,11 +280,7 @@ pub fn symbol_name<'a, 'tcx>(instance: Instance<'tcx>,\n \n     let hash = get_symbol_hash(tcx, Some(def_id), instance_ty, Some(substs));\n \n-    let mut buffer = SymbolPathBuffer::new();\n-    item_path::with_forced_absolute_paths(|| {\n-        tcx.push_item_path(&mut buffer, def_id);\n-    });\n-    buffer.finish(&hash)\n+    SymbolPathBuffer::from_interned(tcx.def_symbol_name(def_id)).finish(&hash)\n }\n \n // Follow C++ namespace-mangling style, see\n@@ -288,6 +311,19 @@ impl SymbolPathBuffer {\n         result\n     }\n \n+    fn from_interned(symbol: ty::SymbolName) -> Self {\n+        let mut result = SymbolPathBuffer {\n+            result: String::with_capacity(64),\n+            temp_buf: String::with_capacity(16)\n+        };\n+        result.result.push_str(&symbol.name);\n+        result\n+    }\n+\n+    fn into_interned(self) -> ty::SymbolName {\n+        ty::SymbolName { name: Symbol::intern(&self.result).as_str() }\n+    }\n+\n     fn finish(mut self, hash: &str) -> String {\n         // end name-sequence\n         self.push(hash);"}, {"sha": "12d077a5507423b16f6630ecbd1ec87c5958c5e9", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a517343566956fb038b061f31558f088944977c3/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a517343566956fb038b061f31558f088944977c3/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=a517343566956fb038b061f31558f088944977c3", "patch": "@@ -65,7 +65,6 @@ use meth;\n use mir;\n use monomorphize::{self, Instance};\n use partitioning::{self, PartitioningStrategy, CodegenUnit};\n-use symbol_cache::SymbolCache;\n use symbol_map::SymbolMap;\n use symbol_names_test;\n use trans_item::{TransItem, DefPathBasedNames};\n@@ -1139,8 +1138,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         let cgu_name = String::from(cgu.name());\n         let cgu_id = cgu.work_product_id();\n-        let symbol_cache = SymbolCache::new(scx.tcx());\n-        let symbol_name_hash = cgu.compute_symbol_name_hash(scx, &symbol_cache);\n+        let symbol_name_hash = cgu.compute_symbol_name_hash(scx);\n \n         // Check whether there is a previous work-product we can\n         // re-use.  Not only must the file exist, and the inputs not\n@@ -1175,11 +1173,11 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         // Instantiate translation items without filling out definitions yet...\n-        let lcx = LocalCrateContext::new(scx, cgu, &symbol_cache);\n+        let lcx = LocalCrateContext::new(scx, cgu);\n         let module = {\n             let ccx = CrateContext::new(scx, &lcx);\n             let trans_items = ccx.codegen_unit()\n-                                 .items_in_deterministic_order(ccx.tcx(), &symbol_cache);\n+                                 .items_in_deterministic_order(ccx.tcx());\n             for &(trans_item, linkage) in &trans_items {\n                 trans_item.predefine(&ccx, linkage);\n             }"}, {"sha": "dc788dc4b48342026eab14e1611ed38b2f6dbc39", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a517343566956fb038b061f31558f088944977c3/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a517343566956fb038b061f31558f088944977c3/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=a517343566956fb038b061f31558f088944977c3", "patch": "@@ -23,7 +23,6 @@ use monomorphize::{self, Instance};\n use rustc::hir::def_id::DefId;\n use rustc::ty::TypeFoldable;\n use rustc::ty::subst::Substs;\n-use trans_item::TransItem;\n use type_of;\n \n /// Translates a reference to a fn/method item, monomorphizing and\n@@ -50,7 +49,7 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         return llfn;\n     }\n \n-    let sym = ccx.symbol_cache().get(TransItem::Fn(instance));\n+    let sym = tcx.symbol_name(instance);\n     debug!(\"get_fn({:?}: {:?}) => {}\", instance, fn_ty, sym);\n \n     // This is subtle and surprising, but sometimes we have to bitcast"}, {"sha": "6afb340107d6661aa1c3a5ad517319757942f887", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a517343566956fb038b061f31558f088944977c3/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a517343566956fb038b061f31558f088944977c3/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=a517343566956fb038b061f31558f088944977c3", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-use back::symbol_names;\n use llvm;\n use llvm::{SetUnnamedAddr};\n use llvm::{ValueRef, True};\n@@ -93,8 +91,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n             hir_map::NodeItem(&hir::Item {\n                 ref attrs, span, node: hir::ItemStatic(..), ..\n             }) => {\n-                let sym = ccx.symbol_cache()\n-                             .get(TransItem::Static(id));\n+                let sym = TransItem::Static(id).symbol_name(ccx.tcx());\n \n                 let defined_in_current_codegen_unit = ccx.codegen_unit()\n                                                          .items()\n@@ -113,7 +110,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n             hir_map::NodeForeignItem(&hir::ForeignItem {\n                 ref attrs, span, node: hir::ForeignItemStatic(..), ..\n             }) => {\n-                let sym = symbol_names::symbol_name(instance, ccx.tcx());\n+                let sym = ccx.tcx().symbol_name(instance);\n                 let g = if let Some(name) =\n                         attr::first_attr_value_str_by_name(&attrs, \"linkage\") {\n                     // If this is a static with a linkage specified, then we need to handle\n@@ -173,7 +170,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n \n         g\n     } else {\n-        let sym = symbol_names::symbol_name(instance, ccx.tcx());\n+        let sym = ccx.tcx().symbol_name(instance);\n \n         // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n         // FIXME(nagisa): investigate whether it can be changed into define_global"}, {"sha": "90cda2f5cad3d582378141b12184d4e5ea05b4a3", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 5, "deletions": 45, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a517343566956fb038b061f31558f088944977c3/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a517343566956fb038b061f31558f088944977c3/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=a517343566956fb038b061f31558f088944977c3", "patch": "@@ -29,14 +29,14 @@ use rustc::ty::layout::{LayoutTyper, TyLayout};\n use session::config::NoDebugInfo;\n use session::Session;\n use session::config;\n-use symbol_cache::SymbolCache;\n use util::nodemap::{NodeSet, DefIdMap, FxHashMap};\n \n use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n use std::ptr;\n use std::iter;\n use std::str;\n+use std::marker::PhantomData;\n use syntax::ast;\n use syntax::symbol::InternedString;\n use syntax_pos::DUMMY_SP;\n@@ -94,7 +94,6 @@ pub struct LocalCrateContext<'a, 'tcx: 'a> {\n     llcx: ContextRef,\n     stats: Stats,\n     codegen_unit: CodegenUnit<'tcx>,\n-    needs_unwind_cleanup_cache: RefCell<FxHashMap<Ty<'tcx>, bool>>,\n     /// Cache instances of monomorphic and polymorphic items\n     instances: RefCell<FxHashMap<Instance<'tcx>, ValueRef>>,\n     /// Cache generated vtables\n@@ -125,11 +124,6 @@ pub struct LocalCrateContext<'a, 'tcx: 'a> {\n     /// Mapping from static definitions to their DefId's.\n     statics: RefCell<FxHashMap<ValueRef, DefId>>,\n \n-    impl_method_cache: RefCell<FxHashMap<(DefId, ast::Name), DefId>>,\n-\n-    /// Cache of closure wrappers for bare fn's.\n-    closure_bare_wrapper_cache: RefCell<FxHashMap<ValueRef, ValueRef>>,\n-\n     /// List of globals for static variables which need to be passed to the\n     /// LLVM function ReplaceAllUsesWith (RAUW) when translation is complete.\n     /// (We have to make sure we don't invalidate any ValueRefs referring\n@@ -141,15 +135,11 @@ pub struct LocalCrateContext<'a, 'tcx: 'a> {\n     used_statics: RefCell<Vec<ValueRef>>,\n \n     lltypes: RefCell<FxHashMap<Ty<'tcx>, Type>>,\n-    llsizingtypes: RefCell<FxHashMap<Ty<'tcx>, Type>>,\n     type_hashcodes: RefCell<FxHashMap<Ty<'tcx>, String>>,\n     int_type: Type,\n     opaque_vec_type: Type,\n     str_slice_type: Type,\n \n-    /// Holds the LLVM values for closure IDs.\n-    closure_vals: RefCell<FxHashMap<Instance<'tcx>, ValueRef>>,\n-\n     dbg_cx: Option<debuginfo::CrateDebugContext<'tcx>>,\n \n     eh_personality: Cell<Option<ValueRef>>,\n@@ -164,7 +154,8 @@ pub struct LocalCrateContext<'a, 'tcx: 'a> {\n     /// A counter that is used for generating local symbol names\n     local_gen_sym_counter: Cell<usize>,\n \n-    symbol_cache: &'a SymbolCache<'a, 'tcx>,\n+    /// A placeholder so we can add lifetimes\n+    placeholder: PhantomData<&'a ()>,\n }\n \n /// A CrateContext value binds together one LocalCrateContext with the\n@@ -366,8 +357,7 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n \n impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n     pub fn new(shared: &SharedCrateContext<'a, 'tcx>,\n-               codegen_unit: CodegenUnit<'tcx>,\n-               symbol_cache: &'a SymbolCache<'a, 'tcx>)\n+               codegen_unit: CodegenUnit<'tcx>)\n                -> LocalCrateContext<'a, 'tcx> {\n         unsafe {\n             // Append \".rs\" to LLVM module identifier.\n@@ -396,7 +386,6 @@ impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n                 llcx: llcx,\n                 stats: Stats::default(),\n                 codegen_unit: codegen_unit,\n-                needs_unwind_cleanup_cache: RefCell::new(FxHashMap()),\n                 instances: RefCell::new(FxHashMap()),\n                 vtables: RefCell::new(FxHashMap()),\n                 const_cstr_cache: RefCell::new(FxHashMap()),\n@@ -405,25 +394,21 @@ impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n                 const_values: RefCell::new(FxHashMap()),\n                 extern_const_values: RefCell::new(DefIdMap()),\n                 statics: RefCell::new(FxHashMap()),\n-                impl_method_cache: RefCell::new(FxHashMap()),\n-                closure_bare_wrapper_cache: RefCell::new(FxHashMap()),\n                 statics_to_rauw: RefCell::new(Vec::new()),\n                 used_statics: RefCell::new(Vec::new()),\n                 lltypes: RefCell::new(FxHashMap()),\n-                llsizingtypes: RefCell::new(FxHashMap()),\n                 type_hashcodes: RefCell::new(FxHashMap()),\n                 int_type: Type::from_ref(ptr::null_mut()),\n                 opaque_vec_type: Type::from_ref(ptr::null_mut()),\n                 str_slice_type: Type::from_ref(ptr::null_mut()),\n-                closure_vals: RefCell::new(FxHashMap()),\n                 dbg_cx: dbg_cx,\n                 eh_personality: Cell::new(None),\n                 eh_unwind_resume: Cell::new(None),\n                 rust_try_fn: Cell::new(None),\n                 intrinsics: RefCell::new(FxHashMap()),\n                 type_of_depth: Cell::new(0),\n                 local_gen_sym_counter: Cell::new(0),\n-                symbol_cache: symbol_cache,\n+                placeholder: PhantomData,\n             };\n \n             let (int_type, opaque_vec_type, str_slice_ty, mut local_ccx) = {\n@@ -515,10 +500,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         unsafe { llvm::LLVMRustGetModuleDataLayout(self.llmod()) }\n     }\n \n-    pub fn needs_unwind_cleanup_cache(&self) -> &RefCell<FxHashMap<Ty<'tcx>, bool>> {\n-        &self.local().needs_unwind_cleanup_cache\n-    }\n-\n     pub fn instances<'a>(&'a self) -> &'a RefCell<FxHashMap<Instance<'tcx>, ValueRef>> {\n         &self.local().instances\n     }\n@@ -554,15 +535,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().statics\n     }\n \n-    pub fn impl_method_cache<'a>(&'a self)\n-            -> &'a RefCell<FxHashMap<(DefId, ast::Name), DefId>> {\n-        &self.local().impl_method_cache\n-    }\n-\n-    pub fn closure_bare_wrapper_cache<'a>(&'a self) -> &'a RefCell<FxHashMap<ValueRef, ValueRef>> {\n-        &self.local().closure_bare_wrapper_cache\n-    }\n-\n     pub fn statics_to_rauw<'a>(&'a self) -> &'a RefCell<Vec<(ValueRef, ValueRef)>> {\n         &self.local().statics_to_rauw\n     }\n@@ -575,10 +547,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().lltypes\n     }\n \n-    pub fn llsizingtypes<'a>(&'a self) -> &'a RefCell<FxHashMap<Ty<'tcx>, Type>> {\n-        &self.local().llsizingtypes\n-    }\n-\n     pub fn type_hashcodes<'a>(&'a self) -> &'a RefCell<FxHashMap<Ty<'tcx>, String>> {\n         &self.local().type_hashcodes\n     }\n@@ -599,10 +567,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local().str_slice_type\n     }\n \n-    pub fn closure_vals<'a>(&'a self) -> &'a RefCell<FxHashMap<Instance<'tcx>, ValueRef>> {\n-        &self.local().closure_vals\n-    }\n-\n     pub fn dbg_cx<'a>(&'a self) -> &'a Option<debuginfo::CrateDebugContext<'tcx>> {\n         &self.local().dbg_cx\n     }\n@@ -644,10 +608,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.shared.use_dll_storage_attrs()\n     }\n \n-    pub fn symbol_cache(&self) -> &'b SymbolCache<'b, 'tcx> {\n-        self.local().symbol_cache\n-    }\n-\n     /// Given the def-id of some item that has no type parameters, make\n     /// a suitable \"empty substs\" for it.\n     pub fn empty_substs_for_def_id(&self, item_def_id: DefId) -> &'tcx Substs<'tcx> {"}, {"sha": "faddffb65fae23477b1076d79fff2c3d251385c3", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a517343566956fb038b061f31558f088944977c3/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a517343566956fb038b061f31558f088944977c3/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=a517343566956fb038b061f31558f088944977c3", "patch": "@@ -67,6 +67,7 @@ pub use rustc::lint;\n pub use rustc::util;\n \n pub use base::trans_crate;\n+pub use back::symbol_names::provide;\n \n pub mod back {\n     pub use rustc::hir::svh;\n@@ -124,7 +125,6 @@ mod meth;\n mod mir;\n mod monomorphize;\n mod partitioning;\n-mod symbol_cache;\n mod symbol_map;\n mod symbol_names_test;\n mod trans_item;"}, {"sha": "2c76cdeb48cdf7cda90d2699399560d1f5a19057", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 17, "deletions": 44, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/a517343566956fb038b061f31558f088944977c3/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a517343566956fb038b061f31558f088944977c3/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=a517343566956fb038b061f31558f088944977c3", "patch": "@@ -113,10 +113,8 @@ use rustc::session::config::NUMBERED_CODEGEN_UNIT_MARKER;\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::item_path::characteristic_def_id_of_type;\n use rustc_incremental::IchHasher;\n-use std::cmp::Ordering;\n use std::hash::Hash;\n use std::sync::Arc;\n-use symbol_cache::SymbolCache;\n use syntax::ast::NodeId;\n use syntax::symbol::{Symbol, InternedString};\n use trans_item::{TransItem, InstantiationMode};\n@@ -175,14 +173,13 @@ impl<'tcx> CodegenUnit<'tcx> {\n     }\n \n     pub fn compute_symbol_name_hash<'a>(&self,\n-                                        scx: &SharedCrateContext<'a, 'tcx>,\n-                                        symbol_cache: &SymbolCache<'a, 'tcx>)\n+                                        scx: &SharedCrateContext<'a, 'tcx>)\n                                         -> u64 {\n         let mut state = IchHasher::new();\n         let exported_symbols = scx.exported_symbols();\n-        let all_items = self.items_in_deterministic_order(scx.tcx(), symbol_cache);\n+        let all_items = self.items_in_deterministic_order(scx.tcx());\n         for (item, _) in all_items {\n-            let symbol_name = symbol_cache.get(item);\n+            let symbol_name = item.symbol_name(scx.tcx());\n             symbol_name.len().hash(&mut state);\n             symbol_name.hash(&mut state);\n             let exported = match item {\n@@ -203,53 +200,30 @@ impl<'tcx> CodegenUnit<'tcx> {\n     }\n \n     pub fn items_in_deterministic_order<'a>(&self,\n-                                            tcx: TyCtxt,\n-                                            symbol_cache: &SymbolCache<'a, 'tcx>)\n+                                            tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                             -> Vec<(TransItem<'tcx>, llvm::Linkage)> {\n-        let mut items: Vec<(TransItem<'tcx>, llvm::Linkage)> =\n-            self.items.iter().map(|(item, linkage)| (*item, *linkage)).collect();\n-\n         // The codegen tests rely on items being process in the same order as\n         // they appear in the file, so for local items, we sort by node_id first\n-        items.sort_by(|&(trans_item1, _), &(trans_item2, _)| {\n-            let node_id1 = local_node_id(tcx, trans_item1);\n-            let node_id2 = local_node_id(tcx, trans_item2);\n-\n-            match (node_id1, node_id2) {\n-                (None, None) => {\n-                    let symbol_name1 = symbol_cache.get(trans_item1);\n-                    let symbol_name2 = symbol_cache.get(trans_item2);\n-                    symbol_name1.cmp(&symbol_name2)\n-                }\n-                // In the following two cases we can avoid looking up the symbol\n-                (None, Some(_)) => Ordering::Less,\n-                (Some(_), None) => Ordering::Greater,\n-                (Some(node_id1), Some(node_id2)) => {\n-                    let ordering = node_id1.cmp(&node_id2);\n-\n-                    if ordering != Ordering::Equal {\n-                        return ordering;\n-                    }\n-\n-                    let symbol_name1 = symbol_cache.get(trans_item1);\n-                    let symbol_name2 = symbol_cache.get(trans_item2);\n-                    symbol_name1.cmp(&symbol_name2)\n-                }\n-            }\n-        });\n-\n-        return items;\n+        #[derive(PartialEq, Eq, PartialOrd, Ord)]\n+        pub struct ItemSortKey(Option<NodeId>, ty::SymbolName);\n \n-        fn local_node_id(tcx: TyCtxt, trans_item: TransItem) -> Option<NodeId> {\n-            match trans_item {\n+        fn item_sort_key<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                   item: TransItem<'tcx>) -> ItemSortKey {\n+            ItemSortKey(match item {\n                 TransItem::Fn(instance) => {\n                     tcx.hir.as_local_node_id(instance.def_id())\n                 }\n                 TransItem::Static(node_id) | TransItem::GlobalAsm(node_id) => {\n                     Some(node_id)\n                 }\n-            }\n+            }, item.symbol_name(tcx))\n         }\n+\n+        let items: Vec<_> = self.items.iter().map(|(&i, &l)| (i, l)).collect();\n+        let mut items : Vec<_> = items.iter()\n+            .map(|il| (il, item_sort_key(tcx, il.0))).collect();\n+        items.sort_by(|&(_, ref key1), &(_, ref key2)| key1.cmp(key2));\n+        items.into_iter().map(|(&item_linkage, _)| item_linkage).collect()\n     }\n }\n \n@@ -537,12 +511,11 @@ fn debug_dump<'a, 'b, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     if cfg!(debug_assertions) {\n         debug!(\"{}\", label);\n-        let symbol_cache = SymbolCache::new(tcx);\n         for cgu in cgus {\n             debug!(\"CodegenUnit {}:\", cgu.name);\n \n             for (trans_item, linkage) in &cgu.items {\n-                let symbol_name = symbol_cache.get(*trans_item);\n+                let symbol_name = trans_item.symbol_name(tcx);\n                 let symbol_hash_start = symbol_name.rfind('h');\n                 let symbol_hash = symbol_hash_start.map(|i| &symbol_name[i ..])\n                                                    .unwrap_or(\"<no hash>\");"}, {"sha": "ddc1ef537a55fcdd4fd575579758efee882301f9", "filename": "src/librustc_trans/symbol_cache.rs", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_trans%2Fsymbol_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_trans%2Fsymbol_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_cache.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -1,42 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use rustc::ty::TyCtxt;\n-use std::cell::RefCell;\n-use syntax_pos::symbol::{InternedString, Symbol};\n-use trans_item::TransItem;\n-use util::nodemap::FxHashMap;\n-\n-// In the SymbolCache we collect the symbol names of translation items\n-// and cache them for later reference. This is just a performance\n-// optimization and the cache is populated lazilly; symbol names of\n-// translation items are deterministic and fully defined by the item.\n-// Thus they can always be recomputed if needed.\n-\n-pub struct SymbolCache<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    index: RefCell<FxHashMap<TransItem<'tcx>, Symbol>>,\n-}\n-\n-impl<'a, 'tcx> SymbolCache<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n-        SymbolCache {\n-            tcx: tcx,\n-            index: RefCell::new(FxHashMap())\n-        }\n-    }\n-\n-    pub fn get(&self, trans_item: TransItem<'tcx>) -> InternedString {\n-        let mut index = self.index.borrow_mut();\n-        index.entry(trans_item)\n-             .or_insert_with(|| Symbol::intern(&trans_item.compute_symbol_name(self.tcx)))\n-             .as_str()\n-    }\n-}"}, {"sha": "85a8d501753f237cfcb363158eac5ea6df213893", "filename": "src/librustc_trans/symbol_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a517343566956fb038b061f31558f088944977c3/src%2Flibrustc_trans%2Fsymbol_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a517343566956fb038b061f31558f088944977c3/src%2Flibrustc_trans%2Fsymbol_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_map.rs?ref=a517343566956fb038b061f31558f088944977c3", "patch": "@@ -36,7 +36,7 @@ impl<'tcx> SymbolMap<'tcx> {\n         // Check for duplicate symbol names\n         let tcx = scx.tcx();\n         let mut symbols: Vec<_> = trans_items.map(|trans_item| {\n-            (trans_item, trans_item.compute_symbol_name(tcx))\n+            (trans_item, trans_item.symbol_name(tcx))\n         }).collect();\n \n         (&mut symbols[..]).sort_by(|&(_, ref sym1), &(_, ref sym2)|{\n@@ -125,7 +125,7 @@ impl<'tcx> SymbolMap<'tcx> {\n         if let Some(sym) = self.get(trans_item) {\n             Cow::from(sym)\n         } else {\n-            Cow::from(trans_item.compute_symbol_name(scx.tcx()))\n+            Cow::from(str::to_owned(&trans_item.symbol_name(scx.tcx())))\n         }\n     }\n }"}, {"sha": "d96757be9f3a5e046f9ba0f1522e4d36bfe7e879", "filename": "src/librustc_trans/symbol_names_test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a517343566956fb038b061f31558f088944977c3/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a517343566956fb038b061f31558f088944977c3/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_names_test.rs?ref=a517343566956fb038b061f31558f088944977c3", "patch": "@@ -14,7 +14,6 @@\n //! item-path. This is used for unit testing the code that generates\n //! paths etc in all kinds of annoying scenarios.\n \n-use back::symbol_names;\n use rustc::hir;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::ty::TyCtxt;\n@@ -52,7 +51,7 @@ impl<'a, 'tcx> SymbolNamesTest<'a, 'tcx> {\n             if attr.check_name(SYMBOL_NAME) {\n                 // for now, can only use on monomorphic names\n                 let instance = Instance::mono(tcx, def_id);\n-                let name = symbol_names::symbol_name(instance, self.tcx);\n+                let name = self.tcx.symbol_name(instance);\n                 tcx.sess.span_err(attr.span, &format!(\"symbol-name({})\", name));\n             } else if attr.check_name(ITEM_PATH) {\n                 let path = tcx.item_path_str(def_id);"}, {"sha": "f953db94fffba6fc988c0ae5cad8048ea20b04e4", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a517343566956fb038b061f31558f088944977c3/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a517343566956fb038b061f31558f088944977c3/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=a517343566956fb038b061f31558f088944977c3", "patch": "@@ -28,10 +28,10 @@ use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::subst::Substs;\n+use syntax_pos::symbol::Symbol;\n use syntax::ast::{self, NodeId};\n use syntax::attr;\n use type_of;\n-use back::symbol_names;\n use std::fmt::Write;\n use std::iter;\n \n@@ -118,7 +118,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                self.to_raw_string(),\n                ccx.codegen_unit().name());\n \n-        let symbol_name = ccx.symbol_cache().get(*self);\n+        let symbol_name = self.symbol_name(ccx.tcx());\n \n         debug!(\"symbol {}\", &symbol_name);\n \n@@ -184,16 +184,18 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         ccx.instances().borrow_mut().insert(instance, lldecl);\n     }\n \n-    pub fn compute_symbol_name(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n+    pub fn symbol_name(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ty::SymbolName {\n         match *self {\n-            TransItem::Fn(instance) => symbol_names::symbol_name(instance, tcx),\n+            TransItem::Fn(instance) => tcx.symbol_name(instance),\n             TransItem::Static(node_id) => {\n                 let def_id = tcx.hir.local_def_id(node_id);\n-                symbol_names::symbol_name(Instance::mono(tcx, def_id), tcx)\n+                tcx.symbol_name(Instance::mono(tcx, def_id))\n             }\n             TransItem::GlobalAsm(node_id) => {\n                 let def_id = tcx.hir.local_def_id(node_id);\n-                format!(\"global_asm_{:?}\", def_id)\n+                ty::SymbolName {\n+                    name: Symbol::intern(&format!(\"global_asm_{:?}\", def_id)).as_str()\n+                }\n             }\n         }\n     }"}]}