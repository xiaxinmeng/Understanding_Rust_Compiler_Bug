{"sha": "2d1aa57d1e05d1d745aaf864965eebd1fd8d6071", "node_id": "C_kwDOAAsO6NoAKDJkMWFhNTdkMWUwNWQxZDc0NWFhZjg2NDk2NWVlYmQxZmQ4ZDYwNzE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-16T09:57:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-16T09:57:32Z"}, "message": "Auto merge of #101860 - oli-obk:information_throwing, r=compiler-errors\n\nDon't throw away information just to recompute it again\n\nalso allows making some functions private.", "tree": {"sha": "a3623255ec649d1ee8d9e411b1f8135bc57c4267", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3623255ec649d1ee8d9e411b1f8135bc57c4267"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d1aa57d1e05d1d745aaf864965eebd1fd8d6071", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d1aa57d1e05d1d745aaf864965eebd1fd8d6071", "html_url": "https://github.com/rust-lang/rust/commit/2d1aa57d1e05d1d745aaf864965eebd1fd8d6071", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d1aa57d1e05d1d745aaf864965eebd1fd8d6071/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22f6aec42de6bce63f8e43f144058428d4dba0f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/22f6aec42de6bce63f8e43f144058428d4dba0f5", "html_url": "https://github.com/rust-lang/rust/commit/22f6aec42de6bce63f8e43f144058428d4dba0f5"}, {"sha": "8aed75bee0734b4b8e5eac3c0256e8fe6c1b6296", "url": "https://api.github.com/repos/rust-lang/rust/commits/8aed75bee0734b4b8e5eac3c0256e8fe6c1b6296", "html_url": "https://github.com/rust-lang/rust/commit/8aed75bee0734b4b8e5eac3c0256e8fe6c1b6296"}], "stats": {"total": 48, "additions": 22, "deletions": 26}, "files": [{"sha": "0002d37753688d2e6ea12d66efd4093de049e143", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2d1aa57d1e05d1d745aaf864965eebd1fd8d6071/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1aa57d1e05d1d745aaf864965eebd1fd8d6071/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=2d1aa57d1e05d1d745aaf864965eebd1fd8d6071", "patch": "@@ -1022,7 +1022,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         cause: &ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         predicate: ty::PolyCoercePredicate<'tcx>,\n-    ) -> Option<InferResult<'tcx, ()>> {\n+    ) -> Result<InferResult<'tcx, ()>, (TyVid, TyVid)> {\n         let subtype_predicate = predicate.map_bound(|p| ty::SubtypePredicate {\n             a_is_expected: false, // when coercing from `a` to `b`, `b` is expected\n             a: p.a,\n@@ -1036,7 +1036,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         cause: &ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         predicate: ty::PolySubtypePredicate<'tcx>,\n-    ) -> Option<InferResult<'tcx, ()>> {\n+    ) -> Result<InferResult<'tcx, ()>, (TyVid, TyVid)> {\n         // Check for two unresolved inference variables, in which case we can\n         // make no progress. This is partly a micro-optimization, but it's\n         // also an opportunity to \"sub-unify\" the variables. This isn't\n@@ -1055,12 +1055,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         match (r_a.kind(), r_b.kind()) {\n             (&ty::Infer(ty::TyVar(a_vid)), &ty::Infer(ty::TyVar(b_vid))) => {\n                 self.inner.borrow_mut().type_variables().sub(a_vid, b_vid);\n-                return None;\n+                return Err((a_vid, b_vid));\n             }\n             _ => {}\n         }\n \n-        Some(self.commit_if_ok(|_snapshot| {\n+        Ok(self.commit_if_ok(|_snapshot| {\n             let ty::SubtypePredicate { a_is_expected, a, b } =\n                 self.replace_bound_vars_with_placeholders(predicate);\n \n@@ -1848,7 +1848,7 @@ impl<'tcx> TyOrConstInferVar<'tcx> {\n \n     /// Tries to extract an inference variable from a type, returns `None`\n     /// for types other than `ty::Infer(_)` (or `InferTy::Fresh*`).\n-    pub fn maybe_from_ty(ty: Ty<'tcx>) -> Option<Self> {\n+    fn maybe_from_ty(ty: Ty<'tcx>) -> Option<Self> {\n         match *ty.kind() {\n             ty::Infer(ty::TyVar(v)) => Some(TyOrConstInferVar::Ty(v)),\n             ty::Infer(ty::IntVar(v)) => Some(TyOrConstInferVar::TyInt(v)),\n@@ -1859,7 +1859,7 @@ impl<'tcx> TyOrConstInferVar<'tcx> {\n \n     /// Tries to extract an inference variable from a constant, returns `None`\n     /// for constants other than `ty::ConstKind::Infer(_)` (or `InferConst::Fresh`).\n-    pub fn maybe_from_const(ct: ty::Const<'tcx>) -> Option<Self> {\n+    fn maybe_from_const(ct: ty::Const<'tcx>) -> Option<Self> {\n         match ct.kind() {\n             ty::ConstKind::Infer(InferConst::Var(v)) => Some(TyOrConstInferVar::Const(v)),\n             _ => None,"}, {"sha": "656c2b0c3e3814115a34da2d76321f0c5be1c96b", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2d1aa57d1e05d1d745aaf864965eebd1fd8d6071/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1aa57d1e05d1d745aaf864965eebd1fd8d6071/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=2d1aa57d1e05d1d745aaf864965eebd1fd8d6071", "patch": "@@ -427,16 +427,14 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                         obligation.param_env,\n                         Binder::dummy(subtype),\n                     ) {\n-                        None => {\n+                        Err((a, b)) => {\n                             // None means that both are unresolved.\n-                            pending_obligation.stalled_on = vec![\n-                                TyOrConstInferVar::maybe_from_ty(subtype.a).unwrap(),\n-                                TyOrConstInferVar::maybe_from_ty(subtype.b).unwrap(),\n-                            ];\n+                            pending_obligation.stalled_on =\n+                                vec![TyOrConstInferVar::Ty(a), TyOrConstInferVar::Ty(b)];\n                             ProcessResult::Unchanged\n                         }\n-                        Some(Ok(ok)) => ProcessResult::Changed(mk_pending(ok.obligations)),\n-                        Some(Err(err)) => {\n+                        Ok(Ok(ok)) => ProcessResult::Changed(mk_pending(ok.obligations)),\n+                        Ok(Err(err)) => {\n                             let expected_found =\n                                 ExpectedFound::new(subtype.a_is_expected, subtype.a, subtype.b);\n                             ProcessResult::Error(FulfillmentErrorCode::CodeSubtypeError(\n@@ -453,16 +451,14 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                         obligation.param_env,\n                         Binder::dummy(coerce),\n                     ) {\n-                        None => {\n+                        Err((a, b)) => {\n                             // None means that both are unresolved.\n-                            pending_obligation.stalled_on = vec![\n-                                TyOrConstInferVar::maybe_from_ty(coerce.a).unwrap(),\n-                                TyOrConstInferVar::maybe_from_ty(coerce.b).unwrap(),\n-                            ];\n+                            pending_obligation.stalled_on =\n+                                vec![TyOrConstInferVar::Ty(a), TyOrConstInferVar::Ty(b)];\n                             ProcessResult::Unchanged\n                         }\n-                        Some(Ok(ok)) => ProcessResult::Changed(mk_pending(ok.obligations)),\n-                        Some(Err(err)) => {\n+                        Ok(Ok(ok)) => ProcessResult::Changed(mk_pending(ok.obligations)),\n+                        Ok(Err(err)) => {\n                             let expected_found = ExpectedFound::new(false, coerce.a, coerce.b);\n                             ProcessResult::Error(FulfillmentErrorCode::CodeSubtypeError(\n                                 expected_found,"}, {"sha": "6cd3d54cbf6a74314912d1edf011143156d656f0", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2d1aa57d1e05d1d745aaf864965eebd1fd8d6071/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1aa57d1e05d1d745aaf864965eebd1fd8d6071/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=2d1aa57d1e05d1d745aaf864965eebd1fd8d6071", "patch": "@@ -462,31 +462,31 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     let p = bound_predicate.rebind(p);\n                     // Does this code ever run?\n                     match self.infcx.subtype_predicate(&obligation.cause, obligation.param_env, p) {\n-                        Some(Ok(InferOk { mut obligations, .. })) => {\n+                        Ok(Ok(InferOk { mut obligations, .. })) => {\n                             self.add_depth(obligations.iter_mut(), obligation.recursion_depth);\n                             self.evaluate_predicates_recursively(\n                                 previous_stack,\n                                 obligations.into_iter(),\n                             )\n                         }\n-                        Some(Err(_)) => Ok(EvaluatedToErr),\n-                        None => Ok(EvaluatedToAmbig),\n+                        Ok(Err(_)) => Ok(EvaluatedToErr),\n+                        Err(..) => Ok(EvaluatedToAmbig),\n                     }\n                 }\n \n                 ty::PredicateKind::Coerce(p) => {\n                     let p = bound_predicate.rebind(p);\n                     // Does this code ever run?\n                     match self.infcx.coerce_predicate(&obligation.cause, obligation.param_env, p) {\n-                        Some(Ok(InferOk { mut obligations, .. })) => {\n+                        Ok(Ok(InferOk { mut obligations, .. })) => {\n                             self.add_depth(obligations.iter_mut(), obligation.recursion_depth);\n                             self.evaluate_predicates_recursively(\n                                 previous_stack,\n                                 obligations.into_iter(),\n                             )\n                         }\n-                        Some(Err(_)) => Ok(EvaluatedToErr),\n-                        None => Ok(EvaluatedToAmbig),\n+                        Ok(Err(_)) => Ok(EvaluatedToErr),\n+                        Err(..) => Ok(EvaluatedToAmbig),\n                     }\n                 }\n "}]}