{"sha": "8301de16dafc81a3b5d94aa0707ad83bdb56a599", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzMDFkZTE2ZGFmYzgxYTNiNWQ5NGFhMDcwN2FkODNiZGI1NmE1OTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-03T03:47:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-03T03:47:47Z"}, "message": "Auto merge of #61775 - nikomatsakis:issue-56238-multiple-lifetimes-async-fn-region-solver, r=MatthewJasper\n\ngeneralize impl trait to permit multiple lifetime bounds\n\nGeneralizes the region solver to support \"pick constraints\". These have the form:\n\n```\npick R0 from [R1..Rn]\n```\n\nwhere `R1..Rn` are called the \"option regions\". The idea is that `R0` must be equal to *some* region in the set `R1..Rn`. These constraints are then used to handle cases like this:\n\n```rust\nfn foo<'a, 'b>(...) -> impl Trait<'a, 'b> { .. }\n```\n\nThe problem here is that every region R in the hidden type must be equal to *either* `'a` *or* `'b` (or `'static`) -- in the past, the only kinds of constraints we had were outlives constraints, and since `'a` and `'b` are unrelated, there was no outlives constraint we could issue that would enforce that (`R: 'a` and `R: 'b` are both too strict, for example). But now we can issue a pick constraint: `pick R from ['a, 'b]`.\n\nIn general, solving pick constraints is tricky. We integrate them into the solver as follows. In general, during the propagation phase, we are monotonically growing a set of inference regions. To handle a case like `pick R from [O...]`, where `O...` represents the option regions, we do the following:\n\n- Look for all the *lower bounds* of the region R -- that is, every region LB such that `R: LB` must hold.\n- Look for all the *upper bounds* of the region R -- that is, every region UB such that `UB: R` must hold.\n- Let the *viable options* be each option region O such that `UB: O` and `O: LB` for each UB, LB bound.\n- Find the *minimal viable option* M, where `O: M` holds for every option region O.\n\nIf there is such a *minimal viable option*, then we make `R: M`. (This may in turn influence other bits of inference.) If there is no minimal viable option, either because all options were eliminated or because none of the remaining options are minimal, we do nothing. Ultimately, if the pick constraint is not satisfied, an error is reported.\n\nFor this logic, we currently require that the option regions O are always lifetime parameters. To determine the bounds, we walk the various outlives edges that were otherwise introduced.\n\nr? @matthewjasper\ncc @cramertj\n\nFixes #56238\n\nTODO:\n\n- [ ] Error messages include region variable info sometimes, how to fix?\n- [ ] Tests for bare `existential type`  and other impl Trait usage", "tree": {"sha": "5fcea49a0e1f65c8598815e4bf16e05dcaf04700", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5fcea49a0e1f65c8598815e4bf16e05dcaf04700"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8301de16dafc81a3b5d94aa0707ad83bdb56a599", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8301de16dafc81a3b5d94aa0707ad83bdb56a599", "html_url": "https://github.com/rust-lang/rust/commit/8301de16dafc81a3b5d94aa0707ad83bdb56a599", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8301de16dafc81a3b5d94aa0707ad83bdb56a599/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0beb2ba16a08dfa01569b5f4644da315dc4c806c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0beb2ba16a08dfa01569b5f4644da315dc4c806c", "html_url": "https://github.com/rust-lang/rust/commit/0beb2ba16a08dfa01569b5f4644da315dc4c806c"}, {"sha": "f7e00a55bba51de1d58f829b562f9aff05d543f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7e00a55bba51de1d58f829b562f9aff05d543f3", "html_url": "https://github.com/rust-lang/rust/commit/f7e00a55bba51de1d58f829b562f9aff05d543f3"}], "stats": {"total": 3128, "additions": 2580, "deletions": 548}, "files": [{"sha": "0d11c31aca6e956ab91f3fff9e5e82f9f1b89f23", "filename": "src/doc/unstable-book/src/language-features/member-constraints.md", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmember-constraints.md", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmember-constraints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmember-constraints.md?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,29 @@\n+# `member_constraints`\n+\n+The tracking issue for this feature is: [#61977]\n+\n+[#61977]: https://github.com/rust-lang/rust/issues/61977\n+\n+------------------------\n+\n+The `member_constraints` feature gate lets you use `impl Trait` syntax with\n+multiple unrelated lifetime parameters.\n+\n+A simple example is:\n+\n+```rust\n+#![feature(member_constraints)]\n+\n+trait Trait<'a, 'b> { }\n+impl<T> Trait<'_, '_> for T {}\n+\n+fn foo<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Trait<'a, 'b> {\n+  (x, y)\n+}\n+\n+fn main() { }\n+```\n+\n+Without the `member_constraints` feature gate, the above example is an\n+error because both `'a` and `'b` appear in the impl Trait bounds, but\n+neither outlives the other."}, {"sha": "b508f91e01ebb22905053676a4c7ba5a33419547", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -23,6 +23,7 @@\n \n use crate::infer::{InferCtxt, RegionVariableOrigin, TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::{ConstVariableOrigin, ConstVariableOriginKind};\n+use crate::infer::region_constraints::MemberConstraint;\n use crate::mir::interpret::ConstValue;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_macros::HashStable;\n@@ -189,11 +190,25 @@ pub enum CanonicalTyVarKind {\n #[derive(Clone, Debug, HashStable)]\n pub struct QueryResponse<'tcx, R> {\n     pub var_values: CanonicalVarValues<'tcx>,\n-    pub region_constraints: Vec<QueryRegionConstraint<'tcx>>,\n+    pub region_constraints: QueryRegionConstraints<'tcx>,\n     pub certainty: Certainty,\n     pub value: R,\n }\n \n+#[derive(Clone, Debug, Default, HashStable)]\n+pub struct QueryRegionConstraints<'tcx> {\n+    pub outlives: Vec<QueryOutlivesConstraint<'tcx>>,\n+    pub member_constraints: Vec<MemberConstraint<'tcx>>,\n+}\n+\n+impl QueryRegionConstraints<'_> {\n+    /// Represents an empty (trivially true) set of region\n+    /// constraints.\n+    pub fn is_empty(&self) -> bool {\n+        self.outlives.is_empty() && self.member_constraints.is_empty()\n+    }\n+}\n+\n pub type Canonicalized<'tcx, V> = Canonical<'tcx, V>;\n \n pub type CanonicalizedQueryResponse<'tcx, T> =\n@@ -292,7 +307,8 @@ impl<'tcx, V> Canonical<'tcx, V> {\n     }\n }\n \n-pub type QueryRegionConstraint<'tcx> = ty::Binder<ty::OutlivesPredicate<Kind<'tcx>, Region<'tcx>>>;\n+pub type QueryOutlivesConstraint<'tcx> =\n+    ty::Binder<ty::OutlivesPredicate<Kind<'tcx>, Region<'tcx>>>;\n \n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// Creates a substitution S for the canonical value with fresh\n@@ -540,6 +556,19 @@ BraceStructLiftImpl! {\n     } where R: Lift<'tcx>\n }\n \n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for QueryRegionConstraints<'tcx> {\n+        outlives, member_constraints\n+    }\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for QueryRegionConstraints<'a> {\n+        type Lifted = QueryRegionConstraints<'tcx>;\n+        outlives, member_constraints\n+    }\n+}\n+\n impl<'tcx> Index<BoundVar> for CanonicalVarValues<'tcx> {\n     type Output = Kind<'tcx>;\n "}, {"sha": "79c5538626be191f80eba1c5671db8b8f56892fd", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -11,7 +11,7 @@ use crate::arena::ArenaAllocatable;\n use crate::infer::canonical::substitute::substitute_value;\n use crate::infer::canonical::{\n     Canonical, CanonicalVarValues, CanonicalizedQueryResponse, Certainty,\n-    OriginalQueryValues, QueryRegionConstraint, QueryResponse,\n+    OriginalQueryValues, QueryRegionConstraints, QueryOutlivesConstraint, QueryResponse,\n };\n use crate::infer::region_constraints::{Constraint, RegionConstraintData};\n use crate::infer::InferCtxtBuilder;\n@@ -132,7 +132,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     {\n         self.canonicalize_response(&QueryResponse {\n             var_values: inference_vars,\n-            region_constraints: vec![],\n+            region_constraints: QueryRegionConstraints::default(),\n             certainty: Certainty::Proven, // Ambiguities are OK!\n             value: answer,\n         })\n@@ -174,7 +174,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n \n         let region_obligations = self.take_registered_region_obligations();\n         let region_constraints = self.with_region_constraints(|region_constraints| {\n-            make_query_outlives(\n+            make_query_region_constraints(\n                 tcx,\n                 region_obligations\n                     .iter()\n@@ -222,10 +222,10 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n             mut obligations,\n         } = self.query_response_substitution(cause, param_env, original_values, query_response)?;\n \n-        obligations.extend(self.query_region_constraints_into_obligations(\n+        obligations.extend(self.query_outlives_constraints_into_obligations(\n             cause,\n             param_env,\n-            &query_response.value.region_constraints,\n+            &query_response.value.region_constraints.outlives,\n             &result_subst,\n         ));\n \n@@ -248,9 +248,9 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// that come out of these queries, which it wants to convert into\n     /// MIR-based constraints and solve. Therefore, it is most\n     /// convenient for the NLL Type Checker to **directly consume**\n-    /// the `QueryRegionConstraint` values that arise from doing a\n+    /// the `QueryOutlivesConstraint` values that arise from doing a\n     /// query. This is contrast to other parts of the compiler, which\n-    /// would prefer for those `QueryRegionConstraint` to be converted\n+    /// would prefer for those `QueryOutlivesConstraint` to be converted\n     /// into the older infcx-style constraints (e.g., calls to\n     /// `sub_regions` or `register_region_obligation`).\n     ///\n@@ -263,7 +263,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     ///   result. If any errors arise, they are propagated back as an\n     ///   `Err` result.\n     /// - In the case of a successful substitution, we will append\n-    ///   `QueryRegionConstraint` values onto the\n+    ///   `QueryOutlivesConstraint` values onto the\n     ///   `output_query_region_constraints` vector for the solver to\n     ///   use (if an error arises, some values may also be pushed, but\n     ///   they should be ignored).\n@@ -279,15 +279,15 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         original_values: &OriginalQueryValues<'tcx>,\n         query_response: &Canonical<'tcx, QueryResponse<'tcx, R>>,\n-        output_query_region_constraints: &mut Vec<QueryRegionConstraint<'tcx>>,\n+        output_query_region_constraints: &mut QueryRegionConstraints<'tcx>,\n     ) -> InferResult<'tcx, R>\n     where\n         R: Debug + TypeFoldable<'tcx>,\n     {\n         let result_subst =\n             self.query_response_substitution_guess(cause, original_values, query_response);\n \n-        // Compute `QueryRegionConstraint` values that unify each of\n+        // Compute `QueryOutlivesConstraint` values that unify each of\n         // the original values `v_o` that was canonicalized into a\n         // variable...\n         let mut obligations = vec![];\n@@ -306,8 +306,10 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                     // To make `v_o = v_r`, we emit `v_o: v_r` and `v_r: v_o`.\n                     if v_o != v_r {\n                         output_query_region_constraints\n+                            .outlives\n                             .push(ty::Binder::dummy(ty::OutlivesPredicate(v_o.into(), v_r)));\n                         output_query_region_constraints\n+                            .outlives\n                             .push(ty::Binder::dummy(ty::OutlivesPredicate(v_r.into(), v_o)));\n                     }\n                 }\n@@ -333,12 +335,12 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         }\n \n         // ...also include the other query region constraints from the query.\n-        output_query_region_constraints.extend(\n-            query_response.value.region_constraints.iter().filter_map(|r_c| {\n+        output_query_region_constraints.outlives.extend(\n+            query_response.value.region_constraints.outlives.iter().filter_map(|r_c| {\n                 let r_c = substitute_value(self.tcx, &result_subst, r_c);\n \n                 // Screen out `'a: 'a` cases -- we skip the binder here but\n-                // only care the inner values to one another, so they are still at\n+                // only compare the inner values to one another, so they are still at\n                 // consistent binding levels.\n                 let &ty::OutlivesPredicate(k1, r2) = r_c.skip_binder();\n                 if k1 != r2.into() {\n@@ -349,6 +351,13 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n             })\n         );\n \n+        // ...also include the query member constraints.\n+        output_query_region_constraints.member_constraints.extend(\n+            query_response.value.region_constraints.member_constraints.iter().map(|p_c| {\n+                substitute_value(self.tcx, &result_subst, p_c)\n+            })\n+        );\n+\n         let user_result: R =\n             query_response.substitute_projected(self.tcx, &result_subst, |q_r| &q_r.value);\n \n@@ -560,11 +569,11 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n \n     /// Converts the region constraints resulting from a query into an\n     /// iterator of obligations.\n-    fn query_region_constraints_into_obligations<'a>(\n+    fn query_outlives_constraints_into_obligations<'a>(\n         &'a self,\n         cause: &'a ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        unsubstituted_region_constraints: &'a [QueryRegionConstraint<'tcx>],\n+        unsubstituted_region_constraints: &'a [QueryOutlivesConstraint<'tcx>],\n         result_subst: &'a CanonicalVarValues<'tcx>,\n     ) -> impl Iterator<Item = PredicateObligation<'tcx>> + 'a + Captures<'tcx> {\n         unsubstituted_region_constraints\n@@ -645,15 +654,16 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n \n /// Given the region obligations and constraints scraped from the infcx,\n /// creates query region constraints.\n-pub fn make_query_outlives<'tcx>(\n+pub fn make_query_region_constraints<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     outlives_obligations: impl Iterator<Item = (Ty<'tcx>, ty::Region<'tcx>)>,\n     region_constraints: &RegionConstraintData<'tcx>,\n-) -> Vec<QueryRegionConstraint<'tcx>> {\n+) -> QueryRegionConstraints<'tcx> {\n     let RegionConstraintData {\n         constraints,\n         verifys,\n         givens,\n+        member_constraints,\n     } = region_constraints;\n \n     assert!(verifys.is_empty());\n@@ -684,5 +694,5 @@ pub fn make_query_outlives<'tcx>(\n         )\n         .collect();\n \n-    outlives\n+    QueryRegionConstraints { outlives, member_constraints: member_constraints.clone() }\n }"}, {"sha": "cbfb048c064a2c2e4d3b91d72c632bf1cfb9f402", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -53,6 +53,7 @@ use crate::infer::{self, SuppressRegionErrors};\n use crate::hir;\n use crate::hir::def_id::DefId;\n use crate::hir::Node;\n+use crate::infer::opaque_types;\n use crate::middle::region;\n use crate::traits::{ObligationCause, ObligationCauseCode};\n use crate::ty::error::TypeError;\n@@ -375,6 +376,23 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             );\n                         }\n                     }\n+\n+                    RegionResolutionError::MemberConstraintFailure {\n+                        opaque_type_def_id,\n+                        hidden_ty,\n+                        member_region,\n+                        span: _,\n+                        choice_regions: _,\n+                    } => {\n+                        let hidden_ty = self.resolve_vars_if_possible(&hidden_ty);\n+                        opaque_types::unexpected_hidden_region_diagnostic(\n+                            self.tcx,\n+                            Some(region_scope_tree),\n+                            opaque_type_def_id,\n+                            hidden_ty,\n+                            member_region,\n+                        ).emit();\n+                    }\n                 }\n             }\n         }\n@@ -411,7 +429,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let is_bound_failure = |e: &RegionResolutionError<'tcx>| match *e {\n             RegionResolutionError::GenericBoundFailure(..) => true,\n             RegionResolutionError::ConcreteFailure(..)\n-            | RegionResolutionError::SubSupConflict(..) => false,\n+                | RegionResolutionError::SubSupConflict(..)\n+                | RegionResolutionError::MemberConstraintFailure { .. } => false,\n         };\n \n         let mut errors = if errors.iter().all(|e| is_bound_failure(e)) {\n@@ -429,6 +448,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             RegionResolutionError::ConcreteFailure(ref sro, _, _) => sro.span(),\n             RegionResolutionError::GenericBoundFailure(ref sro, _, _) => sro.span(),\n             RegionResolutionError::SubSupConflict(_, ref rvo, _, _, _, _) => rvo.span(),\n+            RegionResolutionError::MemberConstraintFailure { span, .. } => span,\n         });\n         errors\n     }"}, {"sha": "d06c4434b3aaf8d4a1b5c9eb003ce63e188dd97c", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 238, "deletions": 103, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -1,26 +1,28 @@\n //! Lexical region resolution.\n \n+use crate::hir::def_id::DefId;\n use crate::infer::region_constraints::Constraint;\n use crate::infer::region_constraints::GenericKind;\n+use crate::infer::region_constraints::MemberConstraint;\n use crate::infer::region_constraints::RegionConstraintData;\n use crate::infer::region_constraints::VarInfos;\n use crate::infer::region_constraints::VerifyBound;\n use crate::infer::RegionVariableOrigin;\n use crate::infer::SubregionOrigin;\n use crate::middle::free_region::RegionRelations;\n+use crate::ty::fold::TypeFoldable;\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::{ReEarlyBound, ReEmpty, ReErased, ReFree, ReStatic};\n+use crate::ty::{ReLateBound, RePlaceholder, ReScope, ReVar};\n+use crate::ty::{Region, RegionVid};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::implementation::{\n     Direction, Graph, NodeIndex, INCOMING, OUTGOING,\n };\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use smallvec::SmallVec;\n use std::fmt;\n-use std::u32;\n-use crate::ty::fold::TypeFoldable;\n-use crate::ty::{self, Ty, TyCtxt};\n-use crate::ty::{ReEarlyBound, ReEmpty, ReErased, ReFree, ReStatic};\n-use crate::ty::{ReLateBound, ReScope, RePlaceholder, ReVar};\n-use crate::ty::{Region, RegionVid};\n+use syntax_pos::Span;\n \n mod graphviz;\n \n@@ -36,11 +38,7 @@ pub fn resolve<'tcx>(\n ) -> (LexicalRegionResolutions<'tcx>, Vec<RegionResolutionError<'tcx>>) {\n     debug!(\"RegionConstraintData: resolve_regions()\");\n     let mut errors = vec![];\n-    let mut resolver = LexicalResolver {\n-        region_rels,\n-        var_infos,\n-        data,\n-    };\n+    let mut resolver = LexicalResolver { region_rels, var_infos, data };\n     let values = resolver.infer_variable_values(&mut errors);\n     (values, errors)\n }\n@@ -84,6 +82,17 @@ pub enum RegionResolutionError<'tcx> {\n         SubregionOrigin<'tcx>,\n         Region<'tcx>,\n     ),\n+\n+    /// Indicates a failure of a `MemberConstraint`. These arise during\n+    /// impl trait processing explicitly -- basically, the impl trait's hidden type\n+    /// included some region that it was not supposed to.\n+    MemberConstraintFailure {\n+        span: Span,\n+        opaque_type_def_id: DefId,\n+        hidden_ty: Ty<'tcx>,\n+        member_region: Region<'tcx>,\n+        choice_regions: Vec<Region<'tcx>>,\n+    },\n }\n \n struct RegionAndOrigin<'tcx> {\n@@ -121,7 +130,12 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n         let graph = self.construct_graph();\n         self.expand_givens(&graph);\n-        self.expansion(&mut var_data);\n+        loop {\n+            self.expansion(&mut var_data);\n+            if !self.enforce_member_constraints(&graph, &mut var_data) {\n+                break;\n+            }\n+        }\n         self.collect_errors(&mut var_data, errors);\n         self.collect_var_errors(&var_data, &graph, errors);\n         var_data\n@@ -136,7 +150,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     fn construct_var_data(&self, tcx: TyCtxt<'tcx>) -> LexicalRegionResolutions<'tcx> {\n         LexicalRegionResolutions {\n             error_region: tcx.lifetimes.re_static,\n-            values: IndexVec::from_elem_n(VarValue::Value(tcx.lifetimes.re_empty), self.num_vars())\n+            values: IndexVec::from_elem_n(VarValue::Value(tcx.lifetimes.re_empty), self.num_vars()),\n         }\n     }\n \n@@ -182,6 +196,113 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n     }\n \n+    /// Enforce all member constraints and return true if anything\n+    /// changed. See `enforce_member_constraint` for more details.\n+    fn enforce_member_constraints(\n+        &self,\n+        graph: &RegionGraph<'tcx>,\n+        var_values: &mut LexicalRegionResolutions<'tcx>,\n+    ) -> bool {\n+        // Note: we don't use the `any` combinator because we don't\n+        // want to stop at the first constraint that makes a change.\n+        let mut any_changed = false;\n+        for member_constraint in &self.data.member_constraints {\n+            if self.enforce_member_constraint(graph, member_constraint, var_values) {\n+                any_changed = true;\n+            }\n+        }\n+        any_changed\n+    }\n+\n+    /// Enforce a constraint like\n+    ///\n+    /// ```\n+    /// 'r member of ['c...]\n+    /// ```\n+    ///\n+    /// We look for all choice regions from the list `'c...` that:\n+    ///\n+    /// (a) are greater than the current value of `'r` (which is a lower bound)\n+    ///\n+    /// and\n+    ///\n+    /// (b) are compatible with the upper bounds of `'r` that we can\n+    /// find by traversing the graph.\n+    ///\n+    /// From that list, we look for a *minimal* option `'c_min`. If we\n+    /// find one, then we can enforce that `'r: 'c_min`.\n+    fn enforce_member_constraint(\n+        &self,\n+        graph: &RegionGraph<'tcx>,\n+        member_constraint: &MemberConstraint<'tcx>,\n+        var_values: &mut LexicalRegionResolutions<'tcx>,\n+    ) -> bool {\n+        debug!(\"enforce_member_constraint(member_constraint={:#?})\", member_constraint);\n+\n+        // The constraint is some inference variable (`vid`) which\n+        // must be equal to one of the options.\n+        let member_vid = match member_constraint.member_region {\n+            ty::ReVar(vid) => *vid,\n+            _ => return false,\n+        };\n+\n+        // The current value of `vid` is a lower bound LB -- i.e., we\n+        // know that `LB <= vid` must be true.\n+        let member_lower_bound: ty::Region<'tcx> = match var_values.value(member_vid) {\n+            VarValue::ErrorValue => return false,\n+            VarValue::Value(r) => r,\n+        };\n+\n+        // Find all the \"upper bounds\" -- that is, each region `b` such that\n+        // `r0 <= b` must hold.\n+        let (member_upper_bounds, _) = self.collect_concrete_regions(\n+            graph,\n+            member_vid,\n+            OUTGOING,\n+            None,\n+        );\n+\n+        // Get an iterator over the *available choice* -- that is,\n+        // each choice region `c` where `lb <= c` and `c <= ub` for all the\n+        // upper bounds `ub`.\n+        debug!(\"enforce_member_constraint: upper_bounds={:#?}\", member_upper_bounds);\n+        let mut options = member_constraint.choice_regions.iter().filter(|option| {\n+            self.sub_concrete_regions(member_lower_bound, option)\n+                && member_upper_bounds\n+                    .iter()\n+                    .all(|upper_bound| self.sub_concrete_regions(option, upper_bound.region))\n+        });\n+\n+        // If there is more than one option, we only make a choice if\n+        // there is a single *least* choice -- i.e., some available\n+        // region that is `<=` all the others.\n+        let mut least_choice: ty::Region<'tcx> = match options.next() {\n+            Some(&r) => r,\n+            None => return false,\n+        };\n+        debug!(\"enforce_member_constraint: least_choice={:?}\", least_choice);\n+        for &option in options {\n+            debug!(\"enforce_member_constraint: option={:?}\", option);\n+            if !self.sub_concrete_regions(least_choice, option) {\n+                if self.sub_concrete_regions(option, least_choice) {\n+                    debug!(\"enforce_member_constraint: new least choice\");\n+                    least_choice = option;\n+                } else {\n+                    debug!(\"enforce_member_constraint: no least choice\");\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        debug!(\"enforce_member_constraint: final least choice = {:?}\", least_choice);\n+        if least_choice != member_lower_bound {\n+            *var_values.value_mut(member_vid) = VarValue::Value(least_choice);\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n     fn expansion(&self, var_values: &mut LexicalRegionResolutions<'tcx>) {\n         self.iterate_until_fixed_point(\"Expansion\", |constraint| {\n             debug!(\"expansion: constraint={:?}\", constraint);\n@@ -196,15 +317,15 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                         let b_data = var_values.value_mut(b_vid);\n                         let retain = match *b_data {\n                             VarValue::Value(ReStatic) | VarValue::ErrorValue => false,\n-                            _ => true\n+                            _ => true,\n                         };\n                         (a_region, b_vid, b_data, retain)\n                     }\n                 },\n                 Constraint::RegSubReg(..) | Constraint::VarSubReg(..) => {\n                     // These constraints are checked after expansion\n                     // is done, in `collect_errors`.\n-                    return (false, false)\n+                    return (false, false);\n                 }\n             };\n \n@@ -226,16 +347,16 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n         match *a_region {\n             // Check if this relationship is implied by a given.\n-            ty::ReEarlyBound(_) | ty::ReFree(_) => if self.data.givens.contains(&(a_region, b_vid))\n-            {\n-                debug!(\"given\");\n-                return false;\n-            },\n+            ty::ReEarlyBound(_) | ty::ReFree(_) => {\n+                if self.data.givens.contains(&(a_region, b_vid)) {\n+                    debug!(\"given\");\n+                    return false;\n+                }\n+            }\n \n             _ => {}\n         }\n \n-\n         match *b_data {\n             VarValue::Value(cur_region) => {\n                 // Identical scopes can show up quite often, if the fixed point\n@@ -267,10 +388,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                     }\n                 }\n \n-                debug!(\n-                    \"Expanding value of {:?} from {:?} to {:?}\",\n-                    b_vid, cur_region, lub\n-                );\n+                debug!(\"Expanding value of {:?} from {:?} to {:?}\", b_vid, cur_region, lub);\n \n                 *b_data = VarValue::Value(lub);\n                 return true;\n@@ -282,6 +400,12 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n     }\n \n+    /// True if `a <= b`, but not defined over inference variables.\n+    fn sub_concrete_regions(&self, a: Region<'tcx>, b: Region<'tcx>) -> bool {\n+        self.lub_concrete_regions(a, b) == b\n+    }\n+\n+    /// Returns the smallest region `c` such that `a <= c` and `b <= c`.\n     fn lub_concrete_regions(&self, a: Region<'tcx>, b: Region<'tcx>) -> Region<'tcx> {\n         let tcx = self.tcx();\n \n@@ -321,17 +445,16 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 // at least as big as fr.scope\".  So, we can\n                 // reasonably compare free regions and scopes:\n                 let fr_scope = match (a, b) {\n-                    (&ReEarlyBound(ref br), _) | (_, &ReEarlyBound(ref br)) => self.region_rels\n-                        .region_scope_tree\n-                        .early_free_scope(self.tcx(), br),\n-                    (&ReFree(ref fr), _) | (_, &ReFree(ref fr)) => self.region_rels\n-                        .region_scope_tree\n-                        .free_scope(self.tcx(), fr),\n+                    (&ReEarlyBound(ref br), _) | (_, &ReEarlyBound(ref br)) => {\n+                        self.region_rels.region_scope_tree.early_free_scope(self.tcx(), br)\n+                    }\n+                    (&ReFree(ref fr), _) | (_, &ReFree(ref fr)) => {\n+                        self.region_rels.region_scope_tree.free_scope(self.tcx(), fr)\n+                    }\n                     _ => bug!(),\n                 };\n-                let r_id = self.region_rels\n-                    .region_scope_tree\n-                    .nearest_common_ancestor(fr_scope, s_id);\n+                let r_id =\n+                    self.region_rels.region_scope_tree.nearest_common_ancestor(fr_scope, s_id);\n                 if r_id == fr_scope {\n                     // if the free region's scope `fr.scope` is bigger than\n                     // the scope region `s_id`, then the LUB is the free\n@@ -352,9 +475,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 // The region corresponding to an outer block is a\n                 // subtype of the region corresponding to an inner\n                 // block.\n-                let lub = self.region_rels\n-                    .region_scope_tree\n-                    .nearest_common_ancestor(a_id, b_id);\n+                let lub = self.region_rels.region_scope_tree.nearest_common_ancestor(a_id, b_id);\n                 tcx.mk_region(ReScope(lub))\n             }\n \n@@ -365,11 +486,13 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n             // For these types, we cannot define any additional\n             // relationship:\n-            (&RePlaceholder(..), _) | (_, &RePlaceholder(..)) => if a == b {\n-                a\n-            } else {\n-                tcx.lifetimes.re_static\n-            },\n+            (&RePlaceholder(..), _) | (_, &RePlaceholder(..)) => {\n+                if a == b {\n+                    a\n+                } else {\n+                    tcx.lifetimes.re_static\n+                }\n+            }\n         }\n     }\n \n@@ -382,10 +505,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         errors: &mut Vec<RegionResolutionError<'tcx>>,\n     ) {\n         for (constraint, origin) in &self.data.constraints {\n-            debug!(\n-                \"collect_errors: constraint={:?} origin={:?}\",\n-                constraint, origin\n-            );\n+            debug!(\"collect_errors: constraint={:?} origin={:?}\", constraint, origin);\n             match *constraint {\n                 Constraint::RegSubVar(..) | Constraint::VarSubVar(..) => {\n                     // Expansion will ensure that these constraints hold. Ignore.\n@@ -433,6 +553,25 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             }\n         }\n \n+        // Check that all member constraints are satisfied.\n+        for member_constraint in &self.data.member_constraints {\n+            let member_region = var_data.normalize(self.tcx(), member_constraint.member_region);\n+            let choice_regions = member_constraint\n+                .choice_regions\n+                .iter()\n+                .map(|&choice_region| var_data.normalize(self.tcx(), choice_region));\n+            if !choice_regions.clone().any(|choice_region| member_region == choice_region) {\n+                let span = self.tcx().def_span(member_constraint.opaque_type_def_id);\n+                errors.push(RegionResolutionError::MemberConstraintFailure {\n+                    span,\n+                    opaque_type_def_id: member_constraint.opaque_type_def_id,\n+                    hidden_ty: member_constraint.hidden_ty,\n+                    member_region,\n+                    choice_regions: choice_regions.collect(),\n+                });\n+            }\n+        }\n+\n         for verify in &self.data.verifys {\n             debug!(\"collect_errors: verify={:?}\", verify);\n             let sub = var_data.normalize(self.tcx(), verify.region);\n@@ -483,34 +622,35 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         // idea is to report errors that derive from independent\n         // regions of the graph, but not those that derive from\n         // overlapping locations.\n-        let mut dup_vec = vec![u32::MAX; self.num_vars()];\n+        let mut dup_vec = IndexVec::from_elem_n(None, self.num_vars());\n \n         for (node_vid, value) in var_data.values.iter_enumerated() {\n             match *value {\n                 VarValue::Value(_) => { /* Inference successful */ }\n                 VarValue::ErrorValue => {\n-                    /* Inference impossible: this value contains\n-                       inconsistent constraints.\n-\n-                       I think that in this case we should report an\n-                       error now -- unlike the case above, we can't\n-                       wait to see whether the user needs the result\n-                       of this variable. The reason is that the mere\n-                       existence of this variable implies that the\n-                       region graph is inconsistent, whether or not it\n-                       is used.\n-\n-                       For example, we may have created a region\n-                       variable that is the GLB of two other regions\n-                       which do not have a GLB. Even if that variable\n-                       is not used, it implies that those two regions\n-                       *should* have a GLB.\n-\n-                       At least I think this is true. It may be that\n-                       the mere existence of a conflict in a region variable\n-                       that is not used is not a problem, so if this rule\n-                       starts to create problems we'll have to revisit\n-                       this portion of the code and think hard about it. =) */\n+                    // Inference impossible: this value contains\n+                    // inconsistent constraints.\n+                    //\n+                    // I think that in this case we should report an\n+                    // error now -- unlike the case above, we can't\n+                    // wait to see whether the user needs the result\n+                    // of this variable. The reason is that the mere\n+                    // existence of this variable implies that the\n+                    // region graph is inconsistent, whether or not it\n+                    // is used.\n+                    //\n+                    // For example, we may have created a region\n+                    // variable that is the GLB of two other regions\n+                    // which do not have a GLB. Even if that variable\n+                    // is not used, it implies that those two regions\n+                    // *should* have a GLB.\n+                    //\n+                    // At least I think this is true. It may be that\n+                    // the mere existence of a conflict in a region\n+                    // variable that is not used is not a problem, so\n+                    // if this rule starts to create problems we'll\n+                    // have to revisit this portion of the code and\n+                    // think hard about it. =) -- nikomatsakis\n                     self.collect_error_for_expanding_node(graph, &mut dup_vec, node_vid, errors);\n                 }\n             }\n@@ -562,16 +702,16 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     fn collect_error_for_expanding_node(\n         &self,\n         graph: &RegionGraph<'tcx>,\n-        dup_vec: &mut [u32],\n+        dup_vec: &mut IndexVec<RegionVid, Option<RegionVid>>,\n         node_idx: RegionVid,\n         errors: &mut Vec<RegionResolutionError<'tcx>>,\n     ) {\n         // Errors in expanding nodes result from a lower-bound that is\n         // not contained by an upper-bound.\n         let (mut lower_bounds, lower_dup) =\n-            self.collect_concrete_regions(graph, node_idx, INCOMING, dup_vec);\n+            self.collect_concrete_regions(graph, node_idx, INCOMING, Some(dup_vec));\n         let (mut upper_bounds, upper_dup) =\n-            self.collect_concrete_regions(graph, node_idx, OUTGOING, dup_vec);\n+            self.collect_concrete_regions(graph, node_idx, OUTGOING, Some(dup_vec));\n \n         if lower_dup || upper_dup {\n             return;\n@@ -604,9 +744,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             };\n \n             for upper_bound in &upper_bounds {\n-                if !self.region_rels\n-                    .is_subregion_of(effective_lower_bound, upper_bound.region)\n-                {\n+                if !self.region_rels.is_subregion_of(effective_lower_bound, upper_bound.region) {\n                     let origin = self.var_infos[node_idx].origin.clone();\n                     debug!(\n                         \"region inference error at {:?} for {:?}: SubSupConflict sub: {:?} \\\n@@ -643,7 +781,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         graph: &RegionGraph<'tcx>,\n         orig_node_idx: RegionVid,\n         dir: Direction,\n-        dup_vec: &mut [u32],\n+        mut dup_vec: Option<&mut IndexVec<RegionVid, Option<RegionVid>>>,\n     ) -> (Vec<RegionAndOrigin<'tcx>>, bool) {\n         struct WalkState<'tcx> {\n             set: FxHashSet<RegionVid>,\n@@ -667,23 +805,23 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             let node_idx = state.stack.pop().unwrap();\n \n             // check whether we've visited this node on some previous walk\n-            if dup_vec[node_idx.index() as usize] == u32::MAX {\n-                dup_vec[node_idx.index() as usize] = orig_node_idx.index() as u32;\n-            } else if dup_vec[node_idx.index() as usize] != orig_node_idx.index() as u32 {\n-                state.dup_found = true;\n-            }\n+            if let Some(dup_vec) = &mut dup_vec {\n+                if dup_vec[node_idx].is_none() {\n+                    dup_vec[node_idx] = Some(orig_node_idx);\n+                } else if dup_vec[node_idx] != Some(orig_node_idx) {\n+                    state.dup_found = true;\n+                }\n \n-            debug!(\n-                \"collect_concrete_regions(orig_node_idx={:?}, node_idx={:?})\",\n-                orig_node_idx, node_idx\n-            );\n+                debug!(\n+                    \"collect_concrete_regions(orig_node_idx={:?}, node_idx={:?})\",\n+                    orig_node_idx, node_idx\n+                );\n+            }\n \n             process_edges(&self.data, &mut state, graph, node_idx, dir);\n         }\n \n-        let WalkState {\n-            result, dup_found, ..\n-        } = state;\n+        let WalkState { result, dup_found, .. } = state;\n         return (result, dup_found);\n \n         fn process_edges<'tcx>(\n@@ -699,11 +837,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             for (_, edge) in graph.adjacent_edges(source_node_index, dir) {\n                 match edge.data {\n                     Constraint::VarSubVar(from_vid, to_vid) => {\n-                        let opp_vid = if from_vid == source_vid {\n-                            to_vid\n-                        } else {\n-                            from_vid\n-                        };\n+                        let opp_vid = if from_vid == source_vid { to_vid } else { from_vid };\n                         if state.set.insert(opp_vid) {\n                             state.stack.push(opp_vid);\n                         }\n@@ -726,7 +860,8 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     }\n \n     fn iterate_until_fixed_point<F>(&self, tag: &str, mut body: F)\n-        where F: FnMut(&Constraint<'tcx>) -> (bool, bool),\n+    where\n+        F: FnMut(&Constraint<'tcx>) -> (bool, bool),\n     {\n         let mut constraints: SmallVec<[_; 16]> = self.data.constraints.keys().collect();\n         let mut iteration = 0;\n@@ -760,17 +895,17 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                     && self.bound_is_met(b, var_values, generic_ty, min)\n             }\n \n-            VerifyBound::OutlivedBy(r) =>\n-                self.region_rels.is_subregion_of(\n-                    min,\n-                    var_values.normalize(self.tcx(), r),\n-                ),\n+            VerifyBound::OutlivedBy(r) => {\n+                self.region_rels.is_subregion_of(min, var_values.normalize(self.tcx(), r))\n+            }\n \n-            VerifyBound::AnyBound(bs) => bs.iter()\n-                .any(|b| self.bound_is_met(b, var_values, generic_ty, min)),\n+            VerifyBound::AnyBound(bs) => {\n+                bs.iter().any(|b| self.bound_is_met(b, var_values, generic_ty, min))\n+            }\n \n-            VerifyBound::AllBounds(bs) => bs.iter()\n-                .all(|b| self.bound_is_met(b, var_values, generic_ty, min)),\n+            VerifyBound::AllBounds(bs) => {\n+                bs.iter().all(|b| self.bound_is_met(b, var_values, generic_ty, min))\n+            }\n         }\n     }\n }"}, {"sha": "663acd67dcd839b147f5e4b3a7fc263a70e0a0af", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -26,6 +26,7 @@ use crate::ty::{FloatVid, IntVid, TyVid, ConstVid};\n use crate::util::nodemap::FxHashMap;\n \n use errors::DiagnosticBuilder;\n+use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::unify as ut;\n use std::cell::{Cell, Ref, RefCell, RefMut};\n use std::collections::BTreeMap;\n@@ -904,6 +905,21 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             .make_subregion(origin, a, b);\n     }\n \n+    /// Require that the region `r` be equal to one of the regions in\n+    /// the set `regions`.\n+    pub fn member_constraint(\n+        &self,\n+        opaque_type_def_id: DefId,\n+        definition_span: Span,\n+        hidden_ty: Ty<'tcx>,\n+        region: ty::Region<'tcx>,\n+        in_regions: &Lrc<Vec<ty::Region<'tcx>>>,\n+    ) {\n+        debug!(\"member_constraint({:?} <: {:?})\", region, in_regions);\n+        self.borrow_region_constraints()\n+            .member_constraint(opaque_type_def_id, definition_span, hidden_ty, region, in_regions);\n+    }\n+\n     pub fn subtype_predicate(\n         &self,\n         cause: &ObligationCause<'tcx>,"}, {"sha": "f43e3fa0b7787f1bf4fc2bb13a99c9b82f497d62", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 340, "deletions": 176, "changes": 516, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -1,16 +1,19 @@\n-use rustc_data_structures::fx::FxHashMap;\n-use syntax_pos::Span;\n-\n-use crate::hir::def_id::DefId;\n use crate::hir;\n+use crate::hir::def_id::DefId;\n use crate::hir::Node;\n-use crate::infer::{self, InferCtxt, InferOk, TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::outlives::free_region_map::FreeRegionRelations;\n+use crate::infer::{self, InferCtxt, InferOk, TypeVariableOrigin, TypeVariableOriginKind};\n+use crate::middle::region;\n use crate::traits::{self, PredicateObligation};\n-use crate::ty::{self, Ty, TyCtxt, GenericParamDefKind};\n use crate::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder, TypeVisitor};\n-use crate::ty::subst::{Kind, InternalSubsts, SubstsRef, UnpackedKind};\n+use crate::ty::subst::{InternalSubsts, Kind, SubstsRef, UnpackedKind};\n+use crate::ty::{self, GenericParamDefKind, Ty, TyCtxt};\n use crate::util::nodemap::DefIdMap;\n+use errors::DiagnosticBuilder;\n+use rustc::session::config::nightly_options;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::sync::Lrc;\n+use syntax_pos::Span;\n \n pub type OpaqueTypeMap<'tcx> = DefIdMap<OpaqueTypeDecl<'tcx>>;\n \n@@ -32,6 +35,20 @@ pub struct OpaqueTypeDecl<'tcx> {\n     /// then `substs` would be `['a, T]`.\n     pub substs: SubstsRef<'tcx>,\n \n+    /// The span of this particular definition of the opaque type.  So\n+    /// for example:\n+    ///\n+    /// ```\n+    /// existential type Foo;\n+    /// fn bar() -> Foo {\n+    ///             ^^^ This is the span we are looking for!\n+    /// ```\n+    ///\n+    /// In cases where the fn returns `(impl Trait, impl Trait)` or\n+    /// other such combinations, the result is currently\n+    /// over-approximated, but better than nothing.\n+    pub definition_span: Span,\n+\n     /// The type variable that represents the value of the abstract type\n     /// that we require. In other words, after we compile this function,\n     /// we will be created a constraint like:\n@@ -98,30 +115,31 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// - `param_env` -- the in-scope parameter environment to be used for\n     ///   obligations\n     /// - `value` -- the value within which we are instantiating opaque types\n+    /// - `value_span` -- the span where the value came from, used in error reporting\n     pub fn instantiate_opaque_types<T: TypeFoldable<'tcx>>(\n         &self,\n         parent_def_id: DefId,\n         body_id: hir::HirId,\n         param_env: ty::ParamEnv<'tcx>,\n         value: &T,\n+        value_span: Span,\n     ) -> InferOk<'tcx, (T, OpaqueTypeMap<'tcx>)> {\n-        debug!(\"instantiate_opaque_types(value={:?}, parent_def_id={:?}, body_id={:?}, \\\n-                param_env={:?})\",\n-               value, parent_def_id, body_id, param_env,\n+        debug!(\n+            \"instantiate_opaque_types(value={:?}, parent_def_id={:?}, body_id={:?}, \\\n+             param_env={:?})\",\n+            value, parent_def_id, body_id, param_env,\n         );\n         let mut instantiator = Instantiator {\n             infcx: self,\n             parent_def_id,\n             body_id,\n             param_env,\n+            value_span,\n             opaque_types: Default::default(),\n             obligations: vec![],\n         };\n         let value = instantiator.instantiate_opaque_types_in_map(value);\n-        InferOk {\n-            value: (value, instantiator.opaque_types),\n-            obligations: instantiator.obligations,\n-        }\n+        InferOk { value: (value, instantiator.opaque_types), obligations: instantiator.obligations }\n     }\n \n     /// Given the map `opaque_types` containing the existential `impl\n@@ -216,22 +234,46 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ///\n     /// # The Solution\n     ///\n-    /// We make use of the constraint that we *do* have in the `<=`\n-    /// relation. To do that, we find the \"minimum\" of all the\n-    /// arguments that appear in the substs: that is, some region\n-    /// which is less than all the others. In the case of `Foo1<'a>`,\n-    /// that would be `'a` (it's the only choice, after all). Then we\n-    /// apply that as a least bound to the variables (e.g., `'a <=\n-    /// '0`).\n+    /// We generally prefer to make `<=` constraints, since they\n+    /// integrate best into the region solver. To do that, we find the\n+    /// \"minimum\" of all the arguments that appear in the substs: that\n+    /// is, some region which is less than all the others. In the case\n+    /// of `Foo1<'a>`, that would be `'a` (it's the only choice, after\n+    /// all). Then we apply that as a least bound to the variables\n+    /// (e.g., `'a <= '0`).\n     ///\n     /// In some cases, there is no minimum. Consider this example:\n     ///\n     /// ```text\n     /// fn baz<'a, 'b>() -> impl Trait<'a, 'b> { ... }\n     /// ```\n     ///\n-    /// Here we would report an error, because `'a` and `'b` have no\n-    /// relation to one another.\n+    /// Here we would report a more complex \"in constraint\", like `'r\n+    /// in ['a, 'b, 'static]` (where `'r` is some regon appearing in\n+    /// the hidden type).\n+    ///\n+    /// # Constrain regions, not the hidden concrete type\n+    ///\n+    /// Note that generating constraints on each region `Rc` is *not*\n+    /// the same as generating an outlives constraint on `Tc` iself.\n+    /// For example, if we had a function like this:\n+    ///\n+    /// ```rust\n+    /// fn foo<'a, T>(x: &'a u32, y: T) -> impl Foo<'a> {\n+    ///   (x, y)\n+    /// }\n+    ///\n+    /// // Equivalent to:\n+    /// existential type FooReturn<'a, T>: Foo<'a>;\n+    /// fn foo<'a, T>(..) -> FooReturn<'a, T> { .. }\n+    /// ```\n+    ///\n+    /// then the hidden type `Tc` would be `(&'0 u32, T)` (where `'0`\n+    /// is an inference variable). If we generated a constraint that\n+    /// `Tc: 'a`, then this would incorrectly require that `T: 'a` --\n+    /// but this is not necessary, because the existential type we\n+    /// create will be allowed to reference `T`. So we only generate a\n+    /// constraint that `'0: 'a`.\n     ///\n     /// # The `free_region_relations` parameter\n     ///\n@@ -274,6 +316,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n+    /// See `constrain_opaque_types` for documentation.\n     pub fn constrain_opaque_type<FRR: FreeRegionRelations<'tcx>>(\n         &self,\n         def_id: DefId,\n@@ -290,32 +333,25 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         debug!(\"constrain_opaque_type: concrete_ty={:?}\", concrete_ty);\n \n-        let abstract_type_generics = tcx.generics_of(def_id);\n+        let opaque_type_generics = tcx.generics_of(def_id);\n \n         let span = tcx.def_span(def_id);\n \n         // If there are required region bounds, we can use them.\n         if opaque_defn.has_required_region_bounds {\n             let predicates_of = tcx.predicates_of(def_id);\n-            debug!(\n-                \"constrain_opaque_type: predicates: {:#?}\",\n-                predicates_of,\n-            );\n+            debug!(\"constrain_opaque_type: predicates: {:#?}\", predicates_of,);\n             let bounds = predicates_of.instantiate(tcx, opaque_defn.substs);\n             debug!(\"constrain_opaque_type: bounds={:#?}\", bounds);\n             let opaque_type = tcx.mk_opaque(def_id, opaque_defn.substs);\n \n-            let required_region_bounds = tcx.required_region_bounds(\n-                opaque_type,\n-                bounds.predicates,\n-            );\n+            let required_region_bounds = tcx.required_region_bounds(opaque_type, bounds.predicates);\n             debug_assert!(!required_region_bounds.is_empty());\n \n-            for region in required_region_bounds {\n-                concrete_ty.visit_with(&mut OpaqueTypeOutlivesVisitor {\n-                    infcx: self,\n-                    least_region: region,\n-                    span,\n+            for required_region in required_region_bounds {\n+                concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n+                    tcx: self.tcx,\n+                    op: |r| self.sub_regions(infer::CallReturn(span), required_region, r),\n                 });\n             }\n             return;\n@@ -329,11 +365,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         // `['a]` for the first impl trait and `'b` for the\n         // second.\n         let mut least_region = None;\n-        for param in &abstract_type_generics.params {\n+        for param in &opaque_type_generics.params {\n             match param.kind {\n                 GenericParamDefKind::Lifetime => {}\n-                _ => continue\n+                _ => continue,\n             }\n+\n             // Get the value supplied for this region from the substs.\n             let subst_arg = opaque_defn.substs.region_at(param.index as usize);\n \n@@ -350,44 +387,21 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         least_region = Some(subst_arg);\n                     } else {\n                         // There are two regions (`lr` and\n-                        // `subst_arg`) which are not relatable. We can't\n-                        // find a best choice.\n-                        let context_name = match opaque_defn.origin {\n-                            hir::ExistTyOrigin::ExistentialType => \"existential type\",\n-                            hir::ExistTyOrigin::ReturnImplTrait => \"impl Trait\",\n-                            hir::ExistTyOrigin::AsyncFn => \"async fn\",\n-                        };\n-                        let msg = format!(\"ambiguous lifetime bound in `{}`\", context_name);\n-                        let mut err = self.tcx\n-                            .sess\n-                            .struct_span_err(span, &msg);\n-\n-                        let lr_name = lr.to_string();\n-                        let subst_arg_name = subst_arg.to_string();\n-                        let label_owned;\n-                        let label = match (&*lr_name, &*subst_arg_name) {\n-                            (\"'_\", \"'_\") => \"the elided lifetimes here do not outlive one another\",\n-                            _ => {\n-                                label_owned = format!(\n-                                    \"neither `{}` nor `{}` outlives the other\",\n-                                    lr_name,\n-                                    subst_arg_name,\n-                                );\n-                                &label_owned\n-                            }\n-                        };\n-                        err.span_label(span, label);\n-\n-                        if let hir::ExistTyOrigin::AsyncFn = opaque_defn.origin {\n-                            err.note(\"multiple unrelated lifetimes are not allowed in \\\n-                                     `async fn`.\");\n-                            err.note(\"if you're using argument-position elided lifetimes, consider \\\n-                                switching to a single named lifetime.\");\n-                        }\n-                        err.emit();\n-\n-                        least_region = Some(self.tcx.mk_region(ty::ReEmpty));\n-                        break;\n+                        // `subst_arg`) which are not relatable. We\n+                        // can't find a best choice. Therefore,\n+                        // instead of creating a single bound like\n+                        // `'r: 'a` (which is our preferred choice),\n+                        // we will create a \"in bound\" like `'r in\n+                        // ['a, 'b, 'c]`, where `'a..'c` are the\n+                        // regions that appear in the impl trait.\n+                        return self.generate_member_constraint(\n+                            concrete_ty,\n+                            opaque_type_generics,\n+                            opaque_defn,\n+                            def_id,\n+                            lr,\n+                            subst_arg,\n+                        );\n                     }\n                 }\n             }\n@@ -396,13 +410,121 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let least_region = least_region.unwrap_or(tcx.lifetimes.re_static);\n         debug!(\"constrain_opaque_types: least_region={:?}\", least_region);\n \n-        concrete_ty.visit_with(&mut OpaqueTypeOutlivesVisitor {\n-            infcx: self,\n-            least_region,\n-            span,\n+        concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n+            tcx: self.tcx,\n+            op: |r| self.sub_regions(infer::CallReturn(span), least_region, r),\n         });\n     }\n \n+    /// As a fallback, we sometimes generate an \"in constraint\". For\n+    /// a case like `impl Foo<'a, 'b>`, where `'a` and `'b` cannot be\n+    /// related, we would generate a constraint `'r in ['a, 'b,\n+    /// 'static]` for each region `'r` that appears in the hidden type\n+    /// (i.e., it must be equal to `'a`, `'b`, or `'static`).\n+    ///\n+    /// `conflict1` and `conflict2` are the two region bounds that we\n+    /// detected which were unrelated. They are used for diagnostics.\n+    fn generate_member_constraint(\n+        &self,\n+        concrete_ty: Ty<'tcx>,\n+        opaque_type_generics: &ty::Generics,\n+        opaque_defn: &OpaqueTypeDecl<'tcx>,\n+        opaque_type_def_id: DefId,\n+        conflict1: ty::Region<'tcx>,\n+        conflict2: ty::Region<'tcx>,\n+    ) {\n+        // For now, enforce a feature gate outside of async functions.\n+        if self.member_constraint_feature_gate(\n+            opaque_defn,\n+            opaque_type_def_id,\n+            conflict1,\n+            conflict2,\n+        ) {\n+            return;\n+        }\n+\n+        // Create the set of choice regions: each region in the hidden\n+        // type can be equal to any of the region parameters of the\n+        // opaque type definition.\n+        let choice_regions: Lrc<Vec<ty::Region<'tcx>>> = Lrc::new(\n+            opaque_type_generics\n+                .params\n+                .iter()\n+                .filter(|param| match param.kind {\n+                    GenericParamDefKind::Lifetime => true,\n+                    GenericParamDefKind::Type { .. } | GenericParamDefKind::Const => false,\n+                })\n+                .map(|param| opaque_defn.substs.region_at(param.index as usize))\n+                .chain(std::iter::once(self.tcx.lifetimes.re_static))\n+                .collect(),\n+        );\n+\n+        concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n+            tcx: self.tcx,\n+            op: |r| self.member_constraint(\n+                opaque_type_def_id,\n+                opaque_defn.definition_span,\n+                concrete_ty,\n+                r,\n+                &choice_regions,\n+            ),\n+        });\n+    }\n+\n+    /// Member constraints are presently feature-gated except for\n+    /// async-await. We expect to lift this once we've had a bit more\n+    /// time.\n+    fn member_constraint_feature_gate(\n+        &self,\n+        opaque_defn: &OpaqueTypeDecl<'tcx>,\n+        opaque_type_def_id: DefId,\n+        conflict1: ty::Region<'tcx>,\n+        conflict2: ty::Region<'tcx>,\n+    ) -> bool {\n+        // If we have `#![feature(member_constraints)]`, no problems.\n+        if self.tcx.features().member_constraints {\n+            return false;\n+        }\n+\n+        let span = self.tcx.def_span(opaque_type_def_id);\n+\n+        // Without a feature-gate, we only generate member-constraints for async-await.\n+        let context_name = match opaque_defn.origin {\n+            // No feature-gate required for `async fn`.\n+            hir::ExistTyOrigin::AsyncFn => return false,\n+\n+            // Otherwise, generate the label we'll use in the error message.\n+            hir::ExistTyOrigin::ExistentialType => \"existential type\",\n+            hir::ExistTyOrigin::ReturnImplTrait => \"impl Trait\",\n+        };\n+        let msg = format!(\"ambiguous lifetime bound in `{}`\", context_name);\n+        let mut err = self.tcx.sess.struct_span_err(span, &msg);\n+\n+        let conflict1_name = conflict1.to_string();\n+        let conflict2_name = conflict2.to_string();\n+        let label_owned;\n+        let label = match (&*conflict1_name, &*conflict2_name) {\n+            (\"'_\", \"'_\") => \"the elided lifetimes here do not outlive one another\",\n+            _ => {\n+                label_owned = format!(\n+                    \"neither `{}` nor `{}` outlives the other\",\n+                    conflict1_name, conflict2_name,\n+                );\n+                &label_owned\n+            }\n+        };\n+        err.span_label(span, label);\n+\n+        if nightly_options::is_nightly_build() {\n+            help!(err,\n+                  \"add #![feature(member_constraints)] to the crate attributes \\\n+                   to enable\");\n+        }\n+\n+        err.emit();\n+        true\n+    }\n+\n     /// Given the fully resolved, instantiated type for an opaque\n     /// type, i.e., the value of an inference variable like C1 or C2\n     /// (*), computes the \"definition type\" for an abstract type\n@@ -456,23 +578,98 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         // Convert the type from the function into a type valid outside\n         // the function, by replacing invalid regions with 'static,\n         // after producing an error for each of them.\n-        let definition_ty =\n-            instantiated_ty.fold_with(&mut ReverseMapper::new(\n-                self.tcx,\n-                self.is_tainted_by_errors(),\n-                def_id,\n-                map,\n-                instantiated_ty,\n-            ));\n-        debug!(\n-            \"infer_opaque_definition_from_instantiation: definition_ty={:?}\",\n-            definition_ty\n-        );\n+        let definition_ty = instantiated_ty.fold_with(&mut ReverseMapper::new(\n+            self.tcx,\n+            self.is_tainted_by_errors(),\n+            def_id,\n+            map,\n+            instantiated_ty,\n+        ));\n+        debug!(\"infer_opaque_definition_from_instantiation: definition_ty={:?}\", definition_ty);\n \n         definition_ty\n     }\n }\n \n+pub fn unexpected_hidden_region_diagnostic(\n+    tcx: TyCtxt<'tcx>,\n+    region_scope_tree: Option<&region::ScopeTree>,\n+    opaque_type_def_id: DefId,\n+    hidden_ty: Ty<'tcx>,\n+    hidden_region: ty::Region<'tcx>,\n+) -> DiagnosticBuilder<'tcx> {\n+    let span = tcx.def_span(opaque_type_def_id);\n+    let mut err = struct_span_err!(\n+        tcx.sess,\n+        span,\n+        E0700,\n+        \"hidden type for `impl Trait` captures lifetime that does not appear in bounds\",\n+    );\n+\n+    // Explain the region we are capturing.\n+    if let ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic | ty::ReEmpty = hidden_region {\n+        // Assuming regionck succeeded (*), we ought to always be\n+        // capturing *some* region from the fn header, and hence it\n+        // ought to be free. So under normal circumstances, we will go\n+        // down this path which gives a decent human readable\n+        // explanation.\n+        //\n+        // (*) if not, the `tainted_by_errors` flag would be set to\n+        // true in any case, so we wouldn't be here at all.\n+        tcx.note_and_explain_free_region(\n+            &mut err,\n+            &format!(\"hidden type `{}` captures \", hidden_ty),\n+            hidden_region,\n+            \"\",\n+        );\n+    } else {\n+        // Ugh. This is a painful case: the hidden region is not one\n+        // that we can easily summarize or explain. This can happen\n+        // in a case like\n+        // `src/test/ui/multiple-lifetimes/ordinary-bounds-unsuited.rs`:\n+        //\n+        // ```\n+        // fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b> {\n+        //   if condition() { a } else { b }\n+        // }\n+        // ```\n+        //\n+        // Here the captured lifetime is the intersection of `'a` and\n+        // `'b`, which we can't quite express.\n+\n+        if let Some(region_scope_tree) = region_scope_tree {\n+            // If the `region_scope_tree` is available, this is being\n+            // invoked from the \"region inferencer error\". We can at\n+            // least report a really cryptic error for now.\n+            tcx.note_and_explain_region(\n+                region_scope_tree,\n+                &mut err,\n+                &format!(\"hidden type `{}` captures \", hidden_ty),\n+                hidden_region,\n+                \"\",\n+            );\n+        } else {\n+            // If the `region_scope_tree` is *unavailable*, this is\n+            // being invoked by the code that comes *after* region\n+            // inferencing. This is a bug, as the region inferencer\n+            // ought to have noticed the failed constraint and invoked\n+            // error reporting, which in turn should have prevented us\n+            // from getting trying to infer the hidden type\n+            // completely.\n+            tcx.sess.delay_span_bug(\n+                span,\n+                &format!(\n+                    \"hidden type captures unexpected lifetime `{:?}` \\\n+                     but no region inference failure\",\n+                    hidden_region,\n+                ),\n+            );\n+        }\n+    }\n+\n+    err\n+}\n+\n // Visitor that requires that (almost) all regions in the type visited outlive\n // `least_region`. We cannot use `push_outlives_components` because regions in\n // closure signatures are not included in their outlives components. We need to\n@@ -486,13 +683,18 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n //\n // We ignore any type parameters because impl trait values are assumed to\n // capture all the in-scope type parameters.\n-struct OpaqueTypeOutlivesVisitor<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n-    least_region: ty::Region<'tcx>,\n-    span: Span,\n+struct ConstrainOpaqueTypeRegionVisitor<'tcx, OP>\n+where\n+    OP: FnMut(ty::Region<'tcx>),\n+{\n+    tcx: TyCtxt<'tcx>,\n+    op: OP,\n }\n \n-impl<'tcx> TypeVisitor<'tcx> for OpaqueTypeOutlivesVisitor<'_, 'tcx> {\n+impl<'tcx, OP> TypeVisitor<'tcx> for ConstrainOpaqueTypeRegionVisitor<'tcx, OP>\n+where\n+    OP: FnMut(ty::Region<'tcx>),\n+{\n     fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> bool {\n         t.skip_binder().visit_with(self);\n         false // keep visiting\n@@ -503,7 +705,7 @@ impl<'tcx> TypeVisitor<'tcx> for OpaqueTypeOutlivesVisitor<'_, 'tcx> {\n             // ignore bound regions, keep visiting\n             ty::ReLateBound(_, _) => false,\n             _ => {\n-                self.infcx.sub_regions(infer::CallReturn(self.span), self.least_region, r);\n+                (self.op)(r);\n                 false\n             }\n         }\n@@ -519,23 +721,23 @@ impl<'tcx> TypeVisitor<'tcx> for OpaqueTypeOutlivesVisitor<'_, 'tcx> {\n             ty::Closure(def_id, ref substs) => {\n                 // Skip lifetime parameters of the enclosing item(s)\n \n-                for upvar_ty in substs.upvar_tys(def_id, self.infcx.tcx) {\n+                for upvar_ty in substs.upvar_tys(def_id, self.tcx) {\n                     upvar_ty.visit_with(self);\n                 }\n \n-                substs.closure_sig_ty(def_id, self.infcx.tcx).visit_with(self);\n+                substs.closure_sig_ty(def_id, self.tcx).visit_with(self);\n             }\n \n             ty::Generator(def_id, ref substs, _) => {\n                 // Skip lifetime parameters of the enclosing item(s)\n                 // Also skip the witness type, because that has no free regions.\n \n-                for upvar_ty in substs.upvar_tys(def_id, self.infcx.tcx) {\n+                for upvar_ty in substs.upvar_tys(def_id, self.tcx) {\n                     upvar_ty.visit_with(self);\n                 }\n \n-                substs.return_ty(def_id, self.infcx.tcx).visit_with(self);\n-                substs.yield_ty(def_id, self.infcx.tcx).visit_with(self);\n+                substs.return_ty(def_id, self.tcx).visit_with(self);\n+                substs.yield_ty(def_id, self.tcx).visit_with(self);\n             }\n             _ => {\n                 ty.super_visit_with(self);\n@@ -616,40 +818,17 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n             None => {\n                 if !self.map_missing_regions_to_empty && !self.tainted_by_errors {\n                     if let Some(hidden_ty) = self.hidden_ty.take() {\n-                        let span = self.tcx.def_span(self.opaque_type_def_id);\n-                        let mut err = struct_span_err!(\n-                            self.tcx.sess,\n-                            span,\n-                            E0700,\n-                            \"hidden type for `impl Trait` captures lifetime that \\\n-                             does not appear in bounds\",\n-                        );\n-\n-                        // Assuming regionck succeeded, then we must\n-                        // be capturing *some* region from the fn\n-                        // header, and hence it must be free, so it's\n-                        // ok to invoke this fn (which doesn't accept\n-                        // all regions, and would ICE if an\n-                        // inappropriate region is given). We check\n-                        // `is_tainted_by_errors` by errors above, so\n-                        // we don't get in here unless regionck\n-                        // succeeded. (Note also that if regionck\n-                        // failed, then the regions we are attempting\n-                        // to map here may well be giving errors\n-                        // *because* the constraints were not\n-                        // satisfiable.)\n-                        self.tcx.note_and_explain_free_region(\n-                            &mut err,\n-                            &format!(\"hidden type `{}` captures \", hidden_ty),\n+                        unexpected_hidden_region_diagnostic(\n+                            self.tcx,\n+                            None,\n+                            self.opaque_type_def_id,\n+                            hidden_ty,\n                             r,\n-                            \"\"\n-                        );\n-\n-                        err.emit();\n+                        ).emit();\n                     }\n                 }\n                 self.tcx.lifetimes.re_empty\n-            },\n+            }\n         }\n     }\n \n@@ -681,34 +860,32 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                 // during codegen.\n \n                 let generics = self.tcx.generics_of(def_id);\n-                let substs = self.tcx.mk_substs(substs.substs.iter().enumerate().map(\n-                    |(index, &kind)| {\n+                let substs =\n+                    self.tcx.mk_substs(substs.substs.iter().enumerate().map(|(index, &kind)| {\n                         if index < generics.parent_count {\n                             // Accommodate missing regions in the parent kinds...\n                             self.fold_kind_mapping_missing_regions_to_empty(kind)\n                         } else {\n                             // ...but not elsewhere.\n                             self.fold_kind_normally(kind)\n                         }\n-                    },\n-                ));\n+                    }));\n \n                 self.tcx.mk_closure(def_id, ty::ClosureSubsts { substs })\n             }\n \n             ty::Generator(def_id, substs, movability) => {\n                 let generics = self.tcx.generics_of(def_id);\n-                let substs = self.tcx.mk_substs(substs.substs.iter().enumerate().map(\n-                    |(index, &kind)| {\n+                let substs =\n+                    self.tcx.mk_substs(substs.substs.iter().enumerate().map(|(index, &kind)| {\n                         if index < generics.parent_count {\n                             // Accommodate missing regions in the parent kinds...\n                             self.fold_kind_mapping_missing_regions_to_empty(kind)\n                         } else {\n                             // ...but not elsewhere.\n                             self.fold_kind_normally(kind)\n                         }\n-                    },\n-                ));\n+                    }));\n \n                 self.tcx.mk_generator(def_id, ty::GeneratorSubsts { substs }, movability)\n             }\n@@ -723,6 +900,7 @@ struct Instantiator<'a, 'tcx> {\n     parent_def_id: DefId,\n     body_id: hir::HirId,\n     param_env: ty::ParamEnv<'tcx>,\n+    value_span: Span,\n     opaque_types: OpaqueTypeMap<'tcx>,\n     obligations: Vec<PredicateObligation<'tcx>>,\n }\n@@ -773,12 +951,10 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                         let parent_def_id = self.parent_def_id;\n                         let def_scope_default = || {\n                             let opaque_parent_hir_id = tcx.hir().get_parent_item(opaque_hir_id);\n-                            parent_def_id == tcx.hir()\n-                                                .local_def_id_from_hir_id(opaque_parent_hir_id)\n+                            parent_def_id\n+                                == tcx.hir().local_def_id_from_hir_id(opaque_parent_hir_id)\n                         };\n-                        let (in_definition_scope, origin) =\n-                            match tcx.hir().find(opaque_hir_id)\n-                        {\n+                        let (in_definition_scope, origin) = match tcx.hir().find(opaque_hir_id) {\n                             Some(Node::Item(item)) => match item.node {\n                                 // Anonymous `impl Trait`\n                                 hir::ItemKind::Existential(hir::ExistTy {\n@@ -847,52 +1023,43 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n         let infcx = self.infcx;\n         let tcx = infcx.tcx;\n \n-        debug!(\n-            \"instantiate_opaque_types: Opaque(def_id={:?}, substs={:?})\",\n-            def_id, substs\n-        );\n+        debug!(\"instantiate_opaque_types: Opaque(def_id={:?}, substs={:?})\", def_id, substs);\n \n         // Use the same type variable if the exact same opaque type appears more\n         // than once in the return type (e.g., if it's passed to a type alias).\n         if let Some(opaque_defn) = self.opaque_types.get(&def_id) {\n             return opaque_defn.concrete_ty;\n         }\n         let span = tcx.def_span(def_id);\n-        let ty_var = infcx.next_ty_var(TypeVariableOrigin {\n-            kind: TypeVariableOriginKind::TypeInference,\n-            span,\n-        });\n+        let ty_var = infcx\n+            .next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span });\n \n         let predicates_of = tcx.predicates_of(def_id);\n-        debug!(\n-            \"instantiate_opaque_types: predicates={:#?}\",\n-            predicates_of,\n-        );\n+        debug!(\"instantiate_opaque_types: predicates={:#?}\", predicates_of,);\n         let bounds = predicates_of.instantiate(tcx, substs);\n         debug!(\"instantiate_opaque_types: bounds={:?}\", bounds);\n \n         let required_region_bounds = tcx.required_region_bounds(ty, bounds.predicates.clone());\n-        debug!(\n-            \"instantiate_opaque_types: required_region_bounds={:?}\",\n-            required_region_bounds\n-        );\n+        debug!(\"instantiate_opaque_types: required_region_bounds={:?}\", required_region_bounds);\n \n         // Make sure that we are in fact defining the *entire* type\n         // (e.g., `existential type Foo<T: Bound>: Bar;` needs to be\n         // defined by a function like `fn foo<T: Bound>() -> Foo<T>`).\n-        debug!(\n-            \"instantiate_opaque_types: param_env={:#?}\",\n-            self.param_env,\n-        );\n-        debug!(\n-            \"instantiate_opaque_types: generics={:#?}\",\n-            tcx.generics_of(def_id),\n-        );\n+        debug!(\"instantiate_opaque_types: param_env={:#?}\", self.param_env,);\n+        debug!(\"instantiate_opaque_types: generics={:#?}\", tcx.generics_of(def_id),);\n+\n+        // Ideally, we'd get the span where *this specific `ty` came\n+        // from*, but right now we just use the span from the overall\n+        // value being folded. In simple cases like `-> impl Foo`,\n+        // these are the same span, but not in cases like `-> (impl\n+        // Foo, impl Bar)`.\n+        let definition_span = self.value_span;\n \n         self.opaque_types.insert(\n             def_id,\n             OpaqueTypeDecl {\n                 substs,\n+                definition_span,\n                 concrete_ty: ty_var,\n                 has_required_region_bounds: !required_region_bounds.is_empty(),\n                 origin,\n@@ -911,8 +1078,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n \n             // Require that the predicate holds for the concrete type.\n             debug!(\"instantiate_opaque_types: predicate={:?}\", predicate);\n-            self.obligations\n-                .push(traits::Obligation::new(cause, self.param_env, predicate));\n+            self.obligations.push(traits::Obligation::new(cause, self.param_env, predicate));\n         }\n \n         ty_var\n@@ -950,9 +1116,7 @@ pub fn may_define_existential_type(\n     );\n \n     // Named existential types can be defined by any siblings or children of siblings.\n-    let scope = tcx.hir()\n-        .get_defining_scope(opaque_hir_id)\n-        .expect(\"could not get defining scope\");\n+    let scope = tcx.hir().get_defining_scope(opaque_hir_id).expect(\"could not get defining scope\");\n     // We walk up the node tree until we hit the root or the scope of the opaque type.\n     while hir_id != scope && hir_id != hir::CRATE_HIR_ID {\n         hir_id = tcx.hir().get_parent_item(hir_id);"}, {"sha": "fcb116fce5c9bfb0f0cf6d3edef97d7886220a57", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 74, "deletions": 1, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -8,11 +8,14 @@ use super::{MiscVariable, RegionVariableOrigin, SubregionOrigin};\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::unify as ut;\n+use crate::hir::def_id::DefId;\n use crate::ty::ReStatic;\n use crate::ty::{self, Ty, TyCtxt};\n use crate::ty::{ReLateBound, ReVar};\n use crate::ty::{Region, RegionVid};\n+use syntax_pos::Span;\n \n use std::collections::BTreeMap;\n use std::{cmp, fmt, mem};\n@@ -78,6 +81,11 @@ pub struct RegionConstraintData<'tcx> {\n     /// be a region variable (or neither, as it happens).\n     pub constraints: BTreeMap<Constraint<'tcx>, SubregionOrigin<'tcx>>,\n \n+    /// Constraints of the form `R0 member of [R1, ..., Rn]`, meaning that\n+    /// `R0` must be equal to one of the regions `R1..Rn`. These occur\n+    /// with `impl Trait` quite frequently.\n+    pub member_constraints: Vec<MemberConstraint<'tcx>>,\n+\n     /// A \"verify\" is something that we need to verify after inference\n     /// is done, but which does not directly affect inference in any\n     /// way.\n@@ -137,6 +145,43 @@ impl Constraint<'_> {\n     }\n }\n \n+/// Requires that `region` must be equal to one of the regions in `choice_regions`.\n+/// We often denote this using the syntax:\n+///\n+/// ```\n+/// R0 member of [O1..On]\n+/// ```\n+#[derive(Debug, Clone, HashStable)]\n+pub struct MemberConstraint<'tcx> {\n+    /// The `DefId` of the opaque type causing this constraint: used for error reporting.\n+    pub opaque_type_def_id: DefId,\n+\n+    /// The span where the hidden type was instantiated.\n+    pub definition_span: Span,\n+\n+    /// The hidden type in which `member_region` appears: used for error reporting.\n+    pub hidden_ty: Ty<'tcx>,\n+\n+    /// The region `R0`.\n+    pub member_region: Region<'tcx>,\n+\n+    /// The options `O1..On`.\n+    pub choice_regions: Lrc<Vec<Region<'tcx>>>,\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for MemberConstraint<'tcx> {\n+        opaque_type_def_id, definition_span, hidden_ty, member_region, choice_regions\n+    }\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for MemberConstraint<'a> {\n+        type Lifted = MemberConstraint<'tcx>;\n+        opaque_type_def_id, definition_span, hidden_ty, member_region, choice_regions\n+    }\n+}\n+\n /// `VerifyGenericBound(T, _, R, RS)`: the parameter type `T` (or\n /// associated type) must outlive the region `R`. `T` is known to\n /// outlive `RS`. Therefore, verify that `R <= RS[i]` for some\n@@ -643,6 +688,30 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         }\n     }\n \n+    pub fn member_constraint(\n+        &mut self,\n+        opaque_type_def_id: DefId,\n+        definition_span: Span,\n+        hidden_ty: Ty<'tcx>,\n+        member_region: ty::Region<'tcx>,\n+        choice_regions: &Lrc<Vec<ty::Region<'tcx>>>,\n+    ) {\n+        debug!(\"member_constraint({:?} in {:#?})\", member_region, choice_regions);\n+\n+        if choice_regions.iter().any(|&r| r == member_region) {\n+            return;\n+        }\n+\n+        self.data.member_constraints.push(MemberConstraint {\n+            opaque_type_def_id,\n+            definition_span,\n+            hidden_ty,\n+            member_region,\n+            choice_regions: choice_regions.clone()\n+        });\n+\n+    }\n+\n     pub fn make_subregion(\n         &mut self,\n         origin: SubregionOrigin<'tcx>,\n@@ -906,9 +975,13 @@ impl<'tcx> RegionConstraintData<'tcx> {\n     pub fn is_empty(&self) -> bool {\n         let RegionConstraintData {\n             constraints,\n+            member_constraints,\n             verifys,\n             givens,\n         } = self;\n-        constraints.is_empty() && verifys.is_empty() && givens.is_empty()\n+        constraints.is_empty() &&\n+            member_constraints.is_empty() &&\n+            verifys.is_empty() &&\n+            givens.is_empty()\n     }\n }"}, {"sha": "a2a5f3f950c7ac022186769fc0406f77f558d654", "filename": "src/librustc/traits/query/type_op/custom.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -3,7 +3,7 @@ use std::fmt;\n use crate::traits::query::Fallible;\n \n use crate::infer::canonical::query_response;\n-use crate::infer::canonical::QueryRegionConstraint;\n+use crate::infer::canonical::QueryRegionConstraints;\n use std::rc::Rc;\n use syntax::source_map::DUMMY_SP;\n use crate::traits::{ObligationCause, TraitEngine, TraitEngineExt};\n@@ -39,7 +39,7 @@ where\n     fn fully_perform(\n         self,\n         infcx: &InferCtxt<'_, 'tcx>,\n-    ) -> Fallible<(Self::Output, Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>)> {\n+    ) -> Fallible<(Self::Output, Option<Rc<QueryRegionConstraints<'tcx>>>)> {\n         if cfg!(debug_assertions) {\n             info!(\"fully_perform({:?})\", self);\n         }\n@@ -62,7 +62,7 @@ where\n fn scrape_region_constraints<'tcx, R>(\n     infcx: &InferCtxt<'_, 'tcx>,\n     op: impl FnOnce() -> Fallible<InferOk<'tcx, R>>,\n-) -> Fallible<(R, Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>)> {\n+) -> Fallible<(R, Option<Rc<QueryRegionConstraints<'tcx>>>)> {\n     let mut fulfill_cx = TraitEngine::new(infcx.tcx);\n     let dummy_body_id = ObligationCause::dummy().body_id;\n \n@@ -92,7 +92,7 @@ fn scrape_region_constraints<'tcx, R>(\n \n     let region_constraint_data = infcx.take_and_reset_region_constraints();\n \n-    let outlives = query_response::make_query_outlives(\n+    let region_constraints = query_response::make_query_region_constraints(\n         infcx.tcx,\n         region_obligations\n             .iter()\n@@ -101,9 +101,9 @@ fn scrape_region_constraints<'tcx, R>(\n         &region_constraint_data,\n     );\n \n-    if outlives.is_empty() {\n+    if region_constraints.is_empty() {\n         Ok((value, None))\n     } else {\n-        Ok((value, Some(Rc::new(outlives))))\n+        Ok((value, Some(Rc::new(region_constraints))))\n     }\n }"}, {"sha": "e2a5cd9670e0c50d889eb56a733c089e092aeb1a", "filename": "src/librustc/traits/query/type_op/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -1,6 +1,6 @@\n use crate::infer::canonical::{\n     Canonical, Canonicalized, CanonicalizedQueryResponse, OriginalQueryValues,\n-    QueryRegionConstraint, QueryResponse,\n+    QueryRegionConstraints, QueryResponse,\n };\n use crate::infer::{InferCtxt, InferOk};\n use std::fmt;\n@@ -32,7 +32,7 @@ pub trait TypeOp<'tcx>: Sized + fmt::Debug {\n     fn fully_perform(\n         self,\n         infcx: &InferCtxt<'_, 'tcx>,\n-    ) -> Fallible<(Self::Output, Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>)>;\n+    ) -> Fallible<(Self::Output, Option<Rc<QueryRegionConstraints<'tcx>>>)>;\n }\n \n /// \"Query type ops\" are type ops that are implemented using a\n@@ -85,7 +85,7 @@ pub trait QueryTypeOp<'tcx>: fmt::Debug + Sized + TypeFoldable<'tcx> + 'tcx {\n     fn fully_perform_into(\n         query_key: ParamEnvAnd<'tcx, Self>,\n         infcx: &InferCtxt<'_, 'tcx>,\n-        output_query_region_constraints: &mut Vec<QueryRegionConstraint<'tcx>>,\n+        output_query_region_constraints: &mut QueryRegionConstraints<'tcx>,\n     ) -> Fallible<Self::QueryResponse> {\n         if let Some(result) = QueryTypeOp::try_fast_path(infcx.tcx, &query_key) {\n             return Ok(result);\n@@ -140,16 +140,16 @@ where\n     fn fully_perform(\n         self,\n         infcx: &InferCtxt<'_, 'tcx>,\n-    ) -> Fallible<(Self::Output, Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>)> {\n-        let mut qrc = vec![];\n-        let r = Q::fully_perform_into(self, infcx, &mut qrc)?;\n+    ) -> Fallible<(Self::Output, Option<Rc<QueryRegionConstraints<'tcx>>>)> {\n+        let mut region_constraints = QueryRegionConstraints::default();\n+        let r = Q::fully_perform_into(self, infcx, &mut region_constraints)?;\n \n         // Promote the final query-region-constraints into a\n         // (optional) ref-counted vector:\n-        let opt_qrc = if qrc.is_empty() {\n+        let opt_qrc = if region_constraints.is_empty() {\n             None\n         } else {\n-            Some(Rc::new(qrc))\n+            Some(Rc::new(region_constraints))\n         };\n \n         Ok((r, opt_qrc))"}, {"sha": "28b52dcea80f1126896e75fe02ab5c9027ebb1e9", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -15,6 +15,7 @@ use crate::mir::interpret;\n \n use std::fmt;\n use std::rc::Rc;\n+use std::sync::Arc;\n \n impl fmt::Debug for ty::GenericParamDef {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n@@ -348,7 +349,7 @@ impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>, C: Lift<'tcx>> Lift<'tcx> for (A, B, C)\n         tcx.lift(&self.0).and_then(|a| {\n             tcx.lift(&self.1).and_then(|b| tcx.lift(&self.2).map(|c| (a, b, c)))\n         })\n-    }\n+   }\n }\n \n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Option<T> {\n@@ -378,6 +379,20 @@ impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Box<T> {\n     }\n }\n \n+impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Rc<T> {\n+    type Lifted = Rc<T::Lifted>;\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&**self).map(Rc::new)\n+    }\n+}\n+\n+impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Arc<T> {\n+    type Lifted = Arc<T::Lifted>;\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&**self).map(Arc::new)\n+    }\n+}\n+\n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for [T] {\n     type Lifted = Vec<T::Lifted>;\n     fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n@@ -838,6 +853,16 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Rc<T> {\n     }\n }\n \n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Arc<T> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        Arc::new((**self).fold_with(folder))\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        (**self).visit_with(visitor)\n+    }\n+}\n+\n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<T> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         let content: T = (**self).fold_with(folder);"}, {"sha": "32aa1cb6b1d36575d77eed95d6999f57c7d10ab9", "filename": "src/librustc_data_structures/binary_search_util/mod.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_data_structures%2Fbinary_search_util%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_data_structures%2Fbinary_search_util%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbinary_search_util%2Fmod.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,49 @@\n+#[cfg(test)]\n+mod test;\n+\n+/// Uses a sorted slice `data: &[E]` as a kind of \"multi-map\". The\n+/// `key_fn` extracts a key of type `K` from the data, and this\n+/// function finds the range of elements that match the key. `data`\n+/// must have been sorted as if by a call to `sort_by_key` for this to\n+/// work.\n+pub fn binary_search_slice<E, K>(data: &'d [E], key_fn: impl Fn(&E) -> K, key: &K) -> &'d [E]\n+where\n+    K: Ord,\n+{\n+    let mid = match data.binary_search_by_key(key, &key_fn) {\n+        Ok(mid) => mid,\n+        Err(_) => return &[],\n+    };\n+\n+    // We get back *some* element with the given key -- so\n+    // search backwards to find the *first* one.\n+    //\n+    // (It'd be more efficient to use a \"galloping\" search\n+    // here, but it's not really worth it for small-ish\n+    // amounts of data.)\n+    let mut start = mid;\n+    while start > 0 {\n+        if key_fn(&data[start - 1]) == *key {\n+            start -= 1;\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    // Now search forward to find the *last* one.\n+    //\n+    // (It'd be more efficient to use a \"galloping\" search\n+    // here, but it's not really worth it for small-ish\n+    // amounts of data.)\n+    let mut end = mid + 1;\n+    let max = data.len();\n+    while end < max {\n+        if key_fn(&data[end]) == *key {\n+            end += 1;\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    &data[start..end]\n+}"}, {"sha": "d74febb5c0fc4a13e2530de71982520e3a944fcf", "filename": "src/librustc_data_structures/binary_search_util/test.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_data_structures%2Fbinary_search_util%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_data_structures%2Fbinary_search_util%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbinary_search_util%2Ftest.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,23 @@\n+use super::*;\n+\n+type Element = (usize, &'static str);\n+\n+fn test_map() -> Vec<Element> {\n+    let mut data = vec![(3, \"three-a\"), (0, \"zero\"), (3, \"three-b\"), (22, \"twenty-two\")];\n+    data.sort_by_key(get_key);\n+    data\n+}\n+\n+fn get_key(data: &Element) -> usize {\n+    data.0\n+}\n+\n+#[test]\n+fn binary_search_slice_test() {\n+    let map = test_map();\n+    assert_eq!(binary_search_slice(&map, get_key, &0), &[(0, \"zero\")]);\n+    assert_eq!(binary_search_slice(&map, get_key, &1), &[]);\n+    assert_eq!(binary_search_slice(&map, get_key, &3), &[(3, \"three-a\"), (3, \"three-b\")]);\n+    assert_eq!(binary_search_slice(&map, get_key, &22), &[(22, \"twenty-two\")]);\n+    assert_eq!(binary_search_slice(&map, get_key, &23), &[]);\n+}"}, {"sha": "5612778ce07ed1075b89c257745daacad3b4107b", "filename": "src/librustc_data_structures/graph/iterate/mod.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Fmod.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -1,5 +1,6 @@\n use super::super::indexed_vec::IndexVec;\n-use super::{DirectedGraph, WithSuccessors, WithNumNodes};\n+use super::{DirectedGraph, WithNumNodes, WithSuccessors};\n+use crate::bit_set::BitSet;\n \n #[cfg(test)]\n mod test;\n@@ -51,3 +52,36 @@ pub fn reverse_post_order<G: DirectedGraph + WithSuccessors + WithNumNodes>(\n     vec.reverse();\n     vec\n }\n+\n+/// A \"depth-first search\" iterator for a directed graph.\n+pub struct DepthFirstSearch<'graph, G>\n+where\n+    G: ?Sized + DirectedGraph + WithNumNodes + WithSuccessors,\n+{\n+    graph: &'graph G,\n+    stack: Vec<G::Node>,\n+    visited: BitSet<G::Node>,\n+}\n+\n+impl<G> DepthFirstSearch<'graph, G>\n+where\n+    G: ?Sized + DirectedGraph + WithNumNodes + WithSuccessors,\n+{\n+    pub fn new(graph: &'graph G, start_node: G::Node) -> Self {\n+        Self { graph, stack: vec![start_node], visited: BitSet::new_empty(graph.num_nodes()) }\n+    }\n+}\n+\n+impl<G> Iterator for DepthFirstSearch<'_, G>\n+where\n+    G: ?Sized + DirectedGraph + WithNumNodes + WithSuccessors,\n+{\n+    type Item = G::Node;\n+\n+    fn next(&mut self) -> Option<G::Node> {\n+        let DepthFirstSearch { stack, visited, graph } = self;\n+        let n = stack.pop()?;\n+        stack.extend(graph.successors(n).filter(|&m| visited.insert(m)));\n+        Some(n)\n+    }\n+}"}, {"sha": "2787fa3c6b1e4eb9dd5cf4d98f82c507f0a4fe22", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -5,6 +5,7 @@ pub mod implementation;\n pub mod iterate;\n mod reference;\n pub mod scc;\n+pub mod vec_graph;\n \n #[cfg(test)]\n mod test;\n@@ -17,6 +18,10 @@ pub trait WithNumNodes: DirectedGraph {\n     fn num_nodes(&self) -> usize;\n }\n \n+pub trait WithNumEdges: DirectedGraph {\n+    fn num_edges(&self) -> usize;\n+}\n+\n pub trait WithSuccessors: DirectedGraph\n where\n     Self: for<'graph> GraphSuccessors<'graph, Item = <Self as DirectedGraph>::Node>,\n@@ -25,6 +30,13 @@ where\n         &'graph self,\n         node: Self::Node,\n     ) -> <Self as GraphSuccessors<'graph>>::Iter;\n+\n+    fn depth_first_search(&self, from: Self::Node) -> iterate::DepthFirstSearch<'_, Self>\n+    where\n+        Self: WithNumNodes,\n+    {\n+        iterate::DepthFirstSearch::new(self, from)\n+    }\n }\n \n pub trait GraphSuccessors<'graph> {"}, {"sha": "78554cda77b44b2a8710e37667af151043b20d84", "filename": "src/librustc_data_structures/graph/scc/mod.rs", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -4,7 +4,8 @@\n //! O(n) time.\n \n use crate::fx::FxHashSet;\n-use crate::graph::{DirectedGraph, WithNumNodes, WithSuccessors};\n+use crate::graph::{DirectedGraph, WithNumNodes, WithNumEdges, WithSuccessors, GraphSuccessors};\n+use crate::graph::vec_graph::VecGraph;\n use crate::indexed_vec::{Idx, IndexVec};\n use std::ops::Range;\n \n@@ -58,6 +59,49 @@ impl<N: Idx, S: Idx> Sccs<N, S> {\n     pub fn successors(&self, scc: S) -> &[S] {\n         self.scc_data.successors(scc)\n     }\n+\n+    /// Construct the reverse graph of the SCC graph.\n+    pub fn reverse(&self) -> VecGraph<S> {\n+        VecGraph::new(\n+            self.num_sccs(),\n+            self.all_sccs()\n+                .flat_map(|source| self.successors(source).iter().map(move |&target| {\n+                    (target, source)\n+                }))\n+                .collect(),\n+        )\n+    }\n+}\n+\n+impl<N: Idx, S: Idx> DirectedGraph for Sccs<N, S> {\n+    type Node = S;\n+}\n+\n+impl<N: Idx, S: Idx> WithNumNodes for Sccs<N, S> {\n+    fn num_nodes(&self) -> usize {\n+        self.num_sccs()\n+    }\n+}\n+\n+impl<N: Idx, S: Idx> WithNumEdges for Sccs<N, S> {\n+    fn num_edges(&self) -> usize {\n+        self.scc_data.all_successors.len()\n+    }\n+}\n+\n+impl<N: Idx, S: Idx> GraphSuccessors<'graph> for Sccs<N, S> {\n+    type Item = S;\n+\n+    type Iter = std::iter::Cloned<std::slice::Iter<'graph, S>>;\n+}\n+\n+impl<N: Idx, S: Idx> WithSuccessors for Sccs<N, S> {\n+    fn successors<'graph>(\n+        &'graph self,\n+        node: S\n+    ) -> <Self as GraphSuccessors<'graph>>::Iter {\n+        self.successors(node).iter().cloned()\n+    }\n }\n \n impl<S: Idx> SccData<S> {"}, {"sha": "6fb1bb42d2cfd396b7c75a3c5110aef71d86ddc6", "filename": "src/librustc_data_structures/graph/vec_graph/mod.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_data_structures%2Fgraph%2Fvec_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_data_structures%2Fgraph%2Fvec_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fvec_graph%2Fmod.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,113 @@\n+use crate::indexed_vec::{Idx, IndexVec};\n+use crate::graph::{DirectedGraph, WithNumNodes, WithNumEdges, WithSuccessors, GraphSuccessors};\n+\n+#[cfg(test)]\n+mod test;\n+\n+pub struct VecGraph<N: Idx> {\n+    /// Maps from a given node to an index where the set of successors\n+    /// for that node starts. The index indexes into the `edges`\n+    /// vector. To find the range for a given node, we look up the\n+    /// start for that node and then the start for the next node\n+    /// (i.e., with an index 1 higher) and get the range between the\n+    /// two. This vector always has an extra entry so that this works\n+    /// even for the max element.\n+    node_starts: IndexVec<N, usize>,\n+\n+    edge_targets: Vec<N>,\n+}\n+\n+impl<N: Idx> VecGraph<N> {\n+    pub fn new(\n+        num_nodes: usize,\n+        mut edge_pairs: Vec<(N, N)>,\n+    ) -> Self {\n+        // Sort the edges by the source -- this is important.\n+        edge_pairs.sort();\n+\n+        let num_edges = edge_pairs.len();\n+\n+        // Store the *target* of each edge into `edge_targets`.\n+        let edge_targets: Vec<N> = edge_pairs.iter().map(|&(_, target)| target).collect();\n+\n+        // Create the *edge starts* array. We are iterating over over\n+        // the (sorted) edge pairs. We maintain the invariant that the\n+        // length of the `node_starts` arary is enough to store the\n+        // current source node -- so when we see that the source node\n+        // for an edge is greater than the current length, we grow the\n+        // edge-starts array by just enough.\n+        let mut node_starts = IndexVec::with_capacity(num_edges);\n+        for (index, &(source, _)) in edge_pairs.iter().enumerate() {\n+            // If we have a list like `[(0, x), (2, y)]`:\n+            //\n+            // - Start out with `node_starts` of `[]`\n+            // - Iterate to `(0, x)` at index 0:\n+            //   - Push one entry because `node_starts.len()` (0) is <= the source (0)\n+            //   - Leaving us with `node_starts` of `[0]`\n+            // - Iterate to `(2, y)` at index 1:\n+            //   - Push one entry because `node_starts.len()` (1) is <= the source (2)\n+            //   - Push one entry because `node_starts.len()` (2) is <= the source (2)\n+            //   - Leaving us with `node_starts` of `[0, 1, 1]`\n+            // - Loop terminates\n+            while node_starts.len() <= source.index() {\n+                node_starts.push(index);\n+            }\n+        }\n+\n+        // Pad out the `node_starts` array so that it has `num_nodes +\n+        // 1` entries. Continuing our example above, if `num_nodes` is\n+        // be `3`, we would push one more index: `[0, 1, 1, 2]`.\n+        //\n+        // Interpretation of that vector:\n+        //\n+        // [0, 1, 1, 2]\n+        //        ---- range for N=2\n+        //     ---- range for N=1\n+        //  ---- range for N=0\n+        while node_starts.len() <= num_nodes {\n+            node_starts.push(edge_targets.len());\n+        }\n+\n+        assert_eq!(node_starts.len(), num_nodes + 1);\n+\n+        Self { node_starts, edge_targets }\n+    }\n+\n+    /// Gets the successors for `source` as a slice.\n+    pub fn successors(&self, source: N) -> &[N] {\n+        let start_index = self.node_starts[source];\n+        let end_index = self.node_starts[source.plus(1)];\n+        &self.edge_targets[start_index..end_index]\n+    }\n+}\n+\n+impl<N: Idx> DirectedGraph for VecGraph<N> {\n+    type Node = N;\n+}\n+\n+impl<N: Idx> WithNumNodes for VecGraph<N> {\n+    fn num_nodes(&self) -> usize {\n+        self.node_starts.len() - 1\n+    }\n+}\n+\n+impl<N: Idx> WithNumEdges for VecGraph<N> {\n+    fn num_edges(&self) -> usize {\n+        self.edge_targets.len()\n+    }\n+}\n+\n+impl<N: Idx> GraphSuccessors<'graph> for VecGraph<N> {\n+    type Item = N;\n+\n+    type Iter = std::iter::Cloned<std::slice::Iter<'graph, N>>;\n+}\n+\n+impl<N: Idx> WithSuccessors for VecGraph<N> {\n+    fn successors<'graph>(\n+        &'graph self,\n+        node: N\n+    ) -> <Self as GraphSuccessors<'graph>>::Iter {\n+        self.successors(node).iter().cloned()\n+    }\n+}"}, {"sha": "97a9bd2ad0b08c74fb5528ddcef46aab09669409", "filename": "src/librustc_data_structures/graph/vec_graph/test.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_data_structures%2Fgraph%2Fvec_graph%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_data_structures%2Fgraph%2Fvec_graph%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fvec_graph%2Ftest.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,51 @@\n+use super::*;\n+\n+fn create_graph() -> VecGraph<usize> {\n+    // Create a simple graph\n+    //\n+    //          5\n+    //          |\n+    //          V\n+    //    0 --> 1 --> 2\n+    //          |\n+    //          v\n+    //          3 --> 4\n+    //\n+    //    6\n+\n+    VecGraph::new(\n+        7,\n+        vec![\n+            (0, 1),\n+            (1, 2),\n+            (1, 3),\n+            (3, 4),\n+            (5, 1),\n+        ],\n+    )\n+}\n+\n+#[test]\n+fn num_nodes() {\n+    let graph = create_graph();\n+    assert_eq!(graph.num_nodes(), 7);\n+}\n+\n+#[test]\n+fn succesors() {\n+    let graph = create_graph();\n+    assert_eq!(graph.successors(0), &[1]);\n+    assert_eq!(graph.successors(1), &[2, 3]);\n+    assert_eq!(graph.successors(2), &[]);\n+    assert_eq!(graph.successors(3), &[4]);\n+    assert_eq!(graph.successors(4), &[]);\n+    assert_eq!(graph.successors(5), &[1]);\n+    assert_eq!(graph.successors(6), &[]);\n+}\n+\n+#[test]\n+fn dfs() {\n+    let graph = create_graph();\n+    let dfs: Vec<_> = graph.depth_first_search(0).collect();\n+    assert_eq!(dfs, vec![0, 1, 3, 4, 2]);\n+}"}, {"sha": "b3a810a622d03dbdf7b2dd7479b1f21e83feeff2", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -19,8 +19,11 @@ pub trait Idx: Copy + 'static + Ord + Debug + Hash {\n     fn index(self) -> usize;\n \n     fn increment_by(&mut self, amount: usize) {\n-        let v = self.index() + amount;\n-        *self = Self::new(v);\n+        *self = self.plus(amount);\n+    }\n+\n+    fn plus(self, amount: usize) -> Self {\n+        Self::new(self.index() + amount)\n     }\n }\n \n@@ -167,6 +170,14 @@ macro_rules! newtype_index {\n             }\n         }\n \n+        impl std::ops::Add<usize> for $type {\n+            type Output = Self;\n+\n+            fn add(self, other: usize) -> Self {\n+                Self::new(self.index() + other)\n+            }\n+        }\n+\n         impl Idx for $type {\n             #[inline]\n             fn new(value: usize) -> Self {"}, {"sha": "98c809f7e25958d7ae98272bf52e0f44940766e6", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -72,6 +72,7 @@ macro_rules! unlikely {\n pub mod macros;\n pub mod svh;\n pub mod base_n;\n+pub mod binary_search_util;\n pub mod bit_set;\n pub mod box_region;\n pub mod const_cstr;"}, {"sha": "1d9e6064c416b38c813ac31d70522cf3b7d4d803", "filename": "src/librustc_mir/borrow_check/nll/constraints/graph.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -1,6 +1,6 @@\n use crate::borrow_check::nll::type_check::Locations;\n-use crate::borrow_check::nll::constraints::ConstraintIndex;\n-use crate::borrow_check::nll::constraints::{ConstraintSet, OutlivesConstraint};\n+use crate::borrow_check::nll::constraints::OutlivesConstraintIndex;\n+use crate::borrow_check::nll::constraints::{OutlivesConstraintSet, OutlivesConstraint};\n use rustc::mir::ConstraintCategory;\n use rustc::ty::RegionVid;\n use rustc_data_structures::graph;\n@@ -12,8 +12,8 @@ use syntax_pos::DUMMY_SP;\n /// -> R2` or `R2 -> R1` depending on the direction type `D`.\n crate struct ConstraintGraph<D: ConstraintGraphDirecton> {\n     _direction: D,\n-    first_constraints: IndexVec<RegionVid, Option<ConstraintIndex>>,\n-    next_constraints: IndexVec<ConstraintIndex, Option<ConstraintIndex>>,\n+    first_constraints: IndexVec<RegionVid, Option<OutlivesConstraintIndex>>,\n+    next_constraints: IndexVec<OutlivesConstraintIndex, Option<OutlivesConstraintIndex>>,\n }\n \n crate type NormalConstraintGraph = ConstraintGraph<Normal>;\n@@ -77,13 +77,13 @@ impl<D: ConstraintGraphDirecton> ConstraintGraph<D> {\n     /// reporting.\n     crate fn new(\n         direction: D,\n-        set: &ConstraintSet,\n+        set: &OutlivesConstraintSet,\n         num_region_vars: usize,\n     ) -> Self {\n         let mut first_constraints = IndexVec::from_elem_n(None, num_region_vars);\n-        let mut next_constraints = IndexVec::from_elem(None, &set.constraints);\n+        let mut next_constraints = IndexVec::from_elem(None, &set.outlives);\n \n-        for (idx, constraint) in set.constraints.iter_enumerated().rev() {\n+        for (idx, constraint) in set.outlives.iter_enumerated().rev() {\n             let head = &mut first_constraints[D::start_region(constraint)];\n             let next = &mut next_constraints[idx];\n             debug_assert!(next.is_none());\n@@ -103,7 +103,7 @@ impl<D: ConstraintGraphDirecton> ConstraintGraph<D> {\n     /// and not constraints.\n     crate fn region_graph<'rg>(\n         &'rg self,\n-        set: &'rg ConstraintSet,\n+        set: &'rg OutlivesConstraintSet,\n         static_region: RegionVid,\n     ) -> RegionGraph<'rg, D> {\n         RegionGraph::new(set, self, static_region)\n@@ -113,7 +113,7 @@ impl<D: ConstraintGraphDirecton> ConstraintGraph<D> {\n     crate fn outgoing_edges<'a>(\n         &'a self,\n         region_sup: RegionVid,\n-        constraints: &'a ConstraintSet,\n+        constraints: &'a OutlivesConstraintSet,\n         static_region: RegionVid,\n     ) -> Edges<'a, D> {\n         //if this is the `'static` region and the graph's direction is normal,\n@@ -142,8 +142,8 @@ impl<D: ConstraintGraphDirecton> ConstraintGraph<D> {\n \n crate struct Edges<'s, D: ConstraintGraphDirecton> {\n     graph: &'s ConstraintGraph<D>,\n-    constraints: &'s ConstraintSet,\n-    pointer: Option<ConstraintIndex>,\n+    constraints: &'s OutlivesConstraintSet,\n+    pointer: Option<OutlivesConstraintIndex>,\n     next_static_idx: Option<usize>,\n     static_region: RegionVid,\n }\n@@ -180,7 +180,7 @@ impl<'s, D: ConstraintGraphDirecton> Iterator for Edges<'s, D> {\n /// reverse) constraint graph. It implements the graph traits and is\n /// usd for doing the SCC computation.\n crate struct RegionGraph<'s, D: ConstraintGraphDirecton> {\n-    set: &'s ConstraintSet,\n+    set: &'s OutlivesConstraintSet,\n     constraint_graph: &'s ConstraintGraph<D>,\n     static_region: RegionVid,\n }\n@@ -191,7 +191,7 @@ impl<'s, D: ConstraintGraphDirecton> RegionGraph<'s, D> {\n     /// construct SCCs for region inference but also for error\n     /// reporting.\n     crate fn new(\n-        set: &'s ConstraintSet,\n+        set: &'s OutlivesConstraintSet,\n         constraint_graph: &'s ConstraintGraph<D>,\n         static_region: RegionVid,\n     ) -> Self {"}, {"sha": "6121ed0cf0d1c3282b87dc813de3f85b294e8407", "filename": "src/librustc_mir/borrow_check/nll/constraints/mod.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -1,37 +1,40 @@\n+use crate::borrow_check::nll::type_check::Locations;\n use rustc::mir::ConstraintCategory;\n use rustc::ty::RegionVid;\n use rustc_data_structures::graph::scc::Sccs;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-use crate::borrow_check::nll::type_check::Locations;\n-\n use std::fmt;\n-use std::ops::Deref;\n+use std::ops::Index;\n \n crate mod graph;\n \n+/// A set of NLL region constraints. These include \"outlives\"\n+/// constraints of the form `R1: R2`. Each constraint is identified by\n+/// a unique `OutlivesConstraintIndex` and you can index into the set\n+/// (`constraint_set[i]`) to access the constraint details.\n #[derive(Clone, Default)]\n-crate struct ConstraintSet {\n-    constraints: IndexVec<ConstraintIndex, OutlivesConstraint>,\n+crate struct OutlivesConstraintSet {\n+    outlives: IndexVec<OutlivesConstraintIndex, OutlivesConstraint>,\n }\n \n-impl ConstraintSet {\n+impl OutlivesConstraintSet {\n     crate fn push(&mut self, constraint: OutlivesConstraint) {\n         debug!(\n-            \"ConstraintSet::push({:?}: {:?} @ {:?}\",\n+            \"OutlivesConstraintSet::push({:?}: {:?} @ {:?}\",\n             constraint.sup, constraint.sub, constraint.locations\n         );\n         if constraint.sup == constraint.sub {\n             // 'a: 'a is pretty uninteresting\n             return;\n         }\n-        self.constraints.push(constraint);\n+        self.outlives.push(constraint);\n     }\n \n     /// Constructs a \"normal\" graph from the constraint set; the graph makes it\n     /// easy to find the constraints affecting a particular region.\n     ///\n     /// N.B., this graph contains a \"frozen\" view of the current\n-    /// constraints. Any new constraints added to the `ConstraintSet`\n+    /// constraints. Any new constraints added to the `OutlivesConstraintSet`\n     /// after the graph is built will not be present in the graph.\n     crate fn graph(&self, num_region_vars: usize) -> graph::NormalConstraintGraph {\n         graph::ConstraintGraph::new(graph::Normal, self, num_region_vars)\n@@ -54,13 +57,17 @@ impl ConstraintSet {\n         let region_graph = &constraint_graph.region_graph(self, static_region);\n         Sccs::new(region_graph)\n     }\n+\n+    crate fn outlives(&self) -> &IndexVec<OutlivesConstraintIndex, OutlivesConstraint> {\n+        &self.outlives\n+    }\n }\n \n-impl Deref for ConstraintSet {\n-    type Target = IndexVec<ConstraintIndex, OutlivesConstraint>;\n+impl Index<OutlivesConstraintIndex> for OutlivesConstraintSet {\n+    type Output = OutlivesConstraint;\n \n-    fn deref(&self) -> &Self::Target {\n-        &self.constraints\n+    fn index(&self, i: OutlivesConstraintIndex) -> &Self::Output {\n+        &self.outlives[i]\n     }\n }\n \n@@ -94,8 +101,8 @@ impl fmt::Debug for OutlivesConstraint {\n }\n \n newtype_index! {\n-    pub struct ConstraintIndex {\n-        DEBUG_FORMAT = \"ConstraintIndex({})\"\n+    pub struct OutlivesConstraintIndex {\n+        DEBUG_FORMAT = \"OutlivesConstraintIndex({})\"\n     }\n }\n "}, {"sha": "b5e2e111f38e518828a10d30581ed9badf3adef3", "filename": "src/librustc_mir/borrow_check/nll/member_constraints.rs", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmember_constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmember_constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmember_constraints.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,235 @@\n+use crate::rustc::ty::{self, Ty};\n+use rustc::hir::def_id::DefId;\n+use rustc::infer::region_constraints::MemberConstraint;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use std::hash::Hash;\n+use std::ops::Index;\n+use syntax_pos::Span;\n+\n+/// Compactly stores a set of `R0 member of [R1...Rn]` constraints,\n+/// indexed by the region `R0`.\n+crate struct MemberConstraintSet<'tcx, R>\n+where\n+    R: Copy + Hash + Eq,\n+{\n+    /// Stores the first \"member\" constraint for a given `R0`. This is an\n+    /// index into the `constraints` vector below.\n+    first_constraints: FxHashMap<R, NllMemberConstraintIndex>,\n+\n+    /// Stores the data about each `R0 member of [R1..Rn]` constraint.\n+    /// These are organized into a linked list, so each constraint\n+    /// contains the index of the next constraint with the same `R0`.\n+    constraints: IndexVec<NllMemberConstraintIndex, NllMemberConstraint<'tcx>>,\n+\n+    /// Stores the `R1..Rn` regions for *all* sets. For any given\n+    /// constraint, we keep two indices so that we can pull out a\n+    /// slice.\n+    choice_regions: Vec<ty::RegionVid>,\n+}\n+\n+/// Represents a `R0 member of [R1..Rn]` constraint\n+crate struct NllMemberConstraint<'tcx> {\n+    next_constraint: Option<NllMemberConstraintIndex>,\n+\n+    /// The opaque type whose hidden type is being inferred. (Used in error reporting.)\n+    crate opaque_type_def_id: DefId,\n+\n+    /// The span where the hidden type was instantiated.\n+    crate definition_span: Span,\n+\n+    /// The hidden type in which `R0` appears. (Used in error reporting.)\n+    crate hidden_ty: Ty<'tcx>,\n+\n+    /// The region `R0`.\n+    crate member_region_vid: ty::RegionVid,\n+\n+    /// Index of `R1` in `choice_regions` vector from `MemberConstraintSet`.\n+    start_index: usize,\n+\n+    /// Index of `Rn` in `choice_regions` vector from `MemberConstraintSet`.\n+    end_index: usize,\n+}\n+\n+newtype_index! {\n+    crate struct NllMemberConstraintIndex {\n+        DEBUG_FORMAT = \"MemberConstraintIndex({})\"\n+    }\n+}\n+\n+impl Default for MemberConstraintSet<'tcx, ty::RegionVid> {\n+    fn default() -> Self {\n+        Self {\n+            first_constraints: Default::default(),\n+            constraints: Default::default(),\n+            choice_regions: Default::default(),\n+        }\n+    }\n+}\n+\n+impl<'tcx> MemberConstraintSet<'tcx, ty::RegionVid> {\n+    /// Pushes a member constraint into the set.\n+    ///\n+    /// The input member constraint `m_c` is in the form produced by\n+    /// the the `rustc::infer` code.\n+    ///\n+    /// The `to_region_vid` callback fn is used to convert the regions\n+    /// within into `RegionVid` format -- it typically consults the\n+    /// `UniversalRegions` data structure that is known to the caller\n+    /// (but which this code is unaware of).\n+    crate fn push_constraint(\n+        &mut self,\n+        m_c: &MemberConstraint<'tcx>,\n+        mut to_region_vid: impl FnMut(ty::Region<'tcx>) -> ty::RegionVid,\n+    ) {\n+        debug!(\"push_constraint(m_c={:?})\", m_c);\n+        let member_region_vid: ty::RegionVid = to_region_vid(m_c.member_region);\n+        let next_constraint = self.first_constraints.get(&member_region_vid).cloned();\n+        let start_index = self.choice_regions.len();\n+        let end_index = start_index + m_c.choice_regions.len();\n+        debug!(\"push_constraint: member_region_vid={:?}\", member_region_vid);\n+        let constraint_index = self.constraints.push(NllMemberConstraint {\n+            next_constraint,\n+            member_region_vid,\n+            opaque_type_def_id: m_c.opaque_type_def_id,\n+            definition_span: m_c.definition_span,\n+            hidden_ty: m_c.hidden_ty,\n+            start_index,\n+            end_index,\n+        });\n+        self.first_constraints.insert(member_region_vid, constraint_index);\n+        self.choice_regions.extend(m_c.choice_regions.iter().map(|&r| to_region_vid(r)));\n+    }\n+}\n+\n+impl<R1> MemberConstraintSet<'tcx, R1>\n+where\n+    R1: Copy + Hash + Eq,\n+{\n+    /// Remap the \"member region\" key using `map_fn`, producing a new\n+    /// member constraint set.  This is used in the NLL code to map from\n+    /// the original `RegionVid` to an scc index. In some cases, we\n+    /// may have multiple `R1` values mapping to the same `R2` key -- that\n+    /// is ok, the two sets will be merged.\n+    crate fn into_mapped<R2>(\n+        self,\n+        mut map_fn: impl FnMut(R1) -> R2,\n+    ) -> MemberConstraintSet<'tcx, R2>\n+    where\n+        R2: Copy + Hash + Eq,\n+    {\n+        // We can re-use most of the original data, just tweaking the\n+        // linked list links a bit.\n+        //\n+        // For example if we had two keys `Ra` and `Rb` that both now\n+        // wind up mapped to the same key `S`, we would append the\n+        // linked list for `Ra` onto the end of the linked list for\n+        // `Rb` (or vice versa) -- this basically just requires\n+        // rewriting the final link from one list to point at the othe\n+        // other (see `append_list`).\n+\n+        let MemberConstraintSet { first_constraints, mut constraints, choice_regions } = self;\n+\n+        let mut first_constraints2 = FxHashMap::default();\n+        first_constraints2.reserve(first_constraints.len());\n+\n+        for (r1, start1) in first_constraints {\n+            let r2 = map_fn(r1);\n+            if let Some(&start2) = first_constraints2.get(&r2) {\n+                append_list(&mut constraints, start1, start2);\n+            }\n+            first_constraints2.insert(r2, start1);\n+        }\n+\n+        MemberConstraintSet {\n+            first_constraints: first_constraints2,\n+            constraints,\n+            choice_regions,\n+        }\n+    }\n+}\n+\n+impl<R> MemberConstraintSet<'tcx, R>\n+where\n+    R: Copy + Hash + Eq,\n+{\n+    crate fn all_indices(\n+        &self,\n+    ) -> impl Iterator<Item = NllMemberConstraintIndex> {\n+        self.constraints.indices()\n+    }\n+\n+    /// Iterate down the constraint indices associated with a given\n+    /// peek-region.  You can then use `choice_regions` and other\n+    /// methods to access data.\n+    crate fn indices(\n+        &self,\n+        member_region_vid: R,\n+    ) -> impl Iterator<Item = NllMemberConstraintIndex> + '_ {\n+        let mut next = self.first_constraints.get(&member_region_vid).cloned();\n+        std::iter::from_fn(move || -> Option<NllMemberConstraintIndex> {\n+            if let Some(current) = next {\n+                next = self.constraints[current].next_constraint;\n+                Some(current)\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+\n+    /// Returns the \"choice regions\" for a given member\n+    /// constraint. This is the `R1..Rn` from a constraint like:\n+    ///\n+    /// ```\n+    /// R0 member of [R1..Rn]\n+    /// ```\n+    crate fn choice_regions(&self, pci: NllMemberConstraintIndex) -> &[ty::RegionVid] {\n+        let NllMemberConstraint { start_index, end_index, .. } = &self.constraints[pci];\n+        &self.choice_regions[*start_index..*end_index]\n+    }\n+}\n+\n+impl<'tcx, R> Index<NllMemberConstraintIndex> for MemberConstraintSet<'tcx, R>\n+where\n+    R: Copy + Hash + Eq,\n+{\n+    type Output = NllMemberConstraint<'tcx>;\n+\n+    fn index(&self, i: NllMemberConstraintIndex) -> &NllMemberConstraint<'tcx> {\n+        &self.constraints[i]\n+    }\n+}\n+\n+/// Given a linked list starting at `source_list` and another linked\n+/// list starting at `target_list`, modify `target_list` so that it is\n+/// followed by `source_list`.\n+///\n+/// Before:\n+///\n+/// ```\n+/// target_list: A -> B -> C -> (None)\n+/// source_list: D -> E -> F -> (None)\n+/// ```\n+///\n+/// After:\n+///\n+/// ```\n+/// target_list: A -> B -> C -> D -> E -> F -> (None)\n+/// ```\n+fn append_list(\n+    constraints: &mut IndexVec<NllMemberConstraintIndex, NllMemberConstraint<'_>>,\n+    target_list: NllMemberConstraintIndex,\n+    source_list: NllMemberConstraintIndex,\n+) {\n+    let mut p = target_list;\n+    loop {\n+        let mut r = &mut constraints[p];\n+        match r.next_constraint {\n+            Some(q) => p = q,\n+            None => {\n+                r.next_constraint = Some(source_list);\n+                return;\n+            }\n+        }\n+    }\n+}"}, {"sha": "eb63e0de195e5d6692d56ad9e94d9edb4514ab3e", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -37,6 +37,7 @@ crate mod type_check;\n mod universal_regions;\n \n mod constraints;\n+mod member_constraints;\n \n use self::facts::AllFacts;\n use self::region_infer::RegionInferenceContext;\n@@ -129,6 +130,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n         placeholder_index_to_region: _,\n         mut liveness_constraints,\n         outlives_constraints,\n+        member_constraints,\n         closure_bounds_mapping,\n         type_tests,\n     } = constraints;\n@@ -150,6 +152,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n         universal_region_relations,\n         body,\n         outlives_constraints,\n+        member_constraints,\n         closure_bounds_mapping,\n         type_tests,\n         liveness_constraints,"}, {"sha": "d4f6ce8801e63689639e3949c20cadca1a1d619b", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dump_mir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -71,7 +71,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n         }\n \n-        let mut constraints: Vec<_> = self.constraints.iter().collect();\n+        let mut constraints: Vec<_> = self.constraints.outlives().iter().collect();\n         constraints.sort();\n         for constraint in &constraints {\n             let OutlivesConstraint {"}, {"sha": "9e08961f440f2ab42ae1c05eac54047e31c53228", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -1,4 +1,5 @@\n use crate::borrow_check::nll::constraints::OutlivesConstraint;\n+use crate::borrow_check::nll::region_infer::AppliedMemberConstraint;\n use crate::borrow_check::nll::region_infer::RegionInferenceContext;\n use crate::borrow_check::nll::type_check::Locations;\n use crate::borrow_check::nll::universal_regions::DefiningTy;\n@@ -195,6 +196,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         Trace::NotVisited => {\n                             bug!(\"found unvisited region {:?} on path to {:?}\", p, r)\n                         }\n+\n                         Trace::FromOutlivesConstraint(c) => {\n                             result.push(c);\n                             p = c.sup;\n@@ -211,10 +213,30 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // Otherwise, walk over the outgoing constraints and\n             // enqueue any regions we find, keeping track of how we\n             // reached them.\n+\n+            // A constraint like `'r: 'x` can come from our constraint\n+            // graph.\n             let fr_static = self.universal_regions.fr_static;\n-            for constraint in self.constraint_graph\n-                .outgoing_edges(r, &self.constraints, fr_static)\n-            {\n+            let outgoing_edges_from_graph = self.constraint_graph\n+                .outgoing_edges(r, &self.constraints, fr_static);\n+\n+\n+            // But member constraints can also give rise to `'r: 'x`\n+            // edges that were not part of the graph initially, so\n+            // watch out for those.\n+            let outgoing_edges_from_picks = self.applied_member_constraints(r)\n+                .iter()\n+                .map(|&AppliedMemberConstraint { min_choice, member_constraint_index, .. }| {\n+                    let p_c = &self.member_constraints[member_constraint_index];\n+                    OutlivesConstraint {\n+                        sup: r,\n+                        sub: min_choice,\n+                        locations: Locations::All(p_c.definition_span),\n+                        category: ConstraintCategory::OpaqueType,\n+                    }\n+                });\n+\n+            for constraint in outgoing_edges_from_graph.chain(outgoing_edges_from_picks) {\n                 debug_assert_eq!(constraint.sup, r);\n                 let sub_region = constraint.sub;\n                 if let Trace::NotVisited = context[sub_region] {\n@@ -687,7 +709,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     // Finds some region R such that `fr1: R` and `R` is live at\n     // `elem`.\n-    crate fn find_sub_region_live_at(&self, fr1: RegionVid, elem: Location) -> RegionVid {\n+    crate fn find_sub_region_live_at(\n+        &self,\n+        fr1: RegionVid,\n+        elem: Location,\n+    ) -> RegionVid {\n         debug!(\"find_sub_region_live_at(fr1={:?}, elem={:?})\", fr1, elem);\n         self.find_constraint_paths_between_regions(fr1, |r| {\n             // First look for some `r` such that `fr1: r` and `r` is live at `elem`\n@@ -729,8 +755,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         fr1: RegionVid,\n         fr2: RegionVid,\n     ) -> (ConstraintCategory, Span) {\n-        let (category, _, span) =\n-            self.best_blame_constraint(body, fr1, |r| self.provides_universal_region(r, fr1, fr2));\n+        let (category, _, span) = self.best_blame_constraint(\n+            body,\n+            fr1,\n+            |r| self.provides_universal_region(r, fr1, fr2),\n+        );\n         (category, span)\n     }\n "}, {"sha": "fdf2af9f44ebcae25a6825d8753f5611a01f0ac1", "filename": "src/librustc_mir/borrow_check/nll/region_infer/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -63,7 +63,7 @@ impl<'a, 'this, 'tcx> dot::GraphWalk<'this> for RawConstraints<'a, 'tcx> {\n         vids.into()\n     }\n     fn edges(&'this self) -> dot::Edges<'this, OutlivesConstraint> {\n-        (&self.regioncx.constraints.raw[..]).into()\n+        (&self.regioncx.constraints.outlives().raw[..]).into()\n     }\n \n     // Render `a: b` as `a -> b`, indicating the flow"}, {"sha": "4e609460c1f70aeb92ac635c032b79a7e23ae7f1", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 346, "deletions": 117, "changes": 463, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -1,25 +1,32 @@\n use super::universal_regions::UniversalRegions;\n use crate::borrow_check::nll::constraints::graph::NormalConstraintGraph;\n-use crate::borrow_check::nll::constraints::{ConstraintSccIndex, ConstraintSet, OutlivesConstraint};\n+use crate::borrow_check::nll::constraints::{\n+    ConstraintSccIndex, OutlivesConstraint, OutlivesConstraintSet,\n+};\n+use crate::borrow_check::nll::member_constraints::{MemberConstraintSet, NllMemberConstraintIndex};\n use crate::borrow_check::nll::region_infer::values::{\n-    PlaceholderIndices, RegionElement, ToElementIndex\n+    PlaceholderIndices, RegionElement, ToElementIndex,\n };\n-use crate::borrow_check::Upvar;\n use crate::borrow_check::nll::type_check::free_region_relations::UniversalRegionRelations;\n use crate::borrow_check::nll::type_check::Locations;\n+use crate::borrow_check::Upvar;\n use rustc::hir::def_id::DefId;\n-use rustc::infer::canonical::QueryRegionConstraint;\n+use rustc::infer::canonical::QueryOutlivesConstraint;\n+use rustc::infer::opaque_types;\n use rustc::infer::region_constraints::{GenericKind, VarInfos, VerifyBound};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin, RegionVariableOrigin};\n use rustc::mir::{\n-    ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements,\n-    ConstraintCategory, Local, Location, Body,\n+    Body, ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements,\n+    ConstraintCategory, Local, Location,\n };\n use rustc::ty::{self, subst::SubstsRef, RegionVid, Ty, TyCtxt, TypeFoldable};\n use rustc::util::common::{self, ErrorReported};\n+use rustc_data_structures::binary_search_util;\n use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::graph::WithSuccessors;\n use rustc_data_structures::graph::scc::Sccs;\n+use rustc_data_structures::graph::vec_graph::VecGraph;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_errors::{Diagnostic, DiagnosticBuilder};\n use syntax_pos::Span;\n@@ -49,17 +56,31 @@ pub struct RegionInferenceContext<'tcx> {\n     liveness_constraints: LivenessValues<RegionVid>,\n \n     /// The outlives constraints computed by the type-check.\n-    constraints: Rc<ConstraintSet>,\n+    constraints: Rc<OutlivesConstraintSet>,\n \n     /// The constraint-set, but in graph form, making it easy to traverse\n     /// the constraints adjacent to a particular region. Used to construct\n     /// the SCC (see `constraint_sccs`) and for error reporting.\n     constraint_graph: Rc<NormalConstraintGraph>,\n \n-    /// The SCC computed from `constraints` and the constraint graph. Used to\n+    /// The SCC computed from `constraints` and the constraint\n+    /// graph. We have an edge from SCC A to SCC B if `A: B`. Used to\n     /// compute the values of each region.\n     constraint_sccs: Rc<Sccs<RegionVid, ConstraintSccIndex>>,\n \n+    /// Reverse of the SCC constraint graph -- i.e., an edge `A -> B`\n+    /// exists if `B: A`. Computed lazilly.\n+    rev_constraint_graph: Option<Rc<VecGraph<ConstraintSccIndex>>>,\n+\n+    /// The \"R0 member of [R1..Rn]\" constraints, indexed by SCC.\n+    member_constraints: Rc<MemberConstraintSet<'tcx, ConstraintSccIndex>>,\n+\n+    /// Records the member constraints that we applied to each scc.\n+    /// This is useful for error reporting. Once constraint\n+    /// propagation is done, this vector is sorted according to\n+    /// `member_region_scc`.\n+    member_constraints_applied: Vec<AppliedMemberConstraint>,\n+\n     /// Map closure bounds to a `Span` that should be used for error reporting.\n     closure_bounds_mapping:\n         FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>>,\n@@ -95,6 +116,32 @@ pub struct RegionInferenceContext<'tcx> {\n     universal_region_relations: Rc<UniversalRegionRelations<'tcx>>,\n }\n \n+/// Each time that `apply_member_constraint` is successful, it appends\n+/// one of these structs to the `member_constraints_applied` field.\n+/// This is used in error reporting to trace out what happened.\n+///\n+/// The way that `apply_member_constraint` works is that it effectively\n+/// adds a new lower bound to the SCC it is analyzing: so you wind up\n+/// with `'R: 'O` where `'R` is the pick-region and `'O` is the\n+/// minimal viable option.\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]\n+struct AppliedMemberConstraint {\n+    /// The SCC that was affected. (The \"member region\".)\n+    ///\n+    /// The vector if `AppliedMemberConstraint` elements is kept sorted\n+    /// by this field.\n+    member_region_scc: ConstraintSccIndex,\n+\n+    /// The \"best option\" that `apply_member_constraint` found -- this was\n+    /// added as an \"ad-hoc\" lower-bound to `member_region_scc`.\n+    min_choice: ty::RegionVid,\n+\n+    /// The \"member constraint index\" -- we can find out details about\n+    /// the constraint from\n+    /// `set.member_constraints[member_constraint_index]`.\n+    member_constraint_index: NllMemberConstraintIndex,\n+}\n+\n struct RegionDefinition<'tcx> {\n     /// What kind of variable is this -- a free region? existential\n     /// variable? etc. (See the `NLLRegionVariableOrigin` for more\n@@ -186,7 +233,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         placeholder_indices: Rc<PlaceholderIndices>,\n         universal_region_relations: Rc<UniversalRegionRelations<'tcx>>,\n         _body: &Body<'tcx>,\n-        outlives_constraints: ConstraintSet,\n+        outlives_constraints: OutlivesConstraintSet,\n+        member_constraints_in: MemberConstraintSet<'tcx, RegionVid>,\n         closure_bounds_mapping: FxHashMap<\n             Location,\n             FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>,\n@@ -218,12 +266,18 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         let scc_representatives = Self::compute_scc_representatives(&constraint_sccs, &definitions);\n \n+        let member_constraints =\n+            Rc::new(member_constraints_in.into_mapped(|r| constraint_sccs.scc(r)));\n+\n         let mut result = Self {\n             definitions,\n             liveness_constraints,\n             constraints,\n             constraint_graph,\n             constraint_sccs,\n+            rev_constraint_graph: None,\n+            member_constraints,\n+            member_constraints_applied: Vec::new(),\n             closure_bounds_mapping,\n             scc_universes,\n             scc_representatives,\n@@ -341,9 +395,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         debug!(\n                             \"init_free_and_bound_regions: placeholder {:?} is \\\n                              not compatible with universe {:?} of its SCC {:?}\",\n-                            placeholder,\n-                            scc_universe,\n-                            scc,\n+                            placeholder, scc_universe, scc,\n                         );\n                         self.add_incompatible_universe(scc);\n                     }\n@@ -394,6 +446,18 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         self.scc_universes[scc]\n     }\n \n+    /// Once region solving has completed, this function will return\n+    /// the member constraints that were applied to the value of a given\n+    /// region `r`. See `AppliedMemberConstraint`.\n+    fn applied_member_constraints(&self, r: impl ToRegionVid) -> &[AppliedMemberConstraint] {\n+        let scc = self.constraint_sccs.scc(r.to_region_vid());\n+        binary_search_util::binary_search_slice(\n+            &self.member_constraints_applied,\n+            |applied| applied.member_region_scc,\n+            &scc,\n+        )\n+    }\n+\n     /// Performs region inference and report errors if we see any\n     /// unsatisfiable constraints. If this is a closure, returns the\n     /// region requirements to propagate to our creator, if any.\n@@ -428,11 +492,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // to store those. Otherwise, we'll pass in `None` to the\n         // functions below, which will trigger them to report errors\n         // eagerly.\n-        let mut outlives_requirements = if infcx.tcx.is_closure(mir_def_id) {\n-            Some(vec![])\n-        } else {\n-            None\n-        };\n+        let mut outlives_requirements =\n+            if infcx.tcx.is_closure(mir_def_id) { Some(vec![]) } else { None };\n \n         self.check_type_tests(\n             infcx,\n@@ -451,16 +512,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             errors_buffer,\n         );\n \n+        self.check_member_constraints(infcx, mir_def_id, errors_buffer);\n+\n         let outlives_requirements = outlives_requirements.unwrap_or(vec![]);\n \n         if outlives_requirements.is_empty() {\n             None\n         } else {\n             let num_external_vids = self.universal_regions.num_global_and_external_regions();\n-            Some(ClosureRegionRequirements {\n-                num_external_vids,\n-                outlives_requirements,\n-            })\n+            Some(ClosureRegionRequirements { num_external_vids, outlives_requirements })\n         }\n     }\n \n@@ -472,7 +532,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         debug!(\"propagate_constraints()\");\n \n         debug!(\"propagate_constraints: constraints={:#?}\", {\n-            let mut constraints: Vec<_> = self.constraints.iter().collect();\n+            let mut constraints: Vec<_> = self.constraints.outlives().iter().collect();\n             constraints.sort();\n             constraints\n                 .into_iter()\n@@ -488,8 +548,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         for scc_index in self.constraint_sccs.all_sccs() {\n             self.propagate_constraint_sccs_if_new(scc_index, visited);\n         }\n+\n+        // Sort the applied member constraints so we can binary search\n+        // through them later.\n+        self.member_constraints_applied.sort_by_key(|applied| applied.member_region_scc);\n     }\n \n+    /// Computes the value of the SCC `scc_a` if it has not already\n+    /// been computed. The `visited` parameter is a bitset\n     #[inline]\n     fn propagate_constraint_sccs_if_new(\n         &mut self,\n@@ -501,6 +567,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n     }\n \n+    /// Computes the value of the SCC `scc_a`, which has not yet been\n+    /// computed. This works by first computing all successors of the\n+    /// SCC (if they haven't been computed already) and then unioning\n+    /// together their elements.\n     fn propagate_constraint_sccs_new(\n         &mut self,\n         scc_a: ConstraintSccIndex,\n@@ -510,10 +580,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         // Walk each SCC `B` such that `A: B`...\n         for &scc_b in constraint_sccs.successors(scc_a) {\n-            debug!(\n-                \"propagate_constraint_sccs: scc_a = {:?} scc_b = {:?}\",\n-                scc_a, scc_b\n-            );\n+            debug!(\"propagate_constraint_sccs: scc_a = {:?} scc_b = {:?}\", scc_a, scc_b);\n \n             // ...compute the value of `B`...\n             self.propagate_constraint_sccs_if_new(scc_b, visited);\n@@ -531,13 +598,184 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n         }\n \n+        // Now take member constraints into account.\n+        let member_constraints = self.member_constraints.clone();\n+        for m_c_i in member_constraints.indices(scc_a) {\n+            self.apply_member_constraint(\n+                scc_a,\n+                m_c_i,\n+                member_constraints.choice_regions(m_c_i),\n+            );\n+        }\n+\n         debug!(\n             \"propagate_constraint_sccs: scc_a = {:?} has value {:?}\",\n             scc_a,\n             self.scc_values.region_value_str(scc_a),\n         );\n     }\n \n+    /// Invoked for each `R0 member of [R1..Rn]` constraint.\n+    ///\n+    /// `scc` is the SCC containing R0, and `choice_regions` are the\n+    /// `R1..Rn` regions -- they are always known to be universal\n+    /// regions (and if that's not true, we just don't attempt to\n+    /// enforce the constraint).\n+    ///\n+    /// The current value of `scc` at the time the method is invoked\n+    /// is considered a *lower bound*.  If possible, we will modify\n+    /// the constraint to set it equal to one of the option regions.\n+    /// If we make any changes, returns true, else false.\n+    fn apply_member_constraint(\n+        &mut self,\n+        scc: ConstraintSccIndex,\n+        member_constraint_index: NllMemberConstraintIndex,\n+        choice_regions: &[ty::RegionVid],\n+    ) -> bool {\n+        debug!(\"apply_member_constraint(scc={:?}, choice_regions={:#?})\", scc, choice_regions,);\n+\n+        if let Some(uh_oh) =\n+            choice_regions.iter().find(|&&r| !self.universal_regions.is_universal_region(r))\n+        {\n+            // FIXME(#61773): This case can only occur with\n+            // `impl_trait_in_bindings`, I believe, and we are just\n+            // opting not to handle it for now. See #61773 for\n+            // details.\n+            bug!(\n+                \"member constraint for `{:?}` has an option region `{:?}` \\\n+                 that is not a universal region\",\n+                self.member_constraints[member_constraint_index].opaque_type_def_id,\n+                uh_oh,\n+            );\n+        }\n+\n+        // Create a mutable vector of the options. We'll try to winnow\n+        // them down.\n+        let mut choice_regions: Vec<ty::RegionVid> = choice_regions.to_vec();\n+\n+        // The 'member region' in a member constraint is part of the\n+        // hidden type, which must be in the root universe. Therefore,\n+        // it cannot have any placeholders in its value.\n+        assert!(self.scc_universes[scc] == ty::UniverseIndex::ROOT);\n+        debug_assert!(\n+            self.scc_values.placeholders_contained_in(scc).next().is_none(),\n+            \"scc {:?} in a member constraint has placeholder value: {:?}\",\n+            scc,\n+            self.scc_values.region_value_str(scc),\n+        );\n+\n+        // The existing value for `scc` is a lower-bound. This will\n+        // consist of some set `{P} + {LB}` of points `{P}` and\n+        // lower-bound free regions `{LB}`. As each choice region `O`\n+        // is a free region, it will outlive the points. But we can\n+        // only consider the option `O` if `O: LB`.\n+        choice_regions.retain(|&o_r| {\n+            self.scc_values\n+                .universal_regions_outlived_by(scc)\n+                .all(|lb| self.universal_region_relations.outlives(o_r, lb))\n+        });\n+        debug!(\"apply_member_constraint: after lb, choice_regions={:?}\", choice_regions);\n+\n+        // Now find all the *upper bounds* -- that is, each UB is a\n+        // free region that must outlive the member region `R0` (`UB:\n+        // R0`). Therefore, we need only keep an option `O` if `UB: O`\n+        // for all UB.\n+        if choice_regions.len() > 1 {\n+            let universal_region_relations = self.universal_region_relations.clone();\n+            let rev_constraint_graph = self.rev_constraint_graph();\n+            for ub in self.upper_bounds(scc, &rev_constraint_graph) {\n+                debug!(\"apply_member_constraint: ub={:?}\", ub);\n+                choice_regions.retain(|&o_r| universal_region_relations.outlives(ub, o_r));\n+            }\n+            debug!(\"apply_member_constraint: after ub, choice_regions={:?}\", choice_regions);\n+        }\n+\n+        // If we ruled everything out, we're done.\n+        if choice_regions.is_empty() {\n+            return false;\n+        }\n+\n+        // Otherwise, we need to find the minimum remaining choice, if\n+        // any, and take that.\n+        debug!(\"apply_member_constraint: choice_regions remaining are {:#?}\", choice_regions);\n+        let min = |r1: ty::RegionVid, r2: ty::RegionVid| -> Option<ty::RegionVid> {\n+            let r1_outlives_r2 = self.universal_region_relations.outlives(r1, r2);\n+            let r2_outlives_r1 = self.universal_region_relations.outlives(r2, r1);\n+            if r1_outlives_r2 && r2_outlives_r1 {\n+                Some(r1.min(r2))\n+            } else if r1_outlives_r2 {\n+                Some(r2)\n+            } else if r2_outlives_r1 {\n+                Some(r1)\n+            } else {\n+                None\n+            }\n+        };\n+        let mut min_choice = choice_regions[0];\n+        for &other_option in &choice_regions[1..] {\n+            debug!(\n+                \"apply_member_constraint: min_choice={:?} other_option={:?}\",\n+                min_choice, other_option,\n+            );\n+            match min(min_choice, other_option) {\n+                Some(m) => min_choice = m,\n+                None => {\n+                    debug!(\n+                        \"apply_member_constraint: {:?} and {:?} are incomparable; no min choice\",\n+                        min_choice, other_option,\n+                    );\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        let min_choice_scc = self.constraint_sccs.scc(min_choice);\n+        debug!(\n+            \"apply_member_constraint: min_choice={:?} best_choice_scc={:?}\",\n+            min_choice,\n+            min_choice_scc,\n+        );\n+        if self.scc_values.add_region(scc, min_choice_scc) {\n+            self.member_constraints_applied.push(AppliedMemberConstraint {\n+                member_region_scc: scc,\n+                min_choice,\n+                member_constraint_index,\n+            });\n+\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// Compute and return the reverse SCC-based constraint graph (lazilly).\n+    fn upper_bounds(\n+        &'a mut self,\n+        scc0: ConstraintSccIndex,\n+        rev_constraint_graph: &'a VecGraph<ConstraintSccIndex>,\n+    ) -> impl Iterator<Item = RegionVid> + 'a {\n+        let scc_values = &self.scc_values;\n+        let mut duplicates = FxHashSet::default();\n+        rev_constraint_graph\n+            .depth_first_search(scc0)\n+            .skip(1)\n+            .flat_map(move |scc1| scc_values.universal_regions_outlived_by(scc1))\n+            .filter(move |&r| duplicates.insert(r))\n+    }\n+\n+    /// Compute and return the reverse SCC-based constraint graph (lazilly).\n+    fn rev_constraint_graph(\n+        &mut self,\n+    ) -> Rc<VecGraph<ConstraintSccIndex>> {\n+        if let Some(g) = &self.rev_constraint_graph {\n+            return g.clone();\n+        }\n+\n+        let rev_graph = Rc::new(self.constraint_sccs.reverse());\n+        self.rev_constraint_graph = Some(rev_graph.clone());\n+        rev_graph\n+    }\n+\n     /// Returns `true` if all the elements in the value of `scc_b` are nameable\n     /// in `scc_a`. Used during constraint propagation, and only once\n     /// the value of `scc_b` has been computed.\n@@ -554,9 +792,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // Otherwise, we have to iterate over the universe elements in\n         // B's value, and check whether all of them are nameable\n         // from universe_a\n-        self.scc_values\n-            .placeholders_contained_in(scc_b)\n-            .all(|p| universe_a.can_name(p.universe))\n+        self.scc_values.placeholders_contained_in(scc_b).all(|p| universe_a.can_name(p.universe))\n     }\n \n     /// Extend `scc` so that it can outlive some placeholder region\n@@ -731,12 +967,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> bool {\n         let tcx = infcx.tcx;\n \n-        let TypeTest {\n-            generic_kind,\n-            lower_bound,\n-            locations,\n-            verify_bound: _,\n-        } = type_test;\n+        let TypeTest { generic_kind, lower_bound, locations, verify_bound: _ } = type_test;\n \n         let generic_ty = generic_kind.to_ty(tcx);\n         let subject = match self.try_promote_type_test_subject(infcx, generic_ty) {\n@@ -886,22 +1117,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// except that it converts further takes the non-local upper\n     /// bound of `'y`, so that the final result is non-local.\n     fn non_local_universal_upper_bound(&self, r: RegionVid) -> RegionVid {\n-        debug!(\n-            \"non_local_universal_upper_bound(r={:?}={})\",\n-            r,\n-            self.region_value_str(r)\n-        );\n+        debug!(\"non_local_universal_upper_bound(r={:?}={})\", r, self.region_value_str(r));\n \n         let lub = self.universal_upper_bound(r);\n \n         // Grow further to get smallest universal region known to\n         // creator.\n         let non_local_lub = self.universal_region_relations.non_local_upper_bound(lub);\n \n-        debug!(\n-            \"non_local_universal_upper_bound: non_local_lub={:?}\",\n-            non_local_lub\n-        );\n+        debug!(\"non_local_universal_upper_bound: non_local_lub={:?}\", non_local_lub);\n \n         non_local_lub\n     }\n@@ -921,11 +1145,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// - For each `end('x)` element in `'r`, compute the mutual LUB, yielding\n     ///   a result `'y`.\n     fn universal_upper_bound(&self, r: RegionVid) -> RegionVid {\n-        debug!(\n-            \"universal_upper_bound(r={:?}={})\",\n-            r,\n-            self.region_value_str(r)\n-        );\n+        debug!(\"universal_upper_bound(r={:?}={})\", r, self.region_value_str(r));\n \n         // Find the smallest universal region that contains all other\n         // universal regions within `region`.\n@@ -950,10 +1170,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         lower_bound: RegionVid,\n         verify_bound: &VerifyBound<'tcx>,\n     ) -> bool {\n-        debug!(\n-            \"eval_verify_bound(lower_bound={:?}, verify_bound={:?})\",\n-            lower_bound, verify_bound\n-        );\n+        debug!(\"eval_verify_bound(lower_bound={:?}, verify_bound={:?})\", lower_bound, verify_bound);\n \n         match verify_bound {\n             VerifyBound::IfEq(test_ty, verify_bound1) => {\n@@ -962,7 +1179,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n             VerifyBound::OutlivedBy(r) => {\n                 let r_vid = self.to_region_vid(r);\n-                self.eval_outlives(body, r_vid, lower_bound)\n+                self.eval_outlives(r_vid, lower_bound)\n             }\n \n             VerifyBound::AnyBound(verify_bounds) => verify_bounds.iter().any(|verify_bound| {\n@@ -1035,22 +1252,24 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         })\n     }\n \n-    // Evaluate whether `sup_region: sub_region @ point`.\n-    fn eval_outlives(\n-        &self,\n-        _body: &Body<'tcx>,\n-        sup_region: RegionVid,\n-        sub_region: RegionVid,\n-    ) -> bool {\n+    // Evaluate whether `sup_region == sub_region`.\n+    fn eval_equal(&self, r1: RegionVid, r2: RegionVid) -> bool {\n+        self.eval_outlives(r1, r2) && self.eval_outlives(r2, r1)\n+    }\n+\n+    // Evaluate whether `sup_region: sub_region`.\n+    fn eval_outlives(&self, sup_region: RegionVid, sub_region: RegionVid) -> bool {\n         debug!(\"eval_outlives({:?}: {:?})\", sup_region, sub_region);\n \n         debug!(\n-            \"eval_outlives: sup_region's value = {:?}\",\n+            \"eval_outlives: sup_region's value = {:?} universal={:?}\",\n             self.region_value_str(sup_region),\n+            self.universal_regions.is_universal_region(sup_region),\n         );\n         debug!(\n-            \"eval_outlives: sub_region's value = {:?}\",\n+            \"eval_outlives: sub_region's value = {:?} universal={:?}\",\n             self.region_value_str(sub_region),\n+            self.universal_regions.is_universal_region(sub_region),\n         );\n \n         let sub_region_scc = self.constraint_sccs.scc(sub_region);\n@@ -1062,9 +1281,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // now). Therefore, the sup-region outlives the sub-region if,\n         // for each universal region R1 in the sub-region, there\n         // exists some region R2 in the sup-region that outlives R1.\n-        let universal_outlives = self.scc_values\n-            .universal_regions_outlived_by(sub_region_scc)\n-            .all(|r1| {\n+        let universal_outlives =\n+            self.scc_values.universal_regions_outlived_by(sub_region_scc).all(|r1| {\n                 self.scc_values\n                     .universal_regions_outlived_by(sup_region_scc)\n                     .any(|r2| self.universal_region_relations.outlives(r2, r1))\n@@ -1082,8 +1300,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             return true;\n         }\n \n-        self.scc_values\n-            .contains_points(sup_region_scc, sub_region_scc)\n+        self.scc_values.contains_points(sup_region_scc, sub_region_scc)\n     }\n \n     /// Once regions have been propagated, this method is used to see\n@@ -1165,12 +1382,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // Because this free region must be in the ROOT universe, we\n         // know it cannot contain any bound universes.\n         assert!(self.scc_universes[longer_fr_scc] == ty::UniverseIndex::ROOT);\n-        debug_assert!(\n-            self.scc_values\n-                .placeholders_contained_in(longer_fr_scc)\n-                .next()\n-                .is_none()\n-        );\n+        debug_assert!(self.scc_values.placeholders_contained_in(longer_fr_scc).next().is_none());\n \n         // Only check all of the relations for the main representative of each\n         // SCC, otherwise just check that we outlive said representative. This\n@@ -1224,9 +1436,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         errors_buffer: &mut Vec<Diagnostic>,\n     ) -> Option<ErrorReported> {\n         // If it is known that `fr: o`, carry on.\n-        if self.universal_region_relations\n-            .outlives(longer_fr, shorter_fr)\n-        {\n+        if self.universal_region_relations.outlives(longer_fr, shorter_fr) {\n             return None;\n         }\n \n@@ -1240,9 +1450,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // We'll call it `fr-` -- it's ever so slightly smaller than\n             // `longer_fr`.\n \n-            if let Some(fr_minus) = self\n-                .universal_region_relations\n-                .non_local_lower_bound(longer_fr)\n+            if let Some(fr_minus) = self.universal_region_relations.non_local_lower_bound(longer_fr)\n             {\n                 debug!(\"check_universal_region: fr_minus={:?}\", fr_minus);\n \n@@ -1252,12 +1460,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // Grow `shorter_fr` until we find some non-local regions. (We\n                 // always will.)  We'll call them `shorter_fr+` -- they're ever\n                 // so slightly larger than `shorter_fr`.\n-                let shorter_fr_plus = self.universal_region_relations\n-                    .non_local_upper_bounds(&shorter_fr);\n-                debug!(\n-                    \"check_universal_region: shorter_fr_plus={:?}\",\n-                    shorter_fr_plus\n-                );\n+                let shorter_fr_plus =\n+                    self.universal_region_relations.non_local_upper_bounds(&shorter_fr);\n+                debug!(\"check_universal_region: shorter_fr_plus={:?}\", shorter_fr_plus);\n                 for &&fr in &shorter_fr_plus {\n                     // Push the constraint `fr-: shorter_fr+`\n                     propagated_outlives_requirements.push(ClosureOutlivesRequirement {\n@@ -1289,28 +1494,20 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         longer_fr: RegionVid,\n         placeholder: ty::PlaceholderRegion,\n     ) {\n-        debug!(\n-            \"check_bound_universal_region(fr={:?}, placeholder={:?})\",\n-            longer_fr, placeholder,\n-        );\n+        debug!(\"check_bound_universal_region(fr={:?}, placeholder={:?})\", longer_fr, placeholder,);\n \n         let longer_fr_scc = self.constraint_sccs.scc(longer_fr);\n-        debug!(\n-            \"check_bound_universal_region: longer_fr_scc={:?}\",\n-            longer_fr_scc,\n-        );\n+        debug!(\"check_bound_universal_region: longer_fr_scc={:?}\", longer_fr_scc,);\n \n         // If we have some bound universal region `'a`, then the only\n         // elements it can contain is itself -- we don't know anything\n         // else about it!\n         let error_element = match {\n-            self.scc_values\n-                .elements_contained_in(longer_fr_scc)\n-                .find(|element| match element {\n-                    RegionElement::Location(_) => true,\n-                    RegionElement::RootUniversalRegion(_) => true,\n-                    RegionElement::PlaceholderRegion(placeholder1) => placeholder != *placeholder1,\n-                })\n+            self.scc_values.elements_contained_in(longer_fr_scc).find(|element| match element {\n+                RegionElement::Location(_) => true,\n+                RegionElement::RootUniversalRegion(_) => true,\n+                RegionElement::PlaceholderRegion(placeholder1) => placeholder != *placeholder1,\n+            })\n         } {\n             Some(v) => v,\n             None => return,\n@@ -1321,7 +1518,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let error_region = match error_element {\n             RegionElement::Location(l) => self.find_sub_region_live_at(longer_fr, l),\n             RegionElement::RootUniversalRegion(r) => r,\n-            RegionElement::PlaceholderRegion(error_placeholder) => self.definitions\n+            RegionElement::PlaceholderRegion(error_placeholder) => self\n+                .definitions\n                 .iter_enumerated()\n                 .filter_map(|(r, definition)| match definition.origin {\n                     NLLRegionVariableOrigin::Placeholder(p) if p == error_placeholder => Some(r),\n@@ -1339,12 +1537,50 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // the AST-based checker uses a more conservative check,\n         // so to even see this error, one must pass in a special\n         // flag.\n-        let mut diag = infcx\n-            .tcx\n-            .sess\n-            .struct_span_err(span, \"higher-ranked subtype error\");\n+        let mut diag = infcx.tcx.sess.struct_span_err(span, \"higher-ranked subtype error\");\n         diag.emit();\n     }\n+\n+    fn check_member_constraints(\n+        &self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+        mir_def_id: DefId,\n+        errors_buffer: &mut Vec<Diagnostic>,\n+    ) {\n+        let member_constraints = self.member_constraints.clone();\n+        for m_c_i in member_constraints.all_indices() {\n+            debug!(\"check_member_constraint(m_c_i={:?})\", m_c_i);\n+            let m_c = &member_constraints[m_c_i];\n+            let member_region_vid = m_c.member_region_vid;\n+            debug!(\n+                \"check_member_constraint: member_region_vid={:?} with value {}\",\n+                member_region_vid,\n+                self.region_value_str(member_region_vid),\n+            );\n+            let choice_regions = member_constraints.choice_regions(m_c_i);\n+            debug!(\"check_member_constraint: choice_regions={:?}\", choice_regions);\n+\n+            // Did the member region wind up equal to any of the option regions?\n+            if let Some(o) = choice_regions.iter().find(|&&o_r| {\n+                self.eval_equal(o_r, m_c.member_region_vid)\n+            }) {\n+                debug!(\"check_member_constraint: evaluated as equal to {:?}\", o);\n+                continue;\n+            }\n+\n+            // If not, report an error.\n+            let region_scope_tree = &infcx.tcx.region_scope_tree(mir_def_id);\n+            let member_region = infcx.tcx.mk_region(ty::ReVar(member_region_vid));\n+            opaque_types::unexpected_hidden_region_diagnostic(\n+                infcx.tcx,\n+                Some(region_scope_tree),\n+                m_c.opaque_type_def_id,\n+                m_c.hidden_ty,\n+                member_region,\n+            )\n+            .buffer(errors_buffer);\n+        }\n+    }\n }\n \n impl<'tcx> RegionDefinition<'tcx> {\n@@ -1358,11 +1594,7 @@ impl<'tcx> RegionDefinition<'tcx> {\n             _ => NLLRegionVariableOrigin::Existential,\n         };\n \n-        Self {\n-            origin,\n-            universe,\n-            external_name: None,\n-        }\n+        Self { origin, universe, external_name: None }\n     }\n }\n \n@@ -1372,7 +1604,7 @@ pub trait ClosureRegionRequirementsExt<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         closure_def_id: DefId,\n         closure_substs: SubstsRef<'tcx>,\n-    ) -> Vec<QueryRegionConstraint<'tcx>>;\n+    ) -> Vec<QueryOutlivesConstraint<'tcx>>;\n \n     fn subst_closure_mapping<T>(\n         &self,\n@@ -1402,7 +1634,7 @@ impl<'tcx> ClosureRegionRequirementsExt<'tcx> for ClosureRegionRequirements<'tcx\n         tcx: TyCtxt<'tcx>,\n         closure_def_id: DefId,\n         closure_substs: SubstsRef<'tcx>,\n-    ) -> Vec<QueryRegionConstraint<'tcx>> {\n+    ) -> Vec<QueryOutlivesConstraint<'tcx>> {\n         debug!(\n             \"apply_requirements(closure_def_id={:?}, closure_substs={:?})\",\n             closure_def_id, closure_substs\n@@ -1465,10 +1697,7 @@ impl<'tcx> ClosureRegionRequirementsExt<'tcx> for ClosureRegionRequirements<'tcx\n             if let ty::ReClosureBound(vid) = r {\n                 closure_mapping[*vid]\n             } else {\n-                bug!(\n-                    \"subst_closure_mapping: encountered non-closure bound free region {:?}\",\n-                    r\n-                )\n+                bug!(\"subst_closure_mapping: encountered non-closure bound free region {:?}\", r)\n             }\n         })\n     }"}, {"sha": "8de014522dea76ed302922d7f77baf84da1fc47e", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -3,7 +3,8 @@ use crate::borrow_check::nll::region_infer::TypeTest;\n use crate::borrow_check::nll::type_check::{Locations, MirTypeckRegionConstraints};\n use crate::borrow_check::nll::universal_regions::UniversalRegions;\n use crate::borrow_check::nll::ToRegionVid;\n-use rustc::infer::canonical::QueryRegionConstraint;\n+use rustc::infer::canonical::QueryRegionConstraints;\n+use rustc::infer::canonical::QueryOutlivesConstraint;\n use rustc::infer::outlives::env::RegionBoundPairs;\n use rustc::infer::outlives::obligations::{TypeOutlives, TypeOutlivesDelegate};\n use rustc::infer::region_constraints::{GenericKind, VerifyBound};\n@@ -49,13 +50,33 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn convert_all(&mut self, query_constraints: &[QueryRegionConstraint<'tcx>]) {\n-        for query_constraint in query_constraints {\n+    pub(super) fn convert_all(&mut self, query_constraints: &QueryRegionConstraints<'tcx>) {\n+        debug!(\"convert_all(query_constraints={:#?})\", query_constraints);\n+\n+        let QueryRegionConstraints { outlives, member_constraints } = query_constraints;\n+\n+        // Annoying: to invoke `self.to_region_vid`, we need access to\n+        // `self.constraints`, but we also want to be mutating\n+        // `self.member_constraints`. For now, just swap out the value\n+        // we want and replace at the end.\n+        let mut tmp = std::mem::replace(\n+            &mut self.constraints.member_constraints,\n+            Default::default(),\n+        );\n+        for member_constraint in member_constraints {\n+            tmp.push_constraint(\n+                member_constraint,\n+                |r| self.to_region_vid(r),\n+            );\n+        }\n+        self.constraints.member_constraints = tmp;\n+\n+        for query_constraint in outlives {\n             self.convert(query_constraint);\n         }\n     }\n \n-    pub(super) fn convert(&mut self, query_constraint: &QueryRegionConstraint<'tcx>) {\n+    pub(super) fn convert(&mut self, query_constraint: &QueryOutlivesConstraint<'tcx>) {\n         debug!(\"generate: constraints at: {:#?}\", self.locations);\n \n         // Extract out various useful fields we'll need below."}, {"sha": "d18a8e87453a54e6788fc9eec352390b0588fa6e", "filename": "src/librustc_mir/borrow_check/nll/type_check/free_region_relations.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -2,7 +2,7 @@ use crate::borrow_check::nll::type_check::constraint_conversion;\n use crate::borrow_check::nll::type_check::{Locations, MirTypeckRegionConstraints};\n use crate::borrow_check::nll::universal_regions::UniversalRegions;\n use crate::borrow_check::nll::ToRegionVid;\n-use rustc::infer::canonical::QueryRegionConstraint;\n+use rustc::infer::canonical::QueryRegionConstraints;\n use rustc::infer::outlives::free_region_map::FreeRegionRelations;\n use rustc::infer::region_constraints::GenericKind;\n use rustc::infer::InferCtxt;\n@@ -287,7 +287,7 @@ impl UniversalRegionRelationsBuilder<'cx, 'tcx> {\n             self.relations.relate_universal_regions(fr, fr_fn_body);\n         }\n \n-        for data in constraint_sets {\n+        for data in &constraint_sets {\n             constraint_conversion::ConstraintConversion::new(\n                 self.infcx,\n                 &self.universal_regions,\n@@ -297,7 +297,7 @@ impl UniversalRegionRelationsBuilder<'cx, 'tcx> {\n                 Locations::All(DUMMY_SP),\n                 ConstraintCategory::Internal,\n                 &mut self.constraints,\n-            ).convert_all(&data);\n+            ).convert_all(data);\n         }\n \n         CreateResult {\n@@ -311,7 +311,7 @@ impl UniversalRegionRelationsBuilder<'cx, 'tcx> {\n     /// either the return type of the MIR or one of its arguments. At\n     /// the same time, compute and add any implied bounds that come\n     /// from this local.\n-    fn add_implied_bounds(&mut self, ty: Ty<'tcx>) -> Option<Rc<Vec<QueryRegionConstraint<'tcx>>>> {\n+    fn add_implied_bounds(&mut self, ty: Ty<'tcx>) -> Option<Rc<QueryRegionConstraints<'tcx>>> {\n         debug!(\"add_implied_bounds(ty={:?})\", ty);\n         let (bounds, constraints) =\n             self.param_env"}, {"sha": "4af78fa5e0f42e4dd64979434aeb0384ff7ebb94", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -1,5 +1,5 @@\n use crate::borrow_check::location::LocationTable;\n-use crate::borrow_check::nll::constraints::ConstraintSet;\n+use crate::borrow_check::nll::constraints::OutlivesConstraintSet;\n use crate::borrow_check::nll::facts::{AllFacts, AllFactsExt};\n use crate::borrow_check::nll::region_infer::values::RegionValueElements;\n use crate::borrow_check::nll::universal_regions::UniversalRegions;\n@@ -107,7 +107,7 @@ fn compute_live_locals(\n fn regions_that_outlive_free_regions(\n     num_region_vars: usize,\n     universal_regions: &UniversalRegions<'tcx>,\n-    constraint_set: &ConstraintSet,\n+    constraint_set: &OutlivesConstraintSet,\n ) -> FxHashSet<RegionVid> {\n     // Build a graph of the outlives constraints thus far. This is\n     // a reverse graph, so for each constraint `R1: R2` we have an"}, {"sha": "f160f658f557640e68731c9b211cf29e19e6025d", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/trace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -6,7 +6,7 @@ use crate::borrow_check::nll::type_check::TypeChecker;\n use crate::dataflow::indexes::MovePathIndex;\n use crate::dataflow::move_paths::MoveData;\n use crate::dataflow::{FlowAtLocation, FlowsAtLocation, MaybeInitializedPlaces};\n-use rustc::infer::canonical::QueryRegionConstraint;\n+use rustc::infer::canonical::QueryRegionConstraints;\n use rustc::mir::{BasicBlock, ConstraintCategory, Local, Location, Body};\n use rustc::traits::query::dropck_outlives::DropckOutlivesResult;\n use rustc::traits::query::type_op::outlives::DropckOutlives;\n@@ -88,7 +88,7 @@ struct LivenessContext<'me, 'typeck, 'flow, 'tcx> {\n \n struct DropData<'tcx> {\n     dropck_result: DropckOutlivesResult<'tcx>,\n-    region_constraint_data: Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>,\n+    region_constraint_data: Option<Rc<QueryRegionConstraints<'tcx>>>,\n }\n \n struct LivenessResults<'me, 'typeck, 'flow, 'tcx> {"}, {"sha": "cdbbe1d02bd92edd54450409dd9ae907ef6b6a08", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -4,7 +4,8 @@\n \n use crate::borrow_check::borrow_set::BorrowSet;\n use crate::borrow_check::location::LocationTable;\n-use crate::borrow_check::nll::constraints::{ConstraintSet, OutlivesConstraint};\n+use crate::borrow_check::nll::constraints::{OutlivesConstraintSet, OutlivesConstraint};\n+use crate::borrow_check::nll::member_constraints::MemberConstraintSet;\n use crate::borrow_check::nll::facts::AllFacts;\n use crate::borrow_check::nll::region_infer::values::LivenessValues;\n use crate::borrow_check::nll::region_infer::values::PlaceholderIndex;\n@@ -23,7 +24,7 @@ use crate::dataflow::MaybeInitializedPlaces;\n use either::Either;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc::infer::canonical::QueryRegionConstraint;\n+use rustc::infer::canonical::QueryRegionConstraints;\n use rustc::infer::outlives::env::RegionBoundPairs;\n use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime, NLLRegionVariableOrigin};\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -127,7 +128,8 @@ pub(crate) fn type_check<'tcx>(\n         placeholder_indices: PlaceholderIndices::default(),\n         placeholder_index_to_region: IndexVec::default(),\n         liveness_constraints: LivenessValues::new(elements.clone()),\n-        outlives_constraints: ConstraintSet::default(),\n+        outlives_constraints: OutlivesConstraintSet::default(),\n+        member_constraints: MemberConstraintSet::default(),\n         closure_bounds_mapping: Default::default(),\n         type_tests: Vec::default(),\n     };\n@@ -215,7 +217,7 @@ fn translate_outlives_facts(cx: &mut BorrowCheckContext<'_, '_>) {\n         let location_table = cx.location_table;\n         facts\n             .outlives\n-            .extend(cx.constraints.outlives_constraints.iter().flat_map(\n+            .extend(cx.constraints.outlives_constraints.outlives().iter().flat_map(\n                 |constraint: &OutlivesConstraint| {\n                     if let Some(from_location) = constraint.locations.from_location() {\n                         Either::Left(iter::once((\n@@ -582,7 +584,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         );\n \n         let locations = location.to_locations();\n-        for constraint in constraints.iter() {\n+        for constraint in constraints.outlives().iter() {\n             let mut constraint = *constraint;\n             constraint.locations = locations;\n             if let ConstraintCategory::Return\n@@ -834,6 +836,7 @@ struct TypeChecker<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     last_span: Span,\n+    body: &'a Body<'tcx>,\n     /// User type annotations are shared between the main MIR and the MIR of\n     /// all of the promoted items.\n     user_type_annotations: &'a CanonicalUserTypeAnnotations<'tcx>,\n@@ -884,7 +887,9 @@ crate struct MirTypeckRegionConstraints<'tcx> {\n     /// hence it must report on their liveness constraints.\n     crate liveness_constraints: LivenessValues<RegionVid>,\n \n-    crate outlives_constraints: ConstraintSet,\n+    crate outlives_constraints: OutlivesConstraintSet,\n+\n+    crate member_constraints: MemberConstraintSet<'tcx, RegionVid>,\n \n     crate closure_bounds_mapping:\n         FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>>,\n@@ -992,6 +997,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             infcx,\n             last_span: DUMMY_SP,\n             mir_def_id,\n+            body,\n             user_type_annotations: &body.user_type_annotations,\n             param_env,\n             region_bound_pairs,\n@@ -1093,7 +1099,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         &mut self,\n         locations: Locations,\n         category: ConstraintCategory,\n-        data: &[QueryRegionConstraint<'tcx>],\n+        data: &QueryRegionConstraints<'tcx>,\n     ) {\n         debug!(\n             \"push_region_constraints: constraints generated at {:?} are {:#?}\",\n@@ -1109,7 +1115,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             locations,\n             category,\n             &mut self.borrowck_context.constraints,\n-        ).convert_all(&data);\n+        ).convert_all(data);\n     }\n \n     /// Convenient wrapper around `relate_tys::relate_types` -- see\n@@ -1229,6 +1235,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         let infcx = self.infcx;\n         let tcx = infcx.tcx;\n         let param_env = self.param_env;\n+        let body = self.body;\n         debug!(\"eq_opaque_type_and_type: mir_def_id={:?}\", self.mir_def_id);\n         let opaque_type_map = self.fully_perform_op(\n             locations,\n@@ -1244,6 +1251,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             dummy_body_id,\n                             param_env,\n                             &anon_ty,\n+                            locations.span(body),\n                         ));\n                     debug!(\n                         \"eq_opaque_type_and_type: \\\n@@ -2508,10 +2516,20 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         location: Location,\n     ) -> ty::InstantiatedPredicates<'tcx> {\n         if let Some(closure_region_requirements) = tcx.mir_borrowck(def_id).closure_requirements {\n-            let closure_constraints =\n-                closure_region_requirements.apply_requirements(tcx, def_id, substs);\n+            let closure_constraints = QueryRegionConstraints {\n+                outlives: closure_region_requirements.apply_requirements(tcx, def_id, substs),\n+\n+                // Presently, closures never propagate member\n+                // constraints to their parents -- they are enforced\n+                // locally.  This is largely a non-issue as member\n+                // constraints only come from `-> impl Trait` and\n+                // friends which don't appear (thus far...) in\n+                // closures.\n+                member_constraints: vec![],\n+            };\n \n             let bounds_mapping = closure_constraints\n+                .outlives\n                 .iter()\n                 .enumerate()\n                 .filter_map(|(idx, constraint)| {"}, {"sha": "5c23ad4a4edfbd361fb8d1259402834e7cc88b72", "filename": "src/librustc_traits/chalk_context/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -17,6 +17,7 @@ use rustc::infer::canonical::{\n     CanonicalVarValues,\n     OriginalQueryValues,\n     QueryResponse,\n+    QueryRegionConstraints,\n     Certainty,\n };\n use rustc::traits::{\n@@ -151,14 +152,14 @@ impl context::AggregateOps<ChalkArenas<'tcx>> for ChalkContext<'tcx> {\n         let solution = constrained_subst.unchecked_map(|cs| match ambiguous {\n             true => QueryResponse {\n                 var_values: cs.subst.make_identity(self.tcx),\n-                region_constraints: Vec::new(),\n+                region_constraints: QueryRegionConstraints::default(),\n                 certainty: Certainty::Ambiguous,\n                 value: (),\n             },\n \n             false => QueryResponse {\n                 var_values: cs.subst,\n-                region_constraints: Vec::new(),\n+                region_constraints: QueryRegionConstraints::default(),\n \n                 // FIXME: restore this later once we get better at handling regions\n                 // region_constraints: cs.constraints"}, {"sha": "b0be37772af39b2a960c60cb63bf3aa4b406192b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -856,7 +856,8 @@ fn typeck_tables_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx ty::TypeckT\n             let revealed_ty = if tcx.features().impl_trait_in_bindings {\n                 fcx.instantiate_opaque_types_from_value(\n                     id,\n-                    &expected_type\n+                    &expected_type,\n+                    body.value.span,\n                 )\n             } else {\n                 expected_type\n@@ -962,7 +963,8 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n                 let revealed_ty = if self.fcx.tcx.features().impl_trait_in_bindings {\n                     self.fcx.instantiate_opaque_types_from_value(\n                         self.parent_id,\n-                        &o_ty\n+                        &o_ty,\n+                        ty.span,\n                     )\n                 } else {\n                     o_ty\n@@ -1058,7 +1060,11 @@ fn check_fn<'a, 'tcx>(\n \n     let declared_ret_ty = fn_sig.output();\n     fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n-    let revealed_ret_ty = fcx.instantiate_opaque_types_from_value(fn_id, &declared_ret_ty);\n+    let revealed_ret_ty = fcx.instantiate_opaque_types_from_value(\n+        fn_id,\n+        &declared_ret_ty,\n+        decl.output.span(),\n+    );\n     fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(revealed_ret_ty)));\n     fn_sig = fcx.tcx.mk_fn_sig(\n         fn_sig.inputs().iter().cloned(),\n@@ -2445,6 +2451,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         parent_id: hir::HirId,\n         value: &T,\n+        value_span: Span,\n     ) -> T {\n         let parent_def_id = self.tcx.hir().local_def_id_from_hir_id(parent_id);\n         debug!(\"instantiate_opaque_types_from_value(parent_def_id={:?}, value={:?})\",\n@@ -2457,6 +2464,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.body_id,\n                 self.param_env,\n                 value,\n+                value_span,\n             )\n         );\n "}, {"sha": "e6a09e7f873ea7d4f04c8a56ce484c412435e460", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -570,6 +570,9 @@ declare_features! (\n     // Allows explicit discriminants on non-unit enum variants.\n     (active, arbitrary_enum_discriminant, \"1.37.0\", Some(60553), None),\n \n+    // Allows `impl Trait` with multiple unrelated lifetimes.\n+    (active, member_constraints, \"1.37.0\", Some(61977), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------"}, {"sha": "aee988d5148ae445f507d61d18876531dbfc47d0", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -389,6 +389,7 @@ symbols! {\n         match_beginning_vert,\n         match_default_bindings,\n         may_dangle,\n+        member_constraints,\n         message,\n         meta,\n         min_const_fn,"}, {"sha": "e3ac817b15ca580e5e9484c8436793020c78f3a4", "filename": "src/test/ui/async-await/async-fn-multiple-lifetimes.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0beb2ba16a08dfa01569b5f4644da315dc4c806c/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-multiple-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beb2ba16a08dfa01569b5f4644da315dc4c806c/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-multiple-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-multiple-lifetimes.rs?ref=0beb2ba16a08dfa01569b5f4644da315dc4c806c", "patch": "@@ -1,19 +0,0 @@\n-// edition:2018\n-\n-#![feature(arbitrary_self_types, async_await, await_macro, pin)]\n-\n-use std::ops::Add;\n-\n-async fn multiple_named_lifetimes<'a, 'b>(_: &'a u8, _: &'b u8) {}\n-//~^ ERROR ambiguous lifetime bound in `async fn`\n-\n-async fn multiple_hrtb_and_single_named_lifetime_ok<'c>(\n-    _: impl for<'a> Add<&'a u8>,\n-    _: impl for<'b> Add<&'b u8>,\n-    _: &'c u8,\n-) {}\n-\n-async fn multiple_elided_lifetimes(_: &u8, _: &u8) {}\n-//~^ ambiguous lifetime bound in `async fn`\n-\n-fn main() {}"}, {"sha": "8c3ee2bed830b7bb88cc3990f95b480dc337a625", "filename": "src/test/ui/async-await/async-fn-multiple-lifetimes.stderr", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0beb2ba16a08dfa01569b5f4644da315dc4c806c/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-multiple-lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0beb2ba16a08dfa01569b5f4644da315dc4c806c/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-multiple-lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-multiple-lifetimes.stderr?ref=0beb2ba16a08dfa01569b5f4644da315dc4c806c", "patch": "@@ -1,20 +0,0 @@\n-error: ambiguous lifetime bound in `async fn`\n-  --> $DIR/async-fn-multiple-lifetimes.rs:7:65\n-   |\n-LL | async fn multiple_named_lifetimes<'a, 'b>(_: &'a u8, _: &'b u8) {}\n-   |                                                                 ^ neither `'a` nor `'b` outlives the other\n-   |\n-   = note: multiple unrelated lifetimes are not allowed in `async fn`.\n-   = note: if you're using argument-position elided lifetimes, consider switching to a single named lifetime.\n-\n-error: ambiguous lifetime bound in `async fn`\n-  --> $DIR/async-fn-multiple-lifetimes.rs:16:52\n-   |\n-LL | async fn multiple_elided_lifetimes(_: &u8, _: &u8) {}\n-   |                                                    ^ the elided lifetimes here do not outlive one another\n-   |\n-   = note: multiple unrelated lifetimes are not allowed in `async fn`.\n-   = note: if you're using argument-position elided lifetimes, consider switching to a single named lifetime.\n-\n-error: aborting due to 2 previous errors\n-"}, {"sha": "45f3170d4c309280ea5d75cfdb9f298eae86037e", "filename": "src/test/ui/async-await/multiple-lifetimes/elided.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Felided.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Felided.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Felided.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,12 @@\n+// edition:2018\n+// run-pass\n+\n+// Test that we can use async fns with multiple arbitrary lifetimes.\n+\n+#![feature(async_await)]\n+\n+async fn multiple_elided_lifetimes(_: &u8, _: &u8) {}\n+\n+fn main() {\n+    let _ = multiple_elided_lifetimes(&22, &44);\n+}"}, {"sha": "a7254cee7552661e9fc7941646c76e58aae84e8a", "filename": "src/test/ui/async-await/multiple-lifetimes/fn-ptr.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Ffn-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Ffn-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Ffn-ptr.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,14 @@\n+// edition:2018\n+// run-pass\n+\n+// Test that we can use async fns with multiple arbitrary lifetimes.\n+\n+#![feature(async_await)]\n+\n+async fn multiple_named_lifetimes<'a, 'b>(_: &'a u8, _: &'b u8, _: fn(&u8)) {}\n+\n+fn gimme(_: &u8) { }\n+\n+fn main() {\n+    let _ = multiple_named_lifetimes(&22, &44, gimme);\n+}"}, {"sha": "620b0080966b9e5e70f3dddc4127194625ab05ca", "filename": "src/test/ui/async-await/multiple-lifetimes/hrtb.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fhrtb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fhrtb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fhrtb.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,17 @@\n+// edition:2018\n+// run-pass\n+\n+// Test that we can use async fns with multiple arbitrary lifetimes.\n+\n+#![feature(arbitrary_self_types, async_await, await_macro)]\n+#![allow(dead_code)]\n+\n+use std::ops::Add;\n+\n+async fn multiple_hrtb_and_single_named_lifetime_ok<'c>(\n+    _: impl for<'a> Add<&'a u8>,\n+    _: impl for<'b> Add<&'b u8>,\n+    _: &'c u8,\n+) {}\n+\n+fn main() {}"}, {"sha": "7d13d48bc8bbde12e87cd361337e5c1a7b216405", "filename": "src/test/ui/async-await/multiple-lifetimes/named.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fnamed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fnamed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fnamed.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,12 @@\n+// edition:2018\n+// run-pass\n+\n+// Test that we can use async fns with multiple arbitrary lifetimes.\n+\n+#![feature(arbitrary_self_types, async_await, await_macro)]\n+\n+async fn multiple_named_lifetimes<'a, 'b>(_: &'a u8, _: &'b u8) {}\n+\n+fn main() {\n+    let _ = multiple_named_lifetimes(&22, &44);\n+}"}, {"sha": "903c43950a5c46f966b0188d6716d5c4fa985885", "filename": "src/test/ui/async-await/multiple-lifetimes/partial-relation.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fpartial-relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fpartial-relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fpartial-relation.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,15 @@\n+// edition:2018\n+// run-pass\n+\n+#![feature(async_await)]\n+\n+async fn lotsa_lifetimes<'a, 'b, 'c>(a: &'a u32, b: &'b u32, c: &'c u32) -> (&'a u32, &'b u32)\n+    where 'b: 'a\n+{\n+    drop((a, c));\n+    (b, b)\n+}\n+\n+fn main() {\n+    let _ = lotsa_lifetimes(&22, &44, &66);\n+}"}, {"sha": "08622311f7b1cb5a1f7595cb5058fdb8152c0284", "filename": "src/test/ui/async-await/multiple-lifetimes/ret-impl-trait-fg.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-fg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-fg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-fg.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,18 @@\n+// edition:2018\n+// run-pass\n+\n+// Test that a feature gate is needed to use `impl Trait` as the\n+// return type of an async.\n+\n+#![feature(async_await, member_constraints)]\n+\n+trait Trait<'a, 'b> { }\n+impl<T> Trait<'_, '_> for T { }\n+\n+async fn async_ret_impl_trait<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a, 'b> {\n+    (a, b)\n+}\n+\n+fn main() {\n+    let _ = async_ret_impl_trait(&22, &44);\n+}"}, {"sha": "08ecea4cc85fce90a4971e512135817780846f56", "filename": "src/test/ui/async-await/multiple-lifetimes/ret-impl-trait-no-fg.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-no-fg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-no-fg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-no-fg.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,18 @@\n+// edition:2018\n+\n+// Test that a feature gate is needed to use `impl Trait` as the\n+// return type of an async.\n+\n+#![feature(async_await)]\n+\n+trait Trait<'a, 'b> { }\n+impl<T> Trait<'_, '_> for T { }\n+\n+async fn async_ret_impl_trait<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a, 'b> {\n+    //~^ ERROR ambiguous lifetime bound\n+    (a, b)\n+}\n+\n+fn main() {\n+    let _ = async_ret_impl_trait(&22, &44);\n+}"}, {"sha": "de2c85d772a72610e7d88f7b2334f2de80c37070", "filename": "src/test/ui/async-await/multiple-lifetimes/ret-impl-trait-no-fg.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-no-fg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-no-fg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-no-fg.stderr?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,10 @@\n+error: ambiguous lifetime bound in `impl Trait`\n+  --> $DIR/ret-impl-trait-no-fg.rs:11:64\n+   |\n+LL | async fn async_ret_impl_trait<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a, 'b> {\n+   |                                                                ^^^^^^^^^^^^^^^^^^ neither `'a` nor `'b` outlives the other\n+   |\n+   = help: add #![feature(member_constraints)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "b4d5d3ec051e26ad8135b0024bf908bdce6d815a", "filename": "src/test/ui/async-await/multiple-lifetimes/ret-impl-trait-one.nll.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.nll.stderr?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,15 @@\n+error: lifetime may not live long enough\n+  --> $DIR/ret-impl-trait-one.rs:12:80\n+   |\n+LL |   async fn async_ret_impl_trait1<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> {\n+   |  ________________________________--__--__________________________________________^\n+   | |                                |   |\n+   | |                                |   lifetime `'b` defined here\n+   | |                                lifetime `'a` defined here\n+LL | |\n+LL | |     (a, b)\n+LL | | }\n+   | |_^ function was supposed to return data with lifetime `'a` but it is returning data with lifetime `'b`\n+\n+error: aborting due to previous error\n+"}, {"sha": "e1b714652737fb8ce51b8ff36ee9b5740b1e47a1", "filename": "src/test/ui/async-await/multiple-lifetimes/ret-impl-trait-one.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,27 @@\n+// edition:2018\n+\n+// Test that a feature gate is needed to use `impl Trait` as the\n+// return type of an async.\n+\n+#![feature(async_await, member_constraints)]\n+\n+trait Trait<'a> { }\n+impl<T> Trait<'_> for T { }\n+\n+// Only `'a` permitted in return type, not `'b`.\n+async fn async_ret_impl_trait1<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> {\n+    //~^ ERROR lifetime mismatch\n+    (a, b)\n+}\n+\n+// As above, but `'b: 'a`, so return type can be inferred to `(&'a u8,\n+// &'a u8)`.\n+async fn async_ret_impl_trait2<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a>\n+where\n+    'b: 'a,\n+{\n+    (a, b)\n+}\n+\n+fn main() {\n+}"}, {"sha": "f6d611517bc8f7abff1dde1637685e1cd33df26d", "filename": "src/test/ui/async-await/multiple-lifetimes/ret-impl-trait-one.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.stderr?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,11 @@\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ret-impl-trait-one.rs:12:65\n+   |\n+LL | async fn async_ret_impl_trait1<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> {\n+   |                                           ------                ^^^^^^^^^^^^^^\n+   |                                           |                     |\n+   |                                           |                     ...but data from `b` is returned here\n+   |                                           this parameter and the return type are declared with different lifetimes...\n+\n+error: aborting due to previous error\n+"}, {"sha": "98da90161e5fd014cb25d67439bba1216ffd5eb2", "filename": "src/test/ui/async-await/multiple-lifetimes/ret-ref.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-ref.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,46 @@\n+// edition:2018\n+\n+// Test that we get the expected borrow check errors when an async\n+// function (which takes multiple lifetimes) only returns data from\n+// one of them.\n+\n+#![feature(async_await)]\n+\n+async fn multiple_named_lifetimes<'a, 'b>(a: &'a u8, _: &'b u8) -> &'a u8 {\n+    a\n+}\n+\n+// Both are borrowed whilst the future is live.\n+async fn future_live() {\n+    let mut a = 22;\n+    let mut b = 44;\n+    let future = multiple_named_lifetimes(&a, &b);\n+    a += 1; //~ ERROR cannot assign\n+    b += 1; //~ ERROR cannot assign\n+    let p = future.await;\n+    drop(p);\n+}\n+\n+// Just the return value is live after future is awaited.\n+async fn just_return_live() {\n+    let mut a = 22;\n+    let mut b = 44;\n+    let future = multiple_named_lifetimes(&a, &b);\n+    let p = future.await;\n+    a += 1; //~ ERROR cannot assign\n+    b += 1;\n+    drop(p);\n+}\n+\n+// Once `p` is dead, both `a` and `b` are unborrowed.\n+async fn after_both_dead() {\n+    let mut a = 22;\n+    let mut b = 44;\n+    let future = multiple_named_lifetimes(&a, &b);\n+    let p = future.await;\n+    drop(p);\n+    a += 1;\n+    b += 1;\n+}\n+\n+fn main() { }"}, {"sha": "fe70d35942c7c679811f02fbec8fb7ab07f2a682", "filename": "src/test/ui/async-await/multiple-lifetimes/ret-ref.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-ref.stderr?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,37 @@\n+error[E0506]: cannot assign to `a` because it is borrowed\n+  --> $DIR/ret-ref.rs:18:5\n+   |\n+LL |     let future = multiple_named_lifetimes(&a, &b);\n+   |                                           -- borrow of `a` occurs here\n+LL |     a += 1;\n+   |     ^^^^^^ assignment to borrowed `a` occurs here\n+LL |     b += 1;\n+LL |     let p = future.await;\n+   |             ------ borrow later used here\n+\n+error[E0506]: cannot assign to `b` because it is borrowed\n+  --> $DIR/ret-ref.rs:19:5\n+   |\n+LL |     let future = multiple_named_lifetimes(&a, &b);\n+   |                                               -- borrow of `b` occurs here\n+LL |     a += 1;\n+LL |     b += 1;\n+   |     ^^^^^^ assignment to borrowed `b` occurs here\n+LL |     let p = future.await;\n+   |             ------ borrow later used here\n+\n+error[E0506]: cannot assign to `a` because it is borrowed\n+  --> $DIR/ret-ref.rs:30:5\n+   |\n+LL |     let future = multiple_named_lifetimes(&a, &b);\n+   |                                           -- borrow of `a` occurs here\n+LL |     let p = future.await;\n+LL |     a += 1;\n+   |     ^^^^^^ assignment to borrowed `a` occurs here\n+LL |     b += 1;\n+LL |     drop(p);\n+   |          - borrow later used here\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0506`."}, {"sha": "b52ad17d5631d0210617257c35347dcc4045aacf", "filename": "src/test/ui/async-await/multiple-lifetimes/variance.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fvariance.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,18 @@\n+// edition:2018\n+// run-pass\n+\n+// Test for async fn where the parameters have distinct lifetime\n+// parameters that appear in all possible variances.\n+\n+#![feature(async_await)]\n+\n+#[allow(dead_code)]\n+async fn lotsa_lifetimes<'a, 'b, 'c>(_: fn(&'a u8), _: fn(&'b u8) -> &'b u8, _: fn() -> &'c u8) { }\n+\n+fn take_any(_: &u8) { }\n+fn identify(x: &u8) -> &u8 { x }\n+fn give_back() -> &'static u8 { &22 }\n+\n+fn main() {\n+    let _ = lotsa_lifetimes(take_any, identify, give_back);\n+}"}, {"sha": "293a93352e641cdd5161c3a4e206c36a62bebd1e", "filename": "src/test/ui/feature-gates/feature-gate-member-constraints.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-member-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-member-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-member-constraints.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,9 @@\n+trait Trait<'a, 'b> { }\n+impl<T> Trait<'_, '_> for T {}\n+\n+fn foo<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Trait<'a, 'b> {\n+    //~^ ERROR ambiguous lifetime bound\n+    (x, y)\n+}\n+\n+fn main() { }"}, {"sha": "3745d5e1c59d6596e73b58da776e352113065183", "filename": "src/test/ui/feature-gates/feature-gate-member-constraints.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-member-constraints.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-member-constraints.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-member-constraints.stderr?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,10 @@\n+error: ambiguous lifetime bound in `impl Trait`\n+  --> $DIR/feature-gate-member-constraints.rs:4:43\n+   |\n+LL | fn foo<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Trait<'a, 'b> {\n+   |                                           ^^^^^^^^^^^^^^^^^^ neither `'a` nor `'b` outlives the other\n+   |\n+   = help: add #![feature(member_constraints)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "61e858ee02d44d3e81e26cf23cd7dba41e2f4320", "filename": "src/test/ui/impl-trait/multiple-lifetimes/error-handling.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,22 @@\n+// compile-flags:-Zborrowck=mir\n+\n+#![feature(member_constraints)]\n+#![feature(existential_type)]\n+\n+#[derive(Clone)]\n+struct CopyIfEq<T, U>(T, U);\n+\n+impl<T: Copy> Copy for CopyIfEq<T, T> {}\n+\n+existential type E<'a, 'b>: Sized;\n+\n+fn foo<'a, 'b, 'c>(x: &'static i32, mut y: &'a i32) -> E<'b, 'c> {\n+    //~^ ERROR lifetime may not live long enough\n+    let v = CopyIfEq::<*mut _, *mut _>(&mut {x}, &mut y);\n+    let u = v;\n+    let _: *mut &'a i32 = u.1;\n+    unsafe { let _: &'b i32 = *u.0; }\n+    u.0\n+}\n+\n+fn main() {}"}, {"sha": "b59dfbe9f2ada7beccec35d88fa34882eac2115b", "filename": "src/test/ui/impl-trait/multiple-lifetimes/error-handling.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling.stderr?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,12 @@\n+error: lifetime may not live long enough\n+  --> $DIR/error-handling.rs:13:56\n+   |\n+LL | fn foo<'a, 'b, 'c>(x: &'static i32, mut y: &'a i32) -> E<'b, 'c> {\n+   |        -- lifetime `'a` defined here                   ^^^^^^^^^ opaque type requires that `'a` must outlive `'static`\n+help: to allow this `impl Trait` to capture borrowed data with lifetime `'a`, add `'a` as a constraint\n+   |\n+LL | existential type E<'a, 'b>: Sized; + 'a\n+   |\n+\n+error: aborting due to previous error\n+"}, {"sha": "2da3886bb552be80fd8aab31ce0eedc060203b27", "filename": "src/test/ui/impl-trait/multiple-lifetimes/inverse-bounds.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Finverse-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Finverse-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Finverse-bounds.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,54 @@\n+// edition:2018\n+// run-pass\n+// revisions: migrate mir\n+//[mir]compile-flags: -Z borrowck=mir\n+\n+#![feature(member_constraints)]\n+\n+trait Trait<'a, 'b> {}\n+impl<T> Trait<'_, '_> for T {}\n+\n+// `Invert<'a> <: Invert<'b>` if `'b: 'a`, unlike most types.\n+//\n+// I am purposefully avoiding the terms co- and contra-variant because\n+// their application to regions depends on how you interpreted Rust\n+// regions. -nikomatsakis\n+struct Invert<'a>(fn(&'a u8));\n+\n+fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Invert<'a>, b: Invert<'b>) -> impl Trait<'d, 'e>\n+where\n+    'c: 'a,\n+    'c: 'b,\n+    'd: 'c,\n+{\n+    // Representing the where clauses as a graph, where `A: B` is an\n+    // edge `B -> A`:\n+    //\n+    // ```\n+    // 'a -> 'c -> 'd\n+    //        ^\n+    //        |\n+    //       'b\n+    // ```\n+    //\n+    // Meanwhile we return a value &'0 u8 where we have the constraints:\n+    //\n+    // ```\n+    // '0: 'a\n+    // '0: 'b\n+    // '0 in ['d, 'e]\n+    // ```\n+    //\n+    // Here, ignoring the \"in\" constraint, the minimal choice for `'0`\n+    // is `'c`, but that is not in the \"in set\". Still, that reduces\n+    // the range of options in the \"in set\" to just `'d` (`'e: 'c`\n+    // does not hold).\n+    let p = if condition() { a } else { b };\n+    p\n+}\n+\n+fn condition() -> bool {\n+    true\n+}\n+\n+fn main() {}"}, {"sha": "4de872e8441efe4c0fcf36a3ea4507717996b780", "filename": "src/test/ui/impl-trait/multiple-lifetimes/inverse-bounds.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Finverse-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Finverse-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Finverse-bounds.stderr?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,19 @@\n+warning[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+  --> $DIR/inverse-bounds.rs:16:70\n+   |\n+LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Invert<'a>, b: Invert<'b>) -> impl Trait<'d, 'e>\n+   |                                                                      ^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: hidden type `Invert<'_>` captures lifetime '_#8r\n+   = warning: this error has been downgraded to a warning for backwards compatibility with previous releases\n+   = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future\n+   = note: for more information, try `rustc --explain E0729`\n+\n+warning: the feature `pin` has been stable since 1.33.0 and no longer requires an attribute to enable\n+  --> $DIR/inverse-bounds.rs:4:60\n+   |\n+LL | #![feature(arbitrary_self_types, async_await, await_macro, pin)]\n+   |                                                            ^^^\n+   |\n+   = note: #[warn(stable_features)] on by default\n+"}, {"sha": "5f484773405cda82305c48f57d8e03520d9f2774", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-pick-original-elided.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-original-elided.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-original-elided.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-original-elided.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,29 @@\n+// edition:2018\n+// compile-pass\n+// revisions: migrate mir\n+//[mir]compile-flags: -Z borrowck=mir\n+\n+#![feature(member_constraints)]\n+\n+trait Trait<'a, 'b> { }\n+impl<T> Trait<'_, '_> for T { }\n+\n+// Test case where we have elision in the impl trait and we have to\n+// pick the right region.\n+\n+// Ultimately `Trait<'x, 'static>`.\n+fn upper_bounds1(a: &u8) -> impl Trait<'_, 'static> {\n+    (a, a)\n+}\n+\n+// Ultimately `Trait<'x, 'x>`, so not really multiple bounds.\n+fn upper_bounds2(a: &u8) -> impl Trait<'_, '_> {\n+    (a, a)\n+}\n+\n+// Kind of a weird annoying case.\n+fn upper_bounds3<'b>(a: &u8) -> impl Trait<'_, 'b> {\n+    (a, a)\n+}\n+\n+fn main() { }"}, {"sha": "c17ae6f0519bfd7598ad64be6e1e170c5363ec98", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-pick-original-existential.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-original-existential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-original-existential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-original-existential.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,32 @@\n+// edition:2018\n+// compile-pass\n+// revisions: migrate mir\n+//[mir]compile-flags: -Z borrowck=mir\n+\n+#![feature(member_constraints)]\n+#![feature(existential_type)]\n+\n+trait Trait<'a, 'b> { }\n+impl<T> Trait<'_, '_> for T { }\n+\n+// Here we wind up selecting `'a` and `'b` in the hidden type because\n+// those are the types that appear in the original values.\n+\n+existential type Foo<'a, 'b>: Trait<'a, 'b>;\n+\n+fn upper_bounds<'a, 'b>(a: &'a u8, b: &'b u8) -> Foo<'a, 'b> {\n+    // In this simple case, you have a hidden type `(&'0 u8, &'1 u8)` and constraints like\n+    //\n+    // ```\n+    // 'a: '0\n+    // 'b: '1\n+    // '0 in ['a, 'b]\n+    // '1 in ['a, 'b]\n+    // ```\n+    //\n+    // We use the fact that `'a: 0'` must hold (combined with the in\n+    // constraint) to determine that `'0 = 'a` must be the answer.\n+    (a, b)\n+}\n+\n+fn main() { }"}, {"sha": "31891ef15c754bc828f0fff654aa1d38a2ecf230", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-pick-original.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-original.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-original.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-original.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,29 @@\n+// edition:2018\n+// compile-pass\n+// revisions: migrate mir\n+//[mir]compile-flags: -Z borrowck=mir\n+\n+#![feature(member_constraints)]\n+\n+trait Trait<'a, 'b> { }\n+impl<T> Trait<'_, '_> for T { }\n+\n+// Here we wind up selecting `'a` and `'b` in the hidden type because\n+// those are the types that appear in the original values.\n+\n+fn upper_bounds<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a, 'b> {\n+    // In this simple case, you have a hidden type `(&'0 u8, &'1 u8)` and constraints like\n+    //\n+    // ```\n+    // 'a: '0\n+    // 'b: '1\n+    // '0 in ['a, 'b]\n+    // '1 in ['a, 'b]\n+    // ```\n+    //\n+    // We use the fact that `'a: 0'` must hold (combined with the in\n+    // constraint) to determine that `'0 = 'a` must be the answer.\n+    (a, b)\n+}\n+\n+fn main() { }"}, {"sha": "29c997085d8f4d2b3538be3259c73fdb5ed0fdc8", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-pick-other.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-other.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-other.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-other.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,46 @@\n+// edition:2018\n+// compile-pass\n+// revisions: migrate mir\n+//[mir]compile-flags: -Z borrowck=mir\n+\n+#![feature(member_constraints)]\n+\n+trait Trait<'a, 'b> {}\n+impl<T> Trait<'_, '_> for T {}\n+\n+// `Ordinary<'a> <: Ordinary<'b>` if `'a: 'b`, as with most types.\n+//\n+// I am purposefully avoiding the terms co- and contra-variant because\n+// their application to regions depends on how you interpreted Rust\n+// regions. -nikomatsakis\n+struct Ordinary<'a>(&'a u8);\n+\n+// Here we wind up selecting `'e` in the hidden type because\n+// we need something outlived by both `'a` and `'b` and only `'e` applies.\n+\n+fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e>\n+where\n+    'a: 'e,\n+    'b: 'e,\n+    'a: 'd,\n+{\n+    // We return a value:\n+    //\n+    // ```\n+    // 'a: '0\n+    // 'b: '1\n+    // '0 in ['d, 'e]\n+    // ```\n+    //\n+    // but we don't have it.\n+    //\n+    // We are forced to pick that '0 = 'e, because only 'e is outlived by *both* 'a and 'b.\n+    let p = if condition() { a } else { b };\n+    p\n+}\n+\n+fn condition() -> bool {\n+    true\n+}\n+\n+fn main() {}"}, {"sha": "a255c48ec6ef10f8a0a5f3a7d05959d5039aaf2e", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unrelated.nll.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.nll.stderr?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,9 @@\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+  --> $DIR/ordinary-bounds-unrelated.rs:18:74\n+   |\n+LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e>\n+   |                                                                          ^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0700`."}, {"sha": "db1641b0140b9d15e0649c1b907dcb20b23c08c2", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unrelated.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,38 @@\n+// edition:2018\n+\n+#![feature(member_constraints)]\n+\n+trait Trait<'a, 'b> {}\n+impl<T> Trait<'_, '_> for T {}\n+\n+// `Ordinary<'a> <: Ordinary<'b>` if `'a: 'b`, as with most types.\n+//\n+// I am purposefully avoiding the terms co- and contra-variant because\n+// their application to regions depends on how you interpreted Rust\n+// regions. -nikomatsakis\n+struct Ordinary<'a>(&'a u8);\n+\n+// Here we get an error because none of our choices (either `'d` nor `'e`) are outlived\n+// by both `'a` and `'b`.\n+\n+fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e>\n+//~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+where\n+    'a: 'e,\n+    'b: 'd,\n+{\n+    // Hidden type `Ordinary<'0>` with constraints:\n+    //\n+    // ```\n+    // 'a: '0\n+    // 'b: '0\n+    // 'a in ['d, 'e]\n+    // ```\n+    if condition() { a } else { b }\n+}\n+\n+fn condition() -> bool {\n+    true\n+}\n+\n+fn main() {}"}, {"sha": "cd2d46ac182180e4a05021595d36dd0164ef603c", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unrelated.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.stderr?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,21 @@\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+  --> $DIR/ordinary-bounds-unrelated.rs:18:74\n+   |\n+LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e>\n+   |                                                                          ^^^^^^^^^^^^^^^^^^\n+   |\n+note: hidden type `Ordinary<'_>` captures the scope of call-site for function at 23:1\n+  --> $DIR/ordinary-bounds-unrelated.rs:23:1\n+   |\n+LL | / {\n+LL | |     // Hidden type `Ordinary<'0>` with constraints:\n+LL | |     //\n+LL | |     // ```\n+...  |\n+LL | |     if condition() { a } else { b }\n+LL | | }\n+   | |_^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0700`."}, {"sha": "af42ed1c5c15a381f9b840043e0076194fcadffd", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unsuited.nll.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.nll.stderr?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,9 @@\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+  --> $DIR/ordinary-bounds-unsuited.rs:20:62\n+   |\n+LL | fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b>\n+   |                                                              ^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0700`."}, {"sha": "7f9c92f15a2f92b5ff86a6c2cbd44038e414159a", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unsuited.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,41 @@\n+// edition:2018\n+\n+#![feature(member_constraints)]\n+\n+trait Trait<'a, 'b> {}\n+impl<T> Trait<'_, '_> for T {}\n+\n+// `Ordinary<'a> <: Ordinary<'b>` if `'a: 'b`, as with most types.\n+//\n+// I am purposefully avoiding the terms co- and contra-variant because\n+// their application to regions depends on how you interpreted Rust\n+// regions. -nikomatsakis\n+struct Ordinary<'a>(&'a u8);\n+\n+// Here we need something outlived by `'a` *and* outlived by `'b`, but\n+// we can only name `'a` and `'b` (and neither suits). So we get an\n+// error. Somewhat unfortunate, though, since the caller would have to\n+// consider the loans for both `'a` and `'b` alive.\n+\n+fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b>\n+    //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+{\n+    // We return a value:\n+    //\n+    // ```\n+    // 'a: '0\n+    // 'b: '1\n+    // '0 in ['a, 'b]\n+    // ```\n+    //\n+    // but we don't have it.\n+    //\n+    // We are forced to pick that '0 = 'e, because only 'e is outlived by *both* 'a and 'b.\n+    if condition() { a } else { b }\n+}\n+\n+fn condition() -> bool {\n+    true\n+}\n+\n+fn main() {}"}, {"sha": "59ce93fa78b6b3754c151c15dc393c84fe9fe16e", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unsuited.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.stderr?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -0,0 +1,21 @@\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+  --> $DIR/ordinary-bounds-unsuited.rs:20:62\n+   |\n+LL | fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b>\n+   |                                                              ^^^^^^^^^^^^^^^^^^\n+   |\n+note: hidden type `Ordinary<'_>` captures the scope of call-site for function at 22:1\n+  --> $DIR/ordinary-bounds-unsuited.rs:22:1\n+   |\n+LL | / {\n+LL | |     // We return a value:\n+LL | |     //\n+LL | |     // ```\n+...  |\n+LL | |     if condition() { a } else { b }\n+LL | | }\n+   | |_^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0700`."}, {"sha": "52475f65a8353b0849060018056a7b15c446d53b", "filename": "src/test/ui/impl-trait/needs_least_region_or_bound.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fimpl-trait%2Fneeds_least_region_or_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8301de16dafc81a3b5d94aa0707ad83bdb56a599/src%2Ftest%2Fui%2Fimpl-trait%2Fneeds_least_region_or_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fneeds_least_region_or_bound.rs?ref=8301de16dafc81a3b5d94aa0707ad83bdb56a599", "patch": "@@ -1,10 +1,24 @@\n+// run-pass\n+\n+#![feature(member_constraints)]\n+\n use std::fmt::Debug;\n \n trait MultiRegionTrait<'a, 'b> {}\n impl<'a, 'b> MultiRegionTrait<'a, 'b> for (&'a u32, &'b u32) {}\n \n fn no_least_region<'a, 'b>(x: &'a u32, y: &'b u32) -> impl MultiRegionTrait<'a, 'b> {\n-//~^ ERROR ambiguous lifetime bound\n+    // Here we have a constraint that:\n+    //\n+    // (x, y) has type (&'0 u32, &'1 u32)\n+    //\n+    // where\n+    //\n+    // 'a: '0\n+    //\n+    // then we require that `('0 u32, &'1 u32): MultiRegionTrait<'a,\n+    // 'b>`, which winds up imposing a requirement that `'0 = 'a` and\n+    // `'1 = 'b`.\n     (x, y)\n }\n "}, {"sha": "f1b4d9c58f39f596f7c557628725212986355907", "filename": "src/test/ui/impl-trait/needs_least_region_or_bound.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0beb2ba16a08dfa01569b5f4644da315dc4c806c/src%2Ftest%2Fui%2Fimpl-trait%2Fneeds_least_region_or_bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0beb2ba16a08dfa01569b5f4644da315dc4c806c/src%2Ftest%2Fui%2Fimpl-trait%2Fneeds_least_region_or_bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fneeds_least_region_or_bound.stderr?ref=0beb2ba16a08dfa01569b5f4644da315dc4c806c", "patch": "@@ -1,8 +0,0 @@\n-error: ambiguous lifetime bound in `impl Trait`\n-  --> $DIR/needs_least_region_or_bound.rs:6:55\n-   |\n-LL | fn no_least_region<'a, 'b>(x: &'a u32, y: &'b u32) -> impl MultiRegionTrait<'a, 'b> {\n-   |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ neither `'a` nor `'b` outlives the other\n-\n-error: aborting due to previous error\n-"}]}