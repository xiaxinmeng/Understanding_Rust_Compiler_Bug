{"sha": "10144e29afb432425fc88cd2534577b4efa05937", "node_id": "C_kwDOAAsO6NoAKDEwMTQ0ZTI5YWZiNDMyNDI1ZmM4OGNkMjUzNDU3N2I0ZWZhMDU5Mzc", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-07-08T05:32:27Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-07-11T06:58:32Z"}, "message": "Handle tags better.\n\nCurrently, for the enums and comparison traits we always check the tag\nfor equality before doing anything else. This is a bit clumsy. This\ncommit changes things so that the tags are handled very much like a\nzeroth field in the enum.\n\nFor `eq`/ne` this makes the code slightly cleaner.\n\nFor `partial_cmp` and `cmp` it's a more notable change: in the case\nwhere the tags aren't equal, instead of having a tag equality check\nfollowed by a tag comparison, it just does a single tag comparison.\n\nThe commit also improves how `Hash` works for enums: instead of having\nduplicated code to hash the tag for every arm within the match, we do\nit just once before the match.\n\nAll this required replacing the `EnumNonMatchingCollapsed` value with a\nnew `EnumTag` value.\n\nFor fieldless enums the new code is particularly improved. All the code\nnow produced is close to optimal, being very similar to what you'd write\nby hand.", "tree": {"sha": "0fc9f573cb7135d0cc9d8f5c4c6e0aaf07f6da1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0fc9f573cb7135d0cc9d8f5c4c6e0aaf07f6da1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10144e29afb432425fc88cd2534577b4efa05937", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10144e29afb432425fc88cd2534577b4efa05937", "html_url": "https://github.com/rust-lang/rust/commit/10144e29afb432425fc88cd2534577b4efa05937", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10144e29afb432425fc88cd2534577b4efa05937/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4bcbd76bc9f8e3a22b251cbdfb21ba7815d61c7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bcbd76bc9f8e3a22b251cbdfb21ba7815d61c7f", "html_url": "https://github.com/rust-lang/rust/commit/4bcbd76bc9f8e3a22b251cbdfb21ba7815d61c7f"}], "stats": {"total": 574, "additions": 245, "deletions": 329}, "files": [{"sha": "7755ff779c4d9c4dc9b6c6c928fa5972d907f130", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10144e29afb432425fc88cd2534577b4efa05937/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10144e29afb432425fc88cd2534577b4efa05937/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=10144e29afb432425fc88cd2534577b4efa05937", "patch": "@@ -148,7 +148,7 @@ fn cs_clone_simple(\n             ),\n         }\n     }\n-    BlockOrExpr::new_mixed(stmts, cx.expr_deref(trait_span, cx.expr_self(trait_span)))\n+    BlockOrExpr::new_mixed(stmts, Some(cx.expr_deref(trait_span, cx.expr_self(trait_span))))\n }\n \n fn cs_clone(\n@@ -177,9 +177,7 @@ fn cs_clone(\n             all_fields = af;\n             vdata = &variant.data;\n         }\n-        EnumNonMatchingCollapsed(..) => {\n-            cx.span_bug(trait_span, &format!(\"non-matching enum variants in `derive({})`\", name,))\n-        }\n+        EnumTag(..) => cx.span_bug(trait_span, &format!(\"enum tags in `derive({})`\", name,)),\n         StaticEnum(..) | StaticStruct(..) => {\n             cx.span_bug(trait_span, &format!(\"associated function in `derive({})`\", name))\n         }"}, {"sha": "1612be862377bf162e8eed5a6a5fe90ab1688edb", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10144e29afb432425fc88cd2534577b4efa05937/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10144e29afb432425fc88cd2534577b4efa05937/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=10144e29afb432425fc88cd2534577b4efa05937", "patch": "@@ -73,16 +73,6 @@ pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> Bl\n                 cx.expr_match(span, expr2, vec![eq_arm, neq_arm])\n             }\n             CsFold::Fieldless => cx.expr_path(equal_path.clone()),\n-            CsFold::EnumNonMatching(span, tag_tuple) => {\n-                if tag_tuple.len() != 2 {\n-                    cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\")\n-                } else {\n-                    let lft = cx.expr_addr_of(span, cx.expr_ident(span, tag_tuple[0]));\n-                    let rgt = cx.expr_addr_of(span, cx.expr_ident(span, tag_tuple[1]));\n-                    let fn_cmp_path = cx.std_path(&[sym::cmp, sym::Ord, sym::cmp]);\n-                    cx.expr_call_global(span, fn_cmp_path, vec![lft, rgt])\n-                }\n-            }\n         },\n     );\n     BlockOrExpr::new_expr(expr)"}, {"sha": "0141b337726214877c66d5253825f3ed46a7780d", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10144e29afb432425fc88cd2534577b4efa05937/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10144e29afb432425fc88cd2534577b4efa05937/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=10144e29afb432425fc88cd2534577b4efa05937", "patch": "@@ -51,7 +51,6 @@ pub fn expand_deriving_partial_eq(\n                 }\n                 CsFold::Combine(span, expr1, expr2) => cx.expr_binary(span, combiner, expr1, expr2),\n                 CsFold::Fieldless => cx.expr_bool(span, base),\n-                CsFold::EnumNonMatching(span, _tag_tuple) => cx.expr_bool(span, !base),\n             },\n         );\n         BlockOrExpr::new_expr(expr)"}, {"sha": "2ebb01cc8a0353b4261f437407f83ec1f090a988", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/10144e29afb432425fc88cd2534577b4efa05937/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10144e29afb432425fc88cd2534577b4efa05937/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=10144e29afb432425fc88cd2534577b4efa05937", "patch": "@@ -82,17 +82,6 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_\n                 cx.expr_match(span, expr2, vec![eq_arm, neq_arm])\n             }\n             CsFold::Fieldless => cx.expr_some(span, cx.expr_path(equal_path.clone())),\n-            CsFold::EnumNonMatching(span, tag_tuple) => {\n-                if tag_tuple.len() != 2 {\n-                    cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n-                } else {\n-                    let lft = cx.expr_addr_of(span, cx.expr_ident(span, tag_tuple[0]));\n-                    let rgt = cx.expr_addr_of(span, cx.expr_ident(span, tag_tuple[1]));\n-                    let fn_partial_cmp_path =\n-                        cx.std_path(&[sym::cmp, sym::PartialOrd, sym::partial_cmp]);\n-                    cx.expr_call_global(span, fn_partial_cmp_path, vec![lft, rgt])\n-                }\n-            }\n         },\n     );\n     BlockOrExpr::new_expr(expr)"}, {"sha": "ceef893e862eb5350c408ef8b8104f9558a1adc9", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10144e29afb432425fc88cd2534577b4efa05937/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10144e29afb432425fc88cd2534577b4efa05937/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=10144e29afb432425fc88cd2534577b4efa05937", "patch": "@@ -45,7 +45,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n     let (ident, vdata, fields) = match substr.fields {\n         Struct(vdata, fields) => (substr.type_ident, *vdata, fields),\n         EnumMatching(_, _, v, fields) => (v.ident, &v.data, fields),\n-        EnumNonMatchingCollapsed(..) | StaticStruct(..) | StaticEnum(..) => {\n+        EnumTag(..) | StaticStruct(..) | StaticEnum(..) => {\n             cx.span_bug(span, \"nonsensical .fields in `#[derive(Debug)]`\")\n         }\n     };\n@@ -176,6 +176,6 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n             stmts.push(names_let.unwrap());\n         }\n         stmts.push(values_let);\n-        BlockOrExpr::new_mixed(stmts, expr)\n+        BlockOrExpr::new_mixed(stmts, Some(expr))\n     }\n }"}, {"sha": "70167cac68a7eb3196197d3b66aad635e4dbe522", "filename": "compiler/rustc_builtin_macros/src/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10144e29afb432425fc88cd2534577b4efa05937/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10144e29afb432425fc88cd2534577b4efa05937/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs?ref=10144e29afb432425fc88cd2534577b4efa05937", "patch": "@@ -287,7 +287,7 @@ fn encodable_substructure(\n                 fn_emit_enum_path,\n                 vec![encoder, cx.expr_str(trait_span, substr.type_ident.name), blk],\n             );\n-            BlockOrExpr::new_mixed(vec![me], expr)\n+            BlockOrExpr::new_mixed(vec![me], Some(expr))\n         }\n \n         _ => cx.bug(\"expected Struct or EnumMatching in derive(Encodable)\"),"}, {"sha": "7ff75592a52fbbfd58c0bac14d84febbe60289d4", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 150, "deletions": 158, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/10144e29afb432425fc88cd2534577b4efa05937/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10144e29afb432425fc88cd2534577b4efa05937/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=10144e29afb432425fc88cd2534577b4efa05937", "patch": "@@ -21,21 +21,14 @@\n //!   `struct T(i32, char)`).\n //! - `EnumMatching`, when `Self` is an enum and all the arguments are the\n //!   same variant of the enum (e.g., `Some(1)`, `Some(3)` and `Some(4)`)\n-//! - `EnumNonMatchingCollapsed` when `Self` is an enum and the arguments\n-//!   are not the same variant (e.g., `None`, `Some(1)` and `None`).\n+//! - `EnumTag` when `Self` is an enum, for comparing the enum tags.\n //! - `StaticEnum` and `StaticStruct` for static methods, where the type\n //!   being derived upon is either an enum or struct respectively. (Any\n //!   argument with type Self is just grouped among the non-self\n //!   arguments.)\n //!\n //! In the first two cases, the values from the corresponding fields in\n-//! all the arguments are grouped together. For `EnumNonMatchingCollapsed`\n-//! this isn't possible (different variants have different fields), so the\n-//! fields are inaccessible. (Previous versions of the deriving infrastructure\n-//! had a way to expand into code that could access them, at the cost of\n-//! generating exponential amounts of code; see issue #15375). There are no\n-//! fields with values in the static cases, so these are treated entirely\n-//! differently.\n+//! all the arguments are grouped together.\n //!\n //! The non-static cases have `Option<ident>` in several places associated\n //! with field `expr`s. This represents the name of the field it is\n@@ -142,21 +135,15 @@\n //!                }])\n //! ```\n //!\n-//! For `C0(a)` and `C1 {x}` ,\n+//! For the tags,\n //!\n //! ```{.text}\n-//! EnumNonMatchingCollapsed(\n-//!     &[<ident for self index value>, <ident of __arg1 index value>])\n+//! EnumTag(\n+//!     &[<ident of self tag>, <ident of other tag>], <expr to combine with>)\n //! ```\n-//!\n-//! It is the same for when the arguments are flipped to `C1 {x}` and\n-//! `C0(a)`; the only difference is what the values of the identifiers\n-//! <ident for self index value> and <ident of __arg1 index value> will\n-//! be in the generated code.\n-//!\n-//! `EnumNonMatchingCollapsed` deliberately provides far less information\n-//! than is generally available for a given pair of variants; see #15375\n-//! for discussion.\n+//! Note that this setup doesn't allow for the brute-force \"match every variant\n+//! against every other variant\" approach, which is bad because it produces a\n+//! quadratic amount of code (see #15375).\n //!\n //! ## Static\n //!\n@@ -180,7 +167,7 @@ use std::iter;\n use std::vec;\n \n use rustc_ast::ptr::P;\n-use rustc_ast::{self as ast, BinOpKind, EnumDef, Expr, Generics, PatKind};\n+use rustc_ast::{self as ast, EnumDef, Expr, Generics, PatKind};\n use rustc_ast::{GenericArg, GenericParamKind, VariantData};\n use rustc_attr as attr;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n@@ -235,6 +222,8 @@ pub struct MethodDef<'a> {\n     pub attributes: Vec<ast::Attribute>,\n \n     /// Can we combine fieldless variants for enums into a single match arm?\n+    /// If true, indicates that the trait operation uses the enum tag in some\n+    /// way.\n     pub unify_fieldless_variants: bool,\n \n     pub combine_substructure: RefCell<CombineSubstructureFunc<'a>>,\n@@ -274,19 +263,22 @@ pub enum StaticFields {\n \n /// A summary of the possible sets of fields.\n pub enum SubstructureFields<'a> {\n+    /// A non-static method with `Self` is a struct.\n     Struct(&'a ast::VariantData, Vec<FieldInfo>),\n+\n     /// Matching variants of the enum: variant index, variant count, ast::Variant,\n     /// fields: the field name is only non-`None` in the case of a struct\n     /// variant.\n     EnumMatching(usize, usize, &'a ast::Variant, Vec<FieldInfo>),\n \n-    /// Non-matching variants of the enum, but with all state hidden from the\n-    /// consequent code. The field is a list of `Ident`s bound to the variant\n-    /// index values for each of the actual input `Self` arguments.\n-    EnumNonMatchingCollapsed(&'a [Ident]),\n+    /// The tag of an enum. The first field is a `FieldInfo` for the tags, as\n+    /// if they were fields. The second field is the expression to combine the\n+    /// tag expression with; it will be `None` if no match is necessary.\n+    EnumTag(FieldInfo, Option<P<Expr>>),\n \n     /// A static method where `Self` is a struct.\n     StaticStruct(&'a ast::VariantData, StaticFields),\n+\n     /// A static method where `Self` is an enum.\n     StaticEnum(&'a ast::EnumDef, Vec<(Ident, Span, StaticFields)>),\n }\n@@ -324,8 +316,8 @@ impl BlockOrExpr {\n         BlockOrExpr(vec![], Some(expr))\n     }\n \n-    pub fn new_mixed(stmts: Vec<ast::Stmt>, expr: P<Expr>) -> BlockOrExpr {\n-        BlockOrExpr(stmts, Some(expr))\n+    pub fn new_mixed(stmts: Vec<ast::Stmt>, expr: Option<P<Expr>>) -> BlockOrExpr {\n+        BlockOrExpr(stmts, expr)\n     }\n \n     // Converts it into a block.\n@@ -339,7 +331,6 @@ impl BlockOrExpr {\n     // Converts it into an expression.\n     fn into_expr(self, cx: &ExtCtxt<'_>, span: Span) -> P<Expr> {\n         if self.0.is_empty() {\n-            // No statements.\n             match self.1 {\n                 None => cx.expr_block(cx.block(span, vec![])),\n                 Some(expr) => expr,\n@@ -1135,44 +1126,34 @@ impl<'a> MethodDef<'a> {\n     ///     fn eq(&self, other: &A) -> bool {\n     ///         let __self_tag = ::core::intrinsics::discriminant_value(self);\n     ///         let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n-    ///         if __self_tag == __arg1_tag {\n+    ///         __self_tag == __arg1_tag &&\n     ///             match (self, other) {\n     ///                 (A::A2(__self_0), A::A2(__arg1_0)) =>\n     ///                     *__self_0 == *__arg1_0,\n     ///                 _ => true,\n     ///             }\n-    ///         } else {\n-    ///             false // catch-all handler\n-    ///         }\n     ///     }\n     /// }\n     /// ```\n-    /// Creates a match for a tuple of all `selflike_args`, where either all\n-    /// variants match, or it falls into a catch-all for when one variant\n-    /// does not match.\n-    ///\n-    /// There are N + 1 cases because is a case for each of the N\n-    /// variants where all of the variants match, and one catch-all for\n-    /// when one does not match.\n-    ///\n-    /// As an optimization we generate code which checks whether all variants\n-    /// match first which makes llvm see that C-like enums can be compiled into\n-    /// a simple equality check (for PartialEq).\n-    ///\n-    /// The catch-all handler is provided access the variant index values\n-    /// for each of the selflike_args, carried in precomputed variables.\n+    /// Creates a tag check combined with a match for a tuple of all\n+    /// `selflike_args`, with an arm for each variant with fields, possibly an\n+    /// arm for each fieldless variant (if `!unify_fieldless_variants` is not\n+    /// true), and possibly a default arm.\n     fn expand_enum_method_body<'b>(\n         &self,\n         cx: &mut ExtCtxt<'_>,\n         trait_: &TraitDef<'b>,\n         enum_def: &'b EnumDef,\n         type_ident: Ident,\n-        mut selflike_args: Vec<P<Expr>>,\n+        selflike_args: Vec<P<Expr>>,\n         nonselflike_args: &[P<Expr>],\n     ) -> BlockOrExpr {\n         let span = trait_.span;\n         let variants = &enum_def.variants;\n \n+        // Traits that unify fieldless variants always use the tag(s).\n+        let uses_tags = self.unify_fieldless_variants;\n+\n         // There is no sensible code to be generated for *any* deriving on a\n         // zero-variant enum. So we just generate a failing expression.\n         if variants.is_empty() {\n@@ -1189,27 +1170,82 @@ impl<'a> MethodDef<'a> {\n             )\n             .collect::<Vec<String>>();\n \n-        // The `tag_idents` will be bound, solely in the catch-all, to\n-        // a series of let statements mapping each selflike_arg to an int\n-        // value corresponding to its discriminant.\n-        let tag_idents = prefixes\n-            .iter()\n-            .map(|name| Ident::from_str_and_span(&format!(\"{}_tag\", name), span))\n-            .collect::<Vec<Ident>>();\n+        // Build a series of let statements mapping each selflike_arg\n+        // to its discriminant value.\n+        //\n+        // e.g. for `PartialEq::eq` builds two statements:\n+        // ```\n+        // let __self_tag = ::core::intrinsics::discriminant_value(self);\n+        // let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n+        // ```\n+        let get_tag_pieces = |cx: &ExtCtxt<'_>| {\n+            let tag_idents: Vec<_> = prefixes\n+                .iter()\n+                .map(|name| Ident::from_str_and_span(&format!(\"{}_tag\", name), span))\n+                .collect();\n \n-        // Builds, via callback to call_substructure_method, the\n-        // delegated expression that handles the catch-all case,\n-        // using `__variants_tuple` to drive logic if necessary.\n-        let catch_all_substructure = EnumNonMatchingCollapsed(&tag_idents);\n+            let mut tag_exprs: Vec<_> = tag_idents\n+                .iter()\n+                .map(|&ident| cx.expr_addr_of(span, cx.expr_ident(span, ident)))\n+                .collect();\n \n-        let first_fieldless = variants.iter().find(|v| v.data.fields().is_empty());\n+            let self_expr = tag_exprs.remove(0);\n+            let other_selflike_exprs = tag_exprs;\n+            let tag_field = FieldInfo { span, name: None, self_expr, other_selflike_exprs };\n+\n+            let tag_let_stmts: Vec<_> = iter::zip(&tag_idents, &selflike_args)\n+                .map(|(&ident, selflike_arg)| {\n+                    let variant_value = deriving::call_intrinsic(\n+                        cx,\n+                        span,\n+                        sym::discriminant_value,\n+                        vec![selflike_arg.clone()],\n+                    );\n+                    cx.stmt_let(span, false, ident, variant_value)\n+                })\n+                .collect();\n+\n+            (tag_field, tag_let_stmts)\n+        };\n+\n+        // There are some special cases involving fieldless enums where no\n+        // match is necessary.\n+        let all_fieldless = variants.iter().all(|v| v.data.fields().is_empty());\n+        if all_fieldless {\n+            if uses_tags && variants.len() > 1 {\n+                // If the type is fieldless and the trait uses the tag and\n+                // there are multiple variants, we need just an operation on\n+                // the tag(s).\n+                let (tag_field, mut tag_let_stmts) = get_tag_pieces(cx);\n+                let mut tag_check = self.call_substructure_method(\n+                    cx,\n+                    trait_,\n+                    type_ident,\n+                    nonselflike_args,\n+                    &EnumTag(tag_field, None),\n+                );\n+                tag_let_stmts.append(&mut tag_check.0);\n+                return BlockOrExpr(tag_let_stmts, tag_check.1);\n+            }\n+\n+            if variants.len() == 1 {\n+                // If there is a single variant, we don't need an operation on\n+                // the tag(s). Just use the most degenerate result.\n+                return self.call_substructure_method(\n+                    cx,\n+                    trait_,\n+                    type_ident,\n+                    nonselflike_args,\n+                    &EnumMatching(0, 1, &variants[0], Vec::new()),\n+                );\n+            };\n+        }\n \n         // These arms are of the form:\n         // (Variant1, Variant1, ...) => Body1\n         // (Variant2, Variant2, ...) => Body2\n         // ...\n         // where each tuple has length = selflike_args.len()\n-\n         let mut match_arms: Vec<ast::Arm> = variants\n             .iter()\n             .enumerate()\n@@ -1233,7 +1269,7 @@ impl<'a> MethodDef<'a> {\n                     use_ref_pat,\n                 );\n \n-                // Here is the pat = `(&VariantK, &VariantK, ...)`\n+                // `(VariantK, VariantK, ...)` or just `VariantK`.\n                 let single_pat = if subpats.len() == 1 {\n                     subpats.pop().unwrap()\n                 } else {\n@@ -1263,27 +1299,28 @@ impl<'a> MethodDef<'a> {\n             })\n             .collect();\n \n+        // Add a default arm to the match, if necessary.\n+        let first_fieldless = variants.iter().find(|v| v.data.fields().is_empty());\n         let default = match first_fieldless {\n             Some(v) if self.unify_fieldless_variants => {\n-                // We need a default case that handles the fieldless variants.\n-                // The index and actual variant aren't meaningful in this case,\n-                // so just use whatever\n-                let substructure = EnumMatching(0, variants.len(), v, Vec::new());\n+                // We need a default case that handles all the fieldless\n+                // variants. The index and actual variant aren't meaningful in\n+                // this case, so just use dummy values.\n                 Some(\n                     self.call_substructure_method(\n                         cx,\n                         trait_,\n                         type_ident,\n                         nonselflike_args,\n-                        &substructure,\n+                        &EnumMatching(0, variants.len(), v, Vec::new()),\n                     )\n                     .into_expr(cx, span),\n                 )\n             }\n             _ if variants.len() > 1 && selflike_args.len() > 1 => {\n-                // Since we know that all the arguments will match if we reach\n+                // Because we know that all the arguments will match if we reach\n                 // the match expression we add the unreachable intrinsics as the\n-                // result of the catch all which should help llvm in optimizing it\n+                // result of the default which should help llvm in optimizing it.\n                 Some(deriving::call_unreachable(cx, span))\n             }\n             _ => None,\n@@ -1292,92 +1329,41 @@ impl<'a> MethodDef<'a> {\n             match_arms.push(cx.arm(span, cx.pat_wild(span), arm));\n         }\n \n-        // We will usually need the catch-all after matching the\n-        // tuples `(VariantK, VariantK, ...)` for each VariantK of the\n-        // enum.  But:\n-        //\n-        // * when there is only one Self arg, the arms above suffice\n-        // (and the deriving we call back into may not be prepared to\n-        // handle EnumNonMatchCollapsed), and,\n-        //\n-        // * when the enum has only one variant, the single arm that\n-        // is already present always suffices.\n-        //\n-        // * In either of the two cases above, if we *did* add a\n-        //   catch-all `_` match, it would trigger the\n-        //   unreachable-pattern error.\n-        //\n-        if variants.len() > 1 && selflike_args.len() > 1 {\n-            // Build a series of let statements mapping each selflike_arg\n-            // to its discriminant value.\n-            //\n-            // i.e., for `enum E<T> { A, B(1), C(T, T) }` for `PartialEq::eq`,\n-            // builds two statements:\n-            // ```\n-            // let __self_tag = ::core::intrinsics::discriminant_value(self);\n-            // let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n-            // ```\n-            let mut index_let_stmts: Vec<ast::Stmt> = Vec::with_capacity(tag_idents.len() + 1);\n-\n-            // We also build an expression which checks whether all discriminants are equal, e.g.\n-            // `__self_tag == __arg1_tag`.\n-            let mut discriminant_test = cx.expr_bool(span, true);\n-            for (i, (&ident, selflike_arg)) in iter::zip(&tag_idents, &selflike_args).enumerate() {\n-                let variant_value = deriving::call_intrinsic(\n-                    cx,\n-                    span,\n-                    sym::discriminant_value,\n-                    vec![selflike_arg.clone()],\n-                );\n-                let let_stmt = cx.stmt_let(span, false, ident, variant_value);\n-                index_let_stmts.push(let_stmt);\n-\n-                if i > 0 {\n-                    let id0 = cx.expr_ident(span, tag_idents[0]);\n-                    let id = cx.expr_ident(span, ident);\n-                    let test = cx.expr_binary(span, BinOpKind::Eq, id0, id);\n-                    discriminant_test = if i == 1 {\n-                        test\n-                    } else {\n-                        cx.expr_binary(span, BinOpKind::And, discriminant_test, test)\n-                    };\n-                }\n-            }\n-\n-            let arm_expr = self\n-                .call_substructure_method(\n-                    cx,\n-                    trait_,\n-                    type_ident,\n-                    nonselflike_args,\n-                    &catch_all_substructure,\n-                )\n-                .into_expr(cx, span);\n-\n-            let match_arg = cx.expr(span, ast::ExprKind::Tup(selflike_args));\n-\n-            // Lastly we create an expression which branches on all discriminants being equal, e.g.\n-            //  if __self_tag == _arg1_tag {\n-            //      match (self, other) {\n-            //          (Variant1, Variant1, ...) => Body1\n-            //          (Variant2, Variant2, ...) => Body2,\n-            //          ...\n-            //          _ => ::core::intrinsics::unreachable()\n-            //      }\n-            //  }\n-            //  else {\n-            //      <delegated expression referring to __self_tag, et al.>\n-            //  }\n-            let all_match = cx.expr_match(span, match_arg, match_arms);\n-            let arm_expr = cx.expr_if(span, discriminant_test, all_match, Some(arm_expr));\n-            BlockOrExpr(index_let_stmts, Some(arm_expr))\n-        } else {\n+        // Create a match expression with one arm per discriminant plus\n+        // possibly a default arm, e.g.:\n+        //      match (self, other) {\n+        //          (Variant1, Variant1, ...) => Body1\n+        //          (Variant2, Variant2, ...) => Body2,\n+        //          ...\n+        //          _ => ::core::intrinsics::unreachable()\n+        //      }\n+        let get_match_expr = |mut selflike_args: Vec<P<Expr>>| {\n             let match_arg = if selflike_args.len() == 1 {\n                 selflike_args.pop().unwrap()\n             } else {\n                 cx.expr(span, ast::ExprKind::Tup(selflike_args))\n             };\n-            BlockOrExpr(vec![], Some(cx.expr_match(span, match_arg, match_arms)))\n+            cx.expr_match(span, match_arg, match_arms)\n+        };\n+\n+        // If the trait uses the tag and there are multiple variants, we need\n+        // to add a tag check operation before the match. Otherwise, the match\n+        // is enough.\n+        if uses_tags && variants.len() > 1 {\n+            let (tag_field, mut tag_let_stmts) = get_tag_pieces(cx);\n+\n+            // Combine a tag check with the match.\n+            let mut tag_check_plus_match = self.call_substructure_method(\n+                cx,\n+                trait_,\n+                type_ident,\n+                nonselflike_args,\n+                &EnumTag(tag_field, Some(get_match_expr(selflike_args))),\n+            );\n+            tag_let_stmts.append(&mut tag_check_plus_match.0);\n+            BlockOrExpr(tag_let_stmts, tag_check_plus_match.1)\n+        } else {\n+            BlockOrExpr(vec![], Some(get_match_expr(selflike_args)))\n         }\n     }\n \n@@ -1591,11 +1577,6 @@ pub enum CsFold<'a> {\n \n     // The fallback case for a struct or enum variant with no fields.\n     Fieldless,\n-\n-    /// The fallback case for non-matching enum variants. The slice is the\n-    /// identifiers holding the variant index value for each of the `Self`\n-    /// arguments.\n-    EnumNonMatching(Span, &'a [Ident]),\n }\n \n /// Folds over fields, combining the expressions for each field in a sequence.\n@@ -1610,8 +1591,8 @@ pub fn cs_fold<F>(\n where\n     F: FnMut(&mut ExtCtxt<'_>, CsFold<'_>) -> P<Expr>,\n {\n-    match *substructure.fields {\n-        EnumMatching(.., ref all_fields) | Struct(_, ref all_fields) => {\n+    match substructure.fields {\n+        EnumMatching(.., all_fields) | Struct(_, all_fields) => {\n             if all_fields.is_empty() {\n                 return f(cx, CsFold::Fieldless);\n             }\n@@ -1635,7 +1616,18 @@ where\n                 rest.iter().rfold(base_expr, op)\n             }\n         }\n-        EnumNonMatchingCollapsed(tuple) => f(cx, CsFold::EnumNonMatching(trait_span, tuple)),\n+        EnumTag(tag_field, match_expr) => {\n+            let tag_check_expr = f(cx, CsFold::Single(tag_field));\n+            if let Some(match_expr) = match_expr {\n+                if use_foldl {\n+                    f(cx, CsFold::Combine(trait_span, tag_check_expr, match_expr.clone()))\n+                } else {\n+                    f(cx, CsFold::Combine(trait_span, match_expr.clone(), tag_check_expr))\n+                }\n+            } else {\n+                tag_check_expr\n+            }\n+        }\n         StaticEnum(..) | StaticStruct(..) => cx.span_bug(trait_span, \"static function in `derive`\"),\n     }\n }"}, {"sha": "32ae3d3447896eeb8cdf4abd4c67147b9fd57b07", "filename": "compiler/rustc_builtin_macros/src/deriving/hash.rs", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/10144e29afb432425fc88cd2534577b4efa05937/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10144e29afb432425fc88cd2534577b4efa05937/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs?ref=10144e29afb432425fc88cd2534577b4efa05937", "patch": "@@ -1,6 +1,6 @@\n use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n-use crate::deriving::{self, path_std, pathvec_std};\n+use crate::deriving::{path_std, pathvec_std};\n \n use rustc_ast::{MetaItem, Mutability};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n@@ -61,32 +61,20 @@ fn hash_substructure(\n         let expr = cx.expr_call(span, hash_path, vec![expr, state_expr.clone()]);\n         cx.stmt_expr(expr)\n     };\n-    let mut stmts = Vec::new();\n \n-    let fields = match substr.fields {\n-        Struct(_, fs) | EnumMatching(_, 1, .., fs) => fs,\n-        EnumMatching(.., fs) => {\n-            let variant_value = cx.expr_addr_of(\n-                trait_span,\n-                deriving::call_intrinsic(\n-                    cx,\n-                    trait_span,\n-                    sym::discriminant_value,\n-                    vec![cx.expr_self(trait_span)],\n-                ),\n-            );\n-\n-            stmts.push(call_hash(trait_span, variant_value));\n-\n-            fs\n+    let (stmts, match_expr) = match substr.fields {\n+        Struct(_, fields) | EnumMatching(.., fields) => {\n+            let stmts =\n+                fields.iter().map(|field| call_hash(field.span, field.self_expr.clone())).collect();\n+            (stmts, None)\n+        }\n+        EnumTag(tag_field, match_expr) => {\n+            assert!(tag_field.other_selflike_exprs.is_empty());\n+            let stmts = vec![call_hash(tag_field.span, tag_field.self_expr.clone())];\n+            (stmts, match_expr.clone())\n         }\n         _ => cx.span_bug(trait_span, \"impossible substructure in `derive(Hash)`\"),\n     };\n \n-    stmts.extend(\n-        fields\n-            .iter()\n-            .map(|FieldInfo { ref self_expr, span, .. }| call_hash(*span, self_expr.clone())),\n-    );\n-    BlockOrExpr::new_stmts(stmts)\n+    BlockOrExpr::new_mixed(stmts, match_expr)\n }"}, {"sha": "e129f25b0dd0bfa604917b6e41fa845bddaf1017", "filename": "src/test/ui/deriving/deriving-all-codegen.stdout", "status": "modified", "additions": 78, "deletions": 118, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/10144e29afb432425fc88cd2534577b4efa05937/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/10144e29afb432425fc88cd2534577b4efa05937/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout?ref=10144e29afb432425fc88cd2534577b4efa05937", "patch": "@@ -766,17 +766,13 @@ enum Fieldless1 {\n #[allow(unused_qualifications)]\n impl ::core::clone::Clone for Fieldless1 {\n     #[inline]\n-    fn clone(&self) -> Fieldless1 {\n-        match self { Fieldless1::A => Fieldless1::A, }\n-    }\n+    fn clone(&self) -> Fieldless1 { Fieldless1::A }\n }\n #[automatically_derived]\n #[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Fieldless1 {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n-        match self {\n-            Fieldless1::A => ::core::fmt::Formatter::write_str(f, \"A\"),\n-        }\n+        ::core::fmt::Formatter::write_str(f, \"A\")\n     }\n }\n #[automatically_derived]\n@@ -788,18 +784,14 @@ impl ::core::default::Default for Fieldless1 {\n #[automatically_derived]\n #[allow(unused_qualifications)]\n impl ::core::hash::Hash for Fieldless1 {\n-    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n-        match self { _ => {} }\n-    }\n+    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}\n }\n impl ::core::marker::StructuralPartialEq for Fieldless1 {}\n #[automatically_derived]\n #[allow(unused_qualifications)]\n impl ::core::cmp::PartialEq for Fieldless1 {\n     #[inline]\n-    fn eq(&self, other: &Fieldless1) -> bool {\n-        match (self, other) { _ => true, }\n-    }\n+    fn eq(&self, other: &Fieldless1) -> bool { true }\n }\n impl ::core::marker::StructuralEq for Fieldless1 {}\n #[automatically_derived]\n@@ -816,17 +808,15 @@ impl ::core::cmp::PartialOrd for Fieldless1 {\n     #[inline]\n     fn partial_cmp(&self, other: &Fieldless1)\n         -> ::core::option::Option<::core::cmp::Ordering> {\n-        match (self, other) {\n-            _ => ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n-        }\n+        ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n     }\n }\n #[automatically_derived]\n #[allow(unused_qualifications)]\n impl ::core::cmp::Ord for Fieldless1 {\n     #[inline]\n     fn cmp(&self, other: &Fieldless1) -> ::core::cmp::Ordering {\n-        match (self, other) { _ => ::core::cmp::Ordering::Equal, }\n+        ::core::cmp::Ordering::Equal\n     }\n }\n \n@@ -868,11 +858,8 @@ impl ::core::default::Default for Fieldless {\n #[allow(unused_qualifications)]\n impl ::core::hash::Hash for Fieldless {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n-        match self {\n-            _ =>\n-                ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n-                    state),\n-        }\n+        let __self_tag = ::core::intrinsics::discriminant_value(self);\n+        ::core::hash::Hash::hash(&__self_tag, state)\n     }\n }\n impl ::core::marker::StructuralPartialEq for Fieldless {}\n@@ -883,9 +870,7 @@ impl ::core::cmp::PartialEq for Fieldless {\n     fn eq(&self, other: &Fieldless) -> bool {\n         let __self_tag = ::core::intrinsics::discriminant_value(self);\n         let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n-        if __self_tag == __arg1_tag {\n-                match (self, other) { _ => true, }\n-            } else { false }\n+        __self_tag == __arg1_tag\n     }\n }\n impl ::core::marker::StructuralEq for Fieldless {}\n@@ -905,14 +890,7 @@ impl ::core::cmp::PartialOrd for Fieldless {\n         -> ::core::option::Option<::core::cmp::Ordering> {\n         let __self_tag = ::core::intrinsics::discriminant_value(self);\n         let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n-        if __self_tag == __arg1_tag {\n-                match (self, other) {\n-                    _ =>\n-                        ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n-                }\n-            } else {\n-               ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)\n-           }\n+        ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)\n     }\n }\n #[automatically_derived]\n@@ -922,9 +900,7 @@ impl ::core::cmp::Ord for Fieldless {\n     fn cmp(&self, other: &Fieldless) -> ::core::cmp::Ordering {\n         let __self_tag = ::core::intrinsics::discriminant_value(self);\n         let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n-        if __self_tag == __arg1_tag {\n-                match (self, other) { _ => ::core::cmp::Ordering::Equal, }\n-            } else { ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) }\n+        ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag)\n     }\n }\n \n@@ -978,21 +954,15 @@ impl ::core::default::Default for Mixed {\n #[allow(unused_qualifications)]\n impl ::core::hash::Hash for Mixed {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n+        let __self_tag = ::core::intrinsics::discriminant_value(self);\n+        ::core::hash::Hash::hash(&__self_tag, state);\n         match self {\n-            Mixed::R(__self_0) => {\n-                ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n-                    state);\n-                ::core::hash::Hash::hash(__self_0, state)\n-            }\n+            Mixed::R(__self_0) => ::core::hash::Hash::hash(__self_0, state),\n             Mixed::S { d1: __self_0, d2: __self_1 } => {\n-                ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n-                    state);\n                 ::core::hash::Hash::hash(__self_0, state);\n                 ::core::hash::Hash::hash(__self_1, state)\n             }\n-            _ =>\n-                ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n-                    state),\n+            _ => {}\n         }\n     }\n }\n@@ -1004,31 +974,29 @@ impl ::core::cmp::PartialEq for Mixed {\n     fn eq(&self, other: &Mixed) -> bool {\n         let __self_tag = ::core::intrinsics::discriminant_value(self);\n         let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n-        if __self_tag == __arg1_tag {\n-                match (self, other) {\n-                    (Mixed::R(__self_0), Mixed::R(__arg1_0)) =>\n-                        *__self_0 == *__arg1_0,\n-                    (Mixed::S { d1: __self_0, d2: __self_1 }, Mixed::S {\n-                        d1: __arg1_0, d2: __arg1_1 }) =>\n-                        *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1,\n-                    _ => true,\n-                }\n-            } else { false }\n+        __self_tag == __arg1_tag &&\n+            match (self, other) {\n+                (Mixed::R(__self_0), Mixed::R(__arg1_0)) =>\n+                    *__self_0 == *__arg1_0,\n+                (Mixed::S { d1: __self_0, d2: __self_1 }, Mixed::S {\n+                    d1: __arg1_0, d2: __arg1_1 }) =>\n+                    *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1,\n+                _ => true,\n+            }\n     }\n     #[inline]\n     fn ne(&self, other: &Mixed) -> bool {\n         let __self_tag = ::core::intrinsics::discriminant_value(self);\n         let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n-        if __self_tag == __arg1_tag {\n-                match (self, other) {\n-                    (Mixed::R(__self_0), Mixed::R(__arg1_0)) =>\n-                        *__self_0 != *__arg1_0,\n-                    (Mixed::S { d1: __self_0, d2: __self_1 }, Mixed::S {\n-                        d1: __arg1_0, d2: __arg1_1 }) =>\n-                        *__self_0 != *__arg1_0 || *__self_1 != *__arg1_1,\n-                    _ => false,\n-                }\n-            } else { true }\n+        __self_tag != __arg1_tag ||\n+            match (self, other) {\n+                (Mixed::R(__self_0), Mixed::R(__arg1_0)) =>\n+                    *__self_0 != *__arg1_0,\n+                (Mixed::S { d1: __self_0, d2: __self_1 }, Mixed::S {\n+                    d1: __arg1_0, d2: __arg1_1 }) =>\n+                    *__self_0 != *__arg1_0 || *__self_1 != *__arg1_1,\n+                _ => false,\n+            }\n     }\n }\n impl ::core::marker::StructuralEq for Mixed {}\n@@ -1050,7 +1018,8 @@ impl ::core::cmp::PartialOrd for Mixed {\n         -> ::core::option::Option<::core::cmp::Ordering> {\n         let __self_tag = ::core::intrinsics::discriminant_value(self);\n         let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n-        if __self_tag == __arg1_tag {\n+        match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {\n+            ::core::option::Option::Some(::core::cmp::Ordering::Equal) =>\n                 match (self, other) {\n                     (Mixed::R(__self_0), Mixed::R(__arg1_0)) =>\n                         ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),\n@@ -1064,10 +1033,9 @@ impl ::core::cmp::PartialOrd for Mixed {\n                         },\n                     _ =>\n                         ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n-                }\n-            } else {\n-               ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)\n-           }\n+                },\n+            cmp => cmp,\n+        }\n     }\n }\n #[automatically_derived]\n@@ -1077,7 +1045,8 @@ impl ::core::cmp::Ord for Mixed {\n     fn cmp(&self, other: &Mixed) -> ::core::cmp::Ordering {\n         let __self_tag = ::core::intrinsics::discriminant_value(self);\n         let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n-        if __self_tag == __arg1_tag {\n+        match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {\n+            ::core::cmp::Ordering::Equal =>\n                 match (self, other) {\n                     (Mixed::R(__self_0), Mixed::R(__arg1_0)) =>\n                         ::core::cmp::Ord::cmp(__self_0, __arg1_0),\n@@ -1089,8 +1058,9 @@ impl ::core::cmp::Ord for Mixed {\n                             cmp => cmp,\n                         },\n                     _ => ::core::cmp::Ordering::Equal,\n-                }\n-            } else { ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) }\n+                },\n+            cmp => cmp,\n+        }\n     }\n }\n \n@@ -1133,22 +1103,12 @@ impl ::core::fmt::Debug for Fielded {\n #[allow(unused_qualifications)]\n impl ::core::hash::Hash for Fielded {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n+        let __self_tag = ::core::intrinsics::discriminant_value(self);\n+        ::core::hash::Hash::hash(&__self_tag, state);\n         match self {\n-            Fielded::X(__self_0) => {\n-                ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n-                    state);\n-                ::core::hash::Hash::hash(__self_0, state)\n-            }\n-            Fielded::Y(__self_0) => {\n-                ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n-                    state);\n-                ::core::hash::Hash::hash(__self_0, state)\n-            }\n-            Fielded::Z(__self_0) => {\n-                ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n-                    state);\n-                ::core::hash::Hash::hash(__self_0, state)\n-            }\n+            Fielded::X(__self_0) => ::core::hash::Hash::hash(__self_0, state),\n+            Fielded::Y(__self_0) => ::core::hash::Hash::hash(__self_0, state),\n+            Fielded::Z(__self_0) => ::core::hash::Hash::hash(__self_0, state),\n         }\n     }\n }\n@@ -1160,33 +1120,31 @@ impl ::core::cmp::PartialEq for Fielded {\n     fn eq(&self, other: &Fielded) -> bool {\n         let __self_tag = ::core::intrinsics::discriminant_value(self);\n         let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n-        if __self_tag == __arg1_tag {\n-                match (self, other) {\n-                    (Fielded::X(__self_0), Fielded::X(__arg1_0)) =>\n-                        *__self_0 == *__arg1_0,\n-                    (Fielded::Y(__self_0), Fielded::Y(__arg1_0)) =>\n-                        *__self_0 == *__arg1_0,\n-                    (Fielded::Z(__self_0), Fielded::Z(__arg1_0)) =>\n-                        *__self_0 == *__arg1_0,\n-                    _ => unsafe { ::core::intrinsics::unreachable() }\n-                }\n-            } else { false }\n+        __self_tag == __arg1_tag &&\n+            match (self, other) {\n+                (Fielded::X(__self_0), Fielded::X(__arg1_0)) =>\n+                    *__self_0 == *__arg1_0,\n+                (Fielded::Y(__self_0), Fielded::Y(__arg1_0)) =>\n+                    *__self_0 == *__arg1_0,\n+                (Fielded::Z(__self_0), Fielded::Z(__arg1_0)) =>\n+                    *__self_0 == *__arg1_0,\n+                _ => unsafe { ::core::intrinsics::unreachable() }\n+            }\n     }\n     #[inline]\n     fn ne(&self, other: &Fielded) -> bool {\n         let __self_tag = ::core::intrinsics::discriminant_value(self);\n         let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n-        if __self_tag == __arg1_tag {\n-                match (self, other) {\n-                    (Fielded::X(__self_0), Fielded::X(__arg1_0)) =>\n-                        *__self_0 != *__arg1_0,\n-                    (Fielded::Y(__self_0), Fielded::Y(__arg1_0)) =>\n-                        *__self_0 != *__arg1_0,\n-                    (Fielded::Z(__self_0), Fielded::Z(__arg1_0)) =>\n-                        *__self_0 != *__arg1_0,\n-                    _ => unsafe { ::core::intrinsics::unreachable() }\n-                }\n-            } else { true }\n+        __self_tag != __arg1_tag ||\n+            match (self, other) {\n+                (Fielded::X(__self_0), Fielded::X(__arg1_0)) =>\n+                    *__self_0 != *__arg1_0,\n+                (Fielded::Y(__self_0), Fielded::Y(__arg1_0)) =>\n+                    *__self_0 != *__arg1_0,\n+                (Fielded::Z(__self_0), Fielded::Z(__arg1_0)) =>\n+                    *__self_0 != *__arg1_0,\n+                _ => unsafe { ::core::intrinsics::unreachable() }\n+            }\n     }\n }\n impl ::core::marker::StructuralEq for Fielded {}\n@@ -1210,7 +1168,8 @@ impl ::core::cmp::PartialOrd for Fielded {\n         -> ::core::option::Option<::core::cmp::Ordering> {\n         let __self_tag = ::core::intrinsics::discriminant_value(self);\n         let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n-        if __self_tag == __arg1_tag {\n+        match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {\n+            ::core::option::Option::Some(::core::cmp::Ordering::Equal) =>\n                 match (self, other) {\n                     (Fielded::X(__self_0), Fielded::X(__arg1_0)) =>\n                         ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),\n@@ -1219,10 +1178,9 @@ impl ::core::cmp::PartialOrd for Fielded {\n                     (Fielded::Z(__self_0), Fielded::Z(__arg1_0)) =>\n                         ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),\n                     _ => unsafe { ::core::intrinsics::unreachable() }\n-                }\n-            } else {\n-               ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)\n-           }\n+                },\n+            cmp => cmp,\n+        }\n     }\n }\n #[automatically_derived]\n@@ -1232,7 +1190,8 @@ impl ::core::cmp::Ord for Fielded {\n     fn cmp(&self, other: &Fielded) -> ::core::cmp::Ordering {\n         let __self_tag = ::core::intrinsics::discriminant_value(self);\n         let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n-        if __self_tag == __arg1_tag {\n+        match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {\n+            ::core::cmp::Ordering::Equal =>\n                 match (self, other) {\n                     (Fielded::X(__self_0), Fielded::X(__arg1_0)) =>\n                         ::core::cmp::Ord::cmp(__self_0, __arg1_0),\n@@ -1241,8 +1200,9 @@ impl ::core::cmp::Ord for Fielded {\n                     (Fielded::Z(__self_0), Fielded::Z(__arg1_0)) =>\n                         ::core::cmp::Ord::cmp(__self_0, __arg1_0),\n                     _ => unsafe { ::core::intrinsics::unreachable() }\n-                }\n-            } else { ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) }\n+                },\n+            cmp => cmp,\n+        }\n     }\n }\n "}]}