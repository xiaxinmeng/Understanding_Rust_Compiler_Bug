{"sha": "cf911ac7578b7079f8bf2944c841c39510967b7b", "node_id": "C_kwDOAAsO6NoAKGNmOTExYWM3NTc4YjcwNzlmOGJmMjk0NGM4NDFjMzk1MTA5NjdiN2I", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-04-28T05:34:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-04-28T05:34:02Z"}, "message": "Rollup merge of #110766 - m-ou-se:fmt-rt, r=jyn514\n\nMore core::fmt::rt cleanup.\n\n- Removes the `V1` suffix from the `Argument` and `Flag` types.\n\n- Moves more of the format_args lang items into the `core::fmt::rt` module. (The only remaining lang item in `core::fmt` is `Arguments` itself, which is a public type.)\n\nPart of https://github.com/rust-lang/rust/issues/99012\n\nFollow-up to https://github.com/rust-lang/rust/pull/110616", "tree": {"sha": "c212f5b952d86675c768c688c28f0d2407214330", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c212f5b952d86675c768c688c28f0d2407214330"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf911ac7578b7079f8bf2944c841c39510967b7b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkS1rKCRBK7hj4Ov3rIwAA3kIIAAgNQb4v94daSalF2CW10KPx\n3UvzV8tvTpB3KC1mV9vrpe50MqWspKWAQzbGuPWleX8kD6PNuHukAoET9CfrnvNA\niLnMg0OT94h9PmvWjTjnVGXSYfe6W79hEb+nIvh9GRLH/FnuSq27lu0TvaWhLp1e\nTUyqfKfODTlyxD4l0jR9697oWkNFUW9tkq59sqHMbSo/VfXX4a+pMvCN3QZFzuWk\nv7jAJVUZ1hsWsncFnOtZqK4F0/niHzaT4/owWsq3LbNPVd1Nm21WezFxZ6AUi4El\n38dQAbegkx7RXHw8eihVe0L2MrhK2laUp01B21fISAZm5GrcEKzUmlqTACTfjMM=\n=tQMr\n-----END PGP SIGNATURE-----\n", "payload": "tree c212f5b952d86675c768c688c28f0d2407214330\nparent 9a3258fa52acdc4b63d0a49df2bd989153440d9b\nparent 52ff751aa4094c808a39d8e4cd9e5f0d1ea7974a\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1682660042 +0200\ncommitter GitHub <noreply@github.com> 1682660042 +0200\n\nRollup merge of #110766 - m-ou-se:fmt-rt, r=jyn514\n\nMore core::fmt::rt cleanup.\n\n- Removes the `V1` suffix from the `Argument` and `Flag` types.\n\n- Moves more of the format_args lang items into the `core::fmt::rt` module. (The only remaining lang item in `core::fmt` is `Arguments` itself, which is a public type.)\n\nPart of https://github.com/rust-lang/rust/issues/99012\n\nFollow-up to https://github.com/rust-lang/rust/pull/110616\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf911ac7578b7079f8bf2944c841c39510967b7b", "html_url": "https://github.com/rust-lang/rust/commit/cf911ac7578b7079f8bf2944c841c39510967b7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf911ac7578b7079f8bf2944c841c39510967b7b/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a3258fa52acdc4b63d0a49df2bd989153440d9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a3258fa52acdc4b63d0a49df2bd989153440d9b", "html_url": "https://github.com/rust-lang/rust/commit/9a3258fa52acdc4b63d0a49df2bd989153440d9b"}, {"sha": "52ff751aa4094c808a39d8e4cd9e5f0d1ea7974a", "url": "https://api.github.com/repos/rust-lang/rust/commits/52ff751aa4094c808a39d8e4cd9e5f0d1ea7974a", "html_url": "https://github.com/rust-lang/rust/commit/52ff751aa4094c808a39d8e4cd9e5f0d1ea7974a"}], "stats": {"total": 551, "additions": 276, "deletions": 275}, "files": [{"sha": "c081162ea1467eb5b46425ffc1433e354c57aba2", "filename": "compiler/rustc_ast_lowering/src/format.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cf911ac7578b7079f8bf2944c841c39510967b7b/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf911ac7578b7079f8bf2944c841c39510967b7b/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs?ref=cf911ac7578b7079f8bf2944c841c39510967b7b", "patch": "@@ -186,7 +186,7 @@ enum ArgumentType {\n /// Generates:\n ///\n /// ```text\n-///     <core::fmt::ArgumentV1>::new_\u2026(arg)\n+///     <core::fmt::Argument>::new_\u2026(arg)\n /// ```\n fn make_argument<'hir>(\n     ctx: &mut LoweringContext<'_, 'hir>,\n@@ -327,7 +327,7 @@ fn make_format_spec<'hir>(\n             None => sym::Unknown,\n         },\n     );\n-    // This needs to match `FlagV1` in library/core/src/fmt/mod.rs.\n+    // This needs to match `Flag` in library/core/src/fmt/rt.rs.\n     let flags: u32 = ((sign == Some(FormatSign::Plus)) as u32)\n         | ((sign == Some(FormatSign::Minus)) as u32) << 1\n         | (alternate as u32) << 2\n@@ -438,7 +438,7 @@ fn expand_format_args<'hir>(\n     // If the args array contains exactly all the original arguments once,\n     // in order, we can use a simple array instead of a `match` construction.\n     // However, if there's a yield point in any argument except the first one,\n-    // we don't do this, because an ArgumentV1 cannot be kept across yield points.\n+    // we don't do this, because an Argument cannot be kept across yield points.\n     //\n     // This is an optimization, speeding up compilation about 1-2% in some cases.\n     // See https://github.com/rust-lang/rust/pull/106770#issuecomment-1380790609\n@@ -449,9 +449,9 @@ fn expand_format_args<'hir>(\n     let args = if use_simple_array {\n         // Generate:\n         //     &[\n-        //         <core::fmt::ArgumentV1>::new_display(&arg0),\n-        //         <core::fmt::ArgumentV1>::new_lower_hex(&arg1),\n-        //         <core::fmt::ArgumentV1>::new_debug(&arg2),\n+        //         <core::fmt::Argument>::new_display(&arg0),\n+        //         <core::fmt::Argument>::new_lower_hex(&arg1),\n+        //         <core::fmt::Argument>::new_debug(&arg2),\n         //         \u2026\n         //     ]\n         let elements: Vec<_> = arguments\n@@ -477,9 +477,9 @@ fn expand_format_args<'hir>(\n         // Generate:\n         //     &match (&arg0, &arg1, &\u2026) {\n         //         args => [\n-        //             <core::fmt::ArgumentV1>::new_display(args.0),\n-        //             <core::fmt::ArgumentV1>::new_lower_hex(args.1),\n-        //             <core::fmt::ArgumentV1>::new_debug(args.0),\n+        //             <core::fmt::Argument>::new_display(args.0),\n+        //             <core::fmt::Argument>::new_lower_hex(args.1),\n+        //             <core::fmt::Argument>::new_debug(args.0),\n         //             \u2026\n         //         ]\n         //     }"}, {"sha": "4fb668545712e58ae0a84807edb15b45015d578a", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf911ac7578b7079f8bf2944c841c39510967b7b/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf911ac7578b7079f8bf2944c841c39510967b7b/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=cf911ac7578b7079f8bf2944c841c39510967b7b", "patch": "@@ -296,7 +296,7 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n                 diag_trait(&mut err, self_ty, tcx.require_lang_item(LangItem::Deref, Some(span)));\n                 err\n             }\n-            _ if tcx.opt_parent(callee) == tcx.get_diagnostic_item(sym::ArgumentV1Methods) => ccx\n+            _ if tcx.opt_parent(callee) == tcx.get_diagnostic_item(sym::ArgumentMethods) => ccx\n                 .tcx\n                 .sess\n                 .create_err(errors::NonConstFmtMacroCall { span, kind: ccx.const_kind() }),"}, {"sha": "c261995621988400b29cc02bacfd448df0e38358", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf911ac7578b7079f8bf2944c841c39510967b7b/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf911ac7578b7079f8bf2944c841c39510967b7b/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=cf911ac7578b7079f8bf2944c841c39510967b7b", "patch": "@@ -129,8 +129,7 @@ symbols! {\n         Any,\n         Arc,\n         Argument,\n-        ArgumentV1,\n-        ArgumentV1Methods,\n+        ArgumentMethods,\n         Arguments,\n         AsMut,\n         AsRef,"}, {"sha": "f4f3223257047a888e1d8b7d436d8d11582b08ec", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 52, "deletions": 194, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/cf911ac7578b7079f8bf2944c841c39510967b7b/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf911ac7578b7079f8bf2944c841c39510967b7b/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=cf911ac7578b7079f8bf2944c841c39510967b7b", "patch": "@@ -251,145 +251,48 @@ impl<'a> Formatter<'a> {\n     }\n }\n \n-// NB. Argument is essentially an optimized partially applied formatting function,\n-// equivalent to `exists T.(&T, fn(&T, &mut Formatter<'_>) -> Result`.\n-\n-extern \"C\" {\n-    type Opaque;\n-}\n-\n-/// This struct represents the generic \"argument\" which is taken by the Xprintf\n-/// family of functions. It contains a function to format the given value. At\n-/// compile time it is ensured that the function and the value have the correct\n-/// types, and then this struct is used to canonicalize arguments to one type.\n-#[lang = \"format_argument\"]\n+/// This structure represents a safely precompiled version of a format string\n+/// and its arguments. This cannot be generated at runtime because it cannot\n+/// safely be done, so no constructors are given and the fields are private\n+/// to prevent modification.\n+///\n+/// The [`format_args!`] macro will safely create an instance of this structure.\n+/// The macro validates the format string at compile-time so usage of the\n+/// [`write()`] and [`format()`] functions can be safely performed.\n+///\n+/// You can use the `Arguments<'a>` that [`format_args!`] returns in `Debug`\n+/// and `Display` contexts as seen below. The example also shows that `Debug`\n+/// and `Display` format to the same thing: the interpolated format string\n+/// in `format_args!`.\n+///\n+/// ```rust\n+/// let debug = format!(\"{:?}\", format_args!(\"{} foo {:?}\", 1, 2));\n+/// let display = format!(\"{}\", format_args!(\"{} foo {:?}\", 1, 2));\n+/// assert_eq!(\"1 foo 2\", display);\n+/// assert_eq!(display, debug);\n+/// ```\n+///\n+/// [`format()`]: ../../std/fmt/fn.format.html\n+#[lang = \"format_arguments\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Copy, Clone)]\n-#[allow(missing_debug_implementations)]\n-#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n-#[doc(hidden)]\n-pub struct ArgumentV1<'a> {\n-    value: &'a Opaque,\n-    formatter: fn(&Opaque, &mut Formatter<'_>) -> Result,\n-}\n-\n-/// This struct represents the unsafety of constructing an `Arguments`.\n-/// It exists, rather than an unsafe function, in order to simplify the expansion\n-/// of `format_args!(..)` and reduce the scope of the `unsafe` block.\n-#[lang = \"format_unsafe_arg\"]\n-#[allow(missing_debug_implementations)]\n-#[doc(hidden)]\n-#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n-pub struct UnsafeArg {\n-    _private: (),\n-}\n-\n-impl UnsafeArg {\n-    /// See documentation where `UnsafeArg` is required to know when it is safe to\n-    /// create and use `UnsafeArg`.\n-    #[doc(hidden)]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n-    #[inline(always)]\n-    pub unsafe fn new() -> Self {\n-        Self { _private: () }\n-    }\n-}\n-\n-// This guarantees a single stable value for the function pointer associated with\n-// indices/counts in the formatting infrastructure.\n-//\n-// Note that a function defined as such would not be correct as functions are\n-// always tagged unnamed_addr with the current lowering to LLVM IR, so their\n-// address is not considered important to LLVM and as such the as_usize cast\n-// could have been miscompiled. In practice, we never call as_usize on non-usize\n-// containing data (as a matter of static generation of the formatting\n-// arguments), so this is merely an additional check.\n-//\n-// We primarily want to ensure that the function pointer at `USIZE_MARKER` has\n-// an address corresponding *only* to functions that also take `&usize` as their\n-// first argument. The read_volatile here ensures that we can safely ready out a\n-// usize from the passed reference and that this address does not point at a\n-// non-usize taking function.\n-#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n-static USIZE_MARKER: fn(&usize, &mut Formatter<'_>) -> Result = |ptr, _| {\n-    // SAFETY: ptr is a reference\n-    let _v: usize = unsafe { crate::ptr::read_volatile(ptr) };\n-    loop {}\n-};\n-\n-macro_rules! arg_new {\n-    ($f: ident, $t: ident) => {\n-        #[doc(hidden)]\n-        #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n-        #[inline]\n-        pub fn $f<'b, T: $t>(x: &'b T) -> ArgumentV1<'_> {\n-            Self::new(x, $t::fmt)\n-        }\n-    };\n-}\n-\n-#[rustc_diagnostic_item = \"ArgumentV1Methods\"]\n-impl<'a> ArgumentV1<'a> {\n-    #[doc(hidden)]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n-    #[inline]\n-    pub fn new<'b, T>(x: &'b T, f: fn(&T, &mut Formatter<'_>) -> Result) -> ArgumentV1<'b> {\n-        // SAFETY: `mem::transmute(x)` is safe because\n-        //     1. `&'b T` keeps the lifetime it originated with `'b`\n-        //              (so as to not have an unbounded lifetime)\n-        //     2. `&'b T` and `&'b Opaque` have the same memory layout\n-        //              (when `T` is `Sized`, as it is here)\n-        // `mem::transmute(f)` is safe since `fn(&T, &mut Formatter<'_>) -> Result`\n-        // and `fn(&Opaque, &mut Formatter<'_>) -> Result` have the same ABI\n-        // (as long as `T` is `Sized`)\n-        unsafe { ArgumentV1 { formatter: mem::transmute(f), value: mem::transmute(x) } }\n-    }\n-\n-    arg_new!(new_display, Display);\n-    arg_new!(new_debug, Debug);\n-    arg_new!(new_octal, Octal);\n-    arg_new!(new_lower_hex, LowerHex);\n-    arg_new!(new_upper_hex, UpperHex);\n-    arg_new!(new_pointer, Pointer);\n-    arg_new!(new_binary, Binary);\n-    arg_new!(new_lower_exp, LowerExp);\n-    arg_new!(new_upper_exp, UpperExp);\n+pub struct Arguments<'a> {\n+    // Format string pieces to print.\n+    pieces: &'a [&'static str],\n \n-    #[doc(hidden)]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n-    pub fn from_usize(x: &usize) -> ArgumentV1<'_> {\n-        ArgumentV1::new(x, USIZE_MARKER)\n-    }\n-\n-    fn as_usize(&self) -> Option<usize> {\n-        // We are type punning a bit here: USIZE_MARKER only takes an &usize but\n-        // formatter takes an &Opaque. Rust understandably doesn't think we should compare\n-        // the function pointers if they don't have the same signature, so we cast to\n-        // usizes to tell it that we just want to compare addresses.\n-        if self.formatter as usize == USIZE_MARKER as usize {\n-            // SAFETY: The `formatter` field is only set to USIZE_MARKER if\n-            // the value is a usize, so this is safe\n-            Some(unsafe { *(self.value as *const _ as *const usize) })\n-        } else {\n-            None\n-        }\n-    }\n-}\n+    // Placeholder specs, or `None` if all specs are default (as in \"{}{}\").\n+    fmt: Option<&'a [rt::Placeholder]>,\n \n-// flags available in the v1 format of format_args\n-#[derive(Copy, Clone)]\n-enum FlagV1 {\n-    SignPlus,\n-    SignMinus,\n-    Alternate,\n-    SignAwareZeroPad,\n-    DebugLowerHex,\n-    DebugUpperHex,\n+    // Dynamic arguments for interpolation, to be interleaved with string\n+    // pieces. (Every argument is preceded by a string piece.)\n+    args: &'a [rt::Argument<'a>],\n }\n \n+/// Used by the format_args!() macro to create a fmt::Arguments object.\n+#[doc(hidden)]\n+#[unstable(feature = \"fmt_internals\", issue = \"none\")]\n impl<'a> Arguments<'a> {\n-    #[doc(hidden)]\n     #[inline]\n-    #[unstable(feature = \"fmt_internals\", issue = \"none\")]\n     #[rustc_const_unstable(feature = \"const_fmt_arguments_new\", issue = \"none\")]\n     pub const fn new_const(pieces: &'a [&'static str]) -> Self {\n         if pieces.len() > 1 {\n@@ -401,22 +304,18 @@ impl<'a> Arguments<'a> {\n     /// When using the format_args!() macro, this function is used to generate the\n     /// Arguments structure.\n     #[cfg(not(bootstrap))]\n-    #[doc(hidden)]\n     #[inline]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n-    pub fn new_v1(pieces: &'a [&'static str], args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\n+    pub fn new_v1(pieces: &'a [&'static str], args: &'a [rt::Argument<'a>]) -> Arguments<'a> {\n         if pieces.len() < args.len() || pieces.len() > args.len() + 1 {\n             panic!(\"invalid args\");\n         }\n         Arguments { pieces, fmt: None, args }\n     }\n \n     #[cfg(bootstrap)]\n-    #[doc(hidden)]\n     #[inline]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n     #[rustc_const_unstable(feature = \"const_fmt_arguments_new\", issue = \"none\")]\n-    pub const fn new_v1(pieces: &'a [&'static str], args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\n+    pub const fn new_v1(pieces: &'a [&'static str], args: &'a [rt::Argument<'a>]) -> Arguments<'a> {\n         if pieces.len() < args.len() || pieces.len() > args.len() + 1 {\n             panic!(\"invalid args\");\n         }\n@@ -425,19 +324,17 @@ impl<'a> Arguments<'a> {\n \n     /// This function is used to specify nonstandard formatting parameters.\n     ///\n-    /// An `UnsafeArg` is required because the following invariants must be held\n+    /// An `rt::UnsafeArg` is required because the following invariants must be held\n     /// in order for this function to be safe:\n     /// 1. The `pieces` slice must be at least as long as `fmt`.\n     /// 2. Every `rt::Placeholder::position` value within `fmt` must be a valid index of `args`.\n     /// 3. Every `rt::Count::Param` within `fmt` must contain a valid index of `args`.\n-    #[doc(hidden)]\n     #[inline]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n     pub fn new_v1_formatted(\n         pieces: &'a [&'static str],\n-        args: &'a [ArgumentV1<'a>],\n+        args: &'a [rt::Argument<'a>],\n         fmt: &'a [rt::Placeholder],\n-        _unsafe_arg: UnsafeArg,\n+        _unsafe_arg: rt::UnsafeArg,\n     ) -> Arguments<'a> {\n         Arguments { pieces, fmt: Some(fmt), args }\n     }\n@@ -446,9 +343,7 @@ impl<'a> Arguments<'a> {\n     ///\n     /// This is intended to be used for setting initial `String` capacity\n     /// when using `format!`. Note: this is neither the lower nor upper bound.\n-    #[doc(hidden)]\n     #[inline]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n     pub fn estimated_capacity(&self) -> usize {\n         let pieces_length: usize = self.pieces.iter().map(|x| x.len()).sum();\n \n@@ -468,43 +363,6 @@ impl<'a> Arguments<'a> {\n     }\n }\n \n-/// This structure represents a safely precompiled version of a format string\n-/// and its arguments. This cannot be generated at runtime because it cannot\n-/// safely be done, so no constructors are given and the fields are private\n-/// to prevent modification.\n-///\n-/// The [`format_args!`] macro will safely create an instance of this structure.\n-/// The macro validates the format string at compile-time so usage of the\n-/// [`write()`] and [`format()`] functions can be safely performed.\n-///\n-/// You can use the `Arguments<'a>` that [`format_args!`] returns in `Debug`\n-/// and `Display` contexts as seen below. The example also shows that `Debug`\n-/// and `Display` format to the same thing: the interpolated format string\n-/// in `format_args!`.\n-///\n-/// ```rust\n-/// let debug = format!(\"{:?}\", format_args!(\"{} foo {:?}\", 1, 2));\n-/// let display = format!(\"{}\", format_args!(\"{} foo {:?}\", 1, 2));\n-/// assert_eq!(\"1 foo 2\", display);\n-/// assert_eq!(display, debug);\n-/// ```\n-///\n-/// [`format()`]: ../../std/fmt/fn.format.html\n-#[lang = \"format_arguments\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Copy, Clone)]\n-pub struct Arguments<'a> {\n-    // Format string pieces to print.\n-    pieces: &'a [&'static str],\n-\n-    // Placeholder specs, or `None` if all specs are default (as in \"{}{}\").\n-    fmt: Option<&'a [rt::Placeholder]>,\n-\n-    // Dynamic arguments for interpolation, to be interleaved with string\n-    // pieces. (Every argument is preceded by a string piece.)\n-    args: &'a [ArgumentV1<'a>],\n-}\n-\n impl<'a> Arguments<'a> {\n     /// Get the formatted string, if it has no arguments to be formatted at runtime.\n     ///\n@@ -1244,7 +1102,7 @@ pub fn write(output: &mut dyn Write, args: Arguments<'_>) -> Result {\n                 if !piece.is_empty() {\n                     formatter.buf.write_str(*piece)?;\n                 }\n-                (arg.formatter)(arg.value, &mut formatter)?;\n+                arg.fmt(&mut formatter)?;\n                 idx += 1;\n             }\n         }\n@@ -1274,7 +1132,7 @@ pub fn write(output: &mut dyn Write, args: Arguments<'_>) -> Result {\n     Ok(())\n }\n \n-unsafe fn run(fmt: &mut Formatter<'_>, arg: &rt::Placeholder, args: &[ArgumentV1<'_>]) -> Result {\n+unsafe fn run(fmt: &mut Formatter<'_>, arg: &rt::Placeholder, args: &[rt::Argument<'_>]) -> Result {\n     fmt.fill = arg.fill;\n     fmt.align = arg.align;\n     fmt.flags = arg.flags;\n@@ -1292,10 +1150,10 @@ unsafe fn run(fmt: &mut Formatter<'_>, arg: &rt::Placeholder, args: &[ArgumentV1\n     let value = unsafe { args.get_unchecked(arg.position) };\n \n     // Then actually do some printing\n-    (value.formatter)(value.value, fmt)\n+    value.fmt(fmt)\n }\n \n-unsafe fn getcount(args: &[ArgumentV1<'_>], cnt: &rt::Count) -> Option<usize> {\n+unsafe fn getcount(args: &[rt::Argument<'_>], cnt: &rt::Count) -> Option<usize> {\n     match *cnt {\n         rt::Count::Is(n) => Some(n),\n         rt::Count::Implied => None,\n@@ -1878,7 +1736,7 @@ impl<'a> Formatter<'a> {\n     #[must_use]\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n     pub fn sign_plus(&self) -> bool {\n-        self.flags & (1 << FlagV1::SignPlus as u32) != 0\n+        self.flags & (1 << rt::Flag::SignPlus as u32) != 0\n     }\n \n     /// Determines if the `-` flag was specified.\n@@ -1907,7 +1765,7 @@ impl<'a> Formatter<'a> {\n     #[must_use]\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n     pub fn sign_minus(&self) -> bool {\n-        self.flags & (1 << FlagV1::SignMinus as u32) != 0\n+        self.flags & (1 << rt::Flag::SignMinus as u32) != 0\n     }\n \n     /// Determines if the `#` flag was specified.\n@@ -1935,7 +1793,7 @@ impl<'a> Formatter<'a> {\n     #[must_use]\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n     pub fn alternate(&self) -> bool {\n-        self.flags & (1 << FlagV1::Alternate as u32) != 0\n+        self.flags & (1 << rt::Flag::Alternate as u32) != 0\n     }\n \n     /// Determines if the `0` flag was specified.\n@@ -1961,17 +1819,17 @@ impl<'a> Formatter<'a> {\n     #[must_use]\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n     pub fn sign_aware_zero_pad(&self) -> bool {\n-        self.flags & (1 << FlagV1::SignAwareZeroPad as u32) != 0\n+        self.flags & (1 << rt::Flag::SignAwareZeroPad as u32) != 0\n     }\n \n     // FIXME: Decide what public API we want for these two flags.\n     // https://github.com/rust-lang/rust/issues/48584\n     fn debug_lower_hex(&self) -> bool {\n-        self.flags & (1 << FlagV1::DebugLowerHex as u32) != 0\n+        self.flags & (1 << rt::Flag::DebugLowerHex as u32) != 0\n     }\n \n     fn debug_upper_hex(&self) -> bool {\n-        self.flags & (1 << FlagV1::DebugUpperHex as u32) != 0\n+        self.flags & (1 << rt::Flag::DebugUpperHex as u32) != 0\n     }\n \n     /// Creates a [`DebugStruct`] builder designed to assist with creation of\n@@ -2531,13 +2389,13 @@ pub(crate) fn pointer_fmt_inner(ptr_addr: usize, f: &mut Formatter<'_>) -> Resul\n     // or not to zero extend, and then unconditionally set it to get the\n     // prefix.\n     if f.alternate() {\n-        f.flags |= 1 << (FlagV1::SignAwareZeroPad as u32);\n+        f.flags |= 1 << (rt::Flag::SignAwareZeroPad as u32);\n \n         if f.width.is_none() {\n             f.width = Some((usize::BITS / 4) as usize + 2);\n         }\n     }\n-    f.flags |= 1 << (FlagV1::Alternate as u32);\n+    f.flags |= 1 << (rt::Flag::Alternate as u32);\n \n     let ret = LowerHex::fmt(&ptr_addr, f);\n "}, {"sha": "0596f6c30ce6dad5dcce353ccf59a0ff0937d08a", "filename": "library/core/src/fmt/rt.rs", "status": "modified", "additions": 148, "deletions": 6, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/cf911ac7578b7079f8bf2944c841c39510967b7b/library%2Fcore%2Fsrc%2Ffmt%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf911ac7578b7079f8bf2944c841c39510967b7b/library%2Fcore%2Fsrc%2Ffmt%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Frt.rs?ref=cf911ac7578b7079f8bf2944c841c39510967b7b", "patch": "@@ -3,6 +3,8 @@\n \n //! These are the lang items used by format_args!().\n \n+use super::*;\n+\n #[lang = \"format_placeholder\"]\n #[derive(Copy, Clone)]\n pub struct Placeholder {\n@@ -28,21 +30,17 @@ impl Placeholder {\n     }\n }\n \n-/// Possible alignments that can be requested as part of a formatting directive.\n #[lang = \"format_alignment\"]\n #[derive(Copy, Clone, PartialEq, Eq)]\n pub enum Alignment {\n-    /// Indication that contents should be left-aligned.\n     Left,\n-    /// Indication that contents should be right-aligned.\n     Right,\n-    /// Indication that contents should be center-aligned.\n     Center,\n-    /// No alignment was requested.\n     Unknown,\n }\n \n-/// Used by [width](https://doc.rust-lang.org/std/fmt/#width) and [precision](https://doc.rust-lang.org/std/fmt/#precision) specifiers.\n+/// Used by [width](https://doc.rust-lang.org/std/fmt/#width)\n+/// and [precision](https://doc.rust-lang.org/std/fmt/#precision) specifiers.\n #[lang = \"format_count\"]\n #[derive(Copy, Clone)]\n pub enum Count {\n@@ -53,3 +51,147 @@ pub enum Count {\n     /// Not specified\n     Implied,\n }\n+\n+// This needs to match the order of flags in compiler/rustc_ast_lowering/src/format.rs.\n+#[derive(Copy, Clone)]\n+pub(super) enum Flag {\n+    SignPlus,\n+    SignMinus,\n+    Alternate,\n+    SignAwareZeroPad,\n+    DebugLowerHex,\n+    DebugUpperHex,\n+}\n+\n+/// This struct represents the generic \"argument\" which is taken by format_args!().\n+/// It contains a function to format the given value. At compile time it is ensured that the\n+/// function and the value have the correct types, and then this struct is used to canonicalize\n+/// arguments to one type.\n+///\n+/// Argument is essentially an optimized partially applied formatting function,\n+/// equivalent to `exists T.(&T, fn(&T, &mut Formatter<'_>) -> Result`.\n+#[lang = \"format_argument\"]\n+#[derive(Copy, Clone)]\n+pub struct Argument<'a> {\n+    value: &'a Opaque,\n+    formatter: fn(&Opaque, &mut Formatter<'_>) -> Result,\n+}\n+\n+#[rustc_diagnostic_item = \"ArgumentMethods\"]\n+impl<'a> Argument<'a> {\n+    #[inline(always)]\n+    fn new<'b, T>(x: &'b T, f: fn(&T, &mut Formatter<'_>) -> Result) -> Argument<'b> {\n+        // SAFETY: `mem::transmute(x)` is safe because\n+        //     1. `&'b T` keeps the lifetime it originated with `'b`\n+        //              (so as to not have an unbounded lifetime)\n+        //     2. `&'b T` and `&'b Opaque` have the same memory layout\n+        //              (when `T` is `Sized`, as it is here)\n+        // `mem::transmute(f)` is safe since `fn(&T, &mut Formatter<'_>) -> Result`\n+        // and `fn(&Opaque, &mut Formatter<'_>) -> Result` have the same ABI\n+        // (as long as `T` is `Sized`)\n+        unsafe { Argument { formatter: mem::transmute(f), value: mem::transmute(x) } }\n+    }\n+\n+    #[inline(always)]\n+    pub fn new_display<'b, T: Display>(x: &'b T) -> Argument<'_> {\n+        Self::new(x, Display::fmt)\n+    }\n+    #[inline(always)]\n+    pub fn new_debug<'b, T: Debug>(x: &'b T) -> Argument<'_> {\n+        Self::new(x, Debug::fmt)\n+    }\n+    #[inline(always)]\n+    pub fn new_octal<'b, T: Octal>(x: &'b T) -> Argument<'_> {\n+        Self::new(x, Octal::fmt)\n+    }\n+    #[inline(always)]\n+    pub fn new_lower_hex<'b, T: LowerHex>(x: &'b T) -> Argument<'_> {\n+        Self::new(x, LowerHex::fmt)\n+    }\n+    #[inline(always)]\n+    pub fn new_upper_hex<'b, T: UpperHex>(x: &'b T) -> Argument<'_> {\n+        Self::new(x, UpperHex::fmt)\n+    }\n+    #[inline(always)]\n+    pub fn new_pointer<'b, T: Pointer>(x: &'b T) -> Argument<'_> {\n+        Self::new(x, Pointer::fmt)\n+    }\n+    #[inline(always)]\n+    pub fn new_binary<'b, T: Binary>(x: &'b T) -> Argument<'_> {\n+        Self::new(x, Binary::fmt)\n+    }\n+    #[inline(always)]\n+    pub fn new_lower_exp<'b, T: LowerExp>(x: &'b T) -> Argument<'_> {\n+        Self::new(x, LowerExp::fmt)\n+    }\n+    #[inline(always)]\n+    pub fn new_upper_exp<'b, T: UpperExp>(x: &'b T) -> Argument<'_> {\n+        Self::new(x, UpperExp::fmt)\n+    }\n+    #[inline(always)]\n+    pub fn from_usize(x: &usize) -> Argument<'_> {\n+        Self::new(x, USIZE_MARKER)\n+    }\n+\n+    #[inline(always)]\n+    pub(super) fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n+        (self.formatter)(self.value, f)\n+    }\n+\n+    #[inline(always)]\n+    pub(super) fn as_usize(&self) -> Option<usize> {\n+        // We are type punning a bit here: USIZE_MARKER only takes an &usize but\n+        // formatter takes an &Opaque. Rust understandably doesn't think we should compare\n+        // the function pointers if they don't have the same signature, so we cast to\n+        // usizes to tell it that we just want to compare addresses.\n+        if self.formatter as usize == USIZE_MARKER as usize {\n+            // SAFETY: The `formatter` field is only set to USIZE_MARKER if\n+            // the value is a usize, so this is safe\n+            Some(unsafe { *(self.value as *const _ as *const usize) })\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// This struct represents the unsafety of constructing an `Arguments`.\n+/// It exists, rather than an unsafe function, in order to simplify the expansion\n+/// of `format_args!(..)` and reduce the scope of the `unsafe` block.\n+#[lang = \"format_unsafe_arg\"]\n+pub struct UnsafeArg {\n+    _private: (),\n+}\n+\n+impl UnsafeArg {\n+    /// See documentation where `UnsafeArg` is required to know when it is safe to\n+    /// create and use `UnsafeArg`.\n+    #[inline(always)]\n+    pub unsafe fn new() -> Self {\n+        Self { _private: () }\n+    }\n+}\n+\n+extern \"C\" {\n+    type Opaque;\n+}\n+\n+// This guarantees a single stable value for the function pointer associated with\n+// indices/counts in the formatting infrastructure.\n+//\n+// Note that a function defined as such would not be correct as functions are\n+// always tagged unnamed_addr with the current lowering to LLVM IR, so their\n+// address is not considered important to LLVM and as such the as_usize cast\n+// could have been miscompiled. In practice, we never call as_usize on non-usize\n+// containing data (as a matter of static generation of the formatting\n+// arguments), so this is merely an additional check.\n+//\n+// We primarily want to ensure that the function pointer at `USIZE_MARKER` has\n+// an address corresponding *only* to functions that also take `&usize` as their\n+// first argument. The read_volatile here ensures that we can safely ready out a\n+// usize from the passed reference and that this address does not point at a\n+// non-usize taking function.\n+static USIZE_MARKER: fn(&usize, &mut Formatter<'_>) -> Result = |ptr, _| {\n+    // SAFETY: ptr is a reference\n+    let _v: usize = unsafe { crate::ptr::read_volatile(ptr) };\n+    loop {}\n+};"}, {"sha": "f04dfab36cad8e46755a8e624a787971c738076d", "filename": "src/tools/miri/tests/fail/panic/double_panic.stderr", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/cf911ac7578b7079f8bf2944c841c39510967b7b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fpanic%2Fdouble_panic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf911ac7578b7079f8bf2944c841c39510967b7b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fpanic%2Fdouble_panic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fpanic%2Fdouble_panic.stderr?ref=cf911ac7578b7079f8bf2944c841c39510967b7b", "patch": "@@ -12,57 +12,59 @@ stack backtrace:\n  at RUSTLIB/std/src/sys_common/backtrace.rs:LL:CC\n    4: <std::sys_common::backtrace::_print::DisplayBacktrace as std::fmt::Display>::fmt\n  at RUSTLIB/std/src/sys_common/backtrace.rs:LL:CC\n-   5: std::fmt::write\n+   5: core::fmt::rt::Argument::fmt\n+ at RUSTLIB/core/src/fmt/rt.rs:LL:CC\n+   6: std::fmt::write\n  at RUSTLIB/core/src/fmt/mod.rs:LL:CC\n-   6: <std::sys::PLATFORM::stdio::Stderr as std::io::Write>::write_fmt\n+   7: <std::sys::PLATFORM::stdio::Stderr as std::io::Write>::write_fmt\n  at RUSTLIB/std/src/io/mod.rs:LL:CC\n-   7: std::sys_common::backtrace::_print\n+   8: std::sys_common::backtrace::_print\n  at RUSTLIB/std/src/sys_common/backtrace.rs:LL:CC\n-   8: std::sys_common::backtrace::print\n+   9: std::sys_common::backtrace::print\n  at RUSTLIB/std/src/sys_common/backtrace.rs:LL:CC\n-   9: std::panicking::default_hook::{closure#1}\n+  10: std::panicking::default_hook::{closure#1}\n  at RUSTLIB/std/src/panicking.rs:LL:CC\n-  10: std::panicking::default_hook\n+  11: std::panicking::default_hook\n  at RUSTLIB/std/src/panicking.rs:LL:CC\n-  11: std::panicking::rust_panic_with_hook\n+  12: std::panicking::rust_panic_with_hook\n  at RUSTLIB/std/src/panicking.rs:LL:CC\n-  12: std::rt::begin_panic::{closure#0}\n+  13: std::rt::begin_panic::{closure#0}\n  at RUSTLIB/std/src/panicking.rs:LL:CC\n-  13: std::sys_common::backtrace::__rust_end_short_backtrace\n+  14: std::sys_common::backtrace::__rust_end_short_backtrace\n  at RUSTLIB/std/src/sys_common/backtrace.rs:LL:CC\n-  14: std::rt::begin_panic\n+  15: std::rt::begin_panic\n  at RUSTLIB/std/src/panicking.rs:LL:CC\n-  15: <Foo as std::ops::Drop>::drop\n+  16: <Foo as std::ops::Drop>::drop\n  at $DIR/double_panic.rs:LL:CC\n-  16: std::ptr::drop_in_place - shim(Some(Foo))\n+  17: std::ptr::drop_in_place - shim(Some(Foo))\n  at RUSTLIB/core/src/ptr/mod.rs:LL:CC\n-  17: main\n+  18: main\n  at $DIR/double_panic.rs:LL:CC\n-  18: <fn() as std::ops::FnOnce<()>>::call_once - shim(fn())\n+  19: <fn() as std::ops::FnOnce<()>>::call_once - shim(fn())\n  at RUSTLIB/core/src/ops/function.rs:LL:CC\n-  19: std::sys_common::backtrace::__rust_begin_short_backtrace\n+  20: std::sys_common::backtrace::__rust_begin_short_backtrace\n  at RUSTLIB/std/src/sys_common/backtrace.rs:LL:CC\n-  20: std::rt::lang_start::{closure#0}\n+  21: std::rt::lang_start::{closure#0}\n  at RUSTLIB/std/src/rt.rs:LL:CC\n-  21: std::ops::function::impls::call_once\n+  22: std::ops::function::impls::call_once\n  at RUSTLIB/core/src/ops/function.rs:LL:CC\n-  22: std::panicking::r#try::do_call\n+  23: std::panicking::r#try::do_call\n  at RUSTLIB/std/src/panicking.rs:LL:CC\n-  23: std::panicking::r#try\n+  24: std::panicking::r#try\n  at RUSTLIB/std/src/panicking.rs:LL:CC\n-  24: std::panic::catch_unwind\n+  25: std::panic::catch_unwind\n  at RUSTLIB/std/src/panic.rs:LL:CC\n-  25: std::rt::lang_start_internal::{closure#2}\n+  26: std::rt::lang_start_internal::{closure#2}\n  at RUSTLIB/std/src/rt.rs:LL:CC\n-  26: std::panicking::r#try::do_call\n+  27: std::panicking::r#try::do_call\n  at RUSTLIB/std/src/panicking.rs:LL:CC\n-  27: std::panicking::r#try\n+  28: std::panicking::r#try\n  at RUSTLIB/std/src/panicking.rs:LL:CC\n-  28: std::panic::catch_unwind\n+  29: std::panic::catch_unwind\n  at RUSTLIB/std/src/panic.rs:LL:CC\n-  29: std::rt::lang_start_internal\n+  30: std::rt::lang_start_internal\n  at RUSTLIB/std/src/rt.rs:LL:CC\n-  30: std::rt::lang_start\n+  31: std::rt::lang_start\n  at RUSTLIB/std/src/rt.rs:LL:CC\n thread panicked while panicking. aborting.\n error: abnormal termination: the program aborted execution"}, {"sha": "5fbd1789b3a9a9a13520f0072d1cc3fff583a530", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/builtin_fn_macro.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf911ac7578b7079f8bf2944c841c39510967b7b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf911ac7578b7079f8bf2944c841c39510967b7b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs?ref=cf911ac7578b7079f8bf2944c841c39510967b7b", "patch": "@@ -201,7 +201,7 @@ macro_rules! format_args {\n }\n \n fn main() {\n-    $crate::fmt::Arguments::new_v1(&[], &[$crate::fmt::ArgumentV1::new(&(arg1(a, b, c)), $crate::fmt::Display::fmt), $crate::fmt::ArgumentV1::new(&(arg2), $crate::fmt::Display::fmt), ]);\n+    $crate::fmt::Arguments::new_v1(&[], &[$crate::fmt::Argument::new(&(arg1(a, b, c)), $crate::fmt::Display::fmt), $crate::fmt::Argument::new(&(arg2), $crate::fmt::Display::fmt), ]);\n }\n \"#]],\n     );\n@@ -229,7 +229,7 @@ macro_rules! format_args {\n }\n \n fn main() {\n-    $crate::fmt::Arguments::new_v1(&[], &[$crate::fmt::ArgumentV1::new(&(a::<A, B>()), $crate::fmt::Display::fmt), $crate::fmt::ArgumentV1::new(&(b), $crate::fmt::Display::fmt), ]);\n+    $crate::fmt::Arguments::new_v1(&[], &[$crate::fmt::Argument::new(&(a::<A, B>()), $crate::fmt::Display::fmt), $crate::fmt::Argument::new(&(b), $crate::fmt::Display::fmt), ]);\n }\n \"#]],\n     );\n@@ -260,7 +260,7 @@ macro_rules! format_args {\n fn main() {\n     let _ =\n         /* parse error: expected field name or number */\n-$crate::fmt::Arguments::new_v1(&[], &[$crate::fmt::ArgumentV1::new(&(a.), $crate::fmt::Display::fmt), ]);\n+$crate::fmt::Arguments::new_v1(&[], &[$crate::fmt::Argument::new(&(a.), $crate::fmt::Display::fmt), ]);\n }\n \"#]],\n     );"}, {"sha": "a9c5e1488aac0b77deba020d3bb9e6e73191c510", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/builtin_fn_macro.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf911ac7578b7079f8bf2944c841c39510967b7b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf911ac7578b7079f8bf2944c841c39510967b7b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs?ref=cf911ac7578b7079f8bf2944c841c39510967b7b", "patch": "@@ -241,8 +241,8 @@ fn format_args_expand(\n     // We expand `format_args!(\"\", a1, a2)` to\n     // ```\n     // $crate::fmt::Arguments::new_v1(&[], &[\n-    //   $crate::fmt::ArgumentV1::new(&arg1,$crate::fmt::Display::fmt),\n-    //   $crate::fmt::ArgumentV1::new(&arg2,$crate::fmt::Display::fmt),\n+    //   $crate::fmt::Argument::new(&arg1,$crate::fmt::Display::fmt),\n+    //   $crate::fmt::Argument::new(&arg2,$crate::fmt::Display::fmt),\n     // ])\n     // ```,\n     // which is still not really correct, but close enough for now\n@@ -267,7 +267,7 @@ fn format_args_expand(\n     }\n     let _format_string = args.remove(0);\n     let arg_tts = args.into_iter().flat_map(|arg| {\n-        quote! { #DOLLAR_CRATE::fmt::ArgumentV1::new(&(#arg), #DOLLAR_CRATE::fmt::Display::fmt), }\n+        quote! { #DOLLAR_CRATE::fmt::Argument::new(&(#arg), #DOLLAR_CRATE::fmt::Display::fmt), }\n     }.token_trees);\n     let expanded = quote! {\n         #DOLLAR_CRATE::fmt::Arguments::new_v1(&[], &[##arg_tts])"}, {"sha": "9bda5f575c99f0069d0b35972794c758af95c035", "filename": "tests/mir-opt/sroa/lifetimes.foo.ScalarReplacementOfAggregates.diff", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cf911ac7578b7079f8bf2944c841c39510967b7b/tests%2Fmir-opt%2Fsroa%2Flifetimes.foo.ScalarReplacementOfAggregates.diff", "raw_url": "https://github.com/rust-lang/rust/raw/cf911ac7578b7079f8bf2944c841c39510967b7b/tests%2Fmir-opt%2Fsroa%2Flifetimes.foo.ScalarReplacementOfAggregates.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fsroa%2Flifetimes.foo.ScalarReplacementOfAggregates.diff?ref=cf911ac7578b7079f8bf2944c841c39510967b7b", "patch": "@@ -15,14 +15,14 @@\n       let mut _13: &[&str; 3];             // in scope 0 at $DIR/lifetimes.rs:+10:19: +10:28\n       let _14: &[&str; 3];                 // in scope 0 at $DIR/lifetimes.rs:+10:19: +10:28\n       let _15: [&str; 3];                  // in scope 0 at $DIR/lifetimes.rs:+10:19: +10:28\n-      let mut _16: &[core::fmt::ArgumentV1<'_>]; // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let mut _17: &[core::fmt::ArgumentV1<'_>; 2]; // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let _18: &[core::fmt::ArgumentV1<'_>; 2]; // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let _19: [core::fmt::ArgumentV1<'_>; 2]; // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let mut _20: core::fmt::ArgumentV1<'_>; // in scope 0 at $DIR/lifetimes.rs:+10:20: +10:23\n+      let mut _16: &[core::fmt::rt::Argument<'_>]; // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n+      let mut _17: &[core::fmt::rt::Argument<'_>; 2]; // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n+      let _18: &[core::fmt::rt::Argument<'_>; 2]; // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n+      let _19: [core::fmt::rt::Argument<'_>; 2]; // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n+      let mut _20: core::fmt::rt::Argument<'_>; // in scope 0 at $DIR/lifetimes.rs:+10:20: +10:23\n       let mut _21: &std::boxed::Box<dyn std::fmt::Display>; // in scope 0 at $DIR/lifetimes.rs:+10:20: +10:23\n       let _22: &std::boxed::Box<dyn std::fmt::Display>; // in scope 0 at $DIR/lifetimes.rs:+10:20: +10:23\n-      let mut _23: core::fmt::ArgumentV1<'_>; // in scope 0 at $DIR/lifetimes.rs:+10:24: +10:27\n+      let mut _23: core::fmt::rt::Argument<'_>; // in scope 0 at $DIR/lifetimes.rs:+10:24: +10:27\n       let mut _24: &u32;                   // in scope 0 at $DIR/lifetimes.rs:+10:24: +10:27\n       let _25: &u32;                       // in scope 0 at $DIR/lifetimes.rs:+10:24: +10:27\n       let mut _27: bool;                   // in scope 0 at $DIR/lifetimes.rs:+12:1: +12:2\n@@ -113,11 +113,11 @@\n           StorageLive(_22);                // scope 4 at $DIR/lifetimes.rs:+10:20: +10:23\n           _22 = &_8;                       // scope 4 at $DIR/lifetimes.rs:+10:20: +10:23\n           _21 = &(*_22);                   // scope 4 at $DIR/lifetimes.rs:+10:20: +10:23\n-          _20 = core::fmt::ArgumentV1::<'_>::new_display::<Box<dyn std::fmt::Display>>(move _21) -> [return: bb3, unwind unreachable]; // scope 4 at $DIR/lifetimes.rs:+10:20: +10:23\n+          _20 = core::fmt::rt::Argument::<'_>::new_display::<Box<dyn std::fmt::Display>>(move _21) -> [return: bb3, unwind unreachable]; // scope 4 at $DIR/lifetimes.rs:+10:20: +10:23\n                                            // mir::Constant\n                                            // + span: $DIR/lifetimes.rs:27:20: 27:23\n                                            // + user_ty: UserType(4)\n-                                           // + literal: Const { ty: for<'b> fn(&'b Box<dyn std::fmt::Display>) -> core::fmt::ArgumentV1<'b> {core::fmt::ArgumentV1::<'_>::new_display::<Box<dyn std::fmt::Display>>}, val: Value(<ZST>) }\n+                                           // + literal: Const { ty: for<'b> fn(&'b Box<dyn std::fmt::Display>) -> core::fmt::rt::Argument<'b> {core::fmt::rt::Argument::<'_>::new_display::<Box<dyn std::fmt::Display>>}, val: Value(<ZST>) }\n       }\n   \n       bb3: {\n@@ -127,11 +127,11 @@\n           StorageLive(_25);                // scope 4 at $DIR/lifetimes.rs:+10:24: +10:27\n           _25 = &_6;                       // scope 4 at $DIR/lifetimes.rs:+10:24: +10:27\n           _24 = &(*_25);                   // scope 4 at $DIR/lifetimes.rs:+10:24: +10:27\n-          _23 = core::fmt::ArgumentV1::<'_>::new_display::<u32>(move _24) -> [return: bb4, unwind unreachable]; // scope 4 at $DIR/lifetimes.rs:+10:24: +10:27\n+          _23 = core::fmt::rt::Argument::<'_>::new_display::<u32>(move _24) -> [return: bb4, unwind unreachable]; // scope 4 at $DIR/lifetimes.rs:+10:24: +10:27\n                                            // mir::Constant\n                                            // + span: $DIR/lifetimes.rs:27:24: 27:27\n                                            // + user_ty: UserType(5)\n-                                           // + literal: Const { ty: for<'b> fn(&'b u32) -> core::fmt::ArgumentV1<'b> {core::fmt::ArgumentV1::<'_>::new_display::<u32>}, val: Value(<ZST>) }\n+                                           // + literal: Const { ty: for<'b> fn(&'b u32) -> core::fmt::rt::Argument<'b> {core::fmt::rt::Argument::<'_>::new_display::<u32>}, val: Value(<ZST>) }\n       }\n   \n       bb4: {\n@@ -141,13 +141,13 @@\n           StorageDead(_20);                // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n           _18 = &_19;                      // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n           _17 = &(*_18);                   // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          _16 = move _17 as &[core::fmt::ArgumentV1<'_>] (Pointer(Unsize)); // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          _16 = move _17 as &[core::fmt::rt::Argument<'_>] (Pointer(Unsize)); // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n           StorageDead(_17);                // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n           _11 = Arguments::<'_>::new_v1(move _12, move _16) -> [return: bb5, unwind unreachable]; // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/std/src/macros.rs:LL:COL\n                                            // + user_ty: UserType(3)\n-                                           // + literal: Const { ty: fn(&[&'static str], &[core::fmt::ArgumentV1<'_>]) -> Arguments<'_> {Arguments::<'_>::new_v1}, val: Value(<ZST>) }\n+                                           // + literal: Const { ty: fn(&[&'static str], &[core::fmt::rt::Argument<'_>]) -> Arguments<'_> {Arguments::<'_>::new_v1}, val: Value(<ZST>) }\n       }\n   \n       bb5: {"}, {"sha": "ed008c454a31ceb9df071bfd931e26edd85fcab6", "filename": "tests/ui/fmt/ifmt-bad-arg.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf911ac7578b7079f8bf2944c841c39510967b7b/tests%2Fui%2Ffmt%2Fifmt-bad-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf911ac7578b7079f8bf2944c841c39510967b7b/tests%2Fui%2Ffmt%2Fifmt-bad-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffmt%2Fifmt-bad-arg.stderr?ref=cf911ac7578b7079f8bf2944c841c39510967b7b", "patch": "@@ -307,7 +307,7 @@ LL |     println!(\"{} {:.*} {}\", 1, 3.2, 4);\n    = note: expected reference `&usize`\n               found reference `&{float}`\n note: associated function defined here\n-  --> $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+  --> $SRC_DIR/core/src/fmt/rt.rs:LL:COL\n    = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0308]: mismatched types\n@@ -321,7 +321,7 @@ LL |     println!(\"{} {:07$.*} {}\", 1, 3.2, 4);\n    = note: expected reference `&usize`\n               found reference `&{float}`\n note: associated function defined here\n-  --> $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+  --> $SRC_DIR/core/src/fmt/rt.rs:LL:COL\n    = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 38 previous errors"}, {"sha": "cc316e55f5cb673e3dc164a9148fa6c03a0d2c90", "filename": "tests/ui/fmt/ifmt-unimpl.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf911ac7578b7079f8bf2944c841c39510967b7b/tests%2Fui%2Ffmt%2Fifmt-unimpl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf911ac7578b7079f8bf2944c841c39510967b7b/tests%2Fui%2Ffmt%2Fifmt-unimpl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffmt%2Fifmt-unimpl.stderr?ref=cf911ac7578b7079f8bf2944c841c39510967b7b", "patch": "@@ -17,9 +17,9 @@ LL |     format!(\"{:X}\", \"3\");\n              NonZeroIsize\n            and 21 others\n    = note: required for `&str` to implement `UpperHex`\n-note: required by a bound in `core::fmt::ArgumentV1::<'a>::new_upper_hex`\n-  --> $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-   = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `arg_new` (in Nightly builds, run with -Z macro-backtrace for more info)\n+note: required by a bound in `core::fmt::rt::Argument::<'a>::new_upper_hex`\n+  --> $SRC_DIR/core/src/fmt/rt.rs:LL:COL\n+   = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "b517a342e634d16d341f9a5dbf7d23c161d1a37a", "filename": "tests/ui/fmt/send-sync.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cf911ac7578b7079f8bf2944c841c39510967b7b/tests%2Fui%2Ffmt%2Fsend-sync.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf911ac7578b7079f8bf2944c841c39510967b7b/tests%2Fui%2Ffmt%2Fsend-sync.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffmt%2Fsend-sync.stderr?ref=cf911ac7578b7079f8bf2944c841c39510967b7b", "patch": "@@ -1,36 +1,36 @@\n-error[E0277]: `core::fmt::Opaque` cannot be shared between threads safely\n+error[E0277]: `core::fmt::rt::Opaque` cannot be shared between threads safely\n   --> $DIR/send-sync.rs:8:10\n    |\n LL |     send(format_args!(\"{:?}\", c));\n-   |     ---- ^^^^^^^^^^^^^^^^^^^^^^^ `core::fmt::Opaque` cannot be shared between threads safely\n+   |     ---- ^^^^^^^^^^^^^^^^^^^^^^^ `core::fmt::rt::Opaque` cannot be shared between threads safely\n    |     |\n    |     required by a bound introduced by this call\n    |\n-   = help: within `[core::fmt::ArgumentV1<'_>]`, the trait `Sync` is not implemented for `core::fmt::Opaque`\n-   = note: required because it appears within the type `&core::fmt::Opaque`\n-   = note: required because it appears within the type `ArgumentV1<'_>`\n-   = note: required because it appears within the type `[ArgumentV1<'_>]`\n-   = note: required for `&[core::fmt::ArgumentV1<'_>]` to implement `Send`\n+   = help: within `[core::fmt::rt::Argument<'_>]`, the trait `Sync` is not implemented for `core::fmt::rt::Opaque`\n+   = note: required because it appears within the type `&core::fmt::rt::Opaque`\n+   = note: required because it appears within the type `Argument<'_>`\n+   = note: required because it appears within the type `[Argument<'_>]`\n+   = note: required for `&[core::fmt::rt::Argument<'_>]` to implement `Send`\n    = note: required because it appears within the type `Arguments<'_>`\n note: required by a bound in `send`\n   --> $DIR/send-sync.rs:1:12\n    |\n LL | fn send<T: Send>(_: T) {}\n    |            ^^^^ required by this bound in `send`\n \n-error[E0277]: `core::fmt::Opaque` cannot be shared between threads safely\n+error[E0277]: `core::fmt::rt::Opaque` cannot be shared between threads safely\n   --> $DIR/send-sync.rs:9:10\n    |\n LL |     sync(format_args!(\"{:?}\", c));\n-   |     ---- ^^^^^^^^^^^^^^^^^^^^^^^ `core::fmt::Opaque` cannot be shared between threads safely\n+   |     ---- ^^^^^^^^^^^^^^^^^^^^^^^ `core::fmt::rt::Opaque` cannot be shared between threads safely\n    |     |\n    |     required by a bound introduced by this call\n    |\n-   = help: within `Arguments<'_>`, the trait `Sync` is not implemented for `core::fmt::Opaque`\n-   = note: required because it appears within the type `&core::fmt::Opaque`\n-   = note: required because it appears within the type `ArgumentV1<'_>`\n-   = note: required because it appears within the type `[ArgumentV1<'_>]`\n-   = note: required because it appears within the type `&[ArgumentV1<'_>]`\n+   = help: within `Arguments<'_>`, the trait `Sync` is not implemented for `core::fmt::rt::Opaque`\n+   = note: required because it appears within the type `&core::fmt::rt::Opaque`\n+   = note: required because it appears within the type `Argument<'_>`\n+   = note: required because it appears within the type `[Argument<'_>]`\n+   = note: required because it appears within the type `&[Argument<'_>]`\n    = note: required because it appears within the type `Arguments<'_>`\n note: required by a bound in `sync`\n   --> $DIR/send-sync.rs:2:12"}]}