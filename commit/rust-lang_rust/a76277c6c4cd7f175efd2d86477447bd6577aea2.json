{"sha": "a76277c6c4cd7f175efd2d86477447bd6577aea2", "node_id": "C_kwDOAAsO6NoAKGE3NjI3N2M2YzRjZDdmMTc1ZWZkMmQ4NjQ3NzQ0N2JkNjU3N2FlYTI", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-05-24T07:15:19Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-05-25T05:40:38Z"}, "message": "add a deep fast_reject routine", "tree": {"sha": "879a61ceb4b4e5b7290374135441c9942413c943", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/879a61ceb4b4e5b7290374135441c9942413c943"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a76277c6c4cd7f175efd2d86477447bd6577aea2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a76277c6c4cd7f175efd2d86477447bd6577aea2", "html_url": "https://github.com/rust-lang/rust/commit/a76277c6c4cd7f175efd2d86477447bd6577aea2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a76277c6c4cd7f175efd2d86477447bd6577aea2/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8d0cd8de090d5c0acb1735d4e8846de277b2604", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8d0cd8de090d5c0acb1735d4e8846de277b2604", "html_url": "https://github.com/rust-lang/rust/commit/b8d0cd8de090d5c0acb1735d4e8846de277b2604"}], "stats": {"total": 295, "additions": 240, "deletions": 55}, "files": [{"sha": "f7ced066062ad2c3387cbcac2d8fecd9c8b0f4aa", "filename": "compiler/rustc_middle/src/ty/fast_reject.rs", "status": "modified", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/a76277c6c4cd7f175efd2d86477447bd6577aea2/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a76277c6c4cd7f175efd2d86477447bd6577aea2/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs?ref=a76277c6c4cd7f175efd2d86477447bd6577aea2", "patch": "@@ -1,8 +1,10 @@\n use crate::mir::Mutability;\n+use crate::ty::subst::GenericArgKind;\n use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_hir::def_id::DefId;\n use std::fmt::Debug;\n use std::hash::Hash;\n+use std::iter;\n \n use self::SimplifiedTypeGen::*;\n \n@@ -72,6 +74,10 @@ pub enum TreatParams {\n \n /// Tries to simplify a type by only returning the outermost injective\u00b9 layer, if one exists.\n ///\n+/// **This function should only be used if you need to store or retrieve the type from some\n+/// hashmap. If you want to quickly decide whether two types may unify, use the [DeepRejectCtxt]\n+/// instead.**\n+///\n /// The idea is to get something simple that we can use to quickly decide if two types could unify,\n /// for example during method lookup. If this function returns `Some(x)` it can only unify with\n /// types for which this method returns either `Some(x)` as well or `None`.\n@@ -182,3 +188,218 @@ impl<D: Copy + Debug + Eq> SimplifiedTypeGen<D> {\n         }\n     }\n }\n+\n+/// Given generic arguments from an obligation and an impl,\n+/// could these two be unified after replacing parameters in the\n+/// the impl with inference variables.\n+///\n+/// For obligations, parameters won't be replaced by inference\n+/// variables and only unify with themselves. We treat them\n+/// the same way we treat placeholders.\n+///\n+/// We also use this function during coherence. For coherence the\n+/// impls only have to overlap for some value, so we treat parameters\n+/// on both sides like inference variables. This behavior is toggled\n+/// using the `treat_obligation_params` field.\n+#[derive(Debug, Clone, Copy)]\n+pub struct DeepRejectCtxt {\n+    pub treat_obligation_params: TreatParams,\n+}\n+\n+impl DeepRejectCtxt {\n+    pub fn generic_args_may_unify(\n+        self,\n+        obligation_arg: ty::GenericArg<'_>,\n+        impl_arg: ty::GenericArg<'_>,\n+    ) -> bool {\n+        match (obligation_arg.unpack(), impl_arg.unpack()) {\n+            // We don't fast reject based on regions for now.\n+            (GenericArgKind::Lifetime(_), GenericArgKind::Lifetime(_)) => true,\n+            (GenericArgKind::Type(obl), GenericArgKind::Type(imp)) => {\n+                self.types_may_unify(obl, imp)\n+            }\n+            (GenericArgKind::Const(obl), GenericArgKind::Const(imp)) => {\n+                self.consts_may_unify(obl, imp)\n+            }\n+            _ => bug!(\"kind mismatch: {obligation_arg} {impl_arg}\"),\n+        }\n+    }\n+\n+    pub fn types_may_unify(self, obligation_ty: Ty<'_>, impl_ty: Ty<'_>) -> bool {\n+        match impl_ty.kind() {\n+            // Start by checking whether the type in the impl may unify with\n+            // pretty much everything. Just return `true` in that case.\n+            ty::Param(_) | ty::Projection(_) | ty::Error(_) => return true,\n+            // These types only unify with inference variables or their own\n+            // variant.\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(_)\n+            | ty::Uint(_)\n+            | ty::Float(_)\n+            | ty::Adt(..)\n+            | ty::Str\n+            | ty::Array(..)\n+            | ty::Slice(..)\n+            | ty::RawPtr(..)\n+            | ty::Dynamic(..)\n+            | ty::Ref(..)\n+            | ty::Never\n+            | ty::Tuple(..)\n+            | ty::FnPtr(..)\n+            | ty::Foreign(..)\n+            | ty::Opaque(..) => {}\n+            ty::FnDef(..)\n+            | ty::Closure(..)\n+            | ty::Generator(..)\n+            | ty::GeneratorWitness(..)\n+            | ty::Placeholder(..)\n+            | ty::Bound(..)\n+            | ty::Infer(_) => bug!(\"unexpected impl_ty: {impl_ty}\"),\n+        }\n+\n+        let k = impl_ty.kind();\n+        match *obligation_ty.kind() {\n+            // Purely rigid types, use structural equivalence.\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(_)\n+            | ty::Uint(_)\n+            | ty::Float(_)\n+            | ty::Str\n+            | ty::Never\n+            | ty::Foreign(_) => obligation_ty == impl_ty,\n+            ty::Ref(_, obl_ty, obl_mutbl) => match k {\n+                &ty::Ref(_, impl_ty, impl_mutbl) => {\n+                    obl_mutbl == impl_mutbl && self.types_may_unify(obl_ty, impl_ty)\n+                }\n+                _ => false,\n+            },\n+            ty::Adt(obl_def, obl_substs) => match k {\n+                &ty::Adt(impl_def, impl_substs) => {\n+                    obl_def == impl_def\n+                        && iter::zip(obl_substs, impl_substs)\n+                            .all(|(obl, imp)| self.generic_args_may_unify(obl, imp))\n+                }\n+                _ => false,\n+            },\n+            ty::Slice(obl_ty) => {\n+                matches!(k, &ty::Slice(impl_ty) if self.types_may_unify(obl_ty, impl_ty))\n+            }\n+            ty::Array(obl_ty, obl_len) => match k {\n+                &ty::Array(impl_ty, impl_len) => {\n+                    self.types_may_unify(obl_ty, impl_ty)\n+                        && self.consts_may_unify(obl_len, impl_len)\n+                }\n+                _ => false,\n+            },\n+            ty::Tuple(obl) => match k {\n+                &ty::Tuple(imp) => {\n+                    obl.len() == imp.len()\n+                        && iter::zip(obl, imp).all(|(obl, imp)| self.types_may_unify(obl, imp))\n+                }\n+                _ => false,\n+            },\n+            ty::RawPtr(obl) => match k {\n+                ty::RawPtr(imp) => obl.mutbl == imp.mutbl && self.types_may_unify(obl.ty, imp.ty),\n+                _ => false,\n+            },\n+            ty::Dynamic(obl_preds, ..) => {\n+                // Ideally we would walk the existential predicates here or at least\n+                // compare their length. But considering that the relevant `Relate` impl\n+                // actually sorts and deduplicates these, that doesn't work.\n+                matches!(k, ty::Dynamic(impl_preds, ..) if\n+                    obl_preds.principal_def_id() == impl_preds.principal_def_id()\n+                )\n+            }\n+            ty::FnPtr(obl_sig) => match k {\n+                ty::FnPtr(impl_sig) => {\n+                    let ty::FnSig { inputs_and_output, c_variadic, unsafety, abi } =\n+                        obl_sig.skip_binder();\n+                    let impl_sig = impl_sig.skip_binder();\n+\n+                    abi == impl_sig.abi\n+                        && c_variadic == impl_sig.c_variadic\n+                        && unsafety == impl_sig.unsafety\n+                        && inputs_and_output.len() == impl_sig.inputs_and_output.len()\n+                        && iter::zip(inputs_and_output, impl_sig.inputs_and_output)\n+                            .all(|(obl, imp)| self.types_may_unify(obl, imp))\n+                }\n+                _ => false,\n+            },\n+\n+            // Opaque types in impls should be forbidden, but that doesn't\n+            // stop compilation. So this match arm should never return true\n+            // if compilation succeeds.\n+            ty::Opaque(..) => matches!(k, ty::Opaque(..)),\n+\n+            // Impls cannot contain these types as these cannot be named directly.\n+            ty::FnDef(..) | ty::Closure(..) | ty::Generator(..) => false,\n+\n+            ty::Placeholder(..) => false,\n+\n+            // Depending on the value of `treat_obligation_params`, we either\n+            // treat generic parameters like placeholders or like inference variables.\n+            ty::Param(_) => match self.treat_obligation_params {\n+                TreatParams::AsPlaceholder => false,\n+                TreatParams::AsInfer => true,\n+            },\n+\n+            ty::Infer(_) => true,\n+\n+            // As we're walking the whole type, it may encounter projections\n+            // inside of binders and what not, so we're just going to assume that\n+            // projections can unify with other stuff.\n+            //\n+            // Looking forward to lazy normalization this is the safer strategy anyways.\n+            ty::Projection(_) => true,\n+\n+            ty::Error(_) => true,\n+\n+            ty::GeneratorWitness(..) | ty::Bound(..) => {\n+                bug!(\"unexpected obligation type: {:?}\", obligation_ty)\n+            }\n+        }\n+    }\n+\n+    pub fn consts_may_unify(self, obligation_ct: ty::Const<'_>, impl_ct: ty::Const<'_>) -> bool {\n+        match impl_ct.val() {\n+            ty::ConstKind::Param(_) | ty::ConstKind::Unevaluated(_) | ty::ConstKind::Error(_) => {\n+                return true;\n+            }\n+            ty::ConstKind::Value(_) => {}\n+            ty::ConstKind::Infer(_) | ty::ConstKind::Bound(..) | ty::ConstKind::Placeholder(_) => {\n+                bug!(\"unexpected impl arg: {:?}\", impl_ct)\n+            }\n+        }\n+\n+        let k = impl_ct.val();\n+        match obligation_ct.val() {\n+            ty::ConstKind::Param(_) => match self.treat_obligation_params {\n+                TreatParams::AsPlaceholder => false,\n+                TreatParams::AsInfer => true,\n+            },\n+\n+            // As we don't necessarily eagerly evaluate constants,\n+            // they might unify with any value.\n+            ty::ConstKind::Unevaluated(_) | ty::ConstKind::Error(_) => true,\n+            ty::ConstKind::Value(obl) => match k {\n+                ty::ConstKind::Value(imp) => {\n+                    // FIXME(valtrees): Once we have valtrees, we can just\n+                    // compare them directly here.\n+                    match (obl.try_to_scalar_int(), imp.try_to_scalar_int()) {\n+                        (Some(obl), Some(imp)) => obl == imp,\n+                        _ => true,\n+                    }\n+                }\n+                _ => true,\n+            },\n+\n+            ty::ConstKind::Infer(_) => true,\n+\n+            ty::ConstKind::Bound(..) | ty::ConstKind::Placeholder(_) => {\n+                bug!(\"unexpected obl const: {:?}\", obligation_ct)\n+            }\n+        }\n+    }\n+}"}, {"sha": "e7f0e47f12c6e87daaeeca6182c518f90b3351c6", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a76277c6c4cd7f175efd2d86477447bd6577aea2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a76277c6c4cd7f175efd2d86477447bd6577aea2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=a76277c6c4cd7f175efd2d86477447bd6577aea2", "patch": "@@ -20,7 +20,7 @@ use rustc_hir::CRATE_HIR_ID;\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_infer::traits::{util, TraitEngine};\n use rustc_middle::traits::specialization_graph::OverlapMode;\n-use rustc_middle::ty::fast_reject::{self, TreatParams};\n+use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, ImplSubject, Ty, TyCtxt};\n@@ -79,26 +79,21 @@ where\n     // Before doing expensive operations like entering an inference context, do\n     // a quick check via fast_reject to tell if the impl headers could possibly\n     // unify.\n+    let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsInfer };\n     let impl1_ref = tcx.impl_trait_ref(impl1_def_id);\n     let impl2_ref = tcx.impl_trait_ref(impl2_def_id);\n-\n-    // Check if any of the input types definitely do not unify.\n-    if iter::zip(\n-        impl1_ref.iter().flat_map(|tref| tref.substs.types()),\n-        impl2_ref.iter().flat_map(|tref| tref.substs.types()),\n-    )\n-    .any(|(ty1, ty2)| {\n-        let t1 = fast_reject::simplify_type(tcx, ty1, TreatParams::AsInfer);\n-        let t2 = fast_reject::simplify_type(tcx, ty2, TreatParams::AsInfer);\n-\n-        if let (Some(t1), Some(t2)) = (t1, t2) {\n-            // Simplified successfully\n-            t1 != t2\n-        } else {\n-            // Types might unify\n-            false\n+    let may_overlap = match (impl1_ref, impl2_ref) {\n+        (Some(a), Some(b)) => iter::zip(a.substs, b.substs)\n+            .all(|(arg1, arg2)| drcx.generic_args_may_unify(arg1, arg2)),\n+        (None, None) => {\n+            let self_ty1 = tcx.type_of(impl1_def_id);\n+            let self_ty2 = tcx.type_of(impl2_def_id);\n+            drcx.types_may_unify(self_ty1, self_ty2)\n         }\n-    }) {\n+        _ => bug!(\"unexpected impls: {impl1_def_id:?} {impl2_def_id:?}\"),\n+    };\n+\n+    if !may_overlap {\n         // Some types involved are definitely different, so the impls couldn't possibly overlap.\n         debug!(\"overlapping_impls: fast_reject early-exit\");\n         return no_overlap();\n@@ -519,7 +514,7 @@ pub fn orphan_check(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Result<(), OrphanChe\n /// 3. Before this local type, no generic type parameter of the impl must\n ///    be reachable through fundamental types.\n ///     - e.g. `impl<T> Trait<LocalType> for Vec<T>` is fine, as `Vec` is not fundamental.\n-///     - while `impl<T> Trait<LocalType for Box<T>` results in an error, as `T` is\n+///     - while `impl<T> Trait<LocalType> for Box<T>` results in an error, as `T` is\n ///       reachable through the fundamental type `Box`.\n /// 4. Every type in the local key parameter not known in C, going\n ///    through the parameter's type tree, must appear only as a subtree of"}, {"sha": "25b19c02a59addfeecc18aab4b63b8e7eb5d15d7", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 5, "deletions": 36, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a76277c6c4cd7f175efd2d86477447bd6577aea2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a76277c6c4cd7f175efd2d86477447bd6577aea2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=a76277c6c4cd7f175efd2d86477447bd6577aea2", "patch": "@@ -33,11 +33,11 @@ use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_middle::dep_graph::{DepKind, DepNodeIndex};\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::thir::abstract_const::NotConstEvaluatable;\n-use rustc_middle::ty::fast_reject::{self, TreatParams};\n+use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::fold::BottomUpFolder;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::relate::TypeRelation;\n-use rustc_middle::ty::subst::{GenericArgKind, Subst, SubstsRef};\n+use rustc_middle::ty::subst::{Subst, SubstsRef};\n use rustc_middle::ty::{self, EarlyBinder, PolyProjectionPredicate, ToPolyTraitRef, ToPredicate};\n use rustc_middle::ty::{Ty, TyCtxt, TypeFoldable};\n use rustc_span::symbol::sym;\n@@ -2137,40 +2137,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // We can avoid creating type variables and doing the full\n         // substitution if we find that any of the input types, when\n         // simplified, do not match.\n-\n-        iter::zip(obligation.predicate.skip_binder().trait_ref.substs, impl_trait_ref.substs).any(\n-            |(obligation_arg, impl_arg)| {\n-                match (obligation_arg.unpack(), impl_arg.unpack()) {\n-                    (GenericArgKind::Type(obligation_ty), GenericArgKind::Type(impl_ty)) => {\n-                        // Note, we simplify parameters for the obligation but not the\n-                        // impl so that we do not reject a blanket impl but do reject\n-                        // more concrete impls if we're searching for `T: Trait`.\n-                        let simplified_obligation_ty = fast_reject::simplify_type(\n-                            self.tcx(),\n-                            obligation_ty,\n-                            TreatParams::AsPlaceholder,\n-                        );\n-                        let simplified_impl_ty =\n-                            fast_reject::simplify_type(self.tcx(), impl_ty, TreatParams::AsInfer);\n-\n-                        simplified_obligation_ty.is_some()\n-                            && simplified_impl_ty.is_some()\n-                            && simplified_obligation_ty != simplified_impl_ty\n-                    }\n-                    (GenericArgKind::Lifetime(_), GenericArgKind::Lifetime(_)) => {\n-                        // Lifetimes can never cause a rejection.\n-                        false\n-                    }\n-                    (GenericArgKind::Const(_), GenericArgKind::Const(_)) => {\n-                        // Conservatively ignore consts (i.e. assume they might\n-                        // unify later) until we have `fast_reject` support for\n-                        // them (if we'll ever need it, even).\n-                        false\n-                    }\n-                    _ => unreachable!(),\n-                }\n-            },\n-        )\n+        let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsPlaceholder };\n+        iter::zip(obligation.predicate.skip_binder().trait_ref.substs, impl_trait_ref.substs)\n+            .any(|(obl, imp)| !drcx.generic_args_may_unify(obl, imp))\n     }\n \n     /// Normalize `where_clause_trait_ref` and try to match it against"}]}