{"sha": "ff88510535611f8497047584b18b819b7fe5cb3a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmODg1MTA1MzU2MTFmODQ5NzA0NzU4NGIxOGI4MTliN2ZlNWNiM2E=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-11-13T23:51:08Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-11-17T19:26:48Z"}, "message": "libcollections: generalize BTree* to use BorrowFrom\n\nGeneralizes the BTree-based collections to use the new BorrowFrom\ninfrastructure for more flexible lookups and removals.", "tree": {"sha": "304b56a0440a40de778d5454245306704e498441", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/304b56a0440a40de778d5454245306704e498441"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff88510535611f8497047584b18b819b7fe5cb3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff88510535611f8497047584b18b819b7fe5cb3a", "html_url": "https://github.com/rust-lang/rust/commit/ff88510535611f8497047584b18b819b7fe5cb3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff88510535611f8497047584b18b819b7fe5cb3a/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7213de1c49e448c7c6ad2d30dc3e6b3a13e090df", "url": "https://api.github.com/repos/rust-lang/rust/commits/7213de1c49e448c7c6ad2d30dc3e6b3a13e090df", "html_url": "https://github.com/rust-lang/rust/commit/7213de1c49e448c7c6ad2d30dc3e6b3a13e090df"}], "stats": {"total": 57, "additions": 42, "deletions": 15}, "files": [{"sha": "007e01ef9820c7bbb3f55afaec9d2e20f313f7a6", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ff88510535611f8497047584b18b819b7fe5cb3a/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff88510535611f8497047584b18b819b7fe5cb3a/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=ff88510535611f8497047584b18b819b7fe5cb3a", "patch": "@@ -21,6 +21,7 @@ use core::prelude::*;\n \n use self::StackOp::*;\n use super::node::*;\n+use core::borrow::BorrowFrom;\n use std::hash::{Writer, Hash};\n use core::default::Default;\n use core::{iter, fmt, mem};\n@@ -184,6 +185,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n     /// Returns a reference to the value corresponding to the key.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but the ordering\n+    /// on the borrowed form *must* match the ordering on the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -195,7 +199,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn get(&self, key: &K) -> Option<&V> {\n+    pub fn get<Sized? Q>(&self, key: &Q) -> Option<&V> where Q: BorrowFrom<K> + Ord {\n         let mut cur_node = &self.root;\n         loop {\n             match cur_node.search(key) {\n@@ -213,6 +217,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n     /// Returns true if the map contains a value for the specified key.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but the ordering\n+    /// on the borrowed form *must* match the ordering on the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -224,7 +231,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn contains_key(&self, key: &K) -> bool {\n+    pub fn contains_key<Sized? Q>(&self, key: &Q) -> bool where Q: BorrowFrom<K> + Ord {\n         self.get(key).is_some()\n     }\n \n@@ -236,6 +243,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n     /// Returns a mutable reference to the value corresponding to the key.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but the ordering\n+    /// on the borrowed form *must* match the ordering on the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -251,7 +261,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     // See `get` for implementation notes, this is basically a copy-paste with mut's added\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn get_mut(&mut self, key: &K) -> Option<&mut V> {\n+    pub fn get_mut<Sized? Q>(&mut self, key: &Q) -> Option<&mut V> where Q: BorrowFrom<K> + Ord {\n         // temp_node is a Borrowck hack for having a mutable value outlive a loop iteration\n         let mut temp_node = &mut self.root;\n         loop {\n@@ -410,6 +420,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// Removes a key from the map, returning the value at the key if the key\n     /// was previously in the map.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but the ordering\n+    /// on the borrowed form *must* match the ordering on the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -421,7 +434,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn remove(&mut self, key: &K) -> Option<V> {\n+    pub fn remove<Sized? Q>(&mut self, key: &Q) -> Option<V> where Q: BorrowFrom<K> + Ord {\n         // See `swap` for a more thorough description of the stuff going on in here\n         let mut stack = stack::PartialSearchStack::new(self);\n         loop {\n@@ -790,14 +803,18 @@ impl<K: Show, V: Show> Show for BTreeMap<K, V> {\n     }\n }\n \n-impl<K: Ord, V> Index<K, V> for BTreeMap<K, V> {\n-    fn index(&self, key: &K) -> &V {\n+impl<K: Ord, Sized? Q, V> Index<Q, V> for BTreeMap<K, V>\n+    where Q: BorrowFrom<K> + Ord\n+{\n+    fn index(&self, key: &Q) -> &V {\n         self.get(key).expect(\"no entry found for key\")\n     }\n }\n \n-impl<K: Ord, V> IndexMut<K, V> for BTreeMap<K, V> {\n-    fn index_mut(&mut self, key: &K) -> &mut V {\n+impl<K: Ord, Sized? Q, V> IndexMut<Q, V> for BTreeMap<K, V>\n+    where Q: BorrowFrom<K> + Ord\n+{\n+    fn index_mut(&mut self, key: &Q) -> &mut V {\n         self.get_mut(key).expect(\"no entry found for key\")\n     }\n }"}, {"sha": "bdd7aa9c61172361852907030425d7daf5f247b1", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ff88510535611f8497047584b18b819b7fe5cb3a/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff88510535611f8497047584b18b819b7fe5cb3a/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=ff88510535611f8497047584b18b819b7fe5cb3a", "patch": "@@ -19,6 +19,7 @@ use core::prelude::*;\n \n use core::{slice, mem, ptr};\n use core::iter::Zip;\n+use core::borrow::BorrowFrom;\n \n use vec;\n use vec::Vec;\n@@ -73,19 +74,19 @@ impl<K: Ord, V> Node<K, V> {\n     /// Searches for the given key in the node. If it finds an exact match,\n     /// `Found` will be yielded with the matching index. If it doesn't find an exact match,\n     /// `GoDown` will be yielded with the index of the subtree the key must lie in.\n-    pub fn search(&self, key: &K) -> SearchResult {\n+    pub fn search<Sized? Q>(&self, key: &Q) -> SearchResult where Q: BorrowFrom<K> + Ord {\n         // FIXME(Gankro): Tune when to search linear or binary based on B (and maybe K/V).\n         // For the B configured as of this writing (B = 6), binary search was *significantly*\n         // worse for uints.\n         self.search_linear(key)\n     }\n \n-    fn search_linear(&self, key: &K) -> SearchResult {\n+    fn search_linear<Sized? Q>(&self, key: &Q) -> SearchResult where Q: BorrowFrom<K> + Ord {\n         for (i, k) in self.keys.iter().enumerate() {\n-            match k.cmp(key) {\n-                Less => {},\n+            match key.cmp(BorrowFrom::borrow_from(k)) {\n+                Greater => {},\n                 Equal => return Found(i),\n-                Greater => return GoDown(i),\n+                Less => return GoDown(i),\n             }\n         }\n         GoDown(self.len())"}, {"sha": "64ae4f6a508677828aacbdf71b9f83125ca740b0", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ff88510535611f8497047584b18b819b7fe5cb3a/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff88510535611f8497047584b18b819b7fe5cb3a/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=ff88510535611f8497047584b18b819b7fe5cb3a", "patch": "@@ -15,6 +15,7 @@ use core::prelude::*;\n \n use btree_map::{BTreeMap, Keys, MoveEntries};\n use std::hash::Hash;\n+use core::borrow::BorrowFrom;\n use core::default::Default;\n use core::{iter, fmt};\n use core::iter::Peekable;\n@@ -167,6 +168,10 @@ impl<T: Ord> BTreeSet<T> {\n \n     /// Returns `true` if the set contains a value.\n     ///\n+    /// The value may be any borrowed form of the set's value type,\n+    /// but the ordering on the borrowed form *must* match the\n+    /// ordering on the value type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -177,7 +182,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn contains(&self, value: &T) -> bool {\n+    pub fn contains<Sized? Q>(&self, value: &Q) -> bool where Q: BorrowFrom<T> + Ord {\n         self.map.contains_key(value)\n     }\n \n@@ -291,6 +296,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// Removes a value from the set. Returns `true` if the value was\n     /// present in the set.\n     ///\n+    /// The value may be any borrowed form of the set's value type,\n+    /// but the ordering on the borrowed form *must* match the\n+    /// ordering on the value type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -303,7 +312,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn remove(&mut self, value: &T) -> bool {\n+    pub fn remove<Sized? Q>(&mut self, value: &Q) -> bool where Q: BorrowFrom<T> + Ord {\n         self.map.remove(value).is_some()\n     }\n }"}]}