{"sha": "f4f4a35b5b1fe54b05b2dac3428c55ef2d3923b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0ZjRhMzViNWIxZmU1NGIwNWIyZGFjMzQyOGM1NWVmMmQzOTIzYjE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-11-08T21:19:28Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-11-09T00:47:57Z"}, "message": "Add new tests showing multiple lifetime parameters in use", "tree": {"sha": "3b83560a12576c1d39ff2f5fd518cbbac88849a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b83560a12576c1d39ff2f5fd518cbbac88849a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4f4a35b5b1fe54b05b2dac3428c55ef2d3923b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4f4a35b5b1fe54b05b2dac3428c55ef2d3923b1", "html_url": "https://github.com/rust-lang/rust/commit/f4f4a35b5b1fe54b05b2dac3428c55ef2d3923b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4f4a35b5b1fe54b05b2dac3428c55ef2d3923b1/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f36a891fe22f656454b70b8f2aa64bef9133e7f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f36a891fe22f656454b70b8f2aa64bef9133e7f0", "html_url": "https://github.com/rust-lang/rust/commit/f36a891fe22f656454b70b8f2aa64bef9133e7f0"}], "stats": {"total": 167, "additions": 165, "deletions": 2}, "files": [{"sha": "77a54fec7bf7c6204699aefceea5e85a0cb9616a", "filename": "src/test/compile-fail/regions-variance-contravariant-use-covariant-in-second-position.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f4f4a35b5b1fe54b05b2dac3428c55ef2d3923b1/src%2Ftest%2Fcompile-fail%2Fregions-variance-contravariant-use-covariant-in-second-position.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4f4a35b5b1fe54b05b2dac3428c55ef2d3923b1/src%2Ftest%2Fcompile-fail%2Fregions-variance-contravariant-use-covariant-in-second-position.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-variance-contravariant-use-covariant-in-second-position.rs?ref=f4f4a35b5b1fe54b05b2dac3428c55ef2d3923b1", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a type which is covariant with respect to its region\n+// parameter yields an error when used in a contravariant way.\n+//\n+// Note: see variance-regions-*.rs for the tests that check that the\n+// variance inference works in the first place.\n+\n+// `S` is contravariant with respect to both parameters.\n+struct S<'a, 'b> {\n+    f: &'a int,\n+    g: &'b int,\n+}\n+\n+fn use_<'short,'long>(c: S<'long, 'short>,\n+                      s: &'short int,\n+                      l: &'long int,\n+                      _where:Option<&'short &'long ()>) {\n+\n+    let _: S<'long, 'short> = c; // OK\n+    let _: S<'short, 'short> = c; // OK\n+\n+    // Test whether S<_,'short> <: S<_,'long>.  Since\n+    // 'short <= 'long, this would be true if the Contravariant type were\n+    // covariant with respect to its parameter 'a.\n+\n+    let _: S<'long, 'long> = c; //~ ERROR mismatched types\n+    //~^ ERROR  cannot infer an appropriate lifetime\n+}\n+\n+fn main() {}"}, {"sha": "3f0161d9deb2b9c46f8111fdf1dec7c86c1515fa", "filename": "src/test/compile-fail/regions-variance-contravariant-use-covariant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4f4a35b5b1fe54b05b2dac3428c55ef2d3923b1/src%2Ftest%2Fcompile-fail%2Fregions-variance-contravariant-use-covariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4f4a35b5b1fe54b05b2dac3428c55ef2d3923b1/src%2Ftest%2Fcompile-fail%2Fregions-variance-contravariant-use-covariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-variance-contravariant-use-covariant.rs?ref=f4f4a35b5b1fe54b05b2dac3428c55ef2d3923b1", "patch": "@@ -14,8 +14,8 @@\n // Note: see variance-regions-*.rs for the tests that check that the\n // variance inference works in the first place.\n \n-// This is covariant with respect to 'a, meaning that\n-// Covariant<'foo> <: Covariant<'static> because\n+// This is contravariant with respect to 'a, meaning that\n+// Contravariant<'foo> <: Contravariant<'static> because\n // 'foo <= 'static\n struct Contravariant<'a> {\n     f: &'a int"}, {"sha": "f98e475094cac85f38e17d1fd5b16482a7b09199", "filename": "src/test/run-pass/regions-mock-tcx.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/f4f4a35b5b1fe54b05b2dac3428c55ef2d3923b1/src%2Ftest%2Frun-pass%2Fregions-mock-tcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4f4a35b5b1fe54b05b2dac3428c55ef2d3923b1/src%2Ftest%2Frun-pass%2Fregions-mock-tcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-tcx.rs?ref=f4f4a35b5b1fe54b05b2dac3428c55ef2d3923b1", "patch": "@@ -0,0 +1,124 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a sample usage pattern for regions. Makes use of the\n+// following features:\n+//\n+// - Multiple lifetime parameters\n+// - Arenas\n+\n+extern mod extra;\n+\n+use extra::arena;\n+use extra::arena::Arena;\n+use std::hashmap::HashMap;\n+use std::cast;\n+use std::libc;\n+use std::mem;\n+\n+type Type<'tcx> = &'tcx TypeStructure<'tcx>;\n+\n+#[deriving(Eq)]\n+enum TypeStructure<'tcx> {\n+    TypeInt,\n+    TypeFunction(Type<'tcx>, Type<'tcx>),\n+}\n+\n+struct TypeContext<'tcx, 'ast> {\n+    ty_arena: &'tcx Arena,\n+    types: ~[Type<'tcx>],\n+    type_table: HashMap<NodeId, Type<'tcx>>,\n+\n+    ast_arena: &'ast Arena,\n+    ast_counter: uint,\n+}\n+\n+impl<'tcx,'ast> TypeContext<'tcx, 'ast> {\n+    fn new(ty_arena: &'tcx Arena, ast_arena: &'ast Arena)\n+           -> TypeContext<'tcx, 'ast> {\n+        TypeContext { ty_arena: ty_arena,\n+                      types: ~[],\n+                      type_table: HashMap::new(),\n+\n+                      ast_arena: ast_arena,\n+                      ast_counter: 0 }\n+    }\n+\n+    fn add_type(&mut self, s: TypeStructure<'tcx>) -> Type<'tcx> {\n+        for &ty in self.types.iter() {\n+            if *ty == s {\n+                return ty;\n+            }\n+        }\n+\n+        let ty = self.ty_arena.alloc(|| s);\n+        self.types.push(ty);\n+        ty\n+    }\n+\n+    fn set_type(&mut self, id: NodeId, ty: Type<'tcx>) -> Type<'tcx> {\n+        self.type_table.insert(id, ty);\n+        ty\n+    }\n+\n+    fn ast(&mut self, a: AstKind<'ast>) -> Ast<'ast> {\n+        let id = self.ast_counter;\n+        self.ast_counter += 1;\n+        self.ast_arena.alloc(|| AstStructure { id: NodeId {id:id}, kind: a })\n+    }\n+}\n+\n+#[deriving(Eq, IterBytes)]\n+struct NodeId {\n+    id: uint\n+}\n+\n+type Ast<'ast> = &'ast AstStructure<'ast>;\n+\n+struct AstStructure<'ast> {\n+    id: NodeId,\n+    kind: AstKind<'ast>\n+}\n+\n+enum AstKind<'ast> {\n+    ExprInt,\n+    ExprVar(uint),\n+    ExprLambda(Ast<'ast>),\n+    // ...\n+}\n+\n+fn compute_types<'tcx,'ast>(tcx: &mut TypeContext<'tcx,'ast>,\n+                            ast: Ast<'ast>) -> Type<'tcx>\n+{\n+    match ast.kind {\n+        ExprInt | ExprVar(_) => {\n+            let ty = tcx.add_type(TypeInt);\n+            tcx.set_type(ast.id, ty)\n+        }\n+\n+        ExprLambda(ast) => {\n+            let arg_ty = tcx.add_type(TypeInt);\n+            let body_ty = compute_types(tcx, ast);\n+            let lambda_ty = tcx.add_type(TypeFunction(arg_ty, body_ty));\n+            tcx.set_type(ast.id, lambda_ty)\n+        }\n+\n+        // ...\n+    }\n+}\n+\n+pub fn main() {\n+    let ty_arena = arena::Arena::new();\n+    let ast_arena = arena::Arena::new();\n+    let mut tcx = TypeContext::new(&ty_arena, &ast_arena);\n+    let ast = tcx.ast(ExprInt);\n+    let ty = compute_types(&mut tcx, ast);\n+    assert_eq!(*ty, TypeInt);\n+}"}]}