{"sha": "829b1a9dd99f9f08faec8b1774798b9025bdf13b", "node_id": "C_kwDOAAsO6NoAKDgyOWIxYTlkZDk5ZjlmMDhmYWVjOGIxNzc0Nzk4YjkwMjViZGYxM2I", "commit": {"author": {"name": "Will Crichton", "email": "wcrichto@cs.stanford.edu", "date": "2021-09-17T01:12:45Z"}, "committer": {"name": "Will Crichton", "email": "wcrichto@cs.stanford.edu", "date": "2021-10-07T02:45:23Z"}, "message": "Incorporate jyn's feedback\n* Move call location logic from function constructor to rendering\n* Fix issue with macro spans in scraping examples\n* Clean up example loading logic\n\nDocumentation / newtype for DecorationInfo\n\nFix line number display\n\nSerialize edition of call site, other small cleanup", "tree": {"sha": "03dc310589158780494e0f57f1a0351adf960c57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03dc310589158780494e0f57f1a0351adf960c57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/829b1a9dd99f9f08faec8b1774798b9025bdf13b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/829b1a9dd99f9f08faec8b1774798b9025bdf13b", "html_url": "https://github.com/rust-lang/rust/commit/829b1a9dd99f9f08faec8b1774798b9025bdf13b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/829b1a9dd99f9f08faec8b1774798b9025bdf13b/comments", "author": {"login": "willcrichton", "id": 663326, "node_id": "MDQ6VXNlcjY2MzMyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/663326?v=4", "gravatar_id": "", "url": "https://api.github.com/users/willcrichton", "html_url": "https://github.com/willcrichton", "followers_url": "https://api.github.com/users/willcrichton/followers", "following_url": "https://api.github.com/users/willcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/willcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/willcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/willcrichton/subscriptions", "organizations_url": "https://api.github.com/users/willcrichton/orgs", "repos_url": "https://api.github.com/users/willcrichton/repos", "events_url": "https://api.github.com/users/willcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/willcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "willcrichton", "id": 663326, "node_id": "MDQ6VXNlcjY2MzMyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/663326?v=4", "gravatar_id": "", "url": "https://api.github.com/users/willcrichton", "html_url": "https://github.com/willcrichton", "followers_url": "https://api.github.com/users/willcrichton/followers", "following_url": "https://api.github.com/users/willcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/willcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/willcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/willcrichton/subscriptions", "organizations_url": "https://api.github.com/users/willcrichton/orgs", "repos_url": "https://api.github.com/users/willcrichton/repos", "events_url": "https://api.github.com/users/willcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/willcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1cb19444f27db434183daa003bad89be9491564", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1cb19444f27db434183daa003bad89be9491564", "html_url": "https://github.com/rust-lang/rust/commit/a1cb19444f27db434183daa003bad89be9491564"}], "stats": {"total": 315, "additions": 183, "deletions": 132}, "files": [{"sha": "9d5a95a88a2df253d0f2cfcb70b9d9e670f1bc64", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/829b1a9dd99f9f08faec8b1774798b9025bdf13b/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/829b1a9dd99f9f08faec8b1774798b9025bdf13b/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=829b1a9dd99f9f08faec8b1774798b9025bdf13b", "patch": "@@ -235,7 +235,7 @@ fn build_external_function(cx: &mut DocContext<'_>, did: DefId) -> clean::Functi\n         decl,\n         generics,\n         header: hir::FnHeader { unsafety: sig.unsafety(), abi: sig.abi(), constness, asyncness },\n-        call_locations: None,\n+        def_id: did,\n     }\n }\n "}, {"sha": "dded5c9934b833a81854e26cd44484c1e226818c", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/829b1a9dd99f9f08faec8b1774798b9025bdf13b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/829b1a9dd99f9f08faec8b1774798b9025bdf13b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=829b1a9dd99f9f08faec8b1774798b9025bdf13b", "patch": "@@ -801,10 +801,8 @@ impl<'a> Clean<Function> for (&'a hir::FnSig<'a>, &'a hir::Generics<'a>, hir::Bo\n     fn clean(&self, cx: &mut DocContext<'_>) -> Function {\n         let (generics, decl) =\n             enter_impl_trait(cx, |cx| (self.1.clean(cx), (&*self.0.decl, self.2).clean(cx)));\n-        let mut function = Function { decl, generics, header: self.0.header, call_locations: None };\n         let def_id = self.2.hir_id.owner.to_def_id();\n-        function.load_call_locations(def_id, cx);\n-        function\n+        Function { decl, generics, header: self.0.header, def_id }\n     }\n }\n \n@@ -936,14 +934,13 @@ impl Clean<Item> for hir::TraitItem<'_> {\n                     let (generics, decl) = enter_impl_trait(cx, |cx| {\n                         (self.generics.clean(cx), (&*sig.decl, &names[..]).clean(cx))\n                     });\n-                    let mut t =\n-                        Function { header: sig.header, decl, generics, call_locations: None };\n+                    let def_id = self.def_id.to_def_id();\n+                    let mut t = Function { header: sig.header, decl, generics, def_id };\n                     if t.header.constness == hir::Constness::Const\n                         && is_unstable_const_fn(cx.tcx, local_did).is_some()\n                     {\n                         t.header.constness = hir::Constness::NotConst;\n                     }\n-                    t.load_call_locations(self.def_id.to_def_id(), cx);\n                     TyMethodItem(t)\n                 }\n                 hir::TraitItemKind::Type(ref bounds, ref default) => {\n@@ -1062,7 +1059,7 @@ impl Clean<Item> for ty::AssocItem {\n                         ty::ImplContainer(_) => Some(self.defaultness),\n                         ty::TraitContainer(_) => None,\n                     };\n-                    let mut function = Function {\n+                    let function = Function {\n                         generics,\n                         decl,\n                         header: hir::FnHeader {\n@@ -1071,12 +1068,11 @@ impl Clean<Item> for ty::AssocItem {\n                             constness,\n                             asyncness,\n                         },\n-                        call_locations: None,\n+                        def_id: self.def_id,\n                     };\n-                    function.load_call_locations(self.def_id, cx);\n                     MethodItem(function, defaultness)\n                 } else {\n-                    let mut function = Function {\n+                    let function = Function {\n                         generics,\n                         decl,\n                         header: hir::FnHeader {\n@@ -1085,9 +1081,8 @@ impl Clean<Item> for ty::AssocItem {\n                             constness: hir::Constness::NotConst,\n                             asyncness: hir::IsAsync::NotAsync,\n                         },\n-                        call_locations: None,\n+                        def_id: self.def_id,\n                     };\n-                    function.load_call_locations(self.def_id, cx);\n                     TyMethodItem(function)\n                 }\n             }\n@@ -2086,7 +2081,8 @@ fn clean_use_statement(\n impl Clean<Item> for (&hir::ForeignItem<'_>, Option<Symbol>) {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n         let (item, renamed) = self;\n-        cx.with_param_env(item.def_id.to_def_id(), |cx| {\n+        let def_id = item.def_id.to_def_id();\n+        cx.with_param_env(def_id, |cx| {\n             let kind = match item.kind {\n                 hir::ForeignItemKind::Fn(ref decl, ref names, ref generics) => {\n                     let abi = cx.tcx.hir().get_foreign_abi(item.hir_id());\n@@ -2106,7 +2102,7 @@ impl Clean<Item> for (&hir::ForeignItem<'_>, Option<Symbol>) {\n                             constness: hir::Constness::NotConst,\n                             asyncness: hir::IsAsync::NotAsync,\n                         },\n-                        call_locations: None,\n+                        def_id,\n                     })\n                 }\n                 hir::ForeignItemKind::Static(ref ty, mutability) => {"}, {"sha": "043ffbfd187c3370b3a1d3d0f0bc8a7078b95cac", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/829b1a9dd99f9f08faec8b1774798b9025bdf13b/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/829b1a9dd99f9f08faec8b1774798b9025bdf13b/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=829b1a9dd99f9f08faec8b1774798b9025bdf13b", "patch": "@@ -42,7 +42,6 @@ use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;\n use crate::html::render::cache::ExternalLocation;\n use crate::html::render::Context;\n-use crate::scrape_examples::{self, FnCallLocations};\n \n use self::FnRetTy::*;\n use self::ItemKind::*;\n@@ -1255,19 +1254,7 @@ crate struct Function {\n     crate decl: FnDecl,\n     crate generics: Generics,\n     crate header: hir::FnHeader,\n-    crate call_locations: Option<FnCallLocations>,\n-}\n-\n-impl Function {\n-    /// If --scrape-examples is used, then this function attempts to find call locations\n-    /// for `self` within `RenderOptions::call_locations` and store them in `Function::call_locations`.\n-    crate fn load_call_locations(&mut self, def_id: hir::def_id::DefId, cx: &DocContext<'_>) {\n-        if let Some(call_locations) = cx.render_options.call_locations.as_ref() {\n-            let key = scrape_examples::def_id_call_key(cx.tcx, def_id);\n-            self.call_locations = call_locations.get(&key).cloned();\n-            debug!(\"call_locations: {:?} -- {:?}\", key, self.call_locations);\n-        }\n-    }\n+    crate def_id: DefId,\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]"}, {"sha": "54b62db791748dce07203a0bd9fe9d55637c0531", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/829b1a9dd99f9f08faec8b1774798b9025bdf13b/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/829b1a9dd99f9f08faec8b1774798b9025bdf13b/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=829b1a9dd99f9f08faec8b1774798b9025bdf13b", "patch": "@@ -207,6 +207,7 @@ impl fmt::Debug for Options {\n             .field(\"run_check\", &self.run_check)\n             .field(\"no_run\", &self.no_run)\n             .field(\"nocapture\", &self.nocapture)\n+            .field(\"scrape_examples\", &self.scrape_examples)\n             .finish()\n     }\n }\n@@ -285,7 +286,7 @@ crate struct RenderOptions {\n     crate emit: Vec<EmitType>,\n     /// If `true`, HTML source pages will generate links for items to their definition.\n     crate generate_link_to_definition: bool,\n-    crate call_locations: Option<AllCallLocations>,\n+    crate call_locations: AllCallLocations,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]"}, {"sha": "a97dd95dcb661ff1553bcf966ff2d9a2b89ec827", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/829b1a9dd99f9f08faec8b1774798b9025bdf13b/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/829b1a9dd99f9f08faec8b1774798b9025bdf13b/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=829b1a9dd99f9f08faec8b1774798b9025bdf13b", "patch": "@@ -31,7 +31,9 @@ crate struct ContextInfo<'a, 'b, 'c> {\n     crate root_path: &'c str,\n }\n \n-crate type DecorationInfo = FxHashMap<&'static str, Vec<(u32, u32)>>;\n+/// Decorations are represented as a map from CSS class to vector of character ranges.\n+/// Each range will be wrapped in a span with that class.\n+crate struct DecorationInfo(crate FxHashMap<&'static str, Vec<(u32, u32)>>);\n \n /// Highlights `src`, returning the HTML output.\n crate fn render_with_highlighting(\n@@ -273,6 +275,7 @@ struct Decorations {\n impl Decorations {\n     fn new(info: DecorationInfo) -> Self {\n         let (starts, ends) = info\n+            .0\n             .into_iter()\n             .map(|(kind, ranges)| ranges.into_iter().map(move |(lo, hi)| ((lo, kind), hi)))\n             .flatten()\n@@ -305,6 +308,7 @@ impl<'a> Classifier<'a> {\n         decoration_info: Option<DecorationInfo>,\n     ) -> Classifier<'_> {\n         let tokens = PeekIter::new(TokenIter { src });\n+        let decorations = decoration_info.map(Decorations::new);\n         Classifier {\n             tokens,\n             in_attribute: false,"}, {"sha": "fe684fd79a1f5a7d6704bd7b69b4e4e1f90de08b", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/829b1a9dd99f9f08faec8b1774798b9025bdf13b/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/829b1a9dd99f9f08faec8b1774798b9025bdf13b/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=829b1a9dd99f9f08faec8b1774798b9025bdf13b", "patch": "@@ -35,6 +35,7 @@ use crate::html::format::Buffer;\n use crate::html::markdown::{self, plain_text_summary, ErrorCodes, IdMap};\n use crate::html::static_files::PAGE;\n use crate::html::{layout, sources};\n+use crate::scrape_examples::AllCallLocations;\n \n /// Major driving force in all rustdoc rendering. This contains information\n /// about where in the tree-like hierarchy rendering is occurring and controls\n@@ -124,6 +125,8 @@ crate struct SharedContext<'tcx> {\n     crate span_correspondance_map: FxHashMap<rustc_span::Span, LinkFromSrc>,\n     /// The [`Cache`] used during rendering.\n     crate cache: Cache,\n+\n+    crate call_locations: AllCallLocations,\n }\n \n impl SharedContext<'_> {\n@@ -389,6 +392,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             generate_redirect_map,\n             show_type_layout,\n             generate_link_to_definition,\n+            call_locations,\n             ..\n         } = options;\n \n@@ -480,6 +484,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             templates,\n             span_correspondance_map: matches,\n             cache,\n+            call_locations,\n         };\n \n         // Add the default themes to the `Vec` of stylepaths"}, {"sha": "cd5316240d00fea6a0cfda4d99cf1f5f57976316", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 46, "deletions": 31, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/829b1a9dd99f9f08faec8b1774798b9025bdf13b/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/829b1a9dd99f9f08faec8b1774798b9025bdf13b/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=829b1a9dd99f9f08faec8b1774798b9025bdf13b", "patch": "@@ -73,8 +73,9 @@ use crate::html::format::{\n     print_generic_bounds, print_where_clause, Buffer, HrefError, PrintWithSpace,\n };\n use crate::html::markdown::{HeadingOffset, Markdown, MarkdownHtml, MarkdownSummaryLine};\n+use crate::html::highlight;\n use crate::html::sources;\n-use crate::scrape_examples::{CallData, FnCallLocations};\n+use crate::scrape_examples::CallData;\n \n /// A pair of name and its optional document.\n crate type NameDoc = (String, Option<String>);\n@@ -592,9 +593,13 @@ fn document_full_inner(\n         }\n     }\n \n-    match &*item.kind {\n+    let kind = match &*item.kind {\n+        clean::ItemKind::StrippedItem(box kind) | kind => kind,\n+    };\n+\n+    match kind {\n         clean::ItemKind::FunctionItem(f) | clean::ItemKind::MethodItem(f, _) => {\n-            render_call_locations(w, cx, &f.call_locations, item);\n+            render_call_locations(w, cx, f.def_id, item);\n         }\n         _ => {}\n     }\n@@ -2458,14 +2463,11 @@ fn collect_paths_for_type(first_ty: clean::Type, cache: &Cache) -> Vec<String> {\n const MAX_FULL_EXAMPLES: usize = 5;\n \n /// Generates the HTML for example call locations generated via the --scrape-examples flag.\n-fn render_call_locations(\n-    w: &mut Buffer,\n-    cx: &Context<'_>,\n-    call_locations: &Option<FnCallLocations>,\n-    item: &clean::Item,\n-) {\n-    let call_locations = match call_locations.as_ref() {\n-        Some(call_locations) if call_locations.len() > 0 => call_locations,\n+fn render_call_locations(w: &mut Buffer, cx: &Context<'_>, def_id: DefId, item: &clean::Item) {\n+    let tcx = cx.tcx();\n+    let key = crate::scrape_examples::def_id_call_key(tcx, def_id);\n+    let call_locations = match cx.shared.call_locations.get(&key) {\n+        Some(call_locations) => call_locations,\n         _ => {\n             return;\n         }\n@@ -2483,7 +2485,6 @@ fn render_call_locations(\n     );\n \n     // Generate the HTML for a single example, being the title and code block\n-    let tcx = cx.tcx();\n     let write_example = |w: &mut Buffer, (path, call_data): (&PathBuf, &CallData)| -> bool {\n         let contents = match fs::read_to_string(&path) {\n             Ok(contents) => contents,\n@@ -2497,40 +2498,51 @@ fn render_call_locations(\n \n         // To reduce file sizes, we only want to embed the source code needed to understand the example, not\n         // the entire file. So we find the smallest byte range that covers all items enclosing examples.\n-        assert!(call_data.locations.len() > 0);\n+        assert!(!call_data.locations.is_empty());\n         let min_loc =\n             call_data.locations.iter().min_by_key(|loc| loc.enclosing_item.byte_span.0).unwrap();\n-        let min_byte = min_loc.enclosing_item.byte_span.0;\n-        let min_line = min_loc.enclosing_item.line_span.0;\n-        let max_byte =\n+        let (byte_offset, _) = min_loc.enclosing_item.byte_span;\n+        let (line_offset, _) = min_loc.enclosing_item.line_span;\n+        let byte_ceiling =\n             call_data.locations.iter().map(|loc| loc.enclosing_item.byte_span.1).max().unwrap();\n \n         // The output code is limited to that byte range.\n-        let contents_subset = &contents[(min_byte as usize)..(max_byte as usize)];\n+        let contents_subset = &contents[(byte_offset as usize)..(byte_ceiling as usize)];\n \n         // The call locations need to be updated to reflect that the size of the program has changed.\n-        // Specifically, the ranges are all subtracted by `min_byte` since that's the new zero point.\n+        // Specifically, the ranges are all subtracted by `byte_offset` since that's the new zero point.\n         let (byte_ranges, line_ranges): (Vec<_>, Vec<_>) = call_data\n             .locations\n             .iter()\n             .map(|loc| {\n                 let (byte_lo, byte_hi) = loc.call_expr.byte_span;\n                 let (line_lo, line_hi) = loc.call_expr.line_span;\n-                ((byte_lo - min_byte, byte_hi - min_byte), (line_lo - min_line, line_hi - min_line))\n+                (\n+                    (byte_lo - byte_offset, byte_hi - byte_offset),\n+                    (line_lo - line_offset, line_hi - line_offset),\n+                )\n             })\n             .unzip();\n \n-        let edition = cx.shared.edition();\n+        let (init_min, init_max) = line_ranges[0];\n+        let line_range = if init_min == init_max {\n+            format!(\"line {}\", init_min + line_offset + 1)\n+        } else {\n+            format!(\"lines {}-{}\", init_min + line_offset + 1, init_max + line_offset + 1)\n+        };\n+\n         write!(\n             w,\n-            r#\"<div class=\"scraped-example\" data-locs=\"{locations}\">\n+            r#\"<div class=\"scraped-example\" data-locs=\"{locations}\" data-offset=\"{offset}\">\n                 <div class=\"scraped-example-title\">\n-                   {name} <a href=\"{root}{url}\" target=\"_blank\">[src]</a>\n+                   {name} (<a href=\"{root}{url}\" target=\"_blank\">{line_range}</a>)\n                 </div>\n                 <div class=\"code-wrapper\">\"#,\n             root = cx.root_path(),\n             url = call_data.url,\n             name = call_data.display_name,\n+            line_range = line_range,\n+            offset = line_offset,\n             // The locations are encoded as a data attribute, so they can be read\n             // later by the JS for interactions.\n             locations = serde_json::to_string(&line_ranges).unwrap(),\n@@ -2551,8 +2563,8 @@ fn render_call_locations(\n                 _ => false,\n             })?;\n             Some(rustc_span::Span::with_root_ctxt(\n-                file.start_pos + BytePos(min_byte),\n-                file.start_pos + BytePos(max_byte),\n+                file.start_pos + BytePos(byte_offset),\n+                file.start_pos + BytePos(byte_ceiling),\n             ))\n         })()\n         .unwrap_or(rustc_span::DUMMY_SP);\n@@ -2566,12 +2578,12 @@ fn render_call_locations(\n         sources::print_src(\n             w,\n             contents_subset,\n-            edition,\n+            call_data.edition,\n             file_span,\n             cx,\n             &root_path,\n-            Some(min_line),\n-            Some(decoration_info),\n+            Some(line_offset),\n+            Some(highlight::DecorationInfo(decoration_info)),\n         );\n         write!(w, \"</div></div>\");\n \n@@ -2590,12 +2602,14 @@ fn render_call_locations(\n         };\n \n         let mut locs = call_locations.into_iter().collect::<Vec<_>>();\n-        locs.sort_by_key(|x| sort_criterion(x));\n+        locs.sort_by_key(sort_criterion);\n         locs\n     };\n \n-    // Write just one example that's visible by default in the method's description.\n     let mut it = ordered_locations.into_iter().peekable();\n+\n+    // An example may fail to write if its source can't be read for some reason, so this method\n+    // continues iterating until a write suceeds\n     let write_and_skip_failure = |w: &mut Buffer, it: &mut Peekable<_>| {\n         while let Some(example) = it.next() {\n             if write_example(&mut *w, example) {\n@@ -2604,6 +2618,7 @@ fn render_call_locations(\n         }\n     };\n \n+    // Write just one example that's visible by default in the method's description.\n     write_and_skip_failure(w, &mut it);\n \n     // Then add the remaining examples in a hidden section.\n@@ -2626,7 +2641,7 @@ fn render_call_locations(\n             write_and_skip_failure(w, &mut it);\n         }\n \n-        // For the remaining examples, generate a <ul /> containing links to the source files.\n+        // For the remaining examples, generate a <ul> containing links to the source files.\n         if it.peek().is_some() {\n             write!(\n                 w,\n@@ -2635,7 +2650,7 @@ fn render_call_locations(\n             it.for_each(|(_, call_data)| {\n                 write!(\n                     w,\n-                    r#\"<li><a href=\"{}{}\" target=\"_blank\">{}</a></li>\"#,\n+                    r#\"<li><a href=\"{root}{url}\" target=\"_blank\">{name}</a></li>\"#,\n                     root = cx.root_path(),\n                     url = call_data.url,\n                     name = call_data.display_name"}, {"sha": "b7d9a30beb169820a3e6784b0a3d889e6721c8ed", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/829b1a9dd99f9f08faec8b1774798b9025bdf13b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/829b1a9dd99f9f08faec8b1774798b9025bdf13b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=829b1a9dd99f9f08faec8b1774798b9025bdf13b", "patch": "@@ -1978,10 +1978,6 @@ details.undocumented[open] > summary::before {\n \tfont-family: 'Fira Sans';\n }\n \n-.scraped-example-title a {\n-\tmargin-left: 5px;\n-}\n-\n .scraped-example:not(.expanded) .code-wrapper pre.line-numbers,\n .scraped-example:not(.expanded) .code-wrapper .example-wrap pre.rust {\n \toverflow: hidden;"}, {"sha": "be63e129f3d918e145f3a234405dfbc7af06c1e5", "filename": "src/librustdoc/html/static/js/main.js", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/829b1a9dd99f9f08faec8b1774798b9025bdf13b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/829b1a9dd99f9f08faec8b1774798b9025bdf13b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js?ref=829b1a9dd99f9f08faec8b1774798b9025bdf13b", "patch": "@@ -996,9 +996,11 @@ function hideThemeButtonState() {\n \n     function updateScrapedExample(example) {\n         var locs = JSON.parse(example.attributes.getNamedItem(\"data-locs\").textContent);\n+        var offset = parseInt(example.attributes.getNamedItem(\"data-offset\").textContent);\n \n         var locIndex = 0;\n         var highlights = example.querySelectorAll('.highlight');\n+        var link = example.querySelector('.scraped-example-title a');\n         addClass(highlights[0], 'focus');\n         if (locs.length > 1) {\n             // Toggle through list of examples in a given file\n@@ -1007,13 +1009,36 @@ function hideThemeButtonState() {\n                 f();\n                 scrollToLoc(example, locs[locIndex]);\n                 addClass(highlights[locIndex], 'focus');\n+\n+                var curLoc = locs[locIndex];\n+                var minLine = curLoc[0] + offset + 1;\n+                var maxLine = curLoc[1] + offset + 1;\n+\n+                var text;\n+                var anchor;\n+                if (minLine == maxLine) {\n+                    text = 'line ' + minLine.toString();\n+                    anchor = minLine.toString();\n+                } else {\n+                    var range = minLine.toString() + '-' + maxLine.toString();\n+                    text = 'lines ' + range;\n+                    anchor = range;\n+                }\n+\n+                var url = new URL(link.href);\n+                url.hash = anchor;\n+\n+                link.href = url.toString();\n+                link.innerHTML = text;\n             };\n+\n             example.querySelector('.prev')\n                 .addEventListener('click', function() {\n                     onChangeLoc(function() {\n                         locIndex = (locIndex - 1 + locs.length) % locs.length;\n                     });\n                 });\n+\n             example.querySelector('.next')\n                 .addEventListener('click', function() {\n                     onChangeLoc(function() { locIndex = (locIndex + 1) % locs.length; });"}, {"sha": "b151f62c1bff2437f5c416d892fc19445b2c4200", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/829b1a9dd99f9f08faec8b1774798b9025bdf13b/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/829b1a9dd99f9f08faec8b1774798b9025bdf13b/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=829b1a9dd99f9f08faec8b1774798b9025bdf13b", "patch": "@@ -289,7 +289,7 @@ crate fn from_fn_header(header: &rustc_hir::FnHeader) -> HashSet<Qualifiers> {\n \n impl FromWithTcx<clean::Function> for Function {\n     fn from_tcx(function: clean::Function, tcx: TyCtxt<'_>) -> Self {\n-        let clean::Function { decl, generics, header, call_locations: _ } = function;\n+        let clean::Function { decl, generics, header, def_id: _ } = function;\n         Function {\n             decl: decl.into_tcx(tcx),\n             generics: generics.into_tcx(tcx),\n@@ -530,7 +530,7 @@ crate fn from_function_method(\n     has_body: bool,\n     tcx: TyCtxt<'_>,\n ) -> Method {\n-    let clean::Function { header, decl, generics, call_locations: _ } = function;\n+    let clean::Function { header, decl, generics, def_id: _ } = function;\n     Method {\n         decl: decl.into_tcx(tcx),\n         generics: generics.into_tcx(tcx),"}, {"sha": "71a62ec5f0db681e931cec8d9c071394fd8e050f", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/829b1a9dd99f9f08faec8b1774798b9025bdf13b/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/829b1a9dd99f9f08faec8b1774798b9025bdf13b/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=829b1a9dd99f9f08faec8b1774798b9025bdf13b", "patch": "@@ -47,11 +47,13 @@ extern crate rustc_interface;\n extern crate rustc_lexer;\n extern crate rustc_lint;\n extern crate rustc_lint_defs;\n+extern crate rustc_macros;\n extern crate rustc_metadata;\n extern crate rustc_middle;\n extern crate rustc_parse;\n extern crate rustc_passes;\n extern crate rustc_resolve;\n+extern crate rustc_serialize;\n extern crate rustc_session;\n extern crate rustc_span;\n extern crate rustc_target;\n@@ -619,8 +621,22 @@ fn opts() -> Vec<RustcOptGroup> {\n                 \"Make the identifiers in the HTML source code pages navigable\",\n             )\n         }),\n-        unstable(\"scrape-examples\", |o| o.optopt(\"\", \"scrape-examples\", \"\", \"\")),\n-        unstable(\"with-examples\", |o| o.optmulti(\"\", \"with-examples\", \"\", \"\")),\n+        unstable(\"scrape-examples\", |o| {\n+            o.optopt(\n+                \"\",\n+                \"scrape-examples\",\n+                \"\",\n+                \"collect function call information (for use with `--with-examples`)\",\n+            )\n+        }),\n+        unstable(\"with-examples\", |o| {\n+            o.optmulti(\n+                \"\",\n+                \"with-examples\",\n+                \"\",\n+                \"path to function call information (for displaying examples in the documentation)\",\n+            )\n+        }),\n     ]\n }\n "}, {"sha": "a3d61fa4d2c5ecf7499c553fb5bff993084fd4e1", "filename": "src/librustdoc/scrape_examples.rs", "status": "modified", "additions": 68, "deletions": 62, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/829b1a9dd99f9f08faec8b1774798b9025bdf13b/src%2Flibrustdoc%2Fscrape_examples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/829b1a9dd99f9f08faec8b1774798b9025bdf13b/src%2Flibrustdoc%2Fscrape_examples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fscrape_examples.rs?ref=829b1a9dd99f9f08faec8b1774798b9025bdf13b", "patch": "@@ -13,14 +13,19 @@ use rustc_hir::{\n     HirId,\n };\n use rustc_interface::interface;\n+use rustc_macros::{Decodable, Encodable};\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::{self, TyCtxt};\n-use rustc_span::{def_id::DefId, BytePos, FileName, SourceFile};\n-use serde::{Deserialize, Serialize};\n+use rustc_serialize::{\n+    opaque::{Decoder, FileEncoder},\n+    Decodable, Encodable,\n+};\n+use rustc_span::{def_id::DefId, edition::Edition, BytePos, FileName, SourceFile};\n+\n use std::fs;\n use std::path::PathBuf;\n \n-#[derive(Serialize, Deserialize, Debug, Clone)]\n+#[derive(Encodable, Decodable, Debug, Clone)]\n crate struct SyntaxRange {\n     crate byte_span: (u32, u32),\n     crate line_span: (usize, usize),\n@@ -38,7 +43,7 @@ impl SyntaxRange {\n     }\n }\n \n-#[derive(Serialize, Deserialize, Debug, Clone)]\n+#[derive(Encodable, Decodable, Debug, Clone)]\n crate struct CallLocation {\n     crate call_expr: SyntaxRange,\n     crate enclosing_item: SyntaxRange,\n@@ -49,9 +54,10 @@ impl CallLocation {\n         tcx: TyCtxt<'_>,\n         expr_span: rustc_span::Span,\n         expr_id: HirId,\n-        source_file: &rustc_span::SourceFile,\n+        source_file: &SourceFile,\n     ) -> Self {\n-        let enclosing_item_span = tcx.hir().span_with_body(tcx.hir().get_parent_item(expr_id));\n+        let enclosing_item_span =\n+            tcx.hir().span_with_body(tcx.hir().get_parent_item(expr_id)).source_callsite();\n         assert!(enclosing_item_span.contains(expr_span));\n \n         CallLocation {\n@@ -61,15 +67,16 @@ impl CallLocation {\n     }\n }\n \n-#[derive(Serialize, Deserialize, Debug, Clone)]\n+#[derive(Encodable, Decodable, Debug, Clone)]\n crate struct CallData {\n     crate locations: Vec<CallLocation>,\n     crate url: String,\n     crate display_name: String,\n+    crate edition: Edition,\n }\n-crate type DefIdCallKey = String;\n+\n crate type FnCallLocations = FxHashMap<PathBuf, CallData>;\n-crate type AllCallLocations = FxHashMap<DefIdCallKey, FnCallLocations>;\n+crate type AllCallLocations = FxHashMap<String, FnCallLocations>;\n \n /// Visitor for traversing a crate and finding instances of function calls.\n struct FindCalls<'a, 'tcx> {\n@@ -79,7 +86,7 @@ struct FindCalls<'a, 'tcx> {\n     calls: &'a mut AllCallLocations,\n }\n \n-crate fn def_id_call_key(tcx: TyCtxt<'_>, def_id: DefId) -> DefIdCallKey {\n+crate fn def_id_call_key(tcx: TyCtxt<'_>, def_id: DefId) -> String {\n     format!(\n         \"{}{}\",\n         tcx.crate_name(def_id.krate).to_ident_string(),\n@@ -101,30 +108,29 @@ where\n         intravisit::walk_expr(self, ex);\n \n         // Get type of function if expression is a function call\n+        let tcx = self.tcx;\n         let (ty, span) = match ex.kind {\n             hir::ExprKind::Call(f, _) => {\n-                let types = self.tcx.typeck(ex.hir_id.owner);\n+                let types = tcx.typeck(ex.hir_id.owner);\n                 (types.node_type(f.hir_id), ex.span)\n             }\n             hir::ExprKind::MethodCall(_, _, _, span) => {\n-                let types = self.tcx.typeck(ex.hir_id.owner);\n+                let types = tcx.typeck(ex.hir_id.owner);\n                 let def_id = types.type_dependent_def_id(ex.hir_id).unwrap();\n-                (self.tcx.type_of(def_id), span)\n+                (tcx.type_of(def_id), span)\n             }\n             _ => {\n                 return;\n             }\n         };\n \n-        if span.from_expansion() {\n-            return;\n-        }\n+        // We need to get the file the example originates in. If the call is contained\n+        // in a macro, then trace the span back to the macro source (rather than macro definition).\n+        let span = span.source_callsite();\n \n         // Save call site if the function resolves to a concrete definition\n         if let ty::FnDef(def_id, _) = ty.kind() {\n-            let fn_key = def_id_call_key(self.tcx, *def_id);\n-            let entries = self.calls.entry(fn_key).or_insert_with(FxHashMap::default);\n-            let file = self.tcx.sess.source_map().lookup_char_pos(span.lo()).file;\n+            let file = tcx.sess.source_map().lookup_char_pos(span.lo()).file;\n             let file_path = match file.name.clone() {\n                 FileName::Real(real_filename) => real_filename.into_local_path(),\n                 _ => None,\n@@ -133,18 +139,19 @@ where\n             if let Some(file_path) = file_path {\n                 let abs_path = fs::canonicalize(file_path.clone()).unwrap();\n                 let cx = &self.cx;\n-                let location = CallLocation::new(self.tcx, span, ex.hir_id, &file);\n-\n-                entries\n-                    .entry(abs_path)\n-                    .or_insert_with(|| {\n-                        let clean_span = crate::clean::types::Span::new(span);\n-                        let url = cx.href_from_span(clean_span).unwrap();\n-                        let display_name = file_path.display().to_string();\n-                        CallData { locations: Vec::new(), url, display_name }\n-                    })\n-                    .locations\n-                    .push(location);\n+                let mk_call_data = || {\n+                    let clean_span = crate::clean::types::Span::new(span);\n+                    let url = cx.href_from_span(clean_span).unwrap();\n+                    let display_name = file_path.display().to_string();\n+                    let edition = tcx.sess.edition();\n+                    CallData { locations: Vec::new(), url, display_name, edition }\n+                };\n+\n+                let fn_key = def_id_call_key(tcx, *def_id);\n+                let fn_entries = self.calls.entry(fn_key).or_default();\n+\n+                let location = CallLocation::new(tcx, span, ex.hir_id, &file);\n+                fn_entries.entry(abs_path).or_insert_with(mk_call_data).locations.push(location);\n             }\n         }\n     }\n@@ -154,55 +161,54 @@ crate fn run(\n     krate: clean::Crate,\n     renderopts: config::RenderOptions,\n     cache: formats::cache::Cache,\n-    tcx: TyCtxt<'tcx>,\n+    tcx: TyCtxt<'_>,\n     example_path: PathBuf,\n ) -> interface::Result<()> {\n-    let inner = move || {\n+    let inner = move || -> Result<(), String> {\n         // Generates source files for examples\n-        let (cx, _) = Context::init(krate, renderopts, cache, tcx).map_err(|e| format!(\"{}\", e))?;\n+        let (cx, _) = Context::init(krate, renderopts, cache, tcx).map_err(|e| e.to_string())?;\n \n         // Run call-finder on all items\n         let mut calls = FxHashMap::default();\n         let mut finder = FindCalls { calls: &mut calls, tcx, map: tcx.hir(), cx };\n         tcx.hir().krate().visit_all_item_likes(&mut finder.as_deep_visitor());\n \n-        // Save output JSON to provided path\n-        let calls_json = serde_json::to_string(&calls).map_err(|e| format!(\"{}\", e))?;\n-        fs::write(example_path, &calls_json).map_err(|e| format!(\"{}\", e))?;\n+        // Save output to provided path\n+        let mut encoder = FileEncoder::new(example_path).map_err(|e| e.to_string())?;\n+        calls.encode(&mut encoder).map_err(|e| e.to_string())?;\n+        encoder.flush().map_err(|e| e.to_string())?;\n \n         Ok(())\n     };\n \n-    inner().map_err(|e: String| {\n-        eprintln!(\"{}\", e);\n-        rustc_errors::ErrorReported\n-    })\n+    if let Err(e) = inner() {\n+        tcx.sess.fatal(&e);\n+    }\n+\n+    Ok(())\n }\n \n crate fn load_call_locations(\n     with_examples: Vec<String>,\n     diag: &rustc_errors::Handler,\n-) -> Result<Option<AllCallLocations>, i32> {\n-    let each_call_locations = with_examples\n-        .into_iter()\n-        .map(|path| {\n+) -> Result<AllCallLocations, i32> {\n+    let inner = || {\n+        let mut all_calls: AllCallLocations = FxHashMap::default();\n+        for path in with_examples {\n             let bytes = fs::read(&path).map_err(|e| format!(\"{} (for path {})\", e, path))?;\n-            let calls: AllCallLocations =\n-                serde_json::from_slice(&bytes).map_err(|e| format!(\"{}\", e))?;\n-            Ok(calls)\n-        })\n-        .collect::<Result<Vec<_>, _>>()\n-        .map_err(|e: String| {\n-            diag.err(&format!(\"failed to load examples with error: {}\", e));\n-            1\n-        })?;\n-\n-    Ok((each_call_locations.len() > 0).then(|| {\n-        each_call_locations.into_iter().fold(FxHashMap::default(), |mut acc, map| {\n-            for (function, calls) in map.into_iter() {\n-                acc.entry(function).or_insert_with(FxHashMap::default).extend(calls.into_iter());\n+            let mut decoder = Decoder::new(&bytes, 0);\n+            let calls = AllCallLocations::decode(&mut decoder)?;\n+\n+            for (function, fn_calls) in calls.into_iter() {\n+                all_calls.entry(function).or_default().extend(fn_calls.into_iter());\n             }\n-            acc\n-        })\n-    }))\n+        }\n+\n+        Ok(all_calls)\n+    };\n+\n+    inner().map_err(|e: String| {\n+        diag.err(&format!(\"failed to load examples: {}\", e));\n+        1\n+    })\n }"}]}