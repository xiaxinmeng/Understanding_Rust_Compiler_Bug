{"sha": "0b4f0a4caa6e765226c5f9d5609289dccb1072ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiNGYwYTRjYWE2ZTc2NTIyNmM1ZjlkNTYwOTI4OWRjY2IxMDcyY2U=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-31T15:18:59Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-31T15:21:39Z"}, "message": "Add a first stab at a tutorial\n\nYou build it with `cd doc/tutorial; node build.js`, and then point\nyour browser at doc/tutorial/web/index.html. Not remotely ready for\npublicity yet.", "tree": {"sha": "05bc8ec0e832959fa0b0fbd7c1f2a1a1e45dffb5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05bc8ec0e832959fa0b0fbd7c1f2a1a1e45dffb5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b4f0a4caa6e765226c5f9d5609289dccb1072ce", "comment_count": 12, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b4f0a4caa6e765226c5f9d5609289dccb1072ce", "html_url": "https://github.com/rust-lang/rust/commit/0b4f0a4caa6e765226c5f9d5609289dccb1072ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b4f0a4caa6e765226c5f9d5609289dccb1072ce/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80c926c5e253d6db299698cfd4932dbcb61cd1bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/80c926c5e253d6db299698cfd4932dbcb61cd1bd", "html_url": "https://github.com/rust-lang/rust/commit/80c926c5e253d6db299698cfd4932dbcb61cd1bd"}], "stats": {"total": 2672, "additions": 2672, "deletions": 0}, "files": [{"sha": "77a221cdcf452657dc9b5da1a59cf554d5087f8e", "filename": "doc/tutorial/args.md", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/0b4f0a4caa6e765226c5f9d5609289dccb1072ce/doc%2Ftutorial%2Fargs.md", "raw_url": "https://github.com/rust-lang/rust/raw/0b4f0a4caa6e765226c5f9d5609289dccb1072ce/doc%2Ftutorial%2Fargs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fargs.md?ref=0b4f0a4caa6e765226c5f9d5609289dccb1072ce", "patch": "@@ -0,0 +1,126 @@\n+# Argument passing\n+\n+Rust datatypes are not trivial to copy (the way, for example,\n+JavaScript values can be copied by simply taking one or two machine\n+words and plunking them somewhere else). Shared boxes require\n+reference count updates, big records or tags require an arbitrary\n+amount of data to be copied (plus updating the reference counts of\n+shared boxes hanging off them), unique pointers require their origin\n+to be de-initialized.\n+\n+For this reason, the way Rust passes arguments to functions is a bit\n+more involved than it is in most languages. It performs some\n+compile-time cleverness to get rid of most of the cost of copying\n+arguments, and forces you to put in explicit copy operators in the\n+places where it can not.\n+\n+## Safe references\n+\n+The foundation of Rust's argument-passing optimization is the fact\n+that Rust tasks for single-threaded worlds, which share no data with\n+other tasks, and that most data is immutable.\n+\n+Take the following program:\n+\n+    let x = get_really_big_record();\n+    myfunc(x);\n+\n+We want to pass `x` to `myfunc` by pointer (which is easy), *and* we\n+want to ensure that `x` stays intact for the duration of the call\n+(which, in this example, is also easy). So we can just use the\n+existing value as the argument, without copying.\n+\n+There are more involved cases. The call could look like this:\n+\n+    myfunc(x, {|| x = get_another_record(); });\n+\n+Now, if `myfunc` first calls its second argument and then accesses its\n+first argument, it will see a different value from the one that was\n+passed to it.\n+\n+The compiler will insert an implicit copy of `x` in such a case,\n+*except* if `x` contains something mutable, in which case a copy would\n+result in code that behaves differently (if you mutate the copy, `x`\n+stays unchanged). That would be bad, so the compiler will disallow\n+such code.\n+\n+When inserting an implicit copy for something big, the compiler will\n+warn, so that you know that the code is not as efficient as it looks.\n+\n+There are even more tricky cases, in which the Rust compiler is forced\n+to pessimistically assume a value will get mutated, even though it is\n+not sure.\n+\n+    fn for_each(v: [mutable @int], iter: block(@int)) {\n+       for elt in v { iter(elt); }\n+    }\n+\n+For all this function knows, calling `iter` (which is a closure that\n+might have access to the vector that's passed as `v`) could cause the\n+elements in the vector to be mutated, with the effect that it can not\n+guarantee that the boxes will live for the duration of the call. So it\n+has to copy them. In this case, this will happen implicitly (bumping a\n+reference count is considered cheap enough to not warn about it).\n+\n+## The copy operator\n+\n+If the `for_each` function given above were to take a vector of\n+`{mutable a: int}` instead of `@int`, it would not be able to\n+implicitly copy, since if the `iter` function changes a copy of a\n+mutable record, the changes won't be visible in the record itself. If\n+we *do* want to allow copies there, we have to explicitly allow it\n+with the `copy` operator:\n+\n+    type mutrec = {mutable x: int};\n+    fn for_each(v: [mutable mutrec], iter: block(mutrec)) {\n+       for elt in v { iter(copy elt); }\n+    }\n+\n+## Argument passing styles\n+\n+The fact that arguments are conceptually passed by safe reference does\n+not mean all arguments are passed by pointer. Composite types like\n+records and tags *are* passed by pointer, but others, like integers\n+and pointers, are simply passed by value.\n+\n+It is possible, when defining a function, to specify a passing style\n+for a parameter by prefixing the parameter name with a symbol. The\n+most common special style is by-mutable-reference, written `&`:\n+\n+    fn vec_push(&v: [int], elt: int) {\n+        v += [elt];\n+    }\n+\n+This will make it possible for the function to mutate the parameter.\n+Clearly, you are only allowed to pass things that can actually be\n+mutated to such a function.\n+\n+Another style is by-move, which will cause the argument to become\n+de-initialized on the caller side, and give ownership of it to the\n+called function. This is written `-`.\n+\n+Finally, the default passing styles (by-value for non-structural\n+types, by-reference for structural ones) are written `+` for by-value\n+and `&&` for by(-immutable)-reference. It is sometimes necessary to\n+override the defaults. We'll talk more about this when discussing\n+[generics][gens].\n+\n+[gens]: FIXME\n+\n+## Other uses of safe references\n+\n+Safe references are not only used for argument passing. When you\n+destructure on a value in an `alt` expression, or loop over a vector\n+with `for`, variables bound to the inside of the given data structure\n+will use safe references, not copies. This means such references have\n+little overhead, but you'll occasionally have to copy them to ensure\n+safety.\n+\n+    let my_rec = {a: 4, b: [1, 2, 3]};\n+    alt my_rec {\n+      {a, b} {\n+        log b; // This is okay\n+        my_rec = {a: a + 1, b: b + [a]};\n+        log b; // Here reference b has become invalid\n+      }\n+    }"}, {"sha": "7318b2a04000d6e99f695547df57d94048507b17", "filename": "doc/tutorial/build.js", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/0b4f0a4caa6e765226c5f9d5609289dccb1072ce/doc%2Ftutorial%2Fbuild.js", "raw_url": "https://github.com/rust-lang/rust/raw/0b4f0a4caa6e765226c5f9d5609289dccb1072ce/doc%2Ftutorial%2Fbuild.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fbuild.js?ref=0b4f0a4caa6e765226c5f9d5609289dccb1072ce", "patch": "@@ -0,0 +1,82 @@\n+var fs = require(\"fs\"), md = require(\"./lib/markdown\");\n+\n+function markdown(str) { return md.toHTML(str, \"Maruku\"); }\n+\n+function fileDates(file, c) {\n+  function takeTime(str) {\n+    return Number(str.match(/^(\\S+)\\s/)[1]) * 1000;\n+  }\n+  require(\"child_process\").exec(\"git rev-list --timestamp HEAD -- \" + file, function(err, stdout) {\n+    if (err != null) { console.log(\"Failed to run git rev-list\"); return; }\n+    var history = stdout.split(\"\\n\");\n+    if (history.length && history[history.length-1] == \"\") history.pop();\n+    var created = history.length ? takeTime(history[0]) : Date.now();\n+    var modified = created;\n+    if (history.length > 1) modified = takeTime(history[history.length-1]);\n+    c(created, modified);\n+  });\n+}\n+\n+function head(title) {\n+  return \"<html><head><link rel='stylesheet' href='style.css' type='text/css'>\" +\n+    \"<meta http-equiv='Content-Type' content='text/html; charset=utf-8'><title>\" +\n+    title + \"</title></head><body>\\n\";\n+}\n+\n+function foot(created, modified) {\n+  var r = \"<p class='head'>\"\n+  var crStr = formatTime(created), modStr = formatTime(modified);\n+  if (created) r += \"Created \" + crStr;\n+  if (crStr != modStr)\n+    r += (created ? \", l\" : \"L\") + \"ast modified on \" + modStr;\n+  return r + \"</p>\";\n+}\n+\n+function formatTime(tm) {\n+  var d = new Date(tm);\n+  var months = [\"\", \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\",\n+                \"September\", \"October\", \"November\", \"December\"];\n+  return months[d.getMonth()] + \" \" + d.getDate() + \", \" + d.getFullYear();\n+}\n+\n+var files = fs.readFileSync(\"order\", \"utf8\").split(\"\\n\").filter(function(x) { return x; });\n+var max_modified = 0;\n+var sections = [];\n+\n+// Querying git for modified dates has to be done async in node it seems...\n+var queried = 0;\n+for (var i = 0; i < files.length; ++i)\n+  (function(i) { // Make lexical i stable\n+    fileDates(files[i], function(ctime, mtime) {\n+      sections[i] = {\n+        text: fs.readFileSync(files[i] + \".md\", \"utf8\"),\n+        ctime: ctime, mtime: mtime,\n+        name: files[i],\n+      };\n+      max_modified = Math.max(mtime, max_modified);\n+      if (++queried == files.length) buildTutorial();\n+    });\n+  })(i);\n+\n+function htmlName(i) { return sections[i].name + \".html\"; }\n+\n+function buildTutorial() {\n+  var index = head(\"Rust language tutorial\") + \"<div id='content'>\" +\n+    markdown(fs.readFileSync(\"index.md\", \"utf8\")) + \"<ol>\";\n+  for (var i = 0; i < sections.length; ++i) {\n+    var s = sections[i];\n+    var html = htmlName(i);\n+    var title = s.text.match(/^# (.*)\\n/)[1];\n+    index += '<li><a href=\"' + html + '\">' + title + \"</a></li>\";\n+    \n+    var nav = '<p class=\"head\">Section ' + (i + 1) + ' of the Rust language tutorial.<br>';\n+    if (i > 0) nav += '<a href=\"' + htmlName(i-1) + '\">\u00ab Section ' + i + \"</a> | \";\n+    nav += '<a href=\"index.html\">Index</a>';\n+    if (i + 1 < sections.length) nav += ' | <a href=\"' + htmlName(i+1) + '\">Section ' + (i + 2) + \" \u00bb</a>\";\n+    nav += \"</p>\";\n+    fs.writeFileSync(\"web/\" + html, head(title) + nav + '<div id=\"content\">' + markdown(s.text) + \"</div>\" +\n+                     nav + foot(s.ctime, s.mtime) + \"</body></html>\");\n+  }\n+  index += \"</ol></div>\" + foot(null, max_modified) + \"</body></html>\";\n+  fs.writeFileSync(\"web/index.html\", index);\n+}"}, {"sha": "9172cb7303f95144f739b69dd146b7039d5c28ff", "filename": "doc/tutorial/control.md", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/0b4f0a4caa6e765226c5f9d5609289dccb1072ce/doc%2Ftutorial%2Fcontrol.md", "raw_url": "https://github.com/rust-lang/rust/raw/0b4f0a4caa6e765226c5f9d5609289dccb1072ce/doc%2Ftutorial%2Fcontrol.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fcontrol.md?ref=0b4f0a4caa6e765226c5f9d5609289dccb1072ce", "patch": "@@ -0,0 +1,169 @@\n+# Control structures\n+\n+## Conditionals\n+\n+We've seen `if` pass by a few times already. To recap, braces are\n+compulsory, an optional `else` clause can be appended, and multiple\n+`if`/`else` constructs can be chained together:\n+\n+    if false {\n+        std::io::println(\"that's odd\");\n+    } else if true {\n+        std::io::println(\"right\");\n+    } else {\n+        std::io::println(\"neither true nor false\");\n+    }\n+\n+The condition given to an `if` construct *must* be of type boolean (no\n+implicit conversion happens). If the arms return a value, this value\n+must be of the same type for every arm in which control reaches the\n+end of the block:\n+\n+    fn signum(x: int) -> int {\n+        if x < 0 { -1 }\n+        else if x > 0 { 1 }\n+        else { ret 0; }\n+    }\n+\n+The `ret` (return) and its semicolon could have been left out without\n+changing the meaning of this function, but it illustrates that you\n+will not get a type error in this case, although the last arm doesn't\n+have type `int`, because control doesn't reach the end of that arm\n+(`ret` is jumping out of the function).\n+\n+## Pattern matching\n+\n+Rust's `alt` construct is a generalized, cleaned-up version of C's\n+`switch` construct. You provide it with a value and a number of arms,\n+each labelled with a pattern, and it will execute the arm that matches\n+the value.\n+\n+    alt my_number {\n+      0       { std::io::println(\"zero\"); }\n+      1 | 2   { std::io::println(\"one or two\"); }\n+      3 to 10 { std::io::println(\"three to ten\"); }\n+      _       { std::io::println(\"something else\"); }\n+    }\n+\n+There is no 'falling through' between arms, as in C\u2014only one arm is\n+executed, and it doesn't have to explicitly `break` out of the\n+construct when it is finished.\n+\n+The part to the left of each arm is called the pattern. Literals are\n+valid patterns, and will match only their own value. The pipe operator\n+(`|`) can be used to assign multiple patterns to a single arm. Ranges\n+of numeric literal patterns can be expressed with `to`. The underscore\n+(`_`) is a wildcard pattern that matches everything.\n+\n+If the arm with the wildcard pattern was left off in the above\n+example, running it on a number greater than ten (or negative) would\n+cause a run-time failure. When no arm matches, `alt` constructs do not\n+silently fall through\u2014they blow up instead.\n+\n+A powerful application of pattern matching is *destructuring*, where\n+you use the matching to get at the contents of data types. Remember\n+that `(float, float)` is a tuple of two floats:\n+\n+    fn angle(vec: (float, float)) -> float {\n+        alt vec {\n+          (0f, y) when y < 0f { 1.5 * std::math::pi }\n+          (0f, y) { 0.5 * std::math::pi }\n+          (x, y) { std::math::atan(y / x) }\n+        }\n+    }\n+\n+A variable name in a pattern matches everything, *and* binds that name\n+to the value of the matched thing inside of the arm block. Thus, `(0f,\n+y)` matches any tuple whose first element is zero, and binds `y` to\n+the second element. `(x, y)` matches any tuple, and binds both\n+elements to a variable.\n+\n+Any `alt` arm can have a guard clause (written `when EXPR`), which is\n+an expression of type `bool` that determines, after the pattern is\n+found to match, whether the arm is taken or not. The variables bound\n+by the pattern are available in this guard expression.\n+\n+## Destructuring let\n+\n+To a limited extent, it is possible to use destructuring patterns when\n+declaring a variable with `let`. For example, you can say this to\n+extract the fields from a tuple:\n+\n+    let (a, b) = get_tuple_of_two_ints();\n+\n+This will introduce two new variables, `a` and `b`, bound to the\n+content of the tuple.\n+\n+You may only use irrevocable patterns in let bindings, though. Things\n+like literals, which only match a specific value, are not allowed.\n+\n+## Loops\n+\n+`while` produces a loop that runs as long as its given condition\n+(which must have type `bool`) evaluates to true. Inside a loop, the\n+keyword `break` can be used to abort the loop, and `cont` can be used\n+to abort the current iteration and continue with the next.\n+\n+    let x = 5;\n+    while true {\n+        x += x - 3;\n+        if x % 5 == 0 { break; }\n+        std::io::println(std::int::str(x));\n+    }\n+\n+This code prints out a weird sequence of numbers and stops as soon as\n+it finds one that can be divided by five.\n+\n+When iterating over a vector, use `for` instead.\n+\n+    for elt in [\"red\", \"green\", \"blue\"] {\n+        std::io::println(elt);\n+    }\n+\n+This will go over each element in the given vector (a three-element\n+vector of strings, in this case), and repeatedly execute the body with\n+`elt` bound to the current element. You may add an optional type\n+declaration (`elt: str`) for the iteration variable if you want.\n+\n+For more involved iteration, such as going over the elements of a hash\n+table, Rust uses higher-order functions. We'll come back to those in a\n+moment.\n+\n+## Failure\n+\n+The `fail` keyword causes the current [task][tasks] to fail. You use\n+it to indicate unexpected failure, much like you'd use `exit(1)` in a\n+C program, except that in Rust, it is possible for other tasks to\n+handle the failure, allowing the program to continue running.\n+\n+`fail` takes an optional argument, which must have type `str`. Trying\n+to access a vector out of bounds, or running a pattern match with no\n+matching clauses, both result in the equivalent of a `fail`.\n+\n+[tasks]: FIXME\n+\n+## Logging\n+\n+Rust has a built-in logging mechanism, using the `log` statement.\n+Logging is polymorphic\u2014any type of value can be logged, and the\n+runtime will do its best to output a textual representation of the\n+value.\n+\n+    log \"hi\";\n+    log (1, [2.5, -1.8]);\n+\n+By default, you *will not* see the output of your log statements. The\n+environment variable `RUST_LOG` controls which log statements actually\n+get output. It can contain a comma-separated list of paths for modules\n+that should be logged. For example, running `rustc` with\n+`RUST_LOG=rustc::front::attr` will turn on logging in its attribute\n+parser. If you compile a program `foo.rs`, you can set `RUST_LOG` to\n+`foo` to enable its logging.\n+\n+Turned-off `log` statements impose minimal overhead on the code that\n+contains them, so except in code that needs to be really, really fast,\n+you should feel free to scatter around debug logging statements, and\n+leave them in.\n+\n+For interactive debugging, you often want unconditional logging. For\n+this, use `log_err` instead of `log` [FIXME better name]."}, {"sha": "25135787f4ddf212870755c9115373cb11260811", "filename": "doc/tutorial/data.md", "status": "added", "additions": 291, "deletions": 0, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/0b4f0a4caa6e765226c5f9d5609289dccb1072ce/doc%2Ftutorial%2Fdata.md", "raw_url": "https://github.com/rust-lang/rust/raw/0b4f0a4caa6e765226c5f9d5609289dccb1072ce/doc%2Ftutorial%2Fdata.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fdata.md?ref=0b4f0a4caa6e765226c5f9d5609289dccb1072ce", "patch": "@@ -0,0 +1,291 @@\n+# Datatypes\n+\n+Rust datatypes are, by default, immutable. The core datatypes of Rust\n+are structural records and 'tags' (tagged unions, algebraic data\n+types).\n+\n+    type point = {x: float, y: float};\n+    tag shape {\n+        circle(point, float);\n+        rectangle(point, point);\n+    }\n+    let my_shape = circle({x: 0.0, y: 0.0}, 10.0);\n+\n+## Records\n+\n+Rust record types are written `{field1: TYPE, field2: TYPE [,\n+...]}`, and record literals are written in the same way, but with\n+expressions instead of types. They are quite similar to C structs, and\n+even laid out the same way in memory (so you can read from a Rust\n+struct in C, and vice-versa).\n+\n+The dot operator is used to access record fields (`mypoint.x`).\n+\n+Fields that you want to mutate must be explicitly marked as such. For\n+example...\n+\n+    type stack = {content: [int], mutable head: uint};\n+\n+With such a type, you can do `mystack.head += 1u`. When the `mutable`\n+is omitted from the type, such an assignment would result in a type\n+error.\n+\n+To 'update' an immutable record, you use functional record update\n+syntax, by ending a record literal with the keyword `with`:\n+\n+    let newpoint = {x: 0f with oldpoint};\n+\n+This will create a new struct, copying all the fields from `oldpoint`\n+into it, except for the ones that are explicitly set in the literal.\n+\n+Rust record types are *structural*. This means that `{x: float, y:\n+float}` is not just a way to define a new type, but is the actual name\n+of the type. Record types can be used without first defining them. If\n+module A defines `type point = {x: float, y: float}`, and module B,\n+without knowing anything about A, defines a function that returns an\n+`{x: float, y: float}`, you can use that return value as a `point` in\n+module A. (Remember that `type` defines an additional name for a type,\n+not an actual new type.)\n+\n+## Record patterns\n+\n+Records can be destructured on in `alt` patterns. The basic syntax is\n+`{fieldname: pattern, ...}`, but the pattern for a field can be\n+omitted as a shorthand for simply binding the variable with the same\n+name as the field.\n+\n+    alt mypoint {\n+        {x: 0f, y: y_name} { /* Provide sub-patterns for fields */ }\n+        {x, y}             { /* Simply bind the fields */ }\n+    }\n+\n+When you are not interested in all the fields of a record, a record\n+pattern may end with `, _` (as in `{field1, _}`) to indicate that\n+you're ignoring all other fields.\n+\n+## Tags\n+\n+Tags [FIXME terminology] are datatypes that have several different\n+representations. For example, the type shown earlier:\n+\n+    tag shape {\n+        circle(point, float);\n+        rectangle(point, point);\n+    }\n+\n+A value of this type is either a circle\u00b8 in which case it contains a\n+point record and a float, or a rectangle, in which case it contains\n+two point records. The run-time representation of such a value\n+includes an identifier of the actual form that it holds, much like the\n+'tagged union' pattern in C, but with better ergonomics.\n+\n+The above declaration will define a type `shape` that can be used to\n+refer to such shapes, and two functions, `circle` and `rectangle`,\n+which can be used to construct values of the type (taking arguments of\n+the specified types). So `circle({x: 0f, y: 0f}, 10f)` is the way to\n+create a new circle.\n+\n+Tag variants do not have to have parameters. This, for example, is\n+equivalent to an `enum` in C:\n+\n+    tag direction {\n+        north;\n+        east;\n+        south;\n+        west;\n+    };\n+\n+This will define `north`, `east`, `south`, and `west` as constants,\n+all of which have type `direction`.\n+\n+There is a special case for tags with a single variant. These are used\n+to define new types in such a way that the new name is not just a\n+synonym for an existing type, but its own distinct type. If you say:\n+\n+    tag gizmo_id = int;\n+\n+That is a shorthand for this:\n+\n+    tag gizmo_id { gizmo_id(int); }\n+\n+Tag types like this can have their content extracted with the\n+dereference (`*`) unary operator:\n+\n+    let my_gizmo_id = gizmo_id(10);\n+    let id_int: int = *my_gizmo_id;\n+\n+## Tag patterns\n+\n+For tag types with multiple variants, destructuring is the only way to\n+get at their contents. All variant constructors can be used as\n+patterns, as in this definition of `area`:\n+\n+    fn area(sh: shape) -> float {\n+        alt sh {\n+            circle(_, size) { std::math::pi * size * size }\n+            rectangle({x, y}, {x: x2, y: y2}) { (x2 - x) * (y2 - y) }\n+        }\n+    }\n+\n+For variants without arguments, you have to write `variantname.` (with\n+a dot at the end) to match them in a pattern. This to prevent\n+ambiguity between matching a variant name and binding a new variable.\n+\n+    fn point_from_direction(dir: direction) -> point {\n+        alt dir {\n+            north. { {x:  0f, y:  1f} }\n+            east.  { {x:  1f, y:  0f} }\n+            south. { {x:  0f, y: -1f} }\n+            west.  { {x: -1f, y:  0f} }\n+        }\n+    }\n+\n+## Tuples\n+\n+Tuples in Rust behave exactly like records, except that their fields\n+do not have names (and can thus not be accessed with dot notation).\n+Tuples can have any arity except for 0 or 1 (though you may see nil,\n+`()`, as the empty tuple if you like).\n+\n+    let mytup: (int, int, float) = (10, 20, 30.0);\n+    alt mytup {\n+      (a, b, c) { log a + b + (c as int); }\n+    }\n+\n+## Pointers\n+\n+In contrast to a lot of modern languages, record and tag types in Rust\n+are not represented as pointers to allocated memory. They are, like in\n+C and C++, represented directly. This means that if you `let x = {x:\n+1f, y: 1f};`, you are creating a record on the stack. If you then copy\n+it into a data structure, the whole record is copied, not just a\n+pointer.\n+\n+For small records like `point`, this is usually still more efficient\n+than allocating memory and going through a pointer. But for big\n+records, or records with mutable fields, it can be useful to have a\n+single copy on the heap, and refer to that through a pointer.\n+\n+Rust supports several types of pointers. The simplest is the unsafe\n+pointer, written `*TYPE`, which is a completely unchecked pointer\n+type only used in unsafe code (and thus, in typical Rust code, very\n+rarely). The safe pointer types are `@TYPE` for shared,\n+reference-counted boxes, and `~TYPE`, for uniquely-owned pointers.\n+\n+All pointer types can be dereferenced with the `*` unary operator.\n+\n+### Shared boxes\n+\n+Shared boxes are pointers to heap-allocated, reference counted memory.\n+A cycle collector ensures that circular references do not result in\n+memory leaks.\n+\n+Creating a shared box is done by simply applying the binary `@`\n+operator to an expression. The result of the expression will be boxed,\n+resulting in a box of the right type. For example:\n+\n+    let x = @10; // New box, refcount of 1\n+    let y = x; // Copy the pointer, increase refcount\n+    // When x and y go out of scope, refcount goes to 0, box is freed\n+\n+NOTE: We may in the future switch to garbage collection, rather than\n+reference counting, for shared boxes.\n+\n+Shared boxes never cross task boundaries.\n+\n+### Unique boxes\n+\n+In contrast to shared boxes, unique boxes are not reference counted.\n+Instead, it is statically guaranteed that only a single owner of the\n+box exists at any time.\n+\n+    let x = ~10;\n+    let y <- x;\n+\n+This is where the 'move' (`<-`) operator comes in. It is similar to\n+`=`, but it de-initializes its source. Thus, the unique box can move\n+from `x` to `y`, without violating the constraint that it only has a\n+single owner.\n+\n+NOTE: If you do `y = x` instead, the box will be copied. We should\n+emit warning for this, or disallow it entirely, but do not currently\n+do so.\n+\n+Unique boxes, when they do not contain any shared boxes, can be sent\n+to other tasks. The sending task will give up ownership of the box,\n+and won't be able to access it afterwards. The receiving task will\n+become the sole owner of the box.\n+\n+### Mutability\n+\n+All pointer types have a mutable variant, written `@mutable TYPE` or\n+`~mutable TYPE`. Given such a pointer, you can write to its contents\n+by combining the dereference operator with a mutating action.\n+\n+    fn increase_contents(pt: @mutable int) {\n+        *pt += 1;\n+    }\n+\n+## Vectors\n+\n+Rust vectors are always heap-allocated and unique. A value of type\n+`[TYPE]` is represented by a pointer to a section of heap memory\n+containing any number of `TYPE` values.\n+\n+NOTE: This uniqueness is turning out to be quite awkward in practice,\n+and might change.\n+\n+Vector literals are enclosed in square brackets. Dereferencing is done\n+with square brackets (and zero-based):\n+\n+    let myvec = [true, false, true, false];\n+    if myvec[1] { std::io::println(\"boom\"); }\n+\n+By default, vectors are immutable\u2014you can not replace their elements.\n+The type written as `[mutable TYPE]` is a vector with mutable\n+elements. Mutable vector literals are written `[mutable]` (empty) or\n+`[mutable 1, 2, 3]` (with elements).\n+\n+Growing a vector in Rust is not as inefficient as it looks (the `+`\n+operator means concatenation when applied to vector types):\n+\n+    let myvec = [], i = 0;\n+    while i < 100 {\n+        myvec += [i];\n+        i += 1;\n+    }\n+\n+Because a vector is unique, replacing it with a longer one (which is\n+what `+= [i]` does) is indistinguishable from appending to it\n+in-place. Vector representations are optimized to grow\n+logarithmically, so the above code generates about the same amount of\n+copying and reallocation as `push` implementations in most other\n+languages.\n+\n+## Strings\n+\n+The `str` type in Rust is represented exactly the same way as a vector\n+of bytes (`[u8]`), except that it is guaranteed to have a trailing\n+null byte (for interoperability with C APIs).\n+\n+This sequence of bytes is interpreted as an UTF-8 encoded sequence of\n+characters. This has the advantage that UTF-8 encoded I/O (which\n+should really be the goal for modern systems) is very fast, and that\n+strings have, for most intents and purposes, a nicely compact\n+representation. It has the disadvantage that you only get\n+constant-time access by byte, not by character.\n+\n+A lot of algorithms don't need constant-time indexed access (they\n+iterate over all characters, which `std::str::chars` helps with), and\n+for those that do, many don't need actual characters, and can operate\n+on bytes. For algorithms that do really need to index by character,\n+there's the option to convert your string to a character vector (using\n+`std::str::to_chars`).\n+\n+Like vectors, strings are always unique. You can wrap them in a shared\n+box to share them. Unlike vectors, there is no mutable variant of\n+strings. They are always immutable.\n+\n+## Resources\n+\n+FIXME fill this in"}, {"sha": "a8bfacedb0ff70a278052a3c26e6f6e71c04edfb", "filename": "doc/tutorial/func.md", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/0b4f0a4caa6e765226c5f9d5609289dccb1072ce/doc%2Ftutorial%2Ffunc.md", "raw_url": "https://github.com/rust-lang/rust/raw/0b4f0a4caa6e765226c5f9d5609289dccb1072ce/doc%2Ftutorial%2Ffunc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Ffunc.md?ref=0b4f0a4caa6e765226c5f9d5609289dccb1072ce", "patch": "@@ -0,0 +1,88 @@\n+# Functions\n+\n+Functions (like all other static declarations, such as `type`) can be\n+declared both at the top level and inside other functions (or modules,\n+which we'll come back to in moment).\n+\n+The `ret` keyword immediately returns from a function. It is\n+optionally followed by an expression to return. In functions that\n+return `()`, the returned expression can be left off. A function can\n+also return a value by having its top level block produce an\n+expression (by omitting the final semicolon).\n+\n+Some functions (such as the C function `exit`) never return normally.\n+In Rust, these are annotated with return type `!`:\n+\n+    fn dead_end() -> ! { fail; }\n+\n+This helps the compiler avoid spurious error messages. For example,\n+the following code would be a type error if `dead_end` would be\n+expected to return.\n+\n+    let dir = if can_go_left() { left }\n+              else if can_go_right() { right }\n+              else { dead_end(); };\n+\n+## Closures\n+\n+FIXME Either move entirely to fn~/fn@ nomenclature, or fix compiler to\n+accept lambda as a type\n+\n+Normal Rust functions (declared with `fn`) do not close over their\n+environment. A `lambda` expression can be used to create a closure.\n+\n+    fn make_plus_function(x: int) -> fn@(int) -> int {\n+        lambda(y: int) -> int { x + y }\n+    }\n+    let plus_two = make_plus_function(2);\n+    assert plus_two(3) == 5;\n+\n+A `lambda` function *copies* its environment (in this case, the\n+binding for `x`). It can not mutate the closed-over bindings, and will\n+not see changes made to these variables after the `lambda` was\n+evaluated. `lambda`s can be put in data structures and passed around\n+without limitation.\n+\n+A different form of closure is the block. Blocks are written like they\n+are in Ruby: `{|x| x + y}`, the formal parameters between pipes,\n+followed by the function body. They are stack-allocated and properly\n+close over their environment (they see updates to closed over\n+variables, for example). But blocks can only be used in a limited set\n+of circumstances. They can be passed to other functions, but not\n+stored in data structures or returned.\n+\n+    fn map_int(f: block(int) -> int, vec: [int]) -> [int] {\n+        let result = [];\n+        for i in vec { result += [f(i)]; }\n+        ret result;\n+    }\n+    map_int({|x| x + 1 }, [1, 2, 3]);\n+\n+A block with no arguments is written `{|| body(); }`\u2014you can not leave\n+off the pipes.\n+\n+## Iteration\n+\n+Functions taking blocks provide a good way to define non-trivial\n+iteration constructs. For example, this one iterates over a vector\n+of integers backwards:\n+\n+    fn for_rev(v: [int], act: block(int)) {\n+        let i = std::vec::len(v);\n+        while (i > 0u) {\n+            i -= 1u;\n+            act(v[i]);\n+        }\n+    }\n+\n+To run such an iteration, you could do this:\n+\n+    for_rev([1, 2, 3], {|n| log n; });\n+\n+But Rust allows a more pleasant syntax for this situation, with the\n+loop block moved out of the parenthesis and the final semicolon\n+omitted:\n+\n+    for_rev([1, 2, 3]) {|n|\n+        log n;\n+    }"}, {"sha": "4ab121bd7b39c253a6e08b3bbdabc3a49c05b55e", "filename": "doc/tutorial/generic.md", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/0b4f0a4caa6e765226c5f9d5609289dccb1072ce/doc%2Ftutorial%2Fgeneric.md", "raw_url": "https://github.com/rust-lang/rust/raw/0b4f0a4caa6e765226c5f9d5609289dccb1072ce/doc%2Ftutorial%2Fgeneric.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fgeneric.md?ref=0b4f0a4caa6e765226c5f9d5609289dccb1072ce", "patch": "@@ -0,0 +1,104 @@\n+# Generics\n+\n+## Generic functions\n+\n+Throughout this tutorial, I've been defining functions like `map` and\n+`for_rev` to take vectors of integers. It is 2011, and we no longer\n+expect to be defining such functions again and again for every type\n+they apply to. Thus, Rust allows functions and datatypes to have type\n+parameters.\n+\n+    fn for_rev<T>(v: [T], act: block(T)) {\n+        let i = std::vec::len(v);\n+        while i > 0u {\n+            i -= 1u;\n+            act(v[i]);\n+        }\n+    }\n+    \n+    fn map<T, U>(f: block(T) -> U, v: [T]) -> [U] {\n+        let acc = [];\n+        for elt in v { acc += [f(elt)]; }\n+        ret acc;\n+    }\n+\n+When defined in this way, these functions can be applied to any type\n+of vector, as long as the type of the block's argument and the type of\n+the vector's content agree with each other.\n+\n+Inside a parameterized (generic) function, the names of the type\n+parameters (capitalized by convention) stand for opaque types. You\n+can't look inside them, but you can pass them around.\n+\n+## Generic datatypes\n+\n+Generic `type` and `tag` declarations follow the same pattern:\n+\n+    type circular_buf<T> = {start: uint,\n+                            end: uint,\n+                            buf: [mutable T]};\n+    \n+    tag option<T> { some(T); none; }\n+\n+You can then declare a function to take a `circular_buf<u8>` or return\n+an `option<str>`, or even an `option<T>` if the function itself is\n+generic.\n+\n+The `option` type given above exists in the standard library as\n+`std::option::t`, and is the way Rust programs express the thing that\n+in C would be a nullable pointer. The nice part is that you have to\n+explicitly unpack an `option` type, so accidental null pointer\n+dereferences become impossible.\n+\n+## Type-inference and generics\n+\n+Rust's type inferrer works very well with generics, but there are\n+programs that just can't be typed.\n+\n+    let n = none;\n+\n+If you never do anything else with none, the compiler will not be able\n+to assign a type to it. (The same goes for `[]`, in fact.) If you\n+really want to have such a statement, you'll have to write it like\n+this:\n+\n+    let n = none::<int>;\n+\n+Note that, in a value expression, `<` already has a meaning as a\n+comparison operator, so you'll have to write `::<T>` to explicitly\n+give a type to a name that denotes a generic value. Fortunately, this\n+is rarely necessary.\n+\n+## Polymorphic built-ins\n+\n+There are two built-in operations that, perhaps surprisingly, act on\n+values of any type. It was already mentioned earlier that `log` can\n+take any type of value and output it as a string.\n+\n+More interesting is that Rust also defines an ordering for all\n+datatypes, and allows you to meaningfully apply comparison operators\n+(`<`, `>`, `<=`, `>=`, `==`, `!=`) to them. For structural types, the\n+comparison happens left to right, so `\"abc\" < \"bac\"` (but note that\n+`\"bac\" < \"\u00e1c\"`, because the ordering acts on UTF-8 sequences without\n+any sophistication).\n+\n+## Generic functions and argument-passing\n+\n+If you try this program:\n+\n+    fn plus1(x: int) -> int { x + 1 }\n+    map(plus1, [1, 2, 3]);\n+\n+You will get an error message about argument passing styles\n+disagreeing. The reason is that generic types are always passed by\n+pointer, so `map` expects a function that takes its argument by\n+pointer. The `plus1` you defined, however, uses the default, efficient\n+way to pass integers, which is by value. To get around this issue, you\n+have to explicitly mark the arguments to a function that you want to\n+pass to a generic higher-order function as being passed by pointer:\n+\n+    fn plus1(&&x: int) -> int { x + 1 }\n+    map(plus1, [1, 2, 3]);\n+\n+NOTE: This is inconvenient, and we are hoping to get rid of this\n+restriction in the future."}, {"sha": "d8c9be5656807be279c1fe6ca374b37f545eb440", "filename": "doc/tutorial/index.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0b4f0a4caa6e765226c5f9d5609289dccb1072ce/doc%2Ftutorial%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/0b4f0a4caa6e765226c5f9d5609289dccb1072ce/doc%2Ftutorial%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Findex.md?ref=0b4f0a4caa6e765226c5f9d5609289dccb1072ce", "patch": "@@ -0,0 +1 @@\n+# Rust language tutorial"}, {"sha": "9976d7f14e68380957b5210e800d84f98671d310", "filename": "doc/tutorial/intro.md", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0b4f0a4caa6e765226c5f9d5609289dccb1072ce/doc%2Ftutorial%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/0b4f0a4caa6e765226c5f9d5609289dccb1072ce/doc%2Ftutorial%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fintro.md?ref=0b4f0a4caa6e765226c5f9d5609289dccb1072ce", "patch": "@@ -0,0 +1,48 @@\n+# Introduction\n+\n+## Scope\n+\n+This is a tutorial for the Rust programming language. It assumes the\n+reader is familiar with the basic concepts of programming, and has\n+programmed in one or more other languages before. The tutorial covers\n+the whole language, though not with the depth and precision of the\n+[language reference][1].\n+\n+FIXME: maybe also the stdlib?\n+\n+[1]: http://www.rust-lang.org/doc/rust.html\n+\n+## Disclaimer\n+\n+Rust is a language under development. The general flavor of the\n+language has settled, but details will continue to change as it is\n+further refined. Nothing in this tutorial is final, and though we try\n+to keep it updated, it is possible that the text occasionally does not\n+reflect the actual state of the language.\n+\n+## First Impressions\n+\n+Though syntax is something you get used to, an initial encounter with\n+a language can be made easier if the notation looks familiar. Rust is\n+a curly-brace language in the tradition of C, C++, and JavaScript.\n+\n+    fn fac(n: int) -> int {\n+        let result = 1;\n+        while n > 0 {\n+            result *= n;\n+            n -= 1;\n+        }\n+        ret result;\n+    }\n+\n+Several differences from C stand out. Types do not come before, but\n+after variable names (preceded by a colon). In local variables\n+(introduced with `let`), they are optional, and will be inferred when\n+left off. Constructs like `while` and `if` do not require parenthesis\n+around the condition (though they allow them). Also, there's a\n+tendency towards aggressive abbreviation in the keywords\u2014`fn` for\n+function, `ret` for return.\n+\n+You should, however, not conclude that Rust is simply an evolution of\n+C. As will become clear in the rest of this tutorial, it goes into\n+quite a different direction."}, {"sha": "f19d052995353a00e4bd897f915b4f6f35dcb1a0", "filename": "doc/tutorial/lib/markdown.js", "status": "added", "additions": 1466, "deletions": 0, "changes": 1466, "blob_url": "https://github.com/rust-lang/rust/blob/0b4f0a4caa6e765226c5f9d5609289dccb1072ce/doc%2Ftutorial%2Flib%2Fmarkdown.js", "raw_url": "https://github.com/rust-lang/rust/raw/0b4f0a4caa6e765226c5f9d5609289dccb1072ce/doc%2Ftutorial%2Flib%2Fmarkdown.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Flib%2Fmarkdown.js?ref=0b4f0a4caa6e765226c5f9d5609289dccb1072ce", "patch": "@@ -0,0 +1,1466 @@\n+// Released under MIT license\n+// Copyright (c) 2009-2010 Dominic Baggott\n+// Copyright (c) 2009-2010 Ash Berlin\n+// Copyright (c) 2011 Christoph Dorn <christoph@christophdorn.com> (http://www.christophdorn.com)\n+\n+(function( expose ) {\n+\n+/**\n+ *  class Markdown\n+ *\n+ *  Markdown processing in Javascript done right. We have very particular views\n+ *  on what constitutes 'right' which include:\n+ *\n+ *  - produces well-formed HTML (this means that em and strong nesting is\n+ *    important)\n+ *\n+ *  - has an intermediate representation to allow processing of parsed data (We\n+ *    in fact have two, both as [JsonML]: a markdown tree and an HTML tree).\n+ *\n+ *  - is easily extensible to add new dialects without having to rewrite the\n+ *    entire parsing mechanics\n+ *\n+ *  - has a good test suite\n+ *\n+ *  This implementation fulfills all of these (except that the test suite could\n+ *  do with expanding to automatically run all the fixtures from other Markdown\n+ *  implementations.)\n+ *\n+ *  ##### Intermediate Representation\n+ *\n+ *  *TODO* Talk about this :) Its JsonML, but document the node names we use.\n+ *\n+ *  [JsonML]: http://jsonml.org/ \"JSON Markup Language\"\n+ **/\n+var Markdown = expose.Markdown = function Markdown(dialect) {\n+  switch (typeof dialect) {\n+    case \"undefined\":\n+      this.dialect = Markdown.dialects.Gruber;\n+      break;\n+    case \"object\":\n+      this.dialect = dialect;\n+      break;\n+    default:\n+      if (dialect in Markdown.dialects) {\n+        this.dialect = Markdown.dialects[dialect];\n+      }\n+      else {\n+        throw new Error(\"Unknown Markdown dialect '\" + String(dialect) + \"'\");\n+      }\n+      break;\n+  }\n+  this.em_state = [];\n+  this.strong_state = [];\n+  this.debug_indent = \"\";\n+}\n+\n+/**\n+ *  parse( markdown, [dialect] ) -> JsonML\n+ *  - markdown (String): markdown string to parse\n+ *  - dialect (String | Dialect): the dialect to use, defaults to gruber\n+ *\n+ *  Parse `markdown` and return a markdown document as a Markdown.JsonML tree.\n+ **/\n+expose.parse = function( source, dialect ) {\n+  // dialect will default if undefined\n+  var md = new Markdown( dialect );\n+  return md.toTree( source );\n+}\n+\n+/**\n+ *  toHTML( markdown, [dialect]  ) -> String\n+ *  toHTML( md_tree ) -> String\n+ *  - markdown (String): markdown string to parse\n+ *  - md_tree (Markdown.JsonML): parsed markdown tree\n+ *\n+ *  Take markdown (either as a string or as a JsonML tree) and run it through\n+ *  [[toHTMLTree]] then turn it into a well-formated HTML fragment.\n+ **/\n+expose.toHTML = function toHTML( source , dialect , options ) {\n+  var input = expose.toHTMLTree( source , dialect , options );\n+\n+  return expose.renderJsonML( input );\n+}\n+\n+/**\n+ *  toHTMLTree( markdown, [dialect] ) -> JsonML\n+ *  toHTMLTree( md_tree ) -> JsonML\n+ *  - markdown (String): markdown string to parse\n+ *  - dialect (String | Dialect): the dialect to use, defaults to gruber\n+ *  - md_tree (Markdown.JsonML): parsed markdown tree\n+ *\n+ *  Turn markdown into HTML, represented as a JsonML tree. If a string is given\n+ *  to this function, it is first parsed into a markdown tree by calling\n+ *  [[parse]].\n+ **/\n+expose.toHTMLTree = function toHTMLTree( input, dialect , options ) {\n+  // convert string input to an MD tree\n+  if ( typeof input ===\"string\" ) input = this.parse( input, dialect );\n+\n+  // Now convert the MD tree to an HTML tree\n+\n+  // remove references from the tree\n+  var attrs = extract_attr( input ),\n+      refs = {};\n+\n+  if ( attrs && attrs.references ) {\n+    refs = attrs.references;\n+  }\n+\n+  var html = convert_tree_to_html( input, refs , options );\n+  merge_text_nodes( html );\n+  return html;\n+}\n+\n+var mk_block = Markdown.mk_block = function(block, trail, line) {\n+  // Be helpful for default case in tests.\n+  if ( arguments.length == 1 ) trail = \"\\n\\n\";\n+\n+  var s = new String(block);\n+  s.trailing = trail;\n+  // To make it clear its not just a string\n+  s.toSource = function() {\n+    return \"Markdown.mk_block( \" +\n+            uneval(block) +\n+            \", \" +\n+            uneval(trail) +\n+            \", \" +\n+            uneval(line) +\n+            \" )\"\n+  }\n+\n+  if (line != undefined)\n+    s.lineNumber = line;\n+\n+  return s;\n+}\n+\n+function count_lines( str ) {\n+  var n = 0, i = -1;;\n+  while ( ( i = str.indexOf('\\n', i+1) ) != -1) n++;\n+  return n;\n+}\n+\n+// Internal - split source into rough blocks\n+Markdown.prototype.split_blocks = function splitBlocks( input, startLine ) {\n+  // [\\s\\S] matches _anything_ (newline or space)\n+  var re = /([\\s\\S]+?)($|\\n(?:\\s*\\n|$)+)/g,\n+      blocks = [],\n+      m;\n+\n+  var line_no = 1;\n+\n+  if ( ( m = /^(\\s*\\n)/.exec(input) ) != null ) {\n+    // skip (but count) leading blank lines\n+    line_no += count_lines( m[0] );\n+    re.lastIndex = m[0].length;\n+  }\n+\n+  while ( ( m = re.exec(input) ) != null ) {\n+    blocks.push( mk_block( m[1], m[2], line_no ) );\n+    line_no += count_lines( m[0] );\n+  }\n+\n+  return blocks;\n+}\n+\n+/**\n+ *  Markdown#processBlock( block, next ) -> undefined | [ JsonML, ... ]\n+ *  - block (String): the block to process\n+ *  - next (Array): the following blocks\n+ *\n+ * Process `block` and return an array of JsonML nodes representing `block`.\n+ *\n+ * It does this by asking each block level function in the dialect to process\n+ * the block until one can. Succesful handling is indicated by returning an\n+ * array (with zero or more JsonML nodes), failure by a false value.\n+ *\n+ * Blocks handlers are responsible for calling [[Markdown#processInline]]\n+ * themselves as appropriate.\n+ *\n+ * If the blocks were split incorrectly or adjacent blocks need collapsing you\n+ * can adjust `next` in place using shift/splice etc.\n+ *\n+ * If any of this default behaviour is not right for the dialect, you can\n+ * define a `__call__` method on the dialect that will get invoked to handle\n+ * the block processing.\n+ */\n+Markdown.prototype.processBlock = function processBlock( block, next ) {\n+  var cbs = this.dialect.block,\n+      ord = cbs.__order__;\n+\n+  if ( \"__call__\" in cbs ) {\n+    return cbs.__call__.call(this, block, next);\n+  }\n+\n+  for ( var i = 0; i < ord.length; i++ ) {\n+    //D:this.debug( \"Testing\", ord[i] );\n+    var res = cbs[ ord[i] ].call( this, block, next );\n+    if ( res ) {\n+      //D:this.debug(\"  matched\");\n+      if ( !isArray(res) || ( res.length > 0 && !( isArray(res[0]) ) ) )\n+        this.debug(ord[i], \"didn't return a proper array\");\n+      //D:this.debug( \"\" );\n+      return res;\n+    }\n+  }\n+\n+  // Uhoh! no match! Should we throw an error?\n+  return [];\n+}\n+\n+Markdown.prototype.processInline = function processInline( block ) {\n+  return this.dialect.inline.__call__.call( this, String( block ) );\n+}\n+\n+/**\n+ *  Markdown#toTree( source ) -> JsonML\n+ *  - source (String): markdown source to parse\n+ *\n+ *  Parse `source` into a JsonML tree representing the markdown document.\n+ **/\n+// custom_tree means set this.tree to `custom_tree` and restore old value on return\n+Markdown.prototype.toTree = function toTree( source, custom_root ) {\n+  var blocks = source instanceof Array\n+             ? source\n+             : this.split_blocks( source );\n+\n+  // Make tree a member variable so its easier to mess with in extensions\n+  var old_tree = this.tree;\n+  try {\n+    this.tree = custom_root || this.tree || [ \"markdown\" ];\n+\n+    blocks:\n+    while ( blocks.length ) {\n+      var b = this.processBlock( blocks.shift(), blocks );\n+\n+      // Reference blocks and the like won't return any content\n+      if ( !b.length ) continue blocks;\n+\n+      this.tree.push.apply( this.tree, b );\n+    }\n+    return this.tree;\n+  }\n+  finally {\n+    if ( custom_root )\n+      this.tree = old_tree;\n+  }\n+\n+}\n+\n+// Noop by default\n+Markdown.prototype.debug = function () {\n+  var args = Array.prototype.slice.call( arguments);\n+  args.unshift(this.debug_indent);\n+  if (typeof print !== \"undefined\")\n+      print.apply( print, args );\n+  if (typeof console !== \"undefined\" && typeof console.log !== \"undefined\")\n+      console.log.apply( null, args );\n+}\n+\n+Markdown.prototype.loop_re_over_block = function( re, block, cb ) {\n+  // Dont use /g regexps with this\n+  var m,\n+      b = block.valueOf();\n+\n+  while ( b.length && (m = re.exec(b) ) != null) {\n+    b = b.substr( m[0].length );\n+    cb.call(this, m);\n+  }\n+  return b;\n+}\n+\n+/**\n+ * Markdown.dialects\n+ *\n+ * Namespace of built-in dialects.\n+ **/\n+Markdown.dialects = {};\n+\n+/**\n+ * Markdown.dialects.Gruber\n+ *\n+ * The default dialect that follows the rules set out by John Gruber's\n+ * markdown.pl as closely as possible. Well actually we follow the behaviour of\n+ * that script which in some places is not exactly what the syntax web page\n+ * says.\n+ **/\n+Markdown.dialects.Gruber = {\n+  block: {\n+    atxHeader: function atxHeader( block, next ) {\n+      var m = block.match( /^(#{1,6})\\s*(.*?)\\s*#*\\s*(?:\\n|$)/ );\n+\n+      if ( !m ) return undefined;\n+\n+      var header = [ \"header\", { level: m[ 1 ].length } ];\n+      Array.prototype.push.apply(header, this.processInline(m[ 2 ]));\n+\n+      if ( m[0].length < block.length )\n+        next.unshift( mk_block( block.substr( m[0].length ), block.trailing, block.lineNumber + 2 ) );\n+\n+      return [ header ];\n+    },\n+\n+    setextHeader: function setextHeader( block, next ) {\n+      var m = block.match( /^(.*)\\n([-=])\\2\\2+(?:\\n|$)/ );\n+\n+      if ( !m ) return undefined;\n+\n+      var level = ( m[ 2 ] === \"=\" ) ? 1 : 2;\n+      var header = [ \"header\", { level : level }, m[ 1 ] ];\n+\n+      if ( m[0].length < block.length )\n+        next.unshift( mk_block( block.substr( m[0].length ), block.trailing, block.lineNumber + 2 ) );\n+\n+      return [ header ];\n+    },\n+\n+    code: function code( block, next ) {\n+      // |    Foo\n+      // |bar\n+      // should be a code block followed by a paragraph. Fun\n+      //\n+      // There might also be adjacent code block to merge.\n+\n+      var ret = [],\n+          re = /^(?: {0,3}\\t| {4})(.*)\\n?/,\n+          lines;\n+\n+      // 4 spaces + content\n+      var m = block.match( re );\n+\n+      if ( !m ) return undefined;\n+\n+      block_search:\n+      do {\n+        // Now pull out the rest of the lines\n+        var b = this.loop_re_over_block(\n+                  re, block.valueOf(), function( m ) { ret.push( m[1] ) } );\n+\n+        if (b.length) {\n+          // Case alluded to in first comment. push it back on as a new block\n+          next.unshift( mk_block(b, block.trailing) );\n+          break block_search;\n+        }\n+        else if (next.length) {\n+          // Check the next block - it might be code too\n+          var m = next[0].match( re );\n+\n+          if ( !m ) break block_search;\n+\n+          // Pull how how many blanks lines follow - minus two to account for .join\n+          ret.push ( block.trailing.replace(/[^\\n]/g, '').substring(2) );\n+\n+          block = next.shift();\n+        }\n+        else\n+          break block_search;\n+      } while (true);\n+\n+      return [ [ \"code_block\", ret.join(\"\\n\") ] ];\n+    },\n+\n+    horizRule: function horizRule( block, next ) {\n+      // this needs to find any hr in the block to handle abutting blocks\n+      var m = block.match( /^(?:([\\s\\S]*?)\\n)?[ \\t]*([-_*])(?:[ \\t]*\\2){2,}[ \\t]*(?:\\n([\\s\\S]*))?$/ );\n+\n+      if ( !m ) {\n+        return undefined;\n+      }\n+\n+      var jsonml = [ [ \"hr\" ] ];\n+\n+      // if there's a leading abutting block, process it\n+      if ( m[ 1 ] ) {\n+        jsonml.unshift.apply( jsonml, this.processBlock( m[ 1 ], [] ) );\n+      }\n+\n+      // if there's a trailing abutting block, stick it into next\n+      if ( m[ 3 ] ) {\n+        next.unshift( mk_block( m[ 3 ] ) );\n+      }\n+\n+      return jsonml;\n+    },\n+\n+    // There are two types of lists. Tight and loose. Tight lists have no whitespace\n+    // between the items (and result in text just in the <li>) and loose lists,\n+    // which have an empty line between list items, resulting in (one or more)\n+    // paragraphs inside the <li>.\n+    //\n+    // There are all sorts weird edge cases about the original markdown.pl's\n+    // handling of lists:\n+    //\n+    // * Nested lists are supposed to be indented by four chars per level. But\n+    //   if they aren't, you can get a nested list by indenting by less than\n+    //   four so long as the indent doesn't match an indent of an existing list\n+    //   item in the 'nest stack'.\n+    //\n+    // * The type of the list (bullet or number) is controlled just by the\n+    //    first item at the indent. Subsequent changes are ignored unless they\n+    //    are for nested lists\n+    //\n+    lists: (function( ) {\n+      // Use a closure to hide a few variables.\n+      var any_list = \"[*+-]|\\\\d\\\\.\",\n+          bullet_list = /[*+-]/,\n+          number_list = /\\d+\\./,\n+          // Capture leading indent as it matters for determining nested lists.\n+          is_list_re = new RegExp( \"^( {0,3})(\" + any_list + \")[ \\t]+\" ),\n+          indent_re = \"(?: {0,3}\\\\t| {4})\";\n+\n+      // TODO: Cache this regexp for certain depths.\n+      // Create a regexp suitable for matching an li for a given stack depth\n+      function regex_for_depth( depth ) {\n+\n+        return new RegExp(\n+          // m[1] = indent, m[2] = list_type\n+          \"(?:^(\" + indent_re + \"{0,\" + depth + \"} {0,3})(\" + any_list + \")\\\\s+)|\" +\n+          // m[3] = cont\n+          \"(^\" + indent_re + \"{0,\" + (depth-1) + \"}[ ]{0,4})\"\n+        );\n+      }\n+      function expand_tab( input ) {\n+        return input.replace( / {0,3}\\t/g, \"    \" );\n+      }\n+\n+      // Add inline content `inline` to `li`. inline comes from processInline\n+      // so is an array of content\n+      function add(li, loose, inline, nl) {\n+        if (loose) {\n+            li.push( [ \"para\" ].concat(inline) );\n+          return;\n+        }\n+        // Hmmm, should this be any block level element or just paras?\n+        var add_to = li[li.length -1] instanceof Array && li[li.length - 1][0] == \"para\"\n+                   ? li[li.length -1]\n+                   : li;\n+\n+        // If there is already some content in this list, add the new line in\n+        if (nl && li.length > 1) inline.unshift(nl);\n+\n+        for (var i=0; i < inline.length; i++) {\n+          var what = inline[i],\n+              is_str = typeof what == \"string\";\n+          if (is_str && add_to.length > 1 && typeof add_to[add_to.length-1] == \"string\" )\n+          {\n+            add_to[ add_to.length-1 ] += what;\n+          }\n+          else {\n+            add_to.push( what );\n+          }\n+        }\n+      }\n+\n+      // contained means have an indent greater than the current one. On\n+      // *every* line in the block\n+      function get_contained_blocks( depth, blocks ) {\n+\n+        var re = new RegExp( \"^(\" + indent_re + \"{\" + depth + \"}.*?\\\\n?)*$\" ),\n+            replace = new RegExp(\"^\" + indent_re + \"{\" + depth + \"}\", \"gm\"),\n+            ret = [];\n+\n+        while ( blocks.length > 0 ) {\n+          if ( re.exec( blocks[0] ) ) {\n+            var b = blocks.shift(),\n+                // Now remove that indent\n+                x = b.replace( replace, \"\");\n+\n+            ret.push( mk_block( x, b.trailing, b.lineNumber ) );\n+          }\n+          break;\n+        }\n+        return ret;\n+      }\n+\n+      // passed to stack.forEach to turn list items up the stack into paras\n+      function paragraphify(s, i, stack) {\n+        var list = s.list;\n+        var last_li = list[list.length-1];\n+\n+        if (last_li[1] instanceof Array && last_li[1][0] == \"para\") {\n+          return;\n+        }\n+        if (i+1 == stack.length) {\n+          // Last stack frame\n+          // Keep the same array, but replace the contents\n+          last_li.push( [\"para\"].concat( last_li.splice(1) ) );\n+        }\n+        else {\n+          var sublist = last_li.pop();\n+          last_li.push( [\"para\"].concat( last_li.splice(1) ), sublist );\n+        }\n+      }\n+\n+      // The matcher function\n+      return function( block, next ) {\n+        var m = block.match( is_list_re );\n+        if ( !m ) return undefined;\n+\n+        function make_list( m ) {\n+          var list = bullet_list.exec( m[2] )\n+                   ? [\"bulletlist\"]\n+                   : [\"numberlist\"];\n+\n+          stack.push( { list: list, indent: m[1] } );\n+          return list;\n+        }\n+\n+\n+        var stack = [], // Stack of lists for nesting.\n+            list = make_list( m ),\n+            last_li,\n+            loose = false,\n+            ret = [ stack[0].list ];\n+\n+        // Loop to search over block looking for inner block elements and loose lists\n+        loose_search:\n+        while( true ) {\n+          // Split into lines preserving new lines at end of line\n+          var lines = block.split( /(?=\\n)/ );\n+\n+          // We have to grab all lines for a li and call processInline on them\n+          // once as there are some inline things that can span lines.\n+          var li_accumulate = \"\";\n+\n+          // Loop over the lines in this block looking for tight lists.\n+          tight_search:\n+          for (var line_no=0; line_no < lines.length; line_no++) {\n+            var nl = \"\",\n+                l = lines[line_no].replace(/^\\n/, function(n) { nl = n; return \"\" });\n+\n+            // TODO: really should cache this\n+            var line_re = regex_for_depth( stack.length );\n+\n+            m = l.match( line_re );\n+            //print( \"line:\", uneval(l), \"\\nline match:\", uneval(m) );\n+\n+            // We have a list item\n+            if ( m[1] !== undefined ) {\n+              // Process the previous list item, if any\n+              if ( li_accumulate.length ) {\n+                add( last_li, loose, this.processInline( li_accumulate ), nl );\n+                // Loose mode will have been dealt with. Reset it\n+                loose = false;\n+                li_accumulate = \"\";\n+              }\n+\n+              m[1] = expand_tab( m[1] );\n+              var wanted_depth = Math.floor(m[1].length/4)+1;\n+              //print( \"want:\", wanted_depth, \"stack:\", stack.length);\n+              if ( wanted_depth > stack.length ) {\n+                // Deep enough for a nested list outright\n+                //print ( \"new nested list\" );\n+                list = make_list( m );\n+                last_li.push( list );\n+                last_li = list[1] = [ \"listitem\" ];\n+              }\n+              else {\n+                // We aren't deep enough to be strictly a new level. This is\n+                // where Md.pl goes nuts. If the indent matches a level in the\n+                // stack, put it there, else put it one deeper then the\n+                // wanted_depth deserves.\n+                var found = stack.some(function(s, i) {\n+                  if ( s.indent != m[1] ) return false;\n+                  list = s.list;     // Found the level we want\n+                  stack.splice(i+1); // Remove the others\n+                  //print(\"found\");\n+                  return true;       // And stop looping\n+                });\n+\n+                if (!found) {\n+                  //print(\"not found. l:\", uneval(l));\n+                  wanted_depth++;\n+                  if (wanted_depth <= stack.length) {\n+                    stack.splice(wanted_depth);\n+                    //print(\"Desired depth now\", wanted_depth, \"stack:\", stack.length);\n+                    list = stack[wanted_depth-1].list;\n+                    //print(\"list:\", uneval(list) );\n+                  }\n+                  else {\n+                    //print (\"made new stack for messy indent\");\n+                    list = make_list(m);\n+                    last_li.push(list);\n+                  }\n+                }\n+\n+                //print( uneval(list), \"last\", list === stack[stack.length-1].list );\n+                last_li = [ \"listitem\" ];\n+                list.push(last_li);\n+              } // end depth of shenegains\n+              nl = \"\";\n+            }\n+\n+            // Add content\n+            if (l.length > m[0].length) {\n+              li_accumulate += nl + l.substr( m[0].length );\n+            }\n+          } // tight_search\n+\n+          if ( li_accumulate.length ) {\n+            add( last_li, loose, this.processInline( li_accumulate ), nl );\n+            // Loose mode will have been dealt with. Reset it\n+            loose = false;\n+            li_accumulate = \"\";\n+          }\n+\n+          // Look at the next block - we might have a loose list. Or an extra\n+          // paragraph for the current li\n+          var contained = get_contained_blocks( stack.length, next );\n+\n+          // Deal with code blocks or properly nested lists\n+          if (contained.length > 0) {\n+            // Make sure all listitems up the stack are paragraphs\n+            stack.forEach( paragraphify, this );\n+\n+            last_li.push.apply( last_li, this.toTree( contained, [] ) );\n+          }\n+\n+          var next_block = next[0] && next[0].valueOf() || \"\";\n+\n+          if ( next_block.match(is_list_re) || next_block.match( /^ / ) ) {\n+            block = next.shift();\n+\n+            // Check for an HR following a list: features/lists/hr_abutting\n+            var hr = this.dialect.block.horizRule( block, next );\n+\n+            if (hr) {\n+              ret.push.apply(ret, hr);\n+              break;\n+            }\n+\n+            // Make sure all listitems up the stack are paragraphs\n+            stack.forEach( paragraphify , this );\n+\n+            loose = true;\n+            continue loose_search;\n+          }\n+          break;\n+        } // loose_search\n+\n+        return ret;\n+      }\n+    })(),\n+\n+    blockquote: function blockquote( block, next ) {\n+      if ( !block.match( /^>/m ) )\n+        return undefined;\n+\n+      var jsonml = [];\n+\n+      // separate out the leading abutting block, if any\n+      if ( block[ 0 ] != \">\" ) {\n+        var lines = block.split( /\\n/ ),\n+            prev = [];\n+\n+        // keep shifting lines until you find a crotchet\n+        while ( lines.length && lines[ 0 ][ 0 ] != \">\" ) {\n+            prev.push( lines.shift() );\n+        }\n+\n+        // reassemble!\n+        block = lines.join( \"\\n\" );\n+        jsonml.push.apply( jsonml, this.processBlock( prev.join( \"\\n\" ), [] ) );\n+      }\n+\n+      // if the next block is also a blockquote merge it in\n+      while ( next.length && next[ 0 ][ 0 ] == \">\" ) {\n+        var b = next.shift();\n+        block += block.trailing + b;\n+        block.trailing = b.trailing;\n+      }\n+\n+      // Strip off the leading \"> \" and re-process as a block.\n+      var input = block.replace( /^> ?/gm, '' ),\n+          old_tree = this.tree;\n+      jsonml.push( this.toTree( input, [ \"blockquote\" ] ) );\n+\n+      return jsonml;\n+    },\n+\n+    referenceDefn: function referenceDefn( block, next) {\n+      var re = /^\\s*\\[(.*?)\\]:\\s*(\\S+)(?:\\s+(?:(['\"])(.*?)\\3|\\((.*?)\\)))?\\n?/;\n+      // interesting matches are [ , ref_id, url, , title, title ]\n+\n+      if ( !block.match(re) )\n+        return undefined;\n+\n+      // make an attribute node if it doesn't exist\n+      if ( !extract_attr( this.tree ) ) {\n+        this.tree.splice( 1, 0, {} );\n+      }\n+\n+      var attrs = extract_attr( this.tree );\n+\n+      // make a references hash if it doesn't exist\n+      if ( attrs.references === undefined ) {\n+        attrs.references = {};\n+      }\n+\n+      var b = this.loop_re_over_block(re, block, function( m ) {\n+\n+        if ( m[2] && m[2][0] == '<' && m[2][m[2].length-1] == '>' )\n+          m[2] = m[2].substring( 1, m[2].length - 1 );\n+\n+        var ref = attrs.references[ m[1].toLowerCase() ] = {\n+          href: m[2]\n+        };\n+\n+        if (m[4] !== undefined)\n+          ref.title = m[4];\n+        else if (m[5] !== undefined)\n+          ref.title = m[5];\n+\n+      } );\n+\n+      if (b.length)\n+        next.unshift( mk_block( b, block.trailing ) );\n+\n+      return [];\n+    },\n+\n+    para: function para( block, next ) {\n+      // everything's a para!\n+      return [ [\"para\"].concat( this.processInline( block ) ) ];\n+    }\n+  }\n+}\n+\n+Markdown.dialects.Gruber.inline = {\n+    __call__: function inline( text, patterns ) {\n+      // Hmmm - should this function be directly in Md#processInline, or\n+      // conversely, should Md#processBlock be moved into block.__call__ too\n+      var out = [ ],\n+          m,\n+          // Look for the next occurange of a special character/pattern\n+          re = new RegExp( \"([\\\\s\\\\S]*?)(\" + (patterns.source || patterns) + \")\", \"g\" ),\n+          lastIndex = 0;\n+\n+      //D:var self = this;\n+      //D:self.debug(\"processInline:\", uneval(text) );\n+      function add(x) {\n+        //D:self.debug(\"  adding output\", uneval(x));\n+        if (typeof x == \"string\" && typeof out[out.length-1] == \"string\")\n+          out[ out.length-1 ] += x;\n+        else\n+          out.push(x);\n+      }\n+\n+      while ( ( m = re.exec(text) ) != null) {\n+        if ( m[1] ) add( m[1] ); // Some un-interesting text matched\n+        else        m[1] = { length: 0 }; // Or there was none, but make m[1].length == 0\n+\n+        var res;\n+        if ( m[2] in this.dialect.inline ) {\n+          res = this.dialect.inline[ m[2] ].call(\n+                    this,\n+                    text.substr( m.index + m[1].length ), m, out );\n+        }\n+        // Default for now to make dev easier. just slurp special and output it.\n+        res = res || [ m[2].length, m[2] ];\n+\n+        var len = res.shift();\n+        // Update how much input was consumed\n+        re.lastIndex += ( len - m[2].length );\n+\n+        // Add children\n+        res.forEach(add);\n+\n+        lastIndex = re.lastIndex;\n+      }\n+\n+      // Add last 'boring' chunk\n+      if ( text.length > lastIndex )\n+        add( text.substr( lastIndex ) );\n+\n+      return out;\n+    },\n+\n+    \"\\\\\": function escaped( text ) {\n+      // [ length of input processed, node/children to add... ]\n+      // Only esacape: \\ ` * _ { } [ ] ( ) # * + - . !\n+      if ( text.match( /^\\\\[\\\\`\\*_{}\\[\\]()#\\+.!\\-]/ ) )\n+        return [ 2, text[1] ];\n+      else\n+        // Not an esacpe\n+        return [ 1, \"\\\\\" ];\n+    },\n+\n+    \"![\": function image( text ) {\n+      // ![Alt text](/path/to/img.jpg \"Optional title\")\n+      //      1          2            3       4         <--- captures\n+      var m = text.match( /^!\\[(.*?)\\][ \\t]*\\([ \\t]*(\\S*)(?:[ \\t]+([\"'])(.*?)\\3)?[ \\t]*\\)/ );\n+\n+      if ( m ) {\n+        if ( m[2] && m[2][0] == '<' && m[2][m[2].length-1] == '>' )\n+          m[2] = m[2].substring( 1, m[2].length - 1 );\n+\n+        m[2] == this.dialect.inline.__call__.call( this, m[2], /\\\\/ )[0];\n+\n+        var attrs = { alt: m[1], href: m[2] || \"\" };\n+        if ( m[4] !== undefined)\n+          attrs.title = m[4];\n+\n+        return [ m[0].length, [ \"img\", attrs ] ];\n+      }\n+\n+      // ![Alt text][id]\n+      m = text.match( /^!\\[(.*?)\\][ \\t]*\\[(.*?)\\]/ );\n+\n+      if ( m ) {\n+        // We can't check if the reference is known here as it likely wont be\n+        // found till after. Check it in md tree->hmtl tree conversion\n+        return [ m[0].length, [ \"img_ref\", { alt: m[1], ref: m[2].toLowerCase(), text: m[0] } ] ];\n+      }\n+\n+      // Just consume the '!['\n+      return [ 2, \"![\" ];\n+    },\n+\n+    \"[\": function link( text ) {\n+      // [link text](/path/to/img.jpg \"Optional title\")\n+      //      1          2            3       4         <--- captures\n+      var m = text.match( /^\\[([\\s\\S]*?)\\][ \\t]*\\([ \\t]*(\\S+)(?:[ \\t]+([\"'])(.*?)\\3)?[ \\t]*\\)/ );\n+\n+      if ( m ) {\n+        if ( m[2] && m[2][0] == '<' && m[2][m[2].length-1] == '>' )\n+          m[2] = m[2].substring( 1, m[2].length - 1 );\n+\n+        // Process escapes only\n+        m[2] = this.dialect.inline.__call__.call( this, m[2], /\\\\/ )[0];\n+\n+        var attrs = { href: m[2] || \"\" };\n+        if ( m[4] !== undefined)\n+          attrs.title = m[4];\n+\n+        var link = [ \"link\", attrs ];\n+        Array.prototype.push.apply( link, this.processInline( m[1] ) );\n+        return [ m[0].length, link ];\n+      }\n+\n+      // [Alt text][id]\n+      // [Alt text] [id]\n+      // [id]\n+      m = text.match( /^\\[([\\s\\S]*?)\\](?: ?\\[(.*?)\\])?/ );\n+\n+      if ( m ) {\n+        // [id] case, text == id\n+        if ( m[2] === undefined || m[2] === \"\" ) m[2] = m[1];\n+\n+        attrs = { ref: m[ 2 ].toLowerCase(),  original: m[ 0 ] };\n+        link = [ \"link_ref\", attrs ];\n+        Array.prototype.push.apply( link, this.processInline( m[1] ) );\n+\n+        // We can't check if the reference is known here as it likely wont be\n+        // found till after. Check it in md tree->hmtl tree conversion.\n+        // Store the original so that conversion can revert if the ref isn't found.\n+        return [\n+          m[ 0 ].length,\n+          link\n+        ];\n+      }\n+\n+      // Just consume the '['\n+      return [ 1, \"[\" ];\n+    },\n+\n+\n+    \"<\": function autoLink( text ) {\n+      var m;\n+\n+      if ( ( m = text.match( /^<(?:((https?|ftp|mailto):[^>]+)|(.*?@.*?\\.[a-zA-Z]+))>/ ) ) != null ) {\n+        if ( m[3] ) {\n+          return [ m[0].length, [ \"link\", { href: \"mailto:\" + m[3] }, m[3] ] ];\n+\n+        }\n+        else if ( m[2] == \"mailto\" ) {\n+          return [ m[0].length, [ \"link\", { href: m[1] }, m[1].substr(\"mailto:\".length ) ] ];\n+        }\n+        else\n+          return [ m[0].length, [ \"link\", { href: m[1] }, m[1] ] ];\n+      }\n+\n+      return [ 1, \"<\" ];\n+    },\n+\n+    \"`\": function inlineCode( text ) {\n+      // Inline code block. as many backticks as you like to start it\n+      // Always skip over the opening ticks.\n+      var m = text.match( /(`+)(([\\s\\S]*?)\\1)/ );\n+\n+      if ( m && m[2] )\n+        return [ m[1].length + m[2].length, [ \"inlinecode\", m[3] ] ];\n+      else {\n+        // TODO: No matching end code found - warn!\n+        return [ 1, \"`\" ];\n+      }\n+    },\n+\n+    \"  \\n\": function lineBreak( text ) {\n+      return [ 3, [ \"linebreak\" ] ];\n+    }\n+\n+}\n+\n+// Meta Helper/generator method for em and strong handling\n+function strong_em( tag, md ) {\n+\n+  var state_slot = tag + \"_state\",\n+      other_slot = tag == \"strong\" ? \"em_state\" : \"strong_state\";\n+\n+  function CloseTag(len) {\n+    this.len_after = len;\n+    this.name = \"close_\" + md;\n+  }\n+\n+  return function ( text, orig_match ) {\n+\n+    if (this[state_slot][0] == md) {\n+      // Most recent em is of this type\n+      //D:this.debug(\"closing\", md);\n+      this[state_slot].shift();\n+\n+      // \"Consume\" everything to go back to the recrusion in the else-block below\n+      return[ text.length, new CloseTag(text.length-md.length) ];\n+    }\n+    else {\n+      // Store a clone of the em/strong states\n+      var other = this[other_slot].slice(),\n+          state = this[state_slot].slice();\n+\n+      this[state_slot].unshift(md);\n+\n+      //D:this.debug_indent += \"  \";\n+\n+      // Recurse\n+      var res = this.processInline( text.substr( md.length ) );\n+      //D:this.debug_indent = this.debug_indent.substr(2);\n+\n+      var last = res[res.length - 1];\n+\n+      //D:this.debug(\"processInline from\", tag + \": \", uneval( res ) );\n+\n+      var check = this[state_slot].shift();\n+      if (last instanceof CloseTag) {\n+        res.pop();\n+        // We matched! Huzzah.\n+        var consumed = text.length - last.len_after;\n+        return [ consumed, [ tag ].concat(res) ];\n+      }\n+      else {\n+        // Restore the state of the other kind. We might have mistakenly closed it.\n+        this[other_slot] = other;\n+        this[state_slot] = state;\n+\n+        // We can't reuse the processed result as it could have wrong parsing contexts in it.\n+        return [ md.length, md ];\n+      }\n+    }\n+  } // End returned function\n+}\n+\n+Markdown.dialects.Gruber.inline[\"**\"] = strong_em(\"strong\", \"**\");\n+Markdown.dialects.Gruber.inline[\"__\"] = strong_em(\"strong\", \"__\");\n+Markdown.dialects.Gruber.inline[\"*\"]  = strong_em(\"em\", \"*\");\n+Markdown.dialects.Gruber.inline[\"_\"]  = strong_em(\"em\", \"_\");\n+\n+\n+// Build default order from insertion order.\n+Markdown.buildBlockOrder = function(d) {\n+  var ord = [];\n+  for ( var i in d ) {\n+    if ( i == \"__order__\" || i == \"__call__\" ) continue;\n+    ord.push( i );\n+  }\n+  d.__order__ = ord;\n+}\n+\n+// Build patterns for inline matcher\n+Markdown.buildInlinePatterns = function(d) {\n+  var patterns = [];\n+\n+  for ( var i in d ) {\n+    if (i == \"__call__\") continue;\n+    var l = i.replace( /([\\\\.*+?|()\\[\\]{}])/g, \"\\\\$1\" )\n+             .replace( /\\n/, \"\\\\n\" );\n+    patterns.push( i.length == 1 ? l : \"(?:\" + l + \")\" );\n+  }\n+\n+  patterns = patterns.join(\"|\");\n+  //print(\"patterns:\", uneval( patterns ) );\n+\n+  var fn = d.__call__;\n+  d.__call__ = function(text, pattern) {\n+    if (pattern != undefined)\n+      return fn.call(this, text, pattern);\n+    else\n+      return fn.call(this, text, patterns);\n+  }\n+}\n+\n+// Helper function to make sub-classing a dialect easier\n+Markdown.subclassDialect = function( d ) {\n+  function Block() {};\n+  Block.prototype = d.block;\n+  function Inline() {};\n+  Inline.prototype = d.inline;\n+\n+  return { block: new Block(), inline: new Inline() };\n+}\n+\n+Markdown.buildBlockOrder ( Markdown.dialects.Gruber.block );\n+Markdown.buildInlinePatterns( Markdown.dialects.Gruber.inline );\n+\n+Markdown.dialects.Maruku = Markdown.subclassDialect( Markdown.dialects.Gruber );\n+\n+Markdown.dialects.Maruku.block.document_meta = function document_meta( block, next ) {\n+  // we're only interested in the first block\n+  if ( block.lineNumber > 1 ) return undefined;\n+\n+  // document_meta blocks consist of one or more lines of `Key: Value\\n`\n+  if ( ! block.match( /^(?:\\w+:.*\\n)*\\w+:.*$/ ) ) return undefined;\n+\n+  // make an attribute node if it doesn't exist\n+  if ( !extract_attr( this.tree ) ) {\n+    this.tree.splice( 1, 0, {} );\n+  }\n+\n+  var pairs = block.split( /\\n/ );\n+  for ( p in pairs ) {\n+    var m = pairs[ p ].match( /(\\w+):\\s*(.*)$/ ),\n+        key = m[ 1 ].toLowerCase(),\n+        value = m[ 2 ];\n+\n+    this.tree[ 1 ][ key ] = value;\n+  }\n+\n+  // document_meta produces no content!\n+  return [];\n+}\n+\n+Markdown.dialects.Maruku.block.block_meta = function block_meta( block, next ) {\n+  // check if the last line of the block is an meta hash\n+  var m = block.match( /(^|\\n) {0,3}\\{:\\s*((?:\\\\\\}|[^\\}])*)\\s*\\}$/ );\n+  if ( !m ) return undefined;\n+\n+  // process the meta hash\n+  var attr = process_meta_hash( m[ 2 ] );\n+\n+  // if we matched ^ then we need to apply meta to the previous block\n+  if ( m[ 1 ] === \"\" ) {\n+    var node = this.tree[ this.tree.length - 1 ],\n+        hash = extract_attr( node );\n+\n+    // if the node is a string (rather than JsonML), bail\n+    if ( typeof node === \"string\" ) return undefined;\n+\n+    // create the attribute hash if it doesn't exist\n+    if ( !hash ) {\n+      hash = {};\n+      node.splice( 1, 0, hash );\n+    }\n+\n+    // add the attributes in\n+    for ( a in attr ) {\n+      hash[ a ] = attr[ a ];\n+    }\n+\n+    // return nothing so the meta hash is removed\n+    return [];\n+  }\n+\n+  // pull the meta hash off the block and process what's left\n+  var b = block.replace( /\\n.*$/, \"\" ),\n+      result = this.processBlock( b, [] );\n+\n+  // get or make the attributes hash\n+  var hash = extract_attr( result[ 0 ] );\n+  if ( !hash ) {\n+    hash = {};\n+    result[ 0 ].splice( 1, 0, hash );\n+  }\n+\n+  // attach the attributes to the block\n+  for ( a in attr ) {\n+    hash[ a ] = attr[ a ];\n+  }\n+\n+  return result;\n+}\n+\n+Markdown.dialects.Maruku.block.definition_list = function definition_list( block, next ) {\n+  // one or more terms followed by one or more definitions, in a single block\n+  var tight = /^((?:[^\\s:].*\\n)+):\\s+([^]+)$/,\n+      list = [ \"dl\" ];\n+\n+  // see if we're dealing with a tight or loose block\n+  if ( ( m = block.match( tight ) ) ) {\n+    // pull subsequent tight DL blocks out of `next`\n+    var blocks = [ block ];\n+    while ( next.length && tight.exec( next[ 0 ] ) ) {\n+      blocks.push( next.shift() );\n+    }\n+\n+    for ( var b = 0; b < blocks.length; ++b ) {\n+      var m = blocks[ b ].match( tight ),\n+          terms = m[ 1 ].replace( /\\n$/, \"\" ).split( /\\n/ ),\n+          defns = m[ 2 ].split( /\\n:\\s+/ );\n+\n+      // print( uneval( m ) );\n+\n+      for ( var i = 0; i < terms.length; ++i ) {\n+        list.push( [ \"dt\" ].concat(this.processInline(terms[i])));\n+      }\n+\n+      for ( var i = 0; i < defns.length; ++i ) {\n+        // run inline processing over the definition\n+        list.push( [ \"dd\" ].concat( this.processInline( defns[ i ].replace( /(\\n)\\s+/, \"$1\" ) ) ) );\n+      }\n+    }\n+  }\n+  else {\n+    return undefined;\n+  }\n+\n+  return [ list ];\n+}\n+\n+Markdown.dialects.Maruku.inline[ \"{:\" ] = function inline_meta( text, matches, out ) {\n+  if ( !out.length ) {\n+    return [ 2, \"{:\" ];\n+  }\n+\n+  // get the preceeding element\n+  var before = out[ out.length - 1 ];\n+\n+  if ( typeof before === \"string\" ) {\n+    return [ 2, \"{:\" ];\n+  }\n+\n+  // match a meta hash\n+  var m = text.match( /^\\{:\\s*((?:\\\\\\}|[^\\}])*)\\s*\\}/ );\n+\n+  // no match, false alarm\n+  if ( !m ) {\n+    return [ 2, \"{:\" ];\n+  }\n+\n+  // attach the attributes to the preceeding element\n+  var meta = process_meta_hash( m[ 1 ] ),\n+      attr = extract_attr( before );\n+\n+  if ( !attr ) {\n+    attr = {};\n+    before.splice( 1, 0, attr );\n+  }\n+\n+  for ( var k in meta ) {\n+    attr[ k ] = meta[ k ];\n+  }\n+\n+  // cut out the string and replace it with nothing\n+  return [ m[ 0 ].length, \"\" ];\n+}\n+\n+Markdown.buildBlockOrder ( Markdown.dialects.Maruku.block );\n+Markdown.buildInlinePatterns( Markdown.dialects.Maruku.inline );\n+\n+var isArray = expose.isArray = function(obj) {\n+    return (obj instanceof Array || typeof obj === \"array\" || Array.isArray(obj));\n+}\n+\n+function extract_attr( jsonml ) {\n+  return isArray(jsonml)\n+      && jsonml.length > 1\n+      && typeof jsonml[ 1 ] === \"object\"\n+      && !( isArray(jsonml[ 1 ]) )\n+      ? jsonml[ 1 ]\n+      : undefined;\n+}\n+\n+function process_meta_hash( meta_string ) {\n+  var meta = split_meta_hash( meta_string ),\n+      attr = {};\n+\n+  for ( var i = 0; i < meta.length; ++i ) {\n+    // id: #foo\n+    if ( /^#/.test( meta[ i ] ) ) {\n+      attr.id = meta[ i ].substring( 1 );\n+    }\n+    // class: .foo\n+    else if ( /^\\./.test( meta[ i ] ) ) {\n+      // if class already exists, append the new one\n+      if ( attr['class'] ) {\n+        attr['class'] = attr['class'] + meta[ i ].replace( /./, \" \" );\n+      }\n+      else {\n+        attr['class'] = meta[ i ].substring( 1 );\n+      }\n+    }\n+    // attribute: foo=bar\n+    else if ( /=/.test( meta[ i ] ) ) {\n+      var s = meta[ i ].split( /=/ );\n+      attr[ s[ 0 ] ] = s[ 1 ];\n+    }\n+  }\n+\n+  return attr;\n+}\n+\n+function split_meta_hash( meta_string ) {\n+  var meta = meta_string.split( \"\" ),\n+      parts = [ \"\" ],\n+      in_quotes = false;\n+\n+  while ( meta.length ) {\n+    var letter = meta.shift();\n+    switch ( letter ) {\n+      case \" \" :\n+        // if we're in a quoted section, keep it\n+        if ( in_quotes ) {\n+          parts[ parts.length - 1 ] += letter;\n+        }\n+        // otherwise make a new part\n+        else {\n+          parts.push( \"\" );\n+        }\n+        break;\n+      case \"'\" :\n+      case '\"' :\n+        // reverse the quotes and move straight on\n+        in_quotes = !in_quotes;\n+        break;\n+      case \"\\\\\" :\n+        // shift off the next letter to be used straight away.\n+        // it was escaped so we'll keep it whatever it is\n+        letter = meta.shift();\n+      default :\n+        parts[ parts.length - 1 ] += letter;\n+        break;\n+    }\n+  }\n+\n+  return parts;\n+}\n+\n+/**\n+ *  renderJsonML( jsonml[, options] ) -> String\n+ *  - jsonml (Array): JsonML array to render to XML\n+ *  - options (Object): options\n+ *\n+ *  Converts the given JsonML into well-formed XML.\n+ *\n+ *  The options currently understood are:\n+ *\n+ *  - root (Boolean): wether or not the root node should be included in the\n+ *    output, or just its children. The default `false` is to not include the\n+ *    root itself.\n+ */\n+expose.renderJsonML = function( jsonml, options ) {\n+  options = options || {};\n+  // include the root element in the rendered output?\n+  options.root = options.root || false;\n+\n+  var content = [];\n+\n+  if ( options.root ) {\n+    content.push( render_tree( jsonml ) );\n+  }\n+  else {\n+    jsonml.shift(); // get rid of the tag\n+    if ( jsonml.length && typeof jsonml[ 0 ] === \"object\" && !( jsonml[ 0 ] instanceof Array ) ) {\n+      jsonml.shift(); // get rid of the attributes\n+    }\n+\n+    while ( jsonml.length ) {\n+      content.push( render_tree( jsonml.shift() ) );\n+    }\n+  }\n+\n+  return content.join( \"\\n\\n\" );\n+}\n+\n+function escapeHTML( text ) {\n+  return text.replace( /&/g, \"&amp;\" )\n+             .replace( /</g, \"&lt;\" )\n+             .replace( />/g, \"&gt;\" )\n+             .replace( /\"/g, \"&quot;\" )\n+             .replace( /'/g, \"&#39;\" );\n+}\n+\n+function render_tree( jsonml ) {\n+  // basic case\n+  if ( typeof jsonml === \"string\" ) {\n+    return escapeHTML( jsonml );\n+  }\n+\n+  var tag = jsonml.shift(),\n+      attributes = {},\n+      content = [];\n+\n+  if ( jsonml.length && typeof jsonml[ 0 ] === \"object\" && !( jsonml[ 0 ] instanceof Array ) ) {\n+    attributes = jsonml.shift();\n+  }\n+\n+  while ( jsonml.length ) {\n+    content.push( arguments.callee( jsonml.shift() ) );\n+  }\n+\n+  var tag_attrs = \"\";\n+  for ( var a in attributes ) {\n+    tag_attrs += \" \" + a + '=\"' + escapeHTML( attributes[ a ] ) + '\"';\n+  }\n+\n+  // be careful about adding whitespace here for inline elements\n+  return \"<\"+ tag + tag_attrs + \">\" + content.join( \"\" ) + \"</\" + tag + \">\";\n+}\n+\n+function convert_tree_to_html( tree, references, options ) {\n+  options = options || {};\n+\n+  // shallow clone\n+  var jsonml = tree.slice( 0 );\n+\n+  if (typeof options.preprocessTreeNode === \"function\") {\n+      jsonml = options.preprocessTreeNode(jsonml, references);\n+  }\n+\n+  // Clone attributes if they exist\n+  var attrs = extract_attr( jsonml );\n+  if ( attrs ) {\n+    jsonml[ 1 ] = {};\n+    for ( var i in attrs ) {\n+      jsonml[ 1 ][ i ] = attrs[ i ];\n+    }\n+    attrs = jsonml[ 1 ];\n+  }\n+\n+  // basic case\n+  if ( typeof jsonml === \"string\" ) {\n+    return jsonml;\n+  }\n+\n+  // convert this node\n+  switch ( jsonml[ 0 ] ) {\n+    case \"header\":\n+      jsonml[ 0 ] = \"h\" + jsonml[ 1 ].level;\n+      delete jsonml[ 1 ].level;\n+      break;\n+    case \"bulletlist\":\n+      jsonml[ 0 ] = \"ul\";\n+      break;\n+    case \"numberlist\":\n+      jsonml[ 0 ] = \"ol\";\n+      break;\n+    case \"listitem\":\n+      jsonml[ 0 ] = \"li\";\n+      break;\n+    case \"para\":\n+      jsonml[ 0 ] = \"p\";\n+      break;\n+    case \"markdown\":\n+      jsonml[ 0 ] = \"html\";\n+      if ( attrs ) delete attrs.references;\n+      break;\n+    case \"code_block\":\n+      jsonml[ 0 ] = \"pre\";\n+      var i = attrs ? 2 : 1;\n+      var code = [ \"code\" ];\n+      code.push.apply( code, jsonml.splice( i ) );\n+      jsonml[ i ] = code;\n+      break;\n+    case \"inlinecode\":\n+      jsonml[ 0 ] = \"code\";\n+      break;\n+    case \"img\":\n+      jsonml[ 1 ].src = jsonml[ 1 ].href;\n+      delete jsonml[ 1 ].href;\n+      break;\n+    case \"linebreak\":\n+      jsonml[0] = \"br\";\n+    break;\n+    case \"link\":\n+      jsonml[ 0 ] = \"a\";\n+      break;\n+    case \"link_ref\":\n+      jsonml[ 0 ] = \"a\";\n+\n+      // grab this ref and clean up the attribute node\n+      var ref = references[ attrs.ref ];\n+\n+      // if the reference exists, make the link\n+      if ( ref ) {\n+        delete attrs.ref;\n+\n+        // add in the href and title, if present\n+        attrs.href = ref.href;\n+        if ( ref.title ) {\n+          attrs.title = ref.title;\n+        }\n+\n+        // get rid of the unneeded original text\n+        delete attrs.original;\n+      }\n+      // the reference doesn't exist, so revert to plain text\n+      else {\n+        return attrs.original;\n+      }\n+      break;\n+  }\n+\n+  // convert all the children\n+  var i = 1;\n+\n+  // deal with the attribute node, if it exists\n+  if ( attrs ) {\n+    // if there are keys, skip over it\n+    for ( var key in jsonml[ 1 ] ) {\n+      i = 2;\n+    }\n+    // if there aren't, remove it\n+    if ( i === 1 ) {\n+      jsonml.splice( i, 1 );\n+    }\n+  }\n+\n+  for ( ; i < jsonml.length; ++i ) {\n+    jsonml[ i ] = arguments.callee( jsonml[ i ], references, options );\n+  }\n+\n+  return jsonml;\n+}\n+\n+\n+// merges adjacent text nodes into a single node\n+function merge_text_nodes( jsonml ) {\n+  // skip the tag name and attribute hash\n+  var i = extract_attr( jsonml ) ? 2 : 1;\n+\n+  while ( i < jsonml.length ) {\n+    // if it's a string check the next item too\n+    if ( typeof jsonml[ i ] === \"string\" ) {\n+      if ( i + 1 < jsonml.length && typeof jsonml[ i + 1 ] === \"string\" ) {\n+        // merge the second string into the first and remove it\n+        jsonml[ i ] += jsonml.splice( i + 1, 1 )[ 0 ];\n+      }\n+      else {\n+        ++i;\n+      }\n+    }\n+    // if it's not a string recurse\n+    else {\n+      arguments.callee( jsonml[ i ] );\n+      ++i;\n+    }\n+  }\n+}\n+\n+} )( (function() {\n+  if ( typeof exports === \"undefined\" ) {\n+    window.markdown = {};\n+    return window.markdown;\n+  }\n+  else {\n+    return exports;\n+  }\n+} )() );"}, {"sha": "d7a0e6417f33cacab08e80f090be818fbc3a24da", "filename": "doc/tutorial/mod.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b4f0a4caa6e765226c5f9d5609289dccb1072ce/doc%2Ftutorial%2Fmod.md", "raw_url": "https://github.com/rust-lang/rust/raw/0b4f0a4caa6e765226c5f9d5609289dccb1072ce/doc%2Ftutorial%2Fmod.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fmod.md?ref=0b4f0a4caa6e765226c5f9d5609289dccb1072ce", "patch": "@@ -0,0 +1,3 @@\n+# Modules and crates\n+\n+FIXME include name resolution details"}, {"sha": "54b7314a2dd5e814216860f5ff9d6290d8720323", "filename": "doc/tutorial/order", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0b4f0a4caa6e765226c5f9d5609289dccb1072ce/doc%2Ftutorial%2Forder", "raw_url": "https://github.com/rust-lang/rust/raw/0b4f0a4caa6e765226c5f9d5609289dccb1072ce/doc%2Ftutorial%2Forder", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Forder?ref=0b4f0a4caa6e765226c5f9d5609289dccb1072ce", "patch": "@@ -0,0 +1,9 @@\n+intro\n+setup\n+syntax\n+control\n+func\n+data\n+args\n+generic\n+mod"}, {"sha": "ffa3a976629231cbf30896b0deb767696747a675", "filename": "doc/tutorial/setup.md", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0b4f0a4caa6e765226c5f9d5609289dccb1072ce/doc%2Ftutorial%2Fsetup.md", "raw_url": "https://github.com/rust-lang/rust/raw/0b4f0a4caa6e765226c5f9d5609289dccb1072ce/doc%2Ftutorial%2Fsetup.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fsetup.md?ref=0b4f0a4caa6e765226c5f9d5609289dccb1072ce", "patch": "@@ -0,0 +1,42 @@\n+# Getting started\n+\n+## Installation\n+\n+FIXME Fill this in when the installation package is finished.\n+\n+## Compiling your first program\n+\n+Rust program files are, by convention, given the extension `.rs`. Say\n+we have a file `hello.rs` containing this program:\n+\n+    use std;\n+    fn main() {\n+        std::io::println(\"hello world!\");\n+    }\n+\n+If the Rust compiler was installed successfully, running `rustc\n+hello.rs` will produce a binary called `hello` (or `hello.exe`).\n+\n+If you modify the program to make it invalid (for example, remove the\n+`use std` line), and then compile it, you'll see an error message like\n+this:\n+\n+    hello.rs:2:4: 2:20 error: unresolved modulename: std\n+    hello.rs:2     std::io::println(\"hello world!\");\n+                   ^~~~~~~~~~~~~~~~\n+\n+The Rust compiler tries to provide useful information when it runs\n+into an error.\n+\n+## Anatomy of a Rust program\n+\n+FIXME say something about libs, main, modules, use\n+\n+## Editing Rust code\n+\n+There are Vim highlighting and indentation scrips in the Rust source\n+distribution under `src/etc/vim/`. An Emacs mode can be found at\n+`[https://github.com/marijnh/rust-mode](https://github.com/marijnh/rust-mode)`.\n+\n+Other editors are not provided for yet. If you end up writing a Rust\n+mode for your favorite editor, let us know so that we can link to it."}, {"sha": "19e9c4aa8ef351d6736e7c2d288d50147c8775b6", "filename": "doc/tutorial/syntax.md", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/0b4f0a4caa6e765226c5f9d5609289dccb1072ce/doc%2Ftutorial%2Fsyntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/0b4f0a4caa6e765226c5f9d5609289dccb1072ce/doc%2Ftutorial%2Fsyntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fsyntax.md?ref=0b4f0a4caa6e765226c5f9d5609289dccb1072ce", "patch": "@@ -0,0 +1,207 @@\n+# Syntax Basics\n+\n+FIXME: mention the module separator `::` somewhere\n+\n+## Braces\n+\n+Assuming you've programmed in any C-family language (C++, Java,\n+JavaScript, C#, or PHP), Rust will feel familiar. The main surface\n+difference to be aware of is that the bodies of `if` statements and of\n+loops *have* to be wrapped in brackets. Single-statement, bracket-less\n+bodies are not allowed.\n+\n+If the verbosity of that bothers you, consider the fact that this\n+allows you to omit the parentheses around the condition in `if`,\n+`while`, and similar constructs. This will save you two characters\n+every time. As a bonus, you no longer have to spend any mental energy\n+on deciding whether you need to add braces or not, or on adding them\n+after the fact when a adding a statement to an `if` branch.\n+\n+Accounting for these differences, the surface syntax of Rust\n+statements and expressions is C-like. Function calls are written\n+`myfunc(arg1, arg2)`, operators have mostly the same name and\n+precedence that they have in C, comments look the same, and constructs\n+like `if` and `while` are available:\n+\n+    fn main() {\n+        if 1 < 2 {\n+            while false { call_a_function(10 * 4); }\n+        } else if 4 < 3 || 3 < 4 {\n+            // Comments are C++-style too\n+        } else {\n+            /* Multi-line comment syntax */\n+        }\n+    }\n+\n+## Expression syntax\n+\n+Though it isn't apparent in most everyday code, there is a fundamental\n+difference between Rust's syntax and the predecessors in this family\n+of languages. Almost everything in rust is an expression, even things\n+that are statements in other languages. This allows for useless things\n+like this (which passes nil\u2014the void type\u2014to a function):\n+\n+    a_function(while false {});\n+\n+But also useful things like this:\n+\n+    let x = if the_stars_align() { 4 }\n+            else if something_else() { 3 }\n+            else { 0 };\n+\n+This piece of code will bind the variable `x` to a value depending on\n+the conditions. Note the condition bodies, which look like `{\n+expression }`. The lack of a semicolon after the last statement in a\n+braced block gives the whole block the value of that last expression.\n+If the branches of the `if` had looked like `{ 4; }`, the above\n+example would simply assign nil (void) to `x`. But without the\n+semicolon, each branch has a different value, and `x` gets the value\n+of the branch that was taken.\n+\n+This also works for function bodies. This function returns a boolean:\n+\n+    fn is_four(x: int) -> bool { x == 4 }\n+\n+If everything is an expression, you might conclude that you have to\n+add a terminating semicolon after *every* statement, even ones that\n+are not traditionally terminated with a semicolon in C (like `while`).\n+That is not the case, though. Statements that end in a block only need\n+a semicolon if that block contains a trailing expression. `while`\n+loops do not allow trailing expressions, and `if` statements tend to\n+only have a trailing expression when you want to use their value for\n+something\u2014in which case you'll have embedded it in a bigger statement,\n+like the `let x = ...` example above.\n+\n+## Types\n+\n+The `-> bool` in the last example is the way a function's return type\n+is written. For functions that do not return a meaningful value (these\n+conceptually return nil in Rust), you can optionally say `-> ()` (`()`\n+is how nil is written), but usually the return annotation is simply\n+left off, as in the `fn main() { ... }` examples we've seen earlier.\n+\n+Every argument to a function must have its type declared (for example,\n+`x: int`). Inside the function, type inference will be able to\n+automatically deduce the type of most locals (generic functions, which\n+we'll come back to later, will occasionally need additional\n+annotation). Locals can be written either with or without a type\n+annotation:\n+\n+    // The type of this vector will be inferred based on its use.\n+    let x = [];\n+    // Explicitly say this is a vector of integers.\n+    let y: [int] = [];\n+\n+The basic types are written like this:\n+\n+`()`\n+: Nil, the type that has only a single value.  \n+\n+`bool`\n+: Boolean type..  \n+\n+`int`\n+: A machine-pointer-sized integer.  \n+\n+`uint`\n+: A machine-pointer-sized unsigned integer.  \n+\n+`i8`, `i16`, `i32`, `i64`\n+: Signed integers with a specific size (in bits).  \n+\n+`u8`, `u16`, `u32`, `u64`\n+: Unsigned integers with a specific size.  \n+\n+`f32`, `f64`\n+: Floating-point types.  \n+\n+`float`\n+: The largest floating-point type efficiently supported on the target machine.  \n+\n+`char`\n+: A character is a 32-bit Unicode code point.  \n+\n+`str`\n+: String type. A string contains a utf-8 encoded sequence of characters.\n+\n+These can be combined in composite types, which will be described in\n+more detail later on (the `T`s here stand for any other type):\n+\n+`[T]`\n+: Vector type.  \n+\n+`[mutable T]`\n+: Mutable vector type.  \n+\n+`(T1, T2)`\n+: Tuple type. Any arity above 1 is supported.  \n+\n+`{fname1: T1, fname2: T2}`\n+: Record type.  \n+\n+`fn(arg1: T1, arg2: T2) -> T3`\n+: Function type.  \n+\n+`@T`, `~T`, `*T`\n+: Pointer types.  \n+\n+`obj { fn method1() }`\n+: Object type.\n+\n+Types can be given names with `type` declarations:\n+\n+    type monster_size = uint;\n+\n+This will provide a synonym, `monster_size`, for unsigned integers. It\n+will not actually create a new type\u2014`monster_size` and `uint` can be\n+used interchangeably, and using one where the other is expected is not\n+a type error. Read about [single-variant tags][svt] in the next\n+section if you need to create a type name that's not just a synonym.\n+\n+[svt]: FIXME\n+\n+## Literals\n+\n+Integers can be written in decimal (`144`), hexadecimal (`0x90`), and\n+binary (`0b10010000`) base. Without suffix, an integer literal is\n+considered to be of type `int`. Add a `u` (`144u`) to make it a `uint`\n+instead. Literals of the fixed-size integer types can be created by\n+the literal with the type name (`i8`, `u64`, etc).\n+\n+Note that, in Rust, no implicit conversion between integer types\n+happens. If you are adding one to a variable of type `uint`, you must\n+type `v += 1u`\u2014saying `+= 1` will give you a type error.\n+\n+Floating point numbers are written `0.0`, `1e6`, or `2.1e-4`. Without\n+suffix, the literal is assumed to be of type `float`. Suffixes `f32`\n+and `f64` can be used to create literals of a specific type. The\n+suffix `f` can be used to write `float` literals without a dot or\n+exponent: `3f`.\n+\n+The nil literal is written just like the type: `()`. The keywords\n+`true` and `false` produce the boolean literals.\n+\n+Character literals are written between single quotes, as in `'x'`. You\n+may put non-ascii characters between single quotes (your source file\n+should be encoded as utf-8 in that case). Rust understands a number of\n+character escapes, using the backslash character:\n+\n+`\\n`\n+: A newline (unicode character 32).\n+`\\r`\n+: A carriage return (13).\n+`\\t`\n+: A tab character (9).\n+`\\\\`, `\\'`, `\\\"`\n+: Simply escapes the following character.\n+`\\xHH`, `\\uHHHH`, `\\UHHHHHHHH`\n+: Unicode escapes, where the `H` characters are the hexadecimal digits that form the character code.\n+\n+String literals allow the same escape sequences. They are written\n+between double quotes (`\"hello\"`). Rust strings may contain newlines.\n+When a newline is preceded by a backslash, it, and all white space\n+following it, will not appear in the resulting string literal.\n+\n+## Operators\n+\n+FIXME recap C-style operators, ?:, explain `as`"}, {"sha": "a71180027f0c7d71abeb8b06b4edca7a59676f15", "filename": "doc/tutorial/web/style.css", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0b4f0a4caa6e765226c5f9d5609289dccb1072ce/doc%2Ftutorial%2Fweb%2Fstyle.css", "raw_url": "https://github.com/rust-lang/rust/raw/0b4f0a4caa6e765226c5f9d5609289dccb1072ce/doc%2Ftutorial%2Fweb%2Fstyle.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fweb%2Fstyle.css?ref=0b4f0a4caa6e765226c5f9d5609289dccb1072ce", "patch": "@@ -0,0 +1,36 @@\n+body {\n+  padding: 1em;\n+  margin: 0;\n+  font-family: \"Helvetica Neue\", Helvetica, sans-serif;\n+}\n+\n+#content {\n+  padding: 1em 6em;\n+  max-width: 50em;\n+}\n+\n+h1 { font-size: 22pt; }\n+h2 { font-size: 17pt; }\n+h3 { font-size: 14pt; }\n+\n+code {\n+  color: #033;\n+}\n+\n+pre {\n+  margin: 1.1em 12px;\n+  border: 1px solid #CCCCCC;\n+  padding: .4em;\n+  font-size: 120%;\n+}\n+\n+p.head {\n+  font-size: 80%;\n+  font-style: italic;\n+  text-align: right;\n+}\n+\n+a, a:visited, a:link {\n+  text-decoration: none;\n+  color: #00438a;\n+}"}]}