{"sha": "dc8414b6076656b0722b0d5a8230a8613d8ccb57", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjODQxNGI2MDc2NjU2YjA3MjJiMGQ1YTgyMzBhODYxM2Q4Y2NiNTc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-09-28T08:32:05Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-09-28T08:32:05Z"}, "message": "fix building libstd for Miri on macOS", "tree": {"sha": "f1ee3297a9ddef1f7d39ea150b7956b1f611b010", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1ee3297a9ddef1f7d39ea150b7956b1f611b010"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc8414b6076656b0722b0d5a8230a8613d8ccb57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc8414b6076656b0722b0d5a8230a8613d8ccb57", "html_url": "https://github.com/rust-lang/rust/commit/dc8414b6076656b0722b0d5a8230a8613d8ccb57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc8414b6076656b0722b0d5a8230a8613d8ccb57/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6369a98ebdee8ce01510f5d4307ddb771c8cb0e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/6369a98ebdee8ce01510f5d4307ddb771c8cb0e5", "html_url": "https://github.com/rust-lang/rust/commit/6369a98ebdee8ce01510f5d4307ddb771c8cb0e5"}], "stats": {"total": 99, "additions": 50, "deletions": 49}, "files": [{"sha": "00680fadc18dc58e225cc4e6a2baff186f326fcd", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 50, "deletions": 49, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/dc8414b6076656b0722b0d5a8230a8613d8ccb57/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8414b6076656b0722b0d5a8230a8613d8ccb57/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=dc8414b6076656b0722b0d5a8230a8613d8ccb57", "patch": "@@ -93,60 +93,61 @@ pub fn init() {\n         reset_sigpipe();\n     }\n \n-    // In the case when all file descriptors are open, the poll has been\n-    // observed to perform better than fcntl (on GNU/Linux).\n-    #[cfg(not(any(\n-        miri,\n-        target_os = \"emscripten\",\n-        target_os = \"fuchsia\",\n-        // The poll on Darwin doesn't set POLLNVAL for closed fds.\n-        target_os = \"macos\",\n-        target_os = \"ios\",\n-        target_os = \"redox\",\n-    )))]\n-    unsafe fn sanitize_standard_fds() {\n-        use crate::sys::os::errno;\n-        let pfds: &mut [_] = &mut [\n-            libc::pollfd { fd: 0, events: 0, revents: 0 },\n-            libc::pollfd { fd: 1, events: 0, revents: 0 },\n-            libc::pollfd { fd: 2, events: 0, revents: 0 },\n-        ];\n-        while libc::poll(pfds.as_mut_ptr(), 3, 0) == -1 {\n-            if errno() == libc::EINTR {\n-                continue;\n-            }\n-            libc::abort();\n-        }\n-        for pfd in pfds {\n-            if pfd.revents & libc::POLLNVAL == 0 {\n-                continue;\n-            }\n-            if libc::open(\"/dev/null\\0\".as_ptr().cast(), libc::O_RDWR, 0) == -1 {\n-                // If the stream is closed but we failed to reopen it, abort the\n-                // process. Otherwise we wouldn't preserve the safety of\n-                // operations on the corresponding Rust object Stdin, Stdout, or\n-                // Stderr.\n-                libc::abort();\n-            }\n-        }\n-    }\n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"redox\"))]\n-    unsafe fn sanitize_standard_fds() {\n-        use crate::sys::os::errno;\n-        for fd in 0..3 {\n-            if libc::fcntl(fd, libc::F_GETFD) == -1 && errno() == libc::EBADF {\n-                if libc::open(\"/dev/null\\0\".as_ptr().cast(), libc::O_RDWR, 0) == -1 {\n+    cfg_if::cfg_if! {\n+        if #[cfg(miri)] {\n+            // The standard fds are always available in Miri.\n+            unsafe fn sanitize_standard_fds() {}\n+        } else if #[cfg(not(any(\n+            target_os = \"emscripten\",\n+            target_os = \"fuchsia\",\n+            // The poll on Darwin doesn't set POLLNVAL for closed fds.\n+            target_os = \"macos\",\n+            target_os = \"ios\",\n+            target_os = \"redox\",\n+        )))] {\n+            // In the case when all file descriptors are open, the poll has been\n+            // observed to perform better than fcntl (on GNU/Linux).\n+            unsafe fn sanitize_standard_fds() {\n+                use crate::sys::os::errno;\n+                let pfds: &mut [_] = &mut [\n+                    libc::pollfd { fd: 0, events: 0, revents: 0 },\n+                    libc::pollfd { fd: 1, events: 0, revents: 0 },\n+                    libc::pollfd { fd: 2, events: 0, revents: 0 },\n+                ];\n+                while libc::poll(pfds.as_mut_ptr(), 3, 0) == -1 {\n+                    if errno() == libc::EINTR {\n+                        continue;\n+                    }\n                     libc::abort();\n                 }\n+                for pfd in pfds {\n+                    if pfd.revents & libc::POLLNVAL == 0 {\n+                        continue;\n+                    }\n+                    if libc::open(\"/dev/null\\0\".as_ptr().cast(), libc::O_RDWR, 0) == -1 {\n+                        // If the stream is closed but we failed to reopen it, abort the\n+                        // process. Otherwise we wouldn't preserve the safety of\n+                        // operations on the corresponding Rust object Stdin, Stdout, or\n+                        // Stderr.\n+                        libc::abort();\n+                    }\n+                }\n+            }\n+        } else if #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"redox\"))] {\n+            unsafe fn sanitize_standard_fds() {\n+                use crate::sys::os::errno;\n+                for fd in 0..3 {\n+                    if libc::fcntl(fd, libc::F_GETFD) == -1 && errno() == libc::EBADF {\n+                        if libc::open(\"/dev/null\\0\".as_ptr().cast(), libc::O_RDWR, 0) == -1 {\n+                            libc::abort();\n+                        }\n+                    }\n+                }\n             }\n+        } else {\n+            unsafe fn sanitize_standard_fds() {}\n         }\n     }\n-    #[cfg(any(\n-        // The standard fds are always available in Miri.\n-        miri,\n-        target_os = \"emscripten\",\n-        target_os = \"fuchsia\"))]\n-    unsafe fn sanitize_standard_fds() {}\n \n     #[cfg(not(any(target_os = \"emscripten\", target_os = \"fuchsia\")))]\n     unsafe fn reset_sigpipe() {"}]}