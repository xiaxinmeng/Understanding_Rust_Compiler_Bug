{"sha": "e2ec3a6561d73cc4b530c69a9bafc30c4f34b1ec", "node_id": "C_kwDOAAsO6NoAKGUyZWMzYTY1NjFkNzNjYzRiNTMwYzY5YTliYWZjMzBjNGYzNGIxZWM", "commit": {"author": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2023-03-03T15:24:05Z"}, "committer": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2023-03-03T15:24:05Z"}, "message": "Refactor generic parameter lowering\n\nSince we moved impl trait handling to other place, there are only two\ncases now: those that introduce implicit `Self` parameter and those that\ndon't.", "tree": {"sha": "72b611d7d61bca146382e955aea678b4934bdbc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72b611d7d61bca146382e955aea678b4934bdbc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2ec3a6561d73cc4b530c69a9bafc30c4f34b1ec", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEkSbsQIURluxz4rzf4laYqTBYYXEFAmQCERUACgkQ4laYqTBY\nYXH2LA//W8nFofq0Ib5H2lBKyp1YFZjypbF587fBcf67lGUeQgSUt5OH+Q2q7HDi\nbgVdIEsp19RpkhTnFyumNY+cuvItNekY57uNN28E9zu2raiSkq2wTcPeREH4K9Mh\nIDm5hzZjpU7/572JVqNoUdN3wU9M2zPUrA4bw7qNr2FiB+E+osfqMZXsc0TM1h5Y\n78Bzpw0Y6IMGlQRFizy7GM8GMqlqiTEe7QgS0lSivaUYLCZNKyrl/aDYrrhbmt+f\n1QW/mQfSx8MpY6C2rK5jWrzJkceWC301eHkOejtzevEee1i5qTqpQ1mAgPV6iGmd\n76evQLqOIibWDEziGWziBv2Sy4jN2aLCUULP6sZzbRPNyQjeuArGLVVFC2wWyZ+H\ntv6x6Yc99x5nn4nX1/jO6rIFb+ySxhyBulJ4mHGM/JoiPdgQ+/QSXXLrzN62xsfG\nQ+zKD8BiJOuWzMvZvxmI7WsfWnG8A3KOaxxQdbJbDxZbPeSwpAed1fH5tGV5CJnQ\nVSA6C25KhZqwCRM/rZ9JrXck6MiwxIsqh8E7rk09CsOTsu252/kKx2vyKPGk99F5\nbYEpQvD8xBcevpETibrdJKW4vd7VtKgYWmqPjKirpWNiPH3NgWLM0fVqZRj+RFSC\n7otPrI4UBXJrR5JjeRteu2sj7Vpabk0FASFxiE9/llqD6CJgySY=\n=unBZ\n-----END PGP SIGNATURE-----", "payload": "tree 72b611d7d61bca146382e955aea678b4934bdbc5\nparent 356d12eae4b8985dc933c13e9281546d532d0845\nauthor Ryo Yoshida <low.ryoshida@gmail.com> 1677857045 +0900\ncommitter Ryo Yoshida <low.ryoshida@gmail.com> 1677857045 +0900\n\nRefactor generic parameter lowering\n\nSince we moved impl trait handling to other place, there are only two\ncases now: those that introduce implicit `Self` parameter and those that\ndon't.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2ec3a6561d73cc4b530c69a9bafc30c4f34b1ec", "html_url": "https://github.com/rust-lang/rust/commit/e2ec3a6561d73cc4b530c69a9bafc30c4f34b1ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2ec3a6561d73cc4b530c69a9bafc30c4f34b1ec/comments", "author": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "356d12eae4b8985dc933c13e9281546d532d0845", "url": "https://api.github.com/repos/rust-lang/rust/commits/356d12eae4b8985dc933c13e9281546d532d0845", "html_url": "https://github.com/rust-lang/rust/commit/356d12eae4b8985dc933c13e9281546d532d0845"}], "stats": {"total": 102, "additions": 45, "deletions": 57}, "files": [{"sha": "5a0aa193388017351a36b26dfe5792ab1ef7305e", "filename": "crates/hir-def/src/generics.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e2ec3a6561d73cc4b530c69a9bafc30c4f34b1ec/crates%2Fhir-def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ec3a6561d73cc4b530c69a9bafc30c4f34b1ec/crates%2Fhir-def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fgenerics.rs?ref=e2ec3a6561d73cc4b530c69a9bafc30c4f34b1ec", "patch": "@@ -207,12 +207,10 @@ impl GenericParams {\n     pub(crate) fn fill_bounds(\n         &mut self,\n         lower_ctx: &LowerCtx<'_>,\n-        node: &dyn ast::HasTypeBounds,\n+        type_bounds: Option<ast::TypeBoundList>,\n         target: Either<TypeRef, LifetimeRef>,\n     ) {\n-        for bound in\n-            node.type_bound_list().iter().flat_map(|type_bound_list| type_bound_list.bounds())\n-        {\n+        for bound in type_bounds.iter().flat_map(|type_bound_list| type_bound_list.bounds()) {\n             self.add_where_predicate_from_bound(lower_ctx, bound, None, target.clone());\n         }\n     }\n@@ -233,7 +231,11 @@ impl GenericParams {\n                     };\n                     self.type_or_consts.alloc(param.into());\n                     let type_ref = TypeRef::Path(name.into());\n-                    self.fill_bounds(lower_ctx, &type_param, Either::Left(type_ref));\n+                    self.fill_bounds(\n+                        lower_ctx,\n+                        type_param.type_bound_list(),\n+                        Either::Left(type_ref),\n+                    );\n                 }\n                 ast::TypeOrConstParam::Const(const_param) => {\n                     let name = const_param.name().map_or_else(Name::missing, |it| it.as_name());\n@@ -255,7 +257,11 @@ impl GenericParams {\n             let param = LifetimeParamData { name: name.clone() };\n             self.lifetimes.alloc(param);\n             let lifetime_ref = LifetimeRef::new_name(name);\n-            self.fill_bounds(lower_ctx, &lifetime_param, Either::Right(lifetime_ref));\n+            self.fill_bounds(\n+                lower_ctx,\n+                lifetime_param.type_bound_list(),\n+                Either::Right(lifetime_ref),\n+            );\n         }\n     }\n "}, {"sha": "b64b4d11e373d304464c47abfe44c6e126617b46", "filename": "crates/hir-def/src/item_tree/lower.rs", "status": "modified", "additions": 33, "deletions": 51, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/e2ec3a6561d73cc4b530c69a9bafc30c4f34b1ec/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ec3a6561d73cc4b530c69a9bafc30c4f34b1ec/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs?ref=e2ec3a6561d73cc4b530c69a9bafc30c4f34b1ec", "patch": "@@ -3,7 +3,7 @@\n use std::{collections::hash_map::Entry, sync::Arc};\n \n use hir_expand::{ast_id_map::AstIdMap, hygiene::Hygiene, HirFileId};\n-use syntax::ast::{self, HasModuleItem};\n+use syntax::ast::{self, HasModuleItem, HasTypeBounds};\n \n use crate::{\n     generics::{GenericParams, TypeParamData, TypeParamProvenance},\n@@ -148,7 +148,7 @@ impl<'a> Ctx<'a> {\n     fn lower_struct(&mut self, strukt: &ast::Struct) -> Option<FileItemTreeId<Struct>> {\n         let visibility = self.lower_visibility(strukt);\n         let name = strukt.name()?.as_name();\n-        let generic_params = self.lower_generic_params(GenericsOwner::Struct, strukt);\n+        let generic_params = self.lower_generic_params(HasImplicitSelf::No, strukt);\n         let fields = self.lower_fields(&strukt.kind());\n         let ast_id = self.source_ast_id_map.ast_id(strukt);\n         let res = Struct { name, visibility, generic_params, fields, ast_id };\n@@ -212,7 +212,7 @@ impl<'a> Ctx<'a> {\n     fn lower_union(&mut self, union: &ast::Union) -> Option<FileItemTreeId<Union>> {\n         let visibility = self.lower_visibility(union);\n         let name = union.name()?.as_name();\n-        let generic_params = self.lower_generic_params(GenericsOwner::Union, union);\n+        let generic_params = self.lower_generic_params(HasImplicitSelf::No, union);\n         let fields = match union.record_field_list() {\n             Some(record_field_list) => self.lower_fields(&StructKind::Record(record_field_list)),\n             None => Fields::Record(IdxRange::new(self.next_field_idx()..self.next_field_idx())),\n@@ -225,7 +225,7 @@ impl<'a> Ctx<'a> {\n     fn lower_enum(&mut self, enum_: &ast::Enum) -> Option<FileItemTreeId<Enum>> {\n         let visibility = self.lower_visibility(enum_);\n         let name = enum_.name()?.as_name();\n-        let generic_params = self.lower_generic_params(GenericsOwner::Enum, enum_);\n+        let generic_params = self.lower_generic_params(HasImplicitSelf::No, enum_);\n         let variants = match &enum_.variant_list() {\n             Some(variant_list) => self.lower_variants(variant_list),\n             None => IdxRange::new(self.next_variant_idx()..self.next_variant_idx()),\n@@ -373,8 +373,7 @@ impl<'a> Ctx<'a> {\n             ast_id,\n             flags,\n         };\n-        res.explicit_generic_params =\n-            self.lower_generic_params(GenericsOwner::Function(&res), func);\n+        res.explicit_generic_params = self.lower_generic_params(HasImplicitSelf::No, func);\n \n         Some(id(self.data().functions.alloc(res)))\n     }\n@@ -387,7 +386,7 @@ impl<'a> Ctx<'a> {\n         let type_ref = type_alias.ty().map(|it| self.lower_type_ref(&it));\n         let visibility = self.lower_visibility(type_alias);\n         let bounds = self.lower_type_bounds(type_alias);\n-        let generic_params = self.lower_generic_params(GenericsOwner::TypeAlias, type_alias);\n+        let generic_params = self.lower_generic_params(HasImplicitSelf::No, type_alias);\n         let ast_id = self.source_ast_id_map.ast_id(type_alias);\n         let res = TypeAlias {\n             name,\n@@ -443,7 +442,8 @@ impl<'a> Ctx<'a> {\n     fn lower_trait(&mut self, trait_def: &ast::Trait) -> Option<FileItemTreeId<Trait>> {\n         let name = trait_def.name()?.as_name();\n         let visibility = self.lower_visibility(trait_def);\n-        let generic_params = self.lower_generic_params(GenericsOwner::Trait(trait_def), trait_def);\n+        let generic_params =\n+            self.lower_generic_params(HasImplicitSelf::Yes(trait_def.type_bound_list()), trait_def);\n         let is_auto = trait_def.auto_token().is_some();\n         let is_unsafe = trait_def.unsafe_token().is_some();\n         let items = trait_def.assoc_item_list().map(|list| {\n@@ -463,7 +463,9 @@ impl<'a> Ctx<'a> {\n     }\n \n     fn lower_impl(&mut self, impl_def: &ast::Impl) -> Option<FileItemTreeId<Impl>> {\n-        let generic_params = self.lower_generic_params(GenericsOwner::Impl, impl_def);\n+        // Note that trait impls don't get implicit `Self` unlike traits, because here they are a\n+        // type alias rather than a type parameter, so this is handled by the resolver.\n+        let generic_params = self.lower_generic_params(HasImplicitSelf::No, impl_def);\n         // FIXME: If trait lowering fails, due to a non PathType for example, we treat this impl\n         // as if it was an non-trait impl. Ideally we want to create a unique missing ref that only\n         // equals itself.\n@@ -567,42 +569,29 @@ impl<'a> Ctx<'a> {\n \n     fn lower_generic_params(\n         &mut self,\n-        owner: GenericsOwner<'_>,\n+        has_implicit_self: HasImplicitSelf,\n         node: &dyn ast::HasGenericParams,\n     ) -> Interned<GenericParams> {\n         let mut generics = GenericParams::default();\n-        match owner {\n-            GenericsOwner::Function(_)\n-            | GenericsOwner::Struct\n-            | GenericsOwner::Enum\n-            | GenericsOwner::Union\n-            | GenericsOwner::TypeAlias => {\n-                generics.fill(&self.body_ctx, node);\n-            }\n-            GenericsOwner::Trait(trait_def) => {\n-                // traits get the Self type as an implicit first type parameter\n-                generics.type_or_consts.alloc(\n-                    TypeParamData {\n-                        name: Some(name![Self]),\n-                        default: None,\n-                        provenance: TypeParamProvenance::TraitSelf,\n-                    }\n-                    .into(),\n-                );\n-                // add super traits as bounds on Self\n-                // i.e., trait Foo: Bar is equivalent to trait Foo where Self: Bar\n-                let self_param = TypeRef::Path(name![Self].into());\n-                generics.fill_bounds(&self.body_ctx, trait_def, Either::Left(self_param));\n-                generics.fill(&self.body_ctx, node);\n-            }\n-            GenericsOwner::Impl => {\n-                // Note that we don't add `Self` here: in `impl`s, `Self` is not a\n-                // type-parameter, but rather is a type-alias for impl's target\n-                // type, so this is handled by the resolver.\n-                generics.fill(&self.body_ctx, node);\n-            }\n+\n+        if let HasImplicitSelf::Yes(bounds) = has_implicit_self {\n+            // Traits and trait aliases get the Self type as an implicit first type parameter.\n+            generics.type_or_consts.alloc(\n+                TypeParamData {\n+                    name: Some(name![Self]),\n+                    default: None,\n+                    provenance: TypeParamProvenance::TraitSelf,\n+                }\n+                .into(),\n+            );\n+            // add super traits as bounds on Self\n+            // i.e., `trait Foo: Bar` is equivalent to `trait Foo where Self: Bar`\n+            let self_param = TypeRef::Path(name![Self].into());\n+            generics.fill_bounds(&self.body_ctx, bounds, Either::Left(self_param));\n         }\n \n+        generics.fill(&self.body_ctx, node);\n+\n         generics.shrink_to_fit();\n         Interned::new(generics)\n     }\n@@ -674,17 +663,10 @@ fn desugar_future_path(orig: TypeRef) -> Path {\n     Path::from_known_path(path, generic_args)\n }\n \n-enum GenericsOwner<'a> {\n-    /// We need access to the partially-lowered `Function` for lowering `impl Trait` in argument\n-    /// position.\n-    Function(&'a Function),\n-    Struct,\n-    Enum,\n-    Union,\n-    /// The `TraitDef` is needed to fill the source map for the implicit `Self` parameter.\n-    Trait(&'a ast::Trait),\n-    TypeAlias,\n-    Impl,\n+enum HasImplicitSelf {\n+    /// Inner list is a type bound list for the implicit `Self`.\n+    Yes(Option<ast::TypeBoundList>),\n+    No,\n }\n \n fn lower_abi(abi: ast::Abi) -> Interned<str> {"}]}