{"sha": "83239c2c1ebed372dd34016bdd75d02e4429589d", "node_id": "C_kwDOAAsO6NoAKDgzMjM5YzJjMWViZWQzNzJkZDM0MDE2YmRkNzVkMDJlNDQyOTU4OWQ", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-11-05T11:35:40Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-11-05T14:21:50Z"}, "message": "Merge from rustc", "tree": {"sha": "f76015608b2a3fcdbdc5dc7f50049e089c6666d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f76015608b2a3fcdbdc5dc7f50049e089c6666d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83239c2c1ebed372dd34016bdd75d02e4429589d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83239c2c1ebed372dd34016bdd75d02e4429589d", "html_url": "https://github.com/rust-lang/rust/commit/83239c2c1ebed372dd34016bdd75d02e4429589d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83239c2c1ebed372dd34016bdd75d02e4429589d/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4492c029eff7b42e91e759576ab0c7ca88f873dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/4492c029eff7b42e91e759576ab0c7ca88f873dc", "html_url": "https://github.com/rust-lang/rust/commit/4492c029eff7b42e91e759576ab0c7ca88f873dc"}, {"sha": "452cf4f7109f58433ac38be7d3da527408571054", "url": "https://api.github.com/repos/rust-lang/rust/commits/452cf4f7109f58433ac38be7d3da527408571054", "html_url": "https://github.com/rust-lang/rust/commit/452cf4f7109f58433ac38be7d3da527408571054"}], "stats": {"total": 20506, "additions": 11676, "deletions": 8830}, "files": [{"sha": "05993830a0fb4ab5d30336f75be3e5001e1fc770", "filename": "COPYRIGHT", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/COPYRIGHT", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/COPYRIGHT", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/COPYRIGHT?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -339,3 +339,53 @@ their own copyright notices and license terms:\n     NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n     USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY\n     OF SUCH DAMAGE.\n+\n+* Portions of internationalization code use code or data from Unicode, which\n+  carry the following license:\n+\n+      UNICODE, INC. LICENSE AGREEMENT - DATA FILES AND SOFTWARE\n+\n+    See Terms of Use <https://www.unicode.org/copyright.html>\n+    for definitions of Unicode Inc.\u2019s Data Files and Software.\n+\n+    NOTICE TO USER: Carefully read the following legal agreement.\n+    BY DOWNLOADING, INSTALLING, COPYING OR OTHERWISE USING UNICODE INC.'S\n+    DATA FILES (\"DATA FILES\"), AND/OR SOFTWARE (\"SOFTWARE\"),\n+    YOU UNEQUIVOCALLY ACCEPT, AND AGREE TO BE BOUND BY, ALL OF THE\n+    TERMS AND CONDITIONS OF THIS AGREEMENT.\n+    IF YOU DO NOT AGREE, DO NOT DOWNLOAD, INSTALL, COPY, DISTRIBUTE OR USE\n+    THE DATA FILES OR SOFTWARE.\n+\n+    COPYRIGHT AND PERMISSION NOTICE\n+\n+    Copyright \u00a9 1991-2022 Unicode, Inc. All rights reserved.\n+    Distributed under the Terms of Use in https://www.unicode.org/copyright.html.\n+\n+    Permission is hereby granted, free of charge, to any person obtaining\n+    a copy of the Unicode data files and any associated documentation\n+    (the \"Data Files\") or Unicode software and any associated documentation\n+    (the \"Software\") to deal in the Data Files or Software\n+    without restriction, including without limitation the rights to use,\n+    copy, modify, merge, publish, distribute, and/or sell copies of\n+    the Data Files or Software, and to permit persons to whom the Data Files\n+    or Software are furnished to do so, provided that either\n+    (a) this copyright and permission notice appear with all copies\n+    of the Data Files or Software, or\n+    (b) this copyright and permission notice appear in associated\n+    Documentation.\n+\n+    THE DATA FILES AND SOFTWARE ARE PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n+    ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n+    WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+    NONINFRINGEMENT OF THIRD PARTY RIGHTS.\n+    IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS\n+    NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL\n+    DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n+    DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n+    TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n+    PERFORMANCE OF THE DATA FILES OR SOFTWARE.\n+\n+    Except as contained in this notice, the name of a copyright holder\n+    shall not be used in advertising or otherwise to promote the sale,\n+    use or other dealings in these Data Files or Software without prior\n+    written authorization of the copyright holder."}, {"sha": "f230f50212a3b841ef1b5aff6dc5c9db566b55bb", "filename": "Cargo.lock", "status": "modified", "additions": 120, "deletions": 45, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -427,7 +427,6 @@ dependencies = [\n  \"glob\",\n  \"itertools\",\n  \"lazy_static\",\n- \"remove_dir_all\",\n  \"serde_json\",\n  \"snapbox\",\n  \"tar\",\n@@ -449,7 +448,7 @@ dependencies = [\n  \"jobserver\",\n  \"libc\",\n  \"log\",\n- \"miow\",\n+ \"miow 0.4.0\",\n  \"same-file\",\n  \"shell-escape\",\n  \"tempfile\",\n@@ -815,7 +814,8 @@ dependencies = [\n  \"lazy_static\",\n  \"lazycell\",\n  \"libc\",\n- \"miow\",\n+ \"miow 0.3.7\",\n+ \"miropt-test-tools\",\n  \"regex\",\n  \"rustfix\",\n  \"serde\",\n@@ -839,7 +839,7 @@ dependencies = [\n  \"lazy_static\",\n  \"libc\",\n  \"log\",\n- \"miow\",\n+ \"miow 0.3.7\",\n  \"regex\",\n  \"rustfix\",\n  \"serde\",\n@@ -852,9 +852,9 @@ dependencies = [\n \n [[package]]\n name = \"concolor\"\n-version = \"0.0.8\"\n+version = \"0.0.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"015267563b1df20adccdd00cb05257b1dfbea70a04928e9cf88ffb850c1a40af\"\n+checksum = \"b90f9dcd9490a97db91a85ccd79e38a87e14323f0bb824659ee3274e9143ba37\"\n dependencies = [\n  \"atty\",\n  \"bitflags\",\n@@ -863,9 +863,9 @@ dependencies = [\n \n [[package]]\n name = \"concolor-query\"\n-version = \"0.0.5\"\n+version = \"0.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d6417fe6fc03a8b533fd2177742eeb39a90c7233eedec7bac96d4d6b69a09449\"\n+checksum = \"82a90734b3d5dcf656e7624cca6bce9c3a90ee11f900e80141a7427ccfb3d317\"\n \n [[package]]\n name = \"content_inspector\"\n@@ -1035,9 +1035,9 @@ dependencies = [\n \n [[package]]\n name = \"curl\"\n-version = \"0.4.43\"\n+version = \"0.4.44\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"37d855aeef205b43f65a5001e0997d81f8efca7badad4fad7d897aa7f0d0651f\"\n+checksum = \"509bd11746c7ac09ebd19f0b17782eae80aadee26237658a6b4808afb5c11a22\"\n dependencies = [\n  \"curl-sys\",\n  \"libc\",\n@@ -1050,9 +1050,9 @@ dependencies = [\n \n [[package]]\n name = \"curl-sys\"\n-version = \"0.4.55+curl-7.83.1\"\n+version = \"0.4.59+curl-7.86.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"23734ec77368ec583c2e61dd3f0b0e5c98b93abe6d2a004ca06b91dd7e3e2762\"\n+checksum = \"6cfce34829f448b08f55b7db6d0009e23e2e86a34e8c2b366269bf5799b4a407\"\n dependencies = [\n  \"cc\",\n  \"libc\",\n@@ -1153,6 +1153,17 @@ dependencies = [\n  \"winapi\",\n ]\n \n+[[package]]\n+name = \"displaydoc\"\n+version = \"0.2.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3bf95dc3f046b9da4f2d51833c0d3547d8564ef6910f5c1ed130306a75b92886\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n [[package]]\n name = \"dlmalloc\"\n version = \"0.2.3\"\n@@ -1514,11 +1525,11 @@ dependencies = [\n \n [[package]]\n name = \"getrandom\"\n-version = \"0.1.14\"\n+version = \"0.1.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7abc8dd8451921606d809ba32e95b6111925cd2906060d2dcc29c070220503eb\"\n+checksum = \"8fc3cb4d91f53b50155bdcfd23f6a4c39ae1969c2ae85982b135750cccaf5fce\"\n dependencies = [\n- \"cfg-if 0.1.10\",\n+ \"cfg-if 1.0.0\",\n  \"libc\",\n  \"wasi 0.9.0+wasi-snapshot-preview1\",\n ]\n@@ -1833,11 +1844,10 @@ dependencies = [\n \n [[package]]\n name = \"intl_pluralrules\"\n-version = \"7.0.1\"\n+version = \"7.0.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b18f988384267d7066cc2be425e6faf352900652c046b6971d2e228d3b1c5ecf\"\n+checksum = \"078ea7b7c29a2b4df841a7f6ac8775ff6074020c6776d48491ce2268e068f972\"\n dependencies = [\n- \"tinystr\",\n  \"unic-langid\",\n ]\n \n@@ -2246,6 +2256,15 @@ dependencies = [\n  \"winapi\",\n ]\n \n+[[package]]\n+name = \"miow\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a7377f7792b3afb6a3cba68daa54ca23c032137010460d667fda53a8d66be00e\"\n+dependencies = [\n+ \"windows-sys 0.28.0\",\n+]\n+\n [[package]]\n name = \"miri\"\n version = \"0.1.0\"\n@@ -2268,6 +2287,13 @@ dependencies = [\n  \"ui_test\",\n ]\n \n+[[package]]\n+name = \"miropt-test-tools\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"regex\",\n+]\n+\n [[package]]\n name = \"new_debug_unreachable\"\n version = \"1.0.4\"\n@@ -2460,7 +2486,7 @@ name = \"panic_abort\"\n version = \"0.0.0\"\n dependencies = [\n  \"alloc\",\n- \"cfg-if 0.1.10\",\n+ \"cfg-if 1.0.0\",\n  \"compiler_builtins\",\n  \"core\",\n  \"libc\",\n@@ -2471,7 +2497,7 @@ name = \"panic_unwind\"\n version = \"0.0.0\"\n dependencies = [\n  \"alloc\",\n- \"cfg-if 0.1.10\",\n+ \"cfg-if 1.0.0\",\n  \"compiler_builtins\",\n  \"core\",\n  \"libc\",\n@@ -2523,7 +2549,7 @@ dependencies = [\n  \"libc\",\n  \"redox_syscall\",\n  \"smallvec\",\n- \"windows-sys\",\n+ \"windows-sys 0.36.1\",\n ]\n \n [[package]]\n@@ -2799,7 +2825,7 @@ version = \"0.7.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"6a6b1679d49b24bbfe0c803429aa1874472f50d9b363131f0e89fc356b544d03\"\n dependencies = [\n- \"getrandom 0.1.14\",\n+ \"getrandom 0.1.16\",\n  \"libc\",\n  \"rand_chacha 0.2.2\",\n  \"rand_core 0.5.1\",\n@@ -2843,7 +2869,7 @@ version = \"0.5.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"90bde5296fc891b0cef12a6d03ddccc162ce7b2aff54160af9338f8d40df6d19\"\n dependencies = [\n- \"getrandom 0.1.14\",\n+ \"getrandom 0.1.16\",\n ]\n \n [[package]]\n@@ -3646,7 +3672,6 @@ dependencies = [\n name = \"rustc_interface\"\n version = \"0.0.0\"\n dependencies = [\n- \"libc\",\n  \"libloading\",\n  \"rustc-rayon\",\n  \"rustc-rayon-core\",\n@@ -3689,7 +3714,6 @@ dependencies = [\n  \"rustc_ty_utils\",\n  \"smallvec\",\n  \"tracing\",\n- \"winapi\",\n ]\n \n [[package]]\n@@ -4109,6 +4133,7 @@ name = \"rustc_session\"\n version = \"0.0.0\"\n dependencies = [\n  \"getopts\",\n+ \"libc\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n@@ -4120,7 +4145,9 @@ dependencies = [\n  \"rustc_serialize\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"smallvec\",\n  \"tracing\",\n+ \"winapi\",\n ]\n \n [[package]]\n@@ -4610,9 +4637,9 @@ checksum = \"da73c8f77aebc0e40c300b93f0a5f1bece7a248a36eee287d4e095f35c7b7d6e\"\n \n [[package]]\n name = \"snapbox\"\n-version = \"0.3.3\"\n+version = \"0.4.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"44d199ccf8f606592df2d145db26f2aa45344e23c64b074cc5a4047f1d99b0f7\"\n+checksum = \"827c00e91b15e2674d8a5270bae91f898693cbf9561cbb58d8eaa31974597293\"\n dependencies = [\n  \"concolor\",\n  \"content_inspector\",\n@@ -4869,9 +4896,9 @@ checksum = \"b1141d4d61095b28419e22cb0bbf02755f5e54e0526f97f1e3d1d160e60885fb\"\n \n [[package]]\n name = \"thin-vec\"\n-version = \"0.2.8\"\n+version = \"0.2.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"104c2cb3180b6fb6d5b2278768e9b88b578d32ba751ea6e8d026688a40d7ed87\"\n+checksum = \"ceb05e71730d396f960f8f3901cdb41be2d339b303e9d7d3a07c5ff0536e671b\"\n \n [[package]]\n name = \"thiserror\"\n@@ -4919,7 +4946,9 @@ name = \"tidy\"\n version = \"0.1.0\"\n dependencies = [\n  \"cargo_metadata 0.14.0\",\n+ \"ignore\",\n  \"lazy_static\",\n+ \"miropt-test-tools\",\n  \"regex\",\n  \"walkdir\",\n ]\n@@ -4940,9 +4969,12 @@ dependencies = [\n \n [[package]]\n name = \"tinystr\"\n-version = \"0.3.4\"\n+version = \"0.7.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"29738eedb4388d9ea620eeab9384884fc3f06f586a2eddb56bedc5885126c7c1\"\n+checksum = \"f8aeafdfd935e4a7fe16a91ab711fa52d54df84f9c8f7ca5837a9d1d902ef4c2\"\n+dependencies = [\n+ \"displaydoc\",\n+]\n \n [[package]]\n name = \"tinyvec\"\n@@ -5178,28 +5210,28 @@ dependencies = [\n \n [[package]]\n name = \"unic-langid\"\n-version = \"0.9.0\"\n+version = \"0.9.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"73328fcd730a030bdb19ddf23e192187a6b01cd98be6d3140622a89129459ce5\"\n+checksum = \"398f9ad7239db44fd0f80fe068d12ff22d78354080332a5077dc6f52f14dcf2f\"\n dependencies = [\n  \"unic-langid-impl\",\n  \"unic-langid-macros\",\n ]\n \n [[package]]\n name = \"unic-langid-impl\"\n-version = \"0.9.0\"\n+version = \"0.9.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1a4a8eeaf0494862c1404c95ec2f4c33a2acff5076f64314b465e3ddae1b934d\"\n+checksum = \"e35bfd2f2b8796545b55d7d3fd3e89a0613f68a0d1c8bc28cb7ff96b411a35ff\"\n dependencies = [\n  \"tinystr\",\n ]\n \n [[package]]\n name = \"unic-langid-macros\"\n-version = \"0.9.0\"\n+version = \"0.9.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"18f980d6d87e8805f2836d64b4138cc95aa7986fa63b1f51f67d5fbff64dd6e5\"\n+checksum = \"055e618bf694161ffff0466d95cef3e1a5edc59f6ba1888e97801f2b4ebdc4fe\"\n dependencies = [\n  \"proc-macro-hack\",\n  \"tinystr\",\n@@ -5209,9 +5241,9 @@ dependencies = [\n \n [[package]]\n name = \"unic-langid-macros-impl\"\n-version = \"0.9.0\"\n+version = \"0.9.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"29396ffd97e27574c3e01368b1a64267d3064969e4848e2e130ff668be9daa9f\"\n+checksum = \"1f5cdec05b907f4e2f6843f4354f4ce6a5bebe1a56df320a49134944477ce4d8\"\n dependencies = [\n  \"proc-macro-hack\",\n  \"quote\",\n@@ -5335,7 +5367,7 @@ name = \"unwind\"\n version = \"0.0.0\"\n dependencies = [\n  \"cc\",\n- \"cfg-if 0.1.10\",\n+ \"cfg-if 1.0.0\",\n  \"compiler_builtins\",\n  \"core\",\n  \"libc\",\n@@ -5452,43 +5484,86 @@ version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n \n+[[package]]\n+name = \"windows-sys\"\n+version = \"0.28.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"82ca39602d5cbfa692c4b67e3bcbb2751477355141c1ed434c94da4186836ff6\"\n+dependencies = [\n+ \"windows_aarch64_msvc 0.28.0\",\n+ \"windows_i686_gnu 0.28.0\",\n+ \"windows_i686_msvc 0.28.0\",\n+ \"windows_x86_64_gnu 0.28.0\",\n+ \"windows_x86_64_msvc 0.28.0\",\n+]\n+\n [[package]]\n name = \"windows-sys\"\n version = \"0.36.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"ea04155a16a59f9eab786fe12a4a450e75cdb175f9e0d80da1e17db09f55b8d2\"\n dependencies = [\n- \"windows_aarch64_msvc\",\n- \"windows_i686_gnu\",\n- \"windows_i686_msvc\",\n- \"windows_x86_64_gnu\",\n- \"windows_x86_64_msvc\",\n+ \"windows_aarch64_msvc 0.36.1\",\n+ \"windows_i686_gnu 0.36.1\",\n+ \"windows_i686_msvc 0.36.1\",\n+ \"windows_x86_64_gnu 0.36.1\",\n+ \"windows_x86_64_msvc 0.36.1\",\n ]\n \n+[[package]]\n+name = \"windows_aarch64_msvc\"\n+version = \"0.28.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"52695a41e536859d5308cc613b4a022261a274390b25bd29dfff4bf08505f3c2\"\n+\n [[package]]\n name = \"windows_aarch64_msvc\"\n version = \"0.36.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9bb8c3fd39ade2d67e9874ac4f3db21f0d710bee00fe7cab16949ec184eeaa47\"\n \n+[[package]]\n+name = \"windows_i686_gnu\"\n+version = \"0.28.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f54725ac23affef038fecb177de6c9bf065787c2f432f79e3c373da92f3e1d8a\"\n+\n [[package]]\n name = \"windows_i686_gnu\"\n version = \"0.36.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"180e6ccf01daf4c426b846dfc66db1fc518f074baa793aa7d9b9aaeffad6a3b6\"\n \n+[[package]]\n+name = \"windows_i686_msvc\"\n+version = \"0.28.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"51d5158a43cc43623c0729d1ad6647e62fa384a3d135fd15108d37c683461f64\"\n+\n [[package]]\n name = \"windows_i686_msvc\"\n version = \"0.36.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"e2e7917148b2812d1eeafaeb22a97e4813dfa60a3f8f78ebe204bcc88f12f024\"\n \n+[[package]]\n+name = \"windows_x86_64_gnu\"\n+version = \"0.28.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bc31f409f565611535130cfe7ee8e6655d3fa99c1c61013981e491921b5ce954\"\n+\n [[package]]\n name = \"windows_x86_64_gnu\"\n version = \"0.36.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"4dcd171b8776c41b97521e5da127a2d86ad280114807d0b2ab1e462bc764d9e1\"\n \n+[[package]]\n+name = \"windows_x86_64_msvc\"\n+version = \"0.28.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3f2b8c7cbd3bfdddd9ab98769f9746a7fad1bca236554cd032b78d768bc0e89f\"\n+\n [[package]]\n name = \"windows_x86_64_msvc\"\n version = \"0.36.1\""}, {"sha": "13a98eedde86704608ea81167f78ea3e3f5cae69", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -11,6 +11,7 @@ members = [\n   \"src/tools/error_index_generator\",\n   \"src/tools/linkchecker\",\n   \"src/tools/lint-docs\",\n+  \"src/tools/miropt-test-tools\",\n   \"src/tools/rustbook\",\n   \"src/tools/unstable-book-gen\",\n   \"src/tools/tidy\","}, {"sha": "5c1990bb6c97bca9952a7bdefe4151cf24511a56", "filename": "RELEASES.md", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -6,7 +6,7 @@ Language\n - [Error on `as` casts of enums with `#[non_exhaustive]` variants](https://github.com/rust-lang/rust/pull/92744/)\n - [Stabilize `let else`](https://github.com/rust-lang/rust/pull/93628/)\n - [Stabilize generic associated types (GATs)](https://github.com/rust-lang/rust/pull/96709/)\n-- [Add lints `let_underscore_drop`, `let_underscore_lock`, and `let_underscore_must_use` from Clippy](https://github.com/rust-lang/rust/pull/97739/)\n+- [Add lints `let_underscore_drop` and `let_underscore_lock` from Clippy](https://github.com/rust-lang/rust/pull/97739/)\n - [Stabilize `break`ing from arbitrary labeled blocks (\"label-break-value\")](https://github.com/rust-lang/rust/pull/99332/)\n - [Uninitialized integers, floats, and raw pointers are now considered immediate UB](https://github.com/rust-lang/rust/pull/98919/).\n   Usage of `MaybeUninit` is the correct way to work with uninitialized memory.\n@@ -87,6 +87,9 @@ Compatibility Notes\n   This strengthens the forward compatibility lint deprecated_cfg_attr_crate_type_name to deny.\n - [`llvm-has-rust-patches` allows setting the build system to treat the LLVM as having Rust-specific patches](https://github.com/rust-lang/rust/pull/101072)\n   This option may need to be set for distributions that are building Rust with a patched LLVM via `llvm-config`, not the built-in LLVM.\n+- Combining three or more languages (e.g. Objective C, C++ and Rust) into one binary may hit linker limitations when using `lld`. For more information, see [issue 102754][102754].\n+\n+[102754]: https://github.com/rust-lang/rust/issues/102754\n \n Internal Changes\n ----------------"}, {"sha": "9253b7e6891a25db4592b74ce72c513da14482bb", "filename": "compiler/rustc_ast/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_ast%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_ast%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2FCargo.toml?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -14,5 +14,5 @@ rustc_macros = { path = \"../rustc_macros\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_span = { path = \"../rustc_span\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n-thin-vec = \"0.2.8\"\n+thin-vec = \"0.2.9\"\n tracing = \"0.1\""}, {"sha": "6a59b9e6151ce13554f9901e95e88ca75d06153d", "filename": "compiler/rustc_ast_lowering/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_ast_lowering%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_ast_lowering%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2FCargo.toml?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -21,5 +21,5 @@ rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n-thin-vec = \"0.2.8\"\n+thin-vec = \"0.2.9\"\n tracing = \"0.1\""}, {"sha": "21c6a2d26f4c2e54f95ba1e0b99c6c8ac0dac71e", "filename": "compiler/rustc_ast_lowering/src/errors.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -277,8 +277,9 @@ pub struct RegisterConflict<'a> {\n pub struct SubTupleBinding<'a> {\n     #[primary_span]\n     #[label]\n-    #[suggestion_verbose(\n+    #[suggestion(\n         ast_lowering_sub_tuple_binding_suggestion,\n+        style = \"verbose\",\n         code = \"..\",\n         applicability = \"maybe-incorrect\"\n     )]"}, {"sha": "c6955741fd4c2961be0d6b732910770783c9fbf9", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -191,7 +191,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     self.lower_angle_bracketed_parameter_data(data, param_mode, itctx)\n                 }\n                 GenericArgs::Parenthesized(ref data) => match parenthesized_generic_args {\n-                    ParenthesizedGenericArgs::Ok => self.lower_parenthesized_parameter_data(data),\n+                    ParenthesizedGenericArgs::Ok => {\n+                        self.lower_parenthesized_parameter_data(data, itctx)\n+                    }\n                     ParenthesizedGenericArgs::Err => {\n                         // Suggest replacing parentheses with angle brackets `Trait(params...)` to `Trait<params...>`\n                         let sub = if !data.inputs.is_empty() {\n@@ -344,6 +346,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_parenthesized_parameter_data(\n         &mut self,\n         data: &ParenthesizedArgs,\n+        itctx: &ImplTraitContext,\n     ) -> (GenericArgsCtor<'hir>, bool) {\n         // Switch to `PassThrough` mode for anonymous lifetimes; this\n         // means that we permit things like `&Ref<T>`, where `Ref` has\n@@ -355,6 +358,17 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             self.lower_ty_direct(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::FnTraitParam))\n         }));\n         let output_ty = match output {\n+            // Only allow `impl Trait` in return position. i.e.:\n+            // ```rust\n+            // fn f(_: impl Fn() -> impl Debug) -> impl Fn() -> impl Debug\n+            // //      disallowed --^^^^^^^^^^        allowed --^^^^^^^^^^\n+            // ```\n+            FnRetTy::Ty(ty)\n+                if matches!(itctx, ImplTraitContext::ReturnPositionOpaqueTy { .. })\n+                    && self.tcx.features().impl_trait_in_fn_trait_return =>\n+            {\n+                self.lower_ty(&ty, itctx)\n+            }\n             FnRetTy::Ty(ty) => {\n                 self.lower_ty(&ty, &ImplTraitContext::Disallowed(ImplTraitPosition::FnTraitReturn))\n             }"}, {"sha": "dac6abe37f5891d3e3667be00defec2bf8184374", "filename": "compiler/rustc_borrowck/src/diagnostics/bound_region_errors.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -5,14 +5,14 @@ use rustc_infer::infer::region_constraints::Constraint;\n use rustc_infer::infer::region_constraints::RegionConstraintData;\n use rustc_infer::infer::RegionVariableOrigin;\n use rustc_infer::infer::{InferCtxt, RegionResolutionError, SubregionOrigin, TyCtxtInferExt as _};\n-use rustc_infer::traits::{Normalized, ObligationCause, TraitEngine, TraitEngineExt};\n+use rustc_infer::traits::ObligationCause;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::RegionVid;\n use rustc_middle::ty::UniverseIndex;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_span::Span;\n use rustc_trait_selection::traits::query::type_op;\n-use rustc_trait_selection::traits::{SelectionContext, TraitEngineExt as _};\n+use rustc_trait_selection::traits::ObligationCtxt;\n use rustc_traits::{type_op_ascribe_user_type_with_span, type_op_prove_predicate_with_cause};\n \n use std::fmt;\n@@ -240,9 +240,9 @@ impl<'tcx> TypeOpInfo<'tcx> for PredicateQuery<'tcx> {\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n         let (ref infcx, key, _) =\n             mbcx.infcx.tcx.infer_ctxt().build_with_canonical(cause.span, &self.canonical_query);\n-        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-        type_op_prove_predicate_with_cause(infcx, &mut *fulfill_cx, key, cause);\n-        try_extract_error_from_fulfill_cx(fulfill_cx, infcx, placeholder_region, error_region)\n+        let ocx = ObligationCtxt::new(infcx);\n+        type_op_prove_predicate_with_cause(&ocx, key, cause);\n+        try_extract_error_from_fulfill_cx(&ocx, placeholder_region, error_region)\n     }\n }\n \n@@ -281,9 +281,7 @@ where\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n         let (ref infcx, key, _) =\n             mbcx.infcx.tcx.infer_ctxt().build_with_canonical(cause.span, &self.canonical_query);\n-        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-\n-        let mut selcx = SelectionContext::new(infcx);\n+        let ocx = ObligationCtxt::new(infcx);\n \n         // FIXME(lqd): Unify and de-duplicate the following with the actual\n         // `rustc_traits::type_op::type_op_normalize` query to allow the span we need in the\n@@ -292,11 +290,9 @@ where\n         // to normalize the `nll/relate_tys/impl-fn-ignore-binder-via-bottom.rs` test. Check\n         // after #85499 lands to see if its fixes have erased this difference.\n         let (param_env, value) = key.into_parts();\n-        let Normalized { value: _, obligations } =\n-            rustc_trait_selection::traits::normalize(&mut selcx, param_env, cause, value.value);\n-        fulfill_cx.register_predicate_obligations(infcx, obligations);\n+        let _ = ocx.normalize(cause, param_env, value.value);\n \n-        try_extract_error_from_fulfill_cx(fulfill_cx, infcx, placeholder_region, error_region)\n+        try_extract_error_from_fulfill_cx(&ocx, placeholder_region, error_region)\n     }\n }\n \n@@ -329,9 +325,9 @@ impl<'tcx> TypeOpInfo<'tcx> for AscribeUserTypeQuery<'tcx> {\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n         let (ref infcx, key, _) =\n             mbcx.infcx.tcx.infer_ctxt().build_with_canonical(cause.span, &self.canonical_query);\n-        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-        type_op_ascribe_user_type_with_span(infcx, &mut *fulfill_cx, key, Some(cause.span)).ok()?;\n-        try_extract_error_from_fulfill_cx(fulfill_cx, infcx, placeholder_region, error_region)\n+        let ocx = ObligationCtxt::new(infcx);\n+        type_op_ascribe_user_type_with_span(&ocx, key, Some(cause.span)).ok()?;\n+        try_extract_error_from_fulfill_cx(&ocx, placeholder_region, error_region)\n     }\n }\n \n@@ -372,25 +368,24 @@ impl<'tcx> TypeOpInfo<'tcx> for crate::type_check::InstantiateOpaqueType<'tcx> {\n     }\n }\n \n-#[instrument(skip(fulfill_cx, infcx), level = \"debug\")]\n+#[instrument(skip(ocx), level = \"debug\")]\n fn try_extract_error_from_fulfill_cx<'tcx>(\n-    mut fulfill_cx: Box<dyn TraitEngine<'tcx> + 'tcx>,\n-    infcx: &InferCtxt<'tcx>,\n+    ocx: &ObligationCtxt<'_, 'tcx>,\n     placeholder_region: ty::Region<'tcx>,\n     error_region: Option<ty::Region<'tcx>>,\n ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n     // We generally shouldn't have errors here because the query was\n     // already run, but there's no point using `delay_span_bug`\n     // when we're going to emit an error here anyway.\n-    let _errors = fulfill_cx.select_all_or_error(infcx);\n-    let region_constraints = infcx.with_region_constraints(|r| r.clone());\n+    let _errors = ocx.select_all_or_error();\n+    let region_constraints = ocx.infcx.with_region_constraints(|r| r.clone());\n     try_extract_error_from_region_constraints(\n-        infcx,\n+        ocx.infcx,\n         placeholder_region,\n         error_region,\n         &region_constraints,\n-        |vid| infcx.region_var_origin(vid),\n-        |vid| infcx.universe_of_region(infcx.tcx.mk_region(ty::ReVar(vid))),\n+        |vid| ocx.infcx.region_var_origin(vid),\n+        |vid| ocx.infcx.universe_of_region(ocx.infcx.tcx.mk_region(ty::ReVar(vid))),\n     )\n }\n "}, {"sha": "8987a51757cd50ff2fa23fc72aba03839c4d4d59", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -23,7 +23,6 @@ use rustc_span::hygiene::DesugaringKind;\n use rustc_span::symbol::sym;\n use rustc_span::{BytePos, Span, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt;\n-use rustc_trait_selection::traits::TraitEngineExt as _;\n \n use crate::borrow_set::TwoPhaseActivation;\n use crate::borrowck_errors;\n@@ -613,24 +612,20 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         else { return; };\n         // Try to find predicates on *generic params* that would allow copying `ty`\n         let infcx = tcx.infer_ctxt().build();\n-        let mut fulfill_cx = <dyn rustc_infer::traits::TraitEngine<'_>>::new(infcx.tcx);\n-\n         let copy_did = infcx.tcx.lang_items().copy_trait().unwrap();\n         let cause = ObligationCause::new(\n             span,\n             self.mir_hir_id(),\n             rustc_infer::traits::ObligationCauseCode::MiscObligation,\n         );\n-        fulfill_cx.register_bound(\n+        let errors = rustc_trait_selection::traits::fully_solve_bound(\n             &infcx,\n+            cause,\n             self.param_env,\n             // Erase any region vids from the type, which may not be resolved\n             infcx.tcx.erase_regions(ty),\n             copy_did,\n-            cause,\n         );\n-        // Select all, including ambiguous predicates\n-        let errors = fulfill_cx.select_all_or_error(&infcx);\n \n         // Only emit suggestion if all required predicates are on generic\n         let predicates: Result<Vec<_>, _> = errors"}, {"sha": "0e7f243bcf36ced6c9a1889d797b98839f0d8a8a", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -2314,7 +2314,7 @@ impl<'tcx> ClosureRegionRequirementsExt<'tcx> for ClosureRegionRequirements<'tcx\n             tcx,\n             closure_substs,\n             self.num_external_vids,\n-            tcx.typeck_root_def_id(closure_def_id),\n+            closure_def_id.expect_local(),\n         );\n         debug!(\"apply_requirements: closure_mapping={:?}\", closure_mapping);\n "}, {"sha": "95ea42b584a3a6d502798fb28467597764193927", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -4,15 +4,15 @@ use rustc_hir::def_id::LocalDefId;\n use rustc_hir::OpaqueTyOrigin;\n use rustc_infer::infer::TyCtxtInferExt as _;\n use rustc_infer::infer::{DefiningAnchor, InferCtxt};\n-use rustc_infer::traits::{Obligation, ObligationCause, TraitEngine};\n+use rustc_infer::traits::{Obligation, ObligationCause};\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts};\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{\n     self, OpaqueHiddenType, OpaqueTypeKey, ToPredicate, Ty, TyCtxt, TypeFoldable,\n };\n use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n-use rustc_trait_selection::traits::TraitEngineExt as _;\n+use rustc_trait_selection::traits::ObligationCtxt;\n \n use super::RegionInferenceContext;\n \n@@ -252,48 +252,45 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         // type-alias-impl-trait/issue-67844-nested-opaque.rs\n         let infcx =\n             self.tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).build();\n+        let ocx = ObligationCtxt::new(&infcx);\n         // Require the hidden type to be well-formed with only the generics of the opaque type.\n         // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n         // hidden type is well formed even without those bounds.\n         let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(definition_ty.into()))\n             .to_predicate(infcx.tcx);\n-        let mut fulfillment_cx = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n \n         let id_substs = InternalSubsts::identity_for_item(self.tcx, def_id.to_def_id());\n \n         // Require that the hidden type actually fulfills all the bounds of the opaque type, even without\n         // the bounds that the function supplies.\n         let opaque_ty = self.tcx.mk_opaque(def_id.to_def_id(), id_substs);\n-        match infcx\n-            .at(&ObligationCause::misc(instantiated_ty.span, body_id), param_env)\n-            .eq(opaque_ty, definition_ty)\n-        {\n-            Ok(infer_ok) => {\n-                for obligation in infer_ok.obligations {\n-                    fulfillment_cx.register_predicate_obligation(&infcx, obligation);\n-                }\n-            }\n-            Err(err) => {\n-                infcx\n-                    .err_ctxt()\n-                    .report_mismatched_types(\n-                        &ObligationCause::misc(instantiated_ty.span, body_id),\n-                        opaque_ty,\n-                        definition_ty,\n-                        err,\n-                    )\n-                    .emit();\n-            }\n+        if let Err(err) = ocx.eq(\n+            &ObligationCause::misc(instantiated_ty.span, body_id),\n+            param_env,\n+            opaque_ty,\n+            definition_ty,\n+        ) {\n+            infcx\n+                .err_ctxt()\n+                .report_mismatched_types(\n+                    &ObligationCause::misc(instantiated_ty.span, body_id),\n+                    opaque_ty,\n+                    definition_ty,\n+                    err,\n+                )\n+                .emit();\n         }\n \n-        fulfillment_cx.register_predicate_obligation(\n-            &infcx,\n-            Obligation::misc(instantiated_ty.span, body_id, param_env, predicate),\n-        );\n+        ocx.register_obligation(Obligation::misc(\n+            instantiated_ty.span,\n+            body_id,\n+            param_env,\n+            predicate,\n+        ));\n \n         // Check that all obligations are satisfied by the implementation's\n         // version.\n-        let errors = fulfillment_cx.select_all_or_error(&infcx);\n+        let errors = ocx.select_all_or_error();\n \n         // This is still required for many(half of the tests in ui/type-alias-impl-trait)\n         // tests to pass"}, {"sha": "fe24f85fae10a53545d1f0183f0326bb1381b632", "filename": "compiler/rustc_borrowck/src/session_diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -49,7 +49,7 @@ pub(crate) struct GenericDoesNotLiveLongEnough {\n #[derive(LintDiagnostic)]\n #[diag(borrowck_var_does_not_need_mut)]\n pub(crate) struct VarNeedNotMut {\n-    #[suggestion_short(applicability = \"machine-applicable\", code = \"\")]\n+    #[suggestion(style = \"short\", applicability = \"machine-applicable\", code = \"\")]\n     pub span: Span,\n }\n #[derive(Diagnostic)]"}, {"sha": "618da9e3253252886807c2413eb32a57a5d55af4", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 93, "deletions": 34, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -22,7 +22,9 @@ use rustc_hir::{BodyOwnerKind, HirId};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin};\n use rustc_middle::ty::fold::TypeFoldable;\n-use rustc_middle::ty::{self, InlineConstSubsts, InlineConstSubstsParts, RegionVid, Ty, TyCtxt};\n+use rustc_middle::ty::{\n+    self, DefIdTree, InlineConstSubsts, InlineConstSubstsParts, RegionVid, Ty, TyCtxt,\n+};\n use rustc_middle::ty::{InternalSubsts, SubstsRef};\n use std::iter;\n \n@@ -241,15 +243,15 @@ impl<'tcx> UniversalRegions<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         closure_substs: SubstsRef<'tcx>,\n         expected_num_vars: usize,\n-        typeck_root_def_id: DefId,\n+        closure_def_id: LocalDefId,\n     ) -> IndexVec<RegionVid, ty::Region<'tcx>> {\n         let mut region_mapping = IndexVec::with_capacity(expected_num_vars);\n         region_mapping.push(tcx.lifetimes.re_static);\n         tcx.for_each_free_region(&closure_substs, |fr| {\n             region_mapping.push(fr);\n         });\n \n-        for_each_late_bound_region_defined_on(tcx, typeck_root_def_id, |r| {\n+        for_each_late_bound_region_in_recursive_scope(tcx, tcx.local_parent(closure_def_id), |r| {\n             region_mapping.push(r);\n         });\n \n@@ -339,9 +341,8 @@ impl<'tcx> UniversalRegions<'tcx> {\n                 // tests, and the resulting print-outs include def-ids\n                 // and other things that are not stable across tests!\n                 // So we just include the region-vid. Annoying.\n-                let typeck_root_def_id = tcx.typeck_root_def_id(def_id);\n-                for_each_late_bound_region_defined_on(tcx, typeck_root_def_id, |r| {\n-                    err.note(&format!(\"late-bound region is {:?}\", self.to_region_vid(r),));\n+                for_each_late_bound_region_in_recursive_scope(tcx, def_id.expect_local(), |r| {\n+                    err.note(&format!(\"late-bound region is {:?}\", self.to_region_vid(r)));\n                 });\n             }\n             DefiningTy::Generator(def_id, substs, _) => {\n@@ -354,9 +355,8 @@ impl<'tcx> UniversalRegions<'tcx> {\n                 // FIXME: As above, we'd like to print out the region\n                 // `r` but doing so is not stable across architectures\n                 // and so forth.\n-                let typeck_root_def_id = tcx.typeck_root_def_id(def_id);\n-                for_each_late_bound_region_defined_on(tcx, typeck_root_def_id, |r| {\n-                    err.note(&format!(\"late-bound region is {:?}\", self.to_region_vid(r),));\n+                for_each_late_bound_region_in_recursive_scope(tcx, def_id.expect_local(), |r| {\n+                    err.note(&format!(\"late-bound region is {:?}\", self.to_region_vid(r)));\n                 });\n             }\n             DefiningTy::FnDef(def_id, substs) => {\n@@ -421,13 +421,24 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             first_extern_index\n         } else {\n             // If this is a closure, generator, or inline-const, then the late-bound regions from the enclosing\n-            // function are actually external regions to us. For example, here, 'a is not local\n+            // function/closures are actually external regions to us. For example, here, 'a is not local\n             // to the closure c (although it is local to the fn foo):\n             // fn foo<'a>() {\n             //     let c = || { let x: &'a u32 = ...; }\n             // }\n-            self.infcx\n-                .replace_late_bound_regions_with_nll_infer_vars(self.mir_def.did, &mut indices);\n+            for_each_late_bound_region_in_recursive_scope(\n+                self.infcx.tcx,\n+                self.infcx.tcx.local_parent(self.mir_def.did),\n+                |r| {\n+                    debug!(?r);\n+                    if !indices.indices.contains_key(&r) {\n+                        let region_vid = self.infcx.next_nll_region_var(FR);\n+                        debug!(?region_vid);\n+                        indices.insert_late_bound_region(r, region_vid.to_region_vid());\n+                    }\n+                },\n+            );\n+\n             // Any regions created during the execution of `defining_ty` or during the above\n             // late-bound region replacement are all considered 'extern' regions\n             self.infcx.num_region_vars()\n@@ -444,12 +455,16 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             bound_inputs_and_output,\n             &mut indices,\n         );\n-        // Converse of above, if this is a function then the late-bound regions declared on its\n-        // signature are local to the fn.\n-        if self.mir_def.did.to_def_id() == typeck_root_def_id {\n-            self.infcx\n-                .replace_late_bound_regions_with_nll_infer_vars(self.mir_def.did, &mut indices);\n-        }\n+        // Converse of above, if this is a function/closure then the late-bound regions declared on its\n+        // signature are local.\n+        for_each_late_bound_region_in_item(self.infcx.tcx, self.mir_def.did, |r| {\n+            debug!(?r);\n+            if !indices.indices.contains_key(&r) {\n+                let region_vid = self.infcx.next_nll_region_var(FR);\n+                debug!(?region_vid);\n+                indices.insert_late_bound_region(r, region_vid.to_region_vid());\n+            }\n+        });\n \n         let (unnormalized_output_ty, mut unnormalized_input_tys) =\n             inputs_and_output.split_last().unwrap();\n@@ -692,7 +707,13 @@ trait InferCtxtExt<'tcx> {\n     where\n         T: TypeFoldable<'tcx>;\n \n-    fn replace_late_bound_regions_with_nll_infer_vars(\n+    fn replace_late_bound_regions_with_nll_infer_vars_in_recursive_scope(\n+        &self,\n+        mir_def_id: LocalDefId,\n+        indices: &mut UniversalRegionIndices<'tcx>,\n+    );\n+\n+    fn replace_late_bound_regions_with_nll_infer_vars_in_item(\n         &self,\n         mir_def_id: LocalDefId,\n         indices: &mut UniversalRegionIndices<'tcx>,\n@@ -746,13 +767,28 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n     /// set of late-bound regions and checks for any that we have not yet seen, adding them to the\n     /// inputs vector.\n     #[instrument(skip(self, indices))]\n-    fn replace_late_bound_regions_with_nll_infer_vars(\n+    fn replace_late_bound_regions_with_nll_infer_vars_in_recursive_scope(\n+        &self,\n+        mir_def_id: LocalDefId,\n+        indices: &mut UniversalRegionIndices<'tcx>,\n+    ) {\n+        for_each_late_bound_region_in_recursive_scope(self.tcx, mir_def_id, |r| {\n+            debug!(?r);\n+            if !indices.indices.contains_key(&r) {\n+                let region_vid = self.next_nll_region_var(FR);\n+                debug!(?region_vid);\n+                indices.insert_late_bound_region(r, region_vid.to_region_vid());\n+            }\n+        });\n+    }\n+\n+    #[instrument(skip(self, indices))]\n+    fn replace_late_bound_regions_with_nll_infer_vars_in_item(\n         &self,\n         mir_def_id: LocalDefId,\n         indices: &mut UniversalRegionIndices<'tcx>,\n     ) {\n-        let typeck_root_def_id = self.tcx.typeck_root_def_id(mir_def_id.to_def_id());\n-        for_each_late_bound_region_defined_on(self.tcx, typeck_root_def_id, |r| {\n+        for_each_late_bound_region_in_item(self.tcx, mir_def_id, |r| {\n             debug!(?r);\n             if !indices.indices.contains_key(&r) {\n                 let region_vid = self.next_nll_region_var(FR);\n@@ -803,21 +839,44 @@ impl<'tcx> UniversalRegionIndices<'tcx> {\n     }\n }\n \n-/// Iterates over the late-bound regions defined on fn_def_id and\n-/// invokes `f` with the liberated form of each one.\n-fn for_each_late_bound_region_defined_on<'tcx>(\n+/// Iterates over the late-bound regions defined on `mir_def_id` and all of its\n+/// parents, up to the typeck root, and invokes `f` with the liberated form\n+/// of each one.\n+fn for_each_late_bound_region_in_recursive_scope<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    fn_def_id: DefId,\n+    mut mir_def_id: LocalDefId,\n     mut f: impl FnMut(ty::Region<'tcx>),\n ) {\n-    if let Some(late_bounds) = tcx.is_late_bound_map(fn_def_id.expect_local()) {\n-        for &region_def_id in late_bounds.iter() {\n-            let name = tcx.item_name(region_def_id.to_def_id());\n-            let liberated_region = tcx.mk_region(ty::ReFree(ty::FreeRegion {\n-                scope: fn_def_id,\n-                bound_region: ty::BoundRegionKind::BrNamed(region_def_id.to_def_id(), name),\n-            }));\n-            f(liberated_region);\n+    let typeck_root_def_id = tcx.typeck_root_def_id(mir_def_id.to_def_id());\n+\n+    // Walk up the tree, collecting late-bound regions until we hit the typeck root\n+    loop {\n+        for_each_late_bound_region_in_item(tcx, mir_def_id, &mut f);\n+\n+        if mir_def_id.to_def_id() == typeck_root_def_id {\n+            break;\n+        } else {\n+            mir_def_id = tcx.local_parent(mir_def_id);\n         }\n     }\n }\n+\n+/// Iterates over the late-bound regions defined on `mir_def_id` and all of its\n+/// parents, up to the typeck root, and invokes `f` with the liberated form\n+/// of each one.\n+fn for_each_late_bound_region_in_item<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    mir_def_id: LocalDefId,\n+    mut f: impl FnMut(ty::Region<'tcx>),\n+) {\n+    if !tcx.def_kind(mir_def_id).is_fn_like() {\n+        return;\n+    }\n+\n+    for bound_var in tcx.late_bound_vars(tcx.hir().local_def_id_to_hir_id(mir_def_id)) {\n+        let ty::BoundVariableKind::Region(bound_region) = bound_var else { continue; };\n+        let liberated_region = tcx\n+            .mk_region(ty::ReFree(ty::FreeRegion { scope: mir_def_id.to_def_id(), bound_region }));\n+        f(liberated_region);\n+    }\n+}"}, {"sha": "467fa932a1567c49eaf9fb927002da8bf95dc44d", "filename": "compiler/rustc_builtin_macros/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_builtin_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_builtin_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2FCargo.toml?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -23,5 +23,5 @@ rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n-thin-vec = \"0.2.8\"\n+thin-vec = \"0.2.9\"\n tracing = \"0.1\""}, {"sha": "eaf1b1167cf21863153e14be1900acf6220f9e68", "filename": "compiler/rustc_builtin_macros/src/alloc_error_handler.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -0,0 +1,104 @@\n+use crate::util::check_builtin_macro_attribute;\n+\n+use rustc_ast::ptr::P;\n+use rustc_ast::{self as ast, FnHeader, FnSig, Generics, StmtKind};\n+use rustc_ast::{Fn, ItemKind, Stmt, TyKind, Unsafe};\n+use rustc_expand::base::{Annotatable, ExtCtxt};\n+use rustc_span::symbol::{kw, sym, Ident};\n+use rustc_span::Span;\n+use thin_vec::thin_vec;\n+\n+pub fn expand(\n+    ecx: &mut ExtCtxt<'_>,\n+    _span: Span,\n+    meta_item: &ast::MetaItem,\n+    item: Annotatable,\n+) -> Vec<Annotatable> {\n+    check_builtin_macro_attribute(ecx, meta_item, sym::alloc_error_handler);\n+\n+    let orig_item = item.clone();\n+    let not_function = || {\n+        ecx.sess\n+            .parse_sess\n+            .span_diagnostic\n+            .span_err(item.span(), \"alloc_error_handler must be a function\");\n+        vec![orig_item.clone()]\n+    };\n+\n+    // Allow using `#[alloc_error_handler]` on an item statement\n+    // FIXME - if we get deref patterns, use them to reduce duplication here\n+    let (item, is_stmt, sig_span) = match &item {\n+        Annotatable::Item(item) => match item.kind {\n+            ItemKind::Fn(ref fn_kind) => (item, false, ecx.with_def_site_ctxt(fn_kind.sig.span)),\n+            _ => return not_function(),\n+        },\n+        Annotatable::Stmt(stmt) => match &stmt.kind {\n+            StmtKind::Item(item_) => match item_.kind {\n+                ItemKind::Fn(ref fn_kind) => {\n+                    (item_, true, ecx.with_def_site_ctxt(fn_kind.sig.span))\n+                }\n+                _ => return not_function(),\n+            },\n+            _ => return not_function(),\n+        },\n+        _ => return not_function(),\n+    };\n+\n+    // Generate a bunch of new items using the AllocFnFactory\n+    let span = ecx.with_def_site_ctxt(item.span);\n+\n+    // Generate item statements for the allocator methods.\n+    let stmts = vec![generate_handler(ecx, item.ident, span, sig_span)];\n+\n+    // Generate anonymous constant serving as container for the allocator methods.\n+    let const_ty = ecx.ty(sig_span, TyKind::Tup(Vec::new()));\n+    let const_body = ecx.expr_block(ecx.block(span, stmts));\n+    let const_item = ecx.item_const(span, Ident::new(kw::Underscore, span), const_ty, const_body);\n+    let const_item = if is_stmt {\n+        Annotatable::Stmt(P(ecx.stmt_item(span, const_item)))\n+    } else {\n+        Annotatable::Item(const_item)\n+    };\n+\n+    // Return the original item and the new methods.\n+    vec![orig_item, const_item]\n+}\n+\n+// #[rustc_std_internal_symbol]\n+// unsafe fn __rg_oom(size: usize, align: usize) -> ! {\n+//     handler(core::alloc::Layout::from_size_align_unchecked(size, align))\n+// }\n+fn generate_handler(cx: &ExtCtxt<'_>, handler: Ident, span: Span, sig_span: Span) -> Stmt {\n+    let usize = cx.path_ident(span, Ident::new(sym::usize, span));\n+    let ty_usize = cx.ty_path(usize);\n+    let size = Ident::from_str_and_span(\"size\", span);\n+    let align = Ident::from_str_and_span(\"align\", span);\n+\n+    let layout_new = cx.std_path(&[sym::alloc, sym::Layout, sym::from_size_align_unchecked]);\n+    let layout_new = cx.expr_path(cx.path(span, layout_new));\n+    let layout =\n+        cx.expr_call(span, layout_new, vec![cx.expr_ident(span, size), cx.expr_ident(span, align)]);\n+\n+    let call = cx.expr_call_ident(sig_span, handler, vec![layout]);\n+\n+    let never = ast::FnRetTy::Ty(cx.ty(span, TyKind::Never));\n+    let params = vec![cx.param(span, size, ty_usize.clone()), cx.param(span, align, ty_usize)];\n+    let decl = cx.fn_decl(params, never);\n+    let header = FnHeader { unsafety: Unsafe::Yes(span), ..FnHeader::default() };\n+    let sig = FnSig { decl, header, span: span };\n+\n+    let body = Some(cx.block_expr(call));\n+    let kind = ItemKind::Fn(Box::new(Fn {\n+        defaultness: ast::Defaultness::Final,\n+        sig,\n+        generics: Generics::default(),\n+        body,\n+    }));\n+\n+    let special = sym::rustc_std_internal_symbol;\n+    let special = cx.meta_word(span, special);\n+    let attrs = thin_vec![cx.attribute(special)];\n+\n+    let item = cx.item(span, Ident::from_str_and_span(\"__rg_oom\", span), attrs, kind);\n+    cx.stmt_item(sig_span, item)\n+}"}, {"sha": "bde0102186a478165cdadbc0ab5f5904ec2543b9", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -25,6 +25,7 @@ use rustc_expand::base::{MacroExpanderFn, ResolverExpand, SyntaxExtensionKind};\n use rustc_expand::proc_macro::BangProcMacro;\n use rustc_span::symbol::sym;\n \n+mod alloc_error_handler;\n mod assert;\n mod cfg;\n mod cfg_accessible;\n@@ -94,6 +95,7 @@ pub fn register_builtin_macros(resolver: &mut dyn ResolverExpand) {\n     }\n \n     register_attr! {\n+        alloc_error_handler: alloc_error_handler::expand,\n         bench: test::expand_bench,\n         cfg_accessible: cfg_accessible::Expander,\n         cfg_eval: cfg_eval::expand,"}, {"sha": "12bb00d346db42c42c88adfad2d5939df371c1f6", "filename": "compiler/rustc_codegen_cranelift/src/allocator.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -5,6 +5,7 @@ use crate::prelude::*;\n \n use rustc_ast::expand::allocator::{AllocatorKind, AllocatorTy, ALLOCATOR_METHODS};\n use rustc_session::config::OomStrategy;\n+use rustc_span::symbol::sym;\n \n /// Returns whether an allocator shim was created\n pub(crate) fn codegen(\n@@ -23,7 +24,7 @@ pub(crate) fn codegen(\n             module,\n             unwind_context,\n             kind,\n-            tcx.lang_items().oom().is_some(),\n+            tcx.alloc_error_handler_kind(()).unwrap(),\n             tcx.sess.opts.unstable_opts.oom,\n         );\n         true\n@@ -36,7 +37,7 @@ fn codegen_inner(\n     module: &mut impl Module,\n     unwind_context: &mut UnwindContext,\n     kind: AllocatorKind,\n-    has_alloc_error_handler: bool,\n+    alloc_error_handler_kind: AllocatorKind,\n     oom_strategy: OomStrategy,\n ) {\n     let usize_ty = module.target_config().pointer_type();\n@@ -108,12 +109,12 @@ fn codegen_inner(\n         returns: vec![],\n     };\n \n-    let callee_name = if has_alloc_error_handler { \"__rg_oom\" } else { \"__rdl_oom\" };\n+    let callee_name = alloc_error_handler_kind.fn_name(sym::oom);\n \n     let func_id =\n         module.declare_function(\"__rust_alloc_error_handler\", Linkage::Export, &sig).unwrap();\n \n-    let callee_func_id = module.declare_function(callee_name, Linkage::Import, &sig).unwrap();\n+    let callee_func_id = module.declare_function(&callee_name, Linkage::Import, &sig).unwrap();\n \n     let mut ctx = Context::new();\n     ctx.func.signature = sig;"}, {"sha": "e2c9ffe9c1c301dedb200c88e8d8dfb2cd649ef7", "filename": "compiler/rustc_codegen_gcc/src/allocator.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_gcc%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_gcc%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fallocator.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -7,7 +7,7 @@ use rustc_span::symbol::sym;\n \n use crate::GccContext;\n \n-pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_name: &str, kind: AllocatorKind, has_alloc_error_handler: bool) {\n+pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_name: &str, kind: AllocatorKind, alloc_error_handler_kind: AllocatorKind) {\n     let context = &mods.context;\n     let usize =\n         match tcx.sess.target.pointer_width {\n@@ -90,14 +90,7 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_nam\n         .collect();\n     let func = context.new_function(None, FunctionType::Exported, void, &args, name, false);\n \n-    let kind =\n-        if has_alloc_error_handler {\n-            AllocatorKind::Global\n-        }\n-        else {\n-            AllocatorKind::Default\n-        };\n-    let callee = kind.fn_name(sym::oom);\n+    let callee = alloc_error_handler_kind.fn_name(sym::oom);\n     let args: Vec<_> = types.iter().enumerate()\n         .map(|(index, typ)| context.new_parameter(None, *typ, &format!(\"param{}\", index)))\n         .collect();"}, {"sha": "dd0daf2c38b109c9775edf7ca5d70056b9e4c699", "filename": "compiler/rustc_codegen_gcc/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -153,11 +153,11 @@ impl CodegenBackend for GccCodegenBackend {\n }\n \n impl ExtraBackendMethods for GccCodegenBackend {\n-    fn codegen_allocator<'tcx>(&self, tcx: TyCtxt<'tcx>, module_name: &str, kind: AllocatorKind, has_alloc_error_handler: bool) -> Self::Module {\n+    fn codegen_allocator<'tcx>(&self, tcx: TyCtxt<'tcx>, module_name: &str, kind: AllocatorKind, alloc_error_handler_kind: AllocatorKind) -> Self::Module {\n         let mut mods = GccContext {\n             context: Context::default(),\n         };\n-        unsafe { allocator::codegen(tcx, &mut mods, module_name, kind, has_alloc_error_handler); }\n+        unsafe { allocator::codegen(tcx, &mut mods, module_name, kind, alloc_error_handler_kind); }\n         mods\n     }\n "}, {"sha": "fed56cdd43821e6cb2dd76a0918e7dcc5c55bf32", "filename": "compiler/rustc_codegen_llvm/src/allocator.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -15,7 +15,7 @@ pub(crate) unsafe fn codegen(\n     module_llvm: &mut ModuleLlvm,\n     module_name: &str,\n     kind: AllocatorKind,\n-    has_alloc_error_handler: bool,\n+    alloc_error_handler_kind: AllocatorKind,\n ) {\n     let llcx = &*module_llvm.llcx;\n     let llmod = module_llvm.llmod();\n@@ -117,8 +117,7 @@ pub(crate) unsafe fn codegen(\n         attributes::apply_to_llfn(llfn, llvm::AttributePlace::Function, &[uwtable]);\n     }\n \n-    let kind = if has_alloc_error_handler { AllocatorKind::Global } else { AllocatorKind::Default };\n-    let callee = kind.fn_name(sym::oom);\n+    let callee = alloc_error_handler_kind.fn_name(sym::oom);\n     let callee = llvm::LLVMRustGetOrInsertFunction(llmod, callee.as_ptr().cast(), callee.len(), ty);\n     // -> ! DIFlagNoReturn\n     attributes::apply_to_llfn(callee, llvm::AttributePlace::Function, &[no_return]);"}, {"sha": "219a4f8fa89594a909cfb3936557c950067fdac9", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 68, "deletions": 8, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -130,15 +130,24 @@ impl<'ll, 'tcx> AsmBuilderMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n                     op_idx.insert(idx, constraints.len());\n                     constraints.push(reg_to_llvm(reg, Some(&value.layout)));\n                 }\n-                InlineAsmOperandRef::InOut { reg, late: _, in_value, out_place: _ } => {\n+                InlineAsmOperandRef::InOut { reg, late, in_value, out_place: _ } => {\n                     let value = llvm_fixup_input(\n                         self,\n                         in_value.immediate(),\n                         reg.reg_class(),\n                         &in_value.layout,\n                     );\n                     inputs.push(value);\n-                    constraints.push(format!(\"{}\", op_idx[&idx]));\n+\n+                    // In the case of fixed registers, we have the choice of\n+                    // either using a tied operand or duplicating the constraint.\n+                    // We prefer the latter because it matches the behavior of\n+                    // Clang.\n+                    if late && matches!(reg, InlineAsmRegOrRegClass::Reg(_)) {\n+                        constraints.push(format!(\"{}\", reg_to_llvm(reg, Some(&in_value.layout))));\n+                    } else {\n+                        constraints.push(format!(\"{}\", op_idx[&idx]));\n+                    }\n                 }\n                 InlineAsmOperandRef::SymFn { instance } => {\n                     inputs.push(self.cx.get_fn(instance));\n@@ -276,13 +285,13 @@ impl<'ll, 'tcx> AsmBuilderMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n         let mut attrs = SmallVec::<[_; 2]>::new();\n         if options.contains(InlineAsmOptions::PURE) {\n             if options.contains(InlineAsmOptions::NOMEM) {\n-                attrs.push(llvm::AttributeKind::ReadNone.create_attr(self.cx.llcx));\n+                attrs.push(llvm::MemoryEffects::None.create_attr(self.cx.llcx));\n             } else if options.contains(InlineAsmOptions::READONLY) {\n-                attrs.push(llvm::AttributeKind::ReadOnly.create_attr(self.cx.llcx));\n+                attrs.push(llvm::MemoryEffects::ReadOnly.create_attr(self.cx.llcx));\n             }\n             attrs.push(llvm::AttributeKind::WillReturn.create_attr(self.cx.llcx));\n         } else if options.contains(InlineAsmOptions::NOMEM) {\n-            attrs.push(llvm::AttributeKind::InaccessibleMemOnly.create_attr(self.cx.llcx));\n+            attrs.push(llvm::MemoryEffects::InaccessibleMemOnly.create_attr(self.cx.llcx));\n         } else {\n             // LLVM doesn't have an attribute to represent ReadOnly + SideEffect\n         }\n@@ -496,6 +505,44 @@ fn xmm_reg_index(reg: InlineAsmReg) -> Option<u32> {\n     }\n }\n \n+/// If the register is an AArch64 integer register then return its index.\n+fn a64_reg_index(reg: InlineAsmReg) -> Option<u32> {\n+    match reg {\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x0) => Some(0),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x1) => Some(1),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x2) => Some(2),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x3) => Some(3),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x4) => Some(4),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x5) => Some(5),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x6) => Some(6),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x7) => Some(7),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x8) => Some(8),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x9) => Some(9),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x10) => Some(10),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x11) => Some(11),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x12) => Some(12),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x13) => Some(13),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x14) => Some(14),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x15) => Some(15),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x16) => Some(16),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x17) => Some(17),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x18) => Some(18),\n+        // x19 is reserved\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x20) => Some(20),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x21) => Some(21),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x22) => Some(22),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x23) => Some(23),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x24) => Some(24),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x25) => Some(25),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x26) => Some(26),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x27) => Some(27),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x28) => Some(28),\n+        // x29 is reserved\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x30) => Some(30),\n+        _ => None,\n+    }\n+}\n+\n /// If the register is an AArch64 vector register then return its index.\n fn a64_vreg_index(reg: InlineAsmReg) -> Option<u32> {\n     match reg {\n@@ -526,6 +573,22 @@ fn reg_to_llvm(reg: InlineAsmRegOrRegClass, layout: Option<&TyAndLayout<'_>>) ->\n                     'x'\n                 };\n                 format!(\"{{{}mm{}}}\", class, idx)\n+            } else if let Some(idx) = a64_reg_index(reg) {\n+                let class = if let Some(layout) = layout {\n+                    match layout.size.bytes() {\n+                        8 => 'x',\n+                        _ => 'w',\n+                    }\n+                } else {\n+                    // We use i32 as the type for discarded outputs\n+                    'w'\n+                };\n+                if class == 'x' && reg == InlineAsmReg::AArch64(AArch64InlineAsmReg::x30) {\n+                    // LLVM doesn't recognize x30. use lr instead.\n+                    \"{lr}\".to_string()\n+                } else {\n+                    format!(\"{{{}{}}}\", class, idx)\n+                }\n             } else if let Some(idx) = a64_vreg_index(reg) {\n                 let class = if let Some(layout) = layout {\n                     match layout.size.bytes() {\n@@ -541,9 +604,6 @@ fn reg_to_llvm(reg: InlineAsmRegOrRegClass, layout: Option<&TyAndLayout<'_>>) ->\n                     'q'\n                 };\n                 format!(\"{{{}{}}}\", class, idx)\n-            } else if reg == InlineAsmReg::AArch64(AArch64InlineAsmReg::x30) {\n-                // LLVM doesn't recognize x30\n-                \"{lr}\".to_string()\n             } else if reg == InlineAsmReg::Arm(ArmInlineAsmReg::r14) {\n                 // LLVM doesn't recognize r14\n                 \"{lr}\".to_string()"}, {"sha": "d96da5cc11d1f72fba53e7116afb7810ca11d39c", "filename": "compiler/rustc_codegen_llvm/src/attributes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -13,7 +13,7 @@ use smallvec::SmallVec;\n \n use crate::attributes;\n use crate::llvm::AttributePlace::Function;\n-use crate::llvm::{self, AllocKindFlags, Attribute, AttributeKind, AttributePlace};\n+use crate::llvm::{self, AllocKindFlags, Attribute, AttributeKind, AttributePlace, MemoryEffects};\n use crate::llvm_util;\n pub use rustc_attr::{InlineAttr, InstructionSetAttr, OptimizeAttr};\n \n@@ -303,10 +303,10 @@ pub fn from_fn_attrs<'ll, 'tcx>(\n         to_add.push(AttributeKind::ReturnsTwice.create_attr(cx.llcx));\n     }\n     if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::FFI_PURE) {\n-        to_add.push(AttributeKind::ReadOnly.create_attr(cx.llcx));\n+        to_add.push(MemoryEffects::ReadOnly.create_attr(cx.llcx));\n     }\n     if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::FFI_CONST) {\n-        to_add.push(AttributeKind::ReadNone.create_attr(cx.llcx));\n+        to_add.push(MemoryEffects::None.create_attr(cx.llcx));\n     }\n     if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::NAKED) {\n         to_add.push(AttributeKind::Naked.create_attr(cx.llcx));"}, {"sha": "9cb36ce7f1890b967d8ca7f4b948b98c0b4f53bd", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -365,11 +365,14 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                 Int(I64) => \"llvm.ssub.with.overflow.i64\",\n                 Int(I128) => \"llvm.ssub.with.overflow.i128\",\n \n-                Uint(U8) => \"llvm.usub.with.overflow.i8\",\n-                Uint(U16) => \"llvm.usub.with.overflow.i16\",\n-                Uint(U32) => \"llvm.usub.with.overflow.i32\",\n-                Uint(U64) => \"llvm.usub.with.overflow.i64\",\n-                Uint(U128) => \"llvm.usub.with.overflow.i128\",\n+                Uint(_) => {\n+                    // Emit sub and icmp instead of llvm.usub.with.overflow. LLVM considers these\n+                    // to be the canonical form. It will attempt to reform llvm.usub.with.overflow\n+                    // in the backend if profitable.\n+                    let sub = self.sub(lhs, rhs);\n+                    let cmp = self.icmp(IntPredicate::IntULT, lhs, rhs);\n+                    return (sub, cmp);\n+                }\n \n                 _ => unreachable!(),\n             },"}, {"sha": "d51aced85df43141c779d0902244f651bdcb7358", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -108,11 +108,11 @@ impl ExtraBackendMethods for LlvmCodegenBackend {\n         tcx: TyCtxt<'tcx>,\n         module_name: &str,\n         kind: AllocatorKind,\n-        has_alloc_error_handler: bool,\n+        alloc_error_handler_kind: AllocatorKind,\n     ) -> ModuleLlvm {\n         let mut module_llvm = ModuleLlvm::new_metadata(tcx, module_name);\n         unsafe {\n-            allocator::codegen(tcx, &mut module_llvm, module_name, kind, has_alloc_error_handler);\n+            allocator::codegen(tcx, &mut module_llvm, module_name, kind, alloc_error_handler_kind);\n         }\n         module_llvm\n     }"}, {"sha": "e2d0390821d1eb780fb387f5412cc225f325586c", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -183,7 +183,6 @@ pub enum AttributeKind {\n     OptimizeNone = 24,\n     ReturnsTwice = 25,\n     ReadNone = 26,\n-    InaccessibleMemOnly = 27,\n     SanitizeHWAddress = 28,\n     WillReturn = 29,\n     StackProtectReq = 30,\n@@ -590,6 +589,15 @@ pub enum ChecksumKind {\n     SHA256,\n }\n \n+/// LLVMRustMemoryEffects\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum MemoryEffects {\n+    None,\n+    ReadOnly,\n+    InaccessibleMemOnly,\n+}\n+\n extern \"C\" {\n     type Opaque;\n }\n@@ -1175,6 +1183,7 @@ extern \"C\" {\n     pub fn LLVMRustCreateUWTableAttr(C: &Context, async_: bool) -> &Attribute;\n     pub fn LLVMRustCreateAllocSizeAttr(C: &Context, size_arg: u32) -> &Attribute;\n     pub fn LLVMRustCreateAllocKindAttr(C: &Context, size_arg: u64) -> &Attribute;\n+    pub fn LLVMRustCreateMemoryEffectsAttr(C: &Context, effects: MemoryEffects) -> &Attribute;\n \n     // Operations on functions\n     pub fn LLVMRustGetOrInsertFunction<'a>("}, {"sha": "f820e7523712ce541fc32cb1a71dd69623e8a639", "filename": "compiler/rustc_codegen_llvm/src/llvm/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -185,6 +185,13 @@ impl AttributeKind {\n     }\n }\n \n+impl MemoryEffects {\n+    /// Create an LLVM Attribute with these memory effects.\n+    pub fn create_attr(self, llcx: &Context) -> &Attribute {\n+        unsafe { LLVMRustCreateMemoryEffectsAttr(llcx, self) }\n+    }\n+}\n+\n pub fn set_section(llglobal: &Value, section_name: &str) {\n     let section_name_cstr = CString::new(section_name).expect(\"unexpected CString error\");\n     unsafe {"}, {"sha": "18789d00fd3a43592ead105593149437f5d204bc", "filename": "compiler/rustc_codegen_ssa/src/back/archive.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -6,11 +6,12 @@ use rustc_span::symbol::Symbol;\n \n use object::read::archive::ArchiveFile;\n \n-use std::fmt::Display;\n use std::fs::File;\n use std::io;\n use std::path::{Path, PathBuf};\n \n+use crate::errors::ExtractBundledLibsError;\n+\n pub trait ArchiveBuilderBuilder {\n     fn new_archive_builder<'a>(&self, sess: &'a Session) -> Box<dyn ArchiveBuilder<'a> + 'a>;\n \n@@ -28,32 +29,35 @@ pub trait ArchiveBuilderBuilder {\n         is_direct_dependency: bool,\n     ) -> PathBuf;\n \n-    fn extract_bundled_libs(\n-        &self,\n-        rlib: &Path,\n+    fn extract_bundled_libs<'a>(\n+        &'a self,\n+        rlib: &'a Path,\n         outdir: &Path,\n         bundled_lib_file_names: &FxHashSet<Symbol>,\n-    ) -> Result<(), String> {\n-        let message = |msg: &str, e: &dyn Display| format!(\"{} '{}': {}\", msg, &rlib.display(), e);\n+    ) -> Result<(), ExtractBundledLibsError<'_>> {\n         let archive_map = unsafe {\n-            Mmap::map(File::open(rlib).map_err(|e| message(\"failed to open file\", &e))?)\n-                .map_err(|e| message(\"failed to mmap file\", &e))?\n+            Mmap::map(\n+                File::open(rlib)\n+                    .map_err(|e| ExtractBundledLibsError::OpenFile { rlib, error: Box::new(e) })?,\n+            )\n+            .map_err(|e| ExtractBundledLibsError::MmapFile { rlib, error: Box::new(e) })?\n         };\n         let archive = ArchiveFile::parse(&*archive_map)\n-            .map_err(|e| message(\"failed to parse archive\", &e))?;\n+            .map_err(|e| ExtractBundledLibsError::ParseArchive { rlib, error: Box::new(e) })?;\n \n         for entry in archive.members() {\n-            let entry = entry.map_err(|e| message(\"failed to read entry\", &e))?;\n+            let entry = entry\n+                .map_err(|e| ExtractBundledLibsError::ReadEntry { rlib, error: Box::new(e) })?;\n             let data = entry\n                 .data(&*archive_map)\n-                .map_err(|e| message(\"failed to get data from archive member\", &e))?;\n+                .map_err(|e| ExtractBundledLibsError::ArchiveMember { rlib, error: Box::new(e) })?;\n             let name = std::str::from_utf8(entry.name())\n-                .map_err(|e| message(\"failed to convert name\", &e))?;\n+                .map_err(|e| ExtractBundledLibsError::ConvertName { rlib, error: Box::new(e) })?;\n             if !bundled_lib_file_names.contains(&Symbol::intern(name)) {\n                 continue; // We need to extract only native libraries.\n             }\n             std::fs::write(&outdir.join(&name), data)\n-                .map_err(|e| message(\"failed to write file\", &e))?;\n+                .map_err(|e| ExtractBundledLibsError::WriteFile { rlib, error: Box::new(e) })?;\n         }\n         Ok(())\n     }"}, {"sha": "5a1ad792924fcf2ce45a784a9550e5af6d7603da", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 49, "deletions": 86, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -919,29 +919,17 @@ fn link_natively<'a>(\n                         )\n                         .is_some();\n \n-                        sess.note_without_error(\"`link.exe` returned an unexpected error\");\n+                        sess.emit_note(errors::LinkExeUnexpectedError);\n                         if is_vs_installed && has_linker {\n                             // the linker is broken\n-                            sess.note_without_error(\n-                                \"the Visual Studio build tools may need to be repaired \\\n-                                using the Visual Studio installer\",\n-                            );\n-                            sess.note_without_error(\n-                                \"or a necessary component may be missing from the \\\n-                                \\\"C++ build tools\\\" workload\",\n-                            );\n+                            sess.emit_note(errors::RepairVSBuildTools);\n+                            sess.emit_note(errors::MissingCppBuildToolComponent);\n                         } else if is_vs_installed {\n                             // the linker is not installed\n-                            sess.note_without_error(\n-                                \"in the Visual Studio installer, ensure the \\\n-                                \\\"C++ build tools\\\" workload is selected\",\n-                            );\n+                            sess.emit_note(errors::SelectCppBuildToolWorkload);\n                         } else {\n                             // visual studio is not installed\n-                            sess.note_without_error(\n-                                \"you may need to install Visual Studio build tools with the \\\n-                                \\\"C++ build tools\\\" workload\",\n-                            );\n+                            sess.emit_note(errors::VisualStudioNotInstalled);\n                         }\n                     }\n                 }\n@@ -954,35 +942,20 @@ fn link_natively<'a>(\n         Err(e) => {\n             let linker_not_found = e.kind() == io::ErrorKind::NotFound;\n \n-            let mut linker_error = {\n-                if linker_not_found {\n-                    sess.struct_err(&format!(\"linker `{}` not found\", linker_path.display()))\n-                } else {\n-                    sess.struct_err(&format!(\n-                        \"could not exec the linker `{}`\",\n-                        linker_path.display()\n-                    ))\n-                }\n-            };\n-\n-            linker_error.note(&e.to_string());\n-\n-            if !linker_not_found {\n-                linker_error.note(&format!(\"{:?}\", &cmd));\n+            if linker_not_found {\n+                sess.emit_err(errors::LinkerNotFound { linker_path, error: e });\n+            } else {\n+                sess.emit_err(errors::UnableToExeLinker {\n+                    linker_path,\n+                    error: e,\n+                    command_formatted: format!(\"{:?}\", &cmd),\n+                });\n             }\n \n-            linker_error.emit();\n-\n             if sess.target.is_like_msvc && linker_not_found {\n-                sess.note_without_error(\n-                    \"the msvc targets depend on the msvc linker \\\n-                     but `link.exe` was not found\",\n-                );\n-                sess.note_without_error(\n-                    \"please ensure that Visual Studio 2017 or later, or Build Tools \\\n-                     for Visual Studio were installed with the Visual C++ option.\",\n-                );\n-                sess.note_without_error(\"VS Code is a different product, and is not sufficient.\");\n+                sess.emit_note(errors::MsvcMissingLinker);\n+                sess.emit_note(errors::CheckInstalledVisualStudio);\n+                sess.emit_note(errors::UnsufficientVSCodeProduct);\n             }\n             sess.abort_if_errors();\n         }\n@@ -1007,15 +980,13 @@ fn link_natively<'a>(\n                     if !prog.status.success() {\n                         let mut output = prog.stderr.clone();\n                         output.extend_from_slice(&prog.stdout);\n-                        sess.struct_warn(&format!(\n-                            \"processing debug info with `dsymutil` failed: {}\",\n-                            prog.status\n-                        ))\n-                        .note(&escape_string(&output))\n-                        .emit();\n+                        sess.emit_warning(errors::ProcessingDymutilFailed {\n+                            status: prog.status,\n+                            output: escape_string(&output),\n+                        });\n                     }\n                 }\n-                Err(e) => sess.fatal(&format!(\"unable to run `dsymutil`: {}\", e)),\n+                Err(error) => sess.emit_fatal(errors::UnableToRunDsymutil { error }),\n             }\n         }\n \n@@ -1092,15 +1063,14 @@ fn strip_symbols_with_external_utility<'a>(\n             if !prog.status.success() {\n                 let mut output = prog.stderr.clone();\n                 output.extend_from_slice(&prog.stdout);\n-                sess.struct_warn(&format!(\n-                    \"stripping debug info with `{}` failed: {}\",\n-                    util, prog.status\n-                ))\n-                .note(&escape_string(&output))\n-                .emit();\n+                sess.emit_warning(errors::StrippingDebugInfoFailed {\n+                    util,\n+                    status: prog.status,\n+                    output: escape_string(&output),\n+                });\n             }\n         }\n-        Err(e) => sess.fatal(&format!(\"unable to run `{}`: {}\", util, e)),\n+        Err(error) => sess.emit_fatal(errors::UnableToRun { util, error }),\n     }\n }\n \n@@ -1153,7 +1123,8 @@ fn link_sanitizer_runtime(sess: &Session, linker: &mut dyn Linker, name: &str) {\n         if path.exists() {\n             return session_tlib;\n         } else {\n-            let default_sysroot = filesearch::get_or_default_sysroot();\n+            let default_sysroot =\n+                filesearch::get_or_default_sysroot().expect(\"Failed finding sysroot\");\n             let default_tlib = filesearch::make_target_lib_path(\n                 &default_sysroot,\n                 sess.opts.target_triple.triple(),\n@@ -1251,7 +1222,7 @@ pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n             )),\n             (Some(linker), None) => {\n                 let stem = linker.file_stem().and_then(|stem| stem.to_str()).unwrap_or_else(|| {\n-                    sess.fatal(\"couldn't extract file stem from specified linker\")\n+                    sess.emit_fatal(errors::LinkerFileStem);\n                 });\n \n                 let flavor = if stem == \"emcc\" {\n@@ -1378,13 +1349,9 @@ fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLib]) {\n         })\n         .collect();\n     if !lib_args.is_empty() {\n-        sess.note_without_error(\n-            \"Link against the following native artifacts when linking \\\n-                                 against this static library. The order and any duplication \\\n-                                 can be significant on some platforms.\",\n-        );\n+        sess.emit_note(errors::StaticLibraryNativeArtifacts);\n         // Prefix for greppability\n-        sess.note_without_error(&format!(\"native-static-libs: {}\", &lib_args.join(\" \")));\n+        sess.emit_note(errors::NativeStaticLibs { arguments: lib_args.join(\" \") });\n     }\n }\n \n@@ -1688,14 +1655,14 @@ fn add_link_script(cmd: &mut dyn Linker, sess: &Session, tmpdir: &Path, crate_ty\n     match (crate_type, &sess.target.link_script) {\n         (CrateType::Cdylib | CrateType::Executable, Some(script)) => {\n             if !sess.target.linker_flavor.is_gnu() {\n-                sess.fatal(\"can only use link script when linking with GNU-like linker\");\n+                sess.emit_fatal(errors::LinkScriptUnavailable);\n             }\n \n             let file_name = [\"rustc\", &sess.target.llvm_target, \"linkfile.ld\"].join(\"-\");\n \n             let path = tmpdir.join(file_name);\n-            if let Err(e) = fs::write(&path, script.as_ref()) {\n-                sess.fatal(&format!(\"failed to write link script to {}: {}\", path.display(), e));\n+            if let Err(error) = fs::write(&path, script.as_ref()) {\n+                sess.emit_fatal(errors::LinkScriptWriteFailure { path, error });\n             }\n \n             cmd.arg(\"--script\");\n@@ -1841,8 +1808,8 @@ fn add_linked_symbol_object(\n \n     let path = tmpdir.join(\"symbols.o\");\n     let result = std::fs::write(&path, file.write().unwrap());\n-    if let Err(e) = result {\n-        sess.fatal(&format!(\"failed to write {}: {}\", path.display(), e));\n+    if let Err(error) = result {\n+        sess.emit_fatal(errors::FailedToWrite { path, error });\n     }\n     cmd.add_object(&path);\n }\n@@ -2299,14 +2266,10 @@ fn collect_natvis_visualizers(\n                 visualizer_paths.push(visualizer_out_file);\n             }\n             Err(error) => {\n-                sess.warn(\n-                    format!(\n-                        \"Unable to write debugger visualizer file `{}`: {} \",\n-                        visualizer_out_file.display(),\n-                        error\n-                    )\n-                    .as_str(),\n-                );\n+                sess.emit_warning(errors::UnableToWriteDebuggerVisualizer {\n+                    path: visualizer_out_file,\n+                    error,\n+                });\n             }\n         };\n     }\n@@ -2484,7 +2447,7 @@ fn add_upstream_rust_crates<'a>(\n                         let rlib = &src.rlib.as_ref().unwrap().0;\n                         archive_builder_builder\n                             .extract_bundled_libs(rlib, tmpdir, &bundled_libs)\n-                            .unwrap_or_else(|e| sess.fatal(e));\n+                            .unwrap_or_else(|e| sess.emit_fatal(e));\n                     }\n \n                     let mut last = (None, NativeLibKind::Unspecified, None);\n@@ -2641,7 +2604,7 @@ fn add_upstream_rust_crates<'a>(\n                 || !codegen_results.crate_info.is_no_builtins.contains(&cnum);\n \n             let mut archive = archive_builder_builder.new_archive_builder(sess);\n-            if let Err(e) = archive.add_archive(\n+            if let Err(error) = archive.add_archive(\n                 cratepath,\n                 Box::new(move |f| {\n                     if f == METADATA_FILENAME {\n@@ -2681,7 +2644,7 @@ fn add_upstream_rust_crates<'a>(\n                     false\n                 }),\n             ) {\n-                sess.fatal(&format!(\"failed to build archive from rlib: {}\", e));\n+                sess.emit_fatal(errors::RlibArchiveBuildFailure { error });\n             }\n             if archive.build(&dst) {\n                 link_upstream(&dst);\n@@ -2813,14 +2776,14 @@ fn add_apple_sdk(cmd: &mut dyn Linker, sess: &Session, flavor: LinkerFlavor) {\n         (\"arm\", \"watchos\") => \"watchos\",\n         (_, \"macos\") => \"macosx\",\n         _ => {\n-            sess.err(&format!(\"unsupported arch `{}` for os `{}`\", arch, os));\n+            sess.emit_err(errors::UnsupportedArch { arch, os });\n             return;\n         }\n     };\n     let sdk_root = match get_apple_sdk_root(sdk_name) {\n         Ok(s) => s,\n         Err(e) => {\n-            sess.err(&e);\n+            sess.emit_err(e);\n             return;\n         }\n     };\n@@ -2836,7 +2799,7 @@ fn add_apple_sdk(cmd: &mut dyn Linker, sess: &Session, flavor: LinkerFlavor) {\n     }\n }\n \n-fn get_apple_sdk_root(sdk_name: &str) -> Result<String, String> {\n+fn get_apple_sdk_root(sdk_name: &str) -> Result<String, errors::AppleSdkRootError<'_>> {\n     // Following what clang does\n     // (https://github.com/llvm/llvm-project/blob/\n     // 296a80102a9b72c3eda80558fb78a3ed8849b341/clang/lib/Driver/ToolChains/Darwin.cpp#L1661-L1678)\n@@ -2886,7 +2849,7 @@ fn get_apple_sdk_root(sdk_name: &str) -> Result<String, String> {\n \n     match res {\n         Ok(output) => Ok(output.trim().to_string()),\n-        Err(e) => Err(format!(\"failed to get {} SDK path: {}\", sdk_name, e)),\n+        Err(error) => Err(errors::AppleSdkRootError::SdkPath { sdk_name, error }),\n     }\n }\n \n@@ -2919,7 +2882,7 @@ fn add_gcc_ld_path(cmd: &mut dyn Linker, sess: &Session, flavor: LinkerFlavor) {\n                 }\n             }\n         } else {\n-            sess.fatal(\"option `-Z gcc-ld` is used even though linker flavor is not gcc\");\n+            sess.emit_fatal(errors::OptionGccOnly);\n         }\n     }\n }"}, {"sha": "752f6b1ef40c92fcdd64994d03c715f9ad6ee90b", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -193,8 +193,11 @@ fn exported_symbols_provider_local<'tcx>(\n     }\n \n     if tcx.allocator_kind(()).is_some() {\n-        for method in ALLOCATOR_METHODS {\n-            let symbol_name = format!(\"__rust_{}\", method.name);\n+        for symbol_name in ALLOCATOR_METHODS\n+            .iter()\n+            .map(|method| format!(\"__rust_{}\", method.name))\n+            .chain([\"__rust_alloc_error_handler\".to_string(), OomStrategy::SYMBOL.to_string()])\n+        {\n             let exported_symbol = ExportedSymbol::NoDefId(SymbolName::new(tcx, &symbol_name));\n \n             symbols.push(("}, {"sha": "c1411690f8289883f8cc391bffd19018b797fad0", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -22,7 +22,6 @@ use rustc_data_structures::sync::ParallelIterator;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::lang_items::LangItem;\n-use rustc_hir::weak_lang_items::WEAK_ITEMS_SYMBOLS;\n use rustc_index::vec::Idx;\n use rustc_metadata::EncodedMetadata;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrs;\n@@ -639,7 +638,14 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n         let llmod_id =\n             cgu_name_builder.build_cgu_name(LOCAL_CRATE, &[\"crate\"], Some(\"allocator\")).to_string();\n         let module_llvm = tcx.sess.time(\"write_allocator_module\", || {\n-            backend.codegen_allocator(tcx, &llmod_id, kind, tcx.lang_items().oom().is_some())\n+            backend.codegen_allocator(\n+                tcx,\n+                &llmod_id,\n+                kind,\n+                // If allocator_kind is Some then alloc_error_handler_kind must\n+                // also be Some.\n+                tcx.alloc_error_handler_kind(()).unwrap(),\n+            )\n         });\n \n         Some(ModuleCodegen { name: llmod_id, module_llvm, kind: ModuleKind::Allocator })\n@@ -887,14 +893,14 @@ impl CrateInfo {\n         // by the compiler, but that's ok because all this stuff is unstable anyway.\n         let target = &tcx.sess.target;\n         if !are_upstream_rust_objects_already_included(tcx.sess) {\n-            let missing_weak_lang_items: FxHashSet<&Symbol> = info\n+            let missing_weak_lang_items: FxHashSet<Symbol> = info\n                 .used_crates\n                 .iter()\n-                .flat_map(|cnum| {\n-                    tcx.missing_lang_items(*cnum)\n-                        .iter()\n-                        .filter(|l| lang_items::required(tcx, **l))\n-                        .filter_map(|item| WEAK_ITEMS_SYMBOLS.get(item))\n+                .flat_map(|&cnum| tcx.missing_lang_items(cnum))\n+                .filter(|l| l.is_weak())\n+                .filter_map(|&l| {\n+                    let name = l.link_name()?;\n+                    lang_items::required(tcx, l).then_some(name)\n                 })\n                 .collect();\n             let prefix = if target.is_like_windows && target.arch == \"x86\" { \"_\" } else { \"\" };"}, {"sha": "36c94462b0b3e50cd338e8ef3a2420231b289297", "filename": "compiler/rustc_codegen_ssa/src/errors.rs", "status": "modified", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -354,3 +354,170 @@ impl IntoDiagnostic<'_> for LinkingFailed<'_> {\n         diag\n     }\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_link_exe_unexpected_error)]\n+pub struct LinkExeUnexpectedError;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_repair_vs_build_tools)]\n+pub struct RepairVSBuildTools;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_missing_cpp_build_tool_component)]\n+pub struct MissingCppBuildToolComponent;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_select_cpp_build_tool_workload)]\n+pub struct SelectCppBuildToolWorkload;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_visual_studio_not_installed)]\n+pub struct VisualStudioNotInstalled;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_linker_not_found)]\n+#[note]\n+pub struct LinkerNotFound {\n+    pub linker_path: PathBuf,\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_unable_to_exe_linker)]\n+#[note]\n+#[note(command_note)]\n+pub struct UnableToExeLinker {\n+    pub linker_path: PathBuf,\n+    pub error: Error,\n+    pub command_formatted: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_msvc_missing_linker)]\n+pub struct MsvcMissingLinker;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_check_installed_visual_studio)]\n+pub struct CheckInstalledVisualStudio;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_unsufficient_vs_code_product)]\n+pub struct UnsufficientVSCodeProduct;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_processing_dymutil_failed)]\n+#[note]\n+pub struct ProcessingDymutilFailed {\n+    pub status: ExitStatus,\n+    pub output: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_unable_to_run_dsymutil)]\n+#[note]\n+pub struct UnableToRunDsymutil {\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_stripping_debu_info_failed)]\n+#[note]\n+pub struct StrippingDebugInfoFailed<'a> {\n+    pub util: &'a str,\n+    pub status: ExitStatus,\n+    pub output: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_unable_to_run)]\n+pub struct UnableToRun<'a> {\n+    pub util: &'a str,\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_linker_file_stem)]\n+pub struct LinkerFileStem;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_static_library_native_artifacts)]\n+pub struct StaticLibraryNativeArtifacts;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_native_static_libs)]\n+pub struct NativeStaticLibs {\n+    pub arguments: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_link_script_unavailable)]\n+pub struct LinkScriptUnavailable;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_link_script_write_failure)]\n+pub struct LinkScriptWriteFailure {\n+    pub path: PathBuf,\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_failed_to_write)]\n+pub struct FailedToWrite {\n+    pub path: PathBuf,\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_unable_to_write_debugger_visualizer)]\n+pub struct UnableToWriteDebuggerVisualizer {\n+    pub path: PathBuf,\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_rlib_archive_build_failure)]\n+pub struct RlibArchiveBuildFailure {\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_option_gcc_only)]\n+pub struct OptionGccOnly;\n+\n+#[derive(Diagnostic)]\n+pub enum ExtractBundledLibsError<'a> {\n+    #[diag(codegen_ssa_extract_bundled_libs_open_file)]\n+    OpenFile { rlib: &'a Path, error: Box<dyn std::error::Error> },\n+\n+    #[diag(codegen_ssa_extract_bundled_libs_mmap_file)]\n+    MmapFile { rlib: &'a Path, error: Box<dyn std::error::Error> },\n+\n+    #[diag(codegen_ssa_extract_bundled_libs_parse_archive)]\n+    ParseArchive { rlib: &'a Path, error: Box<dyn std::error::Error> },\n+\n+    #[diag(codegen_ssa_extract_bundled_libs_read_entry)]\n+    ReadEntry { rlib: &'a Path, error: Box<dyn std::error::Error> },\n+\n+    #[diag(codegen_ssa_extract_bundled_libs_archive_member)]\n+    ArchiveMember { rlib: &'a Path, error: Box<dyn std::error::Error> },\n+\n+    #[diag(codegen_ssa_extract_bundled_libs_convert_name)]\n+    ConvertName { rlib: &'a Path, error: Box<dyn std::error::Error> },\n+\n+    #[diag(codegen_ssa_extract_bundled_libs_write_file)]\n+    WriteFile { rlib: &'a Path, error: Box<dyn std::error::Error> },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_unsupported_arch)]\n+pub struct UnsupportedArch<'a> {\n+    pub arch: &'a str,\n+    pub os: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+pub enum AppleSdkRootError<'a> {\n+    #[diag(codegen_ssa_apple_sdk_error_sdk_path)]\n+    SdkPath { sdk_name: &'a str, error: Error },\n+}"}, {"sha": "0802067cde65d85478612cfa1021312d89cfe3f3", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -17,6 +17,7 @@ use rustc_middle::mir::{self, AssertKind, SwitchTargets};\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf};\n use rustc_middle::ty::print::{with_no_trimmed_paths, with_no_visible_paths};\n use rustc_middle::ty::{self, Instance, Ty, TypeVisitable};\n+use rustc_session::config::OptLevel;\n use rustc_span::source_map::Span;\n use rustc_span::{sym, Symbol};\n use rustc_symbol_mangling::typeid::typeid_for_fnabi;\n@@ -286,12 +287,13 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         assert_eq!(discr.layout.ty, switch_ty);\n         let mut target_iter = targets.iter();\n         if target_iter.len() == 1 {\n-            // If there are two targets (one conditional, one fallback), emit br instead of switch\n+            // If there are two targets (one conditional, one fallback), emit `br` instead of\n+            // `switch`.\n             let (test_value, target) = target_iter.next().unwrap();\n             let lltrue = helper.llbb_with_cleanup(self, target);\n             let llfalse = helper.llbb_with_cleanup(self, targets.otherwise());\n             if switch_ty == bx.tcx().types.bool {\n-                // Don't generate trivial icmps when switching on bool\n+                // Don't generate trivial icmps when switching on bool.\n                 match test_value {\n                     0 => bx.cond_br(discr.immediate(), llfalse, lltrue),\n                     1 => bx.cond_br(discr.immediate(), lltrue, llfalse),\n@@ -303,6 +305,30 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let cmp = bx.icmp(IntPredicate::IntEQ, discr.immediate(), llval);\n                 bx.cond_br(cmp, lltrue, llfalse);\n             }\n+        } else if self.cx.sess().opts.optimize == OptLevel::No\n+            && target_iter.len() == 2\n+            && self.mir[targets.otherwise()].is_empty_unreachable()\n+        {\n+            // In unoptimized builds, if there are two normal targets and the `otherwise` target is\n+            // an unreachable BB, emit `br` instead of `switch`. This leaves behind the unreachable\n+            // BB, which will usually (but not always) be dead code.\n+            //\n+            // Why only in unoptimized builds?\n+            // - In unoptimized builds LLVM uses FastISel which does not support switches, so it\n+            //   must fall back to the to the slower SelectionDAG isel. Therefore, using `br` gives\n+            //   significant compile time speedups for unoptimized builds.\n+            // - In optimized builds the above doesn't hold, and using `br` sometimes results in\n+            //   worse generated code because LLVM can no longer tell that the value being switched\n+            //   on can only have two values, e.g. 0 and 1.\n+            //\n+            let (test_value1, target1) = target_iter.next().unwrap();\n+            let (_test_value2, target2) = target_iter.next().unwrap();\n+            let ll1 = helper.llbb_with_cleanup(self, target1);\n+            let ll2 = helper.llbb_with_cleanup(self, target2);\n+            let switch_llty = bx.immediate_backend_type(bx.layout_of(switch_ty));\n+            let llval = bx.const_uint_big(switch_llty, test_value1);\n+            let cmp = bx.icmp(IntPredicate::IntEQ, discr.immediate(), llval);\n+            bx.cond_br(cmp, ll1, ll2);\n         } else {\n             bx.switch(\n                 discr.immediate(),"}, {"sha": "a4368303de5762eb549ab50bd5bac8989333ce58", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -267,6 +267,7 @@ const WASM_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     // tidy-alphabetical-start\n     (\"atomics\", Some(sym::wasm_target_feature)),\n     (\"bulk-memory\", Some(sym::wasm_target_feature)),\n+    (\"multivalue\", Some(sym::wasm_target_feature)),\n     (\"mutable-globals\", Some(sym::wasm_target_feature)),\n     (\"nontrapping-fptoint\", Some(sym::wasm_target_feature)),\n     (\"reference-types\", Some(sym::wasm_target_feature)),"}, {"sha": "5c35070ea66f4f1ffca07091755333058e6f146e", "filename": "compiler/rustc_codegen_ssa/src/traits/backend.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -119,7 +119,7 @@ pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Se\n         tcx: TyCtxt<'tcx>,\n         module_name: &str,\n         kind: AllocatorKind,\n-        has_alloc_error_handler: bool,\n+        alloc_error_handler_kind: AllocatorKind,\n     ) -> Self::Module;\n     /// This generates the codegen unit and returns it along with\n     /// a `u64` giving an estimate of the unit's processing cost."}, {"sha": "f7d64f6d4f48ae2be6f6d29a69b1fa73222f1fe6", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -598,7 +598,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // the last field).  Can't have foreign types here, how would we\n                 // adjust alignment and size for them?\n                 let field = layout.field(self, layout.fields.count() - 1);\n-                let Some((unsized_size, unsized_align)) = self.size_and_align_of(metadata, &field)? else {\n+                let Some((unsized_size, mut unsized_align)) = self.size_and_align_of(metadata, &field)? else {\n                     // A field with an extern type. We don't know the actual dynamic size\n                     // or the alignment.\n                     return Ok(None);\n@@ -614,6 +614,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // Return the sum of sizes and max of aligns.\n                 let size = sized_size + unsized_size; // `Size` addition\n \n+                // Packed types ignore the alignment of their fields.\n+                if let ty::Adt(def, _) = layout.ty.kind() {\n+                    if def.repr().packed() {\n+                        unsized_align = sized_align;\n+                    }\n+                }\n+\n                 // Choose max of two known alignments (combined value must\n                 // be aligned according to more restrictive of the two).\n                 let align = sized_align.max(unsized_align);"}, {"sha": "b92a68788475fcd60c2907b4d36f5cfef02b3e92", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -7,7 +7,9 @@ use std::convert::TryFrom;\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir::{\n     self,\n-    interpret::{ConstValue, GlobalId, InterpResult, PointerArithmetic, Scalar},\n+    interpret::{\n+        Allocation, ConstAllocation, ConstValue, GlobalId, InterpResult, PointerArithmetic, Scalar,\n+    },\n     BinOp, NonDivergingIntrinsic,\n };\n use rustc_middle::ty;\n@@ -23,7 +25,6 @@ use super::{\n };\n \n mod caller_location;\n-mod type_name;\n \n fn numeric_intrinsic<Prov>(name: Symbol, bits: u128, kind: Primitive) -> Scalar<Prov> {\n     let size = match kind {\n@@ -42,6 +43,13 @@ fn numeric_intrinsic<Prov>(name: Symbol, bits: u128, kind: Primitive) -> Scalar<\n     Scalar::from_uint(bits_out, size)\n }\n \n+/// Directly returns an `Allocation` containing an absolute path representation of the given type.\n+pub(crate) fn alloc_type_name<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> ConstAllocation<'tcx> {\n+    let path = crate::util::type_name(tcx, ty);\n+    let alloc = Allocation::from_bytes_byte_aligned_immutable(path.into_bytes());\n+    tcx.intern_const_alloc(alloc)\n+}\n+\n /// The logic for all nullary intrinsics is implemented here. These intrinsics don't get evaluated\n /// inside an `InterpCx` and instead have their value computed directly from rustc internal info.\n pub(crate) fn eval_nullary_intrinsic<'tcx>(\n@@ -55,7 +63,7 @@ pub(crate) fn eval_nullary_intrinsic<'tcx>(\n     Ok(match name {\n         sym::type_name => {\n             ensure_monomorphic_enough(tcx, tp_ty)?;\n-            let alloc = type_name::alloc_type_name(tcx, tp_ty);\n+            let alloc = alloc_type_name(tcx, tp_ty);\n             ConstValue::Slice { data: alloc, start: 0, end: alloc.inner().len() }\n         }\n         sym::needs_drop => {"}, {"sha": "dd00678aa0ceaf0dac275d7fa7f1a48147aa9a16", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -4,7 +4,7 @@\n use rustc_hir::def::Namespace;\n use rustc_middle::ty::layout::{LayoutOf, PrimitiveExt, TyAndLayout};\n use rustc_middle::ty::print::{FmtPrinter, PrettyPrinter};\n-use rustc_middle::ty::{ConstInt, DelaySpanBugEmitted, Ty};\n+use rustc_middle::ty::{ConstInt, Ty};\n use rustc_middle::{mir, ty};\n use rustc_target::abi::{self, Abi, Align, HasDataLayout, Size, TagEncoding};\n use rustc_target::abi::{VariantIdx, Variants};\n@@ -567,7 +567,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     ty::ConstKind::Param(_) | ty::ConstKind::Placeholder(..) => {\n                         throw_inval!(TooGeneric)\n                     }\n-                    ty::ConstKind::Error(DelaySpanBugEmitted { reported, .. }) => {\n+                    ty::ConstKind::Error(reported) => {\n                         throw_inval!(AlreadyReported(reported))\n                     }\n                     ty::ConstKind::Unevaluated(uv) => {"}, {"sha": "b1ad22b899e30215f339ed97c5c0d2496bb8ff00", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 15, "deletions": 27, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -13,11 +13,8 @@ use rustc_middle::ty::{self, adjustment::PointerCast, Instance, InstanceDef, Ty,\n use rustc_middle::ty::{Binder, TraitPredicate, TraitRef, TypeVisitable};\n use rustc_mir_dataflow::{self, Analysis};\n use rustc_span::{sym, Span, Symbol};\n-use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n-use rustc_trait_selection::traits::{\n-    self, ObligationCauseCode, SelectionContext, TraitEngine, TraitEngineExt,\n-};\n+use rustc_trait_selection::traits::{self, ObligationCauseCode, ObligationCtxt, SelectionContext};\n \n use std::mem;\n use std::ops::Deref;\n@@ -747,35 +744,26 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                     // \"non-const\" check. This is required for correctness here.\n                     {\n                         let infcx = tcx.infer_ctxt().build();\n-                        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n+                        let ocx = ObligationCtxt::new(&infcx);\n+\n                         let predicates = tcx.predicates_of(callee).instantiate(tcx, substs);\n                         let hir_id = tcx\n                             .hir()\n                             .local_def_id_to_hir_id(self.body.source.def_id().expect_local());\n-                        let cause = || {\n-                            ObligationCause::new(\n-                                terminator.source_info.span,\n-                                hir_id,\n-                                ObligationCauseCode::ItemObligation(callee),\n-                            )\n-                        };\n-                        let normalized = infcx.partially_normalize_associated_types_in(\n-                            cause(),\n-                            param_env,\n-                            predicates,\n+                        let cause = ObligationCause::new(\n+                            terminator.source_info.span,\n+                            hir_id,\n+                            ObligationCauseCode::ItemObligation(callee),\n                         );\n-\n-                        for p in normalized.obligations {\n-                            fulfill_cx.register_predicate_obligation(&infcx, p);\n-                        }\n-                        for obligation in traits::predicates_for_generics(\n-                            |_, _| cause(),\n+                        let normalized_predicates =\n+                            ocx.normalize(cause.clone(), param_env, predicates);\n+                        ocx.register_obligations(traits::predicates_for_generics(\n+                            |_, _| cause.clone(),\n                             self.param_env,\n-                            normalized.value,\n-                        ) {\n-                            fulfill_cx.register_predicate_obligation(&infcx, obligation);\n-                        }\n-                        let errors = fulfill_cx.select_all_or_error(&infcx);\n+                            normalized_predicates,\n+                        ));\n+\n+                        let errors = ocx.select_all_or_error();\n                         if !errors.is_empty() {\n                             infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n                         }"}, {"sha": "f48bcd9080966dafe2d693b828bb04aee3aafc69", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -45,11 +45,10 @@ impl<'tcx> MirPass<'tcx> for PromoteTemps<'tcx> {\n         // There's not really any point in promoting errorful MIR.\n         //\n         // This does not include MIR that failed const-checking, which we still try to promote.\n-        if body.return_ty().references_error() {\n-            tcx.sess.delay_span_bug(body.span, \"PromoteTemps: MIR had errors\");\n+        if let Err(_) = body.return_ty().error_reported() {\n+            debug!(\"PromoteTemps: MIR had errors\");\n             return;\n         }\n-\n         if body.source.promoted.is_some() {\n             return;\n         }"}, {"sha": "5446ccb1a47307e7608a7f28b78a27c50b12237d", "filename": "compiler/rustc_const_eval/src/util/call_kind.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcall_kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcall_kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcall_kind.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -3,7 +3,7 @@\n //! context.\n \n use rustc_hir::def_id::DefId;\n-use rustc_hir::lang_items::LangItemGroup;\n+use rustc_hir::lang_items;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, AssocItemContainer, DefIdTree, Instance, ParamEnv, Ty, TyCtxt};\n use rustc_span::symbol::Ident;\n@@ -74,22 +74,24 @@ pub fn call_kind<'tcx>(\n         }\n     });\n \n-    let fn_call = parent\n-        .and_then(|p| tcx.lang_items().group(LangItemGroup::Fn).iter().find(|did| **did == p));\n+    let fn_call = parent.and_then(|p| {\n+        lang_items::FN_TRAITS.iter().filter_map(|&l| tcx.lang_items().get(l)).find(|&id| id == p)\n+    });\n \n-    let operator = (!from_hir_call)\n-        .then(|| parent)\n-        .flatten()\n-        .and_then(|p| tcx.lang_items().group(LangItemGroup::Op).iter().find(|did| **did == p));\n+    let operator = if !from_hir_call && let Some(p) = parent {\n+        lang_items::OPERATORS.iter().filter_map(|&l| tcx.lang_items().get(l)).find(|&id| id == p)\n+    } else {\n+        None\n+    };\n \n     let is_deref = !from_hir_call && tcx.is_diagnostic_item(sym::deref_method, method_did);\n \n     // Check for a 'special' use of 'self' -\n     // an FnOnce call, an operator (e.g. `<<`), or a\n     // deref coercion.\n-    let kind = if let Some(&trait_id) = fn_call {\n+    let kind = if let Some(trait_id) = fn_call {\n         Some(CallKind::FnCall { fn_trait_id: trait_id, self_ty: method_substs.type_at(0) })\n-    } else if let Some(&trait_id) = operator {\n+    } else if let Some(trait_id) = operator {\n         Some(CallKind::Operator { self_arg, trait_id, self_ty: method_substs.type_at(0) })\n     } else if is_deref {\n         let deref_target = tcx.get_diagnostic_item(sym::deref_target).and_then(|deref_target| {"}, {"sha": "4d0f81a4060088b669d85902ca9013a50f7e3e4c", "filename": "compiler/rustc_const_eval/src/util/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -4,9 +4,11 @@ mod call_kind;\n pub mod collect_writes;\n mod find_self_call;\n mod might_permit_raw_init;\n+mod type_name;\n \n pub use self::aggregate::expand_aggregate;\n pub use self::alignment::is_disaligned;\n pub use self::call_kind::{call_kind, CallDesugaringKind, CallKind};\n pub use self::find_self_call::find_self_call;\n pub use self::might_permit_raw_init::might_permit_raw_init;\n+pub use self::type_name::type_name;"}, {"sha": "08a6d69b8e40c28422fc6a8710606cdca7b65d37", "filename": "compiler/rustc_const_eval/src/util/type_name.rs", "status": "renamed", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Ftype_name.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -1,10 +1,9 @@\n use rustc_data_structures::intern::Interned;\n use rustc_hir::def_id::CrateNum;\n use rustc_hir::definitions::DisambiguatedDefPathData;\n-use rustc_middle::mir::interpret::{Allocation, ConstAllocation};\n use rustc_middle::ty::{\n     self,\n-    print::{with_no_verbose_constants, PrettyPrinter, Print, Printer},\n+    print::{PrettyPrinter, Print, Printer},\n     subst::{GenericArg, GenericArgKind},\n     Ty, TyCtxt,\n };\n@@ -74,18 +73,10 @@ impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n     }\n \n     fn print_dyn_existential(\n-        mut self,\n+        self,\n         predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n     ) -> Result<Self::DynExistential, Self::Error> {\n-        let mut first = true;\n-        for p in predicates {\n-            if !first {\n-                write!(self, \"+\")?;\n-            }\n-            first = false;\n-            self = p.print(self)?;\n-        }\n-        Ok(self)\n+        self.pretty_print_dyn_existential(predicates)\n     }\n \n     fn path_crate(mut self, cnum: CrateNum) -> Result<Self::Path, Self::Error> {\n@@ -179,6 +170,11 @@ impl<'tcx> PrettyPrinter<'tcx> for AbsolutePathPrinter<'tcx> {\n \n         Ok(self)\n     }\n+\n+    fn should_print_verbose(&self) -> bool {\n+        // `std::any::type_name` should never print verbose type names\n+        false\n+    }\n }\n \n impl Write for AbsolutePathPrinter<'_> {\n@@ -188,11 +184,6 @@ impl Write for AbsolutePathPrinter<'_> {\n     }\n }\n \n-/// Directly returns an `Allocation` containing an absolute path representation of the given type.\n-pub(crate) fn alloc_type_name<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> ConstAllocation<'tcx> {\n-    let path = with_no_verbose_constants!(\n-        AbsolutePathPrinter { tcx, path: String::new() }.print_type(ty).unwrap().path\n-    );\n-    let alloc = Allocation::from_bytes_byte_aligned_immutable(path.into_bytes());\n-    tcx.intern_const_alloc(alloc)\n+pub fn type_name<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> String {\n+    AbsolutePathPrinter { tcx, path: String::new() }.print_type(ty).unwrap().path\n }", "previous_filename": "compiler/rustc_const_eval/src/interpret/intrinsics/type_name.rs"}, {"sha": "5152d5ab0465c126f50dda00f3513f80ea10d80d", "filename": "compiler/rustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2FCargo.toml?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -25,7 +25,7 @@ smallvec = { version = \"1.8.1\", features = [\"const_generics\", \"union\", \"may_dang\n stable_deref_trait = \"1.0.0\"\n stacker = \"0.1.14\"\n tempfile = \"3.2\"\n-thin-vec = \"0.2.8\"\n+thin-vec = \"0.2.9\"\n tracing = \"0.1\"\n \n [dependencies.parking_lot]"}, {"sha": "c550f246e094aa77358d0010610e108226caf5af", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -410,6 +410,7 @@ impl<T> Lock<T> {\n \n     #[cfg(parallel_compiler)]\n     #[inline(always)]\n+    #[track_caller]\n     pub fn lock(&self) -> LockGuard<'_, T> {\n         if ERROR_CHECKING {\n             self.0.try_lock().expect(\"lock was already held\")\n@@ -420,21 +421,25 @@ impl<T> Lock<T> {\n \n     #[cfg(not(parallel_compiler))]\n     #[inline(always)]\n+    #[track_caller]\n     pub fn lock(&self) -> LockGuard<'_, T> {\n         self.0.borrow_mut()\n     }\n \n     #[inline(always)]\n+    #[track_caller]\n     pub fn with_lock<F: FnOnce(&mut T) -> R, R>(&self, f: F) -> R {\n         f(&mut *self.lock())\n     }\n \n     #[inline(always)]\n+    #[track_caller]\n     pub fn borrow(&self) -> LockGuard<'_, T> {\n         self.lock()\n     }\n \n     #[inline(always)]\n+    #[track_caller]\n     pub fn borrow_mut(&self) -> LockGuard<'_, T> {\n         self.lock()\n     }\n@@ -476,6 +481,7 @@ impl<T> RwLock<T> {\n \n     #[cfg(not(parallel_compiler))]\n     #[inline(always)]\n+    #[track_caller]\n     pub fn read(&self) -> ReadGuard<'_, T> {\n         self.0.borrow()\n     }\n@@ -491,6 +497,7 @@ impl<T> RwLock<T> {\n     }\n \n     #[inline(always)]\n+    #[track_caller]\n     pub fn with_read_lock<F: FnOnce(&T) -> R, R>(&self, f: F) -> R {\n         f(&*self.read())\n     }\n@@ -509,6 +516,7 @@ impl<T> RwLock<T> {\n \n     #[cfg(not(parallel_compiler))]\n     #[inline(always)]\n+    #[track_caller]\n     pub fn write(&self) -> WriteGuard<'_, T> {\n         self.0.borrow_mut()\n     }\n@@ -524,16 +532,19 @@ impl<T> RwLock<T> {\n     }\n \n     #[inline(always)]\n+    #[track_caller]\n     pub fn with_write_lock<F: FnOnce(&mut T) -> R, R>(&self, f: F) -> R {\n         f(&mut *self.write())\n     }\n \n     #[inline(always)]\n+    #[track_caller]\n     pub fn borrow(&self) -> ReadGuard<'_, T> {\n         self.read()\n     }\n \n     #[inline(always)]\n+    #[track_caller]\n     pub fn borrow_mut(&self) -> WriteGuard<'_, T> {\n         self.write()\n     }"}, {"sha": "cf4bcc7c158fcb83cbaa34fe6435046d826118d3", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -1200,6 +1200,7 @@ pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n         false,\n         None,\n         false,\n+        false,\n     ));\n     let handler = rustc_errors::Handler::with_emitter(true, None, emitter);\n "}, {"sha": "cbc4980f8cab3bd7bcea297902ac6a2ab9db364d", "filename": "compiler/rustc_error_codes/src/error_codes/E0382.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0382.md", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0382.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0382.md?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -61,7 +61,7 @@ with `#[derive(Clone)]`.\n \n Some types have no ownership semantics at all and are trivial to duplicate. An\n example is `i32` and the other number types. We don't have to call `.clone()` to\n-clone them, because they are marked `Copy` in addition to `Clone`.  Implicit\n+clone them, because they are marked `Copy` in addition to `Clone`. Implicit\n cloning is more convenient in this case. We can mark our own types `Copy` if\n all their members also are marked `Copy`.\n "}, {"sha": "ad0d758210175fb096eefe07f0929da10767fae6", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_ssa.ftl", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -119,3 +119,66 @@ codegen_ssa_thorin_object_read = {$error}\n codegen_ssa_thorin_object_write = {$error}\n codegen_ssa_thorin_gimli_read = {$error}\n codegen_ssa_thorin_gimli_write = {$error}\n+\n+codegen_ssa_link_exe_unexpected_error = `link.exe` returned an unexpected error\n+\n+codegen_ssa_repair_vs_build_tools = the Visual Studio build tools may need to be repaired using the Visual Studio installer\n+\n+codegen_ssa_missing_cpp_build_tool_component = or a necessary component may be missing from the \"C++ build tools\" workload\n+\n+codegen_ssa_select_cpp_build_tool_workload = in the Visual Studio installer, ensure the \"C++ build tools\" workload is selected\n+\n+codegen_ssa_visual_studio_not_installed = you may need to install Visual Studio build tools with the \"C++ build tools\" workload\n+\n+codegen_ssa_linker_not_found = linker `{$linker_path}` not found\n+    .note = {$error}\n+\n+codegen_ssa_unable_to_exe_linker = could not exec the linker `{$linker_path}`\n+    .note = {$error}\n+    .command_note = {$command_formatted}\n+\n+codegen_ssa_msvc_missing_linker = the msvc targets depend on the msvc linker but `link.exe` was not found\n+\n+codegen_ssa_check_installed_visual_studio = please ensure that Visual Studio 2017 or later, or Build Tools for Visual Studio were installed with the Visual C++ option.\n+\n+codegen_ssa_unsufficient_vs_code_product = VS Code is a different product, and is not sufficient.\n+\n+codegen_ssa_processing_dymutil_failed = processing debug info with `dsymutil` failed: {$status}\n+    .note = {$output}\n+\n+codegen_ssa_unable_to_run_dsymutil = unable to run `dsymutil`: {$error}\n+\n+codegen_ssa_stripping_debu_info_failed = stripping debug info with `{$util}` failed: {$status}\n+    .note = {$output}\n+\n+codegen_ssa_unable_to_run = unable to run `{$util}`: {$error}\n+\n+codegen_ssa_linker_file_stem = couldn't extract file stem from specified linker\n+\n+codegen_ssa_static_library_native_artifacts = Link against the following native artifacts when linking against this static library. The order and any duplication can be significant on some platforms.\n+\n+codegen_ssa_native_static_libs = native-static-libs: {$arguments}\n+\n+codegen_ssa_link_script_unavailable = can only use link script when linking with GNU-like linker\n+\n+codegen_ssa_link_script_write_failure = failed to write link script to {$path}: {$error}\n+\n+codegen_ssa_failed_to_write = failed to write {$path}: {$error}\n+\n+codegen_ssa_unable_to_write_debugger_visualizer = Unable to write debugger visualizer file `{$path}`: {$error}\n+\n+codegen_ssa_rlib_archive_build_failure = failed to build archive from rlib: {$error}\n+\n+codegen_ssa_option_gcc_only = option `-Z gcc-ld` is used even though linker flavor is not gcc\n+\n+codegen_ssa_extract_bundled_libs_open_file = failed to open file '{$rlib}': {$error}\n+codegen_ssa_extract_bundled_libs_mmap_file = failed to mmap file '{$rlib}': {$error}\n+codegen_ssa_extract_bundled_libs_parse_archive = failed to parse archive '{$rlib}': {$error}\n+codegen_ssa_extract_bundled_libs_read_entry = failed to read entry '{$rlib}': {$error}\n+codegen_ssa_extract_bundled_libs_archive_member = failed to get data from archive member '{$rlib}': {$error}\n+codegen_ssa_extract_bundled_libs_convert_name = failed to convert name '{$rlib}': {$error}\n+codegen_ssa_extract_bundled_libs_write_file = failed to write file '{$rlib}': {$error}\n+\n+codegen_ssa_unsupported_arch = unsupported arch `{$arch}` for os `{$os}`\n+\n+codegen_ssa_apple_sdk_error_sdk_path = failed to get {$sdk_name} SDK path: {error}"}, {"sha": "c292ae9b32abba5af8a913994643c571303332c2", "filename": "compiler/rustc_error_messages/locales/en-US/metadata.ftl", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -150,12 +150,28 @@ metadata_no_multiple_global_alloc =\n metadata_prev_global_alloc =\n     previous global allocator defined here\n \n+metadata_no_multiple_alloc_error_handler =\n+    cannot define multiple allocation error handlers\n+    .label = cannot define a new allocation error handler\n+\n+metadata_prev_alloc_error_handler =\n+    previous allocation error handler defined here\n+\n metadata_conflicting_global_alloc =\n     the `#[global_allocator]` in {$other_crate_name} conflicts with global allocator in: {$crate_name}\n \n+metadata_conflicting_alloc_error_handler =\n+    the `#[alloc_error_handler]` in {$other_crate_name} conflicts with allocation error handler in: {$crate_name}\n+\n metadata_global_alloc_required =\n     no global memory allocator found but one is required; link to std or add `#[global_allocator]` to a static item that implements the GlobalAlloc trait\n \n+metadata_alloc_func_required =\n+    `#[alloc_error_handler]` function required, but not found\n+\n+metadata_missing_alloc_error_handler =\n+    use `#![feature(default_alloc_error_handler)]` for a default error handler\n+\n metadata_no_transitive_needs_dep =\n     the crate `{$crate_name}` cannot depend on a crate that needs {$needs_crate_name}, but it depends on `{$deps_crate_name}`\n "}, {"sha": "81d8e8a473bb7184ca5b3892d727eb7523954682", "filename": "compiler/rustc_error_messages/locales/en-US/middle.ftl", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmiddle.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmiddle.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmiddle.ftl?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -27,3 +27,7 @@ middle_values_too_big =\n \n middle_cannot_be_normalized =\n     unable to determine layout for `{$ty}` because `{$failure_ty}` cannot be normalized\n+\n+middle_strict_coherence_needs_negative_coherence =\n+    to use `strict_coherence` on this trait, the `with_negative_coherence` feature must be enabled\n+    .label = due to this attribute"}, {"sha": "48ddb54b79e795eb3c67f96b69bb5dda24e32f01", "filename": "compiler/rustc_error_messages/locales/en-US/monomorphize.ftl", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmonomorphize.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmonomorphize.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmonomorphize.ftl?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -21,6 +21,3 @@ monomorphize_large_assignments =\n     moving {$size} bytes\n     .label = value moved from here\n     .note = The current maximum size is {$limit}, but it can be customized with the move_size_limit attribute: `#![move_size_limit = \"...\"]`\n-\n-monomorphize_requires_lang_item =\n-    requires `{$lang_item}` lang_item"}, {"sha": "5239ff9dc0571d31e0bb58fd6b1e2044deb09b6e", "filename": "compiler/rustc_error_messages/locales/en-US/passes.ftl", "status": "modified", "additions": 41, "deletions": 8, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -367,12 +367,6 @@ passes_unknown_external_lang_item =\n passes_missing_panic_handler =\n     `#[panic_handler]` function required, but not found\n \n-passes_alloc_func_required =\n-    `#[alloc_error_handler]` function required, but not found\n-\n-passes_missing_alloc_error_handler =\n-    use `#![feature(default_alloc_error_handler)]` for a default error handler\n-\n passes_missing_lang_item =\n     language item required, but not found: `{$name}`\n     .note = this can occur when a binary crate with `#![no_std]` is compiled for a target where `{$name}` is defined in the standard library\n@@ -457,8 +451,14 @@ passes_break_inside_async_block =\n     .async_block_label = enclosing `async` block\n \n passes_outside_loop =\n-    `{$name}` outside of a loop\n-    .label = cannot `{$name}` outside of a loop\n+    `{$name}` outside of a loop{$is_break ->\n+        [true] {\" or labeled block\"}\n+        *[false] {\"\"}\n+    }\n+    .label = cannot `{$name}` outside of a loop{$is_break ->\n+        [true] {\" or labeled block\"}\n+        *[false] {\"\"}\n+    }\n \n passes_unlabeled_in_labeled_block =\n     unlabeled `{$cf_type}` inside of a labeled block\n@@ -671,3 +671,36 @@ passes_missing_const_err =\n     attributes `#[rustc_const_unstable]` and `#[rustc_const_stable]` require the function or method to be `const`\n     .help = make the function or method const\n     .label = attribute specified here\n+\n+passes_dead_codes =\n+    { $multiple ->\n+      *[true] multiple {$descr}s are\n+       [false] { $num ->\n+         [one] {$descr} {$name_list} is\n+        *[other] {$descr}s {$name_list} are\n+       }\n+    } never {$participle}\n+\n+passes_change_fields_to_be_of_unit_type =\n+    consider changing the { $num ->\n+      [one] field\n+     *[other] fields\n+    } to be of unit type to suppress this warning while preserving the field numbering, or remove the { $num ->\n+      [one] field\n+     *[other] fields\n+    }\n+\n+passes_parent_info =\n+    {$num ->\n+      [one] {$descr}\n+     *[other] {$descr}s\n+    } in this {$parent_descr}\n+\n+passes_ignored_derived_impls =\n+    `{$name}` has {$trait_list_len ->\n+      [one] a derived impl\n+     *[other] derived impls\n+    } for the {$trait_list_len ->\n+      [one] trait {$trait_list}, but this is\n+     *[other] traits {$trait_list}, but these are\n+    } intentionally ignored during dead code analysis"}, {"sha": "45c017df918e87060cb771ca8ed83cf4d4de8f80", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -12,6 +12,7 @@ use rustc_span::{Span, DUMMY_SP};\n use std::borrow::Cow;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n+use std::panic::Location;\n \n /// Error type for `Diagnostic`'s `suggestions` field, indicating that\n /// `.disable_suggestions()` was called on the `Diagnostic`.\n@@ -107,6 +108,31 @@ pub struct Diagnostic {\n     /// If diagnostic is from Lint, custom hash function ignores notes\n     /// otherwise hash is based on the all the fields\n     pub is_lint: bool,\n+\n+    /// With `-Ztrack_diagnostics` enabled,\n+    /// we print where in rustc this error was emitted.\n+    pub emitted_at: DiagnosticLocation,\n+}\n+\n+#[derive(Clone, Debug, Encodable, Decodable)]\n+pub struct DiagnosticLocation {\n+    file: Cow<'static, str>,\n+    line: u32,\n+    col: u32,\n+}\n+\n+impl DiagnosticLocation {\n+    #[track_caller]\n+    fn caller() -> Self {\n+        let loc = Location::caller();\n+        DiagnosticLocation { file: loc.file().into(), line: loc.line(), col: loc.column() }\n+    }\n+}\n+\n+impl fmt::Display for DiagnosticLocation {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}:{}:{}\", self.file, self.line, self.col)\n+    }\n }\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash, Encodable, Decodable)]\n@@ -173,10 +199,12 @@ impl StringPart {\n }\n \n impl Diagnostic {\n+    #[track_caller]\n     pub fn new<M: Into<DiagnosticMessage>>(level: Level, message: M) -> Self {\n         Diagnostic::new_with_code(level, None, message)\n     }\n \n+    #[track_caller]\n     pub fn new_with_code<M: Into<DiagnosticMessage>>(\n         level: Level,\n         code: Option<DiagnosticId>,\n@@ -192,6 +220,7 @@ impl Diagnostic {\n             args: Default::default(),\n             sort_span: DUMMY_SP,\n             is_lint: false,\n+            emitted_at: DiagnosticLocation::caller(),\n         }\n     }\n "}, {"sha": "ecf8570e81f7131d25f5df080fce350d0c062175", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -133,6 +133,7 @@ mod sealed_level_is_error {\n impl<'a> DiagnosticBuilder<'a, ErrorGuaranteed> {\n     /// Convenience function for internal use, clients should use one of the\n     /// `struct_*` methods on [`Handler`].\n+    #[track_caller]\n     pub(crate) fn new_guaranteeing_error<M: Into<DiagnosticMessage>, const L: Level>(\n         handler: &'a Handler,\n         message: M,\n@@ -196,6 +197,7 @@ impl EmissionGuarantee for ErrorGuaranteed {\n         }\n     }\n \n+    #[track_caller]\n     fn make_diagnostic_builder(\n         handler: &Handler,\n         msg: impl Into<DiagnosticMessage>,\n@@ -209,6 +211,7 @@ impl EmissionGuarantee for ErrorGuaranteed {\n impl<'a> DiagnosticBuilder<'a, ()> {\n     /// Convenience function for internal use, clients should use one of the\n     /// `struct_*` methods on [`Handler`].\n+    #[track_caller]\n     pub(crate) fn new<M: Into<DiagnosticMessage>>(\n         handler: &'a Handler,\n         level: Level,\n@@ -220,6 +223,7 @@ impl<'a> DiagnosticBuilder<'a, ()> {\n \n     /// Creates a new `DiagnosticBuilder` with an already constructed\n     /// diagnostic.\n+    #[track_caller]\n     pub(crate) fn new_diagnostic(handler: &'a Handler, diagnostic: Diagnostic) -> Self {\n         debug!(\"Created new diagnostic\");\n         Self {\n@@ -308,6 +312,7 @@ impl EmissionGuarantee for Noted {\n impl<'a> DiagnosticBuilder<'a, !> {\n     /// Convenience function for internal use, clients should use one of the\n     /// `struct_*` methods on [`Handler`].\n+    #[track_caller]\n     pub(crate) fn new_fatal(handler: &'a Handler, message: impl Into<DiagnosticMessage>) -> Self {\n         let diagnostic = Diagnostic::new_with_code(Level::Fatal, None, message);\n         Self::new_diagnostic_fatal(handler, diagnostic)"}, {"sha": "22f6fc700fad371be7c15ecd14ff14ecb4136aa3", "filename": "compiler/rustc_errors/src/diagnostic_impls.rs", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -11,8 +11,10 @@ use rustc_target::abi::TargetDataLayoutErrors;\n use rustc_target::spec::{PanicStrategy, SplitDebuginfo, StackProtector, TargetTriple};\n use std::borrow::Cow;\n use std::fmt;\n+use std::fmt::Write;\n use std::num::ParseIntError;\n use std::path::{Path, PathBuf};\n+use std::process::ExitStatus;\n \n pub struct DiagnosticArgFromDisplay<'a>(pub &'a dyn fmt::Display);\n \n@@ -58,6 +60,7 @@ into_diagnostic_arg_using_display!(\n     i128,\n     u128,\n     std::io::Error,\n+    std::boxed::Box<dyn std::error::Error>,\n     std::num::NonZeroU32,\n     hir::Target,\n     Edition,\n@@ -66,7 +69,8 @@ into_diagnostic_arg_using_display!(\n     ParseIntError,\n     StackProtector,\n     &TargetTriple,\n-    SplitDebuginfo\n+    SplitDebuginfo,\n+    ExitStatus,\n );\n \n impl IntoDiagnosticArg for bool {\n@@ -170,6 +174,37 @@ impl IntoDiagnosticArg for Level {\n     }\n }\n \n+#[derive(Clone)]\n+pub struct DiagnosticSymbolList(Vec<Symbol>);\n+\n+impl From<Vec<Symbol>> for DiagnosticSymbolList {\n+    fn from(v: Vec<Symbol>) -> Self {\n+        DiagnosticSymbolList(v)\n+    }\n+}\n+\n+impl IntoDiagnosticArg for DiagnosticSymbolList {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        // FIXME: replace the logic here with a real list formatter\n+        let symbols = match &self.0[..] {\n+            [symbol] => format!(\"`{symbol}`\"),\n+            [symbol, last] => {\n+                format!(\"`{symbol}` and `{last}`\",)\n+            }\n+            [symbols @ .., last] => {\n+                let mut result = String::new();\n+                for symbol in symbols {\n+                    write!(result, \"`{symbol}`, \").unwrap();\n+                }\n+                write!(result, \"and `{last}`\").unwrap();\n+                result\n+            }\n+            [] => unreachable!(),\n+        };\n+        DiagnosticArgValue::Str(Cow::Owned(symbols))\n+    }\n+}\n+\n impl IntoDiagnostic<'_, !> for TargetDataLayoutErrors<'_> {\n     fn into_diagnostic(self, handler: &Handler) -> DiagnosticBuilder<'_, !> {\n         let mut diag;"}, {"sha": "b7b8fe3f25a04c43de3b24f6b93ca162789cd88b", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 31, "deletions": 5, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -16,10 +16,10 @@ use crate::snippet::{Annotation, AnnotationType, Line, MultilineAnnotation, Styl\n use crate::styled_buffer::StyledBuffer;\n use crate::translation::{to_fluent_args, Translate};\n use crate::{\n-    CodeSuggestion, Diagnostic, DiagnosticId, DiagnosticMessage, FluentBundle, Handler,\n-    LazyFallbackBundle, Level, MultiSpan, SubDiagnostic, SubstitutionHighlight, SuggestionStyle,\n+    diagnostic::DiagnosticLocation, CodeSuggestion, Diagnostic, DiagnosticId, DiagnosticMessage,\n+    FluentBundle, Handler, LazyFallbackBundle, Level, MultiSpan, SubDiagnostic,\n+    SubstitutionHighlight, SuggestionStyle,\n };\n-\n use rustc_lint_defs::pluralize;\n \n use rustc_data_structures::fx::{FxHashMap, FxIndexMap};\n@@ -64,6 +64,7 @@ impl HumanReadableErrorType {\n         teach: bool,\n         diagnostic_width: Option<usize>,\n         macro_backtrace: bool,\n+        track_diagnostics: bool,\n     ) -> EmitterWriter {\n         let (short, color_config) = self.unzip();\n         let color = color_config.suggests_using_colors();\n@@ -77,6 +78,7 @@ impl HumanReadableErrorType {\n             color,\n             diagnostic_width,\n             macro_backtrace,\n+            track_diagnostics,\n         )\n     }\n }\n@@ -557,6 +559,7 @@ impl Emitter for EmitterWriter {\n             &primary_span,\n             &children,\n             &suggestions,\n+            self.track_diagnostics.then_some(&diag.emitted_at),\n         );\n     }\n \n@@ -650,6 +653,7 @@ pub struct EmitterWriter {\n     diagnostic_width: Option<usize>,\n \n     macro_backtrace: bool,\n+    track_diagnostics: bool,\n }\n \n #[derive(Debug)]\n@@ -669,6 +673,7 @@ impl EmitterWriter {\n         teach: bool,\n         diagnostic_width: Option<usize>,\n         macro_backtrace: bool,\n+        track_diagnostics: bool,\n     ) -> EmitterWriter {\n         let dst = Destination::from_stderr(color_config);\n         EmitterWriter {\n@@ -681,6 +686,7 @@ impl EmitterWriter {\n             ui_testing: false,\n             diagnostic_width,\n             macro_backtrace,\n+            track_diagnostics,\n         }\n     }\n \n@@ -694,6 +700,7 @@ impl EmitterWriter {\n         colored: bool,\n         diagnostic_width: Option<usize>,\n         macro_backtrace: bool,\n+        track_diagnostics: bool,\n     ) -> EmitterWriter {\n         EmitterWriter {\n             dst: Raw(dst, colored),\n@@ -705,6 +712,7 @@ impl EmitterWriter {\n             ui_testing: false,\n             diagnostic_width,\n             macro_backtrace,\n+            track_diagnostics,\n         }\n     }\n \n@@ -1327,6 +1335,7 @@ impl EmitterWriter {\n         level: &Level,\n         max_line_num_len: usize,\n         is_secondary: bool,\n+        emitted_at: Option<&DiagnosticLocation>,\n     ) -> io::Result<()> {\n         let mut buffer = StyledBuffer::new();\n \n@@ -1377,7 +1386,6 @@ impl EmitterWriter {\n                 }\n             }\n         }\n-\n         let mut annotated_files = FileWithAnnotatedLines::collect_annotations(self, args, msp);\n \n         // Make sure our primary file comes first\n@@ -1653,6 +1661,12 @@ impl EmitterWriter {\n             }\n         }\n \n+        if let Some(tracked) = emitted_at {\n+            let track = format!(\"-Ztrack-diagnostics: created at {tracked}\");\n+            let len = buffer.num_lines();\n+            buffer.append(len, &track, Style::NoStyle);\n+        }\n+\n         // final step: take our styled buffer, render it, then output it\n         emit_to_destination(&buffer.render(), level, &mut self.dst, self.short_message)?;\n \n@@ -1977,6 +1991,7 @@ impl EmitterWriter {\n         span: &MultiSpan,\n         children: &[SubDiagnostic],\n         suggestions: &[CodeSuggestion],\n+        emitted_at: Option<&DiagnosticLocation>,\n     ) {\n         let max_line_num_len = if self.ui_testing {\n             ANONYMIZED_LINE_NUM.len()\n@@ -1985,7 +2000,16 @@ impl EmitterWriter {\n             num_decimal_digits(n)\n         };\n \n-        match self.emit_message_default(span, message, args, code, level, max_line_num_len, false) {\n+        match self.emit_message_default(\n+            span,\n+            message,\n+            args,\n+            code,\n+            level,\n+            max_line_num_len,\n+            false,\n+            emitted_at,\n+        ) {\n             Ok(()) => {\n                 if !children.is_empty()\n                     || suggestions.iter().any(|s| s.style != SuggestionStyle::CompletelyHidden)\n@@ -2014,6 +2038,7 @@ impl EmitterWriter {\n                             &child.level,\n                             max_line_num_len,\n                             true,\n+                            None,\n                         ) {\n                             panic!(\"failed to emit error: {}\", err);\n                         }\n@@ -2030,6 +2055,7 @@ impl EmitterWriter {\n                                 &Level::Help,\n                                 max_line_num_len,\n                                 true,\n+                                None,\n                             ) {\n                                 panic!(\"failed to emit error: {}\", e);\n                             }"}, {"sha": "c4498eafa4eab1f287cfe1a8699706571f865777", "filename": "compiler/rustc_errors/src/json.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -45,6 +45,7 @@ pub struct JsonEmitter {\n     json_rendered: HumanReadableErrorType,\n     diagnostic_width: Option<usize>,\n     macro_backtrace: bool,\n+    track_diagnostics: bool,\n }\n \n impl JsonEmitter {\n@@ -57,6 +58,7 @@ impl JsonEmitter {\n         json_rendered: HumanReadableErrorType,\n         diagnostic_width: Option<usize>,\n         macro_backtrace: bool,\n+        track_diagnostics: bool,\n     ) -> JsonEmitter {\n         JsonEmitter {\n             dst: Box::new(io::BufWriter::new(io::stderr())),\n@@ -69,6 +71,7 @@ impl JsonEmitter {\n             json_rendered,\n             diagnostic_width,\n             macro_backtrace,\n+            track_diagnostics,\n         }\n     }\n \n@@ -79,6 +82,7 @@ impl JsonEmitter {\n         fallback_bundle: LazyFallbackBundle,\n         diagnostic_width: Option<usize>,\n         macro_backtrace: bool,\n+        track_diagnostics: bool,\n     ) -> JsonEmitter {\n         let file_path_mapping = FilePathMapping::empty();\n         JsonEmitter::stderr(\n@@ -90,6 +94,7 @@ impl JsonEmitter {\n             json_rendered,\n             diagnostic_width,\n             macro_backtrace,\n+            track_diagnostics,\n         )\n     }\n \n@@ -103,6 +108,7 @@ impl JsonEmitter {\n         json_rendered: HumanReadableErrorType,\n         diagnostic_width: Option<usize>,\n         macro_backtrace: bool,\n+        track_diagnostics: bool,\n     ) -> JsonEmitter {\n         JsonEmitter {\n             dst,\n@@ -115,6 +121,7 @@ impl JsonEmitter {\n             json_rendered,\n             diagnostic_width,\n             macro_backtrace,\n+            track_diagnostics,\n         }\n     }\n \n@@ -350,6 +357,7 @@ impl Diagnostic {\n                 false,\n                 je.diagnostic_width,\n                 je.macro_backtrace,\n+                je.track_diagnostics,\n             )\n             .ui_testing(je.ui_testing)\n             .emit_diagnostic(diag);"}, {"sha": "f131468971b5adbcd66e090b05d21a1f5eb51c55", "filename": "compiler/rustc_errors/src/json/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_errors%2Fsrc%2Fjson%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_errors%2Fsrc%2Fjson%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson%2Ftests.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -59,6 +59,7 @@ fn test_positions(code: &str, span: (u32, u32), expected_output: SpanTestData) {\n             HumanReadableErrorType::Short(ColorConfig::Never),\n             None,\n             false,\n+            false,\n         );\n \n         let span = Span::with_root_ctxt(BytePos(span.0), BytePos(span.1));"}, {"sha": "a8fd1a17a5110d3ae10c194881752e0e9ddce67a", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -376,7 +376,7 @@ pub use diagnostic::{\n     DiagnosticStyledString, IntoDiagnosticArg, SubDiagnostic,\n };\n pub use diagnostic_builder::{DiagnosticBuilder, EmissionGuarantee, Noted};\n-pub use diagnostic_impls::DiagnosticArgFromDisplay;\n+pub use diagnostic_impls::{DiagnosticArgFromDisplay, DiagnosticSymbolList};\n use std::backtrace::Backtrace;\n \n /// A handler deals with errors and other compiler output.\n@@ -492,6 +492,8 @@ pub struct HandlerFlags {\n     pub macro_backtrace: bool,\n     /// If true, identical diagnostics are reported only once.\n     pub deduplicate_diagnostics: bool,\n+    /// Track where errors are created. Enabled with `-Ztrack-diagnostics`.\n+    pub track_diagnostics: bool,\n }\n \n impl Drop for HandlerInner {\n@@ -559,6 +561,7 @@ impl Handler {\n             false,\n             None,\n             flags.macro_backtrace,\n+            flags.track_diagnostics,\n         ));\n         Self::with_emitter_and_flags(emitter, flags)\n     }\n@@ -664,6 +667,7 @@ impl Handler {\n \n     /// Construct a builder with the `msg` at the level appropriate for the specific `EmissionGuarantee`.\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_diagnostic<G: EmissionGuarantee>(\n         &self,\n         msg: impl Into<DiagnosticMessage>,\n@@ -677,6 +681,7 @@ impl Handler {\n     /// * `can_emit_warnings` is `true`\n     /// * `is_force_warn` was set in `DiagnosticId::Lint`\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_span_warn(\n         &self,\n         span: impl Into<MultiSpan>,\n@@ -693,6 +698,7 @@ impl Handler {\n     /// Attempting to `.emit()` the builder will only emit if either:\n     /// * `can_emit_warnings` is `true`\n     /// * `is_force_warn` was set in `DiagnosticId::Lint`\n+    #[track_caller]\n     pub fn struct_span_warn_with_expectation(\n         &self,\n         span: impl Into<MultiSpan>,\n@@ -706,6 +712,7 @@ impl Handler {\n \n     /// Construct a builder at the `Allow` level at the given `span` and with the `msg`.\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_span_allow(\n         &self,\n         span: impl Into<MultiSpan>,\n@@ -719,6 +726,7 @@ impl Handler {\n     /// Construct a builder at the `Warning` level at the given `span` and with the `msg`.\n     /// Also include a code.\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_span_warn_with_code(\n         &self,\n         span: impl Into<MultiSpan>,\n@@ -736,6 +744,7 @@ impl Handler {\n     /// * `can_emit_warnings` is `true`\n     /// * `is_force_warn` was set in `DiagnosticId::Lint`\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_warn(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, ()> {\n         DiagnosticBuilder::new(self, Level::Warning(None), msg)\n     }\n@@ -746,6 +755,7 @@ impl Handler {\n     /// Attempting to `.emit()` the builder will only emit if either:\n     /// * `can_emit_warnings` is `true`\n     /// * `is_force_warn` was set in `DiagnosticId::Lint`\n+    #[track_caller]\n     pub fn struct_warn_with_expectation(\n         &self,\n         msg: impl Into<DiagnosticMessage>,\n@@ -756,12 +766,14 @@ impl Handler {\n \n     /// Construct a builder at the `Allow` level with the `msg`.\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_allow(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, ()> {\n         DiagnosticBuilder::new(self, Level::Allow, msg)\n     }\n \n     /// Construct a builder at the `Expect` level with the `msg`.\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_expect(\n         &self,\n         msg: impl Into<DiagnosticMessage>,\n@@ -772,6 +784,7 @@ impl Handler {\n \n     /// Construct a builder at the `Error` level at the given `span` and with the `msg`.\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_span_err(\n         &self,\n         span: impl Into<MultiSpan>,\n@@ -784,6 +797,7 @@ impl Handler {\n \n     /// Construct a builder at the `Error` level at the given `span`, with the `msg`, and `code`.\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_span_err_with_code(\n         &self,\n         span: impl Into<MultiSpan>,\n@@ -798,6 +812,7 @@ impl Handler {\n     /// Construct a builder at the `Error` level with the `msg`.\n     // FIXME: This method should be removed (every error should have an associated error code).\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_err(\n         &self,\n         msg: impl Into<DiagnosticMessage>,\n@@ -807,12 +822,14 @@ impl Handler {\n \n     /// This should only be used by `rustc_middle::lint::struct_lint_level`. Do not use it for hard errors.\n     #[doc(hidden)]\n+    #[track_caller]\n     pub fn struct_err_lint(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, ()> {\n         DiagnosticBuilder::new(self, Level::Error { lint: true }, msg)\n     }\n \n     /// Construct a builder at the `Error` level with the `msg` and the `code`.\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_err_with_code(\n         &self,\n         msg: impl Into<DiagnosticMessage>,\n@@ -825,6 +842,7 @@ impl Handler {\n \n     /// Construct a builder at the `Warn` level with the `msg` and the `code`.\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_warn_with_code(\n         &self,\n         msg: impl Into<DiagnosticMessage>,\n@@ -837,6 +855,7 @@ impl Handler {\n \n     /// Construct a builder at the `Fatal` level at the given `span` and with the `msg`.\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_span_fatal(\n         &self,\n         span: impl Into<MultiSpan>,\n@@ -849,6 +868,7 @@ impl Handler {\n \n     /// Construct a builder at the `Fatal` level at the given `span`, with the `msg`, and `code`.\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_span_fatal_with_code(\n         &self,\n         span: impl Into<MultiSpan>,\n@@ -862,6 +882,7 @@ impl Handler {\n \n     /// Construct a builder at the `Error` level with the `msg`.\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_fatal(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, !> {\n         DiagnosticBuilder::new_fatal(self, msg)\n     }\n@@ -874,6 +895,7 @@ impl Handler {\n \n     /// Construct a builder at the `Note` level with the `msg`.\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_note_without_error(\n         &self,\n         msg: impl Into<DiagnosticMessage>,\n@@ -882,12 +904,14 @@ impl Handler {\n     }\n \n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn span_fatal(&self, span: impl Into<MultiSpan>, msg: impl Into<DiagnosticMessage>) -> ! {\n         self.emit_diag_at_span(Diagnostic::new(Fatal, msg), span);\n         FatalError.raise()\n     }\n \n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn span_fatal_with_code(\n         &self,\n         span: impl Into<MultiSpan>,\n@@ -899,6 +923,7 @@ impl Handler {\n     }\n \n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn span_err(\n         &self,\n         span: impl Into<MultiSpan>,\n@@ -908,6 +933,7 @@ impl Handler {\n     }\n \n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn span_err_with_code(\n         &self,\n         span: impl Into<MultiSpan>,\n@@ -921,11 +947,13 @@ impl Handler {\n     }\n \n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn span_warn(&self, span: impl Into<MultiSpan>, msg: impl Into<DiagnosticMessage>) {\n         self.emit_diag_at_span(Diagnostic::new(Warning(None), msg), span);\n     }\n \n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn span_warn_with_code(\n         &self,\n         span: impl Into<MultiSpan>,\n@@ -954,10 +982,12 @@ impl Handler {\n         self.inner.borrow_mut().delay_good_path_bug(msg)\n     }\n \n+    #[track_caller]\n     pub fn span_bug_no_panic(&self, span: impl Into<MultiSpan>, msg: impl Into<DiagnosticMessage>) {\n         self.emit_diag_at_span(Diagnostic::new(Bug, msg), span);\n     }\n \n+    #[track_caller]\n     pub fn span_note_without_error(\n         &self,\n         span: impl Into<MultiSpan>,\n@@ -966,6 +996,7 @@ impl Handler {\n         self.emit_diag_at_span(Diagnostic::new(Note, msg), span);\n     }\n \n+    #[track_caller]\n     pub fn span_note_diag(\n         &self,\n         span: Span,\n@@ -1452,6 +1483,7 @@ impl HandlerInner {\n         }\n     }\n \n+    #[track_caller]\n     fn span_bug(&mut self, sp: impl Into<MultiSpan>, msg: impl Into<DiagnosticMessage>) -> ! {\n         self.emit_diag_at_span(Diagnostic::new(Bug, msg), sp);\n         panic::panic_any(ExplicitBug);"}, {"sha": "d82a7a54030c668a3c55bfaaef739b56ce59f509", "filename": "compiler/rustc_expand/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_expand%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_expand%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Ftests.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -151,6 +151,7 @@ fn test_harness(file_text: &str, span_labels: Vec<SpanLabel>, expected_output: &\n             false,\n             None,\n             false,\n+            false,\n         );\n         let handler = Handler::with_emitter(true, None, Box::new(emitter));\n         handler.span_err(msp, \"foo\");"}, {"sha": "7900f1500489e1122eb5f16ad87e8fc75fe72673", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -388,6 +388,9 @@ declare_features! (\n     (active, exclusive_range_pattern, \"1.11.0\", Some(37854), None),\n     /// Allows exhaustive pattern matching on types that contain uninhabited types.\n     (active, exhaustive_patterns, \"1.13.0\", Some(51085), None),\n+    /// Allows using `efiapi`, `sysv64` and `win64` as calling convention\n+    /// for functions with varargs.\n+    (active, extended_varargs_abi_support, \"1.65.0\", Some(100189), None),\n     /// Allows defining `extern type`s.\n     (active, extern_types, \"1.23.0\", Some(43467), None),\n     /// Allows the use of `#[ffi_const]` on foreign functions.\n@@ -412,6 +415,8 @@ declare_features! (\n     (active, half_open_range_patterns_in_slices, \"CURRENT_RUSTC_VERSION\", Some(67264), None),\n     /// Allows `if let` guard in match arms.\n     (active, if_let_guard, \"1.47.0\", Some(51114), None),\n+    /// Allows `impl Trait` as output type in `Fn` traits in return position of functions.\n+    (active, impl_trait_in_fn_trait_return, \"1.64.0\", Some(99697), None),\n     /// Allows using imported `main` function\n     (active, imported_main, \"1.53.0\", Some(28937), None),\n     /// Allows associated types in inherent impls."}, {"sha": "14c8e3c458c497a241673ea10558f5298363f059", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -554,10 +554,6 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     rustc_attr!(rustc_reallocator, Normal, template!(Word), WarnFollowing, IMPL_DETAIL),\n     rustc_attr!(rustc_deallocator, Normal, template!(Word), WarnFollowing, IMPL_DETAIL),\n     rustc_attr!(rustc_allocator_zeroed, Normal, template!(Word), WarnFollowing, IMPL_DETAIL),\n-    gated!(\n-        alloc_error_handler, Normal, template!(Word), WarnFollowing,\n-        experimental!(alloc_error_handler)\n-    ),\n     gated!(\n         default_lib_allocator, Normal, template!(Word), WarnFollowing, allocator_internals,\n         experimental!(default_lib_allocator),"}, {"sha": "3ef58d7d70570031b01e8ed3173ef237b242c07a", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 371, "deletions": 364, "changes": 735, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -358,6 +358,9 @@ pub trait Visitor<'v>: Sized {\n     fn visit_where_predicate(&mut self, predicate: &'v WherePredicate<'v>) {\n         walk_where_predicate(self, predicate)\n     }\n+    fn visit_fn_ret_ty(&mut self, ret_ty: &'v FnRetTy<'v>) {\n+        walk_fn_ret_ty(self, ret_ty)\n+    }\n     fn visit_fn_decl(&mut self, fd: &'v FnDecl<'v>) {\n         walk_fn_decl(self, fd)\n     }\n@@ -410,12 +413,7 @@ pub trait Visitor<'v>: Sized {\n         walk_inf(self, inf);\n     }\n     fn visit_generic_arg(&mut self, generic_arg: &'v GenericArg<'v>) {\n-        match generic_arg {\n-            GenericArg::Lifetime(lt) => self.visit_lifetime(lt),\n-            GenericArg::Type(ty) => self.visit_ty(ty),\n-            GenericArg::Const(ct) => self.visit_anon_const(&ct.value),\n-            GenericArg::Infer(inf) => self.visit_infer(inf),\n-        }\n+        walk_generic_arg(self, generic_arg);\n     }\n     fn visit_lifetime(&mut self, lifetime: &'v Lifetime) {\n         walk_lifetime(self, lifetime)\n@@ -448,63 +446,6 @@ pub trait Visitor<'v>: Sized {\n     }\n }\n \n-pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod<'v>, mod_hir_id: HirId) {\n-    visitor.visit_id(mod_hir_id);\n-    for &item_id in module.item_ids {\n-        visitor.visit_nested_item(item_id);\n-    }\n-}\n-\n-pub fn walk_body<'v, V: Visitor<'v>>(visitor: &mut V, body: &'v Body<'v>) {\n-    walk_list!(visitor, visit_param, body.params);\n-    visitor.visit_expr(&body.value);\n-}\n-\n-pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local<'v>) {\n-    // Intentionally visiting the expr first - the initialization expr\n-    // dominates the local's definition.\n-    walk_list!(visitor, visit_expr, &local.init);\n-    visitor.visit_id(local.hir_id);\n-    visitor.visit_pat(&local.pat);\n-    if let Some(els) = local.els {\n-        visitor.visit_block(els);\n-    }\n-    walk_list!(visitor, visit_ty, &local.ty);\n-}\n-\n-pub fn walk_ident<'v, V: Visitor<'v>>(visitor: &mut V, ident: Ident) {\n-    visitor.visit_name(ident.name);\n-}\n-\n-pub fn walk_label<'v, V: Visitor<'v>>(visitor: &mut V, label: &'v Label) {\n-    visitor.visit_ident(label.ident);\n-}\n-\n-pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime) {\n-    visitor.visit_id(lifetime.hir_id);\n-    match lifetime.name {\n-        LifetimeName::Param(_, ParamName::Plain(ident)) => {\n-            visitor.visit_ident(ident);\n-        }\n-        LifetimeName::Param(_, ParamName::Fresh)\n-        | LifetimeName::Param(_, ParamName::Error)\n-        | LifetimeName::Static\n-        | LifetimeName::Error\n-        | LifetimeName::ImplicitObjectLifetimeDefault\n-        | LifetimeName::Infer => {}\n-    }\n-}\n-\n-pub fn walk_poly_trait_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_ref: &'v PolyTraitRef<'v>) {\n-    walk_list!(visitor, visit_generic_param, trait_ref.bound_generic_params);\n-    visitor.visit_trait_ref(&trait_ref.trait_ref);\n-}\n-\n-pub fn walk_trait_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_ref: &'v TraitRef<'v>) {\n-    visitor.visit_id(trait_ref.hir_ref_id);\n-    visitor.visit_path(&trait_ref.path, trait_ref.hir_ref_id)\n-}\n-\n pub fn walk_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Param<'v>) {\n     visitor.visit_id(param.hir_id);\n     visitor.visit_pat(&param.pat);\n@@ -601,142 +542,80 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n     }\n }\n \n-pub fn walk_inline_asm<'v, V: Visitor<'v>>(visitor: &mut V, asm: &'v InlineAsm<'v>, id: HirId) {\n-    for (op, op_sp) in asm.operands {\n-        match op {\n-            InlineAsmOperand::In { expr, .. } | InlineAsmOperand::InOut { expr, .. } => {\n-                visitor.visit_expr(expr)\n-            }\n-            InlineAsmOperand::Out { expr, .. } => {\n-                if let Some(expr) = expr {\n-                    visitor.visit_expr(expr);\n-                }\n-            }\n-            InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n-                visitor.visit_expr(in_expr);\n-                if let Some(out_expr) = out_expr {\n-                    visitor.visit_expr(out_expr);\n-                }\n-            }\n-            InlineAsmOperand::Const { anon_const, .. }\n-            | InlineAsmOperand::SymFn { anon_const, .. } => visitor.visit_anon_const(anon_const),\n-            InlineAsmOperand::SymStatic { path, .. } => visitor.visit_qpath(path, id, *op_sp),\n-        }\n-    }\n-}\n-\n-pub fn walk_use<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path<'v>, hir_id: HirId) {\n-    visitor.visit_id(hir_id);\n-    visitor.visit_path(path, hir_id);\n+pub fn walk_body<'v, V: Visitor<'v>>(visitor: &mut V, body: &'v Body<'v>) {\n+    walk_list!(visitor, visit_param, body.params);\n+    visitor.visit_expr(&body.value);\n }\n \n-pub fn walk_enum_def<'v, V: Visitor<'v>>(\n-    visitor: &mut V,\n-    enum_definition: &'v EnumDef<'v>,\n-    item_id: HirId,\n-) {\n-    visitor.visit_id(item_id);\n-    walk_list!(visitor, visit_variant, enum_definition.variants);\n+pub fn walk_ident<'v, V: Visitor<'v>>(visitor: &mut V, ident: Ident) {\n+    visitor.visit_name(ident.name);\n }\n \n-pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V, variant: &'v Variant<'v>) {\n-    visitor.visit_ident(variant.ident);\n-    visitor.visit_id(variant.id);\n-    visitor.visit_variant_data(&variant.data);\n-    walk_list!(visitor, visit_anon_const, &variant.disr_expr);\n+pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod<'v>, mod_hir_id: HirId) {\n+    visitor.visit_id(mod_hir_id);\n+    for &item_id in module.item_ids {\n+        visitor.visit_nested_item(item_id);\n+    }\n }\n \n-pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty<'v>) {\n-    visitor.visit_id(typ.hir_id);\n+pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V, foreign_item: &'v ForeignItem<'v>) {\n+    visitor.visit_id(foreign_item.hir_id());\n+    visitor.visit_ident(foreign_item.ident);\n \n-    match typ.kind {\n-        TyKind::Slice(ref ty) => visitor.visit_ty(ty),\n-        TyKind::Ptr(ref mutable_type) => visitor.visit_ty(&mutable_type.ty),\n-        TyKind::Rptr(ref lifetime, ref mutable_type) => {\n-            visitor.visit_lifetime(lifetime);\n-            visitor.visit_ty(&mutable_type.ty)\n-        }\n-        TyKind::Never => {}\n-        TyKind::Tup(tuple_element_types) => {\n-            walk_list!(visitor, visit_ty, tuple_element_types);\n-        }\n-        TyKind::BareFn(ref function_declaration) => {\n-            walk_list!(visitor, visit_generic_param, function_declaration.generic_params);\n-            visitor.visit_fn_decl(&function_declaration.decl);\n-        }\n-        TyKind::Path(ref qpath) => {\n-            visitor.visit_qpath(qpath, typ.hir_id, typ.span);\n-        }\n-        TyKind::OpaqueDef(item_id, lifetimes, _in_trait) => {\n-            visitor.visit_nested_item(item_id);\n-            walk_list!(visitor, visit_generic_arg, lifetimes);\n-        }\n-        TyKind::Array(ref ty, ref length) => {\n-            visitor.visit_ty(ty);\n-            visitor.visit_array_length(length)\n-        }\n-        TyKind::TraitObject(bounds, ref lifetime, _syntax) => {\n-            for bound in bounds {\n-                visitor.visit_poly_trait_ref(bound);\n+    match foreign_item.kind {\n+        ForeignItemKind::Fn(ref function_declaration, param_names, ref generics) => {\n+            visitor.visit_generics(generics);\n+            visitor.visit_fn_decl(function_declaration);\n+            for &param_name in param_names {\n+                visitor.visit_ident(param_name);\n             }\n-            visitor.visit_lifetime(lifetime);\n         }\n-        TyKind::Typeof(ref expression) => visitor.visit_anon_const(expression),\n-        TyKind::Infer | TyKind::Err => {}\n+        ForeignItemKind::Static(ref typ, _) => visitor.visit_ty(typ),\n+        ForeignItemKind::Type => (),\n     }\n }\n \n-pub fn walk_inf<'v, V: Visitor<'v>>(visitor: &mut V, inf: &'v InferArg) {\n-    visitor.visit_id(inf.hir_id);\n-}\n-\n-pub fn walk_qpath<'v, V: Visitor<'v>>(visitor: &mut V, qpath: &'v QPath<'v>, id: HirId) {\n-    match *qpath {\n-        QPath::Resolved(ref maybe_qself, ref path) => {\n-            walk_list!(visitor, visit_ty, maybe_qself);\n-            visitor.visit_path(path, id)\n-        }\n-        QPath::TypeRelative(ref qself, ref segment) => {\n-            visitor.visit_ty(qself);\n-            visitor.visit_path_segment(segment);\n-        }\n-        QPath::LangItem(..) => {}\n+pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local<'v>) {\n+    // Intentionally visiting the expr first - the initialization expr\n+    // dominates the local's definition.\n+    walk_list!(visitor, visit_expr, &local.init);\n+    visitor.visit_id(local.hir_id);\n+    visitor.visit_pat(&local.pat);\n+    if let Some(els) = local.els {\n+        visitor.visit_block(els);\n     }\n+    walk_list!(visitor, visit_ty, &local.ty);\n }\n \n-pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path<'v>) {\n-    for segment in path.segments {\n-        visitor.visit_path_segment(segment);\n-    }\n+pub fn walk_block<'v, V: Visitor<'v>>(visitor: &mut V, block: &'v Block<'v>) {\n+    visitor.visit_id(block.hir_id);\n+    walk_list!(visitor, visit_stmt, block.stmts);\n+    walk_list!(visitor, visit_expr, &block.expr);\n }\n \n-pub fn walk_path_segment<'v, V: Visitor<'v>>(visitor: &mut V, segment: &'v PathSegment<'v>) {\n-    visitor.visit_ident(segment.ident);\n-    visitor.visit_id(segment.hir_id);\n-    if let Some(ref args) = segment.args {\n-        visitor.visit_generic_args(args);\n+pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt<'v>) {\n+    visitor.visit_id(statement.hir_id);\n+    match statement.kind {\n+        StmtKind::Local(ref local) => visitor.visit_local(local),\n+        StmtKind::Item(item) => visitor.visit_nested_item(item),\n+        StmtKind::Expr(ref expression) | StmtKind::Semi(ref expression) => {\n+            visitor.visit_expr(expression)\n+        }\n     }\n }\n \n-pub fn walk_generic_args<'v, V: Visitor<'v>>(visitor: &mut V, generic_args: &'v GenericArgs<'v>) {\n-    walk_list!(visitor, visit_generic_arg, generic_args.args);\n-    walk_list!(visitor, visit_assoc_type_binding, generic_args.bindings);\n-}\n-\n-pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(\n-    visitor: &mut V,\n-    type_binding: &'v TypeBinding<'v>,\n-) {\n-    visitor.visit_id(type_binding.hir_id);\n-    visitor.visit_ident(type_binding.ident);\n-    visitor.visit_generic_args(type_binding.gen_args);\n-    match type_binding.kind {\n-        TypeBindingKind::Equality { ref term } => match term {\n-            Term::Ty(ref ty) => visitor.visit_ty(ty),\n-            Term::Const(ref c) => visitor.visit_anon_const(c),\n-        },\n-        TypeBindingKind::Constraint { bounds } => walk_list!(visitor, visit_param_bound, bounds),\n+pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm<'v>) {\n+    visitor.visit_id(arm.hir_id);\n+    visitor.visit_pat(&arm.pat);\n+    if let Some(ref g) = arm.guard {\n+        match g {\n+            Guard::If(ref e) => visitor.visit_expr(e),\n+            Guard::IfLet(ref l) => {\n+                visitor.visit_let_expr(l);\n+            }\n+        }\n     }\n+    visitor.visit_expr(&arm.body);\n }\n \n pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat<'v>) {\n@@ -784,34 +663,182 @@ pub fn walk_pat_field<'v, V: Visitor<'v>>(visitor: &mut V, field: &'v PatField<'\n     visitor.visit_pat(&field.pat)\n }\n \n-pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V, foreign_item: &'v ForeignItem<'v>) {\n-    visitor.visit_id(foreign_item.hir_id());\n-    visitor.visit_ident(foreign_item.ident);\n-\n-    match foreign_item.kind {\n-        ForeignItemKind::Fn(ref function_declaration, param_names, ref generics) => {\n-            visitor.visit_generics(generics);\n-            visitor.visit_fn_decl(function_declaration);\n-            for &param_name in param_names {\n-                visitor.visit_ident(param_name);\n-            }\n-        }\n-        ForeignItemKind::Static(ref typ, _) => visitor.visit_ty(typ),\n-        ForeignItemKind::Type => (),\n+pub fn walk_array_len<'v, V: Visitor<'v>>(visitor: &mut V, len: &'v ArrayLen) {\n+    match len {\n+        &ArrayLen::Infer(hir_id, _span) => visitor.visit_id(hir_id),\n+        ArrayLen::Body(c) => visitor.visit_anon_const(c),\n     }\n }\n \n-pub fn walk_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v GenericBound<'v>) {\n-    match *bound {\n-        GenericBound::Trait(ref typ, _modifier) => {\n-            visitor.visit_poly_trait_ref(typ);\n-        }\n-        GenericBound::LangItemTrait(_, _span, hir_id, args) => {\n-            visitor.visit_id(hir_id);\n-            visitor.visit_generic_args(args);\n-        }\n-        GenericBound::Outlives(ref lifetime) => visitor.visit_lifetime(lifetime),\n-    }\n+pub fn walk_anon_const<'v, V: Visitor<'v>>(visitor: &mut V, constant: &'v AnonConst) {\n+    visitor.visit_id(constant.hir_id);\n+    visitor.visit_nested_body(constant.body);\n+}\n+\n+pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>) {\n+    visitor.visit_id(expression.hir_id);\n+    match expression.kind {\n+        ExprKind::Box(ref subexpression) => visitor.visit_expr(subexpression),\n+        ExprKind::Array(subexpressions) => {\n+            walk_list!(visitor, visit_expr, subexpressions);\n+        }\n+        ExprKind::ConstBlock(ref anon_const) => visitor.visit_anon_const(anon_const),\n+        ExprKind::Repeat(ref element, ref count) => {\n+            visitor.visit_expr(element);\n+            visitor.visit_array_length(count)\n+        }\n+        ExprKind::Struct(ref qpath, fields, ref optional_base) => {\n+            visitor.visit_qpath(qpath, expression.hir_id, expression.span);\n+            walk_list!(visitor, visit_expr_field, fields);\n+            walk_list!(visitor, visit_expr, optional_base);\n+        }\n+        ExprKind::Tup(subexpressions) => {\n+            walk_list!(visitor, visit_expr, subexpressions);\n+        }\n+        ExprKind::Call(ref callee_expression, arguments) => {\n+            visitor.visit_expr(callee_expression);\n+            walk_list!(visitor, visit_expr, arguments);\n+        }\n+        ExprKind::MethodCall(ref segment, receiver, arguments, _) => {\n+            visitor.visit_path_segment(segment);\n+            visitor.visit_expr(receiver);\n+            walk_list!(visitor, visit_expr, arguments);\n+        }\n+        ExprKind::Binary(_, ref left_expression, ref right_expression) => {\n+            visitor.visit_expr(left_expression);\n+            visitor.visit_expr(right_expression)\n+        }\n+        ExprKind::AddrOf(_, _, ref subexpression) | ExprKind::Unary(_, ref subexpression) => {\n+            visitor.visit_expr(subexpression)\n+        }\n+        ExprKind::Cast(ref subexpression, ref typ) | ExprKind::Type(ref subexpression, ref typ) => {\n+            visitor.visit_expr(subexpression);\n+            visitor.visit_ty(typ)\n+        }\n+        ExprKind::DropTemps(ref subexpression) => {\n+            visitor.visit_expr(subexpression);\n+        }\n+        ExprKind::Let(ref let_expr) => visitor.visit_let_expr(let_expr),\n+        ExprKind::If(ref cond, ref then, ref else_opt) => {\n+            visitor.visit_expr(cond);\n+            visitor.visit_expr(then);\n+            walk_list!(visitor, visit_expr, else_opt);\n+        }\n+        ExprKind::Loop(ref block, ref opt_label, _, _) => {\n+            walk_list!(visitor, visit_label, opt_label);\n+            visitor.visit_block(block);\n+        }\n+        ExprKind::Match(ref subexpression, arms, _) => {\n+            visitor.visit_expr(subexpression);\n+            walk_list!(visitor, visit_arm, arms);\n+        }\n+        ExprKind::Closure(&Closure {\n+            binder: _,\n+            bound_generic_params,\n+            fn_decl,\n+            body,\n+            capture_clause: _,\n+            fn_decl_span: _,\n+            movability: _,\n+        }) => {\n+            walk_list!(visitor, visit_generic_param, bound_generic_params);\n+            visitor.visit_fn(FnKind::Closure, fn_decl, body, expression.span, expression.hir_id)\n+        }\n+        ExprKind::Block(ref block, ref opt_label) => {\n+            walk_list!(visitor, visit_label, opt_label);\n+            visitor.visit_block(block);\n+        }\n+        ExprKind::Assign(ref lhs, ref rhs, _) => {\n+            visitor.visit_expr(rhs);\n+            visitor.visit_expr(lhs)\n+        }\n+        ExprKind::AssignOp(_, ref left_expression, ref right_expression) => {\n+            visitor.visit_expr(right_expression);\n+            visitor.visit_expr(left_expression);\n+        }\n+        ExprKind::Field(ref subexpression, ident) => {\n+            visitor.visit_expr(subexpression);\n+            visitor.visit_ident(ident);\n+        }\n+        ExprKind::Index(ref main_expression, ref index_expression) => {\n+            visitor.visit_expr(main_expression);\n+            visitor.visit_expr(index_expression)\n+        }\n+        ExprKind::Path(ref qpath) => {\n+            visitor.visit_qpath(qpath, expression.hir_id, expression.span);\n+        }\n+        ExprKind::Break(ref destination, ref opt_expr) => {\n+            walk_list!(visitor, visit_label, &destination.label);\n+            walk_list!(visitor, visit_expr, opt_expr);\n+        }\n+        ExprKind::Continue(ref destination) => {\n+            walk_list!(visitor, visit_label, &destination.label);\n+        }\n+        ExprKind::Ret(ref optional_expression) => {\n+            walk_list!(visitor, visit_expr, optional_expression);\n+        }\n+        ExprKind::InlineAsm(ref asm) => {\n+            visitor.visit_inline_asm(asm, expression.hir_id);\n+        }\n+        ExprKind::Yield(ref subexpression, _) => {\n+            visitor.visit_expr(subexpression);\n+        }\n+        ExprKind::Lit(_) | ExprKind::Err => {}\n+    }\n+}\n+\n+pub fn walk_let_expr<'v, V: Visitor<'v>>(visitor: &mut V, let_expr: &'v Let<'v>) {\n+    // match the visit order in walk_local\n+    visitor.visit_expr(let_expr.init);\n+    visitor.visit_id(let_expr.hir_id);\n+    visitor.visit_pat(let_expr.pat);\n+    walk_list!(visitor, visit_ty, let_expr.ty);\n+}\n+\n+pub fn walk_expr_field<'v, V: Visitor<'v>>(visitor: &mut V, field: &'v ExprField<'v>) {\n+    visitor.visit_id(field.hir_id);\n+    visitor.visit_ident(field.ident);\n+    visitor.visit_expr(&field.expr)\n+}\n+\n+pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty<'v>) {\n+    visitor.visit_id(typ.hir_id);\n+\n+    match typ.kind {\n+        TyKind::Slice(ref ty) => visitor.visit_ty(ty),\n+        TyKind::Ptr(ref mutable_type) => visitor.visit_ty(&mutable_type.ty),\n+        TyKind::Rptr(ref lifetime, ref mutable_type) => {\n+            visitor.visit_lifetime(lifetime);\n+            visitor.visit_ty(&mutable_type.ty)\n+        }\n+        TyKind::Never => {}\n+        TyKind::Tup(tuple_element_types) => {\n+            walk_list!(visitor, visit_ty, tuple_element_types);\n+        }\n+        TyKind::BareFn(ref function_declaration) => {\n+            walk_list!(visitor, visit_generic_param, function_declaration.generic_params);\n+            visitor.visit_fn_decl(&function_declaration.decl);\n+        }\n+        TyKind::Path(ref qpath) => {\n+            visitor.visit_qpath(qpath, typ.hir_id, typ.span);\n+        }\n+        TyKind::OpaqueDef(item_id, lifetimes, _in_trait) => {\n+            visitor.visit_nested_item(item_id);\n+            walk_list!(visitor, visit_generic_arg, lifetimes);\n+        }\n+        TyKind::Array(ref ty, ref length) => {\n+            visitor.visit_ty(ty);\n+            visitor.visit_array_length(length)\n+        }\n+        TyKind::TraitObject(bounds, ref lifetime, _syntax) => {\n+            for bound in bounds {\n+                visitor.visit_poly_trait_ref(bound);\n+            }\n+            visitor.visit_lifetime(lifetime);\n+        }\n+        TyKind::Typeof(ref expression) => visitor.visit_anon_const(expression),\n+        TyKind::Infer | TyKind::Err => {}\n+    }\n }\n \n pub fn walk_generic_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v GenericParam<'v>) {\n@@ -875,25 +902,16 @@ pub fn walk_where_predicate<'v, V: Visitor<'v>>(\n     }\n }\n \n-pub fn walk_fn_ret_ty<'v, V: Visitor<'v>>(visitor: &mut V, ret_ty: &'v FnRetTy<'v>) {\n-    if let FnRetTy::Return(ref output_ty) = *ret_ty {\n-        visitor.visit_ty(output_ty)\n-    }\n-}\n-\n pub fn walk_fn_decl<'v, V: Visitor<'v>>(visitor: &mut V, function_declaration: &'v FnDecl<'v>) {\n     for ty in function_declaration.inputs {\n         visitor.visit_ty(ty)\n     }\n-    walk_fn_ret_ty(visitor, &function_declaration.output)\n+    visitor.visit_fn_ret_ty(&function_declaration.output)\n }\n \n-pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V, function_kind: FnKind<'v>) {\n-    match function_kind {\n-        FnKind::ItemFn(_, generics, ..) => {\n-            visitor.visit_generics(generics);\n-        }\n-        FnKind::Closure | FnKind::Method(..) => {}\n+pub fn walk_fn_ret_ty<'v, V: Visitor<'v>>(visitor: &mut V, ret_ty: &'v FnRetTy<'v>) {\n+    if let FnRetTy::Return(ref output_ty) = *ret_ty {\n+        visitor.visit_ty(output_ty)\n     }\n }\n \n@@ -910,6 +928,20 @@ pub fn walk_fn<'v, V: Visitor<'v>>(\n     visitor.visit_nested_body(body_id)\n }\n \n+pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V, function_kind: FnKind<'v>) {\n+    match function_kind {\n+        FnKind::ItemFn(_, generics, ..) => {\n+            visitor.visit_generics(generics);\n+        }\n+        FnKind::Closure | FnKind::Method(..) => {}\n+    }\n+}\n+\n+pub fn walk_use<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path<'v>, hir_id: HirId) {\n+    visitor.visit_id(hir_id);\n+    visitor.visit_path(path, hir_id);\n+}\n+\n pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v TraitItem<'v>) {\n     // N.B., deliberately force a compilation error if/when new fields are added.\n     let TraitItem { ident, generics, ref defaultness, ref kind, span, owner_id: _ } = *trait_item;\n@@ -1004,6 +1036,29 @@ pub fn walk_impl_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, impl_item_ref: &'\n     visitor.visit_associated_item_kind(kind);\n }\n \n+pub fn walk_trait_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_ref: &'v TraitRef<'v>) {\n+    visitor.visit_id(trait_ref.hir_ref_id);\n+    visitor.visit_path(&trait_ref.path, trait_ref.hir_ref_id)\n+}\n+\n+pub fn walk_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v GenericBound<'v>) {\n+    match *bound {\n+        GenericBound::Trait(ref typ, _modifier) => {\n+            visitor.visit_poly_trait_ref(typ);\n+        }\n+        GenericBound::LangItemTrait(_, _span, hir_id, args) => {\n+            visitor.visit_id(hir_id);\n+            visitor.visit_generic_args(args);\n+        }\n+        GenericBound::Outlives(ref lifetime) => visitor.visit_lifetime(lifetime),\n+    }\n+}\n+\n+pub fn walk_poly_trait_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_ref: &'v PolyTraitRef<'v>) {\n+    walk_list!(visitor, visit_generic_param, trait_ref.bound_generic_params);\n+    visitor.visit_trait_ref(&trait_ref.trait_ref);\n+}\n+\n pub fn walk_struct_def<'v, V: Visitor<'v>>(\n     visitor: &mut V,\n     struct_definition: &'v VariantData<'v>,\n@@ -1018,173 +1073,101 @@ pub fn walk_field_def<'v, V: Visitor<'v>>(visitor: &mut V, field: &'v FieldDef<'\n     visitor.visit_ty(&field.ty);\n }\n \n-pub fn walk_block<'v, V: Visitor<'v>>(visitor: &mut V, block: &'v Block<'v>) {\n-    visitor.visit_id(block.hir_id);\n-    walk_list!(visitor, visit_stmt, block.stmts);\n-    walk_list!(visitor, visit_expr, &block.expr);\n+pub fn walk_enum_def<'v, V: Visitor<'v>>(\n+    visitor: &mut V,\n+    enum_definition: &'v EnumDef<'v>,\n+    item_id: HirId,\n+) {\n+    visitor.visit_id(item_id);\n+    walk_list!(visitor, visit_variant, enum_definition.variants);\n }\n \n-pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt<'v>) {\n-    visitor.visit_id(statement.hir_id);\n-    match statement.kind {\n-        StmtKind::Local(ref local) => visitor.visit_local(local),\n-        StmtKind::Item(item) => visitor.visit_nested_item(item),\n-        StmtKind::Expr(ref expression) | StmtKind::Semi(ref expression) => {\n-            visitor.visit_expr(expression)\n-        }\n-    }\n+pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V, variant: &'v Variant<'v>) {\n+    visitor.visit_ident(variant.ident);\n+    visitor.visit_id(variant.id);\n+    visitor.visit_variant_data(&variant.data);\n+    walk_list!(visitor, visit_anon_const, &variant.disr_expr);\n }\n \n-pub fn walk_array_len<'v, V: Visitor<'v>>(visitor: &mut V, len: &'v ArrayLen) {\n-    match len {\n-        &ArrayLen::Infer(hir_id, _span) => visitor.visit_id(hir_id),\n-        ArrayLen::Body(c) => visitor.visit_anon_const(c),\n-    }\n+pub fn walk_label<'v, V: Visitor<'v>>(visitor: &mut V, label: &'v Label) {\n+    visitor.visit_ident(label.ident);\n }\n \n-pub fn walk_anon_const<'v, V: Visitor<'v>>(visitor: &mut V, constant: &'v AnonConst) {\n-    visitor.visit_id(constant.hir_id);\n-    visitor.visit_nested_body(constant.body);\n+pub fn walk_inf<'v, V: Visitor<'v>>(visitor: &mut V, inf: &'v InferArg) {\n+    visitor.visit_id(inf.hir_id);\n }\n \n-pub fn walk_let_expr<'v, V: Visitor<'v>>(visitor: &mut V, let_expr: &'v Let<'v>) {\n-    // match the visit order in walk_local\n-    visitor.visit_expr(let_expr.init);\n-    visitor.visit_id(let_expr.hir_id);\n-    visitor.visit_pat(let_expr.pat);\n-    walk_list!(visitor, visit_ty, let_expr.ty);\n+pub fn walk_generic_arg<'v, V: Visitor<'v>>(visitor: &mut V, generic_arg: &'v GenericArg<'v>) {\n+    match generic_arg {\n+        GenericArg::Lifetime(lt) => visitor.visit_lifetime(lt),\n+        GenericArg::Type(ty) => visitor.visit_ty(ty),\n+        GenericArg::Const(ct) => visitor.visit_anon_const(&ct.value),\n+        GenericArg::Infer(inf) => visitor.visit_infer(inf),\n+    }\n }\n \n-pub fn walk_expr_field<'v, V: Visitor<'v>>(visitor: &mut V, field: &'v ExprField<'v>) {\n-    visitor.visit_id(field.hir_id);\n-    visitor.visit_ident(field.ident);\n-    visitor.visit_expr(&field.expr)\n+pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime) {\n+    visitor.visit_id(lifetime.hir_id);\n+    match lifetime.name {\n+        LifetimeName::Param(_, ParamName::Plain(ident)) => {\n+            visitor.visit_ident(ident);\n+        }\n+        LifetimeName::Param(_, ParamName::Fresh)\n+        | LifetimeName::Param(_, ParamName::Error)\n+        | LifetimeName::Static\n+        | LifetimeName::Error\n+        | LifetimeName::ImplicitObjectLifetimeDefault\n+        | LifetimeName::Infer => {}\n+    }\n }\n \n-pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>) {\n-    visitor.visit_id(expression.hir_id);\n-    match expression.kind {\n-        ExprKind::Box(ref subexpression) => visitor.visit_expr(subexpression),\n-        ExprKind::Array(subexpressions) => {\n-            walk_list!(visitor, visit_expr, subexpressions);\n-        }\n-        ExprKind::ConstBlock(ref anon_const) => visitor.visit_anon_const(anon_const),\n-        ExprKind::Repeat(ref element, ref count) => {\n-            visitor.visit_expr(element);\n-            visitor.visit_array_length(count)\n-        }\n-        ExprKind::Struct(ref qpath, fields, ref optional_base) => {\n-            visitor.visit_qpath(qpath, expression.hir_id, expression.span);\n-            walk_list!(visitor, visit_expr_field, fields);\n-            walk_list!(visitor, visit_expr, optional_base);\n-        }\n-        ExprKind::Tup(subexpressions) => {\n-            walk_list!(visitor, visit_expr, subexpressions);\n-        }\n-        ExprKind::Call(ref callee_expression, arguments) => {\n-            visitor.visit_expr(callee_expression);\n-            walk_list!(visitor, visit_expr, arguments);\n+pub fn walk_qpath<'v, V: Visitor<'v>>(visitor: &mut V, qpath: &'v QPath<'v>, id: HirId) {\n+    match *qpath {\n+        QPath::Resolved(ref maybe_qself, ref path) => {\n+            walk_list!(visitor, visit_ty, maybe_qself);\n+            visitor.visit_path(path, id)\n         }\n-        ExprKind::MethodCall(ref segment, receiver, arguments, _) => {\n+        QPath::TypeRelative(ref qself, ref segment) => {\n+            visitor.visit_ty(qself);\n             visitor.visit_path_segment(segment);\n-            visitor.visit_expr(receiver);\n-            walk_list!(visitor, visit_expr, arguments);\n-        }\n-        ExprKind::Binary(_, ref left_expression, ref right_expression) => {\n-            visitor.visit_expr(left_expression);\n-            visitor.visit_expr(right_expression)\n         }\n-        ExprKind::AddrOf(_, _, ref subexpression) | ExprKind::Unary(_, ref subexpression) => {\n-            visitor.visit_expr(subexpression)\n-        }\n-        ExprKind::Cast(ref subexpression, ref typ) | ExprKind::Type(ref subexpression, ref typ) => {\n-            visitor.visit_expr(subexpression);\n-            visitor.visit_ty(typ)\n-        }\n-        ExprKind::DropTemps(ref subexpression) => {\n-            visitor.visit_expr(subexpression);\n-        }\n-        ExprKind::Let(ref let_expr) => visitor.visit_let_expr(let_expr),\n-        ExprKind::If(ref cond, ref then, ref else_opt) => {\n-            visitor.visit_expr(cond);\n-            visitor.visit_expr(then);\n-            walk_list!(visitor, visit_expr, else_opt);\n-        }\n-        ExprKind::Loop(ref block, ref opt_label, _, _) => {\n-            walk_list!(visitor, visit_label, opt_label);\n-            visitor.visit_block(block);\n-        }\n-        ExprKind::Match(ref subexpression, arms, _) => {\n-            visitor.visit_expr(subexpression);\n-            walk_list!(visitor, visit_arm, arms);\n-        }\n-        ExprKind::Closure(&Closure {\n-            binder: _,\n-            bound_generic_params,\n-            fn_decl,\n-            body,\n-            capture_clause: _,\n-            fn_decl_span: _,\n-            movability: _,\n-        }) => {\n-            walk_list!(visitor, visit_generic_param, bound_generic_params);\n-            visitor.visit_fn(FnKind::Closure, fn_decl, body, expression.span, expression.hir_id)\n-        }\n-        ExprKind::Block(ref block, ref opt_label) => {\n-            walk_list!(visitor, visit_label, opt_label);\n-            visitor.visit_block(block);\n-        }\n-        ExprKind::Assign(ref lhs, ref rhs, _) => {\n-            visitor.visit_expr(rhs);\n-            visitor.visit_expr(lhs)\n-        }\n-        ExprKind::AssignOp(_, ref left_expression, ref right_expression) => {\n-            visitor.visit_expr(right_expression);\n-            visitor.visit_expr(left_expression);\n-        }\n-        ExprKind::Field(ref subexpression, ident) => {\n-            visitor.visit_expr(subexpression);\n-            visitor.visit_ident(ident);\n-        }\n-        ExprKind::Index(ref main_expression, ref index_expression) => {\n-            visitor.visit_expr(main_expression);\n-            visitor.visit_expr(index_expression)\n-        }\n-        ExprKind::Path(ref qpath) => {\n-            visitor.visit_qpath(qpath, expression.hir_id, expression.span);\n-        }\n-        ExprKind::Break(ref destination, ref opt_expr) => {\n-            walk_list!(visitor, visit_label, &destination.label);\n-            walk_list!(visitor, visit_expr, opt_expr);\n-        }\n-        ExprKind::Continue(ref destination) => {\n-            walk_list!(visitor, visit_label, &destination.label);\n-        }\n-        ExprKind::Ret(ref optional_expression) => {\n-            walk_list!(visitor, visit_expr, optional_expression);\n-        }\n-        ExprKind::InlineAsm(ref asm) => {\n-            visitor.visit_inline_asm(asm, expression.hir_id);\n-        }\n-        ExprKind::Yield(ref subexpression, _) => {\n-            visitor.visit_expr(subexpression);\n-        }\n-        ExprKind::Lit(_) | ExprKind::Err => {}\n+        QPath::LangItem(..) => {}\n     }\n }\n \n-pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm<'v>) {\n-    visitor.visit_id(arm.hir_id);\n-    visitor.visit_pat(&arm.pat);\n-    if let Some(ref g) = arm.guard {\n-        match g {\n-            Guard::If(ref e) => visitor.visit_expr(e),\n-            Guard::IfLet(ref l) => {\n-                visitor.visit_let_expr(l);\n-            }\n-        }\n+pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path<'v>) {\n+    for segment in path.segments {\n+        visitor.visit_path_segment(segment);\n+    }\n+}\n+\n+pub fn walk_path_segment<'v, V: Visitor<'v>>(visitor: &mut V, segment: &'v PathSegment<'v>) {\n+    visitor.visit_ident(segment.ident);\n+    visitor.visit_id(segment.hir_id);\n+    if let Some(ref args) = segment.args {\n+        visitor.visit_generic_args(args);\n+    }\n+}\n+\n+pub fn walk_generic_args<'v, V: Visitor<'v>>(visitor: &mut V, generic_args: &'v GenericArgs<'v>) {\n+    walk_list!(visitor, visit_generic_arg, generic_args.args);\n+    walk_list!(visitor, visit_assoc_type_binding, generic_args.bindings);\n+}\n+\n+pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(\n+    visitor: &mut V,\n+    type_binding: &'v TypeBinding<'v>,\n+) {\n+    visitor.visit_id(type_binding.hir_id);\n+    visitor.visit_ident(type_binding.ident);\n+    visitor.visit_generic_args(type_binding.gen_args);\n+    match type_binding.kind {\n+        TypeBindingKind::Equality { ref term } => match term {\n+            Term::Ty(ref ty) => visitor.visit_ty(ty),\n+            Term::Const(ref c) => visitor.visit_anon_const(c),\n+        },\n+        TypeBindingKind::Constraint { bounds } => walk_list!(visitor, visit_param_bound, bounds),\n     }\n-    visitor.visit_expr(&arm.body);\n }\n \n pub fn walk_associated_item_kind<'v, V: Visitor<'v>>(_: &mut V, _: &'v AssocItemKind) {\n@@ -1198,3 +1181,27 @@ pub fn walk_defaultness<'v, V: Visitor<'v>>(_: &mut V, _: &'v Defaultness) {\n     // the right thing to do, should content be added in the future,\n     // would be to walk it.\n }\n+\n+pub fn walk_inline_asm<'v, V: Visitor<'v>>(visitor: &mut V, asm: &'v InlineAsm<'v>, id: HirId) {\n+    for (op, op_sp) in asm.operands {\n+        match op {\n+            InlineAsmOperand::In { expr, .. } | InlineAsmOperand::InOut { expr, .. } => {\n+                visitor.visit_expr(expr)\n+            }\n+            InlineAsmOperand::Out { expr, .. } => {\n+                if let Some(expr) = expr {\n+                    visitor.visit_expr(expr);\n+                }\n+            }\n+            InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n+                visitor.visit_expr(in_expr);\n+                if let Some(out_expr) = out_expr {\n+                    visitor.visit_expr(out_expr);\n+                }\n+            }\n+            InlineAsmOperand::Const { anon_const, .. }\n+            | InlineAsmOperand::SymFn { anon_const, .. } => visitor.visit_anon_const(anon_const),\n+            InlineAsmOperand::SymStatic { path, .. } => visitor.visit_qpath(path, id, *op_sp),\n+        }\n+    }\n+}"}, {"sha": "a55224d10972abf01a57e95933d174bab7481941", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 107, "deletions": 105, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -12,35 +12,56 @@ use crate::errors::LangItemError;\n use crate::{MethodKind, Target};\n \n use rustc_ast as ast;\n-use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_macros::HashStable_Generic;\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n \n-use std::sync::LazyLock;\n-\n-pub enum LangItemGroup {\n-    Op,\n-    Fn,\n+/// All of the language items, defined or not.\n+/// Defined lang items can come from the current crate or its dependencies.\n+#[derive(HashStable_Generic, Debug)]\n+pub struct LanguageItems {\n+    /// Mappings from lang items to their possibly found [`DefId`]s.\n+    /// The index corresponds to the order in [`LangItem`].\n+    items: [Option<DefId>; std::mem::variant_count::<LangItem>()],\n+    /// Lang items that were not found during collection.\n+    pub missing: Vec<LangItem>,\n }\n \n-const NUM_GROUPS: usize = 2;\n+impl LanguageItems {\n+    /// Construct an empty collection of lang items and no missing ones.\n+    pub fn new() -> Self {\n+        Self { items: [None; std::mem::variant_count::<LangItem>()], missing: Vec::new() }\n+    }\n+\n+    pub fn get(&self, item: LangItem) -> Option<DefId> {\n+        self.items[item as usize]\n+    }\n \n-macro_rules! expand_group {\n-    () => {\n-        None\n-    };\n-    ($group:expr) => {\n-        Some($group)\n-    };\n+    pub fn set(&mut self, item: LangItem, def_id: DefId) {\n+        self.items[item as usize] = Some(def_id);\n+    }\n+\n+    /// Requires that a given `LangItem` was bound and returns the corresponding `DefId`.\n+    /// If it wasn't bound, e.g. due to a missing `#[lang = \"<it.name()>\"]`,\n+    /// returns an error encapsulating the `LangItem`.\n+    pub fn require(&self, it: LangItem) -> Result<DefId, LangItemError> {\n+        self.get(it).ok_or_else(|| LangItemError(it))\n+    }\n+\n+    pub fn iter<'a>(&'a self) -> impl Iterator<Item = (LangItem, DefId)> + 'a {\n+        self.items\n+            .iter()\n+            .enumerate()\n+            .filter_map(|(i, id)| id.map(|id| (LangItem::from_u32(i as u32).unwrap(), id)))\n+    }\n }\n \n // The actual lang items defined come at the end of this file in one handy table.\n // So you probably just want to nip down to the end.\n macro_rules! language_item_table {\n     (\n-        $( $(#[$attr:meta])* $variant:ident $($group:expr)?, $module:ident :: $name:ident, $method:ident, $target:expr, $generics:expr; )*\n+        $( $(#[$attr:meta])* $variant:ident, $module:ident :: $name:ident, $method:ident, $target:expr, $generics:expr; )*\n     ) => {\n \n         enum_from_u32! {\n@@ -66,12 +87,17 @@ macro_rules! language_item_table {\n                 }\n             }\n \n-            /// The [group](LangItemGroup) that this lang item belongs to,\n-            /// or `None` if it doesn't belong to a group.\n-            pub fn group(self) -> Option<LangItemGroup> {\n-                use LangItemGroup::*;\n+            /// Opposite of [`LangItem::name`]\n+            pub fn from_name(name: Symbol) -> Option<Self> {\n+                match name {\n+                    $( $module::$name => Some(LangItem::$variant), )*\n+                    _ => None,\n+                }\n+            }\n+\n+            pub fn target(self) -> Target {\n                 match self {\n-                    $( LangItem::$variant => expand_group!($($group)*), )*\n+                    $( LangItem::$variant => $target, )*\n                 }\n             }\n \n@@ -82,66 +108,14 @@ macro_rules! language_item_table {\n             }\n         }\n \n-        /// All of the language items, defined or not.\n-        /// Defined lang items can come from the current crate or its dependencies.\n-        #[derive(HashStable_Generic, Debug)]\n-        pub struct LanguageItems {\n-            /// Mappings from lang items to their possibly found [`DefId`]s.\n-            /// The index corresponds to the order in [`LangItem`].\n-            pub items: Vec<Option<DefId>>,\n-            /// Lang items that were not found during collection.\n-            pub missing: Vec<LangItem>,\n-            /// Mapping from [`LangItemGroup`] discriminants to all\n-            /// [`DefId`]s of lang items in that group.\n-            pub groups: [Vec<DefId>; NUM_GROUPS],\n-        }\n-\n         impl LanguageItems {\n-            /// Construct an empty collection of lang items and no missing ones.\n-            pub fn new() -> Self {\n-                fn init_none(_: LangItem) -> Option<DefId> { None }\n-                const EMPTY: Vec<DefId> = Vec::new();\n-\n-                Self {\n-                    items: vec![$(init_none(LangItem::$variant)),*],\n-                    missing: Vec::new(),\n-                    groups: [EMPTY; NUM_GROUPS],\n-                }\n-            }\n-\n-            /// Returns the mappings to the possibly found `DefId`s for each lang item.\n-            pub fn items(&self) -> &[Option<DefId>] {\n-                &*self.items\n-            }\n-\n-            /// Requires that a given `LangItem` was bound and returns the corresponding `DefId`.\n-            /// If it wasn't bound, e.g. due to a missing `#[lang = \"<it.name()>\"]`,\n-            /// returns an error encapsulating the `LangItem`.\n-            pub fn require(&self, it: LangItem) -> Result<DefId, LangItemError> {\n-                self.items[it as usize].ok_or_else(|| LangItemError(it))\n-            }\n-\n-            /// Returns the [`DefId`]s of all lang items in a group.\n-            pub fn group(&self, group: LangItemGroup) -> &[DefId] {\n-                self.groups[group as usize].as_ref()\n-            }\n-\n             $(\n                 #[doc = concat!(\"Returns the [`DefId`] of the `\", stringify!($name), \"` lang item if it is defined.\")]\n                 pub fn $method(&self) -> Option<DefId> {\n                     self.items[LangItem::$variant as usize]\n                 }\n             )*\n         }\n-\n-        /// A mapping from the name of the lang item to its order and the form it must be of.\n-        pub static ITEM_REFS: LazyLock<FxIndexMap<Symbol, (usize, Target)>> = LazyLock::new(|| {\n-            let mut item_refs = FxIndexMap::default();\n-            $( item_refs.insert($module::$name, (LangItem::$variant as usize, $target)); )*\n-            item_refs\n-        });\n-\n-// End of the macro\n     }\n }\n \n@@ -152,14 +126,12 @@ impl<CTX> HashStable<CTX> for LangItem {\n }\n \n /// Extracts the first `lang = \"$name\"` out of a list of attributes.\n-/// The attributes `#[panic_handler]` and `#[alloc_error_handler]`\n-/// are also extracted out when found.\n+/// The `#[panic_handler]` attribute is also extracted out when found.\n pub fn extract(attrs: &[ast::Attribute]) -> Option<(Symbol, Span)> {\n     attrs.iter().find_map(|attr| {\n         Some(match attr {\n             _ if attr.has_name(sym::lang) => (attr.value_str()?, attr.span),\n             _ if attr.has_name(sym::panic_handler) => (sym::panic_impl, attr.span),\n-            _ if attr.has_name(sym::alloc_error_handler) => (sym::oom, attr.span),\n             _ => return None,\n         })\n     })\n@@ -196,30 +168,30 @@ language_item_table! {\n     TransmuteOpts,           sym::transmute_opts,      transmute_opts,             Target::Struct,         GenericRequirement::Exact(0);\n     TransmuteTrait,          sym::transmute_trait,     transmute_trait,            Target::Trait,          GenericRequirement::Exact(3);\n \n-    Add(Op),                 sym::add,                 add_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n-    Sub(Op),                 sym::sub,                 sub_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n-    Mul(Op),                 sym::mul,                 mul_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n-    Div(Op),                 sym::div,                 div_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n-    Rem(Op),                 sym::rem,                 rem_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n-    Neg(Op),                 sym::neg,                 neg_trait,                  Target::Trait,          GenericRequirement::Exact(0);\n-    Not(Op),                 sym::not,                 not_trait,                  Target::Trait,          GenericRequirement::Exact(0);\n-    BitXor(Op),              sym::bitxor,              bitxor_trait,               Target::Trait,          GenericRequirement::Exact(1);\n-    BitAnd(Op),              sym::bitand,              bitand_trait,               Target::Trait,          GenericRequirement::Exact(1);\n-    BitOr(Op),               sym::bitor,               bitor_trait,                Target::Trait,          GenericRequirement::Exact(1);\n-    Shl(Op),                 sym::shl,                 shl_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n-    Shr(Op),                 sym::shr,                 shr_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n-    AddAssign(Op),           sym::add_assign,          add_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n-    SubAssign(Op),           sym::sub_assign,          sub_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n-    MulAssign(Op),           sym::mul_assign,          mul_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n-    DivAssign(Op),           sym::div_assign,          div_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n-    RemAssign(Op),           sym::rem_assign,          rem_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n-    BitXorAssign(Op),        sym::bitxor_assign,       bitxor_assign_trait,        Target::Trait,          GenericRequirement::Exact(1);\n-    BitAndAssign(Op),        sym::bitand_assign,       bitand_assign_trait,        Target::Trait,          GenericRequirement::Exact(1);\n-    BitOrAssign(Op),         sym::bitor_assign,        bitor_assign_trait,         Target::Trait,          GenericRequirement::Exact(1);\n-    ShlAssign(Op),           sym::shl_assign,          shl_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n-    ShrAssign(Op),           sym::shr_assign,          shr_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n-    Index(Op),               sym::index,               index_trait,                Target::Trait,          GenericRequirement::Exact(1);\n-    IndexMut(Op),            sym::index_mut,           index_mut_trait,            Target::Trait,          GenericRequirement::Exact(1);\n+    Add,                     sym::add,                 add_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Sub,                     sym::sub,                 sub_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Mul,                     sym::mul,                 mul_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Div,                     sym::div,                 div_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Rem,                     sym::rem,                 rem_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Neg,                     sym::neg,                 neg_trait,                  Target::Trait,          GenericRequirement::Exact(0);\n+    Not,                     sym::not,                 not_trait,                  Target::Trait,          GenericRequirement::Exact(0);\n+    BitXor,                  sym::bitxor,              bitxor_trait,               Target::Trait,          GenericRequirement::Exact(1);\n+    BitAnd,                  sym::bitand,              bitand_trait,               Target::Trait,          GenericRequirement::Exact(1);\n+    BitOr,                   sym::bitor,               bitor_trait,                Target::Trait,          GenericRequirement::Exact(1);\n+    Shl,                     sym::shl,                 shl_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Shr,                     sym::shr,                 shr_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    AddAssign,               sym::add_assign,          add_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    SubAssign,               sym::sub_assign,          sub_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    MulAssign,               sym::mul_assign,          mul_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    DivAssign,               sym::div_assign,          div_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    RemAssign,               sym::rem_assign,          rem_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    BitXorAssign,            sym::bitxor_assign,       bitxor_assign_trait,        Target::Trait,          GenericRequirement::Exact(1);\n+    BitAndAssign,            sym::bitand_assign,       bitand_assign_trait,        Target::Trait,          GenericRequirement::Exact(1);\n+    BitOrAssign,             sym::bitor_assign,        bitor_assign_trait,         Target::Trait,          GenericRequirement::Exact(1);\n+    ShlAssign,               sym::shl_assign,          shl_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    ShrAssign,               sym::shr_assign,          shr_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    Index,                   sym::index,               index_trait,                Target::Trait,          GenericRequirement::Exact(1);\n+    IndexMut,                sym::index_mut,           index_mut_trait,            Target::Trait,          GenericRequirement::Exact(1);\n \n     UnsafeCell,              sym::unsafe_cell,         unsafe_cell_type,           Target::Struct,         GenericRequirement::None;\n     VaList,                  sym::va_list,             va_list,                    Target::Struct,         GenericRequirement::None;\n@@ -229,9 +201,9 @@ language_item_table! {\n     DerefTarget,             sym::deref_target,        deref_target,               Target::AssocTy,        GenericRequirement::None;\n     Receiver,                sym::receiver,            receiver_trait,             Target::Trait,          GenericRequirement::None;\n \n-    Fn(Fn),                  kw::Fn,                   fn_trait,                   Target::Trait,          GenericRequirement::Exact(1);\n-    FnMut(Fn),               sym::fn_mut,              fn_mut_trait,               Target::Trait,          GenericRequirement::Exact(1);\n-    FnOnce(Fn),              sym::fn_once,             fn_once_trait,              Target::Trait,          GenericRequirement::Exact(1);\n+    Fn,                      kw::Fn,                   fn_trait,                   Target::Trait,          GenericRequirement::Exact(1);\n+    FnMut,                   sym::fn_mut,              fn_mut_trait,               Target::Trait,          GenericRequirement::Exact(1);\n+    FnOnce,                  sym::fn_once,             fn_once_trait,              Target::Trait,          GenericRequirement::Exact(1);\n \n     FnOnceOutput,            sym::fn_once_output,      fn_once_output,             Target::AssocTy,        GenericRequirement::None;\n \n@@ -241,8 +213,8 @@ language_item_table! {\n     Unpin,                   sym::unpin,               unpin_trait,                Target::Trait,          GenericRequirement::None;\n     Pin,                     sym::pin,                 pin_type,                   Target::Struct,         GenericRequirement::None;\n \n-    PartialEq(Op),           sym::eq,                  eq_trait,                   Target::Trait,          GenericRequirement::Exact(1);\n-    PartialOrd(Op),          sym::partial_ord,         partial_ord_trait,          Target::Trait,          GenericRequirement::Exact(1);\n+    PartialEq,               sym::eq,                  eq_trait,                   Target::Trait,          GenericRequirement::Exact(1);\n+    PartialOrd,              sym::partial_ord,         partial_ord_trait,          Target::Trait,          GenericRequirement::Exact(1);\n \n     // A number of panic-related lang items. The `panic` item corresponds to divide-by-zero and\n     // various panic cases with `match`. The `panic_bounds_check` item is for indexing arrays.\n@@ -266,7 +238,6 @@ language_item_table! {\n     ExchangeMalloc,          sym::exchange_malloc,     exchange_malloc_fn,         Target::Fn,             GenericRequirement::None;\n     BoxFree,                 sym::box_free,            box_free_fn,                Target::Fn,             GenericRequirement::Minimum(1);\n     DropInPlace,             sym::drop_in_place,       drop_in_place_fn,           Target::Fn,             GenericRequirement::Minimum(1);\n-    Oom,                     sym::oom,                 oom,                        Target::Fn,             GenericRequirement::None;\n     AllocLayout,             sym::alloc_layout,        alloc_layout,               Target::Struct,         GenericRequirement::None;\n \n     Start,                   sym::start,               start_fn,                   Target::Fn,             GenericRequirement::Exact(1);\n@@ -338,3 +309,34 @@ pub enum GenericRequirement {\n     Minimum(usize),\n     Exact(usize),\n }\n+\n+pub static FN_TRAITS: &'static [LangItem] = &[LangItem::Fn, LangItem::FnMut, LangItem::FnOnce];\n+\n+pub static OPERATORS: &'static [LangItem] = &[\n+    LangItem::Add,\n+    LangItem::Sub,\n+    LangItem::Mul,\n+    LangItem::Div,\n+    LangItem::Rem,\n+    LangItem::Neg,\n+    LangItem::Not,\n+    LangItem::BitXor,\n+    LangItem::BitAnd,\n+    LangItem::BitOr,\n+    LangItem::Shl,\n+    LangItem::Shr,\n+    LangItem::AddAssign,\n+    LangItem::SubAssign,\n+    LangItem::MulAssign,\n+    LangItem::DivAssign,\n+    LangItem::RemAssign,\n+    LangItem::BitXorAssign,\n+    LangItem::BitAndAssign,\n+    LangItem::BitOrAssign,\n+    LangItem::ShlAssign,\n+    LangItem::ShrAssign,\n+    LangItem::Index,\n+    LangItem::IndexMut,\n+    LangItem::PartialEq,\n+    LangItem::PartialOrd,\n+];"}, {"sha": "1c55cd8fee8f922f94a92bc398f291ee68748b0e", "filename": "compiler/rustc_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flib.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -5,10 +5,10 @@\n #![feature(associated_type_defaults)]\n #![feature(closure_track_caller)]\n #![feature(const_btree_len)]\n-#![feature(once_cell)]\n #![feature(min_specialization)]\n #![feature(never_type)]\n #![feature(rustc_attrs)]\n+#![feature(variant_count)]\n #![recursion_limit = \"256\"]\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]"}, {"sha": "0cc50c6dd85054642fdb576e5137c7bded4bb934", "filename": "compiler/rustc_hir/src/weak_lang_items.rs", "status": "modified", "additions": 18, "deletions": 41, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir%2Fsrc%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir%2Fsrc%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fweak_lang_items.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -1,53 +1,30 @@\n //! Validity checking for weak lang items\n \n-use crate::def_id::DefId;\n-use crate::{lang_items, LangItem, LanguageItems};\n+use crate::LangItem;\n \n-use rustc_ast as ast;\n-use rustc_data_structures::fx::FxIndexMap;\n use rustc_span::symbol::{sym, Symbol};\n \n-use std::sync::LazyLock;\n-\n macro_rules! weak_lang_items {\n-    ($($name:ident, $item:ident, $sym:ident;)*) => (\n-\n-pub static WEAK_ITEMS_REFS: LazyLock<FxIndexMap<Symbol, LangItem>> = LazyLock::new(|| {\n-    let mut map = FxIndexMap::default();\n-    $(map.insert(sym::$name, LangItem::$item);)*\n-    map\n-});\n-\n-pub static WEAK_ITEMS_SYMBOLS: LazyLock<FxIndexMap<LangItem, Symbol>> = LazyLock::new(|| {\n-    let mut map = FxIndexMap::default();\n-    $(map.insert(LangItem::$item, sym::$sym);)*\n-    map\n-});\n-\n-pub fn link_name(attrs: &[ast::Attribute]) -> Option<Symbol>\n-{\n-    lang_items::extract(attrs).and_then(|(name, _)| {\n-        $(if name == sym::$name {\n-            Some(sym::$sym)\n-        } else)* {\n-            None\n+    ($($item:ident, $sym:ident;)*) => {\n+        pub static WEAK_LANG_ITEMS: &[LangItem] = &[$(LangItem::$item,)*];\n+\n+        impl LangItem {\n+            pub fn is_weak(self) -> bool {\n+                matches!(self, $(LangItem::$item)|*)\n+            }\n+\n+            pub fn link_name(self) -> Option<Symbol> {\n+                match self {\n+                    $( LangItem::$item => Some(sym::$sym),)*\n+                    _ => None,\n+                }\n+            }\n         }\n-    })\n-}\n-\n-impl LanguageItems {\n-    pub fn is_weak_lang_item(&self, item_def_id: DefId) -> bool {\n-        let did = Some(item_def_id);\n-\n-        $(self.$name() == did)||*\n     }\n }\n \n-) }\n-\n weak_lang_items! {\n-    panic_impl,         PanicImpl,          rust_begin_unwind;\n-    eh_personality,     EhPersonality,      rust_eh_personality;\n-    eh_catch_typeinfo,  EhCatchTypeinfo,    rust_eh_catch_typeinfo;\n-    oom,                Oom,                rust_oom;\n+    PanicImpl,          rust_begin_unwind;\n+    EhPersonality,      rust_eh_personality;\n+    EhCatchTypeinfo,    rust_eh_catch_typeinfo;\n }"}, {"sha": "e6465d641f1e64552af60f0775a5bbf4564b0666", "filename": "compiler/rustc_hir_analysis/src/astconv/errors.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -177,11 +177,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             .all_traits()\n             .filter(|trait_def_id| {\n                 let viz = self.tcx().visibility(*trait_def_id);\n-                if let Some(def_id) = self.item_def_id() {\n-                    viz.is_accessible_from(def_id, self.tcx())\n-                } else {\n-                    viz.is_visible_locally()\n-                }\n+                let def_id = self.item_def_id();\n+                viz.is_accessible_from(def_id, self.tcx())\n             })\n             .collect();\n "}, {"sha": "9ad1d2bc542d7ce3ac96ae57dfc9b7b0c9c9c730", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -23,7 +23,6 @@ use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Namespace, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{walk_generics, Visitor as _};\n-use rustc_hir::lang_items::LangItem;\n use rustc_hir::{GenericArg, GenericArgs, OpaqueTyOrigin};\n use rustc_middle::middle::stability::AllowUnstable;\n use rustc_middle::ty::subst::{self, GenericArgKind, InternalSubsts, SubstsRef};\n@@ -55,7 +54,7 @@ pub struct PathSeg(pub DefId, pub usize);\n pub trait AstConv<'tcx> {\n     fn tcx<'a>(&'a self) -> TyCtxt<'tcx>;\n \n-    fn item_def_id(&self) -> Option<DefId>;\n+    fn item_def_id(&self) -> DefId;\n \n     /// Returns predicates in scope of the form `X: Foo<T>`, where `X`\n     /// is a type parameter `X` with the given id `def_id` and T\n@@ -501,6 +500,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     }\n                     GenericParamDefKind::Const { has_default } => {\n                         let ty = tcx.at(self.span).type_of(param.def_id);\n+                        if ty.references_error() {\n+                            return tcx.const_error(ty).into();\n+                        }\n                         if !infer_args && has_default {\n                             tcx.bound_const_param_default(param.def_id)\n                                 .subst(tcx, substs.unwrap())\n@@ -884,9 +886,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n         }\n \n-        let sized_def_id = tcx.lang_items().require(LangItem::Sized);\n+        let sized_def_id = tcx.lang_items().sized_trait();\n         match (&sized_def_id, unbound) {\n-            (Ok(sized_def_id), Some(tpb))\n+            (Some(sized_def_id), Some(tpb))\n                 if tpb.path.res == Res::Def(DefKind::Trait, *sized_def_id) =>\n             {\n                 // There was in fact a `?Sized` bound, return without doing anything\n@@ -906,7 +908,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // There was no `?Sized` bound; add implicitly sized if `Sized` is available.\n             }\n         }\n-        if sized_def_id.is_err() {\n+        if sized_def_id.is_none() {\n             // No lang item for `Sized`, so we can't add it as a bound.\n             return;\n         }\n@@ -1908,6 +1910,20 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     }\n                 }\n             }\n+\n+            // see if we can satisfy using an inherent associated type\n+            for impl_ in tcx.inherent_impls(adt_def.did()) {\n+                let assoc_ty = tcx.associated_items(impl_).find_by_name_and_kind(\n+                    tcx,\n+                    assoc_ident,\n+                    ty::AssocKind::Type,\n+                    *impl_,\n+                );\n+                if let Some(assoc_ty) = assoc_ty {\n+                    let ty = tcx.type_of(assoc_ty.def_id);\n+                    return Ok((ty, DefKind::AssocTy, assoc_ty.def_id));\n+                }\n+            }\n         }\n \n         // Find the type of the associated item, and the trait where the associated\n@@ -1977,7 +1993,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     }\n \n                     err.emit()\n-                } else if let Some(reported) = qself_ty.error_reported() {\n+                } else if let Err(reported) = qself_ty.error_reported() {\n                     reported\n                 } else {\n                     // Don't print `TyErr` to the user.\n@@ -2080,17 +2096,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n             debug!(\"qpath_to_ty: self.item_def_id()={:?}\", def_id);\n \n-            let parent_def_id = def_id\n-                .and_then(|def_id| {\n-                    def_id.as_local().map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id))\n-                })\n+            let parent_def_id = def_id.as_local().map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id))\n                 .map(|hir_id| tcx.hir().get_parent_item(hir_id).to_def_id());\n \n             debug!(\"qpath_to_ty: parent_def_id={:?}\", parent_def_id);\n \n             // If the trait in segment is the same as the trait defining the item,\n             // use the `<Self as ..>` syntax in the error.\n-            let is_part_of_self_trait_constraints = def_id == Some(trait_def_id);\n+            let is_part_of_self_trait_constraints = def_id == trait_def_id;\n             let is_part_of_fn_in_self_trait = parent_def_id == Some(trait_def_id);\n \n             let type_name = if is_part_of_self_trait_constraints || is_part_of_fn_in_self_trait {"}, {"sha": "133bbd52b9142c3249d634c057088df2953bfef9", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 62, "deletions": 59, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -6,7 +6,7 @@ use super::*;\n use rustc_attr as attr;\n use rustc_errors::{Applicability, ErrorGuaranteed, MultiSpan};\n use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::{ItemKind, Node, PathSegment};\n@@ -75,15 +75,15 @@ fn check_struct(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n         check_simd(tcx, span, def_id);\n     }\n \n-    check_transparent(tcx, span, def);\n+    check_transparent(tcx, def);\n     check_packed(tcx, span, def);\n }\n \n fn check_union(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let def = tcx.adt_def(def_id);\n     let span = tcx.def_span(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n-    check_transparent(tcx, span, def);\n+    check_transparent(tcx, def);\n     check_union_fields(tcx, span, def_id);\n     check_packed(tcx, span, def);\n }\n@@ -506,11 +506,7 @@ fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n             tcx.ensure().typeck(id.owner_id.def_id);\n         }\n         DefKind::Enum => {\n-            let item = tcx.hir().item(id);\n-            let hir::ItemKind::Enum(ref enum_definition, _) = item.kind else {\n-                return;\n-            };\n-            check_enum(tcx, &enum_definition.variants, item.owner_id.def_id);\n+            check_enum(tcx, id.owner_id.def_id);\n         }\n         DefKind::Fn => {} // entirely within check_item_body\n         DefKind::Impl => {\n@@ -1026,7 +1022,7 @@ pub(super) fn check_packed_inner(\n     None\n }\n \n-pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, adt: ty::AdtDef<'tcx>) {\n+pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, adt: ty::AdtDef<'tcx>) {\n     if !adt.repr().transparent() {\n         return;\n     }\n@@ -1035,14 +1031,14 @@ pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, adt: ty::AdtD\n         feature_err(\n             &tcx.sess.parse_sess,\n             sym::transparent_unions,\n-            sp,\n+            tcx.def_span(adt.did()),\n             \"transparent unions are unstable\",\n         )\n         .emit();\n     }\n \n     if adt.variants().len() != 1 {\n-        bad_variant_count(tcx, adt, sp, adt.did());\n+        bad_variant_count(tcx, adt, tcx.def_span(adt.did()), adt.did());\n         if adt.variants().is_empty() {\n             // Don't bother checking the fields. No variants (and thus no fields) exist.\n             return;\n@@ -1103,7 +1099,7 @@ pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, adt: ty::AdtD\n         .filter_map(|(span, zst, _align1, _non_exhaustive)| if !zst { Some(span) } else { None });\n     let non_zst_count = non_zst_fields.clone().count();\n     if non_zst_count >= 2 {\n-        bad_non_zero_sized_fields(tcx, adt, non_zst_count, non_zst_fields, sp);\n+        bad_non_zero_sized_fields(tcx, adt, non_zst_count, non_zst_fields, tcx.def_span(adt.did()));\n     }\n     let incompatible_zst_fields =\n         field_infos.clone().filter(|(_, _, _, opt)| opt.is_some()).count();\n@@ -1143,20 +1139,19 @@ pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, adt: ty::AdtD\n }\n \n #[allow(trivial_numeric_casts)]\n-fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, vs: &'tcx [hir::Variant<'tcx>], def_id: LocalDefId) {\n+fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) {\n     let def = tcx.adt_def(def_id);\n-    let sp = tcx.def_span(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n \n-    if vs.is_empty() {\n+    if def.variants().is_empty() {\n         if let Some(attr) = tcx.get_attrs(def_id.to_def_id(), sym::repr).next() {\n             struct_span_err!(\n                 tcx.sess,\n                 attr.span,\n                 E0084,\n                 \"unsupported representation for zero-variant enum\"\n             )\n-            .span_label(sp, \"zero-variant enum\")\n+            .span_label(tcx.def_span(def_id), \"zero-variant enum\")\n             .emit();\n         }\n     }\n@@ -1167,88 +1162,96 @@ fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, vs: &'tcx [hir::Variant<'tcx>], def_id: L\n             feature_err(\n                 &tcx.sess.parse_sess,\n                 sym::repr128,\n-                sp,\n+                tcx.def_span(def_id),\n                 \"repr with 128-bit type is unstable\",\n             )\n             .emit();\n         }\n     }\n \n-    for v in vs {\n-        if let Some(ref e) = v.disr_expr {\n-            tcx.ensure().typeck(tcx.hir().local_def_id(e.hir_id));\n+    for v in def.variants() {\n+        if let ty::VariantDiscr::Explicit(discr_def_id) = v.discr {\n+            tcx.ensure().typeck(discr_def_id.expect_local());\n         }\n     }\n \n-    if tcx.adt_def(def_id).repr().int.is_none() {\n-        let is_unit = |var: &hir::Variant<'_>| matches!(var.data, hir::VariantData::Unit(..));\n+    if def.repr().int.is_none() {\n+        let is_unit = |var: &ty::VariantDef| matches!(var.ctor_kind, CtorKind::Const);\n+        let has_disr = |var: &ty::VariantDef| matches!(var.discr, ty::VariantDiscr::Explicit(_));\n \n-        let has_disr = |var: &hir::Variant<'_>| var.disr_expr.is_some();\n-        let has_non_units = vs.iter().any(|var| !is_unit(var));\n-        let disr_units = vs.iter().any(|var| is_unit(&var) && has_disr(&var));\n-        let disr_non_unit = vs.iter().any(|var| !is_unit(&var) && has_disr(&var));\n+        let has_non_units = def.variants().iter().any(|var| !is_unit(var));\n+        let disr_units = def.variants().iter().any(|var| is_unit(&var) && has_disr(&var));\n+        let disr_non_unit = def.variants().iter().any(|var| !is_unit(&var) && has_disr(&var));\n \n         if disr_non_unit || (disr_units && has_non_units) {\n-            let mut err =\n-                struct_span_err!(tcx.sess, sp, E0732, \"`#[repr(inttype)]` must be specified\");\n+            let mut err = struct_span_err!(\n+                tcx.sess,\n+                tcx.def_span(def_id),\n+                E0732,\n+                \"`#[repr(inttype)]` must be specified\"\n+            );\n             err.emit();\n         }\n     }\n \n-    detect_discriminant_duplicate(tcx, def.discriminants(tcx).collect(), vs, sp);\n-\n-    check_transparent(tcx, sp, def);\n+    detect_discriminant_duplicate(tcx, def);\n+    check_transparent(tcx, def);\n }\n \n /// Part of enum check. Given the discriminants of an enum, errors if two or more discriminants are equal\n-fn detect_discriminant_duplicate<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    mut discrs: Vec<(VariantIdx, Discr<'tcx>)>,\n-    vs: &'tcx [hir::Variant<'tcx>],\n-    self_span: Span,\n-) {\n+fn detect_discriminant_duplicate<'tcx>(tcx: TyCtxt<'tcx>, adt: ty::AdtDef<'tcx>) {\n     // Helper closure to reduce duplicate code. This gets called everytime we detect a duplicate.\n     // Here `idx` refers to the order of which the discriminant appears, and its index in `vs`\n-    let report = |dis: Discr<'tcx>, idx: usize, err: &mut Diagnostic| {\n-        let var = &vs[idx]; // HIR for the duplicate discriminant\n-        let (span, display_discr) = match var.disr_expr {\n-            Some(ref expr) => {\n+    let report = |dis: Discr<'tcx>, idx, err: &mut Diagnostic| {\n+        let var = adt.variant(idx); // HIR for the duplicate discriminant\n+        let (span, display_discr) = match var.discr {\n+            ty::VariantDiscr::Explicit(discr_def_id) => {\n                 // In the case the discriminant is both a duplicate and overflowed, let the user know\n-                if let hir::ExprKind::Lit(lit) = &tcx.hir().body(expr.body).value.kind\n+                if let hir::Node::AnonConst(expr) = tcx.hir().get_by_def_id(discr_def_id.expect_local())\n+                    && let hir::ExprKind::Lit(lit) = &tcx.hir().body(expr.body).value.kind\n                     && let rustc_ast::LitKind::Int(lit_value, _int_kind) = &lit.node\n                     && *lit_value != dis.val\n                 {\n-                    (tcx.hir().span(expr.hir_id), format!(\"`{dis}` (overflowed from `{lit_value}`)\"))\n-                // Otherwise, format the value as-is\n+                    (tcx.def_span(discr_def_id), format!(\"`{dis}` (overflowed from `{lit_value}`)\"))\n                 } else {\n-                    (tcx.hir().span(expr.hir_id), format!(\"`{dis}`\"))\n+                    // Otherwise, format the value as-is\n+                    (tcx.def_span(discr_def_id), format!(\"`{dis}`\"))\n                 }\n             }\n-            None => {\n+            // This should not happen.\n+            ty::VariantDiscr::Relative(0) => (tcx.def_span(var.def_id), format!(\"`{dis}`\")),\n+            ty::VariantDiscr::Relative(distance_to_explicit) => {\n                 // At this point we know this discriminant is a duplicate, and was not explicitly\n                 // assigned by the user. Here we iterate backwards to fetch the HIR for the last\n                 // explicitly assigned discriminant, and letting the user know that this was the\n                 // increment startpoint, and how many steps from there leading to the duplicate\n-                if let Some((n, hir::Variant { span, ident, .. })) =\n-                    vs[..idx].iter().rev().enumerate().find(|v| v.1.disr_expr.is_some())\n+                if let Some(explicit_idx) =\n+                    idx.as_u32().checked_sub(distance_to_explicit).map(VariantIdx::from_u32)\n                 {\n-                    let ve_ident = var.ident;\n-                    let n = n + 1;\n-                    let sp = if n > 1 { \"variants\" } else { \"variant\" };\n+                    let explicit_variant = adt.variant(explicit_idx);\n+                    let ve_ident = var.name;\n+                    let ex_ident = explicit_variant.name;\n+                    let sp = if distance_to_explicit > 1 { \"variants\" } else { \"variant\" };\n \n                     err.span_label(\n-                        *span,\n-                        format!(\"discriminant for `{ve_ident}` incremented from this startpoint (`{ident}` + {n} {sp} later => `{ve_ident}` = {dis})\"),\n+                        tcx.def_span(explicit_variant.def_id),\n+                        format!(\n+                            \"discriminant for `{ve_ident}` incremented from this startpoint \\\n+                            (`{ex_ident}` + {distance_to_explicit} {sp} later \\\n+                             => `{ve_ident}` = {dis})\"\n+                        ),\n                     );\n                 }\n \n-                (vs[idx].span, format!(\"`{dis}`\"))\n+                (tcx.def_span(var.def_id), format!(\"`{dis}`\"))\n             }\n         };\n \n         err.span_label(span, format!(\"{display_discr} assigned here\"));\n     };\n \n+    let mut discrs = adt.discriminants(tcx).collect::<Vec<_>>();\n+\n     // Here we loop through the discriminants, comparing each discriminant to another.\n     // When a duplicate is detected, we instantiate an error and point to both\n     // initial and duplicate value. The duplicate discriminant is then discarded by swapping\n@@ -1257,29 +1260,29 @@ fn detect_discriminant_duplicate<'tcx>(\n     // style as we are mutating `discrs` on the fly).\n     let mut i = 0;\n     while i < discrs.len() {\n-        let hir_var_i_idx = discrs[i].0.index();\n+        let var_i_idx = discrs[i].0;\n         let mut error: Option<DiagnosticBuilder<'_, _>> = None;\n \n         let mut o = i + 1;\n         while o < discrs.len() {\n-            let hir_var_o_idx = discrs[o].0.index();\n+            let var_o_idx = discrs[o].0;\n \n             if discrs[i].1.val == discrs[o].1.val {\n                 let err = error.get_or_insert_with(|| {\n                     let mut ret = struct_span_err!(\n                         tcx.sess,\n-                        self_span,\n+                        tcx.def_span(adt.did()),\n                         E0081,\n                         \"discriminant value `{}` assigned more than once\",\n                         discrs[i].1,\n                     );\n \n-                    report(discrs[i].1, hir_var_i_idx, &mut ret);\n+                    report(discrs[i].1, var_i_idx, &mut ret);\n \n                     ret\n                 });\n \n-                report(discrs[o].1, hir_var_o_idx, err);\n+                report(discrs[o].1, var_o_idx, err);\n \n                 // Safe to unwrap here, as we wouldn't reach this point if `discrs` was empty\n                 discrs[o] = *discrs.last().unwrap();"}, {"sha": "c6b497e9b9fc40aad71e61a8d16ef285c4cdea9b", "filename": "compiler/rustc_hir_analysis/src/check/compare_method.rs", "status": "modified", "additions": 8, "deletions": 21, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -290,23 +290,16 @@ fn compare_predicate_entailment<'tcx>(\n     // type would be more appropriate. In other places we have a `Vec<Span>`\n     // corresponding to their `Vec<Predicate>`, but we don't have that here.\n     // Fixing this would improve the output of test `issue-83765.rs`.\n-    let mut result = infcx\n-        .at(&cause, param_env)\n-        .sup(trait_fty, impl_fty)\n-        .map(|infer_ok| ocx.register_infer_ok_obligations(infer_ok));\n+    let mut result = ocx.sup(&cause, param_env, trait_fty, impl_fty);\n \n     // HACK(RPITIT): #101614. When we are trying to infer the hidden types for\n     // RPITITs, we need to equate the output tys instead of just subtyping. If\n     // we just use `sup` above, we'll end up `&'static str <: _#1t`, which causes\n     // us to infer `_#1t = #'_#2r str`, where `'_#2r` is unconstrained, which gets\n     // fixed up to `ReEmpty`, and which is certainly not what we want.\n     if trait_fty.has_infer_types() {\n-        result = result.and_then(|()| {\n-            infcx\n-                .at(&cause, param_env)\n-                .eq(trait_sig.output(), impl_sig.output())\n-                .map(|infer_ok| ocx.register_infer_ok_obligations(infer_ok))\n-        });\n+        result =\n+            result.and_then(|()| ocx.eq(&cause, param_env, trait_sig.output(), impl_sig.output()));\n     }\n \n     if let Err(terr) = result {\n@@ -1389,10 +1382,7 @@ pub(crate) fn raw_compare_const_impl<'tcx>(\n \n     debug!(\"compare_const_impl: trait_ty={:?}\", trait_ty);\n \n-    let err = infcx\n-        .at(&cause, param_env)\n-        .sup(trait_ty, impl_ty)\n-        .map(|ok| ocx.register_infer_ok_obligations(ok));\n+    let err = ocx.sup(&cause, param_env, trait_ty, impl_ty);\n \n     if let Err(terr) = err {\n         debug!(\n@@ -1665,13 +1655,10 @@ pub fn check_type_bounds<'tcx>(\n         GenericParamDefKind::Const { .. } => {\n             let bound_var = ty::BoundVariableKind::Const;\n             bound_vars.push(bound_var);\n-            tcx.mk_const(ty::ConstS {\n-                ty: tcx.type_of(param.def_id),\n-                kind: ty::ConstKind::Bound(\n-                    ty::INNERMOST,\n-                    ty::BoundVar::from_usize(bound_vars.len() - 1),\n-                ),\n-            })\n+            tcx.mk_const(\n+                ty::ConstKind::Bound(ty::INNERMOST, ty::BoundVar::from_usize(bound_vars.len() - 1)),\n+                tcx.type_of(param.def_id),\n+            )\n             .into()\n         }\n     });"}, {"sha": "0117bdd0ba81cb7966043768f14a54de7a1dbc38", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 30, "deletions": 83, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -218,19 +218,16 @@ fn check_item<'tcx>(tcx: TyCtxt<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         hir::ItemKind::Const(ty, ..) => {\n             check_item_type(tcx, def_id, ty.span, false);\n         }\n-        hir::ItemKind::Struct(ref struct_def, ref ast_generics) => {\n-            check_type_defn(tcx, item, false, |wfcx| vec![wfcx.non_enum_variant(struct_def)]);\n-\n+        hir::ItemKind::Struct(_, ref ast_generics) => {\n+            check_type_defn(tcx, item, false);\n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n-        hir::ItemKind::Union(ref struct_def, ref ast_generics) => {\n-            check_type_defn(tcx, item, true, |wfcx| vec![wfcx.non_enum_variant(struct_def)]);\n-\n+        hir::ItemKind::Union(_, ref ast_generics) => {\n+            check_type_defn(tcx, item, true);\n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n-        hir::ItemKind::Enum(ref enum_def, ref ast_generics) => {\n-            check_type_defn(tcx, item, true, |wfcx| wfcx.enum_variants(enum_def));\n-\n+        hir::ItemKind::Enum(_, ref ast_generics) => {\n+            check_type_defn(tcx, item, true);\n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n         hir::ItemKind::Trait(..) => {\n@@ -1037,35 +1034,33 @@ fn item_adt_kind(kind: &ItemKind<'_>) -> Option<AdtKind> {\n }\n \n /// In a type definition, we check that to ensure that the types of the fields are well-formed.\n-fn check_type_defn<'tcx, F>(\n-    tcx: TyCtxt<'tcx>,\n-    item: &hir::Item<'tcx>,\n-    all_sized: bool,\n-    mut lookup_fields: F,\n-) where\n-    F: FnMut(&WfCheckingCtxt<'_, 'tcx>) -> Vec<AdtVariant<'tcx>>,\n-{\n+fn check_type_defn<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'tcx>, all_sized: bool) {\n     let _ = tcx.representability(item.owner_id.def_id);\n+    let adt_def = tcx.adt_def(item.owner_id);\n \n     enter_wf_checking_ctxt(tcx, item.span, item.owner_id.def_id, |wfcx| {\n-        let variants = lookup_fields(wfcx);\n-        let packed = tcx.adt_def(item.owner_id).repr().packed();\n+        let variants = adt_def.variants();\n+        let packed = adt_def.repr().packed();\n \n-        for variant in &variants {\n+        for variant in variants.iter() {\n             // All field types must be well-formed.\n             for field in &variant.fields {\n+                let field_id = field.did.expect_local();\n+                let hir::Node::Field(hir::FieldDef { ty: hir_ty, .. }) = tcx.hir().get_by_def_id(field_id)\n+                else { bug!() };\n+                let ty = wfcx.normalize(hir_ty.span, None, tcx.type_of(field.did));\n                 wfcx.register_wf_obligation(\n-                    field.span,\n-                    Some(WellFormedLoc::Ty(field.def_id)),\n-                    field.ty.into(),\n+                    hir_ty.span,\n+                    Some(WellFormedLoc::Ty(field_id)),\n+                    ty.into(),\n                 )\n             }\n \n             // For DST, or when drop needs to copy things around, all\n             // intermediate types must be sized.\n             let needs_drop_copy = || {\n                 packed && {\n-                    let ty = variant.fields.last().unwrap().ty;\n+                    let ty = tcx.type_of(variant.fields.last().unwrap().did);\n                     let ty = tcx.erase_regions(ty);\n                     if ty.needs_infer() {\n                         tcx.sess\n@@ -1084,27 +1079,31 @@ fn check_type_defn<'tcx, F>(\n                 variant.fields[..variant.fields.len() - unsized_len].iter().enumerate()\n             {\n                 let last = idx == variant.fields.len() - 1;\n+                let field_id = field.did.expect_local();\n+                let hir::Node::Field(hir::FieldDef { ty: hir_ty, .. }) = tcx.hir().get_by_def_id(field_id)\n+                else { bug!() };\n+                let ty = wfcx.normalize(hir_ty.span, None, tcx.type_of(field.did));\n                 wfcx.register_bound(\n                     traits::ObligationCause::new(\n-                        field.span,\n+                        hir_ty.span,\n                         wfcx.body_id,\n                         traits::FieldSized {\n                             adt_kind: match item_adt_kind(&item.kind) {\n                                 Some(i) => i,\n                                 None => bug!(),\n                             },\n-                            span: field.span,\n+                            span: hir_ty.span,\n                             last,\n                         },\n                     ),\n                     wfcx.param_env,\n-                    field.ty,\n+                    ty,\n                     tcx.require_lang_item(LangItem::Sized, None),\n                 );\n             }\n \n             // Explicit `enum` discriminant values must const-evaluate successfully.\n-            if let Some(discr_def_id) = variant.explicit_discr {\n+            if let ty::VariantDiscr::Explicit(discr_def_id) = variant.discr {\n                 let cause = traits::ObligationCause::new(\n                     tcx.def_span(discr_def_id),\n                     wfcx.body_id,\n@@ -1114,7 +1113,7 @@ fn check_type_defn<'tcx, F>(\n                     cause,\n                     wfcx.param_env,\n                     ty::Binder::dummy(ty::PredicateKind::ConstEvaluatable(\n-                        ty::Const::from_anon_const(tcx, discr_def_id),\n+                        ty::Const::from_anon_const(tcx, discr_def_id.expect_local()),\n                     ))\n                     .to_predicate(tcx),\n                 ));\n@@ -1675,7 +1674,7 @@ fn receiver_is_valid<'tcx>(\n \n     // `self: Self` is always valid.\n     if can_eq_self(receiver_ty) {\n-        if let Err(err) = wfcx.equate_types(&cause, wfcx.param_env, self_ty, receiver_ty) {\n+        if let Err(err) = wfcx.eq(&cause, wfcx.param_env, self_ty, receiver_ty) {\n             infcx.err_ctxt().report_mismatched_types(&cause, self_ty, receiver_ty, err).emit();\n         }\n         return true;\n@@ -1705,9 +1704,7 @@ fn receiver_is_valid<'tcx>(\n             if can_eq_self(potential_self_ty) {\n                 wfcx.register_obligations(autoderef.into_obligations());\n \n-                if let Err(err) =\n-                    wfcx.equate_types(&cause, wfcx.param_env, self_ty, potential_self_ty)\n-                {\n+                if let Err(err) = wfcx.eq(&cause, wfcx.param_env, self_ty, potential_self_ty) {\n                     infcx\n                         .err_ctxt()\n                         .report_mismatched_types(&cause, self_ty, potential_self_ty, err)\n@@ -1925,56 +1922,6 @@ fn check_mod_type_wf(tcx: TyCtxt<'_>, module: LocalDefId) {\n     items.par_foreign_items(|item| tcx.ensure().check_well_formed(item.owner_id));\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// ADT\n-\n-// FIXME(eddyb) replace this with getting fields/discriminants through `ty::AdtDef`.\n-struct AdtVariant<'tcx> {\n-    /// Types of fields in the variant, that must be well-formed.\n-    fields: Vec<AdtField<'tcx>>,\n-\n-    /// Explicit discriminant of this variant (e.g. `A = 123`),\n-    /// that must evaluate to a constant value.\n-    explicit_discr: Option<LocalDefId>,\n-}\n-\n-struct AdtField<'tcx> {\n-    ty: Ty<'tcx>,\n-    def_id: LocalDefId,\n-    span: Span,\n-}\n-\n-impl<'a, 'tcx> WfCheckingCtxt<'a, 'tcx> {\n-    // FIXME(eddyb) replace this with getting fields through `ty::AdtDef`.\n-    fn non_enum_variant(&self, struct_def: &hir::VariantData<'_>) -> AdtVariant<'tcx> {\n-        let fields = struct_def\n-            .fields()\n-            .iter()\n-            .map(|field| {\n-                let def_id = self.tcx().hir().local_def_id(field.hir_id);\n-                let field_ty = self.tcx().type_of(def_id);\n-                let field_ty = self.normalize(field.ty.span, None, field_ty);\n-                debug!(\"non_enum_variant: type of field {:?} is {:?}\", field, field_ty);\n-                AdtField { ty: field_ty, span: field.ty.span, def_id }\n-            })\n-            .collect();\n-        AdtVariant { fields, explicit_discr: None }\n-    }\n-\n-    fn enum_variants(&self, enum_def: &hir::EnumDef<'_>) -> Vec<AdtVariant<'tcx>> {\n-        enum_def\n-            .variants\n-            .iter()\n-            .map(|variant| AdtVariant {\n-                fields: self.non_enum_variant(&variant.data).fields,\n-                explicit_discr: variant\n-                    .disr_expr\n-                    .map(|explicit_discr| self.tcx().hir().local_def_id(explicit_discr.hir_id)),\n-            })\n-            .collect()\n-    }\n-}\n-\n fn error_392(\n     tcx: TyCtxt<'_>,\n     span: Span,"}, {"sha": "71c932d747bca7de4f888e463f175e353c761f1d", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -23,9 +23,7 @@ pub(crate) fn orphan_check_impl(\n     impl_def_id: LocalDefId,\n ) -> Result<(), ErrorGuaranteed> {\n     let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n-    if let Some(err) = trait_ref.error_reported() {\n-        return Err(err);\n-    }\n+    trait_ref.error_reported()?;\n \n     let ret = do_orphan_check_impl(tcx, trait_ref, impl_def_id);\n     if tcx.trait_is_auto(trait_ref.def_id) {"}, {"sha": "25faacadf3d0c18a8ca572277481c4106561dd40", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -27,8 +27,8 @@ use rustc_hir as hir;\n use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::{DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::weak_lang_items;\n-use rustc_hir::{GenericParamKind, Node};\n+use rustc_hir::weak_lang_items::WEAK_LANG_ITEMS;\n+use rustc_hir::{lang_items, GenericParamKind, LangItem, Node};\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::mir::mono::Linkage;\n@@ -379,8 +379,8 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n         self.tcx\n     }\n \n-    fn item_def_id(&self) -> Option<DefId> {\n-        Some(self.item_def_id)\n+    fn item_def_id(&self) -> DefId {\n+        self.item_def_id\n     }\n \n     fn get_type_parameter_bounds(\n@@ -604,11 +604,11 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n                 }\n             }\n         }\n-        hir::ItemKind::Enum(ref enum_definition, _) => {\n+        hir::ItemKind::Enum(..) => {\n             tcx.ensure().generics_of(def_id);\n             tcx.ensure().type_of(def_id);\n             tcx.ensure().predicates_of(def_id);\n-            convert_enum_variant_types(tcx, def_id.to_def_id(), enum_definition.variants);\n+            convert_enum_variant_types(tcx, def_id.to_def_id());\n         }\n         hir::ItemKind::Impl { .. } => {\n             tcx.ensure().generics_of(def_id);\n@@ -640,7 +640,8 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n             }\n \n             if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n-                convert_variant_ctor(tcx, ctor_hir_id);\n+                let ctor_def_id = tcx.hir().local_def_id(ctor_hir_id);\n+                convert_variant_ctor(tcx, ctor_def_id);\n             }\n         }\n \n@@ -750,55 +751,51 @@ fn convert_impl_item(tcx: TyCtxt<'_>, impl_item_id: hir::ImplItemId) {\n     }\n }\n \n-fn convert_variant_ctor(tcx: TyCtxt<'_>, ctor_id: hir::HirId) {\n-    let def_id = tcx.hir().local_def_id(ctor_id);\n+fn convert_variant_ctor(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     tcx.ensure().generics_of(def_id);\n     tcx.ensure().type_of(def_id);\n     tcx.ensure().predicates_of(def_id);\n }\n \n-fn convert_enum_variant_types(tcx: TyCtxt<'_>, def_id: DefId, variants: &[hir::Variant<'_>]) {\n+fn convert_enum_variant_types(tcx: TyCtxt<'_>, def_id: DefId) {\n     let def = tcx.adt_def(def_id);\n     let repr_type = def.repr().discr_type();\n     let initial = repr_type.initial_discriminant(tcx);\n     let mut prev_discr = None::<Discr<'_>>;\n \n     // fill the discriminant values and field types\n-    for variant in variants {\n+    for variant in def.variants() {\n         let wrapped_discr = prev_discr.map_or(initial, |d| d.wrap_incr(tcx));\n         prev_discr = Some(\n-            if let Some(ref e) = variant.disr_expr {\n-                let expr_did = tcx.hir().local_def_id(e.hir_id);\n-                def.eval_explicit_discr(tcx, expr_did.to_def_id())\n+            if let ty::VariantDiscr::Explicit(const_def_id) = variant.discr {\n+                def.eval_explicit_discr(tcx, const_def_id)\n             } else if let Some(discr) = repr_type.disr_incr(tcx, prev_discr) {\n                 Some(discr)\n             } else {\n-                struct_span_err!(tcx.sess, variant.span, E0370, \"enum discriminant overflowed\")\n-                    .span_label(\n-                        variant.span,\n-                        format!(\"overflowed on value after {}\", prev_discr.unwrap()),\n-                    )\n+                let span = tcx.def_span(variant.def_id);\n+                struct_span_err!(tcx.sess, span, E0370, \"enum discriminant overflowed\")\n+                    .span_label(span, format!(\"overflowed on value after {}\", prev_discr.unwrap()))\n                     .note(&format!(\n                         \"explicitly set `{} = {}` if that is desired outcome\",\n-                        variant.ident, wrapped_discr\n+                        tcx.item_name(variant.def_id),\n+                        wrapped_discr\n                     ))\n                     .emit();\n                 None\n             }\n             .unwrap_or(wrapped_discr),\n         );\n \n-        for f in variant.data.fields() {\n-            let def_id = tcx.hir().local_def_id(f.hir_id);\n-            tcx.ensure().generics_of(def_id);\n-            tcx.ensure().type_of(def_id);\n-            tcx.ensure().predicates_of(def_id);\n+        for f in &variant.fields {\n+            tcx.ensure().generics_of(f.did);\n+            tcx.ensure().type_of(f.did);\n+            tcx.ensure().predicates_of(f.did);\n         }\n \n         // Convert the ctor, if any. This also registers the variant as\n         // an item.\n-        if let Some(ctor_hir_id) = variant.data.ctor_hir_id() {\n-            convert_variant_ctor(tcx, ctor_hir_id);\n+        if let Some(ctor_def_id) = variant.ctor_def_id {\n+            convert_variant_ctor(tcx, ctor_def_id.expect_local());\n         }\n     }\n }\n@@ -2104,12 +2101,15 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n     // strippable by the linker.\n     //\n     // Additionally weak lang items have predetermined symbol names.\n-    if tcx.is_weak_lang_item(did.to_def_id()) {\n+    if WEAK_LANG_ITEMS.iter().any(|&l| tcx.lang_items().get(l) == Some(did.to_def_id())) {\n         codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n     }\n-    if let Some(name) = weak_lang_items::link_name(attrs) {\n-        codegen_fn_attrs.export_name = Some(name);\n-        codegen_fn_attrs.link_name = Some(name);\n+    if let Some((name, _)) = lang_items::extract(attrs)\n+        && let Some(lang_item) = LangItem::from_name(name)\n+        && let Some(link_name) = lang_item.link_name()\n+    {\n+        codegen_fn_attrs.export_name = Some(link_name);\n+        codegen_fn_attrs.link_name = Some(link_name);\n     }\n     check_link_name_xor_ordinal(tcx, &codegen_fn_attrs, link_ordinal_span);\n "}, {"sha": "3d07f3fbc674dbb3d32ba541a95cf0c5c0309698", "filename": "compiler/rustc_hir_analysis/src/collect/lifetimes.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -1377,11 +1377,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             } else if let Some(body_id) = outermost_body {\n                 let fn_id = self.tcx.hir().body_owner(body_id);\n                 match self.tcx.hir().get(fn_id) {\n-                    Node::Item(&hir::Item { kind: hir::ItemKind::Fn(..), .. })\n-                    | Node::TraitItem(&hir::TraitItem {\n+                    Node::Item(hir::Item { kind: hir::ItemKind::Fn(..), .. })\n+                    | Node::TraitItem(hir::TraitItem {\n                         kind: hir::TraitItemKind::Fn(..), ..\n                     })\n-                    | Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }) => {\n+                    | Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. })\n+                    | Node::Expr(hir::Expr { kind: hir::ExprKind::Closure(..), .. }) => {\n                         let scope = self.tcx.hir().local_def_id(fn_id);\n                         def = Region::Free(scope.to_def_id(), def.id().unwrap());\n                     }"}, {"sha": "5d1ca1cbd2389046881a349839011366507c796d", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -427,6 +427,8 @@ pub(super) fn explicit_predicates_of<'tcx>(\n     } else {\n         if matches!(def_kind, DefKind::AnonConst) && tcx.lazy_normalization() {\n             let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n+            let parent_def_id = tcx.hir().get_parent_item(hir_id);\n+\n             if tcx.hir().opt_const_param_default_param_hir_id(hir_id).is_some() {\n                 // In `generics_of` we set the generics' parent to be our parent's parent which means that\n                 // we lose out on the predicates of our actual parent if we dont return those predicates here.\n@@ -439,8 +441,33 @@ pub(super) fn explicit_predicates_of<'tcx>(\n                 //        parent of generics returned by `generics_of`\n                 //\n                 // In the above code we want the anon const to have predicates in its param env for `T: Trait`\n-                let item_def_id = tcx.hir().get_parent_item(hir_id);\n-                // In the above code example we would be calling `explicit_predicates_of(Foo)` here\n+                // and we would be calling `explicit_predicates_of(Foo)` here\n+                return tcx.explicit_predicates_of(parent_def_id);\n+            }\n+\n+            let parent_def_kind = tcx.def_kind(parent_def_id);\n+            if matches!(parent_def_kind, DefKind::OpaqueTy) {\n+                // In `instantiate_identity` we inherit the predicates of our parent.\n+                // However, opaque types do not have a parent (see `gather_explicit_predicates_of`), which means\n+                // that we lose out on the predicates of our actual parent if we dont return those predicates here.\n+                //\n+                //\n+                // fn foo<T: Trait>() -> impl Iterator<Output = Another<{ <T as Trait>::ASSOC }> > { todo!() }\n+                //                                                        ^^^^^^^^^^^^^^^^^^^ the def id we are calling\n+                //                                                                            explicit_predicates_of on\n+                //\n+                // In the above code we want the anon const to have predicates in its param env for `T: Trait`.\n+                // However, the anon const cannot inherit predicates from its parent since it's opaque.\n+                //\n+                // To fix this, we call `explicit_predicates_of` directly on `foo`, the parent's parent.\n+\n+                // In the above example this is `foo::{opaque#0}` or `impl Iterator`\n+                let parent_hir_id = tcx.hir().local_def_id_to_hir_id(parent_def_id.def_id);\n+\n+                // In the above example this is the function `foo`\n+                let item_def_id = tcx.hir().get_parent_item(parent_hir_id);\n+\n+                // In the above code example we would be calling `explicit_predicates_of(foo)` here\n                 return tcx.explicit_predicates_of(item_def_id);\n             }\n         }"}, {"sha": "afbb27155a2f59f7deb2c49acf44acc590e7c376", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -120,7 +120,7 @@ pub struct TypeofReservedKeywordUsed<'tcx> {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[suggestion_verbose(code = \"{ty}\")]\n+    #[suggestion(style = \"verbose\", code = \"{ty}\")]\n     pub opt_sugg: Option<(Span, Applicability)>,\n }\n \n@@ -156,6 +156,7 @@ pub struct MissingTypeParams {\n \n // Manual implementation of `IntoDiagnostic` to be able to call `span_to_snippet`.\n impl<'a> IntoDiagnostic<'a> for MissingTypeParams {\n+    #[track_caller]\n     fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n         let mut err = handler.struct_span_err_with_code(\n             self.span,\n@@ -238,7 +239,11 @@ pub struct UnusedExternCrate {\n #[derive(LintDiagnostic)]\n #[diag(hir_analysis_extern_crate_not_idiomatic)]\n pub struct ExternCrateNotIdiomatic {\n-    #[suggestion_short(applicability = \"machine-applicable\", code = \"{suggestion_code}\")]\n+    #[suggestion(\n+        style = \"short\",\n+        applicability = \"machine-applicable\",\n+        code = \"{suggestion_code}\"\n+    )]\n     pub span: Span,\n     pub msg_code: String,\n     pub suggestion_code: String,"}, {"sha": "bd1a461b93522235cb2b6423a48da8f0f11c4dfa", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -106,7 +106,7 @@ use rustc_middle::middle;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::util;\n-use rustc_session::config::EntryFnType;\n+use rustc_session::{config::EntryFnType, parse::feature_err};\n use rustc_span::{symbol::sym, Span, DUMMY_SP};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n@@ -118,20 +118,40 @@ use astconv::AstConv;\n use bounds::Bounds;\n \n fn require_c_abi_if_c_variadic(tcx: TyCtxt<'_>, decl: &hir::FnDecl<'_>, abi: Abi, span: Span) {\n-    match (decl.c_variadic, abi) {\n-        // The function has the correct calling convention, or isn't a \"C-variadic\" function.\n-        (false, _) | (true, Abi::C { .. }) | (true, Abi::Cdecl { .. }) => {}\n-        // The function is a \"C-variadic\" function with an incorrect calling convention.\n-        (true, _) => {\n-            let mut err = struct_span_err!(\n-                tcx.sess,\n+    const ERROR_HEAD: &str = \"C-variadic function must have a compatible calling convention\";\n+    const CONVENTIONS_UNSTABLE: &str = \"`C`, `cdecl`, `win64`, `sysv64` or `efiapi`\";\n+    const CONVENTIONS_STABLE: &str = \"`C` or `cdecl`\";\n+    const UNSTABLE_EXPLAIN: &str =\n+        \"using calling conventions other than `C` or `cdecl` for varargs functions is unstable\";\n+\n+    if !decl.c_variadic || matches!(abi, Abi::C { .. } | Abi::Cdecl { .. }) {\n+        return;\n+    }\n+\n+    let extended_abi_support = tcx.features().extended_varargs_abi_support;\n+    let conventions = match (extended_abi_support, abi.supports_varargs()) {\n+        // User enabled additional ABI support for varargs and function ABI matches those ones.\n+        (true, true) => return,\n+\n+        // Using this ABI would be ok, if the feature for additional ABI support was enabled.\n+        // Return CONVENTIONS_STABLE, because we want the other error to look the same.\n+        (false, true) => {\n+            feature_err(\n+                &tcx.sess.parse_sess,\n+                sym::extended_varargs_abi_support,\n                 span,\n-                E0045,\n-                \"C-variadic function must have C or cdecl calling convention\"\n-            );\n-            err.span_label(span, \"C-variadics require C or cdecl calling convention\").emit();\n+                UNSTABLE_EXPLAIN,\n+            )\n+            .emit();\n+            CONVENTIONS_STABLE\n         }\n-    }\n+\n+        (false, false) => CONVENTIONS_STABLE,\n+        (true, false) => CONVENTIONS_UNSTABLE,\n+    };\n+\n+    let mut err = struct_span_err!(tcx.sess, span, E0045, \"{}, like {}\", ERROR_HEAD, conventions);\n+    err.span_label(span, ERROR_HEAD).emit();\n }\n \n fn require_same_types<'tcx>("}, {"sha": "8d39fa81165ea6bdec7d832b39d3313f31f09b46", "filename": "compiler/rustc_hir_typeck/src/_match.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -491,11 +491,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     ..\n                 } = self.type_var_origin(expected)? else { return None; };\n \n-                let sig = *self\n-                    .typeck_results\n-                    .borrow()\n-                    .liberated_fn_sigs()\n-                    .get(hir::HirId::make_owner(self.body_id.owner.def_id))?;\n+                let sig = self.body_fn_sig()?;\n \n                 let substs = sig.output().walk().find_map(|arg| {\n                     if let ty::GenericArgKind::Type(ty) = arg.unpack()"}, {"sha": "7d3129f7ea730567e0bbaefbdc263ca0c27c5f5f", "filename": "compiler/rustc_hir_typeck/src/cast.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -94,10 +94,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         debug!(\"pointer_kind({:?}, {:?})\", t, span);\n \n         let t = self.resolve_vars_if_possible(t);\n-\n-        if let Some(reported) = t.error_reported() {\n-            return Err(reported);\n-        }\n+        t.error_reported()?;\n \n         if self.type_is_sized_modulo_regions(self.param_env, t, span) {\n             return Ok(Some(PointerKind::Thin));\n@@ -222,8 +219,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         // inference is more completely known.\n         match cast_ty.kind() {\n             ty::Dynamic(_, _, ty::Dyn) | ty::Slice(..) => {\n-                let reported = check.report_cast_to_unsized_type(fcx);\n-                Err(reported)\n+                Err(check.report_cast_to_unsized_type(fcx))\n             }\n             _ => Ok(check),\n         }\n@@ -614,10 +610,11 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n     }\n \n     fn report_cast_to_unsized_type(&self, fcx: &FnCtxt<'a, 'tcx>) -> ErrorGuaranteed {\n-        if let Some(reported) =\n-            self.cast_ty.error_reported().or_else(|| self.expr_ty.error_reported())\n-        {\n-            return reported;\n+        if let Err(err) = self.cast_ty.error_reported() {\n+            return err;\n+        }\n+        if let Err(err) = self.expr_ty.error_reported() {\n+            return err;\n         }\n \n         let tstr = fcx.ty_to_string(self.cast_ty);"}, {"sha": "80147d9009113f329cefc5ca4ada2d660210adad", "filename": "compiler/rustc_hir_typeck/src/check.rs", "status": "modified", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -31,13 +31,11 @@ pub(super) fn check_fn<'a, 'tcx>(\n     fn_id: hir::HirId,\n     body: &'tcx hir::Body<'tcx>,\n     can_be_generator: Option<hir::Movability>,\n-    return_type_pre_known: bool,\n ) -> (FnCtxt<'a, 'tcx>, Option<GeneratorTypes<'tcx>>) {\n     // Create the function context. This is either derived from scratch or,\n     // in the case of closures, based on the outer context.\n     let mut fcx = FnCtxt::new(inherited, param_env, body.value.hir_id);\n     fcx.ps.set(UnsafetyState::function(fn_sig.unsafety, fn_id));\n-    fcx.return_type_pre_known = return_type_pre_known;\n \n     let tcx = fcx.tcx;\n     let hir = tcx.hir();\n@@ -51,9 +49,6 @@ pub(super) fn check_fn<'a, 'tcx>(\n             decl.output.span(),\n             param_env,\n         ));\n-    // If we replaced declared_ret_ty with infer vars, then we must be inferring\n-    // an opaque type, so set a flag so we can improve diagnostics.\n-    fcx.return_type_has_opaque = ret_ty != declared_ret_ty;\n \n     fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(ret_ty)));\n \n@@ -211,13 +206,6 @@ pub(super) fn check_fn<'a, 'tcx>(\n         check_panic_info_fn(tcx, panic_impl_did.expect_local(), fn_sig, decl, declared_ret_ty);\n     }\n \n-    // Check that a function marked as `#[alloc_error_handler]` has signature `fn(Layout) -> !`\n-    if let Some(alloc_error_handler_did) = tcx.lang_items().oom()\n-        && alloc_error_handler_did == hir.local_def_id(fn_id).to_def_id()\n-    {\n-        check_alloc_error_fn(tcx, alloc_error_handler_did.expect_local(), fn_sig, decl, declared_ret_ty);\n-    }\n-\n     (fcx, gen_ty)\n }\n \n@@ -273,52 +261,3 @@ fn check_panic_info_fn(\n         tcx.sess.span_err(span, \"should have no const parameters\");\n     }\n }\n-\n-fn check_alloc_error_fn(\n-    tcx: TyCtxt<'_>,\n-    fn_id: LocalDefId,\n-    fn_sig: ty::FnSig<'_>,\n-    decl: &hir::FnDecl<'_>,\n-    declared_ret_ty: Ty<'_>,\n-) {\n-    let Some(alloc_layout_did) = tcx.lang_items().alloc_layout() else {\n-        tcx.sess.err(\"language item required, but not found: `alloc_layout`\");\n-        return;\n-    };\n-\n-    if *declared_ret_ty.kind() != ty::Never {\n-        tcx.sess.span_err(decl.output.span(), \"return type should be `!`\");\n-    }\n-\n-    let inputs = fn_sig.inputs();\n-    if inputs.len() != 1 {\n-        tcx.sess.span_err(tcx.def_span(fn_id), \"function should have one argument\");\n-        return;\n-    }\n-\n-    let arg_is_alloc_layout = match inputs[0].kind() {\n-        ty::Adt(ref adt, _) => adt.did() == alloc_layout_did,\n-        _ => false,\n-    };\n-\n-    if !arg_is_alloc_layout {\n-        tcx.sess.span_err(decl.inputs[0].span, \"argument should be `Layout`\");\n-    }\n-\n-    let DefKind::Fn = tcx.def_kind(fn_id) else {\n-        let span = tcx.def_span(fn_id);\n-        tcx.sess.span_err(span, \"`#[alloc_error_handler]` should be a function\");\n-        return;\n-    };\n-\n-    let generic_counts = tcx.generics_of(fn_id).own_counts();\n-    if generic_counts.types != 0 {\n-        let span = tcx.def_span(fn_id);\n-        tcx.sess.span_err(span, \"`#[alloc_error_handler]` function should have no type parameters\");\n-    }\n-    if generic_counts.consts != 0 {\n-        let span = tcx.def_span(fn_id);\n-        tcx.sess\n-            .span_err(span, \"`#[alloc_error_handler]` function should have no const parameters\");\n-    }\n-}"}, {"sha": "09df50c76b73828500f0466c55e54bb2154adec9", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 45, "deletions": 30, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -15,6 +15,7 @@ use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::source_map::Span;\n use rustc_target::spec::abi::Abi;\n+use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::error_reporting::ArgKind;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use std::cmp;\n@@ -82,8 +83,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         debug!(?bound_sig, ?liberated_sig);\n \n-        let return_type_pre_known = !liberated_sig.output().is_ty_infer();\n-\n         let generator_types = check_fn(\n             self,\n             self.param_env.without_const(),\n@@ -92,7 +91,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             expr.hir_id,\n             body,\n             gen,\n-            return_type_pre_known,\n         )\n         .1;\n \n@@ -225,33 +223,50 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expected_vid: ty::TyVid,\n     ) -> (Option<ExpectedSig<'tcx>>, Option<ty::ClosureKind>) {\n-        let expected_sig =\n-            self.obligations_for_self_ty(expected_vid).find_map(|(_, obligation)| {\n-                debug!(?obligation.predicate);\n-\n-                let bound_predicate = obligation.predicate.kind();\n-                if let ty::PredicateKind::Projection(proj_predicate) =\n-                    obligation.predicate.kind().skip_binder()\n-                {\n-                    // Given a Projection predicate, we can potentially infer\n-                    // the complete signature.\n-                    self.deduce_sig_from_projection(\n-                        Some(obligation.cause.span),\n-                        bound_predicate.rebind(proj_predicate),\n-                    )\n-                } else {\n-                    None\n-                }\n-            });\n+        let mut expected_sig = None;\n+        let mut expected_kind = None;\n \n-        // Even if we can't infer the full signature, we may be able to\n-        // infer the kind. This can occur when we elaborate a predicate\n-        // like `F : Fn<A>`. Note that due to subtyping we could encounter\n-        // many viable options, so pick the most restrictive.\n-        let expected_kind = self\n-            .obligations_for_self_ty(expected_vid)\n-            .filter_map(|(tr, _)| self.tcx.fn_trait_kind_from_lang_item(tr.def_id()))\n-            .fold(None, |best, cur| Some(best.map_or(cur, |best| cmp::min(best, cur))));\n+        for obligation in traits::elaborate_obligations(\n+            self.tcx,\n+            // Reverse the obligations here, since `elaborate_*` uses a stack,\n+            // and we want to keep inference generally in the same order of\n+            // the registered obligations.\n+            self.obligations_for_self_ty(expected_vid).rev().collect(),\n+        ) {\n+            debug!(?obligation.predicate);\n+            let bound_predicate = obligation.predicate.kind();\n+\n+            // Given a Projection predicate, we can potentially infer\n+            // the complete signature.\n+            if expected_sig.is_none()\n+                && let ty::PredicateKind::Projection(proj_predicate) = bound_predicate.skip_binder()\n+            {\n+                expected_sig = self.deduce_sig_from_projection(\n+                    Some(obligation.cause.span),\n+                    bound_predicate.rebind(proj_predicate),\n+                );\n+            }\n+\n+            // Even if we can't infer the full signature, we may be able to\n+            // infer the kind. This can occur when we elaborate a predicate\n+            // like `F : Fn<A>`. Note that due to subtyping we could encounter\n+            // many viable options, so pick the most restrictive.\n+            let trait_def_id = match bound_predicate.skip_binder() {\n+                ty::PredicateKind::Projection(data) => {\n+                    Some(data.projection_ty.trait_def_id(self.tcx))\n+                }\n+                ty::PredicateKind::Trait(data) => Some(data.def_id()),\n+                _ => None,\n+            };\n+            if let Some(closure_kind) =\n+                trait_def_id.and_then(|def_id| self.tcx.fn_trait_kind_from_lang_item(def_id))\n+            {\n+                expected_kind = Some(\n+                    expected_kind\n+                        .map_or_else(|| closure_kind, |current| cmp::min(current, closure_kind)),\n+                );\n+            }\n+        }\n \n         (expected_sig, expected_kind)\n     }\n@@ -689,7 +704,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let output_ty = match *ret_ty.kind() {\n             ty::Infer(ty::TyVar(ret_vid)) => {\n-                self.obligations_for_self_ty(ret_vid).find_map(|(_, obligation)| {\n+                self.obligations_for_self_ty(ret_vid).find_map(|obligation| {\n                     get_future_output(obligation.predicate, obligation.cause.span)\n                 })?\n             }"}, {"sha": "e8bf299b0378ea2241f04cd11c3fb29700a925df", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -1782,7 +1782,8 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n             // may occur at the first return expression we see in the closure\n             // (if it conflicts with the declared return type). Skip adding a\n             // note in this case, since it would be incorrect.\n-            && !fcx.return_type_pre_known\n+            && let Some(fn_sig) = fcx.body_fn_sig()\n+            && fn_sig.output().is_ty_var()\n         {\n             err.span_note(\n                 sp,"}, {"sha": "cfb408396da05e4d0e55b42ce4b7a3981559e82d", "filename": "compiler/rustc_hir_typeck/src/errors.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -113,8 +113,9 @@ pub struct MissingParentheseInRange {\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion_verbose(\n+#[multipart_suggestion(\n     hir_analysis_add_missing_parentheses_in_range,\n+    style = \"verbose\",\n     applicability = \"maybe-incorrect\"\n )]\n pub struct AddMissingParenthesesInRange {"}, {"sha": "682dbab56bc15b0c63d91c21c415327fdb369308", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -220,7 +220,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Hide the outer diverging and has_errors flags.\n         let old_diverges = self.diverges.replace(Diverges::Maybe);\n-        let old_has_errors = self.has_errors.replace(false);\n \n         let ty = ensure_sufficient_stack(|| match &expr.kind {\n             hir::ExprKind::Path(\n@@ -259,7 +258,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Combine the diverging and has_error flags.\n         self.diverges.set(self.diverges.get() | old_diverges);\n-        self.has_errors.set(self.has_errors.get() | old_has_errors);\n \n         debug!(\"type of {} is...\", self.tcx.hir().node_to_string(expr.hir_id));\n         debug!(\"... {:?}, expected is {:?}\", ty, expected);\n@@ -840,7 +838,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return_expr_ty,\n         );\n \n-        if self.return_type_has_opaque {\n+        if let Some(fn_sig) = self.body_fn_sig()\n+            && fn_sig.output().has_opaque_types()\n+        {\n             // Point any obligations that were registered due to opaque type\n             // inference at the return expression.\n             self.select_obligations_where_possible(false, |errors| {"}, {"sha": "7563c543d3f19d55adc0e4a417115638ac7a7101", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 50, "deletions": 48, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -21,8 +21,8 @@ use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMut\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{\n-    self, AdtKind, CanonicalUserType, DefIdTree, EarlyBinder, GenericParamDefKind, ToPolyTraitRef,\n-    ToPredicate, Ty, UserType,\n+    self, AdtKind, CanonicalUserType, DefIdTree, EarlyBinder, GenericParamDefKind, ToPredicate, Ty,\n+    UserType,\n };\n use rustc_middle::ty::{GenericArgKind, InternalSubsts, SubstsRef, UserSelfTy, UserSubsts};\n use rustc_session::lint;\n@@ -143,7 +143,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.typeck_results.borrow_mut().node_types_mut().insert(id, ty);\n \n         if ty.references_error() {\n-            self.has_errors.set(true);\n             self.set_tainted_by_errors();\n         }\n     }\n@@ -650,12 +649,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n-    fn self_type_matches_expected_vid(\n-        &self,\n-        trait_ref: ty::PolyTraitRef<'tcx>,\n-        expected_vid: ty::TyVid,\n-    ) -> bool {\n-        let self_ty = self.shallow_resolve(trait_ref.skip_binder().self_ty());\n+    fn self_type_matches_expected_vid(&self, self_ty: Ty<'tcx>, expected_vid: ty::TyVid) -> bool {\n+        let self_ty = self.shallow_resolve(self_ty);\n         debug!(?self_ty);\n \n         match *self_ty.kind() {\n@@ -674,54 +669,61 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(in super::super) fn obligations_for_self_ty<'b>(\n         &'b self,\n         self_ty: ty::TyVid,\n-    ) -> impl Iterator<Item = (ty::PolyTraitRef<'tcx>, traits::PredicateObligation<'tcx>)>\n-    + Captures<'tcx>\n-    + 'b {\n+    ) -> impl DoubleEndedIterator<Item = traits::PredicateObligation<'tcx>> + Captures<'tcx> + 'b\n+    {\n         // FIXME: consider using `sub_root_var` here so we\n         // can see through subtyping.\n         let ty_var_root = self.root_var(self_ty);\n         trace!(\"pending_obligations = {:#?}\", self.fulfillment_cx.borrow().pending_obligations());\n \n-        self.fulfillment_cx\n-            .borrow()\n-            .pending_obligations()\n-            .into_iter()\n-            .filter_map(move |obligation| {\n-                let bound_predicate = obligation.predicate.kind();\n-                match bound_predicate.skip_binder() {\n-                    ty::PredicateKind::Projection(data) => Some((\n-                        bound_predicate.rebind(data).required_poly_trait_ref(self.tcx),\n-                        obligation,\n-                    )),\n-                    ty::PredicateKind::Trait(data) => {\n-                        Some((bound_predicate.rebind(data).to_poly_trait_ref(), obligation))\n-                    }\n-                    ty::PredicateKind::Subtype(..) => None,\n-                    ty::PredicateKind::Coerce(..) => None,\n-                    ty::PredicateKind::RegionOutlives(..) => None,\n-                    ty::PredicateKind::TypeOutlives(..) => None,\n-                    ty::PredicateKind::WellFormed(..) => None,\n-                    ty::PredicateKind::ObjectSafe(..) => None,\n-                    ty::PredicateKind::ConstEvaluatable(..) => None,\n-                    ty::PredicateKind::ConstEquate(..) => None,\n-                    // N.B., this predicate is created by breaking down a\n-                    // `ClosureType: FnFoo()` predicate, where\n-                    // `ClosureType` represents some `Closure`. It can't\n-                    // possibly be referring to the current closure,\n-                    // because we haven't produced the `Closure` for\n-                    // this closure yet; this is exactly why the other\n-                    // code is looking for a self type of an unresolved\n-                    // inference variable.\n-                    ty::PredicateKind::ClosureKind(..) => None,\n-                    ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n+        self.fulfillment_cx.borrow().pending_obligations().into_iter().filter_map(\n+            move |obligation| match &obligation.predicate.kind().skip_binder() {\n+                ty::PredicateKind::Projection(data)\n+                    if self.self_type_matches_expected_vid(\n+                        data.projection_ty.self_ty(),\n+                        ty_var_root,\n+                    ) =>\n+                {\n+                    Some(obligation)\n                 }\n-            })\n-            .filter(move |(tr, _)| self.self_type_matches_expected_vid(*tr, ty_var_root))\n+                ty::PredicateKind::Trait(data)\n+                    if self.self_type_matches_expected_vid(data.self_ty(), ty_var_root) =>\n+                {\n+                    Some(obligation)\n+                }\n+\n+                ty::PredicateKind::Trait(..)\n+                | ty::PredicateKind::Projection(..)\n+                | ty::PredicateKind::Subtype(..)\n+                | ty::PredicateKind::Coerce(..)\n+                | ty::PredicateKind::RegionOutlives(..)\n+                | ty::PredicateKind::TypeOutlives(..)\n+                | ty::PredicateKind::WellFormed(..)\n+                | ty::PredicateKind::ObjectSafe(..)\n+                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::ConstEquate(..)\n+                // N.B., this predicate is created by breaking down a\n+                // `ClosureType: FnFoo()` predicate, where\n+                // `ClosureType` represents some `Closure`. It can't\n+                // possibly be referring to the current closure,\n+                // because we haven't produced the `Closure` for\n+                // this closure yet; this is exactly why the other\n+                // code is looking for a self type of an unresolved\n+                // inference variable.\n+                | ty::PredicateKind::ClosureKind(..)\n+                | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n+            },\n+        )\n     }\n \n     pub(in super::super) fn type_var_is_sized(&self, self_ty: ty::TyVid) -> bool {\n-        self.obligations_for_self_ty(self_ty)\n-            .any(|(tr, _)| Some(tr.def_id()) == self.tcx.lang_items().sized_trait())\n+        let sized_did = self.tcx.lang_items().sized_trait();\n+        self.obligations_for_self_ty(self_ty).any(|obligation| {\n+            match obligation.predicate.kind().skip_binder() {\n+                ty::PredicateKind::Trait(data) => Some(data.def_id()) == sized_did,\n+                _ => false,\n+            }\n+        })\n     }\n \n     pub(in super::super) fn err_args(&self, len: usize) -> Vec<Ty<'tcx>> {"}, {"sha": "e1955d838f253ebb2c524d5bf9c9ab88761a2037", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -1334,7 +1334,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Hide the outer diverging and `has_errors` flags.\n         let old_diverges = self.diverges.replace(Diverges::Maybe);\n-        let old_has_errors = self.has_errors.replace(false);\n \n         match stmt.kind {\n             hir::StmtKind::Local(l) => {\n@@ -1364,7 +1363,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Combine the diverging and `has_error` flags.\n         self.diverges.set(self.diverges.get() | old_diverges);\n-        self.has_errors.set(self.has_errors.get() | old_has_errors);\n     }\n \n     pub fn check_block_no_value(&self, blk: &'tcx hir::Block<'tcx>) {\n@@ -1544,11 +1542,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.diverges.set(prev_diverges);\n         }\n \n-        let mut ty = ctxt.coerce.unwrap().complete(self);\n-\n-        if self.has_errors.get() || ty.references_error() {\n-            ty = self.tcx.ty_error()\n-        }\n+        let ty = ctxt.coerce.unwrap().complete(self);\n \n         self.write_ty(blk.hir_id, ty);\n "}, {"sha": "72388baa261eae30def6f8dc8d449343b814c6ad", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -112,21 +112,9 @@ pub struct FnCtxt<'a, 'tcx> {\n     /// the diverges flag is set to something other than `Maybe`.\n     pub(super) diverges: Cell<Diverges>,\n \n-    /// Whether any child nodes have any type errors.\n-    pub(super) has_errors: Cell<bool>,\n-\n     pub(super) enclosing_breakables: RefCell<EnclosingBreakables<'tcx>>,\n \n     pub(super) inh: &'a Inherited<'tcx>,\n-\n-    /// True if the function or closure's return type is known before\n-    /// entering the function/closure, i.e. if the return type is\n-    /// either given explicitly or inferred from, say, an `Fn*` trait\n-    /// bound. Used for diagnostic purposes only.\n-    pub(super) return_type_pre_known: bool,\n-\n-    /// True if the return type has an Opaque type\n-    pub(super) return_type_has_opaque: bool,\n }\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -145,14 +133,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             resume_yield_tys: None,\n             ps: Cell::new(UnsafetyState::function(hir::Unsafety::Normal, hir::CRATE_HIR_ID)),\n             diverges: Cell::new(Diverges::Maybe),\n-            has_errors: Cell::new(false),\n             enclosing_breakables: RefCell::new(EnclosingBreakables {\n                 stack: Vec::new(),\n                 by_id: Default::default(),\n             }),\n             inh,\n-            return_type_pre_known: true,\n-            return_type_has_opaque: false,\n         }\n     }\n \n@@ -194,8 +179,8 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         self.tcx\n     }\n \n-    fn item_def_id(&self) -> Option<DefId> {\n-        None\n+    fn item_def_id(&self) -> DefId {\n+        self.body_id.owner.to_def_id()\n     }\n \n     fn get_type_parameter_bounds("}, {"sha": "e3b3fb499b16ab888026d0f72ba480bc5003e7f4", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -22,6 +22,14 @@ use rustc_trait_selection::traits::error_reporting::DefIdOrName;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    pub(crate) fn body_fn_sig(&self) -> Option<ty::FnSig<'tcx>> {\n+        self.typeck_results\n+            .borrow()\n+            .liberated_fn_sigs()\n+            .get(self.tcx.hir().get_parent_node(self.body_id))\n+            .copied()\n+    }\n+\n     pub(in super::super) fn suggest_semicolon_at_end(&self, span: Span, err: &mut Diagnostic) {\n         err.span_suggestion_short(\n             span.shrink_to_hi(),"}, {"sha": "d1762598a5206760b70093fe16ab53d181d83039", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -250,7 +250,7 @@ fn typeck_with_fallback<'tcx>(\n                 param_env,\n                 fn_sig,\n             );\n-            check_fn(&inh, param_env, fn_sig, decl, id, body, None, true).0\n+            check_fn(&inh, param_env, fn_sig, decl, id, body, None).0\n         } else {\n             let fcx = FnCtxt::new(&inh, param_env, body.value.hir_id);\n             let expected_type = body_ty"}, {"sha": "2c7b3bbf31c201531459586effe51e2cfab70725", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -55,8 +55,7 @@ pub enum MethodError<'tcx> {\n     // not-in-scope traits which may work.\n     PrivateMatch(DefKind, DefId, Vec<DefId>),\n \n-    // Found a `Self: Sized` bound where `Self` is a trait object, also the caller may have\n-    // forgotten to import a trait.\n+    // Found a `Self: Sized` bound where `Self` is a trait object.\n     IllegalSizedBound(Vec<DefId>, bool, Span),\n \n     // Found a match, but the return type is wrong"}, {"sha": "e88701685bc6d47a5451a25e7a9d7733d4506988", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -1019,7 +1019,6 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n         let out_of_scope_traits = match self.pick_core() {\n             Some(Ok(p)) => vec![p.item.container_id(self.tcx)],\n-            //Some(Ok(p)) => p.iter().map(|p| p.item.container().id()).collect(),\n             Some(Err(MethodError::Ambiguity(v))) => v\n                 .into_iter()\n                 .map(|source| match source {"}, {"sha": "04ecd2757b427d3aa9e9cc97a2301fd5d6c5ebc7", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 39, "deletions": 97, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -248,7 +248,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         match error {\n             MethodError::NoMatch(NoMatchData {\n-                static_candidates: mut static_sources,\n+                mut static_candidates,\n                 unsatisfied_predicates,\n                 out_of_scope_traits,\n                 lev_candidate,\n@@ -288,9 +288,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if generics.len() > 0 {\n                         let mut autoderef = self.autoderef(span, actual);\n                         let candidate_found = autoderef.any(|(ty, _)| {\n-                            if let ty::Adt(adt_deref, _) = ty.kind() {\n+                            if let ty::Adt(adt_def, _) = ty.kind() {\n                                 self.tcx\n-                                    .inherent_impls(adt_deref.did())\n+                                    .inherent_impls(adt_def.did())\n                                     .iter()\n                                     .filter_map(|def_id| self.associated_value(*def_id, item_name))\n                                     .count()\n@@ -348,15 +348,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n \n                 let ty_span = match actual.kind() {\n-                    ty::Param(param_type) => {\n-                        let generics = self.tcx.generics_of(self.body_id.owner.to_def_id());\n-                        let type_param = generics.type_param(param_type, self.tcx);\n-                        Some(self.tcx.def_span(type_param.def_id))\n-                    }\n+                    ty::Param(param_type) => Some(\n+                        param_type.span_from_generics(self.tcx, self.body_id.owner.to_def_id()),\n+                    ),\n                     ty::Adt(def, _) if def.did().is_local() => Some(tcx.def_span(def.did())),\n                     _ => None,\n                 };\n-\n                 if let Some(span) = ty_span {\n                     err.span_label(\n                         span,\n@@ -386,17 +383,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 let mut custom_span_label = false;\n \n-                if !static_sources.is_empty() {\n+                if !static_candidates.is_empty() {\n                     err.note(\n                         \"found the following associated functions; to be used as methods, \\\n                          functions must have a `self` parameter\",\n                     );\n                     err.span_label(span, \"this is an associated function, not a method\");\n                     custom_span_label = true;\n                 }\n-                if static_sources.len() == 1 {\n+                if static_candidates.len() == 1 {\n                     let ty_str =\n-                        if let Some(CandidateSource::Impl(impl_did)) = static_sources.get(0) {\n+                        if let Some(CandidateSource::Impl(impl_did)) = static_candidates.get(0) {\n                             // When the \"method\" is resolved through dereferencing, we really want the\n                             // original type that has the associated function for accurate suggestions.\n                             // (#61411)\n@@ -422,9 +419,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         err.help(&format!(\"try with `{}::{}`\", ty_str, item_name,));\n                     }\n \n-                    report_candidates(span, &mut err, &mut static_sources, sugg_span);\n-                } else if static_sources.len() > 1 {\n-                    report_candidates(span, &mut err, &mut static_sources, sugg_span);\n+                    report_candidates(span, &mut err, &mut static_candidates, sugg_span);\n+                } else if static_candidates.len() > 1 {\n+                    report_candidates(span, &mut err, &mut static_candidates, sugg_span);\n                 }\n \n                 let mut bound_spans = vec![];\n@@ -496,24 +493,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             if let (ty::Param(_), ty::PredicateKind::Trait(p)) =\n                                 (self_ty.kind(), parent_pred.kind().skip_binder())\n                             {\n+                                let hir = self.tcx.hir();\n                                 let node = match p.trait_ref.self_ty().kind() {\n                                     ty::Param(_) => {\n                                         // Account for `fn` items like in `issue-35677.rs` to\n                                         // suggest restricting its type params.\n-                                        let did = self.tcx.hir().body_owner_def_id(hir::BodyId {\n-                                            hir_id: self.body_id,\n-                                        });\n-                                        Some(\n-                                            self.tcx\n-                                                .hir()\n-                                                .get(self.tcx.hir().local_def_id_to_hir_id(did)),\n-                                        )\n+                                        let parent_body =\n+                                            hir.body_owner(hir::BodyId { hir_id: self.body_id });\n+                                        Some(hir.get(parent_body))\n+                                    }\n+                                    ty::Adt(def, _) => {\n+                                        def.did().as_local().map(|def_id| hir.get_by_def_id(def_id))\n                                     }\n-                                    ty::Adt(def, _) => def.did().as_local().map(|def_id| {\n-                                        self.tcx\n-                                            .hir()\n-                                            .get(self.tcx.hir().local_def_id_to_hir_id(def_id))\n-                                    }),\n                                     _ => None,\n                                 };\n                                 if let Some(hir::Node::Item(hir::Item { kind, .. })) = node {\n@@ -605,7 +596,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         .iter()\n                         .filter_map(|(p, parent, c)| c.as_ref().map(|c| (p, parent, c)))\n                         .filter_map(|(p, parent, c)| match c.code() {\n-                            ObligationCauseCode::ImplDerivedObligation(ref data) => {\n+                            ObligationCauseCode::ImplDerivedObligation(data) => {\n                                 Some((&data.derived, p, parent, data.impl_def_id, data))\n                             }\n                             _ => None,\n@@ -620,22 +611,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         match self.tcx.hir().get_if_local(impl_def_id) {\n                             // Unmet obligation comes from a `derive` macro, point at it once to\n                             // avoid multiple span labels pointing at the same place.\n-                            Some(Node::Item(hir::Item {\n-                                kind: hir::ItemKind::Trait(..),\n-                                ident,\n-                                ..\n-                            })) if matches!(\n-                                ident.span.ctxt().outer_expn_data().kind,\n-                                ExpnKind::Macro(MacroKind::Derive, _)\n-                            ) =>\n-                            {\n-                                let span = ident.span.ctxt().outer_expn_data().call_site;\n-                                let mut spans: MultiSpan = span.into();\n-                                spans.push_span_label(span, derive_msg);\n-                                let entry = spanned_predicates.entry(spans);\n-                                entry.or_insert_with(|| (path, tr_self_ty, Vec::new())).2.push(p);\n-                            }\n-\n                             Some(Node::Item(hir::Item {\n                                 kind: hir::ItemKind::Impl(hir::Impl { of_trait, self_ty, .. }),\n                                 ..\n@@ -659,34 +634,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 entry.or_insert_with(|| (path, tr_self_ty, Vec::new())).2.push(p);\n                             }\n \n-                            // Unmet obligation coming from a `trait`.\n-                            Some(Node::Item(hir::Item {\n-                                kind: hir::ItemKind::Trait(..),\n-                                ident,\n-                                span: item_span,\n-                                ..\n-                            })) if !matches!(\n-                                ident.span.ctxt().outer_expn_data().kind,\n-                                ExpnKind::Macro(MacroKind::Derive, _)\n-                            ) =>\n-                            {\n-                                if let Some(pred) = parent_p {\n-                                    // Done to add the \"doesn't satisfy\" `span_label`.\n-                                    let _ = format_pred(*pred);\n-                                }\n-                                skip_list.insert(p);\n-                                let mut spans = if cause.span != *item_span {\n-                                    let mut spans: MultiSpan = cause.span.into();\n-                                    spans.push_span_label(cause.span, unsatisfied_msg);\n-                                    spans\n-                                } else {\n-                                    ident.span.into()\n-                                };\n-                                spans.push_span_label(ident.span, \"in this trait\");\n-                                let entry = spanned_predicates.entry(spans);\n-                                entry.or_insert_with(|| (path, tr_self_ty, Vec::new())).2.push(p);\n-                            }\n-\n                             // Unmet obligation coming from an `impl`.\n                             Some(Node::Item(hir::Item {\n                                 kind:\n@@ -695,19 +642,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     }),\n                                 span: item_span,\n                                 ..\n-                            })) if !matches!(\n-                                self_ty.span.ctxt().outer_expn_data().kind,\n-                                ExpnKind::Macro(MacroKind::Derive, _)\n-                            ) && !matches!(\n-                                of_trait.as_ref().map(|t| t\n-                                    .path\n-                                    .span\n-                                    .ctxt()\n-                                    .outer_expn_data()\n-                                    .kind),\n-                                Some(ExpnKind::Macro(MacroKind::Derive, _))\n-                            ) =>\n-                            {\n+                            })) => {\n                                 let sized_pred =\n                                     unsatisfied_predicates.iter().any(|(pred, _, _)| {\n                                         match pred.kind().skip_binder() {\n@@ -759,7 +694,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 let entry = spanned_predicates.entry(spans);\n                                 entry.or_insert_with(|| (path, tr_self_ty, Vec::new())).2.push(p);\n                             }\n-                            _ => {}\n+                            Some(_) => unreachable!(),\n+                            None => (),\n                         }\n                     }\n                     let mut spanned_predicates: Vec<_> = spanned_predicates.into_iter().collect();\n@@ -863,7 +799,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                             .on_unimplemented_note(trait_ref, &obligation);\n                                         (message, label)\n                                     })\n-                                    .unwrap_or((None, None))\n+                                    .unwrap()\n                             } else {\n                                 (None, None)\n                             };\n@@ -972,7 +908,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // If the method name is the name of a field with a function or closure type,\n                 // give a helping note that it has to be called as `(x.f)(...)`.\n                 if let SelfSource::MethodCall(expr) = source {\n-                    if !self.suggest_field_call(span, rcvr_ty, expr, item_name, &mut err)\n+                    if !self.suggest_calling_field_as_fn(span, rcvr_ty, expr, item_name, &mut err)\n                         && lev_candidate.is_none()\n                         && !custom_span_label\n                     {\n@@ -982,10 +918,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     label_span_not_found(&mut err);\n                 }\n \n-                // Don't suggest (for example) `expr.field.method()` if `expr.method()`\n-                // doesn't exist due to unsatisfied predicates.\n+                // Don't suggest (for example) `expr.field.clone()` if `expr.clone()`\n+                // can't be called due to `typeof(expr): Clone` not holding.\n                 if unsatisfied_predicates.is_empty() {\n-                    self.check_for_field_method(&mut err, source, span, actual, item_name);\n+                    self.suggest_calling_method_on_field(&mut err, source, span, actual, item_name);\n                 }\n \n                 self.check_for_inner_self(&mut err, source, span, actual, item_name);\n@@ -1007,7 +943,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         source,\n                         out_of_scope_traits,\n                         &unsatisfied_predicates,\n-                        &static_sources,\n+                        &static_candidates,\n                         unsatisfied_bounds,\n                     );\n                 }\n@@ -1146,7 +1082,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         None\n     }\n \n-    fn suggest_field_call(\n+    /// Suggest calling a field with a type that implements the `Fn*` traits instead of a method with\n+    /// the same name as the field i.e. `(a.my_fn_ptr)(10)` instead of `a.my_fn_ptr(10)`.\n+    fn suggest_calling_field_as_fn(\n         &self,\n         span: Span,\n         rcvr_ty: Ty<'tcx>,\n@@ -1408,7 +1346,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         false\n     }\n \n-    fn check_for_field_method(\n+    /// Suggest calling a method on a field i.e. `a.field.bar()` instead of `a.bar()`\n+    fn suggest_calling_method_on_field(\n         &self,\n         err: &mut Diagnostic,\n         source: SelfSource<'tcx>,\n@@ -2021,7 +1960,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) {\n         let mut alt_rcvr_sugg = false;\n         if let (SelfSource::MethodCall(rcvr), false) = (source, unsatisfied_bounds) {\n-            debug!(?span, ?item_name, ?rcvr_ty, ?rcvr);\n+            debug!(\n+                \"suggest_traits_to_import: span={:?}, item_name={:?}, rcvr_ty={:?}, rcvr={:?}\",\n+                span, item_name, rcvr_ty, rcvr\n+            );\n             let skippable = [\n                 self.tcx.lang_items().clone_trait(),\n                 self.tcx.lang_items().deref_trait(),\n@@ -2060,7 +2002,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // suggestions are generally misleading (see #94218).\n                         break;\n                     }\n-                    _ => {}\n+                    Err(_) => (),\n                 }\n \n                 for (rcvr_ty, pre) in &["}, {"sha": "8598369e884b4e4a1fccbb0fdcb4352619ea0919", "filename": "compiler/rustc_hir_typeck/src/op.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -19,7 +19,7 @@ use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::error_reporting::suggestions::TypeErrCtxtExt as _;\n-use rustc_trait_selection::traits::{FulfillmentError, TraitEngine, TraitEngineExt};\n+use rustc_trait_selection::traits::FulfillmentError;\n use rustc_type_ir::sty::TyKind::*;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -785,9 +785,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     other_ty_expr,\n                     expected,\n                 );\n-                let mut fulfill = <dyn TraitEngine<'_>>::new(self.tcx);\n-                fulfill.register_predicate_obligation(self, obligation);\n-                Err(fulfill.select_where_possible(&self.infcx))\n+                Err(rustc_trait_selection::traits::fully_solve_obligation(self, obligation))\n             }\n         }\n     }"}, {"sha": "bb04e1c49baea08c6492b1f1467424c09142029b", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -109,8 +109,9 @@ pub struct InferenceBadError<'a> {\n \n #[derive(Subdiagnostic)]\n pub enum SourceKindSubdiag<'a> {\n-    #[suggestion_verbose(\n+    #[suggestion(\n         infer_source_kind_subdiag_let,\n+        style = \"verbose\",\n         code = \": {type_name}\",\n         applicability = \"has-placeholders\"\n     )]\n@@ -135,8 +136,9 @@ pub enum SourceKindSubdiag<'a> {\n         parent_prefix: String,\n         parent_name: String,\n     },\n-    #[suggestion_verbose(\n+    #[suggestion(\n         infer_source_kind_subdiag_generic_suggestion,\n+        style = \"verbose\",\n         code = \"::<{args}>\",\n         applicability = \"has-placeholders\"\n     )]\n@@ -150,8 +152,9 @@ pub enum SourceKindSubdiag<'a> {\n \n #[derive(Subdiagnostic)]\n pub enum SourceKindMultiSuggestion<'a> {\n-    #[multipart_suggestion_verbose(\n+    #[multipart_suggestion(\n         infer_source_kind_fully_qualified,\n+        style = \"verbose\",\n         applicability = \"has-placeholders\"\n     )]\n     FullyQualified {\n@@ -163,8 +166,9 @@ pub enum SourceKindMultiSuggestion<'a> {\n         adjustment: &'a str,\n         successor_pos: &'a str,\n     },\n-    #[multipart_suggestion_verbose(\n+    #[multipart_suggestion(\n         infer_source_kind_closure_return,\n+        style = \"verbose\",\n         applicability = \"has-placeholders\"\n     )]\n     ClosureReturn {\n@@ -478,8 +482,9 @@ pub enum ImplicitStaticLifetimeSubdiag {\n         #[primary_span]\n         span: Span,\n     },\n-    #[suggestion_verbose(\n+    #[suggestion(\n         infer_implicit_static_lifetime_suggestion,\n+        style = \"verbose\",\n         code = \" + '_\",\n         applicability = \"maybe-incorrect\"\n     )]"}, {"sha": "365b4b1fccdb4ef8ad018c5dd3c88a85751d33b9", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -773,10 +773,10 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n             self.fold_const(bound_to)\n         } else {\n             let var = self.canonical_var(info, const_var.into());\n-            self.tcx().mk_const(ty::ConstS {\n-                kind: ty::ConstKind::Bound(self.binder_index, var),\n-                ty: self.fold_ty(const_var.ty()),\n-            })\n+            self.tcx().mk_const(\n+                ty::ConstKind::Bound(self.binder_index, var),\n+                self.fold_ty(const_var.ty()),\n+            )\n         }\n     }\n }"}, {"sha": "0794792d8cb3786311cc2758fb8f647cfcebb7ad", "filename": "compiler/rustc_infer/src/infer/canonical/mod.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -43,7 +43,7 @@ impl<'tcx> InferCtxt<'tcx> {\n     ///\n     /// This is only meant to be invoked as part of constructing an\n     /// inference context at the start of a query (see\n-    /// `InferCtxtBuilder::enter_with_canonical`). It basically\n+    /// `InferCtxtBuilder::build_with_canonical`). It basically\n     /// brings the canonical value \"into scope\" within your new infcx.\n     ///\n     /// At the end of processing, the substitution S (once\n@@ -147,12 +147,7 @@ impl<'tcx> InferCtxt<'tcx> {\n             CanonicalVarKind::PlaceholderConst(ty::PlaceholderConst { universe, name }, ty) => {\n                 let universe_mapped = universe_map(universe);\n                 let placeholder_mapped = ty::PlaceholderConst { universe: universe_mapped, name };\n-                self.tcx\n-                    .mk_const(ty::ConstS {\n-                        kind: ty::ConstKind::Placeholder(placeholder_mapped),\n-                        ty,\n-                    })\n-                    .into()\n+                self.tcx.mk_const(ty::ConstKind::Placeholder(placeholder_mapped), ty).into()\n             }\n         }\n     }"}, {"sha": "a973bf54b055eb7b98ca89147abc3d3f1f8007d5", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -741,10 +741,10 @@ impl<'tcx> TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                     substs,\n                     substs,\n                 )?;\n-                Ok(self.tcx().mk_const(ty::ConstS {\n-                    ty: c.ty(),\n-                    kind: ty::ConstKind::Unevaluated(ty::UnevaluatedConst { def, substs }),\n-                }))\n+                Ok(self.tcx().mk_const(\n+                    ty::ConstKind::Unevaluated(ty::UnevaluatedConst { def, substs }),\n+                    c.ty(),\n+                ))\n             }\n             _ => relate::super_relate_consts(self, c, c),\n         }\n@@ -955,10 +955,10 @@ impl<'tcx> TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n                     substs,\n                 )?;\n \n-                Ok(self.tcx().mk_const(ty::ConstS {\n-                    ty: c.ty(),\n-                    kind: ty::ConstKind::Unevaluated(ty::UnevaluatedConst { def, substs }),\n-                }))\n+                Ok(self.tcx().mk_const(\n+                    ty::ConstKind::Unevaluated(ty::UnevaluatedConst { def, substs }),\n+                    c.ty(),\n+                ))\n             }\n             _ => relate::super_relate_consts(self, c, c),\n         }"}, {"sha": "d739323de77c817d7bbe41e3ea2fee0e70b15297", "filename": "compiler/rustc_infer/src/infer/higher_ranked/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -94,13 +94,13 @@ impl<'tcx> InferCtxt<'tcx> {\n                 }))\n             },\n             consts: &mut |bound_var: ty::BoundVar, ty| {\n-                self.tcx.mk_const(ty::ConstS {\n-                    kind: ty::ConstKind::Placeholder(ty::PlaceholderConst {\n+                self.tcx.mk_const(\n+                    ty::ConstKind::Placeholder(ty::PlaceholderConst {\n                         universe: next_universe,\n                         name: bound_var,\n                     }),\n                     ty,\n-                })\n+                )\n             },\n         };\n "}, {"sha": "c2eecd9e87a384f16725433eb85bd9ddd0d97059", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -2065,13 +2065,13 @@ fn replace_param_and_infer_substs_with_placeholder<'tcx>(\n                 if ty.has_non_region_param() || ty.has_non_region_infer() {\n                     bug!(\"const `{ct}`'s type should not reference params or types\");\n                 }\n-                tcx.mk_const(ty::ConstS {\n-                    ty,\n-                    kind: ty::ConstKind::Placeholder(ty::PlaceholderConst {\n+                tcx.mk_const(\n+                    ty::ConstKind::Placeholder(ty::PlaceholderConst {\n                         universe: ty::UniverseIndex::ROOT,\n                         name: ty::BoundVar::from_usize(idx),\n                     }),\n-                })\n+                    ty,\n+                )\n                 .into()\n             }\n             _ => arg,"}, {"sha": "2e526733df974b6e33a7c287505c46f200669f33", "filename": "compiler/rustc_interface/Cargo.toml", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2FCargo.toml?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -48,12 +48,6 @@ rustc_resolve = { path = \"../rustc_resolve\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n rustc_ty_utils = { path = \"../rustc_ty_utils\" }\n \n-[target.'cfg(unix)'.dependencies]\n-libc = \"0.2\"\n-\n-[target.'cfg(windows)'.dependencies]\n-winapi = { version = \"0.3\", features = [\"libloaderapi\"] }\n-\n [dev-dependencies]\n rustc_target = { path = \"../rustc_target\" }\n "}, {"sha": "a03e7b0dae527344a17f8edfd6d958cceed0853a", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -690,6 +690,7 @@ fn test_unstable_options_tracking_hash() {\n     untracked!(time_llvm_passes, true);\n     untracked!(time_passes, true);\n     untracked!(trace_macros, true);\n+    untracked!(track_diagnostics, true);\n     untracked!(trim_diagnostic_paths, false);\n     untracked!(ui_testing, true);\n     untracked!(unpretty, Some(\"expanded\".to_string()));"}, {"sha": "62ee72f9883083185e691cae4e023eb319c0b25c", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 2, "deletions": 95, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -9,6 +9,7 @@ use rustc_session as session;\n use rustc_session::config::CheckCfg;\n use rustc_session::config::{self, CrateType};\n use rustc_session::config::{ErrorOutputType, Input, OutputFilenames};\n+use rustc_session::filesearch::sysroot_candidates;\n use rustc_session::lint::{self, BuiltinLintDiagnostics, LintBuffer};\n use rustc_session::parse::CrateConfig;\n use rustc_session::{early_error, filesearch, output, Session};\n@@ -78,7 +79,7 @@ pub fn create_session(\n \n     let bundle = match rustc_errors::fluent_bundle(\n         sopts.maybe_sysroot.clone(),\n-        sysroot_candidates(),\n+        sysroot_candidates().to_vec(),\n         sopts.unstable_opts.translate_lang.clone(),\n         sopts.unstable_opts.translate_additional_ftl.as_deref(),\n         sopts.unstable_opts.translate_directionality_markers,\n@@ -273,100 +274,6 @@ fn get_rustc_path_inner(bin_path: &str) -> Option<PathBuf> {\n     })\n }\n \n-fn sysroot_candidates() -> Vec<PathBuf> {\n-    let target = session::config::host_triple();\n-    let mut sysroot_candidates = vec![filesearch::get_or_default_sysroot()];\n-    let path = current_dll_path().and_then(|s| s.canonicalize().ok());\n-    if let Some(dll) = path {\n-        // use `parent` twice to chop off the file name and then also the\n-        // directory containing the dll which should be either `lib` or `bin`.\n-        if let Some(path) = dll.parent().and_then(|p| p.parent()) {\n-            // The original `path` pointed at the `rustc_driver` crate's dll.\n-            // Now that dll should only be in one of two locations. The first is\n-            // in the compiler's libdir, for example `$sysroot/lib/*.dll`. The\n-            // other is the target's libdir, for example\n-            // `$sysroot/lib/rustlib/$target/lib/*.dll`.\n-            //\n-            // We don't know which, so let's assume that if our `path` above\n-            // ends in `$target` we *could* be in the target libdir, and always\n-            // assume that we may be in the main libdir.\n-            sysroot_candidates.push(path.to_owned());\n-\n-            if path.ends_with(target) {\n-                sysroot_candidates.extend(\n-                    path.parent() // chop off `$target`\n-                        .and_then(|p| p.parent()) // chop off `rustlib`\n-                        .and_then(|p| p.parent()) // chop off `lib`\n-                        .map(|s| s.to_owned()),\n-                );\n-            }\n-        }\n-    }\n-\n-    return sysroot_candidates;\n-\n-    #[cfg(unix)]\n-    fn current_dll_path() -> Option<PathBuf> {\n-        use std::ffi::{CStr, OsStr};\n-        use std::os::unix::prelude::*;\n-\n-        unsafe {\n-            let addr = current_dll_path as usize as *mut _;\n-            let mut info = mem::zeroed();\n-            if libc::dladdr(addr, &mut info) == 0 {\n-                info!(\"dladdr failed\");\n-                return None;\n-            }\n-            if info.dli_fname.is_null() {\n-                info!(\"dladdr returned null pointer\");\n-                return None;\n-            }\n-            let bytes = CStr::from_ptr(info.dli_fname).to_bytes();\n-            let os = OsStr::from_bytes(bytes);\n-            Some(PathBuf::from(os))\n-        }\n-    }\n-\n-    #[cfg(windows)]\n-    fn current_dll_path() -> Option<PathBuf> {\n-        use std::ffi::OsString;\n-        use std::io;\n-        use std::os::windows::prelude::*;\n-        use std::ptr;\n-\n-        use winapi::um::libloaderapi::{\n-            GetModuleFileNameW, GetModuleHandleExW, GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,\n-        };\n-\n-        unsafe {\n-            let mut module = ptr::null_mut();\n-            let r = GetModuleHandleExW(\n-                GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,\n-                current_dll_path as usize as *mut _,\n-                &mut module,\n-            );\n-            if r == 0 {\n-                info!(\"GetModuleHandleExW failed: {}\", io::Error::last_os_error());\n-                return None;\n-            }\n-            let mut space = Vec::with_capacity(1024);\n-            let r = GetModuleFileNameW(module, space.as_mut_ptr(), space.capacity() as u32);\n-            if r == 0 {\n-                info!(\"GetModuleFileNameW failed: {}\", io::Error::last_os_error());\n-                return None;\n-            }\n-            let r = r as usize;\n-            if r >= space.capacity() {\n-                info!(\"our buffer was too small? {}\", io::Error::last_os_error());\n-                return None;\n-            }\n-            space.set_len(r);\n-            let os = OsString::from_wide(&space);\n-            Some(PathBuf::from(os))\n-        }\n-    }\n-}\n-\n fn get_codegen_sysroot(maybe_sysroot: &Option<PathBuf>, backend_name: &str) -> MakeBackendFn {\n     // For now we only allow this function to be called once as it'll dlopen a\n     // few things, which seems to work best if we only do that once. In"}, {"sha": "27c04d828111d28dfbe0e9323f5ae62a58ba1f5e", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -40,7 +40,7 @@ use rustc_feature::{deprecated_attributes, AttributeGate, BuiltinAttribute, Gate\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId, LocalDefIdSet, CRATE_DEF_ID};\n-use rustc_hir::{ForeignItemKind, GenericParamKind, HirId, PatKind, PredicateOrigin};\n+use rustc_hir::{ForeignItemKind, GenericParamKind, HirId, Node, PatKind, PredicateOrigin};\n use rustc_index::vec::Idx;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::layout::{LayoutError, LayoutOf};\n@@ -1423,7 +1423,11 @@ impl<'tcx> LateLintPass<'tcx> for UnreachablePub {\n     }\n \n     fn check_field_def(&mut self, cx: &LateContext<'_>, field: &hir::FieldDef<'_>) {\n-        let def_id = cx.tcx.hir().local_def_id(field.hir_id);\n+        let map = cx.tcx.hir();\n+        let def_id = map.local_def_id(field.hir_id);\n+        if matches!(map.get(map.get_parent_node(field.hir_id)), Node::Variant(_)) {\n+            return;\n+        }\n         self.perform_lint(cx, \"field\", def_id, field.vis_span, false);\n     }\n "}, {"sha": "1a769893f5520aa8771274b624907953b2004c5c", "filename": "compiler/rustc_lint/src/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -83,7 +83,7 @@ pub struct UnknownToolInScopedLint {\n pub struct BuiltinEllpisisInclusiveRangePatterns {\n     #[primary_span]\n     pub span: Span,\n-    #[suggestion_short(code = \"{replace}\", applicability = \"machine-applicable\")]\n+    #[suggestion(style = \"short\", code = \"{replace}\", applicability = \"machine-applicable\")]\n     pub suggestion: Span,\n     pub replace: String,\n }"}, {"sha": "4187850153ccd001c22f3659f4803a0f5b1ea75c", "filename": "compiler/rustc_lint/src/for_loops_over_fallibles.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_lint%2Fsrc%2Ffor_loops_over_fallibles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_lint%2Fsrc%2Ffor_loops_over_fallibles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ffor_loops_over_fallibles.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -3,11 +3,9 @@ use crate::{LateContext, LateLintPass, LintContext};\n use hir::{Expr, Pat};\n use rustc_errors::{Applicability, DelayDm};\n use rustc_hir as hir;\n-use rustc_infer::traits::TraitEngine;\n use rustc_infer::{infer::TyCtxtInferExt, traits::ObligationCause};\n use rustc_middle::ty::{self, List};\n use rustc_span::{sym, Span};\n-use rustc_trait_selection::traits::TraitEngineExt;\n \n declare_lint! {\n     /// The `for_loops_over_fallibles` lint checks for `for` loops over `Option` or `Result` values.\n@@ -160,24 +158,19 @@ fn suggest_question_mark<'tcx>(\n \n     let ty = substs.type_at(0);\n     let infcx = cx.tcx.infer_ctxt().build();\n-    let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-\n     let cause = ObligationCause::new(\n         span,\n         body_id.hir_id,\n         rustc_infer::traits::ObligationCauseCode::MiscObligation,\n     );\n-    fulfill_cx.register_bound(\n+    let errors = rustc_trait_selection::traits::fully_solve_bound(\n         &infcx,\n+        cause,\n         ty::ParamEnv::empty(),\n         // Erase any region vids from the type, which may not be resolved\n         infcx.tcx.erase_regions(ty),\n         into_iterator_did,\n-        cause,\n     );\n \n-    // Select all, including ambiguous predicates\n-    let errors = fulfill_cx.select_all_or_error(&infcx);\n-\n     errors.is_empty()\n }"}, {"sha": "7443d131c64dc315c8f278059fe488e498b54a0e", "filename": "compiler/rustc_lint/src/opaque_hidden_inferred_bound.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -150,8 +150,9 @@ struct OpaqueHiddenInferredBoundLint<'tcx> {\n }\n \n #[derive(Subdiagnostic)]\n-#[suggestion_verbose(\n+#[suggestion(\n     lint_opaque_hidden_inferred_bound_sugg,\n+    style = \"verbose\",\n     applicability = \"machine-applicable\",\n     code = \" + {trait_ref}\"\n )]"}, {"sha": "389f3ccf72acf3ea1b8d22dd16e41290890045b7", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -1982,73 +1982,6 @@ declare_lint! {\n     };\n }\n \n-declare_lint! {\n-    /// The `proc_macro_derive_resolution_fallback` lint detects proc macro\n-    /// derives using inaccessible names from parent modules.\n-    ///\n-    /// ### Example\n-    ///\n-    /// ```rust,ignore (proc-macro)\n-    /// // foo.rs\n-    /// #![crate_type = \"proc-macro\"]\n-    ///\n-    /// extern crate proc_macro;\n-    ///\n-    /// use proc_macro::*;\n-    ///\n-    /// #[proc_macro_derive(Foo)]\n-    /// pub fn foo1(a: TokenStream) -> TokenStream {\n-    ///     drop(a);\n-    ///     \"mod __bar { static mut BAR: Option<Something> = None; }\".parse().unwrap()\n-    /// }\n-    /// ```\n-    ///\n-    /// ```rust,ignore (needs-dependency)\n-    /// // bar.rs\n-    /// #[macro_use]\n-    /// extern crate foo;\n-    ///\n-    /// struct Something;\n-    ///\n-    /// #[derive(Foo)]\n-    /// struct Another;\n-    ///\n-    /// fn main() {}\n-    /// ```\n-    ///\n-    /// This will produce:\n-    ///\n-    /// ```text\n-    /// warning: cannot find type `Something` in this scope\n-    ///  --> src/main.rs:8:10\n-    ///   |\n-    /// 8 | #[derive(Foo)]\n-    ///   |          ^^^ names from parent modules are not accessible without an explicit import\n-    ///   |\n-    ///   = note: `#[warn(proc_macro_derive_resolution_fallback)]` on by default\n-    ///   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-    ///   = note: for more information, see issue #50504 <https://github.com/rust-lang/rust/issues/50504>\n-    /// ```\n-    ///\n-    /// ### Explanation\n-    ///\n-    /// If a proc-macro generates a module, the compiler unintentionally\n-    /// allowed items in that module to refer to items in the crate root\n-    /// without importing them. This is a [future-incompatible] lint to\n-    /// transition this to a hard error in the future. See [issue #50504] for\n-    /// more details.\n-    ///\n-    /// [issue #50504]: https://github.com/rust-lang/rust/issues/50504\n-    /// [future-incompatible]: ../index.md#future-incompatible-lints\n-    pub PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n-    Deny,\n-    \"detects proc macro derives using inaccessible names from parent modules\",\n-    @future_incompatible = FutureIncompatibleInfo {\n-        reference: \"issue #83583 <https://github.com/rust-lang/rust/issues/83583>\",\n-        reason: FutureIncompatibilityReason::FutureReleaseErrorReportNow,\n-    };\n-}\n-\n declare_lint! {\n     /// The `macro_use_extern_crate` lint detects the use of the\n     /// [`macro_use` attribute].\n@@ -3287,7 +3220,6 @@ declare_lint_pass! {\n         UNSTABLE_NAME_COLLISIONS,\n         IRREFUTABLE_LET_PATTERNS,\n         WHERE_CLAUSES_OBJECT_SAFETY,\n-        PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n         MACRO_USE_EXTERN_CRATE,\n         MACRO_EXPANDED_MACRO_EXPORTS_ACCESSED_BY_ABSOLUTE_PATHS,\n         ILL_FORMED_ATTRIBUTE_INPUT,"}, {"sha": "727cfc4416ee94889cef6eb11cc01f98e120ab45", "filename": "compiler/rustc_llvm/llvm-wrapper/LLVMWrapper.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLLVMWrapper.h", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLLVMWrapper.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLLVMWrapper.h?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -76,7 +76,6 @@ enum LLVMRustAttribute {\n   OptimizeNone = 24,\n   ReturnsTwice = 25,\n   ReadNone = 26,\n-  InaccessibleMemOnly = 27,\n   SanitizeHWAddress = 28,\n   WillReturn = 29,\n   StackProtectReq = 30,"}, {"sha": "0d9b5a57b69a2dc719d72ebd7792af14d4b2da9b", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -8,6 +8,9 @@\n #include \"llvm/IR/Intrinsics.h\"\n #include \"llvm/IR/IntrinsicsARM.h\"\n #include \"llvm/IR/Mangler.h\"\n+#if LLVM_VERSION_GE(16, 0)\n+#include \"llvm/IR/ModRef.h\"\n+#endif\n #include \"llvm/Object/Archive.h\"\n #include \"llvm/Object/COFFImportFile.h\"\n #include \"llvm/Object/ObjectFile.h\"\n@@ -213,8 +216,6 @@ static Attribute::AttrKind fromRust(LLVMRustAttribute Kind) {\n     return Attribute::ReturnsTwice;\n   case ReadNone:\n     return Attribute::ReadNone;\n-  case InaccessibleMemOnly:\n-    return Attribute::InaccessibleMemOnly;\n   case SanitizeHWAddress:\n     return Attribute::SanitizeHWAddress;\n   case WillReturn:\n@@ -379,6 +380,43 @@ extern \"C\" LLVMAttributeRef LLVMRustCreateAllocKindAttr(LLVMContextRef C, uint64\n #endif\n }\n \n+// Simplified representation of `MemoryEffects` across the FFI boundary.\n+//\n+// Each variant corresponds to one of the static factory methods on `MemoryEffects`.\n+enum class LLVMRustMemoryEffects {\n+  None,\n+  ReadOnly,\n+  InaccessibleMemOnly,\n+};\n+\n+extern \"C\" LLVMAttributeRef LLVMRustCreateMemoryEffectsAttr(LLVMContextRef C,\n+                                                            LLVMRustMemoryEffects Effects) {\n+#if LLVM_VERSION_GE(16, 0)\n+  switch (Effects) {\n+    case LLVMRustMemoryEffects::None:\n+      return wrap(Attribute::getWithMemoryEffects(*unwrap(C), MemoryEffects::none()));\n+    case LLVMRustMemoryEffects::ReadOnly:\n+      return wrap(Attribute::getWithMemoryEffects(*unwrap(C), MemoryEffects::readOnly()));\n+    case LLVMRustMemoryEffects::InaccessibleMemOnly:\n+      return wrap(Attribute::getWithMemoryEffects(*unwrap(C),\n+                                                  MemoryEffects::inaccessibleMemOnly()));\n+    default:\n+      report_fatal_error(\"bad MemoryEffects.\");\n+  }\n+#else\n+  switch (Effects) {\n+    case LLVMRustMemoryEffects::None:\n+      return wrap(Attribute::get(*unwrap(C), Attribute::ReadNone));\n+    case LLVMRustMemoryEffects::ReadOnly:\n+      return wrap(Attribute::get(*unwrap(C), Attribute::ReadOnly));\n+    case LLVMRustMemoryEffects::InaccessibleMemOnly:\n+      return wrap(Attribute::get(*unwrap(C), Attribute::InaccessibleMemOnly));\n+    default:\n+      report_fatal_error(\"bad MemoryEffects.\");\n+  }\n+#endif\n+}\n+\n // Enable a fast-math flag\n //\n // https://llvm.org/docs/LangRef.html#fast-math-flags"}, {"sha": "ab38a9ccc8f8d8c6addcefc4a162665d7a5a7a42", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -69,6 +69,8 @@ impl<'a> DiagnosticDerive<'a> {\n                     for @Self\n                 where G: rustc_errors::EmissionGuarantee\n             {\n+\n+                #[track_caller]\n                 fn into_diagnostic(\n                     self,\n                     #handler: &'__diagnostic_handler_sess rustc_errors::Handler\n@@ -133,6 +135,7 @@ impl<'a> LintDiagnosticDerive<'a> {\n         let diag = &builder.diag;\n         structure.gen_impl(quote! {\n             gen impl<'__a> rustc_errors::DecorateLint<'__a, ()> for @Self {\n+                #[track_caller]\n                 fn decorate_lint<'__b>(\n                     self,\n                     #diag: &'__b mut rustc_errors::DiagnosticBuilder<'__a, ()>"}, {"sha": "78df0cd1d341ae7d05df7e783833a0e6efa5ce82", "filename": "compiler/rustc_macros/src/diagnostics/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -129,7 +129,7 @@ pub fn lint_diagnostic_derive(s: Structure<'_>) -> TokenStream {\n /// }\n ///\n /// #[derive(Subdiagnostic)]\n-/// #[suggestion_verbose(parser::raw_identifier)]\n+/// #[suggestion(style = \"verbose\",parser::raw_identifier)]\n /// pub struct RawIdentifierSuggestion<'tcx> {\n ///     #[primary_span]\n ///     span: Span,"}, {"sha": "ba06f61299f37d22a18d86fd291b21757bc60e3a", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 103, "deletions": 19, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -12,7 +12,7 @@ use syn::{spanned::Spanned, Attribute, Field, Meta, Type, TypeTuple};\n use syn::{MetaList, MetaNameValue, NestedMeta, Path};\n use synstructure::{BindingInfo, VariantInfo};\n \n-use super::error::invalid_nested_attr;\n+use super::error::{invalid_attr, invalid_nested_attr};\n \n thread_local! {\n     pub static CODE_IDENT_COUNT: RefCell<u32> = RefCell::new(0);\n@@ -472,32 +472,42 @@ pub(super) fn build_suggestion_code(\n }\n \n /// Possible styles for suggestion subdiagnostics.\n-#[derive(Clone, Copy)]\n+#[derive(Clone, Copy, PartialEq)]\n pub(super) enum SuggestionKind {\n-    /// `#[suggestion]`\n     Normal,\n-    /// `#[suggestion_short]`\n     Short,\n-    /// `#[suggestion_hidden]`\n     Hidden,\n-    /// `#[suggestion_verbose]`\n     Verbose,\n+    ToolOnly,\n }\n \n impl FromStr for SuggestionKind {\n     type Err = ();\n \n     fn from_str(s: &str) -> Result<Self, Self::Err> {\n         match s {\n-            \"\" => Ok(SuggestionKind::Normal),\n-            \"_short\" => Ok(SuggestionKind::Short),\n-            \"_hidden\" => Ok(SuggestionKind::Hidden),\n-            \"_verbose\" => Ok(SuggestionKind::Verbose),\n+            \"normal\" => Ok(SuggestionKind::Normal),\n+            \"short\" => Ok(SuggestionKind::Short),\n+            \"hidden\" => Ok(SuggestionKind::Hidden),\n+            \"verbose\" => Ok(SuggestionKind::Verbose),\n+            \"tool-only\" => Ok(SuggestionKind::ToolOnly),\n             _ => Err(()),\n         }\n     }\n }\n \n+impl fmt::Display for SuggestionKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            SuggestionKind::Normal => write!(f, \"normal\"),\n+            SuggestionKind::Short => write!(f, \"short\"),\n+            SuggestionKind::Hidden => write!(f, \"hidden\"),\n+            SuggestionKind::Verbose => write!(f, \"verbose\"),\n+            SuggestionKind::ToolOnly => write!(f, \"tool-only\"),\n+        }\n+    }\n+}\n+\n impl SuggestionKind {\n     pub fn to_suggestion_style(&self) -> TokenStream {\n         match self {\n@@ -513,6 +523,19 @@ impl SuggestionKind {\n             SuggestionKind::Verbose => {\n                 quote! { rustc_errors::SuggestionStyle::ShowAlways }\n             }\n+            SuggestionKind::ToolOnly => {\n+                quote! { rustc_errors::SuggestionStyle::CompletelyHidden }\n+            }\n+        }\n+    }\n+\n+    fn from_suffix(s: &str) -> Option<Self> {\n+        match s {\n+            \"\" => Some(SuggestionKind::Normal),\n+            \"_short\" => Some(SuggestionKind::Short),\n+            \"_hidden\" => Some(SuggestionKind::Hidden),\n+            \"_verbose\" => Some(SuggestionKind::Verbose),\n+            _ => None,\n         }\n     }\n }\n@@ -565,25 +588,49 @@ impl SubdiagnosticKind {\n         let name = name.as_str();\n \n         let meta = attr.parse_meta()?;\n+\n         let mut kind = match name {\n             \"label\" => SubdiagnosticKind::Label,\n             \"note\" => SubdiagnosticKind::Note,\n             \"help\" => SubdiagnosticKind::Help,\n             \"warning\" => SubdiagnosticKind::Warn,\n             _ => {\n+                // Recover old `#[(multipart_)suggestion_*]` syntaxes\n+                // FIXME(#100717): remove\n                 if let Some(suggestion_kind) =\n-                    name.strip_prefix(\"suggestion\").and_then(|s| s.parse().ok())\n+                    name.strip_prefix(\"suggestion\").and_then(SuggestionKind::from_suffix)\n                 {\n+                    if suggestion_kind != SuggestionKind::Normal {\n+                        invalid_attr(attr, &meta)\n+                            .help(format!(\n+                                r#\"Use `#[suggestion(..., style = \"{}\")]` instead\"#,\n+                                suggestion_kind\n+                            ))\n+                            .emit();\n+                    }\n+\n                     SubdiagnosticKind::Suggestion {\n-                        suggestion_kind,\n+                        suggestion_kind: SuggestionKind::Normal,\n                         applicability: None,\n                         code_field: new_code_ident(),\n                         code_init: TokenStream::new(),\n                     }\n                 } else if let Some(suggestion_kind) =\n-                    name.strip_prefix(\"multipart_suggestion\").and_then(|s| s.parse().ok())\n+                    name.strip_prefix(\"multipart_suggestion\").and_then(SuggestionKind::from_suffix)\n                 {\n-                    SubdiagnosticKind::MultipartSuggestion { suggestion_kind, applicability: None }\n+                    if suggestion_kind != SuggestionKind::Normal {\n+                        invalid_attr(attr, &meta)\n+                            .help(format!(\n+                                r#\"Use `#[multipart_suggestion(..., style = \"{}\")]` instead\"#,\n+                                suggestion_kind\n+                            ))\n+                            .emit();\n+                    }\n+\n+                    SubdiagnosticKind::MultipartSuggestion {\n+                        suggestion_kind: SuggestionKind::Normal,\n+                        applicability: None,\n+                    }\n                 } else {\n                     throw_invalid_attr!(attr, &meta);\n                 }\n@@ -621,6 +668,7 @@ impl SubdiagnosticKind {\n         };\n \n         let mut code = None;\n+        let mut suggestion_kind = None;\n \n         let mut nested_iter = nested.into_iter().peekable();\n \n@@ -682,16 +730,37 @@ impl SubdiagnosticKind {\n                     });\n                     applicability.set_once(value, span);\n                 }\n+                (\n+                    \"style\",\n+                    SubdiagnosticKind::Suggestion { .. }\n+                    | SubdiagnosticKind::MultipartSuggestion { .. },\n+                ) => {\n+                    let Some(value) = string_value else {\n+                        invalid_nested_attr(attr, &nested_attr).emit();\n+                        continue;\n+                    };\n+\n+                    let value = value.value().parse().unwrap_or_else(|()| {\n+                        span_err(value.span().unwrap(), \"invalid suggestion style\")\n+                            .help(\"valid styles are `normal`, `short`, `hidden`, `verbose` and `tool-only`\")\n+                            .emit();\n+                        SuggestionKind::Normal\n+                    });\n+\n+                    suggestion_kind.set_once(value, span);\n+                }\n \n                 // Invalid nested attribute\n                 (_, SubdiagnosticKind::Suggestion { .. }) => {\n                     invalid_nested_attr(attr, &nested_attr)\n-                        .help(\"only `code` and `applicability` are valid nested attributes\")\n+                        .help(\n+                            \"only `style`, `code` and `applicability` are valid nested attributes\",\n+                        )\n                         .emit();\n                 }\n                 (_, SubdiagnosticKind::MultipartSuggestion { .. }) => {\n                     invalid_nested_attr(attr, &nested_attr)\n-                        .help(\"only `applicability` is a valid nested attributes\")\n+                        .help(\"only `style` and `applicability` are valid nested attributes\")\n                         .emit()\n                 }\n                 _ => {\n@@ -701,19 +770,34 @@ impl SubdiagnosticKind {\n         }\n \n         match kind {\n-            SubdiagnosticKind::Suggestion { ref code_field, ref mut code_init, .. } => {\n+            SubdiagnosticKind::Suggestion {\n+                ref code_field,\n+                ref mut code_init,\n+                suggestion_kind: ref mut kind_field,\n+                ..\n+            } => {\n+                if let Some(kind) = suggestion_kind.value() {\n+                    *kind_field = kind;\n+                }\n+\n                 *code_init = if let Some(init) = code.value() {\n                     init\n                 } else {\n                     span_err(span, \"suggestion without `code = \\\"...\\\"`\").emit();\n                     quote! { let #code_field = std::iter::empty(); }\n                 };\n             }\n+            SubdiagnosticKind::MultipartSuggestion {\n+                suggestion_kind: ref mut kind_field, ..\n+            } => {\n+                if let Some(kind) = suggestion_kind.value() {\n+                    *kind_field = kind;\n+                }\n+            }\n             SubdiagnosticKind::Label\n             | SubdiagnosticKind::Note\n             | SubdiagnosticKind::Help\n-            | SubdiagnosticKind::Warn\n-            | SubdiagnosticKind::MultipartSuggestion { .. } => {}\n+            | SubdiagnosticKind::Warn => {}\n         }\n \n         Ok(Some((kind, slug)))"}, {"sha": "d4c457975a8422e76f31321a85c3f3713699d1b7", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 85, "deletions": 12, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -1,8 +1,10 @@\n //! Validates all used crates and extern libraries and loads their metadata\n \n use crate::errors::{\n-    ConflictingGlobalAlloc, CrateNotPanicRuntime, GlobalAllocRequired, NoMultipleGlobalAlloc,\n-    NoPanicStrategy, NoTransitiveNeedsDep, NotProfilerRuntime, ProfilerBuiltinsNeedsCore,\n+    AllocFuncRequired, ConflictingAllocErrorHandler, ConflictingGlobalAlloc, CrateNotPanicRuntime,\n+    GlobalAllocRequired, MissingAllocErrorHandler, NoMultipleAllocErrorHandler,\n+    NoMultipleGlobalAlloc, NoPanicStrategy, NoTransitiveNeedsDep, NotProfilerRuntime,\n+    ProfilerBuiltinsNeedsCore,\n };\n use crate::locator::{CrateError, CrateLocator, CratePaths};\n use crate::rmeta::{CrateDep, CrateMetadata, CrateNumMap, CrateRoot, MetadataBlob};\n@@ -41,8 +43,13 @@ pub struct CStore {\n     /// This crate needs an allocator and either provides it itself, or finds it in a dependency.\n     /// If the above is true, then this field denotes the kind of the found allocator.\n     allocator_kind: Option<AllocatorKind>,\n+    /// This crate needs an allocation error handler and either provides it itself, or finds it in a dependency.\n+    /// If the above is true, then this field denotes the kind of the found allocator.\n+    alloc_error_handler_kind: Option<AllocatorKind>,\n     /// This crate has a `#[global_allocator]` item.\n     has_global_allocator: bool,\n+    /// This crate has a `#[alloc_error_handler]` item.\n+    has_alloc_error_handler: bool,\n \n     /// This map is used to verify we get no hash conflicts between\n     /// `StableCrateId` values.\n@@ -197,10 +204,18 @@ impl CStore {\n         self.allocator_kind\n     }\n \n+    pub(crate) fn alloc_error_handler_kind(&self) -> Option<AllocatorKind> {\n+        self.alloc_error_handler_kind\n+    }\n+\n     pub(crate) fn has_global_allocator(&self) -> bool {\n         self.has_global_allocator\n     }\n \n+    pub(crate) fn has_alloc_error_handler(&self) -> bool {\n+        self.has_alloc_error_handler\n+    }\n+\n     pub fn report_unused_deps(&self, tcx: TyCtxt<'_>) {\n         let json_unused_externs = tcx.sess.opts.json_unused_externs;\n \n@@ -247,7 +262,9 @@ impl<'a> CrateLoader<'a> {\n                 metas: IndexVec::from_elem_n(None, 1),\n                 injected_panic_runtime: None,\n                 allocator_kind: None,\n+                alloc_error_handler_kind: None,\n                 has_global_allocator: false,\n+                has_alloc_error_handler: false,\n                 stable_crate_ids,\n                 unused_externs: Vec::new(),\n             },\n@@ -792,6 +809,13 @@ impl<'a> CrateLoader<'a> {\n             }\n             spans => !spans.is_empty(),\n         };\n+        self.cstore.has_alloc_error_handler = match &*alloc_error_handler_spans(&self.sess, krate) {\n+            [span1, span2, ..] => {\n+                self.sess.emit_err(NoMultipleAllocErrorHandler { span2: *span2, span1: *span1 });\n+                true\n+            }\n+            spans => !spans.is_empty(),\n+        };\n \n         // Check to see if we actually need an allocator. This desire comes\n         // about through the `#![needs_allocator]` attribute and is typically\n@@ -832,22 +856,48 @@ impl<'a> CrateLoader<'a> {\n                 }\n             }\n         }\n+        let mut alloc_error_handler =\n+            self.cstore.has_alloc_error_handler.then(|| Symbol::intern(\"this crate\"));\n+        for (_, data) in self.cstore.iter_crate_data() {\n+            if data.has_alloc_error_handler() {\n+                match alloc_error_handler {\n+                    Some(other_crate) => {\n+                        self.sess.emit_err(ConflictingAllocErrorHandler {\n+                            crate_name: data.name(),\n+                            other_crate_name: other_crate,\n+                        });\n+                    }\n+                    None => alloc_error_handler = Some(data.name()),\n+                }\n+            }\n+        }\n \n         if global_allocator.is_some() {\n             self.cstore.allocator_kind = Some(AllocatorKind::Global);\n-            return;\n+        } else {\n+            // Ok we haven't found a global allocator but we still need an\n+            // allocator. At this point our allocator request is typically fulfilled\n+            // by the standard library, denoted by the `#![default_lib_allocator]`\n+            // attribute.\n+            if !self.sess.contains_name(&krate.attrs, sym::default_lib_allocator)\n+                && !self.cstore.iter_crate_data().any(|(_, data)| data.has_default_lib_allocator())\n+            {\n+                self.sess.emit_err(GlobalAllocRequired);\n+            }\n+            self.cstore.allocator_kind = Some(AllocatorKind::Default);\n         }\n \n-        // Ok we haven't found a global allocator but we still need an\n-        // allocator. At this point our allocator request is typically fulfilled\n-        // by the standard library, denoted by the `#![default_lib_allocator]`\n-        // attribute.\n-        if !self.sess.contains_name(&krate.attrs, sym::default_lib_allocator)\n-            && !self.cstore.iter_crate_data().any(|(_, data)| data.has_default_lib_allocator())\n-        {\n-            self.sess.emit_err(GlobalAllocRequired);\n+        if alloc_error_handler.is_some() {\n+            self.cstore.alloc_error_handler_kind = Some(AllocatorKind::Global);\n+        } else {\n+            // The alloc crate provides a default allocation error handler if\n+            // one isn't specified.\n+            if !self.sess.features_untracked().default_alloc_error_handler {\n+                self.sess.emit_err(AllocFuncRequired);\n+                self.sess.emit_note(MissingAllocErrorHandler);\n+            }\n+            self.cstore.alloc_error_handler_kind = Some(AllocatorKind::Default);\n         }\n-        self.cstore.allocator_kind = Some(AllocatorKind::Default);\n     }\n \n     fn inject_dependency_if(\n@@ -1023,3 +1073,26 @@ fn global_allocator_spans(sess: &Session, krate: &ast::Crate) -> Vec<Span> {\n     visit::walk_crate(&mut f, krate);\n     f.spans\n }\n+\n+fn alloc_error_handler_spans(sess: &Session, krate: &ast::Crate) -> Vec<Span> {\n+    struct Finder<'a> {\n+        sess: &'a Session,\n+        name: Symbol,\n+        spans: Vec<Span>,\n+    }\n+    impl<'ast, 'a> visit::Visitor<'ast> for Finder<'a> {\n+        fn visit_item(&mut self, item: &'ast ast::Item) {\n+            if item.ident.name == self.name\n+                && self.sess.contains_name(&item.attrs, sym::rustc_std_internal_symbol)\n+            {\n+                self.spans.push(item.span);\n+            }\n+            visit::walk_item(self, item)\n+        }\n+    }\n+\n+    let name = Symbol::intern(&AllocatorKind::Global.fn_name(sym::oom));\n+    let mut f = Finder { sess, name, spans: Vec::new() };\n+    visit::walk_crate(&mut f, krate);\n+    f.spans\n+}"}, {"sha": "e5b91d566e524be3b54e4faca8e74d9c4cded449", "filename": "compiler/rustc_metadata/src/errors.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -343,17 +343,42 @@ pub struct NoMultipleGlobalAlloc {\n     pub span1: Span,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(metadata_no_multiple_alloc_error_handler)]\n+pub struct NoMultipleAllocErrorHandler {\n+    #[primary_span]\n+    #[label]\n+    pub span2: Span,\n+    #[label(metadata_prev_alloc_error_handler)]\n+    pub span1: Span,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(metadata_conflicting_global_alloc)]\n pub struct ConflictingGlobalAlloc {\n     pub crate_name: Symbol,\n     pub other_crate_name: Symbol,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(metadata_conflicting_alloc_error_handler)]\n+pub struct ConflictingAllocErrorHandler {\n+    pub crate_name: Symbol,\n+    pub other_crate_name: Symbol,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(metadata_global_alloc_required)]\n pub struct GlobalAllocRequired;\n \n+#[derive(Diagnostic)]\n+#[diag(metadata_alloc_func_required)]\n+pub struct AllocFuncRequired;\n+\n+#[derive(Diagnostic)]\n+#[diag(metadata_missing_alloc_error_handler)]\n+pub struct MissingAllocErrorHandler;\n+\n #[derive(Diagnostic)]\n #[diag(metadata_no_transitive_needs_dep)]\n pub struct NoTransitiveNeedsDep<'a> {\n@@ -578,6 +603,7 @@ pub struct InvalidMetadataFiles {\n }\n \n impl IntoDiagnostic<'_> for InvalidMetadataFiles {\n+    #[track_caller]\n     fn into_diagnostic(\n         self,\n         handler: &'_ rustc_errors::Handler,\n@@ -606,6 +632,7 @@ pub struct CannotFindCrate {\n }\n \n impl IntoDiagnostic<'_> for CannotFindCrate {\n+    #[track_caller]\n     fn into_diagnostic(\n         self,\n         handler: &'_ rustc_errors::Handler,"}, {"sha": "8e80d794a13680df61c90fe9e4399c2a362dcb8f", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -15,7 +15,6 @@ use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::definitions::{DefKey, DefPath, DefPathData, DefPathHash};\n use rustc_hir::diagnostic_items::DiagnosticItems;\n-use rustc_hir::lang_items;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::metadata::ModChild;\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportInfo};\n@@ -967,7 +966,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     /// Iterates over the language items in the given crate.\n-    fn get_lang_items(self, tcx: TyCtxt<'tcx>) -> &'tcx [(DefId, usize)] {\n+    fn get_lang_items(self, tcx: TyCtxt<'tcx>) -> &'tcx [(DefId, LangItem)] {\n         tcx.arena.alloc_from_iter(\n             self.root\n                 .lang_items\n@@ -1319,7 +1318,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         )\n     }\n \n-    fn get_missing_lang_items(self, tcx: TyCtxt<'tcx>) -> &'tcx [lang_items::LangItem] {\n+    fn get_missing_lang_items(self, tcx: TyCtxt<'tcx>) -> &'tcx [LangItem] {\n         tcx.arena.alloc_from_iter(self.root.lang_items_missing.decode(self))\n     }\n \n@@ -1765,6 +1764,10 @@ impl CrateMetadata {\n         self.root.has_global_allocator\n     }\n \n+    pub(crate) fn has_alloc_error_handler(&self) -> bool {\n+        self.root.has_alloc_error_handler\n+    }\n+\n     pub(crate) fn has_default_lib_allocator(&self) -> bool {\n         self.root.has_default_lib_allocator\n     }"}, {"sha": "f475b0b39811c5f281ed3af160f7c959112890af", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -255,6 +255,7 @@ provide! { tcx, def_id, other, cdata,\n     is_panic_runtime => { cdata.root.panic_runtime }\n     is_compiler_builtins => { cdata.root.compiler_builtins }\n     has_global_allocator => { cdata.root.has_global_allocator }\n+    has_alloc_error_handler => { cdata.root.has_alloc_error_handler }\n     has_panic_handler => { cdata.root.has_panic_handler }\n     is_profiler_runtime => { cdata.root.profiler_runtime }\n     required_panic_strategy => { cdata.root.required_panic_strategy }\n@@ -339,6 +340,7 @@ pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n     // resolve! Does this work? Unsure! That's what the issue is about\n     *providers = Providers {\n         allocator_kind: |tcx, ()| CStore::from_tcx(tcx).allocator_kind(),\n+        alloc_error_handler_kind: |tcx, ()| CStore::from_tcx(tcx).alloc_error_handler_kind(),\n         is_private_dep: |_tcx, cnum| {\n             assert_eq!(cnum, LOCAL_CRATE);\n             false\n@@ -464,6 +466,10 @@ pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n             assert_eq!(cnum, LOCAL_CRATE);\n             CStore::from_tcx(tcx).has_global_allocator()\n         },\n+        has_alloc_error_handler: |tcx, cnum| {\n+            assert_eq!(cnum, LOCAL_CRATE);\n+            CStore::from_tcx(tcx).has_alloc_error_handler()\n+        },\n         postorder_cnums: |tcx, ()| {\n             tcx.arena\n                 .alloc_slice(&CStore::from_tcx(tcx).crate_dependencies_in_postorder(LOCAL_CRATE))"}, {"sha": "6a73e14e9f58be49e0502d456968d48f2a103cbb", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -17,7 +17,7 @@ use rustc_hir::def_id::{\n };\n use rustc_hir::definitions::DefPathData;\n use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::lang_items;\n+use rustc_hir::lang_items::LangItem;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::dependency_format::Linkage;\n use rustc_middle::middle::exported_symbols::{\n@@ -670,6 +670,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 panic_in_drop_strategy: tcx.sess.opts.unstable_opts.panic_in_drop,\n                 edition: tcx.sess.edition(),\n                 has_global_allocator: tcx.has_global_allocator(LOCAL_CRATE),\n+                has_alloc_error_handler: tcx.has_alloc_error_handler(LOCAL_CRATE),\n                 has_panic_handler: tcx.has_panic_handler(LOCAL_CRATE),\n                 has_default_lib_allocator: tcx\n                     .sess\n@@ -787,8 +788,7 @@ fn should_encode_attr(\n     } else if attr.doc_str().is_some() {\n         // We keep all public doc comments because they might be \"imported\" into downstream crates\n         // if they use `#[doc(inline)]` to copy an item's documentation into their own.\n-        *is_def_id_public\n-            .get_or_insert_with(|| tcx.effective_visibilities(()).effective_vis(def_id).is_some())\n+        *is_def_id_public.get_or_insert_with(|| tcx.effective_visibilities(()).is_exported(def_id))\n     } else if attr.has_name(sym::doc) {\n         // If this is a `doc` attribute, and it's marked `inline` (as in `#[doc(inline)]`), we can\n         // remove it. It won't be inlinable in downstream crates.\n@@ -1905,22 +1905,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.lazy_array(diagnostic_items.iter().map(|(&name, def_id)| (name, def_id.index)))\n     }\n \n-    fn encode_lang_items(&mut self) -> LazyArray<(DefIndex, usize)> {\n+    fn encode_lang_items(&mut self) -> LazyArray<(DefIndex, LangItem)> {\n         empty_proc_macro!(self);\n-        let tcx = self.tcx;\n-        let lang_items = tcx.lang_items();\n-        let lang_items = lang_items.items().iter();\n-        self.lazy_array(lang_items.enumerate().filter_map(|(i, &opt_def_id)| {\n-            if let Some(def_id) = opt_def_id {\n-                if def_id.is_local() {\n-                    return Some((def_id.index, i));\n-                }\n-            }\n-            None\n+        let lang_items = self.tcx.lang_items().iter();\n+        self.lazy_array(lang_items.filter_map(|(lang_item, def_id)| {\n+            def_id.as_local().map(|id| (id.local_def_index, lang_item))\n         }))\n     }\n \n-    fn encode_lang_items_missing(&mut self) -> LazyArray<lang_items::LangItem> {\n+    fn encode_lang_items_missing(&mut self) -> LazyArray<LangItem> {\n         empty_proc_macro!(self);\n         let tcx = self.tcx;\n         self.lazy_array(&tcx.lang_items().missing)"}, {"sha": "aa6d378a43aca95870ed71c2c7f4d3b816a5b88c", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -12,7 +12,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind};\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, DefPathHash, StableCrateId};\n use rustc_hir::definitions::DefKey;\n-use rustc_hir::lang_items;\n+use rustc_hir::lang_items::LangItem;\n use rustc_index::bit_set::{BitSet, FiniteBitSet};\n use rustc_index::vec::IndexVec;\n use rustc_middle::metadata::ModChild;\n@@ -223,15 +223,16 @@ pub(crate) struct CrateRoot {\n     panic_in_drop_strategy: PanicStrategy,\n     edition: Edition,\n     has_global_allocator: bool,\n+    has_alloc_error_handler: bool,\n     has_panic_handler: bool,\n     has_default_lib_allocator: bool,\n \n     crate_deps: LazyArray<CrateDep>,\n     dylib_dependency_formats: LazyArray<Option<LinkagePreference>>,\n     lib_features: LazyArray<(Symbol, Option<Symbol>)>,\n     stability_implications: LazyArray<(Symbol, Symbol)>,\n-    lang_items: LazyArray<(DefIndex, usize)>,\n-    lang_items_missing: LazyArray<lang_items::LangItem>,\n+    lang_items: LazyArray<(DefIndex, LangItem)>,\n+    lang_items_missing: LazyArray<LangItem>,\n     diagnostic_items: LazyArray<(Symbol, DefIndex)>,\n     native_libraries: LazyArray<NativeLib>,\n     foreign_modules: LazyArray<ForeignModule>,"}, {"sha": "8e7d0cf2ab1b01e59d2ed5cda4083fdf9b36709a", "filename": "compiler/rustc_middle/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2FCargo.toml?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -32,7 +32,7 @@ rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_type_ir = { path = \"../rustc_type_ir\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n-thin-vec = \"0.2.8\"\n+thin-vec = \"0.2.9\"\n tracing = \"0.1\"\n \n [features]"}, {"sha": "43903e6739f9195bd56bdfdecde6e38226f86fea", "filename": "compiler/rustc_middle/src/error.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ferror.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -55,3 +55,12 @@ pub struct ConstEvalNonIntError {\n     #[primary_span]\n     pub span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(middle_strict_coherence_needs_negative_coherence)]\n+pub(crate) struct StrictCoherenceNeedsNegativeCoherence {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub attr_span: Option<Span>,\n+}"}, {"sha": "8d1ed4b2a5228d4a82560676f93f400e7f7ea757", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -341,10 +341,10 @@ impl<'tcx> CanonicalVarValues<'tcx> {\n                         tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br)).into()\n                     }\n                     GenericArgKind::Const(ct) => tcx\n-                        .mk_const(ty::ConstS {\n-                            ty: ct.ty(),\n-                            kind: ty::ConstKind::Bound(ty::INNERMOST, ty::BoundVar::from_u32(i)),\n-                        })\n+                        .mk_const(\n+                            ty::ConstKind::Bound(ty::INNERMOST, ty::BoundVar::from_u32(i)),\n+                            ct.ty(),\n+                        )\n                         .into(),\n                 })\n                 .collect(),"}, {"sha": "dd4332d0db6d2132b0ccda20cf4bc83f5469db4d", "filename": "compiler/rustc_middle/src/middle/lang_items.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Flang_items.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -36,10 +36,6 @@ impl<'tcx> TyCtxt<'tcx> {\n             _ => None,\n         }\n     }\n-\n-    pub fn is_weak_lang_item(self, item_def_id: DefId) -> bool {\n-        self.lang_items().is_weak_lang_item(item_def_id)\n-    }\n }\n \n /// Returns `true` if the specified `lang_item` must be present for this"}, {"sha": "ffbd6d10da6b20aaeee2c63541bd04aafa2fac88", "filename": "compiler/rustc_middle/src/middle/privacy.rs", "status": "modified", "additions": 16, "deletions": 32, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -6,8 +6,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_macros::HashStable;\n use rustc_query_system::ich::StableHashingContext;\n-use rustc_span::def_id::{DefId, LocalDefId};\n-use std::hash::Hash;\n+use rustc_span::def_id::LocalDefId;\n \n /// Represents the levels of effective visibility an item can have.\n ///\n@@ -75,33 +74,33 @@ impl EffectiveVisibility {\n }\n \n /// Holds a map of effective visibilities for reachable HIR nodes.\n-#[derive(Debug, Clone)]\n-pub struct EffectiveVisibilities<Id = LocalDefId> {\n-    map: FxHashMap<Id, EffectiveVisibility>,\n+#[derive(Default, Clone, Debug)]\n+pub struct EffectiveVisibilities {\n+    map: FxHashMap<LocalDefId, EffectiveVisibility>,\n }\n \n-impl<Id: Hash + Eq + Copy> EffectiveVisibilities<Id> {\n-    pub fn is_public_at_level(&self, id: Id, level: Level) -> bool {\n+impl EffectiveVisibilities {\n+    pub fn is_public_at_level(&self, id: LocalDefId, level: Level) -> bool {\n         self.effective_vis(id)\n             .map_or(false, |effective_vis| effective_vis.is_public_at_level(level))\n     }\n \n     /// See `Level::Reachable`.\n-    pub fn is_reachable(&self, id: Id) -> bool {\n+    pub fn is_reachable(&self, id: LocalDefId) -> bool {\n         self.is_public_at_level(id, Level::Reachable)\n     }\n \n     /// See `Level::Reexported`.\n-    pub fn is_exported(&self, id: Id) -> bool {\n+    pub fn is_exported(&self, id: LocalDefId) -> bool {\n         self.is_public_at_level(id, Level::Reexported)\n     }\n \n     /// See `Level::Direct`.\n-    pub fn is_directly_public(&self, id: Id) -> bool {\n+    pub fn is_directly_public(&self, id: LocalDefId) -> bool {\n         self.is_public_at_level(id, Level::Direct)\n     }\n \n-    pub fn public_at_level(&self, id: Id) -> Option<Level> {\n+    pub fn public_at_level(&self, id: LocalDefId) -> Option<Level> {\n         self.effective_vis(id).and_then(|effective_vis| {\n             for level in Level::all_levels() {\n                 if effective_vis.is_public_at_level(level) {\n@@ -112,24 +111,17 @@ impl<Id: Hash + Eq + Copy> EffectiveVisibilities<Id> {\n         })\n     }\n \n-    pub fn effective_vis(&self, id: Id) -> Option<&EffectiveVisibility> {\n+    pub fn effective_vis(&self, id: LocalDefId) -> Option<&EffectiveVisibility> {\n         self.map.get(&id)\n     }\n \n-    pub fn iter(&self) -> impl Iterator<Item = (&Id, &EffectiveVisibility)> {\n+    pub fn iter(&self) -> impl Iterator<Item = (&LocalDefId, &EffectiveVisibility)> {\n         self.map.iter()\n     }\n \n-    pub fn map_id<OutId: Hash + Eq + Copy>(\n-        &self,\n-        f: impl Fn(Id) -> OutId,\n-    ) -> EffectiveVisibilities<OutId> {\n-        EffectiveVisibilities { map: self.map.iter().map(|(k, v)| (f(*k), *v)).collect() }\n-    }\n-\n     pub fn set_public_at_level(\n         &mut self,\n-        id: Id,\n+        id: LocalDefId,\n         default_vis: impl FnOnce() -> Visibility,\n         level: Level,\n     ) {\n@@ -144,23 +136,21 @@ impl<Id: Hash + Eq + Copy> EffectiveVisibilities<Id> {\n         }\n         self.map.insert(id, effective_vis);\n     }\n-}\n \n-impl<Id: Hash + Eq + Copy + Into<DefId>> EffectiveVisibilities<Id> {\n     // `parent_id` is not necessarily a parent in source code tree,\n     // it is the node from which the maximum effective visibility is inherited.\n     pub fn update(\n         &mut self,\n-        id: Id,\n+        id: LocalDefId,\n         nominal_vis: Visibility,\n         default_vis: impl FnOnce() -> Visibility,\n-        parent_id: Id,\n+        parent_id: LocalDefId,\n         level: Level,\n         tree: impl DefIdTree,\n     ) -> bool {\n         let mut changed = false;\n         let mut current_effective_vis = self.effective_vis(id).copied().unwrap_or_else(|| {\n-            if id.into().is_crate_root() {\n+            if id.is_top_level_module() {\n                 EffectiveVisibility::from_vis(Visibility::Public)\n             } else {\n                 EffectiveVisibility::from_vis(default_vis())\n@@ -204,12 +194,6 @@ impl<Id: Hash + Eq + Copy + Into<DefId>> EffectiveVisibilities<Id> {\n     }\n }\n \n-impl<Id> Default for EffectiveVisibilities<Id> {\n-    fn default() -> Self {\n-        EffectiveVisibilities { map: Default::default() }\n-    }\n-}\n-\n impl<'a> HashStable<StableHashingContext<'a>> for EffectiveVisibilities {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let EffectiveVisibilities { ref map } = *self;"}, {"sha": "0a96d23e3543b49306b959ff04bc65fa04a54cfa", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -1186,6 +1186,11 @@ impl<'tcx> BasicBlockData<'tcx> {\n     pub fn visitable(&self, index: usize) -> &dyn MirVisitable<'tcx> {\n         if index < self.statements.len() { &self.statements[index] } else { &self.terminator }\n     }\n+\n+    /// Does the block have no statements and an unreachable terminator?\n+    pub fn is_empty_unreachable(&self) -> bool {\n+        self.statements.is_empty() && matches!(self.terminator().kind, TerminatorKind::Unreachable)\n+    }\n }\n \n impl<O> AssertKind<O> {\n@@ -2409,10 +2414,8 @@ impl<'tcx> ConstantKind<'tcx> {\n                 let generics = tcx.generics_of(item_def_id.to_def_id());\n                 let index = generics.param_def_id_to_index[&def_id];\n                 let name = tcx.hir().name(hir_id);\n-                let ty_const = tcx.mk_const(ty::ConstS {\n-                    kind: ty::ConstKind::Param(ty::ParamConst::new(index, name)),\n-                    ty,\n-                });\n+                let ty_const =\n+                    tcx.mk_const(ty::ConstKind::Param(ty::ParamConst::new(index, name)), ty);\n                 debug!(?ty_const);\n \n                 return Self::Ty(ty_const);"}, {"sha": "33acaed435b89eeeeb25429b60b9d66a6de92dc4", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -1391,6 +1391,13 @@ rustc_queries! {\n         desc { \"checking if the crate has_global_allocator\" }\n         separate_provide_extern\n     }\n+    query has_alloc_error_handler(_: CrateNum) -> bool {\n+        // This query depends on untracked global state in CStore\n+        eval_always\n+        fatal_cycle\n+        desc { \"checking if the crate has_alloc_error_handler\" }\n+        separate_provide_extern\n+    }\n     query has_panic_handler(_: CrateNum) -> bool {\n         fatal_cycle\n         desc { \"checking if the crate has_panic_handler\" }\n@@ -1705,7 +1712,7 @@ rustc_queries! {\n     }\n \n     /// Returns the lang items defined in another crate by loading it from metadata.\n-    query defined_lang_items(_: CrateNum) -> &'tcx [(DefId, usize)] {\n+    query defined_lang_items(_: CrateNum) -> &'tcx [(DefId, LangItem)] {\n         desc { \"calculating the lang items defined in a crate\" }\n         separate_provide_extern\n     }\n@@ -1761,6 +1768,10 @@ rustc_queries! {\n         eval_always\n         desc { \"getting the allocator kind for the current crate\" }\n     }\n+    query alloc_error_handler_kind(_: ()) -> Option<AllocatorKind> {\n+        eval_always\n+        desc { \"alloc error handler kind for the current crate\" }\n+    }\n \n     query upvars_mentioned(def_id: DefId) -> Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>> {\n         desc { |tcx| \"collecting upvars mentioned in `{}`\", tcx.def_path_str(def_id) }"}, {"sha": "07ee758b32c1fc6cd0bfb93d87bcfd1120577f2e", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -203,13 +203,20 @@ pub struct UnifyReceiverContext<'tcx> {\n     pub substs: SubstsRef<'tcx>,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift, Default)]\n+#[derive(Clone, PartialEq, Eq, Hash, Lift, Default)]\n pub struct InternedObligationCauseCode<'tcx> {\n     /// `None` for `ObligationCauseCode::MiscObligation` (a common case, occurs ~60% of\n     /// the time). `Some` otherwise.\n     code: Option<Lrc<ObligationCauseCode<'tcx>>>,\n }\n \n+impl<'tcx> std::fmt::Debug for InternedObligationCauseCode<'tcx> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        let cause: &ObligationCauseCode<'_> = self;\n+        cause.fmt(f)\n+    }\n+}\n+\n impl<'tcx> ObligationCauseCode<'tcx> {\n     #[inline(always)]\n     fn into(self) -> InternedObligationCauseCode<'tcx> {"}, {"sha": "cccedc9ec6ea952c8020f12a8daca1a7b31fee7d", "filename": "compiler/rustc_middle/src/traits/specialization_graph.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fspecialization_graph.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -1,3 +1,4 @@\n+use crate::error::StrictCoherenceNeedsNegativeCoherence;\n use crate::ty::fast_reject::SimplifiedType;\n use crate::ty::visit::TypeVisitable;\n use crate::ty::{self, TyCtxt};\n@@ -65,9 +66,21 @@ impl OverlapMode {\n \n         if with_negative_coherence {\n             if strict_coherence { OverlapMode::Strict } else { OverlapMode::WithNegative }\n-        } else if strict_coherence {\n-            bug!(\"To use strict_coherence you need to set with_negative_coherence feature flag\");\n         } else {\n+            if strict_coherence {\n+                let attr_span = trait_id\n+                    .as_local()\n+                    .into_iter()\n+                    .flat_map(|local_def_id| {\n+                        tcx.hir().attrs(tcx.hir().local_def_id_to_hir_id(local_def_id))\n+                    })\n+                    .find(|attr| attr.has_name(sym::rustc_strict_coherence))\n+                    .map(|attr| attr.span);\n+                tcx.sess.emit_err(StrictCoherenceNeedsNegativeCoherence {\n+                    span: tcx.def_span(trait_id),\n+                    attr_span,\n+                });\n+            }\n             OverlapMode::Stable\n         }\n     }\n@@ -249,7 +262,7 @@ pub fn ancestors<'tcx>(\n \n     if let Some(reported) = specialization_graph.has_errored {\n         Err(reported)\n-    } else if let Some(reported) = tcx.type_of(start_from_impl).error_reported() {\n+    } else if let Err(reported) = tcx.type_of(start_from_impl).error_reported() {\n         Err(reported)\n     } else {\n         Ok(Ancestors {"}, {"sha": "e5bcd5fb27aa715baaa2b8ec22cf775631862a1b", "filename": "compiler/rustc_middle/src/ty/abstract_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -1,7 +1,7 @@\n //! A subset of a mir body used for const evaluatability checking.\n use crate::mir;\n use crate::ty::visit::TypeVisitable;\n-use crate::ty::{self, DelaySpanBugEmitted, EarlyBinder, SubstsRef, Ty, TyCtxt};\n+use crate::ty::{self, EarlyBinder, SubstsRef, Ty, TyCtxt};\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::DefId;\n use std::cmp;\n@@ -43,7 +43,7 @@ impl<'tcx> AbstractConst<'tcx> {\n     ) -> Result<Option<AbstractConst<'tcx>>, ErrorGuaranteed> {\n         match ct.kind() {\n             ty::ConstKind::Unevaluated(uv) => AbstractConst::new(tcx, uv),\n-            ty::ConstKind::Error(DelaySpanBugEmitted { reported, .. }) => Err(reported),\n+            ty::ConstKind::Error(reported) => Err(reported),\n             _ => Ok(None),\n         }\n     }"}, {"sha": "7263e8306cf0933d52a5bd30d0b2f4d0e878450e", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -310,7 +310,8 @@ impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n \n impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for ty::Const<'tcx> {\n     fn decode(decoder: &mut D) -> Self {\n-        decoder.interner().mk_const(Decodable::decode(decoder))\n+        let consts: ty::ConstS<'tcx> = Decodable::decode(decoder);\n+        decoder.interner().mk_const(consts.kind, consts.ty)\n     }\n }\n "}, {"sha": "33fdf1a83709465ed858e95f839111412dc37c43", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -77,13 +77,13 @@ impl<'tcx> Const<'tcx> {\n \n         match Self::try_eval_lit_or_param(tcx, ty, expr) {\n             Some(v) => v,\n-            None => tcx.mk_const(ty::ConstS {\n-                kind: ty::ConstKind::Unevaluated(ty::UnevaluatedConst {\n+            None => tcx.mk_const(\n+                ty::ConstKind::Unevaluated(ty::UnevaluatedConst {\n                     def: def.to_global(),\n                     substs: InternalSubsts::identity_for_item(tcx, def.did.to_def_id()),\n                 }),\n                 ty,\n-            }),\n+            ),\n         }\n     }\n \n@@ -138,10 +138,7 @@ impl<'tcx> Const<'tcx> {\n                 let generics = tcx.generics_of(item_def_id.to_def_id());\n                 let index = generics.param_def_id_to_index[&def_id];\n                 let name = tcx.hir().name(hir_id);\n-                Some(tcx.mk_const(ty::ConstS {\n-                    kind: ty::ConstKind::Param(ty::ParamConst::new(index, name)),\n-                    ty,\n-                }))\n+                Some(tcx.mk_const(ty::ConstKind::Param(ty::ParamConst::new(index, name)), ty))\n             }\n             _ => None,\n         }\n@@ -150,7 +147,7 @@ impl<'tcx> Const<'tcx> {\n     /// Interns the given value as a constant.\n     #[inline]\n     pub fn from_value(tcx: TyCtxt<'tcx>, val: ty::ValTree<'tcx>, ty: Ty<'tcx>) -> Self {\n-        tcx.mk_const(ConstS { kind: ConstKind::Value(val), ty })\n+        tcx.mk_const(ConstKind::Value(val), ty)\n     }\n \n     /// Panics if self.kind != ty::ConstKind::Value"}, {"sha": "c1c613f6c602ed3d01017c3aacd74163de0f5368", "filename": "compiler/rustc_middle/src/ty/consts/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -69,7 +69,7 @@ pub enum ConstKind<'tcx> {\n \n     /// A placeholder for a const which could not be computed; this is\n     /// propagated to avoid useless error messages.\n-    Error(ty::DelaySpanBugEmitted),\n+    Error(ErrorGuaranteed),\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]"}, {"sha": "e039436fe0afa69c0108293c2cb792d6f8cacbfd", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -117,7 +117,7 @@ impl<'tcx> Interner for TyCtxt<'tcx> {\n     type BoundTy = ty::BoundTy;\n     type PlaceholderType = ty::PlaceholderType;\n     type InferTy = InferTy;\n-    type DelaySpanBugEmitted = DelaySpanBugEmitted;\n+    type ErrorGuaranteed = ErrorGuaranteed;\n     type PredicateKind = ty::PredicateKind<'tcx>;\n     type AllocId = crate::mir::interpret::AllocId;\n \n@@ -128,15 +128,6 @@ impl<'tcx> Interner for TyCtxt<'tcx> {\n     type PlaceholderRegion = ty::PlaceholderRegion;\n }\n \n-/// A type that is not publicly constructable. This prevents people from making [`TyKind::Error`]s\n-/// except through the error-reporting functions on a [`tcx`][TyCtxt].\n-#[derive(Copy, Clone, Debug, Eq, Hash, PartialEq, PartialOrd, Ord)]\n-#[derive(TyEncodable, TyDecodable, HashStable)]\n-pub struct DelaySpanBugEmitted {\n-    pub reported: ErrorGuaranteed,\n-    _priv: (),\n-}\n-\n type InternedSet<'tcx, T> = ShardedHashMap<InternedInSet<'tcx, T>, ()>;\n \n pub struct CtxtInterners<'tcx> {\n@@ -1303,7 +1294,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     #[track_caller]\n     pub fn ty_error_with_message<S: Into<MultiSpan>>(self, span: S, msg: &str) -> Ty<'tcx> {\n         let reported = self.sess.delay_span_bug(span, msg);\n-        self.mk_ty(Error(DelaySpanBugEmitted { reported, _priv: () }))\n+        self.mk_ty(Error(reported))\n     }\n \n     /// Like [TyCtxt::ty_error] but for constants.\n@@ -1325,10 +1316,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         msg: &str,\n     ) -> Const<'tcx> {\n         let reported = self.sess.delay_span_bug(span, msg);\n-        self.mk_const(ty::ConstS {\n-            kind: ty::ConstKind::Error(DelaySpanBugEmitted { reported, _priv: () }),\n-            ty,\n-        })\n+        self.mk_const(ty::ConstKind::Error(reported), ty)\n     }\n \n     pub fn consider_optimizing<T: Fn() -> String>(self, msg: T) -> bool {\n@@ -2243,7 +2231,7 @@ macro_rules! direct_interners {\n \n direct_interners! {\n     region: mk_region(RegionKind<'tcx>): Region -> Region<'tcx>,\n-    const_: mk_const(ConstS<'tcx>): Const -> Const<'tcx>,\n+    const_: mk_const_internal(ConstS<'tcx>): Const -> Const<'tcx>,\n     const_allocation: intern_const_alloc(Allocation): ConstAllocation -> ConstAllocation<'tcx>,\n     layout: intern_layout(LayoutS<'tcx>): Layout -> Layout<'tcx>,\n     adt_def: intern_adt_def(AdtDefData): AdtDef -> AdtDef<'tcx>,\n@@ -2456,7 +2444,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn mk_lang_item(self, ty: Ty<'tcx>, item: LangItem) -> Option<Ty<'tcx>> {\n-        let def_id = self.lang_items().require(item).ok()?;\n+        let def_id = self.lang_items().get(item)?;\n         Some(self.mk_generic_adt(def_id, ty))\n     }\n \n@@ -2581,9 +2569,14 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_ty_infer(TyVar(v))\n     }\n \n+    #[inline]\n+    pub fn mk_const(self, kind: ty::ConstKind<'tcx>, ty: Ty<'tcx>) -> Const<'tcx> {\n+        self.mk_const_internal(ty::ConstS { kind, ty })\n+    }\n+\n     #[inline]\n     pub fn mk_const_var(self, v: ConstVid<'tcx>, ty: Ty<'tcx>) -> Const<'tcx> {\n-        self.mk_const(ty::ConstS { kind: ty::ConstKind::Infer(InferConst::Var(v)), ty })\n+        self.mk_const(ty::ConstKind::Infer(InferConst::Var(v)), ty)\n     }\n \n     #[inline]\n@@ -2603,7 +2596,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn mk_const_infer(self, ic: InferConst<'tcx>, ty: Ty<'tcx>) -> ty::Const<'tcx> {\n-        self.mk_const(ty::ConstS { kind: ty::ConstKind::Infer(ic), ty })\n+        self.mk_const(ty::ConstKind::Infer(ic), ty)\n     }\n \n     #[inline]\n@@ -2613,7 +2606,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn mk_const_param(self, index: u32, name: Symbol, ty: Ty<'tcx>) -> Const<'tcx> {\n-        self.mk_const(ty::ConstS { kind: ty::ConstKind::Param(ParamConst { index, name }), ty })\n+        self.mk_const(ty::ConstKind::Param(ParamConst { index, name }), ty)\n     }\n \n     pub fn mk_param_from_def(self, param: &ty::GenericParamDef) -> GenericArg<'tcx> {"}, {"sha": "a329753726ef2b91a114d9e3d24a9862226e1525", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -566,10 +566,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                     ))\n                 },\n                 consts: &mut |c, ty: Ty<'tcx>| {\n-                    self.mk_const(ty::ConstS {\n-                        kind: ty::ConstKind::Bound(ty::INNERMOST, shift_bv(c)),\n-                        ty,\n-                    })\n+                    self.mk_const(ty::ConstKind::Bound(ty::INNERMOST, shift_bv(c)), ty)\n                 },\n             },\n         )\n@@ -648,7 +645,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 let index = entry.index();\n                 let var = ty::BoundVar::from_usize(index);\n                 let () = entry.or_insert_with(|| ty::BoundVariableKind::Const).expect_const();\n-                self.tcx.mk_const(ty::ConstS { ty, kind: ty::ConstKind::Bound(ty::INNERMOST, var) })\n+                self.tcx.mk_const(ty::ConstKind::Bound(ty::INNERMOST, var), ty)\n             }\n         }\n \n@@ -732,10 +729,7 @@ impl<'tcx> TypeFolder<'tcx> for Shifter<'tcx> {\n                 ct\n             } else {\n                 let debruijn = debruijn.shifted_in(self.amount);\n-                self.tcx.mk_const(ty::ConstS {\n-                    kind: ty::ConstKind::Bound(debruijn, bound_ct),\n-                    ty: ct.ty(),\n-                })\n+                self.tcx.mk_const(ty::ConstKind::Bound(debruijn, bound_ct), ct.ty())\n             }\n         } else {\n             ct.super_fold_with(self)"}, {"sha": "27090c62d21ed135d895f4c702651ea280a006e3", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -80,7 +80,7 @@ pub use self::consts::{\n };\n pub use self::context::{\n     tls, CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,\n-    CtxtInterners, DeducedParamAttrs, DelaySpanBugEmitted, FreeRegionInfo, GeneratorDiagnosticData,\n+    CtxtInterners, DeducedParamAttrs, FreeRegionInfo, GeneratorDiagnosticData,\n     GeneratorInteriorTypeCause, GlobalCtxt, Lift, OnDiskCache, TyCtxt, TypeckResults, UserType,\n     UserTypeAnnotationIndex,\n };"}, {"sha": "fab85c39d253594fb8bd1dc35044dd9a4de39137", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -63,7 +63,6 @@ thread_local! {\n     static NO_TRIMMED_PATH: Cell<bool> = const { Cell::new(false) };\n     static NO_QUERIES: Cell<bool> = const { Cell::new(false) };\n     static NO_VISIBLE_PATH: Cell<bool> = const { Cell::new(false) };\n-    static NO_VERBOSE_CONSTANTS: Cell<bool> = const { Cell::new(false) };\n }\n \n macro_rules! define_helper {\n@@ -118,9 +117,6 @@ define_helper!(\n     /// Prevent selection of visible paths. `Display` impl of DefId will prefer\n     /// visible (public) reexports of types as paths.\n     fn with_no_visible_paths(NoVisibleGuard, NO_VISIBLE_PATH);\n-    /// Prevent verbose printing of constants. Verbose printing of constants is\n-    /// never desirable in some contexts like `std::any::type_name`.\n-    fn with_no_verbose_constants(NoVerboseConstantsGuard, NO_VERBOSE_CONSTANTS);\n );\n \n /// The \"region highlights\" are used to control region printing during\n@@ -600,7 +596,7 @@ pub trait PrettyPrinter<'tcx>:\n             }\n             ty::FnPtr(ref bare_fn) => p!(print(bare_fn)),\n             ty::Infer(infer_ty) => {\n-                let verbose = self.tcx().sess.verbose();\n+                let verbose = self.should_print_verbose();\n                 if let ty::TyVar(ty_vid) = infer_ty {\n                     if let Some(name) = self.ty_infer_name(ty_vid) {\n                         p!(write(\"{}\", name))\n@@ -642,7 +638,7 @@ pub trait PrettyPrinter<'tcx>:\n                 p!(print_def_path(def_id, &[]));\n             }\n             ty::Projection(ref data) => {\n-                if !(self.tcx().sess.verbose() || NO_QUERIES.with(|q| q.get()))\n+                if !(self.should_print_verbose() || NO_QUERIES.with(|q| q.get()))\n                     && self.tcx().def_kind(data.item_def_id) == DefKind::ImplTraitPlaceholder\n                 {\n                     return self.pretty_print_opaque_impl_type(data.item_def_id, data.substs);\n@@ -658,7 +654,7 @@ pub trait PrettyPrinter<'tcx>:\n                 // only affect certain debug messages (e.g. messages printed\n                 // from `rustc_middle::ty` during the computation of `tcx.predicates_of`),\n                 // and should have no effect on any compiler output.\n-                if self.tcx().sess.verbose() || NO_QUERIES.with(|q| q.get()) {\n+                if self.should_print_verbose() || NO_QUERIES.with(|q| q.get()) {\n                     p!(write(\"Opaque({:?}, {:?})\", def_id, substs));\n                     return Ok(self);\n                 }\n@@ -689,7 +685,7 @@ pub trait PrettyPrinter<'tcx>:\n                     hir::Movability::Static => p!(\"static \"),\n                 }\n \n-                if !self.tcx().sess.verbose() {\n+                if !self.should_print_verbose() {\n                     p!(\"generator\");\n                     // FIXME(eddyb) should use `def_span`.\n                     if let Some(did) = did.as_local() {\n@@ -725,7 +721,7 @@ pub trait PrettyPrinter<'tcx>:\n             }\n             ty::Closure(did, substs) => {\n                 p!(write(\"[\"));\n-                if !self.tcx().sess.verbose() {\n+                if !self.should_print_verbose() {\n                     p!(write(\"closure\"));\n                     // FIXME(eddyb) should use `def_span`.\n                     if let Some(did) = did.as_local() {\n@@ -763,7 +759,7 @@ pub trait PrettyPrinter<'tcx>:\n             }\n             ty::Array(ty, sz) => {\n                 p!(\"[\", print(ty), \"; \");\n-                if !NO_VERBOSE_CONSTANTS.with(|flag| flag.get()) && self.tcx().sess.verbose() {\n+                if self.should_print_verbose() {\n                     p!(write(\"{:?}\", sz));\n                 } else if let ty::ConstKind::Unevaluated(..) = sz.kind() {\n                     // Do not try to evaluate unevaluated constants. If we are const evaluating an\n@@ -1077,7 +1073,7 @@ pub trait PrettyPrinter<'tcx>:\n \n                 // Special-case `Fn(...) -> ...` and re-sugar it.\n                 let fn_trait_kind = cx.tcx().fn_trait_kind_from_lang_item(principal.def_id);\n-                if !cx.tcx().sess.verbose() && fn_trait_kind.is_some() {\n+                if !cx.should_print_verbose() && fn_trait_kind.is_some() {\n                     if let ty::Tuple(tys) = principal.substs.type_at(0).kind() {\n                         let mut projections = predicates.projection_bounds();\n                         if let (Some(proj), None) = (projections.next(), projections.next()) {\n@@ -1141,7 +1137,7 @@ pub trait PrettyPrinter<'tcx>:\n         //\n         // To avoid causing instabilities in compiletest\n         // output, sort the auto-traits alphabetically.\n-        auto_traits.sort_by_cached_key(|did| self.tcx().def_path_str(*did));\n+        auto_traits.sort_by_cached_key(|did| with_no_trimmed_paths!(self.tcx().def_path_str(*did)));\n \n         for def_id in auto_traits {\n             if !first {\n@@ -1185,7 +1181,7 @@ pub trait PrettyPrinter<'tcx>:\n     ) -> Result<Self::Const, Self::Error> {\n         define_scoped_cx!(self);\n \n-        if !NO_VERBOSE_CONSTANTS.with(|flag| flag.get()) && self.tcx().sess.verbose() {\n+        if self.should_print_verbose() {\n             p!(write(\"Const({:?}: {:?})\", ct.kind(), ct.ty()));\n             return Ok(self);\n         }\n@@ -1420,7 +1416,7 @@ pub trait PrettyPrinter<'tcx>:\n     ) -> Result<Self::Const, Self::Error> {\n         define_scoped_cx!(self);\n \n-        if !NO_VERBOSE_CONSTANTS.with(|flag| flag.get()) && self.tcx().sess.verbose() {\n+        if self.should_print_verbose() {\n             p!(write(\"ValTree({:?}: \", valtree), print(ty), \")\");\n             return Ok(self);\n         }\n@@ -1564,6 +1560,10 @@ pub trait PrettyPrinter<'tcx>:\n             Ok(cx)\n         })\n     }\n+\n+    fn should_print_verbose(&self) -> bool {\n+        self.tcx().sess.verbose()\n+    }\n }\n \n // HACK(eddyb) boxed to avoid moving around a large struct by-value.\n@@ -1839,7 +1839,7 @@ impl<'tcx> Printer<'tcx> for FmtPrinter<'_, 'tcx> {\n             }\n         }\n \n-        let verbose = self.tcx.sess.verbose();\n+        let verbose = self.should_print_verbose();\n         disambiguated_data.fmt_maybe_verbose(&mut self, verbose)?;\n \n         self.empty_path = false;\n@@ -1940,7 +1940,7 @@ impl<'tcx> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx> {\n             return true;\n         }\n \n-        if self.tcx.sess.verbose() {\n+        if self.should_print_verbose() {\n             return true;\n         }\n \n@@ -2012,7 +2012,7 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n             return Ok(self);\n         }\n \n-        if self.tcx.sess.verbose() {\n+        if self.should_print_verbose() {\n             p!(write(\"{:?}\", region));\n             return Ok(self);\n         }\n@@ -2218,7 +2218,7 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n         // aren't named. Eventually, we might just want this as the default, but\n         // this is not *quite* right and changes the ordering of some output\n         // anyways.\n-        let (new_value, map) = if self.tcx().sess.verbose() {\n+        let (new_value, map) = if self.should_print_verbose() {\n             let regions: Vec<_> = value\n                 .bound_vars()\n                 .into_iter()"}, {"sha": "c083a405e3cfb605252b89902a4a6efe4f7007b0", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -639,10 +639,10 @@ pub fn super_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n                 au.substs,\n                 bu.substs,\n             )?;\n-            return Ok(tcx.mk_const(ty::ConstS {\n-                kind: ty::ConstKind::Unevaluated(ty::UnevaluatedConst { def: au.def, substs }),\n-                ty: a.ty(),\n-            }));\n+            return Ok(tcx.mk_const(\n+                ty::ConstKind::Unevaluated(ty::UnevaluatedConst { def: au.def, substs }),\n+                a.ty(),\n+            ));\n         }\n         _ => false,\n     };"}, {"sha": "f2070869ce0cd887cf5ae297121ef41f95d6cdad", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -240,7 +240,6 @@ TrivialTypeTraversalAndLiftImpls! {\n     Field,\n     interpret::Scalar,\n     rustc_target::abi::Size,\n-    ty::DelaySpanBugEmitted,\n     rustc_type_ir::DebruijnIndex,\n     ty::BoundVar,\n     ty::Placeholder<ty::BoundVar>,\n@@ -806,7 +805,7 @@ impl<'tcx> TypeSuperFoldable<'tcx> for ty::Const<'tcx> {\n         let ty = self.ty().try_fold_with(folder)?;\n         let kind = self.kind().try_fold_with(folder)?;\n         if ty != self.ty() || kind != self.kind() {\n-            Ok(folder.tcx().mk_const(ty::ConstS { ty, kind }))\n+            Ok(folder.tcx().mk_const(kind, ty))\n         } else {\n             Ok(self)\n         }"}, {"sha": "5f108bf0ef30644a1849beab3e4bb6838a7f2d82", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -20,6 +20,7 @@ use rustc_hir::def_id::DefId;\n use rustc_index::vec::Idx;\n use rustc_macros::HashStable;\n use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n use rustc_target::spec::abi;\n use std::borrow::Cow;\n@@ -1282,6 +1283,12 @@ impl<'tcx> ParamTy {\n     pub fn to_ty(self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         tcx.mk_ty_param(self.index, self.name)\n     }\n+\n+    pub fn span_from_generics(&self, tcx: TyCtxt<'tcx>, item_with_generics: DefId) -> Span {\n+        let generics = tcx.generics_of(item_with_generics);\n+        let type_param = generics.type_param(self, tcx);\n+        tcx.def_span(type_param.def_id)\n+    }\n }\n \n #[derive(Copy, Clone, Hash, TyEncodable, TyDecodable, Eq, PartialEq, Ord, PartialOrd)]"}, {"sha": "f0e9f990a8115e8f00bc7cefc9fc68b0408bab81", "filename": "compiler/rustc_middle/src/ty/visit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -95,11 +95,11 @@ pub trait TypeVisitable<'tcx>: fmt::Debug + Clone {\n     fn references_error(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_ERROR)\n     }\n-    fn error_reported(&self) -> Option<ErrorGuaranteed> {\n+    fn error_reported(&self) -> Result<(), ErrorGuaranteed> {\n         if self.references_error() {\n-            Some(ErrorGuaranteed::unchecked_claim_error_was_emitted())\n+            Err(ErrorGuaranteed::unchecked_claim_error_was_emitted())\n         } else {\n-            None\n+            Ok(())\n         }\n     }\n     fn has_non_region_param(&self) -> bool {"}, {"sha": "98df9c3f0e8df364a961a1f6d8f9699d554058ab", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -74,8 +74,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 Constant { user_ty, span, literal }\n             }\n             ExprKind::ConstParam { param, def_id: _ } => {\n-                let const_param =\n-                    tcx.mk_const(ty::ConstS { kind: ty::ConstKind::Param(param), ty: expr.ty });\n+                let const_param = tcx.mk_const(ty::ConstKind::Param(param), expr.ty);\n                 let literal = ConstantKind::Ty(const_param);\n \n                 Constant { user_ty: None, span, literal }"}, {"sha": "5c82fb1ddc0d5a49beaf8dbce6635556517e32d4", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -2,6 +2,7 @@\n \n use rustc_index::vec::Idx;\n use rustc_middle::ty::util::IntTypeExt;\n+use rustc_target::abi::{Abi, Primitive};\n \n use crate::build::expr::as_place::PlaceBase;\n use crate::build::expr::category::{Category, RvalueFunc};\n@@ -198,15 +199,63 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let (source, ty) = if let ty::Adt(adt_def, ..) = source.ty.kind() && adt_def.is_enum() {\n                     let discr_ty = adt_def.repr().discr_type().to_ty(this.tcx);\n                     let temp = unpack!(block = this.as_temp(block, scope, source, Mutability::Not));\n+                    let layout = this.tcx.layout_of(this.param_env.and(source.ty));\n                     let discr = this.temp(discr_ty, source.span);\n                     this.cfg.push_assign(\n                         block,\n                         source_info,\n                         discr,\n                         Rvalue::Discriminant(temp.into()),\n                     );\n+                    let (op,ty) = (Operand::Move(discr), discr_ty);\n+\n+                    if let Abi::Scalar(scalar) = layout.unwrap().abi{\n+                        if let Primitive::Int(_, signed) = scalar.primitive() {\n+                            let range = scalar.valid_range(&this.tcx);\n+                            // FIXME: Handle wraparound cases too.\n+                            if range.end >= range.start {\n+                                let mut assumer = |range: u128, bin_op: BinOp| {\n+                                    // We will be overwriting this val if our scalar is signed value\n+                                    // because sign extension on unsigned types might cause unintended things\n+                                    let mut range_val =\n+                                        ConstantKind::from_bits(this.tcx, range, ty::ParamEnv::empty().and(discr_ty));\n+                                    let bool_ty = this.tcx.types.bool;\n+                                    if signed {\n+                                        let scalar_size_extend = scalar.size(&this.tcx).sign_extend(range);\n+                                        let discr_layout = this.tcx.layout_of(this.param_env.and(discr_ty));\n+                                        let truncated_val = discr_layout.unwrap().size.truncate(scalar_size_extend);\n+                                        range_val = ConstantKind::from_bits(\n+                                            this.tcx,\n+                                            truncated_val,\n+                                            ty::ParamEnv::empty().and(discr_ty),\n+                                        );\n+                                    }\n+                                    let lit_op = this.literal_operand(expr.span, range_val);\n+                                    let is_bin_op = this.temp(bool_ty, expr_span);\n+                                    this.cfg.push_assign(\n+                                        block,\n+                                        source_info,\n+                                        is_bin_op,\n+                                        Rvalue::BinaryOp(bin_op, Box::new(((lit_op), (Operand::Copy(discr))))),\n+                                    );\n+                                    this.cfg.push(\n+                                        block,\n+                                        Statement {\n+                                            source_info,\n+                                            kind: StatementKind::Intrinsic(Box::new(NonDivergingIntrinsic::Assume(\n+                                                Operand::Copy(is_bin_op),\n+                                            ))),\n+                                        },\n+                                    )\n+                                };\n+                                assumer(range.end, BinOp::Ge);\n+                                assumer(range.start, BinOp::Le);\n+                            }\n+                        }\n+                    }\n+\n+                    (op,ty)\n \n-                    (Operand::Move(discr), discr_ty)\n                 } else {\n                     let ty = source.ty;\n                     let source = unpack!("}, {"sha": "dfd8649cb97e7f716e5ab3218b9157cb192a732d", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 14, "deletions": 37, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -364,12 +364,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     let arm_block = this.bind_pattern(\n                         outer_source_info,\n                         candidate,\n-                        arm.guard.as_ref(),\n                         &fake_borrow_temps,\n                         scrutinee_span,\n-                        Some(arm.span),\n-                        Some(arm.scope),\n-                        Some(match_scope),\n+                        Some((arm, match_scope)),\n                         false,\n                     );\n \n@@ -410,12 +407,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         outer_source_info: SourceInfo,\n         candidate: Candidate<'_, 'tcx>,\n-        guard: Option<&Guard<'tcx>>,\n         fake_borrow_temps: &[(Place<'tcx>, Local)],\n         scrutinee_span: Span,\n-        arm_span: Option<Span>,\n-        arm_scope: Option<region::Scope>,\n-        match_scope: Option<region::Scope>,\n+        arm_match_scope: Option<(&Arm<'tcx>, region::Scope)>,\n         storages_alive: bool,\n     ) -> BasicBlock {\n         if candidate.subcandidates.is_empty() {\n@@ -424,11 +418,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             self.bind_and_guard_matched_candidate(\n                 candidate,\n                 &[],\n-                guard,\n                 fake_borrow_temps,\n                 scrutinee_span,\n-                arm_span,\n-                match_scope,\n+                arm_match_scope,\n                 true,\n                 storages_alive,\n             )\n@@ -449,28 +441,27 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // we lower the guard.\n             let target_block = self.cfg.start_new_block();\n             let mut schedule_drops = true;\n+            let arm = arm_match_scope.unzip().0;\n             // We keep a stack of all of the bindings and type ascriptions\n             // from the parent candidates that we visit, that also need to\n             // be bound for each candidate.\n             traverse_candidate(\n                 candidate,\n                 &mut Vec::new(),\n                 &mut |leaf_candidate, parent_bindings| {\n-                    if let Some(arm_scope) = arm_scope {\n-                        self.clear_top_scope(arm_scope);\n+                    if let Some(arm) = arm {\n+                        self.clear_top_scope(arm.scope);\n                     }\n                     let binding_end = self.bind_and_guard_matched_candidate(\n                         leaf_candidate,\n                         parent_bindings,\n-                        guard,\n                         &fake_borrow_temps,\n                         scrutinee_span,\n-                        arm_span,\n-                        match_scope,\n+                        arm_match_scope,\n                         schedule_drops,\n                         storages_alive,\n                     );\n-                    if arm_scope.is_none() {\n+                    if arm.is_none() {\n                         schedule_drops = false;\n                     }\n                     self.cfg.goto(binding_end, outer_source_info, target_block);\n@@ -636,12 +627,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         self.bind_pattern(\n             self.source_info(irrefutable_pat.span),\n             candidate,\n-            None,\n             &fake_borrow_temps,\n             irrefutable_pat.span,\n             None,\n-            None,\n-            None,\n             false,\n         )\n         .unit()\n@@ -1820,12 +1808,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let post_guard_block = self.bind_pattern(\n             self.source_info(pat.span),\n             guard_candidate,\n-            None,\n             &fake_borrow_temps,\n             expr.span,\n             None,\n-            None,\n-            None,\n             false,\n         );\n \n@@ -1844,11 +1829,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         candidate: Candidate<'pat, 'tcx>,\n         parent_bindings: &[(Vec<Binding<'tcx>>, Vec<Ascription<'tcx>>)],\n-        guard: Option<&Guard<'tcx>>,\n         fake_borrows: &[(Place<'tcx>, Local)],\n         scrutinee_span: Span,\n-        arm_span: Option<Span>,\n-        match_scope: Option<region::Scope>,\n+        arm_match_scope: Option<(&Arm<'tcx>, region::Scope)>,\n         schedule_drops: bool,\n         storages_alive: bool,\n     ) -> BasicBlock {\n@@ -1960,7 +1943,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         //      the reference that we create for the arm.\n         //    * So we eagerly create the reference for the arm and then take a\n         //      reference to that.\n-        if let Some(guard) = guard {\n+        if let Some((arm, match_scope)) = arm_match_scope\n+            && let Some(guard) = &arm.guard\n+        {\n             let tcx = self.tcx;\n             let bindings = parent_bindings\n                 .iter()\n@@ -1981,8 +1966,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 self.cfg.push_assign(block, scrutinee_source_info, Place::from(temp), borrow);\n             }\n \n-            let arm_span = arm_span.unwrap();\n-            let match_scope = match_scope.unwrap();\n             let mut guard_span = rustc_span::DUMMY_SP;\n \n             let (post_guard_block, otherwise_post_guard_block) =\n@@ -1995,13 +1978,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             e,\n                             None,\n                             match_scope,\n-                            this.source_info(arm_span),\n+                            this.source_info(arm.span),\n                         )\n                     }\n                     Guard::IfLet(ref pat, scrutinee) => {\n                         let s = &this.thir[scrutinee];\n                         guard_span = s.span;\n-                        this.lower_let_expr(block, s, pat, match_scope, None, arm_span)\n+                        this.lower_let_expr(block, s, pat, match_scope, None, arm.span)\n                     }\n                 });\n \n@@ -2317,24 +2300,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let matching = this.bind_pattern(\n                 this.source_info(pattern.span),\n                 candidate,\n-                None,\n                 &fake_borrow_temps,\n                 initializer_span,\n                 None,\n-                None,\n-                None,\n                 true,\n             );\n             // This block is for the failure case\n             let failure = this.bind_pattern(\n                 this.source_info(else_block_span),\n                 wildcard,\n-                None,\n                 &fake_borrow_temps,\n                 initializer_span,\n                 None,\n-                None,\n-                None,\n                 true,\n             );\n             this.break_for_else(failure, *let_else_scope, this.source_info(initializer_span));"}, {"sha": "93a3dd8962a9edd608b1f58b366a3ce410cce612", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -79,7 +79,10 @@ impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, '_, 'tcx> {\n         intravisit::walk_local(self, loc);\n         let els = loc.els;\n         if let Some(init) = loc.init && els.is_some() {\n-            self.check_let(&loc.pat, init, loc.span);\n+            // Build a span without the else { ... } as we don't want to underline\n+            // the entire else block in the IDE setting.\n+            let span = loc.span.with_hi(init.span.hi());\n+            self.check_let(&loc.pat, init, span);\n         }\n \n         let (msg, sp) = match loc.source {\n@@ -630,11 +633,6 @@ fn irrefutable_let_patterns(\n     count: usize,\n     span: Span,\n ) {\n-    let span = match source {\n-        LetSource::LetElse(span) => span,\n-        _ => span,\n-    };\n-\n     macro_rules! emit_diag {\n         (\n             $lint:expr,\n@@ -680,7 +678,7 @@ fn irrefutable_let_patterns(\n                 \"removing the guard and adding a `let` inside the match arm\"\n             );\n         }\n-        LetSource::LetElse(..) => {\n+        LetSource::LetElse => {\n             emit_diag!(\n                 lint,\n                 \"`let...else`\",\n@@ -1127,7 +1125,7 @@ pub enum LetSource {\n     GenericLet,\n     IfLet,\n     IfLetGuard,\n-    LetElse(Span),\n+    LetElse,\n     WhileLet,\n }\n \n@@ -1156,8 +1154,8 @@ fn let_source_parent(tcx: TyCtxt<'_>, parent: HirId, pat_id: Option<HirId>) -> L\n     let parent_parent = hir.get_parent_node(parent);\n     let parent_parent_node = hir.get(parent_parent);\n     match parent_parent_node {\n-        hir::Node::Stmt(hir::Stmt { kind: hir::StmtKind::Local(_), span, .. }) => {\n-            return LetSource::LetElse(*span);\n+        hir::Node::Stmt(hir::Stmt { kind: hir::StmtKind::Local(_), .. }) => {\n+            return LetSource::LetElse;\n         }\n         hir::Node::Arm(hir::Arm { guard: Some(hir::Guard::If(_)), .. }) => {\n             return LetSource::IfLetGuard;"}, {"sha": "269d9f3b102c196d0c4279eee54ace23c52edc55", "filename": "compiler/rustc_mir_transform/src/check_unsafety.rs", "status": "modified", "additions": 35, "deletions": 12, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -4,6 +4,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::hir_id::HirId;\n use rustc_hir::intravisit;\n+use rustc_hir::{BlockCheckMode, ExprKind, Node};\n use rustc_middle::mir::visit::{MutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::*;\n use rustc_middle::ty::query::Providers;\n@@ -101,12 +102,10 @@ impl<'tcx> Visitor<'tcx> for UnsafetyChecker<'_, 'tcx> {\n             | StatementKind::Retag { .. }\n             | StatementKind::AscribeUserType(..)\n             | StatementKind::Coverage(..)\n+            | StatementKind::Intrinsic(..)\n             | StatementKind::Nop => {\n                 // safe (at least as emitted during MIR construction)\n             }\n-\n-            // Move to above list once mir construction uses it.\n-            StatementKind::Intrinsic(..) => unreachable!(),\n         }\n         self.super_statement(statement, location);\n     }\n@@ -519,24 +518,48 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     for &UnsafetyViolation { source_info, lint_root, kind, details } in violations.iter() {\n         let (description, note) = details.description_and_note();\n \n-        // Report an error.\n-        let unsafe_fn_msg =\n-            if unsafe_op_in_unsafe_fn_allowed(tcx, lint_root) { \" function or\" } else { \"\" };\n-\n         match kind {\n             UnsafetyViolationKind::General => {\n                 // once\n-                struct_span_err!(\n+                let unsafe_fn_msg = if unsafe_op_in_unsafe_fn_allowed(tcx, lint_root) {\n+                    \" function or\"\n+                } else {\n+                    \"\"\n+                };\n+\n+                let mut err = struct_span_err!(\n                     tcx.sess,\n                     source_info.span,\n                     E0133,\n                     \"{} is unsafe and requires unsafe{} block\",\n                     description,\n                     unsafe_fn_msg,\n-                )\n-                .span_label(source_info.span, description)\n-                .note(note)\n-                .emit();\n+                );\n+                err.span_label(source_info.span, description).note(note);\n+                let note_non_inherited = tcx.hir().parent_iter(lint_root).find(|(id, node)| {\n+                    if let Node::Expr(block) = node\n+                        && let ExprKind::Block(block, _) = block.kind\n+                        && let BlockCheckMode::UnsafeBlock(_) = block.rules\n+                    {\n+                        true\n+                    }\n+                    else if let Some(sig) = tcx.hir().fn_sig_by_hir_id(*id)\n+                        && sig.header.is_unsafe()\n+                    {\n+                        true\n+                    } else {\n+                        false\n+                    }\n+                });\n+                if let Some((id, _)) = note_non_inherited {\n+                    let span = tcx.hir().span(id);\n+                    err.span_label(\n+                        tcx.sess.source_map().guess_head_span(span),\n+                        \"items do not inherit unsafety from separate enclosing items\",\n+                    );\n+                }\n+\n+                err.emit();\n             }\n             UnsafetyViolationKind::UnsafeFn => tcx.struct_span_lint_hir(\n                 UNSAFE_OP_IN_UNSAFE_FN,"}, {"sha": "4791be1306c1b09235074c849503800298cf8ae6", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -288,7 +288,7 @@ fn mir_const<'tcx>(\n \n     let mut body = tcx.mir_built(def).steal();\n \n-    rustc_middle::mir::dump_mir(tcx, None, \"mir_map\", &0, &body, |_, _| Ok(()));\n+    pass_manager::dump_mir_for_phase_change(tcx, &body);\n \n     pm::run_passes(\n         tcx,"}, {"sha": "bf5906741441dad8f301eff8ac2eca8188818189", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -845,7 +845,7 @@ pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> Body<'_> {\n         span,\n     );\n \n-    rustc_middle::mir::dump_mir(tcx, None, \"mir_map\", &0, &body, |_, _| Ok(()));\n+    crate::pass_manager::dump_mir_for_phase_change(tcx, &body);\n \n     body\n }"}, {"sha": "58ddb807059ae37fb3313d7953b68241522ea0c8", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -201,7 +201,7 @@ use std::iter;\n use std::ops::Range;\n use std::path::PathBuf;\n \n-use crate::errors::{LargeAssignmentsLint, RecursionLimit, RequiresLangItem, TypeLengthLimit};\n+use crate::errors::{LargeAssignmentsLint, RecursionLimit, TypeLengthLimit};\n \n #[derive(PartialEq)]\n pub enum MonoItemCollectionMode {\n@@ -1298,14 +1298,7 @@ impl<'v> RootCollector<'_, 'v> {\n             return;\n         };\n \n-        let start_def_id = match self.tcx.lang_items().require(LangItem::Start) {\n-            Ok(s) => s,\n-            Err(lang_item_err) => {\n-                self.tcx\n-                    .sess\n-                    .emit_fatal(RequiresLangItem { lang_item: lang_item_err.0.name().to_string() });\n-            }\n-        };\n+        let start_def_id = self.tcx.require_lang_item(LangItem::Start, None);\n         let main_ret_ty = self.tcx.fn_sig(main_def_id).output();\n \n         // Given that `main()` has no arguments,\n@@ -1343,6 +1336,10 @@ fn create_mono_items_for_default_impls<'tcx>(\n ) {\n     match item.kind {\n         hir::ItemKind::Impl(ref impl_) => {\n+            if matches!(impl_.polarity, hir::ImplPolarity::Negative(_)) {\n+                return;\n+            }\n+\n             for param in impl_.generics.params {\n                 match param.kind {\n                     hir::GenericParamKind::Lifetime { .. } => {}"}, {"sha": "f1ca72de8dbe47d934cc8b8c197c5ed4b4d11ff7", "filename": "compiler/rustc_monomorphize/src/errors.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_monomorphize%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_monomorphize%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Ferrors.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -32,19 +32,14 @@ pub struct TypeLengthLimit {\n     pub type_length: usize,\n }\n \n-#[derive(Diagnostic)]\n-#[diag(monomorphize_requires_lang_item)]\n-pub struct RequiresLangItem {\n-    pub lang_item: String,\n-}\n-\n pub struct UnusedGenericParams {\n     pub span: Span,\n     pub param_spans: Vec<Span>,\n     pub param_names: Vec<String>,\n }\n \n impl IntoDiagnostic<'_> for UnusedGenericParams {\n+    #[track_caller]\n     fn into_diagnostic(\n         self,\n         handler: &'_ rustc_errors::Handler,"}, {"sha": "dc2049028429367100d42c6873efa35e610e0522", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 49, "deletions": 24, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -64,7 +64,7 @@ pub(crate) struct BadQPathStage2 {\n #[diag(parser_incorrect_semicolon)]\n pub(crate) struct IncorrectSemicolon<'a> {\n     #[primary_span]\n-    #[suggestion_short(code = \"\", applicability = \"machine-applicable\")]\n+    #[suggestion(style = \"short\", code = \"\", applicability = \"machine-applicable\")]\n     pub span: Span,\n     #[help]\n     pub opt_help: Option<()>,\n@@ -136,7 +136,12 @@ pub(crate) struct InvalidComparisonOperator {\n \n #[derive(Subdiagnostic)]\n pub(crate) enum InvalidComparisonOperatorSub {\n-    #[suggestion_short(use_instead, applicability = \"machine-applicable\", code = \"{correct}\")]\n+    #[suggestion(\n+        use_instead,\n+        style = \"short\",\n+        applicability = \"machine-applicable\",\n+        code = \"{correct}\"\n+    )]\n     Correctable {\n         #[primary_span]\n         span: Span,\n@@ -160,14 +165,16 @@ pub(crate) struct InvalidLogicalOperator {\n \n #[derive(Subdiagnostic)]\n pub(crate) enum InvalidLogicalOperatorSub {\n-    #[suggestion_short(\n+    #[suggestion(\n         use_amp_amp_for_conjunction,\n+        style = \"short\",\n         applicability = \"machine-applicable\",\n         code = \"&&\"\n     )]\n     Conjunction(#[primary_span] Span),\n-    #[suggestion_short(\n+    #[suggestion(\n         use_pipe_pipe_for_disjunction,\n+        style = \"short\",\n         applicability = \"machine-applicable\",\n         code = \"||\"\n     )]\n@@ -178,7 +185,7 @@ pub(crate) enum InvalidLogicalOperatorSub {\n #[diag(parser_tilde_is_not_unary_operator)]\n pub(crate) struct TildeAsUnaryOperator(\n     #[primary_span]\n-    #[suggestion_short(applicability = \"machine-applicable\", code = \"!\")]\n+    #[suggestion(style = \"short\", applicability = \"machine-applicable\", code = \"!\")]\n     pub Span,\n );\n \n@@ -194,22 +201,25 @@ pub(crate) struct NotAsNegationOperator {\n \n #[derive(Subdiagnostic)]\n pub enum NotAsNegationOperatorSub {\n-    #[suggestion_short(\n+    #[suggestion(\n         parser_unexpected_token_after_not_default,\n+        style = \"short\",\n         applicability = \"machine-applicable\",\n         code = \"!\"\n     )]\n     SuggestNotDefault(#[primary_span] Span),\n \n-    #[suggestion_short(\n+    #[suggestion(\n         parser_unexpected_token_after_not_bitwise,\n+        style = \"short\",\n         applicability = \"machine-applicable\",\n         code = \"!\"\n     )]\n     SuggestNotBitwise(#[primary_span] Span),\n \n-    #[suggestion_short(\n+    #[suggestion(\n         parser_unexpected_token_after_not_logical,\n+        style = \"short\",\n         applicability = \"machine-applicable\",\n         code = \"!\"\n     )]\n@@ -249,7 +259,7 @@ pub(crate) struct UnexpectedTokenAfterLabel {\n     #[primary_span]\n     #[label(parser_unexpected_token_after_label)]\n     pub span: Span,\n-    #[suggestion_verbose(suggestion_remove_label, code = \"\")]\n+    #[suggestion(suggestion_remove_label, style = \"verbose\", code = \"\")]\n     pub remove_label: Option<Span>,\n     #[subdiagnostic]\n     pub enclose_in_block: Option<UnexpectedTokenAfterLabelSugg>,\n@@ -272,7 +282,7 @@ pub(crate) struct RequireColonAfterLabeledExpression {\n     pub span: Span,\n     #[label]\n     pub label: Span,\n-    #[suggestion_short(applicability = \"machine-applicable\", code = \": \")]\n+    #[suggestion(style = \"short\", applicability = \"machine-applicable\", code = \": \")]\n     pub label_end: Span,\n }\n \n@@ -354,7 +364,7 @@ pub(crate) struct IntLiteralTooLarge {\n pub(crate) struct MissingSemicolonBeforeArray {\n     #[primary_span]\n     pub open_delim: Span,\n-    #[suggestion_verbose(applicability = \"maybe-incorrect\", code = \";\")]\n+    #[suggestion(style = \"verbose\", applicability = \"maybe-incorrect\", code = \";\")]\n     pub semicolon: Span,\n }\n \n@@ -442,9 +452,9 @@ pub(crate) struct MissingInInForLoop {\n #[derive(Subdiagnostic)]\n pub(crate) enum MissingInInForLoopSub {\n     // Has been misleading, at least in the past (closed Issue #48492), thus maybe-incorrect\n-    #[suggestion_short(use_in_not_of, applicability = \"maybe-incorrect\", code = \"in\")]\n+    #[suggestion(use_in_not_of, style = \"short\", applicability = \"maybe-incorrect\", code = \"in\")]\n     InNotOf(#[primary_span] Span),\n-    #[suggestion_short(add_in, applicability = \"maybe-incorrect\", code = \" in \")]\n+    #[suggestion(add_in, style = \"short\", applicability = \"maybe-incorrect\", code = \" in \")]\n     AddIn(#[primary_span] Span),\n }\n \n@@ -470,7 +480,7 @@ pub(crate) struct CatchAfterTry {\n pub(crate) struct CommaAfterBaseStruct {\n     #[primary_span]\n     pub span: Span,\n-    #[suggestion_short(applicability = \"machine-applicable\", code = \"\")]\n+    #[suggestion(style = \"short\", applicability = \"machine-applicable\", code = \"\")]\n     pub comma: Span,\n }\n \n@@ -512,15 +522,15 @@ pub(crate) struct RemoveLet {\n #[diag(parser_use_eq_instead)]\n pub(crate) struct UseEqInstead {\n     #[primary_span]\n-    #[suggestion_short(applicability = \"machine-applicable\", code = \"=\")]\n+    #[suggestion(style = \"short\", applicability = \"machine-applicable\", code = \"=\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n #[diag(parser_use_empty_block_not_semi)]\n pub(crate) struct UseEmptyBlockNotSemi {\n     #[primary_span]\n-    #[suggestion_hidden(applicability = \"machine-applicable\", code = \"{{}}\")]\n+    #[suggestion(style = \"hidden\", applicability = \"machine-applicable\", code = \"{{}}\")]\n     pub span: Span,\n }\n \n@@ -576,7 +586,12 @@ pub(crate) struct LeadingPlusNotSupported {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[suggestion_verbose(suggestion_remove_plus, code = \"\", applicability = \"machine-applicable\")]\n+    #[suggestion(\n+        suggestion_remove_plus,\n+        style = \"verbose\",\n+        code = \"\",\n+        applicability = \"machine-applicable\"\n+    )]\n     pub remove_plus: Option<Span>,\n     #[subdiagnostic]\n     pub add_parentheses: Option<ExprParenthesesNeeded>,\n@@ -843,7 +858,7 @@ pub(crate) struct InvalidCurlyInLetElse {\n #[help]\n pub(crate) struct CompoundAssignmentExpressionInLet {\n     #[primary_span]\n-    #[suggestion_short(code = \"=\", applicability = \"maybe-incorrect\")]\n+    #[suggestion(style = \"short\", code = \"=\", applicability = \"maybe-incorrect\")]\n     pub span: Span,\n }\n \n@@ -864,8 +879,9 @@ pub(crate) struct InvalidMetaItem {\n }\n \n #[derive(Subdiagnostic)]\n-#[suggestion_verbose(\n+#[suggestion(\n     parser_sugg_escape_to_use_as_identifier,\n+    style = \"verbose\",\n     applicability = \"maybe-incorrect\",\n     code = \"r#\"\n )]\n@@ -918,6 +934,7 @@ pub(crate) struct ExpectedIdentifier {\n }\n \n impl<'a, G: EmissionGuarantee> IntoDiagnostic<'a, G> for ExpectedIdentifier {\n+    #[track_caller]\n     fn into_diagnostic(\n         self,\n         handler: &'a rustc_errors::Handler,\n@@ -963,6 +980,7 @@ pub(crate) struct ExpectedSemi {\n }\n \n impl<'a, G: EmissionGuarantee> IntoDiagnostic<'a, G> for ExpectedSemi {\n+    #[track_caller]\n     fn into_diagnostic(\n         self,\n         handler: &'a rustc_errors::Handler,\n@@ -1003,7 +1021,12 @@ pub(crate) enum ExpectedSemiSugg {\n         applicability = \"machine-applicable\"\n     )]\n     ChangeToSemi(#[primary_span] Span),\n-    #[suggestion_short(parser_sugg_add_semi, code = \";\", applicability = \"machine-applicable\")]\n+    #[suggestion(\n+        parser_sugg_add_semi,\n+        style = \"short\",\n+        code = \";\",\n+        applicability = \"machine-applicable\"\n+    )]\n     AddSemi(#[primary_span] Span),\n }\n \n@@ -1057,8 +1080,9 @@ pub(crate) struct GenericParamsWithoutAngleBracketsSugg {\n pub(crate) struct ComparisonOperatorsCannotBeChained {\n     #[primary_span]\n     pub span: Vec<Span>,\n-    #[suggestion_verbose(\n+    #[suggestion(\n         parser_sugg_turbofish_syntax,\n+        style = \"verbose\",\n         code = \"::\",\n         applicability = \"maybe-incorrect\"\n     )]\n@@ -1072,8 +1096,9 @@ pub(crate) struct ComparisonOperatorsCannotBeChained {\n \n #[derive(Subdiagnostic)]\n pub(crate) enum ComparisonOperatorsCannotBeChainedSugg {\n-    #[suggestion_verbose(\n+    #[suggestion(\n         sugg_split_comparison,\n+        style = \"verbose\",\n         code = \" && {middle_term}\",\n         applicability = \"maybe-incorrect\"\n     )]\n@@ -1215,15 +1240,15 @@ pub(crate) enum UnexpectedConstParamDeclarationSugg {\n pub(crate) struct UnexpectedConstInGenericParam {\n     #[primary_span]\n     pub span: Span,\n-    #[suggestion_verbose(code = \"\", applicability = \"maybe-incorrect\")]\n+    #[suggestion(style = \"verbose\", code = \"\", applicability = \"maybe-incorrect\")]\n     pub to_remove: Option<Span>,\n }\n \n #[derive(Diagnostic)]\n #[diag(parser_async_move_order_incorrect)]\n pub(crate) struct AsyncMoveOrderIncorrect {\n     #[primary_span]\n-    #[suggestion_verbose(code = \"async move\", applicability = \"maybe-incorrect\")]\n+    #[suggestion(style = \"verbose\", code = \"async move\", applicability = \"maybe-incorrect\")]\n     pub span: Span,\n }\n "}, {"sha": "7dc4fd0044f1ff5d3487fd8d2648e932b8e0df8c", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -769,6 +769,10 @@ impl<'a> Parser<'a> {\n         segment: &PathSegment,\n         end: &[&TokenKind],\n     ) -> bool {\n+        if !self.may_recover() {\n+            return false;\n+        }\n+\n         // This function is intended to be invoked after parsing a path segment where there are two\n         // cases:\n         //\n@@ -863,6 +867,10 @@ impl<'a> Parser<'a> {\n     /// Check if a method call with an intended turbofish has been written without surrounding\n     /// angle brackets.\n     pub(super) fn check_turbofish_missing_angle_brackets(&mut self, segment: &mut PathSegment) {\n+        if !self.may_recover() {\n+            return;\n+        }\n+\n         if token::ModSep == self.token.kind && segment.args.is_none() {\n             let snapshot = self.create_snapshot_for_diagnostic();\n             self.bump();\n@@ -1396,6 +1404,10 @@ impl<'a> Parser<'a> {\n         &mut self,\n         base: P<T>,\n     ) -> PResult<'a, P<T>> {\n+        if !self.may_recover() {\n+            return Ok(base);\n+        }\n+\n         // Do not add `::` to expected tokens.\n         if self.token == token::ModSep {\n             if let Some(ty) = base.to_ty() {"}, {"sha": "0eb633f64168711bef38b86a901bfb207ec04e02", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -132,7 +132,7 @@ impl<'a> Parser<'a> {\n             Ok(expr) => Ok(expr),\n             Err(mut err) => match self.token.ident() {\n                 Some((Ident { name: kw::Underscore, .. }, false))\n-                    if self.look_ahead(1, |t| t == &token::Comma) =>\n+                    if self.may_recover() && self.look_ahead(1, |t| t == &token::Comma) =>\n                 {\n                     // Special-case handling of `foo(_, _, _)`\n                     err.emit();\n@@ -456,15 +456,15 @@ impl<'a> Parser<'a> {\n                 return None;\n             }\n             (Some(op), _) => (op, self.token.span),\n-            (None, Some((Ident { name: sym::and, span }, false))) => {\n+            (None, Some((Ident { name: sym::and, span }, false))) if self.may_recover() => {\n                 self.sess.emit_err(InvalidLogicalOperator {\n                     span: self.token.span,\n                     incorrect: \"and\".into(),\n                     sub: InvalidLogicalOperatorSub::Conjunction(self.token.span),\n                 });\n                 (AssocOp::LAnd, span)\n             }\n-            (None, Some((Ident { name: sym::or, span }, false))) => {\n+            (None, Some((Ident { name: sym::or, span }, false))) if self.may_recover() => {\n                 self.sess.emit_err(InvalidLogicalOperator {\n                     span: self.token.span,\n                     incorrect: \"or\".into(),\n@@ -615,7 +615,7 @@ impl<'a> Parser<'a> {\n             token::Ident(..) if this.token.is_keyword(kw::Box) => {\n                 make_it!(this, attrs, |this, _| this.parse_box_expr(lo))\n             }\n-            token::Ident(..) if this.is_mistaken_not_ident_negation() => {\n+            token::Ident(..) if this.may_recover() && this.is_mistaken_not_ident_negation() => {\n                 make_it!(this, attrs, |this, _| this.recover_not_expr(lo))\n             }\n             _ => return this.parse_dot_or_call_expr(Some(attrs)),\n@@ -718,6 +718,10 @@ impl<'a> Parser<'a> {\n         let cast_expr = match self.parse_as_cast_ty() {\n             Ok(rhs) => mk_expr(self, lhs, rhs),\n             Err(type_err) => {\n+                if !self.may_recover() {\n+                    return Err(type_err);\n+                }\n+\n                 // Rewind to before attempting to parse the type with generics, to recover\n                 // from situations like `x as usize < y` in which we first tried to parse\n                 // `usize < y` as a type with generic arguments.\n@@ -1197,6 +1201,10 @@ impl<'a> Parser<'a> {\n         seq: &mut PResult<'a, P<Expr>>,\n         snapshot: Option<(SnapshotParser<'a>, ExprKind)>,\n     ) -> Option<P<Expr>> {\n+        if !self.may_recover() {\n+            return None;\n+        }\n+\n         match (seq.as_mut(), snapshot) {\n             (Err(err), Some((mut snapshot, ExprKind::Path(None, path)))) => {\n                 snapshot.bump(); // `(`\n@@ -1360,7 +1368,7 @@ impl<'a> Parser<'a> {\n             )\n         } else if self.check_inline_const(0) {\n             self.parse_const_block(lo.to(self.token.span), false)\n-        } else if self.is_do_catch_block() {\n+        } else if self.may_recover() && self.is_do_catch_block() {\n             self.recover_do_catch()\n         } else if self.is_try_block() {\n             self.expect_keyword(kw::Try)?;\n@@ -1532,6 +1540,7 @@ impl<'a> Parser<'a> {\n         {\n             self.parse_block_expr(label, lo, BlockCheckMode::Default)\n         } else if !ate_colon\n+            && self.may_recover()\n             && (matches!(self.token.kind, token::CloseDelim(_) | token::Comma)\n                 || self.token.is_op())\n         {\n@@ -1999,6 +2008,10 @@ impl<'a> Parser<'a> {\n         prev_span: Span,\n         open_delim_span: Span,\n     ) -> PResult<'a, ()> {\n+        if !self.may_recover() {\n+            return Ok(());\n+        }\n+\n         if self.token.kind == token::Comma {\n             if !self.sess.source_map().is_multiline(prev_span.until(self.token.span)) {\n                 return Ok(());\n@@ -2039,7 +2052,7 @@ impl<'a> Parser<'a> {\n         lo: Span,\n         blk_mode: BlockCheckMode,\n     ) -> PResult<'a, P<Expr>> {\n-        if self.is_array_like_block() {\n+        if self.may_recover() && self.is_array_like_block() {\n             if let Some(arr) = self.maybe_suggest_brackets_instead_of_braces(lo) {\n                 return Ok(arr);\n             }"}, {"sha": "2e59c005e315ae21e5bfa0510fe11545a20cfa6f", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -104,6 +104,7 @@ macro_rules! maybe_whole {\n macro_rules! maybe_recover_from_interpolated_ty_qpath {\n     ($self: expr, $allow_qpath_recovery: expr) => {\n         if $allow_qpath_recovery\n+                    && $self.may_recover()\n                     && $self.look_ahead(1, |t| t == &token::ModSep)\n                     && let token::Interpolated(nt) = &$self.token.kind\n                     && let token::NtTy(ty) = &**nt"}, {"sha": "21b487d8ca1e7213dd75b767fe50b79dbeab38a9", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 84, "deletions": 96, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -4,7 +4,7 @@\n \n use itertools::Itertools;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::{pluralize, Applicability, MultiSpan};\n+use rustc_errors::MultiSpan;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -18,7 +18,10 @@ use rustc_session::lint;\n use rustc_span::symbol::{sym, Symbol};\n use std::mem;\n \n-use crate::errors::UselessAssignment;\n+use crate::errors::{\n+    ChangeFieldsToBeOfUnitType, IgnoredDerivedImpls, MultipleDeadCodes, ParentInfo,\n+    UselessAssignment,\n+};\n \n // Any local node that may call something in its body block should be\n // explored. For example, if it's a live Node::Item that is a\n@@ -470,11 +473,6 @@ fn has_allow_dead_code_or_lang_attr_helper(\n         return true;\n     }\n \n-    // (To be) stable attribute for #[lang = \"oom\"]\n-    if tcx.sess.contains_name(attrs, sym::alloc_error_handler) {\n-        return true;\n-    }\n-\n     let def_id = tcx.hir().local_def_id(id);\n     if tcx.def_kind(def_id).has_codegen_attrs() {\n         let cg_attrs = tcx.codegen_fn_attrs(def_id);\n@@ -698,99 +696,89 @@ impl<'tcx> DeadVisitor<'tcx> {\n         parent_item: Option<LocalDefId>,\n         is_positional: bool,\n     ) {\n-        if let Some(&first_id) = dead_codes.first() {\n-            let tcx = self.tcx;\n-            let names: Vec<_> = dead_codes\n-                .iter()\n-                .map(|&def_id| tcx.item_name(def_id.to_def_id()).to_string())\n-                .collect();\n-            let spans: Vec<_> = dead_codes\n-                .iter()\n-                .map(|&def_id| match tcx.def_ident_span(def_id) {\n-                    Some(s) => s.with_ctxt(tcx.def_span(def_id).ctxt()),\n-                    None => tcx.def_span(def_id),\n+        let Some(&first_id) = dead_codes.first() else {\n+            return;\n+        };\n+        let tcx = self.tcx;\n+        let names: Vec<_> =\n+            dead_codes.iter().map(|&def_id| tcx.item_name(def_id.to_def_id())).collect();\n+        let spans: Vec<_> = dead_codes\n+            .iter()\n+            .map(|&def_id| match tcx.def_ident_span(def_id) {\n+                Some(s) => s.with_ctxt(tcx.def_span(def_id).ctxt()),\n+                None => tcx.def_span(def_id),\n+            })\n+            .collect();\n+\n+        let descr = tcx.def_kind(first_id).descr(first_id.to_def_id());\n+        let num = dead_codes.len();\n+        let multiple = num > 6;\n+        let name_list = names.into();\n+\n+        let lint = if is_positional {\n+            lint::builtin::UNUSED_TUPLE_STRUCT_FIELDS\n+        } else {\n+            lint::builtin::DEAD_CODE\n+        };\n+\n+        let parent_info = if let Some(parent_item) = parent_item {\n+            let parent_descr = tcx.def_kind(parent_item).descr(parent_item.to_def_id());\n+            Some(ParentInfo {\n+                num,\n+                descr,\n+                parent_descr,\n+                span: tcx.def_ident_span(parent_item).unwrap(),\n+            })\n+        } else {\n+            None\n+        };\n+\n+        let encl_def_id = parent_item.unwrap_or(first_id);\n+        let ignored_derived_impls =\n+            if let Some(ign_traits) = self.ignored_derived_traits.get(&encl_def_id) {\n+                let trait_list = ign_traits\n+                    .iter()\n+                    .map(|(trait_id, _)| self.tcx.item_name(*trait_id))\n+                    .collect::<Vec<_>>();\n+                let trait_list_len = trait_list.len();\n+                Some(IgnoredDerivedImpls {\n+                    name: self.tcx.item_name(encl_def_id.to_def_id()),\n+                    trait_list: trait_list.into(),\n+                    trait_list_len,\n                 })\n-                .collect();\n-\n-            let descr = tcx.def_kind(first_id).descr(first_id.to_def_id());\n-            let span_len = dead_codes.len();\n-            let names = match &names[..] {\n-                _ if span_len > 6 => String::new(),\n-                [name] => format!(\"`{name}` \"),\n-                [names @ .., last] => {\n-                    format!(\n-                        \"{} and `{last}` \",\n-                        names.iter().map(|name| format!(\"`{name}`\")).join(\", \")\n-                    )\n-                }\n-                [] => unreachable!(),\n+            } else {\n+                None\n             };\n-            let msg = format!(\n-                \"{these}{descr}{s} {names}{are} never {participle}\",\n-                these = if span_len > 6 { \"multiple \" } else { \"\" },\n-                s = pluralize!(span_len),\n-                are = pluralize!(\"is\", span_len),\n-            );\n-\n-            tcx.struct_span_lint_hir(\n-                if is_positional {\n-                    lint::builtin::UNUSED_TUPLE_STRUCT_FIELDS\n-                } else {\n-                    lint::builtin::DEAD_CODE\n-                },\n-                tcx.hir().local_def_id_to_hir_id(first_id),\n-                MultiSpan::from_spans(spans.clone()),\n-                msg,\n-                |err| {\n-                    if is_positional {\n-                        err.multipart_suggestion(\n-                            &format!(\n-                                \"consider changing the field{s} to be of unit type to \\\n-                                      suppress this warning while preserving the field \\\n-                                      numbering, or remove the field{s}\",\n-                                s = pluralize!(span_len)\n-                            ),\n-                            spans.iter().map(|sp| (*sp, \"()\".to_string())).collect(),\n-                            // \"HasPlaceholders\" because applying this fix by itself isn't\n-                            // enough: All constructor calls have to be adjusted as well\n-                            Applicability::HasPlaceholders,\n-                        );\n-                    }\n \n-                    if let Some(parent_item) = parent_item {\n-                        let parent_descr = tcx.def_kind(parent_item).descr(parent_item.to_def_id());\n-                        err.span_label(\n-                            tcx.def_ident_span(parent_item).unwrap(),\n-                            format!(\"{descr}{s} in this {parent_descr}\", s = pluralize!(span_len)),\n-                        );\n-                    }\n+        let diag = if is_positional {\n+            MultipleDeadCodes::UnusedTupleStructFields {\n+                multiple,\n+                num,\n+                descr,\n+                participle,\n+                name_list,\n+                change_fields_suggestion: ChangeFieldsToBeOfUnitType { num, spans: spans.clone() },\n+                parent_info,\n+                ignored_derived_impls,\n+            }\n+        } else {\n+            MultipleDeadCodes::DeadCodes {\n+                multiple,\n+                num,\n+                descr,\n+                participle,\n+                name_list,\n+                parent_info,\n+                ignored_derived_impls,\n+            }\n+        };\n \n-                    let encl_def_id = parent_item.unwrap_or(first_id);\n-                    if let Some(ign_traits) = self.ignored_derived_traits.get(&encl_def_id) {\n-                        let traits_str = ign_traits\n-                            .iter()\n-                            .map(|(trait_id, _)| format!(\"`{}`\", self.tcx.item_name(*trait_id)))\n-                            .collect::<Vec<_>>()\n-                            .join(\" and \");\n-                        let plural_s = pluralize!(ign_traits.len());\n-                        let article = if ign_traits.len() > 1 { \"\" } else { \"a \" };\n-                        let is_are = if ign_traits.len() > 1 { \"these are\" } else { \"this is\" };\n-                        let msg = format!(\n-                            \"`{}` has {}derived impl{} for the trait{} {}, but {} \\\n-                            intentionally ignored during dead code analysis\",\n-                            self.tcx.item_name(encl_def_id.to_def_id()),\n-                            article,\n-                            plural_s,\n-                            plural_s,\n-                            traits_str,\n-                            is_are\n-                        );\n-                        err.note(&msg);\n-                    }\n-                    err\n-                },\n-            );\n-        }\n+        self.tcx.emit_spanned_lint(\n+            lint,\n+            tcx.hir().local_def_id_to_hir_id(first_id),\n+            MultiSpan::from_spans(spans.clone()),\n+            diag,\n+        );\n     }\n \n     fn warn_dead_fields_and_variants("}, {"sha": "1dbf0d642e2afdbbea56d0d49801ace8fb040199", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 66, "deletions": 10, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -4,7 +4,9 @@ use std::{\n };\n \n use rustc_ast::Label;\n-use rustc_errors::{error_code, Applicability, ErrorGuaranteed, IntoDiagnostic, MultiSpan};\n+use rustc_errors::{\n+    error_code, Applicability, DiagnosticSymbolList, ErrorGuaranteed, IntoDiagnostic, MultiSpan,\n+};\n use rustc_hir::{self as hir, ExprKind, Target};\n use rustc_macros::{Diagnostic, LintDiagnostic, Subdiagnostic};\n use rustc_middle::ty::{MainDefinition, Ty};\n@@ -291,7 +293,7 @@ pub struct DocTestUnknownAny {\n #[note(no_op_note)]\n pub struct DocTestUnknownSpotlight {\n     pub path: String,\n-    #[suggestion_short(applicability = \"machine-applicable\", code = \"notable_trait\")]\n+    #[suggestion(style = \"short\", applicability = \"machine-applicable\", code = \"notable_trait\")]\n     pub span: Span,\n }\n \n@@ -701,14 +703,6 @@ pub struct UnknownExternLangItem {\n #[diag(passes_missing_panic_handler)]\n pub struct MissingPanicHandler;\n \n-#[derive(Diagnostic)]\n-#[diag(passes_alloc_func_required)]\n-pub struct AllocFuncRequired;\n-\n-#[derive(Diagnostic)]\n-#[diag(passes_missing_alloc_error_handler)]\n-pub struct MissingAllocErrorHandler;\n-\n #[derive(Diagnostic)]\n #[diag(passes_missing_lang_item)]\n #[note]\n@@ -744,6 +738,7 @@ pub struct InvalidAttrAtCrateLevel {\n }\n \n impl IntoDiagnostic<'_> for InvalidAttrAtCrateLevel {\n+    #[track_caller]\n     fn into_diagnostic(\n         self,\n         handler: &'_ rustc_errors::Handler,\n@@ -876,6 +871,7 @@ pub struct BreakNonLoop<'a> {\n }\n \n impl<'a> IntoDiagnostic<'_> for BreakNonLoop<'a> {\n+    #[track_caller]\n     fn into_diagnostic(\n         self,\n         handler: &rustc_errors::Handler,\n@@ -960,6 +956,7 @@ pub struct OutsideLoop<'a> {\n     #[label]\n     pub span: Span,\n     pub name: &'a str,\n+    pub is_break: bool,\n }\n \n #[derive(Diagnostic)]\n@@ -1013,6 +1010,7 @@ pub struct NakedFunctionsAsmBlock {\n }\n \n impl IntoDiagnostic<'_> for NakedFunctionsAsmBlock {\n+    #[track_caller]\n     fn into_diagnostic(\n         self,\n         handler: &rustc_errors::Handler,\n@@ -1136,6 +1134,7 @@ pub struct NoMainErr {\n }\n \n impl<'a> IntoDiagnostic<'a> for NoMainErr {\n+    #[track_caller]\n     fn into_diagnostic(\n         self,\n         handler: &'a rustc_errors::Handler,\n@@ -1196,6 +1195,7 @@ pub struct DuplicateLangItem {\n }\n \n impl IntoDiagnostic<'_> for DuplicateLangItem {\n+    #[track_caller]\n     fn into_diagnostic(\n         self,\n         handler: &rustc_errors::Handler,\n@@ -1449,3 +1449,59 @@ pub struct MissingConstErr {\n     #[label]\n     pub const_span: Span,\n }\n+\n+#[derive(LintDiagnostic)]\n+pub enum MultipleDeadCodes<'tcx> {\n+    #[diag(passes_dead_codes)]\n+    DeadCodes {\n+        multiple: bool,\n+        num: usize,\n+        descr: &'tcx str,\n+        participle: &'tcx str,\n+        name_list: DiagnosticSymbolList,\n+        #[subdiagnostic]\n+        parent_info: Option<ParentInfo<'tcx>>,\n+        #[subdiagnostic]\n+        ignored_derived_impls: Option<IgnoredDerivedImpls>,\n+    },\n+    #[diag(passes_dead_codes)]\n+    UnusedTupleStructFields {\n+        multiple: bool,\n+        num: usize,\n+        descr: &'tcx str,\n+        participle: &'tcx str,\n+        name_list: DiagnosticSymbolList,\n+        #[subdiagnostic]\n+        change_fields_suggestion: ChangeFieldsToBeOfUnitType,\n+        #[subdiagnostic]\n+        parent_info: Option<ParentInfo<'tcx>>,\n+        #[subdiagnostic]\n+        ignored_derived_impls: Option<IgnoredDerivedImpls>,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[label(passes_parent_info)]\n+pub struct ParentInfo<'tcx> {\n+    pub num: usize,\n+    pub descr: &'tcx str,\n+    pub parent_descr: &'tcx str,\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[note(passes_ignored_derived_impls)]\n+pub struct IgnoredDerivedImpls {\n+    pub name: Symbol,\n+    pub trait_list: DiagnosticSymbolList,\n+    pub trait_list_len: usize,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(passes_change_fields_to_be_of_unit_type, applicability = \"has-placeholders\")]\n+pub struct ChangeFieldsToBeOfUnitType {\n+    pub num: usize,\n+    #[suggestion_part(code = \"()\")]\n+    pub spans: Vec<Span>,\n+}"}, {"sha": "188efc528ef82361b6800fca4cb86a6956dd661a", "filename": "compiler/rustc_passes/src/lang_items.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -16,7 +16,7 @@ use crate::weak_lang_items;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::lang_items::{extract, GenericRequirement, ITEM_REFS};\n+use rustc_hir::lang_items::{extract, GenericRequirement};\n use rustc_hir::{HirId, LangItem, LanguageItems, Target};\n use rustc_middle::ty::TyCtxt;\n use rustc_session::cstore::ExternCrate;\n@@ -43,17 +43,17 @@ impl<'tcx> LanguageItemCollector<'tcx> {\n     fn check_for_lang(&mut self, actual_target: Target, hir_id: HirId) {\n         let attrs = self.tcx.hir().attrs(hir_id);\n         if let Some((name, span)) = extract(&attrs) {\n-            match ITEM_REFS.get(&name).cloned() {\n+            match LangItem::from_name(name) {\n                 // Known lang item with attribute on correct target.\n-                Some((item_index, expected_target)) if actual_target == expected_target => {\n-                    self.collect_item_extended(item_index, hir_id, span);\n+                Some(lang_item) if actual_target == lang_item.target() => {\n+                    self.collect_item_extended(lang_item, hir_id, span);\n                 }\n                 // Known lang item with attribute on incorrect target.\n-                Some((_, expected_target)) => {\n+                Some(lang_item) => {\n                     self.tcx.sess.emit_err(LangItemOnIncorrectTarget {\n                         span,\n                         name,\n-                        expected_target,\n+                        expected_target: lang_item.target(),\n                         actual_target,\n                     });\n                 }\n@@ -65,12 +65,12 @@ impl<'tcx> LanguageItemCollector<'tcx> {\n         }\n     }\n \n-    fn collect_item(&mut self, item_index: usize, item_def_id: DefId) {\n+    fn collect_item(&mut self, lang_item: LangItem, item_def_id: DefId) {\n         // Check for duplicates.\n-        if let Some(original_def_id) = self.items.items[item_index] {\n+        if let Some(original_def_id) = self.items.get(lang_item) {\n             if original_def_id != item_def_id {\n                 let local_span = self.tcx.hir().span_if_local(item_def_id);\n-                let lang_item_name = LangItem::from_u32(item_index as u32).unwrap().name();\n+                let lang_item_name = lang_item.name();\n                 let crate_name = self.tcx.crate_name(item_def_id.krate);\n                 let mut dependency_of = Empty;\n                 let is_local = item_def_id.is_local();\n@@ -139,17 +139,13 @@ impl<'tcx> LanguageItemCollector<'tcx> {\n         }\n \n         // Matched.\n-        self.items.items[item_index] = Some(item_def_id);\n-        if let Some(group) = LangItem::from_u32(item_index as u32).unwrap().group() {\n-            self.items.groups[group as usize].push(item_def_id);\n-        }\n+        self.items.set(lang_item, item_def_id);\n     }\n \n     // Like collect_item() above, but also checks whether the lang item is declared\n     // with the right number of generic arguments.\n-    fn collect_item_extended(&mut self, item_index: usize, hir_id: HirId, span: Span) {\n+    fn collect_item_extended(&mut self, lang_item: LangItem, hir_id: HirId, span: Span) {\n         let item_def_id = self.tcx.hir().local_def_id(hir_id).to_def_id();\n-        let lang_item = LangItem::from_u32(item_index as u32).unwrap();\n         let name = lang_item.name();\n \n         // Now check whether the lang_item has the expected number of generic\n@@ -197,7 +193,7 @@ impl<'tcx> LanguageItemCollector<'tcx> {\n             }\n         }\n \n-        self.collect_item(item_index, item_def_id);\n+        self.collect_item(lang_item, item_def_id);\n     }\n }\n \n@@ -208,8 +204,8 @@ fn get_lang_items(tcx: TyCtxt<'_>, (): ()) -> LanguageItems {\n \n     // Collect lang items in other crates.\n     for &cnum in tcx.crates(()).iter() {\n-        for &(def_id, item_index) in tcx.defined_lang_items(cnum).iter() {\n-            collector.collect_item(item_index, def_id);\n+        for &(def_id, lang_item) in tcx.defined_lang_items(cnum).iter() {\n+            collector.collect_item(lang_item, def_id);\n         }\n     }\n "}, {"sha": "b4cf19e4a34f6ad2b46ad8bc48ed351153a0b333", "filename": "compiler/rustc_passes/src/loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_passes%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_passes%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Floops.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -193,7 +193,7 @@ impl<'a, 'hir> CheckLoopVisitor<'a, 'hir> {\n                 self.sess.emit_err(BreakInsideAsyncBlock { span, closure_span, name });\n             }\n             Normal | AnonConst => {\n-                self.sess.emit_err(OutsideLoop { span, name });\n+                self.sess.emit_err(OutsideLoop { span, name, is_break: name == \"break\" });\n             }\n         }\n     }"}, {"sha": "73ea06a6370d420a9d9eeef5b79ffcdc744ce75b", "filename": "compiler/rustc_passes/src/reachable.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Freachable.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -380,11 +380,9 @@ fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, (): ()) -> FxHashSet<LocalDefId> {\n         })\n         .collect::<Vec<_>>();\n \n-    for item in tcx.lang_items().items().iter() {\n-        if let Some(def_id) = *item {\n-            if let Some(def_id) = def_id.as_local() {\n-                reachable_context.worklist.push(def_id);\n-            }\n+    for (_, def_id) in tcx.lang_items().iter() {\n+        if let Some(def_id) = def_id.as_local() {\n+            reachable_context.worklist.push(def_id);\n         }\n     }\n     {"}, {"sha": "f0815fcd8db9a6de59b633dcdb12368d05e6bd1d", "filename": "compiler/rustc_passes/src/weak_lang_items.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -2,15 +2,12 @@\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::lang_items::{self, LangItem};\n-use rustc_hir::weak_lang_items::WEAK_ITEMS_REFS;\n+use rustc_hir::weak_lang_items::WEAK_LANG_ITEMS;\n use rustc_middle::middle::lang_items::required;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::CrateType;\n \n-use crate::errors::{\n-    AllocFuncRequired, MissingAllocErrorHandler, MissingLangItem, MissingPanicHandler,\n-    UnknownExternLangItem,\n-};\n+use crate::errors::{MissingLangItem, MissingPanicHandler, UnknownExternLangItem};\n \n /// Checks the crate for usage of weak lang items, returning a vector of all the\n /// language items required by this crate, but not defined yet.\n@@ -29,8 +26,8 @@ pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx>, items: &mut lang_items::LanguageItem\n     for id in crate_items.foreign_items() {\n         let attrs = tcx.hir().attrs(id.hir_id());\n         if let Some((lang_item, _)) = lang_items::extract(attrs) {\n-            if let Some(&item) = WEAK_ITEMS_REFS.get(&lang_item) {\n-                if items.require(item).is_err() {\n+            if let Some(item) = LangItem::from_name(lang_item) && item.is_weak() {\n+                if items.get(item).is_none() {\n                     items.missing.push(item);\n                 }\n             } else {\n@@ -65,17 +62,12 @@ fn verify<'tcx>(tcx: TyCtxt<'tcx>, items: &lang_items::LanguageItems) {\n         }\n     }\n \n-    for (name, &item) in WEAK_ITEMS_REFS.iter() {\n-        if missing.contains(&item) && required(tcx, item) && items.require(item).is_err() {\n+    for &item in WEAK_LANG_ITEMS.iter() {\n+        if missing.contains(&item) && required(tcx, item) && items.get(item).is_none() {\n             if item == LangItem::PanicImpl {\n                 tcx.sess.emit_err(MissingPanicHandler);\n-            } else if item == LangItem::Oom {\n-                if !tcx.features().default_alloc_error_handler {\n-                    tcx.sess.emit_err(AllocFuncRequired);\n-                    tcx.sess.emit_note(MissingAllocErrorHandler);\n-                }\n             } else {\n-                tcx.sess.emit_err(MissingLangItem { name: *name });\n+                tcx.sess.emit_err(MissingLangItem { name: item.name() });\n             }\n         }\n     }"}, {"sha": "b2111a1262a3cd9c82d9e11d7bd53f6ff5cf35dd", "filename": "compiler/rustc_query_impl/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_query_impl%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_query_impl%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2FCargo.toml?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -21,7 +21,7 @@ rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }\n-thin-vec = \"0.2.8\"\n+thin-vec = \"0.2.9\"\n tracing = \"0.1\"\n \n [features]"}, {"sha": "028756b5a0a18d1ea3cce2b42440872ae40f5543", "filename": "compiler/rustc_query_system/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_query_system%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_query_system%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2FCargo.toml?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -22,7 +22,7 @@ rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_type_ir = { path = \"../rustc_type_ir\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n-thin-vec = \"0.2.8\"\n+thin-vec = \"0.2.9\"\n tracing = \"0.1\"\n \n [features]"}, {"sha": "423c57275333a2c355020942ecfb383816b8f24b", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 22, "deletions": 33, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -56,21 +56,7 @@ impl<'a, Id: Into<DefId>> ToNameBinding<'a>\n impl<'a, Id: Into<DefId>> ToNameBinding<'a> for (Res, ty::Visibility<Id>, Span, LocalExpnId) {\n     fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n         arenas.alloc_name_binding(NameBinding {\n-            kind: NameBindingKind::Res(self.0, false),\n-            ambiguity: None,\n-            vis: self.1.to_def_id(),\n-            span: self.2,\n-            expansion: self.3,\n-        })\n-    }\n-}\n-\n-struct IsMacroExport;\n-\n-impl<'a> ToNameBinding<'a> for (Res, ty::Visibility, Span, LocalExpnId, IsMacroExport) {\n-    fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n-        arenas.alloc_name_binding(NameBinding {\n-            kind: NameBindingKind::Res(self.0, true),\n+            kind: NameBindingKind::Res(self.0),\n             ambiguity: None,\n             vis: self.1.to_def_id(),\n             span: self.2,\n@@ -364,7 +350,6 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         module_path: Vec<Segment>,\n         kind: ImportKind<'a>,\n         span: Span,\n-        id: NodeId,\n         item: &ast::Item,\n         root_span: Span,\n         root_id: NodeId,\n@@ -377,7 +362,6 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             module_path,\n             imported_module: Cell::new(None),\n             span,\n-            id,\n             use_span: item.span,\n             use_span_with_attributes: item.span_with_attributes(),\n             has_attributes: !item.attrs.is_empty(),\n@@ -574,27 +558,20 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     },\n                     type_ns_only,\n                     nested,\n+                    id,\n                     additional_ids: (id1, id2),\n                 };\n \n-                self.add_import(\n-                    module_path,\n-                    kind,\n-                    use_tree.span,\n-                    id,\n-                    item,\n-                    root_span,\n-                    item.id,\n-                    vis,\n-                );\n+                self.add_import(module_path, kind, use_tree.span, item, root_span, item.id, vis);\n             }\n             ast::UseTreeKind::Glob => {\n                 let kind = ImportKind::Glob {\n                     is_prelude: self.r.session.contains_name(&item.attrs, sym::prelude_import),\n                     max_vis: Cell::new(None),\n+                    id,\n                 };\n                 self.r.visibilities.insert(self.r.local_def_id(id), vis);\n-                self.add_import(prefix, kind, use_tree.span, id, item, root_span, item.id, vis);\n+                self.add_import(prefix, kind, use_tree.span, item, root_span, item.id, vis);\n             }\n             ast::UseTreeKind::Nested(ref items) => {\n                 // Ensure there is at most one `self` in the list\n@@ -881,9 +858,8 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         })\n         .unwrap_or((true, None, self.r.dummy_binding));\n         let import = self.r.arenas.alloc_import(Import {\n-            kind: ImportKind::ExternCrate { source: orig_name, target: ident },\n+            kind: ImportKind::ExternCrate { source: orig_name, target: ident, id: item.id },\n             root_id: item.id,\n-            id: item.id,\n             parent_scope: self.parent_scope,\n             imported_module: Cell::new(module),\n             has_attributes: !item.attrs.is_empty(),\n@@ -1118,7 +1094,6 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             this.r.arenas.alloc_import(Import {\n                 kind: ImportKind::MacroUse,\n                 root_id: item.id,\n-                id: item.id,\n                 parent_scope: this.parent_scope,\n                 imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n                 use_span_with_attributes: item.span_with_attributes(),\n@@ -1278,8 +1253,22 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             let binding = (res, vis, span, expansion).to_name_binding(self.r.arenas);\n             self.r.set_binding_parent_module(binding, parent_scope.module);\n             if is_macro_export {\n-                let module = self.r.graph_root;\n-                self.r.define(module, ident, MacroNS, (res, vis, span, expansion, IsMacroExport));\n+                let import = self.r.arenas.alloc_import(Import {\n+                    kind: ImportKind::MacroExport,\n+                    root_id: item.id,\n+                    parent_scope: self.parent_scope,\n+                    imported_module: Cell::new(None),\n+                    has_attributes: false,\n+                    use_span_with_attributes: span,\n+                    use_span: span,\n+                    root_span: span,\n+                    span: span,\n+                    module_path: Vec::new(),\n+                    vis: Cell::new(Some(vis)),\n+                    used: Cell::new(true),\n+                });\n+                let import_binding = self.r.import(binding, import);\n+                self.r.define(self.r.graph_root, ident, MacroNS, import_binding);\n             } else {\n                 self.r.check_reserved_macro_name(ident, res);\n                 self.insert_unused_macro(ident, def_id, item.id, &rule_spans);"}, {"sha": "32fb5e18276ab86fe721f533c56d88871cb2e44c", "filename": "compiler/rustc_resolve/src/check_unused.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -234,7 +234,7 @@ impl Resolver<'_> {\n                         if !import.span.is_dummy() {\n                             self.lint_buffer.buffer_lint(\n                                 MACRO_USE_EXTERN_CRATE,\n-                                import.id,\n+                                import.root_id,\n                                 import.span,\n                                 \"deprecated `#[macro_use]` attribute used to \\\n                                 import macros should be replaced at use sites \\\n@@ -244,13 +244,13 @@ impl Resolver<'_> {\n                         }\n                     }\n                 }\n-                ImportKind::ExternCrate { .. } => {\n-                    let def_id = self.local_def_id(import.id);\n+                ImportKind::ExternCrate { id, .. } => {\n+                    let def_id = self.local_def_id(id);\n                     self.maybe_unused_extern_crates.push((def_id, import.span));\n                 }\n                 ImportKind::MacroUse => {\n                     let msg = \"unused `#[macro_use]` import\";\n-                    self.lint_buffer.buffer_lint(UNUSED_IMPORTS, import.id, import.span, msg);\n+                    self.lint_buffer.buffer_lint(UNUSED_IMPORTS, import.root_id, import.span, msg);\n                 }\n                 _ => {}\n             }"}, {"sha": "7961e3f1194e1ab7743fc31d70ddec84dc2f36e3", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 53, "deletions": 30, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -58,16 +58,32 @@ pub(crate) enum SuggestionTarget {\n #[derive(Debug)]\n pub(crate) struct TypoSuggestion {\n     pub candidate: Symbol,\n+    /// The source location where the name is defined; None if the name is not defined\n+    /// in source e.g. primitives\n+    pub span: Option<Span>,\n     pub res: Res,\n     pub target: SuggestionTarget,\n }\n \n impl TypoSuggestion {\n-    pub(crate) fn typo_from_res(candidate: Symbol, res: Res) -> TypoSuggestion {\n-        Self { candidate, res, target: SuggestionTarget::SimilarlyNamed }\n+    pub(crate) fn typo_from_ident(ident: Ident, res: Res) -> TypoSuggestion {\n+        Self {\n+            candidate: ident.name,\n+            span: Some(ident.span),\n+            res,\n+            target: SuggestionTarget::SimilarlyNamed,\n+        }\n+    }\n+    pub(crate) fn typo_from_name(candidate: Symbol, res: Res) -> TypoSuggestion {\n+        Self { candidate, span: None, res, target: SuggestionTarget::SimilarlyNamed }\n     }\n-    pub(crate) fn single_item_from_res(candidate: Symbol, res: Res) -> TypoSuggestion {\n-        Self { candidate, res, target: SuggestionTarget::SingleItem }\n+    pub(crate) fn single_item_from_ident(ident: Ident, res: Res) -> TypoSuggestion {\n+        Self {\n+            candidate: ident.name,\n+            span: Some(ident.span),\n+            res,\n+            target: SuggestionTarget::SingleItem,\n+        }\n     }\n }\n \n@@ -174,12 +190,12 @@ impl<'a> Resolver<'a> {\n             ModuleKind::Block => \"block\",\n         };\n \n-        let old_noun = match old_binding.is_import() {\n+        let old_noun = match old_binding.is_import_user_facing() {\n             true => \"import\",\n             false => \"definition\",\n         };\n \n-        let new_participle = match new_binding.is_import() {\n+        let new_participle = match new_binding.is_import_user_facing() {\n             true => \"imported\",\n             false => \"defined\",\n         };\n@@ -210,7 +226,7 @@ impl<'a> Resolver<'a> {\n                 true => struct_span_err!(self.session, span, E0254, \"{}\", msg),\n                 false => struct_span_err!(self.session, span, E0260, \"{}\", msg),\n             },\n-            _ => match (old_binding.is_import(), new_binding.is_import()) {\n+            _ => match (old_binding.is_import_user_facing(), new_binding.is_import_user_facing()) {\n                 (false, false) => struct_span_err!(self.session, span, E0428, \"{}\", msg),\n                 (true, true) => struct_span_err!(self.session, span, E0252, \"{}\", msg),\n                 _ => struct_span_err!(self.session, span, E0255, \"{}\", msg),\n@@ -232,14 +248,18 @@ impl<'a> Resolver<'a> {\n \n         // See https://github.com/rust-lang/rust/issues/32354\n         use NameBindingKind::Import;\n+        let can_suggest = |binding: &NameBinding<'_>, import: &self::Import<'_>| {\n+            !binding.span.is_dummy()\n+                && !matches!(import.kind, ImportKind::MacroUse | ImportKind::MacroExport)\n+        };\n         let import = match (&new_binding.kind, &old_binding.kind) {\n             // If there are two imports where one or both have attributes then prefer removing the\n             // import without attributes.\n             (Import { import: new, .. }, Import { import: old, .. })\n                 if {\n-                    !new_binding.span.is_dummy()\n-                        && !old_binding.span.is_dummy()\n-                        && (new.has_attributes || old.has_attributes)\n+                    (new.has_attributes || old.has_attributes)\n+                        && can_suggest(old_binding, old)\n+                        && can_suggest(new_binding, new)\n                 } =>\n             {\n                 if old.has_attributes {\n@@ -249,10 +269,10 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n             // Otherwise prioritize the new binding.\n-            (Import { import, .. }, other) if !new_binding.span.is_dummy() => {\n+            (Import { import, .. }, other) if can_suggest(new_binding, import) => {\n                 Some((import, new_binding.span, other.is_import()))\n             }\n-            (other, Import { import, .. }) if !old_binding.span.is_dummy() => {\n+            (other, Import { import, .. }) if can_suggest(old_binding, import) => {\n                 Some((import, old_binding.span, other.is_import()))\n             }\n             _ => None,\n@@ -337,7 +357,7 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n             }\n-            ImportKind::ExternCrate { source, target } => {\n+            ImportKind::ExternCrate { source, target, .. } => {\n                 suggestion = Some(format!(\n                     \"extern crate {} as {};\",\n                     source.unwrap_or(target.name),\n@@ -490,7 +510,7 @@ impl<'a> Resolver<'a> {\n             if let Some(binding) = resolution.borrow().binding {\n                 let res = binding.res();\n                 if filter_fn(res) && ctxt.map_or(true, |ctxt| ctxt == key.ident.span.ctxt()) {\n-                    names.push(TypoSuggestion::typo_from_res(key.ident.name, res));\n+                    names.push(TypoSuggestion::typo_from_ident(key.ident, res));\n                 }\n             }\n         }\n@@ -1145,7 +1165,7 @@ impl<'a> Resolver<'a> {\n                                 .get(&expn_id)\n                                 .into_iter()\n                                 .flatten()\n-                                .map(|ident| TypoSuggestion::typo_from_res(ident.name, res)),\n+                                .map(|ident| TypoSuggestion::typo_from_ident(*ident, res)),\n                         );\n                     }\n                 }\n@@ -1164,7 +1184,7 @@ impl<'a> Resolver<'a> {\n                                 suggestions.extend(\n                                     ext.helper_attrs\n                                         .iter()\n-                                        .map(|name| TypoSuggestion::typo_from_res(*name, res)),\n+                                        .map(|name| TypoSuggestion::typo_from_name(*name, res)),\n                                 );\n                             }\n                         }\n@@ -1174,8 +1194,8 @@ impl<'a> Resolver<'a> {\n                     if let MacroRulesScope::Binding(macro_rules_binding) = macro_rules_scope.get() {\n                         let res = macro_rules_binding.binding.res();\n                         if filter_fn(res) {\n-                            suggestions.push(TypoSuggestion::typo_from_res(\n-                                macro_rules_binding.ident.name,\n+                            suggestions.push(TypoSuggestion::typo_from_ident(\n+                                macro_rules_binding.ident,\n                                 res,\n                             ))\n                         }\n@@ -1186,14 +1206,14 @@ impl<'a> Resolver<'a> {\n                     let root_module = this.resolve_crate_root(root_ident);\n                     this.add_module_candidates(root_module, &mut suggestions, filter_fn, None);\n                 }\n-                Scope::Module(module, _) => {\n+                Scope::Module(module) => {\n                     this.add_module_candidates(module, &mut suggestions, filter_fn, None);\n                 }\n                 Scope::MacroUsePrelude => {\n                     suggestions.extend(this.macro_use_prelude.iter().filter_map(\n                         |(name, binding)| {\n                             let res = binding.res();\n-                            filter_fn(res).then_some(TypoSuggestion::typo_from_res(*name, res))\n+                            filter_fn(res).then_some(TypoSuggestion::typo_from_name(*name, res))\n                         },\n                     ));\n                 }\n@@ -1203,22 +1223,22 @@ impl<'a> Resolver<'a> {\n                         suggestions.extend(\n                             BUILTIN_ATTRIBUTES\n                                 .iter()\n-                                .map(|attr| TypoSuggestion::typo_from_res(attr.name, res)),\n+                                .map(|attr| TypoSuggestion::typo_from_name(attr.name, res)),\n                         );\n                     }\n                 }\n                 Scope::ExternPrelude => {\n                     suggestions.extend(this.extern_prelude.iter().filter_map(|(ident, _)| {\n                         let res = Res::Def(DefKind::Mod, CRATE_DEF_ID.to_def_id());\n-                        filter_fn(res).then_some(TypoSuggestion::typo_from_res(ident.name, res))\n+                        filter_fn(res).then_some(TypoSuggestion::typo_from_ident(*ident, res))\n                     }));\n                 }\n                 Scope::ToolPrelude => {\n                     let res = Res::NonMacroAttr(NonMacroAttrKind::Tool);\n                     suggestions.extend(\n                         this.registered_tools\n                             .iter()\n-                            .map(|ident| TypoSuggestion::typo_from_res(ident.name, res)),\n+                            .map(|ident| TypoSuggestion::typo_from_ident(*ident, res)),\n                     );\n                 }\n                 Scope::StdLibPrelude => {\n@@ -1235,7 +1255,8 @@ impl<'a> Resolver<'a> {\n                 Scope::BuiltinTypes => {\n                     suggestions.extend(PrimTy::ALL.iter().filter_map(|prim_ty| {\n                         let res = Res::PrimTy(*prim_ty);\n-                        filter_fn(res).then_some(TypoSuggestion::typo_from_res(prim_ty.name(), res))\n+                        filter_fn(res)\n+                            .then_some(TypoSuggestion::typo_from_name(prim_ty.name(), res))\n                     }))\n                 }\n             }\n@@ -1666,7 +1687,7 @@ impl<'a> Resolver<'a> {\n             let a = if built_in.is_empty() { res.article() } else { \"a\" };\n             format!(\"{a}{built_in} {thing}{from}\", thing = res.descr())\n         } else {\n-            let introduced = if b.is_import() { \"imported\" } else { \"defined\" };\n+            let introduced = if b.is_import_user_facing() { \"imported\" } else { \"defined\" };\n             format!(\"the {thing} {introduced} here\", thing = res.descr())\n         }\n     }\n@@ -1725,10 +1746,10 @@ impl<'a> Resolver<'a> {\n     /// If the binding refers to a tuple struct constructor with fields,\n     /// returns the span of its fields.\n     fn ctor_fields_span(&self, binding: &NameBinding<'_>) -> Option<Span> {\n-        if let NameBindingKind::Res(\n-            Res::Def(DefKind::Ctor(CtorOf::Struct, CtorKind::Fn), ctor_def_id),\n-            _,\n-        ) = binding.kind\n+        if let NameBindingKind::Res(Res::Def(\n+            DefKind::Ctor(CtorOf::Struct, CtorKind::Fn),\n+            ctor_def_id,\n+        )) = binding.kind\n         {\n             let def_id = self.parent(ctor_def_id);\n             let fields = self.field_names.get(&def_id)?;\n@@ -1772,7 +1793,9 @@ impl<'a> Resolver<'a> {\n                         next_ident = source;\n                         Some(binding)\n                     }\n-                    ImportKind::Glob { .. } | ImportKind::MacroUse => Some(binding),\n+                    ImportKind::Glob { .. } | ImportKind::MacroUse | ImportKind::MacroExport => {\n+                        Some(binding)\n+                    }\n                     ImportKind::ExternCrate { .. } => None,\n                 },\n                 _ => None,"}, {"sha": "17ce854cb4388fa88a41aa87a9b8027730a98eee", "filename": "compiler/rustc_resolve/src/effective_visibilities.rs", "status": "modified", "additions": 36, "deletions": 24, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -57,26 +57,45 @@ impl<'r, 'a> EffectiveVisibilitiesVisitor<'r, 'a> {\n                     while let NameBindingKind::Import { binding: nested_binding, import, .. } =\n                         binding.kind\n                     {\n-                        let mut update = |node_id| self.update(\n-                            self.r.local_def_id(node_id),\n-                            binding.vis.expect_local(),\n-                            prev_parent_id,\n-                            level,\n-                        );\n-                        // In theory all the import IDs have individual visibilities and effective\n-                        // visibilities, but in practice these IDs go straigth to HIR where all\n-                        // their few uses assume that their (effective) visibility applies to the\n-                        // whole syntactic `use` item. So we update them all to the maximum value\n-                        // among the potential individual effective visibilities. Maybe HIR for\n-                        // imports shouldn't use three IDs at all.\n-                        update(import.id);\n-                        if let ImportKind::Single { additional_ids, .. } = import.kind {\n-                            update(additional_ids.0);\n-                            update(additional_ids.1);\n+                        let mut update = |node_id| {\n+                            self.update(\n+                                self.r.local_def_id(node_id),\n+                                binding.vis.expect_local(),\n+                                prev_parent_id,\n+                                level,\n+                            )\n+                        };\n+                        match import.kind {\n+                            ImportKind::Single { id, additional_ids, .. } => {\n+                                // In theory all the import IDs have individual visibilities and\n+                                // effective visibilities, but in practice these IDs go straigth to\n+                                // HIR where all their few uses assume that their (effective)\n+                                // visibility applies to the whole syntactic `use` item. So we\n+                                // update them all to the maximum value among the potential\n+                                // individual effective visibilities. Maybe HIR for imports\n+                                // shouldn't use three IDs at all.\n+                                update(id);\n+                                update(additional_ids.0);\n+                                update(additional_ids.1);\n+                                prev_parent_id = self.r.local_def_id(id);\n+                            }\n+                            ImportKind::Glob { id, .. } | ImportKind::ExternCrate { id, .. } => {\n+                                update(id);\n+                                prev_parent_id = self.r.local_def_id(id);\n+                            }\n+                            ImportKind::MacroUse => {\n+                                // In theory we should reset the parent id to something private\n+                                // here, but `macro_use` imports always refer to external items,\n+                                // so it doesn't matter and we can just do nothing.\n+                            }\n+                            ImportKind::MacroExport => {\n+                                // In theory we should reset the parent id to something public\n+                                // here, but it has the same effect as leaving the previous parent,\n+                                // so we can just do nothing.\n+                            }\n                         }\n \n                         level = Level::Reexported;\n-                        prev_parent_id = self.r.local_def_id(import.id);\n                         binding = nested_binding;\n                     }\n                 }\n@@ -138,13 +157,6 @@ impl<'r, 'ast> Visitor<'ast> for EffectiveVisibilitiesVisitor<'ast, 'r> {\n                 self.update(def_id, Visibility::Public, parent_id, Level::Direct);\n             }\n \n-            // Only exported `macro_rules!` items are public, but they always are\n-            ast::ItemKind::MacroDef(ref macro_def) if macro_def.macro_rules => {\n-                let parent_id = self.r.local_parent(def_id);\n-                let vis = self.r.visibilities[&def_id];\n-                self.update(def_id, vis, parent_id, Level::Direct);\n-            }\n-\n             ast::ItemKind::Mod(..) => {\n                 self.set_bindings_effective_visibilities(def_id);\n                 visit::walk_item(self, item);"}, {"sha": "0c4b35b88335ad5e429b68d74e14db5555fb3451", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 16, "deletions": 67, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -1,11 +1,9 @@\n-use rustc_ast::{self as ast, NodeId};\n+use rustc_ast as ast;\n use rustc_feature::is_builtin_attr_name;\n use rustc_hir::def::{DefKind, Namespace, NonMacroAttrKind, PartialRes, PerNS};\n use rustc_hir::PrimTy;\n use rustc_middle::bug;\n use rustc_middle::ty;\n-use rustc_session::lint::builtin::PROC_MACRO_DERIVE_RESOLUTION_FALLBACK;\n-use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_span::def_id::LocalDefId;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::{ExpnId, ExpnKind, LocalExpnId, MacroKind, SyntaxContext};\n@@ -19,7 +17,7 @@ use crate::late::{\n };\n use crate::macros::{sub_namespace_match, MacroRulesScope};\n use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, Determinacy, Finalize};\n-use crate::{ImportKind, LexicalScopeBinding, Module, ModuleKind, ModuleOrUniformRoot};\n+use crate::{Import, ImportKind, LexicalScopeBinding, Module, ModuleKind, ModuleOrUniformRoot};\n use crate::{NameBinding, NameBindingKind, ParentScope, PathResult, PrivacyError, Res};\n use crate::{ResolutionError, Resolver, Scope, ScopeSet, Segment, ToNameBinding, Weak};\n \n@@ -101,7 +99,7 @@ impl<'a> Resolver<'a> {\n         };\n         let mut scope = match ns {\n             _ if is_absolute_path => Scope::CrateRoot,\n-            TypeNS | ValueNS => Scope::Module(module, None),\n+            TypeNS | ValueNS => Scope::Module(module),\n             MacroNS => Scope::DeriveHelpers(parent_scope.expansion),\n         };\n         let mut ctxt = ctxt.normalize_to_macros_2_0();\n@@ -165,7 +163,7 @@ impl<'a> Resolver<'a> {\n                     MacroRulesScope::Invocation(invoc_id) => {\n                         Scope::MacroRules(self.invocation_parent_scopes[&invoc_id].macro_rules)\n                     }\n-                    MacroRulesScope::Empty => Scope::Module(module, None),\n+                    MacroRulesScope::Empty => Scope::Module(module),\n                 },\n                 Scope::CrateRoot => match ns {\n                     TypeNS => {\n@@ -174,16 +172,10 @@ impl<'a> Resolver<'a> {\n                     }\n                     ValueNS | MacroNS => break,\n                 },\n-                Scope::Module(module, prev_lint_id) => {\n+                Scope::Module(module) => {\n                     use_prelude = !module.no_implicit_prelude;\n-                    let derive_fallback_lint_id = match scope_set {\n-                        ScopeSet::Late(.., lint_id) => lint_id,\n-                        _ => None,\n-                    };\n-                    match self.hygienic_lexical_parent(module, &mut ctxt, derive_fallback_lint_id) {\n-                        Some((parent_module, lint_id)) => {\n-                            Scope::Module(parent_module, lint_id.or(prev_lint_id))\n-                        }\n+                    match self.hygienic_lexical_parent(module, &mut ctxt) {\n+                        Some(parent_module) => Scope::Module(parent_module),\n                         None => {\n                             ctxt.adjust(ExpnId::root());\n                             match ns {\n@@ -215,45 +207,13 @@ impl<'a> Resolver<'a> {\n         &mut self,\n         module: Module<'a>,\n         ctxt: &mut SyntaxContext,\n-        derive_fallback_lint_id: Option<NodeId>,\n-    ) -> Option<(Module<'a>, Option<NodeId>)> {\n+    ) -> Option<Module<'a>> {\n         if !module.expansion.outer_expn_is_descendant_of(*ctxt) {\n-            return Some((self.expn_def_scope(ctxt.remove_mark()), None));\n+            return Some(self.expn_def_scope(ctxt.remove_mark()));\n         }\n \n         if let ModuleKind::Block = module.kind {\n-            return Some((module.parent.unwrap().nearest_item_scope(), None));\n-        }\n-\n-        // We need to support the next case under a deprecation warning\n-        // ```\n-        // struct MyStruct;\n-        // ---- begin: this comes from a proc macro derive\n-        // mod implementation_details {\n-        //     // Note that `MyStruct` is not in scope here.\n-        //     impl SomeTrait for MyStruct { ... }\n-        // }\n-        // ---- end\n-        // ```\n-        // So we have to fall back to the module's parent during lexical resolution in this case.\n-        if derive_fallback_lint_id.is_some() {\n-            if let Some(parent) = module.parent {\n-                // Inner module is inside the macro, parent module is outside of the macro.\n-                if module.expansion != parent.expansion\n-                    && module.expansion.is_descendant_of(parent.expansion)\n-                {\n-                    // The macro is a proc macro derive\n-                    if let Some(def_id) = module.expansion.expn_data().macro_def_id {\n-                        let ext = self.get_macro_by_def_id(def_id).ext;\n-                        if ext.builtin_name.is_none()\n-                            && ext.macro_kind() == MacroKind::Derive\n-                            && parent.expansion.outer_expn_is_descendant_of(*ctxt)\n-                        {\n-                            return Some((parent, derive_fallback_lint_id));\n-                        }\n-                    }\n-                }\n-            }\n+            return Some(module.parent.unwrap().nearest_item_scope());\n         }\n \n         None\n@@ -510,7 +470,7 @@ impl<'a> Resolver<'a> {\n                             Err((Determinacy::Determined, _)) => Err(Determinacy::Determined),\n                         }\n                     }\n-                    Scope::Module(module, derive_fallback_lint_id) => {\n+                    Scope::Module(module) => {\n                         let adjusted_parent_scope = &ParentScope { module, ..*parent_scope };\n                         let binding = this.resolve_ident_in_module_unadjusted_ext(\n                             ModuleOrUniformRoot::Module(module),\n@@ -523,21 +483,6 @@ impl<'a> Resolver<'a> {\n                         );\n                         match binding {\n                             Ok(binding) => {\n-                                if let Some(lint_id) = derive_fallback_lint_id {\n-                                    this.lint_buffer.buffer_lint_with_diagnostic(\n-                                        PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n-                                        lint_id,\n-                                        orig_ident.span,\n-                                        &format!(\n-                                            \"cannot find {} `{}` in this scope\",\n-                                            ns.descr(),\n-                                            ident\n-                                        ),\n-                                        BuiltinLintDiagnostics::ProcMacroDeriveResolutionFallback(\n-                                            orig_ident.span,\n-                                        ),\n-                                    );\n-                                }\n                                 let misc_flags = if ptr::eq(module, this.graph_root) {\n                                     Flags::MISC_SUGGEST_CRATE\n                                 } else if module.is_normal() {\n@@ -915,7 +860,11 @@ impl<'a> Resolver<'a> {\n             }\n \n             if !restricted_shadowing && binding.expansion != LocalExpnId::ROOT {\n-                if let NameBindingKind::Res(_, true) = binding.kind {\n+                if let NameBindingKind::Import {\n+                    import: Import { kind: ImportKind::MacroExport, .. },\n+                    ..\n+                } = binding.kind\n+                {\n                     self.macro_expanded_macro_export_errors.insert((path_span, binding.span));\n                 }\n             }"}, {"sha": "4c899a5ff2d7eea409ce980dd2d9e4c77beac438", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 106, "deletions": 80, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -44,20 +44,36 @@ pub enum ImportKind<'a> {\n         type_ns_only: bool,\n         /// Did this import result from a nested import? ie. `use foo::{bar, baz};`\n         nested: bool,\n+        /// The ID of the `UseTree` that imported this `Import`.\n+        ///\n+        /// In the case where the `Import` was expanded from a \"nested\" use tree,\n+        /// this id is the ID of the leaf tree. For example:\n+        ///\n+        /// ```ignore (pacify the merciless tidy)\n+        /// use foo::bar::{a, b}\n+        /// ```\n+        ///\n+        /// If this is the import for `foo::bar::a`, we would have the ID of the `UseTree`\n+        /// for `a` in this field.\n+        id: NodeId,\n         /// Additional `NodeId`s allocated to a `ast::UseTree` for automatically generated `use` statement\n         /// (eg. implicit struct constructors)\n         additional_ids: (NodeId, NodeId),\n     },\n     Glob {\n         is_prelude: bool,\n-        max_vis: Cell<Option<ty::Visibility>>, // The visibility of the greatest re-export.\n-                                               // n.b. `max_vis` is only used in `finalize_import` to check for re-export errors.\n+        // The visibility of the greatest re-export.\n+        // n.b. `max_vis` is only used in `finalize_import` to check for re-export errors.\n+        max_vis: Cell<Option<ty::Visibility>>,\n+        id: NodeId,\n     },\n     ExternCrate {\n         source: Option<Symbol>,\n         target: Ident,\n+        id: NodeId,\n     },\n     MacroUse,\n+    MacroExport,\n }\n \n /// Manually implement `Debug` for `ImportKind` because the `source/target_bindings`\n@@ -71,6 +87,7 @@ impl<'a> std::fmt::Debug for ImportKind<'a> {\n                 ref target,\n                 ref type_ns_only,\n                 ref nested,\n+                ref id,\n                 ref additional_ids,\n                 // Ignore the following to avoid an infinite loop while printing.\n                 source_bindings: _,\n@@ -81,19 +98,23 @@ impl<'a> std::fmt::Debug for ImportKind<'a> {\n                 .field(\"target\", target)\n                 .field(\"type_ns_only\", type_ns_only)\n                 .field(\"nested\", nested)\n+                .field(\"id\", id)\n                 .field(\"additional_ids\", additional_ids)\n                 .finish_non_exhaustive(),\n-            Glob { ref is_prelude, ref max_vis } => f\n+            Glob { ref is_prelude, ref max_vis, ref id } => f\n                 .debug_struct(\"Glob\")\n                 .field(\"is_prelude\", is_prelude)\n                 .field(\"max_vis\", max_vis)\n+                .field(\"id\", id)\n                 .finish(),\n-            ExternCrate { ref source, ref target } => f\n+            ExternCrate { ref source, ref target, ref id } => f\n                 .debug_struct(\"ExternCrate\")\n                 .field(\"source\", source)\n                 .field(\"target\", target)\n+                .field(\"id\", id)\n                 .finish(),\n             MacroUse => f.debug_struct(\"MacroUse\").finish(),\n+            MacroExport => f.debug_struct(\"MacroExport\").finish(),\n         }\n     }\n }\n@@ -103,24 +124,15 @@ impl<'a> std::fmt::Debug for ImportKind<'a> {\n pub(crate) struct Import<'a> {\n     pub kind: ImportKind<'a>,\n \n-    /// The ID of the `extern crate`, `UseTree` etc that imported this `Import`.\n-    ///\n-    /// In the case where the `Import` was expanded from a \"nested\" use tree,\n-    /// this id is the ID of the leaf tree. For example:\n-    ///\n-    /// ```ignore (pacify the merciless tidy)\n+    /// Node ID of the \"root\" use item -- this is always the same as `ImportKind`'s `id`\n+    /// (if it exists) except in the case of \"nested\" use trees, in which case\n+    /// it will be the ID of the root use tree. e.g., in the example\n+    /// ```ignore (incomplete code)\n     /// use foo::bar::{a, b}\n     /// ```\n-    ///\n-    /// If this is the import for `foo::bar::a`, we would have the ID of the `UseTree`\n-    /// for `a` in this field.\n-    pub id: NodeId,\n-\n-    /// The `id` of the \"root\" use-kind -- this is always the same as\n-    /// `id` except in the case of \"nested\" use trees, in which case\n-    /// it will be the `id` of the root use tree. e.g., in the example\n-    /// from `id`, this would be the ID of the `use foo::bar`\n-    /// `UseTree` node.\n+    /// this would be the ID of the `use foo::bar` `UseTree` node.\n+    /// In case of imports without their own node ID it's the closest node that can be used,\n+    /// for example, for reporting lints.\n     pub root_id: NodeId,\n \n     /// Span of the entire use statement.\n@@ -161,6 +173,15 @@ impl<'a> Import<'a> {\n     pub(crate) fn expect_vis(&self) -> ty::Visibility {\n         self.vis.get().expect(\"encountered cleared import visibility\")\n     }\n+\n+    pub(crate) fn id(&self) -> Option<NodeId> {\n+        match self.kind {\n+            ImportKind::Single { id, .. }\n+            | ImportKind::Glob { id, .. }\n+            | ImportKind::ExternCrate { id, .. } => Some(id),\n+            ImportKind::MacroUse | ImportKind::MacroExport => None,\n+        }\n+    }\n }\n \n /// Records information about the resolution of a name in a namespace of a module.\n@@ -368,7 +389,9 @@ impl<'a> Resolver<'a> {\n             self.record_use(target, dummy_binding, false);\n         } else if import.imported_module.get().is_none() {\n             import.used.set(true);\n-            self.used_imports.insert(import.id);\n+            if let Some(id) = import.id() {\n+                self.used_imports.insert(id);\n+            }\n         }\n     }\n }\n@@ -450,7 +473,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 {\n                     // In the case of a new import line, throw a diagnostic message\n                     // for the previous line.\n-                    self.throw_unresolved_import_error(errors, None);\n+                    self.throw_unresolved_import_error(errors);\n                     errors = vec![];\n                 }\n                 if seen_spans.insert(err.span) {\n@@ -482,29 +505,21 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         }\n \n         if !errors.is_empty() {\n-            self.throw_unresolved_import_error(errors, None);\n+            self.throw_unresolved_import_error(errors);\n         }\n     }\n \n-    fn throw_unresolved_import_error(\n-        &self,\n-        errors: Vec<(String, UnresolvedImportError)>,\n-        span: Option<MultiSpan>,\n-    ) {\n+    fn throw_unresolved_import_error(&self, errors: Vec<(String, UnresolvedImportError)>) {\n+        if errors.is_empty() {\n+            return;\n+        }\n+\n         /// Upper limit on the number of `span_label` messages.\n         const MAX_LABEL_COUNT: usize = 10;\n \n-        let (span, msg) = if errors.is_empty() {\n-            (span.unwrap(), \"unresolved import\".to_string())\n-        } else {\n-            let span = MultiSpan::from_spans(errors.iter().map(|(_, err)| err.span).collect());\n-\n-            let paths = errors.iter().map(|(path, _)| format!(\"`{}`\", path)).collect::<Vec<_>>();\n-\n-            let msg = format!(\"unresolved import{} {}\", pluralize!(paths.len()), paths.join(\", \"),);\n-\n-            (span, msg)\n-        };\n+        let span = MultiSpan::from_spans(errors.iter().map(|(_, err)| err.span).collect());\n+        let paths = errors.iter().map(|(path, _)| format!(\"`{}`\", path)).collect::<Vec<_>>();\n+        let msg = format!(\"unresolved import{} {}\", pluralize!(paths.len()), paths.join(\", \"),);\n \n         let mut diag = struct_span_err!(self.r.session, span, E0432, \"{}\", &msg);\n \n@@ -718,47 +733,51 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             PathResult::Indeterminate => unreachable!(),\n         };\n \n-        let (ident, target, source_bindings, target_bindings, type_ns_only) = match import.kind {\n-            ImportKind::Single {\n-                source,\n-                target,\n-                ref source_bindings,\n-                ref target_bindings,\n-                type_ns_only,\n-                ..\n-            } => (source, target, source_bindings, target_bindings, type_ns_only),\n-            ImportKind::Glob { is_prelude, ref max_vis } => {\n-                if import.module_path.len() <= 1 {\n-                    // HACK(eddyb) `lint_if_path_starts_with_module` needs at least\n-                    // 2 segments, so the `resolve_path` above won't trigger it.\n-                    let mut full_path = import.module_path.clone();\n-                    full_path.push(Segment::from_ident(Ident::empty()));\n-                    self.r.lint_if_path_starts_with_module(Some(finalize), &full_path, None);\n-                }\n+        let (ident, target, source_bindings, target_bindings, type_ns_only, import_id) =\n+            match import.kind {\n+                ImportKind::Single {\n+                    source,\n+                    target,\n+                    ref source_bindings,\n+                    ref target_bindings,\n+                    type_ns_only,\n+                    id,\n+                    ..\n+                } => (source, target, source_bindings, target_bindings, type_ns_only, id),\n+                ImportKind::Glob { is_prelude, ref max_vis, id } => {\n+                    if import.module_path.len() <= 1 {\n+                        // HACK(eddyb) `lint_if_path_starts_with_module` needs at least\n+                        // 2 segments, so the `resolve_path` above won't trigger it.\n+                        let mut full_path = import.module_path.clone();\n+                        full_path.push(Segment::from_ident(Ident::empty()));\n+                        self.r.lint_if_path_starts_with_module(Some(finalize), &full_path, None);\n+                    }\n \n-                if let ModuleOrUniformRoot::Module(module) = module {\n-                    if ptr::eq(module, import.parent_scope.module) {\n-                        // Importing a module into itself is not allowed.\n-                        return Some(UnresolvedImportError {\n-                            span: import.span,\n-                            label: Some(String::from(\"cannot glob-import a module into itself\")),\n-                            note: None,\n-                            suggestion: None,\n-                            candidate: None,\n-                        });\n+                    if let ModuleOrUniformRoot::Module(module) = module {\n+                        if ptr::eq(module, import.parent_scope.module) {\n+                            // Importing a module into itself is not allowed.\n+                            return Some(UnresolvedImportError {\n+                                span: import.span,\n+                                label: Some(String::from(\n+                                    \"cannot glob-import a module into itself\",\n+                                )),\n+                                note: None,\n+                                suggestion: None,\n+                                candidate: None,\n+                            });\n+                        }\n                     }\n-                }\n-                if !is_prelude\n+                    if !is_prelude\n                     && let Some(max_vis) = max_vis.get()\n                     && !max_vis.is_at_least(import.expect_vis(), &*self.r)\n                 {\n                     let msg = \"glob import doesn't reexport anything because no candidate is public enough\";\n-                    self.r.lint_buffer.buffer_lint(UNUSED_IMPORTS, import.id, import.span, msg);\n+                    self.r.lint_buffer.buffer_lint(UNUSED_IMPORTS, id, import.span, msg);\n                 }\n-                return None;\n-            }\n-            _ => unreachable!(),\n-        };\n+                    return None;\n+                }\n+                _ => unreachable!(),\n+            };\n \n         let mut all_ns_err = true;\n         self.r.per_ns(|this, ns| {\n@@ -858,7 +877,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                                         match binding.kind {\n                                             // Never suggest the name that has binding error\n                                             // i.e., the name that cannot be previously resolved\n-                                            NameBindingKind::Res(Res::Err, _) => None,\n+                                            NameBindingKind::Res(Res::Err) => None,\n                                             _ => Some(i.name),\n                                         }\n                                     }\n@@ -960,7 +979,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 );\n                 self.r.lint_buffer.buffer_lint(\n                     PUB_USE_OF_PRIVATE_EXTERN_CRATE,\n-                    import.id,\n+                    import_id,\n                     import.span,\n                     &msg,\n                 );\n@@ -989,7 +1008,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     let mut err =\n                         struct_span_err!(self.r.session, import.span, E0364, \"{error_msg}\");\n                     match binding.kind {\n-                        NameBindingKind::Res(Res::Def(DefKind::Macro(_), def_id), _)\n+                        NameBindingKind::Res(Res::Def(DefKind::Macro(_), def_id))\n                             // exclude decl_macro\n                             if self.r.get_macro_by_def_id(def_id).macro_rules =>\n                         {\n@@ -1029,7 +1048,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         // purposes it's good enough to just favor one over the other.\n         self.r.per_ns(|this, ns| {\n             if let Ok(binding) = source_bindings[ns].get() {\n-                this.import_res_map.entry(import.id).or_default()[ns] = Some(binding.res());\n+                this.import_res_map.entry(import_id).or_default()[ns] = Some(binding.res());\n             }\n         });\n \n@@ -1047,6 +1066,9 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         target_bindings: &PerNS<Cell<Option<&'b NameBinding<'b>>>>,\n         target: Ident,\n     ) {\n+        // This function is only called for single imports.\n+        let ImportKind::Single { id, .. } = import.kind else { unreachable!() };\n+\n         // Skip if the import was produced by a macro.\n         if import.parent_scope.expansion != LocalExpnId::ROOT {\n             return;\n@@ -1094,7 +1116,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             redundant_spans.dedup();\n             self.r.lint_buffer.buffer_lint_with_diagnostic(\n                 UNUSED_IMPORTS,\n-                import.id,\n+                id,\n                 import.span,\n                 &format!(\"the item `{}` is imported redundantly\", ident),\n                 BuiltinLintDiagnostics::RedundantImport(redundant_spans, ident),\n@@ -1103,6 +1125,9 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     }\n \n     fn resolve_glob_import(&mut self, import: &'b Import<'b>) {\n+        // This function is only called for glob imports.\n+        let ImportKind::Glob { id, is_prelude, .. } = import.kind else { unreachable!() };\n+\n         let ModuleOrUniformRoot::Module(module) = import.imported_module.get().unwrap() else {\n             self.r.session.span_err(import.span, \"cannot glob-import all possible crates\");\n             return;\n@@ -1113,7 +1138,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             return;\n         } else if ptr::eq(module, import.parent_scope.module) {\n             return;\n-        } else if let ImportKind::Glob { is_prelude: true, .. } = import.kind {\n+        } else if is_prelude {\n             self.r.prelude = Some(module);\n             return;\n         }\n@@ -1145,7 +1170,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         }\n \n         // Record the destination of this import\n-        self.r.record_partial_res(import.id, PartialRes::new(module.res().unwrap()));\n+        self.r.record_partial_res(id, PartialRes::new(module.res().unwrap()));\n     }\n \n     // Miscellaneous post-processing, including recording re-exports,\n@@ -1204,5 +1229,6 @@ fn import_kind_to_string(import_kind: &ImportKind<'_>) -> String {\n         ImportKind::Glob { .. } => \"*\".to_string(),\n         ImportKind::ExternCrate { .. } => \"<extern crate>\".to_string(),\n         ImportKind::MacroUse => \"#[macro_use]\".to_string(),\n+        ImportKind::MacroExport => \"#[macro_export]\".to_string(),\n     }\n }"}, {"sha": "6d2ee25df320dd0898115e07c70b9cdb7c73a8fd", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -32,7 +32,7 @@ use smallvec::{smallvec, SmallVec};\n use rustc_span::source_map::{respan, Spanned};\n use std::assert_matches::debug_assert_matches;\n use std::collections::{hash_map::Entry, BTreeSet};\n-use std::mem::{replace, take};\n+use std::mem::{replace, swap, take};\n \n mod diagnostics;\n \n@@ -3369,11 +3369,6 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             let (mut err, candidates) =\n                 this.smart_resolve_report_errors(path, path_span, PathSource::Type, None);\n \n-            if candidates.is_empty() {\n-                err.cancel();\n-                return Some(parent_err);\n-            }\n-\n             // There are two different error messages user might receive at\n             // this point:\n             // - E0412 cannot find type `{}` in this scope\n@@ -3383,37 +3378,62 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             // latter one - for paths in expression-position.\n             //\n             // Thus (since we're in expression-position at this point), not to\n-            // confuse the user, we want to keep the *message* from E0432 (so\n+            // confuse the user, we want to keep the *message* from E0433 (so\n             // `parent_err`), but we want *hints* from E0412 (so `err`).\n             //\n             // And that's what happens below - we're just mixing both messages\n             // into a single one.\n             let mut parent_err = this.r.into_struct_error(parent_err.span, parent_err.node);\n \n+            // overwrite all properties with the parent's error message\n             err.message = take(&mut parent_err.message);\n             err.code = take(&mut parent_err.code);\n+            swap(&mut err.span, &mut parent_err.span);\n             err.children = take(&mut parent_err.children);\n+            err.sort_span = parent_err.sort_span;\n+            err.is_lint = parent_err.is_lint;\n+\n+            // merge the parent's suggestions with the typo suggestions\n+            fn append_result<T, E>(res1: &mut Result<Vec<T>, E>, res2: Result<Vec<T>, E>) {\n+                match res1 {\n+                    Ok(vec1) => match res2 {\n+                        Ok(mut vec2) => vec1.append(&mut vec2),\n+                        Err(e) => *res1 = Err(e),\n+                    },\n+                    Err(_) => (),\n+                };\n+            }\n+            append_result(&mut err.suggestions, parent_err.suggestions.clone());\n \n             parent_err.cancel();\n \n             let def_id = this.parent_scope.module.nearest_parent_mod();\n \n             if this.should_report_errs() {\n-                this.r.use_injections.push(UseError {\n-                    err,\n-                    candidates,\n-                    def_id,\n-                    instead: false,\n-                    suggestion: None,\n-                    path: path.into(),\n-                    is_call: source.is_call(),\n-                });\n+                if candidates.is_empty() {\n+                    // When there is no suggested imports, we can just emit the error\n+                    // and suggestions immediately. Note that we bypass the usually error\n+                    // reporting routine (ie via `self.r.report_error`) because we need\n+                    // to post-process the `ResolutionError` above.\n+                    err.emit();\n+                } else {\n+                    // If there are suggested imports, the error reporting is delayed\n+                    this.r.use_injections.push(UseError {\n+                        err,\n+                        candidates,\n+                        def_id,\n+                        instead: false,\n+                        suggestion: None,\n+                        path: path.into(),\n+                        is_call: source.is_call(),\n+                    });\n+                }\n             } else {\n                 err.cancel();\n             }\n \n             // We don't return `Some(parent_err)` here, because the error will\n-            // be already printed as part of the `use` injections\n+            // be already printed either immediately or as part of the `use` injections\n             None\n         };\n "}, {"sha": "103187b00d1b7391788fb377a10e8e17ed864229", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -150,15 +150,15 @@ struct BaseError {\n #[derive(Debug)]\n enum TypoCandidate {\n     Typo(TypoSuggestion),\n-    Shadowed(Res),\n+    Shadowed(Res, Option<Span>),\n     None,\n }\n \n impl TypoCandidate {\n     fn to_opt_suggestion(self) -> Option<TypoSuggestion> {\n         match self {\n             TypoCandidate::Typo(sugg) => Some(sugg),\n-            TypoCandidate::Shadowed(_) | TypoCandidate::None => None,\n+            TypoCandidate::Shadowed(_, _) | TypoCandidate::None => None,\n         }\n     }\n }\n@@ -691,9 +691,20 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         let is_expected = &|res| source.is_expected(res);\n         let ident_span = path.last().map_or(span, |ident| ident.ident.span);\n         let typo_sugg = self.lookup_typo_candidate(path, source.namespace(), is_expected);\n-        if let TypoCandidate::Shadowed(res) = typo_sugg\n-            && let Some(id) = res.opt_def_id()\n-            && let Some(sugg_span) = self.r.opt_span(id)\n+        let is_in_same_file = &|sp1, sp2| {\n+            let source_map = self.r.session.source_map();\n+            let file1 = source_map.span_to_filename(sp1);\n+            let file2 = source_map.span_to_filename(sp2);\n+            file1 == file2\n+        };\n+        // print 'you might have meant' if the candidate is (1) is a shadowed name with\n+        // accessible definition and (2) either defined in the same crate as the typo\n+        // (could be in a different file) or introduced in the same file as the typo\n+        // (could belong to a different crate)\n+        if let TypoCandidate::Shadowed(res, Some(sugg_span)) = typo_sugg\n+            && res\n+                .opt_def_id()\n+                .map_or(false, |id| id.is_local() || is_in_same_file(span, sugg_span))\n         {\n             err.span_label(\n                 sugg_span,\n@@ -970,10 +981,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                         .collect();\n                 if targets.len() == 1 {\n                     let target = targets[0];\n-                    return Some(TypoSuggestion::single_item_from_res(\n-                        target.0.ident.name,\n-                        target.1,\n-                    ));\n+                    return Some(TypoSuggestion::single_item_from_ident(target.0.ident, target.1));\n                 }\n             }\n         }\n@@ -1615,7 +1623,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 // Locals and type parameters\n                 for (ident, &res) in &rib.bindings {\n                     if filter_fn(res) && ident.span.ctxt() == rib_ctxt {\n-                        names.push(TypoSuggestion::typo_from_res(ident.name, res));\n+                        names.push(TypoSuggestion::typo_from_ident(*ident, res));\n                     }\n                 }\n \n@@ -1644,9 +1652,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                                             Res::Def(DefKind::Mod, crate_id.as_def_id());\n \n                                         if filter_fn(crate_mod) {\n-                                            Some(TypoSuggestion::typo_from_res(\n-                                                ident.name, crate_mod,\n-                                            ))\n+                                            Some(TypoSuggestion::typo_from_ident(*ident, crate_mod))\n                                         } else {\n                                             None\n                                         }\n@@ -1665,7 +1671,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             // Add primitive types to the mix\n             if filter_fn(Res::PrimTy(PrimTy::Bool)) {\n                 names.extend(PrimTy::ALL.iter().map(|prim_ty| {\n-                    TypoSuggestion::typo_from_res(prim_ty.name(), Res::PrimTy(*prim_ty))\n+                    TypoSuggestion::typo_from_name(prim_ty.name(), Res::PrimTy(*prim_ty))\n                 }))\n             }\n         } else {\n@@ -1692,7 +1698,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                     return TypoCandidate::None;\n                 };\n                 if found == name {\n-                    TypoCandidate::Shadowed(sugg.res)\n+                    TypoCandidate::Shadowed(sugg.res, sugg.span)\n                 } else {\n                     TypoCandidate::Typo(sugg)\n                 }"}, {"sha": "ee1c97d5ad2b7925875e30bf0f3a74fb16094417", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -104,9 +104,7 @@ enum Scope<'a> {\n     DeriveHelpersCompat,\n     MacroRules(MacroRulesScopeRef<'a>),\n     CrateRoot,\n-    // The node ID is for reporting the `PROC_MACRO_DERIVE_RESOLUTION_FALLBACK`\n-    // lint if it should be reported.\n-    Module(Module<'a>, Option<NodeId>),\n+    Module(Module<'a>),\n     MacroUsePrelude,\n     BuiltinAttrs,\n     ExternPrelude,\n@@ -646,7 +644,7 @@ impl<'a> ToNameBinding<'a> for &'a NameBinding<'a> {\n \n #[derive(Clone, Debug)]\n enum NameBindingKind<'a> {\n-    Res(Res, /* is_macro_export */ bool),\n+    Res(Res),\n     Module(Module<'a>),\n     Import { binding: &'a NameBinding<'a>, import: &'a Import<'a>, used: Cell<bool> },\n }\n@@ -745,7 +743,7 @@ impl<'a> NameBinding<'a> {\n \n     fn res(&self) -> Res {\n         match self.kind {\n-            NameBindingKind::Res(res, _) => res,\n+            NameBindingKind::Res(res) => res,\n             NameBindingKind::Module(module) => module.res().unwrap(),\n             NameBindingKind::Import { binding, .. } => binding.res(),\n         }\n@@ -762,10 +760,10 @@ impl<'a> NameBinding<'a> {\n     fn is_possibly_imported_variant(&self) -> bool {\n         match self.kind {\n             NameBindingKind::Import { binding, .. } => binding.is_possibly_imported_variant(),\n-            NameBindingKind::Res(\n-                Res::Def(DefKind::Variant | DefKind::Ctor(CtorOf::Variant, ..), _),\n+            NameBindingKind::Res(Res::Def(\n+                DefKind::Variant | DefKind::Ctor(CtorOf::Variant, ..),\n                 _,\n-            ) => true,\n+            )) => true,\n             NameBindingKind::Res(..) | NameBindingKind::Module(..) => false,\n         }\n     }\n@@ -788,6 +786,13 @@ impl<'a> NameBinding<'a> {\n         matches!(self.kind, NameBindingKind::Import { .. })\n     }\n \n+    /// The binding introduced by `#[macro_export] macro_rules` is a public import, but it might\n+    /// not be perceived as such by users, so treat it as a non-import in some diagnostics.\n+    fn is_import_user_facing(&self) -> bool {\n+        matches!(self.kind, NameBindingKind::Import { import, .. }\n+            if !matches!(import.kind, ImportKind::MacroExport))\n+    }\n+\n     fn is_glob_import(&self) -> bool {\n         match self.kind {\n             NameBindingKind::Import { import, .. } => import.is_glob(),\n@@ -1283,7 +1288,7 @@ impl<'a> Resolver<'a> {\n \n             arenas,\n             dummy_binding: arenas.alloc_name_binding(NameBinding {\n-                kind: NameBindingKind::Res(Res::Err, false),\n+                kind: NameBindingKind::Res(Res::Err),\n                 ambiguity: None,\n                 expansion: LocalExpnId::ROOT,\n                 span: DUMMY_SP,\n@@ -1551,7 +1556,7 @@ impl<'a> Resolver<'a> {\n \n         self.visit_scopes(ScopeSet::All(TypeNS, false), parent_scope, ctxt, |this, scope, _, _| {\n             match scope {\n-                Scope::Module(module, _) => {\n+                Scope::Module(module) => {\n                     this.traits_in_module(module, assoc_item, &mut found_traits);\n                 }\n                 Scope::StdLibPrelude => {\n@@ -1613,10 +1618,12 @@ impl<'a> Resolver<'a> {\n     ) -> SmallVec<[LocalDefId; 1]> {\n         let mut import_ids = smallvec![];\n         while let NameBindingKind::Import { import, binding, .. } = kind {\n-            let id = self.local_def_id(import.id);\n-            self.maybe_unused_trait_imports.insert(id);\n+            if let Some(node_id) = import.id() {\n+                let def_id = self.local_def_id(node_id);\n+                self.maybe_unused_trait_imports.insert(def_id);\n+                import_ids.push(def_id);\n+            }\n             self.add_to_glob_map(&import, trait_name);\n-            import_ids.push(id);\n             kind = &binding.kind;\n         }\n         import_ids\n@@ -1683,16 +1690,18 @@ impl<'a> Resolver<'a> {\n             }\n             used.set(true);\n             import.used.set(true);\n-            self.used_imports.insert(import.id);\n+            if let Some(id) = import.id() {\n+                self.used_imports.insert(id);\n+            }\n             self.add_to_glob_map(&import, ident);\n             self.record_use(ident, binding, false);\n         }\n     }\n \n     #[inline]\n     fn add_to_glob_map(&mut self, import: &Import<'_>, ident: Ident) {\n-        if import.is_glob() {\n-            let def_id = self.local_def_id(import.id);\n+        if let ImportKind::Glob { id, .. } = import.kind {\n+            let def_id = self.local_def_id(id);\n             self.glob_map.entry(def_id).or_default().insert(ident.name);\n         }\n     }\n@@ -1994,11 +2003,7 @@ impl<'a> Resolver<'a> {\n \n     // Items that go to reexport table encoded to metadata and visible through it to other crates.\n     fn is_reexport(&self, binding: &NameBinding<'a>) -> Option<def::Res<!>> {\n-        // FIXME: Consider changing the binding inserted by `#[macro_export] macro_rules`\n-        // into the crate root to actual `NameBindingKind::Import`.\n-        if binding.is_import()\n-            || matches!(binding.kind, NameBindingKind::Res(_, _is_macro_export @ true))\n-        {\n+        if binding.is_import() {\n             let res = binding.res().expect_non_local();\n             // Ambiguous imports are treated as errors at this point and are\n             // not exposed to other crates (see #36837 for more details)."}, {"sha": "db0ef73544faad71ed845dfd1637b4117cc74dd1", "filename": "compiler/rustc_serialize/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_serialize%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_serialize%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2FCargo.toml?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -6,7 +6,7 @@ edition = \"2021\"\n [dependencies]\n indexmap = \"1.9.1\"\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n-thin-vec = \"0.2.8\"\n+thin-vec = \"0.2.9\"\n \n [dev-dependencies]\n rustc_macros = { path = \"../rustc_macros\" }"}, {"sha": "a052f29334169ebd5d6478caf780b41fb8e4df0d", "filename": "compiler/rustc_session/Cargo.toml", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_session%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_session%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2FCargo.toml?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -17,3 +17,10 @@ rustc_span = { path = \"../rustc_span\" }\n rustc_fs_util = { path = \"../rustc_fs_util\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_lint_defs = { path = \"../rustc_lint_defs\" }\n+smallvec = \"1.8.1\"\n+\n+[target.'cfg(unix)'.dependencies]\n+libc = \"0.2\"\n+\n+[target.'cfg(windows)'.dependencies]\n+winapi = { version = \"0.3\", features = [\"libloaderapi\"] }"}, {"sha": "aece29ca0cbf6197f509e73e7596fc191c684ea7", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 47, "deletions": 31, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -738,7 +738,7 @@ impl Default for Options {\n             actually_rustdoc: false,\n             trimmed_def_paths: TrimmedDefPaths::default(),\n             cli_forced_codegen_units: None,\n-            cli_forced_thinlto_off: false,\n+            cli_forced_local_thinlto_off: false,\n             remap_path_prefix: Vec::new(),\n             real_rust_source_base_dir: None,\n             edition: DEFAULT_EDITION,\n@@ -794,6 +794,7 @@ impl UnstableOptions {\n             report_delayed_bugs: self.report_delayed_bugs,\n             macro_backtrace: self.macro_backtrace,\n             deduplicate_diagnostics: self.deduplicate_diagnostics,\n+            track_diagnostics: self.track_diagnostics,\n         }\n     }\n }\n@@ -1720,7 +1721,7 @@ fn should_override_cgus_and_disable_thinlto(\n     error_format: ErrorOutputType,\n     mut codegen_units: Option<usize>,\n ) -> (bool, Option<usize>) {\n-    let mut disable_thinlto = false;\n+    let mut disable_local_thinlto = false;\n     // Issue #30063: if user requests LLVM-related output to one\n     // particular path, disable codegen-units.\n     let incompatible: Vec<_> = output_types\n@@ -1745,12 +1746,12 @@ fn should_override_cgus_and_disable_thinlto(\n                     }\n                     early_warn(error_format, \"resetting to default -C codegen-units=1\");\n                     codegen_units = Some(1);\n-                    disable_thinlto = true;\n+                    disable_local_thinlto = true;\n                 }\n             }\n             _ => {\n                 codegen_units = Some(1);\n-                disable_thinlto = true;\n+                disable_local_thinlto = true;\n             }\n         }\n     }\n@@ -1759,7 +1760,7 @@ fn should_override_cgus_and_disable_thinlto(\n         early_error(error_format, \"value for codegen units must be a positive non-zero integer\");\n     }\n \n-    (disable_thinlto, codegen_units)\n+    (disable_local_thinlto, codegen_units)\n }\n \n fn check_thread_count(unstable_opts: &UnstableOptions, error_format: ErrorOutputType) {\n@@ -1788,34 +1789,49 @@ fn collect_print_requests(\n         cg.target_feature = String::new();\n     }\n \n-    prints.extend(matches.opt_strs(\"print\").into_iter().map(|s| match &*s {\n-        \"crate-name\" => PrintRequest::CrateName,\n-        \"file-names\" => PrintRequest::FileNames,\n-        \"sysroot\" => PrintRequest::Sysroot,\n-        \"target-libdir\" => PrintRequest::TargetLibdir,\n-        \"cfg\" => PrintRequest::Cfg,\n-        \"calling-conventions\" => PrintRequest::CallingConventions,\n-        \"target-list\" => PrintRequest::TargetList,\n-        \"target-cpus\" => PrintRequest::TargetCPUs,\n-        \"target-features\" => PrintRequest::TargetFeatures,\n-        \"relocation-models\" => PrintRequest::RelocationModels,\n-        \"code-models\" => PrintRequest::CodeModels,\n-        \"tls-models\" => PrintRequest::TlsModels,\n-        \"native-static-libs\" => PrintRequest::NativeStaticLibs,\n-        \"stack-protector-strategies\" => PrintRequest::StackProtectorStrategies,\n-        \"target-spec-json\" => {\n-            if unstable_opts.unstable_options {\n-                PrintRequest::TargetSpec\n-            } else {\n+    const PRINT_REQUESTS: &[(&str, PrintRequest)] = &[\n+        (\"crate-name\", PrintRequest::CrateName),\n+        (\"file-names\", PrintRequest::FileNames),\n+        (\"sysroot\", PrintRequest::Sysroot),\n+        (\"target-libdir\", PrintRequest::TargetLibdir),\n+        (\"cfg\", PrintRequest::Cfg),\n+        (\"calling-conventions\", PrintRequest::CallingConventions),\n+        (\"target-list\", PrintRequest::TargetList),\n+        (\"target-cpus\", PrintRequest::TargetCPUs),\n+        (\"target-features\", PrintRequest::TargetFeatures),\n+        (\"relocation-models\", PrintRequest::RelocationModels),\n+        (\"code-models\", PrintRequest::CodeModels),\n+        (\"tls-models\", PrintRequest::TlsModels),\n+        (\"native-static-libs\", PrintRequest::NativeStaticLibs),\n+        (\"stack-protector-strategies\", PrintRequest::StackProtectorStrategies),\n+        (\"target-spec-json\", PrintRequest::TargetSpec),\n+        (\"link-args\", PrintRequest::LinkArgs),\n+    ];\n+\n+    prints.extend(matches.opt_strs(\"print\").into_iter().map(|req| {\n+        match PRINT_REQUESTS.iter().find(|&&(name, _)| name == req) {\n+            Some((_, PrintRequest::TargetSpec)) => {\n+                if unstable_opts.unstable_options {\n+                    PrintRequest::TargetSpec\n+                } else {\n+                    early_error(\n+                        error_format,\n+                        \"the `-Z unstable-options` flag must also be passed to \\\n+                     enable the target-spec-json print option\",\n+                    );\n+                }\n+            }\n+            Some(&(_, print_request)) => print_request,\n+            None => {\n+                let prints =\n+                    PRINT_REQUESTS.iter().map(|(name, _)| format!(\"`{name}`\")).collect::<Vec<_>>();\n+                let prints = prints.join(\", \");\n                 early_error(\n                     error_format,\n-                    \"the `-Z unstable-options` flag must also be passed to \\\n-                     enable the target-spec-json print option\",\n+                    &format!(\"unknown print request `{req}`. Valid print requests are: {prints}\"),\n                 );\n             }\n         }\n-        \"link-args\" => PrintRequest::LinkArgs,\n-        req => early_error(error_format, &format!(\"unknown print request `{req}`\")),\n     }));\n \n     prints\n@@ -2249,7 +2265,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     let output_types = parse_output_types(&unstable_opts, matches, error_format);\n \n     let mut cg = CodegenOptions::build(matches, error_format);\n-    let (disable_thinlto, mut codegen_units) = should_override_cgus_and_disable_thinlto(\n+    let (disable_local_thinlto, mut codegen_units) = should_override_cgus_and_disable_thinlto(\n         &output_types,\n         matches,\n         error_format,\n@@ -2431,7 +2447,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     let sysroot = match &sysroot_opt {\n         Some(s) => s,\n         None => {\n-            tmp_buf = crate::filesearch::get_or_default_sysroot();\n+            tmp_buf = crate::filesearch::get_or_default_sysroot().expect(\"Failed finding sysroot\");\n             &tmp_buf\n         }\n     };\n@@ -2492,7 +2508,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         actually_rustdoc: false,\n         trimmed_def_paths: TrimmedDefPaths::default(),\n         cli_forced_codegen_units: codegen_units,\n-        cli_forced_thinlto_off: disable_thinlto,\n+        cli_forced_local_thinlto_off: disable_local_thinlto,\n         remap_path_prefix,\n         real_rust_source_base_dir,\n         edition,"}, {"sha": "1b66773be6f0804a02627989199547c8c6616769", "filename": "compiler/rustc_session/src/filesearch.rs", "status": "modified", "additions": 120, "deletions": 16, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -1,5 +1,6 @@\n //! A module for searching for libraries\n \n+use smallvec::{smallvec, SmallVec};\n use std::env;\n use std::fs;\n use std::iter::FromIterator;\n@@ -62,9 +63,99 @@ pub fn make_target_lib_path(sysroot: &Path, target_triple: &str) -> PathBuf {\n     PathBuf::from_iter([sysroot, Path::new(&rustlib_path), Path::new(\"lib\")])\n }\n \n+#[cfg(unix)]\n+fn current_dll_path() -> Result<PathBuf, String> {\n+    use std::ffi::{CStr, OsStr};\n+    use std::os::unix::prelude::*;\n+\n+    unsafe {\n+        let addr = current_dll_path as usize as *mut _;\n+        let mut info = std::mem::zeroed();\n+        if libc::dladdr(addr, &mut info) == 0 {\n+            return Err(\"dladdr failed\".into());\n+        }\n+        if info.dli_fname.is_null() {\n+            return Err(\"dladdr returned null pointer\".into());\n+        }\n+        let bytes = CStr::from_ptr(info.dli_fname).to_bytes();\n+        let os = OsStr::from_bytes(bytes);\n+        Ok(PathBuf::from(os))\n+    }\n+}\n+\n+#[cfg(windows)]\n+fn current_dll_path() -> Result<PathBuf, String> {\n+    use std::ffi::OsString;\n+    use std::io;\n+    use std::os::windows::prelude::*;\n+    use std::ptr;\n+\n+    use winapi::um::libloaderapi::{\n+        GetModuleFileNameW, GetModuleHandleExW, GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,\n+    };\n+\n+    unsafe {\n+        let mut module = ptr::null_mut();\n+        let r = GetModuleHandleExW(\n+            GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,\n+            current_dll_path as usize as *mut _,\n+            &mut module,\n+        );\n+        if r == 0 {\n+            return Err(format!(\"GetModuleHandleExW failed: {}\", io::Error::last_os_error()));\n+        }\n+        let mut space = Vec::with_capacity(1024);\n+        let r = GetModuleFileNameW(module, space.as_mut_ptr(), space.capacity() as u32);\n+        if r == 0 {\n+            return Err(format!(\"GetModuleFileNameW failed: {}\", io::Error::last_os_error()));\n+        }\n+        let r = r as usize;\n+        if r >= space.capacity() {\n+            return Err(format!(\"our buffer was too small? {}\", io::Error::last_os_error()));\n+        }\n+        space.set_len(r);\n+        let os = OsString::from_wide(&space);\n+        Ok(PathBuf::from(os))\n+    }\n+}\n+\n+pub fn sysroot_candidates() -> SmallVec<[PathBuf; 2]> {\n+    let target = crate::config::host_triple();\n+    let mut sysroot_candidates: SmallVec<[PathBuf; 2]> =\n+        smallvec![get_or_default_sysroot().expect(\"Failed finding sysroot\")];\n+    let path = current_dll_path().and_then(|s| Ok(s.canonicalize().map_err(|e| e.to_string())?));\n+    if let Ok(dll) = path {\n+        // use `parent` twice to chop off the file name and then also the\n+        // directory containing the dll which should be either `lib` or `bin`.\n+        if let Some(path) = dll.parent().and_then(|p| p.parent()) {\n+            // The original `path` pointed at the `rustc_driver` crate's dll.\n+            // Now that dll should only be in one of two locations. The first is\n+            // in the compiler's libdir, for example `$sysroot/lib/*.dll`. The\n+            // other is the target's libdir, for example\n+            // `$sysroot/lib/rustlib/$target/lib/*.dll`.\n+            //\n+            // We don't know which, so let's assume that if our `path` above\n+            // ends in `$target` we *could* be in the target libdir, and always\n+            // assume that we may be in the main libdir.\n+            sysroot_candidates.push(path.to_owned());\n+\n+            if path.ends_with(target) {\n+                sysroot_candidates.extend(\n+                    path.parent() // chop off `$target`\n+                        .and_then(|p| p.parent()) // chop off `rustlib`\n+                        .and_then(|p| p.parent()) // chop off `lib`\n+                        .map(|s| s.to_owned()),\n+                );\n+            }\n+        }\n+    }\n+\n+    return sysroot_candidates;\n+}\n+\n /// This function checks if sysroot is found using env::args().next(), and if it\n-/// is not found, uses env::current_exe() to imply sysroot.\n-pub fn get_or_default_sysroot() -> PathBuf {\n+/// is not found, finds sysroot from current rustc_driver dll.\n+pub fn get_or_default_sysroot() -> Result<PathBuf, String> {\n     // Follow symlinks.  If the resolved path is relative, make it absolute.\n     fn canonicalize(path: PathBuf) -> PathBuf {\n         let path = fs::canonicalize(&path).unwrap_or(path);\n@@ -74,17 +165,32 @@ pub fn get_or_default_sysroot() -> PathBuf {\n         fix_windows_verbatim_for_gcc(&path)\n     }\n \n-    // Use env::current_exe() to get the path of the executable following\n-    // symlinks/canonicalizing components.\n-    fn from_current_exe() -> PathBuf {\n-        match env::current_exe() {\n-            Ok(exe) => {\n-                let mut p = canonicalize(exe);\n-                p.pop();\n-                p.pop();\n-                p\n-            }\n-            Err(e) => panic!(\"failed to get current_exe: {e}\"),\n+    fn default_from_rustc_driver_dll() -> Result<PathBuf, String> {\n+        let dll = current_dll_path().and_then(|s| Ok(canonicalize(s)))?;\n+\n+        // `dll` will be in one of the following two:\n+        // - compiler's libdir: $sysroot/lib/*.dll\n+        // - target's libdir: $sysroot/lib/rustlib/$target/lib/*.dll\n+        //\n+        // use `parent` twice to chop off the file name and then also the\n+        // directory containing the dll\n+        let dir = dll.parent().and_then(|p| p.parent()).ok_or(format!(\n+            \"Could not move 2 levels upper using `parent()` on {}\",\n+            dll.display()\n+        ))?;\n+\n+        // if `dir` points target's dir, move up to the sysroot\n+        if dir.ends_with(crate::config::host_triple()) {\n+            dir.parent() // chop off `$target`\n+                .and_then(|p| p.parent()) // chop off `rustlib`\n+                .and_then(|p| p.parent()) // chop off `lib`\n+                .map(|s| s.to_owned())\n+                .ok_or(format!(\n+                    \"Could not move 3 levels upper using `parent()` on {}\",\n+                    dir.display()\n+                ))\n+        } else {\n+            Ok(dir.to_owned())\n         }\n     }\n \n@@ -118,7 +224,5 @@ pub fn get_or_default_sysroot() -> PathBuf {\n         }\n     }\n \n-    // Check if sysroot is found using env::args().next(), and if is not found,\n-    // use env::current_exe() to imply sysroot.\n-    from_env_args_next().unwrap_or_else(from_current_exe)\n+    Ok(from_env_args_next().unwrap_or(default_from_rustc_driver_dll()?))\n }"}, {"sha": "f9ee202466f67964ced1c4cafab319f51ab44733", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -181,7 +181,7 @@ top_level_options!(\n         #[rustc_lint_opt_deny_field_access(\"use `Session::codegen_units` instead of this field\")]\n         cli_forced_codegen_units: Option<usize> [UNTRACKED],\n         #[rustc_lint_opt_deny_field_access(\"use `Session::lto` instead of this field\")]\n-        cli_forced_thinlto_off: bool [UNTRACKED],\n+        cli_forced_local_thinlto_off: bool [UNTRACKED],\n \n         /// Remap source path prefixes in all output (messages, object files, debug, etc.).\n         remap_path_prefix: Vec<(PathBuf, PathBuf)> [TRACKED_NO_CRATE_HASH],\n@@ -1587,6 +1587,8 @@ options! {\n         \"choose the TLS model to use (`rustc --print tls-models` for details)\"),\n     trace_macros: bool = (false, parse_bool, [UNTRACKED],\n         \"for every macro invocation, print its name and arguments (default: no)\"),\n+    track_diagnostics: bool = (false, parse_bool, [UNTRACKED],\n+        \"tracks where in rustc a diagnostic was emitted\"),\n     // Diagnostics are considered side-effects of a query (see `QuerySideEffects`) and are saved\n     // alongside query results and changes to translation options can affect diagnostics - so\n     // translation options should be tracked."}, {"sha": "f9f4f2979c4eac3dd8d12f49d2fab810767ec1ad", "filename": "compiler/rustc_session/src/parse.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fparse.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -97,6 +97,7 @@ pub fn feature_err<'a>(\n ///\n /// This variant allows you to control whether it is a library or language feature.\n /// Almost always, you want to use this for a language feature. If so, prefer `feature_err`.\n+#[track_caller]\n pub fn feature_err_issue<'a>(\n     sess: &'a ParseSess,\n     feature: Symbol,\n@@ -332,24 +333,28 @@ impl ParseSess {\n         self.proc_macro_quoted_spans.lock().clone()\n     }\n \n+    #[track_caller]\n     pub fn create_err<'a>(\n         &'a self,\n         err: impl IntoDiagnostic<'a>,\n     ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n         err.into_diagnostic(&self.span_diagnostic)\n     }\n \n+    #[track_caller]\n     pub fn emit_err<'a>(&'a self, err: impl IntoDiagnostic<'a>) -> ErrorGuaranteed {\n         self.create_err(err).emit()\n     }\n \n+    #[track_caller]\n     pub fn create_warning<'a>(\n         &'a self,\n         warning: impl IntoDiagnostic<'a, ()>,\n     ) -> DiagnosticBuilder<'a, ()> {\n         warning.into_diagnostic(&self.span_diagnostic)\n     }\n \n+    #[track_caller]\n     pub fn emit_warning<'a>(&'a self, warning: impl IntoDiagnostic<'a, ()>) {\n         self.create_warning(warning).emit()\n     }\n@@ -377,6 +382,7 @@ impl ParseSess {\n     }\n \n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_err(\n         &self,\n         msg: impl Into<DiagnosticMessage>,"}, {"sha": "103521983578bc4d8670429afd93e6c3dde5cb6e", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 46, "deletions": 10, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -286,6 +286,7 @@ impl Session {\n     }\n \n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_span_warn<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n@@ -294,6 +295,7 @@ impl Session {\n         self.diagnostic().struct_span_warn(sp, msg)\n     }\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_span_warn_with_expectation<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n@@ -303,6 +305,7 @@ impl Session {\n         self.diagnostic().struct_span_warn_with_expectation(sp, msg, id)\n     }\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_span_warn_with_code<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n@@ -312,10 +315,12 @@ impl Session {\n         self.diagnostic().struct_span_warn_with_code(sp, msg, code)\n     }\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_warn(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, ()> {\n         self.diagnostic().struct_warn(msg)\n     }\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_warn_with_expectation(\n         &self,\n         msg: impl Into<DiagnosticMessage>,\n@@ -324,6 +329,7 @@ impl Session {\n         self.diagnostic().struct_warn_with_expectation(msg, id)\n     }\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_span_allow<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n@@ -332,10 +338,12 @@ impl Session {\n         self.diagnostic().struct_span_allow(sp, msg)\n     }\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_allow(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, ()> {\n         self.diagnostic().struct_allow(msg)\n     }\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_expect(\n         &self,\n         msg: impl Into<DiagnosticMessage>,\n@@ -344,6 +352,7 @@ impl Session {\n         self.diagnostic().struct_expect(msg, id)\n     }\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_span_err<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n@@ -352,6 +361,7 @@ impl Session {\n         self.diagnostic().struct_span_err(sp, msg)\n     }\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_span_err_with_code<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n@@ -362,12 +372,14 @@ impl Session {\n     }\n     // FIXME: This method should be removed (every error should have an associated error code).\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_err(\n         &self,\n         msg: impl Into<DiagnosticMessage>,\n     ) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n         self.parse_sess.struct_err(msg)\n     }\n+    #[track_caller]\n     #[rustc_lint_diagnostics]\n     pub fn struct_err_with_code(\n         &self,\n@@ -377,6 +389,7 @@ impl Session {\n         self.diagnostic().struct_err_with_code(msg, code)\n     }\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_warn_with_code(\n         &self,\n         msg: impl Into<DiagnosticMessage>,\n@@ -385,6 +398,7 @@ impl Session {\n         self.diagnostic().struct_warn_with_code(msg, code)\n     }\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_span_fatal<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n@@ -407,6 +421,7 @@ impl Session {\n     }\n \n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, msg: impl Into<DiagnosticMessage>) -> ! {\n         self.diagnostic().span_fatal(sp, msg)\n     }\n@@ -424,6 +439,7 @@ impl Session {\n         self.diagnostic().fatal(msg).raise()\n     }\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn span_err_or_warn<S: Into<MultiSpan>>(\n         &self,\n         is_warning: bool,\n@@ -437,6 +453,7 @@ impl Session {\n         }\n     }\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn span_err<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n@@ -457,12 +474,14 @@ impl Session {\n     pub fn err(&self, msg: impl Into<DiagnosticMessage>) -> ErrorGuaranteed {\n         self.diagnostic().err(msg)\n     }\n+    #[track_caller]\n     pub fn create_err<'a>(\n         &'a self,\n         err: impl IntoDiagnostic<'a>,\n     ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n         self.parse_sess.create_err(err)\n     }\n+    #[track_caller]\n     pub fn create_feature_err<'a>(\n         &'a self,\n         err: impl IntoDiagnostic<'a>,\n@@ -475,33 +494,40 @@ impl Session {\n         add_feature_diagnostics(&mut err, &self.parse_sess, feature);\n         err\n     }\n+    #[track_caller]\n     pub fn emit_err<'a>(&'a self, err: impl IntoDiagnostic<'a>) -> ErrorGuaranteed {\n         self.parse_sess.emit_err(err)\n     }\n+    #[track_caller]\n     pub fn create_warning<'a>(\n         &'a self,\n         err: impl IntoDiagnostic<'a, ()>,\n     ) -> DiagnosticBuilder<'a, ()> {\n         self.parse_sess.create_warning(err)\n     }\n+    #[track_caller]\n     pub fn emit_warning<'a>(&'a self, warning: impl IntoDiagnostic<'a, ()>) {\n         self.parse_sess.emit_warning(warning)\n     }\n+    #[track_caller]\n     pub fn create_note<'a>(\n         &'a self,\n         note: impl IntoDiagnostic<'a, Noted>,\n     ) -> DiagnosticBuilder<'a, Noted> {\n         self.parse_sess.create_note(note)\n     }\n+    #[track_caller]\n     pub fn emit_note<'a>(&'a self, note: impl IntoDiagnostic<'a, Noted>) -> Noted {\n         self.parse_sess.emit_note(note)\n     }\n+    #[track_caller]\n     pub fn create_fatal<'a>(\n         &'a self,\n         fatal: impl IntoDiagnostic<'a, !>,\n     ) -> DiagnosticBuilder<'a, !> {\n         self.parse_sess.create_fatal(fatal)\n     }\n+    #[track_caller]\n     pub fn emit_fatal<'a>(&'a self, fatal: impl IntoDiagnostic<'a, !>) -> ! {\n         self.parse_sess.emit_fatal(fatal)\n     }\n@@ -541,6 +567,7 @@ impl Session {\n     }\n     #[allow(rustc::untranslatable_diagnostic)]\n     #[allow(rustc::diagnostic_outside_of_impl)]\n+    #[track_caller]\n     pub fn span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: impl Into<DiagnosticMessage>) {\n         self.diagnostic().span_warn(sp, msg)\n     }\n@@ -587,6 +614,8 @@ impl Session {\n     pub fn note_without_error(&self, msg: impl Into<DiagnosticMessage>) {\n         self.diagnostic().note_without_error(msg)\n     }\n+\n+    #[track_caller]\n     pub fn span_note_without_error<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n@@ -989,11 +1018,8 @@ impl Session {\n                 return config::Lto::Fat;\n             }\n             config::LtoCli::Thin => {\n-                return if self.opts.cli_forced_thinlto_off {\n-                    config::Lto::Fat\n-                } else {\n-                    config::Lto::Thin\n-                };\n+                // The user explicitly asked for ThinLTO\n+                return config::Lto::Thin;\n             }\n         }\n \n@@ -1005,7 +1031,7 @@ impl Session {\n \n         // If processing command line options determined that we're incompatible\n         // with ThinLTO (e.g., `-C lto --emit llvm-ir`) then return that option.\n-        if self.opts.cli_forced_thinlto_off {\n+        if self.opts.cli_forced_local_thinlto_off {\n             return config::Lto::No;\n         }\n \n@@ -1213,6 +1239,7 @@ fn default_emitter(\n     fallback_bundle: LazyFallbackBundle,\n ) -> Box<dyn Emitter + sync::Send> {\n     let macro_backtrace = sopts.unstable_opts.macro_backtrace;\n+    let track_diagnostics = sopts.unstable_opts.track_diagnostics;\n     match sopts.error_format {\n         config::ErrorOutputType::HumanReadable(kind) => {\n             let (short, color_config) = kind.unzip();\n@@ -1236,6 +1263,7 @@ fn default_emitter(\n                     sopts.unstable_opts.teach,\n                     sopts.diagnostic_width,\n                     macro_backtrace,\n+                    track_diagnostics,\n                 );\n                 Box::new(emitter.ui_testing(sopts.unstable_opts.ui_testing))\n             }\n@@ -1250,6 +1278,7 @@ fn default_emitter(\n                 json_rendered,\n                 sopts.diagnostic_width,\n                 macro_backtrace,\n+                track_diagnostics,\n             )\n             .ui_testing(sopts.unstable_opts.ui_testing),\n         ),\n@@ -1280,7 +1309,7 @@ pub fn build_session(\n \n     let sysroot = match &sopts.maybe_sysroot {\n         Some(sysroot) => sysroot.clone(),\n-        None => filesearch::get_or_default_sysroot(),\n+        None => filesearch::get_or_default_sysroot().expect(\"Failed finding sysroot\"),\n     };\n \n     let target_cfg = config::build_target_config(&sopts, target_override, &sysroot);\n@@ -1552,11 +1581,18 @@ fn early_error_handler(output: config::ErrorOutputType) -> rustc_errors::Handler\n                 false,\n                 None,\n                 false,\n+                false,\n             ))\n         }\n-        config::ErrorOutputType::Json { pretty, json_rendered } => {\n-            Box::new(JsonEmitter::basic(pretty, json_rendered, None, fallback_bundle, None, false))\n-        }\n+        config::ErrorOutputType::Json { pretty, json_rendered } => Box::new(JsonEmitter::basic(\n+            pretty,\n+            json_rendered,\n+            None,\n+            fallback_bundle,\n+            None,\n+            false,\n+            false,\n+        )),\n     };\n     rustc_errors::Handler::with_emitter(true, None, emitter)\n }"}, {"sha": "cccc4897ecca6b35a1454559a2be2228179123f9", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -694,6 +694,7 @@ symbols! {\n         export_name,\n         expr,\n         extended_key_value_attributes,\n+        extended_varargs_abi_support,\n         extern_absolute_paths,\n         extern_crate_item_prelude,\n         extern_crate_self,\n@@ -813,6 +814,7 @@ symbols! {\n         impl_lint_pass,\n         impl_macros,\n         impl_trait_in_bindings,\n+        impl_trait_in_fn_trait_return,\n         implied_by,\n         import,\n         import_name_type,"}, {"sha": "2109b3c24962e6b4db7d1d01637decdcdeeb7f7b", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -654,8 +654,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n                             .builtin_deref(true)\n                             .expect(\"tried to dereference on non-ptr type\")\n                             .ty;\n-                        let dereferenced_const =\n-                            self.tcx.mk_const(ty::ConstS { kind: ct.kind(), ty: pointee_ty });\n+                        let dereferenced_const = self.tcx.mk_const(ct.kind(), pointee_ty);\n                         self = dereferenced_const.print(self)?;\n                     }\n                 }"}, {"sha": "cb2a0c04c6aa8ba1f82af68cd23ac67742afe4de", "filename": "compiler/rustc_target/src/spec/abi.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fabi.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -40,6 +40,28 @@ pub enum Abi {\n     RustCold,\n }\n \n+impl Abi {\n+    pub fn supports_varargs(self) -> bool {\n+        // * C and Cdecl obviously support varargs.\n+        // * C can be based on SysV64 or Win64, so they must support varargs.\n+        // * EfiApi is based on Win64 or C, so it also supports it.\n+        //\n+        // * Stdcall does not, because it would be impossible for the callee to clean\n+        //   up the arguments. (callee doesn't know how many arguments are there)\n+        // * Same for Fastcall, Vectorcall and Thiscall.\n+        // * System can become Stdcall, so is also a no-no.\n+        // * Other calling conventions are related to hardware or the compiler itself.\n+        match self {\n+            Self::C { .. }\n+            | Self::Cdecl { .. }\n+            | Self::Win64 { .. }\n+            | Self::SysV64 { .. }\n+            | Self::EfiApi => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n #[derive(Copy, Clone)]\n pub struct AbiData {\n     abi: Abi,"}, {"sha": "d062b36742d60550d1c639ee2ee54de642053800", "filename": "compiler/rustc_target/src/spec/apple/tests.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple%2Ftests.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -0,0 +1,20 @@\n+use crate::spec::{\n+    aarch64_apple_ios_sim, aarch64_apple_watchos_sim, x86_64_apple_ios, x86_64_apple_tvos,\n+    x86_64_apple_watchos_sim,\n+};\n+\n+#[test]\n+fn simulator_targets_set_abi() {\n+    let all_sim_targets = [\n+        x86_64_apple_ios::target(),\n+        x86_64_apple_tvos::target(),\n+        x86_64_apple_watchos_sim::target(),\n+        aarch64_apple_ios_sim::target(),\n+        // Note: There is currently no ARM64 tvOS simulator target\n+        aarch64_apple_watchos_sim::target(),\n+    ];\n+\n+    for target in all_sim_targets {\n+        assert_eq!(target.abi, \"sim\")\n+    }\n+}"}, {"sha": "148031b1569768eca63e872d67ae5f0ff00906da", "filename": "compiler/rustc_target/src/spec/apple_sdk_base.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_sdk_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_sdk_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_sdk_base.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -1,6 +1,10 @@\n use crate::spec::{cvs, TargetOptions};\n use std::borrow::Cow;\n \n+#[cfg(test)]\n+#[path = \"apple/tests.rs\"]\n+mod tests;\n+\n use Arch::*;\n #[allow(non_camel_case_types)]\n #[derive(Copy, Clone)]\n@@ -11,7 +15,9 @@ pub enum Arch {\n     Arm64,\n     Arm64_32,\n     I386,\n+    #[allow(dead_code)] // Some targets don't use this enum...\n     X86_64,\n+    X86_64_sim,\n     X86_64_macabi,\n     Arm64_macabi,\n     Arm64_sim,\n@@ -25,15 +31,17 @@ fn target_arch_name(arch: Arch) -> &'static str {\n         Arm64 | Arm64_macabi | Arm64_sim => \"arm64\",\n         Arm64_32 => \"arm64_32\",\n         I386 => \"i386\",\n-        X86_64 | X86_64_macabi => \"x86_64\",\n+        X86_64 | X86_64_sim | X86_64_macabi => \"x86_64\",\n     }\n }\n \n fn target_abi(arch: Arch) -> &'static str {\n     match arch {\n         Armv7 | Armv7k | Armv7s | Arm64 | Arm64_32 | I386 | X86_64 => \"\",\n         X86_64_macabi | Arm64_macabi => \"macabi\",\n-        Arm64_sim => \"sim\",\n+        // x86_64-apple-ios is a simulator target, even though it isn't\n+        // declared that way in the target like the other ones...\n+        Arm64_sim | X86_64_sim => \"sim\",\n     }\n }\n \n@@ -45,7 +53,7 @@ fn target_cpu(arch: Arch) -> &'static str {\n         Arm64 => \"apple-a7\",\n         Arm64_32 => \"apple-s4\",\n         I386 => \"yonah\",\n-        X86_64 => \"core2\",\n+        X86_64 | X86_64_sim => \"core2\",\n         X86_64_macabi => \"core2\",\n         Arm64_macabi => \"apple-a12\",\n         Arm64_sim => \"apple-a12\",\n@@ -54,19 +62,20 @@ fn target_cpu(arch: Arch) -> &'static str {\n \n fn link_env_remove(arch: Arch) -> Cow<'static, [Cow<'static, str>]> {\n     match arch {\n-        Armv7 | Armv7k | Armv7s | Arm64 | Arm64_32 | I386 | X86_64 | Arm64_sim => {\n+        Armv7 | Armv7k | Armv7s | Arm64 | Arm64_32 | I386 | X86_64 | X86_64_sim | Arm64_sim => {\n             cvs![\"MACOSX_DEPLOYMENT_TARGET\"]\n         }\n         X86_64_macabi | Arm64_macabi => cvs![\"IPHONEOS_DEPLOYMENT_TARGET\"],\n     }\n }\n \n pub fn opts(os: &'static str, arch: Arch) -> TargetOptions {\n+    let abi = target_abi(arch);\n     TargetOptions {\n-        abi: target_abi(arch).into(),\n+        abi: abi.into(),\n         cpu: target_cpu(arch).into(),\n         link_env_remove: link_env_remove(arch),\n         has_thread_local: false,\n-        ..super::apple_base::opts(os, target_arch_name(arch), target_abi(arch))\n+        ..super::apple_base::opts(os, target_arch_name(arch), abi)\n     }\n }"}, {"sha": "12a66efdd46f9af10bd20ad8ed599a17247f4e27", "filename": "compiler/rustc_target/src/spec/mipsel_sony_psx.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsel_sony_psx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsel_sony_psx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsel_sony_psx.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -0,0 +1,37 @@\n+use crate::spec::{cvs, Cc, LinkerFlavor, Lld, PanicStrategy, RelocModel, Target, TargetOptions};\n+\n+pub fn target() -> Target {\n+    Target {\n+        llvm_target: \"mipsel-sony-psx\".into(),\n+        pointer_width: 32,\n+        data_layout: \"e-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64\".into(),\n+        arch: \"mips\".into(),\n+\n+        options: TargetOptions {\n+            os: \"none\".into(),\n+            env: \"psx\".into(),\n+            vendor: \"sony\".into(),\n+            linker_flavor: LinkerFlavor::Gnu(Cc::No, Lld::Yes),\n+            cpu: \"mips1\".into(),\n+            executables: true,\n+            linker: Some(\"rust-lld\".into()),\n+            relocation_model: RelocModel::Static,\n+            exe_suffix: \".exe\".into(),\n+\n+            // PSX doesn't natively support floats.\n+            features: \"+soft-float\".into(),\n+\n+            // This should be 16 bits, but LLVM incorrectly tries emitting MIPS-II SYNC instructions\n+            // for atomic loads and stores. This crashes rustc so we have to disable the Atomic* API\n+            // until this is fixed upstream. See https://reviews.llvm.org/D122427#3420144 for more\n+            // info.\n+            max_atomic_width: Some(0),\n+\n+            // PSX does not support trap-on-condition instructions.\n+            llvm_args: cvs![\"-mno-check-zero-division\"],\n+            llvm_abiname: \"o32\".into(),\n+            panic_strategy: PanicStrategy::Abort,\n+            ..Default::default()\n+        },\n+    }\n+}"}, {"sha": "72b088d663b1f0bafaf144cfe4a6273f3b71be4d", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -1222,6 +1222,7 @@ supported_targets! {\n     (\"armv7a-kmc-solid_asp3-eabihf\", armv7a_kmc_solid_asp3_eabihf),\n \n     (\"mipsel-sony-psp\", mipsel_sony_psp),\n+    (\"mipsel-sony-psx\", mipsel_sony_psx),\n     (\"mipsel-unknown-none\", mipsel_unknown_none),\n     (\"thumbv4t-none-eabi\", thumbv4t_none_eabi),\n     (\"armv4t-none-eabi\", armv4t_none_eabi),"}, {"sha": "db23f01c233265c17bf20e27627eefc3402f181b", "filename": "compiler/rustc_target/src/spec/x86_64_apple_ios.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_ios.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -2,7 +2,7 @@ use super::apple_sdk_base::{opts, Arch};\n use crate::spec::{StackProbeType, Target, TargetOptions};\n \n pub fn target() -> Target {\n-    let base = opts(\"ios\", Arch::X86_64);\n+    let base = opts(\"ios\", Arch::X86_64_sim);\n     let llvm_target = super::apple_base::ios_sim_llvm_target(\"x86_64\");\n \n     Target {"}, {"sha": "c1fd8e1c8b90ac0b212d03e8d81a8ad308932b76", "filename": "compiler/rustc_target/src/spec/x86_64_apple_tvos.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_tvos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_tvos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_tvos.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -2,7 +2,7 @@ use super::apple_sdk_base::{opts, Arch};\n use crate::spec::{StackProbeType, Target, TargetOptions};\n \n pub fn target() -> Target {\n-    let base = opts(\"tvos\", Arch::X86_64);\n+    let base = opts(\"tvos\", Arch::X86_64_sim);\n     Target {\n         llvm_target: \"x86_64-apple-tvos\".into(),\n         pointer_width: 64,"}, {"sha": "550566b2aa754dc48c295e9ac1e673e3e16f4cf9", "filename": "compiler/rustc_target/src/spec/x86_64_apple_watchos_sim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_watchos_sim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_watchos_sim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_watchos_sim.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -2,7 +2,7 @@ use super::apple_sdk_base::{opts, Arch};\n use crate::spec::{StackProbeType, Target, TargetOptions};\n \n pub fn target() -> Target {\n-    let base = opts(\"watchos\", Arch::X86_64);\n+    let base = opts(\"watchos\", Arch::X86_64_sim);\n \n     let arch = \"x86_64\";\n     let llvm_target = super::apple_base::watchos_sim_llvm_target(arch);"}, {"sha": "23c3715860ea6a4669737d2cd479b205a6048aa2", "filename": "compiler/rustc_trait_selection/src/errors.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_trait_selection%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_trait_selection%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ferrors.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -67,6 +67,7 @@ pub struct NegativePositiveConflict<'a> {\n }\n \n impl IntoDiagnostic<'_> for NegativePositiveConflict<'_> {\n+    #[track_caller]\n     fn into_diagnostic(\n         self,\n         handler: &Handler,"}, {"sha": "96ac4e9c1292a9cba25ade5404ed5bac49e22467", "filename": "compiler/rustc_trait_selection/src/infer.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -1,5 +1,5 @@\n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n-use crate::traits::{self, TraitEngine, TraitEngineExt};\n+use crate::traits::{self, ObligationCtxt};\n \n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n@@ -142,7 +142,7 @@ pub trait InferCtxtBuilderExt<'tcx> {\n     fn enter_canonical_trait_query<K, R>(\n         &mut self,\n         canonical_key: &Canonical<'tcx, K>,\n-        operation: impl FnOnce(&InferCtxt<'tcx>, &mut dyn TraitEngine<'tcx>, K) -> Fallible<R>,\n+        operation: impl FnOnce(&ObligationCtxt<'_, 'tcx>, K) -> Fallible<R>,\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, R>>\n     where\n         K: TypeFoldable<'tcx>,\n@@ -170,17 +170,17 @@ impl<'tcx> InferCtxtBuilderExt<'tcx> for InferCtxtBuilder<'tcx> {\n     fn enter_canonical_trait_query<K, R>(\n         &mut self,\n         canonical_key: &Canonical<'tcx, K>,\n-        operation: impl FnOnce(&InferCtxt<'tcx>, &mut dyn TraitEngine<'tcx>, K) -> Fallible<R>,\n+        operation: impl FnOnce(&ObligationCtxt<'_, 'tcx>, K) -> Fallible<R>,\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, R>>\n     where\n         K: TypeFoldable<'tcx>,\n         R: Debug + TypeFoldable<'tcx>,\n         Canonical<'tcx, QueryResponse<'tcx, R>>: ArenaAllocatable<'tcx>,\n     {\n-        let (ref infcx, key, canonical_inference_vars) =\n+        let (infcx, key, canonical_inference_vars) =\n             self.build_with_canonical(DUMMY_SP, canonical_key);\n-        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-        let value = operation(infcx, &mut *fulfill_cx, key)?;\n-        infcx.make_canonicalized_query_response(canonical_inference_vars, value, &mut *fulfill_cx)\n+        let ocx = ObligationCtxt::new(&infcx);\n+        let value = operation(&ocx, key)?;\n+        ocx.make_canonicalized_query_response(canonical_inference_vars, value)\n     }\n }"}, {"sha": "21516c93efb53aa8b33e681938a61c1701f54d35", "filename": "compiler/rustc_trait_selection/src/traits/engine.rs", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -1,14 +1,21 @@\n use std::cell::RefCell;\n+use std::fmt::Debug;\n \n use super::TraitEngine;\n use super::{ChalkFulfillmentContext, FulfillmentContext};\n use crate::infer::InferCtxtExt;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_infer::infer::at::ToTrace;\n+use rustc_infer::infer::canonical::{\n+    Canonical, CanonicalVarValues, CanonicalizedQueryResponse, QueryResponse,\n+};\n use rustc_infer::infer::{InferCtxt, InferOk};\n+use rustc_infer::traits::query::Fallible;\n use rustc_infer::traits::{\n     FulfillmentError, Obligation, ObligationCause, PredicateObligation, TraitEngineExt as _,\n };\n+use rustc_middle::arena::ArenaAllocatable;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::ToPredicate;\n use rustc_middle::ty::TypeFoldable;\n@@ -105,12 +112,12 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n         self.register_infer_ok_obligations(infer_ok)\n     }\n \n-    pub fn equate_types(\n+    pub fn eq<T: ToTrace<'tcx>>(\n         &self,\n         cause: &ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        expected: Ty<'tcx>,\n-        actual: Ty<'tcx>,\n+        expected: T,\n+        actual: T,\n     ) -> Result<(), TypeError<'tcx>> {\n         match self.infcx.at(cause, param_env).eq(expected, actual) {\n             Ok(InferOk { obligations, value: () }) => {\n@@ -121,6 +128,22 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n         }\n     }\n \n+    pub fn sup<T: ToTrace<'tcx>>(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        expected: T,\n+        actual: T,\n+    ) -> Result<(), TypeError<'tcx>> {\n+        match self.infcx.at(cause, param_env).sup(expected, actual) {\n+            Ok(InferOk { obligations, value: () }) => {\n+                self.register_obligations(obligations);\n+                Ok(())\n+            }\n+            Err(e) => Err(e),\n+        }\n+    }\n+\n     pub fn select_all_or_error(&self) -> Vec<FulfillmentError<'tcx>> {\n         self.engine.borrow_mut().select_all_or_error(self.infcx)\n     }\n@@ -154,4 +177,20 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n         }\n         implied_bounds\n     }\n+\n+    pub fn make_canonicalized_query_response<T>(\n+        &self,\n+        inference_vars: CanonicalVarValues<'tcx>,\n+        answer: T,\n+    ) -> Fallible<CanonicalizedQueryResponse<'tcx, T>>\n+    where\n+        T: Debug + TypeFoldable<'tcx>,\n+        Canonical<'tcx, QueryResponse<'tcx, T>>: ArenaAllocatable<'tcx>,\n+    {\n+        self.infcx.make_canonicalized_query_response(\n+            inference_vars,\n+            answer,\n+            &mut **self.engine.borrow_mut(),\n+        )\n+    }\n }"}, {"sha": "dacce5cd2f6059bd33588e3af6a3bbdb273d557e", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -974,7 +974,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                 // useful for less general traits.\n                                 if peeled\n                                     && !self.tcx.trait_is_auto(def_id)\n-                                    && !self.tcx.lang_items().items().contains(&Some(def_id))\n+                                    && !self.tcx.lang_items().iter().any(|(_, id)| id == def_id)\n                                 {\n                                     let trait_ref = trait_pred.to_poly_trait_ref();\n                                     let impl_candidates =\n@@ -1898,7 +1898,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         let def_id = trait_ref.def_id();\n         if impl_candidates.is_empty() {\n             if self.tcx.trait_is_auto(def_id)\n-                || self.tcx.lang_items().items().contains(&Some(def_id))\n+                || self.tcx.lang_items().iter().any(|(_, id)| id == def_id)\n                 || self.tcx.get_diagnostic_name(def_id).is_some()\n             {\n                 // Mentioning implementers of `Copy`, `Debug` and friends is not useful."}, {"sha": "d7606d88803dc2229fa3e1a08f2d390ca5fbc1c9", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -1019,7 +1019,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         let mut never_suggest_borrow: Vec<_> =\n             [LangItem::Copy, LangItem::Clone, LangItem::Unpin, LangItem::Sized]\n                 .iter()\n-                .filter_map(|lang_item| self.tcx.lang_items().require(*lang_item).ok())\n+                .filter_map(|lang_item| self.tcx.lang_items().get(*lang_item))\n                 .collect();\n \n         if let Some(def_id) = self.tcx.get_diagnostic_item(sym::Send) {"}, {"sha": "9ee6e0a2bf3a20337df5928b9569efd69b572c7c", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -390,6 +390,7 @@ pub fn normalize_param_env_or_error<'tcx>(\n }\n \n /// Normalize a type and process all resulting obligations, returning any errors\n+#[instrument(skip_all)]\n pub fn fully_normalize<'tcx, T>(\n     infcx: &InferCtxt<'tcx>,\n     cause: ObligationCause<'tcx>,\n@@ -399,28 +400,18 @@ pub fn fully_normalize<'tcx, T>(\n where\n     T: TypeFoldable<'tcx>,\n {\n-    debug!(\"fully_normalize_with_fulfillcx(value={:?})\", value);\n-    let selcx = &mut SelectionContext::new(infcx);\n-    let Normalized { value: normalized_value, obligations } =\n-        project::normalize(selcx, param_env, cause, value);\n-    debug!(\n-        \"fully_normalize: normalized_value={:?} obligations={:?}\",\n-        normalized_value, obligations\n-    );\n-\n-    let mut fulfill_cx = FulfillmentContext::new();\n-    for obligation in obligations {\n-        fulfill_cx.register_predicate_obligation(infcx, obligation);\n-    }\n-\n-    debug!(\"fully_normalize: select_all_or_error start\");\n-    let errors = fulfill_cx.select_all_or_error(infcx);\n+    let ocx = ObligationCtxt::new(infcx);\n+    debug!(?value);\n+    let normalized_value = ocx.normalize(cause, param_env, value);\n+    debug!(?normalized_value);\n+    debug!(\"select_all_or_error start\");\n+    let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n         return Err(errors);\n     }\n-    debug!(\"fully_normalize: select_all_or_error complete\");\n+    debug!(\"select_all_or_error complete\");\n     let resolved_value = infcx.resolve_vars_if_possible(normalized_value);\n-    debug!(\"fully_normalize: resolved_value={:?}\", resolved_value);\n+    debug!(?resolved_value);\n     Ok(resolved_value)\n }\n "}, {"sha": "fb062ea71c4ce775bf6c74cf4c153dde6a74a1f3", "filename": "compiler/rustc_trait_selection/src/traits/on_unimplemented.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -27,6 +27,7 @@ pub struct OnUnimplementedDirective {\n }\n \n #[derive(Default)]\n+/// For the `#[rustc_on_unimplemented]` attribute\n pub struct OnUnimplementedNote {\n     pub message: Option<String>,\n     pub label: Option<String>,"}, {"sha": "b1a161c353637610c4d3fd3caad65ed26bb0219e", "filename": "compiler/rustc_trait_selection/src/traits/outlives_bounds.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -1,7 +1,7 @@\n use crate::infer::InferCtxt;\n use crate::traits::query::type_op::{self, TypeOp, TypeOpOutput};\n use crate::traits::query::NoSolution;\n-use crate::traits::{ObligationCause, TraitEngine, TraitEngineExt};\n+use crate::traits::ObligationCause;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::HirId;\n@@ -74,20 +74,20 @@ impl<'a, 'tcx: 'a> InferCtxtExt<'a, 'tcx> for InferCtxt<'tcx> {\n             debug!(?constraints);\n             // Instantiation may have produced new inference variables and constraints on those\n             // variables. Process these constraints.\n-            let mut fulfill_cx = <dyn TraitEngine<'tcx>>::new(self.tcx);\n             let cause = ObligationCause::misc(span, body_id);\n-            for &constraint in &constraints.outlives {\n-                let obligation = self.query_outlives_constraint_to_obligation(\n-                    constraint,\n-                    cause.clone(),\n-                    param_env,\n-                );\n-                fulfill_cx.register_predicate_obligation(self, obligation);\n-            }\n+            let errors = super::fully_solve_obligations(\n+                self,\n+                constraints.outlives.iter().map(|constraint| {\n+                    self.query_outlives_constraint_to_obligation(\n+                        *constraint,\n+                        cause.clone(),\n+                        param_env,\n+                    )\n+                }),\n+            );\n             if !constraints.member_constraints.is_empty() {\n                 span_bug!(span, \"{:#?}\", constraints.member_constraints);\n             }\n-            let errors = fulfill_cx.select_all_or_error(self);\n             if !errors.is_empty() {\n                 self.tcx.sess.delay_span_bug(\n                     span,"}, {"sha": "daee5dd8f02e6ed14a210c950bdf429a59d1b25c", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -831,9 +831,7 @@ impl<'tcx> TypeFolder<'tcx> for BoundVarReplacer<'_, 'tcx> {\n                 let universe = self.universe_for(debruijn);\n                 let p = ty::PlaceholderConst { universe, name: bound_const };\n                 self.mapped_consts.insert(p, bound_const);\n-                self.infcx\n-                    .tcx\n-                    .mk_const(ty::ConstS { kind: ty::ConstKind::Placeholder(p), ty: ct.ty() })\n+                self.infcx.tcx.mk_const(ty::ConstKind::Placeholder(p), ct.ty())\n             }\n             _ => ct.super_fold_with(self),\n         }\n@@ -968,10 +966,7 @@ impl<'tcx> TypeFolder<'tcx> for PlaceholderReplacer<'_, 'tcx> {\n                     let db = ty::DebruijnIndex::from_usize(\n                         self.universe_indices.len() - index + self.current_index.as_usize() - 1,\n                     );\n-                    self.tcx().mk_const(ty::ConstS {\n-                        kind: ty::ConstKind::Bound(db, *replace_var),\n-                        ty: ct.ty(),\n-                    })\n+                    self.tcx().mk_const(ty::ConstKind::Bound(db, *replace_var), ct.ty())\n                 }\n                 None => ct,\n             }\n@@ -2173,7 +2168,7 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n             crate::traits::InternalSubsts::identity_for_item(tcx, assoc_ty.item.def_id);\n         let did = ty::WithOptConstParam::unknown(assoc_ty.item.def_id);\n         let kind = ty::ConstKind::Unevaluated(ty::UnevaluatedConst::new(did, identity_substs));\n-        ty.map_bound(|ty| tcx.mk_const(ty::ConstS { ty, kind }).into())\n+        ty.map_bound(|ty| tcx.mk_const(kind, ty).into())\n     } else {\n         ty.map_bound(|ty| ty.into())\n     };"}, {"sha": "28b4bae7cbecf2c44e6f50c86d4d7f78147d2d10", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -555,13 +555,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             GenericParamDefKind::Const { .. } => {\n                                 let bound_var = ty::BoundVariableKind::Const;\n                                 bound_vars.push(bound_var);\n-                                tcx.mk_const(ty::ConstS {\n-                                    ty: tcx.type_of(param.def_id),\n-                                    kind: ty::ConstKind::Bound(\n+                                tcx.mk_const(\n+                                    ty::ConstKind::Bound(\n                                         ty::INNERMOST,\n                                         ty::BoundVar::from_usize(bound_vars.len() - 1),\n                                     ),\n-                                })\n+                                    tcx.type_of(param.def_id),\n+                                )\n                                 .into()\n                             }\n                         });"}, {"sha": "2035252fe39a63bb66611c6e84cfebab0e954541", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -734,10 +734,10 @@ fn bound_vars_for_item<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> SubstsRef<'tcx\n         }\n \n         ty::GenericParamDefKind::Const { .. } => tcx\n-            .mk_const(ty::ConstS {\n-                kind: ty::ConstKind::Bound(ty::INNERMOST, ty::BoundVar::from(param.index)),\n-                ty: tcx.type_of(param.def_id),\n-            })\n+            .mk_const(\n+                ty::ConstKind::Bound(ty::INNERMOST, ty::BoundVar::from(param.index)),\n+                tcx.type_of(param.def_id),\n+            )\n             .into(),\n     })\n }"}, {"sha": "0492e94b94e9830d602f2cdee3a8940abf488cb7", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -546,7 +546,7 @@ impl<'tcx> LowerInto<'tcx, ty::Const<'tcx>> for &chalk_ir::Const<RustInterner<'t\n             chalk_ir::ConstValue::Placeholder(_p) => unimplemented!(),\n             chalk_ir::ConstValue::Concrete(c) => ty::ConstKind::Value(c.interned),\n         };\n-        interner.tcx.mk_const(ty::ConstS { ty, kind })\n+        interner.tcx.mk_const(kind, ty)\n     }\n }\n "}, {"sha": "82f6111f6f92e440e66dd4a5bb31b68d34ac6c8b", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -28,9 +28,9 @@ fn implied_outlives_bounds<'tcx>(\n     &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, Vec<OutlivesBound<'tcx>>>>,\n     NoSolution,\n > {\n-    tcx.infer_ctxt().enter_canonical_trait_query(&goal, |infcx, _fulfill_cx, key| {\n+    tcx.infer_ctxt().enter_canonical_trait_query(&goal, |ocx, key| {\n         let (param_env, ty) = key.into_parts();\n-        compute_implied_outlives_bounds(&infcx, param_env, ty)\n+        compute_implied_outlives_bounds(&ocx.infcx, param_env, ty)\n     })\n }\n "}, {"sha": "0ffa92f1ad55d960310e1625e13f53c362ea0e09", "filename": "compiler/rustc_traits/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Flib.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -3,6 +3,7 @@\n \n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n+#![feature(let_chains)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "e805eb4282119b5db40be90ebe6a6324ffa9f382", "filename": "compiler/rustc_traits/src/normalize_projection_ty.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_traits%2Fsrc%2Fnormalize_projection_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_traits%2Fsrc%2Fnormalize_projection_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_projection_ty.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -1,6 +1,5 @@\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_infer::traits::TraitEngineExt as _;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{ParamEnvAnd, TyCtxt};\n use rustc_trait_selection::infer::InferCtxtBuilderExt;\n@@ -23,8 +22,8 @@ fn normalize_projection_ty<'tcx>(\n     tcx.sess.perf_stats.normalize_projection_ty.fetch_add(1, Ordering::Relaxed);\n     tcx.infer_ctxt().enter_canonical_trait_query(\n         &goal,\n-        |infcx, fulfill_cx, ParamEnvAnd { param_env, value: goal }| {\n-            let selcx = &mut SelectionContext::new(infcx);\n+        |ocx, ParamEnvAnd { param_env, value: goal }| {\n+            let selcx = &mut SelectionContext::new(ocx.infcx);\n             let cause = ObligationCause::dummy();\n             let mut obligations = vec![];\n             let answer = traits::normalize_projection_type(\n@@ -35,7 +34,7 @@ fn normalize_projection_ty<'tcx>(\n                 0,\n                 &mut obligations,\n             );\n-            fulfill_cx.register_predicate_obligations(infcx, obligations);\n+            ocx.register_obligations(obligations);\n             // FIXME(associated_const_equality): All users of normalize_projection_ty expected\n             // a type, but there is the possibility it could've been a const now. Maybe change\n             // it to a Term later?"}, {"sha": "98cb3f21555ac238e1add134dff545fc097d20d2", "filename": "compiler/rustc_traits/src/type_op.rs", "status": "modified", "additions": 41, "deletions": 76, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -2,25 +2,22 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::at::ToTrace;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n-use rustc_infer::infer::{DefiningAnchor, InferCtxt, TyCtxtInferExt};\n-use rustc_infer::traits::{ObligationCauseCode, TraitEngineExt as _};\n+use rustc_infer::infer::{DefiningAnchor, TyCtxtInferExt};\n+use rustc_infer::traits::ObligationCauseCode;\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{\n-    self, EarlyBinder, FnSig, Lift, PolyFnSig, Ty, TyCtxt, TypeFoldable, Variance,\n-};\n-use rustc_middle::ty::{GenericArg, UserSelfTy, UserSubsts};\n-use rustc_middle::ty::{ParamEnv, ParamEnvAnd, Predicate, ToPredicate};\n+use rustc_middle::ty::{self, FnSig, Lift, PolyFnSig, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{ParamEnvAnd, Predicate, ToPredicate};\n+use rustc_middle::ty::{UserSelfTy, UserSubsts};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_trait_selection::infer::InferCtxtBuilderExt;\n-use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::query::normalize::AtExt;\n use rustc_trait_selection::traits::query::type_op::ascribe_user_type::AscribeUserType;\n use rustc_trait_selection::traits::query::type_op::eq::Eq;\n use rustc_trait_selection::traits::query::type_op::normalize::Normalize;\n use rustc_trait_selection::traits::query::type_op::prove_predicate::ProvePredicate;\n use rustc_trait_selection::traits::query::type_op::subtype::Subtype;\n use rustc_trait_selection::traits::query::{Fallible, NoSolution};\n-use rustc_trait_selection::traits::{Normalized, Obligation, ObligationCause, TraitEngine};\n+use rustc_trait_selection::traits::{Normalized, Obligation, ObligationCause, ObligationCtxt};\n use std::fmt;\n use std::iter::zip;\n \n@@ -42,17 +39,16 @@ fn type_op_ascribe_user_type<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, AscribeUserType<'tcx>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, NoSolution> {\n-    tcx.infer_ctxt().enter_canonical_trait_query(&canonicalized, |infcx, fulfill_cx, key| {\n-        type_op_ascribe_user_type_with_span(infcx, fulfill_cx, key, None)\n+    tcx.infer_ctxt().enter_canonical_trait_query(&canonicalized, |ocx, key| {\n+        type_op_ascribe_user_type_with_span(ocx, key, None)\n     })\n }\n \n /// The core of the `type_op_ascribe_user_type` query: for diagnostics purposes in NLL HRTB errors,\n /// this query can be re-run to better track the span of the obligation cause, and improve the error\n /// message. Do not call directly unless you're in that very specific context.\n-pub fn type_op_ascribe_user_type_with_span<'a, 'tcx: 'a>(\n-    infcx: &'a InferCtxt<'tcx>,\n-    fulfill_cx: &'a mut dyn TraitEngine<'tcx>,\n+pub fn type_op_ascribe_user_type_with_span<'tcx>(\n+    ocx: &ObligationCtxt<'_, 'tcx>,\n     key: ParamEnvAnd<'tcx, AscribeUserType<'tcx>>,\n     span: Option<Span>,\n ) -> Result<(), NoSolution> {\n@@ -61,89 +57,69 @@ pub fn type_op_ascribe_user_type_with_span<'a, 'tcx: 'a>(\n         \"type_op_ascribe_user_type: mir_ty={:?} def_id={:?} user_substs={:?}\",\n         mir_ty, def_id, user_substs\n     );\n-\n-    let mut cx = AscribeUserTypeCx { infcx, param_env, span: span.unwrap_or(DUMMY_SP), fulfill_cx };\n+    let cx = AscribeUserTypeCx { ocx, param_env, span: span.unwrap_or(DUMMY_SP) };\n     cx.relate_mir_and_user_ty(mir_ty, def_id, user_substs)?;\n     Ok(())\n }\n \n struct AscribeUserTypeCx<'me, 'tcx> {\n-    infcx: &'me InferCtxt<'tcx>,\n-    param_env: ParamEnv<'tcx>,\n+    ocx: &'me ObligationCtxt<'me, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     span: Span,\n-    fulfill_cx: &'me mut dyn TraitEngine<'tcx>,\n }\n \n impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n-    fn normalize<T>(&mut self, value: T) -> T\n+    fn normalize<T>(&self, value: T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n         self.normalize_with_cause(value, ObligationCause::misc(self.span, hir::CRATE_HIR_ID))\n     }\n \n-    fn normalize_with_cause<T>(&mut self, value: T, cause: ObligationCause<'tcx>) -> T\n+    fn normalize_with_cause<T>(&self, value: T, cause: ObligationCause<'tcx>) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        self.infcx\n-            .partially_normalize_associated_types_in(cause, self.param_env, value)\n-            .into_value_registering_obligations(self.infcx, self.fulfill_cx)\n+        self.ocx.normalize(cause, self.param_env, value)\n     }\n \n-    fn relate<T>(&mut self, a: T, variance: Variance, b: T) -> Result<(), NoSolution>\n+    fn eq<T>(&self, a: T, b: T) -> Result<(), NoSolution>\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.infcx\n-            .at(&ObligationCause::dummy_with_span(self.span), self.param_env)\n-            .relate(a, variance, b)?\n-            .into_value_registering_obligations(self.infcx, self.fulfill_cx);\n-        Ok(())\n+        Ok(self.ocx.eq(&ObligationCause::dummy_with_span(self.span), self.param_env, a, b)?)\n     }\n \n-    fn prove_predicate(&mut self, predicate: Predicate<'tcx>, cause: ObligationCause<'tcx>) {\n-        self.fulfill_cx.register_predicate_obligation(\n-            self.infcx,\n-            Obligation::new(cause, self.param_env, predicate),\n-        );\n+    fn prove_predicate(&self, predicate: Predicate<'tcx>, cause: ObligationCause<'tcx>) {\n+        self.ocx.register_obligation(Obligation::new(cause, self.param_env, predicate));\n     }\n \n     fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.infcx.tcx\n-    }\n-\n-    fn subst<T>(&self, value: T, substs: &[GenericArg<'tcx>]) -> T\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        EarlyBinder(value).subst(self.tcx(), substs)\n+        self.ocx.infcx.tcx\n     }\n \n     #[instrument(level = \"debug\", skip(self))]\n     fn relate_mir_and_user_ty(\n-        &mut self,\n+        &self,\n         mir_ty: Ty<'tcx>,\n         def_id: DefId,\n         user_substs: UserSubsts<'tcx>,\n     ) -> Result<(), NoSolution> {\n         let UserSubsts { user_self_ty, substs } = user_substs;\n         let tcx = self.tcx();\n \n-        let ty = tcx.type_of(def_id);\n-        let ty = self.subst(ty, substs);\n+        let ty = tcx.bound_type_of(def_id).subst(tcx, substs);\n         let ty = self.normalize(ty);\n         debug!(\"relate_type_and_user_type: ty of def-id is {:?}\", ty);\n \n-        self.relate(mir_ty, Variance::Invariant, ty)?;\n+        self.eq(mir_ty, ty)?;\n \n         // Prove the predicates coming along with `def_id`.\n         //\n         // Also, normalize the `instantiated_predicates`\n         // because otherwise we wind up with duplicate \"type\n         // outlives\" error messages.\n-        let instantiated_predicates =\n-            self.tcx().predicates_of(def_id).instantiate(self.tcx(), substs);\n+        let instantiated_predicates = tcx.predicates_of(def_id).instantiate(tcx, substs);\n \n         let cause = ObligationCause::dummy_with_span(self.span);\n \n@@ -163,15 +139,14 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n         }\n \n         if let Some(UserSelfTy { impl_def_id, self_ty }) = user_self_ty {\n-            let impl_self_ty = self.tcx().type_of(impl_def_id);\n-            let impl_self_ty = self.subst(impl_self_ty, &substs);\n+            let impl_self_ty = tcx.bound_type_of(impl_def_id).subst(tcx, substs);\n             let impl_self_ty = self.normalize(impl_self_ty);\n \n-            self.relate(self_ty, Variance::Invariant, impl_self_ty)?;\n+            self.eq(self_ty, impl_self_ty)?;\n \n             self.prove_predicate(\n                 ty::Binder::dummy(ty::PredicateKind::WellFormed(impl_self_ty.into()))\n-                    .to_predicate(self.tcx()),\n+                    .to_predicate(tcx),\n                 cause.clone(),\n             );\n         }\n@@ -188,7 +163,7 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n         // type were ill-formed but did not appear in `ty`,\n         // which...could happen with normalization...\n         self.prove_predicate(\n-            ty::Binder::dummy(ty::PredicateKind::WellFormed(ty.into())).to_predicate(self.tcx()),\n+            ty::Binder::dummy(ty::PredicateKind::WellFormed(ty.into())).to_predicate(tcx),\n             cause,\n         );\n         Ok(())\n@@ -199,28 +174,23 @@ fn type_op_eq<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Eq<'tcx>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, NoSolution> {\n-    tcx.infer_ctxt().enter_canonical_trait_query(&canonicalized, |infcx, fulfill_cx, key| {\n+    tcx.infer_ctxt().enter_canonical_trait_query(&canonicalized, |ocx, key| {\n         let (param_env, Eq { a, b }) = key.into_parts();\n-        infcx\n-            .at(&ObligationCause::dummy(), param_env)\n-            .eq(a, b)?\n-            .into_value_registering_obligations(infcx, fulfill_cx);\n-        Ok(())\n+        Ok(ocx.eq(&ObligationCause::dummy(), param_env, a, b)?)\n     })\n }\n \n fn type_op_normalize<'tcx, T>(\n-    infcx: &InferCtxt<'tcx>,\n-    fulfill_cx: &mut dyn TraitEngine<'tcx>,\n+    ocx: &ObligationCtxt<'_, 'tcx>,\n     key: ParamEnvAnd<'tcx, Normalize<T>>,\n ) -> Fallible<T>\n where\n     T: fmt::Debug + TypeFoldable<'tcx> + Lift<'tcx>,\n {\n     let (param_env, Normalize { value }) = key.into_parts();\n     let Normalized { value, obligations } =\n-        infcx.at(&ObligationCause::dummy(), param_env).normalize(value)?;\n-    fulfill_cx.register_predicate_obligations(infcx, obligations);\n+        ocx.infcx.at(&ObligationCause::dummy(), param_env).normalize(value)?;\n+    ocx.register_obligations(obligations);\n     Ok(value)\n }\n \n@@ -256,13 +226,9 @@ fn type_op_subtype<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Subtype<'tcx>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, NoSolution> {\n-    tcx.infer_ctxt().enter_canonical_trait_query(&canonicalized, |infcx, fulfill_cx, key| {\n+    tcx.infer_ctxt().enter_canonical_trait_query(&canonicalized, |ocx, key| {\n         let (param_env, Subtype { sub, sup }) = key.into_parts();\n-        infcx\n-            .at(&ObligationCause::dummy(), param_env)\n-            .sup(sup, sub)?\n-            .into_value_registering_obligations(infcx, fulfill_cx);\n-        Ok(())\n+        Ok(ocx.sup(&ObligationCause::dummy(), param_env, sup, sub)?)\n     })\n }\n \n@@ -274,8 +240,8 @@ fn type_op_prove_predicate<'tcx>(\n     // impl-trait/issue-99642.rs\n     tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).enter_canonical_trait_query(\n         &canonicalized,\n-        |infcx, fulfill_cx, key| {\n-            type_op_prove_predicate_with_cause(infcx, fulfill_cx, key, ObligationCause::dummy());\n+        |ocx, key| {\n+            type_op_prove_predicate_with_cause(ocx, key, ObligationCause::dummy());\n             Ok(())\n         },\n     )\n@@ -284,12 +250,11 @@ fn type_op_prove_predicate<'tcx>(\n /// The core of the `type_op_prove_predicate` query: for diagnostics purposes in NLL HRTB errors,\n /// this query can be re-run to better track the span of the obligation cause, and improve the error\n /// message. Do not call directly unless you're in that very specific context.\n-pub fn type_op_prove_predicate_with_cause<'a, 'tcx: 'a>(\n-    infcx: &'a InferCtxt<'tcx>,\n-    fulfill_cx: &'a mut dyn TraitEngine<'tcx>,\n+pub fn type_op_prove_predicate_with_cause<'tcx>(\n+    ocx: &ObligationCtxt<'_, 'tcx>,\n     key: ParamEnvAnd<'tcx, ProvePredicate<'tcx>>,\n     cause: ObligationCause<'tcx>,\n ) {\n     let (param_env, ProvePredicate { predicate }) = key.into_parts();\n-    fulfill_cx.register_predicate_obligation(infcx, Obligation::new(cause, param_env, predicate));\n+    ocx.register_obligation(Obligation::new(cause, param_env, predicate));\n }"}, {"sha": "2bc6bc1fc23aefd98135e45626a433f34acc721f", "filename": "compiler/rustc_transmute/src/layout/tree.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Ftree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Ftree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Ftree.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -284,7 +284,8 @@ pub(crate) mod rustc {\n                 }\n \n                 ty::Array(ty, len) => {\n-                    let len = len.try_eval_usize(tcx, ParamEnv::reveal_all()).unwrap();\n+                    let len =\n+                        len.try_eval_usize(tcx, ParamEnv::reveal_all()).ok_or(Err::Unspecified)?;\n                     let elt = Tree::from_ty(*ty, tcx)?;\n                     Ok(std::iter::repeat(elt)\n                         .take(len as usize)"}, {"sha": "384d03106b1e8c1cc67760bbfdf3345a741bb859", "filename": "compiler/rustc_transmute/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_transmute%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_transmute%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Flib.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -122,7 +122,7 @@ mod rustc {\n \n             let c = c.eval(tcx, param_env);\n \n-            if let Some(err) = c.error_reported() {\n+            if let Err(err) = c.error_reported() {\n                 return Some(Self {\n                     alignment: true,\n                     lifetimes: true,"}, {"sha": "3cef47c0f8ba481d2b3bde2a117b38be3ae5bb18", "filename": "compiler/rustc_ty_utils/src/consts.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -33,7 +33,7 @@ pub(crate) fn destructure_const<'tcx>(\n             // construct the consts for the elements of the array/slice\n             let field_consts = branches\n                 .iter()\n-                .map(|b| tcx.mk_const(ty::ConstS { kind: ty::ConstKind::Value(*b), ty: *inner_ty }))\n+                .map(|b| tcx.mk_const(ty::ConstKind::Value(*b), *inner_ty))\n                 .collect::<Vec<_>>();\n             debug!(?field_consts);\n \n@@ -52,10 +52,7 @@ pub(crate) fn destructure_const<'tcx>(\n \n             for (field, field_valtree) in iter::zip(fields, branches) {\n                 let field_ty = field.ty(tcx, substs);\n-                let field_const = tcx.mk_const(ty::ConstS {\n-                    kind: ty::ConstKind::Value(*field_valtree),\n-                    ty: field_ty,\n-                });\n+                let field_const = tcx.mk_const(ty::ConstKind::Value(*field_valtree), field_ty);\n                 field_consts.push(field_const);\n             }\n             debug!(?field_consts);\n@@ -65,10 +62,7 @@ pub(crate) fn destructure_const<'tcx>(\n         ty::Tuple(elem_tys) => {\n             let fields = iter::zip(*elem_tys, branches)\n                 .map(|(elem_ty, elem_valtree)| {\n-                    tcx.mk_const(ty::ConstS {\n-                        kind: ty::ConstKind::Value(*elem_valtree),\n-                        ty: elem_ty,\n-                    })\n+                    tcx.mk_const(ty::ConstKind::Value(*elem_valtree), elem_ty)\n                 })\n                 .collect::<Vec<_>>();\n \n@@ -261,17 +255,13 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                 let uneval =\n                     ty::UnevaluatedConst::new(ty::WithOptConstParam::unknown(def_id), substs);\n \n-                let constant = self\n-                    .tcx\n-                    .mk_const(ty::ConstS { kind: ty::ConstKind::Unevaluated(uneval), ty: node.ty });\n+                let constant = self.tcx.mk_const(ty::ConstKind::Unevaluated(uneval), node.ty);\n \n                 self.nodes.push(Node::Leaf(constant))\n             }\n \n             ExprKind::ConstParam { param, .. } => {\n-                let const_param = self\n-                    .tcx\n-                    .mk_const(ty::ConstS { kind: ty::ConstKind::Param(*param), ty: node.ty });\n+                let const_param = self.tcx.mk_const(ty::ConstKind::Param(*param), node.ty);\n                 self.nodes.push(Node::Leaf(const_param))\n             }\n "}, {"sha": "99d3bda6ebfff7308b01b3acd4aaa3410013aab7", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -413,7 +413,7 @@ fn issue33140_self_ty(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Ty<'_>> {\n /// Check if a function is async.\n fn asyncness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::IsAsync {\n     let node = tcx.hir().get_by_def_id(def_id.expect_local());\n-    if let Some(fn_kind) = node.fn_kind() { fn_kind.asyncness() } else { hir::IsAsync::NotAsync }\n+    node.fn_sig().map_or(hir::IsAsync::NotAsync, |sig| sig.header.asyncness)\n }\n \n /// Don't call this directly: use ``tcx.conservative_is_privately_uninhabited`` instead."}, {"sha": "7c3eb4efbc9844e73bda2a14e876414b7277609c", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -45,7 +45,7 @@ pub trait Interner {\n     type BoundTy: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n     type PlaceholderType: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n     type InferTy: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n-    type DelaySpanBugEmitted: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type ErrorGuaranteed: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n     type PredicateKind: Clone + Debug + Hash + PartialEq + Eq;\n     type AllocId: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n "}, {"sha": "02cbb2e858f80ac0943792604990d8e8c15727d9", "filename": "compiler/rustc_type_ir/src/sty.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -217,7 +217,7 @@ pub enum TyKind<I: Interner> {\n \n     /// A placeholder for a type which could not be computed; this is\n     /// propagated to avoid useless error messages.\n-    Error(I::DelaySpanBugEmitted),\n+    Error(I::ErrorGuaranteed),\n }\n \n impl<I: Interner> TyKind<I> {\n@@ -626,7 +626,7 @@ impl<I: Interner> fmt::Debug for TyKind<I> {\n // This is manually implemented because a derive would require `I: Encodable`\n impl<I: Interner, E: TyEncoder> Encodable<E> for TyKind<I>\n where\n-    I::DelaySpanBugEmitted: Encodable<E>,\n+    I::ErrorGuaranteed: Encodable<E>,\n     I::AdtDef: Encodable<E>,\n     I::SubstsRef: Encodable<E>,\n     I::DefId: Encodable<E>,\n@@ -645,7 +645,6 @@ where\n     I::BoundTy: Encodable<E>,\n     I::PlaceholderType: Encodable<E>,\n     I::InferTy: Encodable<E>,\n-    I::DelaySpanBugEmitted: Encodable<E>,\n     I::PredicateKind: Encodable<E>,\n     I::AllocId: Encodable<E>,\n {\n@@ -744,7 +743,7 @@ where\n // This is manually implemented because a derive would require `I: Decodable`\n impl<I: Interner, D: TyDecoder<I = I>> Decodable<D> for TyKind<I>\n where\n-    I::DelaySpanBugEmitted: Decodable<D>,\n+    I::ErrorGuaranteed: Decodable<D>,\n     I::AdtDef: Decodable<D>,\n     I::SubstsRef: Decodable<D>,\n     I::DefId: Decodable<D>,\n@@ -763,7 +762,6 @@ where\n     I::BoundTy: Decodable<D>,\n     I::PlaceholderType: Decodable<D>,\n     I::InferTy: Decodable<D>,\n-    I::DelaySpanBugEmitted: Decodable<D>,\n     I::PredicateKind: Decodable<D>,\n     I::AllocId: Decodable<D>,\n {\n@@ -829,7 +827,7 @@ where\n     I::ParamTy: HashStable<CTX>,\n     I::PlaceholderType: HashStable<CTX>,\n     I::InferTy: HashStable<CTX>,\n-    I::DelaySpanBugEmitted: HashStable<CTX>,\n+    I::ErrorGuaranteed: HashStable<CTX>,\n {\n     #[inline]\n     fn hash_stable("}, {"sha": "2373fb2ec4fb04d5de652c08fc91be338212b4be", "filename": "config.toml.example", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -291,10 +291,6 @@ changelog-seen = 2\n # on this runtime, such as `-C profile-generate` or `-C instrument-coverage`).\n #profiler = false\n \n-# Use the optimized LLVM C intrinsics for `compiler_builtins`, rather than Rust intrinsics.\n-# Requires the LLVM submodule to be managed by bootstrap (i.e. not external).\n-#optimized-compiler-builtins = false\n-\n # Indicates whether the native libraries linked into Cargo will be statically\n # linked or not.\n #cargo-native-static = false"}, {"sha": "8c6663569a553e87f226bbd7a1e1c361acbebfd6", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -402,19 +402,18 @@ pub use std::alloc::handle_alloc_error;\n #[allow(unused_attributes)]\n #[unstable(feature = \"alloc_internals\", issue = \"none\")]\n pub mod __alloc_error_handler {\n-    use crate::alloc::Layout;\n-\n-    // called via generated `__rust_alloc_error_handler`\n-\n-    // if there is no `#[alloc_error_handler]`\n+    // called via generated `__rust_alloc_error_handler` if there is no\n+    // `#[alloc_error_handler]`.\n     #[rustc_std_internal_symbol]\n     pub unsafe fn __rdl_oom(size: usize, _align: usize) -> ! {\n         panic!(\"memory allocation of {size} bytes failed\")\n     }\n \n-    // if there is an `#[alloc_error_handler]`\n+    #[cfg(bootstrap)]\n     #[rustc_std_internal_symbol]\n     pub unsafe fn __rg_oom(size: usize, align: usize) -> ! {\n+        use crate::alloc::Layout;\n+\n         let layout = unsafe { Layout::from_size_align_unchecked(size, align) };\n         extern \"Rust\" {\n             #[lang = \"oom\"]"}, {"sha": "c9ba8921f6ecc939ad182bb7db3c078e187ba5e6", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -949,7 +949,7 @@ impl String {\n     /// assert_eq!(string, \"abcdecdeabecde\");\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n-    #[unstable(feature = \"string_extend_from_within\", issue = \"none\")]\n+    #[unstable(feature = \"string_extend_from_within\", issue = \"103806\")]\n     pub fn extend_from_within<R>(&mut self, src: R)\n     where\n         R: RangeBounds<usize>,"}, {"sha": "834c8f58cb2a97f4f94d54c8de1ac112bc62e92e", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -2588,7 +2588,7 @@ impl<T: Clone, A: Allocator> ExtendFromWithinSpec for Vec<T, A> {\n         let (this, spare, len) = unsafe { self.split_at_spare_mut_with_len() };\n \n         // SAFETY:\n-        // - caller guaratees that src is a valid index\n+        // - caller guarantees that src is a valid index\n         let to_clone = unsafe { this.get_unchecked(src) };\n \n         iter::zip(to_clone, spare)\n@@ -2607,7 +2607,7 @@ impl<T: Copy, A: Allocator> ExtendFromWithinSpec for Vec<T, A> {\n             let (init, spare) = self.split_at_spare_mut();\n \n             // SAFETY:\n-            // - caller guaratees that `src` is a valid index\n+            // - caller guarantees that `src` is a valid index\n             let source = unsafe { init.get_unchecked(src) };\n \n             // SAFETY:"}, {"sha": "b24ca037d1afc3e5cd094f774c00be678a9f7e28", "filename": "library/core/src/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Fcore%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Fcore%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ferror.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -1,5 +1,5 @@\n #![doc = include_str!(\"error.md\")]\n-#![unstable(feature = \"error_in_core\", issue = \"none\")]\n+#![unstable(feature = \"error_in_core\", issue = \"103765\")]\n \n #[cfg(test)]\n mod tests;"}, {"sha": "15dd9ea7e803657d9122f63c95fd2db806b1fb04", "filename": "library/core/src/ffi/c_str.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -13,9 +13,9 @@ use crate::str;\n /// array of bytes. It can be constructed safely from a <code>&[[u8]]</code>\n /// slice, or unsafely from a raw `*const c_char`. It can then be\n /// converted to a Rust <code>&[str]</code> by performing UTF-8 validation, or\n-/// into an owned `CString`.\n+/// into an owned [`CString`].\n ///\n-/// `&CStr` is to `CString` as <code>&[str]</code> is to `String`: the former\n+/// `&CStr` is to [`CString`] as <code>&[str]</code> is to [`String`]: the former\n /// in each pair are borrowed references; the latter are owned\n /// strings.\n ///\n@@ -24,6 +24,9 @@ use crate::str;\n /// functions may leverage the unsafe [`CStr::from_ptr`] constructor to provide\n /// a safe interface to other consumers.\n ///\n+/// [`CString`]: ../../std/ffi/struct.CString.html\n+/// [`String`]: ../../std/string/struct.String.html\n+///\n /// # Examples\n ///\n /// Inspecting a foreign C string:"}, {"sha": "2850d84acc3274b09f9169dc6c1b377ddd516730", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -1511,6 +1511,17 @@ pub(crate) mod builtin {\n         /* compiler built-in */\n     }\n \n+    /// Attribute macro applied to a function to register it as a handler for allocation failure.\n+    ///\n+    /// See also [`std::alloc::handle_alloc_error`](../../../std/alloc/fn.handle_alloc_error.html).\n+    #[cfg(not(bootstrap))]\n+    #[unstable(feature = \"alloc_error_handler\", issue = \"51540\")]\n+    #[allow_internal_unstable(rustc_attrs)]\n+    #[rustc_builtin_macro]\n+    pub macro alloc_error_handler($item:item) {\n+        /* compiler built-in */\n+    }\n+\n     /// Keeps the item it's applied to if the passed path is accessible, and removes it otherwise.\n     #[unstable(\n         feature = \"cfg_accessible\","}, {"sha": "cd183540cd5e9d3c5d20d2e4d12156a7502571c5", "filename": "library/core/src/ops/control_flow.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -79,7 +79,9 @@ use crate::{convert, ops};\n /// [`Break`]: ControlFlow::Break\n /// [`Continue`]: ControlFlow::Continue\n #[stable(feature = \"control_flow_enum_type\", since = \"1.55.0\")]\n-#[derive(Debug, Clone, Copy, PartialEq)]\n+// ControlFlow should not implement PartialOrd or Ord, per RFC 3058:\n+// https://rust-lang.github.io/rfcs/3058-try-trait-v2.html#traits-for-controlflow\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub enum ControlFlow<B, C = ()> {\n     /// Move on to the next phase of the operation as normal.\n     #[stable(feature = \"control_flow_enum_type\", since = \"1.55.0\")]"}, {"sha": "804a179bdb3c04a835e47c97db8896da119f73bb", "filename": "library/core/src/prelude/v1.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -75,6 +75,9 @@ pub use crate::macros::builtin::{RustcDecodable, RustcEncodable};\n \n // Do not `doc(no_inline)` so that they become doc items on their own\n // (no public module for them to be re-exported from).\n+#[cfg(not(bootstrap))]\n+#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n+pub use crate::macros::builtin::alloc_error_handler;\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n pub use crate::macros::builtin::{bench, derive, global_allocator, test, test_case};\n "}, {"sha": "e98dac8d12ef449d6d54a8bb1a2e714d68cbea98", "filename": "library/core/tests/any.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Fcore%2Ftests%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Fcore%2Ftests%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fany.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -131,6 +131,24 @@ fn distinct_type_names() {\n     assert_ne!(type_name_of_val(Velocity), type_name_of_val(Velocity(0.0, -9.8)),);\n }\n \n+#[cfg(not(bootstrap))]\n+#[test]\n+fn dyn_type_name() {\n+    trait Foo {\n+        type Bar;\n+    }\n+\n+    assert_eq!(\n+        \"dyn core::ops::function::Fn(i32, i32) -> i32\",\n+        std::any::type_name::<dyn Fn(i32, i32) -> i32>()\n+    );\n+    assert_eq!(\n+        \"dyn coretests::any::dyn_type_name::Foo<Bar = i32> \\\n+        + core::marker::Send + core::marker::Sync\",\n+        std::any::type_name::<dyn Foo<Bar = i32> + Send + Sync>()\n+    );\n+}\n+\n // Test the `Provider` API.\n \n struct SomeConcreteType {"}, {"sha": "eda176d9fcbe61c307de586eb8ca416b39af0d3d", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -5,6 +5,7 @@\n #![feature(bigint_helper_methods)]\n #![feature(cell_update)]\n #![feature(const_assume)]\n+#![feature(const_align_of_val_raw)]\n #![feature(const_black_box)]\n #![feature(const_bool_to_option)]\n #![feature(const_caller_location)]\n@@ -42,6 +43,7 @@\n #![feature(try_find)]\n #![feature(inline_const)]\n #![feature(is_sorted)]\n+#![feature(layout_for_ptr)]\n #![feature(pattern)]\n #![feature(pin_macro)]\n #![feature(sort_internals)]"}, {"sha": "1cfb4fd9fd186e55cc84c3b641bdf37e10858d6e", "filename": "library/core/tests/mem.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Fcore%2Ftests%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Fcore%2Ftests%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fmem.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -1,4 +1,5 @@\n use core::mem::*;\n+use core::ptr;\n \n #[cfg(panic = \"unwind\")]\n use std::rc::Rc;\n@@ -75,6 +76,25 @@ fn align_of_val_basic() {\n     assert_eq!(align_of_val(&1u32), 4);\n }\n \n+#[test]\n+#[cfg(not(bootstrap))] // stage 0 doesn't have the fix yet, so the test fails\n+fn align_of_val_raw_packed() {\n+    #[repr(C, packed)]\n+    struct B {\n+        f: [u32],\n+    }\n+    let storage = [0u8; 4];\n+    let b: *const B = ptr::from_raw_parts(storage.as_ptr().cast(), 1);\n+    assert_eq!(unsafe { align_of_val_raw(b) }, 1);\n+\n+    const ALIGN_OF_VAL_RAW: usize = {\n+        let storage = [0u8; 4];\n+        let b: *const B = ptr::from_raw_parts(storage.as_ptr().cast(), 1);\n+        unsafe { align_of_val_raw(b) }\n+    };\n+    assert_eq!(ALIGN_OF_VAL_RAW, 1);\n+}\n+\n #[test]\n fn test_swap() {\n     let mut x = 31337;"}, {"sha": "e6ea2b1849b4c11bc627cfcffaa6796b95e0746b", "filename": "library/panic_abort/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Fpanic_abort%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Fpanic_abort%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_abort%2FCargo.toml?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -13,7 +13,7 @@ doc = false\n \n [dependencies]\n alloc = { path = \"../alloc\" }\n-cfg-if = { version = \"0.1.8\", features = ['rustc-dep-of-std'] }\n+cfg-if = { version = \"1.0\", features = ['rustc-dep-of-std'] }\n core = { path = \"../core\" }\n libc = { version = \"0.2\", default-features = false }\n compiler_builtins = \"0.1.0\""}, {"sha": "85386976d639a808b4464ecd7337e634b509a53c", "filename": "library/panic_unwind/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Fpanic_unwind%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Fpanic_unwind%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2FCargo.toml?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -17,4 +17,4 @@ core = { path = \"../core\" }\n libc = { version = \"0.2\", default-features = false }\n unwind = { path = \"../unwind\" }\n compiler_builtins = \"0.1.0\"\n-cfg-if = \"0.1.8\"\n+cfg-if = \"1.0\""}, {"sha": "19d90e7ec38398728170f005d86da0558e4aac04", "filename": "library/std/src/net/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Fstd%2Fsrc%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Fstd%2Fsrc%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fmod.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -11,7 +11,7 @@\n //!   [`Ipv6Addr`] are respectively IPv4 and IPv6 addresses\n //! * [`SocketAddr`] represents socket addresses of either IPv4 or IPv6; [`SocketAddrV4`]\n //!   and [`SocketAddrV6`] are respectively IPv4 and IPv6 socket addresses\n-//! * [`ToSocketAddrs`] is a trait that used for generic address resolution when interacting\n+//! * [`ToSocketAddrs`] is a trait that is used for generic address resolution when interacting\n //!   with networking objects like [`TcpListener`], [`TcpStream`] or [`UdpSocket`]\n //! * Other types are return or parameter types for various methods in this module\n //!"}, {"sha": "36d9e8921ef31f110eaf284b7747aadd1044e44a", "filename": "library/std/src/prelude/v1.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -59,6 +59,9 @@ pub use core::prelude::v1::{RustcDecodable, RustcEncodable};\n \n // Do not `doc(no_inline)` so that they become doc items on their own\n // (no public module for them to be re-exported from).\n+#[cfg(not(bootstrap))]\n+#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n+pub use core::prelude::v1::alloc_error_handler;\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n pub use core::prelude::v1::{bench, derive, global_allocator, test, test_case};\n "}, {"sha": "81461de4f721f1d588f68a55c532fc4ea6ec7a9d", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 27, "deletions": 30, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -56,6 +56,7 @@ pub type LPPROCESS_INFORMATION = *mut PROCESS_INFORMATION;\n pub type LPSECURITY_ATTRIBUTES = *mut SECURITY_ATTRIBUTES;\n pub type LPSTARTUPINFO = *mut STARTUPINFO;\n pub type LPVOID = *mut c_void;\n+pub type LPCVOID = *const c_void;\n pub type LPWCH = *mut WCHAR;\n pub type LPWIN32_FIND_DATAW = *mut WIN32_FIND_DATAW;\n pub type LPWSADATA = *mut WSADATA;\n@@ -773,6 +774,16 @@ pub struct timeval {\n     pub tv_usec: c_long,\n }\n \n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct CONSOLE_READCONSOLE_CONTROL {\n+    pub nLength: ULONG,\n+    pub nInitialChars: ULONG,\n+    pub dwCtrlWakeupMask: ULONG,\n+    pub dwControlKeyState: ULONG,\n+}\n+pub type PCONSOLE_READCONSOLE_CONTROL = *mut CONSOLE_READCONSOLE_CONTROL;\n+\n // Desktop specific functions & types\n cfg_if::cfg_if! {\n if #[cfg(not(target_vendor = \"uwp\"))] {\n@@ -801,17 +812,6 @@ if #[cfg(not(target_vendor = \"uwp\"))] {\n     pub type PVECTORED_EXCEPTION_HANDLER =\n         extern \"system\" fn(ExceptionInfo: *mut EXCEPTION_POINTERS) -> LONG;\n \n-    #[repr(C)]\n-    #[derive(Copy, Clone)]\n-    pub struct CONSOLE_READCONSOLE_CONTROL {\n-        pub nLength: ULONG,\n-        pub nInitialChars: ULONG,\n-        pub dwCtrlWakeupMask: ULONG,\n-        pub dwControlKeyState: ULONG,\n-    }\n-\n-    pub type PCONSOLE_READCONSOLE_CONTROL = *mut CONSOLE_READCONSOLE_CONTROL;\n-\n     #[repr(C)]\n     pub struct BY_HANDLE_FILE_INFORMATION {\n         pub dwFileAttributes: DWORD,\n@@ -827,7 +827,6 @@ if #[cfg(not(target_vendor = \"uwp\"))] {\n     }\n \n     pub type LPBY_HANDLE_FILE_INFORMATION = *mut BY_HANDLE_FILE_INFORMATION;\n-    pub type LPCVOID = *const c_void;\n \n     pub const HANDLE_FLAG_INHERIT: DWORD = 0x00000001;\n \n@@ -855,24 +854,6 @@ if #[cfg(not(target_vendor = \"uwp\"))] {\n \n     #[link(name = \"kernel32\")]\n     extern \"system\" {\n-        // Functions forbidden when targeting UWP\n-        pub fn ReadConsoleW(\n-            hConsoleInput: HANDLE,\n-            lpBuffer: LPVOID,\n-            nNumberOfCharsToRead: DWORD,\n-            lpNumberOfCharsRead: LPDWORD,\n-            pInputControl: PCONSOLE_READCONSOLE_CONTROL,\n-        ) -> BOOL;\n-\n-        pub fn WriteConsoleW(\n-            hConsoleOutput: HANDLE,\n-            lpBuffer: LPCVOID,\n-            nNumberOfCharsToWrite: DWORD,\n-            lpNumberOfCharsWritten: LPDWORD,\n-            lpReserved: LPVOID,\n-        ) -> BOOL;\n-\n-        pub fn GetConsoleMode(hConsoleHandle: HANDLE, lpMode: LPDWORD) -> BOOL;\n         // Allowed but unused by UWP\n         pub fn GetFileInformationByHandle(\n             hFile: HANDLE,\n@@ -914,6 +895,22 @@ if #[cfg(target_vendor = \"uwp\")] {\n extern \"system\" {\n     pub fn GetCurrentProcessId() -> DWORD;\n \n+    pub fn ReadConsoleW(\n+        hConsoleInput: HANDLE,\n+        lpBuffer: LPVOID,\n+        nNumberOfCharsToRead: DWORD,\n+        lpNumberOfCharsRead: LPDWORD,\n+        pInputControl: PCONSOLE_READCONSOLE_CONTROL,\n+    ) -> BOOL;\n+    pub fn WriteConsoleW(\n+        hConsoleOutput: HANDLE,\n+        lpBuffer: LPCVOID,\n+        nNumberOfCharsToWrite: DWORD,\n+        lpNumberOfCharsWritten: LPDWORD,\n+        lpReserved: LPVOID,\n+    ) -> BOOL;\n+    pub fn GetConsoleMode(hConsoleHandle: HANDLE, lpMode: LPDWORD) -> BOOL;\n+\n     pub fn GetSystemDirectoryW(lpBuffer: LPWSTR, uSize: UINT) -> UINT;\n     pub fn RemoveDirectoryW(lpPathName: LPCWSTR) -> BOOL;\n     pub fn SetFileAttributesW(lpFileName: LPCWSTR, dwFileAttributes: DWORD) -> BOOL;"}, {"sha": "e67411e16860e679cbb83cb2c6a7080f9542a0e5", "filename": "library/std/src/sys/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -29,19 +29,17 @@ pub mod path;\n pub mod pipe;\n pub mod process;\n pub mod rand;\n+pub mod stdio;\n pub mod thread;\n pub mod thread_local_dtor;\n pub mod thread_local_key;\n pub mod thread_parker;\n pub mod time;\n cfg_if::cfg_if! {\n     if #[cfg(not(target_vendor = \"uwp\"))] {\n-        pub mod stdio;\n         pub mod stack_overflow;\n     } else {\n-        pub mod stdio_uwp;\n         pub mod stack_overflow_uwp;\n-        pub use self::stdio_uwp as stdio;\n         pub use self::stack_overflow_uwp as stack_overflow;\n     }\n }"}, {"sha": "32550f796ec64d8ba818caf51d00c18100e3041a", "filename": "library/std/src/sys/windows/stdio_uwp.rs", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/4492c029eff7b42e91e759576ab0c7ca88f873dc/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio_uwp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4492c029eff7b42e91e759576ab0c7ca88f873dc/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio_uwp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio_uwp.rs?ref=4492c029eff7b42e91e759576ab0c7ca88f873dc", "patch": "@@ -1,87 +0,0 @@\n-#![unstable(issue = \"none\", feature = \"windows_stdio\")]\n-\n-use crate::io;\n-use crate::mem::ManuallyDrop;\n-use crate::os::windows::io::FromRawHandle;\n-use crate::sys::c;\n-use crate::sys::handle::Handle;\n-\n-pub struct Stdin {}\n-pub struct Stdout;\n-pub struct Stderr;\n-\n-const MAX_BUFFER_SIZE: usize = 8192;\n-pub const STDIN_BUF_SIZE: usize = MAX_BUFFER_SIZE / 2 * 3;\n-\n-pub fn get_handle(handle_id: c::DWORD) -> io::Result<c::HANDLE> {\n-    let handle = unsafe { c::GetStdHandle(handle_id) };\n-    if handle == c::INVALID_HANDLE_VALUE {\n-        Err(io::Error::last_os_error())\n-    } else if handle.is_null() {\n-        Err(io::Error::from_raw_os_error(c::ERROR_INVALID_HANDLE as i32))\n-    } else {\n-        Ok(handle)\n-    }\n-}\n-\n-fn write(handle_id: c::DWORD, data: &[u8]) -> io::Result<usize> {\n-    let handle = get_handle(handle_id)?;\n-    // SAFETY: The handle returned from `get_handle` must be valid and non-null.\n-    let handle = unsafe { Handle::from_raw_handle(handle) };\n-    ManuallyDrop::new(handle).write(data)\n-}\n-\n-impl Stdin {\n-    pub const fn new() -> Stdin {\n-        Stdin {}\n-    }\n-}\n-\n-impl io::Read for Stdin {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        let handle = get_handle(c::STD_INPUT_HANDLE)?;\n-        // SAFETY: The handle returned from `get_handle` must be valid and non-null.\n-        let handle = unsafe { Handle::from_raw_handle(handle) };\n-        ManuallyDrop::new(handle).read(buf)\n-    }\n-}\n-\n-impl Stdout {\n-    pub const fn new() -> Stdout {\n-        Stdout\n-    }\n-}\n-\n-impl io::Write for Stdout {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        write(c::STD_OUTPUT_HANDLE, buf)\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        Ok(())\n-    }\n-}\n-\n-impl Stderr {\n-    pub const fn new() -> Stderr {\n-        Stderr\n-    }\n-}\n-\n-impl io::Write for Stderr {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        write(c::STD_ERROR_HANDLE, buf)\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        Ok(())\n-    }\n-}\n-\n-pub fn is_ebadf(err: &io::Error) -> bool {\n-    err.raw_os_error() == Some(c::ERROR_INVALID_HANDLE as i32)\n-}\n-\n-pub fn panic_output() -> Option<impl io::Write> {\n-    Some(Stderr::new())\n-}"}, {"sha": "8cb88016b23ade5b5fb6bdfdf9dce3f128440576", "filename": "library/test/src/console.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Ftest%2Fsrc%2Fconsole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Ftest%2Fsrc%2Fconsole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fconsole.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -228,9 +228,9 @@ fn on_test_event(\n     out: &mut dyn OutputFormatter,\n ) -> io::Result<()> {\n     match (*event).clone() {\n-        TestEvent::TeFiltered(ref filtered_tests, shuffle_seed) => {\n-            st.total = filtered_tests.len();\n-            out.write_run_start(filtered_tests.len(), shuffle_seed)?;\n+        TestEvent::TeFiltered(filtered_tests, shuffle_seed) => {\n+            st.total = filtered_tests;\n+            out.write_run_start(filtered_tests, shuffle_seed)?;\n         }\n         TestEvent::TeFilteredOut(filtered_out) => {\n             st.filtered_out = filtered_out;"}, {"sha": "80281ebd2d4cdd946207f67bf741f10cb0d94e58", "filename": "library/test/src/event.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Ftest%2Fsrc%2Fevent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Ftest%2Fsrc%2Fevent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fevent.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -28,7 +28,7 @@ impl CompletedTest {\n \n #[derive(Debug, Clone)]\n pub enum TestEvent {\n-    TeFiltered(Vec<TestDesc>, Option<u64>),\n+    TeFiltered(usize, Option<u64>),\n     TeWait(TestDesc),\n     TeResult(CompletedTest),\n     TeTimeout(TestDesc),"}, {"sha": "27320e8dbc5ad42738fecaeea8131444bbc961f0", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 93, "deletions": 55, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -40,7 +40,7 @@ pub mod test {\n         cli::{parse_opts, TestOpts},\n         filter_tests,\n         helpers::metrics::{Metric, MetricMap},\n-        options::{Concurrent, Options, RunIgnored, RunStrategy, ShouldPanic},\n+        options::{Options, RunIgnored, RunStrategy, ShouldPanic},\n         run_test, test_main, test_main_static,\n         test_result::{TestResult, TrFailed, TrFailedMsg, TrIgnored, TrOk},\n         time::{TestExecTime, TestTimeOptions},\n@@ -85,7 +85,7 @@ use event::{CompletedTest, TestEvent};\n use helpers::concurrency::get_concurrency;\n use helpers::exit_code::get_exit_code;\n use helpers::shuffle::{get_shuffle_seed, shuffle_tests};\n-use options::{Concurrent, RunStrategy};\n+use options::RunStrategy;\n use test_result::*;\n use time::TestExecTime;\n \n@@ -219,6 +219,38 @@ pub fn assert_test_result<T: Termination>(result: T) -> Result<(), String> {\n     }\n }\n \n+struct FilteredTests {\n+    tests: Vec<(TestId, TestDescAndFn)>,\n+    benchs: Vec<(TestId, TestDescAndFn)>,\n+    next_id: usize,\n+}\n+\n+impl FilteredTests {\n+    fn add_bench(&mut self, desc: TestDesc, testfn: TestFn) {\n+        let test = TestDescAndFn { desc, testfn };\n+        self.benchs.push((TestId(self.next_id), test));\n+        self.next_id += 1;\n+    }\n+    fn add_test(&mut self, desc: TestDesc, testfn: TestFn) {\n+        let test = TestDescAndFn { desc, testfn };\n+        self.tests.push((TestId(self.next_id), test));\n+        self.next_id += 1;\n+    }\n+    fn add_bench_as_test(\n+        &mut self,\n+        desc: TestDesc,\n+        benchfn: impl Fn(&mut Bencher) -> Result<(), String> + Send + 'static,\n+    ) {\n+        let testfn = DynTestFn(Box::new(move || {\n+            bench::run_once(|b| __rust_begin_short_backtrace(|| benchfn(b)))\n+        }));\n+        self.add_test(desc, testfn);\n+    }\n+    fn total_len(&self) -> usize {\n+        self.tests.len() + self.benchs.len()\n+    }\n+}\n+\n pub fn run_tests<F>(\n     opts: &TestOpts,\n     tests: Vec<TestDescAndFn>,\n@@ -235,6 +267,19 @@ where\n         join_handle: Option<thread::JoinHandle<()>>,\n     }\n \n+    impl RunningTest {\n+        fn join(self, completed_test: &mut CompletedTest) {\n+            if let Some(join_handle) = self.join_handle {\n+                if let Err(_) = join_handle.join() {\n+                    if let TrOk = completed_test.result {\n+                        completed_test.result =\n+                            TrFailedMsg(\"panicked after reporting success\".to_string());\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     // Use a deterministic hasher\n     type TestMap =\n         HashMap<TestId, RunningTest, BuildHasherDefault<collections::hash_map::DefaultHasher>>;\n@@ -247,45 +292,51 @@ where\n \n     let tests_len = tests.len();\n \n-    let mut filtered_tests = filter_tests(opts, tests);\n-    if !opts.bench_benchmarks {\n-        filtered_tests = convert_benchmarks_to_tests(filtered_tests);\n-    }\n+    let mut filtered = FilteredTests { tests: Vec::new(), benchs: Vec::new(), next_id: 0 };\n \n-    let filtered_tests = {\n-        let mut filtered_tests = filtered_tests;\n-        for test in filtered_tests.iter_mut() {\n-            test.desc.name = test.desc.name.with_padding(test.testfn.padding());\n-        }\n+    for test in filter_tests(opts, tests) {\n+        let mut desc = test.desc;\n+        desc.name = desc.name.with_padding(test.testfn.padding());\n \n-        filtered_tests\n-    };\n+        match test.testfn {\n+            DynBenchFn(benchfn) => {\n+                if opts.bench_benchmarks {\n+                    filtered.add_bench(desc, DynBenchFn(benchfn));\n+                } else {\n+                    filtered.add_bench_as_test(desc, benchfn);\n+                }\n+            }\n+            StaticBenchFn(benchfn) => {\n+                if opts.bench_benchmarks {\n+                    filtered.add_bench(desc, StaticBenchFn(benchfn));\n+                } else {\n+                    filtered.add_bench_as_test(desc, benchfn);\n+                }\n+            }\n+            testfn => {\n+                filtered.add_test(desc, testfn);\n+            }\n+        };\n+    }\n \n-    let filtered_out = tests_len - filtered_tests.len();\n+    let filtered_out = tests_len - filtered.total_len();\n     let event = TestEvent::TeFilteredOut(filtered_out);\n     notify_about_test_event(event)?;\n \n-    let filtered_descs = filtered_tests.iter().map(|t| t.desc.clone()).collect();\n-\n     let shuffle_seed = get_shuffle_seed(opts);\n \n-    let event = TestEvent::TeFiltered(filtered_descs, shuffle_seed);\n+    let event = TestEvent::TeFiltered(filtered.total_len(), shuffle_seed);\n     notify_about_test_event(event)?;\n \n-    let (mut filtered_tests, filtered_benchs): (Vec<_>, _) = filtered_tests\n-        .into_iter()\n-        .enumerate()\n-        .map(|(i, e)| (TestId(i), e))\n-        .partition(|(_, e)| matches!(e.testfn, StaticTestFn(_) | DynTestFn(_)));\n-\n     let concurrency = opts.test_threads.unwrap_or_else(get_concurrency);\n \n+    let mut remaining = filtered.tests;\n     if let Some(shuffle_seed) = shuffle_seed {\n-        shuffle_tests(shuffle_seed, &mut filtered_tests);\n+        shuffle_tests(shuffle_seed, &mut remaining);\n     }\n     // Store the tests in a VecDeque so we can efficiently remove the first element to run the\n     // tests in the order they were passed (unless shuffled).\n-    let mut remaining = VecDeque::from(filtered_tests);\n+    let mut remaining = VecDeque::from(remaining);\n     let mut pending = 0;\n \n     let (tx, rx) = channel::<CompletedTest>();\n@@ -328,10 +379,10 @@ where\n             let (id, test) = remaining.pop_front().unwrap();\n             let event = TestEvent::TeWait(test.desc.clone());\n             notify_about_test_event(event)?;\n-            let join_handle =\n-                run_test(opts, !opts.run_tests, id, test, run_strategy, tx.clone(), Concurrent::No);\n-            assert!(join_handle.is_none());\n-            let completed_test = rx.recv().unwrap();\n+            let join_handle = run_test(opts, !opts.run_tests, id, test, run_strategy, tx.clone());\n+            // Wait for the test to complete.\n+            let mut completed_test = rx.recv().unwrap();\n+            RunningTest { join_handle }.join(&mut completed_test);\n \n             let event = TestEvent::TeResult(completed_test);\n             notify_about_test_event(event)?;\n@@ -345,15 +396,8 @@ where\n \n                 let event = TestEvent::TeWait(desc.clone());\n                 notify_about_test_event(event)?; //here no pad\n-                let join_handle = run_test(\n-                    opts,\n-                    !opts.run_tests,\n-                    id,\n-                    test,\n-                    run_strategy,\n-                    tx.clone(),\n-                    Concurrent::Yes,\n-                );\n+                let join_handle =\n+                    run_test(opts, !opts.run_tests, id, test, run_strategy, tx.clone());\n                 running_tests.insert(id, RunningTest { join_handle });\n                 timeout_queue.push_back(TimeoutEntry { id, desc, timeout });\n                 pending += 1;\n@@ -385,14 +429,7 @@ where\n \n             let mut completed_test = res.unwrap();\n             let running_test = running_tests.remove(&completed_test.id).unwrap();\n-            if let Some(join_handle) = running_test.join_handle {\n-                if let Err(_) = join_handle.join() {\n-                    if let TrOk = completed_test.result {\n-                        completed_test.result =\n-                            TrFailedMsg(\"panicked after reporting success\".to_string());\n-                    }\n-                }\n-            }\n+            running_test.join(&mut completed_test);\n \n             let event = TestEvent::TeResult(completed_test);\n             notify_about_test_event(event)?;\n@@ -402,11 +439,13 @@ where\n \n     if opts.bench_benchmarks {\n         // All benchmarks run at the end, in serial.\n-        for (id, b) in filtered_benchs {\n+        for (id, b) in filtered.benchs {\n             let event = TestEvent::TeWait(b.desc.clone());\n             notify_about_test_event(event)?;\n-            run_test(opts, false, id, b, run_strategy, tx.clone(), Concurrent::No);\n-            let completed_test = rx.recv().unwrap();\n+            let join_handle = run_test(opts, false, id, b, run_strategy, tx.clone());\n+            // Wait for the test to complete.\n+            let mut completed_test = rx.recv().unwrap();\n+            RunningTest { join_handle }.join(&mut completed_test);\n \n             let event = TestEvent::TeResult(completed_test);\n             notify_about_test_event(event)?;\n@@ -432,7 +471,9 @@ pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescA\n     }\n \n     // Skip tests that match any of the skip filters\n-    filtered.retain(|test| !opts.skip.iter().any(|sf| matches_filter(test, sf)));\n+    if !opts.skip.is_empty() {\n+        filtered.retain(|test| !opts.skip.iter().any(|sf| matches_filter(test, sf)));\n+    }\n \n     // Excludes #[should_panic] tests\n     if opts.exclude_should_panic {\n@@ -480,7 +521,6 @@ pub fn run_test(\n     test: TestDescAndFn,\n     strategy: RunStrategy,\n     monitor_ch: Sender<CompletedTest>,\n-    concurrency: Concurrent,\n ) -> Option<thread::JoinHandle<()>> {\n     let TestDescAndFn { desc, testfn } = test;\n \n@@ -498,7 +538,6 @@ pub fn run_test(\n     struct TestRunOpts {\n         pub strategy: RunStrategy,\n         pub nocapture: bool,\n-        pub concurrency: Concurrent,\n         pub time: Option<time::TestTimeOptions>,\n     }\n \n@@ -509,7 +548,6 @@ pub fn run_test(\n         testfn: Box<dyn FnOnce() -> Result<(), String> + Send>,\n         opts: TestRunOpts,\n     ) -> Option<thread::JoinHandle<()>> {\n-        let concurrency = opts.concurrency;\n         let name = desc.name.clone();\n \n         let runtest = move || match opts.strategy {\n@@ -536,7 +574,7 @@ pub fn run_test(\n         // the test synchronously, regardless of the concurrency\n         // level.\n         let supports_threads = !cfg!(target_os = \"emscripten\") && !cfg!(target_family = \"wasm\");\n-        if concurrency == Concurrent::Yes && supports_threads {\n+        if supports_threads {\n             let cfg = thread::Builder::new().name(name.as_slice().to_owned());\n             let mut runtest = Arc::new(Mutex::new(Some(runtest)));\n             let runtest2 = runtest.clone();\n@@ -557,7 +595,7 @@ pub fn run_test(\n     }\n \n     let test_run_opts =\n-        TestRunOpts { strategy, nocapture: opts.nocapture, concurrency, time: opts.time_options };\n+        TestRunOpts { strategy, nocapture: opts.nocapture, time: opts.time_options };\n \n     match testfn {\n         DynBenchFn(benchfn) => {"}, {"sha": "75ec0b616e193b2403cb4cb77c87a1eb6accd6c2", "filename": "library/test/src/options.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Ftest%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Ftest%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Foptions.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -1,12 +1,5 @@\n //! Enums denoting options for test execution.\n \n-/// Whether to execute tests concurrently or not\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum Concurrent {\n-    Yes,\n-    No,\n-}\n-\n /// Number of times to run a benchmarked function\n #[derive(Clone, PartialEq, Eq)]\n pub enum BenchMode {"}, {"sha": "7b2e6707f9d11243b112b3b7ef5f2a3c71e37fdc", "filename": "library/test/src/tests.rs", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Ftest%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Ftest%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Ftests.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -102,7 +102,7 @@ pub fn do_not_run_ignored_tests() {\n         testfn: DynTestFn(Box::new(f)),\n     };\n     let (tx, rx) = channel();\n-    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n+    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx);\n     let result = rx.recv().unwrap().result;\n     assert_ne!(result, TrOk);\n }\n@@ -125,7 +125,7 @@ pub fn ignored_tests_result_in_ignored() {\n         testfn: DynTestFn(Box::new(f)),\n     };\n     let (tx, rx) = channel();\n-    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n+    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx);\n     let result = rx.recv().unwrap().result;\n     assert_eq!(result, TrIgnored);\n }\n@@ -150,7 +150,7 @@ fn test_should_panic() {\n         testfn: DynTestFn(Box::new(f)),\n     };\n     let (tx, rx) = channel();\n-    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n+    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx);\n     let result = rx.recv().unwrap().result;\n     assert_eq!(result, TrOk);\n }\n@@ -175,7 +175,7 @@ fn test_should_panic_good_message() {\n         testfn: DynTestFn(Box::new(f)),\n     };\n     let (tx, rx) = channel();\n-    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n+    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx);\n     let result = rx.recv().unwrap().result;\n     assert_eq!(result, TrOk);\n }\n@@ -205,7 +205,7 @@ fn test_should_panic_bad_message() {\n         testfn: DynTestFn(Box::new(f)),\n     };\n     let (tx, rx) = channel();\n-    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n+    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx);\n     let result = rx.recv().unwrap().result;\n     assert_eq!(result, TrFailedMsg(failed_msg.to_string()));\n }\n@@ -239,7 +239,7 @@ fn test_should_panic_non_string_message_type() {\n         testfn: DynTestFn(Box::new(f)),\n     };\n     let (tx, rx) = channel();\n-    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n+    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx);\n     let result = rx.recv().unwrap().result;\n     assert_eq!(result, TrFailedMsg(failed_msg));\n }\n@@ -267,15 +267,7 @@ fn test_should_panic_but_succeeds() {\n             testfn: DynTestFn(Box::new(f)),\n         };\n         let (tx, rx) = channel();\n-        run_test(\n-            &TestOpts::new(),\n-            false,\n-            TestId(0),\n-            desc,\n-            RunStrategy::InProcess,\n-            tx,\n-            Concurrent::No,\n-        );\n+        run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx);\n         let result = rx.recv().unwrap().result;\n         assert_eq!(\n             result,\n@@ -306,7 +298,7 @@ fn report_time_test_template(report_time: bool) -> Option<TestExecTime> {\n \n     let test_opts = TestOpts { time_options, ..TestOpts::new() };\n     let (tx, rx) = channel();\n-    run_test(&test_opts, false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n+    run_test(&test_opts, false, TestId(0), desc, RunStrategy::InProcess, tx);\n     let exec_time = rx.recv().unwrap().exec_time;\n     exec_time\n }\n@@ -345,7 +337,7 @@ fn time_test_failure_template(test_type: TestType) -> TestResult {\n \n     let test_opts = TestOpts { time_options: Some(time_options), ..TestOpts::new() };\n     let (tx, rx) = channel();\n-    run_test(&test_opts, false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n+    run_test(&test_opts, false, TestId(0), desc, RunStrategy::InProcess, tx);\n     let result = rx.recv().unwrap().result;\n \n     result"}, {"sha": "32c4a7eb5c18cb0f0b2ff1c8debee4a2690265f8", "filename": "library/unwind/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Funwind%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/library%2Funwind%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Funwind%2FCargo.toml?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -17,7 +17,7 @@ doc = false\n core = { path = \"../core\" }\n libc = { version = \"0.2.79\", features = ['rustc-dep-of-std'], default-features = false }\n compiler_builtins = \"0.1.0\"\n-cfg-if = \"0.1.8\"\n+cfg-if = \"1.0\"\n \n [build-dependencies]\n cc = \"1.0.69\""}, {"sha": "23828f4758d67db275cce6d942ecb6da11d962e9", "filename": "src/bootstrap/bin/rustdoc.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustdoc.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -55,13 +55,9 @@ fn main() {\n         arg.push(&linker);\n         cmd.arg(arg);\n     }\n-    if env::var_os(\"RUSTDOC_FUSE_LD_LLD\").is_some() {\n+    if let Ok(no_threads) = env::var(\"RUSTDOC_LLD_NO_THREADS\") {\n         cmd.arg(\"-Clink-arg=-fuse-ld=lld\");\n-        if cfg!(windows) {\n-            cmd.arg(\"-Clink-arg=-Wl,/threads:1\");\n-        } else {\n-            cmd.arg(\"-Clink-arg=-Wl,--threads=1\");\n-        }\n+        cmd.arg(format!(\"-Clink-arg=-Wl,{}\", no_threads));\n     }\n     // Cargo doesn't pass RUSTDOCFLAGS to proc_macros:\n     // https://github.com/rust-lang/cargo/issues/4423"}, {"sha": "6de3746363337e992ca038f2c4a58901c25c7184", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -621,6 +621,8 @@ impl<'a> Builder<'a> {\n                 check::CodegenBackend,\n                 check::Clippy,\n                 check::Miri,\n+                check::CargoMiri,\n+                check::MiroptTestTools,\n                 check::Rls,\n                 check::RustAnalyzer,\n                 check::Rustfmt,"}, {"sha": "2e1bd8d6d1f6db817547866633ae240c7dd9d685", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -451,16 +451,16 @@ macro_rules! tool_check_step {\n }\n \n tool_check_step!(Rustdoc, \"src/tools/rustdoc\", \"src/librustdoc\", SourceType::InTree);\n-// Clippy and Rustfmt are hybrids. They are external tools, but use a git subtree instead\n+// Clippy, miri and Rustfmt are hybrids. They are external tools, but use a git subtree instead\n // of a submodule. Since the SourceType only drives the deny-warnings\n // behavior, treat it as in-tree so that any new warnings in clippy will be\n // rejected.\n tool_check_step!(Clippy, \"src/tools/clippy\", SourceType::InTree);\n-// Miri on the other hand is treated as out of tree, since InTree also causes it to\n-// be run as part of `check`, which can fail on platforms which libffi-sys has no support for.\n-tool_check_step!(Miri, \"src/tools/miri\", SourceType::Submodule);\n+tool_check_step!(Miri, \"src/tools/miri\", SourceType::InTree);\n+tool_check_step!(CargoMiri, \"src/tools/miri/cargo-miri\", SourceType::InTree);\n tool_check_step!(Rls, \"src/tools/rls\", SourceType::InTree);\n tool_check_step!(Rustfmt, \"src/tools/rustfmt\", SourceType::InTree);\n+tool_check_step!(MiroptTestTools, \"src/tools/miropt-test-tools\", SourceType::InTree);\n \n tool_check_step!(Bootstrap, \"src/bootstrap\", SourceType::InTree, false);\n "}, {"sha": "18e780a108d5a5420f677c2706786111766967d9", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -299,7 +299,9 @@ pub fn std_cargo(builder: &Builder<'_>, target: TargetSelection, stage: u32, car\n \n     // Determine if we're going to compile in optimized C intrinsics to\n     // the `compiler-builtins` crate. These intrinsics live in LLVM's\n-    // `compiler-rt` repository.\n+    // `compiler-rt` repository, but our `src/llvm-project` submodule isn't\n+    // always checked out, so we need to conditionally look for this. (e.g. if\n+    // an external LLVM is used we skip the LLVM submodule checkout).\n     //\n     // Note that this shouldn't affect the correctness of `compiler-builtins`,\n     // but only its speed. Some intrinsics in C haven't been translated to Rust\n@@ -310,15 +312,8 @@ pub fn std_cargo(builder: &Builder<'_>, target: TargetSelection, stage: u32, car\n     // If `compiler-rt` is available ensure that the `c` feature of the\n     // `compiler-builtins` crate is enabled and it's configured to learn where\n     // `compiler-rt` is located.\n-    let compiler_builtins_c_feature = if builder.config.optimized_compiler_builtins {\n-        if !builder.is_rust_llvm(target) {\n-            panic!(\n-                \"need a managed LLVM submodule for optimized intrinsics support; unset `llvm-config` or `optimized-compiler-builtins`\"\n-            );\n-        }\n-\n-        builder.update_submodule(&Path::new(\"src\").join(\"llvm-project\"));\n-        let compiler_builtins_root = builder.src.join(\"src/llvm-project/compiler-rt\");\n+    let compiler_builtins_root = builder.src.join(\"src/llvm-project/compiler-rt\");\n+    let compiler_builtins_c_feature = if compiler_builtins_root.exists() {\n         // Note that `libprofiler_builtins/build.rs` also computes this so if\n         // you're changing something here please also change that.\n         cargo.env(\"RUST_COMPILER_RT_ROOT\", &compiler_builtins_root);"}, {"sha": "21dc11c48081e8f18ac2da327378772b85a5cd8c", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 40, "deletions": 19, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -73,8 +73,6 @@ pub struct Config {\n     pub color: Color,\n     pub patch_binaries_for_nix: bool,\n     pub stage0_metadata: Stage0Metadata,\n-    /// Whether to use the `c` feature of the `compiler_builtins` crate.\n-    pub optimized_compiler_builtins: bool,\n \n     pub on_fail: Option<String>,\n     pub stage: u32,\n@@ -624,7 +622,6 @@ define_config! {\n         bench_stage: Option<u32> = \"bench-stage\",\n         patch_binaries_for_nix: Option<bool> = \"patch-binaries-for-nix\",\n         metrics: Option<bool> = \"metrics\",\n-        optimized_compiler_builtins: Option<bool> = \"optimized-compiler-builtins\",\n     }\n }\n \n@@ -1013,7 +1010,6 @@ impl Config {\n         set(&mut config.print_step_timings, build.print_step_timings);\n         set(&mut config.print_step_rusage, build.print_step_rusage);\n         set(&mut config.patch_binaries_for_nix, build.patch_binaries_for_nix);\n-        set(&mut config.optimized_compiler_builtins, build.optimized_compiler_builtins);\n \n         config.verbose = cmp::max(config.verbose, flags.verbose);\n \n@@ -1384,21 +1380,46 @@ impl Config {\n         git\n     }\n \n-    pub(crate) fn artifact_channel(&self, builder: &Builder<'_>, commit: &str) -> String {\n-        if builder.rust_info.is_managed_git_subrepository() {\n+    /// Bootstrap embeds a version number into the name of shared libraries it uploads in CI.\n+    /// Return the version it would have used for the given commit.\n+    pub(crate) fn artifact_version_part(&self, builder: &Builder<'_>, commit: &str) -> String {\n+        let (channel, version) = if builder.rust_info.is_managed_git_subrepository() {\n             let mut channel = self.git();\n             channel.arg(\"show\").arg(format!(\"{}:src/ci/channel\", commit));\n             let channel = output(&mut channel);\n-            channel.trim().to_owned()\n-        } else if let Ok(channel) = fs::read_to_string(builder.src.join(\"src/ci/channel\")) {\n-            channel.trim().to_owned()\n+            let mut version = self.git();\n+            version.arg(\"show\").arg(format!(\"{}:src/version\", commit));\n+            let version = output(&mut version);\n+            (channel.trim().to_owned(), version.trim().to_owned())\n         } else {\n-            let src = builder.src.display();\n-            eprintln!(\"error: failed to determine artifact channel\");\n-            eprintln!(\n-                \"help: either use git or ensure that {src}/src/ci/channel contains the name of the channel to use\"\n-            );\n-            panic!();\n+            let channel = fs::read_to_string(builder.src.join(\"src/ci/channel\"));\n+            let version = fs::read_to_string(builder.src.join(\"src/version\"));\n+            match (channel, version) {\n+                (Ok(channel), Ok(version)) => {\n+                    (channel.trim().to_owned(), version.trim().to_owned())\n+                }\n+                (channel, version) => {\n+                    let src = builder.src.display();\n+                    eprintln!(\"error: failed to determine artifact channel and/or version\");\n+                    eprintln!(\n+                        \"help: consider using a git checkout or ensure these files are readable\"\n+                    );\n+                    if let Err(channel) = channel {\n+                        eprintln!(\"reading {}/src/ci/channel failed: {:?}\", src, channel);\n+                    }\n+                    if let Err(version) = version {\n+                        eprintln!(\"reading {}/src/version failed: {:?}\", src, version);\n+                    }\n+                    panic!();\n+                }\n+            }\n+        };\n+\n+        match channel.as_str() {\n+            \"stable\" => version,\n+            \"beta\" => channel,\n+            \"nightly\" => channel,\n+            other => unreachable!(\"{:?} is not recognized as a valid channel\", other),\n         }\n     }\n \n@@ -1641,7 +1662,7 @@ fn maybe_download_rustfmt(builder: &Builder<'_>) -> Option<PathBuf> {\n \n fn download_ci_rustc(builder: &Builder<'_>, commit: &str) {\n     builder.verbose(&format!(\"using downloaded stage2 artifacts from CI (commit {commit})\"));\n-    let channel = builder.config.artifact_channel(builder, commit);\n+    let version = builder.config.artifact_version_part(builder, commit);\n     let host = builder.config.build.triple;\n     let bin_root = builder.out.join(host).join(\"ci-rustc\");\n     let rustc_stamp = bin_root.join(\".rustc-stamp\");\n@@ -1650,13 +1671,13 @@ fn download_ci_rustc(builder: &Builder<'_>, commit: &str) {\n         if bin_root.exists() {\n             t!(fs::remove_dir_all(&bin_root));\n         }\n-        let filename = format!(\"rust-std-{channel}-{host}.tar.xz\");\n+        let filename = format!(\"rust-std-{version}-{host}.tar.xz\");\n         let pattern = format!(\"rust-std-{host}\");\n         download_ci_component(builder, filename, &pattern, commit);\n-        let filename = format!(\"rustc-{channel}-{host}.tar.xz\");\n+        let filename = format!(\"rustc-{version}-{host}.tar.xz\");\n         download_ci_component(builder, filename, \"rustc\", commit);\n         // download-rustc doesn't need its own cargo, it can just use beta's.\n-        let filename = format!(\"rustc-dev-{channel}-{host}.tar.xz\");\n+        let filename = format!(\"rustc-dev-{version}-{host}.tar.xz\");\n         download_ci_component(builder, filename, \"rustc-dev\", commit);\n \n         builder.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"rustc\"));"}, {"sha": "805633c926c3a49d68544ccaff3093f570815047", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -1847,21 +1847,23 @@ fn add_env(builder: &Builder<'_>, cmd: &mut Command, target: TargetSelection) {\n ///\n /// Returns whether the files were actually copied.\n fn maybe_install_llvm(builder: &Builder<'_>, target: TargetSelection, dst_libdir: &Path) -> bool {\n-    if !builder.is_rust_llvm(target) {\n-        // If the LLVM was externally provided, then we don't currently copy\n-        // artifacts into the sysroot. This is not necessarily the right\n-        // choice (in particular, it will require the LLVM dylib to be in\n-        // the linker's load path at runtime), but the common use case for\n-        // external LLVMs is distribution provided LLVMs, and in that case\n-        // they're usually in the standard search path (e.g., /usr/lib) and\n-        // copying them here is going to cause problems as we may end up\n-        // with the wrong files and isn't what distributions want.\n-        //\n-        // This behavior may be revisited in the future though.\n-        //\n-        // If the LLVM is coming from ourselves (just from CI) though, we\n-        // still want to install it, as it otherwise won't be available.\n-        return false;\n+    if let Some(config) = builder.config.target_config.get(&target) {\n+        if config.llvm_config.is_some() && !builder.config.llvm_from_ci {\n+            // If the LLVM was externally provided, then we don't currently copy\n+            // artifacts into the sysroot. This is not necessarily the right\n+            // choice (in particular, it will require the LLVM dylib to be in\n+            // the linker's load path at runtime), but the common use case for\n+            // external LLVMs is distribution provided LLVMs, and in that case\n+            // they're usually in the standard search path (e.g., /usr/lib) and\n+            // copying them here is going to cause problems as we may end up\n+            // with the wrong files and isn't what distributions want.\n+            //\n+            // This behavior may be revisited in the future though.\n+            //\n+            // If the LLVM is coming from ourselves (just from CI) though, we\n+            // still want to install it, as it otherwise won't be available.\n+            return false;\n+        }\n     }\n \n     // On macOS, rustc (and LLVM tools) link to an unversioned libLLVM.dylib"}, {"sha": "5d265b9ad0c19eb5473620dfe65f8ddbfc948557", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 6, "deletions": 29, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -765,7 +765,7 @@ impl Step for Rustc {\n }\n \n macro_rules! tool_doc {\n-    ($tool: ident, $should_run: literal, $path: literal, [$($krate: literal),+ $(,)?], in_tree = $in_tree:expr $(,)?) => {\n+    ($tool: ident, $should_run: literal, $path: literal, [$($krate: literal),+ $(,)?] $(,)?) => {\n         #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n         pub struct $tool {\n             target: TargetSelection,\n@@ -821,12 +821,6 @@ macro_rules! tool_doc {\n                 t!(fs::create_dir_all(&out_dir));\n                 t!(symlink_dir_force(&builder.config, &out, &out_dir));\n \n-                let source_type = if $in_tree == true {\n-                    SourceType::InTree\n-                } else {\n-                    SourceType::Submodule\n-                };\n-\n                 // Build cargo command.\n                 let mut cargo = prepare_tool_cargo(\n                     builder,\n@@ -835,7 +829,7 @@ macro_rules! tool_doc {\n                     target,\n                     \"doc\",\n                     $path,\n-                    source_type,\n+                    SourceType::InTree,\n                     &[],\n                 );\n \n@@ -851,38 +845,21 @@ macro_rules! tool_doc {\n                 cargo.rustdocflag(\"--show-type-layout\");\n                 cargo.rustdocflag(\"--generate-link-to-definition\");\n                 cargo.rustdocflag(\"-Zunstable-options\");\n-                if $in_tree == true {\n-                    builder.run(&mut cargo.into());\n-                } else {\n-                    // Allow out-of-tree docs to fail (since the tool might be in a broken state).\n-                    if !builder.try_run(&mut cargo.into()) {\n-                        builder.info(&format!(\n-                            \"WARNING: tool {} failed to document; ignoring failure because it is an out-of-tree tool\",\n-                            stringify!($tool).to_lowercase(),\n-                        ));\n-                    }\n-                }\n+                builder.run(&mut cargo.into());\n             }\n         }\n     }\n }\n \n-tool_doc!(\n-    Rustdoc,\n-    \"rustdoc-tool\",\n-    \"src/tools/rustdoc\",\n-    [\"rustdoc\", \"rustdoc-json-types\"],\n-    in_tree = true\n-);\n+tool_doc!(Rustdoc, \"rustdoc-tool\", \"src/tools/rustdoc\", [\"rustdoc\", \"rustdoc-json-types\"],);\n tool_doc!(\n     Rustfmt,\n     \"rustfmt-nightly\",\n     \"src/tools/rustfmt\",\n     [\"rustfmt-nightly\", \"rustfmt-config_proc_macro\"],\n-    in_tree = true\n );\n-tool_doc!(Clippy, \"clippy\", \"src/tools/clippy\", [\"clippy_utils\"], in_tree = true);\n-tool_doc!(Miri, \"miri\", \"src/tools/miri\", [\"miri\"], in_tree = false);\n+tool_doc!(Clippy, \"clippy\", \"src/tools/clippy\", [\"clippy_utils\"]);\n+tool_doc!(Miri, \"miri\", \"src/tools/miri\", [\"miri\"]);\n \n #[derive(Ord, PartialOrd, Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct ErrorIndex {"}, {"sha": "f5def8ba8341f58b817afaedb9828e75a6ad0ff7", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -1152,8 +1152,8 @@ impl Build {\n                 options[0] = Some(\"-Clink-arg=-fuse-ld=lld\".to_string());\n             }\n \n-            let threads = if target.contains(\"windows\") { \"/threads:1\" } else { \"--threads=1\" };\n-            options[1] = Some(format!(\"-Clink-arg=-Wl,{}\", threads));\n+            let no_threads = util::lld_flag_no_threads(target.contains(\"windows\"));\n+            options[1] = Some(format!(\"-Clink-arg=-Wl,{}\", no_threads));\n         }\n \n         IntoIterator::into_iter(options).flatten()"}, {"sha": "94a61b727a32bccfb2bd33e1b47b1fc68a4d74f5", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -269,8 +269,8 @@ fn download_ci_llvm(builder: &Builder<'_>, llvm_sha: &str) {\n     } else {\n         &builder.config.stage0_metadata.config.artifacts_server\n     };\n-    let channel = builder.config.artifact_channel(builder, llvm_sha);\n-    let filename = format!(\"rust-dev-{}-{}.tar.xz\", channel, builder.build.build.triple);\n+    let version = builder.config.artifact_version_part(builder, llvm_sha);\n+    let filename = format!(\"rust-dev-{}-{}.tar.xz\", version, builder.build.build.triple);\n     let tarball = rustc_cache.join(&filename);\n     if !tarball.exists() {\n         let help_on_error = \"error: failed to download llvm from ci"}, {"sha": "935ce5e7f84b3f154e9feec282b3b65937d6d284", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -509,7 +509,7 @@ impl Step for Miri {\n             host,\n             \"run\",\n             \"src/tools/miri/cargo-miri\",\n-            SourceType::Submodule,\n+            SourceType::InTree,\n             &[],\n         );\n         cargo.add_rustc_lib_path(builder, compiler);\n@@ -557,7 +557,7 @@ impl Step for Miri {\n             host,\n             \"test\",\n             \"src/tools/miri\",\n-            SourceType::Submodule,\n+            SourceType::InTree,\n             &[],\n         );\n         cargo.add_rustc_lib_path(builder, compiler);\n@@ -771,7 +771,10 @@ impl Step for RustdocTheme {\n             cmd.env(\"RUSTDOC_LINKER\", linker);\n         }\n         if builder.is_fuse_ld_lld(self.compiler.host) {\n-            cmd.env(\"RUSTDOC_FUSE_LD_LLD\", \"1\");\n+            cmd.env(\n+                \"RUSTDOC_LLD_NO_THREADS\",\n+                util::lld_flag_no_threads(self.compiler.host.contains(\"windows\")),\n+            );\n         }\n         try_run(builder, &mut cmd);\n     }\n@@ -983,6 +986,7 @@ impl Step for RustdocGUI {\n                     .arg(\"doc\")\n                     .arg(\"--target-dir\")\n                     .arg(&out_dir)\n+                    .env(\"RUSTC_BOOTSTRAP\", \"1\")\n                     .env(\"RUSTDOC\", builder.rustdoc(self.compiler))\n                     .env(\"RUSTC\", builder.rustc(self.compiler))\n                     .current_dir(path);\n@@ -1048,6 +1052,9 @@ impl Step for Tidy {\n         if builder.is_verbose() {\n             cmd.arg(\"--verbose\");\n         }\n+        if builder.config.cmd.bless() {\n+            cmd.arg(\"--bless\");\n+        }\n \n         builder.info(\"tidy check\");\n         try_run(builder, &mut cmd);\n@@ -1722,6 +1729,8 @@ impl BookTest {\n \n         let mut rustbook_cmd = builder.tool_cmd(Tool::Rustbook);\n         let path = builder.src.join(&self.path);\n+        // Books often have feature-gated example text.\n+        rustbook_cmd.env(\"RUSTC_BOOTSTRAP\", \"1\");\n         rustbook_cmd.env(\"PATH\", new_path).arg(\"test\").arg(path);\n         builder.add_rust_test_threads(&mut rustbook_cmd);\n         builder.info(&format!(\"Testing rustbook {}\", self.path.display()));"}, {"sha": "d395220694705e7c6c6c586df1bbdc98c88936ac", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -794,10 +794,9 @@ macro_rules! tool_extended {\n        $($name:ident,\n        $path:expr,\n        $tool_name:expr,\n-       stable = $stable:expr,\n-       $(in_tree = $in_tree:expr,)?\n-       $(tool_std = $tool_std:literal,)?\n-       $extra_deps:block;)+) => {\n+       stable = $stable:expr\n+       $(,tool_std = $tool_std:literal)?\n+       ;)+) => {\n         $(\n             #[derive(Debug, Clone, Hash, PartialEq, Eq)]\n         pub struct $name {\n@@ -839,7 +838,6 @@ macro_rules! tool_extended {\n \n             #[allow(unused_mut)]\n             fn run(mut $sel, $builder: &Builder<'_>) -> Option<PathBuf> {\n-                $extra_deps\n                 $builder.ensure(ToolBuild {\n                     compiler: $sel.compiler,\n                     target: $sel.target,\n@@ -848,11 +846,7 @@ macro_rules! tool_extended {\n                     path: $path,\n                     extra_features: $sel.extra_features,\n                     is_optional_tool: true,\n-                    source_type: if false $(|| $in_tree)* {\n-                        SourceType::InTree\n-                    } else {\n-                        SourceType::Submodule\n-                    },\n+                    source_type: SourceType::InTree,\n                 })\n             }\n         }\n@@ -865,17 +859,17 @@ macro_rules! tool_extended {\n // Note: Most submodule updates for tools are handled by bootstrap.py, since they're needed just to\n // invoke Cargo to build bootstrap. See the comment there for more details.\n tool_extended!((self, builder),\n-    Cargofmt, \"src/tools/rustfmt\", \"cargo-fmt\", stable=true, in_tree=true, {};\n-    CargoClippy, \"src/tools/clippy\", \"cargo-clippy\", stable=true, in_tree=true, {};\n-    Clippy, \"src/tools/clippy\", \"clippy-driver\", stable=true, in_tree=true, {};\n-    Miri, \"src/tools/miri\", \"miri\", stable=false, in_tree=true, {};\n-    CargoMiri, \"src/tools/miri/cargo-miri\", \"cargo-miri\", stable=false, in_tree=true, {};\n+    Cargofmt, \"src/tools/rustfmt\", \"cargo-fmt\", stable=true;\n+    CargoClippy, \"src/tools/clippy\", \"cargo-clippy\", stable=true;\n+    Clippy, \"src/tools/clippy\", \"clippy-driver\", stable=true;\n+    Miri, \"src/tools/miri\", \"miri\", stable=false;\n+    CargoMiri, \"src/tools/miri/cargo-miri\", \"cargo-miri\", stable=true;\n     // FIXME: tool_std is not quite right, we shouldn't allow nightly features.\n     // But `builder.cargo` doesn't know how to handle ToolBootstrap in stages other than 0,\n     // and this is close enough for now.\n-    Rls, \"src/tools/rls\", \"rls\", stable=true, in_tree=true, tool_std=true, {};\n-    RustDemangler, \"src/tools/rust-demangler\", \"rust-demangler\", stable=false, in_tree=true, tool_std=true, {};\n-    Rustfmt, \"src/tools/rustfmt\", \"rustfmt\", stable=true, in_tree=true, {};\n+    Rls, \"src/tools/rls\", \"rls\", stable=true, tool_std=true;\n+    RustDemangler, \"src/tools/rust-demangler\", \"rust-demangler\", stable=false, tool_std=true;\n+    Rustfmt, \"src/tools/rustfmt\", \"rustfmt\", stable=true;\n );\n \n impl<'a> Builder<'a> {"}, {"sha": "20c3801f0a50222cbcc792f98a2786a993d7b5c6", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -13,6 +13,7 @@ use std::time::{Instant, SystemTime, UNIX_EPOCH};\n \n use crate::builder::Builder;\n use crate::config::{Config, TargetSelection};\n+use crate::OnceCell;\n \n /// A helper macro to `unwrap` a result except also print out details like:\n ///\n@@ -607,3 +608,16 @@ pub fn get_clang_cl_resource_dir(clang_cl_path: &str) -> PathBuf {\n     let clang_rt_dir = clang_rt_builtins.parent().expect(\"The clang lib folder should exist\");\n     clang_rt_dir.to_path_buf()\n }\n+\n+pub fn lld_flag_no_threads(is_windows: bool) -> &'static str {\n+    static LLD_NO_THREADS: OnceCell<(&'static str, &'static str)> = OnceCell::new();\n+    let (windows, other) = LLD_NO_THREADS.get_or_init(|| {\n+        let out = output(Command::new(\"lld\").arg(\"-flavor\").arg(\"ld\").arg(\"--version\"));\n+        let newer = match (out.find(char::is_numeric), out.find('.')) {\n+            (Some(b), Some(e)) => out.as_str()[b..e].parse::<i32>().ok().unwrap_or(14) > 10,\n+            _ => true,\n+        };\n+        if newer { (\"/threads:1\", \"--threads=1\") } else { (\"/no-threads\", \"--no-threads\") }\n+    });\n+    if is_windows { windows } else { other }\n+}"}, {"sha": "5ddd3f180396466223ee2e6bf71c0947b3cbc126", "filename": "src/ci/docker/host-x86_64/disabled/dist-x86_64-haiku/Dockerfile", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-x86_64-haiku%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-x86_64-haiku%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-x86_64-haiku%2FDockerfile?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -47,6 +47,4 @@ ENV RUST_CONFIGURE_ARGS --disable-jemalloc \\\n   --set=$TARGET.cc=x86_64-unknown-haiku-gcc \\\n   --set=$TARGET.cxx=x86_64-unknown-haiku-g++ \\\n   --set=$TARGET.llvm-config=/bin/llvm-config-haiku\n-ENV EXTERNAL_LLVM 1\n-\n ENV SCRIPT python3 ../x.py dist --host=$HOST --target=$HOST"}, {"sha": "126c292b38ea1f7a179b5ddaea5762ddc648a715", "filename": "src/ci/docker/host-x86_64/dist-various-2/Dockerfile", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2FDockerfile?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -129,6 +129,4 @@ ENV RUST_CONFIGURE_ARGS --enable-extended --enable-lld --disable-docs \\\n   --set target.wasm32-wasi.wasi-root=/wasm32-wasi \\\n   --musl-root-armv7=/musl-armv7\n \n-ENV EXTERNAL_LLVM 1\n-\n ENV SCRIPT python3 ../x.py dist --host='' --target $TARGETS"}, {"sha": "b0f35bcb9ccf505580aaba4f966ad089a4864b4a", "filename": "src/ci/docker/host-x86_64/test-various/Dockerfile", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2FDockerfile?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -16,7 +16,9 @@ RUN apt-get update && DEBIAN_FRONTEND=noninteractive apt-get install -y --no-ins\n   pkg-config \\\n   xz-utils \\\n   wget \\\n-  patch\n+  patch \\\n+  ovmf \\\n+  qemu-system-x86\n \n RUN curl -sL https://nodejs.org/dist/v15.14.0/node-v15.14.0-linux-x64.tar.xz | \\\n   tar -xJ\n@@ -64,4 +66,9 @@ ENV MUSL_TARGETS=x86_64-unknown-linux-musl \\\n     CXX_x86_64_unknown_linux_musl=x86_64-linux-musl-g++\n ENV MUSL_SCRIPT python3 /checkout/x.py --stage 2 test --host='' --target $MUSL_TARGETS\n \n-ENV SCRIPT $WASM_SCRIPT && $NVPTX_SCRIPT && $MUSL_SCRIPT\n+COPY host-x86_64/test-various/uefi_qemu_test /uefi_qemu_test\n+ENV UEFI_TARGETS=x86_64-unknown-uefi\n+ENV UEFI_SCRIPT python3 /checkout/x.py --stage 2 build --host='' --target $UEFI_TARGETS && \\\n+  python3 -u /uefi_qemu_test/run.py\n+\n+ENV SCRIPT $WASM_SCRIPT && $NVPTX_SCRIPT && $MUSL_SCRIPT && $UEFI_SCRIPT"}, {"sha": "fa8e5b3d08060ec3e547552148f23abe5f757984", "filename": "src/ci/docker/host-x86_64/test-various/uefi_qemu_test/Cargo.toml", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2Fuefi_qemu_test%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2Fuefi_qemu_test%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2Fuefi_qemu_test%2FCargo.toml?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -0,0 +1,9 @@\n+[package]\n+name = \"uefi_qemu_test\"\n+version = \"0.0.0\"\n+edition = \"2021\"\n+\n+[workspace]\n+\n+[dependencies]\n+r-efi = \"4.1.0\""}, {"sha": "46793ce3afa15901f88fe83dde0bea5f8e49a715", "filename": "src/ci/docker/host-x86_64/test-various/uefi_qemu_test/run.py", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2Fuefi_qemu_test%2Frun.py", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2Fuefi_qemu_test%2Frun.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2Fuefi_qemu_test%2Frun.py?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -0,0 +1,96 @@\n+#!/usr/bin/env python3\n+\n+import os\n+import shutil\n+import subprocess\n+import sys\n+import tempfile\n+\n+from pathlib import Path\n+\n+\n+def run(*cmd, capture=False, check=True, env=None):\n+    \"\"\"Print and run a command, optionally capturing the output.\"\"\"\n+    cmd = [str(p) for p in cmd]\n+    print(' '.join(cmd))\n+    return subprocess.run(cmd,\n+                          capture_output=capture,\n+                          check=check,\n+                          env=env,\n+                          text=True)\n+\n+\n+def build_and_run(tmp_dir):\n+    host_artifacts = Path('/checkout/obj/build/x86_64-unknown-linux-gnu')\n+    stage0 = host_artifacts / 'stage0/bin'\n+    stage2 = host_artifacts / 'stage2/bin'\n+\n+    env = dict(os.environ)\n+    env['PATH'] = '{}:{}:{}'.format(stage2, stage0, env['PATH'])\n+\n+    # Copy the test create into `tmp_dir`.\n+    test_crate = Path(tmp_dir) / 'uefi_qemu_test'\n+    shutil.copytree('/uefi_qemu_test', test_crate)\n+\n+    # Build the UEFI executable.\n+    target = 'x86_64-unknown-uefi'\n+    run('cargo',\n+        'build',\n+        '--manifest-path',\n+        test_crate / 'Cargo.toml',\n+        '--target',\n+        target,\n+        env=env)\n+\n+    # Create a mock EFI System Partition in a subdirectory.\n+    esp = test_crate / 'esp'\n+    boot = esp / 'efi/boot'\n+    os.makedirs(boot, exist_ok=True)\n+\n+    # Copy the executable into the ESP.\n+    src_exe_path = test_crate / 'target' / target / 'debug/uefi_qemu_test.efi'\n+    shutil.copy(src_exe_path, boot / 'bootx64.efi')\n+\n+    # Run the executable in QEMU and capture the output.\n+    qemu = 'qemu-system-x86_64'\n+    ovmf_dir = Path('/usr/share/OVMF')\n+    ovmf_code = ovmf_dir / 'OVMF_CODE.fd'\n+    ovmf_vars = ovmf_dir / 'OVMF_VARS.fd'\n+    output = run(qemu,\n+                 '-display',\n+                 'none',\n+                 '-serial',\n+                 'stdio',\n+                 '-drive',\n+                 f'if=pflash,format=raw,readonly=on,file={ovmf_code}',\n+                 '-drive',\n+                 f'if=pflash,format=raw,readonly=on,file={ovmf_vars}',\n+                 '-drive',\n+                 f'format=raw,file=fat:rw:{esp}',\n+                 capture=True,\n+                 # Ubuntu 20.04 (which is what the Dockerfile currently\n+                 # uses) provides QEMU 4.2.1, which segfaults on\n+                 # shutdown under some circumstances. That has been\n+                 # fixed in newer versions of QEMU, but for now just\n+                 # don't check the exit status.\n+                 check=False).stdout\n+\n+    if 'Hello World!' in output:\n+        print('VM produced expected output')\n+    else:\n+        print('unexpected VM output:')\n+        print('---start---')\n+        print(output)\n+        print('---end---')\n+        sys.exit(1)\n+\n+\n+def main():\n+    # Create a temporary directory so that we have a writeable\n+    # workspace.\n+    with tempfile.TemporaryDirectory() as tmp_dir:\n+        build_and_run(tmp_dir)\n+\n+\n+if __name__ == \"__main__\":\n+    main()"}, {"sha": "2ec554c140b59106007e453ee558b62abcaae11f", "filename": "src/ci/docker/host-x86_64/test-various/uefi_qemu_test/src/main.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2Fuefi_qemu_test%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2Fuefi_qemu_test%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2Fuefi_qemu_test%2Fsrc%2Fmain.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -0,0 +1,45 @@\n+// Code is adapted from this hello world example:\n+// https://doc.rust-lang.org/nightly/rustc/platform-support/unknown-uefi.html\n+\n+#![no_main]\n+#![no_std]\n+\n+use core::{panic, ptr};\n+use r_efi::efi::{Char16, Handle, Status, SystemTable, RESET_SHUTDOWN};\n+\n+#[panic_handler]\n+fn panic_handler(_info: &panic::PanicInfo) -> ! {\n+    loop {}\n+}\n+\n+#[export_name = \"efi_main\"]\n+pub extern \"C\" fn main(_h: Handle, st: *mut SystemTable) -> Status {\n+    let s = [\n+        0x0048u16, 0x0065u16, 0x006cu16, 0x006cu16, 0x006fu16, // \"Hello\"\n+        0x0020u16, //                                             \" \"\n+        0x0057u16, 0x006fu16, 0x0072u16, 0x006cu16, 0x0064u16, // \"World\"\n+        0x0021u16, //                                             \"!\"\n+        0x000au16, //                                             \"\\n\"\n+        0x0000u16, //                                             NUL\n+    ];\n+\n+    // Print \"Hello World!\".\n+    let r = unsafe { ((*(*st).con_out).output_string)((*st).con_out, s.as_ptr() as *mut Char16) };\n+    if r.is_error() {\n+        return r;\n+    }\n+\n+    // Shut down.\n+    unsafe {\n+        ((*((*st).runtime_services)).reset_system)(\n+            RESET_SHUTDOWN,\n+            Status::SUCCESS,\n+            0,\n+            ptr::null_mut(),\n+        );\n+    }\n+\n+    // This should never be reached because `reset_system` should never\n+    // return, so fail with an error if we get here.\n+    Status::UNSUPPORTED\n+}"}, {"sha": "23f2215c2d93cfbe85e3e06028f00793c96af05d", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-llvm-13-stage1/Dockerfile", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-13-stage1%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-13-stage1%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-13-stage1%2FDockerfile?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -29,7 +29,6 @@ RUN sh /scripts/sccache.sh\n # We are disabling CI LLVM since this builder is intentionally using a host\n # LLVM, rather than the typical src/llvm-project LLVM.\n ENV NO_DOWNLOAD_CI_LLVM 1\n-ENV EXTERNAL_LLVM 1\n \n # Using llvm-link-shared due to libffi issues -- see #34486\n ENV RUST_CONFIGURE_ARGS \\"}, {"sha": "8f6831bc54e63e6b693c031ab6d7cda8f701d7e8", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-llvm-13/Dockerfile", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-13%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-13%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-13%2FDockerfile?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -40,7 +40,6 @@ RUN sh /scripts/sccache.sh\n # We are disabling CI LLVM since this builder is intentionally using a host\n # LLVM, rather than the typical src/llvm-project LLVM.\n ENV NO_DOWNLOAD_CI_LLVM 1\n-ENV EXTERNAL_LLVM 1\n \n # Using llvm-link-shared due to libffi issues -- see #34486\n ENV RUST_CONFIGURE_ARGS \\"}, {"sha": "9a247fb60a8ee0535c20ecc4d5ab0f4e135c8ab4", "filename": "src/ci/run.sh", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -69,11 +69,6 @@ RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --set rust.codegen-units-std=1\"\n # space required for CI artifacts.\n RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --dist-compression-formats=xz\"\n \n-# Enable the `c` feature for compiler_builtins, but only when the `compiler-rt` source is available.\n-if [ \"$EXTERNAL_LLVM\" = \"\" ]; then\n-  RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --set build.optimized-compiler-builtins\"\n-fi\n-\n if [ \"$DIST_SRC\" = \"\" ]; then\n   RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --disable-dist-src\"\n fi"}, {"sha": "86bb2c0d3816ae2c94b3fb4ba11f299cdcae8c2c", "filename": "src/doc/rustc/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -29,6 +29,7 @@\n     - [\\*-kmc-solid_\\*](platform-support/kmc-solid.md)\n     - [m68k-unknown-linux-gnu](platform-support/m68k-unknown-linux-gnu.md)\n     - [mips64-openwrt-linux-musl](platform-support/mips64-openwrt-linux-musl.md)\n+    - [mipsel-sony-psx](platform-support/mipsel-sony-psx.md)\n     - [nvptx64-nvidia-cuda](platform-support/nvptx64-nvidia-cuda.md)\n     - [riscv32imac-unknown-xous-elf](platform-support/riscv32imac-unknown-xous-elf.md)\n     - [*-pc-windows-gnullvm](platform-support/pc-windows-gnullvm.md)"}, {"sha": "f5a49410ea555e03f6937976d23ed8b8d08f5942", "filename": "src/doc/rustc/src/codegen-options/index.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -531,8 +531,10 @@ platforms. Possible values are:\n   debug information. On other Unix platforms this means that `*.dwo` files will\n   contain debug information.\n \n-Note that `packed` and `unpacked` are gated behind `-Z unstable-options` on\n-non-macOS platforms at this time.\n+Note that all three options are supported on Linux and Apple platforms,\n+`packed` is supported on Windows-MSVC, and all other platforms support `off`.\n+Attempting to use an unsupported option requires using the nightly channel\n+with the `-Z unstable-options` flag.\n \n ## strip\n "}, {"sha": "3ae9872cf62d4e8304d7b34d1bbe63fffa347194", "filename": "src/doc/rustc/src/platform-support.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -260,6 +260,7 @@ target | std | host | notes\n `mips-unknown-linux-uclibc` | \u2713 |  | MIPS Linux with uClibc\n [`mips64-openwrt-linux-musl`](platform-support/mips64-openwrt-linux-musl.md) | ? |  | MIPS64 for OpenWrt Linux MUSL\n `mipsel-sony-psp` | * |  | MIPS (LE) Sony PlayStation Portable (PSP)\n+[`mipsel-sony-psx`](platform-support/mipsel-sony-psx.md) | * |  | MIPS (LE) Sony PlayStation 1 (PSX)\n `mipsel-unknown-linux-uclibc` | \u2713 |  | MIPS (LE) Linux with uClibc\n `mipsel-unknown-none` | * |  | Bare MIPS (LE) softfloat\n `mipsisa32r6-unknown-linux-gnu` | ? |  |"}, {"sha": "589100e8888b32c22e91e41089f38128843b9647", "filename": "src/doc/rustc/src/platform-support/mipsel-sony-psx.md", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Fmipsel-sony-psx.md", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Fmipsel-sony-psx.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Fmipsel-sony-psx.md?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -0,0 +1,49 @@\n+# mipsel-sony-psx\n+\n+**Tier: 3**\n+\n+Sony PlayStation 1 (psx)\n+\n+## Designated Developer\n+\n+* [@ayrtonm](https://github.com/ayrtonm)\n+\n+## Requirements\n+\n+This target is cross-compiled.\n+It has no special requirements for the host.\n+\n+## Building\n+\n+The target can be built by enabling it for a `rustc` build:\n+\n+```toml\n+[build]\n+build-stage = 1\n+target = [\"mipsel-sony-psx\"]\n+```\n+\n+## Cross-compilation\n+\n+This target can be cross-compiled from any host.\n+\n+## Testing\n+\n+Currently there is no support to run the rustc test suite for this target.\n+\n+## Building Rust programs\n+\n+Since it is Tier 3, rust doesn't ship pre-compiled artifacts for this target.\n+\n+Just use the `build-std` nightly cargo feature to build the `core` and `alloc` libraries:\n+```shell\n+cargo build -Zbuild-std=core,alloc --target mipsel-sony-psx\n+```\n+\n+The command above generates an ELF. To generate binaries in the PSEXE format that emulators run, you can use [cargo-psx](https://github.com/ayrtonm/psx-sdk-rs#readme):\n+\n+```shell\n+cargo psx build\n+```\n+\n+or use `-Clink-arg=--oformat=binary` to produce a flat binary."}, {"sha": "df9131ce84afda1444f50c637c0d2796d735e921", "filename": "src/doc/rustc/src/target-tier-policy.md", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fdoc%2Frustc%2Fsrc%2Ftarget-tier-policy.md", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fdoc%2Frustc%2Fsrc%2Ftarget-tier-policy.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Ftarget-tier-policy.md?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -3,6 +3,7 @@\n ## Table of Contents\n \n * [General](#general)\n+* [Adding a new target](#adding-a-new-target)\n * [Tier 3 target policy](#tier-3-target-policy)\n * [Tier 2 target policy](#tier-2-target-policy)\n   * [Tier 2 with host tools](#tier-2-with-host-tools)\n@@ -104,6 +105,30 @@ indicates something entirely optional, and does not indicate guidance or\n recommendations. This language is based on [IETF RFC\n 2119](https://tools.ietf.org/html/rfc2119).\n \n+## Adding a new target\n+\n+New targets typically start as Tier 3 and then can be promoted later.\n+To propose addition of a new target, open a pull request on [`rust-lang/rust`]:\n+\n+- Copy the [Tier 3 target policy](#tier-3-target-policy) to the description\n+  and fill it out, see [example][tier3example].\n+- Add a new description for the target in `src/doc/rustc/src/platform-support`\n+  using the [template][platform_template].\n+- Add the target to the [SUMMARY.md][summary] (allows wildcards) and\n+  [platform-support.md][platformsupport] (must name all targets verbatim).\n+  Link to the created description page.\n+- Ensure the pull request is assigned to a member of the [Rust compiler team][rust_compiler_team] by commenting:\n+  ```text\n+  r? compiler-team\n+  ```\n+\n+[tier3example]: https://github.com/rust-lang/rust/pull/94872\n+[platform_template]: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support/TEMPLATE.md\n+[summary]: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/SUMMARY.md\n+[platformsupport]: https://github.com/rust-lang/rust/blob/master/src/doc/rustc/src/platform-support.md\n+[rust_compiler_team]: https://www.rust-lang.org/governance/teams/compiler\n+[`rust-lang/rust`]: https://github.com/rust-lang/rust\n+\n ## Tier 3 target policy\n \n At this tier, the Rust project provides no official support for a target, so we"}, {"sha": "dfa685785008366a30d395baedc1add28099b27b", "filename": "src/doc/rustdoc/book.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fdoc%2Frustdoc%2Fbook.toml", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fdoc%2Frustdoc%2Fbook.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fbook.toml?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -6,5 +6,9 @@ title = \"The rustdoc book\"\n git-repository-url = \"https://github.com/rust-lang/rust/tree/master/src/doc/rustdoc\"\n \n [output.html.redirect]\n+\"/what-to-include.html\" = \"write-documentation/what-to-include.html\"\n \"/the-doc-attribute.html\" = \"write-documentation/the-doc-attribute.html\"\n+\"/linking-to-items-by-name.html\" = \"write-documentation/linking-to-items-by-name.html\"\n \"/documentation-tests.html\" = \"write-documentation/documentation-tests.html\"\n+\"/website-features.html\" = \"advanced-features.html#custom-search-engines\"\n+\"/passes.html\" = \"deprecated-features.html#passes\""}, {"sha": "b20c30ec8f1c8533026067ceaf4eee82b4ced03a", "filename": "src/doc/unstable-book/src/language-features/extended-varargs-abi-support.md", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fextended-varargs-abi-support.md", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fextended-varargs-abi-support.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fextended-varargs-abi-support.md?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -0,0 +1,10 @@\n+# `extended_varargs_abi_support`\n+\n+The tracking issue for this feature is: [#100189]\n+\n+[#100189]: https://github.com/rust-lang/rust/issues/100189\n+\n+------------------------\n+\n+This feature adds the possibility of using `sysv64`, `win64` or `efiapi` calling\n+conventions on functions with varargs."}, {"sha": "0da69202e679fc41cdbc81861be29a42107a7922", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -20,7 +20,7 @@ serde_json = \"1.0\"\n serde = { version = \"1.0\", features = [\"derive\"] }\n smallvec = \"1.8.1\"\n tempfile = \"3\"\n-thin-vec = \"0.2.8\"\n+thin-vec = \"0.2.9\"\n tracing = \"0.1\"\n tracing-tree = \"0.2.0\"\n "}, {"sha": "84e77e69ecff397cca9edfc49b7289c1a2b3cc35", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -3,6 +3,7 @@ use rustc_hir as hir;\n use rustc_hir::lang_items::LangItem;\n use rustc_middle::ty::{self, Region, RegionVid, TypeFoldable, TypeSuperFoldable};\n use rustc_trait_selection::traits::auto_trait::{self, AutoTraitResult};\n+use thin_vec::ThinVec;\n \n use std::fmt::Debug;\n \n@@ -110,15 +111,14 @@ where\n                 );\n                 let params = raw_generics.params;\n \n-                Generics { params, where_predicates: Vec::new() }\n+                Generics { params, where_predicates: ThinVec::new() }\n             }\n             AutoTraitResult::ExplicitImpl => return None,\n         };\n \n         Some(Item {\n             name: None,\n             attrs: Default::default(),\n-            visibility: Inherited,\n             item_id: ItemId::Auto { trait_: trait_def_id, for_: item_def_id },\n             kind: Box::new(ImplItem(Box::new(Impl {\n                 unsafety: hir::Unsafety::Normal,\n@@ -130,6 +130,7 @@ where\n                 kind: ImplKind::Auto,\n             }))),\n             cfg: None,\n+            inline_stmt_id: None,\n         })\n     }\n \n@@ -183,7 +184,7 @@ where\n     fn handle_lifetimes<'cx>(\n         regions: &RegionConstraintData<'cx>,\n         names_map: &FxHashMap<Symbol, Lifetime>,\n-    ) -> Vec<WherePredicate> {\n+    ) -> ThinVec<WherePredicate> {\n         // Our goal is to 'flatten' the list of constraints by eliminating\n         // all intermediate RegionVids. At the end, all constraints should\n         // be between Regions (aka region variables). This gives us the information\n@@ -429,7 +430,7 @@ where\n         &mut self,\n         item_def_id: DefId,\n         param_env: ty::ParamEnv<'tcx>,\n-        mut existing_predicates: Vec<WherePredicate>,\n+        mut existing_predicates: ThinVec<WherePredicate>,\n         vid_to_region: FxHashMap<ty::RegionVid, ty::Region<'tcx>>,\n     ) -> Generics {\n         debug!(\n@@ -663,7 +664,7 @@ where\n     /// both for visual consistency between 'rustdoc' runs, and to\n     /// make writing tests much easier\n     #[inline]\n-    fn sort_where_predicates(&self, predicates: &mut Vec<WherePredicate>) {\n+    fn sort_where_predicates(&self, predicates: &mut [WherePredicate]) {\n         // We should never have identical bounds - and if we do,\n         // they're visually identical as well. Therefore, using\n         // an unstable sort is fine.\n@@ -710,7 +711,7 @@ where\n     /// approach is probably somewhat slower, but the small number of items\n     /// involved (impls rarely have more than a few bounds) means that it\n     /// shouldn't matter in practice.\n-    fn unstable_debug_sort<T: Debug>(&self, vec: &mut Vec<T>) {\n+    fn unstable_debug_sort<T: Debug>(&self, vec: &mut [T]) {\n         vec.sort_by_cached_key(|x| format!(\"{:?}\", x))\n     }\n "}, {"sha": "d80637055829d80df93fd24be8dbeefc7725b090", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -20,7 +20,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n         trace!(\"get_blanket_impls({:?})\", ty);\n         let mut impls = Vec::new();\n         for trait_def_id in cx.tcx.all_traits() {\n-            if !cx.cache.effective_visibilities.is_directly_public(trait_def_id)\n+            if !cx.cache.effective_visibilities.is_directly_public(cx.tcx, trait_def_id)\n                 || cx.generated_synthetics.get(&(ty.0, trait_def_id)).is_some()\n             {\n                 continue;\n@@ -97,7 +97,6 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                 impls.push(Item {\n                     name: None,\n                     attrs: Default::default(),\n-                    visibility: Inherited,\n                     item_id: ItemId::Blanket { impl_id: impl_def_id, for_: item_def_id },\n                     kind: Box::new(ImplItem(Box::new(Impl {\n                         unsafety: hir::Unsafety::Normal,\n@@ -128,6 +127,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                         ))),\n                     }))),\n                     cfg: None,\n+                    inline_stmt_id: None,\n                 });\n             }\n         }"}, {"sha": "841c4f9d530051526ab9a2a885f08b27cf19d38e", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -19,8 +19,7 @@ use rustc_span::symbol::{kw, sym, Symbol};\n use crate::clean::{\n     self, clean_fn_decl_from_did_and_sig, clean_generics, clean_impl_item, clean_middle_assoc_item,\n     clean_middle_field, clean_middle_ty, clean_trait_ref_with_bindings, clean_ty,\n-    clean_ty_generics, clean_variant_def, clean_visibility, utils, Attributes, AttributesExt,\n-    ImplKind, ItemId, Type, Visibility,\n+    clean_ty_generics, clean_variant_def, utils, Attributes, AttributesExt, ImplKind, ItemId, Type,\n };\n use crate::core::DocContext;\n use crate::formats::item_type::ItemType;\n@@ -152,18 +151,10 @@ pub(crate) fn try_inline(\n \n     let (attrs, cfg) = merge_attrs(cx, Some(parent_module), load_attrs(cx, did), attrs);\n     cx.inlined.insert(did.into());\n-    let mut item = clean::Item::from_def_id_and_attrs_and_parts(\n-        did,\n-        Some(name),\n-        kind,\n-        Box::new(attrs),\n-        cx,\n-        cfg,\n-    );\n-    if let Some(import_def_id) = import_def_id {\n-        // The visibility needs to reflect the one from the reexport and not from the \"source\" DefId.\n-        item.visibility = clean_visibility(cx.tcx.visibility(import_def_id));\n-    }\n+    let mut item =\n+        clean::Item::from_def_id_and_attrs_and_parts(did, Some(name), kind, Box::new(attrs), cfg);\n+    // The visibility needs to reflect the one from the reexport and not from the \"source\" DefId.\n+    item.inline_stmt_id = import_def_id;\n     ret.push(item);\n     Some(ret)\n }\n@@ -239,13 +230,7 @@ pub(crate) fn build_external_trait(cx: &mut DocContext<'_>, did: DefId) -> clean\n         .tcx\n         .associated_items(did)\n         .in_definition_order()\n-        .map(|item| {\n-            // When building an external trait, the cleaned trait will have all items public,\n-            // which causes methods to have a `pub` prefix, which is invalid since items in traits\n-            // can not have a visibility prefix. Thus we override the visibility here manually.\n-            // See https://github.com/rust-lang/rust/issues/81274\n-            clean::Item { visibility: Visibility::Inherited, ..clean_middle_assoc_item(item, cx) }\n-        })\n+        .map(|item| clean_middle_assoc_item(item, cx))\n         .collect();\n \n     let predicates = cx.tcx.predicates_of(did);\n@@ -323,6 +308,21 @@ pub(crate) fn build_impls(\n     for &did in tcx.inherent_impls(did).iter() {\n         build_impl(cx, parent_module, did, attrs, ret);\n     }\n+\n+    // This pretty much exists expressly for `dyn Error` traits that exist in the `alloc` crate.\n+    // See also:\n+    //\n+    // * https://github.com/rust-lang/rust/issues/103170 \u2014 where it didn't used to get documented\n+    // * https://github.com/rust-lang/rust/pull/99917 \u2014 where the feature got used\n+    // * https://github.com/rust-lang/rust/issues/53487 \u2014 overall tracking issue for Error\n+    if tcx.has_attr(did, sym::rustc_has_incoherent_inherent_impls) {\n+        use rustc_middle::ty::fast_reject::SimplifiedTypeGen::*;\n+        let type_ =\n+            if tcx.is_trait(did) { TraitSimplifiedType(did) } else { AdtSimplifiedType(did) };\n+        for &did in tcx.incoherent_impls(type_) {\n+            build_impl(cx, parent_module, did, attrs, ret);\n+        }\n+    }\n }\n \n /// `parent_module` refers to the parent of the re-export, not the original item\n@@ -374,7 +374,7 @@ pub(crate) fn build_impl(\n     if !did.is_local() {\n         if let Some(traitref) = associated_trait {\n             let did = traitref.def_id;\n-            if !cx.cache.effective_visibilities.is_directly_public(did) {\n+            if !cx.cache.effective_visibilities.is_directly_public(tcx, did) {\n                 return;\n             }\n \n@@ -403,7 +403,7 @@ pub(crate) fn build_impl(\n     // reachable in rustdoc generated documentation\n     if !did.is_local() {\n         if let Some(did) = for_.def_id(&cx.cache) {\n-            if !cx.cache.effective_visibilities.is_directly_public(did) {\n+            if !cx.cache.effective_visibilities.is_directly_public(tcx, did) {\n                 return;\n             }\n \n@@ -544,7 +544,6 @@ pub(crate) fn build_impl(\n             },\n         })),\n         Box::new(merged_attrs),\n-        cx,\n         cfg,\n     ));\n }\n@@ -592,7 +591,6 @@ fn build_module_items(\n                     name: None,\n                     attrs: Box::new(clean::Attributes::default()),\n                     item_id: ItemId::Primitive(prim_ty, did.krate),\n-                    visibility: clean::Public,\n                     kind: Box::new(clean::ImportItem(clean::Import::new_simple(\n                         item.ident.name,\n                         clean::ImportSource {\n@@ -611,6 +609,7 @@ fn build_module_items(\n                         true,\n                     ))),\n                     cfg: None,\n+                    inline_stmt_id: None,\n                 });\n             } else if let Some(i) = try_inline(cx, did, None, res, item.ident.name, None, visited) {\n                 items.extend(i)\n@@ -654,7 +653,7 @@ fn build_macro(\n     match CStore::from_tcx(cx.tcx).load_macro_untracked(def_id, cx.sess()) {\n         LoadedMacro::MacroDef(item_def, _) => {\n             if let ast::ItemKind::MacroDef(ref def) = item_def.kind {\n-                let vis = clean_visibility(cx.tcx.visibility(import_def_id.unwrap_or(def_id)));\n+                let vis = cx.tcx.visibility(import_def_id.unwrap_or(def_id));\n                 clean::MacroItem(clean::Macro {\n                     source: utils::display_macro_source(cx, name, def, def_id, vis),\n                 })"}, {"sha": "16e2d9a3cfc3809363312223b769f794c4ec8b27", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 100, "deletions": 136, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -74,20 +74,20 @@ pub(crate) fn clean_doc_module<'tcx>(doc: &DocModule<'tcx>, cx: &mut DocContext<\n     // This covers the case where somebody does an import which should pull in an item,\n     // but there's already an item with the same namespace and same name. Rust gives\n     // priority to the not-imported one, so we should, too.\n-    items.extend(doc.items.iter().flat_map(|(item, renamed)| {\n+    items.extend(doc.items.iter().flat_map(|(item, renamed, import_id)| {\n         // First, lower everything other than imports.\n         if matches!(item.kind, hir::ItemKind::Use(_, hir::UseKind::Glob)) {\n             return Vec::new();\n         }\n-        let v = clean_maybe_renamed_item(cx, item, *renamed);\n+        let v = clean_maybe_renamed_item(cx, item, *renamed, *import_id);\n         for item in &v {\n             if let Some(name) = item.name && !item.attrs.lists(sym::doc).has_word(sym::hidden) {\n                 inserted.insert((item.type_(), name));\n             }\n         }\n         v\n     }));\n-    items.extend(doc.items.iter().flat_map(|(item, renamed)| {\n+    items.extend(doc.items.iter().flat_map(|(item, renamed, _)| {\n         // Now we actually lower the imports, skipping everything else.\n         if let hir::ItemKind::Use(path, hir::UseKind::Glob) = item.kind {\n             let name = renamed.unwrap_or_else(|| cx.tcx.hir().name(item.hir_id()));\n@@ -601,7 +601,7 @@ pub(crate) fn clean_generics<'tcx>(\n         })\n         .collect::<Vec<_>>();\n \n-    let mut params = Vec::with_capacity(gens.params.len());\n+    let mut params = ThinVec::with_capacity(gens.params.len());\n     for p in gens.params.iter().filter(|p| !is_impl_trait(p) && !is_elided_lifetime(p)) {\n         let p = clean_generic_param(cx, Some(gens), p);\n         params.push(p);\n@@ -675,7 +675,7 @@ fn clean_ty_generics<'tcx>(\n             }\n             ty::GenericParamDefKind::Const { .. } => Some(clean_generic_param_def(param, cx)),\n         })\n-        .collect::<Vec<GenericParamDef>>();\n+        .collect::<ThinVec<GenericParamDef>>();\n \n     // param index -> [(trait DefId, associated type name & generics, type, higher-ranked params)]\n     let mut impl_trait_proj =\n@@ -880,7 +880,7 @@ fn clean_fn_or_proc_macro<'tcx>(\n             ProcMacroItem(ProcMacro { kind, helpers })\n         }\n         None => {\n-            let mut func = clean_function(cx, sig, generics, body_id);\n+            let mut func = clean_function(cx, sig, generics, FunctionArgs::Body(body_id));\n             clean_fn_decl_legacy_const_generics(&mut func, attrs);\n             FunctionItem(func)\n         }\n@@ -917,16 +917,28 @@ fn clean_fn_decl_legacy_const_generics(func: &mut Function, attrs: &[ast::Attrib\n     }\n }\n \n+enum FunctionArgs<'tcx> {\n+    Body(hir::BodyId),\n+    Names(&'tcx [Ident]),\n+}\n+\n fn clean_function<'tcx>(\n     cx: &mut DocContext<'tcx>,\n     sig: &hir::FnSig<'tcx>,\n     generics: &hir::Generics<'tcx>,\n-    body_id: hir::BodyId,\n+    args: FunctionArgs<'tcx>,\n ) -> Box<Function> {\n     let (generics, decl) = enter_impl_trait(cx, |cx| {\n         // NOTE: generics must be cleaned before args\n         let generics = clean_generics(generics, cx);\n-        let args = clean_args_from_types_and_body_id(cx, sig.decl.inputs, body_id);\n+        let args = match args {\n+            FunctionArgs::Body(body_id) => {\n+                clean_args_from_types_and_body_id(cx, sig.decl.inputs, body_id)\n+            }\n+            FunctionArgs::Names(names) => {\n+                clean_args_from_types_and_names(cx, sig.decl.inputs, names)\n+            }\n+        };\n         let mut decl = clean_fn_decl_with_args(cx, sig.decl, args);\n         if sig.header.is_async() {\n             decl.output = decl.sugared_async_return_type();\n@@ -1051,18 +1063,12 @@ fn clean_trait_item<'tcx>(trait_item: &hir::TraitItem<'tcx>, cx: &mut DocContext\n             ),\n             hir::TraitItemKind::Const(ty, None) => TyAssocConstItem(clean_ty(ty, cx)),\n             hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n-                let m = clean_function(cx, sig, trait_item.generics, body);\n+                let m = clean_function(cx, sig, trait_item.generics, FunctionArgs::Body(body));\n                 MethodItem(m, None)\n             }\n             hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Required(names)) => {\n-                let (generics, decl) = enter_impl_trait(cx, |cx| {\n-                    // NOTE: generics must be cleaned before args\n-                    let generics = clean_generics(trait_item.generics, cx);\n-                    let args = clean_args_from_types_and_names(cx, sig.decl.inputs, names);\n-                    let decl = clean_fn_decl_with_args(cx, sig.decl, args);\n-                    (generics, decl)\n-                });\n-                TyMethodItem(Box::new(Function { decl, generics }))\n+                let m = clean_function(cx, sig, trait_item.generics, FunctionArgs::Names(names));\n+                TyMethodItem(m)\n             }\n             hir::TraitItemKind::Type(bounds, Some(default)) => {\n                 let generics = enter_impl_trait(cx, |cx| clean_generics(trait_item.generics, cx));\n@@ -1080,13 +1086,10 @@ fn clean_trait_item<'tcx>(trait_item: &hir::TraitItem<'tcx>, cx: &mut DocContext\n             hir::TraitItemKind::Type(bounds, None) => {\n                 let generics = enter_impl_trait(cx, |cx| clean_generics(trait_item.generics, cx));\n                 let bounds = bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect();\n-                TyAssocTypeItem(Box::new(generics), bounds)\n+                TyAssocTypeItem(generics, bounds)\n             }\n         };\n-        let what_rustc_thinks =\n-            Item::from_def_id_and_parts(local_did, Some(trait_item.ident.name), inner, cx);\n-        // Trait items always inherit the trait's visibility -- we don't want to show `pub`.\n-        Item { visibility: Inherited, ..what_rustc_thinks }\n+        Item::from_def_id_and_parts(local_did, Some(trait_item.ident.name), inner, cx)\n     })\n }\n \n@@ -1102,7 +1105,7 @@ pub(crate) fn clean_impl_item<'tcx>(\n                 AssocConstItem(clean_ty(ty, cx), default)\n             }\n             hir::ImplItemKind::Fn(ref sig, body) => {\n-                let m = clean_function(cx, sig, impl_.generics, body);\n+                let m = clean_function(cx, sig, impl_.generics, FunctionArgs::Body(body));\n                 let defaultness = cx.tcx.impl_defaultness(impl_.owner_id);\n                 MethodItem(m, Some(defaultness))\n             }\n@@ -1117,18 +1120,7 @@ pub(crate) fn clean_impl_item<'tcx>(\n             }\n         };\n \n-        let mut what_rustc_thinks =\n-            Item::from_def_id_and_parts(local_did, Some(impl_.ident.name), inner, cx);\n-\n-        let impl_ref = cx.tcx.impl_trait_ref(cx.tcx.local_parent(impl_.owner_id.def_id));\n-\n-        // Trait impl items always inherit the impl's visibility --\n-        // we don't want to show `pub`.\n-        if impl_ref.is_some() {\n-            what_rustc_thinks.visibility = Inherited;\n-        }\n-\n-        what_rustc_thinks\n+        Item::from_def_id_and_parts(local_did, Some(impl_.ident.name), inner, cx)\n     })\n }\n \n@@ -1225,56 +1217,47 @@ pub(crate) fn clean_middle_assoc_item<'tcx>(\n                     tcx.generics_of(assoc_item.def_id),\n                     ty::GenericPredicates { parent: None, predicates },\n                 );\n-                // Move bounds that are (likely) directly attached to the associated type\n-                // from the where clause to the associated type.\n-                // There is no guarantee that this is what the user actually wrote but we have\n-                // no way of knowing.\n-                let mut bounds = generics\n-                    .where_predicates\n-                    .drain_filter(|pred| match *pred {\n-                        WherePredicate::BoundPredicate {\n-                            ty: QPath(box QPathData { ref assoc, ref self_type, ref trait_, .. }),\n-                            ..\n-                        } => {\n-                            if assoc.name != my_name {\n-                                return false;\n-                            }\n-                            if trait_.def_id() != assoc_item.container_id(tcx) {\n-                                return false;\n-                            }\n-                            match *self_type {\n-                                Generic(ref s) if *s == kw::SelfUpper => {}\n-                                _ => return false,\n-                            }\n-                            match &assoc.args {\n-                                GenericArgs::AngleBracketed { args, bindings } => {\n-                                    if !bindings.is_empty()\n-                                        || generics\n-                                            .params\n-                                            .iter()\n-                                            .zip(args.iter())\n-                                            .any(|(param, arg)| !param_eq_arg(param, arg))\n-                                    {\n-                                        return false;\n-                                    }\n-                                }\n-                                GenericArgs::Parenthesized { .. } => {\n-                                    // The only time this happens is if we're inside the rustdoc for Fn(),\n-                                    // which only has one associated type, which is not a GAT, so whatever.\n+                // Filter out the bounds that are (likely?) directly attached to the associated type,\n+                // as opposed to being located in the where clause.\n+                let mut bounds: Vec<GenericBound> = Vec::new();\n+                generics.where_predicates.retain_mut(|pred| match *pred {\n+                    WherePredicate::BoundPredicate {\n+                        ty: QPath(box QPathData { ref assoc, ref self_type, ref trait_, .. }),\n+                        bounds: ref mut pred_bounds,\n+                        ..\n+                    } => {\n+                        if assoc.name != my_name {\n+                            return true;\n+                        }\n+                        if trait_.def_id() != assoc_item.container_id(tcx) {\n+                            return true;\n+                        }\n+                        match *self_type {\n+                            Generic(ref s) if *s == kw::SelfUpper => {}\n+                            _ => return true,\n+                        }\n+                        match &assoc.args {\n+                            GenericArgs::AngleBracketed { args, bindings } => {\n+                                if !bindings.is_empty()\n+                                    || generics\n+                                        .params\n+                                        .iter()\n+                                        .zip(args.iter())\n+                                        .any(|(param, arg)| !param_eq_arg(param, arg))\n+                                {\n+                                    return true;\n                                 }\n                             }\n-                            true\n-                        }\n-                        _ => false,\n-                    })\n-                    .flat_map(|pred| {\n-                        if let WherePredicate::BoundPredicate { bounds, .. } = pred {\n-                            bounds\n-                        } else {\n-                            unreachable!()\n+                            GenericArgs::Parenthesized { .. } => {\n+                                // The only time this happens is if we're inside the rustdoc for Fn(),\n+                                // which only has one associated type, which is not a GAT, so whatever.\n+                            }\n                         }\n-                    })\n-                    .collect::<Vec<_>>();\n+                        bounds.extend(mem::replace(pred_bounds, Vec::new()));\n+                        false\n+                    }\n+                    _ => true,\n+                });\n                 // Our Sized/?Sized bound didn't get handled when creating the generics\n                 // because we didn't actually get our whole set of bounds until just now\n                 // (some of them may have come from the trait). If we do have a sized\n@@ -1290,7 +1273,7 @@ pub(crate) fn clean_middle_assoc_item<'tcx>(\n                 // (generic) associated type from the where clause to the respective parameter.\n                 // There is no guarantee that this is what the user actually wrote but we have\n                 // no way of knowing.\n-                let mut where_predicates = Vec::new();\n+                let mut where_predicates = ThinVec::new();\n                 for mut pred in generics.where_predicates {\n                     if let WherePredicate::BoundPredicate { ty: Generic(arg), bounds, .. } = &mut pred\n                     && let Some(GenericParamDef {\n@@ -1320,7 +1303,7 @@ pub(crate) fn clean_middle_assoc_item<'tcx>(\n                         bounds,\n                     )\n                 } else {\n-                    TyAssocTypeItem(Box::new(generics), bounds)\n+                    TyAssocTypeItem(generics, bounds)\n                 }\n             } else {\n                 // FIXME: when could this happen? Associated items in inherent impls?\n@@ -1331,7 +1314,10 @@ pub(crate) fn clean_middle_assoc_item<'tcx>(\n                             cx,\n                             Some(assoc_item.def_id),\n                         ),\n-                        generics: Generics { params: Vec::new(), where_predicates: Vec::new() },\n+                        generics: Generics {\n+                            params: ThinVec::new(),\n+                            where_predicates: ThinVec::new(),\n+                        },\n                         item_type: None,\n                     }),\n                     Vec::new(),\n@@ -1340,18 +1326,7 @@ pub(crate) fn clean_middle_assoc_item<'tcx>(\n         }\n     };\n \n-    let mut what_rustc_thinks =\n-        Item::from_def_id_and_parts(assoc_item.def_id, Some(assoc_item.name), kind, cx);\n-\n-    let impl_ref = tcx.impl_trait_ref(tcx.parent(assoc_item.def_id));\n-\n-    // Trait impl items always inherit the impl's visibility --\n-    // we don't want to show `pub`.\n-    if impl_ref.is_some() {\n-        what_rustc_thinks.visibility = Visibility::Inherited;\n-    }\n-\n-    what_rustc_thinks\n+    Item::from_def_id_and_parts(assoc_item.def_id, Some(assoc_item.name), kind, cx)\n }\n \n fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type {\n@@ -1406,7 +1381,8 @@ fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type\n                 ty::Projection(proj) => Res::Def(DefKind::Trait, proj.trait_ref(cx.tcx).def_id),\n                 // Rustdoc handles `ty::Error`s by turning them into `Type::Infer`s.\n                 ty::Error(_) => return Type::Infer,\n-                _ => bug!(\"clean: expected associated type, found `{:?}`\", ty),\n+                // Otherwise, this is an inherent associated type.\n+                _ => return clean_middle_ty(ty, cx, None),\n             };\n             let trait_ = clean_path(&hir::Path { span, res, segments: &[] }, cx);\n             register_res(cx, trait_.res);\n@@ -1431,7 +1407,7 @@ fn maybe_expand_private_type_alias<'tcx>(\n     let Res::Def(DefKind::TyAlias, def_id) = path.res else { return None };\n     // Substitute private type aliases\n     let def_id = def_id.as_local()?;\n-    let alias = if !cx.cache.effective_visibilities.is_exported(def_id.to_def_id()) {\n+    let alias = if !cx.cache.effective_visibilities.is_exported(cx.tcx, def_id.to_def_id()) {\n         &cx.tcx.hir().expect_item(def_id).kind\n     } else {\n         return None;\n@@ -1821,30 +1797,7 @@ pub(crate) fn clean_field_with_def_id(\n     ty: Type,\n     cx: &mut DocContext<'_>,\n ) -> Item {\n-    let what_rustc_thinks =\n-        Item::from_def_id_and_parts(def_id, Some(name), StructFieldItem(ty), cx);\n-    if is_field_vis_inherited(cx.tcx, def_id) {\n-        // Variant fields inherit their enum's visibility.\n-        Item { visibility: Visibility::Inherited, ..what_rustc_thinks }\n-    } else {\n-        what_rustc_thinks\n-    }\n-}\n-\n-fn is_field_vis_inherited(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    let parent = tcx.parent(def_id);\n-    match tcx.def_kind(parent) {\n-        DefKind::Struct | DefKind::Union => false,\n-        DefKind::Variant => true,\n-        parent_kind => panic!(\"unexpected parent kind: {:?}\", parent_kind),\n-    }\n-}\n-\n-pub(crate) fn clean_visibility(vis: ty::Visibility<DefId>) -> Visibility {\n-    match vis {\n-        ty::Visibility::Public => Visibility::Public,\n-        ty::Visibility::Restricted(module) => Visibility::Restricted(module),\n-    }\n+    Item::from_def_id_and_parts(def_id, Some(name), StructFieldItem(ty), cx)\n }\n \n pub(crate) fn clean_variant_def<'tcx>(variant: &ty::VariantDef, cx: &mut DocContext<'tcx>) -> Item {\n@@ -1861,10 +1814,7 @@ pub(crate) fn clean_variant_def<'tcx>(variant: &ty::VariantDef, cx: &mut DocCont\n             fields: variant.fields.iter().map(|field| clean_middle_field(field, cx)).collect(),\n         }),\n     };\n-    let what_rustc_thinks =\n-        Item::from_def_id_and_parts(variant.def_id, Some(variant.name), VariantItem(kind), cx);\n-    // don't show `pub` for variants, which always inherit visibility\n-    Item { visibility: Inherited, ..what_rustc_thinks }\n+    Item::from_def_id_and_parts(variant.def_id, Some(variant.name), VariantItem(kind), cx)\n }\n \n fn clean_variant_data<'tcx>(\n@@ -1955,6 +1905,7 @@ fn clean_maybe_renamed_item<'tcx>(\n     cx: &mut DocContext<'tcx>,\n     item: &hir::Item<'tcx>,\n     renamed: Option<Symbol>,\n+    import_id: Option<hir::HirId>,\n ) -> Vec<Item> {\n     use hir::ItemKind;\n \n@@ -2005,7 +1956,7 @@ fn clean_maybe_renamed_item<'tcx>(\n                 clean_fn_or_proc_macro(item, sig, generics, body_id, &mut name, cx)\n             }\n             ItemKind::Macro(ref macro_def, _) => {\n-                let ty_vis = clean_visibility(cx.tcx.visibility(def_id));\n+                let ty_vis = cx.tcx.visibility(def_id);\n                 MacroItem(Macro {\n                     source: display_macro_source(cx, name, macro_def, def_id, ty_vis),\n                 })\n@@ -2031,17 +1982,29 @@ fn clean_maybe_renamed_item<'tcx>(\n             }\n             _ => unreachable!(\"not yet converted\"),\n         };\n-\n-        vec![Item::from_def_id_and_parts(def_id, Some(name), kind, cx)]\n+        if let Some(import_id) = import_id {\n+            let (attrs, cfg) = inline::merge_attrs(\n+                cx,\n+                Some(cx.tcx.parent_module(import_id).to_def_id()),\n+                inline::load_attrs(cx, def_id),\n+                Some(inline::load_attrs(cx, cx.tcx.hir().local_def_id(import_id).to_def_id())),\n+            );\n+            vec![Item::from_def_id_and_attrs_and_parts(\n+                def_id,\n+                Some(name),\n+                kind,\n+                Box::new(attrs),\n+                cfg,\n+            )]\n+        } else {\n+            vec![Item::from_def_id_and_parts(def_id, Some(name), kind, cx)]\n+        }\n     })\n }\n \n fn clean_variant<'tcx>(variant: &hir::Variant<'tcx>, cx: &mut DocContext<'tcx>) -> Item {\n     let kind = VariantItem(clean_variant_data(&variant.data, &variant.disr_expr, cx));\n-    let what_rustc_thinks =\n-        Item::from_hir_id_and_parts(variant.id, Some(variant.ident.name), kind, cx);\n-    // don't show `pub` for variants, which are always public\n-    Item { visibility: Inherited, ..what_rustc_thinks }\n+    Item::from_hir_id_and_parts(variant.id, Some(variant.ident.name), kind, cx)\n }\n \n fn clean_impl<'tcx>(\n@@ -2114,6 +2077,7 @@ fn clean_extern_crate<'tcx>(\n                 }\n         });\n \n+    let krate_owner_def_id = krate.owner_id.to_def_id();\n     if please_inline {\n         let mut visited = FxHashSet::default();\n \n@@ -2122,7 +2086,7 @@ fn clean_extern_crate<'tcx>(\n         if let Some(items) = inline::try_inline(\n             cx,\n             cx.tcx.parent_module(krate.hir_id()).to_def_id(),\n-            Some(krate.owner_id.to_def_id()),\n+            Some(krate_owner_def_id),\n             res,\n             name,\n             Some(attrs),\n@@ -2137,9 +2101,9 @@ fn clean_extern_crate<'tcx>(\n         name: Some(name),\n         attrs: Box::new(Attributes::from_ast(attrs)),\n         item_id: crate_def_id.into(),\n-        visibility: clean_visibility(ty_vis),\n         kind: Box::new(ExternCrateItem { src: orig_name }),\n         cfg: attrs.cfg(cx.tcx, &cx.cache.hidden_cfg),\n+        inline_stmt_id: Some(krate_owner_def_id),\n     }]\n }\n "}, {"sha": "1c184f9b2695cd1fcdac94459ab5f706c0eac58a", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -14,13 +14,14 @@\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty;\n+use thin_vec::ThinVec;\n \n use crate::clean;\n use crate::clean::GenericArgs as PP;\n use crate::clean::WherePredicate as WP;\n use crate::core::DocContext;\n \n-pub(crate) fn where_clauses(cx: &DocContext<'_>, clauses: Vec<WP>) -> Vec<WP> {\n+pub(crate) fn where_clauses(cx: &DocContext<'_>, clauses: Vec<WP>) -> ThinVec<WP> {\n     // First, partition the where clause into its separate components.\n     //\n     // We use `FxIndexMap` so that the insertion order is preserved to prevent messing up to\n@@ -59,7 +60,7 @@ pub(crate) fn where_clauses(cx: &DocContext<'_>, clauses: Vec<WP>) -> Vec<WP> {\n     });\n \n     // And finally, let's reassemble everything\n-    let mut clauses = Vec::new();\n+    let mut clauses = ThinVec::with_capacity(lifetimes.len() + tybounds.len() + equalities.len());\n     clauses.extend(\n         lifetimes.into_iter().map(|(lt, bounds)| WP::RegionPredicate { lifetime: lt, bounds }),\n     );"}, {"sha": "fea3690e50a2149b79f49186b174b02bbc027455", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 73, "deletions": 45, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -24,7 +24,7 @@ use rustc_hir::{BodyId, Mutability};\n use rustc_hir_analysis::check::intrinsic::intrinsic_operation_unsafety;\n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::fast_reject::SimplifiedType;\n-use rustc_middle::ty::{self, TyCtxt};\n+use rustc_middle::ty::{self, DefIdTree, TyCtxt, Visibility};\n use rustc_session::Session;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::DUMMY_SP;\n@@ -34,7 +34,6 @@ use rustc_target::abi::VariantIdx;\n use rustc_target::spec::abi::Abi;\n \n use crate::clean::cfg::Cfg;\n-use crate::clean::clean_visibility;\n use crate::clean::external_path;\n use crate::clean::inline::{self, print_inlined_const};\n use crate::clean::utils::{is_literal_expr, print_const_expr, print_evaluated_const};\n@@ -51,7 +50,6 @@ pub(crate) use self::Type::{\n     Array, BareFunction, BorrowedRef, DynTrait, Generic, ImplTrait, Infer, Primitive, QPath,\n     RawPointer, Slice, Tuple,\n };\n-pub(crate) use self::Visibility::{Inherited, Public};\n \n #[cfg(test)]\n mod tests;\n@@ -348,12 +346,12 @@ pub(crate) struct Item {\n     /// Optional because not every item has a name, e.g. impls.\n     pub(crate) name: Option<Symbol>,\n     pub(crate) attrs: Box<Attributes>,\n-    pub(crate) visibility: Visibility,\n     /// Information about this item that is specific to what kind of item it is.\n     /// E.g., struct vs enum vs function.\n     pub(crate) kind: Box<ItemKind>,\n     pub(crate) item_id: ItemId,\n-\n+    /// This is the `DefId` of the `use` statement if the item was inlined.\n+    pub(crate) inline_stmt_id: Option<DefId>,\n     pub(crate) cfg: Option<Arc<Cfg>>,\n }\n \n@@ -364,9 +362,7 @@ impl fmt::Debug for Item {\n         let alternate = f.alternate();\n         // hand-picked fields that don't bloat the logs too much\n         let mut fmt = f.debug_struct(\"Item\");\n-        fmt.field(\"name\", &self.name)\n-            .field(\"visibility\", &self.visibility)\n-            .field(\"item_id\", &self.item_id);\n+        fmt.field(\"name\", &self.name).field(\"item_id\", &self.item_id);\n         // allow printing the full item if someone really wants to\n         if alternate {\n             fmt.field(\"attrs\", &self.attrs).field(\"kind\", &self.kind).field(\"cfg\", &self.cfg);\n@@ -388,6 +384,15 @@ pub(crate) fn rustc_span(def_id: DefId, tcx: TyCtxt<'_>) -> Span {\n     ))\n }\n \n+fn is_field_vis_inherited(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+    let parent = tcx.parent(def_id);\n+    match tcx.def_kind(parent) {\n+        DefKind::Struct | DefKind::Union => false,\n+        DefKind::Variant => true,\n+        parent_kind => panic!(\"unexpected parent kind: {:?}\", parent_kind),\n+    }\n+}\n+\n impl Item {\n     pub(crate) fn stability<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Option<Stability> {\n         self.item_id.as_def_id().and_then(|did| tcx.lookup_stability(did))\n@@ -462,7 +467,6 @@ impl Item {\n             name,\n             kind,\n             Box::new(Attributes::from_ast(ast_attrs)),\n-            cx,\n             ast_attrs.cfg(cx.tcx, &cx.cache.hidden_cfg),\n         )\n     }\n@@ -472,21 +476,18 @@ impl Item {\n         name: Option<Symbol>,\n         kind: ItemKind,\n         attrs: Box<Attributes>,\n-        cx: &mut DocContext<'_>,\n         cfg: Option<Arc<Cfg>>,\n     ) -> Item {\n         trace!(\"name={:?}, def_id={:?} cfg={:?}\", name, def_id, cfg);\n \n-        // Primitives and Keywords are written in the source code as private modules.\n-        // The modules need to be private so that nobody actually uses them, but the\n-        // keywords and primitives that they are documenting are public.\n-        let visibility = if matches!(&kind, ItemKind::KeywordItem | ItemKind::PrimitiveItem(..)) {\n-            Visibility::Public\n-        } else {\n-            clean_visibility(cx.tcx.visibility(def_id))\n-        };\n-\n-        Item { item_id: def_id.into(), kind: Box::new(kind), name, attrs, visibility, cfg }\n+        Item {\n+            item_id: def_id.into(),\n+            kind: Box::new(kind),\n+            name,\n+            attrs,\n+            cfg,\n+            inline_stmt_id: None,\n+        }\n     }\n \n     /// Finds all `doc` attributes as NameValues and returns their corresponding values, joined\n@@ -691,17 +692,61 @@ impl Item {\n                     asyncness: hir::IsAsync::NotAsync,\n                 }\n             }\n-            ItemKind::FunctionItem(_) | ItemKind::MethodItem(_, _) => {\n+            ItemKind::FunctionItem(_) | ItemKind::MethodItem(_, _) | ItemKind::TyMethodItem(_) => {\n                 let def_id = self.item_id.as_def_id().unwrap();\n                 build_fn_header(def_id, tcx, tcx.asyncness(def_id))\n             }\n-            ItemKind::TyMethodItem(_) => {\n-                build_fn_header(self.item_id.as_def_id().unwrap(), tcx, hir::IsAsync::NotAsync)\n-            }\n             _ => return None,\n         };\n         Some(header)\n     }\n+\n+    /// Returns the visibility of the current item. If the visibility is \"inherited\", then `None`\n+    /// is returned.\n+    pub(crate) fn visibility(&self, tcx: TyCtxt<'_>) -> Option<Visibility<DefId>> {\n+        let def_id = match self.item_id {\n+            // Anything but DefId *shouldn't* matter, but return a reasonable value anyway.\n+            ItemId::Auto { .. } | ItemId::Blanket { .. } => return None,\n+            // Primitives and Keywords are written in the source code as private modules.\n+            // The modules need to be private so that nobody actually uses them, but the\n+            // keywords and primitives that they are documenting are public.\n+            ItemId::Primitive(..) => return Some(Visibility::Public),\n+            ItemId::DefId(def_id) => def_id,\n+        };\n+\n+        match *self.kind {\n+            // Explication on `ItemId::Primitive` just above.\n+            ItemKind::KeywordItem | ItemKind::PrimitiveItem(_) => return Some(Visibility::Public),\n+            // Variant fields inherit their enum's visibility.\n+            StructFieldItem(..) if is_field_vis_inherited(tcx, def_id) => {\n+                return None;\n+            }\n+            // Variants always inherit visibility\n+            VariantItem(..) => return None,\n+            // Trait items inherit the trait's visibility\n+            AssocConstItem(..) | TyAssocConstItem(..) | AssocTypeItem(..) | TyAssocTypeItem(..)\n+            | TyMethodItem(..) | MethodItem(..) => {\n+                let assoc_item = tcx.associated_item(def_id);\n+                let is_trait_item = match assoc_item.container {\n+                    ty::TraitContainer => true,\n+                    ty::ImplContainer => {\n+                        // Trait impl items always inherit the impl's visibility --\n+                        // we don't want to show `pub`.\n+                        tcx.impl_trait_ref(tcx.parent(assoc_item.def_id)).is_some()\n+                    }\n+                };\n+                if is_trait_item {\n+                    return None;\n+                }\n+            }\n+            _ => {}\n+        }\n+        let def_id = match self.inline_stmt_id {\n+            Some(inlined) => inlined,\n+            None => def_id,\n+        };\n+        Some(tcx.visibility(def_id))\n+    }\n }\n \n #[derive(Clone, Debug)]\n@@ -747,7 +792,7 @@ pub(crate) enum ItemKind {\n     /// A required associated type in a trait declaration.\n     ///\n     /// The bounds may be non-empty if there is a `where` clause.\n-    TyAssocTypeItem(Box<Generics>, Vec<GenericBound>),\n+    TyAssocTypeItem(Generics, Vec<GenericBound>),\n     /// An associated type in a trait impl or a provided one in a trait declaration.\n     AssocTypeItem(Box<Typedef>, Vec<GenericBound>),\n     /// An item that has been stripped by a rustdoc pass\n@@ -1414,8 +1459,8 @@ impl GenericParamDef {\n // maybe use a Generic enum and use Vec<Generic>?\n #[derive(Clone, Debug, Default)]\n pub(crate) struct Generics {\n-    pub(crate) params: Vec<GenericParamDef>,\n-    pub(crate) where_predicates: Vec<WherePredicate>,\n+    pub(crate) params: ThinVec<GenericParamDef>,\n+    pub(crate) where_predicates: ThinVec<WherePredicate>,\n }\n \n impl Generics {\n@@ -2030,24 +2075,6 @@ impl From<hir::PrimTy> for PrimitiveType {\n     }\n }\n \n-#[derive(Copy, Clone, Debug)]\n-pub(crate) enum Visibility {\n-    /// `pub`\n-    Public,\n-    /// Visibility inherited from parent.\n-    ///\n-    /// For example, this is the visibility of private items and of enum variants.\n-    Inherited,\n-    /// `pub(crate)`, `pub(super)`, or `pub(in path::to::somewhere)`\n-    Restricted(DefId),\n-}\n-\n-impl Visibility {\n-    pub(crate) fn is_public(&self) -> bool {\n-        matches!(self, Visibility::Public)\n-    }\n-}\n-\n #[derive(Clone, Debug)]\n pub(crate) struct Struct {\n     pub(crate) struct_type: CtorKind,\n@@ -2546,6 +2573,7 @@ mod size_asserts {\n     static_assert_size!(GenericArg, 48);\n     static_assert_size!(GenericArgs, 32);\n     static_assert_size!(GenericParamDef, 56);\n+    static_assert_size!(Generics, 16);\n     static_assert_size!(Item, 56);\n     static_assert_size!(ItemKind, 88);\n     static_assert_size!(PathSegment, 40);"}, {"sha": "df20dc3fc3f7e995e2e42fbce662da3830859da5", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -4,11 +4,10 @@ use crate::clean::render_macro_matchers::render_macro_matcher;\n use crate::clean::{\n     clean_doc_module, clean_middle_const, clean_middle_region, clean_middle_ty, inline, Crate,\n     ExternalCrate, Generic, GenericArg, GenericArgs, ImportSource, Item, ItemKind, Lifetime, Path,\n-    PathSegment, Primitive, PrimitiveType, Type, TypeBinding, Visibility,\n+    PathSegment, Primitive, PrimitiveType, Type, TypeBinding,\n };\n use crate::core::DocContext;\n-use crate::formats::item_type::ItemType;\n-use crate::visit_lib::LibEmbargoVisitor;\n+use crate::html::format::visibility_to_src_with_space;\n \n use rustc_ast as ast;\n use rustc_ast::tokenstream::TokenTree;\n@@ -32,7 +31,7 @@ pub(crate) fn krate(cx: &mut DocContext<'_>) -> Crate {\n \n     for &cnum in cx.tcx.crates(()) {\n         // Analyze doc-reachability for extern items\n-        LibEmbargoVisitor::new(cx).visit_lib(cnum);\n+        crate::visit_lib::lib_embargo_visit_item(cx, cnum.as_def_id());\n     }\n \n     // Clean the crate, translating the entire librustc_ast AST to one that is\n@@ -504,9 +503,6 @@ pub(crate) fn register_res(cx: &mut DocContext<'_>, res: Res) -> DefId {\n         return did;\n     }\n     inline::record_extern_fqn(cx, did, kind);\n-    if let ItemType::Trait = kind {\n-        inline::record_extern_trait(cx, did);\n-    }\n     did\n }\n \n@@ -588,7 +584,7 @@ pub(super) fn display_macro_source(\n     name: Symbol,\n     def: &ast::MacroDef,\n     def_id: DefId,\n-    vis: Visibility,\n+    vis: ty::Visibility<DefId>,\n ) -> String {\n     let tts: Vec<_> = def.body.inner_tokens().into_trees().collect();\n     // Extract the spans of all matchers. They represent the \"interface\" of the macro.\n@@ -600,14 +596,14 @@ pub(super) fn display_macro_source(\n         if matchers.len() <= 1 {\n             format!(\n                 \"{}macro {}{} {{\\n    ...\\n}}\",\n-                vis.to_src_with_space(cx.tcx, def_id),\n+                visibility_to_src_with_space(Some(vis), cx.tcx, def_id),\n                 name,\n                 matchers.map(|matcher| render_macro_matcher(cx.tcx, matcher)).collect::<String>(),\n             )\n         } else {\n             format!(\n                 \"{}macro {} {{\\n{}}}\",\n-                vis.to_src_with_space(cx.tcx, def_id),\n+                visibility_to_src_with_space(Some(vis), cx.tcx, def_id),\n                 name,\n                 render_macro_arms(cx.tcx, matchers, \",\"),\n             )"}, {"sha": "893249e88cf7b658b7b4e0b6d020c45ae99d0817", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -166,6 +166,7 @@ pub(crate) fn new_handler(\n                     unstable_opts.teach,\n                     diagnostic_width,\n                     false,\n+                    unstable_opts.track_diagnostics,\n                 )\n                 .ui_testing(unstable_opts.ui_testing),\n             )\n@@ -184,6 +185,7 @@ pub(crate) fn new_handler(\n                     json_rendered,\n                     diagnostic_width,\n                     false,\n+                    unstable_opts.track_diagnostics,\n                 )\n                 .ui_testing(unstable_opts.ui_testing),\n             )\n@@ -348,7 +350,6 @@ pub(crate) fn run_global_ctxt(\n \n     let auto_traits =\n         tcx.all_traits().filter(|&trait_def_id| tcx.trait_is_auto(trait_def_id)).collect();\n-    let effective_visibilities = tcx.effective_visibilities(()).map_id(Into::into);\n \n     let mut ctxt = DocContext {\n         tcx,\n@@ -361,7 +362,7 @@ pub(crate) fn run_global_ctxt(\n         impl_trait_bounds: Default::default(),\n         generated_synthetics: Default::default(),\n         auto_traits,\n-        cache: Cache::new(effective_visibilities, render_options.document_private),\n+        cache: Cache::new(render_options.document_private),\n         inlined: FxHashSet::default(),\n         output_format,\n         render_options,"}, {"sha": "7cbe2f1e2273863b3176b34ea83e383cc0b83467", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -551,6 +551,7 @@ pub(crate) fn make_test(\n                 false,\n                 Some(80),\n                 false,\n+                false,\n             )\n             .supports_color();\n \n@@ -564,6 +565,7 @@ pub(crate) fn make_test(\n                 false,\n                 None,\n                 false,\n+                false,\n             );\n \n             // FIXME(misdreavus): pass `-Z treat-err-as-bug` to the doctest parser\n@@ -748,6 +750,7 @@ fn check_if_attr_is_complete(source: &str, edition: Edition) -> bool {\n                 false,\n                 None,\n                 false,\n+                false,\n             );\n \n             let handler = Handler::with_emitter(false, None, Box::new(emitter));"}, {"sha": "d027fb6e8763cad8fdc3d1ffd6a237111b5de891", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -2,7 +2,6 @@ use std::mem;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::{CrateNum, DefId};\n-use rustc_middle::middle::privacy::EffectiveVisibilities;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::Symbol;\n \n@@ -15,6 +14,7 @@ use crate::html::format::join_with_double_colon;\n use crate::html::markdown::short_markdown_summary;\n use crate::html::render::search_index::get_function_type_for_search;\n use crate::html::render::IndexItem;\n+use crate::visit_lib::RustdocEffectiveVisibilities;\n \n /// This cache is used to store information about the [`clean::Crate`] being\n /// rendered in order to provide more useful documentation. This contains\n@@ -78,7 +78,7 @@ pub(crate) struct Cache {\n     // Note that external items for which `doc(hidden)` applies to are shown as\n     // non-reachable while local items aren't. This is because we're reusing\n     // the effective visibilities from the privacy check pass.\n-    pub(crate) effective_visibilities: EffectiveVisibilities<DefId>,\n+    pub(crate) effective_visibilities: RustdocEffectiveVisibilities,\n \n     /// The version of the crate being documented, if given from the `--crate-version` flag.\n     pub(crate) crate_version: Option<String>,\n@@ -132,11 +132,8 @@ struct CacheBuilder<'a, 'tcx> {\n }\n \n impl Cache {\n-    pub(crate) fn new(\n-        effective_visibilities: EffectiveVisibilities<DefId>,\n-        document_private: bool,\n-    ) -> Self {\n-        Cache { effective_visibilities, document_private, ..Cache::default() }\n+    pub(crate) fn new(document_private: bool) -> Self {\n+        Cache { document_private, ..Cache::default() }\n     }\n \n     /// Populates the `Cache` with more data. The returned `Crate` will be missing some data that was\n@@ -319,21 +316,28 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                         let desc = item.doc_value().map_or_else(String::new, |x| {\n                             short_markdown_summary(x.as_str(), &item.link_names(self.cache))\n                         });\n-                        self.cache.search_index.push(IndexItem {\n-                            ty: item.type_(),\n-                            name: s.to_string(),\n-                            path: join_with_double_colon(path),\n-                            desc,\n-                            parent,\n-                            parent_idx: None,\n-                            search_type: get_function_type_for_search(\n-                                &item,\n-                                self.tcx,\n-                                clean_impl_generics(self.cache.parent_stack.last()).as_ref(),\n-                                self.cache,\n-                            ),\n-                            aliases: item.attrs.get_doc_aliases(),\n-                        });\n+                        let ty = item.type_();\n+                        let name = s.to_string();\n+                        if ty != ItemType::StructField || u16::from_str_radix(&name, 10).is_err() {\n+                            // In case this is a field from a tuple struct, we don't add it into\n+                            // the search index because its name is something like \"0\", which is\n+                            // not useful for rustdoc search.\n+                            self.cache.search_index.push(IndexItem {\n+                                ty,\n+                                name,\n+                                path: join_with_double_colon(path),\n+                                desc,\n+                                parent,\n+                                parent_idx: None,\n+                                search_type: get_function_type_for_search(\n+                                    &item,\n+                                    self.tcx,\n+                                    clean_impl_generics(self.cache.parent_stack.last()).as_ref(),\n+                                    self.cache,\n+                                ),\n+                                aliases: item.attrs.get_doc_aliases(),\n+                            });\n+                        }\n                     }\n                 }\n                 (Some(parent), None) if is_inherent_impl_item => {\n@@ -387,7 +391,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                         || self\n                             .cache\n                             .effective_visibilities\n-                            .is_directly_public(item.item_id.expect_def_id())\n+                            .is_directly_public(self.tcx, item.item_id.expect_def_id())\n                     {\n                         self.cache.paths.insert(\n                             item.item_id.expect_def_id(),"}, {"sha": "06db3fb0ec4000794de001220a0feceffb0b390b", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 75, "deletions": 78, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -659,7 +659,7 @@ pub(crate) fn href_with_root_path(\n     }\n \n     if !did.is_local()\n-        && !cache.effective_visibilities.is_directly_public(did)\n+        && !cache.effective_visibilities.is_directly_public(tcx, did)\n         && !cache.document_private\n         && !cache.primitive_locations.values().any(|&id| id == did)\n     {\n@@ -1420,87 +1420,84 @@ impl clean::FnDecl {\n     }\n }\n \n-impl clean::Visibility {\n-    pub(crate) fn print_with_space<'a, 'tcx: 'a>(\n-        self,\n-        item_did: ItemId,\n-        cx: &'a Context<'tcx>,\n-    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n-        use std::fmt::Write as _;\n-\n-        let to_print: Cow<'static, str> = match self {\n-            clean::Public => \"pub \".into(),\n-            clean::Inherited => \"\".into(),\n-            clean::Visibility::Restricted(vis_did) => {\n-                // FIXME(camelid): This may not work correctly if `item_did` is a module.\n-                //                 However, rustdoc currently never displays a module's\n-                //                 visibility, so it shouldn't matter.\n-                let parent_module = find_nearest_parent_module(cx.tcx(), item_did.expect_def_id());\n-\n-                if vis_did.is_crate_root() {\n-                    \"pub(crate) \".into()\n-                } else if parent_module == Some(vis_did) {\n-                    // `pub(in foo)` where `foo` is the parent module\n-                    // is the same as no visibility modifier\n-                    \"\".into()\n-                } else if parent_module\n-                    .and_then(|parent| find_nearest_parent_module(cx.tcx(), parent))\n-                    == Some(vis_did)\n-                {\n-                    \"pub(super) \".into()\n-                } else {\n-                    let path = cx.tcx().def_path(vis_did);\n-                    debug!(\"path={:?}\", path);\n-                    // modified from `resolved_path()` to work with `DefPathData`\n-                    let last_name = path.data.last().unwrap().data.get_opt_name().unwrap();\n-                    let anchor = anchor(vis_did, last_name, cx).to_string();\n-\n-                    let mut s = \"pub(in \".to_owned();\n-                    for seg in &path.data[..path.data.len() - 1] {\n-                        let _ = write!(s, \"{}::\", seg.data.get_opt_name().unwrap());\n-                    }\n-                    let _ = write!(s, \"{}) \", anchor);\n-                    s.into()\n+pub(crate) fn visibility_print_with_space<'a, 'tcx: 'a>(\n+    visibility: Option<ty::Visibility<DefId>>,\n+    item_did: ItemId,\n+    cx: &'a Context<'tcx>,\n+) -> impl fmt::Display + 'a + Captures<'tcx> {\n+    use std::fmt::Write as _;\n+\n+    let to_print: Cow<'static, str> = match visibility {\n+        None => \"\".into(),\n+        Some(ty::Visibility::Public) => \"pub \".into(),\n+        Some(ty::Visibility::Restricted(vis_did)) => {\n+            // FIXME(camelid): This may not work correctly if `item_did` is a module.\n+            //                 However, rustdoc currently never displays a module's\n+            //                 visibility, so it shouldn't matter.\n+            let parent_module = find_nearest_parent_module(cx.tcx(), item_did.expect_def_id());\n+\n+            if vis_did.is_crate_root() {\n+                \"pub(crate) \".into()\n+            } else if parent_module == Some(vis_did) {\n+                // `pub(in foo)` where `foo` is the parent module\n+                // is the same as no visibility modifier\n+                \"\".into()\n+            } else if parent_module.and_then(|parent| find_nearest_parent_module(cx.tcx(), parent))\n+                == Some(vis_did)\n+            {\n+                \"pub(super) \".into()\n+            } else {\n+                let path = cx.tcx().def_path(vis_did);\n+                debug!(\"path={:?}\", path);\n+                // modified from `resolved_path()` to work with `DefPathData`\n+                let last_name = path.data.last().unwrap().data.get_opt_name().unwrap();\n+                let anchor = anchor(vis_did, last_name, cx).to_string();\n+\n+                let mut s = \"pub(in \".to_owned();\n+                for seg in &path.data[..path.data.len() - 1] {\n+                    let _ = write!(s, \"{}::\", seg.data.get_opt_name().unwrap());\n                 }\n+                let _ = write!(s, \"{}) \", anchor);\n+                s.into()\n             }\n-        };\n-        display_fn(move |f| write!(f, \"{}\", to_print))\n-    }\n+        }\n+    };\n+    display_fn(move |f| write!(f, \"{}\", to_print))\n+}\n \n-    /// This function is the same as print_with_space, except that it renders no links.\n-    /// It's used for macros' rendered source view, which is syntax highlighted and cannot have\n-    /// any HTML in it.\n-    pub(crate) fn to_src_with_space<'a, 'tcx: 'a>(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-        item_did: DefId,\n-    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n-        let to_print = match self {\n-            clean::Public => \"pub \".to_owned(),\n-            clean::Inherited => String::new(),\n-            clean::Visibility::Restricted(vis_did) => {\n-                // FIXME(camelid): This may not work correctly if `item_did` is a module.\n-                //                 However, rustdoc currently never displays a module's\n-                //                 visibility, so it shouldn't matter.\n-                let parent_module = find_nearest_parent_module(tcx, item_did);\n-\n-                if vis_did.is_crate_root() {\n-                    \"pub(crate) \".to_owned()\n-                } else if parent_module == Some(vis_did) {\n-                    // `pub(in foo)` where `foo` is the parent module\n-                    // is the same as no visibility modifier\n-                    String::new()\n-                } else if parent_module.and_then(|parent| find_nearest_parent_module(tcx, parent))\n-                    == Some(vis_did)\n-                {\n-                    \"pub(super) \".to_owned()\n-                } else {\n-                    format!(\"pub(in {}) \", tcx.def_path_str(vis_did))\n-                }\n+/// This function is the same as print_with_space, except that it renders no links.\n+/// It's used for macros' rendered source view, which is syntax highlighted and cannot have\n+/// any HTML in it.\n+pub(crate) fn visibility_to_src_with_space<'a, 'tcx: 'a>(\n+    visibility: Option<ty::Visibility<DefId>>,\n+    tcx: TyCtxt<'tcx>,\n+    item_did: DefId,\n+) -> impl fmt::Display + 'a + Captures<'tcx> {\n+    let to_print = match visibility {\n+        None => String::new(),\n+        Some(ty::Visibility::Public) => \"pub \".to_owned(),\n+        Some(ty::Visibility::Restricted(vis_did)) => {\n+            // FIXME(camelid): This may not work correctly if `item_did` is a module.\n+            //                 However, rustdoc currently never displays a module's\n+            //                 visibility, so it shouldn't matter.\n+            let parent_module = find_nearest_parent_module(tcx, item_did);\n+\n+            if vis_did.is_crate_root() {\n+                \"pub(crate) \".to_owned()\n+            } else if parent_module == Some(vis_did) {\n+                // `pub(in foo)` where `foo` is the parent module\n+                // is the same as no visibility modifier\n+                String::new()\n+            } else if parent_module.and_then(|parent| find_nearest_parent_module(tcx, parent))\n+                == Some(vis_did)\n+            {\n+                \"pub(super) \".to_owned()\n+            } else {\n+                format!(\"pub(in {}) \", tcx.def_path_str(vis_did))\n             }\n-        };\n-        display_fn(move |f| f.write_str(&to_print))\n-    }\n+        }\n+    };\n+    display_fn(move |f| f.write_str(&to_print))\n }\n \n pub(crate) trait PrintWithSpace {"}, {"sha": "cd8c8c463b1ab60bafcaf15168de9dc1d6003362", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -362,7 +362,7 @@ impl Class {\n         match self {\n             Class::Comment => \"comment\",\n             Class::DocComment => \"doccomment\",\n-            Class::Attribute => \"attribute\",\n+            Class::Attribute => \"attr\",\n             Class::KeyWord => \"kw\",\n             Class::RefKeyWord => \"kw-2\",\n             Class::Self_(_) => \"self\","}, {"sha": "fced2eacd9e72555cd19474962df9428a684c4a1", "filename": "src/librustdoc/html/highlight/fixtures/sample.html", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fsample.html", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fsample.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fsample.html?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -3,16 +3,16 @@\n .kw { color: #8959A8; }\n .kw-2, .prelude-ty { color: #4271AE; }\n .number, .string { color: #718C00; }\n-.self, .bool-val, .prelude-val, .attribute, .attribute .ident { color: #C82829; }\n+.self, .bool-val, .prelude-val, .attr, .attr .ident { color: #C82829; }\n .macro, .macro-nonterminal { color: #3E999F; }\n .lifetime { color: #B76514; }\n .question-mark { color: #ff9011; }\n </style>\n-<pre><code><span class=\"attribute\">#![crate_type = <span class=\"string\">&quot;lib&quot;</span>]\n+<pre><code><span class=\"attr\">#![crate_type = <span class=\"string\">&quot;lib&quot;</span>]\n \n </span><span class=\"kw\">use </span>std::path::{Path, PathBuf};\n \n-<span class=\"attribute\">#[cfg(target_os = <span class=\"string\">&quot;linux&quot;</span>)]\n+<span class=\"attr\">#[cfg(target_os = <span class=\"string\">&quot;linux&quot;</span>)]\n #[cfg(target_os = <span class=\"string\">&quot;windows&quot;</span>)]\n </span><span class=\"kw\">fn </span>main() -&gt; () {\n     <span class=\"kw\">let </span>foo = <span class=\"bool-val\">true </span>&amp;&amp; <span class=\"bool-val\">false </span>|| <span class=\"bool-val\">true</span>;\n@@ -23,7 +23,7 @@\n     <span class=\"macro\">mac!</span>(foo, <span class=\"kw-2\">&amp;mut </span>bar);\n     <span class=\"macro\">assert!</span>(<span class=\"self\">self</span>.length &lt; N &amp;&amp; index &lt;= <span class=\"self\">self</span>.length);\n     ::std::env::var(<span class=\"string\">&quot;gateau&quot;</span>).is_ok();\n-    <span class=\"attribute\">#[rustfmt::skip]\n+    <span class=\"attr\">#[rustfmt::skip]\n     </span><span class=\"kw\">let </span>s:std::path::PathBuf = std::path::PathBuf::new();\n     <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::new();\n "}, {"sha": "2c93b9a097f403e364b77baf0651f3788aac2cbe", "filename": "src/librustdoc/html/highlight/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ftests.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -9,7 +9,7 @@ const STYLE: &str = r#\"\n .kw { color: #8959A8; }\n .kw-2, .prelude-ty { color: #4271AE; }\n .number, .string { color: #718C00; }\n-.self, .bool-val, .prelude-val, .attribute, .attribute .ident { color: #C82829; }\n+.self, .bool-val, .prelude-val, .attr, .attr .ident { color: #C82829; }\n .macro, .macro-nonterminal { color: #3E999F; }\n .lifetime { color: #B76514; }\n .question-mark { color: #ff9011; }"}, {"sha": "3a041ae15d6185904cb8de0d4d9c2b7ed4ca26af", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -70,8 +70,8 @@ use crate::formats::{AssocItemRender, Impl, RenderMode};\n use crate::html::escape::Escape;\n use crate::html::format::{\n     href, join_with_double_colon, print_abi_with_space, print_constness_with_space,\n-    print_default_space, print_generic_bounds, print_where_clause, Buffer, Ending, HrefError,\n-    PrintWithSpace,\n+    print_default_space, print_generic_bounds, print_where_clause, visibility_print_with_space,\n+    Buffer, Ending, HrefError, PrintWithSpace,\n };\n use crate::html::highlight;\n use crate::html::markdown::{\n@@ -747,11 +747,12 @@ fn assoc_const(\n     extra: &str,\n     cx: &Context<'_>,\n ) {\n+    let tcx = cx.tcx();\n     write!(\n         w,\n         \"{extra}{vis}const <a{href} class=\\\"constant\\\">{name}</a>: {ty}\",\n         extra = extra,\n-        vis = it.visibility.print_with_space(it.item_id, cx),\n+        vis = visibility_print_with_space(it.visibility(tcx), it.item_id, cx),\n         href = assoc_href_attr(it, link, cx),\n         name = it.name.as_ref().unwrap(),\n         ty = ty.print(cx),\n@@ -764,7 +765,7 @@ fn assoc_const(\n         //        This hurts readability in this context especially when more complex expressions\n         //        are involved and it doesn't add much of value.\n         //        Find a way to print constants here without all that jazz.\n-        write!(w, \"{}\", Escape(&default.value(cx.tcx()).unwrap_or_else(|| default.expr(cx.tcx()))));\n+        write!(w, \"{}\", Escape(&default.value(tcx).unwrap_or_else(|| default.expr(tcx))));\n     }\n }\n \n@@ -805,14 +806,15 @@ fn assoc_method(\n     cx: &Context<'_>,\n     render_mode: RenderMode,\n ) {\n-    let header = meth.fn_header(cx.tcx()).expect(\"Trying to get header from a non-function item\");\n+    let tcx = cx.tcx();\n+    let header = meth.fn_header(tcx).expect(\"Trying to get header from a non-function item\");\n     let name = meth.name.as_ref().unwrap();\n-    let vis = meth.visibility.print_with_space(meth.item_id, cx).to_string();\n+    let vis = visibility_print_with_space(meth.visibility(tcx), meth.item_id, cx).to_string();\n     // FIXME: Once https://github.com/rust-lang/rust/issues/67792 is implemented, we can remove\n     // this condition.\n     let constness = match render_mode {\n         RenderMode::Normal => {\n-            print_constness_with_space(&header.constness, meth.const_stability(cx.tcx()))\n+            print_constness_with_space(&header.constness, meth.const_stability(tcx))\n         }\n         RenderMode::ForDeref { .. } => \"\",\n     };"}, {"sha": "3225ddabe2e75e429afca4a151df27411e46547d", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 44, "deletions": 33, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -7,7 +7,7 @@ use rustc_hir::def_id::DefId;\n use rustc_middle::middle::stability;\n use rustc_middle::span_bug;\n use rustc_middle::ty::layout::LayoutError;\n-use rustc_middle::ty::{Adt, TyCtxt};\n+use rustc_middle::ty::{self, Adt, TyCtxt};\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_target::abi::{Layout, Primitive, TagEncoding, Variants};\n@@ -28,7 +28,7 @@ use crate::formats::{AssocItemRender, Impl, RenderMode};\n use crate::html::escape::Escape;\n use crate::html::format::{\n     join_with_double_colon, print_abi_with_space, print_constness_with_space, print_where_clause,\n-    Buffer, Ending, PrintWithSpace,\n+    visibility_print_with_space, Buffer, Ending, PrintWithSpace,\n };\n use crate::html::highlight;\n use crate::html::layout::Page;\n@@ -318,6 +318,7 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n             );\n         }\n \n+        let tcx = cx.tcx();\n         match *myitem.kind {\n             clean::ExternCrateItem { ref src } => {\n                 use crate::html::format::anchor;\n@@ -327,14 +328,14 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n                     Some(src) => write!(\n                         w,\n                         \"<div class=\\\"item-left\\\"><code>{}extern crate {} as {};\",\n-                        myitem.visibility.print_with_space(myitem.item_id, cx),\n+                        visibility_print_with_space(myitem.visibility(tcx), myitem.item_id, cx),\n                         anchor(myitem.item_id.expect_def_id(), src, cx),\n                         myitem.name.unwrap(),\n                     ),\n                     None => write!(\n                         w,\n                         \"<div class=\\\"item-left\\\"><code>{}extern crate {};\",\n-                        myitem.visibility.print_with_space(myitem.item_id, cx),\n+                        visibility_print_with_space(myitem.visibility(tcx), myitem.item_id, cx),\n                         anchor(myitem.item_id.expect_def_id(), myitem.name.unwrap(), cx),\n                     ),\n                 }\n@@ -384,7 +385,7 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n                      </div>\\\n                      {stab_tags_before}{stab_tags}{stab_tags_after}\",\n                     stab = stab.unwrap_or_default(),\n-                    vis = myitem.visibility.print_with_space(myitem.item_id, cx),\n+                    vis = visibility_print_with_space(myitem.visibility(tcx), myitem.item_id, cx),\n                     imp = import.print(cx),\n                 );\n                 w.write_str(ITEM_TABLE_ROW_CLOSE);\n@@ -408,8 +409,8 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n                 let stab = myitem.stability_class(cx.tcx());\n                 let add = if stab.is_some() { \" \" } else { \"\" };\n \n-                let visibility_emoji = match myitem.visibility {\n-                    clean::Visibility::Restricted(_) => {\n+                let visibility_emoji = match myitem.visibility(tcx) {\n+                    Some(ty::Visibility::Restricted(_)) => {\n                         \"<span title=\\\"Restricted Visibility\\\">&nbsp;\ud83d\udd12</span> \"\n                     }\n                     _ => \"\",\n@@ -496,12 +497,13 @@ fn extra_info_tags(item: &clean::Item, parent: &clean::Item, tcx: TyCtxt<'_>) ->\n }\n \n fn item_function(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, f: &clean::Function) {\n-    let header = it.fn_header(cx.tcx()).expect(\"printing a function which isn't a function\");\n-    let constness = print_constness_with_space(&header.constness, it.const_stability(cx.tcx()));\n+    let tcx = cx.tcx();\n+    let header = it.fn_header(tcx).expect(\"printing a function which isn't a function\");\n+    let constness = print_constness_with_space(&header.constness, it.const_stability(tcx));\n     let unsafety = header.unsafety.print_with_space();\n     let abi = print_abi_with_space(header.abi).to_string();\n     let asyncness = header.asyncness.print_with_space();\n-    let visibility = it.visibility.print_with_space(it.item_id, cx).to_string();\n+    let visibility = visibility_print_with_space(it.visibility(tcx), it.item_id, cx).to_string();\n     let name = it.name.unwrap();\n \n     let generics_len = format!(\"{:#}\", f.generics.print(cx)).len();\n@@ -539,6 +541,7 @@ fn item_function(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, f: &cle\n }\n \n fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean::Trait) {\n+    let tcx = cx.tcx();\n     let bounds = bounds(&t.bounds, false, cx);\n     let required_types = t.items.iter().filter(|m| m.is_ty_associated_type()).collect::<Vec<_>>();\n     let provided_types = t.items.iter().filter(|m| m.is_associated_type()).collect::<Vec<_>>();\n@@ -549,8 +552,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n     let count_types = required_types.len() + provided_types.len();\n     let count_consts = required_consts.len() + provided_consts.len();\n     let count_methods = required_methods.len() + provided_methods.len();\n-    let must_implement_one_of_functions =\n-        cx.tcx().trait_def(t.def_id).must_implement_one_of.clone();\n+    let must_implement_one_of_functions = tcx.trait_def(t.def_id).must_implement_one_of.clone();\n \n     // Output the trait definition\n     wrap_into_item_decl(w, |w| {\n@@ -559,9 +561,9 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n             write!(\n                 w,\n                 \"{}{}{}trait {}{}{}\",\n-                it.visibility.print_with_space(it.item_id, cx),\n-                t.unsafety(cx.tcx()).print_with_space(),\n-                if t.is_auto(cx.tcx()) { \"auto \" } else { \"\" },\n+                visibility_print_with_space(it.visibility(tcx), it.item_id, cx),\n+                t.unsafety(tcx).print_with_space(),\n+                if t.is_auto(tcx) { \"auto \" } else { \"\" },\n                 it.name.unwrap(),\n                 t.generics.print(cx),\n                 bounds\n@@ -1020,7 +1022,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n     }\n     let extern_crates = extern_crates\n         .into_iter()\n-        .map(|cnum| cx.shared.tcx.crate_name(cnum).to_string())\n+        .map(|cnum| tcx.crate_name(cnum).to_string())\n         .collect::<Vec<_>>()\n         .join(\",\");\n     let (extern_before, extern_after) =\n@@ -1084,7 +1086,7 @@ fn item_typedef(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clea\n     fn write_content(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Typedef) {\n         wrap_item(w, \"typedef\", |w| {\n             render_attributes_in_pre(w, it, \"\");\n-            write!(w, \"{}\", it.visibility.print_with_space(it.item_id, cx));\n+            write!(w, \"{}\", visibility_print_with_space(it.visibility(cx.tcx()), it.item_id, cx));\n             write!(\n                 w,\n                 \"type {}{}{where_clause} = {type_};\",\n@@ -1173,14 +1175,15 @@ fn print_tuple_struct_fields(w: &mut Buffer, cx: &Context<'_>, s: &[clean::Item]\n }\n \n fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::Enum) {\n+    let tcx = cx.tcx();\n     let count_variants = e.variants().count();\n     wrap_into_item_decl(w, |w| {\n         wrap_item(w, \"enum\", |w| {\n             render_attributes_in_pre(w, it, \"\");\n             write!(\n                 w,\n                 \"{}enum {}{}\",\n-                it.visibility.print_with_space(it.item_id, cx),\n+                visibility_print_with_space(it.visibility(tcx), it.item_id, cx),\n                 it.name.unwrap(),\n                 e.generics.print(cx),\n             );\n@@ -1268,10 +1271,10 @@ fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::\n             w.write_str(\"</code>\");\n             render_stability_since_raw(\n                 w,\n-                variant.stable_since(cx.tcx()),\n-                variant.const_stability(cx.tcx()),\n-                it.stable_since(cx.tcx()),\n-                it.const_stable_since(cx.tcx()),\n+                variant.stable_since(tcx),\n+                variant.const_stability(tcx),\n+                it.stable_since(tcx),\n+                it.const_stable_since(tcx),\n             );\n             w.write_str(\"</h3>\");\n \n@@ -1389,12 +1392,13 @@ fn item_primitive(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item) {\n fn item_constant(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, c: &clean::Constant) {\n     wrap_into_item_decl(w, |w| {\n         wrap_item(w, \"const\", |w| {\n+            let tcx = cx.tcx();\n             render_attributes_in_code(w, it);\n \n             write!(\n                 w,\n                 \"{vis}const {name}: {typ}\",\n-                vis = it.visibility.print_with_space(it.item_id, cx),\n+                vis = visibility_print_with_space(it.visibility(tcx), it.item_id, cx),\n                 name = it.name.unwrap(),\n                 typ = c.type_.print(cx),\n             );\n@@ -1408,9 +1412,9 @@ fn item_constant(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, c: &cle\n             //            ` = 100i32;`\n             //        instead?\n \n-            let value = c.value(cx.tcx());\n-            let is_literal = c.is_literal(cx.tcx());\n-            let expr = c.expr(cx.tcx());\n+            let value = c.value(tcx);\n+            let is_literal = c.is_literal(tcx);\n+            let expr = c.expr(tcx);\n             if value.is_some() || is_literal {\n                 write!(w, \" = {expr};\", expr = Escape(&expr));\n             } else {\n@@ -1495,7 +1499,7 @@ fn item_static(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean\n             write!(\n                 w,\n                 \"{vis}static {mutability}{name}: {typ}\",\n-                vis = it.visibility.print_with_space(it.item_id, cx),\n+                vis = visibility_print_with_space(it.visibility(cx.tcx()), it.item_id, cx),\n                 mutability = s.mutability.print_with_space(),\n                 name = it.name.unwrap(),\n                 typ = s.type_.print(cx)\n@@ -1513,7 +1517,7 @@ fn item_foreign_type(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item) {\n             write!(\n                 w,\n                 \"    {}type {};\\n}}\",\n-                it.visibility.print_with_space(it.item_id, cx),\n+                visibility_print_with_space(it.visibility(cx.tcx()), it.item_id, cx),\n                 it.name.unwrap(),\n             );\n         });\n@@ -1666,7 +1670,13 @@ fn render_union(\n     tab: &str,\n     cx: &Context<'_>,\n ) {\n-    write!(w, \"{}union {}\", it.visibility.print_with_space(it.item_id, cx), it.name.unwrap(),);\n+    let tcx = cx.tcx();\n+    write!(\n+        w,\n+        \"{}union {}\",\n+        visibility_print_with_space(it.visibility(tcx), it.item_id, cx),\n+        it.name.unwrap(),\n+    );\n \n     let where_displayed = g\n         .map(|g| {\n@@ -1693,7 +1703,7 @@ fn render_union(\n             write!(\n                 w,\n                 \"    {}{}: {},\\n{}\",\n-                field.visibility.print_with_space(field.item_id, cx),\n+                visibility_print_with_space(field.visibility(tcx), field.item_id, cx),\n                 field.name.unwrap(),\n                 ty.print(cx),\n                 tab\n@@ -1720,10 +1730,11 @@ fn render_struct(\n     structhead: bool,\n     cx: &Context<'_>,\n ) {\n+    let tcx = cx.tcx();\n     write!(\n         w,\n         \"{}{}{}\",\n-        it.visibility.print_with_space(it.item_id, cx),\n+        visibility_print_with_space(it.visibility(tcx), it.item_id, cx),\n         if structhead { \"struct \" } else { \"\" },\n         it.name.unwrap()\n     );\n@@ -1753,7 +1764,7 @@ fn render_struct(\n                         w,\n                         \"\\n{}    {}{}: {},\",\n                         tab,\n-                        field.visibility.print_with_space(field.item_id, cx),\n+                        visibility_print_with_space(field.visibility(tcx), field.item_id, cx),\n                         field.name.unwrap(),\n                         ty.print(cx),\n                     );\n@@ -1785,7 +1796,7 @@ fn render_struct(\n                         write!(\n                             w,\n                             \"{}{}\",\n-                            field.visibility.print_with_space(field.item_id, cx),\n+                            visibility_print_with_space(field.visibility(tcx), field.item_id, cx),\n                             ty.print(cx),\n                         )\n                     }"}, {"sha": "7c0dab1c527d1eb86d91f204b8cd45b680313e2a", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 32, "deletions": 46, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -163,9 +163,6 @@ h1.fqn {\n \tpadding-bottom: 6px;\n \tmargin-bottom: 15px;\n }\n-#toggle-all-docs {\n-\ttext-decoration: none;\n-}\n /* The only headings that get underlines are:\n \t Markdown-generated headings within the top-doc\n \t Rustdoc-generated h2 section headings (e.g. \"Implementations\", \"Required Methods\", etc)\n@@ -209,7 +206,7 @@ ul.all-items {\n \tfont-family: \"Fira Sans\", Arial, NanumBarunGothic, sans-serif;\n }\n \n-a#toggle-all-docs,\n+#toggle-all-docs,\n a.anchor,\n .small-section-header a,\n #source-sidebar a,\n@@ -299,6 +296,16 @@ button {\n \tpadding: 1px 6px;\n }\n \n+button#toggle-all-docs {\n+\tpadding: 0;\n+\tbackground: none;\n+\tborder: none;\n+\tcursor: pointer;\n+\t/* iOS button gradient: https://stackoverflow.com/q/5438567 */\n+\t-webkit-appearance: none;\n+\topacity: 1;\n+}\n+\n /* end tweaks for normalize.css 8 */\n \n .rustdoc {\n@@ -670,7 +677,6 @@ pre, .rustdoc.source .example-wrap {\n }\n \n #main-content > .item-info {\n-\tmargin-top: 0;\n \tmargin-left: 0;\n }\n \n@@ -869,40 +875,30 @@ so that we can apply CSS-filters to change the arrow color in themes */\n \n .search-results {\n \tdisplay: none;\n-\tpadding-bottom: 2em;\n }\n \n .search-results.active {\n \tdisplay: block;\n-\t/* prevent overhanging tabs from moving the first result */\n-\tclear: both;\n-}\n-\n-.search-results .desc > span {\n-\twhite-space: nowrap;\n-\ttext-overflow: ellipsis;\n-\toverflow: hidden;\n-\tdisplay: block;\n }\n \n .search-results > a {\n-\tdisplay: block;\n+\tdisplay: flex;\n \t/* A little margin ensures the browser's outlining of focused links has room to display. */\n \tmargin-left: 2px;\n \tmargin-right: 2px;\n-\tborder-bottom: 1px solid #aaa3;\n+\tborder-bottom: 1px solid var(--border-color);\n+\tgap: 1em;\n }\n \n .search-results > a > div {\n-\tdisplay: flex;\n-\tflex-flow: row wrap;\n+\tflex: 1;\n }\n \n-.search-results .result-name, .search-results div.desc {\n-\twidth: 50%;\n-}\n-.search-results .result-name {\n-\tpadding-right: 1em;\n+.search-results > a > div.desc {\n+\twhite-space: nowrap;\n+\ttext-overflow: ellipsis;\n+\toverflow: hidden;\n+\tdisplay: block;\n }\n \n .search-results a:hover,\n@@ -1086,7 +1082,7 @@ pre.rust .bool-val {\n pre.rust .self {\n \tcolor: var(--code-highlight-self-color);\n }\n-pre.rust .attribute {\n+pre.rust .attr {\n \tcolor: var(--code-highlight-attribute-color);\n }\n pre.rust .macro,\n@@ -1673,7 +1669,6 @@ in storage.js\n \t}\n \n \t.rustdoc {\n-\t\tpadding-top: 0px;\n \t\t/* Sidebar should overlay main content, rather than pushing main content to the right.\n \t\t   Turn off `display: flex` on the body element. */\n \t\tdisplay: block;\n@@ -1793,7 +1788,6 @@ in storage.js\n \n \t.sidebar-elems {\n \t\tmargin-top: 1em;\n-\t\tbackground-color: var(--sidebar-background-color);\n \t}\n \n \t.content {\n@@ -1866,26 +1860,16 @@ in storage.js\n \t}\n \n \t/* Display an alternating layout on tablets and phones */\n-\t.item-table {\n+\t.item-table, .item-row, .item-left, .item-right,\n+\t.search-results > a, .search-results > a > div {\n \t\tdisplay: block;\n \t}\n-\t.item-row {\n-\t\tdisplay: flex;\n-\t\tflex-flow: column wrap;\n-\t}\n-\t.item-left, .item-right {\n-\t\twidth: 100%;\n-\t}\n \n \t/* Display an alternating layout on tablets and phones */\n \t.search-results > a {\n-\t\tborder-bottom: 1px solid #aaa9;\n \t\tpadding: 5px 0px;\n \t}\n-\t.search-results .result-name, .search-results div.desc {\n-\t\twidth: 100%;\n-\t}\n-\t.search-results div.desc, .item-right {\n+\t.search-results > a > div.desc, .item-right {\n \t\tpadding-left: 2em;\n \t}\n \n@@ -1962,24 +1946,26 @@ in storage.js\n \t}\n }\n \n-.method-toggle > summary,\n .implementors-toggle > summary,\n .impl,\n #implementors-list > .docblock,\n .impl-items > section,\n-.methods > section\n+.impl-items > .rustdoc-toggle > summary,\n+.methods > section,\n+.methods > .rustdoc-toggle > summary\n {\n \tmargin-bottom: 0.75em;\n }\n \n-.method-toggle[open]:not(:last-child),\n+.impl-items > .rustdoc-toggle[open]:not(:last-child),\n+.methods > .rustdoc-toggle[open]:not(:last-child),\n .implementors-toggle[open]:not(:last-child) {\n \tmargin-bottom: 2em;\n }\n \n-#trait-implementations-list .method-toggle:not(:last-child),\n-#synthetic-implementations-list .method-toggle:not(:last-child),\n-#blanket-implementations-list .method-toggle:not(:last-child) {\n+#trait-implementations-list .impl-items > .rustdoc-toggle:not(:last-child),\n+#synthetic-implementations-list .impl-items > .rustdoc-toggle:not(:last-child),\n+#blanket-implementations-list .impl-items > .rustdoc-toggle:not(:last-child) {\n \tmargin-bottom: 1em;\n }\n "}, {"sha": "dd0531c5e70e4da1b4cd02a8ee1b010d276a0654", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -1593,7 +1593,6 @@ function initSearch(rawSearchIndex) {\n                 link.className = \"result-\" + type;\n                 link.href = item.href;\n \n-                const wrapper = document.createElement(\"div\");\n                 const resultName = document.createElement(\"div\");\n                 resultName.className = \"result-name\";\n \n@@ -1614,16 +1613,13 @@ function initSearch(rawSearchIndex) {\n                 resultName.insertAdjacentHTML(\n                     \"beforeend\",\n                     item.displayPath + \"<span class=\\\"\" + type + \"\\\">\" + name + extra + \"</span>\");\n-                wrapper.appendChild(resultName);\n+                link.appendChild(resultName);\n \n                 const description = document.createElement(\"div\");\n                 description.className = \"desc\";\n-                const spanDesc = document.createElement(\"span\");\n-                spanDesc.insertAdjacentHTML(\"beforeend\", item.desc);\n+                description.insertAdjacentHTML(\"beforeend\", item.desc);\n \n-                description.appendChild(spanDesc);\n-                wrapper.appendChild(description);\n-                link.appendChild(wrapper);\n+                link.appendChild(description);\n                 output.appendChild(link);\n             });\n         } else if (query.error === null) {"}, {"sha": "e497b619366b175e0513fce42de6754d961d0d95", "filename": "src/librustdoc/html/templates/print_item.html", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fprint_item.html", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fprint_item.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fprint_item.html?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -21,8 +21,8 @@ <h1 class=\"fqn\"> {#- -#}\n                 <a class=\"srclink\" href=\"{{href|safe}}\">source</a> \u00b7 {# -#}\n             {%- else -%}\n         {%- endmatch -%}\n-        <a id=\"toggle-all-docs\" href=\"javascript:void(0)\" title=\"collapse all docs\"> {#- -#}\n-            [<span class=\"inner\">&#x2212;</span>] {#- -#}\n-        </a> {#- -#}\n+        <button id=\"toggle-all-docs\" title=\"collapse all docs\"> {#- -#}\n+            [<span>&#x2212;</span>] {#- -#}\n+        </button> {#- -#}\n     </span> {#- -#}\n </div> {#- -#}"}, {"sha": "cb8b7c18029f02e7812873f1fde215885d211428", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -48,7 +48,8 @@ impl JsonRenderer<'_> {\n             .map(rustc_ast_pretty::pprust::attribute_to_string)\n             .collect();\n         let span = item.span(self.tcx);\n-        let clean::Item { name, attrs: _, kind: _, visibility, item_id, cfg: _ } = item;\n+        let visibility = item.visibility(self.tcx);\n+        let clean::Item { name, attrs: _, kind: _, item_id, cfg: _, .. } = item;\n         let inner = match *item.kind {\n             clean::KeywordItem => return None,\n             clean::StrippedItem(ref inner) => {\n@@ -99,13 +100,12 @@ impl JsonRenderer<'_> {\n         }\n     }\n \n-    fn convert_visibility(&self, v: clean::Visibility) -> Visibility {\n-        use clean::Visibility::*;\n+    fn convert_visibility(&self, v: Option<ty::Visibility<DefId>>) -> Visibility {\n         match v {\n-            Public => Visibility::Public,\n-            Inherited => Visibility::Default,\n-            Restricted(did) if did.is_crate_root() => Visibility::Crate,\n-            Restricted(did) => Visibility::Restricted {\n+            None => Visibility::Default,\n+            Some(ty::Visibility::Public) => Visibility::Public,\n+            Some(ty::Visibility::Restricted(did)) if did.is_crate_root() => Visibility::Crate,\n+            Some(ty::Visibility::Restricted(did)) => Visibility::Restricted {\n                 parent: from_item_id(did.into(), self.tcx),\n                 path: self.tcx.def_path(did).to_string_no_crate_verbose(),\n             },\n@@ -283,7 +283,7 @@ fn from_clean_item(item: clean::Item, tcx: TyCtxt<'_>) -> ItemEnum {\n             ItemEnum::AssocConst { type_: ty.into_tcx(tcx), default: Some(default.expr(tcx)) }\n         }\n         TyAssocTypeItem(g, b) => ItemEnum::AssocType {\n-            generics: (*g).into_tcx(tcx),\n+            generics: g.into_tcx(tcx),\n             bounds: b.into_tcx(tcx),\n             default: None,\n         },"}, {"sha": "057d2fdd9d5fce5b568108af8f4c4ce4f71cc509", "filename": "src/librustdoc/passes/check_doc_test_visibility.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -56,7 +56,7 @@ impl crate::doctest::Tester for Tests {\n }\n \n pub(crate) fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> bool {\n-    if !cx.cache.effective_visibilities.is_directly_public(item.item_id.expect_def_id())\n+    if !cx.cache.effective_visibilities.is_directly_public(cx.tcx, item.item_id.expect_def_id())\n         || matches!(\n             *item.kind,\n             clean::StructFieldItem(_)\n@@ -130,7 +130,7 @@ pub(crate) fn look_for_tests<'tcx>(cx: &DocContext<'tcx>, dox: &str, item: &Item\n             );\n         }\n     } else if tests.found_tests > 0\n-        && !cx.cache.effective_visibilities.is_exported(item.item_id.expect_def_id())\n+        && !cx.cache.effective_visibilities.is_exported(cx.tcx, item.item_id.expect_def_id())\n     {\n         cx.tcx.struct_span_lint_hir(\n             crate::lint::PRIVATE_DOC_TESTS,"}, {"sha": "0bd0dbbeb702ca6ef46be3e8a030606c4479da69", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -1893,7 +1893,7 @@ fn disambiguator_error(\n     diag_info.link_range = disambiguator_range;\n     report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, msg, &diag_info, |diag, _sp| {\n         let msg = format!(\n-            \"see {}/rustdoc/linking-to-items-by-name.html#namespaces-and-disambiguators for more info about disambiguators\",\n+            \"see {}/rustdoc/write-documentation/linking-to-items-by-name.html#namespaces-and-disambiguators for more info about disambiguators\",\n             crate::DOC_RUST_LANG_ORG_CHANNEL\n         );\n         diag.note(&msg);"}, {"sha": "e07a788a72a41e53bc3ea98827579b4717067dc4", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -27,6 +27,7 @@ pub(crate) fn strip_hidden(krate: clean::Crate, cx: &mut DocContext<'_>) -> clea\n \n     // strip all impls referencing stripped items\n     let mut stripper = ImplStripper {\n+        tcx: cx.tcx,\n         retained: &retained,\n         cache: &cx.cache,\n         is_json_output,"}, {"sha": "3bac5a8e5d7490cd8614790559a83b2f68917616", "filename": "src/librustdoc/passes/strip_priv_imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -11,6 +11,6 @@ pub(crate) const STRIP_PRIV_IMPORTS: Pass = Pass {\n     description: \"strips all private import statements (`use`, `extern crate`) from a crate\",\n };\n \n-pub(crate) fn strip_priv_imports(krate: clean::Crate, _: &mut DocContext<'_>) -> clean::Crate {\n-    ImportStripper.fold_crate(krate)\n+pub(crate) fn strip_priv_imports(krate: clean::Crate, cx: &mut DocContext<'_>) -> clean::Crate {\n+    ImportStripper { tcx: cx.tcx }.fold_crate(krate)\n }"}, {"sha": "8fc42462de9696cba2fe15bb85c3ba1c9a6c6113", "filename": "src/librustdoc/passes/strip_private.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -26,12 +26,14 @@ pub(crate) fn strip_private(mut krate: clean::Crate, cx: &mut DocContext<'_>) ->\n             effective_visibilities: &cx.cache.effective_visibilities,\n             update_retained: true,\n             is_json_output,\n+            tcx: cx.tcx,\n         };\n-        krate = ImportStripper.fold_crate(stripper.fold_crate(krate));\n+        krate = ImportStripper { tcx: cx.tcx }.fold_crate(stripper.fold_crate(krate));\n     }\n \n     // strip all impls referencing private items\n     let mut stripper = ImplStripper {\n+        tcx: cx.tcx,\n         retained: &retained,\n         cache: &cx.cache,\n         is_json_output,"}, {"sha": "995fb5dcc1c86de89b780320701190eb25c3790d", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 31, "deletions": 18, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -1,38 +1,40 @@\n //! A collection of utility functions for the `strip_*` passes.\n use rustc_hir::def_id::DefId;\n-use rustc_middle::middle::privacy::EffectiveVisibilities;\n+use rustc_middle::ty::{TyCtxt, Visibility};\n use rustc_span::symbol::sym;\n-\n use std::mem;\n \n use crate::clean::{self, Item, ItemId, ItemIdSet, NestedAttributesExt};\n use crate::fold::{strip_item, DocFolder};\n use crate::formats::cache::Cache;\n+use crate::visit_lib::RustdocEffectiveVisibilities;\n \n-pub(crate) struct Stripper<'a> {\n+pub(crate) struct Stripper<'a, 'tcx> {\n     pub(crate) retained: &'a mut ItemIdSet,\n-    pub(crate) effective_visibilities: &'a EffectiveVisibilities<DefId>,\n+    pub(crate) effective_visibilities: &'a RustdocEffectiveVisibilities,\n     pub(crate) update_retained: bool,\n     pub(crate) is_json_output: bool,\n+    pub(crate) tcx: TyCtxt<'tcx>,\n }\n \n // We need to handle this differently for the JSON output because some non exported items could\n // be used in public API. And so, we need these items as well. `is_exported` only checks if they\n // are in the public API, which is not enough.\n #[inline]\n fn is_item_reachable(\n+    tcx: TyCtxt<'_>,\n     is_json_output: bool,\n-    effective_visibilities: &EffectiveVisibilities<DefId>,\n+    effective_visibilities: &RustdocEffectiveVisibilities,\n     item_id: ItemId,\n ) -> bool {\n     if is_json_output {\n-        effective_visibilities.is_reachable(item_id.expect_def_id())\n+        effective_visibilities.is_reachable(tcx, item_id.expect_def_id())\n     } else {\n-        effective_visibilities.is_exported(item_id.expect_def_id())\n+        effective_visibilities.is_exported(tcx, item_id.expect_def_id())\n     }\n }\n \n-impl<'a> DocFolder for Stripper<'a> {\n+impl<'a, 'tcx> DocFolder for Stripper<'a, 'tcx> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         match *i.kind {\n             clean::StrippedItem(..) => {\n@@ -66,21 +68,26 @@ impl<'a> DocFolder for Stripper<'a> {\n             | clean::ForeignTypeItem => {\n                 let item_id = i.item_id;\n                 if item_id.is_local()\n-                    && !is_item_reachable(self.is_json_output, self.effective_visibilities, item_id)\n+                    && !is_item_reachable(\n+                        self.tcx,\n+                        self.is_json_output,\n+                        self.effective_visibilities,\n+                        item_id,\n+                    )\n                 {\n                     debug!(\"Stripper: stripping {:?} {:?}\", i.type_(), i.name);\n                     return None;\n                 }\n             }\n \n             clean::StructFieldItem(..) => {\n-                if !i.visibility.is_public() {\n+                if i.visibility(self.tcx) != Some(Visibility::Public) {\n                     return Some(strip_item(i));\n                 }\n             }\n \n             clean::ModuleItem(..) => {\n-                if i.item_id.is_local() && !i.visibility.is_public() {\n+                if i.item_id.is_local() && i.visibility(self.tcx) != Some(Visibility::Public) {\n                     debug!(\"Stripper: stripping module {:?}\", i.name);\n                     let old = mem::replace(&mut self.update_retained, false);\n                     let ret = strip_item(self.fold_item_recur(i));\n@@ -146,30 +153,31 @@ impl<'a> DocFolder for Stripper<'a> {\n }\n \n /// This stripper discards all impls which reference stripped items\n-pub(crate) struct ImplStripper<'a> {\n+pub(crate) struct ImplStripper<'a, 'tcx> {\n+    pub(crate) tcx: TyCtxt<'tcx>,\n     pub(crate) retained: &'a ItemIdSet,\n     pub(crate) cache: &'a Cache,\n     pub(crate) is_json_output: bool,\n     pub(crate) document_private: bool,\n }\n \n-impl<'a> ImplStripper<'a> {\n+impl<'a> ImplStripper<'a, '_> {\n     #[inline]\n     fn should_keep_impl(&self, item: &Item, for_def_id: DefId) -> bool {\n         if !for_def_id.is_local() || self.retained.contains(&for_def_id.into()) {\n             true\n         } else if self.is_json_output {\n             // If the \"for\" item is exported and the impl block isn't `#[doc(hidden)]`, then we\n             // need to keep it.\n-            self.cache.effective_visibilities.is_exported(for_def_id)\n+            self.cache.effective_visibilities.is_exported(self.tcx, for_def_id)\n                 && !item.attrs.lists(sym::doc).has_word(sym::hidden)\n         } else {\n             false\n         }\n     }\n }\n \n-impl<'a> DocFolder for ImplStripper<'a> {\n+impl<'a> DocFolder for ImplStripper<'a, '_> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if let clean::ImplItem(ref imp) = *i.kind {\n             // Impl blocks can be skipped if they are: empty; not a trait impl; and have no\n@@ -185,6 +193,7 @@ impl<'a> DocFolder for ImplStripper<'a> {\n                         let item_id = i.item_id;\n                         item_id.is_local()\n                             && !is_item_reachable(\n+                                self.tcx,\n                                 self.is_json_output,\n                                 &self.cache.effective_visibilities,\n                                 item_id,\n@@ -229,12 +238,16 @@ impl<'a> DocFolder for ImplStripper<'a> {\n }\n \n /// This stripper discards all private import statements (`use`, `extern crate`)\n-pub(crate) struct ImportStripper;\n+pub(crate) struct ImportStripper<'tcx> {\n+    pub(crate) tcx: TyCtxt<'tcx>,\n+}\n \n-impl DocFolder for ImportStripper {\n+impl<'tcx> DocFolder for ImportStripper<'tcx> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         match *i.kind {\n-            clean::ExternCrateItem { .. } | clean::ImportItem(..) if !i.visibility.is_public() => {\n+            clean::ExternCrateItem { .. } | clean::ImportItem(..)\n+                if i.visibility(self.tcx) != Some(Visibility::Public) =>\n+            {\n                 None\n             }\n             _ => Some(self.fold_item_recur(i)),"}, {"sha": "c788b9f4093fea7721b838118443e16a71708ee1", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 21, "deletions": 34, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -7,15 +7,14 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::Node;\n use rustc_hir::CRATE_HIR_ID;\n-use rustc_middle::middle::privacy::Level;\n-use rustc_middle::ty::{TyCtxt, Visibility};\n+use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::{CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n \n use std::mem;\n \n-use crate::clean::{self, cfg::Cfg, AttributesExt, NestedAttributesExt};\n+use crate::clean::{cfg::Cfg, AttributesExt, NestedAttributesExt};\n use crate::core;\n \n /// This module is used to store stuff from Rust's AST in a more convenient\n@@ -26,8 +25,8 @@ pub(crate) struct Module<'hir> {\n     pub(crate) where_inner: Span,\n     pub(crate) mods: Vec<Module<'hir>>,\n     pub(crate) id: hir::HirId,\n-    // (item, renamed)\n-    pub(crate) items: Vec<(&'hir hir::Item<'hir>, Option<Symbol>)>,\n+    // (item, renamed, import_id)\n+    pub(crate) items: Vec<(&'hir hir::Item<'hir>, Option<Symbol>, Option<hir::HirId>)>,\n     pub(crate) foreigns: Vec<(&'hir hir::ForeignItem<'hir>, Option<Symbol>)>,\n }\n \n@@ -94,6 +93,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             hir::CRATE_HIR_ID,\n             self.cx.tcx.hir().root_module(),\n             self.cx.tcx.crate_name(LOCAL_CRATE),\n+            None,\n         );\n \n         // `#[macro_export] macro_rules!` items are reexported at the top level of the\n@@ -114,7 +114,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     if self.cx.tcx.has_attr(def_id, sym::macro_export) {\n                         if inserted.insert(def_id) {\n                             let item = self.cx.tcx.hir().expect_item(local_def_id);\n-                            top_level_module.items.push((item, None));\n+                            top_level_module.items.push((item, None, None));\n                         }\n                     }\n                 }\n@@ -156,6 +156,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         id: hir::HirId,\n         m: &'tcx hir::Mod<'tcx>,\n         name: Symbol,\n+        parent_id: Option<hir::HirId>,\n     ) -> Module<'tcx> {\n         let mut om = Module::new(name, id, m.spans.inner_span);\n         let def_id = self.cx.tcx.hir().local_def_id(id).to_def_id();\n@@ -167,15 +168,15 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             if matches!(item.kind, hir::ItemKind::Use(_, hir::UseKind::Glob)) {\n                 continue;\n             }\n-            self.visit_item(item, None, &mut om);\n+            self.visit_item(item, None, &mut om, parent_id);\n         }\n         for &i in m.item_ids {\n             let item = self.cx.tcx.hir().item(i);\n             // To match the way import precedence works, visit glob imports last.\n             // Later passes in rustdoc will de-duplicate by name and kind, so if glob-\n             // imported items appear last, then they'll be the ones that get discarded.\n             if matches!(item.kind, hir::ItemKind::Use(_, hir::UseKind::Glob)) {\n-                self.visit_item(item, None, &mut om);\n+                self.visit_item(item, None, &mut om, parent_id);\n             }\n         }\n         self.inside_public_path = orig_inside_public_path;\n@@ -221,23 +222,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         // made reachable by cross-crate inlining which we're checking here.\n         // (this is done here because we need to know this upfront).\n         if !res_did.is_local() && !is_no_inline {\n-            let attrs = clean::inline::load_attrs(self.cx, res_did);\n-            let self_is_hidden = attrs.lists(sym::doc).has_word(sym::hidden);\n-            if !self_is_hidden {\n-                if let Res::Def(kind, did) = res {\n-                    if kind == DefKind::Mod {\n-                        crate::visit_lib::LibEmbargoVisitor::new(self.cx).visit_mod(did)\n-                    } else {\n-                        // All items need to be handled here in case someone wishes to link\n-                        // to them with intra-doc links\n-                        self.cx.cache.effective_visibilities.set_public_at_level(\n-                            did,\n-                            || Visibility::Restricted(CRATE_DEF_ID),\n-                            Level::Direct,\n-                        );\n-                    }\n-                }\n-            }\n+            crate::visit_lib::lib_embargo_visit_item(self.cx, res_did);\n             return false;\n         }\n \n@@ -246,7 +231,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             None => return false,\n         };\n \n-        let is_private = !self.cx.cache.effective_visibilities.is_directly_public(res_did);\n+        let is_private =\n+            !self.cx.cache.effective_visibilities.is_directly_public(self.cx.tcx, res_did);\n         let is_hidden = inherits_doc_hidden(self.cx.tcx, res_hir_id);\n \n         // Only inline if requested or if the item would otherwise be stripped.\n@@ -263,14 +249,14 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 let prev = mem::replace(&mut self.inlining, true);\n                 for &i in m.item_ids {\n                     let i = self.cx.tcx.hir().item(i);\n-                    self.visit_item(i, None, om);\n+                    self.visit_item(i, None, om, Some(id));\n                 }\n                 self.inlining = prev;\n                 true\n             }\n             Node::Item(it) if !glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n-                self.visit_item(it, renamed, om);\n+                self.visit_item(it, renamed, om, Some(id));\n                 self.inlining = prev;\n                 true\n             }\n@@ -291,6 +277,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         item: &'tcx hir::Item<'_>,\n         renamed: Option<Symbol>,\n         om: &mut Module<'tcx>,\n+        parent_id: Option<hir::HirId>,\n     ) {\n         debug!(\"visiting item {:?}\", item);\n         let name = renamed.unwrap_or(item.ident.name);\n@@ -346,7 +333,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     }\n                 }\n \n-                om.items.push((item, renamed))\n+                om.items.push((item, renamed, parent_id))\n             }\n             hir::ItemKind::Macro(ref macro_def, _) => {\n                 // `#[macro_export] macro_rules!` items are handled separately in `visit()`,\n@@ -365,11 +352,11 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 let nonexported = !self.cx.tcx.has_attr(def_id, sym::macro_export);\n \n                 if is_macro_2_0 || nonexported || self.inlining {\n-                    om.items.push((item, renamed));\n+                    om.items.push((item, renamed, None));\n                 }\n             }\n             hir::ItemKind::Mod(ref m) => {\n-                om.mods.push(self.visit_mod_contents(item.hir_id(), m, name));\n+                om.mods.push(self.visit_mod_contents(item.hir_id(), m, name, parent_id));\n             }\n             hir::ItemKind::Fn(..)\n             | hir::ItemKind::ExternCrate(..)\n@@ -380,19 +367,19 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             | hir::ItemKind::OpaqueTy(..)\n             | hir::ItemKind::Static(..)\n             | hir::ItemKind::Trait(..)\n-            | hir::ItemKind::TraitAlias(..) => om.items.push((item, renamed)),\n+            | hir::ItemKind::TraitAlias(..) => om.items.push((item, renamed, parent_id)),\n             hir::ItemKind::Const(..) => {\n                 // Underscore constants do not correspond to a nameable item and\n                 // so are never useful in documentation.\n                 if name != kw::Underscore {\n-                    om.items.push((item, renamed));\n+                    om.items.push((item, renamed, parent_id));\n                 }\n             }\n             hir::ItemKind::Impl(impl_) => {\n                 // Don't duplicate impls when inlining or if it's implementing a trait, we'll pick\n                 // them up regardless of where they're located.\n                 if !self.inlining && impl_.of_trait.is_none() {\n-                    om.items.push((item, None));\n+                    om.items.push((item, None, None));\n                 }\n             }\n         }"}, {"sha": "e490559b0e92addd40d61d7f25f040749ffa4fb6", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 48, "deletions": 60, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -1,86 +1,74 @@\n+use crate::core::DocContext;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_ID};\n-use rustc_middle::middle::privacy::{EffectiveVisibilities, Level};\n-use rustc_middle::ty::{TyCtxt, Visibility};\n+use rustc_hir::def::DefKind;\n+use rustc_hir::def_id::DefId;\n+use rustc_middle::ty::TyCtxt;\n \n // FIXME: this may not be exhaustive, but is sufficient for rustdocs current uses\n \n+#[derive(Default)]\n+pub(crate) struct RustdocEffectiveVisibilities {\n+    extern_public: FxHashSet<DefId>,\n+}\n+\n+macro_rules! define_method {\n+    ($method:ident) => {\n+        pub(crate) fn $method(&self, tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+            match def_id.as_local() {\n+                Some(def_id) => tcx.effective_visibilities(()).$method(def_id),\n+                None => self.extern_public.contains(&def_id),\n+            }\n+        }\n+    };\n+}\n+\n+impl RustdocEffectiveVisibilities {\n+    define_method!(is_directly_public);\n+    define_method!(is_exported);\n+    define_method!(is_reachable);\n+}\n+\n+pub(crate) fn lib_embargo_visit_item(cx: &mut DocContext<'_>, def_id: DefId) {\n+    assert!(!def_id.is_local());\n+    LibEmbargoVisitor {\n+        tcx: cx.tcx,\n+        extern_public: &mut cx.cache.effective_visibilities.extern_public,\n+        visited_mods: Default::default(),\n+    }\n+    .visit_item(def_id)\n+}\n+\n /// Similar to `librustc_privacy::EmbargoVisitor`, but also takes\n /// specific rustdoc annotations into account (i.e., `doc(hidden)`)\n-pub(crate) struct LibEmbargoVisitor<'a, 'tcx> {\n+struct LibEmbargoVisitor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     // Effective visibilities for reachable nodes\n-    effective_visibilities: &'a mut EffectiveVisibilities<DefId>,\n-    // Previous level, None means unreachable\n-    prev_level: Option<Level>,\n+    extern_public: &'a mut FxHashSet<DefId>,\n     // Keeps track of already visited modules, in case a module re-exports its parent\n     visited_mods: FxHashSet<DefId>,\n }\n \n-impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n-    pub(crate) fn new(cx: &'a mut crate::core::DocContext<'tcx>) -> LibEmbargoVisitor<'a, 'tcx> {\n-        LibEmbargoVisitor {\n-            tcx: cx.tcx,\n-            effective_visibilities: &mut cx.cache.effective_visibilities,\n-            prev_level: Some(Level::Direct),\n-            visited_mods: FxHashSet::default(),\n-        }\n-    }\n-\n-    pub(crate) fn visit_lib(&mut self, cnum: CrateNum) {\n-        let did = cnum.as_def_id();\n-        self.update(did, Some(Level::Direct));\n-        self.visit_mod(did);\n-    }\n-\n-    // Updates node level and returns the updated level\n-    fn update(&mut self, did: DefId, level: Option<Level>) -> Option<Level> {\n-        let is_hidden = self.tcx.is_doc_hidden(did);\n-\n-        let old_level = self.effective_visibilities.public_at_level(did);\n-        // Visibility levels can only grow\n-        if level > old_level && !is_hidden {\n-            self.effective_visibilities.set_public_at_level(\n-                did,\n-                || Visibility::Restricted(CRATE_DEF_ID),\n-                level.unwrap(),\n-            );\n-            level\n-        } else {\n-            old_level\n-        }\n-    }\n-\n-    pub(crate) fn visit_mod(&mut self, def_id: DefId) {\n+impl LibEmbargoVisitor<'_, '_> {\n+    fn visit_mod(&mut self, def_id: DefId) {\n         if !self.visited_mods.insert(def_id) {\n             return;\n         }\n \n         for item in self.tcx.module_children(def_id).iter() {\n             if let Some(def_id) = item.res.opt_def_id() {\n-                if self.tcx.def_key(def_id).parent.map_or(false, |d| d == def_id.index)\n-                    || item.vis.is_public()\n-                {\n-                    self.visit_item(item.res);\n+                if item.vis.is_public() {\n+                    self.visit_item(def_id);\n                 }\n             }\n         }\n     }\n \n-    fn visit_item(&mut self, res: Res<!>) {\n-        let def_id = res.def_id();\n-        let vis = self.tcx.visibility(def_id);\n-        let inherited_item_level = if vis.is_public() { self.prev_level } else { None };\n-\n-        let item_level = self.update(def_id, inherited_item_level);\n-\n-        if let Res::Def(DefKind::Mod, _) = res {\n-            let orig_level = self.prev_level;\n-\n-            self.prev_level = item_level;\n-            self.visit_mod(def_id);\n-            self.prev_level = orig_level;\n+    fn visit_item(&mut self, def_id: DefId) {\n+        if !self.tcx.is_doc_hidden(def_id) {\n+            self.extern_public.insert(def_id);\n+            if self.tcx.def_kind(def_id) == DefKind::Mod {\n+                self.visit_mod(def_id);\n+            }\n         }\n     }\n }"}, {"sha": "2a2ea6b49e79325e0d10d33fac2b10ea3bebcc7c", "filename": "src/llvm-project", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm-project?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -1 +1 @@\n-Subproject commit 4b85255772114ca4946d95fe591933dae7d61991\n+Subproject commit 2a2ea6b49e79325e0d10d33fac2b10ea3bebcc7c"}, {"sha": "aa66c2ed08edb777fc24e53c76b870c99b93026d", "filename": "src/test/codegen/enum-bounds-check-derived-idx.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Ftest%2Fcodegen%2Fenum-bounds-check-derived-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Ftest%2Fcodegen%2Fenum-bounds-check-derived-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fenum-bounds-check-derived-idx.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -12,15 +12,13 @@ pub enum Bar {\n // CHECK-LABEL: @lookup_inc\n #[no_mangle]\n pub fn lookup_inc(buf: &[u8; 5], f: Bar) -> u8 {\n-    // FIXME: panic check can be removed by adding the assumes back after https://github.com/rust-lang/rust/pull/98332\n-    // CHECK: panic_bounds_check\n+    // CHECK-NOT: panic_bounds_check\n     buf[f as usize + 1]\n }\n \n // CHECK-LABEL: @lookup_dec\n #[no_mangle]\n pub fn lookup_dec(buf: &[u8; 5], f: Bar) -> u8 {\n-    // FIXME: panic check can be removed by adding the assumes back after https://github.com/rust-lang/rust/pull/98332\n-    // CHECK: panic_bounds_check\n+    // CHECK-NOT: panic_bounds_check\n     buf[f as usize - 1]\n }"}, {"sha": "b26945bc54940642ee5fc04aa5600bd13a8f87b4", "filename": "src/test/codegen/enum-bounds-check-issue-13926.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Ftest%2Fcodegen%2Fenum-bounds-check-issue-13926.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Ftest%2Fcodegen%2Fenum-bounds-check-issue-13926.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fenum-bounds-check-issue-13926.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -13,7 +13,6 @@ pub enum Exception {\n // CHECK-LABEL: @access\n #[no_mangle]\n pub fn access(array: &[usize; 12], exc: Exception) -> usize {\n-    // FIXME: panic check can be removed by adding the assumes back after https://github.com/rust-lang/rust/pull/98332\n-    // CHECK: panic_bounds_check\n+    // CHECK-NOT: panic_bounds_check\n     array[(exc as u8 - 4) as usize]\n }"}, {"sha": "17322d5911b9228ab1e66f35e4800d16f5b48613", "filename": "src/test/codegen/enum-bounds-check.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Ftest%2Fcodegen%2Fenum-bounds-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Ftest%2Fcodegen%2Fenum-bounds-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fenum-bounds-check.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -21,7 +21,6 @@ pub enum Bar {\n // CHECK-LABEL: @lookup_unmodified\n #[no_mangle]\n pub fn lookup_unmodified(buf: &[u8; 5], f: Bar) -> u8 {\n-    // FIXME: panic check can be removed by adding the assumes back after https://github.com/rust-lang/rust/pull/98332\n-    // CHECK: panic_bounds_check\n+    // CHECK-NOT: panic_bounds_check\n     buf[f as usize]\n }"}, {"sha": "93720503480881a3ccf0df16ae6e81bdeea30a90", "filename": "src/test/codegen/ffi-const.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Ftest%2Fcodegen%2Fffi-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Ftest%2Fcodegen%2Fffi-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fffi-const.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -7,6 +7,7 @@ pub fn bar() { unsafe { foo() } }\n extern \"C\" {\n     // CHECK-LABEL: declare{{.*}}void @foo()\n     // CHECK-SAME: [[ATTRS:#[0-9]+]]\n-    // CHECK-DAG: attributes [[ATTRS]] = { {{.*}}readnone{{.*}} }\n+    // The attribute changed from `readnone` to `memory(none)` with LLVM 16.0.\n+    // CHECK-DAG: attributes [[ATTRS]] = { {{.*}}{{readnone|memory\\(none\\)}}{{.*}} }\n     #[ffi_const] pub fn foo();\n }"}, {"sha": "2ed735813582f67138a6e92689509d06ae6c6b75", "filename": "src/test/codegen/ffi-pure.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Ftest%2Fcodegen%2Fffi-pure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Ftest%2Fcodegen%2Fffi-pure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fffi-pure.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -7,6 +7,7 @@ pub fn bar() { unsafe { foo() } }\n extern \"C\" {\n     // CHECK-LABEL: declare{{.*}}void @foo()\n     // CHECK-SAME: [[ATTRS:#[0-9]+]]\n-    // CHECK-DAG: attributes [[ATTRS]] = { {{.*}}readonly{{.*}} }\n+    // The attribute changed from `readonly` to `memory(read)` with LLVM 16.0.\n+    // CHECK-DAG: attributes [[ATTRS]] = { {{.*}}{{readonly|memory\\(read\\)}}{{.*}} }\n     #[ffi_pure] pub fn foo();\n }"}, {"sha": "a3499babea21b07d40c2b232d14ca2b986b1ce95", "filename": "src/test/codegen/issue-103285-ptr-addr-overflow-check.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Ftest%2Fcodegen%2Fissue-103285-ptr-addr-overflow-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Ftest%2Fcodegen%2Fissue-103285-ptr-addr-overflow-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fissue-103285-ptr-addr-overflow-check.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -0,0 +1,16 @@\n+// compile-flags: -O -C debug-assertions=yes\n+\n+#![crate_type = \"lib\"]\n+#![feature(strict_provenance)]\n+\n+#[no_mangle]\n+pub fn test(src: *const u8, dst: *const u8) -> usize {\n+    // CHECK-LABEL: @test(\n+    // CHECK-NOT: panic\n+    let src_usize = src.addr();\n+    let dst_usize = dst.addr();\n+    if src_usize > dst_usize {\n+        return src_usize - dst_usize;\n+    }\n+    return 0;\n+}"}, {"sha": "36402cc7353ff2c1cebf6ab71b79ce55c4e0eafe", "filename": "src/test/codegen/match-optimized.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Ftest%2Fcodegen%2Fmatch-optimized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Ftest%2Fcodegen%2Fmatch-optimized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fmatch-optimized.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -0,0 +1,60 @@\n+// compile-flags: -C no-prepopulate-passes -O\n+\n+#![crate_type = \"lib\"]\n+\n+pub enum E {\n+    A,\n+    B,\n+    C,\n+}\n+\n+// CHECK-LABEL: @exhaustive_match\n+#[no_mangle]\n+pub fn exhaustive_match(e: E) -> u8 {\n+// CHECK: switch{{.*}}, label %[[OTHERWISE:[a-zA-Z0-9_]+]] [\n+// CHECK-NEXT: i[[TY:[0-9]+]] [[DISCR:[0-9]+]], label %[[A:[a-zA-Z0-9_]+]]\n+// CHECK-NEXT: i[[TY:[0-9]+]] [[DISCR:[0-9]+]], label %[[B:[a-zA-Z0-9_]+]]\n+// CHECK-NEXT: i[[TY:[0-9]+]] [[DISCR:[0-9]+]], label %[[C:[a-zA-Z0-9_]+]]\n+// CHECK-NEXT: ]\n+// CHECK: [[OTHERWISE]]:\n+// CHECK-NEXT: unreachable\n+//\n+// CHECK: [[A]]:\n+// CHECK-NEXT: store i8 0, {{i8\\*|ptr}} %1, align 1\n+// CHECK-NEXT: br label %[[EXIT:[a-zA-Z0-9_]+]]\n+// CHECK: [[B]]:\n+// CHECK-NEXT: store i8 1, {{i8\\*|ptr}} %1, align 1\n+// CHECK-NEXT: br label %[[EXIT]]\n+// CHECK: [[C]]:\n+// CHECK-NEXT: store i8 2, {{i8\\*|ptr}} %1, align 1\n+// CHECK-NEXT: br label %[[EXIT]]\n+    match e {\n+        E::A => 0,\n+        E::B => 1,\n+        E::C => 2,\n+    }\n+}\n+\n+#[repr(u16)]\n+pub enum E2 {\n+    A = 13,\n+    B = 42,\n+}\n+\n+// For optimized code we produce a switch with an unreachable target as the `otherwise` so LLVM\n+// knows the possible values. Compare with `src/test/codegen/match-unoptimized.rs`.\n+\n+// CHECK-LABEL: @exhaustive_match_2\n+#[no_mangle]\n+pub fn exhaustive_match_2(e: E2) -> u8 {\n+    // CHECK: switch i16 %{{.+}}, label %[[UNREACH:.+]] [\n+    // CHECK-NEXT: i16 13,\n+    // CHECK-NEXT: i16 42,\n+    // CHECK-NEXT: ]\n+    // CHECK: [[UNREACH]]:\n+    // CHECK-NEXT: unreachable\n+    match e {\n+        E2::A => 0,\n+        E2::B => 1,\n+    }\n+}"}, {"sha": "be40b29e3d3e1a7fbd5b0b7b92d9ae59818092ed", "filename": "src/test/codegen/match-unoptimized.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Ftest%2Fcodegen%2Fmatch-unoptimized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83239c2c1ebed372dd34016bdd75d02e4429589d/src%2Ftest%2Fcodegen%2Fmatch-unoptimized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fmatch-unoptimized.rs?ref=83239c2c1ebed372dd34016bdd75d02e4429589d", "patch": "@@ -0,0 +1,23 @@\n+// compile-flags: -C no-prepopulate-passes -Copt-level=0\n+\n+#![crate_type = \"lib\"]\n+\n+#[repr(u16)]\n+pub enum E2 {\n+    A = 13,\n+    B = 42,\n+}\n+\n+// For unoptimized code we produce a `br` instead of a `switch`. Compare with\n+// `src/test/codegen/match-optimized.rs`\n+\n+// CHECK-LABEL: @exhaustive_match_2\n+#[no_mangle]\n+pub fn exhaustive_match_2(e: E2) -> u8 {\n+    // CHECK: %[[CMP:.+]] = icmp eq i16 %{{.+}}, 13\n+    // CHECK-NEXT: br i1 %[[CMP:.+]],\n+    match e {\n+        E2::A => 0,\n+        E2::B => 1,\n+    }\n+}"}, {"sha": "b203641fddbd051b62a88131fc43105b4a6ea007", "filename": "src/test/codegen/match.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4492c029eff7b42e91e759576ab0c7ca88f873dc/src%2Ftest%2Fcodegen%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4492c029eff7b42e91e759576ab0c7ca88f873dc/src%2Ftest%2Fcodegen%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fmatch.rs?ref=4492c029eff7b42e91e759576ab0c7ca88f873dc", "patch": "@@ -1,29 +0,0 @@\n-// compile-flags: -C no-prepopulate-passes\n-\n-#![crate_type = \"lib\"]\n-\n-pub enum E {\n-    A,\n-    B,\n-}\n-\n-// CHECK-LABEL: @exhaustive_match\n-#[no_mangle]\n-pub fn exhaustive_match(e: E) -> u8 {\n-// CHECK: switch{{.*}}, label %[[OTHERWISE:[a-zA-Z0-9_]+]] [\n-// CHECK-NEXT: i[[TY:[0-9]+]] [[DISCR:[0-9]+]], label %[[A:[a-zA-Z0-9_]+]]\n-// CHECK-NEXT: i[[TY:[0-9]+]] [[DISCR:[0-9]+]], label %[[B:[a-zA-Z0-9_]+]]\n-// CHECK-NEXT: ]\n-// CHECK: [[OTHERWISE]]:\n-// CHECK-NEXT: unreachable\n-// CHECK: [[A]]:\n-// CHECK-NEXT: store i8 0, {{i8\\*|ptr}} %1, align 1\n-// CHECK-NEXT: br label %[[EXIT:[a-zA-Z0-9_]+]]\n-// CHECK: [[B]]:\n-// CHECK-NEXT: store i8 1, {{i8\\*|ptr}} %1, align 1\n-// CHECK-NEXT: br label %[[EXIT:[a-zA-Z0-9_]+]]\n-    match e {\n-        E::A => 0,\n-        E::B => 1,\n-    }\n-}"}]}