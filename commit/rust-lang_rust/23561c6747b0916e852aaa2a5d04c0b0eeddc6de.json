{"sha": "23561c6747b0916e852aaa2a5d04c0b0eeddc6de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzNTYxYzY3NDdiMDkxNmU4NTJhYWEyYTVkMDRjMGIwZWVkZGM2ZGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-18T05:54:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-18T05:54:21Z"}, "message": "Auto merge of #49972 - Mark-Simulacrum:remove-build, r=alexcrichton\n\nRemove uses of Build across Builder steps\n\nThis is purely a code cleanup; there should be no functional changes.\n\nr? @alexcrichton", "tree": {"sha": "d22845749813e306c2c3deee336e051a43e743c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d22845749813e306c2c3deee336e051a43e743c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/23561c6747b0916e852aaa2a5d04c0b0eeddc6de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/23561c6747b0916e852aaa2a5d04c0b0eeddc6de", "html_url": "https://github.com/rust-lang/rust/commit/23561c6747b0916e852aaa2a5d04c0b0eeddc6de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/23561c6747b0916e852aaa2a5d04c0b0eeddc6de/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dcb44ca2f7ff8b4092750eb98f02ac4f9a2bfbe9", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcb44ca2f7ff8b4092750eb98f02ac4f9a2bfbe9", "html_url": "https://github.com/rust-lang/rust/commit/dcb44ca2f7ff8b4092750eb98f02ac4f9a2bfbe9"}, {"sha": "be1e7893d5a3174ab9347b6b3de0fa607aec4f9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/be1e7893d5a3174ab9347b6b3de0fa607aec4f9f", "html_url": "https://github.com/rust-lang/rust/commit/be1e7893d5a3174ab9347b6b3de0fa607aec4f9f"}], "stats": {"total": 1812, "additions": 873, "deletions": 939}, "files": [{"sha": "20c89f99b2b0c9af40b860fa441333d9c4949bca", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/23561c6747b0916e852aaa2a5d04c0b0eeddc6de/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23561c6747b0916e852aaa2a5d04c0b0eeddc6de/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=23561c6747b0916e852aaa2a5d04c0b0eeddc6de", "patch": "@@ -154,18 +154,17 @@ impl StepDescription {\n             eprintln!(\"{:?} not skipped for {:?} -- not in {:?}\", pathset,\n                 self.name, builder.config.exclude);\n         }\n-        let build = builder.build;\n-        let hosts = &build.hosts;\n+        let hosts = &builder.hosts;\n \n         // Determine the targets participating in this rule.\n         let targets = if self.only_hosts {\n-            if !build.config.run_host_only {\n+            if !builder.config.run_host_only {\n                 return; // don't run anything\n             } else {\n-                &build.hosts\n+                &builder.hosts\n             }\n         } else {\n-            &build.targets\n+            &builder.targets\n         };\n \n         for host in hosts {\n@@ -476,7 +475,7 @@ impl<'a> Builder<'a> {\n \n     pub fn sysroot_codegen_backends(&self, compiler: Compiler) -> PathBuf {\n         self.sysroot_libdir(compiler, compiler.host)\n-            .with_file_name(self.build.config.rust_codegen_backends_dir.clone())\n+            .with_file_name(self.config.rust_codegen_backends_dir.clone())\n     }\n \n     /// Returns the compiler's libdir where it stores the dynamic libraries that\n@@ -486,7 +485,7 @@ impl<'a> Builder<'a> {\n     /// Windows.\n     pub fn rustc_libdir(&self, compiler: Compiler) -> PathBuf {\n         if compiler.is_snapshot(self) {\n-            self.build.rustc_snapshot_libdir()\n+            self.rustc_snapshot_libdir()\n         } else {\n             self.sysroot(compiler).join(libdir(&compiler.host))\n         }\n@@ -523,12 +522,12 @@ impl<'a> Builder<'a> {\n         let compiler = self.compiler(self.top_stage, host);\n         cmd.env(\"RUSTC_STAGE\", compiler.stage.to_string())\n            .env(\"RUSTC_SYSROOT\", self.sysroot(compiler))\n-           .env(\"RUSTDOC_LIBDIR\", self.sysroot_libdir(compiler, self.build.build))\n-           .env(\"CFG_RELEASE_CHANNEL\", &self.build.config.channel)\n+           .env(\"RUSTDOC_LIBDIR\", self.sysroot_libdir(compiler, self.config.build))\n+           .env(\"CFG_RELEASE_CHANNEL\", &self.config.channel)\n            .env(\"RUSTDOC_REAL\", self.rustdoc(host))\n-           .env(\"RUSTDOC_CRATE_VERSION\", self.build.rust_version())\n+           .env(\"RUSTDOC_CRATE_VERSION\", self.rust_version())\n            .env(\"RUSTC_BOOTSTRAP\", \"1\");\n-        if let Some(linker) = self.build.linker(host) {\n+        if let Some(linker) = self.linker(host) {\n             cmd.env(\"RUSTC_TARGET_LINKER\", linker);\n         }\n         cmd\n@@ -609,17 +608,17 @@ impl<'a> Builder<'a> {\n              .env(\"TEST_MIRI\", self.config.test_miri.to_string())\n              .env(\"RUSTC_ERROR_METADATA_DST\", self.extended_error_dir());\n \n-        if let Some(host_linker) = self.build.linker(compiler.host) {\n+        if let Some(host_linker) = self.linker(compiler.host) {\n             cargo.env(\"RUSTC_HOST_LINKER\", host_linker);\n         }\n-        if let Some(target_linker) = self.build.linker(target) {\n+        if let Some(target_linker) = self.linker(target) {\n             cargo.env(\"RUSTC_TARGET_LINKER\", target_linker);\n         }\n         if let Some(ref error_format) = self.config.rustc_error_format {\n             cargo.env(\"RUSTC_ERROR_FORMAT\", error_format);\n         }\n         if cmd != \"build\" && cmd != \"check\" {\n-            cargo.env(\"RUSTDOC_LIBDIR\", self.rustc_libdir(self.compiler(2, self.build.build)));\n+            cargo.env(\"RUSTDOC_LIBDIR\", self.rustc_libdir(self.compiler(2, self.config.build)));\n         }\n \n         if mode == Mode::Tool {\n@@ -677,7 +676,7 @@ impl<'a> Builder<'a> {\n         //\n         // If LLVM support is disabled we need to use the snapshot compiler to compile\n         // build scripts, as the new compiler doesn't support executables.\n-        if mode == Mode::Libstd || !self.build.config.llvm_enabled {\n+        if mode == Mode::Libstd || !self.config.llvm_enabled {\n             cargo.env(\"RUSTC_SNAPSHOT\", &self.initial_rustc)\n                  .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_snapshot_libdir());\n         } else {\n@@ -761,15 +760,15 @@ impl<'a> Builder<'a> {\n         }\n \n         // For `cargo doc` invocations, make rustdoc print the Rust version into the docs\n-        cargo.env(\"RUSTDOC_CRATE_VERSION\", self.build.rust_version());\n+        cargo.env(\"RUSTDOC_CRATE_VERSION\", self.rust_version());\n \n         // Environment variables *required* throughout the build\n         //\n         // FIXME: should update code to not require this env var\n         cargo.env(\"CFG_COMPILER_HOST_TRIPLE\", target);\n \n         // Set this for all builds to make sure doc builds also get it.\n-        cargo.env(\"CFG_RELEASE_CHANNEL\", &self.build.config.channel);\n+        cargo.env(\"CFG_RELEASE_CHANNEL\", &self.config.channel);\n \n         // This one's a bit tricky. As of the time of this writing the compiler\n         // links to the `winapi` crate on crates.io. This crate provides raw\n@@ -854,7 +853,7 @@ impl<'a> Builder<'a> {\n                 panic!(out);\n             }\n             if let Some(out) = self.cache.get(&step) {\n-                self.build.verbose(&format!(\"{}c {:?}\", \"  \".repeat(stack.len()), step));\n+                self.verbose(&format!(\"{}c {:?}\", \"  \".repeat(stack.len()), step));\n \n                 {\n                     let mut graph = self.graph.borrow_mut();\n@@ -869,7 +868,7 @@ impl<'a> Builder<'a> {\n \n                 return out;\n             }\n-            self.build.verbose(&format!(\"{}> {:?}\", \"  \".repeat(stack.len()), step));\n+            self.verbose(&format!(\"{}> {:?}\", \"  \".repeat(stack.len()), step));\n             stack.push(Box::new(step.clone()));\n         }\n \n@@ -899,7 +898,7 @@ impl<'a> Builder<'a> {\n \n         self.parent.set(prev_parent);\n \n-        if self.build.config.print_step_timings && dur > Duration::from_millis(100) {\n+        if self.config.print_step_timings && dur > Duration::from_millis(100) {\n             println!(\"[TIMING] {:?} -- {}.{:03}\",\n                      step,\n                      dur.as_secs(),\n@@ -911,7 +910,7 @@ impl<'a> Builder<'a> {\n             let cur_step = stack.pop().expect(\"step stack empty\");\n             assert_eq!(cur_step.downcast_ref(), Some(&step));\n         }\n-        self.build.verbose(&format!(\"{}< {:?}\", \"  \".repeat(self.stack.borrow().len()), step));\n+        self.verbose(&format!(\"{}< {:?}\", \"  \".repeat(self.stack.borrow().len()), step));\n         self.cache.put(step, out.clone());\n         out\n     }"}, {"sha": "adebd424d7eb644ea028935460cd07628aec7ce2", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 30, "deletions": 33, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/23561c6747b0916e852aaa2a5d04c0b0eeddc6de/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23561c6747b0916e852aaa2a5d04c0b0eeddc6de/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=23561c6747b0916e852aaa2a5d04c0b0eeddc6de", "patch": "@@ -12,7 +12,7 @@\n \n use compile::{run_cargo, std_cargo, test_cargo, rustc_cargo, add_to_sysroot};\n use builder::{RunConfig, Builder, ShouldRun, Step};\n-use {Build, Compiler, Mode};\n+use {Compiler, Mode};\n use cache::Interned;\n use std::path::PathBuf;\n \n@@ -36,24 +36,23 @@ impl Step for Std {\n     }\n \n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let target = self.target;\n-        let compiler = builder.compiler(0, build.build);\n+        let compiler = builder.compiler(0, builder.config.build);\n \n-        let out_dir = build.stage_out(compiler, Mode::Libstd);\n-        build.clear_if_dirty(&out_dir, &builder.rustc(compiler));\n+        let out_dir = builder.stage_out(compiler, Mode::Libstd);\n+        builder.clear_if_dirty(&out_dir, &builder.rustc(compiler));\n         let mut cargo = builder.cargo(compiler, Mode::Libstd, target, \"check\");\n         std_cargo(builder, &compiler, target, &mut cargo);\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n+        let _folder = builder.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n         println!(\"Checking std artifacts ({} -> {})\", &compiler.host, target);\n-        run_cargo(build,\n+        run_cargo(builder,\n                   &mut cargo,\n-                  &libstd_stamp(build, compiler, target),\n+                  &libstd_stamp(builder, compiler, target),\n                   true);\n \n         let libdir = builder.sysroot_libdir(compiler, target);\n-        add_to_sysroot(&build, &libdir, &libstd_stamp(build, compiler, target));\n+        add_to_sysroot(&builder, &libdir, &libstd_stamp(builder, compiler, target));\n     }\n }\n \n@@ -83,26 +82,25 @@ impl Step for Rustc {\n     /// the `compiler` targeting the `target` architecture. The artifacts\n     /// created will also be linked into the sysroot directory.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let compiler = builder.compiler(0, build.build);\n+        let compiler = builder.compiler(0, builder.config.build);\n         let target = self.target;\n \n         let stage_out = builder.stage_out(compiler, Mode::Librustc);\n-        build.clear_if_dirty(&stage_out, &libstd_stamp(build, compiler, target));\n-        build.clear_if_dirty(&stage_out, &libtest_stamp(build, compiler, target));\n+        builder.clear_if_dirty(&stage_out, &libstd_stamp(builder, compiler, target));\n+        builder.clear_if_dirty(&stage_out, &libtest_stamp(builder, compiler, target));\n \n         let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"check\");\n-        rustc_cargo(build, &mut cargo);\n+        rustc_cargo(builder, &mut cargo);\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-rustc\", compiler.stage));\n+        let _folder = builder.fold_output(|| format!(\"stage{}-rustc\", compiler.stage));\n         println!(\"Checking compiler artifacts ({} -> {})\", &compiler.host, target);\n-        run_cargo(build,\n+        run_cargo(builder,\n                   &mut cargo,\n-                  &librustc_stamp(build, compiler, target),\n+                  &librustc_stamp(builder, compiler, target),\n                   true);\n \n         let libdir = builder.sysroot_libdir(compiler, target);\n-        add_to_sysroot(&build, &libdir, &librustc_stamp(build, compiler, target));\n+        add_to_sysroot(&builder, &libdir, &librustc_stamp(builder, compiler, target));\n     }\n }\n \n@@ -126,41 +124,40 @@ impl Step for Test {\n     }\n \n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let target = self.target;\n-        let compiler = builder.compiler(0, build.build);\n+        let compiler = builder.compiler(0, builder.config.build);\n \n-        let out_dir = build.stage_out(compiler, Mode::Libtest);\n-        build.clear_if_dirty(&out_dir, &libstd_stamp(build, compiler, target));\n+        let out_dir = builder.stage_out(compiler, Mode::Libtest);\n+        builder.clear_if_dirty(&out_dir, &libstd_stamp(builder, compiler, target));\n         let mut cargo = builder.cargo(compiler, Mode::Libtest, target, \"check\");\n-        test_cargo(build, &compiler, target, &mut cargo);\n+        test_cargo(builder, &compiler, target, &mut cargo);\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n+        let _folder = builder.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n         println!(\"Checking test artifacts ({} -> {})\", &compiler.host, target);\n-        run_cargo(build,\n+        run_cargo(builder,\n                   &mut cargo,\n-                  &libtest_stamp(build, compiler, target),\n+                  &libtest_stamp(builder, compiler, target),\n                   true);\n \n         let libdir = builder.sysroot_libdir(compiler, target);\n-        add_to_sysroot(&build, &libdir, &libtest_stamp(build, compiler, target));\n+        add_to_sysroot(builder, &libdir, &libtest_stamp(builder, compiler, target));\n     }\n }\n \n /// Cargo's output path for the standard library in a given stage, compiled\n /// by a particular compiler for the specified target.\n-pub fn libstd_stamp(build: &Build, compiler: Compiler, target: Interned<String>) -> PathBuf {\n-    build.cargo_out(compiler, Mode::Libstd, target).join(\".libstd-check.stamp\")\n+pub fn libstd_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+    builder.cargo_out(compiler, Mode::Libstd, target).join(\".libstd-check.stamp\")\n }\n \n /// Cargo's output path for libtest in a given stage, compiled by a particular\n /// compiler for the specified target.\n-pub fn libtest_stamp(build: &Build, compiler: Compiler, target: Interned<String>) -> PathBuf {\n-    build.cargo_out(compiler, Mode::Libtest, target).join(\".libtest-check.stamp\")\n+pub fn libtest_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+    builder.cargo_out(compiler, Mode::Libtest, target).join(\".libtest-check.stamp\")\n }\n \n /// Cargo's output path for librustc in a given stage, compiled by a particular\n /// compiler for the specified target.\n-pub fn librustc_stamp(build: &Build, compiler: Compiler, target: Interned<String>) -> PathBuf {\n-    build.cargo_out(compiler, Mode::Librustc, target).join(\".librustc-check.stamp\")\n+pub fn librustc_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+    builder.cargo_out(compiler, Mode::Librustc, target).join(\".librustc-check.stamp\")\n }"}, {"sha": "07bce77af8d24083844f26e173cdb4604829c4a4", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 143, "deletions": 152, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/23561c6747b0916e852aaa2a5d04c0b0eeddc6de/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23561c6747b0916e852aaa2a5d04c0b0eeddc6de/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=23561c6747b0916e852aaa2a5d04c0b0eeddc6de", "patch": "@@ -31,7 +31,7 @@ use filetime::FileTime;\n use serde_json;\n \n use util::{exe, libdir, is_dylib, CiEnv};\n-use {Build, Compiler, Mode};\n+use {Compiler, Mode};\n use native;\n use tool;\n \n@@ -65,14 +65,13 @@ impl Step for Std {\n     /// using the `compiler` targeting the `target` architecture. The artifacts\n     /// created will also be linked into the sysroot directory.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let target = self.target;\n         let compiler = self.compiler;\n \n         builder.ensure(StartupObjects { compiler, target });\n \n-        if build.force_use_stage1(compiler, target) {\n-            let from = builder.compiler(1, build.build);\n+        if builder.force_use_stage1(compiler, target) {\n+            let from = builder.compiler(1, builder.config.build);\n             builder.ensure(Std {\n                 compiler: from,\n                 target,\n@@ -83,7 +82,7 @@ impl Step for Std {\n             // still contain the musl startup objects.\n             if target.contains(\"musl\") {\n                 let libdir = builder.sysroot_libdir(compiler, target);\n-                copy_musl_third_party_objects(build, target, &libdir);\n+                copy_musl_third_party_objects(builder, target, &libdir);\n             }\n \n             builder.ensure(StdLink {\n@@ -96,24 +95,24 @@ impl Step for Std {\n \n         if target.contains(\"musl\") {\n             let libdir = builder.sysroot_libdir(compiler, target);\n-            copy_musl_third_party_objects(build, target, &libdir);\n+            copy_musl_third_party_objects(builder, target, &libdir);\n         }\n \n-        let out_dir = build.cargo_out(compiler, Mode::Libstd, target);\n-        build.clear_if_dirty(&out_dir, &builder.rustc(compiler));\n+        let out_dir = builder.cargo_out(compiler, Mode::Libstd, target);\n+        builder.clear_if_dirty(&out_dir, &builder.rustc(compiler));\n         let mut cargo = builder.cargo(compiler, Mode::Libstd, target, \"build\");\n         std_cargo(builder, &compiler, target, &mut cargo);\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n-        build.info(&format!(\"Building stage{} std artifacts ({} -> {})\", compiler.stage,\n+        let _folder = builder.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n+        builder.info(&format!(\"Building stage{} std artifacts ({} -> {})\", compiler.stage,\n                 &compiler.host, target));\n-        run_cargo(build,\n+        run_cargo(builder,\n                   &mut cargo,\n-                  &libstd_stamp(build, compiler, target),\n+                  &libstd_stamp(builder, compiler, target),\n                   false);\n \n         builder.ensure(StdLink {\n-            compiler: builder.compiler(compiler.stage, build.build),\n+            compiler: builder.compiler(compiler.stage, builder.config.build),\n             target_compiler: compiler,\n             target,\n         });\n@@ -126,70 +125,70 @@ impl Step for Std {\n /// with a glibc-targeting toolchain, given we have the appropriate startup\n /// files. As those shipped with glibc won't work, copy the ones provided by\n /// musl so we have them on linux-gnu hosts.\n-fn copy_musl_third_party_objects(build: &Build,\n+fn copy_musl_third_party_objects(builder: &Builder,\n                                  target: Interned<String>,\n                                  into: &Path) {\n     for &obj in &[\"crt1.o\", \"crti.o\", \"crtn.o\"] {\n-        build.copy(&build.musl_root(target).unwrap().join(\"lib\").join(obj), &into.join(obj));\n+        builder.copy(&builder.musl_root(target).unwrap().join(\"lib\").join(obj), &into.join(obj));\n     }\n }\n \n /// Configure cargo to compile the standard library, adding appropriate env vars\n /// and such.\n-pub fn std_cargo(build: &Builder,\n+pub fn std_cargo(builder: &Builder,\n                  compiler: &Compiler,\n                  target: Interned<String>,\n                  cargo: &mut Command) {\n     if let Some(target) = env::var_os(\"MACOSX_STD_DEPLOYMENT_TARGET\") {\n         cargo.env(\"MACOSX_DEPLOYMENT_TARGET\", target);\n     }\n \n-    if build.no_std(target) == Some(true) {\n+    if builder.no_std(target) == Some(true) {\n         // for no-std targets we only compile a few no_std crates\n         cargo.arg(\"--features\").arg(\"c mem\")\n             .args(&[\"-p\", \"alloc\"])\n             .args(&[\"-p\", \"compiler_builtins\"])\n             .args(&[\"-p\", \"std_unicode\"])\n             .arg(\"--manifest-path\")\n-            .arg(build.src.join(\"src/rustc/compiler_builtins_shim/Cargo.toml\"));\n+            .arg(builder.src.join(\"src/rustc/compiler_builtins_shim/Cargo.toml\"));\n     } else {\n-        let mut features = build.std_features();\n+        let mut features = builder.std_features();\n \n         // When doing a local rebuild we tell cargo that we're stage1 rather than\n         // stage0. This works fine if the local rust and being-built rust have the\n         // same view of what the default allocator is, but fails otherwise. Since\n         // we don't have a way to express an allocator preference yet, work\n         // around the issue in the case of a local rebuild with jemalloc disabled.\n-        if compiler.stage == 0 && build.local_rebuild && !build.config.use_jemalloc {\n+        if compiler.stage == 0 && builder.local_rebuild && !builder.config.use_jemalloc {\n             features.push_str(\" force_alloc_system\");\n         }\n \n-        if compiler.stage != 0 && build.config.sanitizers {\n+        if compiler.stage != 0 && builder.config.sanitizers {\n             // This variable is used by the sanitizer runtime crates, e.g.\n             // rustc_lsan, to build the sanitizer runtime from C code\n             // When this variable is missing, those crates won't compile the C code,\n             // so we don't set this variable during stage0 where llvm-config is\n             // missing\n             // We also only build the runtimes when --enable-sanitizers (or its\n             // config.toml equivalent) is used\n-            let llvm_config = build.ensure(native::Llvm {\n-                target: build.config.build,\n+            let llvm_config = builder.ensure(native::Llvm {\n+                target: builder.config.build,\n                 emscripten: false,\n             });\n             cargo.env(\"LLVM_CONFIG\", llvm_config);\n         }\n \n         cargo.arg(\"--features\").arg(features)\n             .arg(\"--manifest-path\")\n-            .arg(build.src.join(\"src/libstd/Cargo.toml\"));\n+            .arg(builder.src.join(\"src/libstd/Cargo.toml\"));\n \n-        if let Some(target) = build.config.target_config.get(&target) {\n+        if let Some(target) = builder.config.target_config.get(&target) {\n             if let Some(ref jemalloc) = target.jemalloc {\n                 cargo.env(\"JEMALLOC_OVERRIDE\", jemalloc);\n             }\n         }\n         if target.contains(\"musl\") {\n-            if let Some(p) = build.musl_root(target) {\n+            if let Some(p) = builder.musl_root(target) {\n                 cargo.env(\"MUSL_ROOT\", p);\n             }\n         }\n@@ -219,24 +218,23 @@ impl Step for StdLink {\n     /// libraries for `target`, and this method will find them in the relevant\n     /// output directory.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let compiler = self.compiler;\n         let target_compiler = self.target_compiler;\n         let target = self.target;\n-        build.info(&format!(\"Copying stage{} std from stage{} ({} -> {} / {})\",\n+        builder.info(&format!(\"Copying stage{} std from stage{} ({} -> {} / {})\",\n                 target_compiler.stage,\n                 compiler.stage,\n                 &compiler.host,\n                 target_compiler.host,\n                 target));\n         let libdir = builder.sysroot_libdir(target_compiler, target);\n-        add_to_sysroot(&build, &libdir, &libstd_stamp(build, compiler, target));\n+        add_to_sysroot(builder, &libdir, &libstd_stamp(builder, compiler, target));\n \n-        if build.config.sanitizers && compiler.stage != 0 && target == \"x86_64-apple-darwin\" {\n+        if builder.config.sanitizers && compiler.stage != 0 && target == \"x86_64-apple-darwin\" {\n             // The sanitizers are only built in stage1 or above, so the dylibs will\n             // be missing in stage0 and causes panic. See the `std()` function above\n             // for reason why the sanitizers are not built in stage0.\n-            copy_apple_sanitizer_dylibs(&build, &build.native_dir(target), \"osx\", &libdir);\n+            copy_apple_sanitizer_dylibs(builder, &builder.native_dir(target), \"osx\", &libdir);\n         }\n \n         builder.ensure(tool::CleanTools {\n@@ -247,15 +245,15 @@ impl Step for StdLink {\n     }\n }\n \n-fn copy_apple_sanitizer_dylibs(build: &Build, native_dir: &Path, platform: &str, into: &Path) {\n+fn copy_apple_sanitizer_dylibs(builder: &Builder, native_dir: &Path, platform: &str, into: &Path) {\n     for &sanitizer in &[\"asan\", \"tsan\"] {\n         let filename = format!(\"libclang_rt.{}_{}_dynamic.dylib\", sanitizer, platform);\n         let mut src_path = native_dir.join(sanitizer);\n         src_path.push(\"build\");\n         src_path.push(\"lib\");\n         src_path.push(\"darwin\");\n         src_path.push(&filename);\n-        build.copy(&src_path, &into.join(filename));\n+        builder.copy(&src_path, &into.join(filename));\n     }\n }\n \n@@ -286,40 +284,39 @@ impl Step for StartupObjects {\n     /// files, so we just use the nightly snapshot compiler to always build them (as\n     /// no other compilers are guaranteed to be available).\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let for_compiler = self.compiler;\n         let target = self.target;\n         if !target.contains(\"pc-windows-gnu\") {\n             return\n         }\n \n-        let src_dir = &build.src.join(\"src/rtstartup\");\n-        let dst_dir = &build.native_dir(target).join(\"rtstartup\");\n+        let src_dir = &builder.src.join(\"src/rtstartup\");\n+        let dst_dir = &builder.native_dir(target).join(\"rtstartup\");\n         let sysroot_dir = &builder.sysroot_libdir(for_compiler, target);\n         t!(fs::create_dir_all(dst_dir));\n \n         for file in &[\"rsbegin\", \"rsend\"] {\n             let src_file = &src_dir.join(file.to_string() + \".rs\");\n             let dst_file = &dst_dir.join(file.to_string() + \".o\");\n             if !up_to_date(src_file, dst_file) {\n-                let mut cmd = Command::new(&build.initial_rustc);\n-                build.run(cmd.env(\"RUSTC_BOOTSTRAP\", \"1\")\n+                let mut cmd = Command::new(&builder.initial_rustc);\n+                builder.run(cmd.env(\"RUSTC_BOOTSTRAP\", \"1\")\n                             .arg(\"--cfg\").arg(\"stage0\")\n                             .arg(\"--target\").arg(target)\n                             .arg(\"--emit=obj\")\n                             .arg(\"-o\").arg(dst_file)\n                             .arg(src_file));\n             }\n \n-            build.copy(dst_file, &sysroot_dir.join(file.to_string() + \".o\"));\n+            builder.copy(dst_file, &sysroot_dir.join(file.to_string() + \".o\"));\n         }\n \n         for obj in [\"crt2.o\", \"dllcrt2.o\"].iter() {\n-            let src = compiler_file(build,\n-                                    build.cc(target),\n+            let src = compiler_file(builder,\n+                                    builder.cc(target),\n                                     target,\n                                     obj);\n-            build.copy(&src, &sysroot_dir.join(obj));\n+            builder.copy(&src, &sysroot_dir.join(obj));\n         }\n     }\n }\n@@ -351,57 +348,57 @@ impl Step for Test {\n     /// the build using the `compiler` targeting the `target` architecture. The\n     /// artifacts created will also be linked into the sysroot directory.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let target = self.target;\n         let compiler = self.compiler;\n \n         builder.ensure(Std { compiler, target });\n \n-        if build.force_use_stage1(compiler, target) {\n+        if builder.force_use_stage1(compiler, target) {\n             builder.ensure(Test {\n-                compiler: builder.compiler(1, build.build),\n+                compiler: builder.compiler(1, builder.config.build),\n                 target,\n             });\n-            build.info(&format!(\"Uplifting stage1 test ({} -> {})\", &build.build, target));\n+            builder.info(\n+                &format!(\"Uplifting stage1 test ({} -> {})\", builder.config.build, target));\n             builder.ensure(TestLink {\n-                compiler: builder.compiler(1, build.build),\n+                compiler: builder.compiler(1, builder.config.build),\n                 target_compiler: compiler,\n                 target,\n             });\n             return;\n         }\n \n-        let out_dir = build.cargo_out(compiler, Mode::Libtest, target);\n-        build.clear_if_dirty(&out_dir, &libstd_stamp(build, compiler, target));\n+        let out_dir = builder.cargo_out(compiler, Mode::Libtest, target);\n+        builder.clear_if_dirty(&out_dir, &libstd_stamp(builder, compiler, target));\n         let mut cargo = builder.cargo(compiler, Mode::Libtest, target, \"build\");\n-        test_cargo(build, &compiler, target, &mut cargo);\n+        test_cargo(builder, &compiler, target, &mut cargo);\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n-        build.info(&format!(\"Building stage{} test artifacts ({} -> {})\", compiler.stage,\n+        let _folder = builder.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n+        builder.info(&format!(\"Building stage{} test artifacts ({} -> {})\", compiler.stage,\n                 &compiler.host, target));\n-        run_cargo(build,\n+        run_cargo(builder,\n                   &mut cargo,\n-                  &libtest_stamp(build, compiler, target),\n+                  &libtest_stamp(builder, compiler, target),\n                   false);\n \n         builder.ensure(TestLink {\n-            compiler: builder.compiler(compiler.stage, build.build),\n+            compiler: builder.compiler(compiler.stage, builder.config.build),\n             target_compiler: compiler,\n             target,\n         });\n     }\n }\n \n /// Same as `std_cargo`, but for libtest\n-pub fn test_cargo(build: &Build,\n+pub fn test_cargo(builder: &Builder,\n                   _compiler: &Compiler,\n                   _target: Interned<String>,\n                   cargo: &mut Command) {\n     if let Some(target) = env::var_os(\"MACOSX_STD_DEPLOYMENT_TARGET\") {\n         cargo.env(\"MACOSX_DEPLOYMENT_TARGET\", target);\n     }\n     cargo.arg(\"--manifest-path\")\n-        .arg(build.src.join(\"src/libtest/Cargo.toml\"));\n+        .arg(builder.src.join(\"src/libtest/Cargo.toml\"));\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n@@ -420,18 +417,17 @@ impl Step for TestLink {\n \n     /// Same as `std_link`, only for libtest\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let compiler = self.compiler;\n         let target_compiler = self.target_compiler;\n         let target = self.target;\n-        build.info(&format!(\"Copying stage{} test from stage{} ({} -> {} / {})\",\n+        builder.info(&format!(\"Copying stage{} test from stage{} ({} -> {} / {})\",\n                 target_compiler.stage,\n                 compiler.stage,\n                 &compiler.host,\n                 target_compiler.host,\n                 target));\n-        add_to_sysroot(&build, &builder.sysroot_libdir(target_compiler, target),\n-                    &libtest_stamp(build, compiler, target));\n+        add_to_sysroot(builder, &builder.sysroot_libdir(target_compiler, target),\n+                    &libtest_stamp(builder, compiler, target));\n         builder.ensure(tool::CleanTools {\n             compiler: target_compiler,\n             target,\n@@ -468,20 +464,20 @@ impl Step for Rustc {\n     /// the `compiler` targeting the `target` architecture. The artifacts\n     /// created will also be linked into the sysroot directory.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let compiler = self.compiler;\n         let target = self.target;\n \n         builder.ensure(Test { compiler, target });\n \n-        if build.force_use_stage1(compiler, target) {\n+        if builder.force_use_stage1(compiler, target) {\n             builder.ensure(Rustc {\n-                compiler: builder.compiler(1, build.build),\n+                compiler: builder.compiler(1, builder.config.build),\n                 target,\n             });\n-            build.info(&format!(\"Uplifting stage1 rustc ({} -> {})\", &build.build, target));\n+            builder.info(&format!(\"Uplifting stage1 rustc ({} -> {})\",\n+                builder.config.build, target));\n             builder.ensure(RustcLink {\n-                compiler: builder.compiler(1, build.build),\n+                compiler: builder.compiler(1, builder.config.build),\n                 target_compiler: compiler,\n                 target,\n             });\n@@ -490,71 +486,71 @@ impl Step for Rustc {\n \n         // Ensure that build scripts have a std to link against.\n         builder.ensure(Std {\n-            compiler: builder.compiler(self.compiler.stage, build.build),\n-            target: build.build,\n+            compiler: builder.compiler(self.compiler.stage, builder.config.build),\n+            target: builder.config.build,\n         });\n         let cargo_out = builder.cargo_out(compiler, Mode::Librustc, target);\n-        build.clear_if_dirty(&cargo_out, &libstd_stamp(build, compiler, target));\n-        build.clear_if_dirty(&cargo_out, &libtest_stamp(build, compiler, target));\n+        builder.clear_if_dirty(&cargo_out, &libstd_stamp(builder, compiler, target));\n+        builder.clear_if_dirty(&cargo_out, &libtest_stamp(builder, compiler, target));\n \n         let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"build\");\n-        rustc_cargo(build, &mut cargo);\n+        rustc_cargo(builder, &mut cargo);\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-rustc\", compiler.stage));\n-        build.info(&format!(\"Building stage{} compiler artifacts ({} -> {})\",\n+        let _folder = builder.fold_output(|| format!(\"stage{}-rustc\", compiler.stage));\n+        builder.info(&format!(\"Building stage{} compiler artifacts ({} -> {})\",\n                  compiler.stage, &compiler.host, target));\n-        run_cargo(build,\n+        run_cargo(builder,\n                   &mut cargo,\n-                  &librustc_stamp(build, compiler, target),\n+                  &librustc_stamp(builder, compiler, target),\n                   false);\n \n         builder.ensure(RustcLink {\n-            compiler: builder.compiler(compiler.stage, build.build),\n+            compiler: builder.compiler(compiler.stage, builder.config.build),\n             target_compiler: compiler,\n             target,\n         });\n     }\n }\n \n-pub fn rustc_cargo(build: &Build, cargo: &mut Command) {\n-    cargo.arg(\"--features\").arg(build.rustc_features())\n+pub fn rustc_cargo(builder: &Builder, cargo: &mut Command) {\n+    cargo.arg(\"--features\").arg(builder.rustc_features())\n          .arg(\"--manifest-path\")\n-         .arg(build.src.join(\"src/rustc/Cargo.toml\"));\n-    rustc_cargo_env(build, cargo);\n+         .arg(builder.src.join(\"src/rustc/Cargo.toml\"));\n+    rustc_cargo_env(builder, cargo);\n }\n \n-fn rustc_cargo_env(build: &Build, cargo: &mut Command) {\n+fn rustc_cargo_env(builder: &Builder, cargo: &mut Command) {\n     // Set some configuration variables picked up by build scripts and\n     // the compiler alike\n-    cargo.env(\"CFG_RELEASE\", build.rust_release())\n-         .env(\"CFG_RELEASE_CHANNEL\", &build.config.channel)\n-         .env(\"CFG_VERSION\", build.rust_version())\n-         .env(\"CFG_PREFIX\", build.config.prefix.clone().unwrap_or_default())\n-         .env(\"CFG_CODEGEN_BACKENDS_DIR\", &build.config.rust_codegen_backends_dir);\n+    cargo.env(\"CFG_RELEASE\", builder.rust_release())\n+         .env(\"CFG_RELEASE_CHANNEL\", &builder.config.channel)\n+         .env(\"CFG_VERSION\", builder.rust_version())\n+         .env(\"CFG_PREFIX\", builder.config.prefix.clone().unwrap_or_default())\n+         .env(\"CFG_CODEGEN_BACKENDS_DIR\", &builder.config.rust_codegen_backends_dir);\n \n-    let libdir_relative = build.config.libdir_relative().unwrap_or(Path::new(\"lib\"));\n+    let libdir_relative = builder.config.libdir_relative().unwrap_or(Path::new(\"lib\"));\n     cargo.env(\"CFG_LIBDIR_RELATIVE\", libdir_relative);\n \n     // If we're not building a compiler with debugging information then remove\n     // these two env vars which would be set otherwise.\n-    if build.config.rust_debuginfo_only_std {\n+    if builder.config.rust_debuginfo_only_std {\n         cargo.env_remove(\"RUSTC_DEBUGINFO\");\n         cargo.env_remove(\"RUSTC_DEBUGINFO_LINES\");\n     }\n \n-    if let Some(ref ver_date) = build.rust_info.commit_date() {\n+    if let Some(ref ver_date) = builder.rust_info.commit_date() {\n         cargo.env(\"CFG_VER_DATE\", ver_date);\n     }\n-    if let Some(ref ver_hash) = build.rust_info.sha() {\n+    if let Some(ref ver_hash) = builder.rust_info.sha() {\n         cargo.env(\"CFG_VER_HASH\", ver_hash);\n     }\n-    if !build.unstable_features() {\n+    if !builder.unstable_features() {\n         cargo.env(\"CFG_DISABLE_UNSTABLE_FEATURES\", \"1\");\n     }\n-    if let Some(ref s) = build.config.rustc_default_linker {\n+    if let Some(ref s) = builder.config.rustc_default_linker {\n         cargo.env(\"CFG_DEFAULT_LINKER\", s);\n     }\n-    if build.config.rustc_parallel_queries {\n+    if builder.config.rustc_parallel_queries {\n         cargo.env(\"RUSTC_PARALLEL_QUERIES\", \"1\");\n     }\n }\n@@ -575,18 +571,17 @@ impl Step for RustcLink {\n \n     /// Same as `std_link`, only for librustc\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let compiler = self.compiler;\n         let target_compiler = self.target_compiler;\n         let target = self.target;\n-        build.info(&format!(\"Copying stage{} rustc from stage{} ({} -> {} / {})\",\n+        builder.info(&format!(\"Copying stage{} rustc from stage{} ({} -> {} / {})\",\n                  target_compiler.stage,\n                  compiler.stage,\n                  &compiler.host,\n                  target_compiler.host,\n                  target));\n-        add_to_sysroot(&build, &builder.sysroot_libdir(target_compiler, target),\n-                       &librustc_stamp(build, compiler, target));\n+        add_to_sysroot(builder, &builder.sysroot_libdir(target_compiler, target),\n+                       &librustc_stamp(builder, compiler, target));\n         builder.ensure(tool::CleanTools {\n             compiler: target_compiler,\n             target,\n@@ -624,26 +619,25 @@ impl Step for CodegenBackend {\n     }\n \n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let compiler = self.compiler;\n         let target = self.target;\n \n         builder.ensure(Rustc { compiler, target });\n \n-        if build.force_use_stage1(compiler, target) {\n+        if builder.force_use_stage1(compiler, target) {\n             builder.ensure(CodegenBackend {\n-                compiler: builder.compiler(1, build.build),\n+                compiler: builder.compiler(1, builder.config.build),\n                 target,\n                 backend: self.backend,\n             });\n             return;\n         }\n \n         let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"build\");\n-        let mut features = build.rustc_features().to_string();\n+        let mut features = builder.rustc_features().to_string();\n         cargo.arg(\"--manifest-path\")\n-            .arg(build.src.join(\"src/librustc_trans/Cargo.toml\"));\n-        rustc_cargo_env(build, &mut cargo);\n+            .arg(builder.src.join(\"src/librustc_trans/Cargo.toml\"));\n+        rustc_cargo_env(builder, &mut cargo);\n \n         match &*self.backend {\n             \"llvm\" | \"emscripten\" => {\n@@ -658,45 +652,45 @@ impl Step for CodegenBackend {\n                     features.push_str(\" emscripten\");\n                 }\n \n-                build.info(&format!(\"Building stage{} codegen artifacts ({} -> {}, {})\",\n+                builder.info(&format!(\"Building stage{} codegen artifacts ({} -> {}, {})\",\n                          compiler.stage, &compiler.host, target, self.backend));\n \n                 // Pass down configuration from the LLVM build into the build of\n                 // librustc_llvm and librustc_trans.\n-                if build.is_rust_llvm(target) {\n+                if builder.is_rust_llvm(target) {\n                     cargo.env(\"LLVM_RUSTLLVM\", \"1\");\n                 }\n                 cargo.env(\"LLVM_CONFIG\", &llvm_config);\n                 if self.backend != \"emscripten\" {\n-                    let target_config = build.config.target_config.get(&target);\n+                    let target_config = builder.config.target_config.get(&target);\n                     if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n                         cargo.env(\"CFG_LLVM_ROOT\", s);\n                     }\n                 }\n                 // Building with a static libstdc++ is only supported on linux right now,\n                 // not for MSVC or macOS\n-                if build.config.llvm_static_stdcpp &&\n+                if builder.config.llvm_static_stdcpp &&\n                    !target.contains(\"freebsd\") &&\n                    !target.contains(\"windows\") &&\n                    !target.contains(\"apple\") {\n-                    let file = compiler_file(build,\n-                                             build.cxx(target).unwrap(),\n+                    let file = compiler_file(builder,\n+                                             builder.cxx(target).unwrap(),\n                                              target,\n                                              \"libstdc++.a\");\n                     cargo.env(\"LLVM_STATIC_STDCPP\", file);\n                 }\n-                if build.config.llvm_link_shared {\n+                if builder.config.llvm_link_shared {\n                     cargo.env(\"LLVM_LINK_SHARED\", \"1\");\n                 }\n             }\n             _ => panic!(\"unknown backend: {}\", self.backend),\n         }\n \n-        let tmp_stamp = build.cargo_out(compiler, Mode::Librustc, target)\n+        let tmp_stamp = builder.cargo_out(compiler, Mode::Librustc, target)\n             .join(\".tmp.stamp\");\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-rustc_trans\", compiler.stage));\n-        let files = run_cargo(build,\n+        let _folder = builder.fold_output(|| format!(\"stage{}-rustc_trans\", compiler.stage));\n+        let files = run_cargo(builder,\n                               cargo.arg(\"--features\").arg(features),\n                               &tmp_stamp,\n                               false);\n@@ -717,7 +711,7 @@ impl Step for CodegenBackend {\n                    codegen_backend.display(),\n                    f.display());\n         }\n-        let stamp = codegen_backend_stamp(build, compiler, target, self.backend);\n+        let stamp = codegen_backend_stamp(builder, compiler, target, self.backend);\n         let codegen_backend = codegen_backend.to_str().unwrap();\n         t!(t!(File::create(&stamp)).write_all(codegen_backend.as_bytes()));\n     }\n@@ -732,7 +726,6 @@ impl Step for CodegenBackend {\n fn copy_codegen_backends_to_sysroot(builder: &Builder,\n                                     compiler: Compiler,\n                                     target_compiler: Compiler) {\n-    let build = builder.build;\n     let target = target_compiler.host;\n \n     // Note that this step is different than all the other `*Link` steps in\n@@ -751,7 +744,7 @@ fn copy_codegen_backends_to_sysroot(builder: &Builder,\n     }\n \n     for backend in builder.config.rust_codegen_backends.iter() {\n-        let stamp = codegen_backend_stamp(build, compiler, target, *backend);\n+        let stamp = codegen_backend_stamp(builder, compiler, target, *backend);\n         let mut dylib = String::new();\n         t!(t!(File::open(&stamp)).read_to_string(&mut dylib));\n         let file = Path::new(&dylib);\n@@ -765,7 +758,7 @@ fn copy_codegen_backends_to_sysroot(builder: &Builder,\n                     backend,\n                     &filename[dot..])\n         };\n-        build.copy(&file, &dst.join(target_filename));\n+        builder.copy(&file, &dst.join(target_filename));\n     }\n }\n \n@@ -786,36 +779,36 @@ fn copy_lld_to_sysroot(builder: &Builder,\n \n /// Cargo's output path for the standard library in a given stage, compiled\n /// by a particular compiler for the specified target.\n-pub fn libstd_stamp(build: &Build, compiler: Compiler, target: Interned<String>) -> PathBuf {\n-    build.cargo_out(compiler, Mode::Libstd, target).join(\".libstd.stamp\")\n+pub fn libstd_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+    builder.cargo_out(compiler, Mode::Libstd, target).join(\".libstd.stamp\")\n }\n \n /// Cargo's output path for libtest in a given stage, compiled by a particular\n /// compiler for the specified target.\n-pub fn libtest_stamp(build: &Build, compiler: Compiler, target: Interned<String>) -> PathBuf {\n-    build.cargo_out(compiler, Mode::Libtest, target).join(\".libtest.stamp\")\n+pub fn libtest_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+    builder.cargo_out(compiler, Mode::Libtest, target).join(\".libtest.stamp\")\n }\n \n /// Cargo's output path for librustc in a given stage, compiled by a particular\n /// compiler for the specified target.\n-pub fn librustc_stamp(build: &Build, compiler: Compiler, target: Interned<String>) -> PathBuf {\n-    build.cargo_out(compiler, Mode::Librustc, target).join(\".librustc.stamp\")\n+pub fn librustc_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+    builder.cargo_out(compiler, Mode::Librustc, target).join(\".librustc.stamp\")\n }\n \n-fn codegen_backend_stamp(build: &Build,\n+fn codegen_backend_stamp(builder: &Builder,\n                          compiler: Compiler,\n                          target: Interned<String>,\n                          backend: Interned<String>) -> PathBuf {\n-    build.cargo_out(compiler, Mode::Librustc, target)\n+    builder.cargo_out(compiler, Mode::Librustc, target)\n         .join(format!(\".librustc_trans-{}.stamp\", backend))\n }\n \n-fn compiler_file(build: &Build,\n+fn compiler_file(builder: &Builder,\n                  compiler: &Path,\n                  target: Interned<String>,\n                  file: &str) -> PathBuf {\n     let mut cmd = Command::new(compiler);\n-    cmd.args(build.cflags(target));\n+    cmd.args(builder.cflags(target));\n     cmd.arg(format!(\"-print-file-name={}\", file));\n     let out = output(&mut cmd);\n     PathBuf::from(out.trim())\n@@ -840,12 +833,11 @@ impl Step for Sysroot {\n     /// thinks it is by default, but it's the same as the default for stages\n     /// 1-3.\n     fn run(self, builder: &Builder) -> Interned<PathBuf> {\n-        let build = builder.build;\n         let compiler = self.compiler;\n         let sysroot = if compiler.stage == 0 {\n-            build.out.join(&compiler.host).join(\"stage0-sysroot\")\n+            builder.out.join(&compiler.host).join(\"stage0-sysroot\")\n         } else {\n-            build.out.join(&compiler.host).join(format!(\"stage{}\", compiler.stage))\n+            builder.out.join(&compiler.host).join(format!(\"stage{}\", compiler.stage))\n         };\n         let _ = fs::remove_dir_all(&sysroot);\n         t!(fs::create_dir_all(&sysroot));\n@@ -872,14 +864,13 @@ impl Step for Assemble {\n     /// Prepare a new compiler from the artifacts in `stage`\n     ///\n     /// This will assemble a compiler in `build/$host/stage$stage`. The compiler\n-    /// must have been previously produced by the `stage - 1` build.build\n+    /// must have been previously produced by the `stage - 1` builder.build\n     /// compiler.\n     fn run(self, builder: &Builder) -> Compiler {\n-        let build = builder.build;\n         let target_compiler = self.target_compiler;\n \n         if target_compiler.stage == 0 {\n-            assert_eq!(build.build, target_compiler.host,\n+            assert_eq!(builder.config.build, target_compiler.host,\n                 \"Cannot obtain compiler for non-native build triple at stage 0\");\n             // The stage 0 compiler for the build triple is always pre-built.\n             return target_compiler;\n@@ -902,14 +893,14 @@ impl Step for Assemble {\n         // FIXME: It may be faster if we build just a stage 1 compiler and then\n         //        use that to bootstrap this compiler forward.\n         let build_compiler =\n-            builder.compiler(target_compiler.stage - 1, build.build);\n+            builder.compiler(target_compiler.stage - 1, builder.config.build);\n \n         // Build the libraries for this compiler to link to (i.e., the libraries\n         // it uses at runtime). NOTE: Crates the target compiler compiles don't\n         // link to these. (FIXME: Is that correct? It seems to be correct most\n         // of the time but I think we do link to these for stage2/bin compilers\n         // when not performing a full bootstrap).\n-        if builder.build.config.keep_stage.map_or(false, |s| target_compiler.stage <= s) {\n+        if builder.config.keep_stage.map_or(false, |s| target_compiler.stage <= s) {\n             builder.verbose(\"skipping compilation of compiler due to --keep-stage\");\n             let compiler = build_compiler;\n             for stage in 0..min(target_compiler.stage, builder.config.keep_stage.unwrap()) {\n@@ -924,7 +915,7 @@ impl Step for Assemble {\n                 compiler: build_compiler,\n                 target: target_compiler.host,\n             });\n-            for &backend in build.config.rust_codegen_backends.iter() {\n+            for &backend in builder.config.rust_codegen_backends.iter() {\n                 builder.ensure(CodegenBackend {\n                     compiler: build_compiler,\n                     target: target_compiler.host,\n@@ -933,7 +924,7 @@ impl Step for Assemble {\n             }\n         }\n \n-        let lld_install = if build.config.lld_enabled {\n+        let lld_install = if builder.config.lld_enabled {\n             Some(builder.ensure(native::Lld {\n                 target: target_compiler.host,\n             }))\n@@ -943,7 +934,7 @@ impl Step for Assemble {\n \n         let stage = target_compiler.stage;\n         let host = target_compiler.host;\n-        build.info(&format!(\"Assembling stage{} compiler ({})\", stage, host));\n+        builder.info(&format!(\"Assembling stage{} compiler ({})\", stage, host));\n \n         // Link in all dylibs to the libdir\n         let sysroot = builder.sysroot(target_compiler);\n@@ -965,7 +956,7 @@ impl Step for Assemble {\n         }\n \n         // Link the compiler binary itself into place\n-        let out_dir = build.cargo_out(build_compiler, Mode::Librustc, host);\n+        let out_dir = builder.cargo_out(build_compiler, Mode::Librustc, host);\n         let rustc = out_dir.join(exe(\"rustc\", &*host));\n         let bindir = sysroot.join(\"bin\");\n         t!(fs::create_dir_all(&bindir));\n@@ -981,10 +972,10 @@ impl Step for Assemble {\n ///\n /// For a particular stage this will link the file listed in `stamp` into the\n /// `sysroot_dst` provided.\n-pub fn add_to_sysroot(build: &Build, sysroot_dst: &Path, stamp: &Path) {\n+pub fn add_to_sysroot(builder: &Builder, sysroot_dst: &Path, stamp: &Path) {\n     t!(fs::create_dir_all(&sysroot_dst));\n-    for path in build.read_stamp_file(stamp) {\n-        build.copy(&path, &sysroot_dst.join(path.file_name().unwrap()));\n+    for path in builder.read_stamp_file(stamp) {\n+        builder.copy(&path, &sysroot_dst.join(path.file_name().unwrap()));\n     }\n }\n \n@@ -1011,10 +1002,10 @@ fn stderr_isatty() -> bool {\n     }\n }\n \n-pub fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path, is_check: bool)\n+pub fn run_cargo(builder: &Builder, cargo: &mut Command, stamp: &Path, is_check: bool)\n     -> Vec<PathBuf>\n {\n-    if build.config.dry_run {\n+    if builder.config.dry_run {\n         return Vec::new();\n     }\n \n@@ -1032,7 +1023,7 @@ pub fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path, is_check: boo\n     // files we need to probe for later.\n     let mut deps = Vec::new();\n     let mut toplevel = Vec::new();\n-    let ok = stream_cargo(build, cargo, &mut |msg| {\n+    let ok = stream_cargo(builder, cargo, &mut |msg| {\n         let filenames = match msg {\n             CargoMessage::CompilerArtifact { filenames, .. } => filenames,\n             _ => return,\n@@ -1141,33 +1132,33 @@ pub fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path, is_check: boo\n     let max = max.unwrap();\n     let max_path = max_path.unwrap();\n     if stamp_contents == new_contents && max <= stamp_mtime {\n-        build.verbose(&format!(\"not updating {:?}; contents equal and {:?} <= {:?}\",\n+        builder.verbose(&format!(\"not updating {:?}; contents equal and {:?} <= {:?}\",\n                 stamp, max, stamp_mtime));\n         return deps\n     }\n     if max > stamp_mtime {\n-        build.verbose(&format!(\"updating {:?} as {:?} changed\", stamp, max_path));\n+        builder.verbose(&format!(\"updating {:?} as {:?} changed\", stamp, max_path));\n     } else {\n-        build.verbose(&format!(\"updating {:?} as deps changed\", stamp));\n+        builder.verbose(&format!(\"updating {:?} as deps changed\", stamp));\n     }\n     t!(t!(File::create(stamp)).write_all(&new_contents));\n     deps\n }\n \n pub fn stream_cargo(\n-    build: &Build,\n+    builder: &Builder,\n     cargo: &mut Command,\n     cb: &mut FnMut(CargoMessage),\n ) -> bool {\n-    if build.config.dry_run {\n+    if builder.config.dry_run {\n         return true;\n     }\n     // Instruct Cargo to give us json messages on stdout, critically leaving\n     // stderr as piped so we can get those pretty colors.\n     cargo.arg(\"--message-format\").arg(\"json\")\n          .stdout(Stdio::piped());\n \n-    if stderr_isatty() && build.ci_env == CiEnv::None &&\n+    if stderr_isatty() && builder.ci_env == CiEnv::None &&\n         // if the terminal is reported as dumb, then we don't want to enable color for rustc\n         env::var_os(\"TERM\").map(|t| t != *\"dumb\").unwrap_or(true) {\n         // since we pass message-format=json to cargo, we need to tell the rustc\n@@ -1176,7 +1167,7 @@ pub fn stream_cargo(\n         cargo.env(\"RUSTC_COLOR\", \"1\");\n     }\n \n-    build.verbose(&format!(\"running: {:?}\", cargo));\n+    builder.verbose(&format!(\"running: {:?}\", cargo));\n     let mut child = match cargo.spawn() {\n         Ok(child) => child,\n         Err(e) => panic!(\"failed to execute command: {:?}\\nerror: {}\", cargo, e),"}, {"sha": "e21a59390b7b6ff6b091d9d07efd62420c8e2898", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 298, "deletions": 311, "changes": 609, "blob_url": "https://github.com/rust-lang/rust/blob/23561c6747b0916e852aaa2a5d04c0b0eeddc6de/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23561c6747b0916e852aaa2a5d04c0b0eeddc6de/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=23561c6747b0916e852aaa2a5d04c0b0eeddc6de", "patch": "@@ -26,7 +26,7 @@ use std::process::{Command, Stdio};\n \n use build_helper::output;\n \n-use {Build, Compiler, Mode};\n+use {Compiler, Mode};\n use channel;\n use util::{libdir, is_dylib, exe};\n use builder::{Builder, RunConfig, ShouldRun, Step};\n@@ -36,25 +36,25 @@ use tool::{self, Tool};\n use cache::{INTERNER, Interned};\n use time;\n \n-pub fn pkgname(build: &Build, component: &str) -> String {\n+pub fn pkgname(builder: &Builder, component: &str) -> String {\n     if component == \"cargo\" {\n-        format!(\"{}-{}\", component, build.cargo_package_vers())\n+        format!(\"{}-{}\", component, builder.cargo_package_vers())\n     } else if component == \"rls\" {\n-        format!(\"{}-{}\", component, build.rls_package_vers())\n+        format!(\"{}-{}\", component, builder.rls_package_vers())\n     } else if component == \"rustfmt\" {\n-        format!(\"{}-{}\", component, build.rustfmt_package_vers())\n+        format!(\"{}-{}\", component, builder.rustfmt_package_vers())\n     } else {\n         assert!(component.starts_with(\"rust\"));\n-        format!(\"{}-{}\", component, build.rust_package_vers())\n+        format!(\"{}-{}\", component, builder.rust_package_vers())\n     }\n }\n \n-fn distdir(build: &Build) -> PathBuf {\n-    build.out.join(\"dist\")\n+fn distdir(builder: &Builder) -> PathBuf {\n+    builder.out.join(\"dist\")\n }\n \n-pub fn tmpdir(build: &Build) -> PathBuf {\n-    build.out.join(\"tmp/dist\")\n+pub fn tmpdir(builder: &Builder) -> PathBuf {\n+    builder.out.join(\"tmp/dist\")\n }\n \n fn rust_installer(builder: &Builder) -> Command {\n@@ -84,43 +84,42 @@ impl Step for Docs {\n \n     /// Builds the `rust-docs` installer component.\n     fn run(self, builder: &Builder) -> PathBuf {\n-        let build = builder.build;\n         let host = self.host;\n \n-        let name = pkgname(build, \"rust-docs\");\n+        let name = pkgname(builder, \"rust-docs\");\n \n-        build.info(&format!(\"Dist docs ({})\", host));\n-        if !build.config.docs {\n-            build.info(&format!(\"\\tskipping - docs disabled\"));\n-            return distdir(build).join(format!(\"{}-{}.tar.gz\", name, host));\n+        builder.info(&format!(\"Dist docs ({})\", host));\n+        if !builder.config.docs {\n+            builder.info(&format!(\"\\tskipping - docs disabled\"));\n+            return distdir(builder).join(format!(\"{}-{}.tar.gz\", name, host));\n         }\n \n         builder.default_doc(None);\n \n-        let image = tmpdir(build).join(format!(\"{}-{}-image\", name, host));\n+        let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, host));\n         let _ = fs::remove_dir_all(&image);\n \n         let dst = image.join(\"share/doc/rust/html\");\n         t!(fs::create_dir_all(&dst));\n-        let src = build.doc_out(host);\n-        build.cp_r(&src, &dst);\n+        let src = builder.doc_out(host);\n+        builder.cp_r(&src, &dst);\n \n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n            .arg(\"--product-name=Rust-Documentation\")\n            .arg(\"--rel-manifest-dir=rustlib\")\n            .arg(\"--success-message=Rust-documentation-is-installed.\")\n            .arg(\"--image-dir\").arg(&image)\n-           .arg(\"--work-dir\").arg(&tmpdir(build))\n-           .arg(\"--output-dir\").arg(&distdir(build))\n+           .arg(\"--work-dir\").arg(&tmpdir(builder))\n+           .arg(\"--output-dir\").arg(&distdir(builder))\n            .arg(format!(\"--package-name={}-{}\", name, host))\n            .arg(\"--component-name=rust-docs\")\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n            .arg(\"--bulk-dirs=share/doc/rust/html\");\n-        build.run(&mut cmd);\n-        build.remove_dir(&image);\n+        builder.run(&mut cmd);\n+        builder.remove_dir(&image);\n \n-        distdir(build).join(format!(\"{}-{}.tar.gz\", name, host))\n+        distdir(builder).join(format!(\"{}-{}.tar.gz\", name, host))\n     }\n }\n \n@@ -147,43 +146,42 @@ impl Step for RustcDocs {\n \n     /// Builds the `rustc-docs` installer component.\n     fn run(self, builder: &Builder) -> PathBuf {\n-        let build = builder.build;\n         let host = self.host;\n \n-        let name = pkgname(build, \"rustc-docs\");\n+        let name = pkgname(builder, \"rustc-docs\");\n \n-        build.info(&format!(\"Dist compiler docs ({})\", host));\n-        if !build.config.compiler_docs {\n-            build.info(&format!(\"\\tskipping - compiler docs disabled\"));\n-            return distdir(build).join(format!(\"{}-{}.tar.gz\", name, host));\n+        builder.info(&format!(\"Dist compiler docs ({})\", host));\n+        if !builder.config.compiler_docs {\n+            builder.info(&format!(\"\\tskipping - compiler docs disabled\"));\n+            return distdir(builder).join(format!(\"{}-{}.tar.gz\", name, host));\n         }\n \n         builder.default_doc(None);\n \n-        let image = tmpdir(build).join(format!(\"{}-{}-image\", name, host));\n+        let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, host));\n         let _ = fs::remove_dir_all(&image);\n \n         let dst = image.join(\"share/doc/rust/html\");\n         t!(fs::create_dir_all(&dst));\n-        let src = build.compiler_doc_out(host);\n-        build.cp_r(&src, &dst);\n+        let src = builder.compiler_doc_out(host);\n+        builder.cp_r(&src, &dst);\n \n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n            .arg(\"--product-name=Rustc-Documentation\")\n            .arg(\"--rel-manifest-dir=rustlib\")\n            .arg(\"--success-message=Rustc-documentation-is-installed.\")\n            .arg(\"--image-dir\").arg(&image)\n-           .arg(\"--work-dir\").arg(&tmpdir(build))\n-           .arg(\"--output-dir\").arg(&distdir(build))\n+           .arg(\"--work-dir\").arg(&tmpdir(builder))\n+           .arg(\"--output-dir\").arg(&distdir(builder))\n            .arg(format!(\"--package-name={}-{}\", name, host))\n            .arg(\"--component-name=rustc-docs\")\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n            .arg(\"--bulk-dirs=share/doc/rust/html\");\n-        build.run(&mut cmd);\n-        build.remove_dir(&image);\n+        builder.run(&mut cmd);\n+        builder.remove_dir(&image);\n \n-        distdir(build).join(format!(\"{}-{}.tar.gz\", name, host))\n+        distdir(builder).join(format!(\"{}-{}.tar.gz\", name, host))\n     }\n }\n \n@@ -207,10 +205,10 @@ fn find_files(files: &[&str], path: &[PathBuf]) -> Vec<PathBuf> {\n }\n \n fn make_win_dist(\n-    rust_root: &Path, plat_root: &Path, target_triple: Interned<String>, build: &Build\n+    rust_root: &Path, plat_root: &Path, target_triple: Interned<String>, builder: &Builder\n ) {\n     //Ask gcc where it keeps its stuff\n-    let mut cmd = Command::new(build.cc(target_triple));\n+    let mut cmd = Command::new(builder.cc(target_triple));\n     cmd.arg(\"-print-search-dirs\");\n     let gcc_out = output(&mut cmd);\n \n@@ -296,21 +294,21 @@ fn make_win_dist(\n     let dist_bin_dir = rust_root.join(\"bin/\");\n     fs::create_dir_all(&dist_bin_dir).expect(\"creating dist_bin_dir failed\");\n     for src in rustc_dlls {\n-        build.copy_to_folder(&src, &dist_bin_dir);\n+        builder.copy_to_folder(&src, &dist_bin_dir);\n     }\n \n     //Copy platform tools to platform-specific bin directory\n     let target_bin_dir = plat_root.join(\"lib\").join(\"rustlib\").join(target_triple).join(\"bin\");\n     fs::create_dir_all(&target_bin_dir).expect(\"creating target_bin_dir failed\");\n     for src in target_tools {\n-        build.copy_to_folder(&src, &target_bin_dir);\n+        builder.copy_to_folder(&src, &target_bin_dir);\n     }\n \n     //Copy platform libs to platform-specific lib directory\n     let target_lib_dir = plat_root.join(\"lib\").join(\"rustlib\").join(target_triple).join(\"lib\");\n     fs::create_dir_all(&target_lib_dir).expect(\"creating target_lib_dir failed\");\n     for src in target_libs {\n-        build.copy_to_folder(&src, &target_lib_dir);\n+        builder.copy_to_folder(&src, &target_lib_dir);\n     }\n }\n \n@@ -336,39 +334,38 @@ impl Step for Mingw {\n     /// This contains all the bits and pieces to run the MinGW Windows targets\n     /// without any extra installed software (e.g. we bundle gcc, libraries, etc).\n     fn run(self, builder: &Builder) -> Option<PathBuf> {\n-        let build = builder.build;\n         let host = self.host;\n \n         if !host.contains(\"pc-windows-gnu\") {\n             return None;\n         }\n \n-        build.info(&format!(\"Dist mingw ({})\", host));\n-        let name = pkgname(build, \"rust-mingw\");\n-        let image = tmpdir(build).join(format!(\"{}-{}-image\", name, host));\n+        builder.info(&format!(\"Dist mingw ({})\", host));\n+        let name = pkgname(builder, \"rust-mingw\");\n+        let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, host));\n         let _ = fs::remove_dir_all(&image);\n         t!(fs::create_dir_all(&image));\n \n         // The first argument is a \"temporary directory\" which is just\n         // thrown away (this contains the runtime DLLs included in the rustc package\n         // above) and the second argument is where to place all the MinGW components\n         // (which is what we want).\n-        make_win_dist(&tmpdir(build), &image, host, &build);\n+        make_win_dist(&tmpdir(builder), &image, host, &builder);\n \n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n            .arg(\"--product-name=Rust-MinGW\")\n            .arg(\"--rel-manifest-dir=rustlib\")\n            .arg(\"--success-message=Rust-MinGW-is-installed.\")\n            .arg(\"--image-dir\").arg(&image)\n-           .arg(\"--work-dir\").arg(&tmpdir(build))\n-           .arg(\"--output-dir\").arg(&distdir(build))\n+           .arg(\"--work-dir\").arg(&tmpdir(builder))\n+           .arg(\"--output-dir\").arg(&distdir(builder))\n            .arg(format!(\"--package-name={}-{}\", name, host))\n            .arg(\"--component-name=rust-mingw\")\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n-        build.run(&mut cmd);\n+        builder.run(&mut cmd);\n         t!(fs::remove_dir_all(&image));\n-        Some(distdir(build).join(format!(\"{}-{}.tar.gz\", name, host)))\n+        Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, host)))\n     }\n }\n \n@@ -394,15 +391,14 @@ impl Step for Rustc {\n \n     /// Creates the `rustc` installer component.\n     fn run(self, builder: &Builder) -> PathBuf {\n-        let build = builder.build;\n         let compiler = self.compiler;\n         let host = self.compiler.host;\n \n-        build.info(&format!(\"Dist rustc stage{} ({})\", compiler.stage, compiler.host));\n-        let name = pkgname(build, \"rustc\");\n-        let image = tmpdir(build).join(format!(\"{}-{}-image\", name, host));\n+        builder.info(&format!(\"Dist rustc stage{} ({})\", compiler.stage, compiler.host));\n+        let name = pkgname(builder, \"rustc\");\n+        let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, host));\n         let _ = fs::remove_dir_all(&image);\n-        let overlay = tmpdir(build).join(format!(\"{}-{}-overlay\", name, host));\n+        let overlay = tmpdir(builder).join(format!(\"{}-{}-overlay\", name, host));\n         let _ = fs::remove_dir_all(&overlay);\n \n         // Prepare the rustc \"image\", what will actually end up getting installed\n@@ -411,17 +407,17 @@ impl Step for Rustc {\n         // Prepare the overlay which is part of the tarball but won't actually be\n         // installed\n         let cp = |file: &str| {\n-            build.install(&build.src.join(file), &overlay, 0o644);\n+            builder.install(&builder.src.join(file), &overlay, 0o644);\n         };\n         cp(\"COPYRIGHT\");\n         cp(\"LICENSE-APACHE\");\n         cp(\"LICENSE-MIT\");\n         cp(\"README.md\");\n         // tiny morsel of metadata is used by rust-packaging\n-        let version = build.rust_version();\n-        build.create(&overlay.join(\"version\"), &version);\n-        if let Some(sha) = build.rust_sha() {\n-            build.create(&overlay.join(\"git-commit-hash\"), &sha);\n+        let version = builder.rust_version();\n+        builder.create(&overlay.join(\"version\"), &version);\n+        if let Some(sha) = builder.rust_sha() {\n+            builder.create(&overlay.join(\"git-commit-hash\"), &sha);\n         }\n \n         // On MinGW we've got a few runtime DLL dependencies that we need to\n@@ -435,11 +431,11 @@ impl Step for Rustc {\n         // install will *also* include the rust-mingw package, which also needs\n         // licenses, so to be safe we just include it here in all MinGW packages.\n         if host.contains(\"pc-windows-gnu\") {\n-            make_win_dist(&image, &tmpdir(build), host, build);\n+            make_win_dist(&image, &tmpdir(builder), host, builder);\n \n             let dst = image.join(\"share/doc\");\n             t!(fs::create_dir_all(&dst));\n-            build.cp_r(&build.src.join(\"src/etc/third-party\"), &dst);\n+            builder.cp_r(&builder.src.join(\"src/etc/third-party\"), &dst);\n         }\n \n         // Finally, wrap everything up in a nice tarball!\n@@ -449,37 +445,36 @@ impl Step for Rustc {\n            .arg(\"--rel-manifest-dir=rustlib\")\n            .arg(\"--success-message=Rust-is-ready-to-roll.\")\n            .arg(\"--image-dir\").arg(&image)\n-           .arg(\"--work-dir\").arg(&tmpdir(build))\n-           .arg(\"--output-dir\").arg(&distdir(build))\n+           .arg(\"--work-dir\").arg(&tmpdir(builder))\n+           .arg(\"--output-dir\").arg(&distdir(builder))\n            .arg(\"--non-installed-overlay\").arg(&overlay)\n            .arg(format!(\"--package-name={}-{}\", name, host))\n            .arg(\"--component-name=rustc\")\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n-        build.run(&mut cmd);\n-        build.remove_dir(&image);\n-        build.remove_dir(&overlay);\n+        builder.run(&mut cmd);\n+        builder.remove_dir(&image);\n+        builder.remove_dir(&overlay);\n \n-        return distdir(build).join(format!(\"{}-{}.tar.gz\", name, host));\n+        return distdir(builder).join(format!(\"{}-{}.tar.gz\", name, host));\n \n         fn prepare_image(builder: &Builder, compiler: Compiler, image: &Path) {\n             let host = compiler.host;\n-            let build = builder.build;\n             let src = builder.sysroot(compiler);\n             let libdir = libdir(&host);\n \n             // Copy rustc/rustdoc binaries\n             t!(fs::create_dir_all(image.join(\"bin\")));\n-            build.cp_r(&src.join(\"bin\"), &image.join(\"bin\"));\n+            builder.cp_r(&src.join(\"bin\"), &image.join(\"bin\"));\n \n-            build.install(&builder.rustdoc(compiler.host), &image.join(\"bin\"), 0o755);\n+            builder.install(&builder.rustdoc(compiler.host), &image.join(\"bin\"), 0o755);\n \n             // Copy runtime DLLs needed by the compiler\n             if libdir != \"bin\" {\n-                for entry in build.read_dir(&src.join(libdir)) {\n+                for entry in builder.read_dir(&src.join(libdir)) {\n                     let name = entry.file_name();\n                     if let Some(s) = name.to_str() {\n                         if is_dylib(s) {\n-                            build.install(&entry.path(), &image.join(libdir), 0o644);\n+                            builder.install(&entry.path(), &image.join(libdir), 0o644);\n                         }\n                     }\n                 }\n@@ -490,7 +485,7 @@ impl Step for Rustc {\n             let backends_rel = backends_src.strip_prefix(&src).unwrap();\n             let backends_dst = image.join(&backends_rel);\n             t!(fs::create_dir_all(&backends_dst));\n-            build.cp_r(&backends_src, &backends_dst);\n+            builder.cp_r(&backends_src, &backends_dst);\n \n             // Copy over lld if it's there\n             if builder.config.lld_enabled {\n@@ -505,22 +500,22 @@ impl Step for Rustc {\n                     .join(\"bin\")\n                     .join(&exe);\n                 t!(fs::create_dir_all(&dst.parent().unwrap()));\n-                build.copy(&src, &dst);\n+                builder.copy(&src, &dst);\n             }\n \n             // Man pages\n             t!(fs::create_dir_all(image.join(\"share/man/man1\")));\n-            let man_src = build.src.join(\"src/doc/man\");\n+            let man_src = builder.src.join(\"src/doc/man\");\n             let man_dst = image.join(\"share/man/man1\");\n             let month_year = t!(time::strftime(\"%B %Y\", &time::now()));\n             // don't use our `bootstrap::util::{copy, cp_r}`, because those try\n             // to hardlink, and we don't want to edit the source templates\n-            for file_entry in build.read_dir(&man_src) {\n+            for file_entry in builder.read_dir(&man_src) {\n                 let page_src = file_entry.path();\n                 let page_dst = man_dst.join(file_entry.file_name());\n                 t!(fs::copy(&page_src, &page_dst));\n                 // template in month/year and version number\n-                build.replace_in_file(&page_dst,\n+                builder.replace_in_file(&page_dst,\n                                 &[(\"<INSERT DATE HERE>\", &month_year),\n                                   (\"<INSERT VERSION HERE>\", channel::CFG_RELEASE_NUM)]);\n             }\n@@ -533,7 +528,7 @@ impl Step for Rustc {\n \n             // Misc license info\n             let cp = |file: &str| {\n-                build.install(&build.src.join(file), &image.join(\"share/doc/rust\"), 0o644);\n+                builder.install(&builder.src.join(file), &image.join(\"share/doc/rust\"), 0o644);\n             };\n             cp(\"COPYRIGHT\");\n             cp(\"LICENSE-APACHE\");\n@@ -565,17 +560,16 @@ impl Step for DebuggerScripts {\n \n     /// Copies debugger scripts for `target` into the `sysroot` specified.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let host = self.host;\n         let sysroot = self.sysroot;\n         let dst = sysroot.join(\"lib/rustlib/etc\");\n         t!(fs::create_dir_all(&dst));\n         let cp_debugger_script = |file: &str| {\n-            build.install(&build.src.join(\"src/etc/\").join(file), &dst, 0o644);\n+            builder.install(&builder.src.join(\"src/etc/\").join(file), &dst, 0o644);\n         };\n         if host.contains(\"windows-msvc\") {\n             // windbg debugger scripts\n-            build.install(&build.src.join(\"src/etc/rust-windbg.cmd\"), &sysroot.join(\"bin\"),\n+            builder.install(&builder.src.join(\"src/etc/rust-windbg.cmd\"), &sysroot.join(\"bin\"),\n                 0o755);\n \n             cp_debugger_script(\"natvis/intrinsic.natvis\");\n@@ -585,14 +579,14 @@ impl Step for DebuggerScripts {\n             cp_debugger_script(\"debugger_pretty_printers_common.py\");\n \n             // gdb debugger scripts\n-            build.install(&build.src.join(\"src/etc/rust-gdb\"), &sysroot.join(\"bin\"),\n+            builder.install(&builder.src.join(\"src/etc/rust-gdb\"), &sysroot.join(\"bin\"),\n                     0o755);\n \n             cp_debugger_script(\"gdb_load_rust_pretty_printers.py\");\n             cp_debugger_script(\"gdb_rust_pretty_printing.py\");\n \n             // lldb debugger scripts\n-            build.install(&build.src.join(\"src/etc/rust-lldb\"), &sysroot.join(\"bin\"),\n+            builder.install(&builder.src.join(\"src/etc/rust-lldb\"), &sysroot.join(\"bin\"),\n                     0o755);\n \n             cp_debugger_script(\"lldb_rust_formatters.py\");\n@@ -616,50 +610,50 @@ impl Step for Std {\n \n     fn make_run(run: RunConfig) {\n         run.builder.ensure(Std {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n+            compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n             target: run.target,\n         });\n     }\n \n     fn run(self, builder: &Builder) -> PathBuf {\n-        let build = builder.build;\n         let compiler = self.compiler;\n         let target = self.target;\n \n-        let name = pkgname(build, \"rust-std\");\n-        build.info(&format!(\"Dist std stage{} ({} -> {})\", compiler.stage, &compiler.host, target));\n+        let name = pkgname(builder, \"rust-std\");\n+        builder.info(&format!(\"Dist std stage{} ({} -> {})\",\n+            compiler.stage, &compiler.host, target));\n \n         // The only true set of target libraries came from the build triple, so\n         // let's reduce redundant work by only producing archives from that host.\n-        if compiler.host != build.build {\n-            build.info(&format!(\"\\tskipping, not a build host\"));\n-            return distdir(build).join(format!(\"{}-{}.tar.gz\", name, target));\n+        if compiler.host != builder.config.build {\n+            builder.info(&format!(\"\\tskipping, not a build host\"));\n+            return distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target));\n         }\n \n         // We want to package up as many target libraries as possible\n         // for the `rust-std` package, so if this is a host target we\n         // depend on librustc and otherwise we just depend on libtest.\n-        if build.hosts.iter().any(|t| t == target) {\n+        if builder.hosts.iter().any(|t| t == target) {\n             builder.ensure(compile::Rustc { compiler, target });\n         } else {\n-            if build.no_std(target) == Some(true) {\n+            if builder.no_std(target) == Some(true) {\n                 // the `test` doesn't compile for no-std targets\n                 builder.ensure(compile::Std { compiler, target });\n             } else {\n                 builder.ensure(compile::Test { compiler, target });\n             }\n         }\n \n-        let image = tmpdir(build).join(format!(\"{}-{}-image\", name, target));\n+        let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, target));\n         let _ = fs::remove_dir_all(&image);\n \n         let dst = image.join(\"lib/rustlib\").join(target);\n         t!(fs::create_dir_all(&dst));\n         let mut src = builder.sysroot_libdir(compiler, target).to_path_buf();\n         src.pop(); // Remove the trailing /lib folder from the sysroot_libdir\n-        build.cp_filtered(&src, &dst, &|path| {\n+        builder.cp_filtered(&src, &dst, &|path| {\n             let name = path.file_name().and_then(|s| s.to_str());\n-            name != Some(build.config.rust_codegen_backends_dir.as_str()) &&\n+            name != Some(builder.config.rust_codegen_backends_dir.as_str()) &&\n                 name != Some(\"bin\")\n \n         });\n@@ -670,14 +664,14 @@ impl Step for Std {\n            .arg(\"--rel-manifest-dir=rustlib\")\n            .arg(\"--success-message=std-is-standing-at-the-ready.\")\n            .arg(\"--image-dir\").arg(&image)\n-           .arg(\"--work-dir\").arg(&tmpdir(build))\n-           .arg(\"--output-dir\").arg(&distdir(build))\n+           .arg(\"--work-dir\").arg(&tmpdir(builder))\n+           .arg(\"--output-dir\").arg(&distdir(builder))\n            .arg(format!(\"--package-name={}-{}\", name, target))\n            .arg(format!(\"--component-name=rust-std-{}\", target))\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n-        build.run(&mut cmd);\n-        build.remove_dir(&image);\n-        distdir(build).join(format!(\"{}-{}.tar.gz\", name, target))\n+        builder.run(&mut cmd);\n+        builder.remove_dir(&image);\n+        distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target))\n     }\n }\n \n@@ -693,69 +687,68 @@ impl Step for Analysis {\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n-        run.path(\"analysis\").default_condition(builder.build.config.extended)\n+        run.path(\"analysis\").default_condition(builder.config.extended)\n     }\n \n     fn make_run(run: RunConfig) {\n         run.builder.ensure(Analysis {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n+            compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n             target: run.target,\n         });\n     }\n \n     /// Creates a tarball of save-analysis metadata, if available.\n     fn run(self, builder: &Builder) -> PathBuf {\n-        let build = builder.build;\n         let compiler = self.compiler;\n         let target = self.target;\n-        assert!(build.config.extended);\n-        build.info(&format!(\"Dist analysis\"));\n-        let name = pkgname(build, \"rust-analysis\");\n+        assert!(builder.config.extended);\n+        builder.info(&format!(\"Dist analysis\"));\n+        let name = pkgname(builder, \"rust-analysis\");\n \n-        if &compiler.host != build.build {\n-            build.info(&format!(\"\\tskipping, not a build host\"));\n-            return distdir(build).join(format!(\"{}-{}.tar.gz\", name, target));\n+        if &compiler.host != builder.config.build {\n+            builder.info(&format!(\"\\tskipping, not a build host\"));\n+            return distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target));\n         }\n \n         builder.ensure(Std { compiler, target });\n \n         // Package save-analysis from stage1 if not doing a full bootstrap, as the\n         // stage2 artifacts is simply copied from stage1 in that case.\n-        let compiler = if build.force_use_stage1(compiler, target) {\n+        let compiler = if builder.force_use_stage1(compiler, target) {\n             builder.compiler(1, compiler.host)\n         } else {\n             compiler.clone()\n         };\n \n-        let image = tmpdir(build).join(format!(\"{}-{}-image\", name, target));\n+        let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, target));\n \n-        let src = build.stage_out(compiler, Mode::Libstd)\n-            .join(target).join(build.cargo_dir()).join(\"deps\");\n+        let src = builder.stage_out(compiler, Mode::Libstd)\n+            .join(target).join(builder.cargo_dir()).join(\"deps\");\n \n         let image_src = src.join(\"save-analysis\");\n         let dst = image.join(\"lib/rustlib\").join(target).join(\"analysis\");\n         t!(fs::create_dir_all(&dst));\n-        build.info(&format!(\"image_src: {:?}, dst: {:?}\", image_src, dst));\n-        build.cp_r(&image_src, &dst);\n+        builder.info(&format!(\"image_src: {:?}, dst: {:?}\", image_src, dst));\n+        builder.cp_r(&image_src, &dst);\n \n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n            .arg(\"--product-name=Rust\")\n            .arg(\"--rel-manifest-dir=rustlib\")\n            .arg(\"--success-message=save-analysis-saved.\")\n            .arg(\"--image-dir\").arg(&image)\n-           .arg(\"--work-dir\").arg(&tmpdir(build))\n-           .arg(\"--output-dir\").arg(&distdir(build))\n+           .arg(\"--work-dir\").arg(&tmpdir(builder))\n+           .arg(\"--output-dir\").arg(&distdir(builder))\n            .arg(format!(\"--package-name={}-{}\", name, target))\n            .arg(format!(\"--component-name=rust-analysis-{}\", target))\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n-        build.run(&mut cmd);\n-        build.remove_dir(&image);\n-        distdir(build).join(format!(\"{}-{}.tar.gz\", name, target))\n+        builder.run(&mut cmd);\n+        builder.remove_dir(&image);\n+        distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target))\n     }\n }\n \n-fn copy_src_dirs(build: &Build, src_dirs: &[&str], exclude_dirs: &[&str], dst_dir: &Path) {\n+fn copy_src_dirs(builder: &Builder, src_dirs: &[&str], exclude_dirs: &[&str], dst_dir: &Path) {\n     fn filter_fn(exclude_dirs: &[&str], dir: &str, path: &Path) -> bool {\n         let spath = match path.to_str() {\n             Some(path) => path,\n@@ -794,7 +787,8 @@ fn copy_src_dirs(build: &Build, src_dirs: &[&str], exclude_dirs: &[&str], dst_di\n     for item in src_dirs {\n         let dst = &dst_dir.join(item);\n         t!(fs::create_dir_all(dst));\n-        build.cp_filtered(&build.src.join(item), dst, &|path| filter_fn(exclude_dirs, item, path));\n+        builder.cp_filtered(\n+            &builder.src.join(item), dst, &|path| filter_fn(exclude_dirs, item, path));\n     }\n }\n \n@@ -817,11 +811,10 @@ impl Step for Src {\n \n     /// Creates the `rust-src` installer component\n     fn run(self, builder: &Builder) -> PathBuf {\n-        let build = builder.build;\n-        build.info(&format!(\"Dist src\"));\n+        builder.info(&format!(\"Dist src\"));\n \n-        let name = pkgname(build, \"rust-src\");\n-        let image = tmpdir(build).join(format!(\"{}-image\", name));\n+        let name = pkgname(builder, \"rust-src\");\n+        let image = tmpdir(builder).join(format!(\"{}-image\", name));\n         let _ = fs::remove_dir_all(&image);\n \n         let dst = image.join(\"lib/rustlib/src\");\n@@ -866,9 +859,9 @@ impl Step for Src {\n             \"src/jemalloc/test/unit\",\n         ];\n \n-        copy_src_dirs(build, &std_src_dirs[..], &std_src_dirs_exclude[..], &dst_src);\n+        copy_src_dirs(builder, &std_src_dirs[..], &std_src_dirs_exclude[..], &dst_src);\n         for file in src_files.iter() {\n-            build.copy(&build.src.join(file), &dst_src.join(file));\n+            builder.copy(&builder.src.join(file), &dst_src.join(file));\n         }\n \n         // Create source tarball in rust-installer format\n@@ -878,15 +871,15 @@ impl Step for Src {\n            .arg(\"--rel-manifest-dir=rustlib\")\n            .arg(\"--success-message=Awesome-Source.\")\n            .arg(\"--image-dir\").arg(&image)\n-           .arg(\"--work-dir\").arg(&tmpdir(build))\n-           .arg(\"--output-dir\").arg(&distdir(build))\n+           .arg(\"--work-dir\").arg(&tmpdir(builder))\n+           .arg(\"--output-dir\").arg(&distdir(builder))\n            .arg(format!(\"--package-name={}\", name))\n            .arg(\"--component-name=rust-src\")\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n-        build.run(&mut cmd);\n+        builder.run(&mut cmd);\n \n-        build.remove_dir(&image);\n-        distdir(build).join(&format!(\"{}.tar.gz\", name))\n+        builder.remove_dir(&image);\n+        distdir(builder).join(&format!(\"{}.tar.gz\", name))\n     }\n }\n \n@@ -912,12 +905,11 @@ impl Step for PlainSourceTarball {\n \n     /// Creates the plain source tarball\n     fn run(self, builder: &Builder) -> PathBuf {\n-        let build = builder.build;\n-        build.info(&format!(\"Create plain source tarball\"));\n+        builder.info(&format!(\"Create plain source tarball\"));\n \n         // Make sure that the root folder of tarball has the correct name\n-        let plain_name = format!(\"{}-src\", pkgname(build, \"rustc\"));\n-        let plain_dst_src = tmpdir(build).join(&plain_name);\n+        let plain_name = format!(\"{}-src\", pkgname(builder, \"rustc\"));\n+        let plain_dst_src = tmpdir(builder).join(&plain_name);\n         let _ = fs::remove_dir_all(&plain_dst_src);\n         t!(fs::create_dir_all(&plain_dst_src));\n \n@@ -937,68 +929,68 @@ impl Step for PlainSourceTarball {\n             \"src\",\n         ];\n \n-        copy_src_dirs(build, &src_dirs[..], &[], &plain_dst_src);\n+        copy_src_dirs(builder, &src_dirs[..], &[], &plain_dst_src);\n \n         // Copy the files normally\n         for item in &src_files {\n-            build.copy(&build.src.join(item), &plain_dst_src.join(item));\n+            builder.copy(&builder.src.join(item), &plain_dst_src.join(item));\n         }\n \n         // Create the version file\n-        build.create(&plain_dst_src.join(\"version\"), &build.rust_version());\n-        if let Some(sha) = build.rust_sha() {\n-            build.create(&plain_dst_src.join(\"git-commit-hash\"), &sha);\n+        builder.create(&plain_dst_src.join(\"version\"), &builder.rust_version());\n+        if let Some(sha) = builder.rust_sha() {\n+            builder.create(&plain_dst_src.join(\"git-commit-hash\"), &sha);\n         }\n \n         // If we're building from git sources, we need to vendor a complete distribution.\n-        if build.rust_info.is_git() {\n+        if builder.rust_info.is_git() {\n             // Get cargo-vendor installed, if it isn't already.\n             let mut has_cargo_vendor = false;\n-            let mut cmd = Command::new(&build.initial_cargo);\n+            let mut cmd = Command::new(&builder.initial_cargo);\n             for line in output(cmd.arg(\"install\").arg(\"--list\")).lines() {\n                 has_cargo_vendor |= line.starts_with(\"cargo-vendor \");\n             }\n             if !has_cargo_vendor {\n-                let mut cmd = Command::new(&build.initial_cargo);\n+                let mut cmd = Command::new(&builder.initial_cargo);\n                 cmd.arg(\"install\")\n                    .arg(\"--force\")\n                    .arg(\"--debug\")\n                    .arg(\"--vers\").arg(CARGO_VENDOR_VERSION)\n                    .arg(\"cargo-vendor\")\n-                   .env(\"RUSTC\", &build.initial_rustc);\n-                if let Some(dir) = build.openssl_install_dir(build.config.build) {\n+                   .env(\"RUSTC\", &builder.initial_rustc);\n+                if let Some(dir) = builder.openssl_install_dir(builder.config.build) {\n                     builder.ensure(native::Openssl {\n-                        target: build.config.build,\n+                        target: builder.config.build,\n                     });\n                     cmd.env(\"OPENSSL_DIR\", dir);\n                 }\n-                build.run(&mut cmd);\n+                builder.run(&mut cmd);\n             }\n \n             // Vendor all Cargo dependencies\n-            let mut cmd = Command::new(&build.initial_cargo);\n+            let mut cmd = Command::new(&builder.initial_cargo);\n             cmd.arg(\"vendor\")\n                .current_dir(&plain_dst_src.join(\"src\"));\n-            build.run(&mut cmd);\n+            builder.run(&mut cmd);\n         }\n \n         // Create plain source tarball\n-        let plain_name = format!(\"rustc-{}-src\", build.rust_package_vers());\n-        let mut tarball = distdir(build).join(&format!(\"{}.tar.gz\", plain_name));\n+        let plain_name = format!(\"rustc-{}-src\", builder.rust_package_vers());\n+        let mut tarball = distdir(builder).join(&format!(\"{}.tar.gz\", plain_name));\n         tarball.set_extension(\"\"); // strip .gz\n         tarball.set_extension(\"\"); // strip .tar\n         if let Some(dir) = tarball.parent() {\n-            build.create_dir(&dir);\n+            builder.create_dir(&dir);\n         }\n-        build.info(&format!(\"running installer\"));\n+        builder.info(&format!(\"running installer\"));\n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"tarball\")\n            .arg(\"--input\").arg(&plain_name)\n            .arg(\"--output\").arg(&tarball)\n            .arg(\"--work-dir=.\")\n-           .current_dir(tmpdir(build));\n-        build.run(&mut cmd);\n-        distdir(build).join(&format!(\"{}.tar.gz\", plain_name))\n+           .current_dir(tmpdir(builder));\n+        builder.run(&mut cmd);\n+        distdir(builder).join(&format!(\"{}.tar.gz\", plain_name))\n     }\n }\n \n@@ -1043,52 +1035,51 @@ impl Step for Cargo {\n     }\n \n     fn run(self, builder: &Builder) -> PathBuf {\n-        let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n \n-        build.info(&format!(\"Dist cargo stage{} ({})\", stage, target));\n-        let src = build.src.join(\"src/tools/cargo\");\n+        builder.info(&format!(\"Dist cargo stage{} ({})\", stage, target));\n+        let src = builder.src.join(\"src/tools/cargo\");\n         let etc = src.join(\"src/etc\");\n-        let release_num = build.release_num(\"cargo\");\n-        let name = pkgname(build, \"cargo\");\n-        let version = builder.cargo_info.version(build, &release_num);\n+        let release_num = builder.release_num(\"cargo\");\n+        let name = pkgname(builder, \"cargo\");\n+        let version = builder.cargo_info.version(builder, &release_num);\n \n-        let tmp = tmpdir(build);\n+        let tmp = tmpdir(builder);\n         let image = tmp.join(\"cargo-image\");\n         drop(fs::remove_dir_all(&image));\n-        build.create_dir(&image);\n+        builder.create_dir(&image);\n \n         // Prepare the image directory\n-        build.create_dir(&image.join(\"share/zsh/site-functions\"));\n-        build.create_dir(&image.join(\"etc/bash_completion.d\"));\n+        builder.create_dir(&image.join(\"share/zsh/site-functions\"));\n+        builder.create_dir(&image.join(\"etc/bash_completion.d\"));\n         let cargo = builder.ensure(tool::Cargo {\n-            compiler: builder.compiler(stage, build.build),\n+            compiler: builder.compiler(stage, builder.config.build),\n             target\n         });\n-        build.install(&cargo, &image.join(\"bin\"), 0o755);\n+        builder.install(&cargo, &image.join(\"bin\"), 0o755);\n         for man in t!(etc.join(\"man\").read_dir()) {\n             let man = t!(man);\n-            build.install(&man.path(), &image.join(\"share/man/man1\"), 0o644);\n+            builder.install(&man.path(), &image.join(\"share/man/man1\"), 0o644);\n         }\n-        build.install(&etc.join(\"_cargo\"), &image.join(\"share/zsh/site-functions\"), 0o644);\n-        build.copy(&etc.join(\"cargo.bashcomp.sh\"),\n+        builder.install(&etc.join(\"_cargo\"), &image.join(\"share/zsh/site-functions\"), 0o644);\n+        builder.copy(&etc.join(\"cargo.bashcomp.sh\"),\n              &image.join(\"etc/bash_completion.d/cargo\"));\n         let doc = image.join(\"share/doc/cargo\");\n-        build.install(&src.join(\"README.md\"), &doc, 0o644);\n-        build.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n-        build.install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n-        build.install(&src.join(\"LICENSE-THIRD-PARTY\"), &doc, 0o644);\n+        builder.install(&src.join(\"README.md\"), &doc, 0o644);\n+        builder.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n+        builder.install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n+        builder.install(&src.join(\"LICENSE-THIRD-PARTY\"), &doc, 0o644);\n \n         // Prepare the overlay\n         let overlay = tmp.join(\"cargo-overlay\");\n         drop(fs::remove_dir_all(&overlay));\n-        build.create_dir(&overlay);\n-        build.install(&src.join(\"README.md\"), &overlay, 0o644);\n-        build.install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n-        build.install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n-        build.install(&src.join(\"LICENSE-THIRD-PARTY\"), &overlay, 0o644);\n-        build.create(&overlay.join(\"version\"), &version);\n+        builder.create_dir(&overlay);\n+        builder.install(&src.join(\"README.md\"), &overlay, 0o644);\n+        builder.install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n+        builder.install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n+        builder.install(&src.join(\"LICENSE-THIRD-PARTY\"), &overlay, 0o644);\n+        builder.create(&overlay.join(\"version\"), &version);\n \n         // Generate the installer tarball\n         let mut cmd = rust_installer(builder);\n@@ -1097,14 +1088,14 @@ impl Step for Cargo {\n            .arg(\"--rel-manifest-dir=rustlib\")\n            .arg(\"--success-message=Rust-is-ready-to-roll.\")\n            .arg(\"--image-dir\").arg(&image)\n-           .arg(\"--work-dir\").arg(&tmpdir(build))\n-           .arg(\"--output-dir\").arg(&distdir(build))\n+           .arg(\"--work-dir\").arg(&tmpdir(builder))\n+           .arg(\"--output-dir\").arg(&distdir(builder))\n            .arg(\"--non-installed-overlay\").arg(&overlay)\n            .arg(format!(\"--package-name={}-{}\", name, target))\n            .arg(\"--component-name=cargo\")\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n-        build.run(&mut cmd);\n-        distdir(build).join(format!(\"{}-{}.tar.gz\", name, target))\n+        builder.run(&mut cmd);\n+        distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target))\n     }\n }\n \n@@ -1130,18 +1121,17 @@ impl Step for Rls {\n     }\n \n     fn run(self, builder: &Builder) -> Option<PathBuf> {\n-        let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n-        assert!(build.config.extended);\n+        assert!(builder.config.extended);\n \n-        build.info(&format!(\"Dist RLS stage{} ({})\", stage, target));\n-        let src = build.src.join(\"src/tools/rls\");\n-        let release_num = build.release_num(\"rls\");\n-        let name = pkgname(build, \"rls\");\n-        let version = build.rls_info.version(build, &release_num);\n+        builder.info(&format!(\"Dist RLS stage{} ({})\", stage, target));\n+        let src = builder.src.join(\"src/tools/rls\");\n+        let release_num = builder.release_num(\"rls\");\n+        let name = pkgname(builder, \"rls\");\n+        let version = builder.rls_info.version(builder, &release_num);\n \n-        let tmp = tmpdir(build);\n+        let tmp = tmpdir(builder);\n         let image = tmp.join(\"rls-image\");\n         drop(fs::remove_dir_all(&image));\n         t!(fs::create_dir_all(&image));\n@@ -1150,24 +1140,24 @@ impl Step for Rls {\n         // We expect RLS to build, because we've exited this step above if tool\n         // state for RLS isn't testing.\n         let rls = builder.ensure(tool::Rls {\n-            compiler: builder.compiler(stage, build.build),\n+            compiler: builder.compiler(stage, builder.config.build),\n             target, extra_features: Vec::new()\n         }).or_else(|| { println!(\"Unable to build RLS, skipping dist\"); None })?;\n \n-        build.install(&rls, &image.join(\"bin\"), 0o755);\n+        builder.install(&rls, &image.join(\"bin\"), 0o755);\n         let doc = image.join(\"share/doc/rls\");\n-        build.install(&src.join(\"README.md\"), &doc, 0o644);\n-        build.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n-        build.install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n+        builder.install(&src.join(\"README.md\"), &doc, 0o644);\n+        builder.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n+        builder.install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n \n         // Prepare the overlay\n         let overlay = tmp.join(\"rls-overlay\");\n         drop(fs::remove_dir_all(&overlay));\n         t!(fs::create_dir_all(&overlay));\n-        build.install(&src.join(\"README.md\"), &overlay, 0o644);\n-        build.install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n-        build.install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n-        build.create(&overlay.join(\"version\"), &version);\n+        builder.install(&src.join(\"README.md\"), &overlay, 0o644);\n+        builder.install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n+        builder.install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n+        builder.create(&overlay.join(\"version\"), &version);\n \n         // Generate the installer tarball\n         let mut cmd = rust_installer(builder);\n@@ -1176,15 +1166,15 @@ impl Step for Rls {\n            .arg(\"--rel-manifest-dir=rustlib\")\n            .arg(\"--success-message=RLS-ready-to-serve.\")\n            .arg(\"--image-dir\").arg(&image)\n-           .arg(\"--work-dir\").arg(&tmpdir(build))\n-           .arg(\"--output-dir\").arg(&distdir(build))\n+           .arg(\"--work-dir\").arg(&tmpdir(builder))\n+           .arg(\"--output-dir\").arg(&distdir(builder))\n            .arg(\"--non-installed-overlay\").arg(&overlay)\n            .arg(format!(\"--package-name={}-{}\", name, target))\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n            .arg(\"--component-name=rls-preview\");\n \n-        build.run(&mut cmd);\n-        Some(distdir(build).join(format!(\"{}-{}.tar.gz\", name, target)))\n+        builder.run(&mut cmd);\n+        Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target)))\n     }\n }\n \n@@ -1211,46 +1201,45 @@ impl Step for Rustfmt {\n     }\n \n     fn run(self, builder: &Builder) -> Option<PathBuf> {\n-        let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n \n-        build.info(&format!(\"Dist Rustfmt stage{} ({})\", stage, target));\n-        let src = build.src.join(\"src/tools/rustfmt\");\n-        let release_num = build.release_num(\"rustfmt\");\n-        let name = pkgname(build, \"rustfmt\");\n-        let version = build.rustfmt_info.version(build, &release_num);\n+        builder.info(&format!(\"Dist Rustfmt stage{} ({})\", stage, target));\n+        let src = builder.src.join(\"src/tools/rustfmt\");\n+        let release_num = builder.release_num(\"rustfmt\");\n+        let name = pkgname(builder, \"rustfmt\");\n+        let version = builder.rustfmt_info.version(builder, &release_num);\n \n-        let tmp = tmpdir(build);\n+        let tmp = tmpdir(builder);\n         let image = tmp.join(\"rustfmt-image\");\n         drop(fs::remove_dir_all(&image));\n-        build.create_dir(&image);\n+        builder.create_dir(&image);\n \n         // Prepare the image directory\n         let rustfmt = builder.ensure(tool::Rustfmt {\n-            compiler: builder.compiler(stage, build.build),\n+            compiler: builder.compiler(stage, builder.config.build),\n             target, extra_features: Vec::new()\n         }).or_else(|| { println!(\"Unable to build Rustfmt, skipping dist\"); None })?;\n         let cargofmt = builder.ensure(tool::Cargofmt {\n-            compiler: builder.compiler(stage, build.build),\n+            compiler: builder.compiler(stage, builder.config.build),\n             target, extra_features: Vec::new()\n         }).or_else(|| { println!(\"Unable to build Cargofmt, skipping dist\"); None })?;\n \n-        build.install(&rustfmt, &image.join(\"bin\"), 0o755);\n-        build.install(&cargofmt, &image.join(\"bin\"), 0o755);\n+        builder.install(&rustfmt, &image.join(\"bin\"), 0o755);\n+        builder.install(&cargofmt, &image.join(\"bin\"), 0o755);\n         let doc = image.join(\"share/doc/rustfmt\");\n-        build.install(&src.join(\"README.md\"), &doc, 0o644);\n-        build.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n-        build.install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n+        builder.install(&src.join(\"README.md\"), &doc, 0o644);\n+        builder.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n+        builder.install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n \n         // Prepare the overlay\n         let overlay = tmp.join(\"rustfmt-overlay\");\n         drop(fs::remove_dir_all(&overlay));\n-        build.create_dir(&overlay);\n-        build.install(&src.join(\"README.md\"), &overlay, 0o644);\n-        build.install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n-        build.install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n-        build.create(&overlay.join(\"version\"), &version);\n+        builder.create_dir(&overlay);\n+        builder.install(&src.join(\"README.md\"), &overlay, 0o644);\n+        builder.install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n+        builder.install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n+        builder.create(&overlay.join(\"version\"), &version);\n \n         // Generate the installer tarball\n         let mut cmd = rust_installer(builder);\n@@ -1259,15 +1248,15 @@ impl Step for Rustfmt {\n            .arg(\"--rel-manifest-dir=rustlib\")\n            .arg(\"--success-message=rustfmt-ready-to-fmt.\")\n            .arg(\"--image-dir\").arg(&image)\n-           .arg(\"--work-dir\").arg(&tmpdir(build))\n-           .arg(\"--output-dir\").arg(&distdir(build))\n+           .arg(\"--work-dir\").arg(&tmpdir(builder))\n+           .arg(\"--output-dir\").arg(&distdir(builder))\n            .arg(\"--non-installed-overlay\").arg(&overlay)\n            .arg(format!(\"--package-name={}-{}\", name, target))\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n            .arg(\"--component-name=rustfmt-preview\");\n \n-        build.run(&mut cmd);\n-        Some(distdir(build).join(format!(\"{}-{}.tar.gz\", name, target)))\n+        builder.run(&mut cmd);\n+        Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target)))\n     }\n }\n \n@@ -1291,18 +1280,17 @@ impl Step for Extended {\n     fn make_run(run: RunConfig) {\n         run.builder.ensure(Extended {\n             stage: run.builder.top_stage,\n-            host: run.builder.build.build,\n+            host: run.builder.config.build,\n             target: run.target,\n         });\n     }\n \n     /// Creates a combined installer for the specified target in the provided stage.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n \n-        build.info(&format!(\"Dist extended stage{} ({})\", stage, target));\n+        builder.info(&format!(\"Dist extended stage{} ({})\", stage, target));\n \n         let rustc_installer = builder.ensure(Rustc {\n             compiler: builder.compiler(stage, target),\n@@ -1322,21 +1310,21 @@ impl Step for Extended {\n             target,\n         });\n \n-        let tmp = tmpdir(build);\n+        let tmp = tmpdir(builder);\n         let overlay = tmp.join(\"extended-overlay\");\n-        let etc = build.src.join(\"src/etc/installer\");\n+        let etc = builder.src.join(\"src/etc/installer\");\n         let work = tmp.join(\"work\");\n \n         let _ = fs::remove_dir_all(&overlay);\n-        build.install(&build.src.join(\"COPYRIGHT\"), &overlay, 0o644);\n-        build.install(&build.src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n-        build.install(&build.src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n-        let version = build.rust_version();\n-        build.create(&overlay.join(\"version\"), &version);\n-        if let Some(sha) = build.rust_sha() {\n-            build.create(&overlay.join(\"git-commit-hash\"), &sha);\n+        builder.install(&builder.src.join(\"COPYRIGHT\"), &overlay, 0o644);\n+        builder.install(&builder.src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n+        builder.install(&builder.src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n+        let version = builder.rust_version();\n+        builder.create(&overlay.join(\"version\"), &version);\n+        if let Some(sha) = builder.rust_sha() {\n+            builder.create(&overlay.join(\"git-commit-hash\"), &sha);\n         }\n-        build.install(&etc.join(\"README.md\"), &overlay, 0o644);\n+        builder.install(&etc.join(\"README.md\"), &overlay, 0o644);\n \n         // When rust-std package split from rustc, we needed to ensure that during\n         // upgrades rustc was upgraded before rust-std. To avoid rustc clobbering\n@@ -1349,7 +1337,7 @@ impl Step for Extended {\n         tarballs.extend(rustfmt_installer.clone());\n         tarballs.push(analysis_installer);\n         tarballs.push(std_installer);\n-        if build.config.docs {\n+        if builder.config.docs {\n             tarballs.push(docs_installer);\n         }\n         if target.contains(\"pc-windows-gnu\") {\n@@ -1367,17 +1355,17 @@ impl Step for Extended {\n             .arg(\"--rel-manifest-dir=rustlib\")\n             .arg(\"--success-message=Rust-is-ready-to-roll.\")\n             .arg(\"--work-dir\").arg(&work)\n-            .arg(\"--output-dir\").arg(&distdir(build))\n-            .arg(format!(\"--package-name={}-{}\", pkgname(build, \"rust\"), target))\n+            .arg(\"--output-dir\").arg(&distdir(builder))\n+            .arg(format!(\"--package-name={}-{}\", pkgname(builder, \"rust\"), target))\n             .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n             .arg(\"--input-tarballs\").arg(input_tarballs)\n             .arg(\"--non-installed-overlay\").arg(&overlay);\n-        build.run(&mut cmd);\n+        builder.run(&mut cmd);\n \n         let mut license = String::new();\n-        license += &build.read(&build.src.join(\"COPYRIGHT\"));\n-        license += &build.read(&build.src.join(\"LICENSE-APACHE\"));\n-        license += &build.read(&build.src.join(\"LICENSE-MIT\"));\n+        license += &builder.read(&builder.src.join(\"COPYRIGHT\"));\n+        license += &builder.read(&builder.src.join(\"LICENSE-APACHE\"));\n+        license += &builder.read(&builder.src.join(\"LICENSE-MIT\"));\n         license.push_str(\"\\n\");\n         license.push_str(\"\\n\");\n \n@@ -1432,14 +1420,14 @@ impl Step for Extended {\n                     .arg(\"--scripts\").arg(pkg.join(component))\n                     .arg(\"--nopayload\")\n                     .arg(pkg.join(component).with_extension(\"pkg\"));\n-                build.run(&mut cmd);\n+                builder.run(&mut cmd);\n             };\n \n             let prepare = |name: &str| {\n-                build.create_dir(&pkg.join(name));\n-                build.cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, name), target)),\n+                builder.create_dir(&pkg.join(name));\n+                builder.cp_r(&work.join(&format!(\"{}-{}\", pkgname(builder, name), target)),\n                         &pkg.join(name));\n-                build.install(&etc.join(\"pkg/postinstall\"), &pkg.join(name), 0o755);\n+                builder.install(&etc.join(\"pkg/postinstall\"), &pkg.join(name), 0o755);\n                 pkgbuild(name);\n             };\n             prepare(\"rustc\");\n@@ -1453,39 +1441,39 @@ impl Step for Extended {\n             }\n \n             // create an 'uninstall' package\n-            build.install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"uninstall\"), 0o755);\n+            builder.install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"uninstall\"), 0o755);\n             pkgbuild(\"uninstall\");\n \n-            build.create_dir(&pkg.join(\"res\"));\n-            build.create(&pkg.join(\"res/LICENSE.txt\"), &license);\n-            build.install(&etc.join(\"gfx/rust-logo.png\"), &pkg.join(\"res\"), 0o644);\n+            builder.create_dir(&pkg.join(\"res\"));\n+            builder.create(&pkg.join(\"res/LICENSE.txt\"), &license);\n+            builder.install(&etc.join(\"gfx/rust-logo.png\"), &pkg.join(\"res\"), 0o644);\n             let mut cmd = Command::new(\"productbuild\");\n             cmd.arg(\"--distribution\").arg(xform(&etc.join(\"pkg/Distribution.xml\")))\n                 .arg(\"--resources\").arg(pkg.join(\"res\"))\n-                .arg(distdir(build).join(format!(\"{}-{}.pkg\",\n-                                                    pkgname(build, \"rust\"),\n+                .arg(distdir(builder).join(format!(\"{}-{}.pkg\",\n+                                                    pkgname(builder, \"rust\"),\n                                                     target)))\n                 .arg(\"--package-path\").arg(&pkg);\n-            build.run(&mut cmd);\n+            builder.run(&mut cmd);\n         }\n \n         if target.contains(\"windows\") {\n             let exe = tmp.join(\"exe\");\n             let _ = fs::remove_dir_all(&exe);\n \n             let prepare = |name: &str| {\n-                build.create_dir(&exe.join(name));\n+                builder.create_dir(&exe.join(name));\n                 let dir = if name == \"rust-std\" || name == \"rust-analysis\" {\n                     format!(\"{}-{}\", name, target)\n                 } else if name == \"rls\" {\n                     \"rls-preview\".to_string()\n                 } else {\n                     name.to_string()\n                 };\n-                build.cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, name), target))\n+                builder.cp_r(&work.join(&format!(\"{}-{}\", pkgname(builder, name), target))\n                             .join(dir),\n                         &exe.join(name));\n-                build.remove(&exe.join(name).join(\"manifest.in\"));\n+                builder.remove(&exe.join(name).join(\"manifest.in\"));\n             };\n             prepare(\"rustc\");\n             prepare(\"cargo\");\n@@ -1499,11 +1487,11 @@ impl Step for Extended {\n                 prepare(\"rust-mingw\");\n             }\n \n-            build.install(&xform(&etc.join(\"exe/rust.iss\")), &exe, 0o644);\n-            build.install(&etc.join(\"exe/modpath.iss\"), &exe, 0o644);\n-            build.install(&etc.join(\"exe/upgrade.iss\"), &exe, 0o644);\n-            build.install(&etc.join(\"gfx/rust-logo.ico\"), &exe, 0o644);\n-            build.create(&exe.join(\"LICENSE.txt\"), &license);\n+            builder.install(&xform(&etc.join(\"exe/rust.iss\")), &exe, 0o644);\n+            builder.install(&etc.join(\"exe/modpath.iss\"), &exe, 0o644);\n+            builder.install(&etc.join(\"exe/upgrade.iss\"), &exe, 0o644);\n+            builder.install(&etc.join(\"gfx/rust-logo.ico\"), &exe, 0o644);\n+            builder.create(&exe.join(\"LICENSE.txt\"), &license);\n \n             // Generate exe installer\n             let mut cmd = Command::new(\"iscc\");\n@@ -1512,10 +1500,10 @@ impl Step for Extended {\n             if target.contains(\"windows-gnu\") {\n                 cmd.arg(\"/dMINGW\");\n             }\n-            add_env(build, &mut cmd, target);\n-            build.run(&mut cmd);\n-            build.install(&exe.join(format!(\"{}-{}.exe\", pkgname(build, \"rust\"), target)),\n-                    &distdir(build),\n+            add_env(builder, &mut cmd, target);\n+            builder.run(&mut cmd);\n+            builder.install(&exe.join(format!(\"{}-{}.exe\", pkgname(builder, \"rust\"), target)),\n+                    &distdir(builder),\n                     0o755);\n \n             // Generate msi installer\n@@ -1525,7 +1513,7 @@ impl Step for Extended {\n             let light = wix.join(\"bin/light.exe\");\n \n             let heat_flags = [\"-nologo\", \"-gg\", \"-sfrag\", \"-srd\", \"-sreg\"];\n-            build.run(Command::new(&heat)\n+            builder.run(Command::new(&heat)\n                             .current_dir(&exe)\n                             .arg(\"dir\")\n                             .arg(\"rustc\")\n@@ -1534,7 +1522,7 @@ impl Step for Extended {\n                             .arg(\"-dr\").arg(\"Rustc\")\n                             .arg(\"-var\").arg(\"var.RustcDir\")\n                             .arg(\"-out\").arg(exe.join(\"RustcGroup.wxs\")));\n-            build.run(Command::new(&heat)\n+            builder.run(Command::new(&heat)\n                             .current_dir(&exe)\n                             .arg(\"dir\")\n                             .arg(\"rust-docs\")\n@@ -1544,7 +1532,7 @@ impl Step for Extended {\n                             .arg(\"-var\").arg(\"var.DocsDir\")\n                             .arg(\"-out\").arg(exe.join(\"DocsGroup.wxs\"))\n                             .arg(\"-t\").arg(etc.join(\"msi/squash-components.xsl\")));\n-            build.run(Command::new(&heat)\n+            builder.run(Command::new(&heat)\n                             .current_dir(&exe)\n                             .arg(\"dir\")\n                             .arg(\"cargo\")\n@@ -1554,7 +1542,7 @@ impl Step for Extended {\n                             .arg(\"-var\").arg(\"var.CargoDir\")\n                             .arg(\"-out\").arg(exe.join(\"CargoGroup.wxs\"))\n                             .arg(\"-t\").arg(etc.join(\"msi/remove-duplicates.xsl\")));\n-            build.run(Command::new(&heat)\n+            builder.run(Command::new(&heat)\n                             .current_dir(&exe)\n                             .arg(\"dir\")\n                             .arg(\"rust-std\")\n@@ -1564,7 +1552,7 @@ impl Step for Extended {\n                             .arg(\"-var\").arg(\"var.StdDir\")\n                             .arg(\"-out\").arg(exe.join(\"StdGroup.wxs\")));\n             if rls_installer.is_some() {\n-                build.run(Command::new(&heat)\n+                builder.run(Command::new(&heat)\n                                 .current_dir(&exe)\n                                 .arg(\"dir\")\n                                 .arg(\"rls\")\n@@ -1575,7 +1563,7 @@ impl Step for Extended {\n                                 .arg(\"-out\").arg(exe.join(\"RlsGroup.wxs\"))\n                                 .arg(\"-t\").arg(etc.join(\"msi/remove-duplicates.xsl\")));\n             }\n-            build.run(Command::new(&heat)\n+            builder.run(Command::new(&heat)\n                             .current_dir(&exe)\n                             .arg(\"dir\")\n                             .arg(\"rust-analysis\")\n@@ -1586,7 +1574,7 @@ impl Step for Extended {\n                             .arg(\"-out\").arg(exe.join(\"AnalysisGroup.wxs\"))\n                             .arg(\"-t\").arg(etc.join(\"msi/remove-duplicates.xsl\")));\n             if target.contains(\"windows-gnu\") {\n-                build.run(Command::new(&heat)\n+                builder.run(Command::new(&heat)\n                                 .current_dir(&exe)\n                                 .arg(\"dir\")\n                                 .arg(\"rust-mingw\")\n@@ -1612,15 +1600,15 @@ impl Step for Extended {\n                     .arg(\"-arch\").arg(&arch)\n                     .arg(\"-out\").arg(&output)\n                     .arg(&input);\n-                add_env(build, &mut cmd, target);\n+                add_env(builder, &mut cmd, target);\n \n                 if rls_installer.is_some() {\n                     cmd.arg(\"-dRlsDir=rls\");\n                 }\n                 if target.contains(\"windows-gnu\") {\n                     cmd.arg(\"-dGccDir=rust-mingw\");\n                 }\n-                build.run(&mut cmd);\n+                builder.run(&mut cmd);\n             };\n             candle(&xform(&etc.join(\"msi/rust.wxs\")));\n             candle(&etc.join(\"msi/ui.wxs\"));\n@@ -1638,11 +1626,11 @@ impl Step for Extended {\n                 candle(\"GccGroup.wxs\".as_ref());\n             }\n \n-            build.create(&exe.join(\"LICENSE.rtf\"), &rtf);\n-            build.install(&etc.join(\"gfx/banner.bmp\"), &exe, 0o644);\n-            build.install(&etc.join(\"gfx/dialogbg.bmp\"), &exe, 0o644);\n+            builder.create(&exe.join(\"LICENSE.rtf\"), &rtf);\n+            builder.install(&etc.join(\"gfx/banner.bmp\"), &exe, 0o644);\n+            builder.install(&etc.join(\"gfx/dialogbg.bmp\"), &exe, 0o644);\n \n-            let filename = format!(\"{}-{}.msi\", pkgname(build, \"rust\"), target);\n+            let filename = format!(\"{}-{}.msi\", pkgname(builder, \"rust\"), target);\n             let mut cmd = Command::new(&light);\n             cmd.arg(\"-nologo\")\n                 .arg(\"-ext\").arg(\"WixUIExtension\")\n@@ -1668,28 +1656,28 @@ impl Step for Extended {\n             // ICE57 wrongly complains about the shortcuts\n             cmd.arg(\"-sice:ICE57\");\n \n-            build.run(&mut cmd);\n+            builder.run(&mut cmd);\n \n-            if !build.config.dry_run {\n-                t!(fs::rename(exe.join(&filename), distdir(build).join(&filename)));\n+            if !builder.config.dry_run {\n+                t!(fs::rename(exe.join(&filename), distdir(builder).join(&filename)));\n             }\n         }\n     }\n }\n \n-fn add_env(build: &Build, cmd: &mut Command, target: Interned<String>) {\n+fn add_env(builder: &Builder, cmd: &mut Command, target: Interned<String>) {\n     let mut parts = channel::CFG_RELEASE_NUM.split('.');\n-    cmd.env(\"CFG_RELEASE_INFO\", build.rust_version())\n+    cmd.env(\"CFG_RELEASE_INFO\", builder.rust_version())\n        .env(\"CFG_RELEASE_NUM\", channel::CFG_RELEASE_NUM)\n-       .env(\"CFG_RELEASE\", build.rust_release())\n+       .env(\"CFG_RELEASE\", builder.rust_release())\n        .env(\"CFG_VER_MAJOR\", parts.next().unwrap())\n        .env(\"CFG_VER_MINOR\", parts.next().unwrap())\n        .env(\"CFG_VER_PATCH\", parts.next().unwrap())\n        .env(\"CFG_VER_BUILD\", \"0\") // just needed to build\n-       .env(\"CFG_PACKAGE_VERS\", build.rust_package_vers())\n-       .env(\"CFG_PACKAGE_NAME\", pkgname(build, \"rust\"))\n+       .env(\"CFG_PACKAGE_VERS\", builder.rust_package_vers())\n+       .env(\"CFG_PACKAGE_NAME\", pkgname(builder, \"rust\"))\n        .env(\"CFG_BUILD\", target)\n-       .env(\"CFG_CHANNEL\", &build.config.channel);\n+       .env(\"CFG_CHANNEL\", &builder.config.channel);\n \n     if target.contains(\"windows-gnu\") {\n        cmd.env(\"CFG_MINGW\", \"1\")\n@@ -1722,18 +1710,17 @@ impl Step for HashSign {\n     }\n \n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let mut cmd = builder.tool_cmd(Tool::BuildManifest);\n-        if build.config.dry_run {\n+        if builder.config.dry_run {\n             return;\n         }\n-        let sign = build.config.dist_sign_folder.as_ref().unwrap_or_else(|| {\n+        let sign = builder.config.dist_sign_folder.as_ref().unwrap_or_else(|| {\n             panic!(\"\\n\\nfailed to specify `dist.sign-folder` in `config.toml`\\n\\n\")\n         });\n-        let addr = build.config.dist_upload_addr.as_ref().unwrap_or_else(|| {\n+        let addr = builder.config.dist_upload_addr.as_ref().unwrap_or_else(|| {\n             panic!(\"\\n\\nfailed to specify `dist.upload-addr` in `config.toml`\\n\\n\")\n         });\n-        let file = build.config.dist_gpg_password_file.as_ref().unwrap_or_else(|| {\n+        let file = builder.config.dist_gpg_password_file.as_ref().unwrap_or_else(|| {\n             panic!(\"\\n\\nfailed to specify `dist.gpg-password-file` in `config.toml`\\n\\n\")\n         });\n         let mut pass = String::new();\n@@ -1742,15 +1729,15 @@ impl Step for HashSign {\n         let today = output(Command::new(\"date\").arg(\"+%Y-%m-%d\"));\n \n         cmd.arg(sign);\n-        cmd.arg(distdir(build));\n+        cmd.arg(distdir(builder));\n         cmd.arg(today.trim());\n-        cmd.arg(build.rust_package_vers());\n-        cmd.arg(build.package_vers(&build.release_num(\"cargo\")));\n-        cmd.arg(build.package_vers(&build.release_num(\"rls\")));\n-        cmd.arg(build.package_vers(&build.release_num(\"rustfmt\")));\n+        cmd.arg(builder.rust_package_vers());\n+        cmd.arg(builder.package_vers(&builder.release_num(\"cargo\")));\n+        cmd.arg(builder.package_vers(&builder.release_num(\"rls\")));\n+        cmd.arg(builder.package_vers(&builder.release_num(\"rustfmt\")));\n         cmd.arg(addr);\n \n-        build.create_dir(&distdir(build));\n+        builder.create_dir(&distdir(builder));\n \n         let mut child = t!(cmd.stdin(Stdio::piped()).spawn());\n         t!(child.stdin.take().unwrap().write_all(pass.as_bytes()));"}, {"sha": "ae22260c564edf0bb8b5dea95a625246d8b5b145", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 103, "deletions": 115, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/23561c6747b0916e852aaa2a5d04c0b0eeddc6de/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23561c6747b0916e852aaa2a5d04c0b0eeddc6de/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=23561c6747b0916e852aaa2a5d04c0b0eeddc6de", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Documentation generation for rustbuild.\n+//! Documentation generation for rustbuilder.\n //!\n //! This module implements generation for all bits and pieces of documentation\n //! for the Rust project. This notably includes suites like the rust book, the\n@@ -23,7 +23,7 @@ use std::io::prelude::*;\n use std::io;\n use std::path::{PathBuf, Path};\n \n-use {Build, Mode};\n+use Mode;\n use build_helper::up_to_date;\n \n use util::symlink_dir;\n@@ -47,7 +47,7 @@ macro_rules! book {\n \n             fn should_run(run: ShouldRun) -> ShouldRun {\n                 let builder = run.builder;\n-                run.path($path).default_condition(builder.build.config.docs)\n+                run.path($path).default_condition(builder.config.docs)\n             }\n \n             fn make_run(run: RunConfig) {\n@@ -94,7 +94,7 @@ impl Step for Rustbook {\n     /// This will not actually generate any documentation if the documentation has\n     /// already been generated.\n     fn run(self, builder: &Builder) {\n-        let src = builder.build.src.join(\"src/doc\");\n+        let src = builder.src.join(\"src/doc\");\n         builder.ensure(RustbookSrc {\n             target: self.target,\n             name: self.name,\n@@ -114,7 +114,7 @@ impl Step for UnstableBook {\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n-        run.path(\"src/doc/unstable-book\").default_condition(builder.build.config.docs)\n+        run.path(\"src/doc/unstable-book\").default_condition(builder.config.docs)\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -130,7 +130,7 @@ impl Step for UnstableBook {\n         builder.ensure(RustbookSrc {\n             target: self.target,\n             name: INTERNER.intern_str(\"unstable-book\"),\n-            src: builder.build.md_doc_out(self.target),\n+            src: builder.md_doc_out(self.target),\n         })\n     }\n }\n@@ -147,7 +147,7 @@ impl Step for CargoBook {\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n-        run.path(\"src/tools/cargo/src/doc/book\").default_condition(builder.build.config.docs)\n+        run.path(\"src/tools/cargo/src/doc/book\").default_condition(builder.config.docs)\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -158,22 +158,20 @@ impl Step for CargoBook {\n     }\n \n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-\n         let target = self.target;\n         let name = self.name;\n-        let src = build.src.join(\"src/tools/cargo/src/doc\");\n+        let src = builder.src.join(\"src/tools/cargo/src/doc\");\n \n-        let out = build.doc_out(target);\n+        let out = builder.doc_out(target);\n         t!(fs::create_dir_all(&out));\n \n         let out = out.join(name);\n \n-        build.info(&format!(\"Cargo Book ({}) - {}\", target, name));\n+        builder.info(&format!(\"Cargo Book ({}) - {}\", target, name));\n \n         let _ = fs::remove_dir_all(&out);\n \n-        build.run(builder.tool_cmd(Tool::Rustbook)\n+        builder.run(builder.tool_cmd(Tool::Rustbook)\n                        .arg(\"build\")\n                        .arg(&src)\n                        .arg(\"-d\")\n@@ -200,11 +198,10 @@ impl Step for RustbookSrc {\n     /// This will not actually generate any documentation if the documentation has\n     /// already been generated.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let target = self.target;\n         let name = self.name;\n         let src = self.src;\n-        let out = build.doc_out(target);\n+        let out = builder.doc_out(target);\n         t!(fs::create_dir_all(&out));\n \n         let out = out.join(name);\n@@ -215,9 +212,9 @@ impl Step for RustbookSrc {\n         if up_to_date(&src, &index) && up_to_date(&rustbook, &index) {\n             return\n         }\n-        build.info(&format!(\"Rustbook ({}) - {}\", target, name));\n+        builder.info(&format!(\"Rustbook ({}) - {}\", target, name));\n         let _ = fs::remove_dir_all(&out);\n-        build.run(rustbook_cmd\n+        builder.run(rustbook_cmd\n                        .arg(\"build\")\n                        .arg(&src)\n                        .arg(\"-d\")\n@@ -238,12 +235,12 @@ impl Step for TheBook {\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n-        run.path(\"src/doc/book\").default_condition(builder.build.config.docs)\n+        run.path(\"src/doc/book\").default_condition(builder.config.docs)\n     }\n \n     fn make_run(run: RunConfig) {\n         run.builder.ensure(TheBook {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n+            compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n             target: run.target,\n             name: \"book\",\n         });\n@@ -259,7 +256,6 @@ impl Step for TheBook {\n     /// * Index page\n     /// * Redirect pages\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let compiler = self.compiler;\n         let target = self.target;\n         let name = self.name;\n@@ -283,12 +279,12 @@ impl Step for TheBook {\n \n         // build the index page\n         let index = format!(\"{}/index.md\", name);\n-        build.info(&format!(\"Documenting book index ({})\", target));\n+        builder.info(&format!(\"Documenting book index ({})\", target));\n         invoke_rustdoc(builder, compiler, target, &index);\n \n         // build the redirect pages\n-        build.info(&format!(\"Documenting book redirect pages ({})\", target));\n-        for file in t!(fs::read_dir(build.src.join(\"src/doc/book/redirects\"))) {\n+        builder.info(&format!(\"Documenting book redirect pages ({})\", target));\n+        for file in t!(fs::read_dir(builder.src.join(\"src/doc/book/redirects\"))) {\n             let file = t!(file);\n             let path = file.path();\n             let path = path.to_str().unwrap();\n@@ -299,13 +295,12 @@ impl Step for TheBook {\n }\n \n fn invoke_rustdoc(builder: &Builder, compiler: Compiler, target: Interned<String>, markdown: &str) {\n-    let build = builder.build;\n-    let out = build.doc_out(target);\n+    let out = builder.doc_out(target);\n \n-    let path = build.src.join(\"src/doc\").join(markdown);\n+    let path = builder.src.join(\"src/doc\").join(markdown);\n \n-    let favicon = build.src.join(\"src/doc/favicon.inc\");\n-    let footer = build.src.join(\"src/doc/footer.inc\");\n+    let favicon = builder.src.join(\"src/doc/favicon.inc\");\n+    let footer = builder.src.join(\"src/doc/footer.inc\");\n     let version_info = out.join(\"version_info.html\");\n \n     let mut cmd = builder.rustdoc_cmd(compiler.host);\n@@ -323,7 +318,7 @@ fn invoke_rustdoc(builder: &Builder, compiler: Compiler, target: Interned<String\n         .arg(\"--markdown-css\")\n         .arg(\"../rust.css\");\n \n-    build.run(&mut cmd);\n+    builder.run(&mut cmd);\n }\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n@@ -338,12 +333,12 @@ impl Step for Standalone {\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n-        run.path(\"src/doc\").default_condition(builder.build.config.docs)\n+        run.path(\"src/doc\").default_condition(builder.config.docs)\n     }\n \n     fn make_run(run: RunConfig) {\n         run.builder.ensure(Standalone {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n+            compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n             target: run.target,\n         });\n     }\n@@ -357,31 +352,30 @@ impl Step for Standalone {\n     ///\n     /// In the end, this is just a glorified wrapper around rustdoc!\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let target = self.target;\n         let compiler = self.compiler;\n-        build.info(&format!(\"Documenting standalone ({})\", target));\n-        let out = build.doc_out(target);\n+        builder.info(&format!(\"Documenting standalone ({})\", target));\n+        let out = builder.doc_out(target);\n         t!(fs::create_dir_all(&out));\n \n-        let favicon = build.src.join(\"src/doc/favicon.inc\");\n-        let footer = build.src.join(\"src/doc/footer.inc\");\n-        let full_toc = build.src.join(\"src/doc/full-toc.inc\");\n-        t!(fs::copy(build.src.join(\"src/doc/rust.css\"), out.join(\"rust.css\")));\n+        let favicon = builder.src.join(\"src/doc/favicon.inc\");\n+        let footer = builder.src.join(\"src/doc/footer.inc\");\n+        let full_toc = builder.src.join(\"src/doc/full-toc.inc\");\n+        t!(fs::copy(builder.src.join(\"src/doc/rust.css\"), out.join(\"rust.css\")));\n \n-        let version_input = build.src.join(\"src/doc/version_info.html.template\");\n+        let version_input = builder.src.join(\"src/doc/version_info.html.template\");\n         let version_info = out.join(\"version_info.html\");\n \n-        if !build.config.dry_run && !up_to_date(&version_input, &version_info) {\n+        if !builder.config.dry_run && !up_to_date(&version_input, &version_info) {\n             let mut info = String::new();\n             t!(t!(File::open(&version_input)).read_to_string(&mut info));\n-            let info = info.replace(\"VERSION\", &build.rust_release())\n-                           .replace(\"SHORT_HASH\", build.rust_info.sha_short().unwrap_or(\"\"))\n-                           .replace(\"STAMP\", build.rust_info.sha().unwrap_or(\"\"));\n+            let info = info.replace(\"VERSION\", &builder.rust_release())\n+                           .replace(\"SHORT_HASH\", builder.rust_info.sha_short().unwrap_or(\"\"))\n+                           .replace(\"STAMP\", builder.rust_info.sha().unwrap_or(\"\"));\n             t!(t!(File::create(&version_info)).write_all(info.as_bytes()));\n         }\n \n-        for file in t!(fs::read_dir(build.src.join(\"src/doc\"))) {\n+        for file in t!(fs::read_dir(builder.src.join(\"src/doc\"))) {\n             let file = t!(file);\n             let path = file.path();\n             let filename = path.file_name().unwrap().to_str().unwrap();\n@@ -396,7 +390,7 @@ impl Step for Standalone {\n                up_to_date(&favicon, &html) &&\n                up_to_date(&full_toc, &html) &&\n                up_to_date(&version_info, &html) &&\n-               (build.config.dry_run || up_to_date(&rustdoc, &html)) {\n+               (builder.config.dry_run || up_to_date(&rustdoc, &html)) {\n                 continue\n             }\n \n@@ -416,7 +410,7 @@ impl Step for Standalone {\n             } else {\n                 cmd.arg(\"--markdown-css\").arg(\"rust.css\");\n             }\n-            build.run(&mut cmd);\n+            builder.run(&mut cmd);\n         }\n     }\n }\n@@ -433,7 +427,7 @@ impl Step for Std {\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n-        run.all_krates(\"std\").default_condition(builder.build.config.docs)\n+        run.all_krates(\"std\").default_condition(builder.config.docs)\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -448,22 +442,21 @@ impl Step for Std {\n     /// This will generate all documentation for the standard library and its\n     /// dependencies. This is largely just a wrapper around `cargo doc`.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n-        build.info(&format!(\"Documenting stage{} std ({})\", stage, target));\n-        let out = build.doc_out(target);\n+        builder.info(&format!(\"Documenting stage{} std ({})\", stage, target));\n+        let out = builder.doc_out(target);\n         t!(fs::create_dir_all(&out));\n-        let compiler = builder.compiler(stage, build.build);\n+        let compiler = builder.compiler(stage, builder.config.build);\n         let rustdoc = builder.rustdoc(compiler.host);\n-        let compiler = if build.force_use_stage1(compiler, target) {\n+        let compiler = if builder.force_use_stage1(compiler, target) {\n             builder.compiler(1, compiler.host)\n         } else {\n             compiler\n         };\n \n         builder.ensure(compile::Std { compiler, target });\n-        let out_dir = build.stage_out(compiler, Mode::Libstd)\n+        let out_dir = builder.stage_out(compiler, Mode::Libstd)\n                            .join(target).join(\"doc\");\n \n         // Here what we're doing is creating a *symlink* (directory junction on\n@@ -479,9 +472,9 @@ impl Step for Std {\n         //\n         // This way rustdoc generates output directly into the output, and rustdoc\n         // will also directly handle merging.\n-        let my_out = build.crate_doc_out(target);\n-        build.clear_if_dirty(&my_out, &rustdoc);\n-        t!(symlink_dir_force(&build.config, &my_out, &out_dir));\n+        let my_out = builder.crate_doc_out(target);\n+        builder.clear_if_dirty(&my_out, &rustdoc);\n+        t!(symlink_dir_force(&builder.config, &my_out, &out_dir));\n \n         let mut cargo = builder.cargo(compiler, Mode::Libstd, target, \"doc\");\n         compile::std_cargo(builder, &compiler, target, &mut cargo);\n@@ -497,8 +490,8 @@ impl Step for Std {\n             t!(fs::create_dir_all(out_dir.join(krate)));\n         }\n \n-        build.run(&mut cargo);\n-        build.cp_r(&my_out, &out);\n+        builder.run(&mut cargo);\n+        builder.cp_r(&my_out, &out);\n     }\n }\n \n@@ -514,7 +507,7 @@ impl Step for Test {\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n-        run.krate(\"test\").default_condition(builder.build.config.docs)\n+        run.krate(\"test\").default_condition(builder.config.docs)\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -529,15 +522,14 @@ impl Step for Test {\n     /// This will generate all documentation for libtest and its dependencies. This\n     /// is largely just a wrapper around `cargo doc`.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n-        build.info(&format!(\"Documenting stage{} test ({})\", stage, target));\n-        let out = build.doc_out(target);\n+        builder.info(&format!(\"Documenting stage{} test ({})\", stage, target));\n+        let out = builder.doc_out(target);\n         t!(fs::create_dir_all(&out));\n-        let compiler = builder.compiler(stage, build.build);\n+        let compiler = builder.compiler(stage, builder.config.build);\n         let rustdoc = builder.rustdoc(compiler.host);\n-        let compiler = if build.force_use_stage1(compiler, target) {\n+        let compiler = if builder.force_use_stage1(compiler, target) {\n             builder.compiler(1, compiler.host)\n         } else {\n             compiler\n@@ -547,21 +539,21 @@ impl Step for Test {\n         builder.ensure(Std { stage, target });\n \n         builder.ensure(compile::Test { compiler, target });\n-        let out_dir = build.stage_out(compiler, Mode::Libtest)\n+        let out_dir = builder.stage_out(compiler, Mode::Libtest)\n                            .join(target).join(\"doc\");\n \n         // See docs in std above for why we symlink\n-        let my_out = build.crate_doc_out(target);\n-        build.clear_if_dirty(&my_out, &rustdoc);\n+        let my_out = builder.crate_doc_out(target);\n+        builder.clear_if_dirty(&my_out, &rustdoc);\n         t!(symlink_dir_force(&builder.config, &my_out, &out_dir));\n \n         let mut cargo = builder.cargo(compiler, Mode::Libtest, target, \"doc\");\n-        compile::test_cargo(build, &compiler, target, &mut cargo);\n+        compile::test_cargo(builder, &compiler, target, &mut cargo);\n \n         cargo.arg(\"--no-deps\").arg(\"-p\").arg(\"test\");\n \n-        build.run(&mut cargo);\n-        build.cp_r(&my_out, &out);\n+        builder.run(&mut cargo);\n+        builder.cp_r(&my_out, &out);\n     }\n }\n \n@@ -578,7 +570,7 @@ impl Step for WhitelistedRustc {\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n-        run.krate(\"rustc-main\").default_condition(builder.build.config.docs)\n+        run.krate(\"rustc-main\").default_condition(builder.config.docs)\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -598,15 +590,14 @@ impl Step for WhitelistedRustc {\n     /// here as we want to be able to keep it separate from the standard\n     /// documentation. This is largely just a wrapper around `cargo doc`.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n-        build.info(&format!(\"Documenting stage{} whitelisted compiler ({})\", stage, target));\n-        let out = build.doc_out(target);\n+        builder.info(&format!(\"Documenting stage{} whitelisted compiler ({})\", stage, target));\n+        let out = builder.doc_out(target);\n         t!(fs::create_dir_all(&out));\n-        let compiler = builder.compiler(stage, build.build);\n+        let compiler = builder.compiler(stage, builder.config.build);\n         let rustdoc = builder.rustdoc(compiler.host);\n-        let compiler = if build.force_use_stage1(compiler, target) {\n+        let compiler = if builder.force_use_stage1(compiler, target) {\n             builder.compiler(1, compiler.host)\n         } else {\n             compiler\n@@ -616,16 +607,16 @@ impl Step for WhitelistedRustc {\n         builder.ensure(Std { stage, target });\n \n         builder.ensure(compile::Rustc { compiler, target });\n-        let out_dir = build.stage_out(compiler, Mode::Librustc)\n+        let out_dir = builder.stage_out(compiler, Mode::Librustc)\n                            .join(target).join(\"doc\");\n \n         // See docs in std above for why we symlink\n-        let my_out = build.crate_doc_out(target);\n-        build.clear_if_dirty(&my_out, &rustdoc);\n+        let my_out = builder.crate_doc_out(target);\n+        builder.clear_if_dirty(&my_out, &rustdoc);\n         t!(symlink_dir_force(&builder.config, &my_out, &out_dir));\n \n         let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"doc\");\n-        compile::rustc_cargo(build, &mut cargo);\n+        compile::rustc_cargo(builder, &mut cargo);\n \n         // We don't want to build docs for internal compiler dependencies in this\n         // step (there is another step for that). Therefore, we whitelist the crates\n@@ -635,8 +626,8 @@ impl Step for WhitelistedRustc {\n             cargo.arg(\"-p\").arg(krate);\n         }\n \n-        build.run(&mut cargo);\n-        build.cp_r(&my_out, &out);\n+        builder.run(&mut cargo);\n+        builder.cp_r(&my_out, &out);\n     }\n }\n \n@@ -653,7 +644,7 @@ impl Step for Rustc {\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n-        run.krate(\"rustc-main\").default_condition(builder.build.config.docs)\n+        run.krate(\"rustc-main\").default_condition(builder.config.docs)\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -670,39 +661,38 @@ impl Step for Rustc {\n     /// we do not merge it with the other documentation from std, test and\n     /// proc_macros. This is largely just a wrapper around `cargo doc`.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n-        build.info(&format!(\"Documenting stage{} compiler ({})\", stage, target));\n-        let out = build.compiler_doc_out(target);\n+        builder.info(&format!(\"Documenting stage{} compiler ({})\", stage, target));\n+        let out = builder.compiler_doc_out(target);\n         t!(fs::create_dir_all(&out));\n-        let compiler = builder.compiler(stage, build.build);\n+        let compiler = builder.compiler(stage, builder.config.build);\n         let rustdoc = builder.rustdoc(compiler.host);\n-        let compiler = if build.force_use_stage1(compiler, target) {\n+        let compiler = if builder.force_use_stage1(compiler, target) {\n             builder.compiler(1, compiler.host)\n         } else {\n             compiler\n         };\n \n-        if !build.config.compiler_docs {\n-            build.info(&format!(\"\\tskipping - compiler docs disabled\"));\n+        if !builder.config.compiler_docs {\n+            builder.info(&format!(\"\\tskipping - compiler docs disabled\"));\n             return;\n         }\n \n         // Build libstd docs so that we generate relative links\n         builder.ensure(Std { stage, target });\n \n         builder.ensure(compile::Rustc { compiler, target });\n-        let out_dir = build.stage_out(compiler, Mode::Librustc)\n+        let out_dir = builder.stage_out(compiler, Mode::Librustc)\n                            .join(target).join(\"doc\");\n         // We do not symlink to the same shared folder that already contains std library\n         // documentation from previous steps as we do not want to include that.\n-        build.clear_if_dirty(&out, &rustdoc);\n+        builder.clear_if_dirty(&out, &rustdoc);\n         t!(symlink_dir_force(&builder.config, &out, &out_dir));\n \n         let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"doc\");\n         cargo.env(\"RUSTDOCFLAGS\", \"--document-private-items\");\n-        compile::rustc_cargo(build, &mut cargo);\n+        compile::rustc_cargo(builder, &mut cargo);\n \n         // Only include compiler crates, no dependencies of those, such as `libc`.\n         cargo.arg(\"--no-deps\");\n@@ -711,29 +701,29 @@ impl Step for Rustc {\n         let mut compiler_crates = HashSet::new();\n         for root_crate in &[\"rustc\", \"rustc_driver\"] {\n             let interned_root_crate = INTERNER.intern_str(root_crate);\n-            find_compiler_crates(&build, &interned_root_crate, &mut compiler_crates);\n+            find_compiler_crates(builder, &interned_root_crate, &mut compiler_crates);\n         }\n \n         for krate in &compiler_crates {\n             cargo.arg(\"-p\").arg(krate);\n         }\n \n-        build.run(&mut cargo);\n+        builder.run(&mut cargo);\n     }\n }\n \n fn find_compiler_crates(\n-    build: &Build,\n+    builder: &Builder,\n     name: &Interned<String>,\n     crates: &mut HashSet<Interned<String>>\n ) {\n     // Add current crate.\n     crates.insert(*name);\n \n     // Look for dependencies.\n-    for dep in build.crates.get(name).unwrap().deps.iter() {\n-        if build.crates.get(dep).unwrap().is_local(build) {\n-            find_compiler_crates(build, dep, crates);\n+    for dep in builder.crates.get(name).unwrap().deps.iter() {\n+        if builder.crates.get(dep).unwrap().is_local(builder) {\n+            find_compiler_crates(builder, dep, crates);\n         }\n     }\n }\n@@ -750,7 +740,7 @@ impl Step for ErrorIndex {\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n-        run.path(\"src/tools/error_index_generator\").default_condition(builder.build.config.docs)\n+        run.path(\"src/tools/error_index_generator\").default_condition(builder.config.docs)\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -762,21 +752,20 @@ impl Step for ErrorIndex {\n     /// Generates the HTML rendered error-index by running the\n     /// `error_index_generator` tool.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let target = self.target;\n \n-        build.info(&format!(\"Documenting error index ({})\", target));\n-        let out = build.doc_out(target);\n+        builder.info(&format!(\"Documenting error index ({})\", target));\n+        let out = builder.doc_out(target);\n         t!(fs::create_dir_all(&out));\n         let mut index = builder.tool_cmd(Tool::ErrorIndex);\n         index.arg(\"html\");\n         index.arg(out.join(\"error-index.html\"));\n \n         // FIXME: shouldn't have to pass this env var\n-        index.env(\"CFG_BUILD\", &build.build)\n-             .env(\"RUSTC_ERROR_METADATA_DST\", build.extended_error_dir());\n+        index.env(\"CFG_BUILD\", &builder.config.build)\n+             .env(\"RUSTC_ERROR_METADATA_DST\", builder.extended_error_dir());\n \n-        build.run(&mut index);\n+        builder.run(&mut index);\n     }\n }\n \n@@ -792,7 +781,7 @@ impl Step for UnstableBookGen {\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n-        run.path(\"src/tools/unstable-book-gen\").default_condition(builder.build.config.docs)\n+        run.path(\"src/tools/unstable-book-gen\").default_condition(builder.config.docs)\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -802,23 +791,22 @@ impl Step for UnstableBookGen {\n     }\n \n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let target = self.target;\n \n         builder.ensure(compile::Std {\n-            compiler: builder.compiler(builder.top_stage, build.build),\n+            compiler: builder.compiler(builder.top_stage, builder.config.build),\n             target,\n         });\n \n-        build.info(&format!(\"Generating unstable book md files ({})\", target));\n-        let out = build.md_doc_out(target).join(\"unstable-book\");\n-        build.create_dir(&out);\n-        build.remove_dir(&out);\n+        builder.info(&format!(\"Generating unstable book md files ({})\", target));\n+        let out = builder.md_doc_out(target).join(\"unstable-book\");\n+        builder.create_dir(&out);\n+        builder.remove_dir(&out);\n         let mut cmd = builder.tool_cmd(Tool::UnstableBookGen);\n-        cmd.arg(build.src.join(\"src\"));\n+        cmd.arg(builder.src.join(\"src\"));\n         cmd.arg(out);\n \n-        build.run(&mut cmd);\n+        builder.run(&mut cmd);\n     }\n }\n "}, {"sha": "b37a007e86390249fec901326a0220ddd6ab11ba", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/23561c6747b0916e852aaa2a5d04c0b0eeddc6de/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23561c6747b0916e852aaa2a5d04c0b0eeddc6de/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=23561c6747b0916e852aaa2a5d04c0b0eeddc6de", "patch": "@@ -62,8 +62,7 @@ fn install_sh(\n     stage: u32,\n     host: Option<Interned<String>>\n ) {\n-    let build = builder.build;\n-    build.info(&format!(\"Install {} stage{} ({:?})\", package, stage, host));\n+    builder.info(&format!(\"Install {} stage{} ({:?})\", package, stage, host));\n \n     let prefix_default = PathBuf::from(\"/usr/local\");\n     let sysconfdir_default = PathBuf::from(\"/etc\");\n@@ -72,15 +71,15 @@ fn install_sh(\n     let bindir_default = PathBuf::from(\"bin\");\n     let libdir_default = PathBuf::from(\"lib\");\n     let mandir_default = datadir_default.join(\"man\");\n-    let prefix = build.config.prefix.as_ref().map_or(prefix_default, |p| {\n+    let prefix = builder.config.prefix.as_ref().map_or(prefix_default, |p| {\n         fs::canonicalize(p).expect(&format!(\"could not canonicalize {}\", p.display()))\n     });\n-    let sysconfdir = build.config.sysconfdir.as_ref().unwrap_or(&sysconfdir_default);\n-    let datadir = build.config.datadir.as_ref().unwrap_or(&datadir_default);\n-    let docdir = build.config.docdir.as_ref().unwrap_or(&docdir_default);\n-    let bindir = build.config.bindir.as_ref().unwrap_or(&bindir_default);\n-    let libdir = build.config.libdir.as_ref().unwrap_or(&libdir_default);\n-    let mandir = build.config.mandir.as_ref().unwrap_or(&mandir_default);\n+    let sysconfdir = builder.config.sysconfdir.as_ref().unwrap_or(&sysconfdir_default);\n+    let datadir = builder.config.datadir.as_ref().unwrap_or(&datadir_default);\n+    let docdir = builder.config.docdir.as_ref().unwrap_or(&docdir_default);\n+    let bindir = builder.config.bindir.as_ref().unwrap_or(&bindir_default);\n+    let libdir = builder.config.libdir.as_ref().unwrap_or(&libdir_default);\n+    let mandir = builder.config.mandir.as_ref().unwrap_or(&mandir_default);\n \n     let sysconfdir = prefix.join(sysconfdir);\n     let datadir = prefix.join(datadir);\n@@ -99,18 +98,18 @@ fn install_sh(\n     let libdir = add_destdir(&libdir, &destdir);\n     let mandir = add_destdir(&mandir, &destdir);\n \n-    let empty_dir = build.out.join(\"tmp/empty_dir\");\n+    let empty_dir = builder.out.join(\"tmp/empty_dir\");\n \n     t!(fs::create_dir_all(&empty_dir));\n     let package_name = if let Some(host) = host {\n-        format!(\"{}-{}\", pkgname(build, name), host)\n+        format!(\"{}-{}\", pkgname(builder, name), host)\n     } else {\n-        pkgname(build, name)\n+        pkgname(builder, name)\n     };\n \n     let mut cmd = Command::new(\"sh\");\n     cmd.current_dir(&empty_dir)\n-        .arg(sanitize_sh(&tmpdir(build).join(&package_name).join(\"install.sh\")))\n+        .arg(sanitize_sh(&tmpdir(builder).join(&package_name).join(\"install.sh\")))\n         .arg(format!(\"--prefix={}\", sanitize_sh(&prefix)))\n         .arg(format!(\"--sysconfdir={}\", sanitize_sh(&sysconfdir)))\n         .arg(format!(\"--datadir={}\", sanitize_sh(&datadir)))\n@@ -119,7 +118,7 @@ fn install_sh(\n         .arg(format!(\"--libdir={}\", sanitize_sh(&libdir)))\n         .arg(format!(\"--mandir={}\", sanitize_sh(&mandir)))\n         .arg(\"--disable-ldconfig\");\n-    build.run(&mut cmd);\n+    builder.run(&mut cmd);\n     t!(fs::remove_dir_all(&empty_dir));\n }\n \n@@ -180,7 +179,7 @@ macro_rules! install {\n                 run.builder.ensure($name {\n                     stage: run.builder.top_stage,\n                     target: run.target,\n-                    host: run.builder.build.build,\n+                    host: run.builder.config.build,\n                 });\n             }\n \n@@ -197,7 +196,7 @@ install!((self, builder, _config),\n         install_docs(builder, self.stage, self.target);\n     };\n     Std, \"src/libstd\", true, only_hosts: true, {\n-        for target in &builder.build.targets {\n+        for target in &builder.targets {\n             builder.ensure(dist::Std {\n                 compiler: builder.compiler(self.stage, self.host),\n                 target: *target"}, {"sha": "2c2cf74d9790f554acf00e7da21a778d68820b46", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 69, "deletions": 73, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/23561c6747b0916e852aaa2a5d04c0b0eeddc6de/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23561c6747b0916e852aaa2a5d04c0b0eeddc6de/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=23561c6747b0916e852aaa2a5d04c0b0eeddc6de", "patch": "@@ -29,7 +29,6 @@ use build_helper::output;\n use cmake;\n use cc;\n \n-use Build;\n use util::{self, exe};\n use build_helper::up_to_date;\n use builder::{Builder, RunConfig, ShouldRun, Step};\n@@ -60,39 +59,38 @@ impl Step for Llvm {\n \n     /// Compile LLVM for `target`.\n     fn run(self, builder: &Builder) -> PathBuf {\n-        let build = builder.build;\n         let target = self.target;\n         let emscripten = self.emscripten;\n \n         // If we're using a custom LLVM bail out here, but we can only use a\n         // custom LLVM for the build triple.\n         if !self.emscripten {\n-            if let Some(config) = build.config.target_config.get(&target) {\n+            if let Some(config) = builder.config.target_config.get(&target) {\n                 if let Some(ref s) = config.llvm_config {\n-                    check_llvm_version(build, s);\n+                    check_llvm_version(builder, s);\n                     return s.to_path_buf()\n                 }\n             }\n         }\n \n-        let rebuild_trigger = build.src.join(\"src/rustllvm/llvm-rebuild-trigger\");\n+        let rebuild_trigger = builder.src.join(\"src/rustllvm/llvm-rebuild-trigger\");\n         let mut rebuild_trigger_contents = String::new();\n         t!(t!(File::open(&rebuild_trigger)).read_to_string(&mut rebuild_trigger_contents));\n \n         let (out_dir, llvm_config_ret_dir) = if emscripten {\n-            let dir = build.emscripten_llvm_out(target);\n+            let dir = builder.emscripten_llvm_out(target);\n             let config_dir = dir.join(\"bin\");\n             (dir, config_dir)\n         } else {\n-            let mut dir = build.llvm_out(build.config.build);\n-            if !build.config.build.contains(\"msvc\") || build.config.ninja {\n+            let mut dir = builder.llvm_out(builder.config.build);\n+            if !builder.config.build.contains(\"msvc\") || builder.config.ninja {\n                 dir.push(\"build\");\n             }\n-            (build.llvm_out(target), dir.join(\"bin\"))\n+            (builder.llvm_out(target), dir.join(\"bin\"))\n         };\n         let done_stamp = out_dir.join(\"llvm-finished-building\");\n         let build_llvm_config = llvm_config_ret_dir\n-            .join(exe(\"llvm-config\", &*build.config.build));\n+            .join(exe(\"llvm-config\", &*builder.config.build));\n         if done_stamp.exists() {\n             let mut done_contents = String::new();\n             t!(t!(File::open(&done_stamp)).read_to_string(&mut done_contents));\n@@ -104,17 +102,17 @@ impl Step for Llvm {\n             }\n         }\n \n-        let _folder = build.fold_output(|| \"llvm\");\n+        let _folder = builder.fold_output(|| \"llvm\");\n         let descriptor = if emscripten { \"Emscripten \" } else { \"\" };\n-        build.info(&format!(\"Building {}LLVM for {}\", descriptor, target));\n-        let _time = util::timeit(&build);\n+        builder.info(&format!(\"Building {}LLVM for {}\", descriptor, target));\n+        let _time = util::timeit(&builder);\n         t!(fs::create_dir_all(&out_dir));\n \n         // http://llvm.org/docs/CMake.html\n         let root = if self.emscripten { \"src/llvm-emscripten\" } else { \"src/llvm\" };\n-        let mut cfg = cmake::Config::new(build.src.join(root));\n+        let mut cfg = cmake::Config::new(builder.src.join(root));\n \n-        let profile = match (build.config.llvm_optimize, build.config.llvm_release_debuginfo) {\n+        let profile = match (builder.config.llvm_optimize, builder.config.llvm_release_debuginfo) {\n             (false, _) => \"Debug\",\n             (true, false) => \"Release\",\n             (true, true) => \"RelWithDebInfo\",\n@@ -125,7 +123,7 @@ impl Step for Llvm {\n         let llvm_targets = if self.emscripten {\n             \"JSBackend\"\n         } else {\n-            match build.config.llvm_targets {\n+            match builder.config.llvm_targets {\n                 Some(ref s) => s,\n                 None => \"X86;ARM;AArch64;Mips;PowerPC;SystemZ;MSP430;Sparc;NVPTX;Hexagon\",\n             }\n@@ -134,10 +132,10 @@ impl Step for Llvm {\n         let llvm_exp_targets = if self.emscripten {\n             \"\"\n         } else {\n-            &build.config.llvm_experimental_targets[..]\n+            &builder.config.llvm_experimental_targets[..]\n         };\n \n-        let assertions = if build.config.llvm_assertions {\"ON\"} else {\"OFF\"};\n+        let assertions = if builder.config.llvm_assertions {\"ON\"} else {\"OFF\"};\n \n         cfg.out_dir(&out_dir)\n            .profile(profile)\n@@ -151,7 +149,7 @@ impl Step for Llvm {\n            .define(\"WITH_POLLY\", \"OFF\")\n            .define(\"LLVM_ENABLE_TERMINFO\", \"OFF\")\n            .define(\"LLVM_ENABLE_LIBEDIT\", \"OFF\")\n-           .define(\"LLVM_PARALLEL_COMPILE_JOBS\", build.jobs().to_string())\n+           .define(\"LLVM_PARALLEL_COMPILE_JOBS\", builder.jobs().to_string())\n            .define(\"LLVM_TARGET_ARCH\", target.split('-').next().unwrap())\n            .define(\"LLVM_DEFAULT_TARGET_TRIPLE\", target);\n \n@@ -183,22 +181,22 @@ impl Step for Llvm {\n             cfg.define(\"LLVM_BUILD_32_BITS\", \"ON\");\n         }\n \n-        if let Some(num_linkers) = build.config.llvm_link_jobs {\n+        if let Some(num_linkers) = builder.config.llvm_link_jobs {\n             if num_linkers > 0 {\n                 cfg.define(\"LLVM_PARALLEL_LINK_JOBS\", num_linkers.to_string());\n             }\n         }\n \n         // http://llvm.org/docs/HowToCrossCompileLLVM.html\n-        if target != build.build && !emscripten {\n+        if target != builder.config.build && !emscripten {\n             builder.ensure(Llvm {\n-                target: build.build,\n+                target: builder.config.build,\n                 emscripten: false,\n             });\n             // FIXME: if the llvm root for the build triple is overridden then we\n             //        should use llvm-tblgen from there, also should verify that it\n             //        actually exists most of the time in normal installs of LLVM.\n-            let host = build.llvm_out(build.build).join(\"bin/llvm-tblgen\");\n+            let host = builder.llvm_out(builder.config.build).join(\"bin/llvm-tblgen\");\n             cfg.define(\"CMAKE_CROSSCOMPILING\", \"True\")\n                .define(\"LLVM_TABLEGEN\", &host);\n \n@@ -208,10 +206,10 @@ impl Step for Llvm {\n                cfg.define(\"CMAKE_SYSTEM_NAME\", \"FreeBSD\");\n             }\n \n-            cfg.define(\"LLVM_NATIVE_BUILD\", build.llvm_out(build.build).join(\"build\"));\n+            cfg.define(\"LLVM_NATIVE_BUILD\", builder.llvm_out(builder.config.build).join(\"build\"));\n         }\n \n-        configure_cmake(build, target, &mut cfg, false);\n+        configure_cmake(builder, target, &mut cfg, false);\n \n         // FIXME: we don't actually need to build all LLVM tools and all LLVM\n         //        libraries here, e.g. we just want a few components and a few\n@@ -230,12 +228,12 @@ impl Step for Llvm {\n     }\n }\n \n-fn check_llvm_version(build: &Build, llvm_config: &Path) {\n-    if !build.config.llvm_version_check {\n+fn check_llvm_version(builder: &Builder, llvm_config: &Path) {\n+    if !builder.config.llvm_version_check {\n         return\n     }\n \n-    if build.config.dry_run {\n+    if builder.config.dry_run {\n         return;\n     }\n \n@@ -251,15 +249,15 @@ fn check_llvm_version(build: &Build, llvm_config: &Path) {\n     panic!(\"\\n\\nbad LLVM version: {}, need >=3.9\\n\\n\", version)\n }\n \n-fn configure_cmake(build: &Build,\n+fn configure_cmake(builder: &Builder,\n                    target: Interned<String>,\n                    cfg: &mut cmake::Config,\n                    building_dist_binaries: bool) {\n-    if build.config.ninja {\n+    if builder.config.ninja {\n         cfg.generator(\"Ninja\");\n     }\n     cfg.target(&target)\n-       .host(&build.config.build);\n+       .host(&builder.config.build);\n \n     let sanitize_cc = |cc: &Path| {\n         if target.contains(\"msvc\") {\n@@ -272,29 +270,29 @@ fn configure_cmake(build: &Build,\n     // MSVC with CMake uses msbuild by default which doesn't respect these\n     // vars that we'd otherwise configure. In that case we just skip this\n     // entirely.\n-    if target.contains(\"msvc\") && !build.config.ninja {\n+    if target.contains(\"msvc\") && !builder.config.ninja {\n         return\n     }\n \n-    let cc = build.cc(target);\n-    let cxx = build.cxx(target).unwrap();\n+    let cc = builder.cc(target);\n+    let cxx = builder.cxx(target).unwrap();\n \n     // Handle msvc + ninja + ccache specially (this is what the bots use)\n     if target.contains(\"msvc\") &&\n-       build.config.ninja &&\n-       build.config.ccache.is_some() {\n+       builder.config.ninja &&\n+       builder.config.ccache.is_some() {\n         let mut cc = env::current_exe().expect(\"failed to get cwd\");\n         cc.set_file_name(\"sccache-plus-cl.exe\");\n \n        cfg.define(\"CMAKE_C_COMPILER\", sanitize_cc(&cc))\n           .define(\"CMAKE_CXX_COMPILER\", sanitize_cc(&cc));\n        cfg.env(\"SCCACHE_PATH\",\n-               build.config.ccache.as_ref().unwrap())\n+               builder.config.ccache.as_ref().unwrap())\n           .env(\"SCCACHE_TARGET\", target);\n \n     // If ccache is configured we inform the build a little differently hwo\n     // to invoke ccache while also invoking our compilers.\n-    } else if let Some(ref ccache) = build.config.ccache {\n+    } else if let Some(ref ccache) = builder.config.ccache {\n        cfg.define(\"CMAKE_C_COMPILER\", ccache)\n           .define(\"CMAKE_C_COMPILER_ARG1\", sanitize_cc(cc))\n           .define(\"CMAKE_CXX_COMPILER\", ccache)\n@@ -304,16 +302,16 @@ fn configure_cmake(build: &Build,\n           .define(\"CMAKE_CXX_COMPILER\", sanitize_cc(cxx));\n     }\n \n-    cfg.build_arg(\"-j\").build_arg(build.jobs().to_string());\n-    cfg.define(\"CMAKE_C_FLAGS\", build.cflags(target).join(\" \"));\n-    let mut cxxflags = build.cflags(target).join(\" \");\n+    cfg.build_arg(\"-j\").build_arg(builder.jobs().to_string());\n+    cfg.define(\"CMAKE_C_FLAGS\", builder.cflags(target).join(\" \"));\n+    let mut cxxflags = builder.cflags(target).join(\" \");\n     if building_dist_binaries {\n-        if build.config.llvm_static_stdcpp && !target.contains(\"windows\") {\n+        if builder.config.llvm_static_stdcpp && !target.contains(\"windows\") {\n             cxxflags.push_str(\" -static-libstdc++\");\n         }\n     }\n     cfg.define(\"CMAKE_CXX_FLAGS\", cxxflags);\n-    if let Some(ar) = build.ar(target) {\n+    if let Some(ar) = builder.ar(target) {\n         if ar.is_absolute() {\n             // LLVM build breaks if `CMAKE_AR` is a relative path, for some reason it\n             // tries to resolve this path in the LLVM build directory.\n@@ -349,26 +347,25 @@ impl Step for Lld {\n             return PathBuf::from(\"lld-out-dir-test-gen\");\n         }\n         let target = self.target;\n-        let build = builder.build;\n \n         let llvm_config = builder.ensure(Llvm {\n             target: self.target,\n             emscripten: false,\n         });\n \n-        let out_dir = build.lld_out(target);\n+        let out_dir = builder.lld_out(target);\n         let done_stamp = out_dir.join(\"lld-finished-building\");\n         if done_stamp.exists() {\n             return out_dir\n         }\n \n-        let _folder = build.fold_output(|| \"lld\");\n-        build.info(&format!(\"Building LLD for {}\", target));\n-        let _time = util::timeit(&build);\n+        let _folder = builder.fold_output(|| \"lld\");\n+        builder.info(&format!(\"Building LLD for {}\", target));\n+        let _time = util::timeit(&builder);\n         t!(fs::create_dir_all(&out_dir));\n \n-        let mut cfg = cmake::Config::new(build.src.join(\"src/tools/lld\"));\n-        configure_cmake(build, target, &mut cfg, true);\n+        let mut cfg = cmake::Config::new(builder.src.join(\"src/tools/lld\"));\n+        configure_cmake(builder, target, &mut cfg, true);\n \n         cfg.out_dir(&out_dir)\n            .profile(\"Release\")\n@@ -404,37 +401,36 @@ impl Step for TestHelpers {\n         if builder.config.dry_run {\n             return;\n         }\n-        let build = builder.build;\n         let target = self.target;\n-        let dst = build.test_helpers_out(target);\n-        let src = build.src.join(\"src/test/auxiliary/rust_test_helpers.c\");\n+        let dst = builder.test_helpers_out(target);\n+        let src = builder.src.join(\"src/test/auxiliary/rust_test_helpers.c\");\n         if up_to_date(&src, &dst.join(\"librust_test_helpers.a\")) {\n             return\n         }\n \n-        let _folder = build.fold_output(|| \"build_test_helpers\");\n-        build.info(&format!(\"Building test helpers\"));\n+        let _folder = builder.fold_output(|| \"build_test_helpers\");\n+        builder.info(&format!(\"Building test helpers\"));\n         t!(fs::create_dir_all(&dst));\n         let mut cfg = cc::Build::new();\n \n         // We may have found various cross-compilers a little differently due to our\n         // extra configuration, so inform gcc of these compilers. Note, though, that\n         // on MSVC we still need gcc's detection of env vars (ugh).\n         if !target.contains(\"msvc\") {\n-            if let Some(ar) = build.ar(target) {\n+            if let Some(ar) = builder.ar(target) {\n                 cfg.archiver(ar);\n             }\n-            cfg.compiler(build.cc(target));\n+            cfg.compiler(builder.cc(target));\n         }\n \n         cfg.cargo_metadata(false)\n            .out_dir(&dst)\n            .target(&target)\n-           .host(&build.build)\n+           .host(&builder.config.build)\n            .opt_level(0)\n            .warnings(false)\n            .debug(false)\n-           .file(build.src.join(\"src/test/auxiliary/rust_test_helpers.c\"))\n+           .file(builder.src.join(\"src/test/auxiliary/rust_test_helpers.c\"))\n            .compile(\"rust_test_helpers\");\n     }\n }\n@@ -459,9 +455,8 @@ impl Step for Openssl {\n         if builder.config.dry_run {\n             return;\n         }\n-        let build = builder.build;\n         let target = self.target;\n-        let out = match build.openssl_dir(target) {\n+        let out = match builder.openssl_dir(target) {\n             Some(dir) => dir,\n             None => return,\n         };\n@@ -497,7 +492,8 @@ impl Step for Openssl {\n                 }\n \n                 // Ensure the hash is correct.\n-                let mut shasum = if target.contains(\"apple\") || build.build.contains(\"netbsd\") {\n+                let mut shasum = if target.contains(\"apple\") ||\n+                    builder.config.build.contains(\"netbsd\") {\n                     let mut cmd = Command::new(\"shasum\");\n                     cmd.arg(\"-a\").arg(\"256\");\n                     cmd\n@@ -530,10 +526,10 @@ impl Step for Openssl {\n             t!(fs::rename(&tmp, &tarball));\n         }\n         let obj = out.join(format!(\"openssl-{}\", OPENSSL_VERS));\n-        let dst = build.openssl_install_dir(target).unwrap();\n+        let dst = builder.openssl_install_dir(target).unwrap();\n         drop(fs::remove_dir_all(&obj));\n         drop(fs::remove_dir_all(&dst));\n-        build.run(Command::new(\"tar\").arg(\"zxf\").arg(&tarball).current_dir(&out));\n+        builder.run(Command::new(\"tar\").arg(\"zxf\").arg(&tarball).current_dir(&out));\n \n         let mut configure = Command::new(\"perl\");\n         configure.arg(obj.join(\"Configure\"));\n@@ -583,8 +579,8 @@ impl Step for Openssl {\n             _ => panic!(\"don't know how to configure OpenSSL for {}\", target),\n         };\n         configure.arg(os);\n-        configure.env(\"CC\", build.cc(target));\n-        for flag in build.cflags(target) {\n+        configure.env(\"CC\", builder.cc(target));\n+        for flag in builder.cflags(target) {\n             configure.arg(flag);\n         }\n         // There is no specific os target for android aarch64 or x86_64,\n@@ -596,7 +592,7 @@ impl Step for Openssl {\n         if target == \"sparc64-unknown-netbsd\" {\n             // Need -m64 to get assembly generated correctly for sparc64.\n             configure.arg(\"-m64\");\n-            if build.build.contains(\"netbsd\") {\n+            if builder.config.build.contains(\"netbsd\") {\n                 // Disable sparc64 asm on NetBSD builders, it uses\n                 // m4(1)'s -B flag, which NetBSD m4 does not support.\n                 configure.arg(\"no-asm\");\n@@ -609,12 +605,12 @@ impl Step for Openssl {\n             configure.arg(\"no-asm\");\n         }\n         configure.current_dir(&obj);\n-        build.info(&format!(\"Configuring openssl for {}\", target));\n-        build.run_quiet(&mut configure);\n-        build.info(&format!(\"Building openssl for {}\", target));\n-        build.run_quiet(Command::new(\"make\").arg(\"-j1\").current_dir(&obj));\n-        build.info(&format!(\"Installing openssl for {}\", target));\n-        build.run_quiet(Command::new(\"make\").arg(\"install\").arg(\"-j1\").current_dir(&obj));\n+        builder.info(&format!(\"Configuring openssl for {}\", target));\n+        builder.run_quiet(&mut configure);\n+        builder.info(&format!(\"Building openssl for {}\", target));\n+        builder.run_quiet(Command::new(\"make\").arg(\"-j1\").current_dir(&obj));\n+        builder.info(&format!(\"Installing openssl for {}\", target));\n+        builder.run_quiet(Command::new(\"make\").arg(\"install\").arg(\"-j1\").current_dir(&obj));\n \n         let mut f = t!(File::create(&stamp));\n         t!(f.write_all(OPENSSL_VERS.as_bytes()));"}, {"sha": "3d954cd5d848ca39423c900f36eecaec5efdfbed", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 153, "deletions": 172, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/23561c6747b0916e852aaa2a5d04c0b0eeddc6de/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23561c6747b0916e852aaa2a5d04c0b0eeddc6de/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=23561c6747b0916e852aaa2a5d04c0b0eeddc6de", "patch": "@@ -32,7 +32,7 @@ use dist;\n use native;\n use tool::{self, Tool};\n use util::{self, dylib_path, dylib_path_var};\n-use {Build, Mode};\n+use Mode;\n use toolstate::ToolState;\n \n const ADB_TEST_DIR: &str = \"/data/tmp/work\";\n@@ -65,28 +65,28 @@ impl fmt::Display for TestKind {\n     }\n }\n \n-fn try_run(build: &Build, cmd: &mut Command) -> bool {\n-    if !build.fail_fast {\n-        if !build.try_run(cmd) {\n-            let mut failures = build.delayed_failures.borrow_mut();\n+fn try_run(builder: &Builder, cmd: &mut Command) -> bool {\n+    if !builder.fail_fast {\n+        if !builder.try_run(cmd) {\n+            let mut failures = builder.delayed_failures.borrow_mut();\n             failures.push(format!(\"{:?}\", cmd));\n             return false;\n         }\n     } else {\n-        build.run(cmd);\n+        builder.run(cmd);\n     }\n     true\n }\n \n-fn try_run_quiet(build: &Build, cmd: &mut Command) -> bool {\n-    if !build.fail_fast {\n-        if !build.try_run_quiet(cmd) {\n-            let mut failures = build.delayed_failures.borrow_mut();\n+fn try_run_quiet(builder: &Builder, cmd: &mut Command) -> bool {\n+    if !builder.fail_fast {\n+        if !builder.try_run_quiet(cmd) {\n+            let mut failures = builder.delayed_failures.borrow_mut();\n             failures.push(format!(\"{:?}\", cmd));\n             return false;\n         }\n     } else {\n-        build.run_quiet(cmd);\n+        builder.run_quiet(cmd);\n     }\n     true\n }\n@@ -106,21 +106,20 @@ impl Step for Linkcheck {\n     /// This tool in `src/tools` will verify the validity of all our links in the\n     /// documentation to ensure we don't have a bunch of dead ones.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let host = self.host;\n \n-        build.info(&format!(\"Linkcheck ({})\", host));\n+        builder.info(&format!(\"Linkcheck ({})\", host));\n \n         builder.default_doc(None);\n \n-        let _time = util::timeit(&build);\n-        try_run(build, builder.tool_cmd(Tool::Linkchecker)\n-                              .arg(build.out.join(host).join(\"doc\")));\n+        let _time = util::timeit(&builder);\n+        try_run(builder, builder.tool_cmd(Tool::Linkchecker)\n+                              .arg(builder.out.join(host).join(\"doc\")));\n     }\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n-        run.path(\"src/tools/linkchecker\").default_condition(builder.build.config.docs)\n+        run.path(\"src/tools/linkchecker\").default_condition(builder.config.docs)\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -154,19 +153,18 @@ impl Step for Cargotest {\n     /// This tool in `src/tools` will check out a few Rust projects and run `cargo\n     /// test` to ensure that we don't regress the test suites there.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let compiler = builder.compiler(self.stage, self.host);\n         builder.ensure(compile::Rustc { compiler, target: compiler.host });\n \n         // Note that this is a short, cryptic, and not scoped directory name. This\n         // is currently to minimize the length of path on Windows where we otherwise\n         // quickly run into path name limit constraints.\n-        let out_dir = build.out.join(\"ct\");\n+        let out_dir = builder.out.join(\"ct\");\n         t!(fs::create_dir_all(&out_dir));\n \n-        let _time = util::timeit(&build);\n+        let _time = util::timeit(&builder);\n         let mut cmd = builder.tool_cmd(Tool::CargoTest);\n-        try_run(build, cmd.arg(&build.initial_cargo)\n+        try_run(builder, cmd.arg(&builder.initial_cargo)\n                           .arg(&out_dir)\n                           .env(\"RUSTC\", builder.rustc(compiler))\n                           .env(\"RUSTDOC\", builder.rustdoc(compiler.host)));\n@@ -196,13 +194,12 @@ impl Step for Cargo {\n \n     /// Runs `cargo test` for `cargo` packaged with Rust.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let compiler = builder.compiler(self.stage, self.host);\n \n         builder.ensure(tool::Cargo { compiler, target: self.host });\n         let mut cargo = builder.cargo(compiler, Mode::Tool, self.host, \"test\");\n-        cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/cargo/Cargo.toml\"));\n-        if !build.fail_fast {\n+        cargo.arg(\"--manifest-path\").arg(builder.src.join(\"src/tools/cargo/Cargo.toml\"));\n+        if !builder.fail_fast {\n             cargo.arg(\"--no-fail-fast\");\n         }\n \n@@ -213,7 +210,7 @@ impl Step for Cargo {\n         // available.\n         cargo.env(\"CFG_DISABLE_CROSS_TESTS\", \"1\");\n \n-        try_run(build, cargo.env(\"PATH\", &path_for_cargo(builder, compiler)));\n+        try_run(builder, cargo.env(\"PATH\", &path_for_cargo(builder, compiler)));\n     }\n }\n \n@@ -240,7 +237,6 @@ impl Step for Rls {\n \n     /// Runs `cargo test` for the rls.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let stage = self.stage;\n         let host = self.host;\n         let compiler = builder.compiler(stage, host);\n@@ -257,8 +253,8 @@ impl Step for Rls {\n \n         builder.add_rustc_lib_path(compiler, &mut cargo);\n \n-        if try_run(build, &mut cargo) {\n-            build.save_toolstate(\"rls\", ToolState::TestPass);\n+        if try_run(builder, &mut cargo) {\n+            builder.save_toolstate(\"rls\", ToolState::TestPass);\n         }\n     }\n }\n@@ -286,7 +282,6 @@ impl Step for Rustfmt {\n \n     /// Runs `cargo test` for rustfmt.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let stage = self.stage;\n         let host = self.host;\n         let compiler = builder.compiler(stage, host);\n@@ -303,8 +298,8 @@ impl Step for Rustfmt {\n \n         builder.add_rustc_lib_path(compiler, &mut cargo);\n \n-        if try_run(build, &mut cargo) {\n-            build.save_toolstate(\"rustfmt\", ToolState::TestPass);\n+        if try_run(builder, &mut cargo) {\n+            builder.save_toolstate(\"rustfmt\", ToolState::TestPass);\n         }\n     }\n }\n@@ -321,7 +316,7 @@ impl Step for Miri {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        let test_miri = run.builder.build.config.test_miri;\n+        let test_miri = run.builder.config.test_miri;\n         run.path(\"src/tools/miri\").default_condition(test_miri)\n     }\n \n@@ -334,7 +329,6 @@ impl Step for Miri {\n \n     /// Runs `cargo test` for miri.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let stage = self.stage;\n         let host = self.host;\n         let compiler = builder.compiler(stage, host);\n@@ -346,7 +340,7 @@ impl Step for Miri {\n         });\n         if let Some(miri) = miri {\n             let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n-            cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/miri/Cargo.toml\"));\n+            cargo.arg(\"--manifest-path\").arg(builder.src.join(\"src/tools/miri/Cargo.toml\"));\n \n             // Don't build tests dynamically, just a pain to work with\n             cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n@@ -358,8 +352,8 @@ impl Step for Miri {\n \n             builder.add_rustc_lib_path(compiler, &mut cargo);\n \n-            if try_run(build, &mut cargo) {\n-                build.save_toolstate(\"miri\", ToolState::TestPass);\n+            if try_run(builder, &mut cargo) {\n+                builder.save_toolstate(\"miri\", ToolState::TestPass);\n             }\n         } else {\n             eprintln!(\"failed to test miri: could not build\");\n@@ -391,7 +385,6 @@ impl Step for Clippy {\n \n     /// Runs `cargo test` for clippy.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let stage = self.stage;\n         let host = self.host;\n         let compiler = builder.compiler(stage, host);\n@@ -403,7 +396,7 @@ impl Step for Clippy {\n         });\n         if let Some(clippy) = clippy {\n             let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n-            cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/clippy/Cargo.toml\"));\n+            cargo.arg(\"--manifest-path\").arg(builder.src.join(\"src/tools/clippy/Cargo.toml\"));\n \n             // Don't build tests dynamically, just a pain to work with\n             cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n@@ -418,8 +411,8 @@ impl Step for Clippy {\n \n             builder.add_rustc_lib_path(compiler, &mut cargo);\n \n-            if try_run(build, &mut cargo) {\n-                build.save_toolstate(\"clippy-driver\", ToolState::TestPass);\n+            if try_run(builder, &mut cargo) {\n+                builder.save_toolstate(\"clippy-driver\", ToolState::TestPass);\n             }\n         } else {\n             eprintln!(\"failed to test clippy: could not build\");\n@@ -466,14 +459,14 @@ impl Step for RustdocTheme {\n            .env(\"RUSTC_STAGE\", self.compiler.stage.to_string())\n            .env(\"RUSTC_SYSROOT\", builder.sysroot(self.compiler))\n            .env(\"RUSTDOC_LIBDIR\", builder.sysroot_libdir(self.compiler, self.compiler.host))\n-           .env(\"CFG_RELEASE_CHANNEL\", &builder.build.config.channel)\n+           .env(\"CFG_RELEASE_CHANNEL\", &builder.config.channel)\n            .env(\"RUSTDOC_REAL\", builder.rustdoc(self.compiler.host))\n-           .env(\"RUSTDOC_CRATE_VERSION\", builder.build.rust_version())\n+           .env(\"RUSTDOC_CRATE_VERSION\", builder.rust_version())\n            .env(\"RUSTC_BOOTSTRAP\", \"1\");\n-        if let Some(linker) = builder.build.linker(self.compiler.host) {\n+        if let Some(linker) = builder.linker(self.compiler.host) {\n             cmd.env(\"RUSTC_TARGET_LINKER\", linker);\n         }\n-        try_run(builder.build, &mut cmd);\n+        try_run(builder, &mut cmd);\n     }\n }\n \n@@ -563,21 +556,19 @@ impl Step for Tidy {\n     /// otherwise just implements a few lint-like checks that are specific to the\n     /// compiler itself.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-\n         let mut cmd = builder.tool_cmd(Tool::Tidy);\n-        cmd.arg(build.src.join(\"src\"));\n-        cmd.arg(&build.initial_cargo);\n-        if !build.config.vendor {\n+        cmd.arg(builder.src.join(\"src\"));\n+        cmd.arg(&builder.initial_cargo);\n+        if !builder.config.vendor {\n             cmd.arg(\"--no-vendor\");\n         }\n-        if build.config.quiet_tests {\n+        if builder.config.quiet_tests {\n             cmd.arg(\"--quiet\");\n         }\n \n-        let _folder = build.fold_output(|| \"tidy\");\n+        let _folder = builder.fold_output(|| \"tidy\");\n         builder.info(&format!(\"tidy check\"));\n-        try_run(build, &mut cmd);\n+        try_run(builder, &mut cmd);\n     }\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n@@ -589,8 +580,8 @@ impl Step for Tidy {\n     }\n }\n \n-fn testdir(build: &Build, host: Interned<String>) -> PathBuf {\n-    build.out.join(host).join(\"test\")\n+fn testdir(builder: &Builder, host: Interned<String>) -> PathBuf {\n+    builder.out.join(host).join(\"test\")\n }\n \n macro_rules! default_test {\n@@ -828,25 +819,24 @@ impl Step for Compiletest {\n     /// compiletest `mode` and `suite` arguments. For example `mode` can be\n     /// \"run-pass\" or `suite` can be something like `debuginfo`.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let compiler = self.compiler;\n         let target = self.target;\n         let mode = self.mode;\n         let suite = self.suite;\n \n         // Skip codegen tests if they aren't enabled in configuration.\n-        if !build.config.codegen_tests && suite == \"codegen\" {\n+        if !builder.config.codegen_tests && suite == \"codegen\" {\n             return;\n         }\n \n         if suite == \"debuginfo\" {\n             // Skip debuginfo tests on MSVC\n-            if build.build.contains(\"msvc\") {\n+            if builder.config.build.contains(\"msvc\") {\n                 return;\n             }\n \n             if mode == \"debuginfo-XXX\" {\n-                return if build.build.contains(\"apple\") {\n+                return if builder.config.build.contains(\"apple\") {\n                     builder.ensure(Compiletest {\n                         mode: \"debuginfo-lldb\",\n                         ..self\n@@ -895,15 +885,15 @@ impl Step for Compiletest {\n             cmd.arg(\"--rustdoc-path\").arg(builder.rustdoc(compiler.host));\n         }\n \n-        cmd.arg(\"--src-base\").arg(build.src.join(\"src/test\").join(suite));\n-        cmd.arg(\"--build-base\").arg(testdir(build, compiler.host).join(suite));\n+        cmd.arg(\"--src-base\").arg(builder.src.join(\"src/test\").join(suite));\n+        cmd.arg(\"--build-base\").arg(testdir(builder, compiler.host).join(suite));\n         cmd.arg(\"--stage-id\").arg(format!(\"stage{}-{}\", compiler.stage, target));\n         cmd.arg(\"--mode\").arg(mode);\n         cmd.arg(\"--target\").arg(target);\n         cmd.arg(\"--host\").arg(&*compiler.host);\n-        cmd.arg(\"--llvm-filecheck\").arg(build.llvm_filecheck(build.build));\n+        cmd.arg(\"--llvm-filecheck\").arg(builder.llvm_filecheck(builder.config.build));\n \n-        if let Some(ref nodejs) = build.config.nodejs {\n+        if let Some(ref nodejs) = builder.config.nodejs {\n             cmd.arg(\"--nodejs\").arg(nodejs);\n         }\n \n@@ -913,17 +903,17 @@ impl Step for Compiletest {\n             vec![\"-Crpath\".to_string()]\n         };\n         if !is_rustdoc_ui {\n-            if build.config.rust_optimize_tests {\n+            if builder.config.rust_optimize_tests {\n                 flags.push(\"-O\".to_string());\n             }\n-            if build.config.rust_debuginfo_tests {\n+            if builder.config.rust_debuginfo_tests {\n                 flags.push(\"-g\".to_string());\n             }\n         }\n         flags.push(\"-Zunstable-options\".to_string());\n-        flags.push(build.config.cmd.rustc_args().join(\" \"));\n+        flags.push(builder.config.cmd.rustc_args().join(\" \"));\n \n-        if let Some(linker) = build.linker(target) {\n+        if let Some(linker) = builder.linker(target) {\n             cmd.arg(\"--linker\").arg(linker);\n         }\n \n@@ -932,69 +922,69 @@ impl Step for Compiletest {\n \n         let mut targetflags = flags.clone();\n         targetflags.push(format!(\"-Lnative={}\",\n-                                 build.test_helpers_out(target).display()));\n+                                 builder.test_helpers_out(target).display()));\n         cmd.arg(\"--target-rustcflags\").arg(targetflags.join(\" \"));\n \n-        cmd.arg(\"--docck-python\").arg(build.python());\n+        cmd.arg(\"--docck-python\").arg(builder.python());\n \n-        if build.build.ends_with(\"apple-darwin\") {\n+        if builder.config.build.ends_with(\"apple-darwin\") {\n             // Force /usr/bin/python on macOS for LLDB tests because we're loading the\n             // LLDB plugin's compiled module which only works with the system python\n             // (namely not Homebrew-installed python)\n             cmd.arg(\"--lldb-python\").arg(\"/usr/bin/python\");\n         } else {\n-            cmd.arg(\"--lldb-python\").arg(build.python());\n+            cmd.arg(\"--lldb-python\").arg(builder.python());\n         }\n \n-        if let Some(ref gdb) = build.config.gdb {\n+        if let Some(ref gdb) = builder.config.gdb {\n             cmd.arg(\"--gdb\").arg(gdb);\n         }\n-        if let Some(ref vers) = build.lldb_version {\n+        if let Some(ref vers) = builder.lldb_version {\n             cmd.arg(\"--lldb-version\").arg(vers);\n         }\n-        if let Some(ref dir) = build.lldb_python_dir {\n+        if let Some(ref dir) = builder.lldb_python_dir {\n             cmd.arg(\"--lldb-python-dir\").arg(dir);\n         }\n \n-        cmd.args(&build.config.cmd.test_args());\n+        cmd.args(&builder.config.cmd.test_args());\n \n-        if build.is_verbose() {\n+        if builder.is_verbose() {\n             cmd.arg(\"--verbose\");\n         }\n \n-        if build.config.quiet_tests {\n+        if builder.config.quiet_tests {\n             cmd.arg(\"--quiet\");\n         }\n \n-        if build.config.llvm_enabled {\n+        if builder.config.llvm_enabled {\n             let llvm_config = builder.ensure(native::Llvm {\n-                target: build.config.build,\n+                target: builder.config.build,\n                 emscripten: false,\n             });\n-            if !build.config.dry_run {\n+            if !builder.config.dry_run {\n                 let llvm_version = output(Command::new(&llvm_config).arg(\"--version\"));\n                 cmd.arg(\"--llvm-version\").arg(llvm_version);\n             }\n-            if !build.is_rust_llvm(target) {\n+            if !builder.is_rust_llvm(target) {\n                 cmd.arg(\"--system-llvm\");\n             }\n \n             // Only pass correct values for these flags for the `run-make` suite as it\n             // requires that a C++ compiler was configured which isn't always the case.\n-            if !build.config.dry_run && suite == \"run-make-fulldeps\" {\n+            if !builder.config.dry_run && suite == \"run-make-fulldeps\" {\n                 let llvm_components = output(Command::new(&llvm_config).arg(\"--components\"));\n                 let llvm_cxxflags = output(Command::new(&llvm_config).arg(\"--cxxflags\"));\n-                cmd.arg(\"--cc\").arg(build.cc(target))\n-                .arg(\"--cxx\").arg(build.cxx(target).unwrap())\n-                .arg(\"--cflags\").arg(build.cflags(target).join(\" \"))\n+                cmd.arg(\"--cc\").arg(builder.cc(target))\n+                .arg(\"--cxx\").arg(builder.cxx(target).unwrap())\n+                .arg(\"--cflags\").arg(builder.cflags(target).join(\" \"))\n                 .arg(\"--llvm-components\").arg(llvm_components.trim())\n                 .arg(\"--llvm-cxxflags\").arg(llvm_cxxflags.trim());\n-                if let Some(ar) = build.ar(target) {\n+                if let Some(ar) = builder.ar(target) {\n                     cmd.arg(\"--ar\").arg(ar);\n                 }\n             }\n         }\n-        if suite == \"run-make-fulldeps\" && !build.config.llvm_enabled {\n+        if suite == \"run-make-fulldeps\" && !builder.config.llvm_enabled {\n             builder.info(\n                 &format!(\"Ignoring run-make test suite as they generally don't work without LLVM\"));\n             return;\n@@ -1008,7 +998,7 @@ impl Step for Compiletest {\n                .arg(\"--llvm-cxxflags\").arg(\"\");\n         }\n \n-        if build.remote_tested(target) {\n+        if builder.remote_tested(target) {\n             cmd.arg(\"--remote-test-client\").arg(builder.tool_exe(Tool::RemoteTestClient));\n         }\n \n@@ -1018,42 +1008,42 @@ impl Step for Compiletest {\n         // Note that if we encounter `PATH` we make sure to append to our own `PATH`\n         // rather than stomp over it.\n         if target.contains(\"msvc\") {\n-            for &(ref k, ref v) in build.cc[&target].env() {\n+            for &(ref k, ref v) in builder.cc[&target].env() {\n                 if k != \"PATH\" {\n                     cmd.env(k, v);\n                 }\n             }\n         }\n         cmd.env(\"RUSTC_BOOTSTRAP\", \"1\");\n-        build.add_rust_test_threads(&mut cmd);\n+        builder.add_rust_test_threads(&mut cmd);\n \n-        if build.config.sanitizers {\n+        if builder.config.sanitizers {\n             cmd.env(\"SANITIZER_SUPPORT\", \"1\");\n         }\n \n-        if build.config.profiler {\n+        if builder.config.profiler {\n             cmd.env(\"PROFILER_SUPPORT\", \"1\");\n         }\n \n-        cmd.env(\"RUST_TEST_TMPDIR\", build.out.join(\"tmp\"));\n+        cmd.env(\"RUST_TEST_TMPDIR\", builder.out.join(\"tmp\"));\n \n         cmd.arg(\"--adb-path\").arg(\"adb\");\n         cmd.arg(\"--adb-test-dir\").arg(ADB_TEST_DIR);\n         if target.contains(\"android\") {\n             // Assume that cc for this target comes from the android sysroot\n             cmd.arg(\"--android-cross-path\")\n-               .arg(build.cc(target).parent().unwrap().parent().unwrap());\n+               .arg(builder.cc(target).parent().unwrap().parent().unwrap());\n         } else {\n             cmd.arg(\"--android-cross-path\").arg(\"\");\n         }\n \n-        build.ci_env.force_coloring_in_ci(&mut cmd);\n+        builder.ci_env.force_coloring_in_ci(&mut cmd);\n \n-        let _folder = build.fold_output(|| format!(\"test_{}\", suite));\n+        let _folder = builder.fold_output(|| format!(\"test_{}\", suite));\n         builder.info(&format!(\"Check compiletest suite={} mode={} ({} -> {})\",\n                  suite, mode, &compiler.host, target));\n-        let _time = util::timeit(&build);\n-        try_run(build, &mut cmd);\n+        let _time = util::timeit(&builder);\n+        try_run(builder, &mut cmd);\n     }\n }\n \n@@ -1079,16 +1069,15 @@ impl Step for DocTest {\n     /// located in `src/doc`. The `rustdoc` that's run is the one that sits next to\n     /// `compiler`.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let compiler = self.compiler;\n \n         builder.ensure(compile::Test { compiler, target: compiler.host });\n \n         // Do a breadth-first traversal of the `src/doc` directory and just run\n         // tests for all files that end in `*.md`\n-        let mut stack = vec![build.src.join(self.path)];\n-        let _time = util::timeit(&build);\n-        let _folder = build.fold_output(|| format!(\"test_{}\", self.name));\n+        let mut stack = vec![builder.src.join(self.path)];\n+        let _time = util::timeit(&builder);\n+        let _folder = builder.fold_output(|| format!(\"test_{}\", self.name));\n \n         let mut files = Vec::new();\n         while let Some(p) = stack.pop() {\n@@ -1102,7 +1091,7 @@ impl Step for DocTest {\n             }\n \n             // The nostarch directory in the book is for no starch, and so isn't\n-            // guaranteed to build. We don't care if it doesn't build, so skip it.\n+            // guaranteed to builder. We don't care if it doesn't build, so skip it.\n             if p.to_str().map_or(false, |p| p.contains(\"nostarch\")) {\n                 continue;\n             }\n@@ -1120,7 +1109,7 @@ impl Step for DocTest {\n                 } else {\n                     ToolState::TestFail\n                 };\n-                build.save_toolstate(self.name, toolstate);\n+                builder.save_toolstate(self.name, toolstate);\n             }\n         }\n     }\n@@ -1198,32 +1187,30 @@ impl Step for ErrorIndex {\n     /// generate a markdown file from the error indexes of the code base which is\n     /// then passed to `rustdoc --test`.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let compiler = self.compiler;\n \n         builder.ensure(compile::Std { compiler, target: compiler.host });\n \n-        let dir = testdir(build, compiler.host);\n+        let dir = testdir(builder, compiler.host);\n         t!(fs::create_dir_all(&dir));\n         let output = dir.join(\"error-index.md\");\n \n         let mut tool = builder.tool_cmd(Tool::ErrorIndex);\n         tool.arg(\"markdown\")\n             .arg(&output)\n-            .env(\"CFG_BUILD\", &build.build)\n-            .env(\"RUSTC_ERROR_METADATA_DST\", build.extended_error_dir());\n+            .env(\"CFG_BUILD\", &builder.config.build)\n+            .env(\"RUSTC_ERROR_METADATA_DST\", builder.extended_error_dir());\n \n \n-        let _folder = build.fold_output(|| \"test_error_index\");\n-        build.info(&format!(\"Testing error-index stage{}\", compiler.stage));\n-        let _time = util::timeit(&build);\n-        build.run(&mut tool);\n+        let _folder = builder.fold_output(|| \"test_error_index\");\n+        builder.info(&format!(\"Testing error-index stage{}\", compiler.stage));\n+        let _time = util::timeit(&builder);\n+        builder.run(&mut tool);\n         markdown_test(builder, compiler, &output);\n     }\n }\n \n fn markdown_test(builder: &Builder, compiler: Compiler, markdown: &Path) -> bool {\n-    let build = builder.build;\n     match File::open(markdown) {\n         Ok(mut file) => {\n             let mut contents = String::new();\n@@ -1235,20 +1222,20 @@ fn markdown_test(builder: &Builder, compiler: Compiler, markdown: &Path) -> bool\n         Err(_) => {},\n     }\n \n-    build.info(&format!(\"doc tests for: {}\", markdown.display()));\n+    builder.info(&format!(\"doc tests for: {}\", markdown.display()));\n     let mut cmd = builder.rustdoc_cmd(compiler.host);\n-    build.add_rust_test_threads(&mut cmd);\n+    builder.add_rust_test_threads(&mut cmd);\n     cmd.arg(\"--test\");\n     cmd.arg(markdown);\n     cmd.env(\"RUSTC_BOOTSTRAP\", \"1\");\n \n-    let test_args = build.config.cmd.test_args().join(\" \");\n+    let test_args = builder.config.cmd.test_args().join(\" \");\n     cmd.arg(\"--test-args\").arg(test_args);\n \n-    if build.config.quiet_tests {\n-        try_run_quiet(build, &mut cmd)\n+    if builder.config.quiet_tests {\n+        try_run_quiet(builder, &mut cmd)\n     } else {\n-        try_run(build, &mut cmd)\n+        try_run(builder, &mut cmd)\n     }\n }\n \n@@ -1432,7 +1419,6 @@ impl Step for Crate {\n     /// Currently this runs all tests for a DAG by passing a bunch of `-p foo`\n     /// arguments, and those arguments are discovered from `cargo metadata`.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let compiler = self.compiler;\n         let target = self.target;\n         let mode = self.mode;\n@@ -1446,7 +1432,7 @@ impl Step for Crate {\n         // libstd, then what we're actually testing is the libstd produced in\n         // stage1. Reflect that here by updating the compiler that we're working\n         // with automatically.\n-        let compiler = if build.force_use_stage1(compiler, target) {\n+        let compiler = if builder.force_use_stage1(compiler, target) {\n             builder.compiler(1, compiler.host)\n         } else {\n             compiler.clone()\n@@ -1458,11 +1444,11 @@ impl Step for Crate {\n                 compile::std_cargo(builder, &compiler, target, &mut cargo);\n             }\n             Mode::Libtest => {\n-                compile::test_cargo(build, &compiler, target, &mut cargo);\n+                compile::test_cargo(builder, &compiler, target, &mut cargo);\n             }\n             Mode::Librustc => {\n                 builder.ensure(compile::Rustc { compiler, target });\n-                compile::rustc_cargo(build, &mut cargo);\n+                compile::rustc_cargo(builder, &mut cargo);\n             }\n             _ => panic!(\"can only test libraries\"),\n         };\n@@ -1472,10 +1458,10 @@ impl Step for Crate {\n         // Pass in some standard flags then iterate over the graph we've discovered\n         // in `cargo metadata` with the maps above and figure out what `-p`\n         // arguments need to get passed.\n-        if test_kind.subcommand() == \"test\" && !build.fail_fast {\n+        if test_kind.subcommand() == \"test\" && !builder.fail_fast {\n             cargo.arg(\"--no-fail-fast\");\n         }\n-        if build.doc_tests {\n+        if builder.doc_tests {\n             cargo.arg(\"--doc\");\n         }\n \n@@ -1491,47 +1477,47 @@ impl Step for Crate {\n         cargo.env(dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n \n         cargo.arg(\"--\");\n-        cargo.args(&build.config.cmd.test_args());\n+        cargo.args(&builder.config.cmd.test_args());\n \n-        if build.config.quiet_tests {\n+        if builder.config.quiet_tests {\n             cargo.arg(\"--quiet\");\n         }\n \n         if target.contains(\"emscripten\") {\n             cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n-                      build.config.nodejs.as_ref().expect(\"nodejs not configured\"));\n+                      builder.config.nodejs.as_ref().expect(\"nodejs not configured\"));\n         } else if target.starts_with(\"wasm32\") {\n             // Warn about running tests without the `wasm_syscall` feature enabled.\n             // The javascript shim implements the syscall interface so that test\n             // output can be correctly reported.\n-            if !build.config.wasm_syscall {\n-                build.info(&format!(\"Libstd was built without `wasm_syscall` feature enabled: \\\n+            if !builder.config.wasm_syscall {\n+                builder.info(&format!(\"Libstd was built without `wasm_syscall` feature enabled: \\\n                           test output may not be visible.\"));\n             }\n \n             // On the wasm32-unknown-unknown target we're using LTO which is\n             // incompatible with `-C prefer-dynamic`, so disable that here\n             cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n \n-            let node = build.config.nodejs.as_ref()\n+            let node = builder.config.nodejs.as_ref()\n                 .expect(\"nodejs not configured\");\n             let runner = format!(\"{} {}/src/etc/wasm32-shim.js\",\n                                  node.display(),\n-                                 build.src.display());\n+                                 builder.src.display());\n             cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)), &runner);\n-        } else if build.remote_tested(target) {\n+        } else if builder.remote_tested(target) {\n             cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n                       format!(\"{} run\",\n                               builder.tool_exe(Tool::RemoteTestClient).display()));\n         }\n \n-        let _folder = build.fold_output(|| {\n+        let _folder = builder.fold_output(|| {\n             format!(\"{}_stage{}-{}\", test_kind.subcommand(), compiler.stage, krate)\n         });\n-        build.info(&format!(\"{} {} stage{} ({} -> {})\", test_kind, krate, compiler.stage,\n+        builder.info(&format!(\"{} {} stage{} ({} -> {})\", test_kind, krate, compiler.stage,\n                 &compiler.host, target));\n-        let _time = util::timeit(&build);\n-        try_run(build, &mut cargo);\n+        let _time = util::timeit(&builder);\n+        try_run(builder, &mut cargo);\n     }\n }\n \n@@ -1568,7 +1554,6 @@ impl Step for CrateRustdoc {\n     }\n \n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let test_kind = self.test_kind;\n \n         let compiler = builder.compiler(builder.top_stage, self.host);\n@@ -1579,27 +1564,27 @@ impl Step for CrateRustdoc {\n                                                  target,\n                                                  test_kind.subcommand(),\n                                                  \"src/tools/rustdoc\");\n-        if test_kind.subcommand() == \"test\" && !build.fail_fast {\n+        if test_kind.subcommand() == \"test\" && !builder.fail_fast {\n             cargo.arg(\"--no-fail-fast\");\n         }\n \n         cargo.arg(\"-p\").arg(\"rustdoc:0.0.0\");\n \n         cargo.arg(\"--\");\n-        cargo.args(&build.config.cmd.test_args());\n+        cargo.args(&builder.config.cmd.test_args());\n \n-        if build.config.quiet_tests {\n+        if builder.config.quiet_tests {\n             cargo.arg(\"--quiet\");\n         }\n \n-        let _folder = build.fold_output(|| {\n+        let _folder = builder.fold_output(|| {\n             format!(\"{}_stage{}-rustdoc\", test_kind.subcommand(), compiler.stage)\n         });\n-        build.info(&format!(\"{} rustdoc stage{} ({} -> {})\", test_kind, compiler.stage,\n+        builder.info(&format!(\"{} rustdoc stage{} ({} -> {})\", test_kind, compiler.stage,\n                 &compiler.host, target));\n-        let _time = util::timeit(&build);\n+        let _time = util::timeit(&builder);\n \n-        try_run(build, &mut cargo);\n+        try_run(builder, &mut cargo);\n     }\n }\n \n@@ -1635,17 +1620,16 @@ impl Step for RemoteCopyLibs {\n     }\n \n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let compiler = self.compiler;\n         let target = self.target;\n-        if !build.remote_tested(target) {\n+        if !builder.remote_tested(target) {\n             return\n         }\n \n         builder.ensure(compile::Test { compiler, target });\n \n-        build.info(&format!(\"REMOTE copy libs to emulator ({})\", target));\n-        t!(fs::create_dir_all(build.out.join(\"tmp\")));\n+        builder.info(&format!(\"REMOTE copy libs to emulator ({})\", target));\n+        t!(fs::create_dir_all(builder.out.join(\"tmp\")));\n \n         let server = builder.ensure(tool::RemoteTestServer { compiler, target });\n \n@@ -1655,18 +1639,18 @@ impl Step for RemoteCopyLibs {\n         cmd.arg(\"spawn-emulator\")\n            .arg(target)\n            .arg(&server)\n-           .arg(build.out.join(\"tmp\"));\n-        if let Some(rootfs) = build.qemu_rootfs(target) {\n+           .arg(builder.out.join(\"tmp\"));\n+        if let Some(rootfs) = builder.qemu_rootfs(target) {\n             cmd.arg(rootfs);\n         }\n-        build.run(&mut cmd);\n+        builder.run(&mut cmd);\n \n         // Push all our dylibs to the emulator\n         for f in t!(builder.sysroot_libdir(compiler, target).read_dir()) {\n             let f = t!(f);\n             let name = f.file_name().into_string().unwrap();\n             if util::is_dylib(&name) {\n-                build.run(Command::new(&tool)\n+                builder.run(Command::new(&tool)\n                                   .arg(\"push\")\n                                   .arg(f.path()));\n             }\n@@ -1690,10 +1674,8 @@ impl Step for Distcheck {\n \n     /// Run \"distcheck\", a 'make check' from a tarball\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-\n-        build.info(&format!(\"Distcheck\"));\n-        let dir = build.out.join(\"tmp\").join(\"distcheck\");\n+        builder.info(&format!(\"Distcheck\"));\n+        let dir = builder.out.join(\"tmp\").join(\"distcheck\");\n         let _ = fs::remove_dir_all(&dir);\n         t!(fs::create_dir_all(&dir));\n \n@@ -1706,18 +1688,18 @@ impl Step for Distcheck {\n            .arg(builder.ensure(dist::PlainSourceTarball))\n            .arg(\"--strip-components=1\")\n            .current_dir(&dir);\n-        build.run(&mut cmd);\n-        build.run(Command::new(\"./configure\")\n-                         .args(&build.config.configure_args)\n+        builder.run(&mut cmd);\n+        builder.run(Command::new(\"./configure\")\n+                         .args(&builder.config.configure_args)\n                          .arg(\"--enable-vendor\")\n                          .current_dir(&dir));\n-        build.run(Command::new(build_helper::make(&build.build))\n+        builder.run(Command::new(build_helper::make(&builder.config.build))\n                          .arg(\"check\")\n                          .current_dir(&dir));\n \n         // Now make sure that rust-src has all of libstd's dependencies\n-        build.info(&format!(\"Distcheck rust-src\"));\n-        let dir = build.out.join(\"tmp\").join(\"distcheck-src\");\n+        builder.info(&format!(\"Distcheck rust-src\"));\n+        let dir = builder.out.join(\"tmp\").join(\"distcheck-src\");\n         let _ = fs::remove_dir_all(&dir);\n         t!(fs::create_dir_all(&dir));\n \n@@ -1726,10 +1708,10 @@ impl Step for Distcheck {\n            .arg(builder.ensure(dist::Src))\n            .arg(\"--strip-components=1\")\n            .current_dir(&dir);\n-        build.run(&mut cmd);\n+        builder.run(&mut cmd);\n \n         let toml = dir.join(\"rust-src/lib/rustlib/src/rust/src/libstd/Cargo.toml\");\n-        build.run(Command::new(&build.initial_cargo)\n+        builder.run(Command::new(&builder.initial_cargo)\n                          .arg(\"generate-lockfile\")\n                          .arg(\"--manifest-path\")\n                          .arg(&toml)\n@@ -1747,25 +1729,24 @@ impl Step for Bootstrap {\n \n     /// Test the build system itself\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let mut cmd = Command::new(&build.initial_cargo);\n+        let mut cmd = Command::new(&builder.initial_cargo);\n         cmd.arg(\"test\")\n-           .current_dir(build.src.join(\"src/bootstrap\"))\n+           .current_dir(builder.src.join(\"src/bootstrap\"))\n            .env(\"RUSTFLAGS\", \"-Cdebuginfo=2\")\n-           .env(\"CARGO_TARGET_DIR\", build.out.join(\"bootstrap\"))\n+           .env(\"CARGO_TARGET_DIR\", builder.out.join(\"bootstrap\"))\n            .env(\"RUSTC_BOOTSTRAP\", \"1\")\n-           .env(\"RUSTC\", &build.initial_rustc);\n+           .env(\"RUSTC\", &builder.initial_rustc);\n         if let Some(flags) = option_env!(\"RUSTFLAGS\") {\n             // Use the same rustc flags for testing as for \"normal\" compilation,\n             // so that Cargo doesn\u2019t recompile the entire dependency graph every time:\n             // https://github.com/rust-lang/rust/issues/49215\n             cmd.env(\"RUSTFLAGS\", flags);\n         }\n-        if !build.fail_fast {\n+        if !builder.fail_fast {\n             cmd.arg(\"--no-fail-fast\");\n         }\n-        cmd.arg(\"--\").args(&build.config.cmd.test_args());\n-        try_run(build, &mut cmd);\n+        cmd.arg(\"--\").args(&builder.config.cmd.test_args());\n+        try_run(builder, &mut cmd);\n     }\n \n     fn should_run(run: ShouldRun) -> ShouldRun {"}, {"sha": "6c29bd84fe4673b407da036a821a3d3add99d55a", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 39, "deletions": 43, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/23561c6747b0916e852aaa2a5d04c0b0eeddc6de/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23561c6747b0916e852aaa2a5d04c0b0eeddc6de/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=23561c6747b0916e852aaa2a5d04c0b0eeddc6de", "patch": "@@ -38,15 +38,14 @@ impl Step for CleanTools {\n     }\n \n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let compiler = self.compiler;\n         let target = self.target;\n         let mode = self.mode;\n \n         // This is for the original compiler, but if we're forced to use stage 1, then\n         // std/test/rustc stamps won't exist in stage 2, so we need to get those from stage 1, since\n         // we copy the libs forward.\n-        let tools_dir = build.stage_out(compiler, Mode::Tool);\n+        let tools_dir = builder.stage_out(compiler, Mode::Tool);\n         let compiler = if builder.force_use_stage1(compiler, target) {\n             builder.compiler(1, compiler.host)\n         } else {\n@@ -55,13 +54,13 @@ impl Step for CleanTools {\n \n         for &cur_mode in &[Mode::Libstd, Mode::Libtest, Mode::Librustc] {\n             let stamp = match cur_mode {\n-                Mode::Libstd => libstd_stamp(build, compiler, target),\n-                Mode::Libtest => libtest_stamp(build, compiler, target),\n-                Mode::Librustc => librustc_stamp(build, compiler, target),\n+                Mode::Libstd => libstd_stamp(builder, compiler, target),\n+                Mode::Libtest => libtest_stamp(builder, compiler, target),\n+                Mode::Librustc => librustc_stamp(builder, compiler, target),\n                 _ => panic!(),\n             };\n \n-            if build.clear_if_dirty(&tools_dir, &stamp) {\n+            if builder.clear_if_dirty(&tools_dir, &stamp) {\n                 break;\n             }\n \n@@ -97,7 +96,6 @@ impl Step for ToolBuild {\n     /// This will build the specified tool with the specified `host` compiler in\n     /// `stage` into the normal cargo output directory.\n     fn run(self, builder: &Builder) -> Option<PathBuf> {\n-        let build = builder.build;\n         let compiler = self.compiler;\n         let target = self.target;\n         let tool = self.tool;\n@@ -114,10 +112,10 @@ impl Step for ToolBuild {\n         let mut cargo = prepare_tool_cargo(builder, compiler, target, \"build\", path);\n         cargo.arg(\"--features\").arg(self.extra_features.join(\" \"));\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-{}\", compiler.stage, tool));\n-        build.info(&format!(\"Building stage{} tool {} ({})\", compiler.stage, tool, target));\n+        let _folder = builder.fold_output(|| format!(\"stage{}-{}\", compiler.stage, tool));\n+        builder.info(&format!(\"Building stage{} tool {} ({})\", compiler.stage, tool, target));\n         let mut duplicates = Vec::new();\n-        let is_expected = compile::stream_cargo(build, &mut cargo, &mut |msg| {\n+        let is_expected = compile::stream_cargo(builder, &mut cargo, &mut |msg| {\n             // Only care about big things like the RLS/Cargo for now\n             if tool != \"rls\" && tool != \"cargo\" {\n                 return\n@@ -156,7 +154,7 @@ impl Step for ToolBuild {\n                     }\n                 }\n \n-                let mut artifacts = build.tool_artifacts.borrow_mut();\n+                let mut artifacts = builder.tool_artifacts.borrow_mut();\n                 let prev_artifacts = artifacts\n                     .entry(target)\n                     .or_insert_with(Default::default);\n@@ -190,7 +188,7 @@ impl Step for ToolBuild {\n             panic!(\"tools should not compile multiple copies of the same crate\");\n         }\n \n-        build.save_toolstate(tool, if is_expected {\n+        builder.save_toolstate(tool, if is_expected {\n             ToolState::TestFail\n         } else {\n             ToolState::BuildFail\n@@ -203,10 +201,10 @@ impl Step for ToolBuild {\n                 return None;\n             }\n         } else {\n-            let cargo_out = build.cargo_out(compiler, Mode::Tool, target)\n+            let cargo_out = builder.cargo_out(compiler, Mode::Tool, target)\n                 .join(exe(tool, &compiler.host));\n-            let bin = build.tools_dir(compiler).join(exe(tool, &compiler.host));\n-            build.copy(&cargo_out, &bin);\n+            let bin = builder.tools_dir(compiler).join(exe(tool, &compiler.host));\n+            builder.copy(&cargo_out, &bin);\n             Some(bin)\n         }\n     }\n@@ -219,16 +217,15 @@ pub fn prepare_tool_cargo(\n     command: &'static str,\n     path: &'static str,\n ) -> Command {\n-    let build = builder.build;\n     let mut cargo = builder.cargo(compiler, Mode::Tool, target, command);\n-    let dir = build.src.join(path);\n+    let dir = builder.src.join(path);\n     cargo.arg(\"--manifest-path\").arg(dir.join(\"Cargo.toml\"));\n \n     // We don't want to build tools dynamically as they'll be running across\n     // stages and such and it's just easier if they're not dynamically linked.\n     cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n \n-    if let Some(dir) = build.openssl_install_dir(target) {\n+    if let Some(dir) = builder.openssl_install_dir(target) {\n         cargo.env(\"OPENSSL_STATIC\", \"1\");\n         cargo.env(\"OPENSSL_DIR\", dir);\n         cargo.env(\"LIBZ_SYS_STATIC\", \"1\");\n@@ -238,10 +235,10 @@ pub fn prepare_tool_cargo(\n     // own copy\n     cargo.env(\"LZMA_API_STATIC\", \"1\");\n \n-    cargo.env(\"CFG_RELEASE_CHANNEL\", &build.config.channel);\n-    cargo.env(\"CFG_VERSION\", build.rust_version());\n+    cargo.env(\"CFG_RELEASE_CHANNEL\", &builder.config.channel);\n+    cargo.env(\"CFG_VERSION\", builder.rust_version());\n \n-    let info = GitInfo::new(&build.config, &dir);\n+    let info = GitInfo::new(&builder.config, &dir);\n     if let Some(sha) = info.sha() {\n         cargo.env(\"CFG_COMMIT_HASH\", sha);\n     }\n@@ -269,8 +266,8 @@ macro_rules! tool {\n                 match tool {\n                     $(Tool::$name =>\n                         self.ensure($name {\n-                            compiler: self.compiler(stage, self.build.build),\n-                            target: self.build.build,\n+                            compiler: self.compiler(stage, self.config.build),\n+                            target: self.config.build,\n                         }),\n                     )+\n                 }\n@@ -304,7 +301,7 @@ macro_rules! tool {\n \n             fn make_run(run: RunConfig) {\n                 run.builder.ensure($name {\n-                    compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n+                    compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n                     target: run.target,\n                 });\n             }\n@@ -354,7 +351,7 @@ impl Step for RemoteTestServer {\n \n     fn make_run(run: RunConfig) {\n         run.builder.ensure(RemoteTestServer {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n+            compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n             target: run.target,\n         });\n     }\n@@ -393,26 +390,25 @@ impl Step for Rustdoc {\n     }\n \n     fn run(self, builder: &Builder) -> PathBuf {\n-        let build = builder.build;\n         let target_compiler = builder.compiler(builder.top_stage, self.host);\n         let target = target_compiler.host;\n         let build_compiler = if target_compiler.stage == 0 {\n-            builder.compiler(0, builder.build.build)\n+            builder.compiler(0, builder.config.build)\n         } else if target_compiler.stage >= 2 {\n             // Past stage 2, we consider the compiler to be ABI-compatible and hence capable of\n             // building rustdoc itself.\n-            builder.compiler(target_compiler.stage, builder.build.build)\n+            builder.compiler(target_compiler.stage, builder.config.build)\n         } else {\n             // Similar to `compile::Assemble`, build with the previous stage's compiler. Otherwise\n             // we'd have stageN/bin/rustc and stageN/bin/rustdoc be effectively different stage\n             // compilers, which isn't what we want.\n-            builder.compiler(target_compiler.stage - 1, builder.build.build)\n+            builder.compiler(target_compiler.stage - 1, builder.config.build)\n         };\n \n         builder.ensure(compile::Rustc { compiler: build_compiler, target });\n         builder.ensure(compile::Rustc {\n             compiler: build_compiler,\n-            target: builder.build.build,\n+            target: builder.config.build,\n         });\n \n         let mut cargo = prepare_tool_cargo(builder,\n@@ -425,15 +421,15 @@ impl Step for Rustdoc {\n         cargo.env(\"RUSTC_DEBUGINFO\", builder.config.rust_debuginfo.to_string())\n              .env(\"RUSTC_DEBUGINFO_LINES\", builder.config.rust_debuginfo_lines.to_string());\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-rustdoc\", target_compiler.stage));\n-        build.info(&format!(\"Building rustdoc for stage{} ({})\",\n+        let _folder = builder.fold_output(|| format!(\"stage{}-rustdoc\", target_compiler.stage));\n+        builder.info(&format!(\"Building rustdoc for stage{} ({})\",\n             target_compiler.stage, target_compiler.host));\n-        build.run(&mut cargo);\n+        builder.run(&mut cargo);\n \n         // Cargo adds a number of paths to the dylib search path on windows, which results in\n         // the wrong rustdoc being executed. To avoid the conflicting rustdocs, we name the \"tool\"\n         // rustdoc a different name.\n-        let tool_rustdoc = build.cargo_out(build_compiler, Mode::Tool, target)\n+        let tool_rustdoc = builder.cargo_out(build_compiler, Mode::Tool, target)\n             .join(exe(\"rustdoc-tool-binary\", &target_compiler.host));\n \n         // don't create a stage0-sysroot/bin directory.\n@@ -443,7 +439,7 @@ impl Step for Rustdoc {\n             t!(fs::create_dir_all(&bindir));\n             let bin_rustdoc = bindir.join(exe(\"rustdoc\", &*target_compiler.host));\n             let _ = fs::remove_file(&bin_rustdoc);\n-            build.copy(&tool_rustdoc, &bin_rustdoc);\n+            builder.copy(&tool_rustdoc, &bin_rustdoc);\n             bin_rustdoc\n         } else {\n             tool_rustdoc\n@@ -464,12 +460,12 @@ impl Step for Cargo {\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n-        run.path(\"src/tools/cargo\").default_condition(builder.build.config.extended)\n+        run.path(\"src/tools/cargo\").default_condition(builder.config.extended)\n     }\n \n     fn make_run(run: RunConfig) {\n         run.builder.ensure(Cargo {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n+            compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n             target: run.target,\n         });\n     }\n@@ -482,7 +478,7 @@ impl Step for Cargo {\n         // compiler to be available, so we need to depend on that.\n         builder.ensure(compile::Rustc {\n             compiler: self.compiler,\n-            target: builder.build.build,\n+            target: builder.config.build,\n         });\n         builder.ensure(ToolBuild {\n             compiler: self.compiler,\n@@ -518,12 +514,12 @@ macro_rules! tool_extended {\n \n             fn should_run(run: ShouldRun) -> ShouldRun {\n                 let builder = run.builder;\n-                run.path($path).default_condition(builder.build.config.extended)\n+                run.path($path).default_condition(builder.config.extended)\n             }\n \n             fn make_run(run: RunConfig) {\n                 run.builder.ensure($name {\n-                    compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n+                    compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n                     target: run.target,\n                     extra_features: Vec::new(),\n                 });\n@@ -554,7 +550,7 @@ tool_extended!((self, builder),\n         // compiler to be available, so we need to depend on that.\n         builder.ensure(compile::Rustc {\n             compiler: self.compiler,\n-            target: builder.build.build,\n+            target: builder.config.build,\n         });\n     };\n     Miri, miri, \"src/tools/miri\", \"miri\", {};\n@@ -575,7 +571,7 @@ tool_extended!((self, builder),\n         // compiler to be available, so we need to depend on that.\n         builder.ensure(compile::Rustc {\n             compiler: self.compiler,\n-            target: builder.build.build,\n+            target: builder.config.build,\n         });\n     };\n     Rustfmt, rustfmt, \"src/tools/rustfmt\", \"rustfmt\", {};\n@@ -586,7 +582,7 @@ impl<'a> Builder<'a> {\n     /// `host`.\n     pub fn tool_cmd(&self, tool: Tool) -> Command {\n         let mut cmd = Command::new(self.tool_exe(tool));\n-        let compiler = self.compiler(self.tool_default_stage(tool), self.build.build);\n+        let compiler = self.compiler(self.tool_default_stage(tool), self.config.build);\n         self.prepare_tool_cmd(compiler, &mut cmd);\n         cmd\n     }"}, {"sha": "9a2b9e90440e53d909f8016a981585f16b2b4356", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/23561c6747b0916e852aaa2a5d04c0b0eeddc6de/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23561c6747b0916e852aaa2a5d04c0b0eeddc6de/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=23561c6747b0916e852aaa2a5d04c0b0eeddc6de", "patch": "@@ -22,7 +22,7 @@ use std::process::Command;\n use std::time::{SystemTime, Instant};\n \n use config::Config;\n-use Build;\n+use builder::Builder;\n \n /// Returns the `name` as the filename of a static library for `target`.\n pub fn staticlib(name: &str, target: &str) -> String {\n@@ -104,8 +104,8 @@ pub fn push_exe_path(mut buf: PathBuf, components: &[&str]) -> PathBuf {\n pub struct TimeIt(bool, Instant);\n \n /// Returns an RAII structure that prints out how long it took to drop.\n-pub fn timeit(build: &Build) -> TimeIt {\n-    TimeIt(build.config.dry_run, Instant::now())\n+pub fn timeit(builder: &Builder) -> TimeIt {\n+    TimeIt(builder.config.dry_run, Instant::now())\n }\n \n impl Drop for TimeIt {"}]}