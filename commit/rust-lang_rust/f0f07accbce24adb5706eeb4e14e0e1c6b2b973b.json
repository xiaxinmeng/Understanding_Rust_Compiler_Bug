{"sha": "f0f07accbce24adb5706eeb4e14e0e1c6b2b973b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwZjA3YWNjYmNlMjRhZGI1NzA2ZWViNGUxNGUwZTFjNmIyYjk3M2I=", "commit": {"author": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2021-03-02T15:14:38Z"}, "committer": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2021-03-11T10:37:13Z"}, "message": "move expect_used, filter_next, get_unwrap, ok_expect and unwrap_used to their own modules", "tree": {"sha": "3eec900968bc90d74e49062ad45319699da00b27", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3eec900968bc90d74e49062ad45319699da00b27"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0f07accbce24adb5706eeb4e14e0e1c6b2b973b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0f07accbce24adb5706eeb4e14e0e1c6b2b973b", "html_url": "https://github.com/rust-lang/rust/commit/f0f07accbce24adb5706eeb4e14e0e1c6b2b973b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0f07accbce24adb5706eeb4e14e0e1c6b2b973b/comments", "author": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99afc6e6ac2ce874c4fed32c083f1e160f533015", "url": "https://api.github.com/repos/rust-lang/rust/commits/99afc6e6ac2ce874c4fed32c083f1e160f533015", "html_url": "https://github.com/rust-lang/rust/commit/99afc6e6ac2ce874c4fed32c083f1e160f533015"}], "stats": {"total": 446, "additions": 244, "deletions": 202}, "files": [{"sha": "90b781bd9d1905015998d3bd7df81bc067ae5008", "filename": "clippy_lints/src/methods/expect_used.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f0f07accbce24adb5706eeb4e14e0e1c6b2b973b/clippy_lints%2Fsrc%2Fmethods%2Fexpect_used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f07accbce24adb5706eeb4e14e0e1c6b2b973b/clippy_lints%2Fsrc%2Fmethods%2Fexpect_used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fexpect_used.rs?ref=f0f07accbce24adb5706eeb4e14e0e1c6b2b973b", "patch": "@@ -0,0 +1,30 @@\n+use crate::utils::{is_type_diagnostic_item, span_lint_and_help};\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::EXPECT_USED;\n+\n+/// lint use of `expect()` for `Option`s and `Result`s\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, expect_args: &[hir::Expr<'_>]) {\n+    let obj_ty = cx.typeck_results().expr_ty(&expect_args[0]).peel_refs();\n+\n+    let mess = if is_type_diagnostic_item(cx, obj_ty, sym::option_type) {\n+        Some((EXPECT_USED, \"an Option\", \"None\"))\n+    } else if is_type_diagnostic_item(cx, obj_ty, sym::result_type) {\n+        Some((EXPECT_USED, \"a Result\", \"Err\"))\n+    } else {\n+        None\n+    };\n+\n+    if let Some((lint, kind, none_value)) = mess {\n+        span_lint_and_help(\n+            cx,\n+            lint,\n+            expr.span,\n+            &format!(\"used `expect()` on `{}` value\", kind,),\n+            None,\n+            &format!(\"if this value is an `{}`, it will panic\", none_value,),\n+        );\n+    }\n+}"}, {"sha": "81619e73017f26a07892e72bd41a3ac01c9f5698", "filename": "clippy_lints/src/methods/filter_next.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f0f07accbce24adb5706eeb4e14e0e1c6b2b973b/clippy_lints%2Fsrc%2Fmethods%2Ffilter_next.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f07accbce24adb5706eeb4e14e0e1c6b2b973b/clippy_lints%2Fsrc%2Fmethods%2Ffilter_next.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_next.rs?ref=f0f07accbce24adb5706eeb4e14e0e1c6b2b973b", "patch": "@@ -0,0 +1,31 @@\n+use crate::utils::{match_trait_method, paths, snippet, span_lint, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::FILTER_NEXT;\n+\n+/// lint use of `filter().next()` for `Iterators`\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, filter_args: &'tcx [hir::Expr<'_>]) {\n+    // lint if caller of `.filter().next()` is an Iterator\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n+        let msg = \"called `filter(..).next()` on an `Iterator`. This is more succinctly expressed by calling \\\n+                   `.find(..)` instead\";\n+        let filter_snippet = snippet(cx, filter_args[1].span, \"..\");\n+        if filter_snippet.lines().count() <= 1 {\n+            let iter_snippet = snippet(cx, filter_args[0].span, \"..\");\n+            // add note if not multi-line\n+            span_lint_and_sugg(\n+                cx,\n+                FILTER_NEXT,\n+                expr.span,\n+                msg,\n+                \"try this\",\n+                format!(\"{}.find({})\", iter_snippet, filter_snippet),\n+                Applicability::MachineApplicable,\n+            );\n+        } else {\n+            span_lint(cx, FILTER_NEXT, expr.span, msg);\n+        }\n+    }\n+}"}, {"sha": "2684c50e01b7dcf72d481e3d5ebf5f35119223fc", "filename": "clippy_lints/src/methods/get_unwrap.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/f0f07accbce24adb5706eeb4e14e0e1c6b2b973b/clippy_lints%2Fsrc%2Fmethods%2Fget_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f07accbce24adb5706eeb4e14e0e1c6b2b973b/clippy_lints%2Fsrc%2Fmethods%2Fget_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fget_unwrap.rs?ref=f0f07accbce24adb5706eeb4e14e0e1c6b2b973b", "patch": "@@ -0,0 +1,84 @@\n+use crate::methods::derefs_to_slice;\n+use crate::utils::{\n+    get_parent_expr, is_type_diagnostic_item, match_type, paths, snippet_with_applicability, span_lint_and_sugg,\n+};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::GET_UNWRAP;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, get_args: &'tcx [hir::Expr<'_>], is_mut: bool) {\n+    // Note: we don't want to lint `get_mut().unwrap` for `HashMap` or `BTreeMap`,\n+    // because they do not implement `IndexMut`\n+    let mut applicability = Applicability::MachineApplicable;\n+    let expr_ty = cx.typeck_results().expr_ty(&get_args[0]);\n+    let get_args_str = if get_args.len() > 1 {\n+        snippet_with_applicability(cx, get_args[1].span, \"..\", &mut applicability)\n+    } else {\n+        return; // not linting on a .get().unwrap() chain or variant\n+    };\n+    let mut needs_ref;\n+    let caller_type = if derefs_to_slice(cx, &get_args[0], expr_ty).is_some() {\n+        needs_ref = get_args_str.parse::<usize>().is_ok();\n+        \"slice\"\n+    } else if is_type_diagnostic_item(cx, expr_ty, sym::vec_type) {\n+        needs_ref = get_args_str.parse::<usize>().is_ok();\n+        \"Vec\"\n+    } else if is_type_diagnostic_item(cx, expr_ty, sym!(vecdeque_type)) {\n+        needs_ref = get_args_str.parse::<usize>().is_ok();\n+        \"VecDeque\"\n+    } else if !is_mut && is_type_diagnostic_item(cx, expr_ty, sym!(hashmap_type)) {\n+        needs_ref = true;\n+        \"HashMap\"\n+    } else if !is_mut && match_type(cx, expr_ty, &paths::BTREEMAP) {\n+        needs_ref = true;\n+        \"BTreeMap\"\n+    } else {\n+        return; // caller is not a type that we want to lint\n+    };\n+\n+    let mut span = expr.span;\n+\n+    // Handle the case where the result is immediately dereferenced\n+    // by not requiring ref and pulling the dereference into the\n+    // suggestion.\n+    if_chain! {\n+        if needs_ref;\n+        if let Some(parent) = get_parent_expr(cx, expr);\n+        if let hir::ExprKind::Unary(hir::UnOp::Deref, _) = parent.kind;\n+        then {\n+            needs_ref = false;\n+            span = parent.span;\n+        }\n+    }\n+\n+    let mut_str = if is_mut { \"_mut\" } else { \"\" };\n+    let borrow_str = if !needs_ref {\n+        \"\"\n+    } else if is_mut {\n+        \"&mut \"\n+    } else {\n+        \"&\"\n+    };\n+\n+    span_lint_and_sugg(\n+        cx,\n+        GET_UNWRAP,\n+        span,\n+        &format!(\n+            \"called `.get{0}().unwrap()` on a {1}. Using `[]` is more clear and more concise\",\n+            mut_str, caller_type\n+        ),\n+        \"try this\",\n+        format!(\n+            \"{}{}[{}]\",\n+            borrow_str,\n+            snippet_with_applicability(cx, get_args[0].span, \"..\", &mut applicability),\n+            get_args_str\n+        ),\n+        applicability,\n+    );\n+}"}, {"sha": "71080e9bef0c92793db2af93bec43672d2a160ac", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 18, "deletions": 200, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/f0f07accbce24adb5706eeb4e14e0e1c6b2b973b/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f07accbce24adb5706eeb4e14e0e1c6b2b973b/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=f0f07accbce24adb5706eeb4e14e0e1c6b2b973b", "patch": "@@ -1,14 +1,19 @@\n mod bind_instead_of_map;\n mod bytes_nth;\n+mod expect_used;\n mod filter_map_identity;\n+mod filter_next;\n+mod get_unwrap;\n mod implicit_clone;\n mod inefficient_to_string;\n mod inspect_for_each;\n mod iter_count;\n mod manual_saturating_arithmetic;\n+mod ok_expect;\n mod option_map_unwrap_or;\n mod unnecessary_filter_map;\n mod unnecessary_lazy_eval;\n+mod unwrap_used;\n \n use std::borrow::Cow;\n use std::fmt;\n@@ -1649,31 +1654,31 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n         let method_names: Vec<&str> = method_names.iter().map(|s| &**s).collect();\n \n         match method_names.as_slice() {\n-            [\"unwrap\", \"get\"] => lint_get_unwrap(cx, expr, arg_lists[1], false),\n-            [\"unwrap\", \"get_mut\"] => lint_get_unwrap(cx, expr, arg_lists[1], true),\n-            [\"unwrap\", ..] => lint_unwrap(cx, expr, arg_lists[0]),\n-            [\"expect\", \"ok\"] => lint_ok_expect(cx, expr, arg_lists[1]),\n-            [\"expect\", ..] => lint_expect(cx, expr, arg_lists[0]),\n-            [\"unwrap_or\", \"map\"] => option_map_unwrap_or::lint(cx, expr, arg_lists[1], arg_lists[0], method_spans[1]),\n+            [\"unwrap\", \"get\"] => get_unwrap::check(cx, expr, arg_lists[1], false),\n+            [\"unwrap\", \"get_mut\"] => get_unwrap::check(cx, expr, arg_lists[1], true),\n+            [\"unwrap\", ..] => unwrap_used::check(cx, expr, arg_lists[0]),\n+            [\"expect\", \"ok\"] => ok_expect::check(cx, expr, arg_lists[1]),\n+            [\"expect\", ..] => expect_used::check(cx, expr, arg_lists[0]),\n+            [\"unwrap_or\", \"map\"] => option_map_unwrap_or::check(cx, expr, arg_lists[1], arg_lists[0], method_spans[1]),\n             [\"unwrap_or_else\", \"map\"] => {\n                 if !lint_map_unwrap_or_else(cx, expr, arg_lists[1], arg_lists[0], self.msrv.as_ref()) {\n-                    unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], \"unwrap_or\");\n+                    unnecessary_lazy_eval::check(cx, expr, arg_lists[0], \"unwrap_or\");\n                 }\n             },\n             [\"map_or\", ..] => lint_map_or_none(cx, expr, arg_lists[0]),\n             [\"and_then\", ..] => {\n                 let biom_option_linted = bind_instead_of_map::OptionAndThenSome::lint(cx, expr, arg_lists[0]);\n                 let biom_result_linted = bind_instead_of_map::ResultAndThenOk::lint(cx, expr, arg_lists[0]);\n                 if !biom_option_linted && !biom_result_linted {\n-                    unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], \"and\");\n+                    unnecessary_lazy_eval::check(cx, expr, arg_lists[0], \"and\");\n                 }\n             },\n             [\"or_else\", ..] => {\n                 if !bind_instead_of_map::ResultOrElseErrInfo::lint(cx, expr, arg_lists[0]) {\n-                    unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], \"or\");\n+                    unnecessary_lazy_eval::check(cx, expr, arg_lists[0], \"or\");\n                 }\n             },\n-            [\"next\", \"filter\"] => lint_filter_next(cx, expr, arg_lists[1]),\n+            [\"next\", \"filter\"] => filter_next::check(cx, expr, arg_lists[1]),\n             [\"next\", \"skip_while\"] => lint_skip_while_next(cx, expr, arg_lists[1]),\n             [\"next\", \"iter\"] => lint_iter_next(cx, expr, arg_lists[1]),\n             [\"map\", \"filter\"] => lint_filter_map(cx, expr, false),\n@@ -1724,9 +1729,9 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             [\"map\", \"as_mut\"] => {\n                 lint_option_as_ref_deref(cx, expr, arg_lists[1], arg_lists[0], true, self.msrv.as_ref())\n             },\n-            [\"unwrap_or_else\", ..] => unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], \"unwrap_or\"),\n-            [\"get_or_insert_with\", ..] => unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], \"get_or_insert\"),\n-            [\"ok_or_else\", ..] => unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], \"ok_or\"),\n+            [\"unwrap_or_else\", ..] => unnecessary_lazy_eval::check(cx, expr, arg_lists[0], \"unwrap_or\"),\n+            [\"get_or_insert_with\", ..] => unnecessary_lazy_eval::check(cx, expr, arg_lists[0], \"get_or_insert\"),\n+            [\"ok_or_else\", ..] => unnecessary_lazy_eval::check(cx, expr, arg_lists[0], \"ok_or\"),\n             [\"collect\", \"map\"] => lint_map_collect(cx, expr, arg_lists[1], arg_lists[0]),\n             [\"for_each\", \"inspect\"] => inspect_for_each::lint(cx, expr, method_spans[1]),\n             [\"to_owned\", ..] => implicit_clone::check(cx, expr, sym::ToOwned),\n@@ -2712,79 +2717,6 @@ fn lint_iter_nth_zero<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, nth_ar\n     }\n }\n \n-fn lint_get_unwrap<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, get_args: &'tcx [hir::Expr<'_>], is_mut: bool) {\n-    // Note: we don't want to lint `get_mut().unwrap` for `HashMap` or `BTreeMap`,\n-    // because they do not implement `IndexMut`\n-    let mut applicability = Applicability::MachineApplicable;\n-    let expr_ty = cx.typeck_results().expr_ty(&get_args[0]);\n-    let get_args_str = if get_args.len() > 1 {\n-        snippet_with_applicability(cx, get_args[1].span, \"..\", &mut applicability)\n-    } else {\n-        return; // not linting on a .get().unwrap() chain or variant\n-    };\n-    let mut needs_ref;\n-    let caller_type = if derefs_to_slice(cx, &get_args[0], expr_ty).is_some() {\n-        needs_ref = get_args_str.parse::<usize>().is_ok();\n-        \"slice\"\n-    } else if is_type_diagnostic_item(cx, expr_ty, sym::vec_type) {\n-        needs_ref = get_args_str.parse::<usize>().is_ok();\n-        \"Vec\"\n-    } else if is_type_diagnostic_item(cx, expr_ty, sym::vecdeque_type) {\n-        needs_ref = get_args_str.parse::<usize>().is_ok();\n-        \"VecDeque\"\n-    } else if !is_mut && is_type_diagnostic_item(cx, expr_ty, sym::hashmap_type) {\n-        needs_ref = true;\n-        \"HashMap\"\n-    } else if !is_mut && match_type(cx, expr_ty, &paths::BTREEMAP) {\n-        needs_ref = true;\n-        \"BTreeMap\"\n-    } else {\n-        return; // caller is not a type that we want to lint\n-    };\n-\n-    let mut span = expr.span;\n-\n-    // Handle the case where the result is immediately dereferenced\n-    // by not requiring ref and pulling the dereference into the\n-    // suggestion.\n-    if_chain! {\n-        if needs_ref;\n-        if let Some(parent) = get_parent_expr(cx, expr);\n-        if let hir::ExprKind::Unary(hir::UnOp::Deref, _) = parent.kind;\n-        then {\n-            needs_ref = false;\n-            span = parent.span;\n-        }\n-    }\n-\n-    let mut_str = if is_mut { \"_mut\" } else { \"\" };\n-    let borrow_str = if !needs_ref {\n-        \"\"\n-    } else if is_mut {\n-        \"&mut \"\n-    } else {\n-        \"&\"\n-    };\n-\n-    span_lint_and_sugg(\n-        cx,\n-        GET_UNWRAP,\n-        span,\n-        &format!(\n-            \"called `.get{0}().unwrap()` on a {1}. Using `[]` is more clear and more concise\",\n-            mut_str, caller_type\n-        ),\n-        \"try this\",\n-        format!(\n-            \"{}{}[{}]\",\n-            borrow_str,\n-            snippet_with_applicability(cx, get_args[0].span, \"..\", &mut applicability),\n-            get_args_str\n-        ),\n-        applicability,\n-    );\n-}\n-\n fn lint_iter_skip_next(cx: &LateContext<'_>, expr: &hir::Expr<'_>, skip_args: &[hir::Expr<'_>]) {\n     // lint if caller of skip is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n@@ -2843,80 +2775,6 @@ fn derefs_to_slice<'tcx>(\n     }\n }\n \n-/// lint use of `unwrap()` for `Option`s and `Result`s\n-fn lint_unwrap(cx: &LateContext<'_>, expr: &hir::Expr<'_>, unwrap_args: &[hir::Expr<'_>]) {\n-    let obj_ty = cx.typeck_results().expr_ty(&unwrap_args[0]).peel_refs();\n-\n-    let mess = if is_type_diagnostic_item(cx, obj_ty, sym::option_type) {\n-        Some((UNWRAP_USED, \"an Option\", \"None\"))\n-    } else if is_type_diagnostic_item(cx, obj_ty, sym::result_type) {\n-        Some((UNWRAP_USED, \"a Result\", \"Err\"))\n-    } else {\n-        None\n-    };\n-\n-    if let Some((lint, kind, none_value)) = mess {\n-        span_lint_and_help(\n-            cx,\n-            lint,\n-            expr.span,\n-            &format!(\"used `unwrap()` on `{}` value\", kind,),\n-            None,\n-            &format!(\n-                \"if you don't want to handle the `{}` case gracefully, consider \\\n-                using `expect()` to provide a better panic message\",\n-                none_value,\n-            ),\n-        );\n-    }\n-}\n-\n-/// lint use of `expect()` for `Option`s and `Result`s\n-fn lint_expect(cx: &LateContext<'_>, expr: &hir::Expr<'_>, expect_args: &[hir::Expr<'_>]) {\n-    let obj_ty = cx.typeck_results().expr_ty(&expect_args[0]).peel_refs();\n-\n-    let mess = if is_type_diagnostic_item(cx, obj_ty, sym::option_type) {\n-        Some((EXPECT_USED, \"an Option\", \"None\"))\n-    } else if is_type_diagnostic_item(cx, obj_ty, sym::result_type) {\n-        Some((EXPECT_USED, \"a Result\", \"Err\"))\n-    } else {\n-        None\n-    };\n-\n-    if let Some((lint, kind, none_value)) = mess {\n-        span_lint_and_help(\n-            cx,\n-            lint,\n-            expr.span,\n-            &format!(\"used `expect()` on `{}` value\", kind,),\n-            None,\n-            &format!(\"if this value is an `{}`, it will panic\", none_value,),\n-        );\n-    }\n-}\n-\n-/// lint use of `ok().expect()` for `Result`s\n-fn lint_ok_expect(cx: &LateContext<'_>, expr: &hir::Expr<'_>, ok_args: &[hir::Expr<'_>]) {\n-    if_chain! {\n-        // lint if the caller of `ok()` is a `Result`\n-        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&ok_args[0]), sym::result_type);\n-        let result_type = cx.typeck_results().expr_ty(&ok_args[0]);\n-        if let Some(error_type) = get_error_type(cx, result_type);\n-        if has_debug_impl(error_type, cx);\n-\n-        then {\n-            span_lint_and_help(\n-                cx,\n-                OK_EXPECT,\n-                expr.span,\n-                \"called `ok().expect()` on a `Result` value\",\n-                None,\n-                \"you can call `expect()` directly on the `Result`\",\n-            );\n-        }\n-    }\n-}\n-\n /// lint use of `map().flatten()` for `Iterators` and 'Options'\n fn lint_map_flatten<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map_args: &'tcx [hir::Expr<'_>]) {\n     // lint if caller of `.map().flatten()` is an Iterator\n@@ -3107,31 +2965,6 @@ fn lint_map_or_none<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map\n     );\n }\n \n-/// lint use of `filter().next()` for `Iterators`\n-fn lint_filter_next<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, filter_args: &'tcx [hir::Expr<'_>]) {\n-    // lint if caller of `.filter().next()` is an Iterator\n-    if match_trait_method(cx, expr, &paths::ITERATOR) {\n-        let msg = \"called `filter(..).next()` on an `Iterator`. This is more succinctly expressed by calling \\\n-                   `.find(..)` instead\";\n-        let filter_snippet = snippet(cx, filter_args[1].span, \"..\");\n-        if filter_snippet.lines().count() <= 1 {\n-            let iter_snippet = snippet(cx, filter_args[0].span, \"..\");\n-            // add note if not multi-line\n-            span_lint_and_sugg(\n-                cx,\n-                FILTER_NEXT,\n-                expr.span,\n-                msg,\n-                \"try this\",\n-                format!(\"{}.find({})\", iter_snippet, filter_snippet),\n-                Applicability::MachineApplicable,\n-            );\n-        } else {\n-            span_lint(cx, FILTER_NEXT, expr.span, msg);\n-        }\n-    }\n-}\n-\n /// lint use of `skip_while().next()` for `Iterators`\n fn lint_skip_while_next<'tcx>(\n     cx: &LateContext<'tcx>,\n@@ -3914,21 +3747,6 @@ fn lint_map_collect(\n     }\n }\n \n-/// Given a `Result<T, E>` type, return its error type (`E`).\n-fn get_error_type<'a>(cx: &LateContext<'_>, ty: Ty<'a>) -> Option<Ty<'a>> {\n-    match ty.kind() {\n-        ty::Adt(_, substs) if is_type_diagnostic_item(cx, ty, sym::result_type) => substs.types().nth(1),\n-        _ => None,\n-    }\n-}\n-\n-/// This checks whether a given type is known to implement Debug.\n-fn has_debug_impl<'tcx>(ty: Ty<'tcx>, cx: &LateContext<'tcx>) -> bool {\n-    cx.tcx\n-        .get_diagnostic_item(sym::debug_trait)\n-        .map_or(false, |debug| implements_trait(cx, ty, debug, &[]))\n-}\n-\n enum Convention {\n     Eq(&'static str),\n     StartsWith(&'static str),"}, {"sha": "c1706cc7cc7d266ad0c2f902e3a2d615148c6ca0", "filename": "clippy_lints/src/methods/ok_expect.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f0f07accbce24adb5706eeb4e14e0e1c6b2b973b/clippy_lints%2Fsrc%2Fmethods%2Fok_expect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f07accbce24adb5706eeb4e14e0e1c6b2b973b/clippy_lints%2Fsrc%2Fmethods%2Fok_expect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fok_expect.rs?ref=f0f07accbce24adb5706eeb4e14e0e1c6b2b973b", "patch": "@@ -0,0 +1,45 @@\n+use crate::utils::{implements_trait, is_type_diagnostic_item, span_lint_and_help};\n+use if_chain::if_chain;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+use rustc_span::sym;\n+\n+use super::OK_EXPECT;\n+\n+/// lint use of `ok().expect()` for `Result`s\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, ok_args: &[hir::Expr<'_>]) {\n+    if_chain! {\n+        // lint if the caller of `ok()` is a `Result`\n+        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&ok_args[0]), sym::result_type);\n+        let result_type = cx.typeck_results().expr_ty(&ok_args[0]);\n+        if let Some(error_type) = get_error_type(cx, result_type);\n+        if has_debug_impl(error_type, cx);\n+\n+        then {\n+            span_lint_and_help(\n+                cx,\n+                OK_EXPECT,\n+                expr.span,\n+                \"called `ok().expect()` on a `Result` value\",\n+                None,\n+                \"you can call `expect()` directly on the `Result`\",\n+            );\n+        }\n+    }\n+}\n+\n+/// Given a `Result<T, E>` type, return its error type (`E`).\n+fn get_error_type<'a>(cx: &LateContext<'_>, ty: Ty<'a>) -> Option<Ty<'a>> {\n+    match ty.kind() {\n+        ty::Adt(_, substs) if is_type_diagnostic_item(cx, ty, sym::result_type) => substs.types().nth(1),\n+        _ => None,\n+    }\n+}\n+\n+/// This checks whether a given type is known to implement Debug.\n+fn has_debug_impl<'tcx>(ty: Ty<'tcx>, cx: &LateContext<'tcx>) -> bool {\n+    cx.tcx\n+        .get_diagnostic_item(sym::debug_trait)\n+        .map_or(false, |debug| implements_trait(cx, ty, debug, &[]))\n+}"}, {"sha": "7cdd49bbf0307a6a3a2adaa6c6e8b1e976f1ce55", "filename": "clippy_lints/src/methods/option_map_unwrap_or.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0f07accbce24adb5706eeb4e14e0e1c6b2b973b/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f07accbce24adb5706eeb4e14e0e1c6b2b973b/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs?ref=f0f07accbce24adb5706eeb4e14e0e1c6b2b973b", "patch": "@@ -12,7 +12,7 @@ use rustc_span::{sym, Symbol};\n use super::MAP_UNWRAP_OR;\n \n /// lint use of `map().unwrap_or()` for `Option`s\n-pub(super) fn lint<'tcx>(\n+pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &rustc_hir::Expr<'_>,\n     map_args: &'tcx [rustc_hir::Expr<'_>],"}, {"sha": "a17259d697faa3128d33a83f8699f9e4f5efa86e", "filename": "clippy_lints/src/methods/unnecessary_lazy_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0f07accbce24adb5706eeb4e14e0e1c6b2b973b/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f07accbce24adb5706eeb4e14e0e1c6b2b973b/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs?ref=f0f07accbce24adb5706eeb4e14e0e1c6b2b973b", "patch": "@@ -9,7 +9,7 @@ use super::UNNECESSARY_LAZY_EVALUATIONS;\n \n /// lint use of `<fn>_else(simple closure)` for `Option`s and `Result`s that can be\n /// replaced with `<fn>(return value of simple closure)`\n-pub(super) fn lint<'tcx>(\n+pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx hir::Expr<'_>,\n     args: &'tcx [hir::Expr<'_>],"}, {"sha": "094c3fc45c493b097b13c4bba274938aa1c5f2ee", "filename": "clippy_lints/src/methods/unwrap_used.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f0f07accbce24adb5706eeb4e14e0e1c6b2b973b/clippy_lints%2Fsrc%2Fmethods%2Funwrap_used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f07accbce24adb5706eeb4e14e0e1c6b2b973b/clippy_lints%2Fsrc%2Fmethods%2Funwrap_used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funwrap_used.rs?ref=f0f07accbce24adb5706eeb4e14e0e1c6b2b973b", "patch": "@@ -0,0 +1,34 @@\n+use crate::utils::{is_type_diagnostic_item, span_lint_and_help};\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::UNWRAP_USED;\n+\n+/// lint use of `unwrap()` for `Option`s and `Result`s\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, unwrap_args: &[hir::Expr<'_>]) {\n+    let obj_ty = cx.typeck_results().expr_ty(&unwrap_args[0]).peel_refs();\n+\n+    let mess = if is_type_diagnostic_item(cx, obj_ty, sym::option_type) {\n+        Some((UNWRAP_USED, \"an Option\", \"None\"))\n+    } else if is_type_diagnostic_item(cx, obj_ty, sym::result_type) {\n+        Some((UNWRAP_USED, \"a Result\", \"Err\"))\n+    } else {\n+        None\n+    };\n+\n+    if let Some((lint, kind, none_value)) = mess {\n+        span_lint_and_help(\n+            cx,\n+            lint,\n+            expr.span,\n+            &format!(\"used `unwrap()` on `{}` value\", kind,),\n+            None,\n+            &format!(\n+                \"if you don't want to handle the `{}` case gracefully, consider \\\n+                using `expect()` to provide a better panic message\",\n+                none_value,\n+            ),\n+        );\n+    }\n+}"}]}