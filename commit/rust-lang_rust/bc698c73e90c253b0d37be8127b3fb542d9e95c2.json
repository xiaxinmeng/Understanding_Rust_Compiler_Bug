{"sha": "bc698c73e90c253b0d37be8127b3fb542d9e95c2", "node_id": "C_kwDOAAsO6NoAKGJjNjk4YzczZTkwYzI1M2IwZDM3YmU4MTI3YjNmYjU0MmQ5ZTk1YzI", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-04-21T17:35:06Z"}, "committer": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-04-21T21:11:06Z"}, "message": "deduplicate a lot of code", "tree": {"sha": "14bc8c30dbcf7e6117798bd235a92f0caaaad399", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14bc8c30dbcf7e6117798bd235a92f0caaaad399"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc698c73e90c253b0d37be8127b3fb542d9e95c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc698c73e90c253b0d37be8127b3fb542d9e95c2", "html_url": "https://github.com/rust-lang/rust/commit/bc698c73e90c253b0d37be8127b3fb542d9e95c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc698c73e90c253b0d37be8127b3fb542d9e95c2/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28af967bb9165999294250dc3f3a56c2193c35d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/28af967bb9165999294250dc3f3a56c2193c35d9", "html_url": "https://github.com/rust-lang/rust/commit/28af967bb9165999294250dc3f3a56c2193c35d9"}], "stats": {"total": 369, "additions": 122, "deletions": 247}, "files": [{"sha": "39a3df79a28eb71c3c04691c702cb56a2c1e8f4b", "filename": "compiler/rustc_const_eval/src/const_eval/valtrees.rs", "status": "modified", "additions": 115, "deletions": 224, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/bc698c73e90c253b0d37be8127b3fb542d9e95c2/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc698c73e90c253b0d37be8127b3fb542d9e95c2/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs?ref=bc698c73e90c253b0d37be8127b3fb542d9e95c2", "patch": "@@ -2,16 +2,16 @@ use super::eval_queries::{mk_eval_cx, op_to_const};\n use super::machine::CompileTimeEvalContext;\n use crate::interpret::{\n     intern_const_alloc_recursive, ConstValue, ImmTy, Immediate, InternKind, MemoryKind, PlaceTy,\n-    Pointer, Scalar, ScalarMaybeUninit,\n+    Scalar, ScalarMaybeUninit,\n };\n-use rustc_middle::mir::interpret::{ConstAlloc, GlobalAlloc};\n+use rustc_middle::mir::interpret::ConstAlloc;\n use rustc_middle::mir::{Field, ProjectionElem};\n use rustc_middle::ty::{self, ScalarInt, Ty, TyCtxt};\n use rustc_span::source_map::DUMMY_SP;\n use rustc_target::abi::VariantIdx;\n \n-use crate::interpret::visitor::Value;\n use crate::interpret::MPlaceTy;\n+use crate::interpret::Value;\n \n /// Convert an evaluated constant to a type level constant\n #[instrument(skip(tcx), level = \"debug\")]\n@@ -54,6 +54,7 @@ fn branches<'tcx>(\n     Some(ty::ValTree::Branch(ecx.tcx.arena.alloc_from_iter(branches.collect::<Option<Vec<_>>>()?)))\n }\n \n+#[instrument(skip(ecx), level = \"debug\")]\n fn slice_branches<'tcx>(\n     ecx: &CompileTimeEvalContext<'tcx, 'tcx>,\n     place: &MPlaceTy<'tcx>,\n@@ -139,15 +140,44 @@ fn const_to_valtree_inner<'tcx>(\n #[instrument(skip(ecx), level = \"debug\")]\n fn create_mplace_from_layout<'tcx>(\n     ecx: &mut CompileTimeEvalContext<'tcx, 'tcx>,\n-    param_env_ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n+    ty: Ty<'tcx>,\n ) -> MPlaceTy<'tcx> {\n     let tcx = ecx.tcx;\n-    let layout = tcx.layout_of(param_env_ty).unwrap();\n+    let param_env = ecx.param_env;\n+    let layout = tcx.layout_of(param_env.and(ty)).unwrap();\n     debug!(?layout);\n \n     ecx.allocate(layout, MemoryKind::Stack).unwrap()\n }\n \n+#[instrument(skip(ecx), level = \"debug\")]\n+fn create_pointee_place<'tcx>(\n+    ecx: &mut CompileTimeEvalContext<'tcx, 'tcx>,\n+    ty: Ty<'tcx>,\n+    valtree: ty::ValTree<'tcx>,\n+) -> MPlaceTy<'tcx> {\n+    let tcx = ecx.tcx.tcx;\n+\n+    match ty.kind() {\n+        ty::Slice(_) | ty::Str => {\n+            let slice_ty = match ty.kind() {\n+                ty::Slice(slice_ty) => *slice_ty,\n+                ty::Str => tcx.mk_ty(ty::Uint(ty::UintTy::U8)),\n+                _ => bug!(\"expected ty::Slice | ty::Str\"),\n+            };\n+\n+            // Create a place for the underlying array\n+            let len = valtree.unwrap_branch().len() as u64;\n+            let arr_ty = tcx.mk_array(slice_ty, len as u64);\n+            let place = create_mplace_from_layout(ecx, arr_ty);\n+            debug!(?place);\n+\n+            place\n+        }\n+        _ => create_mplace_from_layout(ecx, ty),\n+    }\n+}\n+\n /// Converts a `ValTree` to a `ConstValue`, which is needed after mir\n /// construction has finished.\n #[instrument(skip(tcx), level = \"debug\")]\n@@ -174,96 +204,28 @@ pub fn valtree_to_const_value<'tcx>(\n             ),\n         },\n         ty::Ref(_, inner_ty, _) => {\n-            match inner_ty.kind() {\n-                ty::Slice(_) | ty::Str => {\n-                    let slice_ty = match inner_ty.kind() {\n-                        ty::Slice(slice_ty) => *slice_ty,\n-                        ty::Str => tcx.mk_ty(ty::Uint(ty::UintTy::U8)),\n-                        _ => bug!(\"expected ty::Slice | ty::Str\"),\n-                    };\n-                    debug!(?slice_ty);\n-\n-                    let valtrees = valtree.unwrap_branch();\n-\n-                    // Create a place for the underlying array\n-                    let len = valtrees.len();\n-                    let arr_ty = tcx.mk_array(slice_ty, len as u64);\n-                    let mut place =\n-                        create_mplace_from_layout(&mut ecx, ty::ParamEnv::empty().and(arr_ty));\n-                    debug!(?place);\n-\n-                    // Insert elements of `arr_valtree` into `place`\n-                    fill_place_recursively(&mut ecx, &mut place, valtree, arr_ty);\n-                    dump_place(&ecx, place.into());\n-\n-                    // The allocation behind `place` is local, we need to intern it\n-                    intern_const_alloc_recursive(&mut ecx, InternKind::Constant, &place).unwrap();\n-\n-                    // Now we need to get the Allocation\n-                    let alloc_id = place.mplace.ptr.provenance.unwrap();\n-                    debug!(?alloc_id);\n-\n-                    let data = match tcx.get_global_alloc(alloc_id) {\n-                        Some(GlobalAlloc::Memory(const_alloc)) => const_alloc,\n-                        _ => bug!(\"expected memory allocation\"),\n-                    };\n-                    debug!(?data);\n-\n-                    return ConstValue::Slice { data, start: 0, end: len as usize };\n-                }\n-                _ => {\n-                    match valtree {\n-                        ty::ValTree::Branch(_) => {\n-                            // create a place for the pointee\n-                            let mut place = create_mplace_from_layout(\n-                                &mut ecx,\n-                                ty::ParamEnv::empty().and(*inner_ty),\n-                            );\n-                            debug!(?place);\n-\n-                            // insert elements of valtree into `place`\n-                            fill_place_recursively(&mut ecx, &mut place, valtree, *inner_ty);\n-                            dump_place(&ecx, place.into());\n-                            intern_const_alloc_recursive(&mut ecx, InternKind::Constant, &place)\n-                                .unwrap();\n-\n-                            let ref_place = place.mplace.to_ref(&tcx);\n-                            let imm = ImmTy::from_immediate(\n-                                ref_place,\n-                                tcx.layout_of(param_env_ty).unwrap(),\n-                            );\n-\n-                            let const_val = op_to_const(&ecx, &imm.into());\n-                            debug!(?const_val);\n-\n-                            const_val\n-                        }\n-                        ty::ValTree::Leaf(_) => {\n-                            let mut place = create_mplace_from_layout(\n-                                &mut ecx,\n-                                ty::ParamEnv::empty().and(*inner_ty),\n-                            );\n-\n-                            fill_place_recursively(&mut ecx, &mut place, valtree, *inner_ty);\n-                            dump_place(&ecx, place.into());\n-\n-                            let ref_place = place.mplace.to_ref(&tcx);\n-                            let imm = ImmTy::from_immediate(\n-                                ref_place,\n-                                tcx.layout_of(param_env_ty).unwrap(),\n-                            );\n-\n-                            op_to_const(&ecx, &imm.into())\n-                        }\n-                    }\n-                }\n-            }\n+            // create a place for the pointee\n+            let mut pointee_place = create_pointee_place(&mut ecx, *inner_ty, valtree);\n+            debug!(?pointee_place);\n+\n+            // insert elements of valtree into `place`\n+            fill_place_recursively(&mut ecx, &mut pointee_place, valtree);\n+            dump_place(&ecx, pointee_place.into());\n+            intern_const_alloc_recursive(&mut ecx, InternKind::Constant, &pointee_place).unwrap();\n+\n+            let ref_place = pointee_place.to_ref(&tcx);\n+            let imm = ImmTy::from_immediate(ref_place, tcx.layout_of(param_env_ty).unwrap());\n+\n+            let const_val = op_to_const(&ecx, &imm.into());\n+            debug!(?const_val);\n+\n+            const_val\n         }\n         ty::Tuple(_) | ty::Array(_, _) | ty::Adt(..) => {\n-            let mut place = create_mplace_from_layout(&mut ecx, param_env_ty);\n+            let mut place = create_mplace_from_layout(&mut ecx, ty);\n             debug!(?place);\n \n-            fill_place_recursively(&mut ecx, &mut place, valtree, ty);\n+            fill_place_recursively(&mut ecx, &mut place, valtree);\n             dump_place(&ecx, place.into());\n             intern_const_alloc_recursive(&mut ecx, InternKind::Constant, &place).unwrap();\n \n@@ -301,12 +263,12 @@ fn fill_place_recursively<'tcx>(\n     ecx: &mut CompileTimeEvalContext<'tcx, 'tcx>,\n     place: &mut MPlaceTy<'tcx>,\n     valtree: ty::ValTree<'tcx>,\n-    ty: Ty<'tcx>,\n ) {\n     // This will match on valtree and write the value(s) corresponding to the ValTree\n     // inside the place recursively.\n \n     let tcx = ecx.tcx.tcx;\n+    let ty = place.layout.ty;\n \n     match ty.kind() {\n         ty::Bool | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Char => {\n@@ -319,161 +281,90 @@ fn fill_place_recursively<'tcx>(\n             .unwrap();\n         }\n         ty::Ref(_, inner_ty, _) => {\n-            match inner_ty.kind() {\n+            let mut pointee_place = create_pointee_place(ecx, *inner_ty, valtree);\n+            debug!(?pointee_place);\n+\n+            fill_place_recursively(ecx, &mut pointee_place, valtree);\n+            dump_place(ecx, pointee_place.into());\n+            intern_const_alloc_recursive(ecx, InternKind::Constant, &pointee_place).unwrap();\n+\n+            let imm = match inner_ty.kind() {\n                 ty::Slice(_) | ty::Str => {\n-                    let slice_ty = match inner_ty.kind() {\n-                        ty::Slice(slice_ty) => *slice_ty,\n-                        ty::Str => tcx.mk_ty(ty::Uint(ty::UintTy::U8)),\n-                        _ => bug!(\"expected ty::Slice | ty::Str\"),\n-                    };\n-                    debug!(?slice_ty);\n-\n-                    let valtrees = valtree.unwrap_branch();\n-                    debug!(?valtrees);\n-                    let len = valtrees.len();\n-                    debug!(?len);\n-\n-                    // create a place for the underlying array\n-                    let arr_ty = tcx.mk_array(slice_ty, len as u64);\n-                    let mut arr_place =\n-                        create_mplace_from_layout(ecx, ty::ParamEnv::empty().and(arr_ty));\n-                    debug!(?arr_place);\n-\n-                    // Insert elements of `arr_valtree` into `place`\n-                    fill_place_recursively(ecx, &mut arr_place, valtree, arr_ty);\n-                    dump_place(&ecx, arr_place.into());\n-\n-                    // Now we need to create a `ScalarPair` from the filled `place`\n-                    // and write that into `place`\n-                    let (alloc_id, offset) = arr_place.mplace.ptr.into_parts();\n-                    debug!(?alloc_id, ?offset);\n-                    let unwrapped_ptr = Pointer { offset, provenance: alloc_id.unwrap() };\n+                    let len = valtree.unwrap_branch().len();\n                     let len_scalar = ScalarMaybeUninit::Scalar(Scalar::from_u64(len as u64));\n \n-                    let imm = Immediate::ScalarPair(\n-                        ScalarMaybeUninit::from_pointer(unwrapped_ptr, &tcx),\n+                    Immediate::ScalarPair(\n+                        ScalarMaybeUninit::from_maybe_pointer((*pointee_place).ptr, &tcx),\n                         len_scalar,\n-                    );\n-                    debug!(?imm);\n-\n-                    // Now write the ScalarPair into the original place we wanted to fill\n-                    // in this call\n-                    let _ = ecx.write_immediate(imm, &(*place).into()).unwrap();\n-\n-                    dump_place(&ecx, (*place).into());\n+                    )\n                 }\n-                _ => {\n-                    let mut pointee_place =\n-                        create_mplace_from_layout(ecx, ty::ParamEnv::empty().and(*inner_ty));\n-                    debug!(?pointee_place);\n-                    fill_place_recursively(ecx, &mut pointee_place, valtree, *inner_ty);\n+                _ => pointee_place.to_ref(&tcx),\n+            };\n+            debug!(?imm);\n \n-                    dump_place(ecx, pointee_place.into());\n-                    intern_const_alloc_recursive(ecx, InternKind::Constant, &pointee_place)\n-                        .unwrap();\n-\n-                    let imm = pointee_place.mplace.to_ref(&tcx);\n-                    debug!(?imm);\n-\n-                    ecx.write_immediate(imm, &(*place).into()).unwrap();\n-                }\n-            }\n+            ecx.write_immediate(imm, &(*place).into()).unwrap();\n         }\n-        ty::Tuple(tuple_types) => {\n+        ty::Adt(_, _) | ty::Tuple(_) | ty::Array(_, _) | ty::Str => {\n             let branches = valtree.unwrap_branch();\n-            assert_eq!(tuple_types.len(), branches.len());\n \n+            // Need to downcast place for enums\n+            let (place_adjusted, branches, variant_idx) = match ty.kind() {\n+                ty::Adt(def, _) if def.is_enum() => {\n+                    // First element of valtree corresponds to variant\n+                    let scalar_int = branches[0].unwrap_leaf();\n+                    let variant_idx = VariantIdx::from_u32(scalar_int.try_to_u32().unwrap());\n+                    let variant = def.variant(variant_idx);\n+                    debug!(?variant);\n+\n+                    (\n+                        place.project_downcast(ecx, variant_idx).unwrap(),\n+                        &branches[1..],\n+                        Some(variant_idx),\n+                    )\n+                }\n+                _ => (*place, branches, None),\n+            };\n+            debug!(?place_adjusted, ?branches);\n+\n+            // Create the places for the fields and fill them recursively\n             for (i, inner_valtree) in branches.iter().enumerate() {\n                 debug!(?i, ?inner_valtree);\n-                let inner_ty = tuple_types.get(i).expect(&format!(\n-                    \"expected to be able to index at position {} into {:?}\",\n-                    i, tuple_types\n-                ));\n-                debug!(?inner_ty);\n-\n-                // Create the mplace for the tuple element\n-                let mut place_inner = ecx.mplace_field(place, i).unwrap();\n+\n+                let mut place_inner = match *ty.kind() {\n+                    ty::Adt(def, substs) if !def.is_enum() => {\n+                        let field = &def.variant(VariantIdx::from_usize(0)).fields[i];\n+                        let field_ty = field.ty(tcx, substs);\n+                        let projection_elem = ProjectionElem::Field(Field::from_usize(i), field_ty);\n+\n+                        ecx.mplace_projection(&place_adjusted, projection_elem).unwrap()\n+                    }\n+                    ty::Adt(_, _) | ty::Tuple(_) => ecx.mplace_field(&place_adjusted, i).unwrap(),\n+                    ty::Array(_, _) | ty::Str => {\n+                        ecx.mplace_index(&place_adjusted, i as u64).unwrap()\n+                    }\n+                    _ => bug!(),\n+                };\n                 debug!(?place_inner);\n \n                 // insert valtree corresponding to tuple element into place\n-                fill_place_recursively(ecx, &mut place_inner, *inner_valtree, *inner_ty);\n+                fill_place_recursively(ecx, &mut place_inner, *inner_valtree);\n+                dump_place(&ecx, place_inner.into());\n             }\n-        }\n-        ty::Array(inner_ty, _) => {\n-            let inner_valtrees = valtree.unwrap_branch();\n-            for (i, inner_valtree) in inner_valtrees.iter().enumerate() {\n-                debug!(?i, ?inner_valtree);\n \n-                let mut place_inner = ecx.mplace_field(place, i).unwrap();\n-                debug!(?place_inner);\n+            debug!(\"dump of place_adjusted:\");\n+            dump_place(ecx, place_adjusted.into());\n \n-                fill_place_recursively(ecx, &mut place_inner, *inner_valtree, *inner_ty)\n-            }\n-        }\n-        ty::Adt(def, substs) if def.is_enum() => {\n-            debug!(\"enum, substs: {:?}\", substs);\n-            let inner_valtrees = valtree.unwrap_branch();\n-\n-            // First element of valtree corresponds to variant\n-            let scalar_int = inner_valtrees[0].unwrap_leaf();\n-            let variant_idx = VariantIdx::from_u32(scalar_int.try_to_u32().unwrap());\n-            let variant = def.variant(variant_idx);\n-            debug!(?variant);\n-\n-            // Need to downcast place\n-            let place_downcast = place.project_downcast(ecx, variant_idx).unwrap();\n-            debug!(?place_downcast);\n-\n-            // fill `place_downcast` with the valtree elements corresponding to\n-            // the fields of the enum\n-            let fields = &variant.fields;\n-            let inner_valtrees = &inner_valtrees[1..];\n-            for (i, field) in fields.iter().enumerate() {\n-                debug!(?i, ?field);\n-\n-                let field_ty = field.ty(tcx, substs);\n-                debug!(?field_ty);\n-\n-                let mut field_mplace = ecx.mplace_field(&place_downcast, i).unwrap();\n-                debug!(?field_mplace);\n-                let inner_valtree = inner_valtrees[i];\n-\n-                fill_place_recursively(ecx, &mut field_mplace, inner_valtree, field_ty);\n-                dump_place(&ecx, field_mplace.into());\n+            if let Some(variant_idx) = variant_idx {\n+                // don't forget filling the place with the discriminant of the enum\n+                ecx.write_discriminant(variant_idx, &(*place).into()).unwrap();\n             }\n \n-            debug!(\"dump of place_downcast\");\n-            dump_place(ecx, place_downcast.into());\n-\n-            // don't forget filling the place with the discriminant of the enum\n-            ecx.write_discriminant(variant_idx, &(*place).into()).unwrap();\n             dump_place(ecx, (*place).into());\n         }\n-        ty::Adt(def, substs) => {\n-            debug!(\"Adt def: {:?} with substs: {:?}\", def, substs);\n-            let inner_valtrees = valtree.unwrap_branch();\n-            debug!(?inner_valtrees);\n-            let (fields, inner_valtrees) =\n-                (&def.variant(VariantIdx::from_usize(0)).fields[..], inner_valtrees);\n-\n-            debug!(\"fields: {:?}\", fields);\n-\n-            for (i, field) in fields.iter().enumerate() {\n-                let field_ty = field.ty(tcx, substs);\n-                debug!(?field_ty);\n-                let old_field_ty = tcx.type_of(field.did);\n-                debug!(?old_field_ty);\n-                let projection_elem = ProjectionElem::Field(Field::from_usize(i), field_ty);\n-                let mut field_place = ecx.mplace_projection(place, projection_elem).unwrap();\n-                let inner_valtree = inner_valtrees[i];\n-\n-                fill_place_recursively(ecx, &mut field_place, inner_valtree, field_ty);\n-            }\n-        }\n-        _ => {}\n+        _ => bug!(\"shouldn't have created a ValTree for {:?}\", ty),\n     }\n }\n \n fn dump_place<'tcx>(ecx: &CompileTimeEvalContext<'tcx, 'tcx>, place: PlaceTy<'tcx>) {\n-    trace!(\"{:?}\", ecx.dump_place(place.place));\n+    trace!(\"{:?}\", ecx.dump_place(*place));\n }"}, {"sha": "69d6c8470a2737233cef08d2ec5e517b725adf93", "filename": "compiler/rustc_const_eval/src/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc698c73e90c253b0d37be8127b3fb542d9e95c2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc698c73e90c253b0d37be8127b3fb542d9e95c2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmod.rs?ref=bc698c73e90c253b0d37be8127b3fb542d9e95c2", "patch": "@@ -14,7 +14,7 @@ mod terminator;\n mod traits;\n mod util;\n mod validity;\n-pub(crate) mod visitor;\n+mod visitor;\n \n pub use rustc_middle::mir::interpret::*; // have all the `interpret` symbols in one place: here\n \n@@ -27,7 +27,7 @@ pub use self::memory::{AllocCheck, AllocRef, AllocRefMut, FnVal, Memory, MemoryK\n pub use self::operand::{ImmTy, Immediate, OpTy, Operand};\n pub use self::place::{MPlaceTy, MemPlace, MemPlaceMeta, Place, PlaceTy};\n pub use self::validity::{CtfeValidationMode, RefTracking};\n-pub use self::visitor::{MutValueVisitor, ValueVisitor};\n+pub use self::visitor::{MutValueVisitor, Value, ValueVisitor};\n \n crate use self::intrinsics::eval_nullary_intrinsic;\n use eval_context::{from_known_layout, mir_assign_valid_types};"}, {"sha": "f2d833b320249f735487bf915794e94a4d661bee", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc698c73e90c253b0d37be8127b3fb542d9e95c2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc698c73e90c253b0d37be8127b3fb542d9e95c2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=bc698c73e90c253b0d37be8127b3fb542d9e95c2", "patch": "@@ -98,7 +98,7 @@ impl<'tcx, Tag: Provenance> Immediate<Tag> {\n // as input for binary and cast operations.\n #[derive(Copy, Clone, Debug)]\n pub struct ImmTy<'tcx, Tag: Provenance = AllocId> {\n-    pub imm: Immediate<Tag>,\n+    imm: Immediate<Tag>,\n     pub layout: TyAndLayout<'tcx>,\n }\n \n@@ -248,7 +248,7 @@ impl<'tcx, Tag: Provenance> ImmTy<'tcx, Tag> {\n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Try reading an immediate in memory; this is interesting particularly for `ScalarPair`.\n     /// Returns `None` if the layout does not permit loading this as a value.\n-    pub(crate) fn try_read_immediate_from_mplace(\n+    fn try_read_immediate_from_mplace(\n         &self,\n         mplace: &MPlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, Option<ImmTy<'tcx, M::PointerTag>>> {"}, {"sha": "3bc6494f0088ef90ea84251881e1498915550970", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bc698c73e90c253b0d37be8127b3fb542d9e95c2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc698c73e90c253b0d37be8127b3fb542d9e95c2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=bc698c73e90c253b0d37be8127b3fb542d9e95c2", "patch": "@@ -82,7 +82,7 @@ rustc_data_structures::static_assert_size!(Place, 56);\n \n #[derive(Copy, Clone, Debug)]\n pub struct PlaceTy<'tcx, Tag: Provenance = AllocId> {\n-    pub(crate) place: Place<Tag>, // Keep this private; it helps enforce invariants.\n+    place: Place<Tag>, // Keep this private; it helps enforce invariants.\n     pub layout: TyAndLayout<'tcx>,\n }\n \n@@ -100,7 +100,7 @@ impl<'tcx, Tag: Provenance> std::ops::Deref for PlaceTy<'tcx, Tag> {\n /// A MemPlace with its layout. Constructing it is only possible in this module.\n #[derive(Copy, Clone, Hash, Eq, PartialEq, Debug)]\n pub struct MPlaceTy<'tcx, Tag: Provenance = AllocId> {\n-    pub(crate) mplace: MemPlace<Tag>,\n+    mplace: MemPlace<Tag>,\n     pub layout: TyAndLayout<'tcx>,\n }\n \n@@ -589,7 +589,6 @@ where\n     }\n \n     /// Projects into a place.\n-    #[instrument(skip(self), level = \"debug\")]\n     pub fn place_projection(\n         &mut self,\n         base: &PlaceTy<'tcx, M::PointerTag>,\n@@ -626,18 +625,15 @@ where\n         &mut self,\n         place: mir::Place<'tcx>,\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n-        debug!(\"projection: {:?}\", place.projection);\n         let mut place_ty = PlaceTy {\n             // This works even for dead/uninitialized locals; we check further when writing\n             place: Place::Local { frame: self.frame_idx(), local: place.local },\n             layout: self.layout_of_local(self.frame(), place.local, None)?,\n         };\n-        debug!(?place_ty);\n \n         for elem in place.projection.iter() {\n             place_ty = self.place_projection(&place_ty, &elem)?\n         }\n-        debug!(\"place after projections: {:?}\", place_ty);\n \n         trace!(\"{:?}\", self.dump_place(place_ty.place));\n         // Sanity-check the type we ended up with.\n@@ -693,7 +689,6 @@ where\n     /// Write an immediate to a place.\n     /// If you use this you are responsible for validating that things got copied at the\n     /// right type.\n-    #[instrument(skip(self), level = \"debug\")]\n     fn write_immediate_no_validate(\n         &mut self,\n         src: Immediate<M::PointerTag>,\n@@ -746,7 +741,6 @@ where\n     /// Write an immediate to memory.\n     /// If you use this you are responsible for validating that things got copied at the\n     /// right type.\n-    #[instrument(skip(self), level = \"debug\")]\n     fn write_immediate_to_mplace_no_validate(\n         &mut self,\n         value: Immediate<M::PointerTag>,\n@@ -769,7 +763,6 @@ where\n         // cover all the bytes!\n         match value {\n             Immediate::Scalar(scalar) => {\n-                debug!(?scalar);\n                 match dest.layout.abi {\n                     Abi::Scalar(_) => {} // fine\n                     _ => span_bug!(\n@@ -882,7 +875,6 @@ where\n         // Let us see if the layout is simple so we take a shortcut, avoid force_allocation.\n         let src = match self.try_read_immediate(src)? {\n             Ok(src_val) => {\n-                debug!(\"immediate from src is {:?}\", src_val);\n                 assert!(!src.layout.is_unsized(), \"cannot have unsized immediates\");\n                 // Yay, we got a value that we can write directly.\n                 // FIXME: Add a check to make sure that if `src` is indirect,\n@@ -978,7 +970,6 @@ where\n     ) -> InterpResult<'tcx, (MPlaceTy<'tcx, M::PointerTag>, Option<Size>)> {\n         let (mplace, size) = match place.place {\n             Place::Local { frame, local } => {\n-                debug!(\"LocalPlace\");\n                 match M::access_local_mut(self, frame, local)? {\n                     Ok(&mut local_val) => {\n                         // We need to make an allocation.\n@@ -992,12 +983,9 @@ where\n                         let (size, align) = self\n                             .size_and_align_of(&meta, &local_layout)?\n                             .expect(\"Cannot allocate for non-dyn-sized type\");\n-                        debug!(?size, ?align);\n                         let ptr = self.allocate_ptr(size, align, MemoryKind::Stack)?;\n-                        debug!(\"allocated ptr: {:?}\", ptr);\n                         let mplace = MemPlace { ptr: ptr.into(), align, meta };\n                         if let LocalValue::Live(Operand::Immediate(value)) = local_val {\n-                            debug!(\"LocalValue::Live: immediate value {:?}\", value);\n                             // Preserve old value.\n                             // We don't have to validate as we can assume the local\n                             // was already valid for its type."}, {"sha": "8cfc5ed0a95d06147ceab0adbbb5a6bf0670bad2", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc698c73e90c253b0d37be8127b3fb542d9e95c2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc698c73e90c253b0d37be8127b3fb542d9e95c2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=bc698c73e90c253b0d37be8127b3fb542d9e95c2", "patch": "@@ -433,7 +433,6 @@ impl<Tag: Provenance, Extra> Allocation<Tag, Extra> {\n                 return self.write_uninit(cx, range);\n             }\n         };\n-        debug!(?val);\n \n         // `to_bits_or_ptr_internal` is the right method because we just want to store this data\n         // as-is into memory.\n@@ -444,16 +443,13 @@ impl<Tag: Provenance, Extra> Allocation<Tag, Extra> {\n             }\n             Ok(data) => (data, None),\n         };\n-        debug!(?bytes, ?provenance);\n \n         let endian = cx.data_layout().endian;\n         let dst = self.get_bytes_mut(cx, range)?;\n-        debug!(?dst);\n         write_target_uint(endian, dst, bytes).unwrap();\n \n         // See if we have to also write a relocation.\n         if let Some(provenance) = provenance {\n-            debug!(\"insert relocation for {:?}\", provenance);\n             self.relocations.0.insert(range.start, provenance);\n         }\n "}, {"sha": "c71aea417eca0143279c565a813ed0da9203dabc", "filename": "compiler/rustc_middle/src/mir/interpret/pointer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc698c73e90c253b0d37be8127b3fb542d9e95c2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc698c73e90c253b0d37be8127b3fb542d9e95c2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs?ref=bc698c73e90c253b0d37be8127b3fb542d9e95c2", "patch": "@@ -158,7 +158,7 @@ impl Provenance for AllocId {\n #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, TyEncodable, TyDecodable, Hash)]\n #[derive(HashStable)]\n pub struct Pointer<Tag = AllocId> {\n-    pub offset: Size, // FIXME This should probably be private\n+    pub(super) offset: Size, // kept private to avoid accidental misinterpretation (meaning depends on `Tag` type)\n     pub provenance: Tag,\n }\n "}]}