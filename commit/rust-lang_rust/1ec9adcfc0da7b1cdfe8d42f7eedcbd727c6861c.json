{"sha": "1ec9adcfc0da7b1cdfe8d42f7eedcbd727c6861c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlYzlhZGNmYzBkYTdiMWNkZmU4ZDQyZjdlZWRjYmQ3MjdjNjg2MWM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-21T18:08:15Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-21T18:14:58Z"}, "message": "std: Tweak rt::at_exit behavior\n\nThere have been some recent panics on the bots and this commit is an attempt to\nappease them. Previously it was considered invalid to run `rt::at_exit` after\nthe handlers had already started running. Due to the multithreaded nature of\napplications, however, it is not always possible to guarantee this. For example\n[this program][ex] will show off the abort.\n\n[ex]: https://gist.github.com/alexcrichton/56300b87af6fa554e52d\n\nThe semantics of the `rt::at_exit` function have been modified as such:\n\n* It is now legal to call `rt::at_exit` at any time. The return value now\n  indicates whether the closure was successfully registered or not. Callers must\n  now decide what to do with this information.\n* The `rt::at_exit` handlers will now be run for a fixed number of iterations.\n  Common cases (such as the example shown) may end up registering a new handler\n  while others are running perhaps once or twice, so this common condition is\n  covered by re-running the handlers a fixed number of times, after which new\n  registrations are forbidden.\n\nSome usage of `rt::at_exit` was updated to handle these new semantics, but\ndeprecated or unstable libraries calling `rt::at_exit` were not updated.", "tree": {"sha": "76ff033c4dce8b2327b28d8b6fc5a2555f05c524", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76ff033c4dce8b2327b28d8b6fc5a2555f05c524"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ec9adcfc0da7b1cdfe8d42f7eedcbd727c6861c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ec9adcfc0da7b1cdfe8d42f7eedcbd727c6861c", "html_url": "https://github.com/rust-lang/rust/commit/1ec9adcfc0da7b1cdfe8d42f7eedcbd727c6861c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ec9adcfc0da7b1cdfe8d42f7eedcbd727c6861c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ecf8c64e1b1b60f228f0c472c0b0dab4a5b5aa61", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecf8c64e1b1b60f228f0c472c0b0dab4a5b5aa61", "html_url": "https://github.com/rust-lang/rust/commit/ecf8c64e1b1b60f228f0c472c0b0dab4a5b5aa61"}], "stats": {"total": 111, "additions": 65, "deletions": 46}, "files": [{"sha": "df94a6ac80fbed300a0235cc12019f4e6d627852", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ec9adcfc0da7b1cdfe8d42f7eedcbd727c6861c/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec9adcfc0da7b1cdfe8d42f7eedcbd727c6861c/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=1ec9adcfc0da7b1cdfe8d42f7eedcbd727c6861c", "patch": "@@ -443,7 +443,7 @@ fn init() {\n         DIRECTIVES = boxed::into_raw(box directives);\n \n         // Schedule the cleanup for the globals for when the runtime exits.\n-        rt::at_exit(move || {\n+        let _ = rt::at_exit(move || {\n             let _g = LOCK.lock();\n             assert!(!DIRECTIVES.is_null());\n             let _directives = Box::from_raw(DIRECTIVES);"}, {"sha": "df280dab37d467221afff885df9cdd78004e01ba", "filename": "src/libstd/io/lazy.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1ec9adcfc0da7b1cdfe8d42f7eedcbd727c6861c/src%2Flibstd%2Fio%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec9adcfc0da7b1cdfe8d42f7eedcbd727c6861c/src%2Flibstd%2Fio%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Flazy.rs?ref=1ec9adcfc0da7b1cdfe8d42f7eedcbd727c6861c", "patch": "@@ -35,25 +35,33 @@ impl<T: Send + Sync + 'static> Lazy<T> {\n     pub fn get(&'static self) -> Option<Arc<T>> {\n         let _g = self.lock.lock();\n         unsafe {\n-            let mut ptr = *self.ptr.get();\n+            let ptr = *self.ptr.get();\n             if ptr.is_null() {\n-                ptr = boxed::into_raw(self.init());\n-                *self.ptr.get() = ptr;\n+                Some(self.init())\n             } else if ptr as usize == 1 {\n-                return None\n+                None\n+            } else {\n+                Some((*ptr).clone())\n             }\n-            Some((*ptr).clone())\n         }\n     }\n \n-    fn init(&'static self) -> Box<Arc<T>> {\n-        rt::at_exit(move || unsafe {\n+    unsafe fn init(&'static self) -> Arc<T> {\n+        // If we successfully register an at exit handler, then we cache the\n+        // `Arc` allocation in our own internal box (it will get deallocated by\n+        // the at exit handler). Otherwise we just return the freshly allocated\n+        // `Arc`.\n+        let registered = rt::at_exit(move || {\n             let g = self.lock.lock();\n             let ptr = *self.ptr.get();\n             *self.ptr.get() = 1 as *mut _;\n             drop(g);\n             drop(Box::from_raw(ptr))\n         });\n-        Box::new((self.init)())\n+        let ret = (self.init)();\n+        if registered.is_ok() {\n+            *self.ptr.get() = boxed::into_raw(Box::new(ret.clone()));\n+        }\n+        return ret\n     }\n }"}, {"sha": "a48758366f347a5331c4cce453c0ec0667fce080", "filename": "src/libstd/old_io/stdio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ec9adcfc0da7b1cdfe8d42f7eedcbd727c6861c/src%2Flibstd%2Fold_io%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec9adcfc0da7b1cdfe8d42f7eedcbd727c6861c/src%2Flibstd%2Fold_io%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fstdio.rs?ref=1ec9adcfc0da7b1cdfe8d42f7eedcbd727c6861c", "patch": "@@ -238,7 +238,7 @@ pub fn stdin() -> StdinReader {\n             STDIN = boxed::into_raw(box stdin);\n \n             // Make sure to free it at exit\n-            rt::at_exit(|| {\n+            let _ = rt::at_exit(|| {\n                 Box::from_raw(STDIN);\n                 STDIN = ptr::null_mut();\n             });"}, {"sha": "9079c0aaffb7d3669e6bd57ecce4dde8d7b8c6c2", "filename": "src/libstd/rt/at_exit_imp.rs", "status": "modified", "additions": 36, "deletions": 23, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/1ec9adcfc0da7b1cdfe8d42f7eedcbd727c6861c/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec9adcfc0da7b1cdfe8d42f7eedcbd727c6861c/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fat_exit_imp.rs?ref=1ec9adcfc0da7b1cdfe8d42f7eedcbd727c6861c", "patch": "@@ -12,6 +12,10 @@\n //!\n //! Documentation can be found on the `rt::at_exit` function.\n \n+// FIXME: switch this to use atexit. Currently this\n+// segfaults (the queue's memory is mysteriously gone), so\n+// instead the cleanup is tied to the `std::rt` entry point.\n+\n use boxed;\n use boxed::Box;\n use vec::Vec;\n@@ -27,47 +31,56 @@ type Queue = Vec<Thunk<'static>>;\n static LOCK: Mutex = MUTEX_INIT;\n static mut QUEUE: *mut Queue = 0 as *mut Queue;\n \n-unsafe fn init() {\n+// The maximum number of times the cleanup routines will be run. While running\n+// the at_exit closures new ones may be registered, and this count is the number\n+// of times the new closures will be allowed to register successfully. After\n+// this number of iterations all new registrations will return `false`.\n+const ITERS: usize = 10;\n+\n+unsafe fn init() -> bool {\n     if QUEUE.is_null() {\n         let state: Box<Queue> = box Vec::new();\n         QUEUE = boxed::into_raw(state);\n-    } else {\n+    } else if QUEUE as usize == 1 {\n         // can't re-init after a cleanup\n-        rtassert!(QUEUE as uint != 1);\n+        return false\n     }\n \n-    // FIXME: switch this to use atexit as below. Currently this\n-    // segfaults (the queue's memory is mysteriously gone), so\n-    // instead the cleanup is tied to the `std::rt` entry point.\n-    //\n-    // ::libc::atexit(cleanup);\n+    return true\n }\n \n pub fn cleanup() {\n-    unsafe {\n-        LOCK.lock();\n-        let queue = QUEUE;\n-        QUEUE = 1 as *mut _;\n-        LOCK.unlock();\n+    for i in 0..ITERS {\n+        unsafe {\n+            LOCK.lock();\n+            let queue = QUEUE;\n+            QUEUE = if i == ITERS - 1 {1} else {0} as *mut _;\n+            LOCK.unlock();\n \n-        // make sure we're not recursively cleaning up\n-        rtassert!(queue as uint != 1);\n+            // make sure we're not recursively cleaning up\n+            rtassert!(queue as usize != 1);\n \n-        // If we never called init, not need to cleanup!\n-        if queue as uint != 0 {\n-            let queue: Box<Queue> = Box::from_raw(queue);\n-            for to_run in *queue {\n-                to_run.invoke(());\n+            // If we never called init, not need to cleanup!\n+            if queue as usize != 0 {\n+                let queue: Box<Queue> = Box::from_raw(queue);\n+                for to_run in *queue {\n+                    to_run.invoke(());\n+                }\n             }\n         }\n     }\n }\n \n-pub fn push(f: Thunk<'static>) {\n+pub fn push(f: Thunk<'static>) -> bool {\n+    let mut ret = true;\n     unsafe {\n         LOCK.lock();\n-        init();\n-        (*QUEUE).push(f);\n+        if init() {\n+            (*QUEUE).push(f);\n+        } else {\n+            ret = false;\n+        }\n         LOCK.unlock();\n     }\n+    return ret\n }"}, {"sha": "43aa4155629ecd3f65d77f93ec4a99043b283c96", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1ec9adcfc0da7b1cdfe8d42f7eedcbd727c6861c/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec9adcfc0da7b1cdfe8d42f7eedcbd727c6861c/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=1ec9adcfc0da7b1cdfe8d42f7eedcbd727c6861c", "patch": "@@ -17,14 +17,9 @@\n //! time being.\n \n #![unstable(feature = \"std_misc\")]\n-\n-// FIXME: this should not be here.\n #![allow(missing_docs)]\n \n-#![allow(dead_code)]\n-\n-use marker::Send;\n-use ops::FnOnce;\n+use prelude::v1::*;\n use sys;\n use thunk::Thunk;\n use usize;\n@@ -149,13 +144,16 @@ fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n \n /// Enqueues a procedure to run when the main thread exits.\n ///\n-/// It is forbidden for procedures to register more `at_exit` handlers when they\n-/// are running, and doing so will lead to a process abort.\n+/// Currently these closures are only run once the main *Rust* thread exits.\n+/// Once the `at_exit` handlers begin running, more may be enqueued, but not\n+/// infinitely so. Eventually a handler registration will be forced to fail.\n ///\n-/// Note that other threads may still be running when `at_exit` routines start\n-/// running.\n-pub fn at_exit<F: FnOnce() + Send + 'static>(f: F) {\n-    at_exit_imp::push(Thunk::new(f));\n+/// Returns `Ok` if the handler was successfully registered, meaning that the\n+/// closure will be run once the main thread exits. Returns `Err` to indicate\n+/// that the closure could not be registered, meaning that it is not scheduled\n+/// to be rune.\n+pub fn at_exit<F: FnOnce() + Send + 'static>(f: F) -> Result<(), ()> {\n+    if at_exit_imp::push(Thunk::new(f)) {Ok(())} else {Err(())}\n }\n \n /// One-time runtime cleanup."}, {"sha": "53f18a57325556264656f70d514fd8aeb2811bb0", "filename": "src/libstd/sys/common/helper_thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ec9adcfc0da7b1cdfe8d42f7eedcbd727c6861c/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec9adcfc0da7b1cdfe8d42f7eedcbd727c6861c/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs?ref=1ec9adcfc0da7b1cdfe8d42f7eedcbd727c6861c", "patch": "@@ -112,7 +112,7 @@ impl<M: Send> Helper<M> {\n                     self.cond.notify_one()\n                 });\n \n-                rt::at_exit(move || { self.shutdown() });\n+                let _ = rt::at_exit(move || { self.shutdown() });\n                 *self.initialized.get() = true;\n             } else if *self.chan.get() as uint == 1 {\n                 panic!(\"cannot continue usage after shutdown\");"}]}