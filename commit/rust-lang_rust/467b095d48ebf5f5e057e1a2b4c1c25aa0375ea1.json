{"sha": "467b095d48ebf5f5e057e1a2b4c1c25aa0375ea1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2N2IwOTVkNDhlYmY1ZjVlMDU3ZTFhMmI0YzFjMjVhYTAzNzVlYTE=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-11T02:50:42Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-24T03:43:29Z"}, "message": "chains: share code between block and visual formatters", "tree": {"sha": "d7e97c2551ebae74836479787f08c55f2e451579", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7e97c2551ebae74836479787f08c55f2e451579"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/467b095d48ebf5f5e057e1a2b4c1c25aa0375ea1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/467b095d48ebf5f5e057e1a2b4c1c25aa0375ea1", "html_url": "https://github.com/rust-lang/rust/commit/467b095d48ebf5f5e057e1a2b4c1c25aa0375ea1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/467b095d48ebf5f5e057e1a2b4c1c25aa0375ea1/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f55cadb65aacded4593312e56709fff3388e5f13", "url": "https://api.github.com/repos/rust-lang/rust/commits/f55cadb65aacded4593312e56709fff3388e5f13", "html_url": "https://github.com/rust-lang/rust/commit/f55cadb65aacded4593312e56709fff3388e5f13"}], "stats": {"total": 338, "additions": 154, "deletions": 184}, "files": [{"sha": "13436106ccb3510aad1678a431867f4616c0c977", "filename": "src/chains.rs", "status": "modified", "additions": 154, "deletions": 184, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/467b095d48ebf5f5e057e1a2b4c1c25aa0375ea1/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/467b095d48ebf5f5e057e1a2b4c1c25aa0375ea1/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=467b095d48ebf5f5e057e1a2b4c1c25aa0375ea1", "patch": "@@ -75,6 +75,7 @@ use utils::{first_line_width, last_line_extendable, last_line_width, mk_sp, wrap\n \n use std::borrow::Cow;\n use std::cmp::min;\n+use std::iter;\n \n use syntax::codemap::Span;\n use syntax::{ast, ptr};\n@@ -88,10 +89,7 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         return chain.parent.rewrite(context, shape);\n     }\n \n-    match context.config.indent_style() {\n-        IndentStyle::Block => rewrite_chain_block(chain, context, shape),\n-        IndentStyle::Visual => rewrite_chain_visual(chain, context, shape),\n-    }\n+    chain.rewrite(context, shape)\n }\n \n // An expression plus trailing `?`s to be formatted together.\n@@ -262,26 +260,36 @@ impl Chain {\n     }\n }\n \n-// TODO comments\n-struct ChainFormatterBlock<'a> {\n-    children: &'a[ChainItem],\n-    rewrites: Vec<String>,\n-    root_ends_with_block: bool,\n-    is_block_like: Vec<bool>,\n-    fits_single_line: bool,\n-}\n+impl Rewrite for Chain {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        debug!(\"rewrite chain {:?} {:?}\", self, shape);\n \n-impl <'a> ChainFormatterBlock<'a> {\n-    fn new(chain: &'a Chain) -> ChainFormatterBlock<'a> {\n-        ChainFormatterBlock {\n-            children: &chain.children,\n-            root_ends_with_block: false,\n-            rewrites: Vec::with_capacity(chain.children.len() + 1),\n-            is_block_like: Vec::with_capacity(chain.children.len() + 1),\n-            fits_single_line: false,\n+        let mut formatter = match context.config.indent_style() {\n+            IndentStyle::Block => Box::new(ChainFormatterBlock::new(self)) as Box<ChainFormatter>,\n+            IndentStyle::Visual => Box::new(ChainFormatterVisual::new(self)) as Box<ChainFormatter>,\n+        };\n+\n+        formatter.format_root(&self.parent, context, shape)?;\n+        if let result @ Some(_) = formatter.pure_root() {\n+            return result;\n         }\n+\n+        // Decide how to layout the rest of the chain.\n+        let child_shape = formatter.child_shape(context, shape);\n+\n+        formatter.format_children(context, child_shape)?;\n+        formatter.format_last_child(context, shape, child_shape)?;\n+\n+        let result = formatter.join_rewrites(context, child_shape)?;\n+        wrap_str(result, context.config.max_width(), shape)\n     }\n+}\n \n+// There are a few types for formatting chains. This is because there is a lot\n+// in common between formatting with block vs visual indent, but they are\n+// different enough that branching on the indent all over the place gets ugly.\n+// Anything that can format a chain is a ChainFormatter.\n+trait ChainFormatter {\n     // Parent is the first item in the chain, e.g., `foo` in `foo.bar.baz()`.\n     // Root is the parent plus any other chain items placed on the first line to\n     // avoid an orphan. E.g.,\n@@ -290,47 +298,43 @@ impl <'a> ChainFormatterBlock<'a> {\n     //     .baz()\n     // ```\n     // If `bar` were not part of the root, then baz would be orphaned and 'float'.\n-    fn format_root(&mut self, parent: &ChainItem, context: &RewriteContext, shape: Shape) -> Option<()> {\n-        let mut root_rewrite: String = parent.rewrite(context, shape)?;\n-\n-        self.root_ends_with_block = is_block_expr(context, &parent.expr, &root_rewrite);\n-        let tab_width = context.config.tab_spaces().saturating_sub(shape.offset);\n-\n-        while root_rewrite.len() <= tab_width && !root_rewrite.contains('\\n') {\n-            let item = &self.children[0];\n-            let shape = shape.offset_left(root_rewrite.len())?;\n-            match &item.rewrite_postfix(context, shape) {\n-                Some(rewrite) => root_rewrite.push_str(rewrite),\n-                None => break,\n-            }\n+    fn format_root(&mut self, parent: &ChainItem, context: &RewriteContext, shape: Shape) -> Option<()>;\n+    fn child_shape(&self, context: &RewriteContext, shape: Shape) -> Shape;\n+    fn format_children(&mut self, context: &RewriteContext, child_shape: Shape) -> Option<()>;\n+    fn format_last_child(&mut self, context: &RewriteContext, shape: Shape, child_shape: Shape) -> Option<()>;\n+    fn join_rewrites(&self, context: &RewriteContext, child_shape: Shape) -> Option<String>;\n+    // Returns `Some` if the chain is only a root, None otherwise.\n+    fn pure_root(&mut self) -> Option<String>;\n+}\n \n-            self.root_ends_with_block = is_block_expr(context, &item.expr, &root_rewrite);\n+// Data and behaviour that is shared by both chain formatters. The concrete\n+// formatters can delegate much behaviour to `ChainFormatterShared`.\n+struct ChainFormatterShared<'a> {\n+    // The current working set of child items.\n+    children: &'a[ChainItem],\n+    // The current rewrites of items (includes trailing `?`s, but not any way to\n+    // connect the rewrites together).\n+    rewrites: Vec<String>,\n+    // Whether the chain can fit on one line.\n+    fits_single_line: bool,\n+}\n \n-            self.children = &self.children[1..];\n-            if self.children.is_empty() {\n-                break;\n-            }\n+impl <'a> ChainFormatterShared<'a> {\n+    fn new(chain: &'a Chain) -> ChainFormatterShared<'a> {\n+        ChainFormatterShared {\n+            children: &chain.children,\n+            rewrites: Vec::with_capacity(chain.children.len() + 1),\n+            fits_single_line: false,\n         }\n-        self.rewrites.push(root_rewrite);\n-        Some(())\n     }\n \n-    fn child_shape(&self, context: &RewriteContext, shape: Shape) -> Shape {\n-        if self.root_ends_with_block {\n-            shape\n+    fn pure_root(&mut self) -> Option<String> {\n+        if self.children.is_empty() {\n+            assert_eq!(self.rewrites.len(), 1);\n+            Some(self.rewrites.pop().unwrap())\n         } else {\n-            shape.block_indent(context.config.tab_spaces())\n-        }.with_max_width(context.config)\n-    }\n-\n-    fn format_children(&mut self, context: &RewriteContext, child_shape: Shape) -> Option<()> {\n-        self.is_block_like.push(self.root_ends_with_block);\n-        for item in &self.children[..self.children.len() - 1] {\n-            let rewrite = item.rewrite_postfix(context, child_shape)?;\n-            self.is_block_like.push(is_block_expr(context, &item.expr, &rewrite));\n-            self.rewrites.push(rewrite);\n+            None\n         }\n-        Some(())\n     }\n \n     // Rewrite the last child. The last child of a chain requires special treatment. We need to\n@@ -365,9 +369,10 @@ impl <'a> ChainFormatterBlock<'a> {\n     //     result\n     // })\n     // ```\n-    fn format_last_child(&mut self, context: &RewriteContext, shape: Shape, child_shape: Shape) -> Option<()> {\n+    fn format_last_child(&mut self, may_extend: bool, context: &RewriteContext, shape: Shape, child_shape: Shape) -> Option<()> {\n         let last = &self.children[self.children.len() - 1];\n-        let extendable = last_line_extendable(&self.rewrites[self.rewrites.len() - 1]);\n+        let extendable = may_extend && last_line_extendable(&self.rewrites[self.rewrites.len() - 1]);\n+\n         // Total of all items excluding the last.\n         let almost_total = if extendable {\n             last_line_width(&self.rewrites[self.rewrites.len() - 1])\n@@ -431,8 +436,7 @@ impl <'a> ChainFormatterBlock<'a> {\n         Some(())\n     }\n \n-\n-    fn join_rewrites(&self, context: &RewriteContext, child_shape: Shape) -> Option<String> {\n+    fn join_rewrites(&self, context: &RewriteContext, child_shape: Shape, block_like_iter: impl Iterator<Item=bool>) -> Option<String> {\n         let connector = if self.fits_single_line {\n             // Yay, we can put everything on one line.\n             Cow::from(\"\")\n@@ -447,8 +451,8 @@ impl <'a> ChainFormatterBlock<'a> {\n         let mut rewrite_iter = self.rewrites.iter();\n         let mut result = rewrite_iter.next().unwrap().clone();\n \n-        for (rewrite, prev_is_block_like) in rewrite_iter.zip(self.is_block_like.iter()) {\n-            if rewrite != \"?\" && !prev_is_block_like {\n+        for (rewrite, prev_is_block_like) in rewrite_iter.zip(block_like_iter) {\n+            if !prev_is_block_like {\n                 result.push_str(&connector);\n             }\n             result.push_str(&rewrite);\n@@ -458,43 +462,102 @@ impl <'a> ChainFormatterBlock<'a> {\n     }\n }\n \n-fn rewrite_chain_block(chain: Chain, context: &RewriteContext, shape: Shape) -> Option<String> {\n-    debug!(\"rewrite_chain_block {:?} {:?}\", chain, shape);\n+// Formats a chain using block indent.\n+struct ChainFormatterBlock<'a> {\n+    shared: ChainFormatterShared<'a>,\n+    // For each rewrite, whether the corresponding item is block-like.\n+    is_block_like: Vec<bool>,\n+}\n+\n+impl <'a> ChainFormatterBlock<'a> {\n+    fn new(chain: &'a Chain) -> ChainFormatterBlock<'a> {\n+        ChainFormatterBlock {\n+            shared: ChainFormatterShared::new(chain),\n+            is_block_like: Vec::with_capacity(chain.children.len() + 1),\n+        }\n+    }\n+}\n \n-    let mut formatter = ChainFormatterBlock::new(&chain);\n+impl <'a> ChainFormatter for ChainFormatterBlock<'a> {\n+    fn format_root(&mut self, parent: &ChainItem, context: &RewriteContext, shape: Shape) -> Option<()> {\n+        let mut root_rewrite: String = parent.rewrite(context, shape)?;\n \n-    formatter.format_root(&chain.parent, context, shape)?;\n-    if formatter.children.is_empty() {\n-        assert_eq!(formatter.rewrites.len(), 1);\n-        return Some(formatter.rewrites.pop().unwrap());\n+        let mut root_ends_with_block = is_block_expr(context, &parent.expr, &root_rewrite);\n+        let tab_width = context.config.tab_spaces().saturating_sub(shape.offset);\n+\n+        while root_rewrite.len() <= tab_width && !root_rewrite.contains('\\n') {\n+            let item = &self.shared.children[0];\n+            let shape = shape.offset_left(root_rewrite.len())?;\n+            match &item.rewrite_postfix(context, shape) {\n+                Some(rewrite) => root_rewrite.push_str(rewrite),\n+                None => break,\n+            }\n+\n+            root_ends_with_block = is_block_expr(context, &item.expr, &root_rewrite);\n+\n+            self.shared.children = &self.shared.children[1..];\n+            if self.shared.children.is_empty() {\n+                break;\n+            }\n+        }\n+        self.is_block_like.push(root_ends_with_block);\n+        self.shared.rewrites.push(root_rewrite);\n+        Some(())\n+    }\n+\n+    fn child_shape(&self, context: &RewriteContext, shape: Shape) -> Shape {\n+        if self.is_block_like[0] {\n+            shape\n+        } else {\n+            shape.block_indent(context.config.tab_spaces())\n+        }.with_max_width(context.config)\n+    }\n+\n+    fn format_children(&mut self, context: &RewriteContext, child_shape: Shape) -> Option<()> {\n+        for item in &self.shared.children[..self.shared.children.len() - 1] {\n+            let rewrite = item.rewrite_postfix(context, child_shape)?;\n+            self.is_block_like.push(is_block_expr(context, &item.expr, &rewrite));\n+            self.shared.rewrites.push(rewrite);\n+        }\n+        Some(())\n     }\n \n-    // Decide how to layout the rest of the chain.\n-    let child_shape = formatter.child_shape(context, shape);\n-    formatter.format_children(context, child_shape)?;\n+    fn format_last_child(&mut self, context: &RewriteContext, shape: Shape, child_shape: Shape) -> Option<()> {\n+        self.shared.format_last_child(true, context, shape, child_shape)\n+    }\n \n-    formatter.format_last_child(context, shape, child_shape)?;\n+    fn join_rewrites(&self, context: &RewriteContext, child_shape: Shape) -> Option<String> {\n+        self.shared.join_rewrites(context, child_shape, self.is_block_like.iter().cloned())\n+    }\n \n-    let result = formatter.join_rewrites(context, child_shape)?;\n-    Some(result)\n+    fn pure_root(&mut self) -> Option<String> {\n+        self.shared.pure_root()\n+    }\n }\n \n+// Format a chain using visual indent.\n struct ChainFormatterVisual<'a> {\n-    children: &'a[ChainItem],\n-    rewrites: Vec<String>,\n-    fits_single_line: bool,\n+    shared: ChainFormatterShared<'a>,\n }\n \n impl<'a> ChainFormatterVisual<'a> {\n     fn new(chain: &'a Chain) -> ChainFormatterVisual<'a> {\n         ChainFormatterVisual {\n-            children: &chain.children,\n-            rewrites: Vec::with_capacity(chain.children.len() + 1),\n-            fits_single_line: false,\n+            shared: ChainFormatterShared::new(chain),\n         }\n     }\n+}\n \n+impl <'a> ChainFormatter for ChainFormatterVisual<'a> {\n     fn format_root(&mut self, parent: &ChainItem, context: &RewriteContext, shape: Shape) -> Option<()> {\n+        // Determines if we can continue formatting a given expression on the same line.\n+        fn is_continuable(expr: &ast::Expr) -> bool {\n+            match expr.node {\n+                ast::ExprKind::Path(..) => true,\n+                _ => false,\n+            }\n+        }\n+\n         // Parent is the first item in the chain, e.g., `foo` in `foo.bar.baz()`.\n         let parent_shape = if is_block_expr(context, &parent.expr, \"\\n\") {\n             shape.visual_indent(0)\n@@ -503,136 +566,43 @@ impl<'a> ChainFormatterVisual<'a> {\n         };\n         let mut root_rewrite = parent.rewrite(context, parent_shape)?;\n \n-        if !root_rewrite.contains('\\n') && Self::is_continuable(&parent.expr) {\n-            let item = &self.children[0];\n+        if !root_rewrite.contains('\\n') && is_continuable(&parent.expr) {\n+            let item = &self.shared.children[0];\n             let overhead = last_line_width(&root_rewrite);\n             let shape = parent_shape.offset_left(overhead)?;\n             let rewrite = item.rewrite_postfix(context, shape)?;\n             root_rewrite.push_str(&rewrite);\n \n-            self.children = &self.children[1..];\n+            self.shared.children = &self.shared.children[1..];\n         }\n \n-        self.rewrites.push(root_rewrite);\n+        self.shared.rewrites.push(root_rewrite);\n         Some(())\n     }\n \n-    // Determines if we can continue formatting a given expression on the same line.\n-    fn is_continuable(expr: &ast::Expr) -> bool {\n-        match expr.node {\n-            ast::ExprKind::Path(..) => true,\n-            _ => false,\n-        }\n+    fn child_shape(&self, context: &RewriteContext, shape: Shape) -> Shape {\n+        shape.visual_indent(0).with_max_width(context.config)\n     }\n \n     fn format_children(&mut self, context: &RewriteContext, child_shape: Shape) -> Option<()> {\n-        for item in &self.children[..self.children.len() - 1] {\n+        for item in &self.shared.children[..self.shared.children.len() - 1] {\n             let rewrite = item.rewrite_postfix(context, child_shape)?;\n-            self.rewrites.push(rewrite);\n+            self.shared.rewrites.push(rewrite);\n         }\n         Some(())\n     }\n \n     fn format_last_child(&mut self, context: &RewriteContext, shape: Shape, child_shape: Shape) -> Option<()> {\n-        let last = &self.children[self.children.len() - 1];\n-\n-        // Total of all items excluding the last.\n-        let almost_total = self.rewrites.iter().fold(0, |a, b| a + b.len()) + last.tries;\n-        let one_line_budget = if self.rewrites.len() == 1 {\n-            shape.width\n-        } else {\n-            min(shape.width, context.config.width_heuristics().chain_width)\n-        };\n-        let all_in_one_line = self.rewrites.iter().all(|s| !s.contains('\\n'))\n-            && almost_total < one_line_budget;\n-        let last_shape = child_shape.sub_width(shape.rhs_overhead(context.config) + last.tries)?;\n-\n-\n-        let mut last_subexpr_str = None;\n-        if all_in_one_line {\n-            // First we try to 'overflow' the last child and see if it looks better than using\n-            // vertical layout.\n-            if let Some(shape) = shape.offset_left(almost_total) {\n-                if let Some(rw) = last.rewrite_postfix(context, shape) {\n-                    // We allow overflowing here only if both of the following conditions match:\n-                    // 1. The entire chain fits in a single line except the last child.\n-                    // 2. `last_child_str.lines().count() >= 5`.\n-                    let line_count = rw.lines().count();\n-                    let could_fit_single_line = almost_total + first_line_width(&rw) <= one_line_budget;\n-                    if could_fit_single_line && line_count >= 5 {\n-                        last_subexpr_str = Some(rw);\n-                        self.fits_single_line = all_in_one_line;\n-                    } else {\n-                        // We could not know whether overflowing is better than using vertical layout,\n-                        // just by looking at the overflowed rewrite. Now we rewrite the last child\n-                        // on its own line, and compare two rewrites to choose which is better.\n-                        match last.rewrite_postfix(context, last_shape) {\n-                            Some(ref new_rw) if !could_fit_single_line => {\n-                                last_subexpr_str = Some(new_rw.clone());\n-                            }\n-                            Some(ref new_rw) if new_rw.lines().count() >= line_count => {\n-                                last_subexpr_str = Some(rw);\n-                                self.fits_single_line = could_fit_single_line && all_in_one_line;\n-                            }\n-                            new_rw @ Some(..) => {\n-                                last_subexpr_str = new_rw;\n-                            }\n-                            _ => {\n-                                last_subexpr_str = Some(rw);\n-                                self.fits_single_line = could_fit_single_line && all_in_one_line;\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        } \n-\n-        let last_subexpr_str = last_subexpr_str.or_else(|| last.rewrite_postfix(context, last_shape));\n-        self.rewrites.push(last_subexpr_str?);\n-        Some(())\n+        self.shared.format_last_child(false, context, shape, child_shape)\n     }\n \n     fn join_rewrites(&self, context: &RewriteContext, child_shape: Shape) -> Option<String> {\n-        let connector = if self.fits_single_line {\n-            // Yay, we can put everything on one line.\n-            Cow::from(\"\")\n-        } else {\n-            // Use new lines.\n-            if *context.force_one_line_chain.borrow() {\n-                return None;\n-            }\n-            child_shape.indent.to_string_with_newline(context.config)\n-        };\n-\n-        let mut rewrite_iter = self.rewrites.iter();\n-        let mut result = rewrite_iter.next().unwrap().clone();\n-\n-        for rewrite in rewrite_iter {\n-            result.push_str(&connector);\n-            result.push_str(&rewrite);\n-        }\n-\n-        Some(result)\n+        self.shared.join_rewrites(context, child_shape, iter::repeat(false))\n     }\n-}\n \n-fn rewrite_chain_visual(chain: Chain, context: &RewriteContext, shape: Shape) -> Option<String> {\n-    let mut formatter = ChainFormatterVisual::new(&chain);\n-\n-    formatter.format_root(&chain.parent, context, shape)?;\n-\n-    if formatter.children.is_empty() {\n-        assert_eq!(formatter.rewrites.len(), 1);\n-        return Some(formatter.rewrites.pop().unwrap());\n+    fn pure_root(&mut self) -> Option<String> {\n+        self.shared.pure_root()\n     }\n-\n-    let child_shape = shape.visual_indent(0).with_max_width(context.config);\n-\n-    formatter.format_children(context, child_shape)?;\n-    formatter.format_last_child(context, shape, child_shape)?;\n-\n-    let result = formatter.join_rewrites(context, child_shape)?;\n-    wrap_str(result, context.config.max_width(), shape)\n }\n \n // States whether an expression's last line exclusively consists of closing"}]}