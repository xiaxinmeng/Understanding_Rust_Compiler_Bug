{"sha": "88202c5b838ea9f328d37f19c022eba5040e234f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4MjAyYzViODM4ZWE5ZjMyOGQzN2YxOWMwMjJlYmE1MDQwZTIzNGY=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-19T23:25:00Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-21T03:04:41Z"}, "message": "Replace bcx.ccx() with bcx.ccx", "tree": {"sha": "4f506bcf033d64c7e01ee44f66b8c8796d5362fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f506bcf033d64c7e01ee44f66b8c8796d5362fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88202c5b838ea9f328d37f19c022eba5040e234f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88202c5b838ea9f328d37f19c022eba5040e234f", "html_url": "https://github.com/rust-lang/rust/commit/88202c5b838ea9f328d37f19c022eba5040e234f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88202c5b838ea9f328d37f19c022eba5040e234f/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f103ea4f8969718df071964a9489d6c70354f99b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f103ea4f8969718df071964a9489d6c70354f99b", "html_url": "https://github.com/rust-lang/rust/commit/f103ea4f8969718df071964a9489d6c70354f99b"}], "stats": {"total": 477, "additions": 238, "deletions": 239}, "files": [{"sha": "8b4343af1990f53f0f8ee6901f08104d78343057", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88202c5b838ea9f328d37f19c022eba5040e234f/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88202c5b838ea9f328d37f19c022eba5040e234f/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=88202c5b838ea9f328d37f19c022eba5040e234f", "patch": "@@ -235,7 +235,7 @@ impl ArgType {\n         if self.is_ignore() {\n             return;\n         }\n-        let ccx = bcx.ccx();\n+        let ccx = bcx.ccx;\n         if self.is_indirect() {\n             let llsz = llsize_of(ccx, self.ty);\n             let llalign = llalign_of_min(ccx, self.ty);"}, {"sha": "31a5538a3c1179f3126eb279fffbc59ae9427d37", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/88202c5b838ea9f328d37f19c022eba5040e234f/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88202c5b838ea9f328d37f19c022eba5040e234f/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=88202c5b838ea9f328d37f19c022eba5040e234f", "patch": "@@ -308,7 +308,7 @@ pub fn trans_switch<'a, 'tcx>(\n     scrutinee: ValueRef,\n     range_assert: bool\n ) -> (BranchKind, Option<ValueRef>) {\n-    let l = bcx.ccx().layout_of(t);\n+    let l = bcx.ccx.layout_of(t);\n     match *l {\n         layout::CEnum { .. } | layout::General { .. } |\n         layout::RawNullablePointer { .. } | layout::StructWrappedNullablePointer { .. } => {\n@@ -343,7 +343,7 @@ pub fn trans_get_discr<'a, 'tcx>(\n     };\n \n     debug!(\"trans_get_discr t: {:?}\", t);\n-    let l = bcx.ccx().layout_of(t);\n+    let l = bcx.ccx.layout_of(t);\n \n     let val = match *l {\n         layout::CEnum { discr, min, max, .. } => {\n@@ -354,11 +354,11 @@ pub fn trans_get_discr<'a, 'tcx>(\n             load_discr(bcx, discr, ptr, 0, def.variants.len() as u64 - 1,\n                        range_assert)\n         }\n-        layout::Univariant { .. } | layout::UntaggedUnion { .. } => C_u8(bcx.ccx(), 0),\n+        layout::Univariant { .. } | layout::UntaggedUnion { .. } => C_u8(bcx.ccx, 0),\n         layout::RawNullablePointer { nndiscr, .. } => {\n             let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n-            let llptrty = type_of::sizing_type_of(bcx.ccx(),\n-                monomorphize::field_ty(bcx.ccx().tcx(), substs,\n+            let llptrty = type_of::sizing_type_of(bcx.ccx,\n+                monomorphize::field_ty(bcx.ccx.tcx(), substs,\n                 &def.variants[nndiscr as usize].fields[0]));\n             bcx.icmp(cmp, bcx.load(scrutinee), C_null(llptrty))\n         }\n@@ -390,7 +390,7 @@ fn struct_wrapped_nullable_bitdiscr(\n fn load_discr(bcx: &BlockAndBuilder, ity: layout::Integer, ptr: ValueRef, min: u64, max: u64,\n               range_assert: bool)\n     -> ValueRef {\n-    let llty = Type::from_integer(bcx.ccx(), ity);\n+    let llty = Type::from_integer(bcx.ccx, ity);\n     assert_eq!(val_ty(ptr), llty.ptr_to());\n     let bits = ity.size().bits();\n     assert!(bits <= 64);\n@@ -416,16 +416,16 @@ fn load_discr(bcx: &BlockAndBuilder, ity: layout::Integer, ptr: ValueRef, min: u\n ///\n /// This should ideally be less tightly tied to `_match`.\n pub fn trans_case<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>, t: Ty<'tcx>, value: Disr) -> ValueRef {\n-    let l = bcx.ccx().layout_of(t);\n+    let l = bcx.ccx.layout_of(t);\n     match *l {\n         layout::CEnum { discr, .. }\n         | layout::General { discr, .. }=> {\n-            C_integral(Type::from_integer(bcx.ccx(), discr), value.0, true)\n+            C_integral(Type::from_integer(bcx.ccx, discr), value.0, true)\n         }\n         layout::RawNullablePointer { .. } |\n         layout::StructWrappedNullablePointer { .. } => {\n             assert!(value == Disr(0) || value == Disr(1));\n-            C_bool(bcx.ccx(), value != Disr(0))\n+            C_bool(bcx.ccx, value != Disr(0))\n         }\n         _ => {\n             bug!(\"{} does not have a discriminant. Represented as {:#?}\", t, l);\n@@ -438,15 +438,15 @@ pub fn trans_case<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>, t: Ty<'tcx>, value:\n pub fn trans_set_discr<'a, 'tcx>(\n     bcx: &BlockAndBuilder<'a, 'tcx>, t: Ty<'tcx>, val: ValueRef, to: Disr\n ) {\n-    let l = bcx.ccx().layout_of(t);\n+    let l = bcx.ccx.layout_of(t);\n     match *l {\n         layout::CEnum{ discr, min, max, .. } => {\n             assert_discr_in_range(Disr(min), Disr(max), to);\n-            bcx.store(C_integral(Type::from_integer(bcx.ccx(), discr), to.0, true),\n+            bcx.store(C_integral(Type::from_integer(bcx.ccx, discr), to.0, true),\n                   val);\n         }\n         layout::General{ discr, .. } => {\n-            bcx.store(C_integral(Type::from_integer(bcx.ccx(), discr), to.0, true),\n+            bcx.store(C_integral(Type::from_integer(bcx.ccx, discr), to.0, true),\n                   bcx.struct_gep(val, 0));\n         }\n         layout::Univariant { .. }\n@@ -455,9 +455,9 @@ pub fn trans_set_discr<'a, 'tcx>(\n             assert_eq!(to, Disr(0));\n         }\n         layout::RawNullablePointer { nndiscr, .. } => {\n-            let nnty = compute_fields(bcx.ccx(), t, nndiscr as usize, false)[0];\n+            let nnty = compute_fields(bcx.ccx, t, nndiscr as usize, false)[0];\n             if to.0 != nndiscr {\n-                let llptrty = type_of::sizing_type_of(bcx.ccx(), nnty);\n+                let llptrty = type_of::sizing_type_of(bcx.ccx, nnty);\n                 bcx.store(C_null(llptrty), val);\n             }\n         }\n@@ -467,10 +467,10 @@ pub fn trans_set_discr<'a, 'tcx>(\n                     // Issue #34427: As workaround for LLVM bug on\n                     // ARM, use memset of 0 on whole struct rather\n                     // than storing null to single target field.\n-                    let llptr = bcx.pointercast(val, Type::i8(bcx.ccx()).ptr_to());\n-                    let fill_byte = C_u8(bcx.ccx(), 0);\n-                    let size = C_uint(bcx.ccx(), nonnull.stride().bytes());\n-                    let align = C_i32(bcx.ccx(), nonnull.align.abi() as i32);\n+                    let llptr = bcx.pointercast(val, Type::i8(bcx.ccx).ptr_to());\n+                    let fill_byte = C_u8(bcx.ccx, 0);\n+                    let size = C_uint(bcx.ccx, nonnull.stride().bytes());\n+                    let align = C_i32(bcx.ccx, nonnull.align.abi() as i32);\n                     base::call_memset(bcx, llptr, fill_byte, size, align, false);\n                 } else {\n                     let path = discrfield.iter().map(|&i| i as usize).collect::<Vec<_>>();\n@@ -504,7 +504,7 @@ pub fn trans_field_ptr<'a, 'tcx>(\n     discr: Disr,\n     ix: usize\n ) -> ValueRef {\n-    let l = bcx.ccx().layout_of(t);\n+    let l = bcx.ccx.layout_of(t);\n     debug!(\"trans_field_ptr on {} represented as {:#?}\", t, l);\n     // Note: if this ever needs to generate conditionals (e.g., if we\n     // decide to do some kind of cdr-coding-like non-unique repr\n@@ -513,7 +513,7 @@ pub fn trans_field_ptr<'a, 'tcx>(\n         layout::Univariant { ref variant, .. } => {\n             assert_eq!(discr, Disr(0));\n             struct_field_ptr(bcx, &variant,\n-             &compute_fields(bcx.ccx(), t, 0, false),\n+             &compute_fields(bcx.ccx, t, 0, false),\n              val, ix, false)\n         }\n         layout::Vector { count, .. } => {\n@@ -522,37 +522,37 @@ pub fn trans_field_ptr<'a, 'tcx>(\n             bcx.struct_gep(val.value, ix)\n         }\n         layout::General { discr: d, ref variants, .. } => {\n-            let mut fields = compute_fields(bcx.ccx(), t, discr.0 as usize, false);\n-            fields.insert(0, d.to_ty(&bcx.ccx().tcx(), false));\n+            let mut fields = compute_fields(bcx.ccx, t, discr.0 as usize, false);\n+            fields.insert(0, d.to_ty(&bcx.ccx.tcx(), false));\n             struct_field_ptr(bcx, &variants[discr.0 as usize],\n              &fields,\n              val, ix + 1, true)\n         }\n         layout::UntaggedUnion { .. } => {\n-            let fields = compute_fields(bcx.ccx(), t, 0, false);\n-            let ty = type_of::in_memory_type_of(bcx.ccx(), fields[ix]);\n+            let fields = compute_fields(bcx.ccx, t, 0, false);\n+            let ty = type_of::in_memory_type_of(bcx.ccx, fields[ix]);\n             bcx.pointercast(val.value, ty.ptr_to())\n         }\n         layout::RawNullablePointer { nndiscr, .. } |\n         layout::StructWrappedNullablePointer { nndiscr,  .. } if discr.0 != nndiscr => {\n-            let nullfields = compute_fields(bcx.ccx(), t, (1-nndiscr) as usize, false);\n+            let nullfields = compute_fields(bcx.ccx, t, (1-nndiscr) as usize, false);\n             // The unit-like case might have a nonzero number of unit-like fields.\n             // (e.d., Result of Either with (), as one side.)\n-            let ty = type_of::type_of(bcx.ccx(), nullfields[ix]);\n-            assert_eq!(machine::llsize_of_alloc(bcx.ccx(), ty), 0);\n+            let ty = type_of::type_of(bcx.ccx, nullfields[ix]);\n+            assert_eq!(machine::llsize_of_alloc(bcx.ccx, ty), 0);\n             bcx.pointercast(val.value, ty.ptr_to())\n         }\n         layout::RawNullablePointer { nndiscr, .. } => {\n-            let nnty = compute_fields(bcx.ccx(), t, nndiscr as usize, false)[0];\n+            let nnty = compute_fields(bcx.ccx, t, nndiscr as usize, false)[0];\n             assert_eq!(ix, 0);\n             assert_eq!(discr.0, nndiscr);\n-            let ty = type_of::type_of(bcx.ccx(), nnty);\n+            let ty = type_of::type_of(bcx.ccx, nnty);\n             bcx.pointercast(val.value, ty.ptr_to())\n         }\n         layout::StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n             assert_eq!(discr.0, nndiscr);\n             struct_field_ptr(bcx, &nonnull,\n-             &compute_fields(bcx.ccx(), t, discr.0 as usize, false),\n+             &compute_fields(bcx.ccx, t, discr.0 as usize, false),\n              val, ix, false)\n         }\n         _ => bug!(\"element access in type without elements: {} represented as {:#?}\", t, l)\n@@ -568,7 +568,7 @@ fn struct_field_ptr<'a, 'tcx>(\n     needs_cast: bool\n ) -> ValueRef {\n     let fty = fields[ix];\n-    let ccx = bcx.ccx();\n+    let ccx = bcx.ccx;\n \n     let ptr_val = if needs_cast {\n         let fields = st.field_index_by_increasing_offset().map(|i| {\n@@ -585,7 +585,7 @@ fn struct_field_ptr<'a, 'tcx>(\n     //   * Packed struct - There is no alignment padding\n     //   * Field is sized - pointer is properly aligned already\n     if st.offsets[ix] == layout::Size::from_bytes(0) || st.packed ||\n-        bcx.ccx().shared().type_is_sized(fty) {\n+        bcx.ccx.shared().type_is_sized(fty) {\n         return bcx.struct_gep(ptr_val, st.memory_index[ix] as usize);\n     }\n \n@@ -624,7 +624,7 @@ fn struct_field_ptr<'a, 'tcx>(\n \n \n     let offset = st.offsets[ix].bytes();\n-    let unaligned_offset = C_uint(bcx.ccx(), offset);\n+    let unaligned_offset = C_uint(bcx.ccx, offset);\n \n     // Get the alignment of the field\n     let (_, align) = glue::size_and_align_of_dst(bcx, fty, meta);\n@@ -635,18 +635,18 @@ fn struct_field_ptr<'a, 'tcx>(\n     //   (unaligned offset + (align - 1)) & -align\n \n     // Calculate offset\n-    let align_sub_1 = bcx.sub(align, C_uint(bcx.ccx(), 1u64));\n+    let align_sub_1 = bcx.sub(align, C_uint(bcx.ccx, 1u64));\n     let offset = bcx.and(bcx.add(unaligned_offset, align_sub_1),\n                          bcx.neg(align));\n \n     debug!(\"struct_field_ptr: DST field offset: {:?}\", Value(offset));\n \n     // Cast and adjust pointer\n-    let byte_ptr = bcx.pointercast(ptr_val, Type::i8p(bcx.ccx()));\n+    let byte_ptr = bcx.pointercast(ptr_val, Type::i8p(bcx.ccx));\n     let byte_ptr = bcx.gep(byte_ptr, &[offset]);\n \n     // Finally, cast back to the type expected\n-    let ll_fty = type_of::in_memory_type_of(bcx.ccx(), fty);\n+    let ll_fty = type_of::in_memory_type_of(bcx.ccx, fty);\n     debug!(\"struct_field_ptr: Field type is {:?}\", ll_fty);\n     bcx.pointercast(byte_ptr, ll_fty.ptr_to())\n }"}, {"sha": "d6385e1ca156263994ec0ef4d35c030b13a23416", "filename": "src/librustc_trans/asm.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/88202c5b838ea9f328d37f19c022eba5040e234f/src%2Flibrustc_trans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88202c5b838ea9f328d37f19c022eba5040e234f/src%2Flibrustc_trans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fasm.rs?ref=88202c5b838ea9f328d37f19c022eba5040e234f", "patch": "@@ -48,7 +48,7 @@ pub fn trans_inline_asm<'a, 'tcx>(\n         if out.is_indirect {\n             indirect_outputs.push(val.unwrap());\n         } else {\n-            output_types.push(type_of::type_of(bcx.ccx(), ty));\n+            output_types.push(type_of::type_of(bcx.ccx, ty));\n         }\n     }\n     if !indirect_outputs.is_empty() {\n@@ -79,9 +79,9 @@ pub fn trans_inline_asm<'a, 'tcx>(\n     // Depending on how many outputs we have, the return type is different\n     let num_outputs = output_types.len();\n     let output_type = match num_outputs {\n-        0 => Type::void(bcx.ccx()),\n+        0 => Type::void(bcx.ccx),\n         1 => output_types[0],\n-        _ => Type::struct_(bcx.ccx(), &output_types[..], false)\n+        _ => Type::struct_(bcx.ccx, &output_types[..], false)\n     };\n \n     let dialect = match ia.dialect {\n@@ -112,12 +112,12 @@ pub fn trans_inline_asm<'a, 'tcx>(\n     // back to source locations.  See #17552.\n     unsafe {\n         let key = \"srcloc\";\n-        let kind = llvm::LLVMGetMDKindIDInContext(bcx.ccx().llcx(),\n+        let kind = llvm::LLVMGetMDKindIDInContext(bcx.ccx.llcx(),\n             key.as_ptr() as *const c_char, key.len() as c_uint);\n \n-        let val: llvm::ValueRef = C_i32(bcx.ccx(), ia.expn_id.into_u32() as i32);\n+        let val: llvm::ValueRef = C_i32(bcx.ccx, ia.expn_id.into_u32() as i32);\n \n         llvm::LLVMSetMetadata(r, kind,\n-            llvm::LLVMMDNodeInContext(bcx.ccx().llcx(), &val, 1));\n+            llvm::LLVMMDNodeInContext(bcx.ccx.llcx(), &val, 1));\n     }\n }"}, {"sha": "9697f2604349bbf9ad5d6b9a124d20c2e5ee1902", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/88202c5b838ea9f328d37f19c022eba5040e234f/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88202c5b838ea9f328d37f19c022eba5040e234f/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=88202c5b838ea9f328d37f19c022eba5040e234f", "patch": "@@ -232,9 +232,9 @@ pub fn unsize_thin_ptr<'a, 'tcx>(\n          &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) |\n         (&ty::TyRawPtr(ty::TypeAndMut { ty: a, .. }),\n          &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) => {\n-            assert!(bcx.ccx().shared().type_is_sized(a));\n-            let ptr_ty = type_of::in_memory_type_of(bcx.ccx(), b).ptr_to();\n-            (bcx.pointercast(src, ptr_ty), unsized_info(bcx.ccx(), a, b, None))\n+            assert!(bcx.ccx.shared().type_is_sized(a));\n+            let ptr_ty = type_of::in_memory_type_of(bcx.ccx, b).ptr_to();\n+            (bcx.pointercast(src, ptr_ty), unsized_info(bcx.ccx, a, b, None))\n         }\n         _ => bug!(\"unsize_thin_ptr: called on bad types\"),\n     }\n@@ -252,13 +252,13 @@ pub fn coerce_unsized_into<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n         (&ty::TyRef(..), &ty::TyRef(..)) |\n         (&ty::TyRef(..), &ty::TyRawPtr(..)) |\n         (&ty::TyRawPtr(..), &ty::TyRawPtr(..)) => {\n-            let (base, info) = if common::type_is_fat_ptr(bcx.ccx(), src_ty) {\n+            let (base, info) = if common::type_is_fat_ptr(bcx.ccx, src_ty) {\n                 // fat-ptr to fat-ptr unsize preserves the vtable\n                 // i.e. &'a fmt::Debug+Send => &'a fmt::Debug\n                 // So we need to pointercast the base to ensure\n                 // the types match up.\n                 let (base, info) = load_fat_ptr(bcx, src, src_ty);\n-                let llcast_ty = type_of::fat_ptr_base_ty(bcx.ccx(), dst_ty);\n+                let llcast_ty = type_of::fat_ptr_base_ty(bcx.ccx, dst_ty);\n                 let base = bcx.pointercast(base, llcast_ty);\n                 (base, info)\n             } else {\n@@ -283,7 +283,7 @@ pub fn coerce_unsized_into<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n \n             let iter = src_fields.zip(dst_fields).enumerate();\n             for (i, (src_fty, dst_fty)) in iter {\n-                if type_is_zero_size(bcx.ccx(), dst_fty) {\n+                if type_is_zero_size(bcx.ccx, dst_fty) {\n                     continue;\n                 }\n \n@@ -460,16 +460,16 @@ pub fn load_fat_ptr<'a, 'tcx>(\n }\n \n pub fn from_immediate(bcx: &BlockAndBuilder, val: ValueRef) -> ValueRef {\n-    if val_ty(val) == Type::i1(bcx.ccx()) {\n-        bcx.zext(val, Type::i8(bcx.ccx()))\n+    if val_ty(val) == Type::i1(bcx.ccx) {\n+        bcx.zext(val, Type::i8(bcx.ccx))\n     } else {\n         val\n     }\n }\n \n pub fn to_immediate(bcx: &BlockAndBuilder, val: ValueRef, ty: Ty) -> ValueRef {\n     if ty.is_bool() {\n-        bcx.trunc(val, Type::i1(bcx.ccx()))\n+        bcx.trunc(val, Type::i1(bcx.ccx))\n     } else {\n         val\n     }\n@@ -526,7 +526,7 @@ pub fn call_memcpy<'a, 'tcx>(b: &Builder<'a, 'tcx>,\n pub fn memcpy_ty<'a, 'tcx>(\n     bcx: &BlockAndBuilder<'a, 'tcx>, dst: ValueRef, src: ValueRef, t: Ty<'tcx>\n ) {\n-    let ccx = bcx.ccx();\n+    let ccx = bcx.ccx;\n \n     if type_is_zero_size(ccx, t) {\n         return;\n@@ -537,7 +537,7 @@ pub fn memcpy_ty<'a, 'tcx>(\n         let llsz = llsize_of(ccx, llty);\n         let llalign = type_of::align_of(ccx, t);\n         call_memcpy(bcx, dst, src, llsz, llalign as u32);\n-    } else if common::type_is_fat_ptr(bcx.ccx(), t) {\n+    } else if common::type_is_fat_ptr(bcx.ccx, t) {\n         let (data, extra) = load_fat_ptr(bcx, src, t);\n         store_fat_ptr(bcx, data, extra, dst, t);\n     } else {\n@@ -560,7 +560,7 @@ pub fn call_memset<'a, 'tcx>(b: &Builder<'a, 'tcx>,\n \n pub fn alloc_ty<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>, ty: Ty<'tcx>, name: &str) -> ValueRef {\n     assert!(!ty.has_param_types());\n-    bcx.fcx().alloca(type_of::type_of(bcx.ccx(), ty), name)\n+    bcx.fcx().alloca(type_of::type_of(bcx.ccx, ty), name)\n }\n \n pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance<'tcx>) {\n@@ -638,7 +638,7 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             let lldestptr = adt::trans_field_ptr(&bcx, sig.output(), dest_val, Disr::from(disr), i);\n             let arg = &fcx.fn_ty.args[arg_idx];\n             arg_idx += 1;\n-            if common::type_is_fat_ptr(bcx.ccx(), arg_ty) {\n+            if common::type_is_fat_ptr(bcx.ccx, arg_ty) {\n                 let meta = &fcx.fn_ty.args[arg_idx];\n                 arg_idx += 1;\n                 arg.store_fn_arg(&bcx, &mut llarg_idx, get_dataptr(&bcx, lldestptr));"}, {"sha": "384c70ffa448b86231a341be17f09173de9982be", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88202c5b838ea9f328d37f19c022eba5040e234f/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88202c5b838ea9f328d37f19c022eba5040e234f/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=88202c5b838ea9f328d37f19c022eba5040e234f", "patch": "@@ -368,7 +368,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     // to drop `self` when the body returns, or in case it unwinds.\n     let self_scope = fcx.schedule_drop_mem(llenv, closure_ty);\n     let fn_ret = callee.ty.fn_ret();\n-    let fn_ty = callee.direct_fn_type(bcx.ccx(), &[]);\n+    let fn_ty = callee.direct_fn_type(bcx.ccx, &[]);\n \n     let first_llarg = if fn_ty.ret.is_indirect() && !fcx.fn_ty.ret.is_ignore() {\n         Some(get_param(fcx.llfn, 0))\n@@ -378,7 +378,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     let llargs = first_llarg.into_iter().chain(llargs[self_idx..].iter().cloned())\n         .collect::<Vec<_>>();\n \n-    let llfn = callee.reify(bcx.ccx());\n+    let llfn = callee.reify(bcx.ccx);\n     let llret;\n     if let Some(landing_pad) = self_scope.landing_pad {\n         let normal_bcx = bcx.fcx().build_new_block(\"normal-return\");"}, {"sha": "86099d241df686bec35b2594f87cb3ef78e990ab", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88202c5b838ea9f328d37f19c022eba5040e234f/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88202c5b838ea9f328d37f19c022eba5040e234f/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=88202c5b838ea9f328d37f19c022eba5040e234f", "patch": "@@ -431,7 +431,7 @@ pub fn declare_local<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                                variable_access: VariableAccess,\n                                variable_kind: VariableKind,\n                                span: Span) {\n-    let cx: &CrateContext = bcx.ccx();\n+    let cx = bcx.ccx;\n \n     let file = span_start(cx, span).file;\n     let filename = file.name.clone();"}, {"sha": "ea34dbbeeb4268dda35a421bd5039bfcd41a8e6d", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/88202c5b838ea9f328d37f19c022eba5040e234f/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88202c5b838ea9f328d37f19c022eba5040e234f/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=88202c5b838ea9f328d37f19c022eba5040e234f", "patch": "@@ -43,10 +43,10 @@ pub fn trans_exchange_free_dyn<'a, 'tcx>(\n     align: ValueRef\n ) {\n     let def_id = langcall(bcx.tcx(), None, \"\", ExchangeFreeFnLangItem);\n-    let args = [bcx.pointercast(v, Type::i8p(bcx.ccx())), size, align];\n-    let callee = Callee::def(bcx.ccx(), def_id, bcx.tcx().intern_substs(&[]));\n+    let args = [bcx.pointercast(v, Type::i8p(bcx.ccx)), size, align];\n+    let callee = Callee::def(bcx.ccx, def_id, bcx.tcx().intern_substs(&[]));\n \n-    let ccx = bcx.ccx();\n+    let ccx = bcx.ccx;\n     let fn_ty = callee.direct_fn_type(ccx, &[]);\n \n     assert!(!fn_ty.ret.is_indirect() && fn_ty.ret.cast.is_none());\n@@ -58,14 +58,14 @@ pub fn trans_exchange_free_dyn<'a, 'tcx>(\n pub fn trans_exchange_free_ty<'a, 'tcx>(\n     bcx: &BlockAndBuilder<'a, 'tcx>, ptr: ValueRef, content_ty: Ty<'tcx>\n ) {\n-    assert!(bcx.ccx().shared().type_is_sized(content_ty));\n-    let sizing_type = sizing_type_of(bcx.ccx(), content_ty);\n-    let content_size = llsize_of_alloc(bcx.ccx(), sizing_type);\n+    assert!(bcx.ccx.shared().type_is_sized(content_ty));\n+    let sizing_type = sizing_type_of(bcx.ccx, content_ty);\n+    let content_size = llsize_of_alloc(bcx.ccx, sizing_type);\n \n     // `Box<ZeroSizeType>` does not allocate.\n     if content_size != 0 {\n-        let content_align = align_of(bcx.ccx(), content_ty);\n-        let ccx = bcx.ccx();\n+        let content_align = align_of(bcx.ccx, content_ty);\n+        let ccx = bcx.ccx;\n         trans_exchange_free_dyn(bcx, ptr, C_uint(ccx, content_size), C_uint(ccx, content_align));\n     }\n }\n@@ -122,8 +122,8 @@ pub fn call_drop_glue<'a, 'tcx>(\n ) {\n     // NB: v is an *alias* of type t here, not a direct value.\n     debug!(\"call_drop_glue(t={:?}, skip_dtor={})\", t, skip_dtor);\n-    if bcx.ccx().shared().type_needs_drop(t) {\n-        let ccx = bcx.ccx();\n+    if bcx.ccx.shared().type_needs_drop(t) {\n+        let ccx = bcx.ccx;\n         let g = if skip_dtor {\n             DropGlueKind::TyContents(t)\n         } else {\n@@ -232,7 +232,7 @@ fn trans_custom_dtor<'a, 'tcx>(mut bcx: BlockAndBuilder<'a, 'tcx>,\n     };\n \n     let (sized_args, unsized_args);\n-    let args: &[ValueRef] = if bcx.ccx().shared().type_is_sized(t) {\n+    let args: &[ValueRef] = if bcx.ccx.shared().type_is_sized(t) {\n         sized_args = [v0];\n         &sized_args\n     } else {\n@@ -248,20 +248,20 @@ fn trans_custom_dtor<'a, 'tcx>(mut bcx: BlockAndBuilder<'a, 'tcx>,\n         def_id: tcx.lang_items.drop_trait().unwrap(),\n         substs: tcx.mk_substs_trait(t, &[])\n     });\n-    let vtbl = match fulfill_obligation(bcx.ccx().shared(), DUMMY_SP, trait_ref) {\n+    let vtbl = match fulfill_obligation(bcx.ccx.shared(), DUMMY_SP, trait_ref) {\n         traits::VtableImpl(data) => data,\n         _ => bug!(\"dtor for {:?} is not an impl???\", t)\n     };\n     let dtor_did = def.destructor().unwrap();\n-    let callee = Callee::def(bcx.ccx(), dtor_did, vtbl.substs);\n-    let fn_ty = callee.direct_fn_type(bcx.ccx(), &[]);\n+    let callee = Callee::def(bcx.ccx, dtor_did, vtbl.substs);\n+    let fn_ty = callee.direct_fn_type(bcx.ccx, &[]);\n     let llret;\n     if let Some(landing_pad) = contents_scope.landing_pad {\n         let normal_bcx = bcx.fcx().build_new_block(\"normal-return\");\n-        llret = bcx.invoke(callee.reify(bcx.ccx()), args, normal_bcx.llbb(), landing_pad, None);\n+        llret = bcx.invoke(callee.reify(bcx.ccx), args, normal_bcx.llbb(), landing_pad, None);\n         bcx = normal_bcx;\n     } else {\n-        llret = bcx.call(callee.reify(bcx.ccx()), args, None);\n+        llret = bcx.call(callee.reify(bcx.ccx), args, None);\n     }\n     fn_ty.apply_attrs_callsite(llret);\n     contents_scope.trans(&bcx);\n@@ -273,19 +273,19 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                                        -> (ValueRef, ValueRef) {\n     debug!(\"calculate size of DST: {}; with lost info: {:?}\",\n            t, Value(info));\n-    if bcx.ccx().shared().type_is_sized(t) {\n-        let sizing_type = sizing_type_of(bcx.ccx(), t);\n-        let size = llsize_of_alloc(bcx.ccx(), sizing_type);\n-        let align = align_of(bcx.ccx(), t);\n+    if bcx.ccx.shared().type_is_sized(t) {\n+        let sizing_type = sizing_type_of(bcx.ccx, t);\n+        let size = llsize_of_alloc(bcx.ccx, sizing_type);\n+        let align = align_of(bcx.ccx, t);\n         debug!(\"size_and_align_of_dst t={} info={:?} size: {} align: {}\",\n                t, Value(info), size, align);\n-        let size = C_uint(bcx.ccx(), size);\n-        let align = C_uint(bcx.ccx(), align);\n+        let size = C_uint(bcx.ccx, size);\n+        let align = C_uint(bcx.ccx, align);\n         return (size, align);\n     }\n     match t.sty {\n         ty::TyAdt(def, substs) => {\n-            let ccx = bcx.ccx();\n+            let ccx = bcx.ccx;\n             // First get the size of all statically known fields.\n             // Don't use type_of::sizing_type_of because that expects t to be sized,\n             // and it also rounds up to alignment, which we want to avoid,\n@@ -348,15 +348,15 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n             //\n             //   `(size + (align-1)) & -align`\n \n-            let addend = bcx.sub(align, C_uint(bcx.ccx(), 1_u64));\n+            let addend = bcx.sub(align, C_uint(bcx.ccx, 1_u64));\n             let size = bcx.and(bcx.add(size, addend), bcx.neg(align));\n \n             (size, align)\n         }\n         ty::TyDynamic(..) => {\n             // info points to the vtable and the second entry in the vtable is the\n             // dynamic size of the object.\n-            let info = bcx.pointercast(info, Type::int(bcx.ccx()).ptr_to());\n+            let info = bcx.pointercast(info, Type::int(bcx.ccx).ptr_to());\n             let size_ptr = bcx.gepi(info, &[1]);\n             let align_ptr = bcx.gepi(info, &[2]);\n             (bcx.load(size_ptr), bcx.load(align_ptr))\n@@ -365,11 +365,11 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n             let unit_ty = t.sequence_element_type(bcx.tcx());\n             // The info in this case is the length of the str, so the size is that\n             // times the unit size.\n-            let llunit_ty = sizing_type_of(bcx.ccx(), unit_ty);\n-            let unit_align = llalign_of_min(bcx.ccx(), llunit_ty);\n-            let unit_size = llsize_of_alloc(bcx.ccx(), llunit_ty);\n-            (bcx.mul(info, C_uint(bcx.ccx(), unit_size)),\n-             C_uint(bcx.ccx(), unit_align))\n+            let llunit_ty = sizing_type_of(bcx.ccx, unit_ty);\n+            let unit_align = llalign_of_min(bcx.ccx, llunit_ty);\n+            let unit_size = llsize_of_alloc(bcx.ccx, llunit_ty);\n+            (bcx.mul(info, C_uint(bcx.ccx, unit_size)),\n+             C_uint(bcx.ccx, unit_align))\n         }\n         _ => bug!(\"Unexpected unsized type, found {}\", t)\n     }\n@@ -394,7 +394,7 @@ fn make_drop_glue<'a, 'tcx>(bcx: BlockAndBuilder<'a, 'tcx>,\n             // special. It may move to library and have Drop impl. As\n             // a safe-guard, assert TyBox not used with TyContents.\n             assert!(!skip_dtor);\n-            if !bcx.ccx().shared().type_is_sized(content_ty) {\n+            if !bcx.ccx.shared().type_is_sized(content_ty) {\n                 let llval = get_dataptr(&bcx, v0);\n                 let llbox = bcx.load(llval);\n                 drop_ty(&bcx, v0, content_ty);\n@@ -407,7 +407,7 @@ fn make_drop_glue<'a, 'tcx>(bcx: BlockAndBuilder<'a, 'tcx>,\n                 let needs_free = bcx.icmp(\n                     llvm::IntNE,\n                     llsize,\n-                    C_uint(bcx.ccx(), 0u64),\n+                    C_uint(bcx.ccx, 0u64),\n                 );\n                 if const_to_opt_uint(needs_free) == Some(0) {\n                     bcx\n@@ -437,7 +437,7 @@ fn make_drop_glue<'a, 'tcx>(bcx: BlockAndBuilder<'a, 'tcx>,\n             let data_ptr = get_dataptr(&bcx, v0);\n             let vtable_ptr = bcx.load(get_meta(&bcx, v0));\n             let dtor = bcx.load(vtable_ptr);\n-            bcx.call(dtor, &[bcx.pointercast(bcx.load(data_ptr), Type::i8p(bcx.ccx()))], None);\n+            bcx.call(dtor, &[bcx.pointercast(bcx.load(data_ptr), Type::i8p(bcx.ccx))], None);\n             bcx\n         }\n         ty::TyAdt(def, ..) if def.dtor_kind().is_present() && !skip_dtor => {\n@@ -447,7 +447,7 @@ fn make_drop_glue<'a, 'tcx>(bcx: BlockAndBuilder<'a, 'tcx>,\n             bcx\n         }\n         _ => {\n-            if bcx.ccx().shared().type_needs_drop(t) {\n+            if bcx.ccx.shared().type_needs_drop(t) {\n                 drop_structural_ty(bcx, v0, t)\n             } else {\n                 bcx"}, {"sha": "d218459eeb59c2b1cf521ed04f9dffd4a6f8d400", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/88202c5b838ea9f328d37f19c022eba5040e234f/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88202c5b838ea9f328d37f19c022eba5040e234f/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=88202c5b838ea9f328d37f19c022eba5040e234f", "patch": "@@ -91,7 +91,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                                       llargs: &[ValueRef],\n                                       llresult: ValueRef,\n                                       span: Span) {\n-    let ccx = bcx.ccx();\n+    let ccx = bcx.ccx;\n     let tcx = bcx.tcx();\n \n     let (def_id, substs, fty) = match callee_ty.sty {\n@@ -137,7 +137,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n         }\n         \"size_of_val\" => {\n             let tp_ty = substs.type_at(0);\n-            if !bcx.ccx().shared().type_is_sized(tp_ty) {\n+            if !bcx.ccx.shared().type_is_sized(tp_ty) {\n                 let (llsize, _) =\n                     glue::size_and_align_of_dst(bcx, tp_ty, llargs[1]);\n                 llsize\n@@ -152,7 +152,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n         }\n         \"min_align_of_val\" => {\n             let tp_ty = substs.type_at(0);\n-            if !bcx.ccx().shared().type_is_sized(tp_ty) {\n+            if !bcx.ccx.shared().type_is_sized(tp_ty) {\n                 let (_, llalign) =\n                     glue::size_and_align_of_dst(bcx, tp_ty, llargs[1]);\n                 llalign\n@@ -191,7 +191,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n         \"needs_drop\" => {\n             let tp_ty = substs.type_at(0);\n \n-            C_bool(ccx, bcx.ccx().shared().type_needs_drop(tp_ty))\n+            C_bool(ccx, bcx.ccx.shared().type_needs_drop(tp_ty))\n         }\n         \"offset\" => {\n             let ptr = llargs[0];\n@@ -237,7 +237,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n         },\n         \"volatile_store\" => {\n             let tp_ty = substs.type_at(0);\n-            if type_is_fat_ptr(bcx.ccx(), tp_ty) {\n+            if type_is_fat_ptr(bcx.ccx, tp_ty) {\n                 bcx.volatile_store(llargs[1], get_dataptr(bcx, llargs[0]));\n                 bcx.volatile_store(llargs[2], get_meta(bcx, llargs[0]));\n             } else {\n@@ -264,7 +264,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                 Some((width, signed)) =>\n                     match name {\n                         \"ctlz\" | \"cttz\" => {\n-                            let y = C_bool(bcx.ccx(), false);\n+                            let y = C_bool(bcx.ccx, false);\n                             let llfn = ccx.get_intrinsic(&format!(\"llvm.{}.i{}\", name, width));\n                             bcx.call(llfn, &[llargs[0], y], None)\n                         }\n@@ -282,7 +282,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                             let intrinsic = format!(\"llvm.{}{}.with.overflow.i{}\",\n                                                     if signed { 's' } else { 'u' },\n                                                     &name[..3], width);\n-                            let llfn = bcx.ccx().get_intrinsic(&intrinsic);\n+                            let llfn = bcx.ccx.get_intrinsic(&intrinsic);\n \n                             // Convert `i1` to a `bool`, and write it to the out parameter\n                             let val = bcx.call(llfn, &[llargs[0], llargs[1]], None);\n@@ -291,7 +291,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                             bcx.store(result, bcx.struct_gep(llresult, 0));\n                             bcx.store(overflow, bcx.struct_gep(llresult, 1));\n \n-                            C_nil(bcx.ccx())\n+                            C_nil(bcx.ccx)\n                         },\n                         \"overflowing_add\" => bcx.add(llargs[0], llargs[1]),\n                         \"overflowing_sub\" => bcx.sub(llargs[0], llargs[1]),\n@@ -406,7 +406,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                         let val = bcx.atomic_cmpxchg(llargs[0], llargs[1], llargs[2], order,\n                             failorder, weak);\n                         let result = bcx.extract_value(val, 0);\n-                        let success = bcx.zext(bcx.extract_value(val, 1), Type::bool(bcx.ccx()));\n+                        let success = bcx.zext(bcx.extract_value(val, 1), Type::bool(bcx.ccx));\n                         bcx.store(result, bcx.struct_gep(llresult, 0));\n                         bcx.store(success, bcx.struct_gep(llresult, 1));\n                     } else {\n@@ -545,7 +545,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                         // This assumes the type is \"simple\", i.e. no\n                         // destructors, and the contents are SIMD\n                         // etc.\n-                        assert!(!bcx.ccx().shared().type_needs_drop(arg_type));\n+                        assert!(!bcx.ccx.shared().type_needs_drop(arg_type));\n                         let arg = adt::MaybeSizedValue::sized(llarg);\n                         (0..contents.len())\n                             .map(|i| {\n@@ -554,18 +554,18 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                             .collect()\n                     }\n                     intrinsics::Type::Pointer(_, Some(ref llvm_elem), _) => {\n-                        let llvm_elem = one(ty_to_type(bcx.ccx(), llvm_elem, &mut false));\n+                        let llvm_elem = one(ty_to_type(bcx.ccx, llvm_elem, &mut false));\n                         vec![bcx.pointercast(llarg, llvm_elem.ptr_to())]\n                     }\n                     intrinsics::Type::Vector(_, Some(ref llvm_elem), length) => {\n-                        let llvm_elem = one(ty_to_type(bcx.ccx(), llvm_elem, &mut false));\n+                        let llvm_elem = one(ty_to_type(bcx.ccx, llvm_elem, &mut false));\n                         vec![bcx.bitcast(llarg, Type::vector(&llvm_elem, length as u64))]\n                     }\n                     intrinsics::Type::Integer(_, width, llvm_width) if width != llvm_width => {\n                         // the LLVM intrinsic uses a smaller integer\n                         // size than the C intrinsic's signature, so\n                         // we have to trim it down here.\n-                        vec![bcx.trunc(llarg, Type::ix(bcx.ccx(), llvm_width as u64))]\n+                        vec![bcx.trunc(llarg, Type::ix(bcx.ccx, llvm_width as u64))]\n                     }\n                     _ => vec![llarg],\n                 }\n@@ -643,7 +643,7 @@ fn copy_intrinsic<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                             src: ValueRef,\n                             count: ValueRef)\n                             -> ValueRef {\n-    let ccx = bcx.ccx();\n+    let ccx = bcx.ccx;\n     let lltp_ty = type_of::type_of(ccx, tp_ty);\n     let align = C_i32(ccx, type_of::align_of(ccx, tp_ty) as i32);\n     let size = machine::llsize_of(ccx, lltp_ty);\n@@ -678,7 +678,7 @@ fn memset_intrinsic<'a, 'tcx>(\n     val: ValueRef,\n     count: ValueRef\n ) -> ValueRef {\n-    let ccx = bcx.ccx();\n+    let ccx = bcx.ccx;\n     let align = C_i32(ccx, type_of::align_of(ccx, ty) as i32);\n     let lltp_ty = type_of::type_of(ccx, ty);\n     let size = machine::llsize_of(ccx, lltp_ty);\n@@ -695,7 +695,7 @@ fn try_intrinsic<'a, 'tcx>(\n ) {\n     if bcx.sess().no_landing_pads() {\n         bcx.call(func, &[data], None);\n-        bcx.store(C_null(Type::i8p(&bcx.ccx())), dest);\n+        bcx.store(C_null(Type::i8p(&bcx.ccx)), dest);\n     } else if wants_msvc_seh(bcx.sess()) {\n         trans_msvc_try(bcx, func, data, local_ptr, dest);\n     } else {\n@@ -716,7 +716,7 @@ fn trans_msvc_try<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                             local_ptr: ValueRef,\n                             dest: ValueRef) {\n     let llfn = get_rust_try_fn(bcx.fcx(), &mut |bcx| {\n-        let ccx = bcx.ccx();\n+        let ccx = bcx.ccx;\n \n         bcx.set_personality_fn(bcx.fcx().eh_personality());\n \n@@ -819,7 +819,7 @@ fn trans_gnu_try<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                            local_ptr: ValueRef,\n                            dest: ValueRef) {\n     let llfn = get_rust_try_fn(bcx.fcx(), &mut |bcx| {\n-        let ccx = bcx.ccx();\n+        let ccx = bcx.ccx;\n \n         // Translates the shims described above:\n         //\n@@ -947,7 +947,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n         ($cond: expr, $($fmt: tt)*) => {\n             if !$cond {\n                 emit_error!($($fmt)*);\n-                return C_nil(bcx.ccx())\n+                return C_nil(bcx.ccx)\n             }\n         }\n     }\n@@ -1038,7 +1038,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n                                     arg_idx, total_len);\n                         None\n                     }\n-                    Some(idx) => Some(C_i32(bcx.ccx(), idx as i32)),\n+                    Some(idx) => Some(C_i32(bcx.ccx, idx as i32)),\n                 }\n             })\n             .collect();"}, {"sha": "df893ac7ab074a163db8ac01ff59c2011b88abec", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88202c5b838ea9f328d37f19c022eba5040e234f/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88202c5b838ea9f328d37f19c022eba5040e234f/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=88202c5b838ea9f328d37f19c022eba5040e234f", "patch": "@@ -92,7 +92,7 @@ pub fn trans_object_shim<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n         CalleeData::Virtual(idx) => {\n             let fn_ptr = get_virtual_method(&bcx,\n                 llargs.remove(fn_ty.ret.is_indirect() as usize + 1), idx);\n-            let llty = fn_ty.llvm_type(bcx.ccx()).ptr_to();\n+            let llty = fn_ty.llvm_type(bcx.ccx).ptr_to();\n             bcx.pointercast(fn_ptr, llty)\n         },\n         _ => bug!(\"trans_object_shim called with non-virtual callee\"),"}, {"sha": "3d3796aeebffc46f16298c63e5dc81d78a91a72e", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/88202c5b838ea9f328d37f19c022eba5040e234f/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88202c5b838ea9f328d37f19c022eba5040e234f/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=88202c5b838ea9f328d37f19c022eba5040e234f", "patch": "@@ -126,7 +126,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     } else {\n                         let exc_ptr = bcx.extract_value(lp, 0);\n                         bcx.call(\n-                            bcx.fcx().eh_unwind_resume().reify(bcx.ccx()),\n+                            bcx.fcx().eh_unwind_resume().reify(bcx.ccx),\n                             &[exc_ptr],\n                             cleanup_bundle,\n                         );\n@@ -185,7 +185,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let discr = base::to_immediate(&bcx, discr, switch_ty);\n                 let switch = bcx.switch(discr, llblock(self, *otherwise), values.len());\n                 for (value, target) in values.iter().zip(targets) {\n-                    let val = Const::from_constval(bcx.ccx(), value.clone(), switch_ty);\n+                    let val = Const::from_constval(bcx.ccx, value.clone(), switch_ty);\n                     let llbb = llblock(self, *target);\n                     bcx.add_case(switch, val.llval, llbb)\n                 }\n@@ -218,7 +218,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         Ref(llval) => llval\n                     };\n                     let load = bcx.load(bcx.pointercast(llslot, cast_ty.ptr_to()));\n-                    let llalign = llalign_of_min(bcx.ccx(), ret.ty);\n+                    let llalign = llalign_of_min(bcx.ccx, ret.ty);\n                     unsafe {\n                         llvm::LLVMSetAlignment(load, llalign);\n                     }\n@@ -239,18 +239,18 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let ty = self.monomorphize(&ty);\n \n                 // Double check for necessity to drop\n-                if !bcx.ccx().shared().type_needs_drop(ty) {\n+                if !bcx.ccx.shared().type_needs_drop(ty) {\n                     funclet_br(self, bcx, target);\n                     return;\n                 }\n \n                 let lvalue = self.trans_lvalue(&bcx, location);\n-                let drop_fn = glue::get_drop_glue(bcx.ccx(), ty);\n-                let drop_ty = glue::get_drop_glue_type(bcx.ccx().shared(), ty);\n-                let is_sized = bcx.ccx().shared().type_is_sized(ty);\n+                let drop_fn = glue::get_drop_glue(bcx.ccx, ty);\n+                let drop_ty = glue::get_drop_glue_type(bcx.ccx.shared(), ty);\n+                let is_sized = bcx.ccx.shared().type_is_sized(ty);\n                 let llvalue = if is_sized {\n                     if drop_ty != ty {\n-                        bcx.pointercast(lvalue.llval, type_of::type_of(bcx.ccx(), drop_ty).ptr_to())\n+                        bcx.pointercast(lvalue.llval, type_of::type_of(bcx.ccx, drop_ty).ptr_to())\n                     } else {\n                         lvalue.llval\n                     }\n@@ -291,7 +291,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 // NOTE: Unlike binops, negation doesn't have its own\n                 // checked operation, just a comparison with the minimum\n                 // value, so we have to check for the assert message.\n-                if !bcx.ccx().check_overflow() {\n+                if !bcx.ccx.check_overflow() {\n                     use rustc_const_math::ConstMathErr::Overflow;\n                     use rustc_const_math::Op::Neg;\n \n@@ -307,8 +307,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 }\n \n                 // Pass the condition through llvm.expect for branch hinting.\n-                let expect = bcx.ccx().get_intrinsic(&\"llvm.expect.i1\");\n-                let cond = bcx.call(expect, &[cond, C_bool(bcx.ccx(), expected)], None);\n+                let expect = bcx.ccx.get_intrinsic(&\"llvm.expect.i1\");\n+                let cond = bcx.call(expect, &[cond, C_bool(bcx.ccx, expected)], None);\n \n                 // Create the failure block and the conditional branch to it.\n                 let lltarget = llblock(self, target);\n@@ -326,8 +326,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 // Get the location information.\n                 let loc = bcx.sess().codemap().lookup_char_pos(span.lo);\n                 let filename = Symbol::intern(&loc.file.name).as_str();\n-                let filename = C_str_slice(bcx.ccx(), filename);\n-                let line = C_u32(bcx.ccx(), loc.line as u32);\n+                let filename = C_str_slice(bcx.ccx, filename);\n+                let line = C_u32(bcx.ccx, loc.line as u32);\n \n                 // Put together the arguments to the panic entry point.\n                 let (lang_item, args, const_err) = match *msg {\n@@ -344,9 +344,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             })\n                         });\n \n-                        let file_line = C_struct(bcx.ccx(), &[filename, line], false);\n-                        let align = llalign_of_min(bcx.ccx(), common::val_ty(file_line));\n-                        let file_line = consts::addr_of(bcx.ccx(),\n+                        let file_line = C_struct(bcx.ccx, &[filename, line], false);\n+                        let align = llalign_of_min(bcx.ccx, common::val_ty(file_line));\n+                        let file_line = consts::addr_of(bcx.ccx,\n                                                         file_line,\n                                                         align,\n                                                         \"panic_bounds_check_loc\");\n@@ -356,12 +356,12 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     }\n                     mir::AssertMessage::Math(ref err) => {\n                         let msg_str = Symbol::intern(err.description()).as_str();\n-                        let msg_str = C_str_slice(bcx.ccx(), msg_str);\n-                        let msg_file_line = C_struct(bcx.ccx(),\n+                        let msg_str = C_str_slice(bcx.ccx, msg_str);\n+                        let msg_file_line = C_struct(bcx.ccx,\n                                                      &[msg_str, filename, line],\n                                                      false);\n-                        let align = llalign_of_min(bcx.ccx(), common::val_ty(msg_file_line));\n-                        let msg_file_line = consts::addr_of(bcx.ccx(),\n+                        let align = llalign_of_min(bcx.ccx, common::val_ty(msg_file_line));\n+                        let msg_file_line = consts::addr_of(bcx.ccx,\n                                                             msg_file_line,\n                                                             align,\n                                                             \"panic_loc\");\n@@ -385,9 +385,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                 // Obtain the panic entry point.\n                 let def_id = common::langcall(bcx.tcx(), Some(span), \"\", lang_item);\n-                let callee = Callee::def(bcx.ccx(), def_id,\n-                    bcx.ccx().empty_substs_for_def_id(def_id));\n-                let llfn = callee.reify(bcx.ccx());\n+                let callee = Callee::def(bcx.ccx, def_id,\n+                    bcx.ccx.empty_substs_for_def_id(def_id));\n+                let llfn = callee.reify(bcx.ccx);\n \n                 // Translate the actual panic invoke/call.\n                 if let Some(unwind) = cleanup {\n@@ -412,7 +412,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                 let (mut callee, abi, sig) = match callee.ty.sty {\n                     ty::TyFnDef(def_id, substs, f) => {\n-                        (Callee::def(bcx.ccx(), def_id, substs), f.abi, &f.sig)\n+                        (Callee::def(bcx.ccx, def_id, substs), f.abi, &f.sig)\n                     }\n                     ty::TyFnPtr(f) => {\n                         (Callee {\n@@ -455,7 +455,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     };\n \n                     // Double check for necessity to drop\n-                    if !bcx.ccx().shared().type_needs_drop(ty) {\n+                    if !bcx.ccx.shared().type_needs_drop(ty) {\n                         funclet_br(self, bcx, target);\n                         return;\n                     }\n@@ -467,12 +467,12 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         Ref(_) => bug!(\"Deref of by-Ref type {:?}\", ptr.ty)\n                     };\n \n-                    let drop_fn = glue::get_drop_glue(bcx.ccx(), ty);\n-                    let drop_ty = glue::get_drop_glue_type(bcx.ccx().shared(), ty);\n-                    let is_sized = bcx.ccx().shared().type_is_sized(ty);\n+                    let drop_fn = glue::get_drop_glue(bcx.ccx, ty);\n+                    let drop_ty = glue::get_drop_glue_type(bcx.ccx.shared(), ty);\n+                    let is_sized = bcx.ccx.shared().type_is_sized(ty);\n                     let llvalue = if is_sized {\n                         if drop_ty != ty {\n-                            bcx.pointercast(llval, type_of::type_of(bcx.ccx(), drop_ty).ptr_to())\n+                            bcx.pointercast(llval, type_of::type_of(bcx.ccx, drop_ty).ptr_to())\n                         } else {\n                             llval\n                         }\n@@ -518,7 +518,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     let op_ty = op_arg.ty(&self.mir, bcx.tcx());\n                     self.monomorphize(&op_ty)\n                 }).collect::<Vec<_>>();\n-                let fn_ty = callee.direct_fn_type(bcx.ccx(), &extra_args);\n+                let fn_ty = callee.direct_fn_type(bcx.ccx, &extra_args);\n \n                 // The arguments we'll be passing. Plus one to account for outptr, if used.\n                 let arg_count = fn_ty.args.len() + fn_ty.ret.is_indirect() as usize;\n@@ -579,7 +579,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let fn_ptr = match callee.data {\n                     NamedTupleConstructor(_) => {\n                         // FIXME translate this like mir::Rvalue::Aggregate.\n-                        callee.reify(bcx.ccx())\n+                        callee.reify(bcx.ccx)\n                     }\n                     Intrinsic => {\n                         use intrinsic::trans_intrinsic_call;\n@@ -673,12 +673,12 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                       callee: &mut CalleeData) {\n         if let Pair(a, b) = op.val {\n             // Treat the values in a fat pointer separately.\n-            if common::type_is_fat_ptr(bcx.ccx(), op.ty) {\n+            if common::type_is_fat_ptr(bcx.ccx, op.ty) {\n                 let (ptr, meta) = (a, b);\n                 if *next_idx == 0 {\n                     if let Virtual(idx) = *callee {\n                         let llfn = meth::get_virtual_method(bcx, meta, idx);\n-                        let llty = fn_ty.llvm_type(bcx.ccx()).ptr_to();\n+                        let llty = fn_ty.llvm_type(bcx.ccx).ptr_to();\n                         *callee = Fn(bcx.pointercast(llfn, llty));\n                     }\n                 }\n@@ -722,13 +722,13 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n         if by_ref && !arg.is_indirect() {\n             // Have to load the argument, maybe while casting it.\n-            if arg.original_ty == Type::i1(bcx.ccx()) {\n+            if arg.original_ty == Type::i1(bcx.ccx) {\n                 // We store bools as i8 so we need to truncate to i1.\n                 llval = bcx.load_range_assert(llval, 0, 2, llvm::False);\n                 llval = bcx.trunc(llval, arg.original_ty);\n             } else if let Some(ty) = arg.cast {\n                 llval = bcx.load(bcx.pointercast(llval, ty.ptr_to()));\n-                let llalign = llalign_of_min(bcx.ccx(), arg.ty);\n+                let llalign = llalign_of_min(bcx.ccx, arg.ty);\n                 unsafe {\n                     llvm::LLVMSetAlignment(llval, llalign);\n                 }\n@@ -761,7 +761,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let base = adt::MaybeSizedValue::sized(llval);\n                 for (n, &ty) in arg_types.iter().enumerate() {\n                     let ptr = adt::trans_field_ptr(bcx, tuple.ty, base, Disr(0), n);\n-                    let val = if common::type_is_fat_ptr(bcx.ccx(), ty) {\n+                    let val = if common::type_is_fat_ptr(bcx.ccx, ty) {\n                         let (lldata, llextra) = base::load_fat_ptr(bcx, ptr, ty);\n                         Pair(lldata, llextra)\n                     } else {\n@@ -777,7 +777,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n             }\n             Immediate(llval) => {\n-                let l = bcx.ccx().layout_of(tuple.ty);\n+                let l = bcx.ccx.layout_of(tuple.ty);\n                 let v = if let layout::Univariant { ref variant, .. } = *l {\n                     variant\n                 } else {\n@@ -786,8 +786,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 for (n, &ty) in arg_types.iter().enumerate() {\n                     let mut elem = bcx.extract_value(llval, v.memory_index[n] as usize);\n                     // Truncate bools to i1, if needed\n-                    if ty.is_bool() && common::val_ty(elem) != Type::i1(bcx.ccx()) {\n-                        elem = bcx.trunc(elem, Type::i1(bcx.ccx()));\n+                    if ty.is_bool() && common::val_ty(elem) != Type::i1(bcx.ccx) {\n+                        elem = bcx.trunc(elem, Type::i1(bcx.ccx));\n                     }\n                     // If the tuple is immediate, the elements are as well\n                     let op = OperandRef {\n@@ -802,8 +802,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 for (n, &ty) in arg_types.iter().enumerate() {\n                     let mut elem = elems[n];\n                     // Truncate bools to i1, if needed\n-                    if ty.is_bool() && common::val_ty(elem) != Type::i1(bcx.ccx()) {\n-                        elem = bcx.trunc(elem, Type::i1(bcx.ccx()));\n+                    if ty.is_bool() && common::val_ty(elem) != Type::i1(bcx.ccx) {\n+                        elem = bcx.trunc(elem, Type::i1(bcx.ccx));\n                     }\n                     // Pair is always made up of immediates\n                     let op = OperandRef {\n@@ -818,7 +818,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     fn get_personality_slot(&mut self, bcx: &BlockAndBuilder<'a, 'tcx>) -> ValueRef {\n-        let ccx = bcx.ccx();\n+        let ccx = bcx.ccx;\n         if let Some(slot) = self.llpersonalityslot {\n             slot\n         } else {\n@@ -847,7 +847,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         let bcx = self.fcx.build_new_block(\"cleanup\");\n         self.landing_pads[target_bb] = Some(bcx.llbb());\n \n-        let ccx = bcx.ccx();\n+        let ccx = bcx.ccx;\n         let llpersonality = self.fcx.eh_personality();\n         let llretty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)], false);\n         let llretval = bcx.landing_pad(llretty, llpersonality, 1, self.fcx.llfn);\n@@ -920,23 +920,23 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                        src: &mir::Operand<'tcx>, dst: LvalueRef<'tcx>) {\n         let mut val = self.trans_operand(bcx, src);\n         if let ty::TyFnDef(def_id, substs, _) = val.ty.sty {\n-            let llouttype = type_of::type_of(bcx.ccx(), dst.ty.to_ty(bcx.tcx()));\n-            let out_type_size = llbitsize_of_real(bcx.ccx(), llouttype);\n+            let llouttype = type_of::type_of(bcx.ccx, dst.ty.to_ty(bcx.tcx()));\n+            let out_type_size = llbitsize_of_real(bcx.ccx, llouttype);\n             if out_type_size != 0 {\n                 // FIXME #19925 Remove this hack after a release cycle.\n-                let f = Callee::def(bcx.ccx(), def_id, substs);\n+                let f = Callee::def(bcx.ccx, def_id, substs);\n                 let ty = match f.ty.sty {\n                     ty::TyFnDef(.., f) => bcx.tcx().mk_fn_ptr(f),\n                     _ => f.ty\n                 };\n                 val = OperandRef {\n-                    val: Immediate(f.reify(bcx.ccx())),\n+                    val: Immediate(f.reify(bcx.ccx)),\n                     ty: ty\n                 };\n             }\n         }\n \n-        let llty = type_of::type_of(bcx.ccx(), val.ty);\n+        let llty = type_of::type_of(bcx.ccx, val.ty);\n         let cast_ptr = bcx.pointercast(dst.llval, llty.ptr_to());\n         self.store_operand(bcx, cast_ptr, val);\n     }"}, {"sha": "08f68f8d49c78a8465ff7c5ec56d239a10e0b729", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/88202c5b838ea9f328d37f19c022eba5040e234f/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88202c5b838ea9f328d37f19c022eba5040e234f/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=88202c5b838ea9f328d37f19c022eba5040e234f", "patch": "@@ -957,27 +957,27 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::Literal::Item { def_id, substs } => {\n                 // Shortcut for zero-sized types, including function item\n                 // types, which would not work with MirConstContext.\n-                if common::type_is_zero_size(bcx.ccx(), ty) {\n-                    let llty = type_of::type_of(bcx.ccx(), ty);\n+                if common::type_is_zero_size(bcx.ccx, ty) {\n+                    let llty = type_of::type_of(bcx.ccx, ty);\n                     return Const::new(C_null(llty), ty);\n                 }\n \n                 let substs = self.monomorphize(&substs);\n                 let instance = Instance::new(def_id, substs);\n-                MirConstContext::trans_def(bcx.ccx(), instance, IndexVec::new())\n+                MirConstContext::trans_def(bcx.ccx, instance, IndexVec::new())\n             }\n             mir::Literal::Promoted { index } => {\n                 let mir = &self.mir.promoted[index];\n-                MirConstContext::new(bcx.ccx(), mir, self.param_substs, IndexVec::new()).trans()\n+                MirConstContext::new(bcx.ccx, mir, self.param_substs, IndexVec::new()).trans()\n             }\n             mir::Literal::Value { value } => {\n-                Ok(Const::from_constval(bcx.ccx(), value, ty))\n+                Ok(Const::from_constval(bcx.ccx, value, ty))\n             }\n         };\n \n         let result = result.unwrap_or_else(|_| {\n             // We've errored, so we don't have to produce working code.\n-            let llty = type_of::type_of(bcx.ccx(), ty);\n+            let llty = type_of::type_of(bcx.ccx, ty);\n             Const::new(C_undef(llty), ty)\n         });\n "}, {"sha": "980c6e678c525b74cc9c4e4ca473cd9195899a46", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/88202c5b838ea9f328d37f19c022eba5040e234f/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88202c5b838ea9f328d37f19c022eba5040e234f/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=88202c5b838ea9f328d37f19c022eba5040e234f", "patch": "@@ -74,7 +74,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         -> LvalueRef<'tcx> {\n         debug!(\"trans_lvalue(lvalue={:?})\", lvalue);\n \n-        let ccx = bcx.ccx();\n+        let ccx = bcx.ccx;\n         let tcx = bcx.tcx();\n \n         if let mir::Lvalue::Local(index) = *lvalue {\n@@ -125,7 +125,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         // Slices already point to the array element type.\n                         bcx.inbounds_gep(tr_base.llval, &[llindex])\n                     } else {\n-                        let zero = common::C_uint(bcx.ccx(), 0u64);\n+                        let zero = common::C_uint(bcx.ccx, 0u64);\n                         bcx.inbounds_gep(tr_base.llval, &[zero, llindex])\n                     };\n                     element\n@@ -162,19 +162,19 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: false,\n                                                          min_length: _ } => {\n-                        let lloffset = C_uint(bcx.ccx(), offset);\n+                        let lloffset = C_uint(bcx.ccx, offset);\n                         (project_index(lloffset), ptr::null_mut())\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: true,\n                                                          min_length: _ } => {\n-                        let lloffset = C_uint(bcx.ccx(), offset);\n-                        let lllen = tr_base.len(bcx.ccx());\n+                        let lloffset = C_uint(bcx.ccx, offset);\n+                        let lllen = tr_base.len(bcx.ccx);\n                         let llindex = bcx.sub(lllen, lloffset);\n                         (project_index(llindex), ptr::null_mut())\n                     }\n                     mir::ProjectionElem::Subslice { from, to } => {\n-                        let llindex = C_uint(bcx.ccx(), from);\n+                        let llindex = C_uint(bcx.ccx, from);\n                         let llbase = project_index(llindex);\n \n                         let base_ty = tr_base.ty.to_ty(bcx.tcx());\n@@ -183,14 +183,14 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 // must cast the lvalue pointer type to the new\n                                 // array type (*[%_; new_len]).\n                                 let base_ty = self.monomorphized_lvalue_ty(lvalue);\n-                                let llbasety = type_of::type_of(bcx.ccx(), base_ty).ptr_to();\n+                                let llbasety = type_of::type_of(bcx.ccx, base_ty).ptr_to();\n                                 let llbase = bcx.pointercast(llbase, llbasety);\n                                 (llbase, ptr::null_mut())\n                             }\n                             ty::TySlice(..) => {\n                                 assert!(tr_base.llextra != ptr::null_mut());\n                                 let lllen = bcx.sub(tr_base.llextra,\n-                                                    C_uint(bcx.ccx(), from+to));\n+                                                    C_uint(bcx.ccx, from+to));\n                                 (llbase, lllen)\n                             }\n                             _ => bug!(\"unexpected type {:?} in Subslice\", base_ty)\n@@ -235,9 +235,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     // See comments in LocalRef::new_operand as to why\n                     // we always have Some in a ZST LocalRef::Operand.\n                     let ty = self.monomorphized_lvalue_ty(lvalue);\n-                    if common::type_is_zero_size(bcx.ccx(), ty) {\n+                    if common::type_is_zero_size(bcx.ccx, ty) {\n                         // Pass an undef pointer as no stores can actually occur.\n-                        let llptr = C_undef(type_of(bcx.ccx(), ty).ptr_to());\n+                        let llptr = C_undef(type_of(bcx.ccx, ty).ptr_to());\n                         f(self, LvalueRef::new_sized(llptr, LvalueTy::from_ty(ty)))\n                     } else {\n                         bug!(\"Lvalue local already set\");\n@@ -259,9 +259,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                      llindex: ValueRef)\n                      -> ValueRef\n     {\n-        let ccx = bcx.ccx();\n-        let index_size = machine::llbitsize_of_real(bcx.ccx(), common::val_ty(llindex));\n-        let int_size = machine::llbitsize_of_real(bcx.ccx(), ccx.int_type());\n+        let ccx = bcx.ccx;\n+        let index_size = machine::llbitsize_of_real(bcx.ccx, common::val_ty(llindex));\n+        let int_size = machine::llbitsize_of_real(bcx.ccx, ccx.int_type());\n         if index_size < int_size {\n             bcx.zext(llindex, ccx.int_type())\n         } else if index_size > int_size {"}, {"sha": "93caa565817e4e7a5660d787794e19191099392c", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/88202c5b838ea9f328d37f19c022eba5040e234f/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88202c5b838ea9f328d37f19c022eba5040e234f/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=88202c5b838ea9f328d37f19c022eba5040e234f", "patch": "@@ -257,7 +257,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n \n                 if !lvalue_locals.contains(local.index()) && !dbg {\n                     debug!(\"alloc: {:?} ({}) -> operand\", local, name);\n-                    return LocalRef::new_operand(bcx.ccx(), ty);\n+                    return LocalRef::new_operand(bcx.ccx, ty);\n                 }\n \n                 debug!(\"alloc: {:?} ({}) -> lvalue\", local, name);\n@@ -283,7 +283,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n                     // alloca in advance. Instead we wait until we see the\n                     // definition and update the operand there.\n                     debug!(\"alloc: {:?} -> operand\", local);\n-                    LocalRef::new_operand(bcx.ccx(), ty)\n+                    LocalRef::new_operand(bcx.ccx, ty)\n                 }\n             }\n         };\n@@ -382,7 +382,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                 let dst = bcx.struct_gep(lltemp, i);\n                 let arg = &fcx.fn_ty.args[idx];\n                 idx += 1;\n-                if common::type_is_fat_ptr(bcx.ccx(), tupled_arg_ty) {\n+                if common::type_is_fat_ptr(bcx.ccx, tupled_arg_ty) {\n                     // We pass fat pointers as two words, but inside the tuple\n                     // they are the two sub-fields of a single aggregate field.\n                     let meta = &fcx.fn_ty.args[idx];\n@@ -431,7 +431,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                   !arg.is_indirect() && arg.cast.is_none() &&\n                   arg_scope.is_none() {\n             if arg.is_ignore() {\n-                return LocalRef::new_operand(bcx.ccx(), arg_ty);\n+                return LocalRef::new_operand(bcx.ccx, arg_ty);\n             }\n \n             // We don't have to cast or keep the argument in the alloca.\n@@ -442,7 +442,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n             }\n             let llarg = llvm::get_param(fcx.llfn, llarg_idx as c_uint);\n             llarg_idx += 1;\n-            let val = if common::type_is_fat_ptr(bcx.ccx(), arg_ty) {\n+            let val = if common::type_is_fat_ptr(bcx.ccx, arg_ty) {\n                 let meta = &fcx.fn_ty.args[idx];\n                 idx += 1;\n                 assert_eq!((meta.cast, meta.pad), (None, None));\n@@ -459,7 +459,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n             return LocalRef::Operand(Some(operand.unpack_if_pair(bcx)));\n         } else {\n             let lltemp = base::alloc_ty(&bcx, arg_ty, &format!(\"arg{}\", arg_index));\n-            if common::type_is_fat_ptr(bcx.ccx(), arg_ty) {\n+            if common::type_is_fat_ptr(bcx.ccx, arg_ty) {\n                 // we pass fat pointers as two words, but we want to\n                 // represent them internally as a pointer to two words,\n                 // so make an alloca to store them in.\n@@ -517,7 +517,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                 llval\n             };\n \n-            let layout = bcx.ccx().layout_of(closure_ty);\n+            let layout = bcx.ccx.layout_of(closure_ty);\n             let offsets = match *layout {\n                 layout::Univariant { ref variant, .. } => &variant.offsets[..],\n                 _ => bug!(\"Closures are only supposed to be Univariant\")\n@@ -526,7 +526,6 @@ fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n             for (i, (decl, ty)) in mir.upvar_decls.iter().zip(upvar_tys).enumerate() {\n                 let byte_offset_of_var_in_env = offsets[i].bytes();\n \n-\n                 let ops = unsafe {\n                     [llvm::LLVMRustDIBuilderCreateOpDeref(),\n                      llvm::LLVMRustDIBuilderCreateOpPlus(),"}, {"sha": "a15d51d9da64dcc2850bb2d03bcd87950f06df0a", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/88202c5b838ea9f328d37f19c022eba5040e234f/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88202c5b838ea9f328d37f19c022eba5040e234f/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=88202c5b838ea9f328d37f19c022eba5040e234f", "patch": "@@ -89,14 +89,14 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n                         -> OperandRef<'tcx> {\n         if let OperandValue::Pair(a, b) = self.val {\n             // Reconstruct the immediate aggregate.\n-            let llty = type_of::type_of(bcx.ccx(), self.ty);\n+            let llty = type_of::type_of(bcx.ccx, self.ty);\n             let mut llpair = common::C_undef(llty);\n             let elems = [a, b];\n             for i in 0..2 {\n                 let mut elem = elems[i];\n                 // Extend boolean i1's to i8.\n-                if common::val_ty(elem) == Type::i1(bcx.ccx()) {\n-                    elem = bcx.zext(elem, Type::i8(bcx.ccx()));\n+                if common::val_ty(elem) == Type::i1(bcx.ccx) {\n+                    elem = bcx.zext(elem, Type::i8(bcx.ccx));\n                 }\n                 llpair = bcx.insert_value(llpair, elem, i);\n             }\n@@ -111,19 +111,19 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n                           -> OperandRef<'tcx> {\n         if let OperandValue::Immediate(llval) = self.val {\n             // Deconstruct the immediate aggregate.\n-            if common::type_is_imm_pair(bcx.ccx(), self.ty) {\n+            if common::type_is_imm_pair(bcx.ccx, self.ty) {\n                 debug!(\"Operand::unpack_if_pair: unpacking {:?}\", self);\n \n                 let mut a = bcx.extract_value(llval, 0);\n                 let mut b = bcx.extract_value(llval, 1);\n \n-                let pair_fields = common::type_pair_fields(bcx.ccx(), self.ty);\n+                let pair_fields = common::type_pair_fields(bcx.ccx, self.ty);\n                 if let Some([a_ty, b_ty]) = pair_fields {\n                     if a_ty.is_bool() {\n-                        a = bcx.trunc(a, Type::i1(bcx.ccx()));\n+                        a = bcx.trunc(a, Type::i1(bcx.ccx));\n                     }\n                     if b_ty.is_bool() {\n-                        b = bcx.trunc(b, Type::i1(bcx.ccx()));\n+                        b = bcx.trunc(b, Type::i1(bcx.ccx));\n                     }\n                 }\n \n@@ -143,19 +143,19 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     {\n         debug!(\"trans_load: {:?} @ {:?}\", Value(llval), ty);\n \n-        let val = if common::type_is_fat_ptr(bcx.ccx(), ty) {\n+        let val = if common::type_is_fat_ptr(bcx.ccx, ty) {\n             let (lldata, llextra) = base::load_fat_ptr(bcx, llval, ty);\n             OperandValue::Pair(lldata, llextra)\n-        } else if common::type_is_imm_pair(bcx.ccx(), ty) {\n-            let [a_ty, b_ty] = common::type_pair_fields(bcx.ccx(), ty).unwrap();\n+        } else if common::type_is_imm_pair(bcx.ccx, ty) {\n+            let [a_ty, b_ty] = common::type_pair_fields(bcx.ccx, ty).unwrap();\n             let a_ptr = bcx.struct_gep(llval, 0);\n             let b_ptr = bcx.struct_gep(llval, 1);\n \n             OperandValue::Pair(\n                 base::load_ty(bcx, a_ptr, a_ty),\n                 base::load_ty(bcx, b_ptr, b_ty)\n             )\n-        } else if common::type_is_immediate(bcx.ccx(), ty) {\n+        } else if common::type_is_immediate(bcx.ccx, ty) {\n             OperandValue::Immediate(base::load_ty(bcx, llval, ty))\n         } else {\n             OperandValue::Ref(llval)\n@@ -230,7 +230,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n             mir::Operand::Constant(ref constant) => {\n                 let val = self.trans_constant(bcx, constant);\n-                let operand = val.to_operand(bcx.ccx());\n+                let operand = val.to_operand(bcx.ccx);\n                 if let OperandValue::Ref(ptr) = operand.val {\n                     // If this is a OperandValue::Ref to an immediate constant, load it.\n                     self.trans_load(bcx, ptr, operand.ty)\n@@ -248,7 +248,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         debug!(\"store_operand: operand={:?}\", operand);\n         // Avoid generating stores of zero-sized values, because the only way to have a zero-sized\n         // value is through `undef`, and store itself is useless.\n-        if common::type_is_zero_size(bcx.ccx(), operand.ty) {\n+        if common::type_is_zero_size(bcx.ccx, operand.ty) {\n             return;\n         }\n         match operand.val {"}, {"sha": "0bca8429d22b24c2fe93f3a9769e78253dd314d4", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/88202c5b838ea9f328d37f19c022eba5040e234f/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88202c5b838ea9f328d37f19c022eba5040e234f/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=88202c5b838ea9f328d37f19c022eba5040e234f", "patch": "@@ -55,7 +55,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::Rvalue::Cast(mir::CastKind::Unsize, ref source, cast_ty) => {\n                 let cast_ty = self.monomorphize(&cast_ty);\n \n-                if common::type_is_fat_ptr(bcx.ccx(), cast_ty) {\n+                if common::type_is_fat_ptr(bcx.ccx, cast_ty) {\n                     // into-coerce of a thin pointer to a fat pointer - just\n                     // use the operand path.\n                     let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n@@ -97,7 +97,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::Rvalue::Repeat(ref elem, ref count) => {\n                 let tr_elem = self.trans_operand(&bcx, elem);\n                 let size = count.value.as_u64(bcx.tcx().sess.target.uint_type);\n-                let size = C_uint(bcx.ccx(), size);\n+                let size = C_uint(bcx.ccx, size);\n                 let base = base::get_dataptr(&bcx, dest.llval);\n                 tvec::slice_for_each(&bcx, base, tr_elem.ty, size, |bcx, llslot| {\n                     self.store_operand(&bcx, llslot, tr_elem);\n@@ -113,7 +113,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         for (i, operand) in operands.iter().enumerate() {\n                             let op = self.trans_operand(&bcx, operand);\n                             // Do not generate stores and GEPis for zero-sized fields.\n-                            if !common::type_is_zero_size(bcx.ccx(), op.ty) {\n+                            if !common::type_is_zero_size(bcx.ccx, op.ty) {\n                                 let val = adt::MaybeSizedValue::sized(dest.llval);\n                                 let field_index = active_field_index.unwrap_or(i);\n                                 let lldest_i = adt::trans_field_ptr(&bcx, dest_ty, val, disr,\n@@ -124,7 +124,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     },\n                     _ => {\n                         // If this is a tuple or closure, we need to translate GEP indices.\n-                        let layout = bcx.ccx().layout_of(dest.ty.to_ty(bcx.tcx()));\n+                        let layout = bcx.ccx.layout_of(dest.ty.to_ty(bcx.tcx()));\n                         let translation = if let Layout::Univariant { ref variant, .. } = *layout {\n                             Some(&variant.memory_index)\n                         } else {\n@@ -133,7 +133,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         for (i, operand) in operands.iter().enumerate() {\n                             let op = self.trans_operand(&bcx, operand);\n                             // Do not generate stores and GEPis for zero-sized fields.\n-                            if !common::type_is_zero_size(bcx.ccx(), op.ty) {\n+                            if !common::type_is_zero_size(bcx.ccx, op.ty) {\n                                 // Note: perhaps this should be StructGep, but\n                                 // note that in some cases the values here will\n                                 // not be structs but arrays.\n@@ -192,8 +192,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         match operand.ty.sty {\n                             ty::TyFnDef(def_id, substs, _) => {\n                                 OperandValue::Immediate(\n-                                    Callee::def(bcx.ccx(), def_id, substs)\n-                                        .reify(bcx.ccx()))\n+                                    Callee::def(bcx.ccx, def_id, substs)\n+                                        .reify(bcx.ccx))\n                             }\n                             _ => {\n                                 bug!(\"{} cannot be reified to a fn ptr\", operand.ty)\n@@ -207,7 +207,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     mir::CastKind::Unsize => {\n                         // unsize targets other than to a fat pointer currently\n                         // can't be operands.\n-                        assert!(common::type_is_fat_ptr(bcx.ccx(), cast_ty));\n+                        assert!(common::type_is_fat_ptr(bcx.ccx, cast_ty));\n \n                         match operand.val {\n                             OperandValue::Pair(lldata, llextra) => {\n@@ -217,7 +217,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 //   &'a fmt::Debug+Send => &'a fmt::Debug,\n                                 // So we need to pointercast the base to ensure\n                                 // the types match up.\n-                                let llcast_ty = type_of::fat_ptr_base_ty(bcx.ccx(), cast_ty);\n+                                let llcast_ty = type_of::fat_ptr_base_ty(bcx.ccx, cast_ty);\n                                 let lldata = bcx.pointercast(lldata, llcast_ty);\n                                 OperandValue::Pair(lldata, llextra)\n                             }\n@@ -233,11 +233,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             }\n                         }\n                     }\n-                    mir::CastKind::Misc if common::type_is_fat_ptr(bcx.ccx(), operand.ty) => {\n-                        let ll_cast_ty = type_of::immediate_type_of(bcx.ccx(), cast_ty);\n-                        let ll_from_ty = type_of::immediate_type_of(bcx.ccx(), operand.ty);\n+                    mir::CastKind::Misc if common::type_is_fat_ptr(bcx.ccx, operand.ty) => {\n+                        let ll_cast_ty = type_of::immediate_type_of(bcx.ccx, cast_ty);\n+                        let ll_from_ty = type_of::immediate_type_of(bcx.ccx, operand.ty);\n                         if let OperandValue::Pair(data_ptr, meta_ptr) = operand.val {\n-                            if common::type_is_fat_ptr(bcx.ccx(), cast_ty) {\n+                            if common::type_is_fat_ptr(bcx.ccx, cast_ty) {\n                                 let ll_cft = ll_cast_ty.field_types();\n                                 let ll_fft = ll_from_ty.field_types();\n                                 let data_cast = bcx.pointercast(data_ptr, ll_cft[0]);\n@@ -254,13 +254,13 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         }\n                     }\n                     mir::CastKind::Misc => {\n-                        debug_assert!(common::type_is_immediate(bcx.ccx(), cast_ty));\n+                        debug_assert!(common::type_is_immediate(bcx.ccx, cast_ty));\n                         let r_t_in = CastTy::from_ty(operand.ty).expect(\"bad input type for cast\");\n                         let r_t_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n-                        let ll_t_in = type_of::immediate_type_of(bcx.ccx(), operand.ty);\n-                        let ll_t_out = type_of::immediate_type_of(bcx.ccx(), cast_ty);\n+                        let ll_t_in = type_of::immediate_type_of(bcx.ccx, operand.ty);\n+                        let ll_t_out = type_of::immediate_type_of(bcx.ccx, cast_ty);\n                         let (llval, signed) = if let CastTy::Int(IntTy::CEnum) = r_t_in {\n-                            let l = bcx.ccx().layout_of(operand.ty);\n+                            let l = bcx.ccx.layout_of(operand.ty);\n                             let discr = match operand.val {\n                                 OperandValue::Immediate(llval) => llval,\n                                 OperandValue::Ref(llptr) => {\n@@ -357,7 +357,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                 // Note: lvalues are indirect, so storing the `llval` into the\n                 // destination effectively creates a reference.\n-                let operand = if bcx.ccx().shared().type_is_sized(ty) {\n+                let operand = if bcx.ccx.shared().type_is_sized(ty) {\n                     OperandRef {\n                         val: OperandValue::Immediate(tr_lvalue.llval),\n                         ty: ref_ty,\n@@ -375,7 +375,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::Rvalue::Len(ref lvalue) => {\n                 let tr_lvalue = self.trans_lvalue(&bcx, lvalue);\n                 let operand = OperandRef {\n-                    val: OperandValue::Immediate(tr_lvalue.len(bcx.ccx())),\n+                    val: OperandValue::Immediate(tr_lvalue.len(bcx.ccx)),\n                     ty: bcx.tcx().types.usize,\n                 };\n                 (bcx, operand)\n@@ -384,7 +384,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::Rvalue::BinaryOp(op, ref lhs, ref rhs) => {\n                 let lhs = self.trans_operand(&bcx, lhs);\n                 let rhs = self.trans_operand(&bcx, rhs);\n-                let llresult = if common::type_is_fat_ptr(bcx.ccx(), lhs.ty) {\n+                let llresult = if common::type_is_fat_ptr(bcx.ccx, lhs.ty) {\n                     match (lhs.val, rhs.val) {\n                         (OperandValue::Pair(lhs_addr, lhs_extra),\n                          OperandValue::Pair(rhs_addr, rhs_extra)) => {\n@@ -443,10 +443,10 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n             mir::Rvalue::Box(content_ty) => {\n                 let content_ty: Ty<'tcx> = self.monomorphize(&content_ty);\n-                let llty = type_of::type_of(bcx.ccx(), content_ty);\n-                let llsize = machine::llsize_of(bcx.ccx(), llty);\n-                let align = type_of::align_of(bcx.ccx(), content_ty);\n-                let llalign = C_uint(bcx.ccx(), align);\n+                let llty = type_of::type_of(bcx.ccx, content_ty);\n+                let llsize = machine::llsize_of(bcx.ccx, llty);\n+                let align = type_of::align_of(bcx.ccx, content_ty);\n+                let llalign = C_uint(bcx.ccx, align);\n                 let llty_ptr = llty.ptr_to();\n                 let box_ty = bcx.tcx().mk_box(content_ty);\n \n@@ -457,8 +457,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         bcx.sess().fatal(&format!(\"allocation of `{}` {}\", box_ty, s));\n                     }\n                 };\n-                let r = Callee::def(bcx.ccx(), def_id, bcx.tcx().intern_substs(&[]))\n-                    .reify(bcx.ccx());\n+                let r = Callee::def(bcx.ccx, def_id, bcx.tcx().intern_substs(&[]))\n+                    .reify(bcx.ccx);\n                 let val = bcx.pointercast(bcx.call(r, &[llsize, llalign], None), llty_ptr);\n \n                 let operand = OperandRef {\n@@ -528,7 +528,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::BinOp::Shr => common::build_unchecked_rshift(bcx, input_ty, lhs, rhs),\n             mir::BinOp::Ne | mir::BinOp::Lt | mir::BinOp::Gt |\n             mir::BinOp::Eq | mir::BinOp::Le | mir::BinOp::Ge => if is_nil {\n-                C_bool(bcx.ccx(), match op {\n+                C_bool(bcx.ccx, match op {\n                     mir::BinOp::Ne | mir::BinOp::Lt | mir::BinOp::Gt => false,\n                     mir::BinOp::Eq | mir::BinOp::Le | mir::BinOp::Ge => true,\n                     _ => unreachable!()\n@@ -542,8 +542,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let (lhs, rhs) = if is_bool {\n                     // FIXME(#36856) -- extend the bools into `i8` because\n                     // LLVM's i1 comparisons are broken.\n-                    (bcx.zext(lhs, Type::i8(bcx.ccx())),\n-                     bcx.zext(rhs, Type::i8(bcx.ccx())))\n+                    (bcx.zext(lhs, Type::i8(bcx.ccx)),\n+                     bcx.zext(rhs, Type::i8(bcx.ccx)))\n                 } else {\n                     (lhs, rhs)\n                 };\n@@ -613,17 +613,17 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         // with #[rustc_inherit_overflow_checks] and inlined from\n         // another crate (mostly core::num generic/#[inline] fns),\n         // while the current crate doesn't use overflow checks.\n-        if !bcx.ccx().check_overflow() {\n+        if !bcx.ccx.check_overflow() {\n             let val = self.trans_scalar_binop(bcx, op, lhs, rhs, input_ty);\n-            return OperandValue::Pair(val, C_bool(bcx.ccx(), false));\n+            return OperandValue::Pair(val, C_bool(bcx.ccx, false));\n         }\n \n         // First try performing the operation on constants, which\n         // will only succeed if both operands are constant.\n         // This is necessary to determine when an overflow Assert\n         // will always panic at runtime, and produce a warning.\n         if let Some((val, of)) = const_scalar_checked_binop(bcx.tcx(), op, lhs, rhs, input_ty) {\n-            return OperandValue::Pair(val, C_bool(bcx.ccx(), of));\n+            return OperandValue::Pair(val, C_bool(bcx.ccx, of));\n         }\n \n         let (val, of) = match op {\n@@ -752,5 +752,5 @@ fn get_overflow_intrinsic(oop: OverflowOp, bcx: &BlockAndBuilder, ty: Ty) -> Val\n         },\n     };\n \n-    bcx.ccx().get_intrinsic(&name)\n+    bcx.ccx.get_intrinsic(&name)\n }"}, {"sha": "cc85f68c197ec34551df74a1742b7d171ddf5bc5", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88202c5b838ea9f328d37f19c022eba5040e234f/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88202c5b838ea9f328d37f19c022eba5040e234f/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=88202c5b838ea9f328d37f19c022eba5040e234f", "patch": "@@ -41,7 +41,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         LocalRef::Operand(Some(_)) => {\n                             let ty = self.monomorphized_lvalue_ty(lvalue);\n \n-                            if !common::type_is_zero_size(bcx.ccx(), ty) {\n+                            if !common::type_is_zero_size(bcx.ccx, ty) {\n                                 span_bug!(statement.source_info.span,\n                                           \"operand {:?} already assigned\",\n                                           rvalue);"}, {"sha": "c09726fda081028c6d48b71d8f9cdecdcf6ad624", "filename": "src/librustc_trans/tvec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/88202c5b838ea9f328d37f19c022eba5040e234f/src%2Flibrustc_trans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88202c5b838ea9f328d37f19c022eba5040e234f/src%2Flibrustc_trans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftvec.rs?ref=88202c5b838ea9f328d37f19c022eba5040e234f", "patch": "@@ -21,7 +21,7 @@ pub fn slice_for_each<'a, 'tcx, F>(\n     f: F\n ) -> BlockAndBuilder<'a, 'tcx> where F: FnOnce(&BlockAndBuilder<'a, 'tcx>, ValueRef) {\n     // Special-case vectors with elements of size 0  so they don't go out of bounds (#9890)\n-    let zst = type_is_zero_size(bcx.ccx(), unit_ty);\n+    let zst = type_is_zero_size(bcx.ccx, unit_ty);\n     let add = |bcx: &BlockAndBuilder, a, b| if zst {\n         bcx.add(a, b)\n     } else {\n@@ -33,7 +33,7 @@ pub fn slice_for_each<'a, 'tcx, F>(\n     let header_bcx = bcx.fcx().build_new_block(\"slice_loop_header\");\n \n     let start = if zst {\n-        C_uint(bcx.ccx(), 0usize)\n+        C_uint(bcx.ccx, 0usize)\n     } else {\n         data_ptr\n     };\n@@ -46,7 +46,7 @@ pub fn slice_for_each<'a, 'tcx, F>(\n     header_bcx.cond_br(keep_going, body_bcx.llbb(), next_bcx.llbb());\n \n     f(&body_bcx, if zst { data_ptr } else { current });\n-    let next = add(&body_bcx, current, C_uint(bcx.ccx(), 1usize));\n+    let next = add(&body_bcx, current, C_uint(bcx.ccx, 1usize));\n     header_bcx.add_incoming_to_phi(current, next, body_bcx.llbb());\n     body_bcx.br(header_bcx.llbb());\n     next_bcx"}]}