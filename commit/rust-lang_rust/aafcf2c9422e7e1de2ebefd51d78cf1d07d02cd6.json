{"sha": "aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhZmNmMmM5NDIyZTdlMWRlMmViZWZkNTFkNzhjZjFkMDdkMDJjZDY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-24T09:47:17Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-29T08:05:18Z"}, "message": "Emit Retag statements, kill Validate statements\n\nAlso \"rename\" -Zmir-emit-validate to -Zmir-emit-retag, which is just a boolean (yes or no).", "tree": {"sha": "8a2704a03646d186d81c7de32e79a981f3567bd1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a2704a03646d186d81c7de32e79a981f3567bd1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6", "html_url": "https://github.com/rust-lang/rust/commit/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e88b7363b7858960ccfd87326ece9d00bf4d973", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e88b7363b7858960ccfd87326ece9d00bf4d973", "html_url": "https://github.com/rust-lang/rust/commit/4e88b7363b7858960ccfd87326ece9d00bf4d973"}], "stats": {"total": 776, "additions": 233, "deletions": 543}, "files": [{"sha": "07a05aeae5d642d5c178a0b077f9a41602488491", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6", "patch": "@@ -254,7 +254,12 @@ fn main() {\n         // When running miri tests, we need to generate MIR for all libraries\n         if env::var(\"TEST_MIRI\").ok().map_or(false, |val| val == \"true\") {\n             cmd.arg(\"-Zalways-encode-mir\");\n-            cmd.arg(\"-Zmir-emit-validate=1\");\n+            // These options are preferred by miri, to be able to perform better validation,\n+            // but the bootstrap compiler might not understand them.\n+            if stage != \"0\" {\n+                cmd.arg(\"-Zmir-emit-retag\");\n+                cmd.arg(\"-Zmir-opt-level=0\");\n+            }\n         }\n \n         // Force all crates compiled by this compiler to (a) be unstable and (b)"}, {"sha": "a73fe2b8a1ab31e6535a7059bce266a338d6cba1", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6", "patch": "@@ -257,9 +257,9 @@ for mir::StatementKind<'gcx> {\n             mir::StatementKind::EndRegion(ref region_scope) => {\n                 region_scope.hash_stable(hcx, hasher);\n             }\n-            mir::StatementKind::Validate(ref op, ref places) => {\n-                op.hash_stable(hcx, hasher);\n-                places.hash_stable(hcx, hasher);\n+            mir::StatementKind::Retag { fn_entry, ref place } => {\n+                fn_entry.hash_stable(hcx, hasher);\n+                place.hash_stable(hcx, hasher);\n             }\n             mir::StatementKind::AscribeUserType(ref place, ref variance, ref c_ty) => {\n                 place.hash_stable(hcx, hasher);\n@@ -278,23 +278,6 @@ for mir::StatementKind<'gcx> {\n \n impl_stable_hash_for!(enum mir::FakeReadCause { ForMatchGuard, ForMatchedPlace, ForLet });\n \n-impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>>\n-    for mir::ValidationOperand<'gcx, T>\n-    where T: HashStable<StableHashingContext<'a>>\n-{\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>)\n-    {\n-        self.place.hash_stable(hcx, hasher);\n-        self.ty.hash_stable(hcx, hasher);\n-        self.re.hash_stable(hcx, hasher);\n-        self.mutbl.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl_stable_hash_for!(enum mir::ValidationOp { Acquire, Release, Suspend(region_scope) });\n-\n impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::Place<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,"}, {"sha": "4f6a8158933afbf280e525b2150ccfa626f9919c", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 10, "deletions": 64, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6", "patch": "@@ -1754,10 +1754,13 @@ pub enum StatementKind<'tcx> {\n         inputs: Box<[Operand<'tcx>]>,\n     },\n \n-    /// Assert the given places to be valid inhabitants of their type.  These statements are\n-    /// currently only interpreted by miri and only generated when \"-Z mir-emit-validate\" is passed.\n-    /// See <https://internals.rust-lang.org/t/types-as-contracts/5562/73> for more details.\n-    Validate(ValidationOp, Vec<ValidationOperand<'tcx, Place<'tcx>>>),\n+    /// Retag references in the given place, ensuring they got fresh tags.  This is\n+    /// part of the Stacked Borrows model. `fn_entry` indicates whether this\n+    /// is the initial retag that happens in the function prolog. These statements are\n+    /// currently only interpreted by miri and only generated when \"-Z mir-emit-retag\" is passed.\n+    /// See <https://internals.rust-lang.org/t/stacked-borrows-an-aliasing-model-for-rust/8153/>\n+    /// for more details.\n+    Retag { fn_entry: bool, place: Place<'tcx> },\n \n     /// Mark one terminating point of a region scope (i.e. static region).\n     /// (The starting point(s) arise implicitly from borrows.)\n@@ -1810,57 +1813,6 @@ pub enum FakeReadCause {\n     ForLet,\n }\n \n-/// The `ValidationOp` describes what happens with each of the operands of a\n-/// `Validate` statement.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, PartialEq, Eq)]\n-pub enum ValidationOp {\n-    /// Recursively traverse the place following the type and validate that all type\n-    /// invariants are maintained.  Furthermore, acquire exclusive/read-only access to the\n-    /// memory reachable from the place.\n-    Acquire,\n-    /// Recursive traverse the *mutable* part of the type and relinquish all exclusive\n-    /// access.\n-    Release,\n-    /// Recursive traverse the *mutable* part of the type and relinquish all exclusive\n-    /// access *until* the given region ends.  Then, access will be recovered.\n-    Suspend(region::Scope),\n-}\n-\n-impl Debug for ValidationOp {\n-    fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n-        use self::ValidationOp::*;\n-        match *self {\n-            Acquire => write!(fmt, \"Acquire\"),\n-            Release => write!(fmt, \"Release\"),\n-            // (reuse lifetime rendering policy from ppaux.)\n-            Suspend(ref ce) => write!(fmt, \"Suspend({})\", ty::ReScope(*ce)),\n-        }\n-    }\n-}\n-\n-// This is generic so that it can be reused by miri\n-#[derive(Clone, Hash, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n-pub struct ValidationOperand<'tcx, T> {\n-    pub place: T,\n-    pub ty: Ty<'tcx>,\n-    pub re: Option<region::Scope>,\n-    pub mutbl: hir::Mutability,\n-}\n-\n-impl<'tcx, T: Debug> Debug for ValidationOperand<'tcx, T> {\n-    fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n-        write!(fmt, \"{:?}: {:?}\", self.place, self.ty)?;\n-        if let Some(ce) = self.re {\n-            // (reuse lifetime rendering policy from ppaux.)\n-            write!(fmt, \"/{}\", ty::ReScope(ce))?;\n-        }\n-        if let hir::MutImmutable = self.mutbl {\n-            write!(fmt, \" (imm)\")?;\n-        }\n-        Ok(())\n-    }\n-}\n-\n impl<'tcx> Debug for Statement<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n         use self::StatementKind::*;\n@@ -1869,7 +1821,8 @@ impl<'tcx> Debug for Statement<'tcx> {\n             FakeRead(ref cause, ref place) => write!(fmt, \"FakeRead({:?}, {:?})\", cause, place),\n             // (reuse lifetime rendering policy from ppaux.)\n             EndRegion(ref ce) => write!(fmt, \"EndRegion({})\", ty::ReScope(*ce)),\n-            Validate(ref op, ref places) => write!(fmt, \"Validate({:?}, {:?})\", op, places),\n+            Retag { fn_entry, ref place } =>\n+                write!(fmt, \"Retag({}{:?})\", if fn_entry { \"[fn entry]: \" } else { \"\" }, place),\n             StorageLive(ref place) => write!(fmt, \"StorageLive({:?})\", place),\n             StorageDead(ref place) => write!(fmt, \"StorageDead({:?})\", place),\n             SetDiscriminant {\n@@ -2944,7 +2897,6 @@ CloneTypeFoldableAndLiftImpls! {\n     SourceInfo,\n     UpvarDecl,\n     FakeReadCause,\n-    ValidationOp,\n     SourceScope,\n     SourceScopeData,\n     SourceScopeLocalData,\n@@ -2997,12 +2949,6 @@ BraceStructTypeFoldableImpl! {\n     }\n }\n \n-BraceStructTypeFoldableImpl! {\n-    impl<'tcx> TypeFoldable<'tcx> for ValidationOperand<'tcx, Place<'tcx>> {\n-        place, ty, re, mutbl\n-    }\n-}\n-\n BraceStructTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for Statement<'tcx> {\n         source_info, kind\n@@ -3017,7 +2963,7 @@ EnumTypeFoldableImpl! {\n         (StatementKind::StorageLive)(a),\n         (StatementKind::StorageDead)(a),\n         (StatementKind::InlineAsm) { asm, outputs, inputs },\n-        (StatementKind::Validate)(a, b),\n+        (StatementKind::Retag) { fn_entry, place },\n         (StatementKind::EndRegion)(a),\n         (StatementKind::AscribeUserType)(a, v, b),\n         (StatementKind::Nop),"}, {"sha": "d60fff18b948229396a5e6e5b457348eb1110631", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6", "patch": "@@ -371,16 +371,12 @@ macro_rules! make_mir_visitor {\n                         );\n                     }\n                     StatementKind::EndRegion(_) => {}\n-                    StatementKind::Validate(_, ref $($mutability)* places) => {\n-                        for operand in places {\n-                            self.visit_place(\n-                                & $($mutability)* operand.place,\n-                                PlaceContext::NonUse(NonUseContext::Validate),\n-                                location\n-                            );\n-                            self.visit_ty(& $($mutability)* operand.ty,\n-                                          TyContext::Location(location));\n-                        }\n+                    StatementKind::Retag { fn_entry: _, ref $($mutability)* place } => {\n+                        self.visit_place(\n+                            place,\n+                            PlaceContext::MutatingUse(MutatingUseContext::Retag),\n+                            location,\n+                        );\n                     }\n                     StatementKind::SetDiscriminant{ ref $($mutability)* place, .. } => {\n                         self.visit_place(\n@@ -1010,6 +1006,8 @@ pub enum MutatingUseContext<'tcx> {\n     ///     f(&mut x.y);\n     ///\n     Projection,\n+    /// Retagging (updating the \"Stacked Borrows\" tag)\n+    Retag,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n@@ -1020,8 +1018,6 @@ pub enum NonUseContext {\n     StorageDead,\n     /// User type annotation assertions for NLL.\n     AscribeUserTy,\n-    /// Validation command.\n-    Validate,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]"}, {"sha": "76200777584012a60666a7d654ba7bd4e1dafbf5", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6", "patch": "@@ -1282,9 +1282,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"in addition to `.mir` files, create graphviz `.dot` files\"),\n     dump_mir_exclude_pass_number: bool = (false, parse_bool, [UNTRACKED],\n         \"if set, exclude the pass number when dumping MIR (used in tests)\"),\n-    mir_emit_validate: usize = (0, parse_uint, [TRACKED],\n-        \"emit Validate MIR statements, interpreted e.g. by miri (0: do not emit; 1: if function \\\n-         contains unsafe block, only validate arguments; 2: always emit full validation)\"),\n+    mir_emit_retag: bool = (false, parse_bool, [TRACKED],\n+        \"emit Retagging MIR statements, interpreted e.g. by miri; implies -Zmir-opt-level=0\"),\n     perf_stats: bool = (false, parse_bool, [UNTRACKED],\n         \"print some performance-related statistics\"),\n     hir_stats: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "409665e47774529149696bc7423e70df2f0bf0b0", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6", "patch": "@@ -1547,11 +1547,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Should we emit EndRegion MIR statements? These are consumed by\n-    /// MIR borrowck, but not when NLL is used. They are also consumed\n-    /// by the validation stuff.\n+    /// MIR borrowck, but not when NLL is used.\n     pub fn emit_end_regions(self) -> bool {\n         self.sess.opts.debugging_opts.emit_end_regions ||\n-            self.sess.opts.debugging_opts.mir_emit_validate > 0 ||\n             self.use_mir_borrowck()\n     }\n "}, {"sha": "a93c6faaf7ba927658a0c6c030bc1b59d24e8ccf", "filename": "src/librustc_codegen_llvm/mir/analyze.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs?ref=aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6", "patch": "@@ -219,7 +219,8 @@ impl Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'll, 'tcx> {\n                 self.assign(local, location);\n             }\n \n-            PlaceContext::NonUse(_) => {}\n+            PlaceContext::NonUse(_) |\n+            PlaceContext::MutatingUse(MutatingUseContext::Retag) => {}\n \n             PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) |\n             PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) => {"}, {"sha": "cc4e64e07881df684b48afc4c4f8b9dc385ef0a6", "filename": "src/librustc_codegen_llvm/mir/statement.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs?ref=aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6", "patch": "@@ -109,7 +109,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n             }\n             mir::StatementKind::FakeRead(..) |\n             mir::StatementKind::EndRegion(_) |\n-            mir::StatementKind::Validate(..) |\n+            mir::StatementKind::Retag { .. } |\n             mir::StatementKind::AscribeUserType(..) |\n             mir::StatementKind::Nop => bx,\n         }"}, {"sha": "25e8b4ba7220f76990f4145003f12e802c908b91", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6", "patch": "@@ -574,9 +574,9 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n             }\n             StatementKind::Nop\n             | StatementKind::AscribeUserType(..)\n-            | StatementKind::Validate(..)\n+            | StatementKind::Retag { .. }\n             | StatementKind::StorageLive(..) => {\n-                // `Nop`, `AscribeUserType`, `Validate`, and `StorageLive` are irrelevant\n+                // `Nop`, `AscribeUserType`, `Retag`, and `StorageLive` are irrelevant\n                 // to borrow check.\n             }\n             StatementKind::StorageDead(local) => {"}, {"sha": "0d0f5a60ed41486c8799b943cecab9878acdf142", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6", "patch": "@@ -136,9 +136,9 @@ impl<'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx, 'gcx> {\n             StatementKind::EndRegion(..) |\n             StatementKind::Nop |\n             StatementKind::AscribeUserType(..) |\n-            StatementKind::Validate(..) |\n+            StatementKind::Retag { .. } |\n             StatementKind::StorageLive(..) => {\n-                // `Nop`, `AscribeUserType`, `Validate`, and `StorageLive` are irrelevant\n+                // `Nop`, `AscribeUserType`, `Retag`, and `StorageLive` are irrelevant\n                 // to borrow check.\n             }\n             StatementKind::StorageDead(local) => {"}, {"sha": "c4eac2c9341dc520f50a6821a23190d5df4f75de", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6", "patch": "@@ -1264,7 +1264,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             | StatementKind::StorageDead(_)\n             | StatementKind::InlineAsm { .. }\n             | StatementKind::EndRegion(_)\n-            | StatementKind::Validate(..)\n+            | StatementKind::Retag { .. }\n             | StatementKind::Nop => {}\n         }\n     }"}, {"sha": "69d2a89b5f237216732664bcfa033788c2275dae", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6", "patch": "@@ -338,7 +338,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n             mir::StatementKind::FakeRead(..) |\n             mir::StatementKind::SetDiscriminant { .. } |\n             mir::StatementKind::StorageLive(..) |\n-            mir::StatementKind::Validate(..) |\n+            mir::StatementKind::Retag { .. } |\n             mir::StatementKind::AscribeUserType(..) |\n             mir::StatementKind::Nop => {}\n "}, {"sha": "968e39cc3d156872dc2e3c2550f13eaf646f15b4", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6", "patch": "@@ -302,7 +302,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n                           \"SetDiscriminant should not exist during borrowck\");\n             }\n             StatementKind::EndRegion(_) |\n-            StatementKind::Validate(..) |\n+            StatementKind::Retag { .. } |\n             StatementKind::AscribeUserType(..) |\n             StatementKind::Nop => {}\n         }"}, {"sha": "5a5002dece5ab6790e868ccca4a924c9f64519b4", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6", "patch": "@@ -242,10 +242,10 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n \n     /// Execute a validation operation\n     #[inline]\n-    fn validation_op(\n+    fn retag(\n         _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        _op: ::rustc::mir::ValidationOp,\n-        _operand: &::rustc::mir::ValidationOperand<'tcx, ::rustc::mir::Place<'tcx>>,\n+        _fn_entry: bool,\n+        _place: PlaceTy<'tcx, Self::PointerTag>,\n     ) -> EvalResult<'tcx> {\n         Ok(())\n     }"}, {"sha": "80b9948f612e498f96aa216e0917709e859ceff6", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6", "patch": "@@ -118,11 +118,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             // interpreter is solely intended for borrowck'ed code.\n             FakeRead(..) => {}\n \n-            // Validity checks.\n-            Validate(op, ref places) => {\n-                for operand in places {\n-                    M::validation_op(self, op, operand)?;\n-                }\n+            // Retagging.\n+            Retag { fn_entry, ref place } => {\n+                let dest = self.eval_place(place)?;\n+                M::retag(self, fn_entry, dest)?;\n             }\n \n             EndRegion(..) => {}"}, {"sha": "0f16e29aae904364ae8a5d2861b3a739333c9fa2", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6", "patch": "@@ -0,0 +1,169 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This pass adds validation calls (AcquireValid, ReleaseValid) where appropriate.\n+//! It has to be run really early, before transformations like inlining, because\n+//! introducing these calls *adds* UB -- so, conceptually, this pass is actually part\n+//! of MIR building, and only after this pass we think of the program has having the\n+//! normal MIR semantics.\n+\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::mir::*;\n+use transform::{MirPass, MirSource};\n+\n+pub struct AddRetag;\n+\n+/// Determines whether this place is local: If it is part of a local variable.\n+/// We do not consider writes to pointers local, only writes that immediately assign\n+/// to a local variable.\n+/// One important property here is that evaluating the place immediately after\n+/// the assignment must produce the same place as what was used during the assignment.\n+fn is_local<'tcx>(\n+    place: &Place<'tcx>,\n+) -> bool {\n+    use rustc::mir::Place::*;\n+\n+    match *place {\n+        Local { .. } => true,\n+        Promoted(_) |\n+        Static(_) => false,\n+        Projection(ref proj) => {\n+            match proj.elem {\n+                ProjectionElem::Deref |\n+                ProjectionElem::Index(_) =>\n+                    // Which place these point to depends on external circumstances\n+                    // (a local storing the array index, the current value of\n+                    // the projection base), so we stop tracking here.\n+                    false,\n+                _ => is_local(&proj.base),\n+            }\n+        }\n+    }\n+}\n+\n+/// Determine whether this type has a reference in it, recursing below compound types but\n+/// not below references.\n+fn has_reference<'a, 'gcx, 'tcx>(ty: Ty<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n+    match ty.sty {\n+        // Primitive types that are not references\n+        ty::Bool | ty::Char |\n+        ty::Float(_) | ty::Int(_) | ty::Uint(_) |\n+        ty::RawPtr(..) | ty::FnPtr(..) |\n+        ty::Str | ty::FnDef(..) | ty::Never =>\n+            false,\n+        // References\n+        ty::Ref(..) => true,\n+        ty::Adt(..) if ty.is_box() => true,\n+        // Compound types\n+        ty::Array(ty, ..) | ty::Slice(ty) =>\n+            has_reference(ty, tcx),\n+        ty::Tuple(tys) =>\n+            tys.iter().any(|ty| has_reference(ty, tcx)),\n+        ty::Adt(adt, substs) =>\n+            adt.variants.iter().any(|v| v.fields.iter().any(|f|\n+                has_reference(f.ty(tcx, substs), tcx)\n+            )),\n+        // Conservative fallback\n+        _ => true,\n+    }\n+}\n+\n+impl MirPass for AddRetag {\n+    fn run_pass<'a, 'tcx>(&self,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          _src: MirSource,\n+                          mir: &mut Mir<'tcx>)\n+    {\n+        if !tcx.sess.opts.debugging_opts.mir_emit_retag {\n+            return;\n+        }\n+        let (span, arg_count) = (mir.span, mir.arg_count);\n+        let (basic_blocks, local_decls) = mir.basic_blocks_and_local_decls_mut();\n+        let needs_retag = |place: &Place<'tcx>| {\n+            is_local(place) && has_reference(place.ty(&*local_decls, tcx).to_ty(tcx), tcx)\n+        };\n+\n+        // PART 1\n+        // Retag arguments at the beginning of the start block.\n+        {\n+            let source_info = SourceInfo {\n+                scope: OUTERMOST_SOURCE_SCOPE,\n+                span: span, // FIXME: Consider using just the span covering the function\n+                            // argument declaration.\n+            };\n+            // Gather all arguments, skip return value.\n+            let places = local_decls.iter_enumerated().skip(1).take(arg_count)\n+                    .map(|(local, _)| Place::Local(local))\n+                    .filter(needs_retag)\n+                    .collect::<Vec<_>>();\n+            // Emit their retags.\n+            basic_blocks[START_BLOCK].statements.splice(0..0,\n+                places.into_iter().map(|place| Statement {\n+                    source_info,\n+                    kind: StatementKind::Retag { fn_entry: true, place },\n+                })\n+            );\n+        }\n+\n+        // PART 2\n+        // Retag return values of functions.\n+        // We collect the return destinations because we cannot mutate while iterating.\n+        let mut returns: Vec<(SourceInfo, Place<'tcx>, BasicBlock)> = Vec::new();\n+        for block_data in basic_blocks.iter_mut() {\n+            match block_data.terminator {\n+                Some(Terminator { kind: TerminatorKind::Call { ref destination, .. },\n+                                  source_info }) => {\n+                    // Remember the return destination for later\n+                    if let &Some(ref destination) = destination {\n+                        if needs_retag(&destination.0) {\n+                            returns.push((source_info, destination.0.clone(), destination.1));\n+                        }\n+                    }\n+                }\n+                _ => {\n+                    // Not a block ending in a Call -> ignore.\n+                    // `Drop` is also a call, but it doesn't return anything so we are good.\n+                }\n+            }\n+        }\n+        // Now we go over the returns we collected to retag the return values.\n+        for (source_info, dest_place, dest_block) in returns {\n+            basic_blocks[dest_block].statements.insert(0, Statement {\n+                source_info,\n+                kind: StatementKind::Retag { fn_entry: false, place: dest_place },\n+            });\n+        }\n+\n+        // PART 3\n+        // Add retag after assignment.\n+        for block_data in basic_blocks {\n+            // We want to insert statements as we iterate.  To this end, we\n+            // iterate backwards using indices.\n+            for i in (0..block_data.statements.len()).rev() {\n+                match block_data.statements[i].kind {\n+                    // Assignments can make values obtained elsewhere \"local\".\n+                    // We could try to be smart here and e.g. only retag if the assignment\n+                    // loaded from memory, but that seems risky: We might miss a subtle corner\n+                    // case.\n+                    StatementKind::Assign(ref place, box Rvalue::Use(..))\n+                    if needs_retag(place) => {\n+                        // Insert a retag after the assignment.\n+                        let source_info = block_data.statements[i].source_info;\n+                        block_data.statements.insert(i+1,Statement {\n+                            source_info,\n+                            kind: StatementKind::Retag { fn_entry: false, place: place.clone() },\n+                        });\n+                    }\n+                    _ => {},\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "5b489b5db942b1916db954bb776b7faa486cbd04", "filename": "src/librustc_mir/transform/add_validation.rs", "status": "removed", "additions": 0, "deletions": 395, "changes": 395, "blob_url": "https://github.com/rust-lang/rust/blob/4e88b7363b7858960ccfd87326ece9d00bf4d973/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e88b7363b7858960ccfd87326ece9d00bf4d973/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs?ref=4e88b7363b7858960ccfd87326ece9d00bf4d973", "patch": "@@ -1,395 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! This pass adds validation calls (AcquireValid, ReleaseValid) where appropriate.\n-//! It has to be run really early, before transformations like inlining, because\n-//! introducing these calls *adds* UB -- so, conceptually, this pass is actually part\n-//! of MIR building, and only after this pass we think of the program has having the\n-//! normal MIR semantics.\n-\n-use rustc::ty::{self, TyCtxt, RegionKind};\n-use rustc::hir;\n-use rustc::mir::*;\n-use rustc::middle::region;\n-use transform::{MirPass, MirSource};\n-\n-pub struct AddValidation;\n-\n-/// Determine the \"context\" of the place: Mutability and region.\n-fn place_context<'a, 'tcx, D>(\n-    place: &Place<'tcx>,\n-    local_decls: &D,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>\n-) -> (Option<region::Scope>, hir::Mutability)\n-    where D: HasLocalDecls<'tcx>\n-{\n-    use rustc::mir::Place::*;\n-\n-    match *place {\n-        Local { .. } => (None, hir::MutMutable),\n-        Promoted(_) |\n-        Static(_) => (None, hir::MutImmutable),\n-        Projection(ref proj) => {\n-            match proj.elem {\n-                ProjectionElem::Deref => {\n-                    // Computing the inside the recursion makes this quadratic.\n-                    // We don't expect deep paths though.\n-                    let ty = proj.base.ty(local_decls, tcx).to_ty(tcx);\n-                    // A Deref projection may restrict the context, this depends on the type\n-                    // being deref'd.\n-                    let context = match ty.sty {\n-                        ty::Ref(re, _, mutbl) => {\n-                            let re = match re {\n-                                &RegionKind::ReScope(ce) => Some(ce),\n-                                &RegionKind::ReErased =>\n-                                    bug!(\"AddValidation pass must be run before erasing lifetimes\"),\n-                                _ => None\n-                            };\n-                            (re, mutbl)\n-                        }\n-                        ty::RawPtr(_) =>\n-                            // There is no guarantee behind even a mutable raw pointer,\n-                            // no write locks are acquired there, so we also don't want to\n-                            // release any.\n-                            (None, hir::MutImmutable),\n-                        ty::Adt(adt, _) if adt.is_box() => (None, hir::MutMutable),\n-                        _ => bug!(\"Deref on a non-pointer type {:?}\", ty),\n-                    };\n-                    // \"Intersect\" this restriction with proj.base.\n-                    if let (Some(_), hir::MutImmutable) = context {\n-                        // This is already as restricted as it gets, no need to even recurse\n-                        context\n-                    } else {\n-                        let base_context = place_context(&proj.base, local_decls, tcx);\n-                        // The region of the outermost Deref is always most restrictive.\n-                        let re = context.0.or(base_context.0);\n-                        let mutbl = context.1.and(base_context.1);\n-                        (re, mutbl)\n-                    }\n-\n-                }\n-                _ => place_context(&proj.base, local_decls, tcx),\n-            }\n-        }\n-    }\n-}\n-\n-/// Check if this function contains an unsafe block or is an unsafe function.\n-fn fn_contains_unsafe<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource) -> bool {\n-    use rustc::hir::intravisit::{self, Visitor, FnKind};\n-    use rustc::hir::map::blocks::FnLikeNode;\n-    use rustc::hir::Node;\n-\n-    /// Decide if this is an unsafe block\n-    fn block_is_unsafe(block: &hir::Block) -> bool {\n-        use rustc::hir::BlockCheckMode::*;\n-\n-        match block.rules {\n-            UnsafeBlock(_) | PushUnsafeBlock(_) => true,\n-            // For PopUnsafeBlock, we don't actually know -- but we will always also check all\n-            // parent blocks, so we can safely declare the PopUnsafeBlock to not be unsafe.\n-            DefaultBlock | PopUnsafeBlock(_) => false,\n-        }\n-    }\n-\n-    /// Decide if this FnLike is a closure\n-    fn fn_is_closure<'a>(fn_like: FnLikeNode<'a>) -> bool {\n-        match fn_like.kind() {\n-            FnKind::Closure(_) => true,\n-            FnKind::Method(..) | FnKind::ItemFn(..) => false,\n-        }\n-    }\n-\n-    let node_id = tcx.hir.as_local_node_id(src.def_id).unwrap();\n-    let fn_like = match tcx.hir.body_owner_kind(node_id) {\n-        hir::BodyOwnerKind::Fn => {\n-            match FnLikeNode::from_node(tcx.hir.get(node_id)) {\n-                Some(fn_like) => fn_like,\n-                None => return false, // e.g. struct ctor shims -- such auto-generated code cannot\n-                                      // contain unsafe.\n-            }\n-        },\n-        _ => return false, // only functions can have unsafe\n-    };\n-\n-    // Test if the function is marked unsafe.\n-    if fn_like.unsafety() == hir::Unsafety::Unsafe {\n-        return true;\n-    }\n-\n-    // For closures, we need to walk up the parents and see if we are inside an unsafe fn or\n-    // unsafe block.\n-    if fn_is_closure(fn_like) {\n-        let mut cur = fn_like.id();\n-        loop {\n-            // Go further upwards.\n-            cur = tcx.hir.get_parent_node(cur);\n-            let node = tcx.hir.get(cur);\n-            // Check if this is an unsafe function\n-            if let Some(fn_like) = FnLikeNode::from_node(node) {\n-                if !fn_is_closure(fn_like) {\n-                    if fn_like.unsafety() == hir::Unsafety::Unsafe {\n-                        return true;\n-                    }\n-                }\n-            }\n-            // Check if this is an unsafe block, or an item\n-            match node {\n-                Node::Expr(&hir::Expr { node: hir::ExprKind::Block(ref block, _), ..}) => {\n-                    if block_is_unsafe(&*block) {\n-                        // Found an unsafe block, we can bail out here.\n-                        return true;\n-                    }\n-                }\n-                Node::Item(..) => {\n-                    // No walking up beyond items.  This makes sure the loop always terminates.\n-                    break;\n-                }\n-                _ => {},\n-            }\n-        }\n-    }\n-\n-    // Visit the entire body of the function and check for unsafe blocks in there\n-    struct FindUnsafe {\n-        found_unsafe: bool,\n-    }\n-    let mut finder = FindUnsafe { found_unsafe: false };\n-    // Run the visitor on the NodeId we got.  Seems like there is no uniform way to do that.\n-    finder.visit_body(tcx.hir.body(fn_like.body()));\n-\n-    impl<'tcx> Visitor<'tcx> for FindUnsafe {\n-        fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n-            intravisit::NestedVisitorMap::None\n-        }\n-\n-        fn visit_block(&mut self, b: &'tcx hir::Block) {\n-            if self.found_unsafe { return; } // short-circuit\n-\n-            if block_is_unsafe(b) {\n-                // We found an unsafe block.  We can stop searching.\n-                self.found_unsafe = true;\n-            } else {\n-                // No unsafe block here, go on searching.\n-                intravisit::walk_block(self, b);\n-            }\n-        }\n-    }\n-\n-    finder.found_unsafe\n-}\n-\n-impl MirPass for AddValidation {\n-    fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          src: MirSource,\n-                          mir: &mut Mir<'tcx>)\n-    {\n-        let emit_validate = tcx.sess.opts.debugging_opts.mir_emit_validate;\n-        if emit_validate == 0 {\n-            return;\n-        }\n-        let restricted_validation = emit_validate == 1 && fn_contains_unsafe(tcx, src);\n-        let (span, arg_count) = (mir.span, mir.arg_count);\n-        let (basic_blocks, local_decls) = mir.basic_blocks_and_local_decls_mut();\n-\n-        // Convert a place to a validation operand.\n-        let place_to_operand = |place: Place<'tcx>| -> ValidationOperand<'tcx, Place<'tcx>> {\n-            let (re, mutbl) = place_context(&place, local_decls, tcx);\n-            let ty = place.ty(local_decls, tcx).to_ty(tcx);\n-            ValidationOperand { place, ty, re, mutbl }\n-        };\n-\n-        // Emit an Acquire at the beginning of the given block.  If we are in restricted emission\n-        // mode (mir_emit_validate=1), also emit a Release immediately after the Acquire.\n-        let emit_acquire = |block: &mut BasicBlockData<'tcx>, source_info, operands: Vec<_>| {\n-            if operands.len() == 0 {\n-                return; // Nothing to do\n-            }\n-            // Emit the release first, to avoid cloning if we do not emit it\n-            if restricted_validation {\n-                let release_stmt = Statement {\n-                    source_info,\n-                    kind: StatementKind::Validate(ValidationOp::Release, operands.clone()),\n-                };\n-                block.statements.insert(0, release_stmt);\n-            }\n-            // Now, the acquire\n-            let acquire_stmt = Statement {\n-                source_info,\n-                kind: StatementKind::Validate(ValidationOp::Acquire, operands),\n-            };\n-            block.statements.insert(0, acquire_stmt);\n-        };\n-\n-        // PART 1\n-        // Add an AcquireValid at the beginning of the start block.\n-        {\n-            let source_info = SourceInfo {\n-                scope: OUTERMOST_SOURCE_SCOPE,\n-                span: span, // FIXME: Consider using just the span covering the function\n-                            // argument declaration.\n-            };\n-            // Gather all arguments, skip return value.\n-            let operands = local_decls.iter_enumerated().skip(1).take(arg_count)\n-                    .map(|(local, _)| place_to_operand(Place::Local(local))).collect();\n-            emit_acquire(&mut basic_blocks[START_BLOCK], source_info, operands);\n-        }\n-\n-        // PART 2\n-        // Add ReleaseValid/AcquireValid around function call terminators.  We don't use a visitor\n-        // because we need to access the block that a Call jumps to.\n-        let mut returns : Vec<(SourceInfo, Place<'tcx>, BasicBlock)> = Vec::new();\n-        for block_data in basic_blocks.iter_mut() {\n-            match block_data.terminator {\n-                Some(Terminator { kind: TerminatorKind::Call { ref args, ref destination, .. },\n-                                  source_info }) => {\n-                    // Before the call: Release all arguments *and* the return value.\n-                    // The callee may write into the return value!  Note that this relies\n-                    // on \"release of uninitialized\" to be a NOP.\n-                    if !restricted_validation {\n-                        let release_stmt = Statement {\n-                            source_info,\n-                            kind: StatementKind::Validate(ValidationOp::Release,\n-                                destination.iter().map(|dest| place_to_operand(dest.0.clone()))\n-                                .chain(\n-                                    args.iter().filter_map(|op| {\n-                                        match op {\n-                                            &Operand::Copy(ref place) |\n-                                            &Operand::Move(ref place) =>\n-                                                Some(place_to_operand(place.clone())),\n-                                            &Operand::Constant(..) => { None },\n-                                        }\n-                                    })\n-                                ).collect())\n-                        };\n-                        block_data.statements.push(release_stmt);\n-                    }\n-                    // Remember the return destination for later\n-                    if let &Some(ref destination) = destination {\n-                        returns.push((source_info, destination.0.clone(), destination.1));\n-                    }\n-                }\n-                Some(Terminator { kind: TerminatorKind::Drop { location: ref place, .. },\n-                                  source_info }) |\n-                Some(Terminator { kind: TerminatorKind::DropAndReplace { location: ref place, .. },\n-                                  source_info }) => {\n-                    // Before the call: Release all arguments\n-                    if !restricted_validation {\n-                        let release_stmt = Statement {\n-                            source_info,\n-                            kind: StatementKind::Validate(ValidationOp::Release,\n-                                    vec![place_to_operand(place.clone())]),\n-                        };\n-                        block_data.statements.push(release_stmt);\n-                    }\n-                    // drop doesn't return anything, so we need no acquire.\n-                }\n-                _ => {\n-                    // Not a block ending in a Call -> ignore.\n-                }\n-            }\n-        }\n-        // Now we go over the returns we collected to acquire the return values.\n-        for (source_info, dest_place, dest_block) in returns {\n-            emit_acquire(\n-                &mut basic_blocks[dest_block],\n-                source_info,\n-                vec![place_to_operand(dest_place)]\n-            );\n-        }\n-\n-        if restricted_validation {\n-            // No part 3 for us.\n-            return;\n-        }\n-\n-        // PART 3\n-        // Add ReleaseValid/AcquireValid around Ref and Cast.  Again an iterator does not seem very\n-        // suited as we need to add new statements before and after each Ref.\n-        for block_data in basic_blocks {\n-            // We want to insert statements around Ref commands as we iterate.  To this end, we\n-            // iterate backwards using indices.\n-            for i in (0..block_data.statements.len()).rev() {\n-                match block_data.statements[i].kind {\n-                    // When the borrow of this ref expires, we need to recover validation.\n-                    StatementKind::Assign(_, box Rvalue::Ref(_, _, _)) => {\n-                        // Due to a lack of NLL; we can't capture anything directly here.\n-                        // Instead, we have to re-match and clone there.\n-                        let (dest_place, re, src_place) = match block_data.statements[i].kind {\n-                            StatementKind::Assign(ref dest_place,\n-                                                  box Rvalue::Ref(re, _, ref src_place)) => {\n-                                (dest_place.clone(), re, src_place.clone())\n-                            },\n-                            _ => bug!(\"We already matched this.\"),\n-                        };\n-                        // So this is a ref, and we got all the data we wanted.\n-                        // Do an acquire of the result -- but only what it points to, so add a Deref\n-                        // projection.\n-                        let acquire_stmt = Statement {\n-                            source_info: block_data.statements[i].source_info,\n-                            kind: StatementKind::Validate(ValidationOp::Acquire,\n-                                    vec![place_to_operand(dest_place.deref())]),\n-                        };\n-                        block_data.statements.insert(i+1, acquire_stmt);\n-\n-                        // The source is released until the region of the borrow ends.\n-                        let op = match re {\n-                            &RegionKind::ReScope(ce) => ValidationOp::Suspend(ce),\n-                            &RegionKind::ReErased =>\n-                                bug!(\"AddValidation pass must be run before erasing lifetimes\"),\n-                            _ => ValidationOp::Release,\n-                        };\n-                        let release_stmt = Statement {\n-                            source_info: block_data.statements[i].source_info,\n-                            kind: StatementKind::Validate(op, vec![place_to_operand(src_place)]),\n-                        };\n-                        block_data.statements.insert(i, release_stmt);\n-                    }\n-                    // Casts can change what validation does (e.g. unsizing)\n-                    StatementKind::Assign(_, box Rvalue::Cast(kind, Operand::Copy(_), _)) |\n-                    StatementKind::Assign(_, box Rvalue::Cast(kind, Operand::Move(_), _))\n-                        if kind != CastKind::Misc =>\n-                    {\n-                        // Due to a lack of NLL; we can't capture anything directly here.\n-                        // Instead, we have to re-match and clone there.\n-                        let (dest_place, src_place) = match block_data.statements[i].kind {\n-                            StatementKind::Assign(ref dest_place,\n-                                    box Rvalue::Cast(_, Operand::Copy(ref src_place), _)) |\n-                            StatementKind::Assign(ref dest_place,\n-                                    box Rvalue::Cast(_, Operand::Move(ref src_place), _)) =>\n-                            {\n-                                (dest_place.clone(), src_place.clone())\n-                            },\n-                            _ => bug!(\"We already matched this.\"),\n-                        };\n-\n-                        // Acquire of the result\n-                        let acquire_stmt = Statement {\n-                            source_info: block_data.statements[i].source_info,\n-                            kind: StatementKind::Validate(ValidationOp::Acquire,\n-                                    vec![place_to_operand(dest_place)]),\n-                        };\n-                        block_data.statements.insert(i+1, acquire_stmt);\n-\n-                        // Release of the input\n-                        let release_stmt = Statement {\n-                            source_info: block_data.statements[i].source_info,\n-                            kind: StatementKind::Validate(ValidationOp::Release,\n-                                                            vec![place_to_operand(src_place)]),\n-                        };\n-                        block_data.statements.insert(i, release_stmt);\n-                    }\n-                    _ => {},\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "c28bb0ca35704b56d93378ec61474c32473d832b", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6", "patch": "@@ -113,7 +113,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             StatementKind::StorageLive(..) |\n             StatementKind::StorageDead(..) |\n             StatementKind::EndRegion(..) |\n-            StatementKind::Validate(..) |\n+            StatementKind::Retag { .. } |\n             StatementKind::AscribeUserType(..) |\n             StatementKind::Nop => {\n                 // safe (at least as emitted during MIR construction)"}, {"sha": "6351a6b40cb03a9db2aad442e38cdffb55f778b2", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6", "patch": "@@ -22,23 +22,19 @@ use transform::{MirPass, MirSource};\n \n struct EraseRegionsVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    in_validation_statement: bool,\n }\n \n impl<'a, 'tcx> EraseRegionsVisitor<'a, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n         EraseRegionsVisitor {\n             tcx,\n-            in_validation_statement: false,\n         }\n     }\n }\n \n impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &mut Ty<'tcx>, _: TyContext) {\n-        if !self.in_validation_statement {\n-            *ty = self.tcx.erase_regions(ty);\n-        }\n+        *ty = self.tcx.erase_regions(ty);\n         self.super_ty(ty);\n     }\n \n@@ -58,20 +54,11 @@ impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n                        block: BasicBlock,\n                        statement: &mut Statement<'tcx>,\n                        location: Location) {\n-        // Do NOT delete EndRegion if validation statements are emitted.\n-        // Validation needs EndRegion.\n-        if self.tcx.sess.opts.debugging_opts.mir_emit_validate == 0 {\n-            if let StatementKind::EndRegion(_) = statement.kind {\n-                statement.kind = StatementKind::Nop;\n-            }\n+        if let StatementKind::EndRegion(_) = statement.kind {\n+            statement.kind = StatementKind::Nop;\n         }\n \n-        self.in_validation_statement = match statement.kind {\n-            StatementKind::Validate(..) => true,\n-            _ => false,\n-        };\n         self.super_statement(block, statement, location);\n-        self.in_validation_statement = false;\n     }\n }\n "}, {"sha": "92cfcb3fd56cb4d3f04898c972206ff9e07349fb", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6", "patch": "@@ -23,7 +23,7 @@ use std::borrow::Cow;\n use syntax::ast;\n use syntax_pos::Span;\n \n-pub mod add_validation;\n+pub mod add_retag;\n pub mod add_moves_for_packed_drops;\n pub mod cleanup_post_borrowck;\n pub mod check_unsafety;\n@@ -258,19 +258,21 @@ fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx\n         // Remove all `FakeRead` statements and the borrows that are only\n         // used for checking matches\n         &cleanup_post_borrowck::CleanFakeReadsAndBorrows,\n+\n         &simplify::SimplifyCfg::new(\"early-opt\"),\n \n         // These next passes must be executed together\n         &add_call_guards::CriticalCallEdges,\n         &elaborate_drops::ElaborateDrops,\n         &no_landing_pads::NoLandingPads,\n-        // AddValidation needs to run after ElaborateDrops and before EraseRegions, and it needs\n-        // an AllCallEdges pass right before it.\n-        &add_call_guards::AllCallEdges,\n-        &add_validation::AddValidation,\n         // AddMovesForPackedDrops needs to run after drop\n         // elaboration.\n         &add_moves_for_packed_drops::AddMovesForPackedDrops,\n+        // AddRetag needs to run after ElaborateDrops, and it needs\n+        // an AllCallEdges pass right before it.  Otherwise it should\n+        // run fairly late, but before optimizations begin.\n+        &add_call_guards::AllCallEdges,\n+        &add_retag::AddRetag,\n \n         &simplify::SimplifyCfg::new(\"elaborate-drops\"),\n "}, {"sha": "ca9c4eb9b8bb971f3d8bca1046c98d2afb4c30ee", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6", "patch": "@@ -1167,7 +1167,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 StatementKind::StorageDead(_) |\n                 StatementKind::InlineAsm {..} |\n                 StatementKind::EndRegion(_) |\n-                StatementKind::Validate(..) |\n+                StatementKind::Retag { .. } |\n                 StatementKind::AscribeUserType(..) |\n                 StatementKind::Nop => {}\n             }"}, {"sha": "1e193485950579bcae7671ca912c7b12cddad674", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6", "patch": "@@ -241,7 +241,7 @@ fn check_statement(\n         // These are all NOPs\n         | StatementKind::StorageLive(_)\n         | StatementKind::StorageDead(_)\n-        | StatementKind::Validate(..)\n+        | StatementKind::Retag { .. }\n         | StatementKind::EndRegion(_)\n         | StatementKind::AscribeUserType(..)\n         | StatementKind::Nop => Ok(()),"}, {"sha": "c1c127fa8d6484979f00ed3e383929c21f6d3a7c", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6", "patch": "@@ -68,7 +68,7 @@ impl RemoveNoopLandingPads {\n                 StatementKind::Assign(_, _) |\n                 StatementKind::SetDiscriminant { .. } |\n                 StatementKind::InlineAsm { .. } |\n-                StatementKind::Validate { .. } => {\n+                StatementKind::Retag { .. } => {\n                     return false;\n                 }\n             }"}, {"sha": "a5a19f04b7e8e49b1e61617ace060e2a29c07e94", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6", "patch": "@@ -162,7 +162,7 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             mir::StatementKind::StorageDead(_) |\n             mir::StatementKind::InlineAsm { .. } |\n             mir::StatementKind::EndRegion(_) |\n-            mir::StatementKind::Validate(..) |\n+            mir::StatementKind::Retag { .. } |\n             mir::StatementKind::AscribeUserType(..) |\n             mir::StatementKind::Nop => continue,\n             mir::StatementKind::SetDiscriminant{ .. } =>"}, {"sha": "12c13b8f81531b330bd08c1225cad594ba7d4f95", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6", "patch": "@@ -204,7 +204,7 @@ pub fn categorize<'tcx>(context: PlaceContext<'tcx>) -> Option<DefUse> {\n         PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) |\n         PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) |\n         PlaceContext::NonUse(NonUseContext::AscribeUserTy) |\n-        PlaceContext::NonUse(NonUseContext::Validate) =>\n+        PlaceContext::MutatingUse(MutatingUseContext::Retag) =>\n             Some(DefUse::Use),\n \n         ///////////////////////////////////////////////////////////////////////////"}, {"sha": "ecfe7d13782de3dc2c0daa875d9e731dbcc0d44c", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=aafcf2c9422e7e1de2ebefd51d78cf1d07d02cd6", "patch": "@@ -84,7 +84,7 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n             StatementKind::Assign(..) => \"StatementKind::Assign\",\n             StatementKind::FakeRead(..) => \"StatementKind::FakeRead\",\n             StatementKind::EndRegion(..) => \"StatementKind::EndRegion\",\n-            StatementKind::Validate(..) => \"StatementKind::Validate\",\n+            StatementKind::Retag { .. } => \"StatementKind::Retag\",\n             StatementKind::SetDiscriminant { .. } => \"StatementKind::SetDiscriminant\",\n             StatementKind::StorageLive(..) => \"StatementKind::StorageLive\",\n             StatementKind::StorageDead(..) => \"StatementKind::StorageDead\","}]}