{"sha": "8ad12c3e251df6b8ed42b4d32709f4f55470a0be", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhZDEyYzNlMjUxZGY2YjhlZDQyYjRkMzI3MDlmNGY1NTQ3MGEwYmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-19T00:57:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-19T00:57:25Z"}, "message": "Auto merge of #30381 - fhahn:memchr-in-std, r=alexcrichton\n\nThis PR adds `memchr`and `memrchr` based on @BurntSushi 's rust-memchr crate to libstd (as discussed in #30151).\n\nI've update some places in libstd to use memchr/memrchr, but I am not sure if there are other places where it could be used as well.\n\nref #30076", "tree": {"sha": "0b89a14f1590e2537f5aa796092364438014d249", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b89a14f1590e2537f5aa796092364438014d249"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ad12c3e251df6b8ed42b4d32709f4f55470a0be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ad12c3e251df6b8ed42b4d32709f4f55470a0be", "html_url": "https://github.com/rust-lang/rust/commit/8ad12c3e251df6b8ed42b4d32709f4f55470a0be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ad12c3e251df6b8ed42b4d32709f4f55470a0be/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e278950c2243f0d8e6638678359139a22d7e427", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e278950c2243f0d8e6638678359139a22d7e427", "html_url": "https://github.com/rust-lang/rust/commit/9e278950c2243f0d8e6638678359139a22d7e427"}, {"sha": "a206e556d07134661eba5cbb0315fbd59c3e6717", "url": "https://api.github.com/repos/rust-lang/rust/commits/a206e556d07134661eba5cbb0315fbd59c3e6717", "html_url": "https://github.com/rust-lang/rust/commit/a206e556d07134661eba5cbb0315fbd59c3e6717"}], "stats": {"total": 402, "additions": 397, "deletions": 5}, "files": [{"sha": "9863d5645fc4d1be789d03bcf58c1b3cfafbba39", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=8ad12c3e251df6b8ed42b4d32709f4f55470a0be", "patch": "@@ -1 +1 @@\n-Subproject commit 867c6ff0b824d6d295951ed34bb252d5e0b2467a\n+Subproject commit 9863d5645fc4d1be789d03bcf58c1b3cfafbba39"}, {"sha": "3f3913471b8958193c7a2543e408350412d508c9", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8ad12c3e251df6b8ed42b4d32709f4f55470a0be/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ad12c3e251df6b8ed42b4d32709f4f55470a0be/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=8ad12c3e251df6b8ed42b4d32709f4f55470a0be", "patch": "@@ -19,6 +19,7 @@ use io;\n use iter::Iterator;\n use libc;\n use mem;\n+use memchr;\n use ops::Deref;\n use option::Option::{self, Some, None};\n use os::raw::c_char;\n@@ -188,7 +189,7 @@ impl CString {\n     }\n \n     fn _new(bytes: Vec<u8>) -> Result<CString, NulError> {\n-        match bytes.iter().position(|x| *x == 0) {\n+        match memchr::memchr(0, &bytes) {\n             Some(i) => Err(NulError(i, bytes)),\n             None => Ok(unsafe { CString::from_vec_unchecked(bytes) }),\n         }"}, {"sha": "79eedbeda2c727375b9c93bc2aa6d5d80245e550", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8ad12c3e251df6b8ed42b4d32709f4f55470a0be/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ad12c3e251df6b8ed42b4d32709f4f55470a0be/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=8ad12c3e251df6b8ed42b4d32709f4f55470a0be", "patch": "@@ -18,6 +18,7 @@ use cmp;\n use error;\n use fmt;\n use io::{self, DEFAULT_BUF_SIZE, Error, ErrorKind, SeekFrom};\n+use memchr;\n \n /// The `BufReader` struct adds buffering to any reader.\n ///\n@@ -746,7 +747,7 @@ impl<W: Write> LineWriter<W> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<W: Write> Write for LineWriter<W> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        match buf.iter().rposition(|b| *b == b'\\n') {\n+        match memchr::memrchr(b'\\n', buf) {\n             Some(i) => {\n                 let n = try!(self.inner.write(&buf[..i + 1]));\n                 if n != i + 1 { return Ok(n) }"}, {"sha": "cc3f8097a88e9df5bd0236ab88c152e50113228f", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8ad12c3e251df6b8ed42b4d32709f4f55470a0be/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ad12c3e251df6b8ed42b4d32709f4f55470a0be/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=8ad12c3e251df6b8ed42b4d32709f4f55470a0be", "patch": "@@ -254,6 +254,7 @@ use result;\n use string::String;\n use str;\n use vec::Vec;\n+use memchr;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::buffered::{BufReader, BufWriter, LineWriter};\n@@ -1194,7 +1195,7 @@ fn read_until<R: BufRead + ?Sized>(r: &mut R, delim: u8, buf: &mut Vec<u8>)\n                 Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n                 Err(e) => return Err(e)\n             };\n-            match available.iter().position(|x| *x == delim) {\n+            match memchr::memchr(delim, available) {\n                 Some(i) => {\n                     buf.extend_from_slice(&available[..i + 1]);\n                     (true, i + 1)"}, {"sha": "eba0c799cd2c1c08208c102ce08924bb4dde3795", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ad12c3e251df6b8ed42b4d32709f4f55470a0be/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ad12c3e251df6b8ed42b4d32709f4f55470a0be/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=8ad12c3e251df6b8ed42b4d32709f4f55470a0be", "patch": "@@ -248,6 +248,7 @@\n #![feature(link_args)]\n #![feature(linkage)]\n #![feature(macro_reexport)]\n+#![feature(num_bits_bytes)]\n #![feature(on_unimplemented)]\n #![feature(oom)]\n #![feature(optin_builtin_traits)]\n@@ -429,6 +430,7 @@ pub mod path;\n pub mod process;\n pub mod sync;\n pub mod time;\n+mod memchr;\n \n #[macro_use]\n #[path = \"sys/common/mod.rs\"] mod sys_common;"}, {"sha": "c654efd499b6410f7d9b9679b9471392bbe18f85", "filename": "src/libstd/memchr.rs", "status": "added", "additions": 386, "deletions": 0, "changes": 386, "blob_url": "https://github.com/rust-lang/rust/blob/8ad12c3e251df6b8ed42b4d32709f4f55470a0be/src%2Flibstd%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ad12c3e251df6b8ed42b4d32709f4f55470a0be/src%2Flibstd%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmemchr.rs?ref=8ad12c3e251df6b8ed42b4d32709f4f55470a0be", "patch": "@@ -0,0 +1,386 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// Original implementation taken from rust-memchr\n+// Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n+\n+\n+\n+/// A safe interface to `memchr`.\n+///\n+/// Returns the index corresponding to the first occurrence of `needle` in\n+/// `haystack`, or `None` if one is not found.\n+///\n+/// memchr reduces to super-optimized machine code at around an order of\n+/// magnitude faster than `haystack.iter().position(|&b| b == needle)`.\n+/// (See benchmarks.)\n+///\n+/// # Example\n+///\n+/// This shows how to find the first position of a byte in a byte string.\n+///\n+/// ```rust,ignore\n+/// use memchr::memchr;\n+///\n+/// let haystack = b\"the quick brown fox\";\n+/// assert_eq!(memchr(b'k', haystack), Some(8));\n+/// ```\n+pub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n+    // libc memchr\n+    #[cfg(not(target_os = \"windows\"))]\n+    fn memchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n+        use libc;\n+\n+        let p = unsafe {\n+            libc::memchr(\n+                haystack.as_ptr() as *const libc::c_void,\n+                needle as libc::c_int,\n+                haystack.len() as libc::size_t)\n+        };\n+        if p.is_null() {\n+            None\n+        } else {\n+            Some(p as usize - (haystack.as_ptr() as usize))\n+        }\n+    }\n+\n+    // use fallback on windows, since it's faster\n+    #[cfg(target_os = \"windows\")]\n+    fn memchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n+        fallback::memchr(needle, haystack)\n+    }\n+\n+    memchr_specific(needle, haystack)\n+}\n+\n+/// A safe interface to `memrchr`.\n+///\n+/// Returns the index corresponding to the last occurrence of `needle` in\n+/// `haystack`, or `None` if one is not found.\n+///\n+/// # Example\n+///\n+/// This shows how to find the last position of a byte in a byte string.\n+///\n+/// ```rust,ignore\n+/// use memchr::memrchr;\n+///\n+/// let haystack = b\"the quick brown fox\";\n+/// assert_eq!(memrchr(b'o', haystack), Some(17));\n+/// ```\n+pub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n+\n+    #[cfg(target_os = \"linux\")]\n+    fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n+        use libc;\n+\n+        // GNU's memrchr() will - unlike memchr() - error if haystack is empty.\n+        if haystack.is_empty() {return None}\n+        let p = unsafe {\n+            libc::memrchr(\n+                haystack.as_ptr() as *const libc::c_void,\n+                needle as libc::c_int,\n+                haystack.len() as libc::size_t)\n+        };\n+        if p.is_null() {\n+            None\n+        } else {\n+            Some(p as usize - (haystack.as_ptr() as usize))\n+        }\n+    }\n+\n+    #[cfg(not(target_os = \"linux\"))]\n+    fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n+        haystack.iter().rposition(|&b| b == needle)\n+    }\n+\n+    memrchr_specific(needle, haystack)\n+}\n+\n+#[allow(dead_code)]\n+mod fallback {\n+    use cmp;\n+    use usize;\n+\n+    const LO_U64: u64 = 0x0101010101010101;\n+    const HI_U64: u64 = 0x8080808080808080;\n+\n+    // use truncation\n+    const LO_USIZE: usize = LO_U64 as usize;\n+    const HI_USIZE: usize = HI_U64 as usize;\n+\n+    /// Return `true` if `x` contains any zero byte.\n+    ///\n+    /// From *Matters Computational*, J. Arndt\n+    ///\n+    /// \"The idea is to subtract one from each of the bytes and then look for\n+    /// bytes where the borrow propagated all the way to the most significant\n+    /// bit.\"\n+    #[inline]\n+    fn contains_zero_byte(x: usize) -> bool {\n+        x.wrapping_sub(LO_USIZE) & !x & HI_USIZE != 0\n+    }\n+\n+    #[cfg(target_pointer_width = \"32\")]\n+    #[inline]\n+    fn repeat_byte(b: u8) -> usize {\n+        let mut rep = (b as usize) << 8 | b as usize;\n+        rep = rep << 16 | rep;\n+        rep\n+    }\n+\n+    #[cfg(target_pointer_width = \"64\")]\n+    #[inline]\n+    fn repeat_byte(b: u8) -> usize {\n+        let mut rep = (b as usize) << 8 | b as usize;\n+        rep = rep << 16 | rep;\n+        rep = rep << 32 | rep;\n+        rep\n+    }\n+\n+    /// Return the first index matching the byte `a` in `text`.\n+    pub fn memchr(x: u8, text: &[u8]) -> Option<usize> {\n+        // Scan for a single byte value by reading two `usize` words at a time.\n+        //\n+        // Split `text` in three parts\n+        // - unaligned inital part, before the first word aligned address in text\n+        // - body, scan by 2 words at a time\n+        // - the last remaining part, < 2 word size\n+        let len = text.len();\n+        let ptr = text.as_ptr();\n+\n+        // search up to an aligned boundary\n+        let align = (ptr as usize) & (usize::BYTES- 1);\n+        let mut offset;\n+        if align > 0 {\n+            offset = cmp::min(usize::BYTES - align, len);\n+            if let Some(index) = text[..offset].iter().position(|elt| *elt == x) {\n+                return Some(index);\n+            }\n+        } else {\n+            offset = 0;\n+        }\n+\n+        // search the body of the text\n+        let repeated_x = repeat_byte(x);\n+\n+        if len >= 2 * usize::BYTES {\n+            while offset <= len - 2 * usize::BYTES {\n+                unsafe {\n+                    let u = *(ptr.offset(offset as isize) as *const usize);\n+                    let v = *(ptr.offset((offset + usize::BYTES) as isize) as *const usize);\n+\n+                    // break if there is a matching byte\n+                    let zu = contains_zero_byte(u ^ repeated_x);\n+                    let zv = contains_zero_byte(v ^ repeated_x);\n+                    if zu || zv {\n+                        break;\n+                    }\n+                }\n+                offset += usize::BYTES * 2;\n+            }\n+        }\n+\n+        // find the byte after the point the body loop stopped\n+        text[offset..].iter().position(|elt| *elt == x).map(|i| offset + i)\n+    }\n+\n+    /// Return the last index matching the byte `a` in `text`.\n+    pub fn memrchr(x: u8, text: &[u8]) -> Option<usize> {\n+        // Scan for a single byte value by reading two `usize` words at a time.\n+        //\n+        // Split `text` in three parts\n+        // - unaligned tail, after the last word aligned address in text\n+        // - body, scan by 2 words at a time\n+        // - the first remaining bytes, < 2 word size\n+        let len = text.len();\n+        let ptr = text.as_ptr();\n+\n+        // search to an aligned boundary\n+        let end_align = (ptr as usize + len) & (usize::BYTES - 1);\n+        let mut offset;\n+        if end_align > 0 {\n+            offset = len - cmp::min(usize::BYTES - end_align, len);\n+            if let Some(index) = text[offset..].iter().rposition(|elt| *elt == x) {\n+                return Some(offset + index);\n+            }\n+        } else {\n+            offset = len;\n+        }\n+\n+        // search the body of the text\n+        let repeated_x = repeat_byte(x);\n+\n+        while offset >= 2 * usize::BYTES {\n+            unsafe {\n+                let u = *(ptr.offset(offset as isize - 2 * usize::BYTES as isize) as *const usize);\n+                let v = *(ptr.offset(offset as isize - usize::BYTES as isize) as *const usize);\n+\n+                // break if there is a matching byte\n+                let zu = contains_zero_byte(u ^ repeated_x);\n+                let zv = contains_zero_byte(v ^ repeated_x);\n+                if zu || zv {\n+                    break;\n+                }\n+            }\n+            offset -= 2 * usize::BYTES;\n+        }\n+\n+        // find the byte before the point the body loop stopped\n+        text[..offset].iter().rposition(|elt| *elt == x)\n+    }\n+\n+    // test fallback implementations on all plattforms\n+    #[test]\n+    fn matches_one() {\n+        assert_eq!(Some(0), memchr(b'a', b\"a\"));\n+    }\n+\n+    #[test]\n+    fn matches_begin() {\n+        assert_eq!(Some(0), memchr(b'a', b\"aaaa\"));\n+    }\n+\n+    #[test]\n+    fn matches_end() {\n+        assert_eq!(Some(4), memchr(b'z', b\"aaaaz\"));\n+    }\n+\n+    #[test]\n+    fn matches_nul() {\n+        assert_eq!(Some(4), memchr(b'\\x00', b\"aaaa\\x00\"));\n+    }\n+\n+    #[test]\n+    fn matches_past_nul() {\n+        assert_eq!(Some(5), memchr(b'z', b\"aaaa\\x00z\"));\n+    }\n+\n+    #[test]\n+    fn no_match_empty() {\n+        assert_eq!(None, memchr(b'a', b\"\"));\n+    }\n+\n+    #[test]\n+    fn no_match() {\n+        assert_eq!(None, memchr(b'a', b\"xyz\"));\n+    }\n+\n+    #[test]\n+    fn matches_one_reversed() {\n+        assert_eq!(Some(0), memrchr(b'a', b\"a\"));\n+    }\n+\n+    #[test]\n+    fn matches_begin_reversed() {\n+        assert_eq!(Some(3), memrchr(b'a', b\"aaaa\"));\n+    }\n+\n+    #[test]\n+    fn matches_end_reversed() {\n+        assert_eq!(Some(0), memrchr(b'z', b\"zaaaa\"));\n+    }\n+\n+    #[test]\n+    fn matches_nul_reversed() {\n+        assert_eq!(Some(4), memrchr(b'\\x00', b\"aaaa\\x00\"));\n+    }\n+\n+    #[test]\n+    fn matches_past_nul_reversed() {\n+        assert_eq!(Some(0), memrchr(b'z', b\"z\\x00aaaa\"));\n+    }\n+\n+    #[test]\n+    fn no_match_empty_reversed() {\n+        assert_eq!(None, memrchr(b'a', b\"\"));\n+    }\n+\n+    #[test]\n+    fn no_match_reversed() {\n+        assert_eq!(None, memrchr(b'a', b\"xyz\"));\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    // test the implementations for the current plattform\n+    use super::{memchr, memrchr};\n+\n+    #[test]\n+    fn matches_one() {\n+        assert_eq!(Some(0), memchr(b'a', b\"a\"));\n+    }\n+\n+    #[test]\n+    fn matches_begin() {\n+        assert_eq!(Some(0), memchr(b'a', b\"aaaa\"));\n+    }\n+\n+    #[test]\n+    fn matches_end() {\n+        assert_eq!(Some(4), memchr(b'z', b\"aaaaz\"));\n+    }\n+\n+    #[test]\n+    fn matches_nul() {\n+        assert_eq!(Some(4), memchr(b'\\x00', b\"aaaa\\x00\"));\n+    }\n+\n+    #[test]\n+    fn matches_past_nul() {\n+        assert_eq!(Some(5), memchr(b'z', b\"aaaa\\x00z\"));\n+    }\n+\n+    #[test]\n+    fn no_match_empty() {\n+        assert_eq!(None, memchr(b'a', b\"\"));\n+    }\n+\n+    #[test]\n+    fn no_match() {\n+        assert_eq!(None, memchr(b'a', b\"xyz\"));\n+    }\n+\n+    #[test]\n+    fn matches_one_reversed() {\n+        assert_eq!(Some(0), memrchr(b'a', b\"a\"));\n+    }\n+\n+    #[test]\n+    fn matches_begin_reversed() {\n+        assert_eq!(Some(3), memrchr(b'a', b\"aaaa\"));\n+    }\n+\n+    #[test]\n+    fn matches_end_reversed() {\n+        assert_eq!(Some(0), memrchr(b'z', b\"zaaaa\"));\n+    }\n+\n+    #[test]\n+    fn matches_nul_reversed() {\n+        assert_eq!(Some(4), memrchr(b'\\x00', b\"aaaa\\x00\"));\n+    }\n+\n+    #[test]\n+    fn matches_past_nul_reversed() {\n+        assert_eq!(Some(0), memrchr(b'z', b\"z\\x00aaaa\"));\n+    }\n+\n+    #[test]\n+    fn no_match_empty_reversed() {\n+        assert_eq!(None, memrchr(b'a', b\"\"));\n+    }\n+\n+    #[test]\n+    fn no_match_reversed() {\n+        assert_eq!(None, memrchr(b'a', b\"xyz\"));\n+    }\n+}"}, {"sha": "12b9d6191a05fb5bd483528ba2397d29d11c8c83", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8ad12c3e251df6b8ed42b4d32709f4f55470a0be/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ad12c3e251df6b8ed42b4d32709f4f55470a0be/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=8ad12c3e251df6b8ed42b4d32709f4f55470a0be", "patch": "@@ -22,6 +22,7 @@ use io;\n use iter;\n use libc::{self, c_int, c_char, c_void};\n use mem;\n+use memchr;\n use path::{self, PathBuf};\n use ptr;\n use slice;\n@@ -406,7 +407,7 @@ pub fn env() -> Env {\n         if input.is_empty() {\n             return None;\n         }\n-        let pos = input[1..].iter().position(|&b| b == b'=').map(|p| p + 1);\n+        let pos = memchr::memchr(b'=', &input[1..]).map(|p| p + 1);\n         pos.map(|p| (\n             OsStringExt::from_vec(input[..p].to_vec()),\n             OsStringExt::from_vec(input[p+1..].to_vec()),"}]}