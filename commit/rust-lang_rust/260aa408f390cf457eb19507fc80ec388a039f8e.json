{"sha": "260aa408f390cf457eb19507fc80ec388a039f8e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2MGFhNDA4ZjM5MGNmNDU3ZWIxOTUwN2ZjODBlYzM4OGEwMzlmOGU=", "commit": {"author": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-06-16T00:45:24Z"}, "committer": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-06-16T00:45:24Z"}, "message": "Merge branch 'master' of github.com:graydon/rust into fastcall", "tree": {"sha": "afe7cdf6c65a8894cc844dc46f1104c42950def3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afe7cdf6c65a8894cc844dc46f1104c42950def3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/260aa408f390cf457eb19507fc80ec388a039f8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/260aa408f390cf457eb19507fc80ec388a039f8e", "html_url": "https://github.com/rust-lang/rust/commit/260aa408f390cf457eb19507fc80ec388a039f8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/260aa408f390cf457eb19507fc80ec388a039f8e/comments", "author": null, "committer": null, "parents": [{"sha": "405c164f023e3aceb64d0eeee1591de391201826", "url": "https://api.github.com/repos/rust-lang/rust/commits/405c164f023e3aceb64d0eeee1591de391201826", "html_url": "https://github.com/rust-lang/rust/commit/405c164f023e3aceb64d0eeee1591de391201826"}, {"sha": "97765561a24412c99485fba7491e5898c7459791", "url": "https://api.github.com/repos/rust-lang/rust/commits/97765561a24412c99485fba7491e5898c7459791", "html_url": "https://github.com/rust-lang/rust/commit/97765561a24412c99485fba7491e5898c7459791"}], "stats": {"total": 1892, "additions": 1149, "deletions": 743}, "files": [{"sha": "d8604ed999e74fbff1659b4e2f227331467ce55d", "filename": "mk/stage3.mk", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/260aa408f390cf457eb19507fc80ec388a039f8e/mk%2Fstage3.mk", "raw_url": "https://github.com/rust-lang/rust/raw/260aa408f390cf457eb19507fc80ec388a039f8e/mk%2Fstage3.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fstage3.mk?ref=260aa408f390cf457eb19507fc80ec388a039f8e", "patch": "@@ -1,13 +1,8 @@\n-stage3/std.o: $(STDLIB_CRATE) $(STDLIB_INPUTS) \\\n+stage3/$(CFG_STDLIB): $(STDLIB_CRATE) $(STDLIB_INPUTS) \\\n               stage2/rustc$(X) stage2/$(CFG_STDLIB) stage2/intrinsics.bc \\\n               $(LREQ) $(MKFILES)\n-\t@$(call E, compile: $@)\n-\t$(STAGE2) -c --shared -o $@ $<\n-\n-stage3/$(CFG_STDLIB): stage2/std.o stage2/glue.o\n-\t@$(call E, link: $@)\n-\t$(Q)gcc $(CFG_GCCISH_CFLAGS) stage2/glue.o $(CFG_GCCISH_LINK_FLAGS) -o \\\n-        $@ $< -Lstage2 -Lrt -lrustrt\n+\t@$(call E, compile_and_link: $@)\n+\t$(STAGE2)  --shared -o $@ $<\n \n stage3/librustc.o: $(COMPILER_CRATE) $(COMPILER_INPUTS) $(SREQ2)\n \t@$(call E, compile: $@)"}, {"sha": "d79ff61748c10d7d6dee4b480b04b12fc1d4d7ad", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=260aa408f390cf457eb19507fc80ec388a039f8e", "patch": "@@ -104,7 +104,7 @@ const int closure_elt_bindings = 2;\n \n const int closure_elt_ty_params = 3;\n \n-const uint ivec_default_length = 8u;\n+const uint ivec_default_length = 4u;\n \n const uint ivec_elt_len = 0u;\n "}, {"sha": "c986842e9aed2723194d5d0ed6018a6ab0f83b4d", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=260aa408f390cf457eb19507fc80ec388a039f8e", "patch": "@@ -209,7 +209,7 @@ mod write {\n  *\n  * There are a few issues to handle:\n  *\n- *  - Linkers operate on a flat namespace, so we have to flatten names.\n+ *  - Linnkers operate on a flat namespace, so we have to flatten names.\n  *    We do this using the C++ namespace-mangling technique. Foo::bar\n  *    symbols and such.\n  *\n@@ -221,15 +221,15 @@ mod write {\n  *    symbols in the same process before you're even hitting birthday-paradox\n  *    collision probability.\n  *\n- *  - Symbols in dirrerent crates but with same names \"within\" the crate need\n+ *  - Symbols in different crates but with same names \"within\" the crate need\n  *    to get different linkage-names.\n  *\n  * So here is what we do:\n  *\n  *  - Separate the meta tags into two sets: exported and local. Only work with\n  *    the exported ones when considering linkage.\n  *\n- *  - Consider two exported tags as special (and madatory): name and vers.\n+ *  - Consider two exported tags as special (and mandatory): name and vers.\n  *    Every crate gets them; if it doesn't name them explicitly we infer them\n  *    as basename(crate) and \"0.1\", respectively. Call these CNAME, CVERS.\n  *"}, {"sha": "e0a6d28f2b7ef897aacc3c7ab7c44574191918a8", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=260aa408f390cf457eb19507fc80ec388a039f8e", "patch": "@@ -81,18 +81,18 @@ fn compile_input(session::session sess, eval::env env, str input,\n     auto crate =\n         time(time_passes, \"parsing\", bind parse_input(sess, p, input));\n     if (sess.get_opts().output_type == link::output_type_none) { ret; }\n-    auto def_map =\n+    auto d =\n         time(time_passes, \"resolution\",\n              bind resolve::resolve_crate(sess, crate));\n-    auto ty_cx = ty::mk_ctxt(sess, def_map);\n+    auto ty_cx = ty::mk_ctxt(sess, d._0, d._1);\n     time[()](time_passes, \"typechecking\",\n              bind typeck::check_crate(ty_cx, crate));\n     if (sess.get_opts().run_typestate) {\n         time(time_passes, \"typestate checking\",\n              bind middle::tstate::ck::check_crate(ty_cx, crate));\n     }\n     time(time_passes, \"alias checking\",\n-         bind middle::alias::check_crate(@ty_cx, def_map, crate));\n+         bind middle::alias::check_crate(@ty_cx, crate));\n     auto llmod =\n         time[llvm::llvm::ModuleRef](time_passes, \"translation\",\n                                     bind trans::trans_crate(sess, crate,\n@@ -109,8 +109,8 @@ fn pretty_print_input(session::session sess, eval::env env, str input,\n     auto mode;\n     alt (ppm) {\n         case (ppm_typed) {\n-            auto def_map = resolve::resolve_crate(sess, crate);\n-            auto ty_cx = ty::mk_ctxt(sess, def_map);\n+            auto d = resolve::resolve_crate(sess, crate);\n+            auto ty_cx = ty::mk_ctxt(sess, d._0, d._1);\n             typeck::check_crate(ty_cx, crate);\n             mode = ppaux::mo_typed(ty_cx);\n         }\n@@ -399,37 +399,34 @@ fn main(vec[str] args) {\n         let str prog = \"gcc\";\n         // The invocations of gcc share some flags across platforms\n \n-        let vec[str] common_cflags =\n-            [\"-fno-strict-aliasing\", \"-fPIC\", \"-Wall\", \"-fno-rtti\",\n-             \"-fno-exceptions\", \"-g\"];\n-        let vec[str] common_libs =\n-            [stage, \"-Lrustllvm\", \"-Lrt\", \"-lrustrt\", \"-lrustllvm\", \"-lstd\",\n-             \"-lm\"];\n+        let vec[str] common_args = [stage, \"-Lrt\", \"-lrustrt\",\n+         \"-fno-strict-aliasing\", \"-fPIC\", \"-Wall\",\n+         \"-fno-rtti\", \"-fno-exceptions\", \"-g\", glu, \"-o\",\n+         saved_out_filename, saved_out_filename + \".o\"];\n+\n+       auto shared_cmd;\n+\n         alt (sess.get_targ_cfg().os) {\n             case (session::os_win32) {\n-                gcc_args =\n-                    common_cflags +\n-                        [\"-march=i686\", \"-O2\", glu, main, \"-o\",\n-                         saved_out_filename, saved_out_filename + \".o\"] +\n-                        common_libs;\n+                shared_cmd = \"-shared\";\n+                gcc_args = common_args + [\"-march=i686\", \"-O2\"];\n             }\n             case (session::os_macos) {\n-                gcc_args =\n-                    common_cflags +\n-                        [\"-arch i386\", \"-O0\", \"-m32\", glu, main, \"-o\",\n-                         saved_out_filename, saved_out_filename + \".o\"] +\n-                        common_libs;\n+                shared_cmd = \"-dynamiclib\";\n+                gcc_args = common_args + [\"-arch i386\", \"-O0\", \"-m32\"];\n             }\n             case (session::os_linux) {\n-                gcc_args =\n-                    common_cflags +\n-                        [\"-march=i686\", \"-O2\", \"-m32\", glu, main, \"-o\",\n-                         saved_out_filename, saved_out_filename + \".o\"] +\n-                        common_libs;\n+                shared_cmd = \"-shared\";\n+                gcc_args = common_args + [\"-march=i686\", \"-O2\", \"-m32\"];\n             }\n         }\n-        // We run 'gcc' here\n+        if (sopts.shared) {\n+           gcc_args += [shared_cmd];\n+        } else {\n+           gcc_args += [\"-Lrustllvm\", \"-lrustllvm\", \"-lstd\", \"-lm\", main];\n+        }\n \n+        // We run 'gcc' here\n         run::run_program(prog, gcc_args);\n         // Clean up on Darwin\n "}, {"sha": "b66c286f32596a462fa3f478950b03b360c892fa", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=260aa408f390cf457eb19507fc80ec388a039f8e", "patch": "@@ -359,19 +359,17 @@ tag constr_arg_general_[T] { carg_base; carg_ident(T); carg_lit(@lit); }\n \n type constr_arg = constr_arg_general[uint];\n \n-type constr_arg_use = constr_arg_general[ident];\n-\n type constr_arg_general[T] = spanned[constr_arg_general_[T]];\n \n+type constr_ = rec(path path,\n+                   vec[@constr_arg_general[uint]] args,\n+                   ann ann);\n \n-// The ann field is there so that using the def_map in the type\n-// context, we can get the def_id for the path.\n-type constr_general[T] =\n-    rec(path path, vec[@constr_arg_general[T]] args, ann ann);\n-\n-type constr = spanned[constr_general[uint]];\n+type constr = spanned[constr_];\n \n-type constr_use = spanned[constr_general[ident]];\n+/* The parser generates ast::constrs; resolve generates\n+ a mapping from each function to a list of ty::constr_defs,\n+ corresponding to these. */\n \n type arg = rec(mode mode, @ty ty, ident ident, def_id id);\n "}, {"sha": "98004bf6961b0c31ee0ec694d48cb9afa455f249", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=260aa408f390cf457eb19507fc80ec388a039f8e", "patch": "@@ -78,8 +78,8 @@ fn parse_ty_or_bang(@pstate st, str_def sd) -> ty_or_bang {\n     }\n }\n \n-fn parse_constrs(@pstate st, str_def sd) -> vec[@ast::constr] {\n-    let vec[@ast::constr] res = [];\n+fn parse_constrs(@pstate st, str_def sd) -> vec[@ty::constr_def] {\n+    let vec[@ty::constr_def] res = [];\n     alt (peek(st) as char) {\n         case (':') {\n             do  {\n@@ -92,7 +92,7 @@ fn parse_constrs(@pstate st, str_def sd) -> vec[@ast::constr] {\n     ret res;\n }\n \n-fn parse_constr(@pstate st, str_def sd) -> @ast::constr {\n+fn parse_constr(@pstate st, str_def sd) -> @ty::constr_def {\n     st.tcx.sess.unimpl(\"Reading constraints \" + \" isn't implemented\");\n     /*\n     let vec[@ast::constr_arg] args = [];\n@@ -318,7 +318,7 @@ fn parse_hex(@pstate st) -> uint {\n }\n \n fn parse_ty_fn(@pstate st, str_def sd) ->\n-   tup(vec[ty::arg], ty::t, ast::controlflow, vec[@ast::constr]) {\n+   tup(vec[ty::arg], ty::t, ast::controlflow, vec[@ty::constr_def]) {\n     assert (next(st) as char == '[');\n     let vec[ty::arg] inputs = [];\n     while (peek(st) as char != ']') {"}, {"sha": "88d8516043baff5cce7cafffaae0931ad32b975a", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 62, "deletions": 16, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=260aa408f390cf457eb19507fc80ec388a039f8e", "patch": "@@ -5,6 +5,9 @@ import std::str;\n import std::option;\n import std::option::some;\n import std::option::none;\n+import std::either;\n+import std::either::left;\n+import std::either::right;\n import std::map::hashmap;\n import driver::session;\n import util::common;\n@@ -816,14 +819,9 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n         hi = es.span.hi;\n         ex = ast::expr_bind(e, es.node, p.get_ann());\n     } else if (p.peek() == token::POUND) {\n-        p.bump();\n-        auto pth = parse_path(p);\n-        auto es =\n-            parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n-                      parse_expr, p);\n-        hi = es.span.hi;\n-        auto ext_span = rec(lo=lo, hi=hi);\n-        ex = expand_syntax_ext(p, ext_span, pth, es.node, none);\n+        auto ex_ext = parse_syntax_ext(p);\n+        lo = ex_ext.span.lo;\n+        ex = ex_ext.node;\n     } else if (eat_word(p, \"fail\")) {\n         auto msg;\n         alt (p.peek()) {\n@@ -917,6 +915,21 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n     ret @spanned(lo, hi, ex);\n }\n \n+fn parse_syntax_ext(&parser p) -> @ast::expr {\n+    auto lo = p.get_lo_pos();\n+    expect(p, token::POUND);\n+    ret parse_syntax_ext_inner(p, lo);\n+}\n+\n+fn parse_syntax_ext_inner(&parser p, uint lo) -> @ast::expr {\n+    auto pth = parse_path(p);\n+    auto es = parse_seq(token::LPAREN, token::RPAREN,\n+                        some(token::COMMA), parse_expr, p);\n+    auto hi = es.span.hi;\n+    auto ext_span = rec(lo=lo, hi=hi);\n+    auto ex = expand_syntax_ext(p, ext_span, pth, es.node, none);\n+    ret @spanned(lo, hi, ex);\n+}\n \n /*\n  * FIXME: This is a crude approximation of the syntax-extension system,\n@@ -1423,7 +1436,22 @@ fn parse_source_stmt(&parser p) -> @ast::stmt {\n         auto hi = p.get_span();\n         ret @spanned(lo, decl.span.hi, ast::stmt_decl(decl, p.get_ann()));\n     } else {\n-        alt (parse_item(p, [])) {\n+\n+        auto item_attrs;\n+        alt (parse_attrs_or_ext(p)) {\n+            case (none) {\n+                item_attrs = [];\n+            }\n+            case (some(left(?attrs))) {\n+                item_attrs = attrs;\n+            }\n+            case (some(right(?ext))) {\n+                ret @spanned(lo, ext.span.hi,\n+                             ast::stmt_expr(ext, p.get_ann()));\n+            }\n+        }\n+\n+        alt (parse_item(p, item_attrs)) {\n             case (got_item(?i)) {\n                 auto hi = i.span.hi;\n                 auto decl = @spanned(lo, hi, ast::decl_item(i));\n@@ -1936,6 +1964,26 @@ fn parse_item(&parser p, vec[ast::attribute] attrs) -> parsed_item {\n     } else { ret no_item; }\n }\n \n+// A type to distingush between the parsing of item attributes or syntax\n+// extensions, which both begin with token.POUND\n+type attr_or_ext = option::t[either::t[vec[ast::attribute],\n+                                       @ast::expr]];\n+\n+fn parse_attrs_or_ext(&parser p) -> attr_or_ext {\n+    if (p.peek() == token::POUND) {\n+        auto lo = p.get_lo_pos();\n+        p.bump();\n+        if (p.peek() == token::LBRACKET) {\n+            auto first_attr = parse_attribute_inner(p, lo);\n+            ret some(left([first_attr] + parse_attributes(p)));\n+        } else {\n+            ret some(right(parse_syntax_ext_inner(p, lo)));\n+        }\n+    } else {\n+        ret none;\n+    }\n+}\n+\n fn parse_attributes(&parser p) -> vec[ast::attribute] {\n     let vec[ast::attribute] attrs = [];\n     while (p.peek() == token::POUND) { attrs += [parse_attribute(p)]; }\n@@ -1945,6 +1993,10 @@ fn parse_attributes(&parser p) -> vec[ast::attribute] {\n fn parse_attribute(&parser p) -> ast::attribute {\n     auto lo = p.get_lo_pos();\n     expect(p, token::POUND);\n+    ret parse_attribute_inner(p, lo);\n+}\n+\n+fn parse_attribute_inner(&parser p, uint lo) -> ast::attribute {\n     expect(p, token::LBRACKET);\n     auto meta_item = parse_meta_item(p);\n     expect(p, token::RBRACKET);\n@@ -2181,13 +2233,7 @@ fn parse_crate_directive(&parser p) -> ast::crate_directive {\n         auto hi = p.get_hi_pos();\n         expect(p, token::RBRACE);\n         ret spanned(lo, hi, ast::cdir_let(id, x, v));\n-    } else if (is_word(p, \"use\")) {\n-        auto vi = parse_view_item(p);\n-        ret spanned(lo, vi.span.hi, ast::cdir_view_item(vi));\n-    } else if (is_word(p, \"import\")) {\n-        auto vi = parse_view_item(p);\n-        ret spanned(lo, vi.span.hi, ast::cdir_view_item(vi));\n-    } else if (is_word(p, \"export\")) {\n+    } else if (is_view_item(p)) {\n         auto vi = parse_view_item(p);\n         ret spanned(lo, vi.span.hi, ast::cdir_view_item(vi));\n     } else {"}, {"sha": "57cb33b8af60f5a25dbcf7d1ddf968126e7d5d5c", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 79, "deletions": 37, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=260aa408f390cf457eb19507fc80ec388a039f8e", "patch": "@@ -35,14 +35,11 @@ tag local_info { arg(ast::mode); objfield(ast::mutability); }\n \n type ctx =\n     rec(@ty::ctxt tcx,\n-        resolve::def_map dm,\n         std::map::hashmap[def_num, local_info] local_map);\n \n-fn check_crate(@ty::ctxt tcx, resolve::def_map dm, &@ast::crate crate) {\n+fn check_crate(@ty::ctxt tcx, &@ast::crate crate) {\n     auto cx =\n         @rec(tcx=tcx,\n-             dm=dm,\n-\n              // Stores information about object fields and function\n              // arguments that's otherwise not easily available.\n              local_map=util::common::new_int_hash());\n@@ -77,12 +74,18 @@ fn visit_item(@ctx cx, &@ast::item i, &scope sc, &vt[scope] v) {\n }\n \n fn visit_expr(@ctx cx, &@ast::expr ex, &scope sc, &vt[scope] v) {\n-    auto handled = false;\n+    auto handled = true;\n     alt (ex.node) {\n-        case (ast::expr_call(?f, ?args, _)) { check_call(*cx, f, args, sc); }\n+        case (ast::expr_call(?f, ?args, _)) {\n+            check_call(*cx, f, args, sc);\n+            handled = false;\n+        }\n+        case (ast::expr_be(?cl, _)) {\n+            check_tail_call(*cx, cl);\n+            visit::visit_expr(cl, sc, v);\n+        }\n         case (ast::expr_alt(?input, ?arms, _)) {\n             check_alt(*cx, input, arms, sc, v);\n-            handled = true;\n         }\n         case (ast::expr_put(?val, _)) {\n             alt (val) {\n@@ -97,44 +100,36 @@ fn visit_expr(@ctx cx, &@ast::expr ex, &scope sc, &vt[scope] v) {\n                 }\n                 case (_) { }\n             }\n-            handled = true;\n         }\n         case (ast::expr_for_each(?decl, ?call, ?block, _)) {\n             check_for_each(*cx, decl, call, block, sc, v);\n-            handled = true;\n         }\n         case (ast::expr_for(?decl, ?seq, ?block, _)) {\n             check_for(*cx, decl, seq, block, sc, v);\n-            handled = true;\n         }\n         case (ast::expr_path(?pt, ?ann)) {\n             check_var(*cx, ex, pt, ann, false, sc);\n+            handled = false;\n         }\n         case (ast::expr_move(?dest, ?src, _)) {\n             check_assign(cx, dest, src, sc, v);\n-            handled = true;\n         }\n         case (ast::expr_assign(?dest, ?src, _)) {\n             check_assign(cx, dest, src, sc, v);\n-            handled = true;\n         }\n         case (ast::expr_assign_op(_, ?dest, ?src, _)) {\n             check_assign(cx, dest, src, sc, v);\n-            handled = true;\n         }\n-        case (_) { }\n+        case (_) { handled = false; }\n     }\n     if (!handled) { visit::visit_expr(ex, sc, v); }\n }\n \n fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc) ->\n    rec(vec[def_num] root_vars, vec[ty::t] unsafe_ts) {\n     auto fty = ty::expr_ty(*cx.tcx, f);\n-    auto arg_ts =\n-        alt (ty::struct(*cx.tcx, fty)) {\n-            case (ty::ty_fn(_, ?args, _, _, _)) { args }\n-            case (ty::ty_native_fn(_, ?args, _)) { args }\n-        };\n+    auto arg_ts = fty_args(cx, fty);\n+\n     let vec[def_num] roots = [];\n     let vec[tup(uint, def_num)] mut_roots = [];\n     let vec[ty::t] unsafe_ts = [];\n@@ -175,11 +170,11 @@ fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc) ->\n     if (vec::len(unsafe_ts) > 0u) {\n         alt (f.node) {\n             case (ast::expr_path(_, ?ann)) {\n-                if (def_is_local(cx.dm.get(ann.id))) {\n-                    cx.tcx.sess.span_err(f.span,\n-                                         #fmt(\"function may alias with \\\n-                         argument %u, which is not immutably rooted\",\n-                                              unsafe_t_offsets.(0)));\n+                if (def_is_local(cx.tcx.def_map.get(ann.id), true)) {\n+                    cx.tcx.sess.span_err\n+                        (f.span, #fmt(\"function may alias with argument \\\n+                         %u, which is not immutably rooted\",\n+                         unsafe_t_offsets.(0)));\n                 }\n             }\n             case (_) { }\n@@ -221,8 +216,47 @@ fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc) ->\n     ret rec(root_vars=roots, unsafe_ts=unsafe_ts);\n }\n \n-fn check_alt(&ctx cx, &@ast::expr input, &vec[ast::arm] arms, &scope sc,\n-             &vt[scope] v) {\n+fn check_tail_call(&ctx cx, &@ast::expr call) {\n+    auto args;\n+    auto f = alt (call.node) {\n+        case (ast::expr_call(?f, ?args_, _)) { args = args_; f }\n+    };\n+    auto i = 0u;\n+    for (ty::arg arg_t in fty_args(cx, ty::expr_ty(*cx.tcx, f))) {\n+        if (arg_t.mode != ty::mo_val) {\n+            auto mut_a = arg_t.mode == ty::mo_alias(true);\n+            auto ok = true;\n+            alt (args.(i).node) {\n+                case (ast::expr_path(_, ?ann)) {\n+                    auto def = cx.tcx.def_map.get(ann.id);\n+                    auto dnum = ast::def_id_of_def(def)._1;\n+                    alt (cx.local_map.find(dnum)) {\n+                        case (some(arg(ast::alias(?mut)))) {\n+                            if (mut_a && !mut) {\n+                                cx.tcx.sess.span_warn\n+                                    (args.(i).span, \"passing an immutable \\\n+                                     alias by mutable alias\");\n+                            }\n+                        }\n+                        case (_) {\n+                            ok = !def_is_local(def, false);\n+                        }\n+                    }\n+                }\n+                case (_) { ok = false; }\n+            }\n+            if (!ok) {\n+                cx.tcx.sess.span_warn\n+                    (args.(i).span, \"can not pass a local value by alias to \\\n+                                     a tail call\");\n+            }\n+        }\n+        i += 1u;\n+    }\n+}\n+\n+fn check_alt(&ctx cx, &@ast::expr input, &vec[ast::arm] arms,\n+             &scope sc, &vt[scope] v) {\n     visit::visit_expr(input, sc, v);\n     auto root = expr_root(cx, input, true);\n     auto roots =\n@@ -316,8 +350,8 @@ fn check_for(&ctx cx, &@ast::local local, &@ast::expr seq, &ast::block block,\n \n fn check_var(&ctx cx, &@ast::expr ex, &ast::path p, ast::ann ann, bool assign,\n              &scope sc) {\n-    auto def = cx.dm.get(ann.id);\n-    if (!def_is_local(def)) { ret; }\n+    auto def = cx.tcx.def_map.get(ann.id);\n+    if (!def_is_local(def, true)) { ret; }\n     auto my_defnum = ast::def_id_of_def(def)._1;\n     auto var_t = ty::expr_ty(*cx.tcx, ex);\n     for (restrict r in sc) {\n@@ -342,7 +376,7 @@ fn check_assign(&@ctx cx, &@ast::expr dest, &@ast::expr src, &scope sc,\n     visit_expr(cx, src, sc, v);\n     alt (dest.node) {\n         case (ast::expr_path(?p, ?ann)) {\n-            auto dnum = ast::def_id_of_def(cx.dm.get(ann.id))._1;\n+            auto dnum = ast::def_id_of_def(cx.tcx.def_map.get(ann.id))._1;\n             if (is_immutable_alias(cx, sc, dnum)) {\n                 cx.tcx.sess.span_err(dest.span,\n                                      \"assigning to immutable alias\");\n@@ -529,7 +563,7 @@ fn inner_mut(&vec[deref] ds) -> option::t[ty::t] {\n fn path_def_id(&ctx cx, &@ast::expr ex) -> option::t[ast::def_id] {\n     alt (ex.node) {\n         case (ast::expr_path(_, ?ann)) {\n-            ret some(ast::def_id_of_def(cx.dm.get(ann.id)));\n+            ret some(ast::def_id_of_def(cx.tcx.def_map.get(ann.id)));\n         }\n         case (_) { ret none; }\n     }\n@@ -594,15 +628,23 @@ fn ty_can_unsafely_include(&ctx cx, ty::t needle, ty::t haystack, bool mut) ->\n     ret helper(*cx.tcx, needle, haystack, mut);\n }\n \n-fn def_is_local(&ast::def d) -> bool {\n+fn def_is_local(&ast::def d, bool objfields_count) -> bool {\n     ret alt (d) {\n-            case (ast::def_local(_)) { true }\n-            case (ast::def_arg(_)) { true }\n-            case (ast::def_obj_field(_)) { true }\n-            case (ast::def_binding(_)) { true }\n-            case (_) { false }\n-        };\n+        case (ast::def_local(_)) { true }\n+        case (ast::def_arg(_)) { true }\n+        case (ast::def_obj_field(_)) { objfields_count }\n+        case (ast::def_binding(_)) { true }\n+        case (_) { false }\n+    };\n }\n+\n+fn fty_args(&ctx cx, ty::t fty) -> vec[ty::arg] {\n+    ret alt (ty::struct(*cx.tcx, fty)) {\n+        case (ty::ty_fn(_, ?args, _, _, _)) { args }\n+        case (ty::ty_native_fn(_, ?args, _)) { args }\n+    };\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "dc2acfa6ca74e536bdd225c5a92804a853aee3f1", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=260aa408f390cf457eb19507fc80ec388a039f8e", "patch": "@@ -221,8 +221,7 @@ mod Encode {\n                     case (ast::native_abi_cdecl) { w.write_char('c'); }\n                     case (ast::native_abi_llvm) { w.write_char('l'); }\n                 }\n-                let vec[@constr] res_constrs = [];\n-                enc_ty_fn(w, cx, args, out, ast::return, res_constrs);\n+                enc_ty_fn(w, cx, args, out, ast::return, []);\n             }\n             case (ty::ty_obj(?methods)) {\n                 w.write_str(\"O[\");\n@@ -253,7 +252,7 @@ mod Encode {\n         }\n     }\n     fn enc_ty_fn(&io::writer w, &@ctxt cx, &vec[ty::arg] args, &ty::t out,\n-                 &ast::controlflow cf, &vec[@ast::constr] constrs) {\n+                 &ast::controlflow cf, &vec[@ty::constr_def] constrs) {\n         w.write_char('[');\n         for (ty::arg arg in args) {\n             alt (arg.mode) {\n@@ -271,15 +270,15 @@ mod Encode {\n             case (_) { enc_ty(w, cx, out); }\n         }\n         auto colon = true;\n-        for (@ast::constr c in constrs) {\n+        for (@ty::constr_def c in constrs) {\n             if (colon) {\n                 w.write_char(':');\n                 colon = false;\n             } else { w.write_char(','); }\n             enc_constr(w, cx, c);\n         }\n     }\n-    fn enc_constr(&io::writer w, &@ctxt cx, &@ast::constr c) {\n+    fn enc_constr(&io::writer w, &@ctxt cx, &@ty::constr_def c) {\n         w.write_str(path_to_str(c.node.path));\n         w.write_char('(');\n         // FIXME"}, {"sha": "4d20216564ca575f61801165b4bce87fc515cf72", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 57, "deletions": 15, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=260aa408f390cf457eb19507fc80ec388a039f8e", "patch": "@@ -11,7 +11,8 @@ import util::common::new_int_hash;\n import util::common::new_uint_hash;\n import util::common::new_str_hash;\n import util::common::span;\n-import middle::tstate::ann::ts_ann;\n+import util::common::respan;\n+import middle::ty::constr_table;\n import visit::vt;\n import std::map::hashmap;\n import std::list;\n@@ -111,24 +112,26 @@ type def_map = hashmap[uint, def];\n type env =\n     rec(crate_map crate_map,\n         def_map def_map,\n+        constr_table fn_constrs,\n         hashmap[def_id, @ast::item] ast_map,\n         hashmap[ast::def_num, import_state] imports,\n         hashmap[ast::def_num, @indexed_mod] mod_map,\n         hashmap[def_id, vec[ident]] ext_map,\n         ext_hash ext_cache,\n         session sess);\n \n-\n // Used to distinguish between lookups from outside and from inside modules,\n // since export restrictions should only be applied for the former.\n tag dir { inside; outside; }\n \n tag namespace { ns_value; ns_type; ns_module; }\n \n-fn resolve_crate(session sess, @ast::crate crate) -> def_map {\n+fn resolve_crate(session sess, @ast::crate crate)\n+    -> tup(def_map, constr_table) {\n     auto e =\n         @rec(crate_map=new_uint_hash[ast::crate_num](),\n              def_map=new_uint_hash[def](),\n+             fn_constrs = new_def_hash[vec[ty::constr_def]](),\n              ast_map=new_def_hash[@ast::item](),\n              imports=new_int_hash[import_state](),\n              mod_map=new_int_hash[@indexed_mod](),\n@@ -140,7 +143,7 @@ fn resolve_crate(session sess, @ast::crate crate) -> def_map {\n     resolve_imports(*e);\n     check_for_collisions(e, *crate);\n     resolve_names(e, crate);\n-    ret e.def_map;\n+    ret tup(e.def_map, e.fn_constrs);\n }\n \n \n@@ -266,8 +269,9 @@ fn resolve_names(&@env e, &@ast::crate c) {\n              visit_arm=bind walk_arm(e, _, _, _),\n              visit_expr=bind walk_expr(e, _, _, _),\n              visit_ty=bind walk_ty(e, _, _, _),\n-             visit_fn=visit_fn_with_scope,\n-             visit_constr=bind walk_constr(e, _, _, _)\n+             visit_constr = bind walk_constr(e, _, _, _),\n+             visit_fn=bind visit_fn_with_scope\n+                        (e, _, _, _, _, _, _, _, _)\n              with *visit::default_visitor());\n     visit::visit_crate(*c, cons(scope_crate(c), @nil), visit::vtor(v));\n     fn walk_expr(@env e, &@ast::expr exp, &scopes sc, &vt[scopes] v) {\n@@ -282,12 +286,7 @@ fn resolve_names(&@env e, &@ast::crate c) {\n             case (_) { }\n         }\n     }\n-    fn walk_constr(@env e, &@ast::constr c, &scopes sc, &vt[scopes] v) {\n-        auto new_def =\n-            lookup_path_strict(*e, sc, c.span, c.node.path.node.idents,\n-                               ns_value);\n-        e.def_map.insert(c.node.ann.id, new_def);\n-    }\n+\n     fn walk_ty(@env e, &@ast::ty t, &scopes sc, &vt[scopes] v) {\n         visit::visit_ty(t, sc, v);\n         alt (t.node) {\n@@ -300,6 +299,13 @@ fn resolve_names(&@env e, &@ast::crate c) {\n             case (_) { }\n         }\n     }\n+\n+    fn walk_constr(@env e, &@ast::constr c, &scopes sc, &vt[scopes] v) {\n+        auto new_def = lookup_path_strict(*e, sc, c.span,\n+                                          c.node.path.node.idents, ns_value);\n+        e.def_map.insert(c.node.ann.id, new_def);\n+    }\n+\n     fn walk_arm(@env e, &ast::arm a, &scopes sc, &vt[scopes] v) {\n         walk_pat(*e, sc, a.pat);\n         visit_arm_with_scope(a, sc, v);\n@@ -338,11 +344,16 @@ fn visit_native_item_with_scope(&@ast::native_item ni, &scopes sc,\n     visit::visit_native_item(ni, cons(scope_native_item(ni), @sc), v);\n }\n \n-fn visit_fn_with_scope(&ast::_fn f, &vec[ast::ty_param] tp, &span sp,\n+fn visit_fn_with_scope(&@env e, &ast::_fn f, &vec[ast::ty_param] tp, &span sp,\n                        &ident name, &def_id d_id, &ann a, &scopes sc,\n                        &vt[scopes] v) {\n-    visit::visit_fn(f, tp, sp, name, d_id, a, cons(scope_fn(f.decl, tp), @sc),\n-                    v);\n+    // here's where we need to set up the mapping\n+    // for f's constrs in the table.\n+    for (@ast::constr c in f.decl.constraints) {\n+        resolve_constr(e, d_id, c, sc, v); \n+    }\n+    visit::visit_fn(f, tp, sp, name, d_id, a,\n+                    cons(scope_fn(f.decl, tp), @sc), v);\n }\n \n fn visit_block_with_scope(&ast::block b, &scopes sc, &vt[scopes] v) {\n@@ -389,6 +400,37 @@ fn follow_import(&env e, &scopes sc, vec[ident] path, &span sp) -> def {\n     }\n }\n \n+fn resolve_constr(@env e, &def_id d_id, &@ast::constr c, &scopes sc,\n+                  &vt[scopes] v) {\n+    let def new_def = lookup_path_strict(*e, sc, c.span,\n+                                         c.node.path.node.idents,\n+                                         ns_value);\n+    alt (new_def) {\n+        case (ast::def_fn(?pred_id)) {\n+            let ty::constr_general[uint] c_ = rec(path=c.node.path,\n+                                                  args=c.node.args,\n+                                                  id=pred_id);\n+            let ty::constr_def new_constr = respan(c.span, c_);\n+            add_constr(e, d_id, new_constr);\n+        }\n+        case (_) {\n+            e.sess.span_err(c.span, \"Non-predicate in constraint: \"\n+                            + ty::path_to_str(c.node.path));\n+        }\n+    }\n+}\n+\n+fn add_constr(&@env e, &def_id d_id, &ty::constr_def c) {\n+    e.fn_constrs.insert(d_id,\n+       alt (e.fn_constrs.find(d_id)) {\n+          case (none) {\n+              [c]\n+          }\n+          case (some(?cs)) {\n+              cs + [c]\n+          }\n+       });\n+}\n \n // Import resolution\n fn resolve_import(&env e, &@ast::view_item it, &scopes sc) {"}, {"sha": "7bde65f40d8c7a8c2440163adfacbc630f31f3de", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 355, "deletions": 385, "changes": 740, "blob_url": "https://github.com/rust-lang/rust/blob/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=260aa408f390cf457eb19507fc80ec388a039f8e", "patch": "@@ -113,13 +113,18 @@ type stats =\n         mutable uint n_null_glues,\n         mutable uint n_real_glues);\n \n+// Crate context.  Every crate we compile has one of these.\n type crate_ctxt =\n     rec(session::session sess,\n         ModuleRef llmod,\n         target_data td,\n         type_names tn,\n         hashmap[str, ValueRef] externs,\n         hashmap[str, ValueRef] intrinsics,\n+\n+        // A mapping from the def_id of each item in this crate to the address\n+        // of the first instruction of the item's definition in the executable\n+        // we're generating.\n         hashmap[ast::def_id, ValueRef] item_ids,\n         hashmap[ast::def_id, @ast::item] items,\n         hashmap[ast::def_id, @ast::native_item] native_items,\n@@ -1110,7 +1115,7 @@ fn trans_non_gc_free(&@block_ctxt cx, ValueRef v) -> result {\n fn find_scope_cx(&@block_ctxt cx) -> @block_ctxt {\n     if (cx.kind != NON_SCOPE_BLOCK) { ret cx; }\n     alt (cx.parent) {\n-        case (parent_some(?b)) { be find_scope_cx(b); }\n+        case (parent_some(?b)) { ret find_scope_cx(b); }\n         case (parent_none) {\n             cx.fcx.lcx.ccx.sess.bug(\"trans::find_scope_cx() \" +\n                                         \"called on parentless block_ctxt\");\n@@ -2369,7 +2374,7 @@ fn make_numerical_cmp_glue(&@block_ctxt cx, ValueRef lhs, ValueRef rhs,\n \n // Returns the length of an interior vector and a pointer to its first\n // element, in that order.\n-fn get_ivec_len_and_data(&@block_ctxt bcx, ValueRef v, ty::t unit_ty) ->\n+fn get_len_and_data(&@block_ctxt bcx, ValueRef v, ty::t unit_ty) ->\n    tup(ValueRef, ValueRef, @block_ctxt) {\n     auto llunitty = type_of_or_i8(bcx, unit_ty);\n     auto stack_len =\n@@ -2450,7 +2455,7 @@ fn iter_structural_ty(&@block_ctxt cx, ValueRef v, &ty::t t, val_and_ty_fn f)\n                   ty::t t) -> result {\n         ret f(cx, av, t);\n     }\n-    be iter_structural_ty_full(cx, v, v, t, bind adaptor_fn(f, _, _, _, _));\n+    ret iter_structural_ty_full(cx, v, v, t, bind adaptor_fn(f, _, _, _, _));\n }\n \n fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n@@ -2481,11 +2486,13 @@ fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n         auto rslt = size_of(bcx, unit_ty);\n         auto unit_sz = rslt.val;\n         bcx = rslt.bcx;\n-        auto a_len_and_data = get_ivec_len_and_data(bcx, av, unit_ty);\n+\n+        auto a_len_and_data = ivec::get_len_and_data(bcx, av, unit_ty);\n         auto a_len = a_len_and_data._0;\n         auto a_elem = a_len_and_data._1;\n         bcx = a_len_and_data._2;\n-        auto b_len_and_data = get_ivec_len_and_data(bcx, bv, unit_ty);\n+\n+        auto b_len_and_data = ivec::get_len_and_data(bcx, bv, unit_ty);\n         auto b_len = b_len_and_data._0;\n         auto b_elem = b_len_and_data._1;\n         bcx = b_len_and_data._2;\n@@ -2688,8 +2695,8 @@ fn iter_sequence_inner(&@block_ctxt cx, ValueRef src,\n         ret f(cx, load_if_immediate(cx, p, elt_ty), elt_ty);\n     }\n     auto elt_sz = size_of(cx, elt_ty);\n-    be iter_sequence_raw(elt_sz.bcx, src, src, src_lim, elt_sz.val,\n-                         bind adaptor_fn(f, elt_ty, _, _, _));\n+    ret iter_sequence_raw(elt_sz.bcx, src, src, src_lim, elt_sz.val,\n+                          bind adaptor_fn(f, elt_ty, _, _, _));\n }\n \n \n@@ -3209,209 +3216,292 @@ fn trans_vec_append(&@block_ctxt cx, &ty::t t, ValueRef lhs, ValueRef rhs) ->\n }\n \n \n-// Returns a tuple consisting of a pointer to the newly-reserved space and a\n-// block context. Updates the length appropriately.\n-fn reserve_ivec_space(&@block_ctxt cx, TypeRef llunitty, ValueRef v,\n-                      ValueRef len_needed) -> result {\n-    auto stack_len_ptr =\n-        cx.build.InBoundsGEP(v, [C_int(0), C_uint(abi::ivec_elt_len)]);\n-    auto stack_len = cx.build.Load(stack_len_ptr);\n-    auto alen =\n-        cx.build.Load(cx.build.InBoundsGEP(v,\n-                                           [C_int(0),\n-                                            C_uint(abi::ivec_elt_alen)]));\n-    // There are four cases we have to consider:\n-    // (1) On heap, no resize necessary.\n-    // (2) On heap, need to resize.\n-    // (3) On stack, no resize necessary.\n-    // (4) On stack, need to spill to heap.\n-\n-    auto maybe_on_heap =\n-        cx.build.ICmp(lib::llvm::LLVMIntEQ, stack_len, C_int(0));\n-    auto maybe_on_heap_cx = new_sub_block_ctxt(cx, \"maybe_on_heap\");\n-    auto on_stack_cx = new_sub_block_ctxt(cx, \"on_stack\");\n-    cx.build.CondBr(maybe_on_heap, maybe_on_heap_cx.llbb, on_stack_cx.llbb);\n-    auto next_cx = new_sub_block_ctxt(cx, \"next\");\n-    // We're possibly on the heap, unless the vector is zero-length.\n+mod ivec {\n+    // Returns the length of an interior vector and a pointer to its first\n+    // element, in that order.\n+    fn get_len_and_data(&@block_ctxt bcx, ValueRef v, ty::t unit_ty) ->\n+            tup(ValueRef, ValueRef, @block_ctxt) {\n+        auto llunitty = type_of_or_i8(bcx, unit_ty);\n+        auto stack_len =\n+            bcx.build.Load(bcx.build.InBoundsGEP(v,\n+                [C_int(0), C_uint(abi::ivec_elt_len)]));\n+        auto stack_elem =\n+            bcx.build.InBoundsGEP(v,\n+                [C_int(0), C_uint(abi::ivec_elt_elems), C_int(0)]);\n+        auto on_heap = bcx.build.ICmp(lib::llvm::LLVMIntEQ, stack_len,\n+                                      C_int(0));\n+        auto on_heap_cx = new_sub_block_ctxt(bcx, \"on_heap\");\n+        auto next_cx = new_sub_block_ctxt(bcx, \"next\");\n+        bcx.build.CondBr(on_heap, on_heap_cx.llbb, next_cx.llbb);\n+        auto heap_stub =\n+            on_heap_cx.build.PointerCast(v, T_ptr(T_ivec_heap(llunitty)));\n+        auto heap_ptr = {\n+            auto v = [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)];\n+            on_heap_cx.build.Load(on_heap_cx.build.InBoundsGEP(heap_stub, v))\n+        };\n \n-    auto stub_p = [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)];\n+        // Check whether the heap pointer is null. If it is, the vector length\n+        // is truly zero.\n \n-    auto stub_ptr =\n-        maybe_on_heap_cx.build.PointerCast(v, T_ptr(T_ivec_heap(llunitty)));\n-    auto heap_ptr =\n-        {\n-            auto m = maybe_on_heap_cx.build.InBoundsGEP(stub_ptr, stub_p);\n-            maybe_on_heap_cx.build.Load(m)\n+        auto llstubty = T_ivec_heap(llunitty);\n+        auto llheapptrty = struct_elt(llstubty, abi::ivec_heap_stub_elt_ptr);\n+        auto heap_ptr_is_null =\n+            on_heap_cx.build.ICmp(lib::llvm::LLVMIntEQ, heap_ptr,\n+                                  C_null(T_ptr(llheapptrty)));\n+        auto zero_len_cx = new_sub_block_ctxt(bcx, \"zero_len\");\n+        auto nonzero_len_cx = new_sub_block_ctxt(bcx, \"nonzero_len\");\n+        on_heap_cx.build.CondBr(heap_ptr_is_null, zero_len_cx.llbb,\n+                                nonzero_len_cx.llbb);\n+        // Technically this context is unnecessary, but it makes this function\n+        // clearer.\n+\n+        auto zero_len = C_int(0);\n+        auto zero_elem = C_null(T_ptr(llunitty));\n+        zero_len_cx.build.Br(next_cx.llbb);\n+        // If we're here, then we actually have a heapified vector.\n+\n+        auto heap_len = {\n+            auto v = [C_int(0), C_uint(abi::ivec_heap_elt_len)];\n+            auto m = nonzero_len_cx.build.InBoundsGEP(heap_ptr, v);\n+            nonzero_len_cx.build.Load(m)\n         };\n-    auto on_heap =\n-        maybe_on_heap_cx.build.ICmp(lib::llvm::LLVMIntNE, heap_ptr,\n-                                    C_null(val_ty(heap_ptr)));\n-    auto on_heap_cx = new_sub_block_ctxt(cx, \"on_heap\");\n-    maybe_on_heap_cx.build.CondBr(on_heap, on_heap_cx.llbb, on_stack_cx.llbb);\n-    // We're definitely on the heap. Check whether we need to resize.\n-\n-    auto heap_len_ptr =\n-        on_heap_cx.build.InBoundsGEP(heap_ptr,\n-                                     [C_int(0),\n-                                      C_uint(abi::ivec_heap_elt_len)]);\n-    auto heap_len = on_heap_cx.build.Load(heap_len_ptr);\n-    auto new_heap_len = on_heap_cx.build.Add(heap_len, len_needed);\n-    auto heap_len_unscaled =\n-        on_heap_cx.build.UDiv(heap_len, llsize_of(llunitty));\n-    auto heap_no_resize_needed =\n-        on_heap_cx.build.ICmp(lib::llvm::LLVMIntULE, new_heap_len, alen);\n-    auto heap_no_resize_cx = new_sub_block_ctxt(cx, \"heap_no_resize\");\n-    auto heap_resize_cx = new_sub_block_ctxt(cx, \"heap_resize\");\n-    on_heap_cx.build.CondBr(heap_no_resize_needed, heap_no_resize_cx.llbb,\n-                            heap_resize_cx.llbb);\n-    // Case (1): We're on the heap and don't need to resize.\n-\n-    auto heap_data_no_resize =\n-        heap_no_resize_cx.build.InBoundsGEP(heap_ptr,\n-                                            [C_int(0),\n-                                             C_uint(abi::ivec_heap_elt_elems),\n-                                             heap_len_unscaled]);\n-    heap_no_resize_cx.build.Store(new_heap_len, heap_len_ptr);\n-    heap_no_resize_cx.build.Br(next_cx.llbb);\n-    // Case (2): We're on the heap and need to resize. This path is rare, so\n-    // we delegate to cold glue.\n-\n-    {\n-        auto p = heap_resize_cx.build.PointerCast(v, T_ptr(T_opaque_ivec()));\n-        heap_resize_cx.build.Call(cx.fcx.lcx.ccx.upcalls.ivec_resize,\n-                                  [cx.fcx.lltaskptr, p, new_heap_len]);\n-    }\n-\n-    auto heap_ptr_resize =\n+        auto heap_elem =\n+            nonzero_len_cx.build.InBoundsGEP(heap_ptr,\n+                [C_int(0), C_uint(abi::ivec_heap_elt_elems), C_int(0)]);\n+        nonzero_len_cx.build.Br(next_cx.llbb);\n+\n+        // Now we can figure out the length of `v` and get a pointer to its\n+        // first element.\n+\n+        auto len =\n+            next_cx.build.Phi(T_int(),\n+                [stack_len, zero_len, heap_len],\n+                [bcx.llbb, zero_len_cx.llbb, nonzero_len_cx.llbb]);\n+        auto elem =\n+            next_cx.build.Phi(T_ptr(llunitty),\n+                [stack_elem, zero_elem, heap_elem],\n+                [bcx.llbb, zero_len_cx.llbb, nonzero_len_cx.llbb]);\n+        ret tup(len, elem, next_cx);\n+    }\n+\n+    // Returns a tuple consisting of a pointer to the newly-reserved space and\n+    // a block context. Updates the length appropriately.\n+    fn reserve_space(&@block_ctxt cx, TypeRef llunitty, ValueRef v,\n+                     ValueRef len_needed) -> result {\n+        auto stack_len_ptr =\n+            cx.build.InBoundsGEP(v, [C_int(0), C_uint(abi::ivec_elt_len)]);\n+        auto stack_len = cx.build.Load(stack_len_ptr);\n+        auto alen =\n+            cx.build.Load(cx.build.InBoundsGEP(v,\n+                                               [C_int(0),\n+                                                C_uint(abi::ivec_elt_alen)]));\n+        // There are four cases we have to consider:\n+        // (1) On heap, no resize necessary.\n+        // (2) On heap, need to resize.\n+        // (3) On stack, no resize necessary.\n+        // (4) On stack, need to spill to heap.\n+\n+        auto maybe_on_heap =\n+            cx.build.ICmp(lib::llvm::LLVMIntEQ, stack_len, C_int(0));\n+        auto maybe_on_heap_cx = new_sub_block_ctxt(cx, \"maybe_on_heap\");\n+        auto on_stack_cx = new_sub_block_ctxt(cx, \"on_stack\");\n+        cx.build.CondBr(maybe_on_heap, maybe_on_heap_cx.llbb,\n+                        on_stack_cx.llbb);\n+        auto next_cx = new_sub_block_ctxt(cx, \"next\");\n+        // We're possibly on the heap, unless the vector is zero-length.\n+\n+        auto stub_p = [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)];\n+\n+        auto stub_ptr = maybe_on_heap_cx.build.PointerCast(v,\n+            T_ptr(T_ivec_heap(llunitty)));\n+        auto heap_ptr =\n+            {\n+                auto m = maybe_on_heap_cx.build.InBoundsGEP(stub_ptr, stub_p);\n+                maybe_on_heap_cx.build.Load(m)\n+            };\n+        auto on_heap =\n+            maybe_on_heap_cx.build.ICmp(lib::llvm::LLVMIntNE, heap_ptr,\n+                                        C_null(val_ty(heap_ptr)));\n+        auto on_heap_cx = new_sub_block_ctxt(cx, \"on_heap\");\n+        maybe_on_heap_cx.build.CondBr(on_heap, on_heap_cx.llbb,\n+                                      on_stack_cx.llbb);\n+\n+        // We're definitely on the heap. Check whether we need to resize.\n+        auto heap_len_ptr =\n+            on_heap_cx.build.InBoundsGEP(heap_ptr,\n+                                         [C_int(0),\n+                                          C_uint(abi::ivec_heap_elt_len)]);\n+        auto heap_len = on_heap_cx.build.Load(heap_len_ptr);\n+        auto new_heap_len = on_heap_cx.build.Add(heap_len, len_needed);\n+        auto heap_len_unscaled =\n+            on_heap_cx.build.UDiv(heap_len, llsize_of(llunitty));\n+        auto heap_no_resize_needed =\n+            on_heap_cx.build.ICmp(lib::llvm::LLVMIntULE, new_heap_len, alen);\n+        auto heap_no_resize_cx = new_sub_block_ctxt(cx, \"heap_no_resize\");\n+        auto heap_resize_cx = new_sub_block_ctxt(cx, \"heap_resize\");\n+        on_heap_cx.build.CondBr(heap_no_resize_needed, heap_no_resize_cx.llbb,\n+                                heap_resize_cx.llbb);\n+        // Case (1): We're on the heap and don't need to resize.\n+\n+        auto heap_data_no_resize =\n+            heap_no_resize_cx.build.InBoundsGEP(heap_ptr,\n+                [C_int(0),\n+                 C_uint(abi::ivec_heap_elt_elems),\n+                 heap_len_unscaled]);\n+        heap_no_resize_cx.build.Store(new_heap_len, heap_len_ptr);\n+        heap_no_resize_cx.build.Br(next_cx.llbb);\n+\n+        // Case (2): We're on the heap and need to resize. This path is rare,\n+        // so we delegate to cold glue.\n+\n         {\n+            auto p = heap_resize_cx.build.PointerCast(v,\n+                                                      T_ptr(T_opaque_ivec()));\n+            heap_resize_cx.build.Call(cx.fcx.lcx.ccx.upcalls.ivec_resize,\n+                                      [cx.fcx.lltaskptr, p, new_heap_len]);\n+        }\n+\n+        auto heap_ptr_resize = {\n             auto m = heap_resize_cx.build.InBoundsGEP(stub_ptr, stub_p);\n             heap_resize_cx.build.Load(m)\n         };\n-    auto heap_data_resize =\n-        heap_resize_cx.build.InBoundsGEP(heap_ptr_resize,\n-                                         [C_int(0),\n-                                          C_uint(abi::ivec_heap_elt_elems),\n-                                          heap_len_unscaled]);\n-    heap_resize_cx.build.Br(next_cx.llbb);\n-    // We're on the stack. Check whether we need to spill to the heap.\n-\n-    auto new_stack_len = on_stack_cx.build.Add(stack_len, len_needed);\n-    auto stack_no_spill_needed =\n-        on_stack_cx.build.ICmp(lib::llvm::LLVMIntULE, new_stack_len, alen);\n-    auto stack_len_unscaled =\n-        on_stack_cx.build.UDiv(stack_len, llsize_of(llunitty));\n-    auto stack_no_spill_cx = new_sub_block_ctxt(cx, \"stack_no_spill\");\n-    auto stack_spill_cx = new_sub_block_ctxt(cx, \"stack_spill\");\n-    on_stack_cx.build.CondBr(stack_no_spill_needed, stack_no_spill_cx.llbb,\n-                             stack_spill_cx.llbb);\n-    // Case (3): We're on the stack and don't need to spill.\n-\n-    auto stack_data_no_spill =\n-        stack_no_spill_cx.build.InBoundsGEP(v,\n-                                            [C_int(0),\n-                                             C_uint(abi::ivec_elt_elems),\n-                                             stack_len_unscaled]);\n-    stack_no_spill_cx.build.Store(new_stack_len, stack_len_ptr);\n-    stack_no_spill_cx.build.Br(next_cx.llbb);\n-    // Case (4): We're on the stack and need to spill. Like case (2), this\n-    // path is rare, so we delegate to cold glue.\n-\n-    {\n-        auto p = stack_spill_cx.build.PointerCast(v, T_ptr(T_opaque_ivec()));\n-        stack_spill_cx.build.Call(cx.fcx.lcx.ccx.upcalls.ivec_spill,\n-                                  [cx.fcx.lltaskptr, p, new_stack_len]);\n-    }\n-    auto spill_stub =\n-        stack_spill_cx.build.PointerCast(v, T_ptr(T_ivec_heap(llunitty)));\n-    auto heap_ptr_spill =\n-        stack_spill_cx.build.Load(stack_spill_cx.build.InBoundsGEP(spill_stub,\n-                                                                   stub_p));\n-    auto heap_len_ptr_spill =\n-        stack_spill_cx.build.InBoundsGEP(heap_ptr_spill,\n-                                         [C_int(0),\n-                                          C_uint(abi::ivec_heap_elt_len)]);\n-    auto heap_data_spill =\n-        stack_spill_cx.build.InBoundsGEP(heap_ptr_spill,\n-                                         [C_int(0),\n-                                          C_uint(abi::ivec_heap_elt_elems),\n-                                          stack_len_unscaled]);\n-    stack_spill_cx.build.Br(next_cx.llbb);\n-    // Phi together the different data pointers to get the result.\n+        auto heap_data_resize =\n+            heap_resize_cx.build.InBoundsGEP(heap_ptr_resize,\n+                [C_int(0),\n+                 C_uint(abi::ivec_heap_elt_elems),\n+                 heap_len_unscaled]);\n+        heap_resize_cx.build.Br(next_cx.llbb);\n+\n+        // We're on the stack. Check whether we need to spill to the heap.\n+        auto new_stack_len = on_stack_cx.build.Add(stack_len, len_needed);\n+        auto stack_no_spill_needed =\n+            on_stack_cx.build.ICmp(lib::llvm::LLVMIntULE, new_stack_len,\n+                                   alen);\n+        auto stack_len_unscaled =\n+            on_stack_cx.build.UDiv(stack_len, llsize_of(llunitty));\n+        auto stack_no_spill_cx = new_sub_block_ctxt(cx, \"stack_no_spill\");\n+        auto stack_spill_cx = new_sub_block_ctxt(cx, \"stack_spill\");\n+        on_stack_cx.build.CondBr(stack_no_spill_needed,\n+                                 stack_no_spill_cx.llbb,\n+                                 stack_spill_cx.llbb);\n+\n+        // Case (3): We're on the stack and don't need to spill.\n+        auto stack_data_no_spill =\n+            stack_no_spill_cx.build.InBoundsGEP(v,\n+                                                [C_int(0),\n+                                                 C_uint(abi::ivec_elt_elems),\n+                                                 stack_len_unscaled]);\n+        stack_no_spill_cx.build.Store(new_stack_len, stack_len_ptr);\n+        stack_no_spill_cx.build.Br(next_cx.llbb);\n+\n+        // Case (4): We're on the stack and need to spill. Like case (2), this\n+        // path is rare, so we delegate to cold glue.\n+        {\n+            auto p = stack_spill_cx.build.PointerCast(v,\n+                T_ptr(T_opaque_ivec()));\n+            stack_spill_cx.build.Call(cx.fcx.lcx.ccx.upcalls.ivec_spill,\n+                                      [cx.fcx.lltaskptr, p, new_stack_len]);\n+        }\n+\n+        auto spill_stub =\n+            stack_spill_cx.build.PointerCast(v, T_ptr(T_ivec_heap(llunitty)));\n+        auto heap_ptr_spill =\n+            stack_spill_cx.build.Load(\n+                stack_spill_cx.build.InBoundsGEP(spill_stub, stub_p));\n+        auto heap_len_ptr_spill =\n+            stack_spill_cx.build.InBoundsGEP(heap_ptr_spill,\n+                [C_int(0), C_uint(abi::ivec_heap_elt_len)]);\n+        auto heap_data_spill =\n+            stack_spill_cx.build.InBoundsGEP(heap_ptr_spill,\n+                [C_int(0),\n+                 C_uint(abi::ivec_heap_elt_elems),\n+                 stack_len_unscaled]);\n+        stack_spill_cx.build.Br(next_cx.llbb);\n+\n+        // Phi together the different data pointers to get the result.\n+        auto data_ptr =\n+            next_cx.build.Phi(T_ptr(llunitty),\n+                              [heap_data_no_resize, heap_data_resize,\n+                               stack_data_no_spill, heap_data_spill],\n+                              [heap_no_resize_cx.llbb, heap_resize_cx.llbb,\n+                               stack_no_spill_cx.llbb, stack_spill_cx.llbb]);\n+        ret res(next_cx, data_ptr);\n+    }\n+\n+    fn trans_append(&@block_ctxt cx, &ty::t t, ValueRef lhs, ValueRef rhs) ->\n+       result {\n+        auto unit_ty = ty::sequence_element_type(cx.fcx.lcx.ccx.tcx, t);\n+        auto llunitty = type_of_or_i8(cx, unit_ty);\n+        auto skip_null;\n+        alt (ty::struct(cx.fcx.lcx.ccx.tcx, t)) {\n+            case (ty::ty_istr) { skip_null = true; }\n+            case (ty::ty_ivec(_)) { skip_null = false; }\n+            case (_) {\n+                cx.fcx.lcx.ccx.tcx.sess.bug(\"non-istr/ivec in trans_append\");\n+            }\n+        }\n+        // Gather the various type descriptors we'll need.\n \n-    auto data_ptr =\n-        next_cx.build.Phi(T_ptr(llunitty),\n-                          [heap_data_no_resize, heap_data_resize,\n-                           stack_data_no_spill, heap_data_spill],\n-                          [heap_no_resize_cx.llbb, heap_resize_cx.llbb,\n-                           stack_no_spill_cx.llbb, stack_spill_cx.llbb]);\n-    ret res(next_cx, data_ptr);\n-}\n+        auto rslt = get_tydesc(cx, t, false, none);\n+        auto vec_tydesc = rslt.val;\n+        auto bcx = rslt.bcx;\n+        rslt = get_tydesc(bcx, unit_ty, false, none);\n+        auto unit_tydesc = rslt.val;\n+        bcx = rslt.bcx;\n \n-fn trans_ivec_append(&@block_ctxt cx, &ty::t t, ValueRef lhs, ValueRef rhs) ->\n-   result {\n-    auto unit_ty = ty::sequence_element_type(cx.fcx.lcx.ccx.tcx, t);\n-    auto llunitty = type_of_or_i8(cx, unit_ty);\n-    auto skip_null;\n-    alt (ty::struct(cx.fcx.lcx.ccx.tcx, t)) {\n-        case (ty::ty_istr) { skip_null = true; }\n-        case (ty::ty_ivec(_)) { skip_null = false; }\n-        case (_) {\n-            cx.fcx.lcx.ccx.tcx.sess.bug(\"non-istr/ivec in trans_ivec_append\");\n-        }\n-    }\n-    // Gather the various type descriptors we'll need.\n+        lazily_emit_tydesc_glue(bcx, abi::tydesc_field_take_glue, none);\n+        lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, none);\n+        lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, none);\n \n-    auto rslt = get_tydesc(cx, t, false, none);\n-    auto vec_tydesc = rslt.val;\n-    auto bcx = rslt.bcx;\n-    rslt = get_tydesc(bcx, unit_ty, false, none);\n-    auto unit_tydesc = rslt.val;\n-    bcx = rslt.bcx;\n-    lazily_emit_tydesc_glue(bcx, abi::tydesc_field_take_glue, none);\n-    lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, none);\n-    lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, none);\n-    auto rhs_len_and_data = get_ivec_len_and_data(bcx, rhs, unit_ty);\n-    auto rhs_len = rhs_len_and_data._0;\n-    auto rhs_data = rhs_len_and_data._1;\n-    bcx = rhs_len_and_data._2;\n-    rslt = reserve_ivec_space(bcx, llunitty, lhs, rhs_len);\n-    auto lhs_data = rslt.val;\n-    bcx = rslt.bcx;\n-    // Work out the end pointer.\n-\n-    auto lhs_unscaled_idx = bcx.build.UDiv(rhs_len, llsize_of(llunitty));\n-    auto lhs_end = bcx.build.InBoundsGEP(lhs_data, [lhs_unscaled_idx]);\n-    // Now emit the copy loop.\n-\n-    auto dest_ptr = alloca(bcx, T_ptr(llunitty));\n-    bcx.build.Store(lhs_data, dest_ptr);\n-    auto src_ptr = alloca(bcx, T_ptr(llunitty));\n-    bcx.build.Store(rhs_data, src_ptr);\n-    auto copy_loop_header_cx = new_sub_block_ctxt(bcx, \"copy_loop_header\");\n-    bcx.build.Br(copy_loop_header_cx.llbb);\n-    auto copy_dest_ptr = copy_loop_header_cx.build.Load(dest_ptr);\n-    auto not_yet_at_end =\n-        copy_loop_header_cx.build.ICmp(lib::llvm::LLVMIntNE, copy_dest_ptr,\n-                                       lhs_end);\n-    auto copy_loop_body_cx = new_sub_block_ctxt(bcx, \"copy_loop_body\");\n-    auto next_cx = new_sub_block_ctxt(bcx, \"next\");\n-    copy_loop_header_cx.build.CondBr(not_yet_at_end, copy_loop_body_cx.llbb,\n-                                     next_cx.llbb);\n-    auto copy_src_ptr = copy_loop_body_cx.build.Load(src_ptr);\n-    rslt = copy_val(copy_loop_body_cx, INIT, copy_dest_ptr, copy_src_ptr, t);\n-    auto post_copy_cx = rslt.bcx;\n-    // Increment both pointers.\n-\n-    post_copy_cx.build.Store(post_copy_cx.build.InBoundsGEP(copy_dest_ptr,\n-                                                            [C_int(1)]),\n-                             dest_ptr);\n-    post_copy_cx.build.Store(post_copy_cx.build.InBoundsGEP(copy_src_ptr,\n-                                                            [C_int(1)]),\n-                             src_ptr);\n-    post_copy_cx.build.Br(copy_loop_header_cx.llbb);\n-    ret res(next_cx, C_nil());\n+        auto rhs_len_and_data = get_len_and_data(bcx, rhs, unit_ty);\n+        auto rhs_len = rhs_len_and_data._0;\n+        auto rhs_data = rhs_len_and_data._1;\n+\n+        bcx = rhs_len_and_data._2;\n+        rslt = reserve_space(bcx, llunitty, lhs, rhs_len);\n+        auto lhs_data = rslt.val;\n+        bcx = rslt.bcx;\n+\n+        // Work out the end pointer.\n+        auto lhs_unscaled_idx = bcx.build.UDiv(rhs_len, llsize_of(llunitty));\n+        auto lhs_end = bcx.build.InBoundsGEP(lhs_data, [lhs_unscaled_idx]);\n+\n+        // Now emit the copy loop.\n+        auto dest_ptr = alloca(bcx, T_ptr(llunitty));\n+        bcx.build.Store(lhs_data, dest_ptr);\n+        auto src_ptr = alloca(bcx, T_ptr(llunitty));\n+        bcx.build.Store(rhs_data, src_ptr);\n+        auto copy_loop_header_cx = new_sub_block_ctxt(bcx,\n+                                                      \"copy_loop_header\");\n+        bcx.build.Br(copy_loop_header_cx.llbb);\n+        auto copy_dest_ptr = copy_loop_header_cx.build.Load(dest_ptr);\n+        auto not_yet_at_end =\n+            copy_loop_header_cx.build.ICmp(lib::llvm::LLVMIntNE,\n+                                           copy_dest_ptr,\n+                                           lhs_end);\n+        auto copy_loop_body_cx = new_sub_block_ctxt(bcx, \"copy_loop_body\");\n+        auto next_cx = new_sub_block_ctxt(bcx, \"next\");\n+        copy_loop_header_cx.build.CondBr(not_yet_at_end,\n+                                         copy_loop_body_cx.llbb,\n+                                         next_cx.llbb);\n+        auto copy_src_ptr = copy_loop_body_cx.build.Load(src_ptr);\n+        rslt = copy_val(copy_loop_body_cx, INIT, copy_dest_ptr, copy_src_ptr,\n+                        t);\n+        auto post_copy_cx = rslt.bcx;\n+        // Increment both pointers.\n+\n+        post_copy_cx.build.Store(post_copy_cx.build.InBoundsGEP(copy_dest_ptr,\n+                                                                [C_int(1)]),\n+                                 dest_ptr);\n+        post_copy_cx.build.Store(post_copy_cx.build.InBoundsGEP(copy_src_ptr,\n+                                                                [C_int(1)]),\n+                                 src_ptr);\n+        post_copy_cx.build.Br(copy_loop_header_cx.llbb);\n+        ret res(next_cx, C_nil());\n+    }\n }\n \n+\n fn trans_vec_add(&@block_ctxt cx, &ty::t t, ValueRef lhs, ValueRef rhs) ->\n    result {\n     auto r = alloc_ty(cx, t);\n@@ -4359,7 +4449,7 @@ fn trans_index(&@block_ctxt cx, &span sp, &@ast::expr base, &@ast::expr idx,\n     maybe_name_value(cx.fcx.lcx.ccx, scaled_ix, \"scaled_ix\");\n     auto interior_len_and_data;\n     if (is_interior) {\n-        auto rslt = get_ivec_len_and_data(bcx, v, unit_ty);\n+        auto rslt = get_len_and_data(bcx, v, unit_ty);\n         interior_len_and_data = some(tup(rslt._0, rslt._1));\n         bcx = rslt._2;\n     } else { interior_len_and_data = none; }\n@@ -5081,7 +5171,7 @@ fn trans_vec(&@block_ctxt cx, &vec[@ast::expr] args, &ast::ann ann) ->\n }\n \n fn trans_ivec(@block_ctxt bcx, &vec[@ast::expr] args, &ast::ann ann) ->\n-   result {\n+        result {\n     auto typ = node_ann_type(bcx.fcx.lcx.ccx, ann);\n     auto unit_ty;\n     alt (ty::struct(bcx.fcx.lcx.ccx.tcx, typ)) {\n@@ -5325,9 +5415,9 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n                 alt (op) {\n                     case (ast::add) {\n                         if (ty::sequence_is_interior(cx.fcx.lcx.ccx.tcx, t)) {\n-                            ret trans_ivec_append(rhs_res.bcx, t,\n-                                                  lhs_res.res.val,\n-                                                  rhs_res.val);\n+                            ret ivec::trans_append(rhs_res.bcx, t,\n+                                                   lhs_res.res.val,\n+                                                   rhs_res.val);\n                         }\n                         ret trans_vec_append(rhs_res.bcx, t, lhs_res.res.val,\n                                              rhs_res.val);\n@@ -5967,24 +6057,26 @@ fn recv_val(&@block_ctxt cx, ValueRef lhs, &@ast::expr rhs, &ty::t unit_ty,\n \n */\n \n-// trans_anon_obj: create (and return!) an LLVM function that is the object\n-// constructor for the anonymous object being translated.  \n-//\n-// This code differs from trans_obj in that, rather than creating an object\n-// constructor function and putting it in the generated code as an object\n-// item, we are instead \"inlining\" the construction of the object.\n-fn trans_anon_obj(@block_ctxt cx, &span sp, &ast::anon_obj anon_obj,\n+// trans_anon_obj: create and return a pointer to an object.  This code\n+// differs from trans_obj in that, rather than creating an object constructor\n+// function and putting it in the generated code as an object item, we are\n+// instead \"inlining\" the construction of the object and returning the object\n+// itself.\n+fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj, \n                   &vec[ast::ty_param] ty_params, ast::def_id oid,\n                   &ast::ann ann) -> result {\n-    auto ccx = cx.fcx.lcx.ccx;\n-    // A crate_ctxt has an item_ids hashmap, which has all of the def_ids of\n-    // everything in the crate.  By looking up a def_id, you can get the\n-    // ValueRef of that item.\n \n-    auto llctor_decl = ccx.item_ids.get(oid);\n+    // Right now, we're assuming that anon objs don't take ty params, even\n+    // though the AST supports it.  It's nonsensical to write an expression\n+    // like \"obj[T](){ ... with ... }\", since T is never instantiated;\n+    // nevertheless, such an expression will parse.  FIXME for the future:\n+    // support typarams (issue #n).\n+    assert vec::len(ty_params) == 0u;\n+\n+    auto ccx = bcx.fcx.lcx.ccx;\n+\n     // If with_obj (the object being extended) exists, translate it, producing\n     // a result.\n-\n     let option::t[result] with_obj_val = none[result];\n     alt (anon_obj.with_obj) {\n         case (none) { }\n@@ -5993,81 +6085,44 @@ fn trans_anon_obj(@block_ctxt cx, &span sp, &ast::anon_obj anon_obj,\n             // value) wrapped in a result.  We want to allocate space for this\n             // value in our outer object, then copy it into the outer object.\n \n-            with_obj_val = some[result](trans_expr(cx, e));\n+            with_obj_val = some[result](trans_expr(bcx, e));\n         }\n     }\n-    // If the anonymous object we're translating adds any additional fields,\n-    // they'll become the arguments to the function we're creating.\n \n     // FIXME (part of issue #417): all of the following code is copypasta from\n     // trans_obj for translating the anonymous wrapper object.  Eventually we\n     // should abstract this code out of trans_anon_obj and trans_obj.\n \n-    // For the anon obj's additional fields, if any exist, translate object\n-    // constructor arguments to function arguments.\n-\n-    let vec[ast::obj_field] addtl_fields = [];\n-    let vec[ast::arg] addtl_fn_args = [];\n-    alt (anon_obj.fields) {\n-        case (none) { }\n-        case (some(?fields)) {\n-            addtl_fields = fields;\n-            for (ast::obj_field f in fields) {\n-                addtl_fn_args +=\n-                    [rec(mode=ast::alias(false),\n-                         ty=f.ty,\n-                         ident=f.ident,\n-                         id=f.id)];\n-            }\n-        }\n-    }\n-    auto fcx = new_fn_ctxt(cx.fcx.lcx, sp, llctor_decl);\n-    // Both regular arguments and type parameters are handled here.\n-\n-    create_llargs_for_fn_args(fcx, ast::proto_fn, none[ty_self_pair],\n-                              ret_ty_of_fn(ccx, ann), addtl_fn_args,\n-                              ty_params);\n-    let vec[ty::arg] arg_tys = arg_tys_of_fn(ccx, ann);\n-    copy_args_to_allocas(fcx, addtl_fn_args, arg_tys);\n-    //  Create the first block context in the function and keep a handle on it\n-    //  to pass to finish_fn later.\n-\n-    auto bcx = new_top_block_ctxt(fcx);\n-    auto lltop = bcx.llbb;\n-    // Pick up the type of this object by looking at our own output type, that\n-    // is, the output type of the object constructor we're building.\n-\n-    auto self_ty = ret_ty_of_fn(ccx, ann);\n+    auto self_ty = ty::ann_to_type(ccx.tcx, ann);\n     auto llself_ty = type_of(ccx, sp, self_ty);\n-    // Set up the two-word pair that we're going to return from the object\n-    // constructor we're building.  The two elements of this pair will be a\n-    // vtable pointer and a body pointer.  (llretptr already points to the\n-    // place where this two-word pair should go; it was pre-allocated by the\n-    // caller of the function.)\n \n-    auto pair = bcx.fcx.llretptr;\n+    // Allocate the object that we're going to return.  It's a two-word pair\n+    // containing a vtable pointer and a body pointer.\n+    auto pair = alloca(bcx, llself_ty);\n+\n     // Grab onto the first and second elements of the pair.\n     // abi::obj_field_vtbl and abi::obj_field_box simply specify words 0 and 1\n     // of 'pair'.\n-\n     auto pair_vtbl =\n         bcx.build.GEP(pair, [C_int(0), C_int(abi::obj_field_vtbl)]);\n     auto pair_box =\n         bcx.build.GEP(pair, [C_int(0), C_int(abi::obj_field_box)]);\n-    // Make a vtable for this object: a static array of pointers to functions.\n-    // It will be located in the read-only memory of the executable we're\n-    // creating and will contain ValueRefs for all of this object's methods.\n-    // create_vtbl returns a pointer to the vtable, which we store.\n \n-    // create_vtbl() wants an ast::_obj and all we have is an\n-    // ast::anon_obj, so we need to roll our own.\n+    // Make a vtable for the outer object.  create_vtbl() wants an ast::_obj\n+    // and all we have is an ast::anon_obj, so we need to roll our own.\n+    let vec[ast::obj_field] addtl_fields = [];\n+    alt (anon_obj.fields) {\n+        case (none) { }\n+        case (some(?fields)) { addtl_fields = fields; }\n+    }\n+    let ast::_obj wrapper_obj = rec(\n+        fields = addtl_fields,\n+        methods = anon_obj.methods,\n+        dtor = none[@ast::method]);\n+\n+    auto vtbl = create_vtbl(bcx.fcx.lcx, llself_ty, self_ty, wrapper_obj, \n+                            ty_params);\n \n-    let ast::_obj wrapper_obj =\n-        rec(fields=addtl_fields,\n-            methods=anon_obj.methods,\n-            dtor=none[@ast::method]);\n-    auto vtbl =\n-        create_vtbl(cx.fcx.lcx, llself_ty, self_ty, wrapper_obj, ty_params);\n     bcx.build.Store(vtbl, pair_vtbl);\n     // FIXME (part of issue #417): This vtable needs to contain \"forwarding\n     // slots\" for the methods that exist in the with_obj, as well.  How do we\n@@ -6081,127 +6136,29 @@ fn trans_anon_obj(@block_ctxt cx, &span sp, &ast::anon_obj anon_obj,\n     // also have to fill in the with_obj field of this tuple.\n \n     let TypeRef llbox_ty = T_opaque_obj_ptr(ccx.tn);\n-    // FIXME: we should probably also allocate a box for empty objs that have\n-    // a dtor, since otherwise they are never dropped, and the dtor never\n-    // runs.\n-\n-    if (vec::len[ast::ty_param](ty_params) == 0u &&\n-            vec::len[ty::arg](arg_tys) == 0u) {\n-        // If the object we're translating has no fields or type parameters,\n-        // there's not much to do.\n-\n-        // Store null into pair, if no args or typarams.\n-\n-        bcx.build.Store(C_null(llbox_ty), pair_box);\n-    } else {\n-        // Otherwise, we have to synthesize a big structural type for the\n-        // object body.\n-\n-        let vec[ty::t] obj_fields = [];\n-        for (ty::arg a in arg_tys) { vec::push[ty::t](obj_fields, a.ty); }\n-        // Tuple type for fields: [field, ...]\n+    \n+    alt (anon_obj.fields) {\n+        case (none) { \n+            // If the object we're translating has no fields or type\n+            // parameters, there's not much to do.\n \n-        let ty::t fields_ty = ty::mk_imm_tup(ccx.tcx, obj_fields);\n-        // Tuple type for typarams: [typaram, ...]\n+            // Store null into pair, if no args or typarams.\n+            bcx.build.Store(C_null(llbox_ty), pair_box);\n \n-        auto tydesc_ty = ty::mk_type(ccx.tcx);\n-        let vec[ty::t] tps = [];\n-        for (ast::ty_param tp in ty_params) {\n-            vec::push[ty::t](tps, tydesc_ty);\n         }\n-        let ty::t typarams_ty = ty::mk_imm_tup(ccx.tcx, tps);\n-        // Tuple type for body: [tydesc_ty, [typaram, ...], [field, ...]]\n-\n-        let ty::t body_ty =\n-            ty::mk_imm_tup(ccx.tcx, [tydesc_ty, typarams_ty, fields_ty]);\n-        // Hand this type we've synthesized off to trans_malloc_boxed, which\n-        // allocates a box, including space for a refcount.\n-\n-        auto box = trans_malloc_boxed(bcx, body_ty);\n-        bcx = box.bcx;\n-        // mk_imm_box throws a refcount into the type we're synthesizing, so\n-        // that it looks like: [rc, [tydesc_ty, [typaram, ...], [field, ...]]]\n-\n-        let ty::t boxed_body_ty = ty::mk_imm_box(ccx.tcx, body_ty);\n-        // Grab onto the refcount and body parts of the box we allocated.\n-\n-        auto rc =\n-            GEP_tup_like(bcx, boxed_body_ty, box.val,\n-                         [0, abi::box_rc_field_refcnt]);\n-        bcx = rc.bcx;\n-        auto body =\n-            GEP_tup_like(bcx, boxed_body_ty, box.val,\n-                         [0, abi::box_rc_field_body]);\n-        bcx = body.bcx;\n-        bcx.build.Store(C_int(1), rc.val);\n-        // Put together a tydesc for the body, so that the object can later be\n-        // freed by calling through its tydesc.\n-\n-        // Every object (not just those with type parameters) needs to have a\n-        // tydesc to describe its body, since all objects have unknown type to\n-        // the user of the object.  So the tydesc is needed to keep track of\n-        // the types of the object's fields, so that the fields can be freed\n-        // later.\n-\n-        auto body_tydesc =\n-            GEP_tup_like(bcx, body_ty, body.val,\n-                         [0, abi::obj_body_elt_tydesc]);\n-        bcx = body_tydesc.bcx;\n-        auto ti = none[@tydesc_info];\n-        auto body_td = get_tydesc(bcx, body_ty, true, ti);\n-        lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n-        lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n-        bcx = body_td.bcx;\n-        bcx.build.Store(body_td.val, body_tydesc.val);\n-        // Copy the object's type parameters and fields into the space we\n-        // allocated for the object body.  (This is something like saving the\n-        // lexical environment of a function in its closure: the \"captured\n-        // typarams\" are any type parameters that are passed to the object\n-        // constructor and are then available to the object's methods.\n-        // Likewise for the object's fields.)\n-\n-        // Copy typarams into captured typarams.\n \n-        auto body_typarams =\n-            GEP_tup_like(bcx, body_ty, body.val,\n-                         [0, abi::obj_body_elt_typarams]);\n-        bcx = body_typarams.bcx;\n-        let int i = 0;\n-        for (ast::ty_param tp in ty_params) {\n-            auto typaram = bcx.fcx.lltydescs.(i);\n-            auto capture =\n-                GEP_tup_like(bcx, typarams_ty, body_typarams.val, [0, i]);\n-            bcx = capture.bcx;\n-            bcx = copy_val(bcx, INIT, capture.val, typaram, tydesc_ty).bcx;\n-            i += 1;\n-        }\n-        // Copy args into body fields.\n+        case (some(?fields)) {\n+            // For the moment let's pretend that there are no additional\n+            // fields.\n+            bcx.fcx.lcx.ccx.sess.unimpl(\"anon objs don't support \"\n+                                        + \"adding fields yet\");\n \n-        auto body_fields =\n-            GEP_tup_like(bcx, body_ty, body.val,\n-                         [0, abi::obj_body_elt_fields]);\n-        bcx = body_fields.bcx;\n-        i = 0;\n-        for (ast::obj_field f in wrapper_obj.fields) {\n-            auto arg = bcx.fcx.llargs.get(f.id);\n-            arg = load_if_immediate(bcx, arg, arg_tys.(i).ty);\n-            auto field =\n-                GEP_tup_like(bcx, fields_ty, body_fields.val, [0, i]);\n-            bcx = field.bcx;\n-            bcx = copy_val(bcx, INIT, field.val, arg, arg_tys.(i).ty).bcx;\n-            i += 1;\n+            // FIXME (issue #417): drop these fields into the newly created\n+            // object.\n         }\n-        // Store box ptr in outer pair.\n-\n-        auto p = bcx.build.PointerCast(box.val, llbox_ty);\n-        bcx.build.Store(p, pair_box);\n     }\n-    bcx.build.RetVoid();\n-    // Insert the mandatory first few basic blocks before lltop.\n \n-    finish_fn(fcx, lltop);\n     // Return the object we built.\n-\n     ret res(bcx, pair);\n }\n \n@@ -6658,6 +6615,10 @@ fn arg_tys_of_fn(&@crate_ctxt ccx, ast::ann ann) -> vec[ty::arg] {\n fn ret_ty_of_fn_ty(&@crate_ctxt ccx, ty::t t) -> ty::t {\n     alt (ty::struct(ccx.tcx, t)) {\n         case (ty::ty_fn(_, _, ?ret_ty, _, _)) { ret ret_ty; }\n+        case (_) {\n+            ccx.sess.bug(\"ret_ty_of_fn_ty() called on non-function type: \"\n+                         + ty_to_str(ccx.tcx, t));\n+        }\n     }\n }\n \n@@ -6807,6 +6768,10 @@ fn create_vtbl(@local_ctxt cx, TypeRef llself_ty, ty::t self_ty,\n         let str s = mangle_internal_name_by_path(mcx.ccx, mcx.path);\n         let ValueRef llfn =\n             decl_internal_fastcall_fn(cx.ccx.llmod, s, llfnty);\n+\n+        // Every method on an object gets its def_id inserted into the\n+        // crate-wide item_ids map, together with the ValueRef that points to\n+        // where that method's definition will be in the executable.\n         cx.ccx.item_ids.insert(m.node.id, llfn);\n         cx.ccx.item_symbols.insert(m.node.id, s);\n         trans_fn(mcx, m.span, m.node.meth, llfn,\n@@ -7157,6 +7122,11 @@ fn trans_item(@local_ctxt cx, &ast::item item) {\n     }\n }\n \n+// Translate a module.  Doing this amounts to translating the items in the\n+// module; there ends up being no artifact (aside from linkage names) of\n+// separate modules in the compiled program.  That's because modules exist\n+// only as a convenience for humans working with the code, to organize names\n+// and control visibility.\n fn trans_mod(@local_ctxt cx, &ast::_mod m) {\n     for (@ast::item item in m.items) { trans_item(cx, *item); }\n }"}, {"sha": "db61c9be18986f19a74ccf640068a9551504d41a", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=260aa408f390cf457eb19507fc80ec388a039f8e", "patch": "@@ -198,8 +198,9 @@ to represent predicate *arguments* however. This type\n Both types store an ident and span, for error-logging purposes.\n */\n type pred_desc_ = rec(vec[@constr_arg_use] args, uint bit_num);\n-\n type pred_desc = spanned[pred_desc_];\n+type constr_arg_use = constr_arg_general[ident];\n+\n \n tag constraint {\n     cinit(uint, span, ident);\n@@ -456,7 +457,7 @@ fn controlflow_expr(&crate_ctxt ccx, @expr e) -> controlflow {\n     }\n }\n \n-fn constraints_expr(&ty::ctxt cx, @expr e) -> vec[@ast::constr] {\n+fn constraints_expr(&ty::ctxt cx, @expr e) -> vec[@ty::constr_def] {\n     alt (ty::struct(cx, ty::ann_to_type(cx, expr_ann(e)))) {\n         case (ty::ty_fn(_, _, _, _, ?cs)) { ret cs; }\n         case (_) { ret []; }\n@@ -511,9 +512,11 @@ fn constraints(&fn_ctxt fcx) -> vec[norm_constraint] {\n // FIXME:\n // this probably doesn't handle name shadowing well (or at all)\n // variables should really always be id'd by def_id and not ident\n+\n fn match_args(&fn_ctxt fcx, vec[pred_desc] occs, vec[@constr_arg_use] occ) ->\n    uint {\n-    log \"match_args: looking at \" + pretty::ppaux::constr_args_to_str_1(occ);\n+    log (\"match_args: looking at \" +\n+         pretty::ppaux::constr_args_to_str(std::util::id[str], occ));\n     for (pred_desc pd in occs) {\n         log \"match_args: candidate \" + pred_desc_to_str(pd);\n         if (ty::args_eq(str::eq, pd.node.args, occ)) { ret pd.node.bit_num; }\n@@ -586,11 +589,13 @@ fn expr_to_constr(ty::ctxt tcx, &@expr e) -> constr {\n \n fn pred_desc_to_str(&pred_desc p) -> str {\n     ret \"<\" + uistr(p.node.bit_num) + \", \" +\n-            pretty::ppaux::constr_args_to_str_1(p.node.args) + \">\";\n+         pretty::ppaux::constr_args_to_str(std::util::id[str], p.node.args)\n+         + \">\";\n }\n \n-fn substitute_constr_args(&ty::ctxt cx, &vec[@expr] actuals, &@ast::constr c)\n-   -> constr__ {\n+fn substitute_constr_args(&ty::ctxt cx,\n+                          &vec[@expr] actuals, &@ty::constr_def c)\n+    -> constr__ {\n     let vec[@constr_arg_use] res = [];\n     for (@constr_arg a in c.node.args) {\n         res += [substitute_arg(cx, actuals, a)];"}, {"sha": "f669afa965dd73fdfbc4a2acb1c82c27fb2f0aa2", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=260aa408f390cf457eb19507fc80ec388a039f8e", "patch": "@@ -37,30 +37,16 @@ fn collect_pred(&ctxt cx, &@expr e) {\n         case (expr_check(?e, _)) {\n             vec::push(*cx.cs, expr_to_constr(cx.tcx, e));\n         }\n-        case (\n-             // If it's a call, generate appropriate instances of the\n-             // call's constraints.\n-             expr_call(?operator, ?operands, ?a)) {\n-            for (@ast::constr c in constraints_expr(cx.tcx, operator)) {\n-                auto d_id = ann_to_def_strict(cx.tcx, c.node.ann);\n-                alt (d_id) {\n-                    case (def_fn(?an_id)) {\n-                        let aux::constr ct =\n-                            respan(c.span,\n-                                   rec(id=an_id,\n-                                       c=aux::substitute_constr_args(cx.tcx,\n-                                                                     operands,\n-                                                                     c)));\n-                        vec::push(*cx.cs, ct);\n-                    }\n-                    case (_) {\n-                        cx.tcx.sess.span_err(c.span,\n-                                             \"Non-pred in constraint\");\n-                    }\n-                }\n+        // If it's a call, generate appropriate instances of the\n+        // call's constraints.\n+        case (expr_call(?operator, ?operands, ?a)) {\n+            for (@ty::constr_def c in constraints_expr(cx.tcx, operator)) {\n+                let aux::constr ct = respan(c.span,\n+                      rec(id=c.node.id,\n+                          c=aux::substitute_constr_args(cx.tcx,\n+                                                        operands, c)));\n+                vec::push(*cx.cs, ct);\n             }\n-            // FIXME: constraints on result type\n-\n         }\n         case (_) { }\n     }"}, {"sha": "a355c9f3f12174d91841838faa7dc63691fc4eb3", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 7, "deletions": 29, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=260aa408f390cf457eb19507fc80ec388a039f8e", "patch": "@@ -208,38 +208,16 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n             auto args = vec::clone[@expr](operands);\n             vec::push[@expr](args, operator);\n             find_pre_post_exprs(fcx, args, a);\n-            /* should test higher-order constrained functions */\n-\n-            /* FIXME */\n-\n-            /* see if the call has any constraints on its in type */\n-\n-            log \"a function: \";\n+            /* see if the call has any constraints on its type */\n+            log(\"a function: \" );\n             log_expr(*operator);\n             auto pp = expr_pp(fcx.ccx, e);\n-            for (@constr c in constraints_expr(fcx.ccx.tcx, operator)) {\n-                auto id = ann_to_def(fcx.ccx, c.node.ann);\n-                alt (id) {\n-                    case (some(def_fn(?d_id))) {\n-                        auto i =\n-                            bit_num(fcx,\n-                                    rec(id=d_id,\n-                                        c=substitute_constr_args(fcx.ccx.tcx,\n-                                                                 operands,\n-                                                                 c)));\n-                        require(i, pp);\n-                    }\n-                    case (_) {\n-                        fcx.ccx.tcx.sess.span_err(c.span,\n-                                                  \"Unbound pred \" +\n-                                                      \" or pred that's not \\\n-                                                        bound to a function\");\n-                    }\n-                }\n+            for (@ty::constr_def c in \n+                     constraints_expr(fcx.ccx.tcx, operator)) {\n+                auto i = bit_num(fcx, rec(id=c.node.id,\n+                  c=substitute_constr_args(fcx.ccx.tcx, operands, c)));\n+                require(i, pp);\n             }\n-\n-            // FIXME: constraints on result type\n-\n             /* if this is a failing call, its postcondition sets everything */\n             alt (controlflow_expr(fcx.ccx, operator)) {\n                 case (noreturn) { set_postcond_false(fcx.ccx, a); }"}, {"sha": "6ef2384d8f145a721d969a4c1eb833e5fe33b668", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 57, "deletions": 59, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=260aa408f390cf457eb19507fc80ec388a039f8e", "patch": "@@ -13,23 +13,14 @@ import std::option::some;\n import std::smallintmap;\n import driver::session;\n import front::ast;\n+import front::ast::def_id;\n+import front::ast::constr_arg_general;\n import front::ast::mutability;\n import front::ast::controlflow;\n import front::creader;\n import middle::metadata;\n-import util::common;\n-import util::common::ty_u8;\n-import util::common::ty_u16;\n-import util::common::ty_u32;\n-import util::common::ty_u64;\n-import util::common::ty_i8;\n-import util::common::ty_i16;\n-import util::common::ty_i32;\n-import util::common::ty_i64;\n-import util::common::ty_f32;\n-import util::common::ty_f64;\n-import util::common::new_def_hash;\n-import util::common::span;\n+import util::common::*;\n+\n import util::data::interner;\n \n \n@@ -46,20 +37,22 @@ type method =\n         vec[arg] inputs,\n         t output,\n         controlflow cf,\n-        vec[@ast::constr] constrs);\n+        vec[@constr_def] constrs);\n \n tag any_item {\n     any_item_rust(@ast::item);\n     any_item_native(@ast::native_item, ast::native_abi);\n }\n \n type item_table = hashmap[ast::def_id, any_item];\n+type constr_table = hashmap[ast::def_id, vec[constr_def]]; \n \n type mt = rec(t ty, ast::mutability mut);\n \n \n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n+\n type creader_cache = hashmap[tup(int, uint, uint), ty::t];\n \n type ctxt =\n@@ -68,7 +61,7 @@ type ctxt =\n         resolve::def_map def_map,\n         node_type_table node_types,\n         item_table items, // Only contains type items\n-\n+        constr_table fn_constrs,\n         type_cache tcache,\n         creader_cache rcache,\n         hashmap[t, str] short_names_cache,\n@@ -83,7 +76,6 @@ type ty_ctxt = ctxt;\n      ret mk_fn(cx, m.proto, m.inputs, m.output, m.cf, m.constrs);\n  }\n \n-\n // Never construct these manually. These are interned.\n //\n // TODO: It'd be really nice to be able to hide this definition from the\n@@ -107,11 +99,11 @@ tag sty {\n     ty_int;\n     ty_float;\n     ty_uint;\n-    ty_machine(util::common::ty_mach);\n+    ty_machine(ty_mach);\n     ty_char;\n     ty_str;\n     ty_istr;\n-    ty_tag(ast::def_id, vec[t]);\n+    ty_tag(def_id, vec[t]);\n     ty_box(mt);\n     ty_vec(mt);\n     ty_ivec(mt);\n@@ -121,7 +113,7 @@ tag sty {\n     ty_task;\n     ty_tup(vec[mt]);\n     ty_rec(vec[field]);\n-    ty_fn(ast::proto, vec[arg], t, controlflow, vec[@ast::constr]);\n+    ty_fn(ast::proto, vec[arg], t, controlflow, vec[@constr_def]);\n     ty_native_fn(ast::native_abi, vec[arg], t);\n     ty_obj(vec[method]);\n     ty_var(int); // type variable\n@@ -134,6 +126,10 @@ tag sty {\n \n }\n \n+type constr_def = spanned[constr_general[uint]];\n+type constr_general[T] =  rec(path path,\n+                              vec[@constr_arg_general[T]] args,\n+                              def_id id);\n \n // Data structures used in type unification\n tag type_err {\n@@ -247,19 +243,21 @@ fn mk_rcache() -> creader_cache {\n     ret map::mk_hashmap[tup(int, uint, uint), t](h, e);\n }\n \n-fn mk_ctxt(session::session s, resolve::def_map dm) -> ctxt {\n+fn mk_ctxt(session::session s, resolve::def_map dm, constr_table cs) -> ctxt {\n+\n     let vec[mutable option::t[ty::ty_param_substs_opt_and_ty]] ntt_sub =\n         [mutable ];\n     let node_type_table ntt = @mutable ntt_sub;\n-    auto tcache = common::new_def_hash[ty::ty_param_count_and_ty]();\n-    auto items = common::new_def_hash[any_item]();\n+    auto tcache = new_def_hash[ty::ty_param_count_and_ty]();\n+    auto items = new_def_hash[any_item]();\n     auto ts = @interner::mk[raw_t](hash_raw_ty, eq_raw_ty);\n     auto cx =\n         rec(ts=ts,\n             sess=s,\n             def_map=dm,\n             node_types=ntt,\n             items=items,\n+            fn_constrs = cs,\n             tcache=tcache,\n             rcache=mk_rcache(),\n             short_names_cache=map::mk_hashmap[ty::t,\n@@ -379,7 +377,7 @@ fn mk_float(&ctxt cx) -> t { ret idx_float; }\n \n fn mk_uint(&ctxt cx) -> t { ret idx_uint; }\n \n-fn mk_mach(&ctxt cx, &util::common::ty_mach tm) -> t {\n+fn mk_mach(&ctxt cx, &ty_mach tm) -> t {\n     alt (tm) {\n         case (ty_u8) { ret idx_u8; }\n         case (ty_u16) { ret idx_u16; }\n@@ -439,7 +437,7 @@ fn mk_imm_tup(&ctxt cx, &vec[t] tys) -> t {\n fn mk_rec(&ctxt cx, &vec[field] fs) -> t { ret gen_ty(cx, ty_rec(fs)); }\n \n fn mk_fn(&ctxt cx, &ast::proto proto, &vec[arg] args, &t ty, &controlflow cf,\n-         &vec[@ast::constr] constrs) -> t {\n+         &vec[@constr_def] constrs) -> t {\n     ret gen_ty(cx, ty_fn(proto, args, ty, cf, constrs));\n }\n \n@@ -759,8 +757,8 @@ fn sequence_is_interior(&ctxt cx, &t ty) -> bool {\n \n fn sequence_element_type(&ctxt cx, &t ty) -> t {\n     alt (struct(cx, ty)) {\n-        case (ty_str) { ret mk_mach(cx, common::ty_u8); }\n-        case (ty_istr) { ret mk_mach(cx, common::ty_u8); }\n+        case (ty_str) { ret mk_mach(cx, ty_u8); }\n+        case (ty_istr) { ret mk_mach(cx, ty_u8); }\n         case (ty_vec(?mt)) { ret mt.ty; }\n         case (ty_ivec(?mt)) { ret mt.ty; }\n         case (_) {\n@@ -915,14 +913,14 @@ fn type_is_integral(&ctxt cx, &t ty) -> bool {\n         case (ty_uint) { ret true; }\n         case (ty_machine(?m)) {\n             alt (m) {\n-                case (common::ty_i8) { ret true; }\n-                case (common::ty_i16) { ret true; }\n-                case (common::ty_i32) { ret true; }\n-                case (common::ty_i64) { ret true; }\n-                case (common::ty_u8) { ret true; }\n-                case (common::ty_u16) { ret true; }\n-                case (common::ty_u32) { ret true; }\n-                case (common::ty_u64) { ret true; }\n+                case (ty_i8) { ret true; }\n+                case (ty_i16) { ret true; }\n+                case (ty_i32) { ret true; }\n+                case (ty_i64) { ret true; }\n+                case (ty_u8) { ret true; }\n+                case (ty_u16) { ret true; }\n+                case (ty_u32) { ret true; }\n+                case (ty_u64) { ret true; }\n                 case (_) { ret false; }\n             }\n         }\n@@ -935,8 +933,8 @@ fn type_is_fp(&ctxt cx, &t ty) -> bool {\n     alt (struct(cx, ty)) {\n         case (ty_machine(?tm)) {\n             alt (tm) {\n-                case (common::ty_f32) { ret true; }\n-                case (common::ty_f64) { ret true; }\n+                case (ty_f32) { ret true; }\n+                case (ty_f64) { ret true; }\n                 case (_) { ret false; }\n             }\n         }\n@@ -950,10 +948,10 @@ fn type_is_signed(&ctxt cx, &t ty) -> bool {\n         case (ty_int) { ret true; }\n         case (ty_machine(?tm)) {\n             alt (tm) {\n-                case (common::ty_i8) { ret true; }\n-                case (common::ty_i16) { ret true; }\n-                case (common::ty_i32) { ret true; }\n-                case (common::ty_i64) { ret true; }\n+                case (ty_i8) { ret true; }\n+                case (ty_i16) { ret true; }\n+                case (ty_i32) { ret true; }\n+                case (ty_i64) { ret true; }\n                 case (_) { ret false; }\n             }\n         }\n@@ -1005,16 +1003,16 @@ fn hash_type_structure(&sty st) -> uint {\n         case (ty_uint) { ret 4u; }\n         case (ty_machine(?tm)) {\n             alt (tm) {\n-                case (common::ty_i8) { ret 5u; }\n-                case (common::ty_i16) { ret 6u; }\n-                case (common::ty_i32) { ret 7u; }\n-                case (common::ty_i64) { ret 8u; }\n-                case (common::ty_u8) { ret 9u; }\n-                case (common::ty_u16) { ret 10u; }\n-                case (common::ty_u32) { ret 11u; }\n-                case (common::ty_u64) { ret 12u; }\n-                case (common::ty_f32) { ret 13u; }\n-                case (common::ty_f64) { ret 14u; }\n+                case (ty_i8) { ret 5u; }\n+                case (ty_i16) { ret 6u; }\n+                case (ty_i32) { ret 7u; }\n+                case (ty_i64) { ret 8u; }\n+                case (ty_u8) { ret 9u; }\n+                case (ty_u16) { ret 10u; }\n+                case (ty_u32) { ret 11u; }\n+                case (ty_u64) { ret 12u; }\n+                case (ty_f32) { ret 13u; }\n+                case (ty_f64) { ret 14u; }\n             }\n         }\n         case (ty_char) { ret 15u; }\n@@ -1096,7 +1094,7 @@ fn arg_eq[T](&fn(&T, &T) -> bool  eq, @ast::constr_arg_general[T] a,\n         }\n         case (ast::carg_lit(?l)) {\n             alt (b.node) {\n-                case (ast::carg_lit(?m)) { ret util::common::lit_eq(l, m); }\n+                case (ast::carg_lit(?m)) { ret lit_eq(l, m); }\n                 case (_) { ret false; }\n             }\n         }\n@@ -1113,18 +1111,18 @@ fn args_eq[T](fn(&T, &T) -> bool  eq, vec[@ast::constr_arg_general[T]] a,\n     ret true;\n }\n \n-fn constr_eq(&@ast::constr c, &@ast::constr d) -> bool {\n+fn constr_eq(&@constr_def c, &@constr_def d) -> bool {\n     ret path_to_str(c.node.path) == path_to_str(d.node.path) &&\n              // FIXME: hack\n             args_eq(eq_int, c.node.args, d.node.args);\n }\n \n-fn constrs_eq(&vec[@ast::constr] cs, &vec[@ast::constr] ds) -> bool {\n+fn constrs_eq(&vec[@constr_def] cs, &vec[@constr_def] ds) -> bool {\n     if (vec::len(cs) != vec::len(ds)) { ret false; }\n-    auto i = 0;\n-    for (@ast::constr c in cs) {\n+    auto i = 0u;\n+    for (@constr_def c in cs) {\n         if (!constr_eq(c, ds.(i))) { ret false; }\n-        i += 1;\n+        i += 1u;\n     }\n     ret true;\n }\n@@ -1829,8 +1827,8 @@ mod unify {\n                 &t expected, &t actual, &vec[arg] expected_inputs,\n                 &t expected_output, &vec[arg] actual_inputs, &t actual_output,\n                 &controlflow expected_cf, &controlflow actual_cf,\n-                &vec[@ast::constr] expected_constrs,\n-                &vec[@ast::constr] actual_constrs) -> result {\n+                &vec[@constr_def] expected_constrs,\n+                &vec[@constr_def] actual_constrs) -> result {\n         if (e_proto != a_proto) { ret ures_err(terr_mismatch); }\n         alt (expected_cf) {\n             case (ast::return) { }\n@@ -2473,7 +2471,7 @@ fn tag_variant_with_id(&ctxt cx, &ast::def_id tag_id, &ast::def_id variant_id)\n     auto i = 0u;\n     while (i < vec::len[variant_info](variants)) {\n         auto variant = variants.(i);\n-        if (common::def_eq(variant.id, variant_id)) { ret variant; }\n+        if (def_eq(variant.id, variant_id)) { ret variant; }\n         i += 1u;\n     }\n     cx.sess.bug(\"tag_variant_with_id(): no variant exists with that ID\");"}, {"sha": "bd804b97bd2164e61a1719666357a0fb5611e2c2", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 56, "deletions": 38, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=260aa408f390cf457eb19507fc80ec388a039f8e", "patch": "@@ -6,6 +6,7 @@ import front::creader;\n import driver::session;\n import util::common;\n import util::common::span;\n+import util::common::respan;\n import util::common::new_def_hash;\n import util::common::log_expr_err;\n import middle::ty;\n@@ -312,7 +313,10 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n             auto f = bind ast_arg_to_arg(tcx, getter, _);\n             auto i = vec::map[ast::ty_arg, arg](f, inputs);\n             auto out_ty = ast_ty_to_ty(tcx, getter, output);\n-            typ = ty::mk_fn(tcx, proto, i, out_ty, cf, constrs);\n+            let fn(&@ast::constr) -> @ty::constr_def g =\n+                bind ast_constr_to_constr(tcx, _);\n+            let vec[@ty::constr_def] out_constrs = vec::map(g, constrs);\n+            typ = ty::mk_fn(tcx, proto, i, out_ty, cf, out_constrs);\n         }\n         case (ast::ty_path(?path, ?ann)) {\n             alt (tcx.def_map.get(ann.id)) {\n@@ -341,13 +345,17 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n             for (ast::ty_method m in meths) {\n                 auto ins = vec::map[ast::ty_arg, arg](f, m.node.inputs);\n                 auto out = ast_ty_to_ty(tcx, getter, m.node.output);\n+                let fn(&@ast::constr) -> @ty::constr_def g =\n+                    bind ast_constr_to_constr(tcx, _);\n+                let vec[@ty::constr_def] out_constrs =\n+                       vec::map(g, m.node.constrs);\n                 let ty::method new_m =\n                     rec(proto=m.node.proto,\n                         ident=m.node.ident,\n                         inputs=ins,\n                         output=out,\n                         cf=m.node.cf,\n-                        constrs=m.node.constrs);\n+                        constrs=out_constrs);\n                 vec::push[ty::method](tmeths, new_m);\n             }\n             typ = ty::mk_obj(tcx, ty::sort_methods(tmeths));\n@@ -388,7 +396,7 @@ mod write {\n     // Writes a type parameter count and type pair into the node type table.\n     fn ty(&ty::ctxt tcx, uint node_id, &ty_param_substs_opt_and_ty tpot) {\n         assert (!ty::type_contains_vars(tcx, tpot._1));\n-        be inner(tcx.node_types, node_id, tpot);\n+        ret inner(tcx.node_types, node_id, tpot);\n     }\n \n     // Writes a type parameter count and type pair into the node type table.\n@@ -404,23 +412,23 @@ mod write {\n \n     // Writes a type with no type parameters into the node type table.\n     fn ty_only(&ty::ctxt tcx, uint node_id, ty::t typ) {\n-        be ty(tcx, node_id, tup(none[vec[ty::t]], typ));\n+        ret ty(tcx, node_id, tup(none[vec[ty::t]], typ));\n     }\n \n     // Writes a type with no type parameters into the node type table. This\n     // function allows for the possibility of type variables.\n     fn ty_only_fixup(@fn_ctxt fcx, uint node_id, ty::t typ) {\n-        be ty_fixup(fcx, node_id, tup(none[vec[ty::t]], typ));\n+        ret ty_fixup(fcx, node_id, tup(none[vec[ty::t]], typ));\n     }\n \n     // Writes a nil type into the node type table.\n     fn nil_ty(&ty::ctxt tcx, uint node_id) {\n-        be ty(tcx, node_id, tup(none[vec[ty::t]], ty::mk_nil(tcx)));\n+        ret ty(tcx, node_id, tup(none[vec[ty::t]], ty::mk_nil(tcx)));\n     }\n \n     // Writes the bottom type into the node type table.\n     fn bot_ty(&ty::ctxt tcx, uint node_id) {\n-        be ty(tcx, node_id, tup(none[vec[ty::t]], ty::mk_bot(tcx)));\n+        ret ty(tcx, node_id, tup(none[vec[ty::t]], ty::mk_bot(tcx)));\n     }\n }\n \n@@ -449,9 +457,12 @@ mod collect {\n        ty::ty_param_count_and_ty {\n         auto input_tys = vec::map[ast::arg, arg](ty_of_arg, decl.inputs);\n         auto output_ty = convert(decl.output);\n+        let fn(&@ast::constr) -> @ty::constr_def g =\n+            bind ast_constr_to_constr(cx.tcx, _);\n+        let vec[@ty::constr_def] out_constrs = vec::map(g, decl.constraints);\n         auto t_fn =\n             ty::mk_fn(cx.tcx, proto, input_tys, output_ty, decl.cf,\n-                      decl.constraints);\n+                      out_constrs);\n         auto ty_param_count = vec::len[ast::ty_param](ty_params);\n         auto tpt = tup(ty_param_count, t_fn);\n         alt (def_id) {\n@@ -512,12 +523,13 @@ mod collect {\n         auto f = bind ty_of_arg(cx, _);\n         auto inputs = vec::map[ast::arg, arg](f, m.node.meth.decl.inputs);\n         auto output = convert(m.node.meth.decl.output);\n-        ret rec(proto=m.node.meth.proto,\n-                ident=m.node.ident,\n-                inputs=inputs,\n-                output=output,\n-                cf=m.node.meth.decl.cf,\n-                constrs=m.node.meth.decl.constraints);\n+        let fn(&@ast::constr) -> @ty::constr_def g =\n+            bind ast_constr_to_constr(cx.tcx, _);\n+        let vec[@ty::constr_def] out_constrs =\n+            vec::map(g, m.node.meth.decl.constraints);\n+        ret rec(proto=m.node.meth.proto, ident=m.node.ident,\n+                inputs=inputs, output=output, cf=m.node.meth.decl.cf,\n+                constrs=out_constrs);\n     }\n     fn ty_of_obj(@ctxt cx, &ast::ident id, &ast::_obj obj_info,\n                  &vec[ast::ty_param] ty_params) -> ty::ty_param_count_and_ty {\n@@ -537,10 +549,8 @@ mod collect {\n             auto t_field = ast_ty_to_ty(cx.tcx, g, f.ty);\n             vec::push(t_inputs, rec(mode=ty::mo_alias(false), ty=t_field));\n         }\n-        let vec[@ast::constr] constrs = [];\n-        auto t_fn =\n-            ty::mk_fn(cx.tcx, ast::proto_fn, t_inputs, t_obj._1, ast::return,\n-                      constrs);\n+        auto t_fn = ty::mk_fn(cx.tcx, ast::proto_fn, t_inputs, t_obj._1,\n+                              ast::return, []);\n         auto tpt = tup(t_obj._0, t_fn);\n         cx.tcx.tcache.insert(ctor_id, tpt);\n         ret tpt;\n@@ -652,11 +662,8 @@ mod collect {\n                 }\n                 auto tag_t = ty::mk_tag(cx.tcx, tag_id, ty_param_tys);\n                 // FIXME: this will be different for constrained types\n-\n-                let vec[@ast::constr] res_constrs = [];\n-                result_ty =\n-                    ty::mk_fn(cx.tcx, ast::proto_fn, args, tag_t, ast::return,\n-                              res_constrs);\n+                result_ty = ty::mk_fn(cx.tcx, ast::proto_fn, args, tag_t,\n+                                      ast::return, []);\n             }\n             auto tpt = tup(ty_param_count, result_ty);\n             cx.tcx.tcache.insert(variant.node.id, tpt);\n@@ -752,12 +759,8 @@ mod collect {\n                 alt (object.dtor) {\n                     case (none) {/* nothing to do */ }\n                     case (some(?m)) {\n-                        let vec[@ast::constr] constrs = [];\n-                        let vec[arg] res_inputs = [];\n-                        auto t =\n-                            ty::mk_fn(cx.tcx, ast::proto_fn, res_inputs,\n-                                      ty::mk_nil(cx.tcx), ast::return,\n-                                      constrs);\n+                        auto t = ty::mk_fn(cx.tcx, ast::proto_fn, [],\n+                                   ty::mk_nil(cx.tcx), ast::return, []);\n                         write::ty_only(cx.tcx, m.node.ann.id, t);\n                     }\n                 }\n@@ -1421,9 +1424,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                         &@ast::expr rhs, &ast::ann a) {\n         check_expr(fcx, lhs);\n         check_expr(fcx, rhs);\n-        auto typ =\n-            demand::simple(fcx, sp, expr_ty(fcx.ccx.tcx, lhs),\n-                           expr_ty(fcx.ccx.tcx, rhs));\n+        demand::simple(fcx, sp, expr_ty(fcx.ccx.tcx, lhs),\n+                       expr_ty(fcx.ccx.tcx, rhs));\n         write::ty_only_fixup(fcx, a.id, ty::mk_nil(fcx.ccx.tcx));\n     }\n     // A generic function for checking call expressions\n@@ -2123,12 +2125,13 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 auto inputs =\n                     vec::map[ast::arg, arg](f, m.node.meth.decl.inputs);\n                 auto output = convert(m.node.meth.decl.output);\n-                ret rec(proto=m.node.meth.proto,\n-                        ident=m.node.ident,\n-                        inputs=inputs,\n-                        output=output,\n-                        cf=m.node.meth.decl.cf,\n-                        constrs=m.node.meth.decl.constraints);\n+                let fn(&@ast::constr) -> @ty::constr_def g =\n+                    bind ast_constr_to_constr(ccx.tcx, _);\n+                let vec[@ty::constr_def] out_constrs =\n+                    vec::map(g, m.node.meth.decl.constraints);\n+                ret rec(proto=m.node.meth.proto, ident=m.node.ident,\n+                        inputs=inputs, output=output, cf=m.node.meth.decl.cf,\n+                        constrs=out_constrs);\n             }\n             fn get_anon_obj_method_types(@crate_ctxt ccx,\n                                          &ast::anon_obj anon_obj) ->\n@@ -2180,6 +2183,21 @@ fn get_obj_info(&@crate_ctxt ccx) -> option::t[obj_info] {\n     ret vec::last[obj_info](ccx.obj_infos);\n }\n \n+fn ast_constr_to_constr(ty::ctxt tcx, &@ast::constr c)\n+    -> @ty::constr_def {\n+    alt (tcx.def_map.find(c.node.ann.id)) {\n+        case (some(ast::def_fn(?pred_id))) {\n+            ret @respan(c.span, rec(path=c.node.path, args=c.node.args,\n+                                    id=pred_id));\n+        }\n+        case (_) {\n+            tcx.sess.span_err(c.span, \"Predicate \"\n+                              + path_to_str(c.node.path)\n+                              + \" is unbound or bound to a non-function\");\n+        }\n+    }\n+}\n+\n fn check_decl_initializer(&@fn_ctxt fcx, &ast::def_id lid,\n                           &ast::initializer init) {\n     check_expr(fcx, init.expr);"}, {"sha": "929bfdcc25c3689a4491d75d46553554c61d4c81", "filename": "src/comp/pretty/ppaux.rs", "status": "modified", "additions": 46, "deletions": 36, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Fcomp%2Fpretty%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Fcomp%2Fpretty%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fppaux.rs?ref=260aa408f390cf457eb19507fc80ec388a039f8e", "patch": "@@ -1,7 +1,6 @@\n \n import std::io;\n import middle::ty::*;\n-import front::ast::constr_arg;\n import front::lexer;\n import pp::word;\n import pp::eof;\n@@ -21,9 +20,10 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n             };\n         ret s + ty_to_str(cx, input.ty);\n     }\n+\n     fn fn_to_str(&ctxt cx, ast::proto proto, option::t[ast::ident] ident,\n                  vec[arg] inputs, t output, ast::controlflow cf,\n-                 &vec[@ast::constr] constrs) -> str {\n+                 &vec[@constr_def] constrs) -> str {\n         auto f = bind fn_input_to_str(cx, _);\n         auto s;\n         alt (proto) {\n@@ -69,7 +69,7 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n         case (ty_int) { s += \"int\"; }\n         case (ty_float) { s += \"float\"; }\n         case (ty_uint) { s += \"uint\"; }\n-        case (ty_machine(?tm)) { s += common::ty_mach_to_str(tm); }\n+        case (ty_machine(?tm)) { s += ty_mach_to_str(tm); }\n         case (ty_char) { s += \"char\"; }\n         case (ty_str) { s += \"str\"; }\n         case (ty_istr) { s += \"istr\"; }\n@@ -92,10 +92,8 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n         }\n         case (ty_tag(?id, ?tps)) {\n             // The user should never see this if the cname is set properly!\n-\n             s +=\n-                \"<tag#\" + util::common::istr(id._0) + \":\" +\n-                    util::common::istr(id._1) + \">\";\n+                \"<tag#\" + istr(id._0) + \":\" + istr(id._1) + \">\";\n             if (vec::len[t](tps) > 0u) {\n                 auto f = bind ty_to_str(cx, _);\n                 auto strs = vec::map[t, str](f, tps);\n@@ -104,21 +102,20 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n         }\n         case (ty_fn(?proto, ?inputs, ?output, ?cf, ?constrs)) {\n             s +=\n-                fn_to_str(cx, proto, none[ast::ident], inputs, output, cf,\n+                fn_to_str(cx, proto, none, inputs, output, cf,\n                           constrs);\n         }\n         case (ty_native_fn(_, ?inputs, ?output)) {\n-            let vec[@ast::constr] constrs = [];\n             s +=\n-                fn_to_str(cx, ast::proto_fn, none[ast::ident], inputs, output,\n-                          ast::return, constrs);\n+                fn_to_str(cx, ast::proto_fn, none, inputs, output,\n+                          ast::return, []);\n         }\n         case (ty_obj(?meths)) {\n             auto f = bind method_to_str(cx, _);\n             auto m = vec::map[method, str](f, meths);\n             s += \"obj {\\n\\t\" + str::connect(m, \"\\n\\t\") + \"\\n}\";\n         }\n-        case (ty_var(?v)) { s += \"<T\" + util::common::istr(v) + \">\"; }\n+        case (ty_var(?v)) { s += \"<T\" + istr(v) + \">\"; }\n         case (ty_param(?id)) {\n             s += \"'\" + str::unsafe_from_bytes([('a' as u8) + (id as u8)]);\n         }\n@@ -144,7 +141,7 @@ fn constr_arg_to_str[T](fn(&T) -> str  f, &ast::constr_arg_general_[T] c) ->\n     }\n }\n \n-fn constr_arg_to_str_1(&ast::constr_arg_general_[str] c) -> str {\n+fn constr_arg_to_str_1(&front::ast::constr_arg_general_[str] c) -> str {\n     alt (c) {\n         case (ast::carg_base) { ret \"*\"; }\n         case (ast::carg_ident(?i)) { ret i; }\n@@ -164,18 +161,7 @@ fn constr_args_to_str[T](fn(&T) -> str  f,\n     ret s;\n }\n \n-fn constr_args_to_str_1(&vec[@ast::constr_arg_use] args) -> str {\n-    auto comma = false;\n-    auto s = \"(\";\n-    for (@ast::constr_arg_use a in args) {\n-        if (comma) { s += \", \"; } else { comma = true; }\n-        s += constr_arg_to_str_1(a.node);\n-    }\n-    s += \")\";\n-    ret s;\n-}\n-\n-fn print_literal(&ps s, &@ast::lit lit) {\n+fn print_literal(&ps s, &@front::ast::lit lit) {\n     maybe_print_comment(s, lit.span.lo);\n     alt (next_lit(s)) {\n         case (some(?lt)) {\n@@ -196,18 +182,18 @@ fn print_literal(&ps s, &@ast::lit lit) {\n             word(s.s,\n                  \"'\" + escape_str(str::from_bytes([ch as u8]), '\\'') + \"'\");\n         }\n-        case (ast::lit_int(?val)) { word(s.s, common::istr(val)); }\n-        case (ast::lit_uint(?val)) { word(s.s, common::uistr(val) + \"u\"); }\n+        case (ast::lit_int(?val)) { word(s.s, istr(val)); }\n+        case (ast::lit_uint(?val)) { word(s.s, uistr(val) + \"u\"); }\n         case (ast::lit_float(?fstr)) { word(s.s, fstr); }\n         case (ast::lit_mach_int(?mach, ?val)) {\n-            word(s.s, common::istr(val as int));\n-            word(s.s, common::ty_mach_to_str(mach));\n+            word(s.s, istr(val as int));\n+            word(s.s, ty_mach_to_str(mach));\n         }\n         case (ast::lit_mach_float(?mach, ?val)) {\n             // val is already a str\n \n             word(s.s, val);\n-            word(s.s, common::ty_mach_to_str(mach));\n+            word(s.s, ty_mach_to_str(mach));\n         }\n         case (ast::lit_nil) { word(s.s, \"()\"); }\n         case (ast::lit_bool(?val)) {\n@@ -216,7 +202,7 @@ fn print_literal(&ps s, &@ast::lit lit) {\n     }\n }\n \n-fn lit_to_str(&@ast::lit l) -> str { be to_str(l, print_literal); }\n+fn lit_to_str(&@front::ast::lit l) -> str { be to_str(l, print_literal); }\n \n fn next_lit(&ps s) -> option::t[lexer::lit] {\n     alt (s.literals) {\n@@ -360,22 +346,46 @@ const uint default_columns = 78u;\n // needed b/c constr_args_to_str needs\n // something that takes an alias\n // (argh)\n-fn uint_to_str(&uint i) -> str { ret util::common::uistr(i); }\n \n-fn constr_to_str(&@ast::constr c) -> str {\n-    ret path_to_str(c.node.path) +\n-            constr_args_to_str(uint_to_str, c.node.args);\n+fn uint_to_str(&uint i) -> str { ret uistr(i); }\n+\n+fn constr_to_str(&@constr_def c) -> str {\n+  ret path_to_str(c.node.path)\n+      + constr_args_to_str(uint_to_str, c.node.args);\n }\n \n-fn constrs_str(&vec[@ast::constr] constrs) -> str {\n+\n+fn ast_constr_to_str(&@front::ast::constr c) -> str {\n+  ret path_to_str(c.node.path)\n+      + constr_args_to_str(uint_to_str, c.node.args);\n+}\n+\n+fn constrs_str(&vec[@constr_def] constrs) -> str {\n     auto s = \"\";\n     auto colon = true;\n-    for (@ast::constr c in constrs) {\n+    for (@constr_def c in constrs) {\n         if (colon) { s += \" : \"; colon = false; } else { s += \", \"; }\n         s += constr_to_str(c);\n     }\n     ret s;\n }\n+\n+fn ast_constrs_str(&vec[@ast::constr] constrs) -> str {\n+  auto s = \"\";\n+  auto colon = true;\n+  for (@ast::constr c in constrs) {\n+    if (colon) {\n+      s += \" : \";\n+      colon = false;\n+    }\n+    else {\n+      s += \", \";\n+    }\n+    s += ast_constr_to_str(c);\n+  }\n+  ret s;\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "8db88541c2fc57ac53cd319037bec905ebd9d458", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=260aa408f390cf457eb19507fc80ec388a039f8e", "patch": "@@ -802,7 +802,7 @@ fn print_expr(&ps s, &@ast::expr expr) {\n         }\n         case (ast::expr_anon_obj(_, _, _, _)) {\n             word(s.s, \"anon obj\");\n-            // TODO: nicer pretty-printing of anon objs\n+            // FIXME (issue #499): nicer pretty-printing of anon objs\n \n         }\n     }\n@@ -1094,7 +1094,7 @@ fn print_ty_fn(&ps s, &ast::proto proto, &option::t[str] id,\n         }\n         end(s);\n     }\n-    word_space(s, constrs_str(constrs));\n+    word_space(s, ast_constrs_str(constrs));\n     end(s);\n }\n "}, {"sha": "12ccbb2bbfbdc37f9901244a427b21f7e55525db", "filename": "src/lib/either.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Flib%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Flib%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Feither.rs?ref=260aa408f390cf457eb19507fc80ec388a039f8e", "patch": "@@ -0,0 +1,64 @@\n+import option;\n+import option::some;\n+import option::none;\n+\n+tag t[T, U] {\n+    left(T);\n+    right(U);\n+}\n+\n+type operator[T, U] = fn(&T) -> U;\n+\n+fn either[T, U, V](&operator[T, V] f_left,\n+                   &operator[U, V] f_right,\n+                   &t[T, U] value) -> V {\n+    alt (value) {\n+        case (left(?l)) { f_left(l) }\n+        case (right(?r)) { f_right(r) }\n+    }\n+}\n+\n+fn lefts[T, U](&vec[t[T, U]] eithers) -> vec[T] {\n+    let vec[T] result = [];\n+    for (t[T, U] elt in eithers) {\n+        alt (elt) {\n+            case (left(?l)) { result += [l] }\n+            case (_) { /* fallthrough */ }\n+        }\n+    }\n+    ret result;\n+}\n+\n+fn rights[T, U](&vec[t[T, U]] eithers) -> vec[U] {\n+    let vec[U] result = [];\n+    for (t[T, U] elt in eithers) {\n+        alt (elt) {\n+            case (right(?r)) { result += [r] }\n+            case (_) { /* fallthrough */ }\n+        }\n+    }\n+    ret result;\n+}\n+\n+fn partition[T, U](&vec[t[T, U]] eithers) -> tup(vec[T], vec[U]) {\n+    let vec[T] lefts = [];\n+    let vec[U] rights = [];\n+    for (t[T, U] elt in eithers) {\n+        alt (elt) {\n+            case (left(?l)) { lefts += [l] }\n+            case (right(?r)) { rights += [r] }\n+        }\n+    }\n+    ret tup(lefts, rights);\n+}\n+\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//"}, {"sha": "a752e005b5e30bbec47cc5ca6ac7716722f2f59b", "filename": "src/lib/list.rs", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Flib%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Flib%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flist.rs?ref=260aa408f390cf457eb19507fc80ec388a039f8e", "patch": "@@ -18,35 +18,52 @@ fn from_vec[T](vec[T] v) -> list[T] {\n     ret l;\n }\n \n-fn foldl[T, U](&list[T] ls, &U u, fn(&T, &U) -> U  f) -> U {\n-    alt (ls) {\n-        case (cons(?hd, ?tl)) {\n-            auto u_ = f(hd, u);\n-            be foldl[T, U](*tl, u_, f);\n+fn foldl[T, U](&list[T] ls_, &U u, fn(&T, &U) -> U  f) -> U {\n+    let U accum = u;\n+    auto ls = ls_;\n+    while (true) {\n+        alt (ls) {\n+            case (cons(?hd, ?tl)) {\n+                accum = f(hd, accum);\n+                ls = *tl;\n+            }\n+            case (nil) { break; }\n         }\n-        case (nil) { ret u; }\n     }\n+    ret accum;\n }\n \n-fn find[T, U](&list[T] ls, fn(&T) -> option::t[U]  f) -> option::t[U] {\n-    alt (ls) {\n-        case (cons(?hd, ?tl)) {\n-            alt (f(hd)) {\n-                case (none) { be find[T, U](*tl, f); }\n-                case (some(?res)) { ret some[U](res); }\n+fn find[T, U](&list[T] ls_, fn(&T) -> option::t[U]  f) -> option::t[U] {\n+    auto ls = ls_;\n+    while (true) {\n+        alt (ls) {\n+            case (cons(?hd, ?tl)) {\n+                alt (f(hd)) {\n+                    case (none) { ls = *tl; }\n+                    case (some(?res)) { ret some(res); }\n+                }\n             }\n+            case (nil) { break; }\n         }\n-        case (nil) { ret none[U]; }\n     }\n+    ret none;\n }\n \n-fn has[T](&list[T] ls, &T elt) -> bool {\n-    alt (ls) {\n-        case (cons(?hd, ?tl)) {\n-            if (elt == hd) { ret true; } else { be has(*tl, elt); }\n+fn has[T](&list[T] ls_, &T elt) -> bool {\n+    auto ls = ls_;\n+    while (true) {\n+        alt (ls) {\n+            case (cons(?hd, ?tl)) {\n+                if (elt == hd) {\n+                    ret true;\n+                } else {\n+                    ls = *tl;\n+                }\n+            }\n+            case (nil) { ret false; }\n         }\n-        case (nil) { ret false; }\n     }\n+    ret false; // Typestate checker doesn't understand infinite loops\n }\n \n fn length[T](&list[T] ls) -> uint {"}, {"sha": "26d36257bd5492f7c490f2f1bfd96ca0610a8340", "filename": "src/lib/std.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=260aa408f390cf457eb19507fc80ec388a039f8e", "patch": "@@ -22,6 +22,7 @@ mod task;\n \n // Utility modules.\n \n+mod either;\n mod option;\n mod util;\n "}, {"sha": "14fddb55633be06b9a6c3a150fd85756948e0683", "filename": "src/lib/term.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Flib%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Flib%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fterm.rs?ref=260aa408f390cf457eb19507fc80ec388a039f8e", "patch": "@@ -48,7 +48,17 @@ fn reset(io::buf_writer writer) {\n }\n \n fn color_supported() -> bool {\n-    ret generic_os::getenv(\"TERM\") == option::some[str](\"xterm-color\");\n+    auto supported_terms = [\"xterm-color\",\n+                            \"xterm\",\n+                            \"screen-bce\"];\n+    ret alt (generic_os::getenv(\"TERM\")) {\n+        case (option::some(?env)) {\n+            vec::member(env, supported_terms)\n+        }\n+        case (option::none) {\n+            false\n+        }\n+    };\n }\n \n fn set_color(io::buf_writer writer, u8 first_char, u8 color) {\n@@ -67,3 +77,11 @@ fn bg(io::buf_writer writer, u8 color) {\n }\n // export fg;\n // export bg;\n+\n+// Local Variables:\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "31786fcaf655fe3c7368924dddf1a8ff282ddbe9", "filename": "src/test/compile-fail/ext-after-attrib.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Ftest%2Fcompile-fail%2Fext-after-attrib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Ftest%2Fcompile-fail%2Fext-after-attrib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fext-after-attrib.rs?ref=260aa408f390cf457eb19507fc80ec388a039f8e", "patch": "@@ -0,0 +1,8 @@\n+// xfail-stage0\n+// error-pattern:expecting \\[, found fmt\n+\n+// Don't know how to deal with a syntax extension appearing after an\n+// item attribute. Probably could use a better error message.\n+#[foo = \"bar\"]\n+#fmt(\"baz\")\n+fn main() { }\n\\ No newline at end of file"}, {"sha": "ae8068d05e16ee232f3e4e7d7019311679e1c582", "filename": "src/test/compile-fail/not-a-pred.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Ftest%2Fcompile-fail%2Fnot-a-pred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Ftest%2Fcompile-fail%2Fnot-a-pred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-a-pred.rs?ref=260aa408f390cf457eb19507fc80ec388a039f8e", "patch": "@@ -1,6 +1,6 @@\n // -*- rust -*-\n-\n-// error-pattern: mismatched types\n+// xfail-stage0\n+// error-pattern: Non-predicate in constraint: lt\n \n fn f(int a, int b) : lt(a,b) {\n }"}, {"sha": "5c7df451bf2f324281fe7dce138ce6fe03e8f10c", "filename": "src/test/run-pass/anon-objs.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Ftest%2Frun-pass%2Fanon-objs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Ftest%2Frun-pass%2Fanon-objs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fanon-objs.rs?ref=260aa408f390cf457eb19507fc80ec388a039f8e", "patch": "@@ -5,18 +5,30 @@\n use std;\n \n fn main() {\n+\n     obj a() {\n-        fn foo() -> int { ret 2; }\n-        fn bar() -> int { ret self.foo(); }\n+        fn foo() -> int {\n+            ret 2;\n+        }\n+        fn bar() -> int {\n+            ret self.foo();\n+        }\n     }\n+\n     auto my_a = a();\n+\n     // Extending an object with a new method\n+    auto my_b = obj { \n+        fn baz() -> int { \n+            ret self.foo(); \n+        } \n+        with my_a \n+    };\n \n-    auto my_b = anon obj;\n     // Extending an object with a new field\n+    auto my_c = obj(int quux) { with my_a } ;\n \n-    auto my_c = anon obj;\n     // Should this be legal?\n-\n-    auto my_d = anon obj;\n-}\n\\ No newline at end of file\n+    auto my_d = obj() { with my_a } ;\n+    \n+}"}, {"sha": "c407a386d600cd4245bdcaa560b7439d7af38a39", "filename": "src/test/run-pass/item-attributes.rs", "status": "modified", "additions": 78, "deletions": 6, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Ftest%2Frun-pass%2Fitem-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Ftest%2Frun-pass%2Fitem-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fitem-attributes.rs?ref=260aa408f390cf457eb19507fc80ec388a039f8e", "patch": "@@ -1,14 +1,16 @@\n-\n-\n-\n // xfail-stage0\n+\n mod test_single_attr_outer {\n \n     #[attr = \"val\"]\n     const int x = 10;\n \n     #[attr = \"val\"]\n-    mod mod1 { }\n+    fn f() {}\n+\n+    #[attr = \"val\"]\n+    mod mod1 {\n+    }\n \n     #[attr = \"val\"]\n     native \"rust\" mod rustrt { }\n@@ -29,7 +31,12 @@ mod test_multi_attr_outer {\n \n     #[attr1 = \"val\"]\n     #[attr2 = \"val\"]\n-    mod mod1 { }\n+    fn f() {}\n+\n+    #[attr1 = \"val\"]\n+    #[attr2 = \"val\"]\n+    mod mod1 {\n+    }\n \n     #[attr1 = \"val\"]\n     #[attr2 = \"val\"]\n@@ -45,4 +52,69 @@ mod test_multi_attr_outer {\n     obj o() { }\n }\n \n-fn main() { }\n\\ No newline at end of file\n+mod test_stmt_single_attr_outer {\n+\n+    fn f() {\n+\n+        #[attr = \"val\"]\n+        const int x = 10;\n+\n+        #[attr = \"val\"]\n+        fn f() {}\n+\n+        /* FIXME: Issue #493\n+        #[attr = \"val\"]\n+        mod mod1 {\n+        }\n+\n+        #[attr = \"val\"]\n+        native \"rust\" mod rustrt {\n+        }\n+        */\n+\n+        #[attr = \"val\"]\n+        type t = obj { };\n+\n+        #[attr = \"val\"]\n+        obj o() { }\n+\n+    }\n+}\n+\n+mod test_stmt_multi_attr_outer {\n+\n+    fn f() {\n+\n+        #[attr1 = \"val\"]\n+        #[attr2 = \"val\"]\n+        const int x = 10;\n+\n+        #[attr1 = \"val\"]\n+        #[attr2 = \"val\"]\n+        fn f() {}\n+\n+        /* FIXME: Issue #493\n+        #[attr1 = \"val\"]\n+        #[attr2 = \"val\"]\n+        mod mod1 {\n+        }\n+\n+        #[attr1 = \"val\"]\n+        #[attr2 = \"val\"]\n+        native \"rust\" mod rustrt {\n+        }\n+        */\n+\n+        #[attr1 = \"val\"]\n+        #[attr2 = \"val\"]\n+        type t = obj { };\n+\n+        #[attr1 = \"val\"]\n+        #[attr2 = \"val\"]\n+        obj o() { }\n+\n+    }\n+}\n+\n+fn main() {\n+}"}, {"sha": "0ece8be64e978bcd39987fc5a7169efa1cdce7b9", "filename": "src/test/run-pass/lib-either.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Ftest%2Frun-pass%2Flib-either.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Ftest%2Frun-pass%2Flib-either.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-either.rs?ref=260aa408f390cf457eb19507fc80ec388a039f8e", "patch": "@@ -0,0 +1,117 @@\n+// xfail-stage0\n+\n+use std;\n+import std::either::*;\n+import std::vec::len;\n+\n+fn test_either_left() {\n+  auto val = left(10);\n+  fn f_left(&int x) -> bool { x == 10 }\n+  fn f_right(&uint x) -> bool { false }\n+  assert (either(f_left, f_right, val));\n+}\n+\n+fn test_either_right() {\n+  auto val = right(10u);\n+  fn f_left(&int x) -> bool { false }\n+  fn f_right(&uint x) -> bool { x == 10u }\n+  assert (either(f_left, f_right, val));\n+}\n+\n+fn test_lefts() {\n+  auto input = [left(10),\n+                right(11),\n+                left(12),\n+                right(13),\n+                left(14)];\n+  auto result = lefts(input);\n+  assert (result == [10, 12, 14]);\n+}\n+\n+fn test_lefts_none() {\n+  let vec[t[int, int]] input = [right(10),\n+                                right(10)];\n+  auto result = lefts(input);\n+  assert (len(result) == 0u);\n+}\n+\n+fn test_lefts_empty() {\n+  let vec[t[int, int]] input = [];\n+  auto result = lefts(input);\n+  assert (len(result) == 0u);\n+}\n+\n+fn test_rights() {\n+  auto input = [left(10),\n+                right(11),\n+                left(12),\n+                right(13),\n+                left(14)];\n+  auto result = rights(input);\n+  assert (result == [11, 13]);\n+}\n+\n+fn test_rights_none() {\n+  let vec[t[int, int]] input = [left(10),\n+                                left(10)];\n+  auto result = rights(input);\n+  assert (len(result) == 0u);\n+}\n+\n+fn test_rights_empty() {\n+    let vec[t[int, int]] input = [];\n+    auto result = rights(input);\n+    assert (len(result) == 0u);\n+}\n+\n+fn test_partition() {\n+  auto input = [left(10),\n+                right(11),\n+                left(12),\n+                right(13),\n+                left(14)];\n+  auto result = partition(input);\n+  assert (result._0.(0) == 10);\n+  assert (result._0.(1) == 12);\n+  assert (result._0.(2) == 14);\n+  assert (result._1.(0) == 11);\n+  assert (result._1.(1) == 13);\n+}\n+\n+fn test_partition_no_lefts() {\n+  let vec[t[int, int]] input = [right(10),\n+                                right(11)];\n+  auto result = partition(input);\n+  assert (len(result._0) == 0u);\n+  assert (len(result._1) == 2u);\n+}\n+\n+fn test_partition_no_rights() {\n+  let vec[t[int, int]] input = [left(10),\n+                                left(11)];\n+  auto result = partition(input);\n+  assert (len(result._0) == 2u);\n+  assert (len(result._1) == 0u);\n+}\n+\n+fn test_partition_empty() {\n+  let vec[t[int, int]] input = [];\n+  auto result = partition(input);\n+  assert (len(result._0) == 0u);\n+  assert (len(result._1) == 0u);\n+}\n+\n+fn main() {\n+  test_either_left();\n+  test_either_right();\n+  test_lefts();\n+  test_lefts_none();\n+  test_lefts_empty();\n+  test_rights();\n+  test_rights_none();\n+  test_rights_empty();\n+  test_partition();\n+  test_partition_no_lefts();\n+  test_partition_no_rights();\n+  test_partition_empty();\n+}\n\\ No newline at end of file"}, {"sha": "df56f4810ee5c55b38cfc58b62913408a6e3fd62", "filename": "src/test/run-pass/simple-anon-objs.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Ftest%2Frun-pass%2Fsimple-anon-objs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260aa408f390cf457eb19507fc80ec388a039f8e/src%2Ftest%2Frun-pass%2Fsimple-anon-objs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimple-anon-objs.rs?ref=260aa408f390cf457eb19507fc80ec388a039f8e", "patch": "@@ -1,7 +1,6 @@\n \n \n // xfail-stage0\n-// xfail-stage1\n use std;\n \n fn main() {\n@@ -11,10 +10,24 @@ fn main() {\n     auto my_a = a();\n     // Extending an object with a new method\n \n-    auto my_b = anon obj;\n-    assert (my_a.foo() == 2);\n-    // FIXME: these raise a runtime error\n-    //assert my_b.foo() == 2;\n+    auto my_b = obj { \n+        fn bar() -> int { \n+            ret 3;\n+        }\n+        with my_a \n+    };\n \n+    assert (my_a.foo() == 2);\n     assert (my_b.bar() == 3);\n-}\n\\ No newline at end of file\n+\n+    auto my_c = obj {\n+        fn baz() -> int {\n+            ret 4;\n+        }\n+        with my_b\n+    };\n+\n+    assert (my_c.baz() == 4);\n+\n+}\n+"}]}