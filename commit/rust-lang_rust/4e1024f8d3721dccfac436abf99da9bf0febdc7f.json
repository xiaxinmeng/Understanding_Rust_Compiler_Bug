{"sha": "4e1024f8d3721dccfac436abf99da9bf0febdc7f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlMTAyNGY4ZDM3MjFkY2NmYWM0MzZhYmY5OWRhOWJmMGZlYmRjN2Y=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-08-07T06:59:12Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-08-13T22:27:34Z"}, "message": "core: Put stability attributes all over the slice module\n\nMuch of this is as discussed[1]. Many things are marked\n\n[1]: https://github.com/rust-lang/meeting-minutes/blob/master/Meeting-API-review-2014-08-06.md", "tree": {"sha": "0a7926446523b65b7b9ec49fe889d1794ae10674", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a7926446523b65b7b9ec49fe889d1794ae10674"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e1024f8d3721dccfac436abf99da9bf0febdc7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e1024f8d3721dccfac436abf99da9bf0febdc7f", "html_url": "https://github.com/rust-lang/rust/commit/4e1024f8d3721dccfac436abf99da9bf0febdc7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e1024f8d3721dccfac436abf99da9bf0febdc7f/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4b354ca0258b4914b6e6b64b0143a8aec861fa0", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4b354ca0258b4914b6e6b64b0143a8aec861fa0", "html_url": "https://github.com/rust-lang/rust/commit/a4b354ca0258b4914b6e6b64b0143a8aec861fa0"}], "stats": {"total": 74, "additions": 74, "deletions": 0}, "files": [{"sha": "354beb56d2dc3cbcf8386a2bdaf8d258e92f9418", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e1024f8d3721dccfac436abf99da9bf0febdc7f/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e1024f8d3721dccfac436abf99da9bf0febdc7f/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=4e1024f8d3721dccfac436abf99da9bf0febdc7f", "patch": "@@ -362,6 +362,7 @@ pub struct MutItems<'a, T> {\n \n impl<'a, T> Iterator<&'a mut T> for MutItems<'a, T> {\n     #[inline]\n+    #[allow(deprecated)] // mut_shift_ref\n     fn next(&mut self) -> Option<&'a mut T> {\n         if self.nelts == 0 {\n             return None;\n@@ -384,6 +385,7 @@ impl<'a, T> Iterator<&'a mut T> for MutItems<'a, T> {\n \n impl<'a, T> DoubleEndedIterator<&'a mut T> for MutItems<'a, T> {\n     #[inline]\n+    #[allow(deprecated)] // mut_shift_ref\n     fn next_back(&mut self) -> Option<&'a mut T> {\n         if self.nelts == 0 {\n             return None;"}, {"sha": "5acb55de6f155fb4c8b1e0ded320c100e23c6b18", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/4e1024f8d3721dccfac436abf99da9bf0febdc7f/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e1024f8d3721dccfac436abf99da9bf0febdc7f/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=4e1024f8d3721dccfac436abf99da9bf0febdc7f", "patch": "@@ -12,6 +12,7 @@\n //!\n //! For more details `std::slice`.\n \n+#![stable]\n #![doc(primitive = \"slice\")]\n \n // How this module is organized.\n@@ -57,27 +58,31 @@ use RawSlice = raw::Slice;\n //\n \n /// Extension methods for vectors\n+#[unstable = \"may merge with other traits; region parameter may disappear\"]\n pub trait ImmutableSlice<'a, T> {\n     /**\n      * Returns a slice of self spanning the interval [`start`, `end`).\n      *\n      * Fails when the slice (or part of it) is outside the bounds of self,\n      * or when `start` > `end`.\n      */\n+    #[unstable]\n     fn slice(&self, start: uint, end: uint) -> &'a [T];\n \n     /**\n      * Returns a slice of self from `start` to the end of the vec.\n      *\n      * Fails when `start` points outside the bounds of self.\n      */\n+    #[unstable]\n     fn slice_from(&self, start: uint) -> &'a [T];\n \n     /**\n      * Returns a slice of self from the start of the vec to `end`.\n      *\n      * Fails when `end` points outside the bounds of self.\n      */\n+    #[unstable]\n     fn slice_to(&self, end: uint) -> &'a [T];\n \n     /// Divides one slice into two at an index.\n@@ -87,24 +92,29 @@ pub trait ImmutableSlice<'a, T> {\n     /// indices from `[mid, len)` (excluding the index `len` itself).\n     ///\n     /// Fails if `mid > len`.\n+    #[unstable]\n     fn split_at(&self, mid: uint) -> (&'a [T], &'a [T]);\n \n     /// Returns an iterator over the vector\n+    #[unstable = \"iterator type may change\"]\n     fn iter(self) -> Items<'a, T>;\n     /// Returns an iterator over the subslices of the vector which are\n     /// separated by elements that match `pred`.  The matched element\n     /// is not contained in the subslices.\n+    #[unstable = \"iterator type may change\"]\n     fn split(self, pred: |&T|: 'a -> bool) -> Splits<'a, T>;\n     /// Returns an iterator over the subslices of the vector which are\n     /// separated by elements that match `pred`, limited to splitting\n     /// at most `n` times.  The matched element is not contained in\n     /// the subslices.\n+    #[unstable = \"iterator type may change\"]\n     fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T>;\n     /// Returns an iterator over the subslices of the vector which are\n     /// separated by elements that match `pred` limited to splitting\n     /// at most `n` times. This starts at the end of the vector and\n     /// works backwards.  The matched element is not contained in the\n     /// subslices.\n+    #[unstable = \"iterator type may change\"]\n     fn rsplitn(self,  n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T>;\n \n     /**\n@@ -129,6 +139,7 @@ pub trait ImmutableSlice<'a, T> {\n      * ```\n      *\n      */\n+    #[unstable = \"iterator type may change\"]\n     fn windows(self, size: uint) -> Windows<'a, T>;\n     /**\n      *\n@@ -154,24 +165,30 @@ pub trait ImmutableSlice<'a, T> {\n      * ```\n      *\n      */\n+    #[unstable = \"iterator type may change\"]\n     fn chunks(self, size: uint) -> Chunks<'a, T>;\n \n     /// Returns the element of a vector at the given index, or `None` if the\n     /// index is out of bounds\n+    #[unstable]\n     fn get(&self, index: uint) -> Option<&'a T>;\n     /// Returns the first element of a vector, or `None` if it is empty\n+    #[unstable = \"name may change\"]\n     fn head(&self) -> Option<&'a T>;\n     /// Returns all but the first element of a vector\n+    #[unstable = \"name may change\"]\n     fn tail(&self) -> &'a [T];\n     /// Returns all but the first `n' elements of a vector\n     #[deprecated = \"use slice_from\"]\n     fn tailn(&self, n: uint) -> &'a [T];\n     /// Returns all but the last element of a vector\n+    #[unstable = \"name may change\"]\n     fn init(&self) -> &'a [T];\n     /// Returns all but the last `n' elements of a vector\n     #[deprecated = \"use slice_to but note the arguments are different\"]\n     fn initn(&self, n: uint) -> &'a [T];\n     /// Returns the last element of a vector, or `None` if it is empty.\n+    #[unstable = \"name may change\"]\n     fn last(&self) -> Option<&'a T>;\n \n     /// Returns a pointer to the element at the given index, without doing\n@@ -193,6 +210,7 @@ pub trait ImmutableSlice<'a, T> {\n      * Modifying the vector may cause its buffer to be reallocated, which\n      * would also make any pointers to it invalid.\n      */\n+    #[unstable]\n     fn as_ptr(&self) -> *const T;\n \n     /**\n@@ -241,6 +259,7 @@ pub trait ImmutableSlice<'a, T> {\n      *\n      * Returns `None` if vector is empty\n      */\n+    #[deprecated = \"find some other way. sorry\"]\n     fn shift_ref(&mut self) -> Option<&'a T>;\n \n     /**\n@@ -259,9 +278,11 @@ pub trait ImmutableSlice<'a, T> {\n      *\n      * Returns `None` if slice is empty.\n      */\n+    #[deprecated = \"find some other way. sorry\"]\n     fn pop_ref(&mut self) -> Option<&'a T>;\n }\n \n+#[unstable]\n impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n     #[inline]\n     fn slice(&self, start: uint, end: uint) -> &'a [T] {\n@@ -458,6 +479,7 @@ impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n \n /// Extension methods for vectors such that their elements are\n /// mutable.\n+#[experimental = \"may merge with other traits; may lose region param; needs review\"]\n pub trait MutableSlice<'a, T> {\n     /// Returns a mutable reference to the element at the given index,\n     /// or `None` if the index is out of bounds\n@@ -522,6 +544,7 @@ pub trait MutableSlice<'a, T> {\n      *\n      * Returns `None` if slice is empty\n      */\n+    #[deprecated = \"find some other way. sorry\"]\n     fn mut_shift_ref(&mut self) -> Option<&'a mut T>;\n \n     /**\n@@ -540,6 +563,7 @@ pub trait MutableSlice<'a, T> {\n      *\n      * Returns `None` if slice is empty.\n      */\n+    #[deprecated = \"find some other way. sorry\"]\n     fn mut_pop_ref(&mut self) -> Option<&'a mut T>;\n \n     /// Swaps two elements in a vector.\n@@ -664,6 +688,7 @@ pub trait MutableSlice<'a, T> {\n     unsafe fn copy_memory(self, src: &[T]);\n }\n \n+#[experimental = \"trait is experimental\"]\n impl<'a,T> MutableSlice<'a, T> for &'a mut [T] {\n     #[inline]\n     fn get_mut(self, index: uint) -> Option<&'a mut T> {\n@@ -812,6 +837,7 @@ impl<'a,T> MutableSlice<'a, T> for &'a mut [T] {\n }\n \n /// Extension methods for vectors contain `PartialEq` elements.\n+#[unstable = \"may merge with other traits\"]\n pub trait ImmutablePartialEqSlice<T:PartialEq> {\n     /// Find the first index containing a matching value\n     fn position_elem(&self, t: &T) -> Option<uint>;\n@@ -829,6 +855,7 @@ pub trait ImmutablePartialEqSlice<T:PartialEq> {\n     fn ends_with(&self, needle: &[T]) -> bool;\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<'a,T:PartialEq> ImmutablePartialEqSlice<T> for &'a [T] {\n     #[inline]\n     fn position_elem(&self, x: &T) -> Option<uint> {\n@@ -859,6 +886,7 @@ impl<'a,T:PartialEq> ImmutablePartialEqSlice<T> for &'a [T] {\n }\n \n /// Extension methods for vectors containing `Ord` elements.\n+#[unstable = \"may merge with other traits\"]\n pub trait ImmutableOrdSlice<T: Ord> {\n     /**\n      * Binary search a sorted vector for a given element.\n@@ -880,8 +908,10 @@ pub trait ImmutableOrdSlice<T: Ord> {\n     fn binary_search_elem(&self, x: &T) -> BinarySearchResult;\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<'a, T: Ord> ImmutableOrdSlice<T> for &'a [T] {\n     #[deprecated = \"use binary_search_elem\"]\n+    #[allow(deprecated)]\n     fn bsearch_elem(&self, x: &T) -> Option<uint> {\n         self.bsearch(|p| p.cmp(x))\n     }\n@@ -893,6 +923,7 @@ impl<'a, T: Ord> ImmutableOrdSlice<T> for &'a [T] {\n }\n \n /// Trait for &[T] where T is Cloneable\n+#[unstable = \"may merge with other traits\"]\n pub trait MutableCloneableSlice<T> {\n     /// Copies as many elements from `src` as it can into `self` (the\n     /// shorter of `self.len()` and `src.len()`). Returns the number\n@@ -922,6 +953,7 @@ pub trait MutableCloneableSlice<T> {\n     fn clone_from_slice(self, &[T]) -> uint;\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<'a, T:Clone> MutableCloneableSlice<T> for &'a mut [T] {\n     #[inline]\n     fn clone_from_slice(self, src: &[T]) -> uint {\n@@ -940,16 +972,19 @@ impl<'a, T:Clone> MutableCloneableSlice<T> for &'a mut [T] {\n //\n \n /// Any vector that can be represented as a slice.\n+#[unstable = \"may merge with other traits\"]\n pub trait Slice<T> {\n     /// Work with `self` as a slice.\n     fn as_slice<'a>(&'a self) -> &'a [T];\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<'a,T> Slice<T> for &'a [T] {\n     #[inline(always)]\n     fn as_slice<'a>(&'a self) -> &'a [T] { *self }\n }\n \n+#[experimental = \"trait is experimental\"]\n impl<'a, T> Collection for &'a [T] {\n     /// Returns the length of a vector\n     #[inline]\n@@ -958,6 +993,7 @@ impl<'a, T> Collection for &'a [T] {\n     }\n }\n \n+#[unstable = \"waiting for DST\"]\n impl<'a, T> Default for &'a [T] {\n     fn default() -> &'a [T] { &[] }\n }\n@@ -972,6 +1008,7 @@ impl<'a, T> Default for &'a [T] {\n // The shared definition of the `Item` and `MutItems` iterators\n macro_rules! iterator {\n     (struct $name:ident -> $ptr:ty, $elem:ty) => {\n+        #[experimental = \"needs review\"]\n         impl<'a, T> Iterator<$elem> for $name<'a, T> {\n             #[inline]\n             fn next(&mut self) -> Option<$elem> {\n@@ -1007,6 +1044,7 @@ macro_rules! iterator {\n             }\n         }\n \n+        #[experimental = \"needs review\"]\n         impl<'a, T> DoubleEndedIterator<$elem> for $name<'a, T> {\n             #[inline]\n             fn next_back(&mut self) -> Option<$elem> {\n@@ -1034,6 +1072,7 @@ macro_rules! iterator {\n }\n \n /// Immutable slice iterator\n+#[experimental = \"needs review\"]\n pub struct Items<'a, T> {\n     ptr: *const T,\n     end: *const T,\n@@ -1042,12 +1081,15 @@ pub struct Items<'a, T> {\n \n iterator!{struct Items -> *const T, &'a T}\n \n+#[experimental = \"needs review\"]\n impl<'a, T> ExactSize<&'a T> for Items<'a, T> {}\n \n+#[experimental = \"needs review\"]\n impl<'a, T> Clone for Items<'a, T> {\n     fn clone(&self) -> Items<'a, T> { *self }\n }\n \n+#[experimental = \"needs review\"]\n impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -1073,6 +1115,7 @@ impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n }\n \n /// Mutable slice iterator\n+#[experimental = \"needs review\"]\n pub struct MutItems<'a, T> {\n     ptr: *mut T,\n     end: *mut T,\n@@ -1082,16 +1125,19 @@ pub struct MutItems<'a, T> {\n \n iterator!{struct MutItems -> *mut T, &'a mut T}\n \n+#[experimental = \"needs review\"]\n impl<'a, T> ExactSize<&'a mut T> for MutItems<'a, T> {}\n \n /// An iterator over the slices of a vector separated by elements that\n /// match a predicate function.\n+#[experimental = \"needs review\"]\n pub struct Splits<'a, T> {\n     v: &'a [T],\n     pred: |t: &T|: 'a -> bool,\n     finished: bool\n }\n \n+#[experimental = \"needs review\"]\n impl<'a, T> Iterator<&'a [T]> for Splits<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a [T]> {\n@@ -1120,6 +1166,7 @@ impl<'a, T> Iterator<&'a [T]> for Splits<'a, T> {\n     }\n }\n \n+#[experimental = \"needs review\"]\n impl<'a, T> DoubleEndedIterator<&'a [T]> for Splits<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n@@ -1141,12 +1188,14 @@ impl<'a, T> DoubleEndedIterator<&'a [T]> for Splits<'a, T> {\n \n /// An iterator over the subslices of the vector which are separated\n /// by elements that match `pred`.\n+#[experimental = \"needs review\"]\n pub struct MutSplits<'a, T> {\n     v: &'a mut [T],\n     pred: |t: &T|: 'a -> bool,\n     finished: bool\n }\n \n+#[experimental = \"needs review\"]\n impl<'a, T> Iterator<&'a mut [T]> for MutSplits<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut [T]> {\n@@ -1183,6 +1232,7 @@ impl<'a, T> Iterator<&'a mut [T]> for MutSplits<'a, T> {\n     }\n }\n \n+#[experimental = \"needs review\"]\n impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut [T]> {\n@@ -1207,12 +1257,14 @@ impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T> {\n \n /// An iterator over the slices of a vector separated by elements that\n /// match a predicate function, splitting at most a fixed number of times.\n+#[experimental = \"needs review\"]\n pub struct SplitsN<'a, T> {\n     iter: Splits<'a, T>,\n     count: uint,\n     invert: bool\n }\n \n+#[experimental = \"needs review\"]\n impl<'a, T> Iterator<&'a [T]> for SplitsN<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a [T]> {\n@@ -1242,11 +1294,13 @@ impl<'a, T> Iterator<&'a [T]> for SplitsN<'a, T> {\n /// An iterator over the (overlapping) slices of length `size` within\n /// a vector.\n #[deriving(Clone)]\n+#[experimental = \"needs review\"]\n pub struct Windows<'a, T> {\n     v: &'a [T],\n     size: uint\n }\n \n+#[experimental = \"needs review\"]\n impl<'a, T> Iterator<&'a [T]> for Windows<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a [T]> {\n@@ -1276,11 +1330,13 @@ impl<'a, T> Iterator<&'a [T]> for Windows<'a, T> {\n /// When the vector len is not evenly divided by the chunk size,\n /// the last slice of the iteration will be the remainder.\n #[deriving(Clone)]\n+#[experimental = \"needs review\"]\n pub struct Chunks<'a, T> {\n     v: &'a [T],\n     size: uint\n }\n \n+#[experimental = \"needs review\"]\n impl<'a, T> Iterator<&'a [T]> for Chunks<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a [T]> {\n@@ -1306,6 +1362,7 @@ impl<'a, T> Iterator<&'a [T]> for Chunks<'a, T> {\n     }\n }\n \n+#[experimental = \"needs review\"]\n impl<'a, T> DoubleEndedIterator<&'a [T]> for Chunks<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n@@ -1321,6 +1378,7 @@ impl<'a, T> DoubleEndedIterator<&'a [T]> for Chunks<'a, T> {\n     }\n }\n \n+#[experimental = \"needs review\"]\n impl<'a, T> RandomAccessIterator<&'a [T]> for Chunks<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -1344,11 +1402,13 @@ impl<'a, T> RandomAccessIterator<&'a [T]> for Chunks<'a, T> {\n /// An iterator over a vector in (non-overlapping) mutable chunks (`size`  elements at a time). When\n /// the vector len is not evenly divided by the chunk size, the last slice of the iteration will be\n /// the remainder.\n+#[experimental = \"needs review\"]\n pub struct MutChunks<'a, T> {\n     v: &'a mut [T],\n     chunk_size: uint\n }\n \n+#[experimental = \"needs review\"]\n impl<'a, T> Iterator<&'a mut [T]> for MutChunks<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut [T]> {\n@@ -1375,6 +1435,7 @@ impl<'a, T> Iterator<&'a mut [T]> for MutChunks<'a, T> {\n     }\n }\n \n+#[experimental = \"needs review\"]\n impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutChunks<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut [T]> {\n@@ -1401,13 +1462,15 @@ impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutChunks<'a, T> {\n /// succeeded, and the contained value is an index where a matching\n /// value could be inserted while maintaining sort order.\n #[deriving(PartialEq, Show)]\n+#[experimental = \"needs review\"]\n pub enum BinarySearchResult {\n     /// The index of the found value.\n     Found(uint),\n     /// The index where the value should have been found.\n     NotFound(uint)\n }\n \n+#[experimental = \"needs review\"]\n impl BinarySearchResult {\n     /// Converts a `Found` to `Some`, `NotFound` to `None`.\n     /// Similar to `Result::ok`.\n@@ -1437,6 +1500,7 @@ impl BinarySearchResult {\n /**\n  * Converts a pointer to A into a slice of length 1 (without copying).\n  */\n+#[unstable = \"waiting for DST\"]\n pub fn ref_slice<'a, A>(s: &'a A) -> &'a [A] {\n     unsafe {\n         transmute(RawSlice { data: s, len: 1 })\n@@ -1446,6 +1510,7 @@ pub fn ref_slice<'a, A>(s: &'a A) -> &'a [A] {\n /**\n  * Converts a pointer to A into a slice of length 1 (without copying).\n  */\n+#[unstable = \"waiting for DST\"]\n pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n     unsafe {\n         let ptr: *const A = transmute(s);\n@@ -1461,6 +1526,7 @@ pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n //\n \n /// Unsafe operations\n+#[experimental = \"needs review\"]\n pub mod raw {\n     use mem::transmute;\n     use ptr::RawPtr;\n@@ -1526,6 +1592,7 @@ pub mod raw {\n }\n \n /// Operations on `[u8]`.\n+#[experimental = \"needs review\"]\n pub mod bytes {\n     use collections::Collection;\n     use ptr;\n@@ -1563,6 +1630,7 @@ pub mod bytes {\n // Boilerplate traits\n //\n \n+#[unstable = \"waiting for DST\"]\n impl<'a,T:PartialEq> PartialEq for &'a [T] {\n     fn eq(&self, other: & &'a [T]) -> bool {\n         self.len() == other.len() &&\n@@ -1574,19 +1642,23 @@ impl<'a,T:PartialEq> PartialEq for &'a [T] {\n     }\n }\n \n+#[unstable = \"waiting for DST\"]\n impl<'a,T:Eq> Eq for &'a [T] {}\n \n+#[unstable = \"waiting for DST\"]\n impl<'a,T:PartialEq, V: Slice<T>> Equiv<V> for &'a [T] {\n     #[inline]\n     fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n }\n \n+#[unstable = \"waiting for DST\"]\n impl<'a,T:Ord> Ord for &'a [T] {\n     fn cmp(&self, other: & &'a [T]) -> Ordering {\n         order::cmp(self.iter(), other.iter())\n     }\n }\n \n+#[unstable = \"waiting for DST\"]\n impl<'a, T: PartialOrd> PartialOrd for &'a [T] {\n     #[inline]\n     fn partial_cmp(&self, other: &&'a [T]) -> Option<Ordering> {"}]}