{"sha": "7299df8409097de67647b371b81da7bcf49112e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyOTlkZjg0MDkwOTdkZTY3NjQ3YjM3MWI4MWRhN2JjZjQ5MTEyZTY=", "commit": {"author": {"name": "Bernardo", "email": "berublan@gmail.com", "date": "2018-12-19T18:25:42Z"}, "committer": {"name": "Bernardo", "email": "berublan@gmail.com", "date": "2018-12-25T18:59:02Z"}, "message": "simplified version", "tree": {"sha": "02e736db2cba1f1b51873ebce4c6dc16d675fbc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02e736db2cba1f1b51873ebce4c6dc16d675fbc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7299df8409097de67647b371b81da7bcf49112e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7299df8409097de67647b371b81da7bcf49112e6", "html_url": "https://github.com/rust-lang/rust/commit/7299df8409097de67647b371b81da7bcf49112e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7299df8409097de67647b371b81da7bcf49112e6/comments", "author": {"login": "vemoo", "id": 4866051, "node_id": "MDQ6VXNlcjQ4NjYwNTE=", "avatar_url": "https://avatars.githubusercontent.com/u/4866051?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vemoo", "html_url": "https://github.com/vemoo", "followers_url": "https://api.github.com/users/vemoo/followers", "following_url": "https://api.github.com/users/vemoo/following{/other_user}", "gists_url": "https://api.github.com/users/vemoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/vemoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vemoo/subscriptions", "organizations_url": "https://api.github.com/users/vemoo/orgs", "repos_url": "https://api.github.com/users/vemoo/repos", "events_url": "https://api.github.com/users/vemoo/events{/privacy}", "received_events_url": "https://api.github.com/users/vemoo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vemoo", "id": 4866051, "node_id": "MDQ6VXNlcjQ4NjYwNTE=", "avatar_url": "https://avatars.githubusercontent.com/u/4866051?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vemoo", "html_url": "https://github.com/vemoo", "followers_url": "https://api.github.com/users/vemoo/followers", "following_url": "https://api.github.com/users/vemoo/following{/other_user}", "gists_url": "https://api.github.com/users/vemoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/vemoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vemoo/subscriptions", "organizations_url": "https://api.github.com/users/vemoo/orgs", "repos_url": "https://api.github.com/users/vemoo/repos", "events_url": "https://api.github.com/users/vemoo/events{/privacy}", "received_events_url": "https://api.github.com/users/vemoo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c9df62c1c6a778a8df9ea028d1dce98c91c4d9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c9df62c1c6a778a8df9ea028d1dce98c91c4d9d", "html_url": "https://github.com/rust-lang/rust/commit/8c9df62c1c6a778a8df9ea028d1dce98c91c4d9d"}], "stats": {"total": 139, "additions": 139, "deletions": 0}, "files": [{"sha": "6bd6a397ebf1e5f6a4c54c580c9c1cf5b0213438", "filename": "crates/ra_editor/src/line_index_utils.rs", "status": "modified", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/7299df8409097de67647b371b81da7bcf49112e6/crates%2Fra_editor%2Fsrc%2Fline_index_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7299df8409097de67647b371b81da7bcf49112e6/crates%2Fra_editor%2Fsrc%2Fline_index_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fline_index_utils.rs?ref=7299df8409097de67647b371b81da7bcf49112e6", "patch": "@@ -1,6 +1,7 @@\n use ra_text_edit::{AtomTextEdit};\n use ra_syntax::{TextUnit, TextRange};\n use crate::{LineIndex, LineCol};\n+use superslice::Ext;\n \n #[derive(Debug)]\n struct OffsetNewlineIter<'a> {\n@@ -58,6 +59,136 @@ trait TranslatedNewlineIterator {\n     }\n }\n \n+#[derive(Debug)]\n+struct AltEdit<'a> {\n+    insert_newlines: OffsetNewlineIter<'a>,\n+    delete: TextRange,\n+    diff: i64,\n+}\n+\n+fn translate_range_by(range: TextRange, diff: i64) -> TextRange {\n+    if diff == 0 {\n+        range\n+    } else {\n+        let start = translate_by(range.start(), diff);\n+        let end = translate_by(range.end(), diff);\n+        TextRange::from_to(start, end)\n+    }\n+}\n+\n+fn translate_by(x: TextUnit, diff: i64) -> TextUnit {\n+    if diff == 0 {\n+        x\n+    } else {\n+        TextUnit::from((x.to_usize() as i64 + diff) as u32)\n+    }\n+}\n+\n+fn to_alt_edits<'a>(offset: TextUnit, edits: &'a [AtomTextEdit]) -> Vec<AltEdit<'a>> {\n+    let mut xs: Vec<AltEdit<'a>> = Vec::with_capacity(edits.len());\n+    // collect and sort edits\n+    for edit in edits {\n+        // TODO discard after translating?\n+        // if edit.delete.start() >= offset {\n+        //     continue;\n+        // }\n+        let insert_index = xs.upper_bound_by_key(&edit.delete.start(), |x| x.delete.start());\n+        let diff = edit.insert.len() as i64 - edit.delete.len().to_usize() as i64;\n+        xs.insert(\n+            insert_index,\n+            AltEdit {\n+                insert_newlines: OffsetNewlineIter {\n+                    offset: edit.delete.start(),\n+                    text: &edit.insert,\n+                },\n+                delete: edit.delete,\n+                diff: diff,\n+            },\n+        );\n+    }\n+    // translate edits by previous edits\n+    for i in 1..xs.len() {\n+        let (x, prevs) = xs[0..=i].split_last_mut().unwrap();\n+        for prev in prevs {\n+            x.delete = translate_range_by(x.delete, prev.diff);\n+            x.insert_newlines.offset = translate_by(x.insert_newlines.offset, prev.diff);\n+        }\n+    }\n+    xs\n+}\n+\n+#[derive(Debug)]\n+enum NextNewline {\n+    Use,\n+    Discard,\n+    Replace(TextUnit),\n+    New(TextUnit),\n+}\n+\n+fn next_newline(candidate: Option<TextUnit>, edits: &mut [AltEdit]) -> NextNewline {\n+    let mut candidate = match candidate {\n+        None => {\n+            for edit in edits {\n+                if let Some(inserted) = edit.insert_newlines.next() {\n+                    return NextNewline::New(inserted);\n+                }\n+            }\n+            return NextNewline::Use; // END\n+        }\n+        Some(x) => x,\n+    };\n+\n+    for edit in edits {\n+        if candidate <= edit.delete.start() {\n+            return NextNewline::Replace(candidate);\n+        } else if candidate <= edit.delete.end() {\n+            return match edit.insert_newlines.next() {\n+                Some(x) => NextNewline::Replace(x),\n+                None => NextNewline::Discard,\n+            };\n+        } else {\n+            if let Some(inserted) = edit.insert_newlines.next() {\n+                return NextNewline::New(inserted);\n+            }\n+            candidate = translate_by(candidate, edit.diff);\n+        }\n+    }\n+    return NextNewline::Replace(candidate);\n+}\n+\n+fn count_newlines(offset: TextUnit, line_index: &LineIndex, edits: &[AtomTextEdit]) -> u32 {\n+    let mut edits = to_alt_edits(offset, edits);\n+    let mut orig_newlines = line_index.newlines().iter().map(|x| *x).peekable();\n+\n+    let mut count = 0;\n+\n+    loop {\n+        let res = next_newline(orig_newlines.peek().map(|x| *x), &mut edits);\n+        let next = match res {\n+            NextNewline::Use => orig_newlines.next(),\n+            NextNewline::Discard => {\n+                orig_newlines.next();\n+                continue;\n+            }\n+            NextNewline::Replace(new) => {\n+                orig_newlines.next();\n+                Some(new)\n+            }\n+            NextNewline::New(new) => Some(new),\n+        };\n+        match next {\n+            Some(n) if n <= offset => {\n+                count += 1;\n+            }\n+            _ => {\n+                break;\n+            }\n+        }\n+    }\n+\n+    count\n+}\n+\n struct TranslatedAtomEdit<'a> {\n     delete: TextRange,\n     insert: &'a str,\n@@ -256,5 +387,13 @@ mod test {\n             let actual = translate_offset_with_edit(&line_index, x.offset, &x.edits);\n             assert_eq!(actual.line, expected.line);\n         }\n+\n+        #[test]\n+        fn test_translate_offset_with_edit_alt(x in arb_text_with_offset_and_edits()) {\n+            let line_index = LineIndex::new(&x.text);\n+            let expected = translate_after_edit(&x.text, x.offset, x.edits.clone());\n+            let actual_lines = count_newlines(x.offset, &line_index, &x.edits);\n+            assert_eq!(actual_lines, expected.line);\n+        }\n     }\n }"}]}