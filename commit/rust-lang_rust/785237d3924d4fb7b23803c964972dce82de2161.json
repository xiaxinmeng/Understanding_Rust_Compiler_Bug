{"sha": "785237d3924d4fb7b23803c964972dce82de2161", "node_id": "C_kwDOAAsO6NoAKDc4NTIzN2QzOTI0ZDRmYjdiMjM4MDNjOTY0OTcyZGNlODJkZTIxNjE", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev+love@gmail.com", "date": "2022-11-20T04:15:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-20T04:15:59Z"}, "message": "Rollup merge of #104435 - scottmcm:iter-repeat-n, r=thomcc\n\n`VecDeque::resize` should re-use the buffer in the passed-in element\n\nToday it always copies it for *every* appended element, but one of those clones is avoidable.\n\nThis adds `iter::repeat_n` (https://github.com/rust-lang/rust/issues/104434) as the primitive needed to do this.  If this PR is acceptable, I'll also use this in `Vec` rather than its custom `ExtendElement` type & infrastructure that is harder to share between multiple different containers:\n\nhttps://github.com/rust-lang/rust/blob/101e1822c3e54e63996c8aaa014d55716f3937eb/library/alloc/src/vec/mod.rs#L2479-L2492", "tree": {"sha": "c3b5a12cfff05df99d15ec98e86583d3a4045dee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3b5a12cfff05df99d15ec98e86583d3a4045dee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/785237d3924d4fb7b23803c964972dce82de2161", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjean/CRBK7hj4Ov3rIwAAF3AIAH485m4MdxoPgHQl2+fGQAsV\nmHPxLFR1VVKYwd0KVEfYd9EgI6LR1lQJMbv/zbHF4Y+riFfcOcSuxvk3UFhBhmbk\na7lxE2Q8SdUAt5YSRu0X2hPBsoJgBLgdncPxtTIEEcepMdsflVgVFyCEeJP4n1Ln\nfwwt0a3zHWA58iEvY++sSz3OhcxDxdoGCvacVpeT3TfSYfd2aUtsphnauVjTDtr7\n0dDVAF38olSVVPAKJUqBvfjqgC38YP+hQ3sOGnm8hIF8dmBjaNBNg+sfiUUgmy5N\niQg1uCaqrdDBjwy3V8bNgWKp+31+PdZ1LDOynKxRDkZKs86GjW8NZ5vLh6fDZtk=\n=x3bP\n-----END PGP SIGNATURE-----\n", "payload": "tree c3b5a12cfff05df99d15ec98e86583d3a4045dee\nparent e69b84204aecf27fe18ada467f78c83b788b80e4\nparent 71bb200225f0164940acc21f1fb647c8155f1706\nauthor Yuki Okushi <huyuumi.dev+love@gmail.com> 1668917759 +0900\ncommitter GitHub <noreply@github.com> 1668917759 +0900\n\nRollup merge of #104435 - scottmcm:iter-repeat-n, r=thomcc\n\n`VecDeque::resize` should re-use the buffer in the passed-in element\n\nToday it always copies it for *every* appended element, but one of those clones is avoidable.\n\nThis adds `iter::repeat_n` (https://github.com/rust-lang/rust/issues/104434) as the primitive needed to do this.  If this PR is acceptable, I'll also use this in `Vec` rather than its custom `ExtendElement` type & infrastructure that is harder to share between multiple different containers:\n\nhttps://github.com/rust-lang/rust/blob/101e1822c3e54e63996c8aaa014d55716f3937eb/library/alloc/src/vec/mod.rs#L2479-L2492\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/785237d3924d4fb7b23803c964972dce82de2161", "html_url": "https://github.com/rust-lang/rust/commit/785237d3924d4fb7b23803c964972dce82de2161", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/785237d3924d4fb7b23803c964972dce82de2161/comments", "author": null, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e69b84204aecf27fe18ada467f78c83b788b80e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e69b84204aecf27fe18ada467f78c83b788b80e4", "html_url": "https://github.com/rust-lang/rust/commit/e69b84204aecf27fe18ada467f78c83b788b80e4"}, {"sha": "71bb200225f0164940acc21f1fb647c8155f1706", "url": "https://api.github.com/repos/rust-lang/rust/commits/71bb200225f0164940acc21f1fb647c8155f1706", "html_url": "https://github.com/rust-lang/rust/commit/71bb200225f0164940acc21f1fb647c8155f1706"}], "stats": {"total": 325, "additions": 323, "deletions": 2}, "files": [{"sha": "537fe22a4be72b3bd1f35eb1c51e124a0ca08003", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/785237d3924d4fb7b23803c964972dce82de2161/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785237d3924d4fb7b23803c964972dce82de2161/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=785237d3924d4fb7b23803c964972dce82de2161", "patch": "@@ -10,7 +10,7 @@\n use core::cmp::{self, Ordering};\n use core::fmt;\n use core::hash::{Hash, Hasher};\n-use core::iter::{repeat_with, FromIterator};\n+use core::iter::{repeat_n, repeat_with, FromIterator};\n use core::marker::PhantomData;\n use core::mem::{ManuallyDrop, MaybeUninit, SizedTypeProperties};\n use core::ops::{Index, IndexMut, Range, RangeBounds};\n@@ -2833,7 +2833,12 @@ impl<T: Clone, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"deque_extras\", since = \"1.16.0\")]\n     pub fn resize(&mut self, new_len: usize, value: T) {\n-        self.resize_with(new_len, || value.clone());\n+        if new_len > self.len() {\n+            let extra = new_len - self.len();\n+            self.extend(repeat_n(value, extra))\n+        } else {\n+            self.truncate(new_len);\n+        }\n     }\n }\n "}, {"sha": "5e13547abcb70f2dc616e94e0afe3decf06b22ea", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/785237d3924d4fb7b23803c964972dce82de2161/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785237d3924d4fb7b23803c964972dce82de2161/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=785237d3924d4fb7b23803c964972dce82de2161", "patch": "@@ -124,6 +124,7 @@\n #![feature(inplace_iteration)]\n #![feature(iter_advance_by)]\n #![feature(iter_next_chunk)]\n+#![feature(iter_repeat_n)]\n #![feature(layout_for_ptr)]\n #![feature(maybe_uninit_slice)]\n #![feature(maybe_uninit_uninit_array)]"}, {"sha": "c1b9e7af9d857f43bf77cd141ee404ebc46dc902", "filename": "library/alloc/tests/vec_deque.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/785237d3924d4fb7b23803c964972dce82de2161/library%2Falloc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785237d3924d4fb7b23803c964972dce82de2161/library%2Falloc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec_deque.rs?ref=785237d3924d4fb7b23803c964972dce82de2161", "patch": "@@ -1727,3 +1727,11 @@ fn test_from_zero_sized_vec() {\n     let queue = VecDeque::from(v);\n     assert_eq!(queue.len(), 100);\n }\n+\n+#[test]\n+fn test_resize_keeps_reserved_space_from_item() {\n+    let v = Vec::<i32>::with_capacity(1234);\n+    let mut d = VecDeque::new();\n+    d.resize(1, v);\n+    assert_eq!(d[0].capacity(), 1234);\n+}"}, {"sha": "bb35d50b4bfda2a7c39313d8faa753f8758e713d", "filename": "library/core/src/iter/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/785237d3924d4fb7b23803c964972dce82de2161/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785237d3924d4fb7b23803c964972dce82de2161/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs?ref=785237d3924d4fb7b23803c964972dce82de2161", "patch": "@@ -401,6 +401,8 @@ pub use self::sources::{once, Once};\n pub use self::sources::{once_with, OnceWith};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::sources::{repeat, Repeat};\n+#[unstable(feature = \"iter_repeat_n\", issue = \"104434\")]\n+pub use self::sources::{repeat_n, RepeatN};\n #[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n pub use self::sources::{repeat_with, RepeatWith};\n #[stable(feature = \"iter_successors\", since = \"1.34.0\")]"}, {"sha": "3ec426a3ad9a155cba3489d1ea4a533f124b8be9", "filename": "library/core/src/iter/sources.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/785237d3924d4fb7b23803c964972dce82de2161/library%2Fcore%2Fsrc%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785237d3924d4fb7b23803c964972dce82de2161/library%2Fcore%2Fsrc%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources.rs?ref=785237d3924d4fb7b23803c964972dce82de2161", "patch": "@@ -4,6 +4,7 @@ mod from_generator;\n mod once;\n mod once_with;\n mod repeat;\n+mod repeat_n;\n mod repeat_with;\n mod successors;\n \n@@ -16,6 +17,9 @@ pub use self::empty::{empty, Empty};\n #[stable(feature = \"iter_once\", since = \"1.2.0\")]\n pub use self::once::{once, Once};\n \n+#[unstable(feature = \"iter_repeat_n\", issue = \"104434\")]\n+pub use self::repeat_n::{repeat_n, RepeatN};\n+\n #[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n pub use self::repeat_with::{repeat_with, RepeatWith};\n "}, {"sha": "dc69bf4df595e9f68d216b07017f124fd369390a", "filename": "library/core/src/iter/sources/repeat_n.rs", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/785237d3924d4fb7b23803c964972dce82de2161/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat_n.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785237d3924d4fb7b23803c964972dce82de2161/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat_n.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat_n.rs?ref=785237d3924d4fb7b23803c964972dce82de2161", "patch": "@@ -0,0 +1,195 @@\n+use crate::iter::{FusedIterator, TrustedLen};\n+use crate::mem::ManuallyDrop;\n+\n+/// Creates a new iterator that repeats a single element a given number of times.\n+///\n+/// The `repeat_n()` function repeats a single value exactly `n` times.\n+///\n+/// This is very similar to using [`repeat()`] with [`Iterator::take()`],\n+/// but there are two differences:\n+/// - `repeat_n()` can return the original value, rather than always cloning.\n+/// - `repeat_n()` produces an [`ExactSizeIterator`].\n+///\n+/// [`repeat()`]: crate::iter::repeat\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// #![feature(iter_repeat_n)]\n+/// use std::iter;\n+///\n+/// // four of the the number four:\n+/// let mut four_fours = iter::repeat_n(4, 4);\n+///\n+/// assert_eq!(Some(4), four_fours.next());\n+/// assert_eq!(Some(4), four_fours.next());\n+/// assert_eq!(Some(4), four_fours.next());\n+/// assert_eq!(Some(4), four_fours.next());\n+///\n+/// // no more fours\n+/// assert_eq!(None, four_fours.next());\n+/// ```\n+///\n+/// For non-`Copy` types,\n+///\n+/// ```\n+/// #![feature(iter_repeat_n)]\n+/// use std::iter;\n+///\n+/// let v: Vec<i32> = Vec::with_capacity(123);\n+/// let mut it = iter::repeat_n(v, 5);\n+///\n+/// for i in 0..4 {\n+///     // It starts by cloning things\n+///     let cloned = it.next().unwrap();\n+///     assert_eq!(cloned.len(), 0);\n+///     assert_eq!(cloned.capacity(), 0);\n+/// }\n+///\n+/// // ... but the last item is the original one\n+/// let last = it.next().unwrap();\n+/// assert_eq!(last.len(), 0);\n+/// assert_eq!(last.capacity(), 123);\n+///\n+/// // ... and now we're done\n+/// assert_eq!(None, it.next());\n+/// ```\n+#[inline]\n+#[unstable(feature = \"iter_repeat_n\", issue = \"104434\")]\n+#[doc(hidden)] // waiting on ACP#120 to decide whether to expose publicly\n+pub fn repeat_n<T: Clone>(element: T, count: usize) -> RepeatN<T> {\n+    let mut element = ManuallyDrop::new(element);\n+\n+    if count == 0 {\n+        // SAFETY: we definitely haven't dropped it yet, since we only just got\n+        // passed it in, and because the count is zero the instance we're about\n+        // to create won't drop it, so to avoid leaking we need to now.\n+        unsafe { ManuallyDrop::drop(&mut element) };\n+    }\n+\n+    RepeatN { element, count }\n+}\n+\n+/// An iterator that repeats an element an exact number of times.\n+///\n+/// This `struct` is created by the [`repeat_n()`] function.\n+/// See its documentation for more.\n+#[derive(Clone, Debug)]\n+#[unstable(feature = \"iter_repeat_n\", issue = \"104434\")]\n+#[doc(hidden)] // waiting on ACP#120 to decide whether to expose publicly\n+pub struct RepeatN<A> {\n+    count: usize,\n+    // Invariant: has been dropped iff count == 0.\n+    element: ManuallyDrop<A>,\n+}\n+\n+impl<A> RepeatN<A> {\n+    /// If we haven't already dropped the element, return it in an option.\n+    ///\n+    /// Clears the count so it won't be dropped again later.\n+    #[inline]\n+    fn take_element(&mut self) -> Option<A> {\n+        if self.count > 0 {\n+            self.count = 0;\n+            // SAFETY: We just set count to zero so it won't be dropped again,\n+            // and it used to be non-zero so it hasn't already been dropped.\n+            unsafe { Some(ManuallyDrop::take(&mut self.element)) }\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"iter_repeat_n\", issue = \"104434\")]\n+impl<A> Drop for RepeatN<A> {\n+    fn drop(&mut self) {\n+        self.take_element();\n+    }\n+}\n+\n+#[unstable(feature = \"iter_repeat_n\", issue = \"104434\")]\n+impl<A: Clone> Iterator for RepeatN<A> {\n+    type Item = A;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        if self.count == 0 {\n+            return None;\n+        }\n+\n+        self.count -= 1;\n+        Some(if self.count == 0 {\n+            // SAFETY: the check above ensured that the count used to be non-zero,\n+            // so element hasn't been dropped yet, and we just lowered the count to\n+            // zero so it won't be dropped later, and thus it's okay to take it here.\n+            unsafe { ManuallyDrop::take(&mut self.element) }\n+        } else {\n+            A::clone(&mut self.element)\n+        })\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let len = self.len();\n+        (len, Some(len))\n+    }\n+\n+    #[inline]\n+    fn advance_by(&mut self, skip: usize) -> Result<(), usize> {\n+        let len = self.count;\n+\n+        if skip >= len {\n+            self.take_element();\n+        }\n+\n+        if skip > len {\n+            Err(len)\n+        } else {\n+            self.count = len - skip;\n+            Ok(())\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<A> {\n+        self.take_element()\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.len()\n+    }\n+}\n+\n+#[unstable(feature = \"iter_repeat_n\", issue = \"104434\")]\n+impl<A: Clone> ExactSizeIterator for RepeatN<A> {\n+    fn len(&self) -> usize {\n+        self.count\n+    }\n+}\n+\n+#[unstable(feature = \"iter_repeat_n\", issue = \"104434\")]\n+impl<A: Clone> DoubleEndedIterator for RepeatN<A> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> {\n+        self.next()\n+    }\n+\n+    #[inline]\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        self.advance_by(n)\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<A> {\n+        self.nth(n)\n+    }\n+}\n+\n+#[unstable(feature = \"iter_repeat_n\", issue = \"104434\")]\n+impl<A: Clone> FusedIterator for RepeatN<A> {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<A: Clone> TrustedLen for RepeatN<A> {}"}, {"sha": "a15f3a5148f0a6cebd77d04fe8b55ce676ba7f50", "filename": "library/core/tests/iter/sources.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/785237d3924d4fb7b23803c964972dce82de2161/library%2Fcore%2Ftests%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785237d3924d4fb7b23803c964972dce82de2161/library%2Fcore%2Ftests%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fsources.rs?ref=785237d3924d4fb7b23803c964972dce82de2161", "patch": "@@ -106,3 +106,52 @@ fn test_empty() {\n     let mut it = empty::<i32>();\n     assert_eq!(it.next(), None);\n }\n+\n+#[test]\n+fn test_repeat_n_drop() {\n+    #[derive(Clone, Debug)]\n+    struct DropCounter<'a>(&'a Cell<usize>);\n+    impl Drop for DropCounter<'_> {\n+        fn drop(&mut self) {\n+            self.0.set(self.0.get() + 1);\n+        }\n+    }\n+\n+    // `repeat_n(x, 0)` drops `x` immediately\n+    let count = Cell::new(0);\n+    let item = DropCounter(&count);\n+    let mut it = repeat_n(item, 0);\n+    assert_eq!(count.get(), 1);\n+    assert!(it.next().is_none());\n+    assert_eq!(count.get(), 1);\n+    drop(it);\n+    assert_eq!(count.get(), 1);\n+\n+    // Dropping the iterator needs to drop the item if it's non-empty\n+    let count = Cell::new(0);\n+    let item = DropCounter(&count);\n+    let it = repeat_n(item, 3);\n+    assert_eq!(count.get(), 0);\n+    drop(it);\n+    assert_eq!(count.get(), 1);\n+\n+    // Dropping the iterator doesn't drop the item if it was exhausted\n+    let count = Cell::new(0);\n+    let item = DropCounter(&count);\n+    let mut it = repeat_n(item, 3);\n+    assert_eq!(count.get(), 0);\n+    let x0 = it.next().unwrap();\n+    assert_eq!(count.get(), 0);\n+    let x1 = it.next().unwrap();\n+    assert_eq!(count.get(), 0);\n+    let x2 = it.next().unwrap();\n+    assert_eq!(count.get(), 0);\n+    assert!(it.next().is_none());\n+    assert_eq!(count.get(), 0);\n+    assert!(it.next().is_none());\n+    assert_eq!(count.get(), 0);\n+    drop(it);\n+    assert_eq!(count.get(), 0);\n+    drop((x0, x1, x2));\n+    assert_eq!(count.get(), 3);\n+}"}, {"sha": "4c0c0da652f95444c9b42eba60f29cb0dd9a7090", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/785237d3924d4fb7b23803c964972dce82de2161/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785237d3924d4fb7b23803c964972dce82de2161/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=785237d3924d4fb7b23803c964972dce82de2161", "patch": "@@ -75,6 +75,7 @@\n #![feature(iter_is_partitioned)]\n #![feature(iter_next_chunk)]\n #![feature(iter_order_by)]\n+#![feature(iter_repeat_n)]\n #![feature(iterator_try_collect)]\n #![feature(iterator_try_reduce)]\n #![feature(const_mut_refs)]"}, {"sha": "20e1d9b4d5988daf60977e13b4aabdc23a952e66", "filename": "src/test/codegen/iter-repeat-n-trivial-drop.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/785237d3924d4fb7b23803c964972dce82de2161/src%2Ftest%2Fcodegen%2Fiter-repeat-n-trivial-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785237d3924d4fb7b23803c964972dce82de2161/src%2Ftest%2Fcodegen%2Fiter-repeat-n-trivial-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fiter-repeat-n-trivial-drop.rs?ref=785237d3924d4fb7b23803c964972dce82de2161", "patch": "@@ -0,0 +1,56 @@\n+// compile-flags: -O\n+// only-x86_64\n+// ignore-debug: the debug assertions get in the way\n+\n+#![crate_type = \"lib\"]\n+#![feature(iter_repeat_n)]\n+\n+#[derive(Clone)]\n+pub struct NotCopy(u16);\n+\n+impl Drop for NotCopy {\n+    fn drop(&mut self) {}\n+}\n+\n+// For a type where `Drop::drop` doesn't do anything observable and a clone is the\n+// same as a move, make sure that the extra case for the last item disappears.\n+\n+#[no_mangle]\n+// CHECK-LABEL: @iter_repeat_n_next\n+pub fn iter_repeat_n_next(it: &mut std::iter::RepeatN<NotCopy>) -> Option<NotCopy> {\n+    // CHECK-NEXT: start:\n+    // CHECK-NOT: br\n+    // CHECK: %[[COUNT:.+]] = load i64\n+    // CHECK-NEXT: %[[COUNT_ZERO:.+]] = icmp eq i64 %[[COUNT]], 0\n+    // CHECK-NEXT: br i1 %[[COUNT_ZERO]], label %[[EMPTY:.+]], label %[[NOT_EMPTY:.+]]\n+\n+    // CHECK: [[NOT_EMPTY]]:\n+    // CHECK-NEXT: %[[DEC:.+]] = add i64 %[[COUNT]], -1\n+    // CHECK-NEXT: store i64 %[[DEC]]\n+    // CHECK-NOT: br\n+    // CHECK: %[[VAL:.+]] = load i16\n+    // CHECK-NEXT: br label %[[EMPTY]]\n+\n+    // CHECK: [[EMPTY]]:\n+    // CHECK-NOT: br\n+    // CHECK: phi i16 [ undef, %start ], [ %[[VAL]], %[[NOT_EMPTY]] ]\n+    // CHECK-NOT: br\n+    // CHECK: ret\n+\n+    it.next()\n+}\n+\n+// And as a result, using the iterator can optimize without special cases for\n+// the last iteration, like `memset`ing all the items in one call.\n+\n+#[no_mangle]\n+// CHECK-LABEL: @vec_extend_via_iter_repeat_n\n+pub fn vec_extend_via_iter_repeat_n() -> Vec<u8> {\n+    // CHECK: %[[ADDR:.+]] = tail call dereferenceable_or_null(1234) ptr @__rust_alloc(i64 1234, i64 1)\n+    // CHECK: tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(1234) %[[ADDR]], i8 42, i64 1234,\n+\n+    let n = 1234_usize;\n+    let mut v = Vec::with_capacity(n);\n+    v.extend(std::iter::repeat_n(42_u8, n));\n+    v\n+}"}]}