{"sha": "a56ff9d02f67a2736a6735014564fe5e496ad148", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1NmZmOWQwMmY2N2EyNzM2YTY3MzUwMTQ1NjRmZTVlNDk2YWQxNDg=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-11T00:01:39Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-24T03:43:29Z"}, "message": "chains: factor into objects", "tree": {"sha": "a1efe07e478a5f73997a20676c44a801e647a1ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1efe07e478a5f73997a20676c44a801e647a1ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a56ff9d02f67a2736a6735014564fe5e496ad148", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a56ff9d02f67a2736a6735014564fe5e496ad148", "html_url": "https://github.com/rust-lang/rust/commit/a56ff9d02f67a2736a6735014564fe5e496ad148", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a56ff9d02f67a2736a6735014564fe5e496ad148/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86314bf09f22341703dfc539d4e0c55478face0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/86314bf09f22341703dfc539d4e0c55478face0b", "html_url": "https://github.com/rust-lang/rust/commit/86314bf09f22341703dfc539d4e0c55478face0b"}], "stats": {"total": 632, "additions": 331, "deletions": 301}, "files": [{"sha": "692d1c946fc58a4a092d2d3aadf7e120b7e7f11b", "filename": "src/chains.rs", "status": "modified", "additions": 331, "deletions": 301, "changes": 632, "blob_url": "https://github.com/rust-lang/rust/blob/a56ff9d02f67a2736a6735014564fe5e496ad148/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a56ff9d02f67a2736a6735014564fe5e496ad148/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=a56ff9d02f67a2736a6735014564fe5e496ad148", "patch": "@@ -111,7 +111,7 @@ struct Chain {\n \n impl Chain {\n     fn from_ast(expr: &ast::Expr, context: &RewriteContext) -> Chain {\n-        let mut subexpr_list = make_subexpr_list(expr, context);\n+        let mut subexpr_list = Self::make_subexpr_list(expr, context);\n \n         // Un-parse the expression tree into ChainItems\n         let mut children = vec![];\n@@ -139,10 +139,67 @@ impl Chain {\n             children,\n         }\n     }\n+\n+    // Returns a Vec of the prefixes of the chain.\n+    // E.g., for input `a.b.c` we return [`a.b.c`, `a.b`, 'a']\n+    fn make_subexpr_list(expr: &ast::Expr, context: &RewriteContext) -> Vec<ast::Expr> {\n+        let mut subexpr_list = vec![expr.clone()];\n+\n+        while let Some(subexpr) = Self::pop_expr_chain(subexpr_list.last().unwrap(), context) {\n+            subexpr_list.push(subexpr.clone());\n+        }\n+\n+        subexpr_list\n+    }\n+\n+    // Returns the expression's subexpression, if it exists. When the subexpr\n+    // is a try! macro, we'll convert it to shorthand when the option is set.\n+    fn pop_expr_chain(expr: &ast::Expr, context: &RewriteContext) -> Option<ast::Expr> {\n+        match expr.node {\n+            ast::ExprKind::MethodCall(_, ref expressions) => {\n+                Some(Self::convert_try(&expressions[0], context))\n+            }\n+            ast::ExprKind::Field(ref subexpr, _) | ast::ExprKind::Try(ref subexpr) => {\n+                Some(Self::convert_try(subexpr, context))\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    fn convert_try(expr: &ast::Expr, context: &RewriteContext) -> ast::Expr {\n+        match expr.node {\n+            ast::ExprKind::Mac(ref mac) if context.config.use_try_shorthand() => {\n+                if let Some(subexpr) = convert_try_mac(mac, context) {\n+                    subexpr\n+                } else {\n+                    expr.clone()\n+                }\n+            }\n+            _ => expr.clone(),\n+        }\n+    }\n }\n \n-fn rewrite_chain_block(chain: Chain, context: &RewriteContext, shape: Shape) -> Option<String> {\n-    debug!(\"rewrite_chain_block {:?} {:?}\", chain, shape);\n+// TODO comments\n+struct ChainFormatterBlock<'a> {\n+    children: &'a[ChainItem],\n+    rewrites: Vec<String>,\n+    root_ends_with_block: bool,\n+    is_block_like: Vec<bool>,\n+    fits_single_line: bool,\n+}\n+\n+impl <'a> ChainFormatterBlock<'a> {\n+    fn new(chain: &'a Chain) -> ChainFormatterBlock<'a> {\n+        ChainFormatterBlock {\n+            children: &chain.children,\n+            root_ends_with_block: false,\n+            rewrites: Vec::with_capacity(chain.children.len() + 1),\n+            is_block_like: Vec::with_capacity(chain.children.len() + 1),\n+            fits_single_line: false,\n+        }\n+    }\n+\n     // Parent is the first item in the chain, e.g., `foo` in `foo.bar.baz()`.\n     // Root is the parent plus any other chain items placed on the first line to\n     // avoid an orphan. E.g.,\n@@ -151,73 +208,53 @@ fn rewrite_chain_block(chain: Chain, context: &RewriteContext, shape: Shape) ->\n     //     .baz()\n     // ```\n     // If `bar` were not part of the root, then baz would be orphaned and 'float'.\n-    let mut root_rewrite = chain.parent.expr\n-        .rewrite(context, shape)\n-        .map(|parent_rw| parent_rw + &\"?\".repeat(chain.parent.tries))?;\n-\n-    let mut children: &[_] = &chain.children;\n-    let mut root_ends_with_block = is_block_expr(context, &chain.parent.expr, &root_rewrite);\n-    let tab_width = context.config.tab_spaces().saturating_sub(shape.offset);\n-\n-    while root_rewrite.len() <= tab_width && !root_rewrite.contains('\\n') {\n-        let item = &children[0];\n-        let shape = shape.offset_left(root_rewrite.len())?;\n-        match rewrite_chain_subexpr(&item.expr, context, shape) {\n-            Some(rewrite) => {\n-                root_rewrite.push_str(&rewrite);\n-                root_rewrite.push_str(&\"?\".repeat(item.tries));\n+    fn format_root(&mut self, parent: &ChainItem, context: &RewriteContext, shape: Shape) -> Option<()> {\n+        let mut root_rewrite: String = parent.expr\n+            .rewrite(context, shape)\n+            .map(|parent_rw| parent_rw + &\"?\".repeat(parent.tries))?;\n+\n+        self.root_ends_with_block = is_block_expr(context, &parent.expr, &root_rewrite);\n+        let tab_width = context.config.tab_spaces().saturating_sub(shape.offset);\n+\n+        while root_rewrite.len() <= tab_width && !root_rewrite.contains('\\n') {\n+            let item = &self.children[0];\n+            let shape = shape.offset_left(root_rewrite.len())?;\n+            match rewrite_chain_subexpr(&item.expr, context, shape) {\n+                Some(rewrite) => {\n+                    root_rewrite.push_str(&rewrite);\n+                    root_rewrite.push_str(&\"?\".repeat(item.tries));\n+                }\n+                None => break,\n             }\n-            None => break,\n-        }\n \n-        root_ends_with_block = is_block_expr(context, &item.expr, &root_rewrite);\n+            self.root_ends_with_block = is_block_expr(context, &item.expr, &root_rewrite);\n \n-        children = &children[1..];\n-        if children.is_empty() {\n-            return Some(root_rewrite);\n+            self.children = &self.children[1..];\n+            if self.children.is_empty() {\n+                break;\n+            }\n         }\n+        self.rewrites.push(root_rewrite);\n+        Some(())\n     }\n \n-    // Separate out the last item in the chain for special treatment below.\n-    let last = &children[children.len() - 1];\n-    children = &children[..children.len() - 1];\n-\n-    // Decide how to layout the rest of the chain.\n-    let child_shape = if root_ends_with_block {\n-        shape\n-    } else {\n-        shape.block_indent(context.config.tab_spaces())\n-    }.with_max_width(context.config);\n-\n-    let mut rewrites: Vec<String> = Vec::with_capacity(children.len() + 2);\n-    rewrites.push(root_rewrite);\n-    let mut is_block_like = Vec::with_capacity(children.len() + 2);\n-    is_block_like.push(root_ends_with_block);\n-    for item in children {\n-        let rewrite = rewrite_chain_subexpr(&item.expr, context, child_shape)?;\n-        is_block_like.push(is_block_expr(context, &item.expr, &rewrite));\n-        rewrites.push(format!(\"{}{}\", rewrite, \"?\".repeat(item.tries)));\n+    fn child_shape(&self, context: &RewriteContext, shape: Shape) -> Shape {\n+        if self.root_ends_with_block {\n+            shape\n+        } else {\n+            shape.block_indent(context.config.tab_spaces())\n+        }.with_max_width(context.config)\n     }\n \n-    // Total of all items excluding the last.\n-    let extend_last_subexpr = last_line_extendable(&rewrites[rewrites.len() - 1]);\n-    let almost_total = if extend_last_subexpr {\n-        last_line_width(&rewrites[rewrites.len() - 1])\n-    } else {\n-        rewrites.iter().fold(0, |a, b| a + b.len())\n-    } + last.tries;\n-    let one_line_budget = if rewrites.len() == 1 {\n-        shape.width\n-    } else {\n-        min(shape.width, context.config.width_heuristics().chain_width)\n-    };\n-    let all_in_one_line = rewrites.iter().all(|s| !s.contains('\\n'))\n-        && almost_total < one_line_budget;\n-    let last_shape = if all_in_one_line {\n-        shape.sub_width(last.tries)?\n-    } else {\n-        child_shape.sub_width(shape.rhs_overhead(context.config) + last.tries)?\n-    };\n+    fn format_children(&mut self, context: &RewriteContext, child_shape: Shape) -> Option<()> {\n+        self.is_block_like.push(self.root_ends_with_block);\n+        for item in &self.children[..self.children.len()] {\n+            let rewrite = rewrite_chain_subexpr(&item.expr, context, child_shape)?;\n+            self.is_block_like.push(is_block_expr(context, &item.expr, &rewrite));\n+            self.rewrites.push(format!(\"{}{}\", rewrite, \"?\".repeat(item.tries)));\n+        }\n+        Some(())\n+    }\n \n     // Rewrite the last child. The last child of a chain requires special treatment. We need to\n     // know whether 'overflowing' the last child make a better formatting:\n@@ -251,237 +288,277 @@ fn rewrite_chain_block(chain: Chain, context: &RewriteContext, shape: Shape) ->\n     //     result\n     // })\n     // ```\n+    fn format_last_child(&mut self, context: &RewriteContext, shape: Shape, child_shape: Shape) -> Option<()> {\n+        let last = &self.children[self.children.len() - 1];\n+        let extendable = last_line_extendable(&self.rewrites[self.rewrites.len() - 1]);\n+        // Total of all items excluding the last.\n+        let almost_total = if extendable {\n+            last_line_width(&self.rewrites[self.rewrites.len() - 1])\n+        } else {\n+            self.rewrites.iter().fold(0, |a, b| a + b.len())\n+        } + last.tries;\n+        let one_line_budget = if self.rewrites.len() == 1 {\n+            shape.width\n+        } else {\n+            min(shape.width, context.config.width_heuristics().chain_width)\n+        }.saturating_sub(almost_total);\n \n-    let mut last_subexpr_str = None;\n-    let mut fits_single_line = false;\n-    if all_in_one_line || extend_last_subexpr {\n-        // First we try to 'overflow' the last child and see if it looks better than using\n-        // vertical layout.\n-        if let Some(shape) = last_shape.offset_left(almost_total) {\n-            if let Some(rw) = rewrite_chain_subexpr(&last.expr, context, shape) {\n-                // We allow overflowing here only if both of the following conditions match:\n-                // 1. The entire chain fits in a single line except the last child.\n-                // 2. `last_child_str.lines().count() >= 5`.\n-                let line_count = rw.lines().count();\n-                let could_fit_single_line = almost_total + first_line_width(&rw) <= one_line_budget;\n-                if fits_single_line && line_count >= 5 {\n-                    last_subexpr_str = Some(rw);\n-                    fits_single_line = true;\n-                } else {\n-                    // We could not know whether overflowing is better than using vertical layout,\n-                    // just by looking at the overflowed rewrite. Now we rewrite the last child\n-                    // on its own line, and compare two rewrites to choose which is better.\n-                    match rewrite_chain_subexpr(&last.expr, context, last_shape) {\n-                        Some(ref new_rw) if !could_fit_single_line => {\n-                            last_subexpr_str = Some(new_rw.clone());\n-                        }\n-                        Some(ref new_rw) if new_rw.lines().count() >= line_count => {\n-                            last_subexpr_str = Some(rw);\n-                            fits_single_line = could_fit_single_line;\n-                        }\n-                        new_rw @ Some(..) => {\n-                            last_subexpr_str = new_rw;\n-                        }\n-                        _ => {\n-                            last_subexpr_str = Some(rw);\n-                            fits_single_line = could_fit_single_line;\n+        let all_in_one_line = self.rewrites.iter().all(|s| !s.contains('\\n')) && one_line_budget > 0;\n+        let last_shape = if all_in_one_line {\n+            shape.sub_width(last.tries)?\n+        } else {\n+            child_shape.sub_width(shape.rhs_overhead(context.config) + last.tries)?\n+        };\n+\n+        let mut last_subexpr_str = None;\n+        if all_in_one_line || extendable {\n+            // First we try to 'overflow' the last child and see if it looks better than using\n+            // vertical layout.\n+            if let Some(shape) = last_shape.offset_left(almost_total) {\n+                if let Some(rw) = rewrite_chain_subexpr(&last.expr, context, shape) {\n+                    // We allow overflowing here only if both of the following conditions match:\n+                    // 1. The entire chain fits in a single line except the last child.\n+                    // 2. `last_child_str.lines().count() >= 5`.\n+                    let line_count = rw.lines().count();\n+                    let could_fit_single_line = first_line_width(&rw) <= one_line_budget;\n+                    if could_fit_single_line && line_count >= 5 {\n+                        last_subexpr_str = Some(rw);\n+                        self.fits_single_line = all_in_one_line;\n+                    } else {\n+                        // We could not know whether overflowing is better than using vertical layout,\n+                        // just by looking at the overflowed rewrite. Now we rewrite the last child\n+                        // on its own line, and compare two rewrites to choose which is better.\n+                        match rewrite_chain_subexpr(&last.expr, context, last_shape) {\n+                            Some(ref new_rw) if !could_fit_single_line => {\n+                                last_subexpr_str = Some(new_rw.clone());\n+                            }\n+                            Some(ref new_rw) if new_rw.lines().count() >= line_count => {\n+                                last_subexpr_str = Some(rw);\n+                                self.fits_single_line = could_fit_single_line && all_in_one_line;\n+                            }\n+                            new_rw @ Some(..) => {\n+                                last_subexpr_str = new_rw;\n+                            }\n+                            _ => {\n+                                last_subexpr_str = Some(rw);\n+                                self.fits_single_line = could_fit_single_line && all_in_one_line;\n+                            }\n                         }\n                     }\n                 }\n             }\n         }\n+\n+        last_subexpr_str = last_subexpr_str.or_else(|| rewrite_chain_subexpr(&last.expr, context, last_shape));\n+        self.rewrites.push(format!(\"{}{}\", last_subexpr_str?, \"?\".repeat(last.tries)));\n+        Some(())\n     }\n \n-    last_subexpr_str = last_subexpr_str.or_else(|| rewrite_chain_subexpr(&last.expr, context, last_shape));\n-    rewrites.push(format!(\"{}{}\", last_subexpr_str?, \"?\".repeat(last.tries)));\n \n-    // We should never look at this, since we only look at the block-ness of the\n-    // previous item in the chain.\n-    is_block_like.push(false);\n+    fn join_rewrites(&self, context: &RewriteContext, child_shape: Shape) -> Option<String> {\n+        let connector = if self.fits_single_line {\n+            // Yay, we can put everything on one line.\n+            Cow::from(\"\")\n+        } else {\n+            // Use new lines.\n+            if *context.force_one_line_chain.borrow() {\n+                return None;\n+            }\n+            child_shape.indent.to_string_with_newline(context.config)\n+        };\n \n-    let connector = if fits_single_line && all_in_one_line {\n-        // Yay, we can put everything on one line.\n-        Cow::from(\"\")\n-    } else {\n-        // Use new lines.\n-        if *context.force_one_line_chain.borrow() {\n-            return None;\n+        let mut rewrite_iter = self.rewrites.iter();\n+        let mut result = rewrite_iter.next().unwrap().clone();\n+\n+        for (rewrite, prev_is_block_like) in rewrite_iter.zip(self.is_block_like.iter()) {\n+            if rewrite != \"?\" && !prev_is_block_like {\n+                result.push_str(&connector);\n+            }\n+            result.push_str(&rewrite);\n         }\n-        child_shape.indent.to_string_with_newline(context.config)\n-    };\n \n-    let result = join_rewrites(&rewrites, &is_block_like, &connector);\n+        Some(result)\n+    }\n+}\n+\n+fn rewrite_chain_block(chain: Chain, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    debug!(\"rewrite_chain_block {:?} {:?}\", chain, shape);\n+\n+    let mut formatter = ChainFormatterBlock::new(&chain);\n+\n+    formatter.format_root(&chain.parent, context, shape)?;\n+    if formatter.children.is_empty() {\n+        assert_eq!(formatter.rewrites.len(), 1);\n+        return Some(formatter.rewrites.pop().unwrap());\n+    }\n+\n+    // Decide how to layout the rest of the chain.\n+    let child_shape = formatter.child_shape(context, shape);\n+    formatter.format_children(context, child_shape)?;\n+\n+    formatter.format_last_child(context, shape, child_shape)?;\n+\n+    let result = formatter.join_rewrites(context, child_shape)?;\n     Some(result)\n }\n \n-fn rewrite_chain_visual(chain: Chain, context: &RewriteContext, shape: Shape) -> Option<String> {\n-    // Parent is the first item in the chain, e.g., `foo` in `foo.bar.baz()`.\n-    let parent_shape = if is_block_expr(context, &chain.parent.expr, \"\\n\") {\n-        shape.visual_indent(0)\n-    } else {\n-        shape\n-    };\n-    let mut children: &[_] = &chain.children;\n-    let mut root_rewrite = chain.parent.expr\n-        .rewrite(context, parent_shape)\n-        .map(|parent_rw| parent_rw + &\"?\".repeat(chain.parent.tries))?;\n-\n-    if !root_rewrite.contains('\\n') && is_continuable(&chain.parent.expr) {\n-        let item = &children[0];\n-        let overhead = last_line_width(&root_rewrite);\n-        let shape = parent_shape.offset_left(overhead)?;\n-        let rewrite = rewrite_chain_subexpr(&item.expr, context, shape)?;\n-        root_rewrite.push_str(&rewrite);\n-        root_rewrite.push_str(&\"?\".repeat(item.tries));\n-        children = &children[1..];\n-        if children.is_empty() {\n-            return Some(root_rewrite);\n+struct ChainFormatterVisual<'a> {\n+    children: &'a[ChainItem],\n+    rewrites: Vec<String>,\n+    fits_single_line: bool,\n+}\n+\n+impl<'a> ChainFormatterVisual<'a> {\n+    fn new(chain: &'a Chain) -> ChainFormatterVisual<'a> {\n+        ChainFormatterVisual {\n+            children: &chain.children,\n+            rewrites: Vec::with_capacity(chain.children.len() + 1),\n+            fits_single_line: false,\n         }\n     }\n \n-    let last = &children[children.len() - 1];\n-    children = &children[..children.len() - 1];\n+    fn format_root(&mut self, parent: &ChainItem, context: &RewriteContext, shape: Shape) -> Option<()> {\n+        // Parent is the first item in the chain, e.g., `foo` in `foo.bar.baz()`.\n+        let parent_shape = if is_block_expr(context, &parent.expr, \"\\n\") {\n+            shape.visual_indent(0)\n+        } else {\n+            shape\n+        };\n+        let mut root_rewrite = parent.expr\n+            .rewrite(context, parent_shape)\n+            .map(|parent_rw| parent_rw + &\"?\".repeat(parent.tries))?;\n+\n+        if !root_rewrite.contains('\\n') && Self::is_continuable(&parent.expr) {\n+            let item = &self.children[0];\n+            let overhead = last_line_width(&root_rewrite);\n+            let shape = parent_shape.offset_left(overhead)?;\n+            let rewrite = rewrite_chain_subexpr(&item.expr, context, shape)?;\n+            root_rewrite.push_str(&rewrite);\n+            root_rewrite.push_str(&\"?\".repeat(item.tries));\n+\n+            self.children = &self.children[1..];\n+        }\n \n-    let child_shape = shape.visual_indent(0).with_max_width(context.config);\n+        self.rewrites.push(root_rewrite);\n+        Some(())\n+    }\n \n-    let mut rewrites: Vec<String> = Vec::with_capacity(children.len() + 2);\n-    rewrites.push(root_rewrite);\n-    for item in chain.children.iter() {\n-        let rewrite = rewrite_chain_subexpr(&item.expr, context, child_shape)?;\n-        rewrites.push(format!(\"{}{}\", rewrite, \"?\".repeat(item.tries)));\n+    // Determines if we can continue formatting a given expression on the same line.\n+    fn is_continuable(expr: &ast::Expr) -> bool {\n+        match expr.node {\n+            ast::ExprKind::Path(..) => true,\n+            _ => false,\n+        }\n     }\n \n-    // Total of all items excluding the last.\n-    let almost_total = rewrites.iter().fold(0, |a, b| a + b.len()) + last.tries;\n-    let one_line_budget = if rewrites.len() == 1 {\n-        shape.width\n-    } else {\n-        min(shape.width, context.config.width_heuristics().chain_width)\n-    };\n-    let all_in_one_line = rewrites.iter().all(|s| !s.contains('\\n'))\n-        && almost_total < one_line_budget;\n-    let last_shape = child_shape.sub_width(shape.rhs_overhead(context.config) + last.tries)?;\n+    fn format_children(&mut self, context: &RewriteContext, child_shape: Shape) -> Option<()> {\n+        for item in &self.children[..self.children.len() - 1] {\n+            let rewrite = rewrite_chain_subexpr(&item.expr, context, child_shape)?;\n+            self.rewrites.push(format!(\"{}{}\", rewrite, \"?\".repeat(item.tries)));\n+        }\n+        Some(())\n+    }\n \n-    // Rewrite the last child. The last child of a chain requires special treatment. We need to\n-    // know whether 'overflowing' the last child make a better formatting:\n-    //\n-    // A chain with overflowing the last child:\n-    // ```\n-    // parent.child1.child2.last_child(\n-    //     a,\n-    //     b,\n-    //     c,\n-    // )\n-    // ```\n-    //\n-    // A chain without overflowing the last child (in vertical layout):\n-    // ```\n-    // parent\n-    //     .child1\n-    //     .child2\n-    //     .last_child(a, b, c)\n-    // ```\n-    //\n-    // In particular, overflowing is effective when the last child is a method with a multi-lined\n-    // block-like argument (e.g. closure):\n-    // ```\n-    // parent.child1.child2.last_child(|a, b, c| {\n-    //     let x = foo(a, b, c);\n-    //     let y = bar(a, b, c);\n-    //\n-    //     // ...\n-    //\n-    //     result\n-    // })\n-    // ```\n+    fn format_last_child(&mut self, context: &RewriteContext, shape: Shape, child_shape: Shape) -> Option<()> {\n+        let last = &self.children[self.children.len() - 1];\n \n-    let mut last_subexpr_str = None;\n-    let mut fits_single_line = false;\n-    if all_in_one_line {\n-        // First we try to 'overflow' the last child and see if it looks better than using\n-        // vertical layout.\n-        if let Some(shape) = parent_shape.offset_left(almost_total) {\n-            if let Some(rw) = rewrite_chain_subexpr(&last.expr, context, shape) {\n-                // We allow overflowing here only if both of the following conditions match:\n-                // 1. The entire chain fits in a single line except the last child.\n-                // 2. `last_child_str.lines().count() >= 5`.\n-                let line_count = rw.lines().count();\n-                let could_fit_single_line = almost_total + first_line_width(&rw) <= one_line_budget;\n-                if could_fit_single_line && line_count >= 5 {\n-                    last_subexpr_str = Some(rw);\n-                    fits_single_line = true;\n-                } else {\n-                    // We could not know whether overflowing is better than using vertical layout,\n-                    // just by looking at the overflowed rewrite. Now we rewrite the last child\n-                    // on its own line, and compare two rewrites to choose which is better.\n-                    match rewrite_chain_subexpr(&last.expr, context, last_shape) {\n-                        Some(ref new_rw) if !could_fit_single_line => {\n-                            last_subexpr_str = Some(new_rw.clone());\n-                        }\n-                        Some(ref new_rw) if new_rw.lines().count() >= line_count => {\n-                            last_subexpr_str = Some(rw);\n-                            fits_single_line = could_fit_single_line;\n-                        }\n-                        new_rw @ Some(..) => {\n-                            last_subexpr_str = new_rw;\n-                        }\n-                        _ => {\n-                            last_subexpr_str = Some(rw);\n-                            fits_single_line = could_fit_single_line;\n+        // Total of all items excluding the last.\n+        let almost_total = self.rewrites.iter().fold(0, |a, b| a + b.len()) + last.tries;\n+        let one_line_budget = if self.rewrites.len() == 1 {\n+            shape.width\n+        } else {\n+            min(shape.width, context.config.width_heuristics().chain_width)\n+        };\n+        let all_in_one_line = self.rewrites.iter().all(|s| !s.contains('\\n'))\n+            && almost_total < one_line_budget;\n+        let last_shape = child_shape.sub_width(shape.rhs_overhead(context.config) + last.tries)?;\n+\n+\n+        let mut last_subexpr_str = None;\n+        if all_in_one_line {\n+            // First we try to 'overflow' the last child and see if it looks better than using\n+            // vertical layout.\n+            if let Some(shape) = shape.offset_left(almost_total) {\n+                if let Some(rw) = rewrite_chain_subexpr(&last.expr, context, shape) {\n+                    // We allow overflowing here only if both of the following conditions match:\n+                    // 1. The entire chain fits in a single line except the last child.\n+                    // 2. `last_child_str.lines().count() >= 5`.\n+                    let line_count = rw.lines().count();\n+                    let could_fit_single_line = almost_total + first_line_width(&rw) <= one_line_budget;\n+                    if could_fit_single_line && line_count >= 5 {\n+                        last_subexpr_str = Some(rw);\n+                        self.fits_single_line = all_in_one_line;\n+                    } else {\n+                        // We could not know whether overflowing is better than using vertical layout,\n+                        // just by looking at the overflowed rewrite. Now we rewrite the last child\n+                        // on its own line, and compare two rewrites to choose which is better.\n+                        match rewrite_chain_subexpr(&last.expr, context, last_shape) {\n+                            Some(ref new_rw) if !could_fit_single_line => {\n+                                last_subexpr_str = Some(new_rw.clone());\n+                            }\n+                            Some(ref new_rw) if new_rw.lines().count() >= line_count => {\n+                                last_subexpr_str = Some(rw);\n+                                self.fits_single_line = could_fit_single_line && all_in_one_line;\n+                            }\n+                            new_rw @ Some(..) => {\n+                                last_subexpr_str = new_rw;\n+                            }\n+                            _ => {\n+                                last_subexpr_str = Some(rw);\n+                                self.fits_single_line = could_fit_single_line && all_in_one_line;\n+                            }\n                         }\n                     }\n                 }\n             }\n-        }\n-    } \n+        } \n \n-    last_subexpr_str = last_subexpr_str.or_else(|| rewrite_chain_subexpr(&last.expr, context, last_shape));\n-    rewrites.push(last_subexpr_str?);\n-\n-    let connector = if fits_single_line && all_in_one_line {\n-        // Yay, we can put everything on one line.\n-        Cow::from(\"\")\n-    } else {\n-        // Use new lines.\n-        if *context.force_one_line_chain.borrow() {\n-            return None;\n-        }\n-        child_shape.indent.to_string_with_newline(context.config)\n-    };\n+        let last_subexpr_str = last_subexpr_str.or_else(|| rewrite_chain_subexpr(&last.expr, context, last_shape));\n+        self.rewrites.push(format!(\"{}{}\", last_subexpr_str?, \"?\".repeat(last.tries)));\n+        Some(())\n+    }\n \n-    let result = format!(\"{}{}\",\n-        join_rewrites_vis(&rewrites, &connector),\n-        \"?\".repeat(last.tries),\n-    );\n-    wrap_str(result, context.config.max_width(), shape)\n-}\n+    fn join_rewrites(&self, context: &RewriteContext, child_shape: Shape) -> Option<String> {\n+        let connector = if self.fits_single_line {\n+            // Yay, we can put everything on one line.\n+            Cow::from(\"\")\n+        } else {\n+            // Use new lines.\n+            if *context.force_one_line_chain.borrow() {\n+                return None;\n+            }\n+            child_shape.indent.to_string_with_newline(context.config)\n+        };\n \n-fn join_rewrites(rewrites: &[String], is_block_like: &[bool], connector: &str) -> String {\n-    let mut rewrite_iter = rewrites.iter();\n-    let mut result = rewrite_iter.next().unwrap().clone();\n+        let mut rewrite_iter = self.rewrites.iter();\n+        let mut result = rewrite_iter.next().unwrap().clone();\n \n-    for (rewrite, prev_is_block_like) in rewrite_iter.zip(is_block_like.iter()) {\n-        if rewrite != \"?\" && !prev_is_block_like {\n-            result.push_str(connector);\n+        for rewrite in rewrite_iter {\n+            result.push_str(&connector);\n+            result.push_str(&rewrite);\n         }\n-        result.push_str(&rewrite);\n-    }\n \n-    result\n+        Some(result)\n+    }\n }\n \n-fn join_rewrites_vis(rewrites: &[String], connector: &str) -> String {\n-    let mut rewrite_iter = rewrites.iter();\n-    let mut result = rewrite_iter.next().unwrap().clone();\n+fn rewrite_chain_visual(chain: Chain, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    let mut formatter = ChainFormatterVisual::new(&chain);\n+\n+    formatter.format_root(&chain.parent, context, shape)?;\n \n-    for rewrite in rewrite_iter {\n-        if rewrite != \"?\" {\n-            result.push_str(connector);\n-        }\n-        result.push_str(&rewrite);\n+    if formatter.children.is_empty() {\n+        assert_eq!(formatter.rewrites.len(), 1);\n+        return Some(formatter.rewrites.pop().unwrap());\n     }\n \n-    result\n+    let child_shape = shape.visual_indent(0).with_max_width(context.config);\n+\n+    formatter.format_children(context, child_shape)?;\n+    formatter.format_last_child(context, shape, child_shape)?;\n+\n+    let result = formatter.join_rewrites(context, child_shape)?;\n+    wrap_str(result, context.config.max_width(), shape)\n }\n \n // States whether an expression's last line exclusively consists of closing\n@@ -513,45 +590,6 @@ fn is_block_expr(context: &RewriteContext, expr: &ast::Expr, repr: &str) -> bool\n     }\n }\n \n-// Returns a Vec of the prefixes of the chain.\n-// E.g., for input `a.b.c` we return [`a.b.c`, `a.b`, 'a']\n-fn make_subexpr_list(expr: &ast::Expr, context: &RewriteContext) -> Vec<ast::Expr> {\n-    let mut subexpr_list = vec![expr.clone()];\n-\n-    while let Some(subexpr) = pop_expr_chain(subexpr_list.last().unwrap(), context) {\n-        subexpr_list.push(subexpr.clone());\n-    }\n-\n-    subexpr_list\n-}\n-\n-// Returns the expression's subexpression, if it exists. When the subexpr\n-// is a try! macro, we'll convert it to shorthand when the option is set.\n-fn pop_expr_chain(expr: &ast::Expr, context: &RewriteContext) -> Option<ast::Expr> {\n-    match expr.node {\n-        ast::ExprKind::MethodCall(_, ref expressions) => {\n-            Some(convert_try(&expressions[0], context))\n-        }\n-        ast::ExprKind::Field(ref subexpr, _) | ast::ExprKind::Try(ref subexpr) => {\n-            Some(convert_try(subexpr, context))\n-        }\n-        _ => None,\n-    }\n-}\n-\n-fn convert_try(expr: &ast::Expr, context: &RewriteContext) -> ast::Expr {\n-    match expr.node {\n-        ast::ExprKind::Mac(ref mac) if context.config.use_try_shorthand() => {\n-            if let Some(subexpr) = convert_try_mac(mac, context) {\n-                subexpr\n-            } else {\n-                expr.clone()\n-            }\n-        }\n-        _ => expr.clone(),\n-    }\n-}\n-\n // Rewrite the last element in the chain `expr`. E.g., given `a.b.c` we rewrite\n // `.c`.\n fn rewrite_chain_subexpr(\n@@ -600,14 +638,6 @@ fn is_tup_field_access(expr: &ast::Expr) -> bool {\n     }\n }\n \n-// Determines if we can continue formatting a given expression on the same line.\n-fn is_continuable(expr: &ast::Expr) -> bool {\n-    match expr.node {\n-        ast::ExprKind::Path(..) => true,\n-        _ => false,\n-    }\n-}\n-\n fn rewrite_method_call(\n     method_name: ast::Ident,\n     types: &[ast::GenericArg],"}]}