{"sha": "bd2f1cb2785f87177249e2bdb628ed782fcd8def", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkMmYxY2IyNzg1Zjg3MTc3MjQ5ZTJiZGI2MjhlZDc4MmZjZDhkZWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-19T13:13:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-19T13:13:41Z"}, "message": "Auto merge of #79342 - CDirkx:ipaddr-const, r=oli-obk\n\nStabilize all stable methods of `Ipv4Addr`, `Ipv6Addr` and `IpAddr` as const\n\nThis PR stabilizes all currently stable methods of `Ipv4Addr`, `Ipv6Addr` and `IpAddr` as const.\nTracking issue: #76205\n\n`Ipv4Addr` (`const_ipv4`):\n - `octets`\n - `is_loopback`\n - `is_private`\n - `is_link_local`\n - `is_multicast`\n - `is_broadcast`\n - `is_docmentation`\n - `to_ipv6_compatible`\n - `to_ipv6_mapped`\n\n`Ipv6Addr` (`const_ipv6`):\n - `segments`\n - `is_unspecified`\n - `is_loopback`\n - `is_multicast`\n - `to_ipv4`\n\n`IpAddr` (`const_ip`):\n - `is_unspecified`\n - `is_loopback`\n - `is_multicast`\n\n## Motivation\nThe ip methods seem like prime candidates to be made const: their behavior is defined by an external spec, and based solely on the byte contents of an address. These methods have been made unstable const in the beginning of September, after the necessary const integer arithmetic was stabilized.\n\nThere is currently a PR open (#78802) to change the internal representation of `IpAddr{4,6}` from `libc` types to a byte array. This does not have any impact on the constness of the methods.\n\n## Implementation\nMost of the stabilizations are straightforward, with the exception of `Ipv6Addr::segments`, which uses the unstable feature `const_fn_transmute`. The code could be rewritten to equivalent stable code, but this leads to worse code generation (#75085).\nThis is why `segments` gets marked with `#[rustc_allow_const_fn_unstable(const_fn_transmute)]`, like the already const-stable `Ipv6Addr::new`, the justification being that a const-stable alternative implementation exists https://github.com/rust-lang/rust/pull/76206#issuecomment-685044184.\n\n## Future posibilities\nThis PR const-stabilizes all currently stable ip methods, however there are also a number of unstable methods under the `ip` feature (#27709). These methods are already unstable const. There is a PR open (#76098) to stabilize those methods, which could include const-stabilization. However, stabilizing those methods as const is dependent on `Ipv4Addr::octets` and `Ipv6Addr::segments` (covered by this PR).", "tree": {"sha": "f8f59d70b75a338cd9860c0135afe4273833366b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8f59d70b75a338cd9860c0135afe4273833366b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd2f1cb2785f87177249e2bdb628ed782fcd8def", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd2f1cb2785f87177249e2bdb628ed782fcd8def", "html_url": "https://github.com/rust-lang/rust/commit/bd2f1cb2785f87177249e2bdb628ed782fcd8def", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd2f1cb2785f87177249e2bdb628ed782fcd8def/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bb302d34dde36cc78a288cb5beb4af7fe30ba41", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bb302d34dde36cc78a288cb5beb4af7fe30ba41", "html_url": "https://github.com/rust-lang/rust/commit/8bb302d34dde36cc78a288cb5beb4af7fe30ba41"}, {"sha": "4fcef4b1571a4909041fb6e8f304d33df611b1dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fcef4b1571a4909041fb6e8f304d33df611b1dc", "html_url": "https://github.com/rust-lang/rust/commit/4fcef4b1571a4909041fb6e8f304d33df611b1dc"}], "stats": {"total": 49, "additions": 27, "deletions": 22}, "files": [{"sha": "d33b772633d29772e0350090109b2dd1fc9c13fd", "filename": "library/std/src/net/ip.rs", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/bd2f1cb2785f87177249e2bdb628ed782fcd8def/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2f1cb2785f87177249e2bdb628ed782fcd8def/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip.rs?ref=bd2f1cb2785f87177249e2bdb628ed782fcd8def", "patch": "@@ -148,7 +148,7 @@ impl IpAddr {\n     /// assert_eq!(IpAddr::V4(Ipv4Addr::new(0, 0, 0, 0)).is_unspecified(), true);\n     /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)).is_unspecified(), true);\n     /// ```\n-    #[rustc_const_unstable(feature = \"const_ip\", issue = \"76205\")]\n+    #[rustc_const_stable(feature = \"const_ip\", since = \"1.50.0\")]\n     #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n     pub const fn is_unspecified(&self) -> bool {\n         match self {\n@@ -170,7 +170,7 @@ impl IpAddr {\n     /// assert_eq!(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)).is_loopback(), true);\n     /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0x1)).is_loopback(), true);\n     /// ```\n-    #[rustc_const_unstable(feature = \"const_ip\", issue = \"76205\")]\n+    #[rustc_const_stable(feature = \"const_ip\", since = \"1.50.0\")]\n     #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n     pub const fn is_loopback(&self) -> bool {\n         match self {\n@@ -215,7 +215,7 @@ impl IpAddr {\n     /// assert_eq!(IpAddr::V4(Ipv4Addr::new(224, 254, 0, 0)).is_multicast(), true);\n     /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0)).is_multicast(), true);\n     /// ```\n-    #[rustc_const_unstable(feature = \"const_ip\", issue = \"76205\")]\n+    #[rustc_const_stable(feature = \"const_ip\", since = \"1.50.0\")]\n     #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n     pub const fn is_multicast(&self) -> bool {\n         match self {\n@@ -301,8 +301,8 @@ impl Ipv4Addr {\n     ///\n     /// let addr = Ipv4Addr::new(127, 0, 0, 1);\n     /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.32.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const fn new(a: u8, b: u8, c: u8, d: u8) -> Ipv4Addr {\n         // `s_addr` is stored as BE on all machine and the array is in BE order.\n         // So the native endian conversion method is used so that it's never swapped.\n@@ -358,7 +358,7 @@ impl Ipv4Addr {\n     /// let addr = Ipv4Addr::new(127, 0, 0, 1);\n     /// assert_eq!(addr.octets(), [127, 0, 0, 1]);\n     /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n+    #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.50.0\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const fn octets(&self) -> [u8; 4] {\n         // This returns the order we want because s_addr is stored in big-endian.\n@@ -380,8 +380,8 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(0, 0, 0, 0).is_unspecified(), true);\n     /// assert_eq!(Ipv4Addr::new(45, 22, 13, 197).is_unspecified(), false);\n     /// ```\n-    #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n     #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.32.0\")]\n+    #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n     pub const fn is_unspecified(&self) -> bool {\n         self.inner.s_addr == 0\n     }\n@@ -400,7 +400,7 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(127, 0, 0, 1).is_loopback(), true);\n     /// assert_eq!(Ipv4Addr::new(45, 22, 13, 197).is_loopback(), false);\n     /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n+    #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.50.0\")]\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub const fn is_loopback(&self) -> bool {\n         self.octets()[0] == 127\n@@ -429,7 +429,7 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(192, 168, 0, 2).is_private(), true);\n     /// assert_eq!(Ipv4Addr::new(192, 169, 0, 2).is_private(), false);\n     /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n+    #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.50.0\")]\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub const fn is_private(&self) -> bool {\n         match self.octets() {\n@@ -455,7 +455,7 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(169, 254, 10, 65).is_link_local(), true);\n     /// assert_eq!(Ipv4Addr::new(16, 89, 10, 65).is_link_local(), false);\n     /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n+    #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.50.0\")]\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub const fn is_link_local(&self) -> bool {\n         matches!(self.octets(), [169, 254, ..])\n@@ -675,7 +675,7 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(236, 168, 10, 65).is_multicast(), true);\n     /// assert_eq!(Ipv4Addr::new(172, 16, 10, 65).is_multicast(), false);\n     /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n+    #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.50.0\")]\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub const fn is_multicast(&self) -> bool {\n         self.octets()[0] >= 224 && self.octets()[0] <= 239\n@@ -695,7 +695,7 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_broadcast(), true);\n     /// assert_eq!(Ipv4Addr::new(236, 168, 10, 65).is_broadcast(), false);\n     /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n+    #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.50.0\")]\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub const fn is_broadcast(&self) -> bool {\n         u32::from_be_bytes(self.octets()) == u32::from_be_bytes(Self::BROADCAST.octets())\n@@ -721,7 +721,7 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(203, 0, 113, 6).is_documentation(), true);\n     /// assert_eq!(Ipv4Addr::new(193, 34, 17, 19).is_documentation(), false);\n     /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n+    #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.50.0\")]\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub const fn is_documentation(&self) -> bool {\n         match self.octets() {\n@@ -751,7 +751,7 @@ impl Ipv4Addr {\n     ///     Ipv6Addr::new(0, 0, 0, 0, 0, 0, 49152, 767)\n     /// );\n     /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n+    #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.50.0\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const fn to_ipv6_compatible(&self) -> Ipv6Addr {\n         let [a, b, c, d] = self.octets();\n@@ -774,7 +774,7 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(192, 0, 2, 255).to_ipv6_mapped(),\n     ///            Ipv6Addr::new(0, 0, 0, 0, 0, 65535, 49152, 767));\n     /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n+    #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.50.0\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const fn to_ipv6_mapped(&self) -> Ipv6Addr {\n         let [a, b, c, d] = self.octets();\n@@ -1043,9 +1043,9 @@ impl Ipv6Addr {\n     ///\n     /// let addr = Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff);\n     /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_stable(feature = \"const_ipv6\", since = \"1.32.0\")]\n     #[rustc_allow_const_fn_unstable(const_fn_transmute)]\n+    #[rustc_const_stable(feature = \"const_ipv6\", since = \"1.32.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const fn new(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16, h: u16) -> Ipv6Addr {\n         let addr16 = [\n             a.to_be(),\n@@ -1061,6 +1061,8 @@ impl Ipv6Addr {\n             inner: c::in6_addr {\n                 // All elements in `addr16` are big endian.\n                 // SAFETY: `[u16; 8]` is always safe to transmute to `[u8; 16]`.\n+                // rustc_allow_const_fn_unstable: the transmute could be written as stable const\n+                // code, but that leads to worse code generation (#75085)\n                 s6_addr: unsafe { transmute::<_, [u8; 16]>(addr16) },\n             },\n         }\n@@ -1102,11 +1104,14 @@ impl Ipv6Addr {\n     /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).segments(),\n     ///            [0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff]);\n     /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n+    #[rustc_allow_const_fn_unstable(const_fn_transmute)]\n+    #[rustc_const_stable(feature = \"const_ipv6\", since = \"1.50.0\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const fn segments(&self) -> [u16; 8] {\n         // All elements in `s6_addr` must be big endian.\n         // SAFETY: `[u8; 16]` is always safe to transmute to `[u16; 8]`.\n+        // rustc_allow_const_fn_unstable: the transmute could be written as stable const code, but\n+        // that leads to worse code generation (#75085)\n         let [a, b, c, d, e, f, g, h] = unsafe { transmute::<_, [u16; 8]>(self.inner.s6_addr) };\n         // We want native endian u16\n         [\n@@ -1135,7 +1140,7 @@ impl Ipv6Addr {\n     /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unspecified(), false);\n     /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0).is_unspecified(), true);\n     /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n+    #[rustc_const_stable(feature = \"const_ipv6\", since = \"1.50.0\")]\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub const fn is_unspecified(&self) -> bool {\n         u128::from_be_bytes(self.octets()) == u128::from_be_bytes(Ipv6Addr::UNSPECIFIED.octets())\n@@ -1155,7 +1160,7 @@ impl Ipv6Addr {\n     /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_loopback(), false);\n     /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0x1).is_loopback(), true);\n     /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n+    #[rustc_const_stable(feature = \"const_ipv6\", since = \"1.50.0\")]\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub const fn is_loopback(&self) -> bool {\n         u128::from_be_bytes(self.octets()) == u128::from_be_bytes(Ipv6Addr::LOCALHOST.octets())\n@@ -1465,7 +1470,7 @@ impl Ipv6Addr {\n     /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).is_multicast(), true);\n     /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_multicast(), false);\n     /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n+    #[rustc_const_stable(feature = \"const_ipv6\", since = \"1.50.0\")]\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub const fn is_multicast(&self) -> bool {\n         (self.segments()[0] & 0xff00) == 0xff00\n@@ -1520,7 +1525,7 @@ impl Ipv6Addr {\n     /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1).to_ipv4(),\n     ///            Some(Ipv4Addr::new(0, 0, 0, 1)));\n     /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n+    #[rustc_const_stable(feature = \"const_ipv6\", since = \"1.50.0\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const fn to_ipv4(&self) -> Option<Ipv4Addr> {\n         if let [0, 0, 0, 0, 0, 0 | 0xffff, ab, cd] = self.segments() {\n@@ -1540,8 +1545,8 @@ impl Ipv6Addr {\n     /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).octets(),\n     ///            [255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n     /// ```\n-    #[stable(feature = \"ipv6_to_octets\", since = \"1.12.0\")]\n     #[rustc_const_stable(feature = \"const_ipv6\", since = \"1.32.0\")]\n+    #[stable(feature = \"ipv6_to_octets\", since = \"1.12.0\")]\n     pub const fn octets(&self) -> [u8; 16] {\n         self.inner.s6_addr\n     }"}]}