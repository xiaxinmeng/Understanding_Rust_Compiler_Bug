{"sha": "a00f8ba7fcac1b27341679c51bf5a3271fa82df3", "node_id": "C_kwDOAAsO6NoAKGEwMGY4YmE3ZmNhYzFiMjczNDE2NzljNTFiZjVhMzI3MWZhODJkZjM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-15T17:37:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-15T17:37:15Z"}, "message": "Auto merge of #104054 - RalfJung:byte-provenance, r=oli-obk\n\ninterpret: support for per-byte provenance\n\nAlso factors the provenance map into its own module.\n\nThe third commit does the same for the init mask. I can move it in a separate PR if you prefer.\n\nFixes https://github.com/rust-lang/miri/issues/2181\n\nr? `@oli-obk`", "tree": {"sha": "155672e116c8913192ba36b4a9e0f668e387c3ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/155672e116c8913192ba36b4a9e0f668e387c3ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a00f8ba7fcac1b27341679c51bf5a3271fa82df3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a00f8ba7fcac1b27341679c51bf5a3271fa82df3", "html_url": "https://github.com/rust-lang/rust/commit/a00f8ba7fcac1b27341679c51bf5a3271fa82df3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d651a295e0e0c331153288b10b78344a4ede20b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d651a295e0e0c331153288b10b78344a4ede20b", "html_url": "https://github.com/rust-lang/rust/commit/6d651a295e0e0c331153288b10b78344a4ede20b"}, {"sha": "68af46c1121d14a3d89ec56cd4ed2fef829bae75", "url": "https://api.github.com/repos/rust-lang/rust/commits/68af46c1121d14a3d89ec56cd4ed2fef829bae75", "html_url": "https://github.com/rust-lang/rust/commit/68af46c1121d14a3d89ec56cd4ed2fef829bae75"}], "stats": {"total": 2212, "additions": 1253, "deletions": 959}, "files": [{"sha": "c0c6c76473ba8a8c781fde028eef0272bc92f341", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=a00f8ba7fcac1b27341679c51bf5a3271fa82df3", "patch": "@@ -398,7 +398,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n         let bytes = alloc.inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len()).to_vec();\n         data_ctx.define(bytes.into_boxed_slice());\n \n-        for &(offset, alloc_id) in alloc.provenance().iter() {\n+        for &(offset, alloc_id) in alloc.provenance().ptrs().iter() {\n             let addend = {\n                 let endianness = tcx.data_layout.endian;\n                 let offset = offset.bytes() as usize;\n@@ -431,7 +431,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n                     {\n                         tcx.sess.fatal(&format!(\n                             \"Allocation {:?} contains reference to TLS value {:?}\",\n-                            alloc, def_id\n+                            alloc_id, def_id\n                         ));\n                     }\n "}, {"sha": "111bfeb1322038961f693f4d924b9ff18754d600", "filename": "compiler/rustc_codegen_gcc/src/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs?ref=a00f8ba7fcac1b27341679c51bf5a3271fa82df3", "patch": "@@ -297,12 +297,12 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n \n pub fn const_alloc_to_gcc<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, alloc: ConstAllocation<'tcx>) -> RValue<'gcc> {\n     let alloc = alloc.inner();\n-    let mut llvals = Vec::with_capacity(alloc.provenance().len() + 1);\n+    let mut llvals = Vec::with_capacity(alloc.provenance().ptrs().len() + 1);\n     let dl = cx.data_layout();\n     let pointer_size = dl.pointer_size.bytes() as usize;\n \n     let mut next_offset = 0;\n-    for &(offset, alloc_id) in alloc.provenance().iter() {\n+    for &(offset, alloc_id) in alloc.provenance().ptrs().iter() {\n         let offset = offset.bytes();\n         assert_eq!(offset as usize as u64, offset);\n         let offset = offset as usize;"}, {"sha": "69434280b2144c86eef7673258e3f29dc5694eb7", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=a00f8ba7fcac1b27341679c51bf5a3271fa82df3", "patch": "@@ -28,7 +28,7 @@ use std::ops::Range;\n \n pub fn const_alloc_to_llvm<'ll>(cx: &CodegenCx<'ll, '_>, alloc: ConstAllocation<'_>) -> &'ll Value {\n     let alloc = alloc.inner();\n-    let mut llvals = Vec::with_capacity(alloc.provenance().len() + 1);\n+    let mut llvals = Vec::with_capacity(alloc.provenance().ptrs().len() + 1);\n     let dl = cx.data_layout();\n     let pointer_size = dl.pointer_size.bytes() as usize;\n \n@@ -40,9 +40,7 @@ pub fn const_alloc_to_llvm<'ll>(cx: &CodegenCx<'ll, '_>, alloc: ConstAllocation<\n         alloc: &'a Allocation,\n         range: Range<usize>,\n     ) {\n-        let chunks = alloc\n-            .init_mask()\n-            .range_as_init_chunks(Size::from_bytes(range.start), Size::from_bytes(range.end));\n+        let chunks = alloc.init_mask().range_as_init_chunks(range.clone().into());\n \n         let chunk_to_llval = move |chunk| match chunk {\n             InitChunk::Init(range) => {\n@@ -80,7 +78,7 @@ pub fn const_alloc_to_llvm<'ll>(cx: &CodegenCx<'ll, '_>, alloc: ConstAllocation<\n     }\n \n     let mut next_offset = 0;\n-    for &(offset, alloc_id) in alloc.provenance().iter() {\n+    for &(offset, alloc_id) in alloc.provenance().ptrs().iter() {\n         let offset = offset.bytes();\n         assert_eq!(offset as usize as u64, offset);\n         let offset = offset as usize;\n@@ -489,7 +487,7 @@ impl<'ll> StaticMethods for CodegenCx<'ll, '_> {\n                     // happens to be zero. Instead, we should only check the value of defined bytes\n                     // and set all undefined bytes to zero if this allocation is headed for the\n                     // BSS.\n-                    let all_bytes_are_zero = alloc.provenance().is_empty()\n+                    let all_bytes_are_zero = alloc.provenance().ptrs().is_empty()\n                         && alloc\n                             .inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len())\n                             .iter()\n@@ -513,7 +511,7 @@ impl<'ll> StaticMethods for CodegenCx<'ll, '_> {\n                         section.as_str().as_ptr().cast(),\n                         section.as_str().len() as c_uint,\n                     );\n-                    assert!(alloc.provenance().is_empty());\n+                    assert!(alloc.provenance().ptrs().is_empty());\n \n                     // The `inspect` method is okay here because we checked for provenance, and\n                     // because we are doing this access to inspect the final interpreter state (not"}, {"sha": "458cc6180d53e47281bf97a9754125159963cb96", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=a00f8ba7fcac1b27341679c51bf5a3271fa82df3", "patch": "@@ -134,7 +134,7 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx, const_eval:\n         alloc.mutability = Mutability::Not;\n     };\n     // link the alloc id to the actual allocation\n-    leftover_allocations.extend(alloc.provenance().iter().map(|&(_, alloc_id)| alloc_id));\n+    leftover_allocations.extend(alloc.provenance().ptrs().iter().map(|&(_, alloc_id)| alloc_id));\n     let alloc = tcx.intern_const_alloc(alloc);\n     tcx.set_alloc_id_memory(alloc_id, alloc);\n     None\n@@ -439,7 +439,7 @@ pub fn intern_const_alloc_recursive<\n             }\n             let alloc = tcx.intern_const_alloc(alloc);\n             tcx.set_alloc_id_memory(alloc_id, alloc);\n-            for &(_, alloc_id) in alloc.inner().provenance().iter() {\n+            for &(_, alloc_id) in alloc.inner().provenance().ptrs().iter() {\n                 if leftover_allocations.insert(alloc_id) {\n                     todo.push(alloc_id);\n                 }"}, {"sha": "7c20d9138e17185765286b8a3f64a5d7bd3880d7", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=a00f8ba7fcac1b27341679c51bf5a3271fa82df3", "patch": "@@ -112,15 +112,15 @@ pub struct Memory<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n /// A reference to some allocation that was already bounds-checked for the given region\n /// and had the on-access machine hooks run.\n #[derive(Copy, Clone)]\n-pub struct AllocRef<'a, 'tcx, Prov, Extra> {\n+pub struct AllocRef<'a, 'tcx, Prov: Provenance, Extra> {\n     alloc: &'a Allocation<Prov, Extra>,\n     range: AllocRange,\n     tcx: TyCtxt<'tcx>,\n     alloc_id: AllocId,\n }\n /// A reference to some allocation that was already bounds-checked for the given region\n /// and had the on-access machine hooks run.\n-pub struct AllocRefMut<'a, 'tcx, Prov, Extra> {\n+pub struct AllocRefMut<'a, 'tcx, Prov: Provenance, Extra> {\n     alloc: &'a mut Allocation<Prov, Extra>,\n     range: AllocRange,\n     tcx: TyCtxt<'tcx>,\n@@ -302,8 +302,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .into());\n         };\n \n-        debug!(?alloc);\n-\n         if alloc.mutability == Mutability::Not {\n             throw_ub_format!(\"deallocating immutable allocation {alloc_id:?}\");\n         }\n@@ -797,7 +795,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     // This is a new allocation, add the allocation it points to `todo`.\n                     if let Some((_, alloc)) = self.memory.alloc_map.get(id) {\n                         todo.extend(\n-                            alloc.provenance().values().filter_map(|prov| prov.get_alloc_id()),\n+                            alloc.provenance().provenances().filter_map(|prov| prov.get_alloc_id()),\n                         );\n                     }\n                 }\n@@ -833,7 +831,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a,\n             allocs_to_print: &mut VecDeque<AllocId>,\n             alloc: &Allocation<Prov, Extra>,\n         ) -> std::fmt::Result {\n-            for alloc_id in alloc.provenance().values().filter_map(|prov| prov.get_alloc_id()) {\n+            for alloc_id in alloc.provenance().provenances().filter_map(|prov| prov.get_alloc_id())\n+            {\n                 allocs_to_print.push_back(alloc_id);\n             }\n             write!(fmt, \"{}\", display_allocation(tcx, alloc))\n@@ -962,7 +961,7 @@ impl<'tcx, 'a, Prov: Provenance, Extra> AllocRef<'a, 'tcx, Prov, Extra> {\n \n     /// Returns whether the allocation has provenance anywhere in the range of the `AllocRef`.\n     pub(crate) fn has_provenance(&self) -> bool {\n-        self.alloc.range_has_provenance(&self.tcx, self.range)\n+        !self.alloc.provenance().range_empty(self.range, &self.tcx)\n     }\n }\n \n@@ -1060,7 +1059,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         // Source alloc preparations and access hooks.\n         let Some((src_alloc_id, src_offset, src_prov)) = src_parts else {\n-            // Zero-sized *source*, that means dst is also zero-sized and we have nothing to do.\n+            // Zero-sized *source*, that means dest is also zero-sized and we have nothing to do.\n             return Ok(());\n         };\n         let src_alloc = self.get_alloc_raw(src_alloc_id)?;\n@@ -1079,22 +1078,18 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             return Ok(());\n         };\n \n-        // Checks provenance edges on the src, which needs to happen before\n-        // `prepare_provenance_copy`.\n-        if src_alloc.range_has_provenance(&tcx, alloc_range(src_range.start, Size::ZERO)) {\n-            throw_unsup!(PartialPointerCopy(Pointer::new(src_alloc_id, src_range.start)));\n-        }\n-        if src_alloc.range_has_provenance(&tcx, alloc_range(src_range.end(), Size::ZERO)) {\n-            throw_unsup!(PartialPointerCopy(Pointer::new(src_alloc_id, src_range.end())));\n-        }\n+        // Prepare getting source provenance.\n         let src_bytes = src_alloc.get_bytes_unchecked(src_range).as_ptr(); // raw ptr, so we can also get a ptr to the destination allocation\n         // first copy the provenance to a temporary buffer, because\n         // `get_bytes_mut` will clear the provenance, which is correct,\n         // since we don't want to keep any provenance at the target.\n-        let provenance =\n-            src_alloc.prepare_provenance_copy(self, src_range, dest_offset, num_copies);\n+        // This will also error if copying partial provenance is not supported.\n+        let provenance = src_alloc\n+            .provenance()\n+            .prepare_copy(src_range, dest_offset, num_copies, self)\n+            .map_err(|e| e.to_interp_error(dest_alloc_id))?;\n         // Prepare a copy of the initialization mask.\n-        let compressed = src_alloc.compress_uninit_range(src_range);\n+        let init = src_alloc.init_mask().prepare_copy(src_range);\n \n         // Destination alloc preparations and access hooks.\n         let (dest_alloc, extra) = self.get_alloc_raw_mut(dest_alloc_id)?;\n@@ -1111,7 +1106,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .map_err(|e| e.to_interp_error(dest_alloc_id))?\n             .as_mut_ptr();\n \n-        if compressed.no_bytes_init() {\n+        if init.no_bytes_init() {\n             // Fast path: If all bytes are `uninit` then there is nothing to copy. The target range\n             // is marked as uninitialized but we otherwise omit changing the byte representation which may\n             // be arbitrary for uninitialized bytes.\n@@ -1160,13 +1155,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n \n         // now fill in all the \"init\" data\n-        dest_alloc.mark_compressed_init_range(\n-            &compressed,\n+        dest_alloc.init_mask_apply_copy(\n+            init,\n             alloc_range(dest_offset, size), // just a single copy (i.e., not full `dest_range`)\n             num_copies,\n         );\n         // copy the provenance to the destination\n-        dest_alloc.mark_provenance_range(provenance);\n+        dest_alloc.provenance_apply_copy(provenance);\n \n         Ok(())\n     }"}, {"sha": "2fdfdd77256fcce4ed49226323612f11c168cff7", "filename": "compiler/rustc_hir_analysis/src/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs?ref=a00f8ba7fcac1b27341679c51bf5a3271fa82df3", "patch": "@@ -159,7 +159,7 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt<'_>, id: LocalDefId) {\n     // the consumer's responsibility to ensure all bytes that have been read\n     // have defined values.\n     if let Ok(alloc) = tcx.eval_static_initializer(id.to_def_id())\n-        && alloc.inner().provenance().len() != 0\n+        && alloc.inner().provenance().ptrs().len() != 0\n     {\n         let msg = \"statics with a custom `#[link_section]` must be a \\\n                         simple list of bytes on the wasm target with no \\"}, {"sha": "680240703465f284726de2a262bd18880b46710c", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 69, "deletions": 768, "changes": 837, "blob_url": "https://github.com/rust-lang/rust/blob/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=a00f8ba7fcac1b27341679c51bf5a3271fa82df3", "patch": "@@ -1,16 +1,18 @@\n //! The virtual memory representation of the MIR interpreter.\n \n+mod init_mask;\n+mod provenance_map;\n+#[cfg(test)]\n+mod tests;\n+\n use std::borrow::Cow;\n-use std::convert::{TryFrom, TryInto};\n use std::fmt;\n use std::hash;\n-use std::iter;\n-use std::ops::{Deref, Range};\n+use std::ops::Range;\n use std::ptr;\n \n use rustc_ast::Mutability;\n use rustc_data_structures::intern::Interned;\n-use rustc_data_structures::sorted_map::SortedMap;\n use rustc_span::DUMMY_SP;\n use rustc_target::abi::{Align, HasDataLayout, Size};\n \n@@ -20,6 +22,10 @@ use super::{\n     UnsupportedOpInfo,\n };\n use crate::ty;\n+use init_mask::*;\n+use provenance_map::*;\n+\n+pub use init_mask::{InitChunk, InitChunkIter};\n \n /// This type represents an Allocation in the Miri/CTFE core engine.\n ///\n@@ -28,9 +34,9 @@ use crate::ty;\n /// module provides higher-level access.\n // Note: for performance reasons when interning, some of the `Allocation` fields can be partially\n // hashed. (see the `Hash` impl below for more details), so the impl is not derived.\n-#[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, TyEncodable, TyDecodable)]\n+#[derive(Clone, Eq, PartialEq, PartialOrd, Ord, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n-pub struct Allocation<Prov = AllocId, Extra = ()> {\n+pub struct Allocation<Prov: Provenance = AllocId, Extra = ()> {\n     /// The actual bytes of the allocation.\n     /// Note that the bytes of a pointer represent the offset of the pointer.\n     bytes: Box<[u8]>,\n@@ -102,20 +108,18 @@ impl hash::Hash for Allocation {\n /// (`ConstAllocation`) are used quite a bit.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, HashStable)]\n #[rustc_pass_by_value]\n-pub struct ConstAllocation<'tcx, Prov = AllocId, Extra = ()>(\n-    pub Interned<'tcx, Allocation<Prov, Extra>>,\n-);\n+pub struct ConstAllocation<'tcx>(pub Interned<'tcx, Allocation>);\n \n impl<'tcx> fmt::Debug for ConstAllocation<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // This matches how `Allocation` is printed. We print it like this to\n-        // avoid having to update expected output in a lot of tests.\n-        write!(f, \"{:?}\", self.inner())\n+        // The debug representation of this is very verbose and basically useless,\n+        // so don't print it.\n+        write!(f, \"ConstAllocation {{ .. }}\")\n     }\n }\n \n-impl<'tcx, Prov, Extra> ConstAllocation<'tcx, Prov, Extra> {\n-    pub fn inner(self) -> &'tcx Allocation<Prov, Extra> {\n+impl<'tcx> ConstAllocation<'tcx> {\n+    pub fn inner(self) -> &'tcx Allocation {\n         self.0.0\n     }\n }\n@@ -183,12 +187,21 @@ pub fn alloc_range(start: Size, size: Size) -> AllocRange {\n     AllocRange { start, size }\n }\n \n-impl AllocRange {\n+impl From<Range<Size>> for AllocRange {\n     #[inline]\n-    pub fn from(r: Range<Size>) -> Self {\n+    fn from(r: Range<Size>) -> Self {\n         alloc_range(r.start, r.end - r.start) // `Size` subtraction (overflow-checked)\n     }\n+}\n+\n+impl From<Range<usize>> for AllocRange {\n+    #[inline]\n+    fn from(r: Range<usize>) -> Self {\n+        AllocRange::from(Size::from_bytes(r.start)..Size::from_bytes(r.end))\n+    }\n+}\n \n+impl AllocRange {\n     #[inline(always)]\n     pub fn end(self) -> Size {\n         self.start + self.size // This does overflow checking.\n@@ -205,7 +218,7 @@ impl AllocRange {\n }\n \n // The constructors are all without extra; the extra gets added by a machine hook later.\n-impl<Prov> Allocation<Prov> {\n+impl<Prov: Provenance> Allocation<Prov> {\n     /// Creates an allocation initialized by the given bytes\n     pub fn from_bytes<'a>(\n         slice: impl Into<Cow<'a, [u8]>>,\n@@ -263,18 +276,18 @@ impl<Prov> Allocation<Prov> {\n impl Allocation {\n     /// Adjust allocation from the ones in tcx to a custom Machine instance\n     /// with a different Provenance and Extra type.\n-    pub fn adjust_from_tcx<Prov, Extra, Err>(\n+    pub fn adjust_from_tcx<Prov: Provenance, Extra, Err>(\n         self,\n         cx: &impl HasDataLayout,\n         extra: Extra,\n         mut adjust_ptr: impl FnMut(Pointer<AllocId>) -> Result<Pointer<Prov>, Err>,\n     ) -> Result<Allocation<Prov, Extra>, Err> {\n         // Compute new pointer provenance, which also adjusts the bytes.\n         let mut bytes = self.bytes;\n-        let mut new_provenance = Vec::with_capacity(self.provenance.0.len());\n+        let mut new_provenance = Vec::with_capacity(self.provenance.ptrs().len());\n         let ptr_size = cx.data_layout().pointer_size.bytes_usize();\n         let endian = cx.data_layout().endian;\n-        for &(offset, alloc_id) in self.provenance.iter() {\n+        for &(offset, alloc_id) in self.provenance.ptrs().iter() {\n             let idx = offset.bytes_usize();\n             let ptr_bytes = &mut bytes[idx..idx + ptr_size];\n             let bits = read_target_uint(endian, ptr_bytes).unwrap();\n@@ -286,7 +299,7 @@ impl Allocation {\n         // Create allocation.\n         Ok(Allocation {\n             bytes,\n-            provenance: ProvenanceMap::from_presorted(new_provenance),\n+            provenance: ProvenanceMap::from_presorted_ptrs(new_provenance),\n             init_mask: self.init_mask,\n             align: self.align,\n             mutability: self.mutability,\n@@ -296,7 +309,7 @@ impl Allocation {\n }\n \n /// Raw accessors. Provide access to otherwise private bytes.\n-impl<Prov, Extra> Allocation<Prov, Extra> {\n+impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n     pub fn len(&self) -> usize {\n         self.bytes.len()\n     }\n@@ -349,9 +362,14 @@ impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n         cx: &impl HasDataLayout,\n         range: AllocRange,\n     ) -> AllocResult<&[u8]> {\n-        self.check_init(range)?;\n+        self.init_mask.is_range_initialized(range).map_err(|uninit_range| {\n+            AllocError::InvalidUninitBytes(Some(UninitBytesAccess {\n+                access: range,\n+                uninit: uninit_range,\n+            }))\n+        })?;\n         if !Prov::OFFSET_IS_ADDR {\n-            if self.range_has_provenance(cx, range) {\n+            if !self.provenance.range_empty(range, cx) {\n                 return Err(AllocError::ReadPointerAsBytes);\n             }\n         }\n@@ -370,7 +388,7 @@ impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n         range: AllocRange,\n     ) -> AllocResult<&mut [u8]> {\n         self.mark_init(range, true);\n-        self.clear_provenance(cx, range)?;\n+        self.provenance.clear(range, cx)?;\n \n         Ok(&mut self.bytes[range.start.bytes_usize()..range.end().bytes_usize()])\n     }\n@@ -382,7 +400,7 @@ impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n         range: AllocRange,\n     ) -> AllocResult<*mut [u8]> {\n         self.mark_init(range, true);\n-        self.clear_provenance(cx, range)?;\n+        self.provenance.clear(range, cx)?;\n \n         assert!(range.end().bytes_usize() <= self.bytes.len()); // need to do our own bounds-check\n         let begin_ptr = self.bytes.as_mut_ptr().wrapping_add(range.start.bytes_usize());\n@@ -393,6 +411,15 @@ impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n \n /// Reading and writing.\n impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n+    /// Sets the init bit for the given range.\n+    fn mark_init(&mut self, range: AllocRange, is_init: bool) {\n+        if range.size.bytes() == 0 {\n+            return;\n+        }\n+        assert!(self.mutability == Mutability::Mut);\n+        self.init_mask.set_range(range, is_init);\n+    }\n+\n     /// Reads a *non-ZST* scalar.\n     ///\n     /// If `read_provenance` is `true`, this will also read provenance; otherwise (if the machine\n@@ -410,7 +437,7 @@ impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n         read_provenance: bool,\n     ) -> AllocResult<Scalar<Prov>> {\n         // First and foremost, if anything is uninit, bail.\n-        if self.is_init(range).is_err() {\n+        if self.init_mask.is_range_initialized(range).is_err() {\n             return Err(AllocError::InvalidUninitBytes(None));\n         }\n \n@@ -423,18 +450,17 @@ impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n \n             // When reading data with provenance, the easy case is finding provenance exactly where we\n             // are reading, then we can put data and provenance back together and return that.\n-            if let Some(&prov) = self.provenance.get(&range.start) {\n+            if let Some(prov) = self.provenance.get_ptr(range.start) {\n                 // Now we can return the bits, with their appropriate provenance.\n                 let ptr = Pointer::new(prov, Size::from_bytes(bits));\n                 return Ok(Scalar::from_pointer(ptr, cx));\n             }\n \n             // If we can work on pointers byte-wise, join the byte-wise provenances.\n             if Prov::OFFSET_IS_ADDR {\n-                let mut prov = self.offset_get_provenance(cx, range.start);\n-                for offset in 1..range.size.bytes() {\n-                    let this_prov =\n-                        self.offset_get_provenance(cx, range.start + Size::from_bytes(offset));\n+                let mut prov = self.provenance.get(range.start, cx);\n+                for offset in Size::from_bytes(1)..range.size {\n+                    let this_prov = self.provenance.get(range.start + offset, cx);\n                     prov = Prov::join(prov, this_prov);\n                 }\n                 // Now use this provenance.\n@@ -452,7 +478,7 @@ impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n \n         // Fallback path for when we cannot treat provenance bytewise or ignore it.\n         assert!(!Prov::OFFSET_IS_ADDR);\n-        if self.range_has_provenance(cx, range) {\n+        if !self.provenance.range_empty(range, cx) {\n             return Err(AllocError::ReadPointerAsBytes);\n         }\n         // There is no provenance, we can just return the bits.\n@@ -466,7 +492,6 @@ impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n     /// Most likely, you want to call `InterpCx::write_scalar` instead of this method.\n-    #[instrument(skip(self, cx), level = \"debug\")]\n     pub fn write_scalar(\n         &mut self,\n         cx: &impl HasDataLayout,\n@@ -491,7 +516,8 @@ impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n \n         // See if we have to also store some provenance.\n         if let Some(provenance) = provenance {\n-            self.provenance.0.insert(range.start, provenance);\n+            assert_eq!(range.size, cx.data_layout().pointer_size);\n+            self.provenance.insert_ptr(range.start, provenance, cx);\n         }\n \n         Ok(())\n@@ -500,750 +526,25 @@ impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n     /// Write \"uninit\" to the given memory range.\n     pub fn write_uninit(&mut self, cx: &impl HasDataLayout, range: AllocRange) -> AllocResult {\n         self.mark_init(range, false);\n-        self.clear_provenance(cx, range)?;\n+        self.provenance.clear(range, cx)?;\n         return Ok(());\n     }\n-}\n-\n-/// Provenance.\n-impl<Prov: Copy, Extra> Allocation<Prov, Extra> {\n-    /// Returns all provenance overlapping with the given pointer-offset pair.\n-    fn range_get_provenance(&self, cx: &impl HasDataLayout, range: AllocRange) -> &[(Size, Prov)] {\n-        // We have to go back `pointer_size - 1` bytes, as that one would still overlap with\n-        // the beginning of this range.\n-        let start = range.start.bytes().saturating_sub(cx.data_layout().pointer_size.bytes() - 1);\n-        self.provenance.range(Size::from_bytes(start)..range.end())\n-    }\n-\n-    /// Get the provenance of a single byte.\n-    fn offset_get_provenance(&self, cx: &impl HasDataLayout, offset: Size) -> Option<Prov> {\n-        let prov = self.range_get_provenance(cx, alloc_range(offset, Size::from_bytes(1)));\n-        assert!(prov.len() <= 1);\n-        prov.first().map(|(_offset, prov)| *prov)\n-    }\n-\n-    /// Returns whether this allocation has progrnance overlapping with the given range.\n-    ///\n-    /// Note: this function exists to allow `range_get_provenance` to be private, in order to somewhat\n-    /// limit access to provenance outside of the `Allocation` abstraction.\n-    ///\n-    pub fn range_has_provenance(&self, cx: &impl HasDataLayout, range: AllocRange) -> bool {\n-        !self.range_get_provenance(cx, range).is_empty()\n-    }\n-\n-    /// Removes all provenance inside the given range.\n-    /// If there is provenance overlapping with the edges, it\n-    /// are removed as well *and* the bytes they cover are marked as\n-    /// uninitialized. This is a somewhat odd \"spooky action at a distance\",\n-    /// but it allows strictly more code to run than if we would just error\n-    /// immediately in that case.\n-    fn clear_provenance(&mut self, cx: &impl HasDataLayout, range: AllocRange) -> AllocResult\n-    where\n-        Prov: Provenance,\n-    {\n-        // Find the start and end of the given range and its outermost provenance.\n-        let (first, last) = {\n-            // Find all provenance overlapping the given range.\n-            let provenance = self.range_get_provenance(cx, range);\n-            if provenance.is_empty() {\n-                return Ok(());\n-            }\n-\n-            (\n-                provenance.first().unwrap().0,\n-                provenance.last().unwrap().0 + cx.data_layout().pointer_size,\n-            )\n-        };\n-        let start = range.start;\n-        let end = range.end();\n-\n-        // We need to handle clearing the provenance from parts of a pointer.\n-        // FIXME: Miri should preserve partial provenance; see\n-        // https://github.com/rust-lang/miri/issues/2181.\n-        if first < start {\n-            if Prov::ERR_ON_PARTIAL_PTR_OVERWRITE {\n-                return Err(AllocError::PartialPointerOverwrite(first));\n-            }\n-            warn!(\n-                \"Partial pointer overwrite! De-initializing memory at offsets {first:?}..{start:?}.\"\n-            );\n-            self.init_mask.set_range(first, start, false);\n-        }\n-        if last > end {\n-            if Prov::ERR_ON_PARTIAL_PTR_OVERWRITE {\n-                return Err(AllocError::PartialPointerOverwrite(\n-                    last - cx.data_layout().pointer_size,\n-                ));\n-            }\n-            warn!(\n-                \"Partial pointer overwrite! De-initializing memory at offsets {end:?}..{last:?}.\"\n-            );\n-            self.init_mask.set_range(end, last, false);\n-        }\n-\n-        // Forget all the provenance.\n-        // Since provenance do not overlap, we know that removing until `last` (exclusive) is fine,\n-        // i.e., this will not remove any other provenance just after the ones we care about.\n-        self.provenance.0.remove_range(first..last);\n-\n-        Ok(())\n-    }\n-}\n-\n-/// Stores the provenance information of pointers stored in memory.\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n-pub struct ProvenanceMap<Prov = AllocId>(SortedMap<Size, Prov>);\n-\n-impl<Prov> ProvenanceMap<Prov> {\n-    pub fn new() -> Self {\n-        ProvenanceMap(SortedMap::new())\n-    }\n-\n-    // The caller must guarantee that the given provenance list is already sorted\n-    // by address and contain no duplicates.\n-    pub fn from_presorted(r: Vec<(Size, Prov)>) -> Self {\n-        ProvenanceMap(SortedMap::from_presorted_elements(r))\n-    }\n-}\n-\n-impl<Prov> Deref for ProvenanceMap<Prov> {\n-    type Target = SortedMap<Size, Prov>;\n-\n-    fn deref(&self) -> &Self::Target {\n-        &self.0\n-    }\n-}\n-\n-/// A partial, owned list of provenance to transfer into another allocation.\n-///\n-/// Offsets are already adjusted to the destination allocation.\n-pub struct AllocationProvenance<Prov> {\n-    dest_provenance: Vec<(Size, Prov)>,\n-}\n-\n-impl<Prov: Copy, Extra> Allocation<Prov, Extra> {\n-    pub fn prepare_provenance_copy(\n-        &self,\n-        cx: &impl HasDataLayout,\n-        src: AllocRange,\n-        dest: Size,\n-        count: u64,\n-    ) -> AllocationProvenance<Prov> {\n-        let provenance = self.range_get_provenance(cx, src);\n-        if provenance.is_empty() {\n-            return AllocationProvenance { dest_provenance: Vec::new() };\n-        }\n-\n-        let size = src.size;\n-        let mut new_provenance = Vec::with_capacity(provenance.len() * (count as usize));\n-\n-        // If `count` is large, this is rather wasteful -- we are allocating a big array here, which\n-        // is mostly filled with redundant information since it's just N copies of the same `Prov`s\n-        // at slightly adjusted offsets. The reason we do this is so that in `mark_provenance_range`\n-        // we can use `insert_presorted`. That wouldn't work with an `Iterator` that just produces\n-        // the right sequence of provenance for all N copies.\n-        for i in 0..count {\n-            new_provenance.extend(provenance.iter().map(|&(offset, reloc)| {\n-                // compute offset for current repetition\n-                let dest_offset = dest + size * i; // `Size` operations\n-                (\n-                    // shift offsets from source allocation to destination allocation\n-                    (offset + dest_offset) - src.start, // `Size` operations\n-                    reloc,\n-                )\n-            }));\n-        }\n-\n-        AllocationProvenance { dest_provenance: new_provenance }\n-    }\n \n-    /// Applies a provenance copy.\n-    /// The affected range, as defined in the parameters to `prepare_provenance_copy` is expected\n+    /// Applies a previously prepared provenance copy.\n+    /// The affected range, as defined in the parameters to `provenance().prepare_copy` is expected\n     /// to be clear of provenance.\n     ///\n     /// This is dangerous to use as it can violate internal `Allocation` invariants!\n     /// It only exists to support an efficient implementation of `mem_copy_repeatedly`.\n-    pub fn mark_provenance_range(&mut self, provenance: AllocationProvenance<Prov>) {\n-        self.provenance.0.insert_presorted(provenance.dest_provenance);\n+    pub fn provenance_apply_copy(&mut self, copy: ProvenanceCopy<Prov>) {\n+        self.provenance.apply_copy(copy)\n     }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Uninitialized byte tracking\n-////////////////////////////////////////////////////////////////////////////////\n-\n-type Block = u64;\n-\n-/// A bitmask where each bit refers to the byte with the same index. If the bit is `true`, the byte\n-/// is initialized. If it is `false` the byte is uninitialized.\n-// Note: for performance reasons when interning, some of the `InitMask` fields can be partially\n-// hashed. (see the `Hash` impl below for more details), so the impl is not derived.\n-#[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, TyEncodable, TyDecodable)]\n-#[derive(HashStable)]\n-pub struct InitMask {\n-    blocks: Vec<Block>,\n-    len: Size,\n-}\n-\n-// Const allocations are only hashed for interning. However, they can be large, making the hashing\n-// expensive especially since it uses `FxHash`: it's better suited to short keys, not potentially\n-// big buffers like the allocation's init mask. We can partially hash some fields when they're\n-// large.\n-impl hash::Hash for InitMask {\n-    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n-        const MAX_BLOCKS_TO_HASH: usize = MAX_BYTES_TO_HASH / std::mem::size_of::<Block>();\n-        const MAX_BLOCKS_LEN: usize = MAX_HASHED_BUFFER_LEN / std::mem::size_of::<Block>();\n \n-        // Partially hash the `blocks` buffer when it is large. To limit collisions with common\n-        // prefixes and suffixes, we hash the length and some slices of the buffer.\n-        let block_count = self.blocks.len();\n-        if block_count > MAX_BLOCKS_LEN {\n-            // Hash the buffer's length.\n-            block_count.hash(state);\n-\n-            // And its head and tail.\n-            self.blocks[..MAX_BLOCKS_TO_HASH].hash(state);\n-            self.blocks[block_count - MAX_BLOCKS_TO_HASH..].hash(state);\n-        } else {\n-            self.blocks.hash(state);\n-        }\n-\n-        // Hash the other fields as usual.\n-        self.len.hash(state);\n-    }\n-}\n-\n-impl InitMask {\n-    pub const BLOCK_SIZE: u64 = 64;\n-\n-    #[inline]\n-    fn bit_index(bits: Size) -> (usize, usize) {\n-        // BLOCK_SIZE is the number of bits that can fit in a `Block`.\n-        // Each bit in a `Block` represents the initialization state of one byte of an allocation,\n-        // so we use `.bytes()` here.\n-        let bits = bits.bytes();\n-        let a = bits / InitMask::BLOCK_SIZE;\n-        let b = bits % InitMask::BLOCK_SIZE;\n-        (usize::try_from(a).unwrap(), usize::try_from(b).unwrap())\n-    }\n-\n-    #[inline]\n-    fn size_from_bit_index(block: impl TryInto<u64>, bit: impl TryInto<u64>) -> Size {\n-        let block = block.try_into().ok().unwrap();\n-        let bit = bit.try_into().ok().unwrap();\n-        Size::from_bytes(block * InitMask::BLOCK_SIZE + bit)\n-    }\n-\n-    pub fn new(size: Size, state: bool) -> Self {\n-        let mut m = InitMask { blocks: vec![], len: Size::ZERO };\n-        m.grow(size, state);\n-        m\n-    }\n-\n-    pub fn set_range(&mut self, start: Size, end: Size, new_state: bool) {\n-        let len = self.len;\n-        if end > len {\n-            self.grow(end - len, new_state);\n-        }\n-        self.set_range_inbounds(start, end, new_state);\n-    }\n-\n-    pub fn set_range_inbounds(&mut self, start: Size, end: Size, new_state: bool) {\n-        let (blocka, bita) = Self::bit_index(start);\n-        let (blockb, bitb) = Self::bit_index(end);\n-        if blocka == blockb {\n-            // First set all bits except the first `bita`,\n-            // then unset the last `64 - bitb` bits.\n-            let range = if bitb == 0 {\n-                u64::MAX << bita\n-            } else {\n-                (u64::MAX << bita) & (u64::MAX >> (64 - bitb))\n-            };\n-            if new_state {\n-                self.blocks[blocka] |= range;\n-            } else {\n-                self.blocks[blocka] &= !range;\n-            }\n-            return;\n-        }\n-        // across block boundaries\n-        if new_state {\n-            // Set `bita..64` to `1`.\n-            self.blocks[blocka] |= u64::MAX << bita;\n-            // Set `0..bitb` to `1`.\n-            if bitb != 0 {\n-                self.blocks[blockb] |= u64::MAX >> (64 - bitb);\n-            }\n-            // Fill in all the other blocks (much faster than one bit at a time).\n-            for block in (blocka + 1)..blockb {\n-                self.blocks[block] = u64::MAX;\n-            }\n-        } else {\n-            // Set `bita..64` to `0`.\n-            self.blocks[blocka] &= !(u64::MAX << bita);\n-            // Set `0..bitb` to `0`.\n-            if bitb != 0 {\n-                self.blocks[blockb] &= !(u64::MAX >> (64 - bitb));\n-            }\n-            // Fill in all the other blocks (much faster than one bit at a time).\n-            for block in (blocka + 1)..blockb {\n-                self.blocks[block] = 0;\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn get(&self, i: Size) -> bool {\n-        let (block, bit) = Self::bit_index(i);\n-        (self.blocks[block] & (1 << bit)) != 0\n-    }\n-\n-    #[inline]\n-    pub fn set(&mut self, i: Size, new_state: bool) {\n-        let (block, bit) = Self::bit_index(i);\n-        self.set_bit(block, bit, new_state);\n-    }\n-\n-    #[inline]\n-    fn set_bit(&mut self, block: usize, bit: usize, new_state: bool) {\n-        if new_state {\n-            self.blocks[block] |= 1 << bit;\n-        } else {\n-            self.blocks[block] &= !(1 << bit);\n-        }\n-    }\n-\n-    pub fn grow(&mut self, amount: Size, new_state: bool) {\n-        if amount.bytes() == 0 {\n-            return;\n-        }\n-        let unused_trailing_bits =\n-            u64::try_from(self.blocks.len()).unwrap() * Self::BLOCK_SIZE - self.len.bytes();\n-        if amount.bytes() > unused_trailing_bits {\n-            let additional_blocks = amount.bytes() / Self::BLOCK_SIZE + 1;\n-            self.blocks.extend(\n-                // FIXME(oli-obk): optimize this by repeating `new_state as Block`.\n-                iter::repeat(0).take(usize::try_from(additional_blocks).unwrap()),\n-            );\n-        }\n-        let start = self.len;\n-        self.len += amount;\n-        self.set_range_inbounds(start, start + amount, new_state); // `Size` operation\n-    }\n-\n-    /// Returns the index of the first bit in `start..end` (end-exclusive) that is equal to is_init.\n-    fn find_bit(&self, start: Size, end: Size, is_init: bool) -> Option<Size> {\n-        /// A fast implementation of `find_bit`,\n-        /// which skips over an entire block at a time if it's all 0s (resp. 1s),\n-        /// and finds the first 1 (resp. 0) bit inside a block using `trailing_zeros` instead of a loop.\n-        ///\n-        /// Note that all examples below are written with 8 (instead of 64) bit blocks for simplicity,\n-        /// and with the least significant bit (and lowest block) first:\n-        /// ```text\n-        ///        00000000|00000000\n-        ///        ^      ^ ^      ^\n-        /// index: 0      7 8      15\n-        /// ```\n-        /// Also, if not stated, assume that `is_init = true`, that is, we are searching for the first 1 bit.\n-        fn find_bit_fast(\n-            init_mask: &InitMask,\n-            start: Size,\n-            end: Size,\n-            is_init: bool,\n-        ) -> Option<Size> {\n-            /// Search one block, returning the index of the first bit equal to `is_init`.\n-            fn search_block(\n-                bits: Block,\n-                block: usize,\n-                start_bit: usize,\n-                is_init: bool,\n-            ) -> Option<Size> {\n-                // For the following examples, assume this function was called with:\n-                //   bits = 0b00111011\n-                //   start_bit = 3\n-                //   is_init = false\n-                // Note that, for the examples in this function, the most significant bit is written first,\n-                // which is backwards compared to the comments in `find_bit`/`find_bit_fast`.\n-\n-                // Invert bits so we're always looking for the first set bit.\n-                //        ! 0b00111011\n-                //   bits = 0b11000100\n-                let bits = if is_init { bits } else { !bits };\n-                // Mask off unused start bits.\n-                //          0b11000100\n-                //        & 0b11111000\n-                //   bits = 0b11000000\n-                let bits = bits & (!0 << start_bit);\n-                // Find set bit, if any.\n-                //   bit = trailing_zeros(0b11000000)\n-                //   bit = 6\n-                if bits == 0 {\n-                    None\n-                } else {\n-                    let bit = bits.trailing_zeros();\n-                    Some(InitMask::size_from_bit_index(block, bit))\n-                }\n-            }\n-\n-            if start >= end {\n-                return None;\n-            }\n-\n-            // Convert `start` and `end` to block indexes and bit indexes within each block.\n-            // We must convert `end` to an inclusive bound to handle block boundaries correctly.\n-            //\n-            // For example:\n-            //\n-            //   (a) 00000000|00000000    (b) 00000000|\n-            //       ^~~~~~~~~~~^             ^~~~~~~~~^\n-            //     start       end          start     end\n-            //\n-            // In both cases, the block index of `end` is 1.\n-            // But we do want to search block 1 in (a), and we don't in (b).\n-            //\n-            // We subtract 1 from both end positions to make them inclusive:\n-            //\n-            //   (a) 00000000|00000000    (b) 00000000|\n-            //       ^~~~~~~~~~^              ^~~~~~~^\n-            //     start    end_inclusive   start end_inclusive\n-            //\n-            // For (a), the block index of `end_inclusive` is 1, and for (b), it's 0.\n-            // This provides the desired behavior of searching blocks 0 and 1 for (a),\n-            // and searching only block 0 for (b).\n-            // There is no concern of overflows since we checked for `start >= end` above.\n-            let (start_block, start_bit) = InitMask::bit_index(start);\n-            let end_inclusive = Size::from_bytes(end.bytes() - 1);\n-            let (end_block_inclusive, _) = InitMask::bit_index(end_inclusive);\n-\n-            // Handle first block: need to skip `start_bit` bits.\n-            //\n-            // We need to handle the first block separately,\n-            // because there may be bits earlier in the block that should be ignored,\n-            // such as the bit marked (1) in this example:\n-            //\n-            //       (1)\n-            //       -|------\n-            //   (c) 01000000|00000000|00000001\n-            //          ^~~~~~~~~~~~~~~~~~^\n-            //        start              end\n-            if let Some(i) =\n-                search_block(init_mask.blocks[start_block], start_block, start_bit, is_init)\n-            {\n-                // If the range is less than a block, we may find a matching bit after `end`.\n-                //\n-                // For example, we shouldn't successfully find bit (2), because it's after `end`:\n-                //\n-                //             (2)\n-                //       -------|\n-                //   (d) 00000001|00000000|00000001\n-                //        ^~~~~^\n-                //      start end\n-                //\n-                // An alternative would be to mask off end bits in the same way as we do for start bits,\n-                // but performing this check afterwards is faster and simpler to implement.\n-                if i < end {\n-                    return Some(i);\n-                } else {\n-                    return None;\n-                }\n-            }\n-\n-            // Handle remaining blocks.\n-            //\n-            // We can skip over an entire block at once if it's all 0s (resp. 1s).\n-            // The block marked (3) in this example is the first block that will be handled by this loop,\n-            // and it will be skipped for that reason:\n-            //\n-            //                   (3)\n-            //                --------\n-            //   (e) 01000000|00000000|00000001\n-            //          ^~~~~~~~~~~~~~~~~~^\n-            //        start              end\n-            if start_block < end_block_inclusive {\n-                // This loop is written in a specific way for performance.\n-                // Notably: `..end_block_inclusive + 1` is used for an inclusive range instead of `..=end_block_inclusive`,\n-                // and `.zip(start_block + 1..)` is used to track the index instead of `.enumerate().skip().take()`,\n-                // because both alternatives result in significantly worse codegen.\n-                // `end_block_inclusive + 1` is guaranteed not to wrap, because `end_block_inclusive <= end / BLOCK_SIZE`,\n-                // and `BLOCK_SIZE` (the number of bits per block) will always be at least 8 (1 byte).\n-                for (&bits, block) in init_mask.blocks[start_block + 1..end_block_inclusive + 1]\n-                    .iter()\n-                    .zip(start_block + 1..)\n-                {\n-                    if let Some(i) = search_block(bits, block, 0, is_init) {\n-                        // If this is the last block, we may find a matching bit after `end`.\n-                        //\n-                        // For example, we shouldn't successfully find bit (4), because it's after `end`:\n-                        //\n-                        //                               (4)\n-                        //                         -------|\n-                        //   (f) 00000001|00000000|00000001\n-                        //          ^~~~~~~~~~~~~~~~~~^\n-                        //        start              end\n-                        //\n-                        // As above with example (d), we could handle the end block separately and mask off end bits,\n-                        // but unconditionally searching an entire block at once and performing this check afterwards\n-                        // is faster and much simpler to implement.\n-                        if i < end {\n-                            return Some(i);\n-                        } else {\n-                            return None;\n-                        }\n-                    }\n-                }\n-            }\n-\n-            None\n-        }\n-\n-        #[cfg_attr(not(debug_assertions), allow(dead_code))]\n-        fn find_bit_slow(\n-            init_mask: &InitMask,\n-            start: Size,\n-            end: Size,\n-            is_init: bool,\n-        ) -> Option<Size> {\n-            (start..end).find(|&i| init_mask.get(i) == is_init)\n-        }\n-\n-        let result = find_bit_fast(self, start, end, is_init);\n-\n-        debug_assert_eq!(\n-            result,\n-            find_bit_slow(self, start, end, is_init),\n-            \"optimized implementation of find_bit is wrong for start={:?} end={:?} is_init={} init_mask={:#?}\",\n-            start,\n-            end,\n-            is_init,\n-            self\n-        );\n-\n-        result\n-    }\n-}\n-\n-/// A contiguous chunk of initialized or uninitialized memory.\n-pub enum InitChunk {\n-    Init(Range<Size>),\n-    Uninit(Range<Size>),\n-}\n-\n-impl InitChunk {\n-    #[inline]\n-    pub fn is_init(&self) -> bool {\n-        match self {\n-            Self::Init(_) => true,\n-            Self::Uninit(_) => false,\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn range(&self) -> Range<Size> {\n-        match self {\n-            Self::Init(r) => r.clone(),\n-            Self::Uninit(r) => r.clone(),\n-        }\n-    }\n-}\n-\n-impl InitMask {\n-    /// Checks whether the range `start..end` (end-exclusive) is entirely initialized.\n-    ///\n-    /// Returns `Ok(())` if it's initialized. Otherwise returns a range of byte\n-    /// indexes for the first contiguous span of the uninitialized access.\n-    #[inline]\n-    pub fn is_range_initialized(&self, start: Size, end: Size) -> Result<(), AllocRange> {\n-        if end > self.len {\n-            return Err(AllocRange::from(self.len..end));\n-        }\n-\n-        let uninit_start = self.find_bit(start, end, false);\n-\n-        match uninit_start {\n-            Some(uninit_start) => {\n-                let uninit_end = self.find_bit(uninit_start, end, true).unwrap_or(end);\n-                Err(AllocRange::from(uninit_start..uninit_end))\n-            }\n-            None => Ok(()),\n-        }\n-    }\n-\n-    /// Returns an iterator, yielding a range of byte indexes for each contiguous region\n-    /// of initialized or uninitialized bytes inside the range `start..end` (end-exclusive).\n-    ///\n-    /// The iterator guarantees the following:\n-    /// - Chunks are nonempty.\n-    /// - Chunks are adjacent (each range's start is equal to the previous range's end).\n-    /// - Chunks span exactly `start..end` (the first starts at `start`, the last ends at `end`).\n-    /// - Chunks alternate between [`InitChunk::Init`] and [`InitChunk::Uninit`].\n-    #[inline]\n-    pub fn range_as_init_chunks(&self, start: Size, end: Size) -> InitChunkIter<'_> {\n-        assert!(end <= self.len);\n-\n-        let is_init = if start < end {\n-            self.get(start)\n-        } else {\n-            // `start..end` is empty: there are no chunks, so use some arbitrary value\n-            false\n-        };\n-\n-        InitChunkIter { init_mask: self, is_init, start, end }\n-    }\n-}\n-\n-/// Yields [`InitChunk`]s. See [`InitMask::range_as_init_chunks`].\n-#[derive(Clone)]\n-pub struct InitChunkIter<'a> {\n-    init_mask: &'a InitMask,\n-    /// Whether the next chunk we will return is initialized.\n-    /// If there are no more chunks, contains some arbitrary value.\n-    is_init: bool,\n-    /// The current byte index into `init_mask`.\n-    start: Size,\n-    /// The end byte index into `init_mask`.\n-    end: Size,\n-}\n-\n-impl<'a> Iterator for InitChunkIter<'a> {\n-    type Item = InitChunk;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<Self::Item> {\n-        if self.start >= self.end {\n-            return None;\n-        }\n-\n-        let end_of_chunk =\n-            self.init_mask.find_bit(self.start, self.end, !self.is_init).unwrap_or(self.end);\n-        let range = self.start..end_of_chunk;\n-\n-        let ret =\n-            Some(if self.is_init { InitChunk::Init(range) } else { InitChunk::Uninit(range) });\n-\n-        self.is_init = !self.is_init;\n-        self.start = end_of_chunk;\n-\n-        ret\n-    }\n-}\n-\n-/// Uninitialized bytes.\n-impl<Prov: Copy, Extra> Allocation<Prov, Extra> {\n-    /// Checks whether the given range  is entirely initialized.\n-    ///\n-    /// Returns `Ok(())` if it's initialized. Otherwise returns the range of byte\n-    /// indexes of the first contiguous uninitialized access.\n-    fn is_init(&self, range: AllocRange) -> Result<(), AllocRange> {\n-        self.init_mask.is_range_initialized(range.start, range.end()) // `Size` addition\n-    }\n-\n-    /// Checks that a range of bytes is initialized. If not, returns the `InvalidUninitBytes`\n-    /// error which will report the first range of bytes which is uninitialized.\n-    fn check_init(&self, range: AllocRange) -> AllocResult {\n-        self.is_init(range).map_err(|uninit_range| {\n-            AllocError::InvalidUninitBytes(Some(UninitBytesAccess {\n-                access: range,\n-                uninit: uninit_range,\n-            }))\n-        })\n-    }\n-\n-    fn mark_init(&mut self, range: AllocRange, is_init: bool) {\n-        if range.size.bytes() == 0 {\n-            return;\n-        }\n-        assert!(self.mutability == Mutability::Mut);\n-        self.init_mask.set_range(range.start, range.end(), is_init);\n-    }\n-}\n-\n-/// Run-length encoding of the uninit mask.\n-/// Used to copy parts of a mask multiple times to another allocation.\n-pub struct InitMaskCompressed {\n-    /// Whether the first range is initialized.\n-    initial: bool,\n-    /// The lengths of ranges that are run-length encoded.\n-    /// The initialization state of the ranges alternate starting with `initial`.\n-    ranges: smallvec::SmallVec<[u64; 1]>,\n-}\n-\n-impl InitMaskCompressed {\n-    pub fn no_bytes_init(&self) -> bool {\n-        // The `ranges` are run-length encoded and of alternating initialization state.\n-        // So if `ranges.len() > 1` then the second block is an initialized range.\n-        !self.initial && self.ranges.len() == 1\n-    }\n-}\n-\n-/// Transferring the initialization mask to other allocations.\n-impl<Prov, Extra> Allocation<Prov, Extra> {\n-    /// Creates a run-length encoding of the initialization mask; panics if range is empty.\n-    ///\n-    /// This is essentially a more space-efficient version of\n-    /// `InitMask::range_as_init_chunks(...).collect::<Vec<_>>()`.\n-    pub fn compress_uninit_range(&self, range: AllocRange) -> InitMaskCompressed {\n-        // Since we are copying `size` bytes from `src` to `dest + i * size` (`for i in 0..repeat`),\n-        // a naive initialization mask copying algorithm would repeatedly have to read the initialization mask from\n-        // the source and write it to the destination. Even if we optimized the memory accesses,\n-        // we'd be doing all of this `repeat` times.\n-        // Therefore we precompute a compressed version of the initialization mask of the source value and\n-        // then write it back `repeat` times without computing any more information from the source.\n-\n-        // A precomputed cache for ranges of initialized / uninitialized bits\n-        // 0000010010001110 will become\n-        // `[5, 1, 2, 1, 3, 3, 1]`,\n-        // where each element toggles the state.\n-\n-        let mut ranges = smallvec::SmallVec::<[u64; 1]>::new();\n-\n-        let mut chunks = self.init_mask.range_as_init_chunks(range.start, range.end()).peekable();\n-\n-        let initial = chunks.peek().expect(\"range should be nonempty\").is_init();\n-\n-        // Here we rely on `range_as_init_chunks` to yield alternating init/uninit chunks.\n-        for chunk in chunks {\n-            let len = chunk.range().end.bytes() - chunk.range().start.bytes();\n-            ranges.push(len);\n-        }\n-\n-        InitMaskCompressed { ranges, initial }\n-    }\n-\n-    /// Applies multiple instances of the run-length encoding to the initialization mask.\n+    /// Applies a previously prepared copy of the init mask.\n     ///\n     /// This is dangerous to use as it can violate internal `Allocation` invariants!\n     /// It only exists to support an efficient implementation of `mem_copy_repeatedly`.\n-    pub fn mark_compressed_init_range(\n-        &mut self,\n-        defined: &InitMaskCompressed,\n-        range: AllocRange,\n-        repeat: u64,\n-    ) {\n-        // An optimization where we can just overwrite an entire range of initialization\n-        // bits if they are going to be uniformly `1` or `0`.\n-        if defined.ranges.len() <= 1 {\n-            self.init_mask.set_range_inbounds(\n-                range.start,\n-                range.start + range.size * repeat, // `Size` operations\n-                defined.initial,\n-            );\n-            return;\n-        }\n-\n-        for mut j in 0..repeat {\n-            j *= range.size.bytes();\n-            j += range.start.bytes();\n-            let mut cur = defined.initial;\n-            for range in &defined.ranges {\n-                let old_j = j;\n-                j += range;\n-                self.init_mask.set_range_inbounds(\n-                    Size::from_bytes(old_j),\n-                    Size::from_bytes(j),\n-                    cur,\n-                );\n-                cur = !cur;\n-            }\n-        }\n+    pub fn init_mask_apply_copy(&mut self, copy: InitCopy, range: AllocRange, repeat: u64) {\n+        self.init_mask.apply_copy(copy, range, repeat)\n     }\n }"}, {"sha": "d88a0c19e5937a5ce804c0ca2162aa86183df0e6", "filename": "compiler/rustc_middle/src/mir/interpret/allocation/init_mask.rs", "status": "added", "additions": 530, "deletions": 0, "changes": 530, "blob_url": "https://github.com/rust-lang/rust/blob/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Finit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Finit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Finit_mask.rs?ref=a00f8ba7fcac1b27341679c51bf5a3271fa82df3", "patch": "@@ -0,0 +1,530 @@\n+use std::hash;\n+use std::iter;\n+use std::ops::Range;\n+\n+use rustc_target::abi::Size;\n+\n+use super::AllocRange;\n+\n+type Block = u64;\n+\n+/// A bitmask where each bit refers to the byte with the same index. If the bit is `true`, the byte\n+/// is initialized. If it is `false` the byte is uninitialized.\n+// Note: for performance reasons when interning, some of the `InitMask` fields can be partially\n+// hashed. (see the `Hash` impl below for more details), so the impl is not derived.\n+#[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, TyEncodable, TyDecodable)]\n+#[derive(HashStable)]\n+pub struct InitMask {\n+    blocks: Vec<Block>,\n+    len: Size,\n+}\n+\n+// Const allocations are only hashed for interning. However, they can be large, making the hashing\n+// expensive especially since it uses `FxHash`: it's better suited to short keys, not potentially\n+// big buffers like the allocation's init mask. We can partially hash some fields when they're\n+// large.\n+impl hash::Hash for InitMask {\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        const MAX_BLOCKS_TO_HASH: usize = super::MAX_BYTES_TO_HASH / std::mem::size_of::<Block>();\n+        const MAX_BLOCKS_LEN: usize = super::MAX_HASHED_BUFFER_LEN / std::mem::size_of::<Block>();\n+\n+        // Partially hash the `blocks` buffer when it is large. To limit collisions with common\n+        // prefixes and suffixes, we hash the length and some slices of the buffer.\n+        let block_count = self.blocks.len();\n+        if block_count > MAX_BLOCKS_LEN {\n+            // Hash the buffer's length.\n+            block_count.hash(state);\n+\n+            // And its head and tail.\n+            self.blocks[..MAX_BLOCKS_TO_HASH].hash(state);\n+            self.blocks[block_count - MAX_BLOCKS_TO_HASH..].hash(state);\n+        } else {\n+            self.blocks.hash(state);\n+        }\n+\n+        // Hash the other fields as usual.\n+        self.len.hash(state);\n+    }\n+}\n+\n+impl InitMask {\n+    pub const BLOCK_SIZE: u64 = 64;\n+\n+    pub fn new(size: Size, state: bool) -> Self {\n+        let mut m = InitMask { blocks: vec![], len: Size::ZERO };\n+        m.grow(size, state);\n+        m\n+    }\n+\n+    #[inline]\n+    fn bit_index(bits: Size) -> (usize, usize) {\n+        // BLOCK_SIZE is the number of bits that can fit in a `Block`.\n+        // Each bit in a `Block` represents the initialization state of one byte of an allocation,\n+        // so we use `.bytes()` here.\n+        let bits = bits.bytes();\n+        let a = bits / InitMask::BLOCK_SIZE;\n+        let b = bits % InitMask::BLOCK_SIZE;\n+        (usize::try_from(a).unwrap(), usize::try_from(b).unwrap())\n+    }\n+\n+    #[inline]\n+    fn size_from_bit_index(block: impl TryInto<u64>, bit: impl TryInto<u64>) -> Size {\n+        let block = block.try_into().ok().unwrap();\n+        let bit = bit.try_into().ok().unwrap();\n+        Size::from_bytes(block * InitMask::BLOCK_SIZE + bit)\n+    }\n+\n+    /// Checks whether the `range` is entirely initialized.\n+    ///\n+    /// Returns `Ok(())` if it's initialized. Otherwise returns a range of byte\n+    /// indexes for the first contiguous span of the uninitialized access.\n+    #[inline]\n+    pub fn is_range_initialized(&self, range: AllocRange) -> Result<(), AllocRange> {\n+        let end = range.end();\n+        if end > self.len {\n+            return Err(AllocRange::from(self.len..end));\n+        }\n+\n+        let uninit_start = self.find_bit(range.start, end, false);\n+\n+        match uninit_start {\n+            Some(uninit_start) => {\n+                let uninit_end = self.find_bit(uninit_start, end, true).unwrap_or(end);\n+                Err(AllocRange::from(uninit_start..uninit_end))\n+            }\n+            None => Ok(()),\n+        }\n+    }\n+\n+    pub fn set_range(&mut self, range: AllocRange, new_state: bool) {\n+        let end = range.end();\n+        let len = self.len;\n+        if end > len {\n+            self.grow(end - len, new_state);\n+        }\n+        self.set_range_inbounds(range.start, end, new_state);\n+    }\n+\n+    fn set_range_inbounds(&mut self, start: Size, end: Size, new_state: bool) {\n+        let (blocka, bita) = Self::bit_index(start);\n+        let (blockb, bitb) = Self::bit_index(end);\n+        if blocka == blockb {\n+            // First set all bits except the first `bita`,\n+            // then unset the last `64 - bitb` bits.\n+            let range = if bitb == 0 {\n+                u64::MAX << bita\n+            } else {\n+                (u64::MAX << bita) & (u64::MAX >> (64 - bitb))\n+            };\n+            if new_state {\n+                self.blocks[blocka] |= range;\n+            } else {\n+                self.blocks[blocka] &= !range;\n+            }\n+            return;\n+        }\n+        // across block boundaries\n+        if new_state {\n+            // Set `bita..64` to `1`.\n+            self.blocks[blocka] |= u64::MAX << bita;\n+            // Set `0..bitb` to `1`.\n+            if bitb != 0 {\n+                self.blocks[blockb] |= u64::MAX >> (64 - bitb);\n+            }\n+            // Fill in all the other blocks (much faster than one bit at a time).\n+            for block in (blocka + 1)..blockb {\n+                self.blocks[block] = u64::MAX;\n+            }\n+        } else {\n+            // Set `bita..64` to `0`.\n+            self.blocks[blocka] &= !(u64::MAX << bita);\n+            // Set `0..bitb` to `0`.\n+            if bitb != 0 {\n+                self.blocks[blockb] &= !(u64::MAX >> (64 - bitb));\n+            }\n+            // Fill in all the other blocks (much faster than one bit at a time).\n+            for block in (blocka + 1)..blockb {\n+                self.blocks[block] = 0;\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn get(&self, i: Size) -> bool {\n+        let (block, bit) = Self::bit_index(i);\n+        (self.blocks[block] & (1 << bit)) != 0\n+    }\n+\n+    fn grow(&mut self, amount: Size, new_state: bool) {\n+        if amount.bytes() == 0 {\n+            return;\n+        }\n+        let unused_trailing_bits =\n+            u64::try_from(self.blocks.len()).unwrap() * Self::BLOCK_SIZE - self.len.bytes();\n+        if amount.bytes() > unused_trailing_bits {\n+            let additional_blocks = amount.bytes() / Self::BLOCK_SIZE + 1;\n+            self.blocks.extend(\n+                // FIXME(oli-obk): optimize this by repeating `new_state as Block`.\n+                iter::repeat(0).take(usize::try_from(additional_blocks).unwrap()),\n+            );\n+        }\n+        let start = self.len;\n+        self.len += amount;\n+        self.set_range_inbounds(start, start + amount, new_state); // `Size` operation\n+    }\n+\n+    /// Returns the index of the first bit in `start..end` (end-exclusive) that is equal to is_init.\n+    fn find_bit(&self, start: Size, end: Size, is_init: bool) -> Option<Size> {\n+        /// A fast implementation of `find_bit`,\n+        /// which skips over an entire block at a time if it's all 0s (resp. 1s),\n+        /// and finds the first 1 (resp. 0) bit inside a block using `trailing_zeros` instead of a loop.\n+        ///\n+        /// Note that all examples below are written with 8 (instead of 64) bit blocks for simplicity,\n+        /// and with the least significant bit (and lowest block) first:\n+        /// ```text\n+        ///        00000000|00000000\n+        ///        ^      ^ ^      ^\n+        /// index: 0      7 8      15\n+        /// ```\n+        /// Also, if not stated, assume that `is_init = true`, that is, we are searching for the first 1 bit.\n+        fn find_bit_fast(\n+            init_mask: &InitMask,\n+            start: Size,\n+            end: Size,\n+            is_init: bool,\n+        ) -> Option<Size> {\n+            /// Search one block, returning the index of the first bit equal to `is_init`.\n+            fn search_block(\n+                bits: Block,\n+                block: usize,\n+                start_bit: usize,\n+                is_init: bool,\n+            ) -> Option<Size> {\n+                // For the following examples, assume this function was called with:\n+                //   bits = 0b00111011\n+                //   start_bit = 3\n+                //   is_init = false\n+                // Note that, for the examples in this function, the most significant bit is written first,\n+                // which is backwards compared to the comments in `find_bit`/`find_bit_fast`.\n+\n+                // Invert bits so we're always looking for the first set bit.\n+                //        ! 0b00111011\n+                //   bits = 0b11000100\n+                let bits = if is_init { bits } else { !bits };\n+                // Mask off unused start bits.\n+                //          0b11000100\n+                //        & 0b11111000\n+                //   bits = 0b11000000\n+                let bits = bits & (!0 << start_bit);\n+                // Find set bit, if any.\n+                //   bit = trailing_zeros(0b11000000)\n+                //   bit = 6\n+                if bits == 0 {\n+                    None\n+                } else {\n+                    let bit = bits.trailing_zeros();\n+                    Some(InitMask::size_from_bit_index(block, bit))\n+                }\n+            }\n+\n+            if start >= end {\n+                return None;\n+            }\n+\n+            // Convert `start` and `end` to block indexes and bit indexes within each block.\n+            // We must convert `end` to an inclusive bound to handle block boundaries correctly.\n+            //\n+            // For example:\n+            //\n+            //   (a) 00000000|00000000    (b) 00000000|\n+            //       ^~~~~~~~~~~^             ^~~~~~~~~^\n+            //     start       end          start     end\n+            //\n+            // In both cases, the block index of `end` is 1.\n+            // But we do want to search block 1 in (a), and we don't in (b).\n+            //\n+            // We subtract 1 from both end positions to make them inclusive:\n+            //\n+            //   (a) 00000000|00000000    (b) 00000000|\n+            //       ^~~~~~~~~~^              ^~~~~~~^\n+            //     start    end_inclusive   start end_inclusive\n+            //\n+            // For (a), the block index of `end_inclusive` is 1, and for (b), it's 0.\n+            // This provides the desired behavior of searching blocks 0 and 1 for (a),\n+            // and searching only block 0 for (b).\n+            // There is no concern of overflows since we checked for `start >= end` above.\n+            let (start_block, start_bit) = InitMask::bit_index(start);\n+            let end_inclusive = Size::from_bytes(end.bytes() - 1);\n+            let (end_block_inclusive, _) = InitMask::bit_index(end_inclusive);\n+\n+            // Handle first block: need to skip `start_bit` bits.\n+            //\n+            // We need to handle the first block separately,\n+            // because there may be bits earlier in the block that should be ignored,\n+            // such as the bit marked (1) in this example:\n+            //\n+            //       (1)\n+            //       -|------\n+            //   (c) 01000000|00000000|00000001\n+            //          ^~~~~~~~~~~~~~~~~~^\n+            //        start              end\n+            if let Some(i) =\n+                search_block(init_mask.blocks[start_block], start_block, start_bit, is_init)\n+            {\n+                // If the range is less than a block, we may find a matching bit after `end`.\n+                //\n+                // For example, we shouldn't successfully find bit (2), because it's after `end`:\n+                //\n+                //             (2)\n+                //       -------|\n+                //   (d) 00000001|00000000|00000001\n+                //        ^~~~~^\n+                //      start end\n+                //\n+                // An alternative would be to mask off end bits in the same way as we do for start bits,\n+                // but performing this check afterwards is faster and simpler to implement.\n+                if i < end {\n+                    return Some(i);\n+                } else {\n+                    return None;\n+                }\n+            }\n+\n+            // Handle remaining blocks.\n+            //\n+            // We can skip over an entire block at once if it's all 0s (resp. 1s).\n+            // The block marked (3) in this example is the first block that will be handled by this loop,\n+            // and it will be skipped for that reason:\n+            //\n+            //                   (3)\n+            //                --------\n+            //   (e) 01000000|00000000|00000001\n+            //          ^~~~~~~~~~~~~~~~~~^\n+            //        start              end\n+            if start_block < end_block_inclusive {\n+                // This loop is written in a specific way for performance.\n+                // Notably: `..end_block_inclusive + 1` is used for an inclusive range instead of `..=end_block_inclusive`,\n+                // and `.zip(start_block + 1..)` is used to track the index instead of `.enumerate().skip().take()`,\n+                // because both alternatives result in significantly worse codegen.\n+                // `end_block_inclusive + 1` is guaranteed not to wrap, because `end_block_inclusive <= end / BLOCK_SIZE`,\n+                // and `BLOCK_SIZE` (the number of bits per block) will always be at least 8 (1 byte).\n+                for (&bits, block) in init_mask.blocks[start_block + 1..end_block_inclusive + 1]\n+                    .iter()\n+                    .zip(start_block + 1..)\n+                {\n+                    if let Some(i) = search_block(bits, block, 0, is_init) {\n+                        // If this is the last block, we may find a matching bit after `end`.\n+                        //\n+                        // For example, we shouldn't successfully find bit (4), because it's after `end`:\n+                        //\n+                        //                               (4)\n+                        //                         -------|\n+                        //   (f) 00000001|00000000|00000001\n+                        //          ^~~~~~~~~~~~~~~~~~^\n+                        //        start              end\n+                        //\n+                        // As above with example (d), we could handle the end block separately and mask off end bits,\n+                        // but unconditionally searching an entire block at once and performing this check afterwards\n+                        // is faster and much simpler to implement.\n+                        if i < end {\n+                            return Some(i);\n+                        } else {\n+                            return None;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            None\n+        }\n+\n+        #[cfg_attr(not(debug_assertions), allow(dead_code))]\n+        fn find_bit_slow(\n+            init_mask: &InitMask,\n+            start: Size,\n+            end: Size,\n+            is_init: bool,\n+        ) -> Option<Size> {\n+            (start..end).find(|&i| init_mask.get(i) == is_init)\n+        }\n+\n+        let result = find_bit_fast(self, start, end, is_init);\n+\n+        debug_assert_eq!(\n+            result,\n+            find_bit_slow(self, start, end, is_init),\n+            \"optimized implementation of find_bit is wrong for start={:?} end={:?} is_init={} init_mask={:#?}\",\n+            start,\n+            end,\n+            is_init,\n+            self\n+        );\n+\n+        result\n+    }\n+}\n+\n+/// A contiguous chunk of initialized or uninitialized memory.\n+pub enum InitChunk {\n+    Init(Range<Size>),\n+    Uninit(Range<Size>),\n+}\n+\n+impl InitChunk {\n+    #[inline]\n+    pub fn is_init(&self) -> bool {\n+        match self {\n+            Self::Init(_) => true,\n+            Self::Uninit(_) => false,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn range(&self) -> Range<Size> {\n+        match self {\n+            Self::Init(r) => r.clone(),\n+            Self::Uninit(r) => r.clone(),\n+        }\n+    }\n+}\n+\n+impl InitMask {\n+    /// Returns an iterator, yielding a range of byte indexes for each contiguous region\n+    /// of initialized or uninitialized bytes inside the range `start..end` (end-exclusive).\n+    ///\n+    /// The iterator guarantees the following:\n+    /// - Chunks are nonempty.\n+    /// - Chunks are adjacent (each range's start is equal to the previous range's end).\n+    /// - Chunks span exactly `start..end` (the first starts at `start`, the last ends at `end`).\n+    /// - Chunks alternate between [`InitChunk::Init`] and [`InitChunk::Uninit`].\n+    #[inline]\n+    pub fn range_as_init_chunks(&self, range: AllocRange) -> InitChunkIter<'_> {\n+        let start = range.start;\n+        let end = range.end();\n+        assert!(end <= self.len);\n+\n+        let is_init = if start < end {\n+            self.get(start)\n+        } else {\n+            // `start..end` is empty: there are no chunks, so use some arbitrary value\n+            false\n+        };\n+\n+        InitChunkIter { init_mask: self, is_init, start, end }\n+    }\n+}\n+\n+/// Yields [`InitChunk`]s. See [`InitMask::range_as_init_chunks`].\n+#[derive(Clone)]\n+pub struct InitChunkIter<'a> {\n+    init_mask: &'a InitMask,\n+    /// Whether the next chunk we will return is initialized.\n+    /// If there are no more chunks, contains some arbitrary value.\n+    is_init: bool,\n+    /// The current byte index into `init_mask`.\n+    start: Size,\n+    /// The end byte index into `init_mask`.\n+    end: Size,\n+}\n+\n+impl<'a> Iterator for InitChunkIter<'a> {\n+    type Item = InitChunk;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if self.start >= self.end {\n+            return None;\n+        }\n+\n+        let end_of_chunk =\n+            self.init_mask.find_bit(self.start, self.end, !self.is_init).unwrap_or(self.end);\n+        let range = self.start..end_of_chunk;\n+\n+        let ret =\n+            Some(if self.is_init { InitChunk::Init(range) } else { InitChunk::Uninit(range) });\n+\n+        self.is_init = !self.is_init;\n+        self.start = end_of_chunk;\n+\n+        ret\n+    }\n+}\n+\n+/// Run-length encoding of the uninit mask.\n+/// Used to copy parts of a mask multiple times to another allocation.\n+pub struct InitCopy {\n+    /// Whether the first range is initialized.\n+    initial: bool,\n+    /// The lengths of ranges that are run-length encoded.\n+    /// The initialization state of the ranges alternate starting with `initial`.\n+    ranges: smallvec::SmallVec<[u64; 1]>,\n+}\n+\n+impl InitCopy {\n+    pub fn no_bytes_init(&self) -> bool {\n+        // The `ranges` are run-length encoded and of alternating initialization state.\n+        // So if `ranges.len() > 1` then the second block is an initialized range.\n+        !self.initial && self.ranges.len() == 1\n+    }\n+}\n+\n+/// Transferring the initialization mask to other allocations.\n+impl InitMask {\n+    /// Creates a run-length encoding of the initialization mask; panics if range is empty.\n+    ///\n+    /// This is essentially a more space-efficient version of\n+    /// `InitMask::range_as_init_chunks(...).collect::<Vec<_>>()`.\n+    pub fn prepare_copy(&self, range: AllocRange) -> InitCopy {\n+        // Since we are copying `size` bytes from `src` to `dest + i * size` (`for i in 0..repeat`),\n+        // a naive initialization mask copying algorithm would repeatedly have to read the initialization mask from\n+        // the source and write it to the destination. Even if we optimized the memory accesses,\n+        // we'd be doing all of this `repeat` times.\n+        // Therefore we precompute a compressed version of the initialization mask of the source value and\n+        // then write it back `repeat` times without computing any more information from the source.\n+\n+        // A precomputed cache for ranges of initialized / uninitialized bits\n+        // 0000010010001110 will become\n+        // `[5, 1, 2, 1, 3, 3, 1]`,\n+        // where each element toggles the state.\n+\n+        let mut ranges = smallvec::SmallVec::<[u64; 1]>::new();\n+\n+        let mut chunks = self.range_as_init_chunks(range).peekable();\n+\n+        let initial = chunks.peek().expect(\"range should be nonempty\").is_init();\n+\n+        // Here we rely on `range_as_init_chunks` to yield alternating init/uninit chunks.\n+        for chunk in chunks {\n+            let len = chunk.range().end.bytes() - chunk.range().start.bytes();\n+            ranges.push(len);\n+        }\n+\n+        InitCopy { ranges, initial }\n+    }\n+\n+    /// Applies multiple instances of the run-length encoding to the initialization mask.\n+    pub fn apply_copy(&mut self, defined: InitCopy, range: AllocRange, repeat: u64) {\n+        // An optimization where we can just overwrite an entire range of initialization\n+        // bits if they are going to be uniformly `1` or `0`.\n+        if defined.ranges.len() <= 1 {\n+            self.set_range_inbounds(\n+                range.start,\n+                range.start + range.size * repeat, // `Size` operations\n+                defined.initial,\n+            );\n+            return;\n+        }\n+\n+        for mut j in 0..repeat {\n+            j *= range.size.bytes();\n+            j += range.start.bytes();\n+            let mut cur = defined.initial;\n+            for range in &defined.ranges {\n+                let old_j = j;\n+                j += range;\n+                self.set_range_inbounds(Size::from_bytes(old_j), Size::from_bytes(j), cur);\n+                cur = !cur;\n+            }\n+        }\n+    }\n+}"}, {"sha": "19ee209e552d2343c191cc131a36714fb3467e18", "filename": "compiler/rustc_middle/src/mir/interpret/allocation/provenance_map.rs", "status": "added", "additions": 321, "deletions": 0, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Fprovenance_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Fprovenance_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Fprovenance_map.rs?ref=a00f8ba7fcac1b27341679c51bf5a3271fa82df3", "patch": "@@ -0,0 +1,321 @@\n+//! Store the provenance for each byte in the range, with a more efficient\n+//! representation for the common case where PTR_SIZE consecutive bytes have the same provenance.\n+\n+use std::cmp;\n+\n+use rustc_data_structures::sorted_map::SortedMap;\n+use rustc_target::abi::{HasDataLayout, Size};\n+\n+use super::{alloc_range, AllocError, AllocId, AllocRange, AllocResult, Provenance};\n+use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n+\n+/// Stores the provenance information of pointers stored in memory.\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[derive(HashStable)]\n+pub struct ProvenanceMap<Prov = AllocId> {\n+    /// Provenance in this map applies from the given offset for an entire pointer-size worth of\n+    /// bytes. Two entires in this map are always at least a pointer size apart.\n+    ptrs: SortedMap<Size, Prov>,\n+    /// Provenance in this map only applies to the given single byte.\n+    /// This map is disjoint from the previous. It will always be empty when\n+    /// `Prov::OFFSET_IS_ADDR` is false.\n+    bytes: Option<Box<SortedMap<Size, Prov>>>,\n+}\n+\n+impl<D: Decoder, Prov: Provenance + Decodable<D>> Decodable<D> for ProvenanceMap<Prov> {\n+    fn decode(d: &mut D) -> Self {\n+        assert!(!Prov::OFFSET_IS_ADDR); // only `AllocId` is ever serialized\n+        Self { ptrs: Decodable::decode(d), bytes: None }\n+    }\n+}\n+\n+impl<S: Encoder, Prov: Provenance + Encodable<S>> Encodable<S> for ProvenanceMap<Prov> {\n+    fn encode(&self, s: &mut S) {\n+        let Self { ptrs, bytes } = self;\n+        assert!(!Prov::OFFSET_IS_ADDR); // only `AllocId` is ever serialized\n+        debug_assert!(bytes.is_none());\n+        ptrs.encode(s)\n+    }\n+}\n+\n+impl<Prov> ProvenanceMap<Prov> {\n+    pub fn new() -> Self {\n+        ProvenanceMap { ptrs: SortedMap::new(), bytes: None }\n+    }\n+\n+    /// The caller must guarantee that the given provenance list is already sorted\n+    /// by address and contain no duplicates.\n+    pub fn from_presorted_ptrs(r: Vec<(Size, Prov)>) -> Self {\n+        ProvenanceMap { ptrs: SortedMap::from_presorted_elements(r), bytes: None }\n+    }\n+}\n+\n+impl ProvenanceMap {\n+    /// Give access to the ptr-sized provenances (which can also be thought of as relocations, and\n+    /// indeed that is how codegen treats them).\n+    ///\n+    /// Only exposed with `AllocId` provenance, since it panics if there is bytewise provenance.\n+    #[inline]\n+    pub fn ptrs(&self) -> &SortedMap<Size, AllocId> {\n+        debug_assert!(self.bytes.is_none()); // `AllocId::OFFSET_IS_ADDR` is false so this cannot fail\n+        &self.ptrs\n+    }\n+}\n+\n+impl<Prov: Provenance> ProvenanceMap<Prov> {\n+    /// Returns all ptr-sized provenance in the given range.\n+    /// If the range has length 0, returns provenance that crosses the edge between `start-1` and\n+    /// `start`.\n+    fn range_get_ptrs(&self, range: AllocRange, cx: &impl HasDataLayout) -> &[(Size, Prov)] {\n+        // We have to go back `pointer_size - 1` bytes, as that one would still overlap with\n+        // the beginning of this range.\n+        let adjusted_start = Size::from_bytes(\n+            range.start.bytes().saturating_sub(cx.data_layout().pointer_size.bytes() - 1),\n+        );\n+        self.ptrs.range(adjusted_start..range.end())\n+    }\n+\n+    /// Returns all byte-wise provenance in the given range.\n+    fn range_get_bytes(&self, range: AllocRange) -> &[(Size, Prov)] {\n+        if let Some(bytes) = self.bytes.as_ref() {\n+            bytes.range(range.start..range.end())\n+        } else {\n+            &[]\n+        }\n+    }\n+\n+    /// Get the provenance of a single byte.\n+    pub fn get(&self, offset: Size, cx: &impl HasDataLayout) -> Option<Prov> {\n+        let prov = self.range_get_ptrs(alloc_range(offset, Size::from_bytes(1)), cx);\n+        debug_assert!(prov.len() <= 1);\n+        if let Some(entry) = prov.first() {\n+            // If it overlaps with this byte, it is on this byte.\n+            debug_assert!(self.bytes.as_ref().map_or(true, |b| b.get(&offset).is_none()));\n+            Some(entry.1)\n+        } else {\n+            // Look up per-byte provenance.\n+            self.bytes.as_ref().and_then(|b| b.get(&offset).copied())\n+        }\n+    }\n+\n+    /// Check if here is ptr-sized provenance at the given index.\n+    /// Does not mean anything for bytewise provenance! But can be useful as an optimization.\n+    pub fn get_ptr(&self, offset: Size) -> Option<Prov> {\n+        self.ptrs.get(&offset).copied()\n+    }\n+\n+    /// Returns whether this allocation has provenance overlapping with the given range.\n+    ///\n+    /// Note: this function exists to allow `range_get_provenance` to be private, in order to somewhat\n+    /// limit access to provenance outside of the `Allocation` abstraction.\n+    ///\n+    pub fn range_empty(&self, range: AllocRange, cx: &impl HasDataLayout) -> bool {\n+        self.range_get_ptrs(range, cx).is_empty() && self.range_get_bytes(range).is_empty()\n+    }\n+\n+    /// Yields all the provenances stored in this map.\n+    pub fn provenances(&self) -> impl Iterator<Item = Prov> + '_ {\n+        let bytes = self.bytes.iter().flat_map(|b| b.values());\n+        self.ptrs.values().chain(bytes).copied()\n+    }\n+\n+    pub fn insert_ptr(&mut self, offset: Size, prov: Prov, cx: &impl HasDataLayout) {\n+        debug_assert!(self.range_empty(alloc_range(offset, cx.data_layout().pointer_size), cx));\n+        self.ptrs.insert(offset, prov);\n+    }\n+\n+    /// Removes all provenance inside the given range.\n+    /// If there is provenance overlapping with the edges, might result in an error.\n+    pub fn clear(&mut self, range: AllocRange, cx: &impl HasDataLayout) -> AllocResult {\n+        let start = range.start;\n+        let end = range.end();\n+        // Clear the bytewise part -- this is easy.\n+        if Prov::OFFSET_IS_ADDR {\n+            if let Some(bytes) = self.bytes.as_mut() {\n+                bytes.remove_range(start..end);\n+            }\n+        } else {\n+            debug_assert!(self.bytes.is_none());\n+        }\n+\n+        // For the ptr-sized part, find the first (inclusive) and last (exclusive) byte of\n+        // provenance that overlaps with the given range.\n+        let (first, last) = {\n+            // Find all provenance overlapping the given range.\n+            let provenance = self.range_get_ptrs(range, cx);\n+            if provenance.is_empty() {\n+                // No provenance in this range, we are done.\n+                return Ok(());\n+            }\n+\n+            (\n+                provenance.first().unwrap().0,\n+                provenance.last().unwrap().0 + cx.data_layout().pointer_size,\n+            )\n+        };\n+\n+        // We need to handle clearing the provenance from parts of a pointer.\n+        if first < start {\n+            if !Prov::OFFSET_IS_ADDR {\n+                // We can't split up the provenance into less than a pointer.\n+                return Err(AllocError::PartialPointerOverwrite(first));\n+            }\n+            // Insert the remaining part in the bytewise provenance.\n+            let prov = self.ptrs[&first];\n+            let bytes = self.bytes.get_or_insert_with(Box::default);\n+            for offset in first..start {\n+                bytes.insert(offset, prov);\n+            }\n+        }\n+        if last > end {\n+            let begin_of_last = last - cx.data_layout().pointer_size;\n+            if !Prov::OFFSET_IS_ADDR {\n+                // We can't split up the provenance into less than a pointer.\n+                return Err(AllocError::PartialPointerOverwrite(begin_of_last));\n+            }\n+            // Insert the remaining part in the bytewise provenance.\n+            let prov = self.ptrs[&begin_of_last];\n+            let bytes = self.bytes.get_or_insert_with(Box::default);\n+            for offset in end..last {\n+                bytes.insert(offset, prov);\n+            }\n+        }\n+\n+        // Forget all the provenance.\n+        // Since provenance do not overlap, we know that removing until `last` (exclusive) is fine,\n+        // i.e., this will not remove any other provenance just after the ones we care about.\n+        self.ptrs.remove_range(first..last);\n+\n+        Ok(())\n+    }\n+}\n+\n+/// A partial, owned list of provenance to transfer into another allocation.\n+///\n+/// Offsets are already adjusted to the destination allocation.\n+pub struct ProvenanceCopy<Prov> {\n+    dest_ptrs: Option<Box<[(Size, Prov)]>>,\n+    dest_bytes: Option<Box<[(Size, Prov)]>>,\n+}\n+\n+impl<Prov: Provenance> ProvenanceMap<Prov> {\n+    pub fn prepare_copy(\n+        &self,\n+        src: AllocRange,\n+        dest: Size,\n+        count: u64,\n+        cx: &impl HasDataLayout,\n+    ) -> AllocResult<ProvenanceCopy<Prov>> {\n+        let shift_offset = move |idx, offset| {\n+            // compute offset for current repetition\n+            let dest_offset = dest + src.size * idx; // `Size` operations\n+            // shift offsets from source allocation to destination allocation\n+            (offset - src.start) + dest_offset // `Size` operations\n+        };\n+        let ptr_size = cx.data_layout().pointer_size;\n+\n+        // # Pointer-sized provenances\n+        // Get the provenances that are entirely within this range.\n+        // (Different from `range_get_ptrs` which asks if they overlap the range.)\n+        // Only makes sense if we are copying at least one pointer worth of bytes.\n+        let mut dest_ptrs_box = None;\n+        if src.size >= ptr_size {\n+            let adjusted_end = Size::from_bytes(src.end().bytes() - (ptr_size.bytes() - 1));\n+            let ptrs = self.ptrs.range(src.start..adjusted_end);\n+            // If `count` is large, this is rather wasteful -- we are allocating a big array here, which\n+            // is mostly filled with redundant information since it's just N copies of the same `Prov`s\n+            // at slightly adjusted offsets. The reason we do this is so that in `mark_provenance_range`\n+            // we can use `insert_presorted`. That wouldn't work with an `Iterator` that just produces\n+            // the right sequence of provenance for all N copies.\n+            // Basically, this large array would have to be created anyway in the target allocation.\n+            let mut dest_ptrs = Vec::with_capacity(ptrs.len() * (count as usize));\n+            for i in 0..count {\n+                dest_ptrs\n+                    .extend(ptrs.iter().map(|&(offset, reloc)| (shift_offset(i, offset), reloc)));\n+            }\n+            debug_assert_eq!(dest_ptrs.len(), dest_ptrs.capacity());\n+            dest_ptrs_box = Some(dest_ptrs.into_boxed_slice());\n+        };\n+\n+        // # Byte-sized provenances\n+        // This includes the existing bytewise provenance in the range, and ptr provenance\n+        // that overlaps with the begin/end of the range.\n+        let mut dest_bytes_box = None;\n+        let begin_overlap = self.range_get_ptrs(alloc_range(src.start, Size::ZERO), cx).first();\n+        let end_overlap = self.range_get_ptrs(alloc_range(src.end(), Size::ZERO), cx).first();\n+        if !Prov::OFFSET_IS_ADDR {\n+            // There can't be any bytewise provenance, and we cannot split up the begin/end overlap.\n+            if let Some(entry) = begin_overlap {\n+                return Err(AllocError::PartialPointerCopy(entry.0));\n+            }\n+            if let Some(entry) = end_overlap {\n+                return Err(AllocError::PartialPointerCopy(entry.0));\n+            }\n+            debug_assert!(self.bytes.is_none());\n+        } else {\n+            let mut bytes = Vec::new();\n+            // First, if there is a part of a pointer at the start, add that.\n+            if let Some(entry) = begin_overlap {\n+                trace!(\"start overlapping entry: {entry:?}\");\n+                // For really small copies, make sure we don't run off the end of the `src` range.\n+                let entry_end = cmp::min(entry.0 + ptr_size, src.end());\n+                for offset in src.start..entry_end {\n+                    bytes.push((offset, entry.1));\n+                }\n+            } else {\n+                trace!(\"no start overlapping entry\");\n+            }\n+            // Then the main part, bytewise provenance from `self.bytes`.\n+            if let Some(all_bytes) = self.bytes.as_ref() {\n+                bytes.extend(all_bytes.range(src.start..src.end()));\n+            }\n+            // And finally possibly parts of a pointer at the end.\n+            if let Some(entry) = end_overlap {\n+                trace!(\"end overlapping entry: {entry:?}\");\n+                // For really small copies, make sure we don't start before `src` does.\n+                let entry_start = cmp::max(entry.0, src.start);\n+                for offset in entry_start..src.end() {\n+                    if bytes.last().map_or(true, |bytes_entry| bytes_entry.0 < offset) {\n+                        // The last entry, if it exists, has a lower offset than us.\n+                        bytes.push((offset, entry.1));\n+                    } else {\n+                        // There already is an entry for this offset in there! This can happen when the\n+                        // start and end range checks actually end up hitting the same pointer, so we\n+                        // already added this in the \"pointer at the start\" part above.\n+                        assert!(entry.0 <= src.start);\n+                    }\n+                }\n+            } else {\n+                trace!(\"no end overlapping entry\");\n+            }\n+            trace!(\"byte provenances: {bytes:?}\");\n+\n+            // And again a buffer for the new list on the target side.\n+            let mut dest_bytes = Vec::with_capacity(bytes.len() * (count as usize));\n+            for i in 0..count {\n+                dest_bytes\n+                    .extend(bytes.iter().map(|&(offset, reloc)| (shift_offset(i, offset), reloc)));\n+            }\n+            debug_assert_eq!(dest_bytes.len(), dest_bytes.capacity());\n+            dest_bytes_box = Some(dest_bytes.into_boxed_slice());\n+        }\n+\n+        Ok(ProvenanceCopy { dest_ptrs: dest_ptrs_box, dest_bytes: dest_bytes_box })\n+    }\n+\n+    /// Applies a provenance copy.\n+    /// The affected range, as defined in the parameters to `prepare_copy` is expected\n+    /// to be clear of provenance.\n+    pub fn apply_copy(&mut self, copy: ProvenanceCopy<Prov>) {\n+        if let Some(dest_ptrs) = copy.dest_ptrs {\n+            self.ptrs.insert_presorted(dest_ptrs.into());\n+        }\n+        if Prov::OFFSET_IS_ADDR {\n+            if let Some(dest_bytes) = copy.dest_bytes && !dest_bytes.is_empty() {\n+                self.bytes.get_or_insert_with(Box::default).insert_presorted(dest_bytes.into());\n+            }\n+        } else {\n+            debug_assert!(copy.dest_bytes.is_none());\n+        }\n+    }\n+}"}, {"sha": "c9c3c50c5371e92be300050e09a213dc2defca4b", "filename": "compiler/rustc_middle/src/mir/interpret/allocation/tests.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Ftests.rs?ref=a00f8ba7fcac1b27341679c51bf5a3271fa82df3", "patch": "@@ -0,0 +1,19 @@\n+use super::*;\n+\n+#[test]\n+fn uninit_mask() {\n+    let mut mask = InitMask::new(Size::from_bytes(500), false);\n+    assert!(!mask.get(Size::from_bytes(499)));\n+    mask.set_range(alloc_range(Size::from_bytes(499), Size::from_bytes(1)), true);\n+    assert!(mask.get(Size::from_bytes(499)));\n+    mask.set_range((100..256).into(), true);\n+    for i in 0..100 {\n+        assert!(!mask.get(Size::from_bytes(i)), \"{i} should not be set\");\n+    }\n+    for i in 100..256 {\n+        assert!(mask.get(Size::from_bytes(i)), \"{i} should be set\");\n+    }\n+    for i in 256..499 {\n+        assert!(!mask.get(Size::from_bytes(i)), \"{i} should not be set\");\n+    }\n+}"}, {"sha": "1ea8baa3cae3c95319309b2d31437b3bb4242a2f", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=a00f8ba7fcac1b27341679c51bf5a3271fa82df3", "patch": "@@ -401,16 +401,15 @@ impl fmt::Display for UndefinedBehaviorInfo {\n pub enum UnsupportedOpInfo {\n     /// Free-form case. Only for errors that are never caught!\n     Unsupported(String),\n-    /// Overwriting parts of a pointer; the resulting state cannot be represented in our\n-    /// `Allocation` data structure. See <https://github.com/rust-lang/miri/issues/2181>.\n-    PartialPointerOverwrite(Pointer<AllocId>),\n-    /// Attempting to `copy` parts of a pointer to somewhere else; the resulting state cannot be\n-    /// represented in our `Allocation` data structure. See\n-    /// <https://github.com/rust-lang/miri/issues/2181>.\n-    PartialPointerCopy(Pointer<AllocId>),\n     //\n     // The variants below are only reachable from CTFE/const prop, miri will never emit them.\n     //\n+    /// Overwriting parts of a pointer; without knowing absolute addresses, the resulting state\n+    /// cannot be represented by the CTFE interpreter.\n+    PartialPointerOverwrite(Pointer<AllocId>),\n+    /// Attempting to `copy` parts of a pointer to somewhere else; without knowing absolute\n+    /// addresses, the resulting state cannot be represented by the CTFE interpreter.\n+    PartialPointerCopy(Pointer<AllocId>),\n     /// Encountered a pointer where we needed raw bytes.\n     ReadPointerAsBytes,\n     /// Accessing thread local statics"}, {"sha": "d79cd8b7a8a4b075c4bfdcc30a5379141d6bc385", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=a00f8ba7fcac1b27341679c51bf5a3271fa82df3", "patch": "@@ -128,8 +128,8 @@ pub use self::error::{\n pub use self::value::{get_slice_bytes, ConstAlloc, ConstValue, Scalar};\n \n pub use self::allocation::{\n-    alloc_range, AllocRange, Allocation, ConstAllocation, InitChunk, InitChunkIter, InitMask,\n-    ProvenanceMap,\n+    alloc_range, AllocError, AllocRange, AllocResult, Allocation, ConstAllocation, InitChunk,\n+    InitChunkIter,\n };\n \n pub use self::pointer::{Pointer, PointerArithmetic, Provenance};"}, {"sha": "4e59f1b24821643263b294a83f75b84e0c07144f", "filename": "compiler/rustc_middle/src/mir/interpret/pointer.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs?ref=a00f8ba7fcac1b27341679c51bf5a3271fa82df3", "patch": "@@ -103,8 +103,7 @@ impl<T: HasDataLayout> PointerArithmetic for T {}\n /// This trait abstracts over the kind of provenance that is associated with a `Pointer`. It is\n /// mostly opaque; the `Machine` trait extends it with some more operations that also have access to\n /// some global state.\n-/// We don't actually care about this `Debug` bound (we use `Provenance::fmt` to format the entire\n-/// pointer), but `derive` adds some unnecessary bounds.\n+/// The `Debug` rendering is used to distplay bare provenance, and for the default impl of `fmt`.\n pub trait Provenance: Copy + fmt::Debug {\n     /// Says whether the `offset` field of `Pointer`s with this provenance is the actual physical address.\n     /// - If `false`, the offset *must* be relative. This means the bytes representing a pointer are\n@@ -115,14 +114,23 @@ pub trait Provenance: Copy + fmt::Debug {\n     ///   pointer, and implement ptr-to-int transmutation by stripping provenance.\n     const OFFSET_IS_ADDR: bool;\n \n-    /// We also use this trait to control whether to abort execution when a pointer is being partially overwritten\n-    /// (this avoids a separate trait in `allocation.rs` just for this purpose).\n-    const ERR_ON_PARTIAL_PTR_OVERWRITE: bool;\n-\n     /// Determines how a pointer should be printed.\n+    ///\n+    /// Default impl is only good for when `OFFSET_IS_ADDR == true`.\n     fn fmt(ptr: &Pointer<Self>, f: &mut fmt::Formatter<'_>) -> fmt::Result\n     where\n-        Self: Sized;\n+        Self: Sized,\n+    {\n+        assert!(Self::OFFSET_IS_ADDR);\n+        let (prov, addr) = ptr.into_parts(); // address is absolute\n+        write!(f, \"{:#x}\", addr.bytes())?;\n+        if f.alternate() {\n+            write!(f, \"{prov:#?}\")?;\n+        } else {\n+            write!(f, \"{prov:?}\")?;\n+        }\n+        Ok(())\n+    }\n \n     /// If `OFFSET_IS_ADDR == false`, provenance must always be able to\n     /// identify the allocation this ptr points to (i.e., this must return `Some`).\n@@ -139,9 +147,6 @@ impl Provenance for AllocId {\n     // so ptr-to-int casts are not possible (since we do not know the global physical offset).\n     const OFFSET_IS_ADDR: bool = false;\n \n-    // For now, do not allow this, so that we keep our options open.\n-    const ERR_ON_PARTIAL_PTR_OVERWRITE: bool = true;\n-\n     fn fmt(ptr: &Pointer<Self>, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // Forward `alternate` flag to `alloc_id` printing.\n         if f.alternate() {"}, {"sha": "2b3f2c024118977f7e70ad72d16bf59de4221dc1", "filename": "compiler/rustc_middle/src/mir/pretty.rs", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs?ref=a00f8ba7fcac1b27341679c51bf5a3271fa82df3", "patch": "@@ -12,8 +12,8 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::DefId;\n use rustc_index::vec::Idx;\n use rustc_middle::mir::interpret::{\n-    read_target_uint, AllocId, Allocation, ConstAllocation, ConstValue, GlobalAlloc, Pointer,\n-    Provenance,\n+    alloc_range, read_target_uint, AllocId, Allocation, ConstAllocation, ConstValue, GlobalAlloc,\n+    Pointer, Provenance,\n };\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::MirSource;\n@@ -685,7 +685,7 @@ pub fn write_allocations<'tcx>(\n     fn alloc_ids_from_alloc(\n         alloc: ConstAllocation<'_>,\n     ) -> impl DoubleEndedIterator<Item = AllocId> + '_ {\n-        alloc.inner().provenance().values().map(|id| *id)\n+        alloc.inner().provenance().ptrs().values().map(|id| *id)\n     }\n \n     fn alloc_ids_from_const_val(val: ConstValue<'_>) -> impl Iterator<Item = AllocId> + '_ {\n@@ -788,15 +788,15 @@ pub fn write_allocations<'tcx>(\n /// After the hex dump, an ascii dump follows, replacing all unprintable characters (control\n /// characters or characters whose value is larger than 127) with a `.`\n /// This also prints provenance adequately.\n-pub fn display_allocation<'a, 'tcx, Prov, Extra>(\n+pub fn display_allocation<'a, 'tcx, Prov: Provenance, Extra>(\n     tcx: TyCtxt<'tcx>,\n     alloc: &'a Allocation<Prov, Extra>,\n ) -> RenderAllocation<'a, 'tcx, Prov, Extra> {\n     RenderAllocation { tcx, alloc }\n }\n \n #[doc(hidden)]\n-pub struct RenderAllocation<'a, 'tcx, Prov, Extra> {\n+pub struct RenderAllocation<'a, 'tcx, Prov: Provenance, Extra> {\n     tcx: TyCtxt<'tcx>,\n     alloc: &'a Allocation<Prov, Extra>,\n }\n@@ -882,9 +882,9 @@ fn write_allocation_bytes<'tcx, Prov: Provenance, Extra>(\n         if i != line_start {\n             write!(w, \" \")?;\n         }\n-        if let Some(&prov) = alloc.provenance().get(&i) {\n+        if let Some(prov) = alloc.provenance().get_ptr(i) {\n             // Memory with provenance must be defined\n-            assert!(alloc.init_mask().is_range_initialized(i, i + ptr_size).is_ok());\n+            assert!(alloc.init_mask().is_range_initialized(alloc_range(i, ptr_size)).is_ok());\n             let j = i.bytes_usize();\n             let offset = alloc\n                 .inspect_with_uninit_and_ptr_outside_interpreter(j..j + ptr_size.bytes_usize());\n@@ -904,9 +904,9 @@ fn write_allocation_bytes<'tcx, Prov: Provenance, Extra>(\n                 let overflow = ptr_size - remainder;\n                 let remainder_width = provenance_width(remainder.bytes_usize()) - 2;\n                 let overflow_width = provenance_width(overflow.bytes_usize() - 1) + 1;\n-                ascii.push('\u257e');\n-                for _ in 0..remainder.bytes() - 1 {\n-                    ascii.push('\u2500');\n+                ascii.push('\u257e'); // HEAVY LEFT AND LIGHT RIGHT\n+                for _ in 1..remainder.bytes() {\n+                    ascii.push('\u2500'); // LIGHT HORIZONTAL\n                 }\n                 if overflow_width > remainder_width && overflow_width >= target.len() {\n                     // The case where the provenance fits into the part in the next line\n@@ -926,7 +926,7 @@ fn write_allocation_bytes<'tcx, Prov: Provenance, Extra>(\n                 for _ in 0..overflow.bytes() - 1 {\n                     ascii.push('\u2500');\n                 }\n-                ascii.push('\u257c');\n+                ascii.push('\u257c'); // LIGHT LEFT AND HEAVY RIGHT\n                 i += ptr_size;\n                 continue;\n             } else {\n@@ -941,7 +941,23 @@ fn write_allocation_bytes<'tcx, Prov: Provenance, Extra>(\n                 ascii.push('\u257c');\n                 i += ptr_size;\n             }\n-        } else if alloc.init_mask().is_range_initialized(i, i + Size::from_bytes(1)).is_ok() {\n+        } else if let Some(prov) = alloc.provenance().get(i, &tcx) {\n+            // Memory with provenance must be defined\n+            assert!(\n+                alloc.init_mask().is_range_initialized(alloc_range(i, Size::from_bytes(1))).is_ok()\n+            );\n+            ascii.push('\u2501'); // HEAVY HORIZONTAL\n+            // We have two characters to display this, which is obviously not enough.\n+            // Format is similar to \"oversized\" above.\n+            let j = i.bytes_usize();\n+            let c = alloc.inspect_with_uninit_and_ptr_outside_interpreter(j..j + 1)[0];\n+            write!(w, \"\u257e{:02x}{:#?} (1 ptr byte)\u257c\", c, prov)?;\n+            i += Size::from_bytes(1);\n+        } else if alloc\n+            .init_mask()\n+            .is_range_initialized(alloc_range(i, Size::from_bytes(1)))\n+            .is_ok()\n+        {\n             let j = i.bytes_usize();\n \n             // Checked definedness (and thus range) and provenance. This access also doesn't"}, {"sha": "3e59c0b967c3d8a6fd00cca0aab858108760467f", "filename": "compiler/rustc_middle/src/ty/impls_ty.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs?ref=a00f8ba7fcac1b27341679c51bf5a3271fa82df3", "patch": "@@ -112,19 +112,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::AllocId {\n     }\n }\n \n-// `Relocations` with default type parameters is a sorted map.\n-impl<'a, Prov> HashStable<StableHashingContext<'a>> for mir::interpret::ProvenanceMap<Prov>\n-where\n-    Prov: HashStable<StableHashingContext<'a>>,\n-{\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        self.len().hash_stable(hcx, hasher);\n-        for reloc in self.iter() {\n-            reloc.hash_stable(hcx, hasher);\n-        }\n-    }\n-}\n-\n impl<'a> ToStableHashKey<StableHashingContext<'a>> for region::Scope {\n     type KeyType = region::Scope;\n "}, {"sha": "9b9f942b491a2e8c9f0acb8a43776a231bb707a9", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=a00f8ba7fcac1b27341679c51bf5a3271fa82df3", "patch": "@@ -266,7 +266,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         _tcx: TyCtxt<'tcx>,\n         _machine: &Self,\n         _alloc_id: AllocId,\n-        alloc: ConstAllocation<'tcx, Self::Provenance, Self::AllocExtra>,\n+        alloc: ConstAllocation<'tcx>,\n         _static_def_id: Option<DefId>,\n         is_write: bool,\n     ) -> InterpResult<'tcx> {"}, {"sha": "e296d4766c18b8e2624e3874156739323f0fe2ce", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=a00f8ba7fcac1b27341679c51bf5a3271fa82df3", "patch": "@@ -456,7 +456,7 @@ fn collect_items_rec<'tcx>(\n             recursion_depth_reset = None;\n \n             if let Ok(alloc) = tcx.eval_static_initializer(def_id) {\n-                for &id in alloc.inner().provenance().values() {\n+                for &id in alloc.inner().provenance().ptrs().values() {\n                     collect_miri(tcx, id, &mut neighbors);\n                 }\n             }\n@@ -1404,7 +1404,7 @@ fn collect_miri<'tcx>(tcx: TyCtxt<'tcx>, alloc_id: AllocId, output: &mut MonoIte\n         }\n         GlobalAlloc::Memory(alloc) => {\n             trace!(\"collecting {:?} with {:#?}\", alloc_id, alloc);\n-            for &inner in alloc.inner().provenance().values() {\n+            for &inner in alloc.inner().provenance().ptrs().values() {\n                 rustc_data_structures::stack::ensure_sufficient_stack(|| {\n                     collect_miri(tcx, inner, output);\n                 });\n@@ -1443,7 +1443,7 @@ fn collect_const_value<'tcx>(\n     match value {\n         ConstValue::Scalar(Scalar::Ptr(ptr, _size)) => collect_miri(tcx, ptr.provenance, output),\n         ConstValue::Slice { data: alloc, start: _, end: _ } | ConstValue::ByRef { alloc, .. } => {\n-            for &id in alloc.inner().provenance().values() {\n+            for &id in alloc.inner().provenance().ptrs().values() {\n                 collect_miri(tcx, id, output);\n             }\n         }"}, {"sha": "ec35914f1e3b5a9fe8878902d09aaa9c5f25d607", "filename": "library/core/src/mem/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs?ref=a00f8ba7fcac1b27341679c51bf5a3271fa82df3", "patch": "@@ -725,10 +725,7 @@ pub const fn swap<T>(x: &mut T, y: &mut T) {\n     // understanding `mem::replace`, `Option::take`, etc. - a better overall\n     // solution might be to make `ptr::swap_nonoverlapping` into an intrinsic, which\n     // a backend can choose to implement using the block optimization, or not.\n-    // NOTE(scottmcm) MIRI is disabled here as reading in smaller units is a\n-    // pessimization for it.  Also, if the type contains any unaligned pointers,\n-    // copying those over multiple reads is difficult to support.\n-    #[cfg(not(any(target_arch = \"spirv\", miri)))]\n+    #[cfg(not(any(target_arch = \"spirv\")))]\n     {\n         // For types that are larger multiples of their alignment, the simple way\n         // tends to copy the whole thing to stack rather than doing it one part"}, {"sha": "9d4bae3eaa5f7c11b4b12ff67aad5f49756f80d8", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=a00f8ba7fcac1b27341679c51bf5a3271fa82df3", "patch": "@@ -908,21 +908,15 @@ pub const unsafe fn swap_nonoverlapping<T>(x: *mut T, y: *mut T, count: usize) {\n         );\n     }\n \n-    // NOTE(scottmcm) Miri is disabled here as reading in smaller units is a\n-    // pessimization for it.  Also, if the type contains any unaligned pointers,\n-    // copying those over multiple reads is difficult to support.\n-    #[cfg(not(miri))]\n+    // Split up the slice into small power-of-two-sized chunks that LLVM is able\n+    // to vectorize (unless it's a special type with more-than-pointer alignment,\n+    // because we don't want to pessimize things like slices of SIMD vectors.)\n+    if mem::align_of::<T>() <= mem::size_of::<usize>()\n+        && (!mem::size_of::<T>().is_power_of_two()\n+            || mem::size_of::<T>() > mem::size_of::<usize>() * 2)\n     {\n-        // Split up the slice into small power-of-two-sized chunks that LLVM is able\n-        // to vectorize (unless it's a special type with more-than-pointer alignment,\n-        // because we don't want to pessimize things like slices of SIMD vectors.)\n-        if mem::align_of::<T>() <= mem::size_of::<usize>()\n-            && (!mem::size_of::<T>().is_power_of_two()\n-                || mem::size_of::<T>() > mem::size_of::<usize>() * 2)\n-        {\n-            attempt_swap_as_chunks!(usize);\n-            attempt_swap_as_chunks!(u8);\n-        }\n+        attempt_swap_as_chunks!(usize);\n+        attempt_swap_as_chunks!(u8);\n     }\n \n     // SAFETY: Same preconditions as this function"}, {"sha": "84ce291016aafbeee2d614356b5f0e841b4aeb2c", "filename": "src/test/ui-fulldeps/uninit_mask.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6d651a295e0e0c331153288b10b78344a4ede20b/src%2Ftest%2Fui-fulldeps%2Funinit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d651a295e0e0c331153288b10b78344a4ede20b/src%2Ftest%2Fui-fulldeps%2Funinit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Funinit_mask.rs?ref=6d651a295e0e0c331153288b10b78344a4ede20b", "patch": "@@ -1,28 +0,0 @@\n-// run-pass\n-// ignore-cross-compile\n-// ignore-stage1\n-\n-#![feature(rustc_private)]\n-\n-extern crate rustc_middle;\n-extern crate rustc_target;\n-\n-use rustc_middle::mir::interpret::InitMask;\n-use rustc_target::abi::Size;\n-\n-fn main() {\n-    let mut mask = InitMask::new(Size::from_bytes(500), false);\n-    assert!(!mask.get(Size::from_bytes(499)));\n-    mask.set(Size::from_bytes(499), true);\n-    assert!(mask.get(Size::from_bytes(499)));\n-    mask.set_range_inbounds(Size::from_bytes(100), Size::from_bytes(256), true);\n-    for i in 0..100 {\n-        assert!(!mask.get(Size::from_bytes(i)));\n-    }\n-    for i in 100..256 {\n-        assert!(mask.get(Size::from_bytes(i)));\n-    }\n-    for i in 256..499 {\n-        assert!(!mask.get(Size::from_bytes(i)));\n-    }\n-}"}, {"sha": "0cfa3812e400de351e96b8d07d1fb8c9e3f39bce", "filename": "src/tools/miri/src/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs?ref=a00f8ba7fcac1b27341679c51bf5a3271fa82df3", "patch": "@@ -229,13 +229,13 @@ pub fn report_error<'tcx, 'mir>(\n                 Unsupported(\n                     UnsupportedOpInfo::ThreadLocalStatic(_) |\n                     UnsupportedOpInfo::ReadExternStatic(_) |\n-                    UnsupportedOpInfo::PartialPointerOverwrite(_) | // we make memory uninit instead\n+                    UnsupportedOpInfo::PartialPointerOverwrite(_) |\n+                    UnsupportedOpInfo::PartialPointerCopy(_) |\n                     UnsupportedOpInfo::ReadPointerAsBytes\n                 ) =>\n                     panic!(\"Error should never be raised by Miri: {kind:?}\", kind = e.kind()),\n                 Unsupported(\n-                    UnsupportedOpInfo::Unsupported(_) |\n-                    UnsupportedOpInfo::PartialPointerCopy(_)\n+                    UnsupportedOpInfo::Unsupported(_)\n                 ) =>\n                     vec![(None, format!(\"this is likely not a bug in the program; it indicates that the program performed an operation that the interpreter does not support\"))],\n                 UndefinedBehavior(UndefinedBehaviorInfo::AlignmentCheckFailed { .. })"}, {"sha": "5887d26462ba2751135c5a5aa810f9477be64f87", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=a00f8ba7fcac1b27341679c51bf5a3271fa82df3", "patch": "@@ -133,7 +133,7 @@ impl fmt::Display for MiriMemoryKind {\n }\n \n /// Pointer provenance.\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Clone, Copy)]\n pub enum Provenance {\n     Concrete {\n         alloc_id: AllocId,\n@@ -176,18 +176,9 @@ static_assert_size!(Pointer<Provenance>, 24);\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n static_assert_size!(Scalar<Provenance>, 32);\n \n-impl interpret::Provenance for Provenance {\n-    /// We use absolute addresses in the `offset` of a `Pointer<Provenance>`.\n-    const OFFSET_IS_ADDR: bool = true;\n-\n-    /// We cannot err on partial overwrites, it happens too often in practice (due to unions).\n-    const ERR_ON_PARTIAL_PTR_OVERWRITE: bool = false;\n-\n-    fn fmt(ptr: &Pointer<Self>, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let (prov, addr) = ptr.into_parts(); // address is absolute\n-        write!(f, \"{:#x}\", addr.bytes())?;\n-\n-        match prov {\n+impl fmt::Debug for Provenance {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match self {\n             Provenance::Concrete { alloc_id, sb } => {\n                 // Forward `alternate` flag to `alloc_id` printing.\n                 if f.alternate() {\n@@ -202,9 +193,13 @@ impl interpret::Provenance for Provenance {\n                 write!(f, \"[wildcard]\")?;\n             }\n         }\n-\n         Ok(())\n     }\n+}\n+\n+impl interpret::Provenance for Provenance {\n+    /// We use absolute addresses in the `offset` of a `Pointer<Provenance>`.\n+    const OFFSET_IS_ADDR: bool = true;\n \n     fn get_alloc_id(self) -> Option<AllocId> {\n         match self {"}, {"sha": "73712348f0d5f076cd3d81e662ecc112cafad175", "filename": "src/tools/miri/src/tag_gc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/src%2Ftools%2Fmiri%2Fsrc%2Ftag_gc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/src%2Ftools%2Fmiri%2Fsrc%2Ftag_gc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Ftag_gc.rs?ref=a00f8ba7fcac1b27341679c51bf5a3271fa82df3", "patch": "@@ -127,7 +127,7 @@ impl VisitTags for Operand<Provenance> {\n \n impl VisitTags for Allocation<Provenance, AllocExtra> {\n     fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n-        for (_size, prov) in self.provenance().iter() {\n+        for prov in self.provenance().provenances() {\n             prov.visit_tags(visit);\n         }\n "}, {"sha": "e1dcdda7fdfe344608cd137199d59a402ce01e23", "filename": "src/tools/miri/tests/fail/copy_half_a_pointer.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6d651a295e0e0c331153288b10b78344a4ede20b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcopy_half_a_pointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d651a295e0e0c331153288b10b78344a4ede20b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcopy_half_a_pointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcopy_half_a_pointer.rs?ref=6d651a295e0e0c331153288b10b78344a4ede20b", "patch": "@@ -1,21 +0,0 @@\n-//@normalize-stderr-test: \"\\+0x[48]\" -> \"+HALF_PTR\"\n-#![allow(dead_code)]\n-\n-// We use packed structs to get around alignment restrictions\n-#[repr(packed)]\n-struct Data {\n-    pad: u8,\n-    ptr: &'static i32,\n-}\n-\n-static G: i32 = 0;\n-\n-fn main() {\n-    let mut d = Data { pad: 0, ptr: &G };\n-\n-    // Get a pointer to the beginning of the Data struct (one u8 byte, then the pointer bytes).\n-    let d_alias = &mut d as *mut _ as *mut *const u8;\n-    unsafe {\n-        let _x = d_alias.read_unaligned(); //~ERROR: unable to copy parts of a pointer\n-    }\n-}"}, {"sha": "21797757084eec6bba714e3cf6123aa1eadbe232", "filename": "src/tools/miri/tests/fail/copy_half_a_pointer.stderr", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6d651a295e0e0c331153288b10b78344a4ede20b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcopy_half_a_pointer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d651a295e0e0c331153288b10b78344a4ede20b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcopy_half_a_pointer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcopy_half_a_pointer.stderr?ref=6d651a295e0e0c331153288b10b78344a4ede20b", "patch": "@@ -1,14 +0,0 @@\n-error: unsupported operation: unable to copy parts of a pointer from memory at ALLOC+HALF_PTR\n-  --> $DIR/copy_half_a_pointer.rs:LL:CC\n-   |\n-LL |         let _x = d_alias.read_unaligned();\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^ unable to copy parts of a pointer from memory at ALLOC+HALF_PTR\n-   |\n-   = help: this is likely not a bug in the program; it indicates that the program performed an operation that the interpreter does not support\n-   = note: BACKTRACE:\n-   = note: inside `main` at $DIR/copy_half_a_pointer.rs:LL:CC\n-\n-note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n-\n-error: aborting due to previous error\n-"}, {"sha": "d3a68fbdd018f6aa13bb832c00c13e49a227e676", "filename": "src/tools/miri/tests/fail/provenance/pointer_partial_overwrite.rs", "status": "renamed", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fprovenance%2Fpointer_partial_overwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fprovenance%2Fpointer_partial_overwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fprovenance%2Fpointer_partial_overwrite.rs?ref=a00f8ba7fcac1b27341679c51bf5a3271fa82df3", "patch": "@@ -2,16 +2,13 @@\n //@compile-flags: -Zmiri-disable-alignment-check -Zmiri-disable-stacked-borrows -Zmiri-disable-validation\n \n // Test what happens when we overwrite parts of a pointer.\n-// Also see <https://github.com/rust-lang/miri/issues/2181>.\n \n fn main() {\n     let mut p = &42;\n     unsafe {\n         let ptr: *mut _ = &mut p;\n-        *(ptr as *mut u8) = 123; // if we ever support 8 bit pointers, this is gonna cause\n-        // \"attempted to interpret some raw bytes as a pointer address\" instead of\n-        // \"attempted to read undefined bytes\"\n+        *(ptr as *mut u8) = 123; // this removes provenance from one of the bytes, meaning the entire ptr is considered to have no provenance.\n     }\n-    let x = *p; //~ ERROR: this operation requires initialized memory\n+    let x = *p; //~ ERROR: no provenance\n     panic!(\"this should never print: {}\", x);\n }", "previous_filename": "src/tools/miri/tests/fail/pointer_partial_overwrite.rs"}, {"sha": "06e5ede8c7788447bb204c9df009d115331d1027", "filename": "src/tools/miri/tests/fail/provenance/pointer_partial_overwrite.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fprovenance%2Fpointer_partial_overwrite.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fprovenance%2Fpointer_partial_overwrite.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fprovenance%2Fpointer_partial_overwrite.stderr?ref=a00f8ba7fcac1b27341679c51bf5a3271fa82df3", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: using uninitialized data, but this operation requires initialized memory\n+error: Undefined Behavior: dereferencing pointer failed: $HEX[noalloc] is a dangling pointer (it has no provenance)\n   --> $DIR/pointer_partial_overwrite.rs:LL:CC\n    |\n LL |     let x = *p;\n-   |             ^^ using uninitialized data, but this operation requires initialized memory\n+   |             ^^ dereferencing pointer failed: $HEX[noalloc] is a dangling pointer (it has no provenance)\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information", "previous_filename": "src/tools/miri/tests/fail/pointer_partial_overwrite.stderr"}, {"sha": "170bc6e1ed12b5a76ce98278401997b94a0ac4af", "filename": "src/tools/miri/tests/fail/uninit_buffer_with_provenance.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Funinit_buffer_with_provenance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Funinit_buffer_with_provenance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Funinit_buffer_with_provenance.rs?ref=a00f8ba7fcac1b27341679c51bf5a3271fa82df3", "patch": "@@ -0,0 +1,32 @@\n+//@error-pattern: memory is uninitialized at [0x4..0x8]\n+//@normalize-stderr-test: \"a[0-9]+\" -> \"ALLOC\"\n+#![feature(strict_provenance)]\n+\n+// Test printing allocations that contain single-byte provenance.\n+\n+use std::alloc::{alloc, dealloc, Layout};\n+use std::mem::{self, MaybeUninit};\n+use std::slice::from_raw_parts;\n+\n+fn byte_with_provenance<T>(val: u8, prov: *const T) -> MaybeUninit<u8> {\n+    let ptr = prov.with_addr(val as usize);\n+    let bytes: [MaybeUninit<u8>; mem::size_of::<*const ()>()] = unsafe { mem::transmute(ptr) };\n+    let lsb = if cfg!(target_endian = \"little\") { 0 } else { bytes.len() - 1 };\n+    bytes[lsb]\n+}\n+\n+fn main() {\n+    let layout = Layout::from_size_align(16, 8).unwrap();\n+    unsafe {\n+        let ptr = alloc(layout);\n+        let ptr_raw = ptr.cast::<MaybeUninit<u8>>();\n+        *ptr_raw.add(0) = byte_with_provenance(0x42, &42u8);\n+        *ptr.add(1) = 0x12;\n+        *ptr.add(2) = 0x13;\n+        *ptr_raw.add(3) = byte_with_provenance(0x43, &0u8);\n+        let slice1 = from_raw_parts(ptr, 8);\n+        let slice2 = from_raw_parts(ptr.add(8), 8);\n+        drop(slice1.cmp(slice2));\n+        dealloc(ptr, layout);\n+    }\n+}"}, {"sha": "715d76aa1c2e75a6b4f8002cd9bd852c27798c51", "filename": "src/tools/miri/tests/fail/uninit_buffer_with_provenance.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Funinit_buffer_with_provenance.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Funinit_buffer_with_provenance.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Funinit_buffer_with_provenance.stderr?ref=a00f8ba7fcac1b27341679c51bf5a3271fa82df3", "patch": "@@ -0,0 +1,32 @@\n+error: Undefined Behavior: reading memory at ALLOC[0x0..0x8], but memory is uninitialized at [0x4..0x8], and this operation requires initialized memory\n+  --> RUSTLIB/core/src/slice/cmp.rs:LL:CC\n+   |\n+LL |         let mut order = unsafe { memcmp(left.as_ptr(), right.as_ptr(), len) as isize };\n+   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ reading memory at ALLOC[0x0..0x8], but memory is uninitialized at [0x4..0x8], and this operation requires initialized memory\n+   |\n+   = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n+   = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n+   = note: BACKTRACE:\n+   = note: inside `<u8 as core::slice::cmp::SliceOrd>::compare` at RUSTLIB/core/src/slice/cmp.rs:LL:CC\n+   = note: inside `core::slice::cmp::<impl std::cmp::Ord for [u8]>::cmp` at RUSTLIB/core/src/slice/cmp.rs:LL:CC\n+note: inside `main` at $DIR/uninit_buffer_with_provenance.rs:LL:CC\n+  --> $DIR/uninit_buffer_with_provenance.rs:LL:CC\n+   |\n+LL |         drop(slice1.cmp(slice2));\n+   |              ^^^^^^^^^^^^^^^^^^\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+Uninitialized memory occurred at ALLOC[0x4..0x8], in this allocation:\n+ALLOC (Rust heap, size: 16, align: 8) {\n+    \u257e42[ALLOC]<TAG> (1 ptr byte)\u257c 12 13 \u257e43[ALLOC]<TAG> (1 ptr byte)\u257c __ __ __ __ __ __ __ __ __ __ __ __ \u2502 \u2501..\u2501\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n+}\n+ALLOC (global (static or const), size: 1, align: 1) {\n+    2a                                              \u2502 *\n+}\n+ALLOC (global (static or const), size: 1, align: 1) {\n+    00                                              \u2502 .\n+}\n+\n+error: aborting due to previous error\n+"}, {"sha": "b18d903e36cebf07950473644d630600deb8b2bd", "filename": "src/tools/miri/tests/pass/provenance.rs", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fprovenance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00f8ba7fcac1b27341679c51bf5a3271fa82df3/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fprovenance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fprovenance.rs?ref=a00f8ba7fcac1b27341679c51bf5a3271fa82df3", "patch": "@@ -0,0 +1,139 @@\n+#![feature(strict_provenance)]\n+#![feature(pointer_byte_offsets)]\n+use std::{mem, ptr};\n+\n+const PTR_SIZE: usize = mem::size_of::<&i32>();\n+\n+fn main() {\n+    basic();\n+    partial_overwrite_then_restore();\n+    bytewise_ptr_methods();\n+    bytewise_custom_memcpy();\n+    bytewise_custom_memcpy_chunked();\n+}\n+\n+/// Some basic smoke tests for provenance.\n+fn basic() {\n+    let x = &42;\n+    let ptr = x as *const i32;\n+    let addr: usize = unsafe { mem::transmute(ptr) }; // an integer without provenance\n+    // But we can give provenance back via `with_addr`.\n+    let ptr_back = ptr.with_addr(addr);\n+    assert_eq!(unsafe { *ptr_back }, 42);\n+\n+    // It is preserved by MaybeUninit.\n+    let addr_mu: mem::MaybeUninit<usize> = unsafe { mem::transmute(ptr) };\n+    let ptr_back: *const i32 = unsafe { mem::transmute(addr_mu) };\n+    assert_eq!(unsafe { *ptr_back }, 42);\n+}\n+\n+/// Overwrite one byte of a pointer, then restore it.\n+fn partial_overwrite_then_restore() {\n+    unsafe fn ptr_bytes<'x>(ptr: &'x mut *const i32) -> &'x mut [mem::MaybeUninit<u8>; PTR_SIZE] {\n+        mem::transmute(ptr)\n+    }\n+\n+    // Returns a value with the same provenance as `x` but 0 for the integer value.\n+    // `x` must be initialized.\n+    unsafe fn zero_with_provenance(x: mem::MaybeUninit<u8>) -> mem::MaybeUninit<u8> {\n+        let ptr = [x; PTR_SIZE];\n+        let ptr: *const i32 = mem::transmute(ptr);\n+        let mut ptr = ptr.with_addr(0);\n+        ptr_bytes(&mut ptr)[0]\n+    }\n+\n+    unsafe {\n+        let ptr = &42;\n+        let mut ptr = ptr as *const i32;\n+        // Get a bytewise view of the pointer.\n+        let ptr_bytes = ptr_bytes(&mut ptr);\n+\n+        // The highest bytes must be 0 for this to work.\n+        let hi = if cfg!(target_endian = \"little\") { ptr_bytes.len() - 1 } else { 0 };\n+        assert_eq!(*ptr_bytes[hi].as_ptr().cast::<u8>(), 0);\n+        // Overwrite provenance on the last byte.\n+        ptr_bytes[hi] = mem::MaybeUninit::new(0);\n+        // Restore it from the another byte.\n+        ptr_bytes[hi] = zero_with_provenance(ptr_bytes[1]);\n+\n+        // Now ptr should be good again.\n+        assert_eq!(*ptr, 42);\n+    }\n+}\n+\n+fn bytewise_ptr_methods() {\n+    let mut ptr1 = &1;\n+    let mut ptr2 = &2;\n+\n+    // Swap them, bytewise.\n+    unsafe {\n+        ptr::swap_nonoverlapping(\n+            &mut ptr1 as *mut _ as *mut mem::MaybeUninit<u8>,\n+            &mut ptr2 as *mut _ as *mut mem::MaybeUninit<u8>,\n+            mem::size_of::<&i32>(),\n+        );\n+    }\n+\n+    // Make sure they still work.\n+    assert_eq!(*ptr1, 2);\n+    assert_eq!(*ptr2, 1);\n+\n+    // TODO: also test ptr::swap, ptr::copy, ptr::copy_nonoverlapping.\n+}\n+\n+fn bytewise_custom_memcpy() {\n+    unsafe fn memcpy<T>(to: *mut T, from: *const T) {\n+        let to = to.cast::<mem::MaybeUninit<u8>>();\n+        let from = from.cast::<mem::MaybeUninit<u8>>();\n+        for i in 0..mem::size_of::<T>() {\n+            let b = from.add(i).read();\n+            to.add(i).write(b);\n+        }\n+    }\n+\n+    let ptr1 = &1;\n+    let mut ptr2 = &2;\n+\n+    // Copy, bytewise.\n+    unsafe { memcpy(&mut ptr2, &ptr1) };\n+\n+    // Make sure they still work.\n+    assert_eq!(*ptr1, 1);\n+    assert_eq!(*ptr2, 1);\n+}\n+\n+fn bytewise_custom_memcpy_chunked() {\n+    unsafe fn memcpy<T>(to: *mut T, from: *const T) {\n+        assert!(mem::size_of::<T>() % mem::size_of::<usize>() == 0);\n+        let count = mem::size_of::<T>() / mem::size_of::<usize>();\n+        let to = to.cast::<mem::MaybeUninit<usize>>();\n+        let from = from.cast::<mem::MaybeUninit<usize>>();\n+        for i in 0..count {\n+            let b = from.add(i).read();\n+            to.add(i).write(b);\n+        }\n+    }\n+\n+    // Prepare an array where pointers are stored at... interesting... offsets.\n+    let mut data = [0usize; 2 * PTR_SIZE];\n+    let mut offsets = vec![];\n+    for i in 0..mem::size_of::<usize>() {\n+        // We have 2*PTR_SIZE room for each of these pointers.\n+        let base = i * 2 * PTR_SIZE;\n+        // This one is mis-aligned by `i`.\n+        let offset = base + i;\n+        offsets.push(offset);\n+        // Store it there.\n+        unsafe { data.as_mut_ptr().byte_add(offset).cast::<&i32>().write_unaligned(&42) };\n+    }\n+\n+    // Now memcpy that.\n+    let mut data2 = [0usize; 2 * PTR_SIZE];\n+    unsafe { memcpy(&mut data2, &data) };\n+\n+    // And check the result.\n+    for &offset in &offsets {\n+        let ptr = unsafe { data2.as_ptr().byte_add(offset).cast::<&i32>().read_unaligned() };\n+        assert_eq!(*ptr, 42);\n+    }\n+}"}]}