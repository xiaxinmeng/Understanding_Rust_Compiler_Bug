{"sha": "7dc64b45b5149a566ad6d1284f8f90eb10468ca3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkYzY0YjQ1YjUxNDlhNTY2YWQ2ZDEyODRmOGY5MGViMTA0NjhjYTM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-09T23:17:06Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-09T23:17:06Z"}, "message": "rustc: Make tag pattern translation generic-aware. Un-XFAIL generic-tag-alt.rs.", "tree": {"sha": "abf73af7452167d343efb1665ad9135033dcd541", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/abf73af7452167d343efb1665ad9135033dcd541"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7dc64b45b5149a566ad6d1284f8f90eb10468ca3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7dc64b45b5149a566ad6d1284f8f90eb10468ca3", "html_url": "https://github.com/rust-lang/rust/commit/7dc64b45b5149a566ad6d1284f8f90eb10468ca3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7dc64b45b5149a566ad6d1284f8f90eb10468ca3/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba2e04f271ca4015a3fb22dd01543ab9dc5d6543", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba2e04f271ca4015a3fb22dd01543ab9dc5d6543", "html_url": "https://github.com/rust-lang/rust/commit/ba2e04f271ca4015a3fb22dd01543ab9dc5d6543"}], "stats": {"total": 83, "additions": 50, "deletions": 33}, "files": [{"sha": "2c35d07f64995694719bc682d2b0e5987bfc6f88", "filename": "src/Makefile", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7dc64b45b5149a566ad6d1284f8f90eb10468ca3/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/7dc64b45b5149a566ad6d1284f8f90eb10468ca3/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=7dc64b45b5149a566ad6d1284f8f90eb10468ca3", "patch": "@@ -453,7 +453,6 @@ TEST_XFAILS_RUSTC := $(addprefix test/run-pass/, \\\n                         foreach-put-structured.rs \\\n                         foreach-simple-outer-slot.rs \\\n                         generic-iter-frame.rs \\\n-                        generic-tag-alt.rs \\\n                         generic-tag-values.rs \\\n                         iter-range.rs \\\n                         iter-ret.rs \\"}, {"sha": "7dea9e0c0ecdce34a689d9fd92da0c7e21657fee", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 50, "deletions": 32, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/7dc64b45b5149a566ad6d1284f8f90eb10468ca3/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc64b45b5149a566ad6d1284f8f90eb10468ca3/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=7dc64b45b5149a566ad6d1284f8f90eb10468ca3", "patch": "@@ -1730,6 +1730,25 @@ fn tag_variants(@crate_ctxt cx, ast.def_id id) -> vec[ast.variant] {\n     fail;   // not reached\n }\n \n+// Returns the tag variant with the given ID.\n+fn tag_variant_with_id(@crate_ctxt cx,\n+                       &ast.def_id tag_id,\n+                       &ast.def_id variant_id) -> ast.variant {\n+    auto variants = tag_variants(cx, tag_id);\n+\n+    auto i = 0u;\n+    while (i < _vec.len[ast.variant](variants)) {\n+        auto variant = variants.(i);\n+        if (common.def_eq(variant.id, variant_id)) {\n+            ret variant;\n+        }\n+        i += 1u;\n+    }\n+\n+    log \"tag_variant_with_id(): no variant exists with that ID\";\n+    fail;\n+}\n+\n // Returns a new plain tag type of the given ID with no type parameters. Don't\n // use this function in new code; it's a hack to keep things working for now.\n fn mk_plain_tag(ast.def_id tid) -> @ty.t {\n@@ -2909,23 +2928,6 @@ fn trans_do_while(@block_ctxt cx, &ast.block body,\n \n // Pattern matching translation\n \n-// Returns a pointer to the union part of the LLVM representation of a tag\n-// type, cast to the appropriate type.\n-fn get_pat_union_ptr(@block_ctxt cx, vec[@ast.pat] subpats, ValueRef llval)\n-    -> ValueRef {\n-    auto llblobptr = cx.build.GEP(llval, vec(C_int(0), C_int(1)));\n-\n-    // Generate the union type.\n-    let vec[TypeRef] llsubpattys = vec();\n-    for (@ast.pat subpat in subpats) {\n-        llsubpattys += vec(type_of(cx.fcx.ccx, pat_ty(subpat)));\n-    }\n-\n-    // Recursively check subpatterns.\n-    auto llunionty = T_struct(llsubpattys);\n-    ret cx.build.TruncOrBitCast(llblobptr, T_ptr(llunionty));\n-}\n-\n fn trans_pat_match(@block_ctxt cx, @ast.pat pat, ValueRef llval,\n                    @block_ctxt next_cx) -> result {\n     alt (pat.node) {\n@@ -2943,7 +2945,11 @@ fn trans_pat_match(@block_ctxt cx, @ast.pat pat, ValueRef llval,\n         }\n \n         case (ast.pat_tag(?id, ?subpats, ?vdef_opt, ?ann)) {\n-            auto lldiscrimptr = cx.build.GEP(llval, vec(C_int(0), C_int(0)));\n+            auto lltagptr = cx.build.PointerCast(llval,\n+                T_opaque_tag_ptr(cx.fcx.ccx.tn));\n+\n+            auto lldiscrimptr = cx.build.GEP(lltagptr,\n+                                             vec(C_int(0), C_int(0)));\n             auto lldiscrim = cx.build.Load(lldiscrimptr);\n \n             auto vdef = option.get[ast.variant_def](vdef_opt);\n@@ -2968,13 +2974,15 @@ fn trans_pat_match(@block_ctxt cx, @ast.pat pat, ValueRef llval,\n             cx.build.CondBr(lleq, matched_cx.llbb, next_cx.llbb);\n \n             if (_vec.len[@ast.pat](subpats) > 0u) {\n-                auto llunionptr = get_pat_union_ptr(matched_cx, subpats,\n-                                                    llval);\n+                auto llblobptr = matched_cx.build.GEP(lltagptr,\n+                    vec(C_int(0), C_int(1)));\n                 auto i = 0;\n                 for (@ast.pat subpat in subpats) {\n-                    auto llsubvalptr = matched_cx.build.GEP(llunionptr,\n-                                                            vec(C_int(0),\n-                                                                C_int(i)));\n+                    auto rslt = GEP_tag(matched_cx, llblobptr, variants.(i),\n+                                        i);\n+                    auto llsubvalptr = rslt.val;\n+                    matched_cx = rslt.bcx;\n+\n                     auto llsubval = load_scalar_or_boxed(matched_cx,\n                                                          llsubvalptr,\n                                                          pat_ty(subpat));\n@@ -2998,25 +3006,35 @@ fn trans_pat_binding(@block_ctxt cx, @ast.pat pat, ValueRef llval)\n         case (ast.pat_lit(_, _)) { ret res(cx, llval); }\n         case (ast.pat_bind(?id, ?def_id, ?ann)) {\n             auto ty = node_ann_type(cx.fcx.ccx, ann);\n-            auto llty = type_of(cx.fcx.ccx, ty);\n \n-            auto dst = cx.build.Alloca(llty);\n+            auto rslt = alloc_ty(cx, ty);\n+            auto dst = rslt.val;\n+            auto bcx = rslt.bcx;\n+\n             llvm.LLVMSetValueName(dst, _str.buf(id));\n-            cx.fcx.lllocals.insert(def_id, dst);\n-            cx.cleanups += clean(bind drop_slot(_, dst, ty));\n+            bcx.fcx.lllocals.insert(def_id, dst);\n+            bcx.cleanups += clean(bind drop_slot(_, dst, ty));\n \n-            ret copy_ty(cx, INIT, dst, llval, ty);\n+            ret copy_ty(bcx, INIT, dst, llval, ty);\n         }\n-        case (ast.pat_tag(_, ?subpats, _, _)) {\n+        case (ast.pat_tag(_, ?subpats, ?vdef_opt, _)) {\n             if (_vec.len[@ast.pat](subpats) == 0u) { ret res(cx, llval); }\n \n-            auto llunionptr = get_pat_union_ptr(cx, subpats, llval);\n+            // Get the appropriate variant for this tag.\n+            auto vdef = option.get[ast.variant_def](vdef_opt);\n+            auto variant = tag_variant_with_id(cx.fcx.ccx, vdef._0, vdef._1);\n+\n+            auto lltagptr = cx.build.PointerCast(llval,\n+                T_opaque_tag_ptr(cx.fcx.ccx.tn));\n+            auto llblobptr = cx.build.GEP(lltagptr, vec(C_int(0), C_int(1)));\n \n             auto this_cx = cx;\n             auto i = 0;\n             for (@ast.pat subpat in subpats) {\n-                auto llsubvalptr = this_cx.build.GEP(llunionptr,\n-                                                     vec(C_int(0), C_int(i)));\n+                auto rslt = GEP_tag(this_cx, llblobptr, variant, i);\n+                this_cx = rslt.bcx;\n+                auto llsubvalptr = rslt.val;\n+\n                 auto llsubval = load_scalar_or_boxed(this_cx, llsubvalptr,\n                                                      pat_ty(subpat));\n                 auto subpat_res = trans_pat_binding(this_cx, subpat,"}]}