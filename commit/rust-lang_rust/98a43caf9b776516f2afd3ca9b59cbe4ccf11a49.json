{"sha": "98a43caf9b776516f2afd3ca9b59cbe4ccf11a49", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4YTQzY2FmOWI3NzY1MTZmMmFmZDNjYTliNTljYmU0Y2NmMTFhNDk=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-04-25T23:00:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-25T23:00:17Z"}, "message": "Rollup merge of #71392 - ecstatic-morse:body-predecessor-cache-arc, r=nikomatsakis\n\nDon't hold the predecessor cache lock longer than necessary\n\n#71044 returns a `LockGuard` with the predecessor cache to callers of `Body::predecessors`. As a result, the lock around the predecessor cache could be held for an arbitrarily long time. This PR uses reference counting for ownership of the predecessor cache, meaning the lock is only ever held within `PredecessorCache::compute`. Checking this API for potential sources of deadlock is much easier now, since we no longer have to consider its consumers, only its internals.\n\nThis required removing `predecessors_for`, since there is no equivalent to `LockGuard::map` for `Arc` and `Rc`. I believe this could be emulated with `owning_ref::{Arc,Rc}Ref`, but I don't think it's necessary. Also, we continue to return an opaque type from `Body::predecessors` with the lifetime of the `Body`, not `'static`.\n\nThis depends on #71044. Only the last two commits are new.\n\nr? @nikomatsakis", "tree": {"sha": "cc0cfa9a253f25e20ec9275f537e4feff76475fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc0cfa9a253f25e20ec9275f537e4feff76475fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98a43caf9b776516f2afd3ca9b59cbe4ccf11a49", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJepMEBCRBK7hj4Ov3rIwAAdHIIAH0XYKnAzThCwn3X13gTcXaR\nH2e2bjn72dRYQ337yJUko0vzvSRQoq/RgAHNtz+IrKFDlniWMCmCprleripg2vRa\niP07EzF8HFah7P9S1Gjw+FyUw+eL+vNmpBuPNtB1C8+wHGWeczvggF52+4yvSQvO\nBuMaLQb0cqQ/hnieXqOadl1Ki3RSqR70b0dhn/vZJ94mYXSD5xFAVFRB8G+WtkRE\ncDJFaNM5yEZme5slGNkpAtYGgC57KNG29fZnGkyuzk3Sq0yy/2bj6FHSkWEQ++l3\n5Q5br035+P4RZN6+CporQNbfBXEaa9VZW263iVnD/ifiVpE+n9wZW6nNg14hPdI=\n=CoT2\n-----END PGP SIGNATURE-----\n", "payload": "tree cc0cfa9a253f25e20ec9275f537e4feff76475fb\nparent b964451a72eb20283ee8f23541eae24474278158\nparent 34dfbc3fef3fb02c36beb982523ce8d9d90838e7\nauthor Dylan DPC <dylan.dpc@gmail.com> 1587855617 +0200\ncommitter GitHub <noreply@github.com> 1587855617 +0200\n\nRollup merge of #71392 - ecstatic-morse:body-predecessor-cache-arc, r=nikomatsakis\n\nDon't hold the predecessor cache lock longer than necessary\n\n#71044 returns a `LockGuard` with the predecessor cache to callers of `Body::predecessors`. As a result, the lock around the predecessor cache could be held for an arbitrarily long time. This PR uses reference counting for ownership of the predecessor cache, meaning the lock is only ever held within `PredecessorCache::compute`. Checking this API for potential sources of deadlock is much easier now, since we no longer have to consider its consumers, only its internals.\n\nThis required removing `predecessors_for`, since there is no equivalent to `LockGuard::map` for `Arc` and `Rc`. I believe this could be emulated with `owning_ref::{Arc,Rc}Ref`, but I don't think it's necessary. Also, we continue to return an opaque type from `Body::predecessors` with the lifetime of the `Body`, not `'static`.\n\nThis depends on #71044. Only the last two commits are new.\n\nr? @nikomatsakis\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98a43caf9b776516f2afd3ca9b59cbe4ccf11a49", "html_url": "https://github.com/rust-lang/rust/commit/98a43caf9b776516f2afd3ca9b59cbe4ccf11a49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98a43caf9b776516f2afd3ca9b59cbe4ccf11a49/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b964451a72eb20283ee8f23541eae24474278158", "url": "https://api.github.com/repos/rust-lang/rust/commits/b964451a72eb20283ee8f23541eae24474278158", "html_url": "https://github.com/rust-lang/rust/commit/b964451a72eb20283ee8f23541eae24474278158"}, {"sha": "34dfbc3fef3fb02c36beb982523ce8d9d90838e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/34dfbc3fef3fb02c36beb982523ce8d9d90838e7", "html_url": "https://github.com/rust-lang/rust/commit/34dfbc3fef3fb02c36beb982523ce8d9d90838e7"}], "stats": {"total": 70, "additions": 35, "deletions": 35}, "files": [{"sha": "00b4bf96afa594b75e55115647bb84b9410c6179", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98a43caf9b776516f2afd3ca9b59cbe4ccf11a49/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a43caf9b776516f2afd3ca9b59cbe4ccf11a49/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=98a43caf9b776516f2afd3ca9b59cbe4ccf11a49", "patch": "@@ -157,7 +157,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     let cleanup_kinds = analyze::cleanup_kinds(&mir);\n     // Allocate a `Block` for every basic block, except\n     // the start block, if nothing loops back to it.\n-    let reentrant_start_block = !mir.predecessors_for(mir::START_BLOCK).is_empty();\n+    let reentrant_start_block = !mir.predecessors()[mir::START_BLOCK].is_empty();\n     let block_bxs: IndexVec<mir::BasicBlock, Bx::BasicBlock> = mir\n         .basic_blocks()\n         .indices()"}, {"sha": "34c05ec59f38812438f8825514521b932b2eae04", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/98a43caf9b776516f2afd3ca9b59cbe4ccf11a49/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a43caf9b776516f2afd3ca9b59cbe4ccf11a49/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=98a43caf9b776516f2afd3ca9b59cbe4ccf11a49", "patch": "@@ -23,14 +23,12 @@ use rustc_ast::ast::Name;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::dominators::{dominators, Dominators};\n use rustc_data_structures::graph::{self, GraphSuccessors};\n-use rustc_data_structures::sync::MappedLockGuard;\n use rustc_index::bit_set::BitMatrix;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_macros::HashStable;\n use rustc_serialize::{Decodable, Encodable};\n use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n-use smallvec::SmallVec;\n use std::borrow::Cow;\n use std::fmt::{self, Debug, Display, Formatter, Write};\n use std::ops::{Index, IndexMut};\n@@ -170,7 +168,7 @@ pub struct Body<'tcx> {\n     /// FIXME(oli-obk): rewrite the promoted during promotion to eliminate the cell components.\n     pub ignore_interior_mut_in_const_validation: bool,\n \n-    pub predecessor_cache: PredecessorCache,\n+    predecessor_cache: PredecessorCache,\n }\n \n impl<'tcx> Body<'tcx> {\n@@ -398,15 +396,6 @@ impl<'tcx> Body<'tcx> {\n         Location { block: bb, statement_index: self[bb].statements.len() }\n     }\n \n-    #[inline]\n-    pub fn predecessors_for(\n-        &self,\n-        bb: BasicBlock,\n-    ) -> impl std::ops::Deref<Target = SmallVec<[BasicBlock; 4]>> + '_ {\n-        let predecessors = self.predecessor_cache.compute(&self.basic_blocks);\n-        MappedLockGuard::map(predecessors, |preds| &mut preds[bb])\n-    }\n-\n     #[inline]\n     pub fn predecessors(&self) -> impl std::ops::Deref<Target = Predecessors> + '_ {\n         self.predecessor_cache.compute(&self.basic_blocks)\n@@ -2684,7 +2673,7 @@ impl graph::GraphPredecessors<'graph> for Body<'tcx> {\n impl graph::WithPredecessors for Body<'tcx> {\n     #[inline]\n     fn predecessors(&self, node: Self::Node) -> <Self as graph::GraphPredecessors<'_>>::Iter {\n-        self.predecessors_for(node).clone().into_iter()\n+        self.predecessors()[node].clone().into_iter()\n     }\n }\n "}, {"sha": "9508365886aa790f3f83d029d9cf7106afac8fca", "filename": "src/librustc_middle/mir/predecessors.rs", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/98a43caf9b776516f2afd3ca9b59cbe4ccf11a49/src%2Flibrustc_middle%2Fmir%2Fpredecessors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a43caf9b776516f2afd3ca9b59cbe4ccf11a49/src%2Flibrustc_middle%2Fmir%2Fpredecessors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fpredecessors.rs?ref=98a43caf9b776516f2afd3ca9b59cbe4ccf11a49", "patch": "@@ -1,5 +1,7 @@\n+//! Lazily compute the reverse control-flow graph for the MIR.\n+\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_data_structures::sync::{Lock, LockGuard, MappedLockGuard};\n+use rustc_data_structures::sync::{Lock, Lrc};\n use rustc_index::vec::IndexVec;\n use rustc_serialize as serialize;\n use smallvec::SmallVec;\n@@ -10,40 +12,49 @@ use crate::mir::{BasicBlock, BasicBlockData};\n pub type Predecessors = IndexVec<BasicBlock, SmallVec<[BasicBlock; 4]>>;\n \n #[derive(Clone, Debug)]\n-pub struct PredecessorCache {\n-    cache: Lock<Option<Predecessors>>,\n+pub(super) struct PredecessorCache {\n+    cache: Lock<Option<Lrc<Predecessors>>>,\n }\n \n impl PredecessorCache {\n     #[inline]\n-    pub fn new() -> Self {\n+    pub(super) fn new() -> Self {\n         PredecessorCache { cache: Lock::new(None) }\n     }\n \n+    /// Invalidates the predecessor cache.\n+    ///\n+    /// Invalidating the predecessor cache requires mutating the MIR, which in turn requires a\n+    /// unique reference (`&mut`) to the `mir::Body`. Because of this, we can assume that all\n+    /// callers of `invalidate` have a unique reference to the MIR and thus to the predecessor\n+    /// cache. This means we don't actually need to take a lock when `invalidate` is called.\n     #[inline]\n-    pub fn invalidate(&mut self) {\n+    pub(super) fn invalidate(&mut self) {\n         *self.cache.get_mut() = None;\n     }\n \n+    /// Returns a ref-counted smart pointer containing the predecessor graph for this MIR.\n+    ///\n+    /// We use ref-counting instead of a mapped `LockGuard` here to ensure that the lock for\n+    /// `cache` is only held inside this function. As long as no other locks are taken while\n+    /// computing the predecessor graph, deadlock is impossible.\n     #[inline]\n-    pub fn compute(\n+    pub(super) fn compute(\n         &self,\n         basic_blocks: &IndexVec<BasicBlock, BasicBlockData<'_>>,\n-    ) -> MappedLockGuard<'_, Predecessors> {\n-        LockGuard::map(self.cache.lock(), |cache| {\n-            cache.get_or_insert_with(|| {\n-                let mut preds = IndexVec::from_elem(SmallVec::new(), basic_blocks);\n-                for (bb, data) in basic_blocks.iter_enumerated() {\n-                    if let Some(term) = &data.terminator {\n-                        for &succ in term.successors() {\n-                            preds[succ].push(bb);\n-                        }\n+    ) -> Lrc<Predecessors> {\n+        Lrc::clone(self.cache.lock().get_or_insert_with(|| {\n+            let mut preds = IndexVec::from_elem(SmallVec::new(), basic_blocks);\n+            for (bb, data) in basic_blocks.iter_enumerated() {\n+                if let Some(term) = &data.terminator {\n+                    for &succ in term.successors() {\n+                        preds[succ].push(bb);\n                     }\n                 }\n+            }\n \n-                preds\n-            })\n-        })\n+            Lrc::new(preds)\n+        }))\n     }\n }\n "}, {"sha": "d424d0525fdd8eef306efb796af23ec2dbc7506a", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98a43caf9b776516f2afd3ca9b59cbe4ccf11a49/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a43caf9b776516f2afd3ca9b59cbe4ccf11a49/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=98a43caf9b776516f2afd3ca9b59cbe4ccf11a49", "patch": "@@ -1269,7 +1269,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             location: Location,\n         ) -> impl Iterator<Item = Location> + 'a {\n             if location.statement_index == 0 {\n-                let predecessors = body.predecessors_for(location.block).to_vec();\n+                let predecessors = body.predecessors()[location.block].to_vec();\n                 Either::Left(predecessors.into_iter().map(move |bb| body.terminator_loc(bb)))\n             } else {\n                 Either::Right(std::iter::once(Location {"}, {"sha": "6cd814962c6133fac8e86a8d544b5984327c19d8", "filename": "src/librustc_mir/borrow_check/region_infer/values.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98a43caf9b776516f2afd3ca9b59cbe4ccf11a49/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a43caf9b776516f2afd3ca9b59cbe4ccf11a49/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fvalues.rs?ref=98a43caf9b776516f2afd3ca9b59cbe4ccf11a49", "patch": "@@ -89,7 +89,7 @@ impl RegionValueElements {\n             // If this is a basic block head, then the predecessors are\n             // the terminators of other basic blocks\n             stack.extend(\n-                body.predecessors_for(block)\n+                body.predecessors()[block]\n                     .iter()\n                     .map(|&pred_bb| body.terminator_loc(pred_bb))\n                     .map(|pred_loc| self.point_from_location(pred_loc)),"}, {"sha": "ec52a08c7b2162094da07e03d8f0e203c42947cb", "filename": "src/librustc_mir/borrow_check/type_check/liveness/trace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98a43caf9b776516f2afd3ca9b59cbe4ccf11a49/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a43caf9b776516f2afd3ca9b59cbe4ccf11a49/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs?ref=98a43caf9b776516f2afd3ca9b59cbe4ccf11a49", "patch": "@@ -303,7 +303,7 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n         }\n \n         let body = self.cx.body;\n-        for &pred_block in body.predecessors_for(block).iter() {\n+        for &pred_block in body.predecessors()[block].iter() {\n             debug!(\"compute_drop_live_points_for_block: pred_block = {:?}\", pred_block,);\n \n             // Check whether the variable is (at least partially)"}]}