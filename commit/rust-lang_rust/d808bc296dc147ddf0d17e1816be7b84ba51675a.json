{"sha": "d808bc296dc147ddf0d17e1816be7b84ba51675a", "node_id": "C_kwDOAAsO6NoAKGQ4MDhiYzI5NmRjMTQ3ZGRmMGQxN2UxODE2YmU3Yjg0YmE1MTY3NWE", "commit": {"author": {"name": "Joshua Nelson", "email": "github@jyn.dev", "date": "2023-03-17T15:24:40Z"}, "committer": {"name": "Joshua Nelson", "email": "github@jyn.dev", "date": "2023-03-17T15:24:40Z"}, "message": "Add tests for configure.py\n\n- Separate out functions so that each unit test doesn't create a file on disk\n- Add a few unit tests\n\nNotably, verifying that we generate valid toml relies on python 3.11 so\nwe can use `tomllib`.", "tree": {"sha": "fc11e80dae6d8b40a38ff0420b250ca7783302e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc11e80dae6d8b40a38ff0420b250ca7783302e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d808bc296dc147ddf0d17e1816be7b84ba51675a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d808bc296dc147ddf0d17e1816be7b84ba51675a", "html_url": "https://github.com/rust-lang/rust/commit/d808bc296dc147ddf0d17e1816be7b84ba51675a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d808bc296dc147ddf0d17e1816be7b84ba51675a/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d64f229a09515978e6f338b821057a64334a0b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d64f229a09515978e6f338b821057a64334a0b5", "html_url": "https://github.com/rust-lang/rust/commit/2d64f229a09515978e6f338b821057a64334a0b5"}], "stats": {"total": 457, "additions": 259, "deletions": 198}, "files": [{"sha": "6a4a64a1ed549d05e9ec0925498054ed1104ec18", "filename": "src/bootstrap/bootstrap_test.py", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d808bc296dc147ddf0d17e1816be7b84ba51675a/src%2Fbootstrap%2Fbootstrap_test.py", "raw_url": "https://github.com/rust-lang/rust/raw/d808bc296dc147ddf0d17e1816be7b84ba51675a/src%2Fbootstrap%2Fbootstrap_test.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap_test.py?ref=d808bc296dc147ddf0d17e1816be7b84ba51675a", "patch": "@@ -11,6 +11,7 @@\n from shutil import rmtree\n \n import bootstrap\n+import configure\n \n \n class VerifyTestCase(unittest.TestCase):\n@@ -74,12 +75,51 @@ def test_same_dates(self):\n         self.assertFalse(self.build.program_out_of_date(self.rustc_stamp_path, self.key))\n \n \n+class GenerateAndParseConfig(unittest.TestCase):\n+    \"\"\"Test that we can serialize and deserialize a config.toml file\"\"\"\n+    def serialize_and_parse(self, args):\n+        from io import StringIO\n+\n+        section_order, sections, targets = configure.parse_args(args)\n+        buffer = StringIO()\n+        configure.write_config_toml(buffer, section_order, targets, sections)\n+        build = bootstrap.RustBuild()\n+        build.config_toml = buffer.getvalue()\n+\n+        try:\n+            import tomllib\n+            # Verify this is actually valid TOML.\n+            tomllib.loads(build.config_toml)\n+        except ImportError:\n+            # too old a version of python\n+            pass\n+        return build\n+\n+    def test_no_args(self):\n+        build = self.serialize_and_parse([])\n+        self.assertEqual(build.get_toml(\"changelog-seen\"), '2')\n+        self.assertIsNone(build.get_toml(\"llvm.download-ci-llvm\"))\n+\n+    def test_set_section(self):\n+        build = self.serialize_and_parse([\"--set\", \"llvm.download-ci-llvm\"])\n+        self.assertEqual(build.get_toml(\"download-ci-llvm\", section=\"llvm\"), 'true')\n+\n+    def test_set_target(self):\n+        build = self.serialize_and_parse([\"--set\", \"target.x86_64-unknown-linux-gnu.cc=gcc\"])\n+        self.assertEqual(build.get_toml(\"cc\", section=\"target.x86_64-unknown-linux-gnu\"), 'gcc')\n+\n+    # Uncomment when #108928 is fixed.\n+    # def test_set_top_level(self):\n+    #     build = self.serialize_and_parse([\"--set\", \"profile=compiler\"])\n+    #     self.assertEqual(build.get_toml(\"profile\"), 'compiler')\n+\n if __name__ == '__main__':\n     SUITE = unittest.TestSuite()\n     TEST_LOADER = unittest.TestLoader()\n     SUITE.addTest(doctest.DocTestSuite(bootstrap))\n     SUITE.addTests([\n         TEST_LOADER.loadTestsFromTestCase(VerifyTestCase),\n+        TEST_LOADER.loadTestsFromTestCase(GenerateAndParseConfig),\n         TEST_LOADER.loadTestsFromTestCase(ProgramOutOfDate)])\n \n     RUNNER = unittest.TextTestRunner(stream=sys.stdout, verbosity=2)"}, {"sha": "dc2271bdf27acbb9f4f2a077e8c4693b9c6a88f9", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 219, "deletions": 198, "changes": 417, "blob_url": "https://github.com/rust-lang/rust/blob/d808bc296dc147ddf0d17e1816be7b84ba51675a/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/d808bc296dc147ddf0d17e1816be7b84ba51675a/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=d808bc296dc147ddf0d17e1816be7b84ba51675a", "patch": "@@ -205,77 +205,78 @@ def err(msg):\n \n # Parse all command line arguments into one of these three lists, handling\n # boolean and value-based options separately\n-unknown_args = []\n-need_value_args = []\n-known_args = {}\n-\n-p(\"processing command line\")\n-i = 1\n-while i < len(sys.argv):\n-    arg = sys.argv[i]\n-    i += 1\n-    if not arg.startswith('--'):\n-        unknown_args.append(arg)\n-        continue\n-\n-    found = False\n-    for option in options:\n-        value = None\n-        if option.value:\n-            keyval = arg[2:].split('=', 1)\n-            key = keyval[0]\n-            if option.name != key:\n-                continue\n+def parse_args(args):\n+    unknown_args = []\n+    need_value_args = []\n+    known_args = {}\n+\n+    i = 0\n+    while i < len(args):\n+        arg = args[i]\n+        i += 1\n+        if not arg.startswith('--'):\n+            unknown_args.append(arg)\n+            continue\n \n-            if len(keyval) > 1:\n-                value = keyval[1]\n-            elif i < len(sys.argv):\n-                value = sys.argv[i]\n-                i += 1\n-            else:\n-                need_value_args.append(arg)\n-                continue\n-        else:\n-            if arg[2:] == 'enable-' + option.name:\n-                value = True\n-            elif arg[2:] == 'disable-' + option.name:\n-                value = False\n+        found = False\n+        for option in options:\n+            value = None\n+            if option.value:\n+                keyval = arg[2:].split('=', 1)\n+                key = keyval[0]\n+                if option.name != key:\n+                    continue\n+\n+                if len(keyval) > 1:\n+                    value = keyval[1]\n+                elif i < len(args):\n+                    value = args[i]\n+                    i += 1\n+                else:\n+                    need_value_args.append(arg)\n+                    continue\n             else:\n-                continue\n+                if arg[2:] == 'enable-' + option.name:\n+                    value = True\n+                elif arg[2:] == 'disable-' + option.name:\n+                    value = False\n+                else:\n+                    continue\n \n-        found = True\n-        if option.name not in known_args:\n-            known_args[option.name] = []\n-        known_args[option.name].append((option, value))\n-        break\n-\n-    if not found:\n-        unknown_args.append(arg)\n-p(\"\")\n-\n-# Note: here and a few other places, we use [-1] to apply the *last* value\n-# passed.  But if option-checking is enabled, then the known_args loop will\n-# also assert that options are only passed once.\n-option_checking = ('option-checking' not in known_args\n-                   or known_args['option-checking'][-1][1])\n-if option_checking:\n-    if len(unknown_args) > 0:\n-        err(\"Option '\" + unknown_args[0] + \"' is not recognized\")\n-    if len(need_value_args) > 0:\n-        err(\"Option '{0}' needs a value ({0}=val)\".format(need_value_args[0]))\n-\n-# Parse all known arguments into a configuration structure that reflects the\n-# TOML we're going to write out\n-config = {}\n-\n-\n-def build():\n+            found = True\n+            if option.name not in known_args:\n+                known_args[option.name] = []\n+            known_args[option.name].append((option, value))\n+            break\n+\n+        if not found:\n+            unknown_args.append(arg)\n+    \n+    # Note: here and a few other places, we use [-1] to apply the *last* value\n+    # passed.  But if option-checking is enabled, then the known_args loop will\n+    # also assert that options are only passed once.\n+    option_checking = ('option-checking' not in known_args\n+                    or known_args['option-checking'][-1][1])\n+    if option_checking:\n+        if len(unknown_args) > 0:\n+            err(\"Option '\" + unknown_args[0] + \"' is not recognized\")\n+        if len(need_value_args) > 0:\n+            err(\"Option '{0}' needs a value ({0}=val)\".format(need_value_args[0]))\n+\n+    config = {}\n+\n+    set('build.configure-args', sys.argv[1:], config)\n+    apply_args(known_args, option_checking, config)\n+    return parse_example_config(known_args, config)\n+\n+\n+def build(known_args):\n     if 'build' in known_args:\n         return known_args['build'][-1][1]\n     return bootstrap.default_build_triple(verbose=False)\n \n \n-def set(key, value):\n+def set(key, value, config):\n     if isinstance(value, list):\n         # Remove empty values, which value.split(',') tends to generate.\n         value = [v for v in value if v]\n@@ -297,122 +298,127 @@ def set(key, value):\n             arr = arr[part]\n \n \n-for key in known_args:\n-    # The `set` option is special and can be passed a bunch of times\n-    if key == 'set':\n-        for option, value in known_args[key]:\n-            keyval = value.split('=', 1)\n-            if len(keyval) == 1 or keyval[1] == \"true\":\n-                value = True\n-            elif keyval[1] == \"false\":\n-                value = False\n-            else:\n-                value = keyval[1]\n-            set(keyval[0], value)\n-        continue\n-\n-    # Ensure each option is only passed once\n-    arr = known_args[key]\n-    if option_checking and len(arr) > 1:\n-        err(\"Option '{}' provided more than once\".format(key))\n-    option, value = arr[-1]\n-\n-    # If we have a clear avenue to set our value in rustbuild, do so\n-    if option.rustbuild is not None:\n-        set(option.rustbuild, value)\n-        continue\n-\n-    # Otherwise we're a \"special\" option and need some extra handling, so do\n-    # that here.\n-    if option.name == 'sccache':\n-        set('llvm.ccache', 'sccache')\n-    elif option.name == 'local-rust':\n-        for path in os.environ['PATH'].split(os.pathsep):\n-            if os.path.exists(path + '/rustc'):\n-                set('build.rustc', path + '/rustc')\n-                break\n-        for path in os.environ['PATH'].split(os.pathsep):\n-            if os.path.exists(path + '/cargo'):\n-                set('build.cargo', path + '/cargo')\n-                break\n-    elif option.name == 'local-rust-root':\n-        set('build.rustc', value + '/bin/rustc')\n-        set('build.cargo', value + '/bin/cargo')\n-    elif option.name == 'llvm-root':\n-        set('target.{}.llvm-config'.format(build()), value + '/bin/llvm-config')\n-    elif option.name == 'llvm-config':\n-        set('target.{}.llvm-config'.format(build()), value)\n-    elif option.name == 'llvm-filecheck':\n-        set('target.{}.llvm-filecheck'.format(build()), value)\n-    elif option.name == 'tools':\n-        set('build.tools', value.split(','))\n-    elif option.name == 'codegen-backends':\n-        set('rust.codegen-backends', value.split(','))\n-    elif option.name == 'host':\n-        set('build.host', value.split(','))\n-    elif option.name == 'target':\n-        set('build.target', value.split(','))\n-    elif option.name == 'full-tools':\n-        set('rust.codegen-backends', ['llvm'])\n-        set('rust.lld', True)\n-        set('rust.llvm-tools', True)\n-        set('build.extended', True)\n-    elif option.name == 'option-checking':\n-        # this was handled above\n-        pass\n-    elif option.name == 'dist-compression-formats':\n-        set('dist.compression-formats', value.split(','))\n-    else:\n-        raise RuntimeError(\"unhandled option {}\".format(option.name))\n+def apply_args(known_args, option_checking, config):\n+    for key in known_args:\n+        # The `set` option is special and can be passed a bunch of times\n+        if key == 'set':\n+            for option, value in known_args[key]:\n+                keyval = value.split('=', 1)\n+                if len(keyval) == 1 or keyval[1] == \"true\":\n+                    value = True\n+                elif keyval[1] == \"false\":\n+                    value = False\n+                else:\n+                    value = keyval[1]\n+                set(keyval[0], value, config)\n+            continue\n \n-set('build.configure-args', sys.argv[1:])\n+        # Ensure each option is only passed once\n+        arr = known_args[key]\n+        if option_checking and len(arr) > 1:\n+            err(\"Option '{}' provided more than once\".format(key))\n+        option, value = arr[-1]\n+\n+        # If we have a clear avenue to set our value in rustbuild, do so\n+        if option.rustbuild is not None:\n+            set(option.rustbuild, value, config)\n+            continue\n+\n+        # Otherwise we're a \"special\" option and need some extra handling, so do\n+        # that here.\n+        build_triple = build(known_args)\n+\n+        if option.name == 'sccache':\n+            set('llvm.ccache', 'sccache', config)\n+        elif option.name == 'local-rust':\n+            for path in os.environ['PATH'].split(os.pathsep):\n+                if os.path.exists(path + '/rustc'):\n+                    set('build.rustc', path + '/rustc', config)\n+                    break\n+            for path in os.environ['PATH'].split(os.pathsep):\n+                if os.path.exists(path + '/cargo'):\n+                    set('build.cargo', path + '/cargo', config)\n+                    break\n+        elif option.name == 'local-rust-root':\n+            set('build.rustc', value + '/bin/rustc', config)\n+            set('build.cargo', value + '/bin/cargo', config)\n+        elif option.name == 'llvm-root':\n+            set('target.{}.llvm-config'.format(build_triple), value + '/bin/llvm-config', config)\n+        elif option.name == 'llvm-config':\n+            set('target.{}.llvm-config'.format(build_triple), value, config)\n+        elif option.name == 'llvm-filecheck':\n+            set('target.{}.llvm-filecheck'.format(build_triple), value, config)\n+        elif option.name == 'tools':\n+            set('build.tools', value.split(','), config)\n+        elif option.name == 'codegen-backends':\n+            set('rust.codegen-backends', value.split(','), config)\n+        elif option.name == 'host':\n+            set('build.host', value.split(','), config)\n+        elif option.name == 'target':\n+            set('build.target', value.split(','), config)\n+        elif option.name == 'full-tools':\n+            set('rust.codegen-backends', ['llvm'], config)\n+            set('rust.lld', True, config)\n+            set('rust.llvm-tools', True, config)\n+            set('build.extended', True, config)\n+        elif option.name == 'option-checking':\n+            # this was handled above\n+            pass\n+        elif option.name == 'dist-compression-formats':\n+            set('dist.compression-formats', value.split(','), config)\n+        else:\n+            raise RuntimeError(\"unhandled option {}\".format(option.name))\n \n # \"Parse\" the `config.example.toml` file into the various sections, and we'll\n # use this as a template of a `config.toml` to write out which preserves\n # all the various comments and whatnot.\n #\n # Note that the `target` section is handled separately as we'll duplicate it\n # per configured target, so there's a bit of special handling for that here.\n-sections = {}\n-cur_section = None\n-sections[None] = []\n-section_order = [None]\n-targets = {}\n-top_level_keys = []\n-\n-for line in open(rust_dir + '/config.example.toml').read().split(\"\\n\"):\n-    if cur_section == None:\n-        if line.count('=') == 1:\n-            top_level_key = line.split('=')[0]\n-            top_level_key = top_level_key.strip(' #')\n-            top_level_keys.append(top_level_key)\n-    if line.startswith('['):\n-        cur_section = line[1:-1]\n-        if cur_section.startswith('target'):\n-            cur_section = 'target'\n-        elif '.' in cur_section:\n-            raise RuntimeError(\"don't know how to deal with section: {}\".format(cur_section))\n-        sections[cur_section] = [line]\n-        section_order.append(cur_section)\n-    else:\n-        sections[cur_section].append(line)\n-\n-# Fill out the `targets` array by giving all configured targets a copy of the\n-# `target` section we just loaded from the example config\n-configured_targets = [build()]\n-if 'build' in config:\n-    if 'host' in config['build']:\n-        configured_targets += config['build']['host']\n-    if 'target' in config['build']:\n-        configured_targets += config['build']['target']\n-if 'target' in config:\n-    for target in config['target']:\n-        configured_targets.append(target)\n-for target in configured_targets:\n-    targets[target] = sections['target'][:]\n-    # For `.` to be valid TOML, it needs to be quoted. But `bootstrap.py` doesn't use a proper TOML parser and fails to parse the target.\n-    # Avoid using quotes unless it's necessary.\n-    targets[target][0] = targets[target][0].replace(\"x86_64-unknown-linux-gnu\", \"'{}'\".format(target) if \".\" in target else target)\n+def parse_example_config(known_args, config):\n+    sections = {}\n+    cur_section = None\n+    sections[None] = []\n+    section_order = [None]\n+    targets = {}\n+    top_level_keys = []\n+\n+    for line in open(rust_dir + '/config.example.toml').read().split(\"\\n\"):\n+        if cur_section == None:\n+            if line.count('=') == 1:\n+                top_level_key = line.split('=')[0]\n+                top_level_key = top_level_key.strip(' #')\n+                top_level_keys.append(top_level_key)\n+        if line.startswith('['):\n+            cur_section = line[1:-1]\n+            if cur_section.startswith('target'):\n+                cur_section = 'target'\n+            elif '.' in cur_section:\n+                raise RuntimeError(\"don't know how to deal with section: {}\".format(cur_section))\n+            sections[cur_section] = [line]\n+            section_order.append(cur_section)\n+        else:\n+            sections[cur_section].append(line)\n+\n+    # Fill out the `targets` array by giving all configured targets a copy of the\n+    # `target` section we just loaded from the example config\n+    configured_targets = [build(known_args)]\n+    if 'build' in config:\n+        if 'host' in config['build']:\n+            configured_targets += config['build']['host']\n+        if 'target' in config['build']:\n+            configured_targets += config['build']['target']\n+    if 'target' in config:\n+        for target in config['target']:\n+            configured_targets.append(target)\n+    for target in configured_targets:\n+        targets[target] = sections['target'][:]\n+        # For `.` to be valid TOML, it needs to be quoted. But `bootstrap.py` doesn't use a proper TOML parser and fails to parse the target.\n+        # Avoid using quotes unless it's necessary.\n+        targets[target][0] = targets[target][0].replace(\"x86_64-unknown-linux-gnu\", \"'{}'\".format(target) if \".\" in target else target)\n+\n+    configure_file(sections, top_level_keys, targets, config)\n+    return section_order, sections, targets\n \n \n def is_number(value):\n@@ -475,17 +481,20 @@ def configure_top_level_key(lines, top_level_key, value):\n     raise RuntimeError(\"failed to find config line for {}\".format(top_level_key))\n \n \n-for section_key, section_config in config.items():\n-    if section_key not in sections and section_key not in top_level_keys:\n-        raise RuntimeError(\"config key {} not in sections or top_level_keys\".format(section_key))\n-    if section_key in top_level_keys:\n-        configure_top_level_key(sections[None], section_key, section_config)\n+# Modify `sections` to reflect the parsed arguments and example configs.\n+def configure_file(sections, top_level_keys, targets, config):\n+    for section_key, section_config in config.items():\n+        if section_key not in sections and section_key not in top_level_keys:\n+            raise RuntimeError(\"config key {} not in sections or top_level_keys\".format(section_key))\n+        if section_key in top_level_keys:\n+            configure_top_level_key(sections[None], section_key, section_config)\n+\n+        elif  section_key == 'target':\n+            for target in section_config:\n+                configure_section(targets[target], section_config[target])\n+        else:\n+            configure_section(sections[section_key], section_config)\n \n-    elif  section_key == 'target':\n-        for target in section_config:\n-            configure_section(targets[target], section_config[target])\n-    else:\n-        configure_section(sections[section_key], section_config)\n \n def write_uncommented(target, f):\n     block = []\n@@ -503,24 +512,36 @@ def write_uncommented(target, f):\n         is_comment = is_comment and line.startswith('#')\n     return f\n \n-# Now that we've built up our `config.toml`, write it all out in the same\n-# order that we read it in.\n-p(\"\")\n-p(\"writing `config.toml` in current directory\")\n-with bootstrap.output('config.toml') as f:\n+\n+def write_config_toml(writer, section_order, targets, sections):\n     for section in section_order:\n         if section == 'target':\n             for target in targets:\n-                f = write_uncommented(targets[target], f)\n+                writer = write_uncommented(targets[target], writer)\n         else:\n-            f = write_uncommented(sections[section], f)\n-\n-with bootstrap.output('Makefile') as f:\n-    contents = os.path.join(rust_dir, 'src', 'bootstrap', 'mk', 'Makefile.in')\n-    contents = open(contents).read()\n-    contents = contents.replace(\"$(CFG_SRC_DIR)\", rust_dir + '/')\n-    contents = contents.replace(\"$(CFG_PYTHON)\", sys.executable)\n-    f.write(contents)\n-\n-p(\"\")\n-p(\"run `python {}/x.py --help`\".format(rust_dir))\n+            writer = write_uncommented(sections[section], writer)\n+\n+\n+if __name__ == \"__main__\":\n+    p(\"processing command line\")\n+    # Parse all known arguments into a configuration structure that reflects the\n+    # TOML we're going to write out\n+    p(\"\")\n+    section_order, sections, targets = parse_args(sys.argv[1:])\n+\n+    # Now that we've built up our `config.toml`, write it all out in the same\n+    # order that we read it in.\n+    p(\"\")\n+    p(\"writing `config.toml` in current directory\")\n+    with bootstrap.output('config.toml') as f:\n+        write_config_toml(f, section_order, targets, sections)\n+\n+    with bootstrap.output('Makefile') as f:\n+        contents = os.path.join(rust_dir, 'src', 'bootstrap', 'mk', 'Makefile.in')\n+        contents = open(contents).read()\n+        contents = contents.replace(\"$(CFG_SRC_DIR)\", rust_dir + '/')\n+        contents = contents.replace(\"$(CFG_PYTHON)\", sys.executable)\n+        f.write(contents)\n+\n+    p(\"\")\n+    p(\"run `python {}/x.py --help`\".format(rust_dir))"}]}