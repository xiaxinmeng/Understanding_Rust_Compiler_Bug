{"sha": "e68333a689dc0f665018514f966b3f1098a8adf0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2ODMzM2E2ODlkYzBmNjY1MDE4NTE0Zjk2NmIzZjEwOThhOGFkZjA=", "commit": {"author": {"name": "Jonas Hietala", "email": "tradet.h@gmail.com", "date": "2014-07-20T12:59:13Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-21T16:54:31Z"}, "message": "Polish bitv docs.", "tree": {"sha": "0704ee40287f751db3578a7df01eef6f111d4882", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0704ee40287f751db3578a7df01eef6f111d4882"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e68333a689dc0f665018514f966b3f1098a8adf0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e68333a689dc0f665018514f966b3f1098a8adf0", "html_url": "https://github.com/rust-lang/rust/commit/e68333a689dc0f665018514f966b3f1098a8adf0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e68333a689dc0f665018514f966b3f1098a8adf0/comments", "author": {"login": "treeman", "id": 162027, "node_id": "MDQ6VXNlcjE2MjAyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162027?v=4", "gravatar_id": "", "url": "https://api.github.com/users/treeman", "html_url": "https://github.com/treeman", "followers_url": "https://api.github.com/users/treeman/followers", "following_url": "https://api.github.com/users/treeman/following{/other_user}", "gists_url": "https://api.github.com/users/treeman/gists{/gist_id}", "starred_url": "https://api.github.com/users/treeman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/treeman/subscriptions", "organizations_url": "https://api.github.com/users/treeman/orgs", "repos_url": "https://api.github.com/users/treeman/repos", "events_url": "https://api.github.com/users/treeman/events{/privacy}", "received_events_url": "https://api.github.com/users/treeman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71afdc4323773b1351e7ddccecdfeec2b65e932f", "url": "https://api.github.com/repos/rust-lang/rust/commits/71afdc4323773b1351e7ddccecdfeec2b65e932f", "html_url": "https://github.com/rust-lang/rust/commit/71afdc4323773b1351e7ddccecdfeec2b65e932f"}], "stats": {"total": 121, "additions": 65, "deletions": 56}, "files": [{"sha": "e8439d83e5e019074d5aa62ec4ad8332ede4a965", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 44, "deletions": 39, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/e68333a689dc0f665018514f966b3f1098a8adf0/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e68333a689dc0f665018514f966b3f1098a8adf0/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=e68333a689dc0f665018514f966b3f1098a8adf0", "patch": "@@ -25,6 +25,8 @@\n //!\n //! // Store the primes as a BitvSet\n //! let primes = {\n+//!     // Assume all numbers are prime to begin, and then we\n+//!     // cross off non-primes progressively\n //!     let mut bv = Bitv::with_capacity(max_prime, true);\n //!\n //!     // Neither 0 nor 1 are prime\n@@ -33,8 +35,8 @@\n //!\n //!     for i in range(2, max_prime) {\n //!         // if i is a prime\n-//!         if bv.get(i) {\n-//!             // mark all multiples of i as non-prime (any multiples below i * i\n+//!         if bv[i] {\n+//!             // Mark all multiples of i as non-prime (any multiples below i * i\n //!             // will have been marked as non-prime previously)\n //!             for j in iter::range_step(i * i, max_prime, i) { bv.set(j, false) }\n //!         }\n@@ -252,6 +254,9 @@ impl Bitv {\n     /// let bv: Bitv = [false, true].iter().map(|n| *n).collect();\n     /// assert_eq!(bv.get(0), false);\n     /// assert_eq!(bv.get(1), true);\n+    ///\n+    /// // Can also use array indexing\n+    /// assert_eq!(bv[1], true);\n     /// ```\n     #[inline]\n     pub fn get(&self, i: uint) -> bool {\n@@ -275,7 +280,7 @@ impl Bitv {\n     ///\n     /// let mut bv = Bitv::with_capacity(5, false);\n     /// bv.set(3, true);\n-    /// assert_eq!(bv.get(3), true);\n+    /// assert_eq!(bv[3], true);\n     /// ```\n     #[inline]\n     pub fn set(&mut self, i: uint, x: bool) {\n@@ -478,7 +483,7 @@ impl Bitv {\n     /// Organise the bits into bytes, such that the first bit in the\n     /// `Bitv` becomes the high-order bit of the first byte. If the\n     /// size of the `Bitv` is not a multiple of 8 then trailing bits\n-    /// will be filled-in with false/0.\n+    /// will be filled-in with `false`.\n     ///\n     /// # Example\n     ///\n@@ -716,9 +721,9 @@ impl Bitv {\n /// # Example\n ///\n /// ```\n-/// use std::collections::bitv::from_bytes;\n+/// use std::collections::bitv;\n ///\n-/// let bv = from_bytes([0b10100000, 0b00010010]);\n+/// let bv = bitv::from_bytes([0b10100000, 0b00010010]);\n /// assert!(bv.eq_vec([true, false, true, false,\n ///                    false, false, false, false,\n ///                    false, false, false, true,\n@@ -898,7 +903,7 @@ impl<'a> RandomAccessIterator<bool> for Bits<'a> {\n ///\n /// ```\n /// use std::collections::{BitvSet, Bitv};\n-/// use std::collections::bitv::from_bytes;\n+/// use std::collections::bitv;\n ///\n /// // It's a regular set\n /// let mut s = BitvSet::new();\n@@ -913,7 +918,7 @@ impl<'a> RandomAccessIterator<bool> for Bits<'a> {\n /// }\n ///\n /// // Can initialize from a `Bitv`\n-/// let other = BitvSet::from_bitv(from_bytes([0b11010000]));\n+/// let other = BitvSet::from_bitv(bitv::from_bytes([0b11010000]));\n ///\n /// s.union_with(&other);\n ///\n@@ -1048,7 +1053,7 @@ impl BitvSet {\n     /// s.insert(0);\n     ///\n     /// let bv = s.get_ref();\n-    /// assert_eq!(bv.get(0), true);\n+    /// assert_eq!(bv[0], true);\n     /// ```\n     #[inline]\n     pub fn get_ref<'a>(&'a self) -> &'a Bitv {\n@@ -1131,9 +1136,9 @@ impl BitvSet {\n     ///\n     /// ```\n     /// use std::collections::BitvSet;\n-    /// use std::collections::bitv::from_bytes;\n+    /// use std::collections::bitv;\n     ///\n-    /// let s = BitvSet::from_bitv(from_bytes([0b01001010]));\n+    /// let s = BitvSet::from_bitv(bitv::from_bytes([0b01001010]));\n     ///\n     /// // Print 1, 4, 6 in arbitrary order\n     /// for x in s.iter() {\n@@ -1152,10 +1157,10 @@ impl BitvSet {\n     ///\n     /// ```\n     /// use std::collections::BitvSet;\n-    /// use std::collections::bitv::from_bytes;\n+    /// use std::collections::bitv;\n     ///\n-    /// let a = BitvSet::from_bitv(from_bytes([0b01101000]));\n-    /// let b = BitvSet::from_bitv(from_bytes([0b10100000]));\n+    /// let a = BitvSet::from_bitv(bitv::from_bytes([0b01101000]));\n+    /// let b = BitvSet::from_bitv(bitv::from_bytes([0b10100000]));\n     ///\n     /// // Print 0, 1, 2, 4 in arbitrary order\n     /// for x in a.union(&b) {\n@@ -1180,10 +1185,10 @@ impl BitvSet {\n     ///\n     /// ```\n     /// use std::collections::BitvSet;\n-    /// use std::collections::bitv::from_bytes;\n+    /// use std::collections::bitv;\n     ///\n-    /// let a = BitvSet::from_bitv(from_bytes([0b01101000]));\n-    /// let b = BitvSet::from_bitv(from_bytes([0b10100000]));\n+    /// let a = BitvSet::from_bitv(bitv::from_bytes([0b01101000]));\n+    /// let b = BitvSet::from_bitv(bitv::from_bytes([0b10100000]));\n     ///\n     /// // Print 2\n     /// for x in a.intersection(&b) {\n@@ -1209,10 +1214,10 @@ impl BitvSet {\n     ///\n     /// ```\n     /// use std::collections::BitvSet;\n-    /// use std::collections::bitv::from_bytes;\n+    /// use std::collections::bitv;\n     ///\n-    /// let a = BitvSet::from_bitv(from_bytes([0b01101000]));\n-    /// let b = BitvSet::from_bitv(from_bytes([0b10100000]));\n+    /// let a = BitvSet::from_bitv(bitv::from_bytes([0b01101000]));\n+    /// let b = BitvSet::from_bitv(bitv::from_bytes([0b10100000]));\n     ///\n     /// // Print 2, 4 in arbitrary order\n     /// for x in a.difference(&b) {\n@@ -1245,10 +1250,10 @@ impl BitvSet {\n     ///\n     /// ```\n     /// use std::collections::BitvSet;\n-    /// use std::collections::bitv::from_bytes;\n+    /// use std::collections::bitv;\n     ///\n-    /// let a = BitvSet::from_bitv(from_bytes([0b01101000]));\n-    /// let b = BitvSet::from_bitv(from_bytes([0b10100000]));\n+    /// let a = BitvSet::from_bitv(bitv::from_bytes([0b01101000]));\n+    /// let b = BitvSet::from_bitv(bitv::from_bytes([0b10100000]));\n     ///\n     /// // Print 0, 1, 4 in arbitrary order\n     /// for x in a.symmetric_difference(&b) {\n@@ -1272,13 +1277,13 @@ impl BitvSet {\n     ///\n     /// ```\n     /// use std::collections::BitvSet;\n-    /// use std::collections::bitv::from_bytes;\n+    /// use std::collections::bitv;\n     ///\n-    /// let mut a = BitvSet::from_bitv(from_bytes([0b01101000]));\n-    /// let b = BitvSet::from_bitv(from_bytes([0b10100000]));\n+    /// let mut a = BitvSet::from_bitv(bitv::from_bytes([0b01101000]));\n+    /// let b = BitvSet::from_bitv(bitv::from_bytes([0b10100000]));\n     ///\n     /// a.union_with(&b);\n-    /// assert_eq!(a.unwrap(), from_bytes([0b11101000]));\n+    /// assert_eq!(a.unwrap(), bitv::from_bytes([0b11101000]));\n     /// ```\n     #[inline]\n     pub fn union_with(&mut self, other: &BitvSet) {\n@@ -1291,13 +1296,13 @@ impl BitvSet {\n     ///\n     /// ```\n     /// use std::collections::BitvSet;\n-    /// use std::collections::bitv::from_bytes;\n+    /// use std::collections::bitv;\n     ///\n-    /// let mut a = BitvSet::from_bitv(from_bytes([0b01101000]));\n-    /// let b = BitvSet::from_bitv(from_bytes([0b10100000]));\n+    /// let mut a = BitvSet::from_bitv(bitv::from_bytes([0b01101000]));\n+    /// let b = BitvSet::from_bitv(bitv::from_bytes([0b10100000]));\n     ///\n     /// a.intersect_with(&b);\n-    /// assert_eq!(a.unwrap(), from_bytes([0b00100000]));\n+    /// assert_eq!(a.unwrap(), bitv::from_bytes([0b00100000]));\n     /// ```\n     #[inline]\n     pub fn intersect_with(&mut self, other: &BitvSet) {\n@@ -1310,13 +1315,13 @@ impl BitvSet {\n     ///\n     /// ```\n     /// use std::collections::BitvSet;\n-    /// use std::collections::bitv::from_bytes;\n+    /// use std::collections::bitv;\n     ///\n-    /// let mut a = BitvSet::from_bitv(from_bytes([0b01101000]));\n-    /// let b = BitvSet::from_bitv(from_bytes([0b10100000]));\n+    /// let mut a = BitvSet::from_bitv(bitv::from_bytes([0b01101000]));\n+    /// let b = BitvSet::from_bitv(bitv::from_bytes([0b10100000]));\n     ///\n     /// a.difference_with(&b);\n-    /// assert_eq!(a.unwrap(), from_bytes([0b01001000]));\n+    /// assert_eq!(a.unwrap(), bitv::from_bytes([0b01001000]));\n     /// ```\n     #[inline]\n     pub fn difference_with(&mut self, other: &BitvSet) {\n@@ -1329,13 +1334,13 @@ impl BitvSet {\n     ///\n     /// ```\n     /// use std::collections::BitvSet;\n-    /// use std::collections::bitv::from_bytes;\n+    /// use std::collections::bitv;\n     ///\n-    /// let mut a = BitvSet::from_bitv(from_bytes([0b01101000]));\n-    /// let b = BitvSet::from_bitv(from_bytes([0b10100000]));\n+    /// let mut a = BitvSet::from_bitv(bitv::from_bytes([0b01101000]));\n+    /// let b = BitvSet::from_bitv(bitv::from_bytes([0b10100000]));\n     ///\n     /// a.symmetric_difference_with(&b);\n-    /// assert_eq!(a.unwrap(), from_bytes([0b11001000]));\n+    /// assert_eq!(a.unwrap(), bitv::from_bytes([0b11001000]));\n     /// ```\n     #[inline]\n     pub fn symmetric_difference_with(&mut self, other: &BitvSet) {"}, {"sha": "fba89df1bbc6b2555b9cbb75158d3f9f17866b2c", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e68333a689dc0f665018514f966b3f1098a8adf0/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e68333a689dc0f665018514f966b3f1098a8adf0/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=e68333a689dc0f665018514f966b3f1098a8adf0", "patch": "@@ -330,36 +330,36 @@ pub trait MutableSet<T>: Set<T> + Mutable {\n ///\n /// # Example\n ///\n-/// With a `Deque` we can simulate a stack:\n+/// With a `Deque` we can simulate a queue efficiently:\n ///\n /// ```\n /// use std::collections::{RingBuf, Deque};\n ///\n-/// let mut stack = RingBuf::new();\n-/// stack.push_front(1i);\n-/// stack.push_front(2i);\n-/// stack.push_front(3i);\n+/// let mut queue = RingBuf::new();\n+/// queue.push_back(1i);\n+/// queue.push_back(2i);\n+/// queue.push_back(3i);\n ///\n-/// // Will print 3, 2, 1\n-/// while !stack.is_empty() {\n-///     let x = stack.pop_front().unwrap();\n+/// // Will print 1, 2, 3\n+/// while !queue.is_empty() {\n+///     let x = queue.pop_front().unwrap();\n ///     println!(\"{}\", x);\n /// }\n /// ```\n ///\n-/// We can simulate a queue:\n+/// We can also simulate a stack:\n ///\n /// ```\n /// use std::collections::{RingBuf, Deque};\n ///\n-/// let mut queue = RingBuf::new();\n-/// queue.push_back(1i);\n-/// queue.push_back(2i);\n-/// queue.push_back(3i);\n+/// let mut stack = RingBuf::new();\n+/// stack.push_front(1i);\n+/// stack.push_front(2i);\n+/// stack.push_front(3i);\n ///\n-/// // Will print 1, 2, 3\n-/// while !queue.is_empty() {\n-///     let x = queue.pop_front().unwrap();\n+/// // Will print 3, 2, 1\n+/// while !stack.is_empty() {\n+///     let x = stack.pop_front().unwrap();\n ///     println!(\"{}\", x);\n /// }\n /// ```\n@@ -385,7 +385,7 @@ pub trait MutableSet<T>: Set<T> + Mutable {\n /// }\n /// ```\n pub trait Deque<T> : Mutable {\n-    /// Provide a reference to the front element, or `None` if the sequence is.\n+    /// Provide a reference to the front element, or `None` if the sequence is\n     /// empty.\n     ///\n     /// # Example\n@@ -472,6 +472,7 @@ pub trait Deque<T> : Mutable {\n     /// d.push_front(1i);\n     /// d.push_front(2i);\n     /// assert_eq!(d.front(), Some(&2i));\n+    /// ```\n     fn push_front(&mut self, elt: T);\n \n     /// Insert an element last in the sequence.\n@@ -485,6 +486,7 @@ pub trait Deque<T> : Mutable {\n     /// d.push_back(1i);\n     /// d.push_back(2i);\n     /// assert_eq!(d.front(), Some(&1i));\n+    /// ```\n     fn push_back(&mut self, elt: T);\n \n     /// Remove the last element and return it, or `None` if the sequence is empty.\n@@ -501,6 +503,7 @@ pub trait Deque<T> : Mutable {\n     /// assert_eq!(d.pop_back(), Some(2i));\n     /// assert_eq!(d.pop_back(), Some(1i));\n     /// assert_eq!(d.pop_back(), None);\n+    /// ```\n     fn pop_back(&mut self) -> Option<T>;\n \n     /// Remove the first element and return it, or `None` if the sequence is empty.\n@@ -517,6 +520,7 @@ pub trait Deque<T> : Mutable {\n     /// assert_eq!(d.pop_front(), Some(1i));\n     /// assert_eq!(d.pop_front(), Some(2i));\n     /// assert_eq!(d.pop_front(), None);\n+    /// ```\n     fn pop_front(&mut self) -> Option<T>;\n }\n "}]}