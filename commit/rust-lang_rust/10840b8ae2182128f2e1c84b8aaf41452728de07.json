{"sha": "10840b8ae2182128f2e1c84b8aaf41452728de07", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwODQwYjhhZTIxODIxMjhmMmUxYzg0YjhhYWY0MTQ1MjcyOGRlMDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-08T08:39:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-08T08:39:56Z"}, "message": "Auto merge of #62366 - lzutao:feature/float-from-to-bytes, r=SimonSapin\n\nAdd float conversions to and from bytes\n\nRework of #58756. Address https://github.com/rust-lang/rust/pull/58756#issuecomment-488385889.\n\nFixes #57492.\n\nr? @SimonSapin", "tree": {"sha": "1bcf36cef776e86f7210f273eaa7fc989362ff23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1bcf36cef776e86f7210f273eaa7fc989362ff23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10840b8ae2182128f2e1c84b8aaf41452728de07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10840b8ae2182128f2e1c84b8aaf41452728de07", "html_url": "https://github.com/rust-lang/rust/commit/10840b8ae2182128f2e1c84b8aaf41452728de07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10840b8ae2182128f2e1c84b8aaf41452728de07/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db592f4627251cfd8571a05cf8e06a56be9470c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/db592f4627251cfd8571a05cf8e06a56be9470c2", "html_url": "https://github.com/rust-lang/rust/commit/db592f4627251cfd8571a05cf8e06a56be9470c2"}, {"sha": "df53a3fd55a233cc04ce20d448f64ec70b937b06", "url": "https://api.github.com/repos/rust-lang/rust/commits/df53a3fd55a233cc04ce20d448f64ec70b937b06", "html_url": "https://github.com/rust-lang/rust/commit/df53a3fd55a233cc04ce20d448f64ec70b937b06"}], "stats": {"total": 242, "additions": 236, "deletions": 6}, "files": [{"sha": "fc2c431ca0f9ccc00311782ff93798ffbc602ac6", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 118, "deletions": 3, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/10840b8ae2182128f2e1c84b8aaf41452728de07/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10840b8ae2182128f2e1c84b8aaf41452728de07/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=10840b8ae2182128f2e1c84b8aaf41452728de07", "patch": "@@ -450,15 +450,130 @@ impl f32 {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::f32;\n     /// let v = f32::from_bits(0x41480000);\n-    /// let difference = (v - 12.5).abs();\n-    /// assert!(difference <= 1e-5);\n+    /// assert_eq!(v, 12.5);\n     /// ```\n     #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n     #[inline]\n     pub fn from_bits(v: u32) -> Self {\n         // It turns out the safety issues with sNaN were overblown! Hooray!\n         unsafe { mem::transmute(v) }\n     }\n+\n+    /// Return the memory representation of this floating point number as a byte array in\n+    /// big-endian (network) byte order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(float_to_from_bytes)]\n+    /// let bytes = 12.5f32.to_be_bytes();\n+    /// assert_eq!(bytes, [0x41, 0x48, 0x00, 0x00]);\n+    /// ```\n+    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[inline]\n+    pub fn to_be_bytes(self) -> [u8; 4] {\n+        self.to_bits().to_be_bytes()\n+    }\n+\n+    /// Return the memory representation of this floating point number as a byte array in\n+    /// little-endian byte order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(float_to_from_bytes)]\n+    /// let bytes = 12.5f32.to_le_bytes();\n+    /// assert_eq!(bytes, [0x00, 0x00, 0x48, 0x41]);\n+    /// ```\n+    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[inline]\n+    pub fn to_le_bytes(self) -> [u8; 4] {\n+        self.to_bits().to_le_bytes()\n+    }\n+\n+    /// Return the memory representation of this floating point number as a byte array in\n+    /// native byte order.\n+    ///\n+    /// As the target platform's native endianness is used, portable code\n+    /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate, instead.\n+    ///\n+    /// [`to_be_bytes`]: #method.to_be_bytes\n+    /// [`to_le_bytes`]: #method.to_le_bytes\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(float_to_from_bytes)]\n+    /// let bytes = 12.5f32.to_ne_bytes();\n+    /// assert_eq!(\n+    ///     bytes,\n+    ///     if cfg!(target_endian = \"big\") {\n+    ///         [0x41, 0x48, 0x00, 0x00]\n+    ///     } else {\n+    ///         [0x00, 0x00, 0x48, 0x41]\n+    ///     }\n+    /// );\n+    /// ```\n+    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[inline]\n+    pub fn to_ne_bytes(self) -> [u8; 4] {\n+        self.to_bits().to_ne_bytes()\n+    }\n+\n+    /// Create a floating point value from its representation as a byte array in big endian.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(float_to_from_bytes)]\n+    /// let value = f32::from_be_bytes([0x41, 0x48, 0x00, 0x00]);\n+    /// assert_eq!(value, 12.5);\n+    /// ```\n+    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[inline]\n+    pub fn from_be_bytes(bytes: [u8; 4]) -> Self {\n+        Self::from_bits(u32::from_be_bytes(bytes))\n+    }\n+\n+    /// Create a floating point value from its representation as a byte array in big endian.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(float_to_from_bytes)]\n+    /// let value = f32::from_le_bytes([0x00, 0x00, 0x48, 0x41]);\n+    /// assert_eq!(value, 12.5);\n+    /// ```\n+    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[inline]\n+    pub fn from_le_bytes(bytes: [u8; 4]) -> Self {\n+        Self::from_bits(u32::from_le_bytes(bytes))\n+    }\n+\n+    /// Create a floating point value from its representation as a byte array in big endian.\n+    ///\n+    /// As the target platform's native endianness is used, portable code\n+    /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n+    /// appropriate instead.\n+    ///\n+    /// [`from_be_bytes`]: #method.from_be_bytes\n+    /// [`from_le_bytes`]: #method.from_le_bytes\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(float_to_from_bytes)]\n+    /// let value = f32::from_ne_bytes(if cfg!(target_endian = \"big\") {\n+    ///     [0x41, 0x48, 0x00, 0x00]\n+    /// } else {\n+    ///     [0x00, 0x00, 0x48, 0x41]\n+    /// });\n+    /// assert_eq!(value, 12.5);\n+    /// ```\n+    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[inline]\n+    pub fn from_ne_bytes(bytes: [u8; 4]) -> Self {\n+        Self::from_bits(u32::from_ne_bytes(bytes))\n+    }\n }"}, {"sha": "6bd0b6e5c7f77de785f9237db7b7a83ecce82856", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 118, "deletions": 3, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/10840b8ae2182128f2e1c84b8aaf41452728de07/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10840b8ae2182128f2e1c84b8aaf41452728de07/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=10840b8ae2182128f2e1c84b8aaf41452728de07", "patch": "@@ -463,15 +463,130 @@ impl f64 {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::f64;\n     /// let v = f64::from_bits(0x4029000000000000);\n-    /// let difference = (v - 12.5).abs();\n-    /// assert!(difference <= 1e-5);\n+    /// assert_eq!(v, 12.5);\n     /// ```\n     #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n     #[inline]\n     pub fn from_bits(v: u64) -> Self {\n         // It turns out the safety issues with sNaN were overblown! Hooray!\n         unsafe { mem::transmute(v) }\n     }\n+\n+    /// Return the memory representation of this floating point number as a byte array in\n+    /// big-endian (network) byte order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(float_to_from_bytes)]\n+    /// let bytes = 12.5f64.to_be_bytes();\n+    /// assert_eq!(bytes, [0x40, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);\n+    /// ```\n+    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[inline]\n+    pub fn to_be_bytes(self) -> [u8; 8] {\n+        self.to_bits().to_be_bytes()\n+    }\n+\n+    /// Return the memory representation of this floating point number as a byte array in\n+    /// little-endian byte order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(float_to_from_bytes)]\n+    /// let bytes = 12.5f64.to_le_bytes();\n+    /// assert_eq!(bytes, [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x40]);\n+    /// ```\n+    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[inline]\n+    pub fn to_le_bytes(self) -> [u8; 8] {\n+        self.to_bits().to_le_bytes()\n+    }\n+\n+    /// Return the memory representation of this floating point number as a byte array in\n+    /// native byte order.\n+    ///\n+    /// As the target platform's native endianness is used, portable code\n+    /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate, instead.\n+    ///\n+    /// [`to_be_bytes`]: #method.to_be_bytes\n+    /// [`to_le_bytes`]: #method.to_le_bytes\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(float_to_from_bytes)]\n+    /// let bytes = 12.5f64.to_ne_bytes();\n+    /// assert_eq!(\n+    ///     bytes,\n+    ///     if cfg!(target_endian = \"big\") {\n+    ///         [0x40, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]\n+    ///     } else {\n+    ///         [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x40]\n+    ///     }\n+    /// );\n+    /// ```\n+    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[inline]\n+    pub fn to_ne_bytes(self) -> [u8; 8] {\n+        self.to_bits().to_ne_bytes()\n+    }\n+\n+    /// Create a floating point value from its representation as a byte array in big endian.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(float_to_from_bytes)]\n+    /// let value = f64::from_be_bytes([0x40, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);\n+    /// assert_eq!(value, 12.5);\n+    /// ```\n+    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[inline]\n+    pub fn from_be_bytes(bytes: [u8; 8]) -> Self {\n+        Self::from_bits(u64::from_be_bytes(bytes))\n+    }\n+\n+    /// Create a floating point value from its representation as a byte array in big endian.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(float_to_from_bytes)]\n+    /// let value = f64::from_le_bytes([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x40]);\n+    /// assert_eq!(value, 12.5);\n+    /// ```\n+    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[inline]\n+    pub fn from_le_bytes(bytes: [u8; 8]) -> Self {\n+        Self::from_bits(u64::from_le_bytes(bytes))\n+    }\n+\n+    /// Create a floating point value from its representation as a byte array in big endian.\n+    ///\n+    /// As the target platform's native endianness is used, portable code\n+    /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n+    /// appropriate instead.\n+    ///\n+    /// [`from_be_bytes`]: #method.from_be_bytes\n+    /// [`from_le_bytes`]: #method.from_le_bytes\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(float_to_from_bytes)]\n+    /// let value = f64::from_ne_bytes(if cfg!(target_endian = \"big\") {\n+    ///     [0x40, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]\n+    /// } else {\n+    ///     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x40]\n+    /// });\n+    /// assert_eq!(value, 12.5);\n+    /// ```\n+    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[inline]\n+    pub fn from_ne_bytes(bytes: [u8; 8]) -> Self {\n+        Self::from_bits(u64::from_ne_bytes(bytes))\n+    }\n }"}]}