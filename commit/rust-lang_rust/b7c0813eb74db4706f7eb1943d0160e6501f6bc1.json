{"sha": "b7c0813eb74db4706f7eb1943d0160e6501f6bc1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3YzA4MTNlYjc0ZGI0NzA2ZjdlYjE5NDNkMDE2MGU2NTAxZjZiYzE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-19T00:39:32Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-19T01:57:35Z"}, "message": "Round 4 test fixes and rebase conflicts", "tree": {"sha": "6fcaddd15e86efb0d49b338ff55ac8e3995c82b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6fcaddd15e86efb0d49b338ff55ac8e3995c82b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7c0813eb74db4706f7eb1943d0160e6501f6bc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7c0813eb74db4706f7eb1943d0160e6501f6bc1", "html_url": "https://github.com/rust-lang/rust/commit/b7c0813eb74db4706f7eb1943d0160e6501f6bc1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7c0813eb74db4706f7eb1943d0160e6501f6bc1/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63f51ee90ccc1b7ab3a749ba7dbd4a3c76961c16", "url": "https://api.github.com/repos/rust-lang/rust/commits/63f51ee90ccc1b7ab3a749ba7dbd4a3c76961c16", "html_url": "https://github.com/rust-lang/rust/commit/63f51ee90ccc1b7ab3a749ba7dbd4a3c76961c16"}], "stats": {"total": 199, "additions": 180, "deletions": 19}, "files": [{"sha": "6569ab9c05acd768f56d4d4d5d9b9ddd32c65943", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7c0813eb74db4706f7eb1943d0160e6501f6bc1/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7c0813eb74db4706f7eb1943d0160e6501f6bc1/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=b7c0813eb74db4706f7eb1943d0160e6501f6bc1", "patch": "@@ -147,7 +147,6 @@ mod std {\n #[cfg(test)]\n mod prelude {\n     // from core.\n-    pub use core::borrow::IntoCow;\n     pub use core::clone::Clone;\n     pub use core::cmp::{PartialEq, Eq, PartialOrd, Ord};\n     pub use core::cmp::Ordering::{Less, Equal, Greater};\n@@ -173,6 +172,7 @@ mod prelude {\n     pub use unicode::char::CharExt;\n \n     // from collections.\n+    pub use borrow::IntoCow;\n     pub use slice::SliceConcatExt;\n     pub use string::{String, ToString};\n     pub use vec::Vec;"}, {"sha": "c142819a5189671bf8400aed0fe5c0fe357a48c6", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7c0813eb74db4706f7eb1943d0160e6501f6bc1/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7c0813eb74db4706f7eb1943d0160e6501f6bc1/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=b7c0813eb74db4706f7eb1943d0160e6501f6bc1", "patch": "@@ -1041,7 +1041,7 @@ mod tests {\n     }\n \n     #[cfg(test)]\n-    fn list_from<T: Clone>(v: &[T]) -> DList<T> {\n+    fn list_from<T: Clone>(v: &[T]) -> LinkedList<T> {\n         v.iter().cloned().collect()\n     }\n "}, {"sha": "776b8b3af147c262b31fafccd74c9b376f070279", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7c0813eb74db4706f7eb1943d0160e6501f6bc1/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7c0813eb74db4706f7eb1943d0160e6501f6bc1/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=b7c0813eb74db4706f7eb1943d0160e6501f6bc1", "patch": "@@ -1997,9 +1997,9 @@ mod tests {\n \n     #[test]\n     fn test_lexicographic_permutations_empty_and_short() {\n-        let empty : &mut[i32] = &mut[..];\n+        let empty : &mut[i32] = &mut[];\n         assert!(empty.next_permutation() == false);\n-        let b: &mut[i32] = &mut[..];\n+        let b: &mut[i32] = &mut[];\n         assert!(empty == b);\n         assert!(empty.prev_permutation() == false);\n         assert!(empty == b);"}, {"sha": "d284eb341792b4d363c3cd6896346b7db581a32d", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b7c0813eb74db4706f7eb1943d0160e6501f6bc1/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7c0813eb74db4706f7eb1943d0160e6501f6bc1/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=b7c0813eb74db4706f7eb1943d0160e6501f6bc1", "patch": "@@ -301,7 +301,7 @@ impl<T:?Sized> MarkerTrait for T { }\n /// As an example, consider a trait with no methods like `Even`, meant\n /// to represent types that are \"even\":\n ///\n-/// ```rust\n+/// ```rust,ignore\n /// trait Even { }\n /// ```\n ///\n@@ -310,7 +310,7 @@ impl<T:?Sized> MarkerTrait for T { }\n /// categorize types (and hence instances of those types) as \"even\" or\n /// not, so if we *were* going to have a method, it might look like:\n ///\n-/// ```rust\n+/// ```rust,ignore\n /// trait Even {\n ///     fn is_even(self) -> bool { true }\n /// }\n@@ -319,7 +319,7 @@ impl<T:?Sized> MarkerTrait for T { }\n /// Therefore, we can model a method like this as follows:\n ///\n /// ```rust\n-/// use std::marker::PhantomFn\n+/// use std::marker::PhantomFn;\n /// trait Even : PhantomFn<Self> { }\n /// ```\n ///"}, {"sha": "2d1a5e10bd63f73a6e815452f8ea9abb41e35cf6", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7c0813eb74db4706f7eb1943d0160e6501f6bc1/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7c0813eb74db4706f7eb1943d0160e6501f6bc1/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=b7c0813eb74db4706f7eb1943d0160e6501f6bc1", "patch": "@@ -283,7 +283,7 @@ pub mod compat {\n                   fallback: usize) -> usize {\n         let mut module: Vec<u16> = module.utf16_units().collect();\n         module.push(0);\n-        let symbol = CString::from_slice(symbol.as_bytes());\n+        let symbol = CString::new(symbol).unwrap();\n         let func = unsafe {\n             let handle = GetModuleHandleW(module.as_ptr());\n             GetProcAddress(handle, symbol.as_ptr()) as usize"}, {"sha": "e001cd9a1ec8bf9c6e104335caa14007c6317078", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 165, "deletions": 1, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/b7c0813eb74db4706f7eb1943d0160e6501f6bc1/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7c0813eb74db4706f7eb1943d0160e6501f6bc1/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=b7c0813eb74db4706f7eb1943d0160e6501f6bc1", "patch": "@@ -10,7 +10,7 @@\n \n use prelude::v1::*;\n \n-use collections::hash_map::Hasher;\n+#[cfg(stage0)] use collections::hash_map::Hasher;\n use collections;\n use env;\n use ffi::CString;\n@@ -106,6 +106,7 @@ impl Process {\n     }\n \n     #[allow(deprecated)]\n+    #[cfg(stage0)]\n     pub fn spawn<K, V, C, P>(cfg: &C, in_fd: Option<P>,\n                               out_fd: Option<P>, err_fd: Option<P>)\n                               -> IoResult<Process>\n@@ -267,6 +268,169 @@ impl Process {\n             })\n         }\n     }\n+    #[allow(deprecated)]\n+    #[cfg(not(stage0))]\n+    pub fn spawn<K, V, C, P>(cfg: &C, in_fd: Option<P>,\n+                              out_fd: Option<P>, err_fd: Option<P>)\n+                              -> IoResult<Process>\n+        where C: ProcessConfig<K, V>, P: AsInner<FileDesc>,\n+              K: BytesContainer + Eq + Hash, V: BytesContainer\n+    {\n+        use libc::types::os::arch::extra::{DWORD, HANDLE, STARTUPINFO};\n+        use libc::consts::os::extra::{\n+            TRUE, FALSE,\n+            STARTF_USESTDHANDLES,\n+            INVALID_HANDLE_VALUE,\n+            DUPLICATE_SAME_ACCESS\n+        };\n+        use libc::funcs::extra::kernel32::{\n+            GetCurrentProcess,\n+            DuplicateHandle,\n+            CloseHandle,\n+            CreateProcessW\n+        };\n+        use libc::funcs::extra::msvcrt::get_osfhandle;\n+\n+        use mem;\n+        use iter::IteratorExt;\n+        use str::StrExt;\n+\n+        if cfg.gid().is_some() || cfg.uid().is_some() {\n+            return Err(IoError {\n+                kind: old_io::IoUnavailable,\n+                desc: \"unsupported gid/uid requested on windows\",\n+                detail: None,\n+            })\n+        }\n+\n+        // To have the spawning semantics of unix/windows stay the same, we need to\n+        // read the *child's* PATH if one is provided. See #15149 for more details.\n+        let program = cfg.env().and_then(|env| {\n+            for (key, v) in env {\n+                if b\"PATH\" != key.container_as_bytes() { continue }\n+\n+                // Split the value and test each path to see if the\n+                // program exists.\n+                for path in os::split_paths(v.container_as_bytes()) {\n+                    let path = path.join(cfg.program().as_bytes())\n+                                   .with_extension(env::consts::EXE_EXTENSION);\n+                    if path.exists() {\n+                        return Some(CString::from_slice(path.as_vec()))\n+                    }\n+                }\n+                break\n+            }\n+            None\n+        });\n+\n+        unsafe {\n+            let mut si = zeroed_startupinfo();\n+            si.cb = mem::size_of::<STARTUPINFO>() as DWORD;\n+            si.dwFlags = STARTF_USESTDHANDLES;\n+\n+            let cur_proc = GetCurrentProcess();\n+\n+            // Similarly to unix, we don't actually leave holes for the stdio file\n+            // descriptors, but rather open up /dev/null equivalents. These\n+            // equivalents are drawn from libuv's windows process spawning.\n+            let set_fd = |fd: &Option<P>, slot: &mut HANDLE,\n+                          is_stdin: bool| {\n+                match *fd {\n+                    None => {\n+                        let access = if is_stdin {\n+                            libc::FILE_GENERIC_READ\n+                        } else {\n+                            libc::FILE_GENERIC_WRITE | libc::FILE_READ_ATTRIBUTES\n+                        };\n+                        let size = mem::size_of::<libc::SECURITY_ATTRIBUTES>();\n+                        let mut sa = libc::SECURITY_ATTRIBUTES {\n+                            nLength: size as libc::DWORD,\n+                            lpSecurityDescriptor: ptr::null_mut(),\n+                            bInheritHandle: 1,\n+                        };\n+                        let mut filename: Vec<u16> = \"NUL\".utf16_units().collect();\n+                        filename.push(0);\n+                        *slot = libc::CreateFileW(filename.as_ptr(),\n+                                                  access,\n+                                                  libc::FILE_SHARE_READ |\n+                                                      libc::FILE_SHARE_WRITE,\n+                                                  &mut sa,\n+                                                  libc::OPEN_EXISTING,\n+                                                  0,\n+                                                  ptr::null_mut());\n+                        if *slot == INVALID_HANDLE_VALUE {\n+                            return Err(super::last_error())\n+                        }\n+                    }\n+                    Some(ref fd) => {\n+                        let orig = get_osfhandle(fd.as_inner().fd()) as HANDLE;\n+                        if orig == INVALID_HANDLE_VALUE {\n+                            return Err(super::last_error())\n+                        }\n+                        if DuplicateHandle(cur_proc, orig, cur_proc, slot,\n+                                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n+                            return Err(super::last_error())\n+                        }\n+                    }\n+                }\n+                Ok(())\n+            };\n+\n+            try!(set_fd(&in_fd, &mut si.hStdInput, true));\n+            try!(set_fd(&out_fd, &mut si.hStdOutput, false));\n+            try!(set_fd(&err_fd, &mut si.hStdError, false));\n+\n+            let cmd_str = make_command_line(program.as_ref().unwrap_or(cfg.program()),\n+                                            cfg.args());\n+            let mut pi = zeroed_process_information();\n+            let mut create_err = None;\n+\n+            // stolen from the libuv code.\n+            let mut flags = libc::CREATE_UNICODE_ENVIRONMENT;\n+            if cfg.detach() {\n+                flags |= libc::DETACHED_PROCESS | libc::CREATE_NEW_PROCESS_GROUP;\n+            }\n+\n+            with_envp(cfg.env(), |envp| {\n+                with_dirp(cfg.cwd(), |dirp| {\n+                    let mut cmd_str: Vec<u16> = cmd_str.utf16_units().collect();\n+                    cmd_str.push(0);\n+                    let _lock = CREATE_PROCESS_LOCK.lock().unwrap();\n+                    let created = CreateProcessW(ptr::null(),\n+                                                 cmd_str.as_mut_ptr(),\n+                                                 ptr::null_mut(),\n+                                                 ptr::null_mut(),\n+                                                 TRUE,\n+                                                 flags, envp, dirp,\n+                                                 &mut si, &mut pi);\n+                    if created == FALSE {\n+                        create_err = Some(super::last_error());\n+                    }\n+                })\n+            });\n+\n+            assert!(CloseHandle(si.hStdInput) != 0);\n+            assert!(CloseHandle(si.hStdOutput) != 0);\n+            assert!(CloseHandle(si.hStdError) != 0);\n+\n+            match create_err {\n+                Some(err) => return Err(err),\n+                None => {}\n+            }\n+\n+            // We close the thread handle because we don't care about keeping the\n+            // thread id valid, and we aren't keeping the thread handle around to be\n+            // able to close it later. We don't close the process handle however\n+            // because std::we want the process id to stay valid at least until the\n+            // calling code closes the process handle.\n+            assert!(CloseHandle(pi.hThread) != 0);\n+\n+            Ok(Process {\n+                pid: pi.dwProcessId as pid_t,\n+                handle: pi.hProcess as *mut ()\n+            })\n+        }\n+    }\n \n     /// Waits for a process to exit and returns the exit code, failing\n     /// if there is no process with the specified id."}, {"sha": "1c95ee43d27af9166be3f3bfc7a91454050d8b24", "filename": "src/test/compile-fail/object-safety-phantom-fn.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b7c0813eb74db4706f7eb1943d0160e6501f6bc1/src%2Ftest%2Fcompile-fail%2Fobject-safety-phantom-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7c0813eb74db4706f7eb1943d0160e6501f6bc1/src%2Ftest%2Fcompile-fail%2Fobject-safety-phantom-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-phantom-fn.rs?ref=b7c0813eb74db4706f7eb1943d0160e6501f6bc1", "patch": "@@ -11,10 +11,16 @@\n // Check that `Self` appearing in a phantom fn does not make a trait not object safe.\n \n #![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+use std::marker::PhantomFn;\n \n trait Baz : PhantomFn<Self> {\n }\n \n+trait Bar<T> : PhantomFn<(Self, T)> {\n+}\n+\n fn make_bar<T:Bar<u32>>(t: &T) -> &Bar<u32> {\n     t\n }"}, {"sha": "e96c345034bce6c070873ff7b4b303da5bcfe6e7", "filename": "src/test/compile-fail/regions-assoc-type-in-supertrait-outlives-container.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7c0813eb74db4706f7eb1943d0160e6501f6bc1/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-in-supertrait-outlives-container.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7c0813eb74db4706f7eb1943d0160e6501f6bc1/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-in-supertrait-outlives-container.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-in-supertrait-outlives-container.rs?ref=b7c0813eb74db4706f7eb1943d0160e6501f6bc1", "patch": "@@ -15,9 +15,6 @@\n \n #![allow(dead_code)]\n \n-use std::mem::transmute;\n-use std::ops::Deref;\n-\n ///////////////////////////////////////////////////////////////////////////\n \n pub trait TheTrait {"}, {"sha": "6d8a02ab17480beb4dd567a9dcdb8cb1a3f12653", "filename": "src/test/compile-fail/regions-assoc-type-outlives-container-wc.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7c0813eb74db4706f7eb1943d0160e6501f6bc1/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-outlives-container-wc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7c0813eb74db4706f7eb1943d0160e6501f6bc1/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-outlives-container-wc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-outlives-container-wc.rs?ref=b7c0813eb74db4706f7eb1943d0160e6501f6bc1", "patch": "@@ -15,9 +15,6 @@\n \n #![allow(dead_code)]\n \n-use std::mem::transmute;\n-use std::ops::Deref;\n-\n ///////////////////////////////////////////////////////////////////////////\n \n pub trait TheTrait {"}, {"sha": "5fafec50a4b5863077501cefabe63cd097617a82", "filename": "src/test/compile-fail/regions-assoc-type-outlives-container.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7c0813eb74db4706f7eb1943d0160e6501f6bc1/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-outlives-container.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7c0813eb74db4706f7eb1943d0160e6501f6bc1/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-outlives-container.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-outlives-container.rs?ref=b7c0813eb74db4706f7eb1943d0160e6501f6bc1", "patch": "@@ -14,9 +14,6 @@\n \n #![allow(dead_code)]\n \n-use std::mem::transmute;\n-use std::ops::Deref;\n-\n ///////////////////////////////////////////////////////////////////////////\n \n pub trait TheTrait {"}, {"sha": "325fba8a0ee4288fe1852189e716733692faa59f", "filename": "src/test/run-pass/trait-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7c0813eb74db4706f7eb1943d0160e6501f6bc1/src%2Ftest%2Frun-pass%2Ftrait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7c0813eb74db4706f7eb1943d0160e6501f6bc1/src%2Ftest%2Frun-pass%2Ftrait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-impl.rs?ref=b7c0813eb74db4706f7eb1943d0160e6501f6bc1", "patch": "@@ -17,7 +17,7 @@ use traitimpl::Bar;\n static mut COUNT: uint = 1;\n \n trait T {\n-    fn foo(&self) {}\n+    fn t(&self) {}\n }\n \n impl<'a> T+'a {"}]}