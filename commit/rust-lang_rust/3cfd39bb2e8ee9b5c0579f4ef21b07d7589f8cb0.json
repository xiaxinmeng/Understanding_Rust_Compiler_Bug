{"sha": "3cfd39bb2e8ee9b5c0579f4ef21b07d7589f8cb0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjZmQzOWJiMmU4ZWU5YjVjMDU3OWY0ZWYyMWIwN2Q3NTg5ZjhjYjA=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-05-04T07:21:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-04T07:21:27Z"}, "message": "Rollup merge of #60516 - JohnTitor:remove-typeck, r=matthewjasper\n\nRemove TypeckMir\n\nFixes #60422\n\nr? @matthewjasper", "tree": {"sha": "e29440010fc4c6642da1a96e79872dc4692dcf84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e29440010fc4c6642da1a96e79872dc4692dcf84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3cfd39bb2e8ee9b5c0579f4ef21b07d7589f8cb0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJczT13CRBK7hj4Ov3rIwAAdHIIAF4Fsnw2y4qUX7GpCOsFeRRo\nrDelfD6n8nJGqxtJTPht1c35EUXd7SPH8pM4su/TG6khs4OWgyl32hfsNEhDhuhH\n0Qyeqhf52Tjl9AXTJZun9tV7jNlOzR8TTRw66NN1pzxRPrQvjLR6u3vm2T7PlYAI\nbUrJyq39FrFDpNjNTzUUKfvaGAY/u+YKM/wOo+OHfh0UELfw8NNRFGHHkOn+s97C\nCUT8hMMHDJx+ATL1HSIHxOIuM2qXeTkgkj4O1MYzneIr5jekus3eOQMWAEfmTGkS\ntGdVIS9CZta2u9B/PSrlnx1BLq4i7LMMGhEKs9qPg8I+ryhL5ZppAfy6ZQA3riw=\n=SgOE\n-----END PGP SIGNATURE-----\n", "payload": "tree e29440010fc4c6642da1a96e79872dc4692dcf84\nparent ffc33b3733196f139807bf5ff515f3232d6260df\nparent f734057c3c8cf621dc59d4c8e29b361d40c42612\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1556954487 +0200\ncommitter GitHub <noreply@github.com> 1556954487 +0200\n\nRollup merge of #60516 - JohnTitor:remove-typeck, r=matthewjasper\n\nRemove TypeckMir\n\nFixes #60422\n\nr? @matthewjasper\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3cfd39bb2e8ee9b5c0579f4ef21b07d7589f8cb0", "html_url": "https://github.com/rust-lang/rust/commit/3cfd39bb2e8ee9b5c0579f4ef21b07d7589f8cb0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3cfd39bb2e8ee9b5c0579f4ef21b07d7589f8cb0/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffc33b3733196f139807bf5ff515f3232d6260df", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffc33b3733196f139807bf5ff515f3232d6260df", "html_url": "https://github.com/rust-lang/rust/commit/ffc33b3733196f139807bf5ff515f3232d6260df"}, {"sha": "f734057c3c8cf621dc59d4c8e29b361d40c42612", "url": "https://api.github.com/repos/rust-lang/rust/commits/f734057c3c8cf621dc59d4c8e29b361d40c42612", "html_url": "https://github.com/rust-lang/rust/commit/f734057c3c8cf621dc59d4c8e29b361d40c42612"}], "stats": {"total": 323, "additions": 131, "deletions": 192}, "files": [{"sha": "58a164b38f9119e0f221d4f4f914d7208561eeb4", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3cfd39bb2e8ee9b5c0579f4ef21b07d7589f8cb0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cfd39bb2e8ee9b5c0579f4ef21b07d7589f8cb0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs?ref=3cfd39bb2e8ee9b5c0579f4ef21b07d7589f8cb0", "patch": "@@ -47,11 +47,10 @@ pub(super) fn generate<'gcx, 'tcx>(\n         mir.local_decls.indices().collect()\n     } else {\n         let free_regions = {\n-            let borrowck_context = typeck.borrowck_context.as_ref().unwrap();\n             regions_that_outlive_free_regions(\n                 typeck.infcx.num_region_vars(),\n-                &borrowck_context.universal_regions,\n-                &borrowck_context.constraints.outlives_constraints,\n+                &typeck.borrowck_context.universal_regions,\n+                &typeck.borrowck_context.constraints.outlives_constraints,\n             )\n         };\n         compute_live_locals(typeck.tcx(), &free_regions, mir)"}, {"sha": "87e9a704fac1e60d26d5fe9b02d2a488cb2dce60", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/trace.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3cfd39bb2e8ee9b5c0579f4ef21b07d7589f8cb0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cfd39bb2e8ee9b5c0579f4ef21b07d7589f8cb0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs?ref=3cfd39bb2e8ee9b5c0579f4ef21b07d7589f8cb0", "patch": "@@ -517,16 +517,15 @@ impl LivenessContext<'_, '_, '_, '_, 'tcx> {\n \n         let tcx = typeck.tcx();\n         tcx.for_each_free_region(&value, |live_region| {\n-            let borrowck_context = typeck.borrowck_context.as_mut().unwrap();\n-            let live_region_vid = borrowck_context\n+            let live_region_vid = typeck.borrowck_context\n                 .universal_regions\n                 .to_region_vid(live_region);\n-            borrowck_context\n+            typeck.borrowck_context\n                 .constraints\n                 .liveness_constraints\n                 .add_elements(live_region_vid, live_at);\n \n-            if let Some(facts) = borrowck_context.all_facts {\n+            if let Some(facts) = typeck.borrowck_context.all_facts {\n                 for point in live_at.iter() {\n                     let loc = elements.to_location(point);\n                     facts.region_live_at.push((live_region_vid, location_table.start_index(loc)));"}, {"sha": "4589e4ef036a42628f7e85da9cf973557e277c4e", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 124, "deletions": 181, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/3cfd39bb2e8ee9b5c0579f4ef21b07d7589f8cb0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cfd39bb2e8ee9b5c0579f4ef21b07d7589f8cb0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=3cfd39bb2e8ee9b5c0579f4ef21b07d7589f8cb0", "patch": "@@ -20,7 +20,6 @@ use crate::borrow_check::nll::ToRegionVid;\n use crate::dataflow::move_paths::MoveData;\n use crate::dataflow::FlowAtLocation;\n use crate::dataflow::MaybeInitializedPlaces;\n-use crate::transform::{MirPass, MirSource};\n use either::Either;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n@@ -159,16 +158,14 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n         param_env,\n         mir,\n         &region_bound_pairs,\n-        Some(implicit_region_bound),\n-        Some(&mut borrowck_context),\n-        Some(&universal_region_relations),\n-        |cx| {\n+        implicit_region_bound,\n+        &mut borrowck_context,\n+        &universal_region_relations,\n+        |mut cx| {\n             cx.equate_inputs_and_outputs(mir, universal_regions, &normalized_inputs_and_output);\n-            liveness::generate(cx, mir, elements, flow_inits, move_data, location_table);\n+            liveness::generate(&mut cx, mir, elements, flow_inits, move_data, location_table);\n \n-            cx.borrowck_context\n-                .as_mut()\n-                .map(|bcx| translate_outlives_facts(bcx));\n+            translate_outlives_facts(cx.borrowck_context);\n         },\n     );\n \n@@ -184,9 +181,9 @@ fn type_check_internal<'a, 'gcx, 'tcx, R>(\n     param_env: ty::ParamEnv<'gcx>,\n     mir: &'a Mir<'tcx>,\n     region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n-    implicit_region_bound: Option<ty::Region<'tcx>>,\n-    borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n-    universal_region_relations: Option<&'a UniversalRegionRelations<'tcx>>,\n+    implicit_region_bound: ty::Region<'tcx>,\n+    borrowck_context: &'a mut BorrowCheckContext<'a, 'tcx>,\n+    universal_region_relations: &'a UniversalRegionRelations<'tcx>,\n     mut extra: impl FnMut(&mut TypeChecker<'a, 'gcx, 'tcx>) -> R,\n ) -> R where {\n     let mut checker = TypeChecker::new(\n@@ -548,15 +545,19 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         let all_facts = &mut None;\n         let mut constraints = Default::default();\n         let mut closure_bounds = Default::default();\n-        if let Some(ref mut bcx) = self.cx.borrowck_context {\n-            // Don't try to add borrow_region facts for the promoted MIR\n-            mem::swap(bcx.all_facts, all_facts);\n-\n-            // Use a new sets of constraints and closure bounds so that we can\n-            // modify their locations.\n-            mem::swap(&mut bcx.constraints.outlives_constraints, &mut constraints);\n-            mem::swap(&mut bcx.constraints.closure_bounds_mapping, &mut closure_bounds);\n-        };\n+        // Don't try to add borrow_region facts for the promoted MIR\n+        mem::swap(self.cx.borrowck_context.all_facts, all_facts);\n+\n+        // Use a new sets of constraints and closure bounds so that we can\n+        // modify their locations.\n+        mem::swap(\n+            &mut self.cx.borrowck_context.constraints.outlives_constraints,\n+            &mut constraints\n+        );\n+        mem::swap(\n+            &mut self.cx.borrowck_context.constraints.closure_bounds_mapping,\n+            &mut closure_bounds\n+        );\n \n         self.visit_mir(promoted_mir);\n \n@@ -567,40 +568,44 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n \n         self.mir = parent_mir;\n         // Merge the outlives constraints back in, at the given location.\n-        if let Some(ref mut base_bcx) = self.cx.borrowck_context {\n-            mem::swap(base_bcx.all_facts, all_facts);\n-            mem::swap(&mut base_bcx.constraints.outlives_constraints, &mut constraints);\n-            mem::swap(&mut base_bcx.constraints.closure_bounds_mapping, &mut closure_bounds);\n-\n-            let locations = location.to_locations();\n-            for constraint in constraints.iter() {\n-                let mut constraint = *constraint;\n-                constraint.locations = locations;\n-                if let ConstraintCategory::Return\n-                    | ConstraintCategory::UseAsConst\n-                    | ConstraintCategory::UseAsStatic = constraint.category\n-                {\n-                    // \"Returning\" from a promoted is an assigment to a\n-                    // temporary from the user's point of view.\n-                    constraint.category = ConstraintCategory::Boring;\n-                }\n-                base_bcx.constraints.outlives_constraints.push(constraint)\n-            }\n+        mem::swap(self.cx.borrowck_context.all_facts, all_facts);\n+        mem::swap(\n+            &mut self.cx.borrowck_context.constraints.outlives_constraints,\n+            &mut constraints\n+        );\n+        mem::swap(\n+            &mut self.cx.borrowck_context.constraints.closure_bounds_mapping,\n+            &mut closure_bounds\n+        );\n \n-            if !closure_bounds.is_empty() {\n-                let combined_bounds_mapping = closure_bounds\n-                    .into_iter()\n-                    .flat_map(|(_, value)| value)\n-                    .collect();\n-                let existing = base_bcx\n-                    .constraints\n-                    .closure_bounds_mapping\n-                    .insert(location, combined_bounds_mapping);\n-                assert!(\n-                    existing.is_none(),\n-                    \"Multiple promoteds/closures at the same location.\"\n-                );\n+        let locations = location.to_locations();\n+        for constraint in constraints.iter() {\n+            let mut constraint = *constraint;\n+            constraint.locations = locations;\n+            if let ConstraintCategory::Return\n+                | ConstraintCategory::UseAsConst\n+                | ConstraintCategory::UseAsStatic = constraint.category\n+            {\n+                // \"Returning\" from a promoted is an assigment to a\n+                // temporary from the user's point of view.\n+                constraint.category = ConstraintCategory::Boring;\n             }\n+            self.cx.borrowck_context.constraints.outlives_constraints.push(constraint)\n+        }\n+\n+        if !closure_bounds.is_empty() {\n+            let combined_bounds_mapping = closure_bounds\n+                .into_iter()\n+                .flat_map(|(_, value)| value)\n+                .collect();\n+            let existing = self.cx.borrowck_context\n+                .constraints\n+                .closure_bounds_mapping\n+                .insert(location, combined_bounds_mapping);\n+            assert!(\n+                existing.is_none(),\n+                \"Multiple promoteds/closures at the same location.\"\n+            );\n         }\n     }\n \n@@ -831,10 +836,10 @@ struct TypeChecker<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     user_type_annotations: &'a CanonicalUserTypeAnnotations<'tcx>,\n     mir_def_id: DefId,\n     region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n-    implicit_region_bound: Option<ty::Region<'tcx>>,\n+    implicit_region_bound: ty::Region<'tcx>,\n     reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n-    borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n-    universal_region_relations: Option<&'a UniversalRegionRelations<'tcx>>,\n+    borrowck_context: &'a mut BorrowCheckContext<'a, 'tcx>,\n+    universal_region_relations: &'a UniversalRegionRelations<'tcx>,\n }\n \n struct BorrowCheckContext<'a, 'tcx: 'a> {\n@@ -976,9 +981,9 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         mir_def_id: DefId,\n         param_env: ty::ParamEnv<'gcx>,\n         region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n-        implicit_region_bound: Option<ty::Region<'tcx>>,\n-        borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n-        universal_region_relations: Option<&'a UniversalRegionRelations<'tcx>>,\n+        implicit_region_bound: ty::Region<'tcx>,\n+        borrowck_context: &'a mut BorrowCheckContext<'a, 'tcx>,\n+        universal_region_relations: &'a UniversalRegionRelations<'tcx>,\n     ) -> Self {\n         let mut checker = Self {\n             infcx,\n@@ -1092,18 +1097,16 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             locations, data\n         );\n \n-        if let Some(ref mut borrowck_context) = self.borrowck_context {\n-            constraint_conversion::ConstraintConversion::new(\n-                self.infcx,\n-                borrowck_context.universal_regions,\n-                self.region_bound_pairs,\n-                self.implicit_region_bound,\n-                self.param_env,\n-                locations,\n-                category,\n-                &mut borrowck_context.constraints,\n-            ).convert_all(&data);\n-        }\n+        constraint_conversion::ConstraintConversion::new(\n+            self.infcx,\n+            self.borrowck_context.universal_regions,\n+            self.region_bound_pairs,\n+            Some(self.implicit_region_bound),\n+            self.param_env,\n+            locations,\n+            category,\n+            &mut self.borrowck_context.constraints,\n+        ).convert_all(&data);\n     }\n \n     /// Convenient wrapper around `relate_tys::relate_types` -- see\n@@ -1123,7 +1126,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             b,\n             locations,\n             category,\n-            self.borrowck_context.as_mut().map(|x| &mut **x),\n+            Some(self.borrowck_context),\n         )\n     }\n \n@@ -1276,10 +1279,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             ),\n         )?;\n \n-        let universal_region_relations = match self.universal_region_relations {\n-            Some(rel) => rel,\n-            None => return Ok(()),\n-        };\n+        let universal_region_relations = self.universal_region_relations;\n \n         // Finally, if we instantiated the anon types successfully, we\n         // have to solve any bounds (e.g., `-> impl Iterator` needs to\n@@ -1324,14 +1324,14 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 // of lowering. Assignments to other sorts of places *are* interesting\n                 // though.\n                 let category = match *place {\n-                    Place::Base(PlaceBase::Local(RETURN_PLACE)) => if let Some(BorrowCheckContext {\n+                    Place::Base(PlaceBase::Local(RETURN_PLACE)) => if let BorrowCheckContext {\n                         universal_regions:\n                             UniversalRegions {\n                                 defining_ty: DefiningTy::Const(def_id, _),\n                                 ..\n                             },\n                         ..\n-                    }) = self.borrowck_context\n+                    } = self.borrowck_context\n                     {\n                         if tcx.is_static(*def_id) {\n                             ConstraintCategory::UseAsStatic\n@@ -1559,15 +1559,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 // output) types in the signature must be live, since\n                 // all the inputs that fed into it were live.\n                 for &late_bound_region in map.values() {\n-                    if let Some(ref mut borrowck_context) = self.borrowck_context {\n-                        let region_vid = borrowck_context\n-                            .universal_regions\n-                            .to_region_vid(late_bound_region);\n-                        borrowck_context\n-                            .constraints\n-                            .liveness_constraints\n-                            .add_element(region_vid, term_location);\n-                    }\n+                    let region_vid = self.borrowck_context\n+                        .universal_regions\n+                        .to_region_vid(late_bound_region);\n+                    self.borrowck_context\n+                        .constraints\n+                        .liveness_constraints\n+                        .add_element(region_vid, term_location);\n                 }\n \n                 self.check_call_inputs(mir, term, &sig, args, term_location, from_hir_call);\n@@ -1629,14 +1627,14 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 let dest_ty = dest.ty(mir, tcx).ty;\n                 let category = match *dest {\n                     Place::Base(PlaceBase::Local(RETURN_PLACE)) => {\n-                        if let Some(BorrowCheckContext {\n+                        if let BorrowCheckContext {\n                             universal_regions:\n                                 UniversalRegions {\n                                     defining_ty: DefiningTy::Const(def_id, _),\n                                     ..\n                                 },\n                             ..\n-                        }) = self.borrowck_context\n+                        } = self.borrowck_context\n                         {\n                             if tcx.is_static(*def_id) {\n                                 ConstraintCategory::UseAsStatic\n@@ -2343,10 +2341,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             all_facts,\n             constraints,\n             ..\n-        } = match self.borrowck_context {\n-            Some(ref mut borrowck_context) => borrowck_context,\n-            None => return,\n-        };\n+        } = self.borrowck_context;\n \n         // In Polonius mode, we also push a `borrow_region` fact\n         // linking the loan to the region (in some cases, though,\n@@ -2512,45 +2507,43 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             let closure_constraints =\n                 closure_region_requirements.apply_requirements(tcx, def_id, substs);\n \n-            if let Some(ref mut borrowck_context) = self.borrowck_context {\n-                let bounds_mapping = closure_constraints\n-                    .iter()\n-                    .enumerate()\n-                    .filter_map(|(idx, constraint)| {\n-                        let ty::OutlivesPredicate(k1, r2) =\n-                            constraint.no_bound_vars().unwrap_or_else(|| {\n-                                bug!(\"query_constraint {:?} contained bound vars\", constraint,);\n-                            });\n-\n-                        match k1.unpack() {\n-                            UnpackedKind::Lifetime(r1) => {\n-                                // constraint is r1: r2\n-                                let r1_vid = borrowck_context.universal_regions.to_region_vid(r1);\n-                                let r2_vid = borrowck_context.universal_regions.to_region_vid(r2);\n-                                let outlives_requirements =\n-                                    &closure_region_requirements.outlives_requirements[idx];\n-                                Some((\n-                                    (r1_vid, r2_vid),\n-                                    (\n-                                        outlives_requirements.category,\n-                                        outlives_requirements.blame_span,\n-                                    ),\n-                                ))\n-                            }\n-                            UnpackedKind::Type(_) | UnpackedKind::Const(_) => None,\n+            let bounds_mapping = closure_constraints\n+                .iter()\n+                .enumerate()\n+                .filter_map(|(idx, constraint)| {\n+                    let ty::OutlivesPredicate(k1, r2) =\n+                        constraint.no_bound_vars().unwrap_or_else(|| {\n+                            bug!(\"query_constraint {:?} contained bound vars\", constraint,);\n+                        });\n+\n+                    match k1.unpack() {\n+                        UnpackedKind::Lifetime(r1) => {\n+                            // constraint is r1: r2\n+                            let r1_vid = self.borrowck_context.universal_regions.to_region_vid(r1);\n+                            let r2_vid = self.borrowck_context.universal_regions.to_region_vid(r2);\n+                            let outlives_requirements =\n+                                &closure_region_requirements.outlives_requirements[idx];\n+                            Some((\n+                                (r1_vid, r2_vid),\n+                                (\n+                                    outlives_requirements.category,\n+                                    outlives_requirements.blame_span,\n+                                ),\n+                            ))\n                         }\n-                    })\n-                    .collect();\n-\n-                let existing = borrowck_context\n-                    .constraints\n-                    .closure_bounds_mapping\n-                    .insert(location, bounds_mapping);\n-                assert!(\n-                    existing.is_none(),\n-                    \"Multiple closures at the same location.\"\n-                );\n-            }\n+                        UnpackedKind::Type(_) | UnpackedKind::Const(_) => None,\n+                    }\n+                })\n+                .collect();\n+\n+            let existing = self.borrowck_context\n+                .constraints\n+                .closure_bounds_mapping\n+                .insert(location, bounds_mapping);\n+            assert!(\n+                existing.is_none(),\n+                \"Multiple closures at the same location.\"\n+            );\n \n             self.push_region_constraints(\n                 location.to_locations(),\n@@ -2668,56 +2661,6 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub struct TypeckMir;\n-\n-impl MirPass for TypeckMir {\n-    fn run_pass<'a, 'tcx>(\n-        &self,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        src: MirSource<'tcx>,\n-        mir: &mut Mir<'tcx>,\n-    ) {\n-        let def_id = src.def_id();\n-        debug!(\"run_pass: {:?}\", def_id);\n-\n-        // FIXME: We don't need this MIR pass anymore.\n-        if true {\n-            return;\n-        }\n-\n-        if tcx.sess.err_count() > 0 {\n-            // compiling a broken program can obviously result in a\n-            // broken MIR, so try not to report duplicate errors.\n-            return;\n-        }\n-\n-        if tcx.is_constructor(def_id) {\n-            // We just assume that the automatically generated struct/variant constructors are\n-            // correct. See the comment in the `mir_borrowck` implementation for an\n-            // explanation why we need this.\n-            return;\n-        }\n-\n-        let param_env = tcx.param_env(def_id);\n-        tcx.infer_ctxt().enter(|infcx| {\n-            type_check_internal(\n-                &infcx,\n-                def_id,\n-                param_env,\n-                mir,\n-                &vec![],\n-                None,\n-                None,\n-                None,\n-                |_| (),\n-            );\n-\n-            // For verification purposes, we just ignore the resulting\n-            // region constraint sets. Not our problem. =)\n-        });\n-    }\n-}\n-\n trait NormalizeLocation: fmt::Debug + Copy {\n     fn to_locations(self) -> Locations;\n }"}, {"sha": "b6091644157178fd55a450481d4bb41fdb8a54cd", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cfd39bb2e8ee9b5c0579f4ef21b07d7589f8cb0/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cfd39bb2e8ee9b5c0579f4ef21b07d7589f8cb0/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=3cfd39bb2e8ee9b5c0579f4ef21b07d7589f8cb0", "patch": "@@ -1,4 +1,3 @@\n-use crate::borrow_check::nll::type_check;\n use crate::build;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::mir::{Mir, MirPhase, Promoted};\n@@ -205,7 +204,6 @@ fn mir_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Stea\n     run_passes(tcx, &mut mir, InstanceDef::Item(def_id), MirPhase::Const, &[\n         // What we need to do constant evaluation.\n         &simplify::SimplifyCfg::new(\"initial\"),\n-        &type_check::TypeckMir,\n         &rustc_peek::SanityCheck,\n         &uniform_array_move_out::UniformArrayMoveOut,\n     ]);"}, {"sha": "6d22e9cd9fab98b01ab036fc6702602d53331641", "filename": "src/test/mir-opt/storage_ranges.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3cfd39bb2e8ee9b5c0579f4ef21b07d7589f8cb0/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cfd39bb2e8ee9b5c0579f4ef21b07d7589f8cb0/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs?ref=3cfd39bb2e8ee9b5c0579f4ef21b07d7589f8cb0", "patch": "@@ -7,7 +7,7 @@ fn main() {\n }\n \n // END RUST SOURCE\n-// START rustc.main.TypeckMir.before.mir\n+// START rustc.main.nll.0.mir\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = const 0i32;\n@@ -31,4 +31,4 @@ fn main() {\n //         StorageDead(_1);\n //         return;\n //      }\n-// END rustc.main.TypeckMir.before.mir\n+// END rustc.main.nll.0.mir"}]}