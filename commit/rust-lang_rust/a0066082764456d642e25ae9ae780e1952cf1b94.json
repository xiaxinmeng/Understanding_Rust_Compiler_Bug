{"sha": "a0066082764456d642e25ae9ae780e1952cf1b94", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwMDY2MDgyNzY0NDU2ZDY0MmUyNWFlOWFlNzgwZTE5NTJjZjFiOTQ=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-11-03T20:23:01Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-11-03T21:04:32Z"}, "message": "Remove stage0 stuff that was awaiting snapshot\n\nand re-register snapshots\n\nJust removing unneeded code, no review", "tree": {"sha": "95f6e716d248eb8b5605740a60dedc9090d33ced", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95f6e716d248eb8b5605740a60dedc9090d33ced"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0066082764456d642e25ae9ae780e1952cf1b94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0066082764456d642e25ae9ae780e1952cf1b94", "html_url": "https://github.com/rust-lang/rust/commit/a0066082764456d642e25ae9ae780e1952cf1b94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0066082764456d642e25ae9ae780e1952cf1b94/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1fb590854d02489cd56bb27a3516725e8e40c50", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1fb590854d02489cd56bb27a3516725e8e40c50", "html_url": "https://github.com/rust-lang/rust/commit/c1fb590854d02489cd56bb27a3516725e8e40c50"}], "stats": {"total": 748, "additions": 9, "deletions": 739}, "files": [{"sha": "6d4a5849e352266daf26f7c0e237d512e04ab7fc", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a0066082764456d642e25ae9ae780e1952cf1b94/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0066082764456d642e25ae9ae780e1952cf1b94/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=a0066082764456d642e25ae9ae780e1952cf1b94", "patch": "@@ -135,18 +135,6 @@ pub pure fn from_elem<T: Copy>(n_elts: uint, t: T) -> @[T] {\n \n #[cfg(notest)]\n pub mod traits {\n-    #[legacy_exports];\n-\n-    #[cfg(stage0)]\n-    pub impl<T: Copy> @[T] : Add<&[const T],@[T]> {\n-        #[inline(always)]\n-        pure fn add(rhs: & &[const T]) -> @[T] {\n-            append(self, (*rhs))\n-        }\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pub impl<T: Copy> @[T] : Add<&[const T],@[T]> {\n         #[inline(always)]\n         pure fn add(rhs: & &self/[const T]) -> @[T] {\n@@ -156,8 +144,7 @@ pub mod traits {\n }\n \n #[cfg(test)]\n-pub mod traits {\n-    #[legacy_exports];}\n+pub mod traits {}\n \n pub mod raw {\n     pub type VecRepr = vec::raw::VecRepr;"}, {"sha": "2b2180e7efcc034998f5fd85050f48c5affe0f3b", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/a0066082764456d642e25ae9ae780e1952cf1b94/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0066082764456d642e25ae9ae780e1952cf1b94/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=a0066082764456d642e25ae9ae780e1952cf1b94", "patch": "@@ -65,31 +65,13 @@ pub mod ct {\n         FlagSignAlways,\n         FlagAlternate,\n     }\n-    #[cfg(stage0)]\n-    pub enum Count {\n-        CountIs(int),\n-        CountIsParam(int),\n-        CountIsNextParam,\n-        CountImplied,\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pub enum Count {\n         CountIs(uint),\n         CountIsParam(uint),\n         CountIsNextParam,\n         CountImplied,\n     }\n \n-    #[cfg(stage0)]\n-    pub type Conv =\n-        {param: Option<int>,\n-         flags: ~[Flag],\n-         width: Count,\n-         precision: Count,\n-         ty: Ty};\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     // A formatted conversion from an expression to a string\n     pub type Conv =\n         {param: Option<uint>,\n@@ -176,24 +158,6 @@ pub mod ct {\n                              ty: ty.ty}),\n              next: ty.next};\n     }\n-    #[cfg(stage0)]\n-    pub fn parse_parameter(s: &str, i: uint, lim: uint) ->\n-       {param: Option<int>, next: uint} {\n-        if i >= lim { return {param: None, next: i}; }\n-        let num = peek_num(s, i, lim);\n-        return match num {\n-              None => {param: None, next: i},\n-              Some(t) => {\n-                let n = t.num as int;\n-                let j = t.next;\n-                if j < lim && s[j] == '$' as u8 {\n-                    {param: Some(n), next: j + 1}\n-                } else { {param: None, next: i} }\n-              }\n-            };\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pub fn parse_parameter(s: &str, i: uint, lim: uint) ->\n        {param: Option<uint>, next: uint} {\n         if i >= lim { return {param: None, next: i}; }\n@@ -237,31 +201,6 @@ pub mod ct {\n                 more(FlagAlternate, s, i, lim)\n             } else { {flags: move noflags, next: i} };\n     }\n-    #[cfg(stage0)]\n-    pub fn parse_count(s: &str, i: uint, lim: uint)\n-        -> {count: Count, next: uint} {\n-        return if i >= lim {\n-                {count: CountImplied, next: i}\n-            } else if s[i] == '*' as u8 {\n-                let param = parse_parameter(s, i + 1, lim);\n-                let j = param.next;\n-                match param.param {\n-                  None => {count: CountIsNextParam, next: j},\n-                  Some(n) => {count: CountIsParam(n), next: j}\n-                }\n-            } else {\n-                let num = peek_num(s, i, lim);\n-                match num {\n-                  None => {count: CountImplied, next: i},\n-                  Some(num) => {\n-                    count: CountIs(num.num as int),\n-                    next: num.next\n-                  }\n-                }\n-            };\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n         pub fn parse_count(s: &str, i: uint, lim: uint)\n         -> {count: Count, next: uint} {\n         return if i >= lim {\n@@ -346,10 +285,6 @@ pub mod rt {\n     pub const flag_sign_always    : u32 = 0b00000000001000u32;\n     pub const flag_alternate      : u32 = 0b00000000010000u32;\n \n-    #[cfg(stage0)]\n-    pub enum Count { CountIs(int), CountImplied, }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pub enum Count { CountIs(uint), CountImplied, }\n \n     pub enum Ty { TyDefault, TyBits, TyHexUpper, TyHexLower, TyOctal, }"}, {"sha": "68d5f140cb5110079b17744da069630c354d83d1", "filename": "src/libcore/private.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a0066082764456d642e25ae9ae780e1952cf1b94/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0066082764456d642e25ae9ae780e1952cf1b94/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=a0066082764456d642e25ae9ae780e1952cf1b94", "patch": "@@ -27,7 +27,6 @@ extern mod rustrt {\n #[abi = \"rust-intrinsic\"]\n extern mod rusti {\n \n-    #[cfg(stage1)] #[cfg(stage2)] #[cfg(stage3)]\n     fn atomic_cxchg(dst: &mut int, old: int, src: int) -> int;\n     fn atomic_xadd(dst: &mut int, src: int) -> int;\n     fn atomic_xsub(dst: &mut int, src: int) -> int;\n@@ -38,17 +37,6 @@ type rust_port_id = uint;\n \n type GlobalPtr = *libc::uintptr_t;\n \n-// FIXME #3527: Remove once snapshots have atomic_cxchg\n-#[cfg(stage0)]\n-fn compare_and_swap(address: &mut libc::uintptr_t,\n-                    oldval: libc::uintptr_t,\n-                    newval: libc::uintptr_t) -> bool {\n-    rustrt::rust_compare_and_swap_ptr(address, oldval, newval)\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n fn compare_and_swap(address: &mut int, oldval: int, newval: int) -> bool {\n     let old = rusti::atomic_cxchg(address, oldval, newval);\n     old == oldval"}, {"sha": "2753a254c41e8a7fcabc9d844cd701ebf18dc448", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a0066082764456d642e25ae9ae780e1952cf1b94/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0066082764456d642e25ae9ae780e1952cf1b94/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=a0066082764456d642e25ae9ae780e1952cf1b94", "patch": "@@ -226,30 +226,12 @@ impl<T> *const T : Ord {\n }\n \n // Equality for region pointers\n-#[cfg(stage0)]\n-impl<T:Eq> &const T : Eq {\n-    pure fn eq(other: & &const T) -> bool { return *self == *(*other); }\n-    pure fn ne(other: & &const T) -> bool { return *self != *(*other); }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<T:Eq> &const T : Eq {\n     pure fn eq(other: & &self/const T) -> bool { return *self == *(*other); }\n     pure fn ne(other: & &self/const T) -> bool { return *self != *(*other); }\n }\n \n // Comparison for region pointers\n-#[cfg(stage0)]\n-impl<T:Ord> &const T : Ord {\n-    pure fn lt(other: & &const T) -> bool { *self < *(*other) }\n-    pure fn le(other: & &const T) -> bool { *self <= *(*other) }\n-    pure fn ge(other: & &const T) -> bool { *self >= *(*other) }\n-    pure fn gt(other: & &const T) -> bool { *self > *(*other) }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<T:Ord> &const T : Ord {\n     pure fn lt(other: & &self/const T) -> bool { *self < *(*other) }\n     pure fn le(other: & &self/const T) -> bool { *self <= *(*other) }"}, {"sha": "8b67d30b66bb102c68e385795cafb166d7d09428", "filename": "src/libcore/str.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a0066082764456d642e25ae9ae780e1952cf1b94/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0066082764456d642e25ae9ae780e1952cf1b94/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=a0066082764456d642e25ae9ae780e1952cf1b94", "patch": "@@ -735,18 +735,6 @@ pure fn gt(a: &str, b: &str) -> bool {\n     !le(a, b)\n }\n \n-#[cfg(stage0)]\n-impl &str : Eq {\n-    #[inline(always)]\n-    pure fn eq(other: & &str) -> bool {\n-        eq_slice(self, (*other))\n-    }\n-    #[inline(always)]\n-    pure fn ne(other: & &str) -> bool { !self.eq(other) }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl &str : Eq {\n     #[inline(always)]\n     pure fn eq(other: & &self/str) -> bool {\n@@ -785,20 +773,6 @@ impl ~str : Ord {\n     pure fn gt(other: &~str) -> bool { gt(self, (*other)) }\n }\n \n-#[cfg(stage0)]\n-impl &str : Ord {\n-    #[inline(always)]\n-    pure fn lt(other: & &str) -> bool { lt(self, (*other)) }\n-    #[inline(always)]\n-    pure fn le(other: & &str) -> bool { le(self, (*other)) }\n-    #[inline(always)]\n-    pure fn ge(other: & &str) -> bool { ge(self, (*other)) }\n-    #[inline(always)]\n-    pure fn gt(other: & &str) -> bool { gt(self, (*other)) }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl &str : Ord {\n     #[inline(always)]\n     pure fn lt(other: & &self/str) -> bool { lt(self, (*other)) }\n@@ -2122,16 +2096,6 @@ impl ~str: Trimmable {\n \n #[cfg(notest)]\n pub mod traits {\n-    #[cfg(stage0)]\n-    impl ~str : Add<&str,~str> {\n-        #[inline(always)]\n-        pure fn add(rhs: & &str) -> ~str {\n-            append(copy self, (*rhs))\n-        }\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     impl ~str : Add<&str,~str> {\n         #[inline(always)]\n         pure fn add(rhs: & &self/str) -> ~str {"}, {"sha": "16415300b09ee76c3d1b6a1e44547ad8bbb96f5a", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a0066082764456d642e25ae9ae780e1952cf1b94/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0066082764456d642e25ae9ae780e1952cf1b94/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=a0066082764456d642e25ae9ae780e1952cf1b94", "patch": "@@ -1317,16 +1317,6 @@ pure fn eq<T: Eq>(a: &[T], b: &[T]) -> bool {\n     return true;\n }\n \n-#[cfg(stage0)]\n-impl<T: Eq> &[T] : Eq {\n-    #[inline(always)]\n-    pure fn eq(other: & &[T]) -> bool { eq(self, (*other)) }\n-    #[inline(always)]\n-    pure fn ne(other: & &[T]) -> bool { !self.eq(other) }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<T: Eq> &[T] : Eq {\n     #[inline(always)]\n     pure fn eq(other: & &self/[T]) -> bool { eq(self, (*other)) }\n@@ -1370,20 +1360,6 @@ pure fn le<T: Ord>(a: &[T], b: &[T]) -> bool { !lt(b, a) }\n pure fn ge<T: Ord>(a: &[T], b: &[T]) -> bool { !lt(a, b) }\n pure fn gt<T: Ord>(a: &[T], b: &[T]) -> bool { lt(b, a)  }\n \n-#[cfg(stage0)]\n-impl<T: Ord> &[T] : Ord {\n-    #[inline(always)]\n-    pure fn lt(other: & &[T]) -> bool { lt(self, (*other)) }\n-    #[inline(always)]\n-    pure fn le(other: & &[T]) -> bool { le(self, (*other)) }\n-    #[inline(always)]\n-    pure fn ge(other: & &[T]) -> bool { ge(self, (*other)) }\n-    #[inline(always)]\n-    pure fn gt(other: & &[T]) -> bool { gt(self, (*other)) }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<T: Ord> &[T] : Ord {\n     #[inline(always)]\n     pure fn lt(other: & &self/[T]) -> bool { lt(self, (*other)) }\n@@ -1419,33 +1395,13 @@ impl<T: Ord> @[T] : Ord {\n \n #[cfg(notest)]\n pub mod traits {\n-    #[cfg(stage0)]\n-    impl<T: Copy> ~[T] : Add<&[const T],~[T]> {\n-        #[inline(always)]\n-        pure fn add(rhs: & &[const T]) -> ~[T] {\n-            append(copy self, (*rhs))\n-        }\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     impl<T: Copy> ~[T] : Add<&[const T],~[T]> {\n         #[inline(always)]\n         pure fn add(rhs: & &self/[const T]) -> ~[T] {\n             append(copy self, (*rhs))\n         }\n     }\n \n-    #[cfg(stage0)]\n-    impl<T: Copy> ~[mut T] : Add<&[const T],~[mut T]> {\n-        #[inline(always)]\n-        pure fn add(rhs: & &[const T]) -> ~[mut T] {\n-            append_mut(copy self, (*rhs))\n-        }\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     impl<T: Copy> ~[mut T] : Add<&[const T],~[mut T]> {\n         #[inline(always)]\n         pure fn add(rhs: & &self/[const T]) -> ~[mut T] {"}, {"sha": "da1f807bcbcf69fe8ba34b9c0d5b521955ca40d8", "filename": "src/libstd/json.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a0066082764456d642e25ae9ae780e1952cf1b94/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0066082764456d642e25ae9ae780e1952cf1b94/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=a0066082764456d642e25ae9ae780e1952cf1b94", "patch": "@@ -273,32 +273,6 @@ pub impl PrettySerializer: serialization::Serializer {\n     }\n }\n \n-#[cfg(stage0)]\n-pub impl Json: serialization::Serializable {\n-    fn serialize<S: serialization::Serializer>(&self, s: &S) {\n-        match *self {\n-            Number(v) => v.serialize(s),\n-            String(ref v) => v.serialize(s),\n-            Boolean(v) => v.serialize(s),\n-            List(v) => v.serialize(s),\n-            Object(ref v) => {\n-                do s.emit_rec || {\n-                    let mut idx = 0;\n-                    for v.each |key, value| {\n-                        do s.emit_field(*key, idx) {\n-                            value.serialize(s);\n-                        }\n-                        idx += 1;\n-                    }\n-                }\n-            },\n-            Null => s.emit_nil(),\n-        }\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub impl<\n     S: serialization::Serializer\n > Json: serialization::Serializable<S> {"}, {"sha": "1b2cd0aaa3db8f8a48fa02d8f730f86bc9cf57d4", "filename": "src/libstd/serialization.rs", "status": "modified", "additions": 0, "deletions": 475, "changes": 475, "blob_url": "https://github.com/rust-lang/rust/blob/a0066082764456d642e25ae9ae780e1952cf1b94/src%2Flibstd%2Fserialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0066082764456d642e25ae9ae780e1952cf1b94/src%2Flibstd%2Fserialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization.rs?ref=a0066082764456d642e25ae9ae780e1952cf1b94", "patch": "@@ -92,481 +92,6 @@ pub trait Deserializer {\n     fn read_tup_elt<T>(&self, idx: uint, f: fn() -> T) -> T;\n }\n \n-#[cfg(stage0)]\n-pub mod traits {\n-pub trait Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S);\n-}\n-\n-pub trait Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> self;\n-}\n-\n-pub impl uint: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_uint(*self) }\n-}\n-\n-pub impl uint: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> uint {\n-        d.read_uint()\n-    }\n-}\n-\n-pub impl u8: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_u8(*self) }\n-}\n-\n-pub impl u8: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> u8 {\n-        d.read_u8()\n-    }\n-}\n-\n-pub impl u16: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_u16(*self) }\n-}\n-\n-pub impl u16: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> u16 {\n-        d.read_u16()\n-    }\n-}\n-\n-pub impl u32: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_u32(*self) }\n-}\n-\n-pub impl u32: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> u32 {\n-        d.read_u32()\n-    }\n-}\n-\n-pub impl u64: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_u64(*self) }\n-}\n-\n-pub impl u64: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> u64 {\n-        d.read_u64()\n-    }\n-}\n-\n-pub impl int: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_int(*self) }\n-}\n-\n-pub impl int: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> int {\n-        d.read_int()\n-    }\n-}\n-\n-pub impl i8: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_i8(*self) }\n-}\n-\n-pub impl i8: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> i8 {\n-        d.read_i8()\n-    }\n-}\n-\n-pub impl i16: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_i16(*self) }\n-}\n-\n-pub impl i16: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> i16 {\n-        d.read_i16()\n-    }\n-}\n-\n-pub impl i32: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_i32(*self) }\n-}\n-\n-pub impl i32: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> i32 {\n-        d.read_i32()\n-    }\n-}\n-\n-pub impl i64: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_i64(*self) }\n-}\n-\n-pub impl i64: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> i64 {\n-        d.read_i64()\n-    }\n-}\n-\n-pub impl &str: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_borrowed_str(*self) }\n-}\n-\n-pub impl ~str: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_owned_str(*self) }\n-}\n-\n-pub impl ~str: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> ~str {\n-        d.read_owned_str()\n-    }\n-}\n-\n-pub impl @str: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_managed_str(*self) }\n-}\n-\n-pub impl @str: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> @str {\n-        d.read_managed_str()\n-    }\n-}\n-\n-pub impl float: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_float(*self) }\n-}\n-\n-pub impl float: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> float {\n-        d.read_float()\n-    }\n-}\n-\n-pub impl f32: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_f32(*self) }\n-}\n-\n-pub impl f32: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> f32 {\n-        d.read_f32() }\n-}\n-\n-pub impl f64: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_f64(*self) }\n-}\n-\n-pub impl f64: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> f64 {\n-        d.read_f64()\n-    }\n-}\n-\n-pub impl bool: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_bool(*self) }\n-}\n-\n-pub impl bool: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> bool {\n-        d.read_bool()\n-    }\n-}\n-\n-pub impl (): Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_nil() }\n-}\n-\n-pub impl (): Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> () {\n-        d.read_nil()\n-    }\n-}\n-\n-pub impl<T: Serializable> &T: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) {\n-        s.emit_borrowed(|| (**self).serialize(s))\n-    }\n-}\n-\n-pub impl<T: Serializable> ~T: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) {\n-        s.emit_owned(|| (**self).serialize(s))\n-    }\n-}\n-\n-pub impl<T: Deserializable> ~T: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> ~T {\n-        d.read_owned(|| ~deserialize(d))\n-    }\n-}\n-\n-pub impl<T: Serializable> @T: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) {\n-        s.emit_managed(|| (**self).serialize(s))\n-    }\n-}\n-\n-pub impl<T: Deserializable> @T: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> @T {\n-        d.read_managed(|| @deserialize(d))\n-    }\n-}\n-\n-pub impl<T: Serializable> &[T]: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) {\n-        do s.emit_borrowed_vec(self.len()) {\n-            for self.eachi |i, e| {\n-                s.emit_vec_elt(i, || e.serialize(s))\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<T: Serializable> ~[T]: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) {\n-        do s.emit_owned_vec(self.len()) {\n-            for self.eachi |i, e| {\n-                s.emit_vec_elt(i, || e.serialize(s))\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<T: Deserializable> ~[T]: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> ~[T] {\n-        do d.read_owned_vec |len| {\n-            do vec::from_fn(len) |i| {\n-                d.read_vec_elt(i, || deserialize(d))\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<T: Serializable> @[T]: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) {\n-        do s.emit_managed_vec(self.len()) {\n-            for self.eachi |i, e| {\n-                s.emit_vec_elt(i, || e.serialize(s))\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<T: Deserializable> @[T]: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> @[T] {\n-        do d.read_managed_vec |len| {\n-            do at_vec::from_fn(len) |i| {\n-                d.read_vec_elt(i, || deserialize(d))\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<T: Serializable> Option<T>: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) {\n-        do s.emit_enum(~\"option\") {\n-            match *self {\n-              None => do s.emit_enum_variant(~\"none\", 0u, 0u) {\n-              },\n-\n-              Some(ref v) => do s.emit_enum_variant(~\"some\", 1u, 1u) {\n-                s.emit_enum_variant_arg(0u, || v.serialize(s))\n-              }\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<T: Deserializable> Option<T>: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> Option<T> {\n-        do d.read_enum(~\"option\") {\n-            do d.read_enum_variant |i| {\n-                match i {\n-                  0 => None,\n-                  1 => Some(d.read_enum_variant_arg(0u, || deserialize(d))),\n-                  _ => fail(fmt!(\"Bad variant for option: %u\", i))\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<\n-    T0: Serializable,\n-    T1: Serializable\n-> (T0, T1): Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) {\n-        match *self {\n-            (ref t0, ref t1) => {\n-                do s.emit_tup(2) {\n-                    s.emit_tup_elt(0, || t0.serialize(s));\n-                    s.emit_tup_elt(1, || t1.serialize(s));\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<\n-    T0: Deserializable,\n-    T1: Deserializable\n-> (T0, T1): Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> (T0, T1) {\n-        do d.read_tup(2) {\n-            (\n-                d.read_tup_elt(0, || deserialize(d)),\n-                d.read_tup_elt(1, || deserialize(d))\n-            )\n-        }\n-    }\n-}\n-\n-pub impl<\n-    T0: Serializable,\n-    T1: Serializable,\n-    T2: Serializable\n-> (T0, T1, T2): Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) {\n-        match *self {\n-            (ref t0, ref t1, ref t2) => {\n-                do s.emit_tup(3) {\n-                    s.emit_tup_elt(0, || t0.serialize(s));\n-                    s.emit_tup_elt(1, || t1.serialize(s));\n-                    s.emit_tup_elt(2, || t2.serialize(s));\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<\n-    T0: Deserializable,\n-    T1: Deserializable,\n-    T2: Deserializable\n-> (T0, T1, T2): Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> (T0, T1, T2) {\n-        do d.read_tup(3) {\n-            (\n-                d.read_tup_elt(0, || deserialize(d)),\n-                d.read_tup_elt(1, || deserialize(d)),\n-                d.read_tup_elt(2, || deserialize(d))\n-            )\n-        }\n-    }\n-}\n-\n-pub impl<\n-    T0: Serializable,\n-    T1: Serializable,\n-    T2: Serializable,\n-    T3: Serializable\n-> (T0, T1, T2, T3): Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) {\n-        match *self {\n-            (ref t0, ref t1, ref t2, ref t3) => {\n-                do s.emit_tup(4) {\n-                    s.emit_tup_elt(0, || t0.serialize(s));\n-                    s.emit_tup_elt(1, || t1.serialize(s));\n-                    s.emit_tup_elt(2, || t2.serialize(s));\n-                    s.emit_tup_elt(3, || t3.serialize(s));\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<\n-    T0: Deserializable,\n-    T1: Deserializable,\n-    T2: Deserializable,\n-    T3: Deserializable\n-> (T0, T1, T2, T3): Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> (T0, T1, T2, T3) {\n-        do d.read_tup(4) {\n-            (\n-                d.read_tup_elt(0, || deserialize(d)),\n-                d.read_tup_elt(1, || deserialize(d)),\n-                d.read_tup_elt(2, || deserialize(d)),\n-                d.read_tup_elt(3, || deserialize(d))\n-            )\n-        }\n-    }\n-}\n-\n-pub impl<\n-    T0: Serializable,\n-    T1: Serializable,\n-    T2: Serializable,\n-    T3: Serializable,\n-    T4: Serializable\n-> (T0, T1, T2, T3, T4): Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) {\n-        match *self {\n-            (ref t0, ref t1, ref t2, ref t3, ref t4) => {\n-                do s.emit_tup(5) {\n-                    s.emit_tup_elt(0, || t0.serialize(s));\n-                    s.emit_tup_elt(1, || t1.serialize(s));\n-                    s.emit_tup_elt(2, || t2.serialize(s));\n-                    s.emit_tup_elt(3, || t3.serialize(s));\n-                    s.emit_tup_elt(4, || t4.serialize(s));\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<\n-    T0: Deserializable,\n-    T1: Deserializable,\n-    T2: Deserializable,\n-    T3: Deserializable,\n-    T4: Deserializable\n-> (T0, T1, T2, T3, T4): Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D)\n-      -> (T0, T1, T2, T3, T4) {\n-        do d.read_tup(5) {\n-            (\n-                d.read_tup_elt(0, || deserialize(d)),\n-                d.read_tup_elt(1, || deserialize(d)),\n-                d.read_tup_elt(2, || deserialize(d)),\n-                d.read_tup_elt(3, || deserialize(d)),\n-                d.read_tup_elt(4, || deserialize(d))\n-            )\n-        }\n-    }\n-}\n-\n-// ___________________________________________________________________________\n-// Helper routines\n-//\n-// In some cases, these should eventually be coded as traits.\n-\n-pub trait SerializerHelpers {\n-    fn emit_from_vec<T>(&self, v: &[T], f: fn(&T));\n-}\n-\n-pub impl<S: Serializer> S: SerializerHelpers {\n-    fn emit_from_vec<T>(&self, v: &[T], f: fn(&T)) {\n-        do self.emit_owned_vec(v.len()) {\n-            for v.eachi |i, e| {\n-                do self.emit_vec_elt(i) {\n-                    f(e)\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub trait DeserializerHelpers {\n-    fn read_to_vec<T>(&self, f: fn() -> T) -> ~[T];\n-}\n-\n-pub impl<D: Deserializer> D: DeserializerHelpers {\n-    fn read_to_vec<T>(&self, f: fn() -> T) -> ~[T] {\n-        do self.read_owned_vec |len| {\n-            do vec::from_fn(len) |i| {\n-                self.read_vec_elt(i, || f())\n-            }\n-        }\n-    }\n-}\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub mod traits {\n pub trait Serializable<S: Serializer> {\n     fn serialize(&self, s: &S);"}, {"sha": "21b0af9420fab94e933a3d7129d3d4e2881c2845", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a0066082764456d642e25ae9ae780e1952cf1b94/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0066082764456d642e25ae9ae780e1952cf1b94/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=a0066082764456d642e25ae9ae780e1952cf1b94", "patch": "@@ -23,36 +23,6 @@ macro_rules! interner_key (\n // implemented.\n struct ident { repr: uint }\n \n-#[cfg(stage0)]\n-impl ident: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) {\n-        let intr = match unsafe {\n-            task::local_data::local_data_get(interner_key!())\n-        } {\n-            None => fail ~\"serialization: TLS interner not set up\",\n-            Some(intr) => intr\n-        };\n-\n-        s.emit_owned_str(*(*intr).get(*self));\n-    }\n-}\n-\n-#[cfg(stage0)]\n-impl ident: Deserializable {\n-    static fn deserialize<D: Deserializer>(d: &D) -> ident {\n-        let intr = match unsafe {\n-            task::local_data::local_data_get(interner_key!())\n-        } {\n-            None => fail ~\"deserialization: TLS interner not set up\",\n-            Some(intr) => intr\n-        };\n-\n-        (*intr).intern(@d.read_owned_str())\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<S: Serializer> ident: Serializable<S> {\n     fn serialize(&self, s: &S) {\n         let intr = match unsafe {\n@@ -66,8 +36,6 @@ impl<S: Serializer> ident: Serializable<S> {\n     }\n }\n \n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<D: Deserializer> ident: Deserializable<D> {\n     static fn deserialize(d: &D) -> ident {\n         let intr = match unsafe {"}, {"sha": "4278e1f199a626be6ee811c2ee515b03914ffa8e", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a0066082764456d642e25ae9ae780e1952cf1b94/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0066082764456d642e25ae9ae780e1952cf1b94/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=a0066082764456d642e25ae9ae780e1952cf1b94", "patch": "@@ -182,28 +182,11 @@ impl span : cmp::Eq {\n     pure fn ne(other: &span) -> bool { !self.eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl span: Serializable {\n-    /* Note #1972 -- spans are serialized but not deserialized */\n-    fn serialize<S: Serializer>(&self, _s: &S) { }\n-}\n-\n-#[cfg(stage0)]\n-impl span: Deserializable {\n-    static fn deserialize<D: Deserializer>(_d: &D) -> span {\n-        ast_util::dummy_sp()\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<S: Serializer> span: Serializable<S> {\n     /* Note #1972 -- spans are serialized but not deserialized */\n     fn serialize(&self, _s: &S) { }\n }\n \n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<D: Deserializer> span: Deserializable<D> {\n     static fn deserialize(_d: &D) -> span {\n         ast_util::dummy_sp()"}, {"sha": "42874e35adaa401a142b75009541124434c26f73", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a0066082764456d642e25ae9ae780e1952cf1b94/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a0066082764456d642e25ae9ae780e1952cf1b94/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=a0066082764456d642e25ae9ae780e1952cf1b94", "patch": "@@ -1,3 +1,11 @@\n+S 2012-11-02 4876eb7\n+  macos-i386 e391b167f0361c70440ef2b45541b0832f77fa44\n+  macos-x86_64 480a9f39b995a4bd7213275f6048b08ec599a22e\n+  freebsd-x86_64 4253e538863c4d668d145587a296c92595db0a3e\n+  linux-i386 cd666d55fe54b80a28dfe940598dd54987decdad\n+  linux-x86_64 549ab5b90f0118b8b02e00da7cc396d96066bbff\n+  winnt-i386 5fda5900795d2c137602140e8618f37b7e42b4cd\n+\n S 2012-10-09 cd6f24f\n   macos-i386 7f2f2857eac33ff0792e4ea7a3ff91a09304fcab\n   macos-x86_64 bb3d191e2e31cb754223ab162281fd9727e63ea9"}]}