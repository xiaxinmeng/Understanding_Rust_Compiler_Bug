{"sha": "f8ea24edc8b663c5acbe252936aa375f1d3a944e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4ZWEyNGVkYzhiNjYzYzVhY2JlMjUyOTM2YWEzNzVmMWQzYTk0NGU=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-16T22:15:31Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-11T01:14:58Z"}, "message": "rustc: Avoid free functions taking &TyCtxt and &InferCtxt.", "tree": {"sha": "247db5a8139cd4165a1704635e6d0d1f98713d6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/247db5a8139cd4165a1704635e6d0d1f98713d6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8ea24edc8b663c5acbe252936aa375f1d3a944e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8ea24edc8b663c5acbe252936aa375f1d3a944e", "html_url": "https://github.com/rust-lang/rust/commit/f8ea24edc8b663c5acbe252936aa375f1d3a944e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8ea24edc8b663c5acbe252936aa375f1d3a944e/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7ee56e862071c3cea4c5fb7cf12444591e0b3f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2", "html_url": "https://github.com/rust-lang/rust/commit/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2"}], "stats": {"total": 1768, "additions": 765, "deletions": 1003}, "files": [{"sha": "156d8e8c95fc8ad59011a549d0bb7064e3b217b5", "filename": "src/librustc/infer/bivariate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Finfer%2Fbivariate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Finfer%2Fbivariate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fbivariate.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -25,7 +25,7 @@\n //! In particular, it might be enough to say (A,B) are bivariant for\n //! all (A,B).\n \n-use super::combine::{self, CombineFields};\n+use super::combine::CombineFields;\n use super::type_variable::{BiTo};\n \n use ty::{self, Ty, TyCtxt};\n@@ -96,7 +96,7 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Bivariate<'a, 'tcx> {\n             }\n \n             _ => {\n-                combine::super_combine_tys(self.fields.infcx, self, a, b)\n+                self.fields.infcx.super_combine_tys(self, a, b)\n             }\n         }\n     }"}, {"sha": "0812d8d0de413e18c1c27630f8b7ae50b3f06689", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 42, "deletions": 40, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -60,50 +60,51 @@ pub struct CombineFields<'a, 'tcx: 'a> {\n     pub obligations: PredicateObligations<'tcx>,\n }\n \n-pub fn super_combine_tys<'a,'tcx:'a,R>(infcx: &InferCtxt<'a, 'tcx>,\n-                                       relation: &mut R,\n-                                       a: Ty<'tcx>,\n-                                       b: Ty<'tcx>)\n-                                       -> RelateResult<'tcx, Ty<'tcx>>\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+pub fn super_combine_tys<R>(&self,\n+                            relation: &mut R,\n+                            a: Ty<'tcx>,\n+                            b: Ty<'tcx>)\n+                            -> RelateResult<'tcx, Ty<'tcx>>\n     where R: TypeRelation<'a,'tcx>\n {\n     let a_is_expected = relation.a_is_expected();\n \n     match (&a.sty, &b.sty) {\n         // Relate integral variables to other types\n         (&ty::TyInfer(ty::IntVar(a_id)), &ty::TyInfer(ty::IntVar(b_id))) => {\n-            infcx.int_unification_table\n-                 .borrow_mut()\n-                 .unify_var_var(a_id, b_id)\n-                 .map_err(|e| int_unification_error(a_is_expected, e))?;\n+            self.int_unification_table\n+                .borrow_mut()\n+                .unify_var_var(a_id, b_id)\n+                .map_err(|e| int_unification_error(a_is_expected, e))?;\n             Ok(a)\n         }\n         (&ty::TyInfer(ty::IntVar(v_id)), &ty::TyInt(v)) => {\n-            unify_integral_variable(infcx, a_is_expected, v_id, IntType(v))\n+            self.unify_integral_variable(a_is_expected, v_id, IntType(v))\n         }\n         (&ty::TyInt(v), &ty::TyInfer(ty::IntVar(v_id))) => {\n-            unify_integral_variable(infcx, !a_is_expected, v_id, IntType(v))\n+            self.unify_integral_variable(!a_is_expected, v_id, IntType(v))\n         }\n         (&ty::TyInfer(ty::IntVar(v_id)), &ty::TyUint(v)) => {\n-            unify_integral_variable(infcx, a_is_expected, v_id, UintType(v))\n+            self.unify_integral_variable(a_is_expected, v_id, UintType(v))\n         }\n         (&ty::TyUint(v), &ty::TyInfer(ty::IntVar(v_id))) => {\n-            unify_integral_variable(infcx, !a_is_expected, v_id, UintType(v))\n+            self.unify_integral_variable(!a_is_expected, v_id, UintType(v))\n         }\n \n         // Relate floating-point variables to other types\n         (&ty::TyInfer(ty::FloatVar(a_id)), &ty::TyInfer(ty::FloatVar(b_id))) => {\n-            infcx.float_unification_table\n-                 .borrow_mut()\n-                 .unify_var_var(a_id, b_id)\n-                 .map_err(|e| float_unification_error(relation.a_is_expected(), e))?;\n+            self.float_unification_table\n+                .borrow_mut()\n+                .unify_var_var(a_id, b_id)\n+                .map_err(|e| float_unification_error(relation.a_is_expected(), e))?;\n             Ok(a)\n         }\n         (&ty::TyInfer(ty::FloatVar(v_id)), &ty::TyFloat(v)) => {\n-            unify_float_variable(infcx, a_is_expected, v_id, v)\n+            self.unify_float_variable(a_is_expected, v_id, v)\n         }\n         (&ty::TyFloat(v), &ty::TyInfer(ty::FloatVar(v_id))) => {\n-            unify_float_variable(infcx, !a_is_expected, v_id, v)\n+            self.unify_float_variable(!a_is_expected, v_id, v)\n         }\n \n         // All other cases of inference are errors\n@@ -119,33 +120,34 @@ pub fn super_combine_tys<'a,'tcx:'a,R>(infcx: &InferCtxt<'a, 'tcx>,\n     }\n }\n \n-fn unify_integral_variable<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n-                                    vid_is_expected: bool,\n-                                    vid: ty::IntVid,\n-                                    val: ty::IntVarValue)\n-                                    -> RelateResult<'tcx, Ty<'tcx>>\n+fn unify_integral_variable(&self,\n+                           vid_is_expected: bool,\n+                           vid: ty::IntVid,\n+                           val: ty::IntVarValue)\n+                           -> RelateResult<'tcx, Ty<'tcx>>\n {\n-    infcx.int_unification_table\n-         .borrow_mut()\n-         .unify_var_value(vid, val)\n-         .map_err(|e| int_unification_error(vid_is_expected, e))?;\n+    self.int_unification_table\n+        .borrow_mut()\n+        .unify_var_value(vid, val)\n+        .map_err(|e| int_unification_error(vid_is_expected, e))?;\n     match val {\n-        IntType(v) => Ok(infcx.tcx.mk_mach_int(v)),\n-        UintType(v) => Ok(infcx.tcx.mk_mach_uint(v)),\n+        IntType(v) => Ok(self.tcx.mk_mach_int(v)),\n+        UintType(v) => Ok(self.tcx.mk_mach_uint(v)),\n     }\n }\n \n-fn unify_float_variable<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n-                                 vid_is_expected: bool,\n-                                 vid: ty::FloatVid,\n-                                 val: ast::FloatTy)\n-                                 -> RelateResult<'tcx, Ty<'tcx>>\n+fn unify_float_variable(&self,\n+                        vid_is_expected: bool,\n+                        vid: ty::FloatVid,\n+                        val: ast::FloatTy)\n+                        -> RelateResult<'tcx, Ty<'tcx>>\n {\n-    infcx.float_unification_table\n-         .borrow_mut()\n-         .unify_var_value(vid, val)\n-         .map_err(|e| float_unification_error(vid_is_expected, e))?;\n-    Ok(infcx.tcx.mk_mach_float(val))\n+    self.float_unification_table\n+        .borrow_mut()\n+        .unify_var_value(vid, val)\n+        .map_err(|e| float_unification_error(vid_is_expected, e))?;\n+    Ok(self.tcx.mk_mach_float(val))\n+}\n }\n \n impl<'a, 'tcx> CombineFields<'a, 'tcx> {"}, {"sha": "d6a66f74c2ddad30502b46717f1b428c82456784", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::combine::{self, CombineFields};\n+use super::combine::CombineFields;\n use super::higher_ranked::HigherRankedRelations;\n use super::{Subtype};\n use super::type_variable::{EqTo};\n@@ -74,7 +74,7 @@ impl<'a, 'tcx> TypeRelation<'a,'tcx> for Equate<'a, 'tcx> {\n             }\n \n             _ => {\n-                combine::super_combine_tys(self.fields.infcx, self, a, b)?;\n+                self.fields.infcx.super_combine_tys(self, a, b)?;\n                 Ok(a)\n             }\n         }"}, {"sha": "8572eee5ccc20ad1e69bab15a2e5378fc9b20406", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 34, "deletions": 49, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -31,14 +31,6 @@ pub trait HigherRankedRelations<'a,'tcx> {\n         where T: Relate<'a,'tcx>;\n }\n \n-trait InferCtxtExt {\n-    fn tainted_regions(&self, snapshot: &CombinedSnapshot, r: ty::Region) -> Vec<ty::Region>;\n-\n-    fn region_vars_confined_to_snapshot(&self,\n-                                        snapshot: &CombinedSnapshot)\n-                                        -> Vec<ty::RegionVid>;\n-}\n-\n impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n     fn higher_ranked_sub<T>(&self, a: &Binder<T>, b: &Binder<T>)\n                             -> RelateResult<'tcx, Binder<T>>\n@@ -79,23 +71,9 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n \n             // Presuming type comparison succeeds, we need to check\n             // that the skolemized regions do not \"leak\".\n-            match leak_check(self.infcx, &skol_map, snapshot) {\n-                Ok(()) => { }\n-                Err((skol_br, tainted_region)) => {\n-                    if self.a_is_expected {\n-                        debug!(\"Not as polymorphic!\");\n-                        return Err(TypeError::RegionsInsufficientlyPolymorphic(skol_br,\n-                                                                               tainted_region));\n-                    } else {\n-                        debug!(\"Overly polymorphic!\");\n-                        return Err(TypeError::RegionsOverlyPolymorphic(skol_br,\n-                                                                       tainted_region));\n-                    }\n-                }\n-            }\n+            self.infcx.leak_check(!self.a_is_expected, &skol_map, snapshot)?;\n \n-            debug!(\"higher_ranked_sub: OK result={:?}\",\n-                   result);\n+            debug!(\"higher_ranked_sub: OK result={:?}\", result);\n \n             Ok(ty::Binder(result))\n         });\n@@ -371,7 +349,7 @@ fn fold_regions_in<'tcx, T, F>(tcx: &TyCtxt<'tcx>,\n     })\n }\n \n-impl<'a,'tcx> InferCtxtExt for InferCtxt<'a,'tcx> {\n+impl<'a,'tcx> InferCtxt<'a,'tcx> {\n     fn tainted_regions(&self, snapshot: &CombinedSnapshot, r: ty::Region) -> Vec<ty::Region> {\n         self.region_vars.tainted(&snapshot.region_vars_snapshot, r)\n     }\n@@ -452,12 +430,11 @@ impl<'a,'tcx> InferCtxtExt for InferCtxt<'a,'tcx> {\n \n         region_vars\n     }\n-}\n \n-pub fn skolemize_late_bound_regions<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n-                                               binder: &ty::Binder<T>,\n-                                               snapshot: &CombinedSnapshot)\n-                                               -> (T, SkolemizationMap)\n+pub fn skolemize_late_bound_regions<T>(&self,\n+                                       binder: &ty::Binder<T>,\n+                                       snapshot: &CombinedSnapshot)\n+                                       -> (T, SkolemizationMap)\n     where T : TypeFoldable<'tcx>\n {\n     /*!\n@@ -468,8 +445,8 @@ pub fn skolemize_late_bound_regions<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n      * details.\n      */\n \n-    let (result, map) = infcx.tcx.replace_late_bound_regions(binder, |br| {\n-        infcx.region_vars.new_skolemized(br, &snapshot.region_vars_snapshot)\n+    let (result, map) = self.tcx.replace_late_bound_regions(binder, |br| {\n+        self.region_vars.new_skolemized(br, &snapshot.region_vars_snapshot)\n     });\n \n     debug!(\"skolemize_bound_regions(binder={:?}, result={:?}, map={:?})\",\n@@ -480,10 +457,11 @@ pub fn skolemize_late_bound_regions<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n     (result, map)\n }\n \n-pub fn leak_check<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n-                           skol_map: &SkolemizationMap,\n-                           snapshot: &CombinedSnapshot)\n-                           -> Result<(),(ty::BoundRegion,ty::Region)>\n+pub fn leak_check(&self,\n+                  overly_polymorphic: bool,\n+                  skol_map: &SkolemizationMap,\n+                  snapshot: &CombinedSnapshot)\n+                  -> RelateResult<'tcx, ()>\n {\n     /*!\n      * Searches the region constriants created since `snapshot` was started\n@@ -496,9 +474,9 @@ pub fn leak_check<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n     debug!(\"leak_check: skol_map={:?}\",\n            skol_map);\n \n-    let new_vars = infcx.region_vars_confined_to_snapshot(snapshot);\n+    let new_vars = self.region_vars_confined_to_snapshot(snapshot);\n     for (&skol_br, &skol) in skol_map {\n-        let tainted = infcx.tainted_regions(snapshot, skol);\n+        let tainted = self.tainted_regions(snapshot, skol);\n         for &tainted_region in &tainted {\n             // Each skolemized should only be relatable to itself\n             // or new variables:\n@@ -516,8 +494,15 @@ pub fn leak_check<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n                    skol_br,\n                    tainted_region);\n \n-            // A is not as polymorphic as B:\n-            return Err((skol_br, tainted_region));\n+            if overly_polymorphic {\n+                debug!(\"Overly polymorphic!\");\n+                return Err(TypeError::RegionsOverlyPolymorphic(skol_br,\n+                                                               tainted_region));\n+            } else {\n+                debug!(\"Not as polymorphic!\");\n+                return Err(TypeError::RegionsInsufficientlyPolymorphic(skol_br,\n+                                                                       tainted_region));\n+            }\n         }\n     }\n     Ok(())\n@@ -551,14 +536,13 @@ pub fn leak_check<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n /// replace `'0` with a late-bound region `'a`.  The depth is matched\n /// to the depth of the predicate, in this case 1, so that the final\n /// predicate is `for<'a> &'a int : Clone`.\n-pub fn plug_leaks<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n-                             skol_map: SkolemizationMap,\n-                             snapshot: &CombinedSnapshot,\n-                             value: &T)\n-                             -> T\n+pub fn plug_leaks<T>(&self,\n+                     skol_map: SkolemizationMap,\n+                     snapshot: &CombinedSnapshot,\n+                     value: &T) -> T\n     where T : TypeFoldable<'tcx>\n {\n-    debug_assert!(leak_check(infcx, &skol_map, snapshot).is_ok());\n+    debug_assert!(self.leak_check(false, &skol_map, snapshot).is_ok());\n \n     debug!(\"plug_leaks(skol_map={:?}, value={:?})\",\n            skol_map,\n@@ -572,7 +556,7 @@ pub fn plug_leaks<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n         skol_map\n         .into_iter()\n         .flat_map(|(skol_br, skol)| {\n-            infcx.tainted_regions(snapshot, skol)\n+            self.tainted_regions(snapshot, skol)\n                 .into_iter()\n                 .map(move |tainted_region| (tainted_region, skol_br))\n         })\n@@ -583,14 +567,14 @@ pub fn plug_leaks<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n \n     // Remove any instantiated type variables from `value`; those can hide\n     // references to regions from the `fold_regions` code below.\n-    let value = infcx.resolve_type_vars_if_possible(value);\n+    let value = self.resolve_type_vars_if_possible(value);\n \n     // Map any skolemization byproducts back to a late-bound\n     // region. Put that late-bound region at whatever the outermost\n     // binder is that we encountered in `value`. The caller is\n     // responsible for ensuring that (a) `value` contains at least one\n     // binder and (b) that binder is the one we want to use.\n-    let result = infcx.tcx.fold_regions(&value, &mut false, |r, current_depth| {\n+    let result = self.tcx.fold_regions(&value, &mut false, |r, current_depth| {\n         match inv_skol_map.get(&r) {\n             None => r,\n             Some(br) => {\n@@ -612,3 +596,4 @@ pub fn plug_leaks<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n \n     result\n }\n+}"}, {"sha": "94d261f9df383601a08ea049e356b235c55b0618", "filename": "src/librustc/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flattice.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -29,7 +29,6 @@\n //! over a `LatticeValue`, which is a value defined with respect to\n //! a lattice.\n \n-use super::combine;\n use super::InferCtxt;\n \n use ty::TyVar;\n@@ -78,7 +77,7 @@ pub fn super_lattice_tys<'a,'tcx,L:LatticeDir<'a,'tcx>>(this: &mut L,\n         }\n \n         _ => {\n-            combine::super_combine_tys(this.infcx(), this, a, b)\n+            infcx.super_combine_tys(this, a, b)\n         }\n     }\n }"}, {"sha": "c876f6adae5618c88af0ae7df8f7c30d5a6dc3e1", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 83, "deletions": 186, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -366,19 +366,21 @@ pub enum FixupError {\n     UnresolvedTy(TyVid)\n }\n \n-pub fn fixup_err_to_string(f: FixupError) -> String {\n-    use self::FixupError::*;\n-\n-    match f {\n-      UnresolvedIntTy(_) => {\n-          \"cannot determine the type of this integer; add a suffix to \\\n-           specify the type explicitly\".to_string()\n-      }\n-      UnresolvedFloatTy(_) => {\n-          \"cannot determine the type of this number; add a suffix to specify \\\n-           the type explicitly\".to_string()\n-      }\n-      UnresolvedTy(_) => \"unconstrained type\".to_string(),\n+impl fmt::Display for FixupError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        use self::FixupError::*;\n+\n+        match *self {\n+            UnresolvedIntTy(_) => {\n+                write!(f, \"cannot determine the type of this integer; \\\n+                           add a suffix to specify the type explicitly\")\n+            }\n+            UnresolvedFloatTy(_) => {\n+                write!(f, \"cannot determine the type of this number; \\\n+                           add a suffix to specify the type explicitly\")\n+            }\n+            UnresolvedTy(_) => write!(f, \"unconstrained type\")\n+        }\n     }\n }\n \n@@ -414,103 +416,19 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n }\n \n-pub fn mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n-                          a_is_expected: bool,\n-                          origin: TypeOrigin,\n-                          a: Ty<'tcx>,\n-                          b: Ty<'tcx>)\n-    -> InferResult<'tcx, ()>\n-{\n-    debug!(\"mk_subty({:?} <: {:?})\", a, b);\n-    cx.sub_types(a_is_expected, origin, a, b)\n-}\n-\n-pub fn can_mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>, a: Ty<'tcx>, b: Ty<'tcx>)\n-    -> UnitResult<'tcx>\n-{\n-    debug!(\"can_mk_subty({:?} <: {:?})\", a, b);\n-    cx.probe(|_| {\n-        let trace = TypeTrace {\n-            origin: TypeOrigin::Misc(codemap::DUMMY_SP),\n-            values: Types(expected_found(true, a, b))\n-        };\n-        cx.sub(true, trace, &a, &b).map(|_| ())\n-    })\n-}\n-\n-pub fn can_mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>, a: Ty<'tcx>, b: Ty<'tcx>)\n-    -> UnitResult<'tcx>\n-{\n-    cx.can_equate(&a, &b)\n-}\n-\n-pub fn mk_subr<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n-                         origin: SubregionOrigin<'tcx>,\n-                         a: ty::Region,\n-                         b: ty::Region) {\n-    debug!(\"mk_subr({:?} <: {:?})\", a, b);\n-    let snapshot = cx.region_vars.start_snapshot();\n-    cx.region_vars.make_subregion(origin, a, b);\n-    cx.region_vars.commit(snapshot);\n-}\n-\n-pub fn mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n-                         a_is_expected: bool,\n-                         origin: TypeOrigin,\n-                         a: Ty<'tcx>,\n-                         b: Ty<'tcx>)\n-    -> InferResult<'tcx, ()>\n-{\n-    debug!(\"mk_eqty({:?} <: {:?})\", a, b);\n-    cx.eq_types(a_is_expected, origin, a, b)\n-}\n-\n-pub fn mk_eq_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n-                                  a_is_expected: bool,\n-                                  origin: TypeOrigin,\n-                                  a: ty::TraitRef<'tcx>,\n-                                  b: ty::TraitRef<'tcx>)\n-    -> InferResult<'tcx, ()>\n-{\n-    debug!(\"mk_eq_trait_refs({:?} = {:?})\", a, b);\n-    cx.eq_trait_refs(a_is_expected, origin, a, b)\n-}\n-\n-pub fn mk_sub_poly_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n-                                        a_is_expected: bool,\n-                                        origin: TypeOrigin,\n-                                        a: ty::PolyTraitRef<'tcx>,\n-                                        b: ty::PolyTraitRef<'tcx>)\n-    -> InferResult<'tcx, ()>\n-{\n-    debug!(\"mk_sub_poly_trait_refs({:?} <: {:?})\", a, b);\n-    cx.sub_poly_trait_refs(a_is_expected, origin, a, b)\n-}\n-\n-pub fn mk_eq_impl_headers<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n-                                    a_is_expected: bool,\n-                                    origin: TypeOrigin,\n-                                    a: &ty::ImplHeader<'tcx>,\n-                                    b: &ty::ImplHeader<'tcx>)\n-    -> InferResult<'tcx, ()>\n-{\n-    debug!(\"mk_eq_impl_header({:?} = {:?})\", a, b);\n-    match (a.trait_ref, b.trait_ref) {\n-        (Some(a_ref), Some(b_ref)) => mk_eq_trait_refs(cx, a_is_expected, origin, a_ref, b_ref),\n-        (None, None) => mk_eqty(cx, a_is_expected, origin, a.self_ty, b.self_ty),\n-        _ => bug!(\"mk_eq_impl_headers given mismatched impl kinds\"),\n+impl<T> ExpectedFound<T> {\n+    fn new(a_is_expected: bool, a: T, b: T) -> Self {\n+        if a_is_expected {\n+            ExpectedFound {expected: a, found: b}\n+        } else {\n+            ExpectedFound {expected: b, found: a}\n+        }\n     }\n }\n \n-fn expected_found<T>(a_is_expected: bool,\n-                     a: T,\n-                     b: T)\n-                     -> ExpectedFound<T>\n-{\n-    if a_is_expected {\n-        ExpectedFound {expected: a, found: b}\n-    } else {\n-        ExpectedFound {expected: b, found: a}\n+impl<'tcx, T> InferOk<'tcx, T> {\n+    fn unit(self) -> InferOk<'tcx, ()> {\n+        InferOk { value: (), obligations: self.obligations }\n     }\n }\n \n@@ -551,18 +469,19 @@ impl<'tcx> TyCtxt<'tcx> {\n             fulfill_cx.register_predicate_obligation(&infcx, obligation);\n         }\n \n-        drain_fulfillment_cx_or_panic(DUMMY_SP, &infcx, &mut fulfill_cx, &result)\n+        infcx.drain_fulfillment_cx_or_panic(DUMMY_SP, &mut fulfill_cx, &result)\n     }\n }\n \n-pub fn drain_fulfillment_cx_or_panic<'a,'tcx,T>(span: Span,\n-                                                infcx: &InferCtxt<'a,'tcx>,\n-                                                fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n-                                                result: &T)\n-                                                -> T\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+pub fn drain_fulfillment_cx_or_panic<T>(&self,\n+                                        span: Span,\n+                                        fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n+                                        result: &T)\n+                                        -> T\n     where T : TypeFoldable<'tcx>\n {\n-    match drain_fulfillment_cx(infcx, fulfill_cx, result) {\n+    match self.drain_fulfillment_cx(fulfill_cx, result) {\n         Ok(v) => v,\n         Err(errors) => {\n             span_bug!(\n@@ -580,10 +499,10 @@ pub fn drain_fulfillment_cx_or_panic<'a,'tcx,T>(span: Span,\n /// inference variables that appear in `result` to be unified, and\n /// hence we need to process those obligations to get the complete\n /// picture of the type.\n-pub fn drain_fulfillment_cx<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n-                                       fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n-                                       result: &T)\n-                                       -> Result<T,Vec<traits::FulfillmentError<'tcx>>>\n+pub fn drain_fulfillment_cx<T>(&self,\n+                               fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n+                               result: &T)\n+                               -> Result<T,Vec<traits::FulfillmentError<'tcx>>>\n     where T : TypeFoldable<'tcx>\n {\n     debug!(\"drain_fulfillment_cx(result={:?})\",\n@@ -592,24 +511,12 @@ pub fn drain_fulfillment_cx<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n     // In principle, we only need to do this so long as `result`\n     // contains unbound type parameters. It could be a slight\n     // optimization to stop iterating early.\n-    match fulfill_cx.select_all_or_error(infcx) {\n-        Ok(()) => { }\n-        Err(errors) => {\n-            return Err(errors);\n-        }\n-    }\n-\n-    let result = infcx.resolve_type_vars_if_possible(result);\n-    Ok(infcx.tcx.erase_regions(&result))\n-}\n+    fulfill_cx.select_all_or_error(self)?;\n \n-impl<'tcx, T> InferOk<'tcx, T> {\n-    fn unit(self) -> InferOk<'tcx, ()> {\n-        InferOk { value: (), obligations: self.obligations }\n-    }\n+    let result = self.resolve_type_vars_if_possible(result);\n+    Ok(self.tcx.erase_regions(&result))\n }\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn projection_mode(&self) -> ProjectionMode {\n         self.projection_mode\n     }\n@@ -896,6 +803,18 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         })\n     }\n \n+    pub fn can_sub_types(&self,\n+                         a: Ty<'tcx>,\n+                         b: Ty<'tcx>)\n+                         -> UnitResult<'tcx>\n+    {\n+        self.probe(|_| {\n+            let origin = TypeOrigin::Misc(codemap::DUMMY_SP);\n+            let trace = TypeTrace::types(origin, true, a, b);\n+            self.sub(true, trace, &a, &b).map(|_| ())\n+        })\n+    }\n+\n     pub fn eq_types(&self,\n                     a_is_expected: bool,\n                     origin: TypeOrigin,\n@@ -916,71 +835,54 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                           b: ty::TraitRef<'tcx>)\n         -> InferResult<'tcx, ()>\n     {\n-        debug!(\"eq_trait_refs({:?} <: {:?})\",\n-               a,\n-               b);\n+        debug!(\"eq_trait_refs({:?} = {:?})\", a, b);\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace {\n                 origin: origin,\n-                values: TraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n+                values: TraitRefs(ExpectedFound::new(a_is_expected, a, b))\n             };\n             self.equate(a_is_expected, trace, &a, &b).map(|ok| ok.unit())\n         })\n     }\n \n+    pub fn eq_impl_headers(&self,\n+                           a_is_expected: bool,\n+                           origin: TypeOrigin,\n+                           a: &ty::ImplHeader<'tcx>,\n+                           b: &ty::ImplHeader<'tcx>)\n+                           -> InferResult<'tcx, ()>\n+    {\n+        debug!(\"eq_impl_header({:?} = {:?})\", a, b);\n+        match (a.trait_ref, b.trait_ref) {\n+            (Some(a_ref), Some(b_ref)) => self.eq_trait_refs(a_is_expected, origin, a_ref, b_ref),\n+            (None, None) => self.eq_types(a_is_expected, origin, a.self_ty, b.self_ty),\n+            _ => bug!(\"mk_eq_impl_headers given mismatched impl kinds\"),\n+        }\n+    }\n+\n     pub fn sub_poly_trait_refs(&self,\n                                a_is_expected: bool,\n                                origin: TypeOrigin,\n                                a: ty::PolyTraitRef<'tcx>,\n                                b: ty::PolyTraitRef<'tcx>)\n         -> InferResult<'tcx, ()>\n     {\n-        debug!(\"sub_poly_trait_refs({:?} <: {:?})\",\n-               a,\n-               b);\n+        debug!(\"sub_poly_trait_refs({:?} <: {:?})\", a, b);\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace {\n                 origin: origin,\n-                values: PolyTraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n+                values: PolyTraitRefs(ExpectedFound::new(a_is_expected, a, b))\n             };\n             self.sub(a_is_expected, trace, &a, &b).map(|ok| ok.unit())\n         })\n     }\n \n-    pub fn skolemize_late_bound_regions<T>(&self,\n-                                           value: &ty::Binder<T>,\n-                                           snapshot: &CombinedSnapshot)\n-                                           -> (T, SkolemizationMap)\n-        where T : TypeFoldable<'tcx>\n-    {\n-        /*! See `higher_ranked::skolemize_late_bound_regions` */\n-\n-        higher_ranked::skolemize_late_bound_regions(self, value, snapshot)\n-    }\n-\n-    pub fn leak_check(&self,\n-                      skol_map: &SkolemizationMap,\n-                      snapshot: &CombinedSnapshot)\n-                      -> UnitResult<'tcx>\n-    {\n-        /*! See `higher_ranked::leak_check` */\n-\n-        match higher_ranked::leak_check(self, skol_map, snapshot) {\n-            Ok(()) => Ok(()),\n-            Err((br, r)) => Err(TypeError::RegionsInsufficientlyPolymorphic(br, r))\n-        }\n-    }\n-\n-    pub fn plug_leaks<T>(&self,\n-                         skol_map: SkolemizationMap,\n-                         snapshot: &CombinedSnapshot,\n-                         value: &T)\n-                         -> T\n-        where T : TypeFoldable<'tcx>\n-    {\n-        /*! See `higher_ranked::plug_leaks` */\n-\n-        higher_ranked::plug_leaks(self, skol_map, snapshot, value)\n+    pub fn sub_regions(&self,\n+                       origin: SubregionOrigin<'tcx>,\n+                       a: ty::Region,\n+                       b: ty::Region) {\n+        debug!(\"sub_regions({:?} <: {:?})\", a, b);\n+        self.region_vars.make_subregion(origin, a, b);\n     }\n \n     pub fn equality_predicate(&self,\n@@ -992,8 +894,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             let (ty::EquatePredicate(a, b), skol_map) =\n                 self.skolemize_late_bound_regions(predicate, snapshot);\n             let origin = TypeOrigin::EquatePredicate(span);\n-            let eqty_ok = mk_eqty(self, false, origin, a, b)?;\n-            self.leak_check(&skol_map, snapshot).map(|_| eqty_ok.unit())\n+            let eqty_ok = self.eq_types(false, origin, a, b)?;\n+            self.leak_check(false, &skol_map, snapshot).map(|_| eqty_ok.unit())\n         })\n     }\n \n@@ -1006,8 +908,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             let (ty::OutlivesPredicate(r_a, r_b), skol_map) =\n                 self.skolemize_late_bound_regions(predicate, snapshot);\n             let origin = RelateRegionParamBound(span);\n-            let () = mk_subr(self, origin, r_b, r_a); // `b : a` ==> `a <= b`\n-            self.leak_check(&skol_map, snapshot)\n+            self.sub_regions(origin, r_b, r_a); // `b : a` ==> `a <= b`\n+            self.leak_check(false, &skol_map, snapshot)\n         })\n     }\n \n@@ -1509,12 +1411,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             // anyhow. We should make this typetrace stuff more\n             // generic so we don't have to do anything quite this\n             // terrible.\n-            let e = self.tcx.types.err;\n-            let trace = TypeTrace {\n-                origin: TypeOrigin::Misc(codemap::DUMMY_SP),\n-                values: Types(expected_found(true, e, e))\n-            };\n-            self.equate(true, trace, a, b)\n+            self.equate(true, TypeTrace::dummy(self.tcx), a, b)\n         }).map(|_| ())\n     }\n \n@@ -1638,7 +1535,7 @@ impl<'tcx> TypeTrace<'tcx> {\n                  -> TypeTrace<'tcx> {\n         TypeTrace {\n             origin: origin,\n-            values: Types(expected_found(a_is_expected, a, b))\n+            values: Types(ExpectedFound::new(a_is_expected, a, b))\n         }\n     }\n "}, {"sha": "a85ae46e662d79df3ec49e7ea2857888ab0af3f7", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::combine::{self, CombineFields};\n+use super::combine::CombineFields;\n use super::higher_ranked::HigherRankedRelations;\n use super::SubregionOrigin;\n use super::type_variable::{SubtypeOf, SupertypeOf};\n@@ -96,7 +96,7 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Sub<'a, 'tcx> {\n             }\n \n             _ => {\n-                combine::super_combine_tys(self.fields.infcx, self, a, b)?;\n+                self.fields.infcx.super_combine_tys(self, a, b)?;\n                 Ok(a)\n             }\n         }"}, {"sha": "f9a9a451d45fd0412417c0f98876a9204d7f33a5", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -20,63 +20,64 @@ use ty::{Ty, TyCtxt};\n use syntax::codemap::Span;\n use hir as ast;\n \n-pub fn prohibit_type_params(tcx: &TyCtxt, segments: &[ast::PathSegment]) {\n+impl<'tcx> TyCtxt<'tcx> {\n+pub fn prohibit_type_params(&self, segments: &[ast::PathSegment]) {\n     for segment in segments {\n         for typ in segment.parameters.types() {\n-            span_err!(tcx.sess, typ.span, E0109,\n+            span_err!(self.sess, typ.span, E0109,\n                       \"type parameters are not allowed on this type\");\n             break;\n         }\n         for lifetime in segment.parameters.lifetimes() {\n-            span_err!(tcx.sess, lifetime.span, E0110,\n+            span_err!(self.sess, lifetime.span, E0110,\n                       \"lifetime parameters are not allowed on this type\");\n             break;\n         }\n         for binding in segment.parameters.bindings() {\n-            prohibit_projection(tcx, binding.span);\n+            self.prohibit_projection(binding.span);\n             break;\n         }\n     }\n }\n \n-pub fn prohibit_projection(tcx: &TyCtxt, span: Span)\n+pub fn prohibit_projection(&self, span: Span)\n {\n-    span_err!(tcx.sess, span, E0229,\n+    span_err!(self.sess, span, E0229,\n               \"associated type bindings are not allowed here\");\n }\n \n-pub fn prim_ty_to_ty<'tcx>(tcx: &TyCtxt<'tcx>,\n-                           segments: &[ast::PathSegment],\n-                           nty: ast::PrimTy)\n-                           -> Ty<'tcx> {\n-    prohibit_type_params(tcx, segments);\n+pub fn prim_ty_to_ty(&self,\n+                     segments: &[ast::PathSegment],\n+                     nty: ast::PrimTy)\n+                     -> Ty<'tcx> {\n+    self.prohibit_type_params(segments);\n     match nty {\n-        ast::TyBool => tcx.types.bool,\n-        ast::TyChar => tcx.types.char,\n-        ast::TyInt(it) => tcx.mk_mach_int(it),\n-        ast::TyUint(uit) => tcx.mk_mach_uint(uit),\n-        ast::TyFloat(ft) => tcx.mk_mach_float(ft),\n-        ast::TyStr => tcx.mk_str()\n+        ast::TyBool => self.types.bool,\n+        ast::TyChar => self.types.char,\n+        ast::TyInt(it) => self.mk_mach_int(it),\n+        ast::TyUint(uit) => self.mk_mach_uint(uit),\n+        ast::TyFloat(ft) => self.mk_mach_float(ft),\n+        ast::TyStr => self.mk_str()\n     }\n }\n \n /// If a type in the AST is a primitive type, return the ty::Ty corresponding\n /// to it.\n-pub fn ast_ty_to_prim_ty<'tcx>(tcx: &TyCtxt<'tcx>, ast_ty: &ast::Ty)\n-                               -> Option<Ty<'tcx>> {\n+pub fn ast_ty_to_prim_ty(&self, ast_ty: &ast::Ty) -> Option<Ty<'tcx>> {\n     if let ast::TyPath(None, ref path) = ast_ty.node {\n-        let def = match tcx.def_map.borrow().get(&ast_ty.id) {\n+        let def = match self.def_map.borrow().get(&ast_ty.id) {\n             None => {\n                 span_bug!(ast_ty.span, \"unbound path {:?}\", path)\n             }\n             Some(d) => d.full_def()\n         };\n         if let Def::PrimTy(nty) = def {\n-            Some(prim_ty_to_ty(tcx, &path.segments, nty))\n+            Some(self.prim_ty_to_ty(&path.segments, nty))\n         } else {\n             None\n         }\n     } else {\n         None\n     }\n }\n+}"}, {"sha": "ccd927a3289e3673053b2c25ac7593e567a88014", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -48,9 +48,8 @@ impl FreeRegionMap {\n         }\n     }\n \n-    pub fn relate_free_regions_from_predicates<'tcx>(&mut self,\n-                                                     _tcx: &TyCtxt<'tcx>,\n-                                                     predicates: &[ty::Predicate<'tcx>]) {\n+    pub fn relate_free_regions_from_predicates(&mut self,\n+                                               predicates: &[ty::Predicate]) {\n         debug!(\"relate_free_regions_from_predicates(predicates={:?})\", predicates);\n         for predicate in predicates {\n             match *predicate {"}, {"sha": "f596f3b4a50a11ac3365c4b9f8305adaf3c81bdd", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -625,9 +625,9 @@ fn maybe_do_stability_check(tcx: &TyCtxt, id: DefId, span: Span,\n         return;\n     }\n     let (stability, deprecation) = if is_staged_api(tcx, id) {\n-        (lookup_stability(tcx, id), None)\n+        (tcx.lookup_stability(id), None)\n     } else {\n-        (None, lookup_deprecation(tcx, id))\n+        (None, tcx.lookup_deprecation(id))\n     };\n     debug!(\"maybe_do_stability_check: \\\n             inspecting id={:?} span={:?} of stability={:?}\", id, span, stability);\n@@ -651,45 +651,47 @@ fn is_staged_api(tcx: &TyCtxt, id: DefId) -> bool {\n     }\n }\n \n+impl<'tcx> TyCtxt<'tcx> {\n /// Lookup the stability for a node, loading external crate\n /// metadata as necessary.\n-pub fn lookup_stability<'tcx>(tcx: &TyCtxt<'tcx>, id: DefId) -> Option<&'tcx Stability> {\n-    if let Some(st) = tcx.stability.borrow().stab_map.get(&id) {\n+pub fn lookup_stability(&self, id: DefId) -> Option<&'tcx Stability> {\n+    if let Some(st) = self.stability.borrow().stab_map.get(&id) {\n         return *st;\n     }\n \n-    let st = lookup_stability_uncached(tcx, id);\n-    tcx.stability.borrow_mut().stab_map.insert(id, st);\n+    let st = self.lookup_stability_uncached(id);\n+    self.stability.borrow_mut().stab_map.insert(id, st);\n     st\n }\n \n-pub fn lookup_deprecation<'tcx>(tcx: &TyCtxt<'tcx>, id: DefId) -> Option<Deprecation> {\n-    if let Some(depr) = tcx.stability.borrow().depr_map.get(&id) {\n+pub fn lookup_deprecation(&self, id: DefId) -> Option<Deprecation> {\n+    if let Some(depr) = self.stability.borrow().depr_map.get(&id) {\n         return depr.clone();\n     }\n \n-    let depr = lookup_deprecation_uncached(tcx, id);\n-    tcx.stability.borrow_mut().depr_map.insert(id, depr.clone());\n+    let depr = self.lookup_deprecation_uncached(id);\n+    self.stability.borrow_mut().depr_map.insert(id, depr.clone());\n     depr\n }\n \n-fn lookup_stability_uncached<'tcx>(tcx: &TyCtxt<'tcx>, id: DefId) -> Option<&'tcx Stability> {\n+fn lookup_stability_uncached(&self, id: DefId) -> Option<&'tcx Stability> {\n     debug!(\"lookup(id={:?})\", id);\n     if id.is_local() {\n         None // The stability cache is filled partially lazily\n     } else {\n-        tcx.sess.cstore.stability(id).map(|st| tcx.intern_stability(st))\n+        self.sess.cstore.stability(id).map(|st| self.intern_stability(st))\n     }\n }\n \n-fn lookup_deprecation_uncached<'tcx>(tcx: &TyCtxt<'tcx>, id: DefId) -> Option<Deprecation> {\n+fn lookup_deprecation_uncached(&self, id: DefId) -> Option<Deprecation> {\n     debug!(\"lookup(id={:?})\", id);\n     if id.is_local() {\n         None // The stability cache is filled partially lazily\n     } else {\n-        tcx.sess.cstore.deprecation(id)\n+        self.sess.cstore.deprecation(id)\n     }\n }\n+}\n \n /// Given the list of enabled features that were not language features (i.e. that\n /// were expected to be library features), and the list of features used from"}, {"sha": "ca2224d78847415d40057e8ef06c1147f776af59", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -16,7 +16,7 @@ use middle::cstore::LOCAL_CRATE;\n use hir::def_id::DefId;\n use ty::subst::TypeSpace;\n use ty::{self, Ty, TyCtxt};\n-use infer::{self, InferCtxt, TypeOrigin};\n+use infer::{InferCtxt, TypeOrigin};\n use syntax::codemap::DUMMY_SP;\n \n #[derive(Copy, Clone)]\n@@ -57,11 +57,10 @@ fn overlap<'cx, 'tcx>(selcx: &mut SelectionContext<'cx, 'tcx>,\n     debug!(\"overlap: b_impl_header={:?}\", b_impl_header);\n \n     // Do `a` and `b` unify? If not, no overlap.\n-    if let Err(_) = infer::mk_eq_impl_headers(selcx.infcx(),\n-                                              true,\n-                                              TypeOrigin::Misc(DUMMY_SP),\n-                                              &a_impl_header,\n-                                              &b_impl_header) {\n+    if let Err(_) = selcx.infcx().eq_impl_headers(true,\n+                                                  TypeOrigin::Misc(DUMMY_SP),\n+                                                  &a_impl_header,\n+                                                  &b_impl_header) {\n         return None;\n     }\n "}, {"sha": "fb030288a72af20edd5923a66511d6bc62f9d30e", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 198, "deletions": 227, "changes": 425, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -22,7 +22,6 @@ use super::{\n     SelectionError,\n     ObjectSafetyViolation,\n     MethodViolationCode,\n-    object_safety_violations,\n };\n \n use fmt_macros::{Parser, Piece, Position};\n@@ -61,83 +60,82 @@ impl<'tcx> TraitErrorKey<'tcx> {\n     }\n }\n \n-pub fn report_fulfillment_errors<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                           errors: &Vec<FulfillmentError<'tcx>>) {\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+pub fn report_fulfillment_errors(&self, errors: &Vec<FulfillmentError<'tcx>>) {\n     for error in errors {\n-        report_fulfillment_error(infcx, error, None);\n+        self.report_fulfillment_error(error, None);\n     }\n }\n \n-pub fn report_fulfillment_errors_as_warnings<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                                       errors: &Vec<FulfillmentError<'tcx>>,\n-                                                       node_id: ast::NodeId)\n-{\n+pub fn report_fulfillment_errors_as_warnings(&self,\n+                                             errors: &Vec<FulfillmentError<'tcx>>,\n+                                             node_id: ast::NodeId) {\n     for error in errors {\n-        report_fulfillment_error(infcx, error, Some(node_id));\n+        self.report_fulfillment_error(error, Some(node_id));\n     }\n }\n \n-fn report_fulfillment_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                      error: &FulfillmentError<'tcx>,\n-                                      warning_node_id: Option<ast::NodeId>) {\n-    let error_key = TraitErrorKey::from_error(infcx, error, warning_node_id);\n+fn report_fulfillment_error(&self,\n+                            error: &FulfillmentError<'tcx>,\n+                            warning_node_id: Option<ast::NodeId>) {\n+    let error_key = TraitErrorKey::from_error(self, error, warning_node_id);\n     debug!(\"report_fulfillment_errors({:?}) - key={:?}\",\n            error, error_key);\n-    if !infcx.reported_trait_errors.borrow_mut().insert(error_key) {\n+    if !self.reported_trait_errors.borrow_mut().insert(error_key) {\n         debug!(\"report_fulfillment_errors: skipping duplicate\");\n         return;\n     }\n     match error.code {\n         FulfillmentErrorCode::CodeSelectionError(ref e) => {\n-            report_selection_error(infcx, &error.obligation, e, warning_node_id);\n+            self.report_selection_error(&error.obligation, e, warning_node_id);\n         }\n         FulfillmentErrorCode::CodeProjectionError(ref e) => {\n-            report_projection_error(infcx, &error.obligation, e, warning_node_id);\n+            self.report_projection_error(&error.obligation, e, warning_node_id);\n         }\n         FulfillmentErrorCode::CodeAmbiguity => {\n-            maybe_report_ambiguity(infcx, &error.obligation);\n+            self.maybe_report_ambiguity(&error.obligation);\n         }\n     }\n }\n \n-pub fn report_projection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                         obligation: &PredicateObligation<'tcx>,\n-                                         error: &MismatchedProjectionTypes<'tcx>,\n-                                         warning_node_id: Option<ast::NodeId>)\n+fn report_projection_error(&self,\n+                           obligation: &PredicateObligation<'tcx>,\n+                           error: &MismatchedProjectionTypes<'tcx>,\n+                           warning_node_id: Option<ast::NodeId>)\n {\n     let predicate =\n-        infcx.resolve_type_vars_if_possible(&obligation.predicate);\n+        self.resolve_type_vars_if_possible(&obligation.predicate);\n \n     if !predicate.references_error() {\n         if let Some(warning_node_id) = warning_node_id {\n-            infcx.tcx.sess.add_lint(\n+            self.tcx.sess.add_lint(\n                 ::lint::builtin::UNSIZED_IN_TUPLE,\n                 warning_node_id,\n                 obligation.cause.span,\n                 format!(\"type mismatch resolving `{}`: {}\",\n                         predicate,\n                         error.err));\n         } else {\n-            let mut err = struct_span_err!(infcx.tcx.sess, obligation.cause.span, E0271,\n+            let mut err = struct_span_err!(self.tcx.sess, obligation.cause.span, E0271,\n                                            \"type mismatch resolving `{}`: {}\",\n                                            predicate,\n                                            error.err);\n-            note_obligation_cause(infcx, &mut err, obligation);\n+            self.note_obligation_cause(&mut err, obligation);\n             err.emit();\n         }\n     }\n }\n \n-fn on_unimplemented_note<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                   trait_ref: ty::PolyTraitRef<'tcx>,\n-                                   span: Span) -> Option<String> {\n+fn on_unimplemented_note(&self,\n+                         trait_ref: ty::PolyTraitRef<'tcx>,\n+                         span: Span) -> Option<String> {\n     let trait_ref = trait_ref.skip_binder();\n     let def_id = trait_ref.def_id;\n     let mut report = None;\n-    for item in infcx.tcx.get_attrs(def_id).iter() {\n+    for item in self.tcx.get_attrs(def_id).iter() {\n         if item.check_name(\"rustc_on_unimplemented\") {\n             let err_sp = item.meta().span.substitute_dummy(span);\n-            let def = infcx.tcx.lookup_trait_def(def_id);\n+            let def = self.tcx.lookup_trait_def(def_id);\n             let trait_str = def.trait_ref.to_string();\n             if let Some(ref istring) = item.value_str() {\n                 let mut generic_map = def.generics.types.iter_enumerated()\n@@ -157,7 +155,7 @@ fn on_unimplemented_note<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                             Position::ArgumentNamed(s) => match generic_map.get(s) {\n                                 Some(val) => Some(val),\n                                 None => {\n-                                    span_err!(infcx.tcx.sess, err_sp, E0272,\n+                                    span_err!(self.tcx.sess, err_sp, E0272,\n                                                    \"the #[rustc_on_unimplemented] \\\n                                                             attribute on \\\n                                                             trait definition for {} refers to \\\n@@ -168,7 +166,7 @@ fn on_unimplemented_note<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                 }\n                             },\n                             _ => {\n-                                     span_err!(infcx.tcx.sess, err_sp, E0273,\n+                                     span_err!(self.tcx.sess, err_sp, E0273,\n                                                \"the #[rustc_on_unimplemented] \\\n                                                         attribute on \\\n                                                         trait definition for {} must have named \\\n@@ -187,7 +185,7 @@ fn on_unimplemented_note<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                     report = Some(err);\n                 }\n             } else {\n-                span_err!(infcx.tcx.sess, err_sp, E0274,\n+                span_err!(self.tcx.sess, err_sp, E0274,\n                                         \"the #[rustc_on_unimplemented] attribute on \\\n                                                  trait definition for {} must have a value, \\\n                                                  eg `#[rustc_on_unimplemented = \\\"foo\\\"]`\",\n@@ -199,21 +197,20 @@ fn on_unimplemented_note<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     report\n }\n \n-fn find_similar_impl_candidates<'a, 'tcx>(\n-    infcx: &InferCtxt<'a, 'tcx>,\n-    trait_ref: ty::PolyTraitRef<'tcx>)\n-    -> Vec<ty::TraitRef<'tcx>>\n+fn report_similar_impl_candidates(&self,\n+                                  trait_ref: ty::PolyTraitRef<'tcx>,\n+                                  err: &mut DiagnosticBuilder)\n {\n-    let simp = fast_reject::simplify_type(infcx.tcx,\n+    let simp = fast_reject::simplify_type(self.tcx,\n                                           trait_ref.skip_binder().self_ty(),\n                                           true);\n     let mut impl_candidates = Vec::new();\n-    let trait_def = infcx.tcx.lookup_trait_def(trait_ref.def_id());\n+    let trait_def = self.tcx.lookup_trait_def(trait_ref.def_id());\n \n     match simp {\n-        Some(simp) => trait_def.for_each_impl(infcx.tcx, |def_id| {\n-            let imp = infcx.tcx.impl_trait_ref(def_id).unwrap();\n-            let imp_simp = fast_reject::simplify_type(infcx.tcx,\n+        Some(simp) => trait_def.for_each_impl(self.tcx, |def_id| {\n+            let imp = self.tcx.impl_trait_ref(def_id).unwrap();\n+            let imp_simp = fast_reject::simplify_type(self.tcx,\n                                                       imp.self_ty(),\n                                                       true);\n             if let Some(imp_simp) = imp_simp {\n@@ -223,17 +220,16 @@ fn find_similar_impl_candidates<'a, 'tcx>(\n             }\n             impl_candidates.push(imp);\n         }),\n-        None => trait_def.for_each_impl(infcx.tcx, |def_id| {\n+        None => trait_def.for_each_impl(self.tcx, |def_id| {\n             impl_candidates.push(\n-                infcx.tcx.impl_trait_ref(def_id).unwrap());\n+                self.tcx.impl_trait_ref(def_id).unwrap());\n         })\n     };\n-    impl_candidates\n-}\n \n-fn report_similar_impl_candidates(err: &mut DiagnosticBuilder,\n-                                  impl_candidates: &[ty::TraitRef])\n-{\n+    if impl_candidates.is_empty() {\n+        return;\n+    }\n+\n     err.help(&format!(\"the following implementations were found:\"));\n \n     let end = cmp::min(4, impl_candidates.len());\n@@ -251,26 +247,25 @@ fn report_similar_impl_candidates(err: &mut DiagnosticBuilder,\n /// whose result could not be truly determined and thus we can't say\n /// if the program type checks or not -- and they are unusual\n /// occurrences in any case.\n-pub fn report_overflow_error<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n-                                          obligation: &Obligation<'tcx, T>,\n-                                          suggest_increasing_limit: bool)\n-                                          -> !\n+pub fn report_overflow_error<T>(&self,\n+                                obligation: &Obligation<'tcx, T>,\n+                                suggest_increasing_limit: bool) -> !\n     where T: fmt::Display + TypeFoldable<'tcx>\n {\n     let predicate =\n-        infcx.resolve_type_vars_if_possible(&obligation.predicate);\n-    let mut err = struct_span_err!(infcx.tcx.sess, obligation.cause.span, E0275,\n+        self.resolve_type_vars_if_possible(&obligation.predicate);\n+    let mut err = struct_span_err!(self.tcx.sess, obligation.cause.span, E0275,\n                                    \"overflow evaluating the requirement `{}`\",\n                                    predicate);\n \n     if suggest_increasing_limit {\n-        suggest_new_overflow_limit(infcx.tcx, &mut err);\n+        self.suggest_new_overflow_limit(&mut err);\n     }\n \n-    note_obligation_cause(infcx, &mut err, obligation);\n+    self.note_obligation_cause(&mut err, obligation);\n \n     err.emit();\n-    infcx.tcx.sess.abort_if_errors();\n+    self.tcx.sess.abort_if_errors();\n     bug!();\n }\n \n@@ -279,33 +274,29 @@ pub fn report_overflow_error<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n /// that we can give a more helpful error message (and, in particular,\n /// we do not suggest increasing the overflow limit, which is not\n /// going to help).\n-pub fn report_overflow_error_cycle<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                             cycle: &Vec<PredicateObligation<'tcx>>)\n-                                             -> !\n-{\n+pub fn report_overflow_error_cycle(&self, cycle: &Vec<PredicateObligation<'tcx>>) -> ! {\n     assert!(cycle.len() > 1);\n \n     debug!(\"report_overflow_error_cycle(cycle length = {})\", cycle.len());\n \n-    let cycle = infcx.resolve_type_vars_if_possible(cycle);\n+    let cycle = self.resolve_type_vars_if_possible(cycle);\n \n     debug!(\"report_overflow_error_cycle: cycle={:?}\", cycle);\n \n     assert_eq!(&cycle[0].predicate, &cycle.last().unwrap().predicate);\n \n-    try_report_overflow_error_type_of_infinite_size(infcx, &cycle);\n-    report_overflow_error(infcx, &cycle[0], false);\n+    self.try_report_overflow_error_type_of_infinite_size(&cycle);\n+    self.report_overflow_error(&cycle[0], false);\n }\n \n /// If a cycle results from evaluated whether something is Sized, that\n /// is a particular special case that always results from a struct or\n /// enum definition that lacks indirection (e.g., `struct Foo { x: Foo\n /// }`). We wish to report a targeted error for this case.\n-pub fn try_report_overflow_error_type_of_infinite_size<'a, 'tcx>(\n-    infcx: &InferCtxt<'a, 'tcx>,\n+pub fn try_report_overflow_error_type_of_infinite_size(&self,\n     cycle: &[PredicateObligation<'tcx>])\n {\n-    let sized_trait = match infcx.tcx.lang_items.sized_trait() {\n+    let sized_trait = match self.tcx.lang_items.sized_trait() {\n         Some(v) => v,\n         None => return,\n     };\n@@ -373,8 +364,8 @@ pub fn try_report_overflow_error_type_of_infinite_size<'a, 'tcx>(\n                        .chain(struct_enum_tys.iter().cloned().take(main_index))\n                        .collect();\n \n-    let tcx = infcx.tcx;\n-    let mut err = recursive_type_with_infinite_size_error(tcx, main_def_id);\n+    let tcx = self.tcx;\n+    let mut err = tcx.recursive_type_with_infinite_size_error(main_def_id);\n     let len = struct_enum_tys.len();\n     if len > 2 {\n         err.note(&format!(\"type `{}` is embedded within `{}`...\",\n@@ -388,48 +379,38 @@ pub fn try_report_overflow_error_type_of_infinite_size<'a, 'tcx>(\n                           struct_enum_tys[len-1]));\n     }\n     err.emit();\n-    infcx.tcx.sess.abort_if_errors();\n+    self.tcx.sess.abort_if_errors();\n     bug!();\n }\n \n-pub fn recursive_type_with_infinite_size_error<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                                     type_def_id: DefId)\n-                                                     -> DiagnosticBuilder<'tcx>\n+pub fn report_selection_error(&self,\n+                              obligation: &PredicateObligation<'tcx>,\n+                              error: &SelectionError<'tcx>,\n+                              warning_node_id: Option<ast::NodeId>)\n {\n-    assert!(type_def_id.is_local());\n-    let span = tcx.map.span_if_local(type_def_id).unwrap();\n-    let mut err = struct_span_err!(tcx.sess, span, E0072, \"recursive type `{}` has infinite size\",\n-                                   tcx.item_path_str(type_def_id));\n-    err.help(&format!(\"insert indirection (e.g., a `Box`, `Rc`, or `&`) \\\n-                       at some point to make `{}` representable\",\n-                      tcx.item_path_str(type_def_id)));\n-    err\n-}\n-\n-pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                        obligation: &PredicateObligation<'tcx>,\n-                                        error: &SelectionError<'tcx>,\n-                                        warning_node_id: Option<ast::NodeId>)\n-{\n-    match *error {\n+    let span = obligation.cause.span;\n+    let mut err = match *error {\n         SelectionError::Unimplemented => {\n             if let ObligationCauseCode::CompareImplMethodObligation = obligation.cause.code {\n                 span_err!(\n-                    infcx.tcx.sess, obligation.cause.span, E0276,\n+                    self.tcx.sess, span, E0276,\n                     \"the requirement `{}` appears on the impl \\\n                      method but not on the corresponding trait method\",\n                     obligation.predicate);\n+                return;\n             } else {\n                 match obligation.predicate {\n                     ty::Predicate::Trait(ref trait_predicate) => {\n                         let trait_predicate =\n-                            infcx.resolve_type_vars_if_possible(trait_predicate);\n+                            self.resolve_type_vars_if_possible(trait_predicate);\n \n-                        if !infcx.tcx.sess.has_errors() || !trait_predicate.references_error() {\n+                        if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n+                            return;\n+                        } else {\n                             let trait_ref = trait_predicate.to_poly_trait_ref();\n \n                             if let Some(warning_node_id) = warning_node_id {\n-                                infcx.tcx.sess.add_lint(\n+                                self.tcx.sess.add_lint(\n                                     ::lint::builtin::UNSIZED_IN_TUPLE,\n                                     warning_node_id,\n                                     obligation.cause.span,\n@@ -439,14 +420,14 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                             }\n \n                             let mut err = struct_span_err!(\n-                                infcx.tcx.sess, obligation.cause.span, E0277,\n+                                self.tcx.sess, span, E0277,\n                                 \"the trait bound `{}` is not satisfied\",\n                                 trait_ref.to_predicate());\n \n                             // Try to report a help message\n \n                             if !trait_ref.has_infer_types() &&\n-                                predicate_can_apply(infcx, trait_ref)\n+                                self.predicate_can_apply(trait_ref)\n                             {\n                                 // If a where-clause may be useful, remind the\n                                 // user that they can add it.\n@@ -458,81 +439,63 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                 err.help(&format!(\"consider adding a `where {}` bound\",\n                                     trait_ref.to_predicate()\n                                     ));\n-                            } else if let Some(s) = on_unimplemented_note(infcx, trait_ref,\n-                                                                          obligation.cause.span) {\n+                            } else if let Some(s) = self.on_unimplemented_note(trait_ref, span) {\n                                 // Otherwise, if there is an on-unimplemented note,\n                                 // display it.\n                                 err.note(&s);\n                             } else {\n                                 // If we can't show anything useful, try to find\n                                 // similar impls.\n \n-                                let impl_candidates =\n-                                    find_similar_impl_candidates(infcx, trait_ref);\n-                                if impl_candidates.len() > 0 {\n-                                    report_similar_impl_candidates(&mut err, &impl_candidates);\n-                                }\n+                                self.report_similar_impl_candidates(trait_ref, &mut err);\n                             }\n-                            note_obligation_cause(infcx, &mut err, obligation);\n-                            err.emit();\n+                            err\n                         }\n                     },\n                     ty::Predicate::Equate(ref predicate) => {\n-                        let predicate = infcx.resolve_type_vars_if_possible(predicate);\n-                        let err = infcx.equality_predicate(obligation.cause.span,\n-                                                           &predicate).err().unwrap();\n-                        let mut err = struct_span_err!(\n-                            infcx.tcx.sess, obligation.cause.span, E0278,\n+                        let predicate = self.resolve_type_vars_if_possible(predicate);\n+                        let err = self.equality_predicate(span,\n+                                                          &predicate).err().unwrap();\n+                        struct_span_err!(self.tcx.sess, span, E0278,\n                             \"the requirement `{}` is not satisfied (`{}`)\",\n-                            predicate,\n-                            err);\n-                        note_obligation_cause(infcx, &mut err, obligation);\n-                        err.emit();\n+                            predicate, err)\n                     }\n \n                     ty::Predicate::RegionOutlives(ref predicate) => {\n-                        let predicate = infcx.resolve_type_vars_if_possible(predicate);\n-                        let err = infcx.region_outlives_predicate(obligation.cause.span,\n-                                                                  &predicate).err().unwrap();\n-                        let mut err = struct_span_err!(\n-                            infcx.tcx.sess, obligation.cause.span, E0279,\n+                        let predicate = self.resolve_type_vars_if_possible(predicate);\n+                        let err = self.region_outlives_predicate(span,\n+                                                                 &predicate).err().unwrap();\n+                        struct_span_err!(self.tcx.sess, span, E0279,\n                             \"the requirement `{}` is not satisfied (`{}`)\",\n-                            predicate,\n-                            err);\n-                        note_obligation_cause(infcx, &mut err, obligation);\n-                        err.emit();\n+                            predicate, err)\n                     }\n \n                     ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n                         let predicate =\n-                            infcx.resolve_type_vars_if_possible(&obligation.predicate);\n-                        let mut err = struct_span_err!(\n-                            infcx.tcx.sess, obligation.cause.span, E0280,\n+                            self.resolve_type_vars_if_possible(&obligation.predicate);\n+                        struct_span_err!(self.tcx.sess, span, E0280,\n                             \"the requirement `{}` is not satisfied\",\n-                            predicate);\n-                        note_obligation_cause(infcx, &mut err, obligation);\n-                        err.emit();\n+                            predicate)\n                     }\n \n                     ty::Predicate::ObjectSafe(trait_def_id) => {\n-                        let violations = object_safety_violations(\n-                            infcx.tcx, trait_def_id);\n-                        let err = report_object_safety_error(infcx.tcx,\n-                                                             obligation.cause.span,\n-                                                             trait_def_id,\n-                                                             warning_node_id,\n-                                                             violations);\n-                        if let Some(mut err) = err {\n-                            note_obligation_cause(infcx, &mut err, obligation);\n-                            err.emit();\n+                        let violations = self.tcx.object_safety_violations(trait_def_id);\n+                        let err = self.tcx.report_object_safety_error(span,\n+                                                                      trait_def_id,\n+                                                                      warning_node_id,\n+                                                                      violations);\n+                        if let Some(err) = err {\n+                            err\n+                        } else {\n+                            return;\n                         }\n                     }\n \n                     ty::Predicate::ClosureKind(closure_def_id, kind) => {\n-                        let found_kind = infcx.closure_kind(closure_def_id).unwrap();\n-                        let closure_span = infcx.tcx.map.span_if_local(closure_def_id).unwrap();\n+                        let found_kind = self.closure_kind(closure_def_id).unwrap();\n+                        let closure_span = self.tcx.map.span_if_local(closure_def_id).unwrap();\n                         let mut err = struct_span_err!(\n-                            infcx.tcx.sess, closure_span, E0525,\n+                            self.tcx.sess, closure_span, E0525,\n                             \"expected a closure that implements the `{}` trait, but this closure \\\n                              only implements `{}`\",\n                             kind,\n@@ -541,6 +504,7 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                             obligation.cause.span,\n                             &format!(\"the requirement to implement `{}` derives from here\", kind));\n                         err.emit();\n+                        return;\n                     }\n \n                     ty::Predicate::WellFormed(ty) => {\n@@ -549,10 +513,7 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                         // ambiguity; otherwise, they always\n                         // degenerate into other obligations\n                         // (which may fail).\n-                        span_bug!(\n-                            obligation.cause.span,\n-                            \"WF predicate not satisfied for {:?}\",\n-                            ty);\n+                        span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n                     }\n \n                     ty::Predicate::Rfc1592(ref data) => {\n@@ -566,49 +527,66 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n         }\n \n         OutputTypeParameterMismatch(ref expected_trait_ref, ref actual_trait_ref, ref e) => {\n-            let expected_trait_ref = infcx.resolve_type_vars_if_possible(&*expected_trait_ref);\n-            let actual_trait_ref = infcx.resolve_type_vars_if_possible(&*actual_trait_ref);\n-            if !actual_trait_ref.self_ty().references_error() {\n-                let mut err = struct_span_err!(\n-                    infcx.tcx.sess, obligation.cause.span, E0281,\n-                    \"type mismatch: the type `{}` implements the trait `{}`, \\\n-                     but the trait `{}` is required ({})\",\n-                    expected_trait_ref.self_ty(),\n-                    expected_trait_ref,\n-                    actual_trait_ref,\n-                    e);\n-                note_obligation_cause(infcx, &mut err, obligation);\n-                err.emit();\n+            let expected_trait_ref = self.resolve_type_vars_if_possible(&*expected_trait_ref);\n+            let actual_trait_ref = self.resolve_type_vars_if_possible(&*actual_trait_ref);\n+            if actual_trait_ref.self_ty().references_error() {\n+                return;\n             }\n+            struct_span_err!(self.tcx.sess, span, E0281,\n+                \"type mismatch: the type `{}` implements the trait `{}`, \\\n+                 but the trait `{}` is required ({})\",\n+                expected_trait_ref.self_ty(),\n+                expected_trait_ref,\n+                actual_trait_ref,\n+                e)\n         }\n \n         TraitNotObjectSafe(did) => {\n-            let violations = object_safety_violations(infcx.tcx, did);\n-            let err = report_object_safety_error(infcx.tcx, obligation.cause.span, did,\n-                                                 warning_node_id,\n-                                                 violations);\n-            if let Some(mut err) = err {\n-                note_obligation_cause(infcx, &mut err, obligation);\n-                err.emit();\n+            let violations = self.tcx.object_safety_violations(did);\n+            let err = self.tcx.report_object_safety_error(span, did,\n+                                                          warning_node_id,\n+                                                          violations);\n+            if let Some(err) = err {\n+                err\n+            } else {\n+                return;\n             }\n         }\n-    }\n+    };\n+    self.note_obligation_cause(&mut err, obligation);\n+    err.emit();\n+}\n+}\n+\n+impl<'tcx> TyCtxt<'tcx> {\n+pub fn recursive_type_with_infinite_size_error(&self,\n+                                               type_def_id: DefId)\n+                                               -> DiagnosticBuilder<'tcx>\n+{\n+    assert!(type_def_id.is_local());\n+    let span = self.map.span_if_local(type_def_id).unwrap();\n+    let mut err = struct_span_err!(self.sess, span, E0072, \"recursive type `{}` has infinite size\",\n+                                   self.item_path_str(type_def_id));\n+    err.help(&format!(\"insert indirection (e.g., a `Box`, `Rc`, or `&`) \\\n+                       at some point to make `{}` representable\",\n+                      self.item_path_str(type_def_id)));\n+    err\n }\n \n-pub fn report_object_safety_error<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                        span: Span,\n-                                        trait_def_id: DefId,\n-                                        warning_node_id: Option<ast::NodeId>,\n-                                        violations: Vec<ObjectSafetyViolation>)\n-                                        -> Option<DiagnosticBuilder<'tcx>>\n+pub fn report_object_safety_error(&self,\n+                                  span: Span,\n+                                  trait_def_id: DefId,\n+                                  warning_node_id: Option<ast::NodeId>,\n+                                  violations: Vec<ObjectSafetyViolation>)\n+                                  -> Option<DiagnosticBuilder<'tcx>>\n {\n     let mut err = match warning_node_id {\n         Some(_) => None,\n         None => {\n             Some(struct_span_err!(\n-                tcx.sess, span, E0038,\n+                self.sess, span, E0038,\n                 \"the trait `{}` cannot be made into an object\",\n-                tcx.item_path_str(trait_def_id)))\n+                self.item_path_str(trait_def_id)))\n         }\n     };\n \n@@ -652,7 +630,7 @@ pub fn report_object_safety_error<'tcx>(tcx: &TyCtxt<'tcx>,\n         };\n         match (warning_node_id, &mut err) {\n             (Some(node_id), &mut None) => {\n-                tcx.sess.add_lint(\n+                self.sess.add_lint(\n                     ::lint::builtin::OBJECT_UNSAFE_FRAGMENT,\n                     node_id,\n                     span,\n@@ -666,23 +644,24 @@ pub fn report_object_safety_error<'tcx>(tcx: &TyCtxt<'tcx>,\n     }\n     err\n }\n+}\n \n-pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                        obligation: &PredicateObligation<'tcx>) {\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+fn maybe_report_ambiguity(&self, obligation: &PredicateObligation<'tcx>) {\n     // Unable to successfully determine, probably means\n     // insufficient type information, but could mean\n     // ambiguous impls. The latter *ought* to be a\n     // coherence violation, so we don't report it here.\n \n-    let predicate = infcx.resolve_type_vars_if_possible(&obligation.predicate);\n+    let predicate = self.resolve_type_vars_if_possible(&obligation.predicate);\n \n     debug!(\"maybe_report_ambiguity(predicate={:?}, obligation={:?})\",\n            predicate,\n            obligation);\n \n     // Ambiguity errors are often caused as fallout from earlier\n     // errors. So just ignore them if this infcx is tainted.\n-    if infcx.is_tainted_by_errors() {\n+    if self.is_tainted_by_errors() {\n         return;\n     }\n \n@@ -717,18 +696,18 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                 // inhabited. But in any case I just threw in this check for\n                 // has_errors() to be sure that compilation isn't happening\n                 // anyway. In that case, why inundate the user.\n-                if !infcx.tcx.sess.has_errors() {\n+                if !self.tcx.sess.has_errors() {\n                     if\n-                        infcx.tcx.lang_items.sized_trait()\n+                        self.tcx.lang_items.sized_trait()\n                         .map_or(false, |sized_id| sized_id == trait_ref.def_id())\n                     {\n-                        need_type_info(infcx, obligation.cause.span, self_ty);\n+                        self.need_type_info(obligation.cause.span, self_ty);\n                     } else {\n-                        let mut err = struct_span_err!(infcx.tcx.sess, obligation.cause.span, E0283,\n+                        let mut err = struct_span_err!(self.tcx.sess, obligation.cause.span, E0283,\n                                                        \"type annotations required: \\\n                                                         cannot resolve `{}`\",\n                                                        predicate);\n-                        note_obligation_cause(infcx, &mut err, obligation);\n+                        self.note_obligation_cause(&mut err, obligation);\n                         err.emit();\n                     }\n                 }\n@@ -738,17 +717,17 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n         ty::Predicate::WellFormed(ty) => {\n             // Same hacky approach as above to avoid deluging user\n             // with error messages.\n-            if !ty.references_error() && !infcx.tcx.sess.has_errors() {\n-                need_type_info(infcx, obligation.cause.span, ty);\n+            if !ty.references_error() && !self.tcx.sess.has_errors() {\n+                self.need_type_info(obligation.cause.span, ty);\n             }\n         }\n \n         _ => {\n-            if !infcx.tcx.sess.has_errors() {\n-                let mut err = struct_span_err!(infcx.tcx.sess, obligation.cause.span, E0284,\n+            if !self.tcx.sess.has_errors() {\n+                let mut err = struct_span_err!(self.tcx.sess, obligation.cause.span, E0284,\n                                                \"type annotations required: cannot resolve `{}`\",\n                                                predicate);\n-                note_obligation_cause(infcx, &mut err, obligation);\n+                self.note_obligation_cause(&mut err, obligation);\n                 err.emit();\n             }\n         }\n@@ -757,10 +736,7 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n \n /// Returns whether the trait predicate may apply for *some* assignment\n /// to the type parameters.\n-fn predicate_can_apply<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                 pred: ty::PolyTraitRef<'tcx>)\n-                                 -> bool\n-{\n+fn predicate_can_apply(&self, pred: ty::PolyTraitRef<'tcx>) -> bool {\n     struct ParamToVarFolder<'a, 'tcx: 'a> {\n         infcx: &'a InferCtxt<'a, 'tcx>,\n         var_map: FnvHashMap<Ty<'tcx>, Ty<'tcx>>\n@@ -780,11 +756,11 @@ fn predicate_can_apply<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n         }\n     }\n \n-    infcx.probe(|_| {\n-        let mut selcx = SelectionContext::new(infcx);\n+    self.probe(|_| {\n+        let mut selcx = SelectionContext::new(self);\n \n         let cleaned_pred = pred.fold_with(&mut ParamToVarFolder {\n-            infcx: infcx,\n+            infcx: self,\n             var_map: FnvHashMap()\n         });\n \n@@ -804,34 +780,30 @@ fn predicate_can_apply<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n }\n \n \n-fn need_type_info<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                            span: Span,\n-                            ty: Ty<'tcx>)\n-{\n-    span_err!(infcx.tcx.sess, span, E0282,\n+fn need_type_info(&self, span: Span, ty: Ty<'tcx>) {\n+    span_err!(self.tcx.sess, span, E0282,\n               \"unable to infer enough type information about `{}`; \\\n                type annotations or generic parameter binding required\",\n               ty);\n }\n \n-fn note_obligation_cause<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n-                                      err: &mut DiagnosticBuilder,\n-                                      obligation: &Obligation<'tcx, T>)\n+fn note_obligation_cause<T>(&self,\n+                            err: &mut DiagnosticBuilder,\n+                            obligation: &Obligation<'tcx, T>)\n     where T: fmt::Display\n {\n-    note_obligation_cause_code(infcx,\n-                               err,\n-                               &obligation.predicate,\n-                               &obligation.cause.code);\n+    self.note_obligation_cause_code(err,\n+                                    &obligation.predicate,\n+                                    &obligation.cause.code);\n }\n \n-fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n-                                           err: &mut DiagnosticBuilder,\n-                                           predicate: &T,\n-                                           cause_code: &ObligationCauseCode<'tcx>)\n+fn note_obligation_cause_code<T>(&self,\n+                                 err: &mut DiagnosticBuilder,\n+                                 predicate: &T,\n+                                 cause_code: &ObligationCauseCode<'tcx>)\n     where T: fmt::Display\n {\n-    let tcx = infcx.tcx;\n+    let tcx = self.tcx;\n     match *cause_code {\n         ObligationCauseCode::MiscObligation => { }\n         ObligationCauseCode::SliceOrArrayElem => {\n@@ -854,7 +826,7 @@ fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n         }\n         ObligationCauseCode::ObjectCastObligation(object_ty) => {\n             err.note(&format!(\"required for the cast to the object type `{}`\",\n-                              infcx.ty_to_string(object_ty)));\n+                              self.ty_to_string(object_ty)));\n         }\n         ObligationCauseCode::RepeatVec => {\n             err.note(\"the `Copy` trait is required because the \\\n@@ -891,26 +863,24 @@ fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n             err.note(\"shared static variables must have a type that implements `Sync`\");\n         }\n         ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n-            let parent_trait_ref = infcx.resolve_type_vars_if_possible(&data.parent_trait_ref);\n+            let parent_trait_ref = self.resolve_type_vars_if_possible(&data.parent_trait_ref);\n             err.note(&format!(\"required because it appears within the type `{}`\",\n                               parent_trait_ref.0.self_ty()));\n             let parent_predicate = parent_trait_ref.to_predicate();\n-            note_obligation_cause_code(infcx,\n-                                       err,\n-                                       &parent_predicate,\n-                                       &data.parent_code);\n+            self.note_obligation_cause_code(err,\n+                                            &parent_predicate,\n+                                            &data.parent_code);\n         }\n         ObligationCauseCode::ImplDerivedObligation(ref data) => {\n-            let parent_trait_ref = infcx.resolve_type_vars_if_possible(&data.parent_trait_ref);\n+            let parent_trait_ref = self.resolve_type_vars_if_possible(&data.parent_trait_ref);\n             err.note(\n                 &format!(\"required because of the requirements on the impl of `{}` for `{}`\",\n                          parent_trait_ref,\n                          parent_trait_ref.0.self_ty()));\n             let parent_predicate = parent_trait_ref.to_predicate();\n-            note_obligation_cause_code(infcx,\n-                                       err,\n-                                       &parent_predicate,\n-                                       &data.parent_code);\n+            self.note_obligation_cause_code(err,\n+                                            &parent_predicate,\n+                                            &data.parent_code);\n         }\n         ObligationCauseCode::CompareImplMethodObligation => {\n             err.note(\n@@ -921,10 +891,11 @@ fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n     }\n }\n \n-fn suggest_new_overflow_limit(tcx: &TyCtxt, err:&mut DiagnosticBuilder) {\n-    let current_limit = tcx.sess.recursion_limit.get();\n+fn suggest_new_overflow_limit(&self, err: &mut DiagnosticBuilder) {\n+    let current_limit = self.tcx.sess.recursion_limit.get();\n     let suggested_limit = current_limit * 2;\n     err.note(&format!(\n                       \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n                       suggested_limit));\n }\n+}"}, {"sha": "efee80c6566402032ce614fcc31a829958dbecd7", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -21,16 +21,13 @@ use util::nodemap::{FnvHashMap, FnvHashSet, NodeMap};\n use super::CodeAmbiguity;\n use super::CodeProjectionError;\n use super::CodeSelectionError;\n-use super::is_object_safe;\n use super::FulfillmentError;\n use super::FulfillmentErrorCode;\n use super::ObligationCause;\n use super::PredicateObligation;\n use super::project;\n-use super::report_overflow_error_cycle;\n use super::select::SelectionContext;\n use super::Unimplemented;\n-use super::util::predicate_for_builtin_bound;\n \n pub struct GlobalFulfilledPredicates<'tcx> {\n     set: FnvHashSet<ty::PolyTraitPredicate<'tcx>>,\n@@ -163,7 +160,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n                                       builtin_bound: ty::BuiltinBound,\n                                       cause: ObligationCause<'tcx>)\n     {\n-        match predicate_for_builtin_bound(infcx.tcx, cause, builtin_bound, 0, ty) {\n+        match infcx.tcx.predicate_for_builtin_bound(cause, builtin_bound, 0, ty) {\n             Ok(predicate) => {\n                 self.register_predicate_obligation(infcx, predicate);\n             }\n@@ -449,7 +446,7 @@ fn process_child_obligations<'a,'tcx>(\n                     debug!(\"process_child_obligations: coinductive match\");\n                     None\n                 } else {\n-                    report_overflow_error_cycle(selcx.infcx(), &cycle);\n+                    selcx.infcx().report_overflow_error_cycle(&cycle);\n                 }\n             } else {\n                 // Not a cycle. Just ignore this obligation then,\n@@ -677,7 +674,7 @@ fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n         }\n \n         ty::Predicate::ObjectSafe(trait_def_id) => {\n-            if !is_object_safe(selcx.tcx(), trait_def_id) {\n+            if !selcx.tcx().is_object_safe(trait_def_id) {\n                 Err(CodeSelectionError(Unimplemented))\n             } else {\n                 Ok(Some(Vec::new()))"}, {"sha": "49851f720cc3fa546f76478aaf7e86502f2137ec", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -19,46 +19,31 @@ use hir::def_id::DefId;\n use middle::free_region::FreeRegionMap;\n use ty::subst;\n use ty::{self, Ty, TypeFoldable};\n-use infer::{fixup_err_to_string, InferCtxt};\n+use infer::InferCtxt;\n \n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n \n pub use self::error_reporting::TraitErrorKey;\n-pub use self::error_reporting::recursive_type_with_infinite_size_error;\n-pub use self::error_reporting::report_fulfillment_errors;\n-pub use self::error_reporting::report_fulfillment_errors_as_warnings;\n-pub use self::error_reporting::report_overflow_error;\n-pub use self::error_reporting::report_overflow_error_cycle;\n-pub use self::error_reporting::report_selection_error;\n-pub use self::error_reporting::report_object_safety_error;\n pub use self::coherence::orphan_check;\n pub use self::coherence::overlapping_impls;\n pub use self::coherence::OrphanCheckErr;\n pub use self::fulfill::{FulfillmentContext, GlobalFulfilledPredicates, RegionObligation};\n pub use self::project::{MismatchedProjectionTypes, ProjectionMode};\n pub use self::project::{normalize, Normalized};\n-pub use self::object_safety::is_object_safe;\n-pub use self::object_safety::astconv_object_safety_violations;\n-pub use self::object_safety::object_safety_violations;\n pub use self::object_safety::ObjectSafetyViolation;\n pub use self::object_safety::MethodViolationCode;\n-pub use self::object_safety::is_vtable_safe_method;\n pub use self::select::{EvaluationCache, SelectionContext, SelectionCache};\n pub use self::select::{MethodMatchResult, MethodMatched, MethodAmbiguous, MethodDidNotMatch};\n pub use self::select::{MethodMatchedData}; // intentionally don't export variants\n pub use self::specialize::{Overlap, specialization_graph, specializes, translate_substs};\n pub use self::util::elaborate_predicates;\n-pub use self::util::get_vtable_index_of_object_method;\n-pub use self::util::trait_ref_for_builtin_bound;\n-pub use self::util::predicate_for_trait_def;\n pub use self::util::supertraits;\n pub use self::util::Supertraits;\n pub use self::util::supertrait_def_ids;\n pub use self::util::SupertraitDefIds;\n pub use self::util::transitive_bounds;\n-pub use self::util::upcast;\n \n mod coherence;\n mod error_reporting;\n@@ -343,7 +328,7 @@ pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n \n     let cause = ObligationCause::misc(span, ast::DUMMY_NODE_ID);\n     let obligation =\n-        util::predicate_for_builtin_bound(infcx.tcx, cause, bound, 0, ty);\n+        infcx.tcx.predicate_for_builtin_bound(cause, bound, 0, ty);\n     let obligation = match obligation {\n         Ok(o) => o,\n         Err(..) => return false\n@@ -444,7 +429,7 @@ pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvi\n                                            &infcx.parameter_environment.caller_bounds) {\n         Ok(predicates) => predicates,\n         Err(errors) => {\n-            report_fulfillment_errors(&infcx, &errors);\n+            infcx.report_fulfillment_errors(&errors);\n             return infcx.parameter_environment; // an unnormalized env is better than nothing\n         }\n     };\n@@ -464,8 +449,7 @@ pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvi\n             // represents a legitimate failure due to some kind of\n             // unconstrained variable, and it seems better not to ICE,\n             // all things considered.\n-            let err_msg = fixup_err_to_string(fixup_err);\n-            tcx.sess.span_err(span, &err_msg);\n+            tcx.sess.span_err(span, &fixup_err.to_string());\n             return infcx.parameter_environment; // an unnormalized env is better than nothing\n         }\n     };"}, {"sha": "ea129d437fb39dee5774e23494a7e7bf4d4a3ab6", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 59, "deletions": 69, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -53,15 +53,13 @@ pub enum MethodViolationCode {\n     Generic,\n }\n \n-pub fn is_object_safe<'tcx>(tcx: &TyCtxt<'tcx>,\n-                            trait_def_id: DefId)\n-                            -> bool\n-{\n+impl<'tcx> TyCtxt<'tcx> {\n+pub fn is_object_safe(&self, trait_def_id: DefId) -> bool {\n     // Because we query yes/no results frequently, we keep a cache:\n-    let def = tcx.lookup_trait_def(trait_def_id);\n+    let def = self.lookup_trait_def(trait_def_id);\n \n     let result = def.object_safety().unwrap_or_else(|| {\n-        let result = object_safety_violations(tcx, trait_def_id).is_empty();\n+        let result = self.object_safety_violations(trait_def_id).is_empty();\n \n         // Record just a yes/no result in the cache; this is what is\n         // queried most frequently. Note that this may overwrite a\n@@ -80,43 +78,40 @@ pub fn is_object_safe<'tcx>(tcx: &TyCtxt<'tcx>,\n /// astconv - currently, Self in supertraits. This is needed\n /// because `object_safety_violations` can't be used during\n /// type collection.\n-pub fn astconv_object_safety_violations<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                              trait_def_id: DefId)\n-                                              -> Vec<ObjectSafetyViolation<'tcx>>\n+pub fn astconv_object_safety_violations(&self, trait_def_id: DefId)\n+                                        -> Vec<ObjectSafetyViolation<'tcx>>\n {\n     let mut violations = vec![];\n \n-    if supertraits_reference_self(tcx, trait_def_id) {\n+    if self.supertraits_reference_self(trait_def_id) {\n         violations.push(ObjectSafetyViolation::SupertraitSelf);\n     }\n \n-    debug!(\"object_safety_violations_for_trait(trait_def_id={:?}) = {:?}\",\n+    debug!(\"astconv_object_safety_violations(trait_def_id={:?}) = {:?}\",\n            trait_def_id,\n            violations);\n \n     violations\n }\n \n-pub fn object_safety_violations<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                      trait_def_id: DefId)\n-                                      -> Vec<ObjectSafetyViolation<'tcx>>\n+pub fn object_safety_violations(&self, trait_def_id: DefId)\n+                                -> Vec<ObjectSafetyViolation<'tcx>>\n {\n-    traits::supertrait_def_ids(tcx, trait_def_id)\n-        .flat_map(|def_id| object_safety_violations_for_trait(tcx, def_id))\n+    traits::supertrait_def_ids(self, trait_def_id)\n+        .flat_map(|def_id| self.object_safety_violations_for_trait(def_id))\n         .collect()\n }\n \n-fn object_safety_violations_for_trait<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                            trait_def_id: DefId)\n-                                            -> Vec<ObjectSafetyViolation<'tcx>>\n+fn object_safety_violations_for_trait(&self, trait_def_id: DefId)\n+                                      -> Vec<ObjectSafetyViolation<'tcx>>\n {\n     // Check methods for violations.\n     let mut violations: Vec<_> =\n-        tcx.trait_items(trait_def_id).iter()\n+        self.trait_items(trait_def_id).iter()\n         .filter_map(|item| {\n             match *item {\n                 ty::MethodTraitItem(ref m) => {\n-                    object_safety_violation_for_method(tcx, trait_def_id, &m)\n+                    self.object_safety_violation_for_method(trait_def_id, &m)\n                         .map(|code| ObjectSafetyViolation::Method(m.clone(), code))\n                 }\n                 _ => None,\n@@ -125,10 +120,10 @@ fn object_safety_violations_for_trait<'tcx>(tcx: &TyCtxt<'tcx>,\n         .collect();\n \n     // Check the trait itself.\n-    if trait_has_sized_self(tcx, trait_def_id) {\n+    if self.trait_has_sized_self(trait_def_id) {\n         violations.push(ObjectSafetyViolation::SizedSelf);\n     }\n-    if supertraits_reference_self(tcx, trait_def_id) {\n+    if self.supertraits_reference_self(trait_def_id) {\n         violations.push(ObjectSafetyViolation::SupertraitSelf);\n     }\n \n@@ -139,18 +134,15 @@ fn object_safety_violations_for_trait<'tcx>(tcx: &TyCtxt<'tcx>,\n     violations\n }\n \n-pub fn supertraits_reference_self<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                        trait_def_id: DefId)\n-                                        -> bool\n-{\n-    let trait_def = tcx.lookup_trait_def(trait_def_id);\n+fn supertraits_reference_self(&self, trait_def_id: DefId) -> bool {\n+    let trait_def = self.lookup_trait_def(trait_def_id);\n     let trait_ref = trait_def.trait_ref.clone();\n     let trait_ref = trait_ref.to_poly_trait_ref();\n-    let predicates = tcx.lookup_super_predicates(trait_def_id);\n+    let predicates = self.lookup_super_predicates(trait_def_id);\n     predicates\n         .predicates\n         .into_iter()\n-        .map(|predicate| predicate.subst_supertrait(tcx, &trait_ref))\n+        .map(|predicate| predicate.subst_supertrait(self, &trait_ref))\n         .any(|predicate| {\n             match predicate {\n                 ty::Predicate::Trait(ref data) => {\n@@ -174,30 +166,27 @@ pub fn supertraits_reference_self<'tcx>(tcx: &TyCtxt<'tcx>,\n         })\n }\n \n-fn trait_has_sized_self<'tcx>(tcx: &TyCtxt<'tcx>,\n-                              trait_def_id: DefId)\n-                              -> bool\n-{\n-    let trait_def = tcx.lookup_trait_def(trait_def_id);\n-    let trait_predicates = tcx.lookup_predicates(trait_def_id);\n-    generics_require_sized_self(tcx, &trait_def.generics, &trait_predicates)\n+fn trait_has_sized_self(&self, trait_def_id: DefId) -> bool {\n+    let trait_def = self.lookup_trait_def(trait_def_id);\n+    let trait_predicates = self.lookup_predicates(trait_def_id);\n+    self.generics_require_sized_self(&trait_def.generics, &trait_predicates)\n }\n \n-fn generics_require_sized_self<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                     generics: &ty::Generics<'tcx>,\n-                                     predicates: &ty::GenericPredicates<'tcx>)\n-                                     -> bool\n+fn generics_require_sized_self(&self,\n+                               generics: &ty::Generics<'tcx>,\n+                               predicates: &ty::GenericPredicates<'tcx>)\n+                               -> bool\n {\n-    let sized_def_id = match tcx.lang_items.sized_trait() {\n+    let sized_def_id = match self.lang_items.sized_trait() {\n         Some(def_id) => def_id,\n         None => { return false; /* No Sized trait, can't require it! */ }\n     };\n \n     // Search for a predicate like `Self : Sized` amongst the trait bounds.\n-    let free_substs = tcx.construct_free_substs(generics,\n-                                                tcx.region_maps.node_extent(ast::DUMMY_NODE_ID));\n-    let predicates = predicates.instantiate(tcx, &free_substs).predicates.into_vec();\n-    elaborate_predicates(tcx, predicates)\n+    let free_substs = self.construct_free_substs(generics,\n+        self.region_maps.node_extent(ast::DUMMY_NODE_ID));\n+    let predicates = predicates.instantiate(self, &free_substs).predicates.into_vec();\n+    elaborate_predicates(self, predicates)\n         .any(|predicate| {\n             match predicate {\n                 ty::Predicate::Trait(ref trait_pred) if trait_pred.def_id() == sized_def_id => {\n@@ -219,40 +208,40 @@ fn generics_require_sized_self<'tcx>(tcx: &TyCtxt<'tcx>,\n }\n \n /// Returns `Some(_)` if this method makes the containing trait not object safe.\n-fn object_safety_violation_for_method<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                            trait_def_id: DefId,\n-                                            method: &ty::Method<'tcx>)\n-                                            -> Option<MethodViolationCode>\n+fn object_safety_violation_for_method(&self,\n+                                      trait_def_id: DefId,\n+                                      method: &ty::Method<'tcx>)\n+                                      -> Option<MethodViolationCode>\n {\n     // Any method that has a `Self : Sized` requisite is otherwise\n     // exempt from the regulations.\n-    if generics_require_sized_self(tcx, &method.generics, &method.predicates) {\n+    if self.generics_require_sized_self(&method.generics, &method.predicates) {\n         return None;\n     }\n \n-    virtual_call_violation_for_method(tcx, trait_def_id, method)\n+    self.virtual_call_violation_for_method(trait_def_id, method)\n }\n \n /// We say a method is *vtable safe* if it can be invoked on a trait\n /// object.  Note that object-safe traits can have some\n /// non-vtable-safe methods, so long as they require `Self:Sized` or\n /// otherwise ensure that they cannot be used when `Self=Trait`.\n-pub fn is_vtable_safe_method<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                   trait_def_id: DefId,\n-                                   method: &ty::Method<'tcx>)\n-                                   -> bool\n+pub fn is_vtable_safe_method(&self,\n+                             trait_def_id: DefId,\n+                             method: &ty::Method<'tcx>)\n+                             -> bool\n {\n-    virtual_call_violation_for_method(tcx, trait_def_id, method).is_none()\n+    self.virtual_call_violation_for_method(trait_def_id, method).is_none()\n }\n \n /// Returns `Some(_)` if this method cannot be called on a trait\n /// object; this does not necessarily imply that the enclosing trait\n /// is not object safe, because the method might have a where clause\n /// `Self:Sized`.\n-fn virtual_call_violation_for_method<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                           trait_def_id: DefId,\n-                                           method: &ty::Method<'tcx>)\n-                                           -> Option<MethodViolationCode>\n+fn virtual_call_violation_for_method(&self,\n+                                     trait_def_id: DefId,\n+                                     method: &ty::Method<'tcx>)\n+                                     -> Option<MethodViolationCode>\n {\n     // The method's first parameter must be something that derefs (or\n     // autorefs) to `&self`. For now, we only accept `self`, `&self`\n@@ -272,12 +261,12 @@ fn virtual_call_violation_for_method<'tcx>(tcx: &TyCtxt<'tcx>,\n     // arguments or return type apart from the receiver.\n     let ref sig = method.fty.sig;\n     for &input_ty in &sig.0.inputs[1..] {\n-        if contains_illegal_self_type_reference(tcx, trait_def_id, input_ty) {\n+        if self.contains_illegal_self_type_reference(trait_def_id, input_ty) {\n             return Some(MethodViolationCode::ReferencesSelf);\n         }\n     }\n     if let ty::FnConverging(result_type) = sig.0.output {\n-        if contains_illegal_self_type_reference(tcx, trait_def_id, result_type) {\n+        if self.contains_illegal_self_type_reference(trait_def_id, result_type) {\n             return Some(MethodViolationCode::ReferencesSelf);\n         }\n     }\n@@ -290,10 +279,10 @@ fn virtual_call_violation_for_method<'tcx>(tcx: &TyCtxt<'tcx>,\n     None\n }\n \n-fn contains_illegal_self_type_reference<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                              trait_def_id: DefId,\n-                                              ty: Ty<'tcx>)\n-                                              -> bool\n+fn contains_illegal_self_type_reference(&self,\n+                                        trait_def_id: DefId,\n+                                        ty: Ty<'tcx>)\n+                                        -> bool\n {\n     // This is somewhat subtle. In general, we want to forbid\n     // references to `Self` in the argument and return types,\n@@ -351,9 +340,9 @@ fn contains_illegal_self_type_reference<'tcx>(tcx: &TyCtxt<'tcx>,\n \n                 // Compute supertraits of current trait lazily.\n                 if supertraits.is_none() {\n-                    let trait_def = tcx.lookup_trait_def(trait_def_id);\n+                    let trait_def = self.lookup_trait_def(trait_def_id);\n                     let trait_ref = ty::Binder(trait_def.trait_ref.clone());\n-                    supertraits = Some(traits::supertraits(tcx, trait_ref).collect());\n+                    supertraits = Some(traits::supertraits(self, trait_ref).collect());\n                 }\n \n                 // Determine whether the trait reference `Foo as\n@@ -381,3 +370,4 @@ fn contains_illegal_self_type_reference<'tcx>(tcx: &TyCtxt<'tcx>,\n \n     error\n }\n+}"}, {"sha": "bc26ee615f7c1d62ffa9e0c6701e83b3a52fa366", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -11,7 +11,6 @@\n //! Code for projecting associated types out of trait references.\n \n use super::elaborate_predicates;\n-use super::report_overflow_error;\n use super::specialization_graph;\n use super::translate_substs;\n use super::Obligation;\n@@ -188,7 +187,7 @@ pub fn poly_project_and_unify_type<'cx,'tcx>(\n         let skol_obligation = obligation.with(skol_predicate);\n         match project_and_unify_type(selcx, &skol_obligation) {\n             Ok(result) => {\n-                match infcx.leak_check(&skol_map, snapshot) {\n+                match infcx.leak_check(false, &skol_map, snapshot) {\n                     Ok(()) => Ok(infcx.plug_leaks(skol_map, snapshot, &result)),\n                     Err(e) => Err(MismatchedProjectionTypes { err: e }),\n                 }\n@@ -231,7 +230,7 @@ fn project_and_unify_type<'cx,'tcx>(\n \n     let infcx = selcx.infcx();\n     let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n-    match infer::mk_eqty(infcx, true, origin, normalized_ty, obligation.predicate.ty) {\n+    match infcx.eq_types(true, origin, normalized_ty, obligation.predicate.ty) {\n         Ok(InferOk { obligations: inferred_obligations, .. }) => {\n             // FIXME(#32730) propagate obligations\n             assert!(inferred_obligations.is_empty());\n@@ -262,11 +261,10 @@ fn consider_unification_despite_ambiguity<'cx,'tcx>(selcx: &mut SelectionContext\n             let closure_typer = selcx.closure_typer();\n             let closure_type = closure_typer.closure_type(closure_def_id, substs);\n             let ty::Binder((_, ret_type)) =\n-                util::closure_trait_ref_and_return_type(infcx.tcx,\n-                                                        def_id,\n-                                                        self_ty,\n-                                                        &closure_type.sig,\n-                                                        util::TupleArgumentsFlag::No);\n+                infcx.tcx.closure_trait_ref_and_return_type(def_id,\n+                                                            self_ty,\n+                                                            &closure_type.sig,\n+                                                            util::TupleArgumentsFlag::No);\n             // We don't have to normalize the return type here - this is only\n             // reached for TyClosure: Fn inputs where the closure kind is\n             // still unknown, which should only occur in typeck where the\n@@ -281,7 +279,7 @@ fn consider_unification_despite_ambiguity<'cx,'tcx>(selcx: &mut SelectionContext\n                    ret_type);\n             let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n             let obligation_ty = obligation.predicate.ty;\n-            match infer::mk_eqty(infcx, true, origin, obligation_ty, ret_type) {\n+            match infcx.eq_types(true, origin, obligation_ty, ret_type) {\n                 Ok(InferOk { obligations, .. }) => {\n                     // FIXME(#32730) propagate obligations\n                     assert!(obligations.is_empty());\n@@ -578,7 +576,7 @@ fn project_type<'cx,'tcx>(\n     let recursion_limit = selcx.tcx().sess.recursion_limit.get();\n     if obligation.recursion_depth >= recursion_limit {\n         debug!(\"project: overflow!\");\n-        report_overflow_error(selcx.infcx(), &obligation, true);\n+        selcx.infcx().report_overflow_error(&obligation, true);\n     }\n \n     let obligation_trait_ref =\n@@ -1053,11 +1051,10 @@ fn confirm_callable_candidate<'cx,'tcx>(\n \n     // Note: we unwrap the binder here but re-create it below (1)\n     let ty::Binder((trait_ref, ret_type)) =\n-        util::closure_trait_ref_and_return_type(tcx,\n-                                                fn_once_def_id,\n-                                                obligation.predicate.trait_ref.self_ty(),\n-                                                fn_sig,\n-                                                flag);\n+        tcx.closure_trait_ref_and_return_type(fn_once_def_id,\n+                                              obligation.predicate.trait_ref.self_ty(),\n+                                              fn_sig,\n+                                              flag);\n \n     let predicate = ty::Binder(ty::ProjectionPredicate { // (1) recreate binder here\n         projection_ty: ty::ProjectionTy {"}, {"sha": "c47f728eec52bda12b3007707b86863a5c423258", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -20,7 +20,6 @@ use super::DerivedObligationCause;\n use super::project;\n use super::project::{normalize_with_depth, Normalized};\n use super::{PredicateObligation, TraitObligation, ObligationCause};\n-use super::report_overflow_error;\n use super::{ObligationCauseCode, BuiltinDerivedObligation, ImplDerivedObligation};\n use super::{SelectionError, Unimplemented, OutputTypeParameterMismatch};\n use super::{ObjectCastObligation, Obligation};\n@@ -32,7 +31,6 @@ use super::{VtableBuiltin, VtableImpl, VtableParam, VtableClosure,\n             VtableFnPointer, VtableObject, VtableDefaultImpl};\n use super::{VtableImplData, VtableObjectData, VtableBuiltinData,\n             VtableClosureData, VtableDefaultImplData};\n-use super::object_safety;\n use super::util;\n \n use hir::def_id::DefId;\n@@ -455,7 +453,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             ty::Predicate::ObjectSafe(trait_def_id) => {\n-                if object_safety::is_object_safe(self.tcx(), trait_def_id) {\n+                if self.tcx().is_object_safe(trait_def_id) {\n                     EvaluatedToOk\n                 } else {\n                     EvaluatedToErr\n@@ -683,7 +681,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // not update) the cache.\n         let recursion_limit = self.infcx.tcx.sess.recursion_limit.get();\n         if stack.obligation.recursion_depth >= recursion_limit {\n-            report_overflow_error(self.infcx(), &stack.obligation, true);\n+            self.infcx().report_overflow_error(&stack.obligation, true);\n         }\n \n         // Check the cache. Note that we skolemize the trait-ref\n@@ -1155,7 +1153,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             Err(_) => { return false; }\n         }\n \n-        self.infcx.leak_check(skol_map, snapshot).is_ok()\n+        self.infcx.leak_check(false, skol_map, snapshot).is_ok()\n     }\n \n     /// Given an obligation like `<SomeTrait for T>`, search the obligations that the caller\n@@ -1397,7 +1395,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // these cases wind up being considered ambiguous due to a\n         // (spurious) ambiguity introduced here.\n         let predicate_trait_ref = obligation.predicate.to_poly_trait_ref();\n-        if !object_safety::is_object_safe(self.tcx(), predicate_trait_ref.def_id()) {\n+        if !self.tcx().is_object_safe(predicate_trait_ref.def_id()) {\n             return;\n         }\n \n@@ -1855,7 +1853,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                                   recursion_depth,\n                                                   &skol_ty);\n                 let skol_obligation =\n-                    util::predicate_for_trait_def(self.tcx(),\n+                    self.tcx().predicate_for_trait_def(\n                                                   cause.clone(),\n                                                   trait_def_id,\n                                                   recursion_depth,\n@@ -2226,7 +2224,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // entries, so that we can compute the offset for the selected\n             // trait.\n             vtable_base =\n-                nonmatching.map(|t| util::count_own_vtable_entries(self.tcx(), t))\n+                nonmatching.map(|t| self.tcx().count_own_vtable_entries(t))\n                            .sum();\n \n         }\n@@ -2248,11 +2246,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let sig = self_ty.fn_sig();\n         let trait_ref =\n-            util::closure_trait_ref_and_return_type(self.tcx(),\n-                                                    obligation.predicate.def_id(),\n-                                                    self_ty,\n-                                                    sig,\n-                                                    util::TupleArgumentsFlag::Yes)\n+            self.tcx().closure_trait_ref_and_return_type(obligation.predicate.def_id(),\n+                                                         self_ty,\n+                                                         sig,\n+                                                         util::TupleArgumentsFlag::Yes)\n             .map_bound(|(trait_ref, _)| trait_ref);\n \n         self.confirm_poly_trait_refs(obligation.cause.clone(),\n@@ -2396,7 +2393,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n //                    })\n //                    .chain(Some(data.principal_def_id()));\n                 if let Some(did) = object_dids.find(|did| {\n-                    !object_safety::is_object_safe(tcx, *did)\n+                    !tcx.is_object_safe(*did)\n                 }) {\n                     return Err(TraitNotObjectSafe(did))\n                 }\n@@ -2422,7 +2419,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // object type is Foo+Send, this would create an obligation\n                 // for the Send check.)\n                 for bound in &builtin_bounds {\n-                    if let Ok(tr) = util::trait_ref_for_builtin_bound(tcx, bound, source) {\n+                    if let Ok(tr) = tcx.trait_ref_for_builtin_bound(bound, source) {\n                         push(tr.to_predicate());\n                     } else {\n                         return Err(Unimplemented);\n@@ -2511,7 +2508,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 assert!(obligations.is_empty());\n \n                 // Construct the nested Field<T>: Unsize<Field<U>> predicate.\n-                nested.push(util::predicate_for_trait_def(tcx,\n+                nested.push(tcx.predicate_for_trait_def(\n                     obligation.cause.clone(),\n                     obligation.predicate.def_id(),\n                     obligation.recursion_depth + 1,\n@@ -2605,7 +2602,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // FIXME(#32730) propagate obligations\n         assert!(obligations.is_empty());\n \n-        if let Err(e) = self.infcx.leak_check(&skol_map, snapshot) {\n+        if let Err(e) = self.infcx.leak_check(false, &skol_map, snapshot) {\n             debug!(\"match_impl: failed leak check due to `{}`\", e);\n             return Err(());\n         }\n@@ -2710,11 +2707,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     {\n         let closure_type = self.infcx.closure_type(closure_def_id, substs);\n         let ty::Binder((trait_ref, _)) =\n-            util::closure_trait_ref_and_return_type(self.tcx(),\n-                                                    obligation.predicate.def_id(),\n-                                                    obligation.predicate.0.self_ty(), // (1)\n-                                                    &closure_type.sig,\n-                                                    util::TupleArgumentsFlag::No);\n+            self.tcx().closure_trait_ref_and_return_type(obligation.predicate.def_id(),\n+                                                         obligation.predicate.0.self_ty(), // (1)\n+                                                         &closure_type.sig,\n+                                                         util::TupleArgumentsFlag::No);\n         // (1) Feels icky to skip the binder here, but OTOH we know\n         // that the self-type is an unboxed closure type and hence is\n         // in fact unparameterized (or at least does not reference any"}, {"sha": "3d80e149f4f3e233eca16563f475808872ec7cb5", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -21,7 +21,7 @@ use super::{SelectionContext, FulfillmentContext};\n use super::util::{fresh_type_vars_for_impl, impl_trait_ref_and_oblig};\n \n use hir::def_id::DefId;\n-use infer::{self, InferCtxt, TypeOrigin};\n+use infer::{InferCtxt, TypeOrigin};\n use middle::region;\n use ty::subst::{Subst, Substs};\n use traits::{self, ProjectionMode, ObligationCause, Normalized};\n@@ -177,11 +177,10 @@ fn fulfill_implication<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                                                        &target_substs);\n \n         // do the impls unify? If not, no specialization.\n-        if let Err(_) = infer::mk_eq_trait_refs(&infcx,\n-                                                true,\n-                                                TypeOrigin::Misc(DUMMY_SP),\n-                                                source_trait_ref,\n-                                                target_trait_ref) {\n+        if let Err(_) = infcx.eq_trait_refs(true,\n+                                            TypeOrigin::Misc(DUMMY_SP),\n+                                            source_trait_ref,\n+                                            target_trait_ref) {\n             debug!(\"fulfill_implication: {:?} does not unify with {:?}\",\n                    source_trait_ref,\n                    target_trait_ref);\n@@ -196,7 +195,7 @@ fn fulfill_implication<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n             fulfill_cx.register_predicate_obligation(&infcx, oblig);\n         }\n \n-        if let Err(errors) = infer::drain_fulfillment_cx(&infcx, &mut fulfill_cx, &()) {\n+        if let Err(errors) = infcx.drain_fulfillment_cx(&mut fulfill_cx, &()) {\n             // no dice!\n             debug!(\"fulfill_implication: for impls on {:?} and {:?}, could not fulfill: {:?} given \\\n                     {:?}\","}, {"sha": "629b1152b609c55b575c13a153e12caa3c38a233", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 40, "deletions": 44, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -378,41 +378,40 @@ pub fn predicates_for_generics<'tcx>(cause: ObligationCause<'tcx>,\n     }).collect()\n }\n \n-pub fn trait_ref_for_builtin_bound<'tcx>(\n-    tcx: &TyCtxt<'tcx>,\n+pub fn predicate_for_trait_ref<'tcx>(\n+    cause: ObligationCause<'tcx>,\n+    trait_ref: ty::TraitRef<'tcx>,\n+    recursion_depth: usize)\n+    -> PredicateObligation<'tcx>\n+{\n+    Obligation {\n+        cause: cause,\n+        recursion_depth: recursion_depth,\n+        predicate: trait_ref.to_predicate(),\n+    }\n+}\n+\n+impl<'tcx> TyCtxt<'tcx> {\n+pub fn trait_ref_for_builtin_bound(&self,\n     builtin_bound: ty::BuiltinBound,\n     param_ty: Ty<'tcx>)\n     -> Result<ty::TraitRef<'tcx>, ErrorReported>\n {\n-    match tcx.lang_items.from_builtin_kind(builtin_bound) {\n+    match self.lang_items.from_builtin_kind(builtin_bound) {\n         Ok(def_id) => {\n             Ok(ty::TraitRef {\n                 def_id: def_id,\n-                substs: tcx.mk_substs(Substs::empty().with_self_ty(param_ty))\n+                substs: self.mk_substs(Substs::empty().with_self_ty(param_ty))\n             })\n         }\n         Err(e) => {\n-            tcx.sess.err(&e);\n+            self.sess.err(&e);\n             Err(ErrorReported)\n         }\n     }\n }\n \n-pub fn predicate_for_trait_ref<'tcx>(\n-    cause: ObligationCause<'tcx>,\n-    trait_ref: ty::TraitRef<'tcx>,\n-    recursion_depth: usize)\n-    -> PredicateObligation<'tcx>\n-{\n-    Obligation {\n-        cause: cause,\n-        recursion_depth: recursion_depth,\n-        predicate: trait_ref.to_predicate(),\n-    }\n-}\n-\n-pub fn predicate_for_trait_def<'tcx>(\n-    tcx: &TyCtxt<'tcx>,\n+pub fn predicate_for_trait_def(&self,\n     cause: ObligationCause<'tcx>,\n     trait_def_id: DefId,\n     recursion_depth: usize,\n@@ -422,50 +421,47 @@ pub fn predicate_for_trait_def<'tcx>(\n {\n     let trait_ref = ty::TraitRef {\n         def_id: trait_def_id,\n-        substs: tcx.mk_substs(Substs::new_trait(ty_params, vec![], param_ty))\n+        substs: self.mk_substs(Substs::new_trait(ty_params, vec![], param_ty))\n     };\n     predicate_for_trait_ref(cause, trait_ref, recursion_depth)\n }\n \n-pub fn predicate_for_builtin_bound<'tcx>(\n-    tcx: &TyCtxt<'tcx>,\n+pub fn predicate_for_builtin_bound(&self,\n     cause: ObligationCause<'tcx>,\n     builtin_bound: ty::BuiltinBound,\n     recursion_depth: usize,\n     param_ty: Ty<'tcx>)\n     -> Result<PredicateObligation<'tcx>, ErrorReported>\n {\n-    let trait_ref = trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty)?;\n+    let trait_ref = self.trait_ref_for_builtin_bound(builtin_bound, param_ty)?;\n     Ok(predicate_for_trait_ref(cause, trait_ref, recursion_depth))\n }\n \n /// Cast a trait reference into a reference to one of its super\n /// traits; returns `None` if `target_trait_def_id` is not a\n /// supertrait.\n-pub fn upcast<'tcx>(tcx: &TyCtxt<'tcx>,\n-                    source_trait_ref: ty::PolyTraitRef<'tcx>,\n-                    target_trait_def_id: DefId)\n-                    -> Vec<ty::PolyTraitRef<'tcx>>\n+pub fn upcast_choices(&self,\n+                      source_trait_ref: ty::PolyTraitRef<'tcx>,\n+                      target_trait_def_id: DefId)\n+                      -> Vec<ty::PolyTraitRef<'tcx>>\n {\n     if source_trait_ref.def_id() == target_trait_def_id {\n         return vec![source_trait_ref]; // shorcut the most common case\n     }\n \n-    supertraits(tcx, source_trait_ref)\n+    supertraits(self, source_trait_ref)\n         .filter(|r| r.def_id() == target_trait_def_id)\n         .collect()\n }\n \n /// Given a trait `trait_ref`, returns the number of vtable entries\n /// that come from `trait_ref`, excluding its supertraits. Used in\n /// computing the vtable base for an upcast trait of a trait object.\n-pub fn count_own_vtable_entries<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                      trait_ref: ty::PolyTraitRef<'tcx>)\n-                                      -> usize {\n+pub fn count_own_vtable_entries(&self, trait_ref: ty::PolyTraitRef<'tcx>) -> usize {\n     let mut entries = 0;\n     // Count number of methods and add them to the total offset.\n     // Skip over associated types and constants.\n-    for trait_item in &tcx.trait_items(trait_ref.def_id())[..] {\n+    for trait_item in &self.trait_items(trait_ref.def_id())[..] {\n         if let ty::MethodTraitItem(_) = *trait_item {\n             entries += 1;\n         }\n@@ -476,14 +472,14 @@ pub fn count_own_vtable_entries<'tcx>(tcx: &TyCtxt<'tcx>,\n /// Given an upcast trait object described by `object`, returns the\n /// index of the method `method_def_id` (which should be part of\n /// `object.upcast_trait_ref`) within the vtable for `object`.\n-pub fn get_vtable_index_of_object_method<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                               object: &super::VtableObjectData<'tcx>,\n-                                               method_def_id: DefId) -> usize {\n+pub fn get_vtable_index_of_object_method(&self,\n+                                         object: &super::VtableObjectData<'tcx>,\n+                                         method_def_id: DefId) -> usize {\n     // Count number of methods preceding the one we are selecting and\n     // add them to the total offset.\n     // Skip over associated types and constants.\n     let mut entries = object.vtable_base;\n-    for trait_item in &tcx.trait_items(object.upcast_trait_ref.def_id())[..] {\n+    for trait_item in &self.trait_items(object.upcast_trait_ref.def_id())[..] {\n         if trait_item.def_id() == method_def_id {\n             // The item with the ID we were given really ought to be a method.\n             assert!(match *trait_item {\n@@ -502,10 +498,7 @@ pub fn get_vtable_index_of_object_method<'tcx>(tcx: &TyCtxt<'tcx>,\n          method_def_id);\n }\n \n-pub enum TupleArgumentsFlag { Yes, No }\n-\n-pub fn closure_trait_ref_and_return_type<'tcx>(\n-    tcx: &TyCtxt<'tcx>,\n+pub fn closure_trait_ref_and_return_type(&self,\n     fn_trait_def_id: DefId,\n     self_ty: Ty<'tcx>,\n     sig: &ty::PolyFnSig<'tcx>,\n@@ -514,12 +507,15 @@ pub fn closure_trait_ref_and_return_type<'tcx>(\n {\n     let arguments_tuple = match tuple_arguments {\n         TupleArgumentsFlag::No => sig.0.inputs[0],\n-        TupleArgumentsFlag::Yes => tcx.mk_tup(sig.0.inputs.to_vec()),\n+        TupleArgumentsFlag::Yes => self.mk_tup(sig.0.inputs.to_vec()),\n     };\n     let trait_substs = Substs::new_trait(vec![arguments_tuple], vec![], self_ty);\n     let trait_ref = ty::TraitRef {\n         def_id: fn_trait_def_id,\n-        substs: tcx.mk_substs(trait_substs),\n+        substs: self.mk_substs(trait_substs),\n     };\n-    ty::Binder((trait_ref, sig.0.output.unwrap_or(tcx.mk_nil())))\n+    ty::Binder((trait_ref, sig.0.output.unwrap_or(self.mk_nil())))\n }\n+}\n+\n+pub enum TupleArgumentsFlag { Yes, No }"}, {"sha": "bcdc9feab5b91bd769623c73946017fe7b8ff5f3", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -12,7 +12,7 @@ pub use self::Integer::*;\n pub use self::Layout::*;\n pub use self::Primitive::*;\n \n-use infer::{InferCtxt, drain_fulfillment_cx_or_panic};\n+use infer::InferCtxt;\n use session::Session;\n use traits;\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n@@ -754,7 +754,7 @@ fn normalize_associated_type<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n         fulfill_cx.register_predicate_obligation(infcx, obligation);\n     }\n \n-    drain_fulfillment_cx_or_panic(DUMMY_SP, infcx, &mut fulfill_cx, &result)\n+    infcx.drain_fulfillment_cx_or_panic(DUMMY_SP, &mut fulfill_cx, &result)\n }\n \n impl Layout {"}, {"sha": "ed50d151a2a7846e48ade9053edcc7e853068ce3", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -55,20 +55,18 @@ pub enum Component<'tcx> {\n     EscapingProjection(Vec<Component<'tcx>>),\n }\n \n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n /// Returns all the things that must outlive `'a` for the condition\n /// `ty0: 'a` to hold.\n-pub fn components<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n-                           ty0: Ty<'tcx>)\n+pub fn outlives_components(&self, ty0: Ty<'tcx>)\n                            -> Vec<Component<'tcx>> {\n     let mut components = vec![];\n-    compute_components(infcx, ty0, &mut components);\n+    self.compute_components(ty0, &mut components);\n     debug!(\"components({:?}) = {:?}\", ty0, components);\n     components\n }\n \n-fn compute_components<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n-                               ty: Ty<'tcx>,\n-                               out: &mut Vec<Component<'tcx>>) {\n+fn compute_components(&self, ty: Ty<'tcx>, out: &mut Vec<Component<'tcx>>) {\n     // Descend through the types, looking for the various \"base\"\n     // components and collecting them into `out`. This is not written\n     // with `collect()` because of the need to sometimes skip subtrees\n@@ -114,7 +112,7 @@ fn compute_components<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n             // taking into consideration UFCS and so forth.\n \n             for &upvar_ty in &substs.upvar_tys {\n-                compute_components(infcx, upvar_ty, out);\n+                self.compute_components(upvar_ty, out);\n             }\n         }\n \n@@ -145,7 +143,7 @@ fn compute_components<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n                 // fallback case: hard code\n                 // OutlivesProjectionComponents.  Continue walking\n                 // through and constrain Pi.\n-                let subcomponents = capture_components(infcx, ty);\n+                let subcomponents = self.capture_components(ty);\n                 out.push(Component::EscapingProjection(subcomponents));\n             }\n         }\n@@ -154,11 +152,11 @@ fn compute_components<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n         // and proceed with resolved version. If we cannot resolve it,\n         // then record the unresolved variable as a component.\n         ty::TyInfer(_) => {\n-            let ty = infcx.resolve_type_vars_if_possible(&ty);\n+            let ty = self.resolve_type_vars_if_possible(&ty);\n             if let ty::TyInfer(infer_ty) = ty.sty {\n                 out.push(Component::UnresolvedInferenceVariable(infer_ty));\n             } else {\n-                compute_components(infcx, ty, out);\n+                self.compute_components(ty, out);\n             }\n         }\n \n@@ -194,22 +192,21 @@ fn compute_components<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n \n             push_region_constraints(out, ty.regions());\n             for subty in ty.walk_shallow() {\n-                compute_components(infcx, subty, out);\n+                self.compute_components(subty, out);\n             }\n         }\n     }\n }\n \n-fn capture_components<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n-                               ty: Ty<'tcx>)\n-                               -> Vec<Component<'tcx>> {\n+fn capture_components(&self, ty: Ty<'tcx>) -> Vec<Component<'tcx>> {\n     let mut temp = vec![];\n     push_region_constraints(&mut temp, ty.regions());\n     for subty in ty.walk_shallow() {\n-        compute_components(infcx, subty, &mut temp);\n+        self.compute_components(subty, &mut temp);\n     }\n     temp\n }\n+}\n \n fn push_region_constraints<'tcx>(out: &mut Vec<Component<'tcx>>, regions: Vec<ty::Region>) {\n     for r in regions {"}, {"sha": "05d1dc755306748222630e366100f7c2af4791ee", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -14,7 +14,6 @@ use middle::cstore;\n use hir::def_id::DefId;\n use middle::region;\n use ty::subst::{self, Substs};\n-use traits;\n use ty::{self, AdtDef, ToPredicate, TypeFlags, Ty, TyCtxt, TyS, TypeFoldable};\n use util::common::ErrorReported;\n \n@@ -633,7 +632,7 @@ pub struct DebruijnIndex {\n /// to be used. These also support explicit bounds: both the internally-stored\n /// *scope*, which the region is assumed to outlive, as well as other\n /// relations stored in the `FreeRegionMap`. Note that these relations\n-/// aren't checked when you `make_subregion` (or `mk_eqty`), only by\n+/// aren't checked when you `make_subregion` (or `eq_types`), only by\n /// `resolve_regions_and_report_errors`.\n ///\n /// When working with higher-ranked types, some region relations aren't\n@@ -778,7 +777,7 @@ impl BuiltinBounds {\n                                tcx: &TyCtxt<'tcx>,\n                                self_ty: Ty<'tcx>) -> Vec<ty::Predicate<'tcx>> {\n         self.iter().filter_map(|builtin_bound|\n-            match traits::trait_ref_for_builtin_bound(tcx, builtin_bound, self_ty) {\n+            match tcx.trait_ref_for_builtin_bound(builtin_bound, self_ty) {\n                 Ok(trait_ref) => Some(trait_ref.to_predicate()),\n                 Err(ErrorReported) => { None }\n             }"}, {"sha": "c7cd900aa9a2096212041b759fa09f610d8378ad", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -10,7 +10,7 @@\n \n use hir::def_id::DefId;\n use infer::InferCtxt;\n-use ty::outlives::{self, Component};\n+use ty::outlives::Component;\n use ty::subst::Substs;\n use traits;\n use ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable};\n@@ -182,7 +182,7 @@ pub fn implied_bounds<'a,'tcx>(\n                         match infcx.tcx.no_late_bound_regions(data) {\n                             None => vec![],\n                             Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n-                                let components = outlives::components(infcx, ty_a);\n+                                let components = infcx.outlives_components(ty_a);\n                                 implied_bounds_from_components(r_b, components)\n                             }\n                         },\n@@ -288,9 +288,7 @@ impl<'a,'tcx> WfPredicates<'a,'tcx> {\n                      rfc1592: bool) {\n         if !subty.has_escaping_regions() {\n             let cause = self.cause(cause);\n-            match traits::trait_ref_for_builtin_bound(self.infcx.tcx,\n-                                                      ty::BoundSized,\n-                                                      subty) {\n+            match self.infcx.tcx.trait_ref_for_builtin_bound(ty::BoundSized, subty) {\n                 Ok(trait_ref) => {\n                     let predicate = trait_ref.to_predicate();\n                     let predicate = if rfc1592 {"}, {"sha": "ba29a6703e50bf91d2ea74f5cbe9f073ea97ecdf", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -26,7 +26,6 @@ use rustc::hir::pat_util::def_to_path;\n use rustc::ty::{self, Ty, TyCtxt, subst};\n use rustc::ty::util::IntTypeExt;\n use rustc::traits::ProjectionMode;\n-use rustc::middle::astconv_util::ast_ty_to_prim_ty;\n use rustc::util::nodemap::NodeMap;\n use rustc::lint;\n \n@@ -100,7 +99,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n                 hir::ItemConst(ref ty, ref const_expr) => {\n-                    Some((&const_expr, ast_ty_to_prim_ty(tcx, ty)))\n+                    Some((&const_expr, tcx.ast_ty_to_prim_ty(ty)))\n                 }\n                 _ => None\n             },\n@@ -126,7 +125,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n             },\n             Some(ast_map::NodeImplItem(ii)) => match ii.node {\n                 hir::ImplItemKind::Const(ref ty, ref expr) => {\n-                    Some((&expr, ast_ty_to_prim_ty(tcx, ty)))\n+                    Some((&expr, tcx.ast_ty_to_prim_ty(ty)))\n                 }\n                 _ => None\n             },\n@@ -144,7 +143,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n         let expr_ty = match tcx.sess.cstore.maybe_get_item_ast(tcx, def_id) {\n             cstore::FoundAst::Found(&InlinedItem::Item(ref item)) => match item.node {\n                 hir::ItemConst(ref ty, ref const_expr) => {\n-                    Some((&**const_expr, ast_ty_to_prim_ty(tcx, ty)))\n+                    Some((&**const_expr, tcx.ast_ty_to_prim_ty(ty)))\n                 },\n                 _ => None\n             },\n@@ -165,7 +164,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n             },\n             cstore::FoundAst::Found(&InlinedItem::ImplItem(_, ref ii)) => match ii.node {\n                 hir::ImplItemKind::Const(ref ty, ref expr) => {\n-                    Some((&**expr, ast_ty_to_prim_ty(tcx, ty)))\n+                    Some((&**expr, tcx.ast_ty_to_prim_ty(ty)))\n                 },\n                 _ => None\n             },\n@@ -679,7 +678,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n         }\n       }\n       hir::ExprCast(ref base, ref target_ty) => {\n-        let ety = ast_ty_to_prim_ty(tcx, &target_ty).or_else(|| ety)\n+        let ety = tcx.ast_ty_to_prim_ty(&target_ty).or(ety)\n                 .unwrap_or_else(|| {\n                     tcx.sess.span_fatal(target_ty.span,\n                                         \"target type not found for const cast\")\n@@ -1041,7 +1040,7 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n                 Some(ic) => lookup_const_by_id(tcx, ic.def_id, None),\n                 None => match ti.node {\n                     hir::ConstTraitItem(ref ty, Some(ref expr)) => {\n-                        Some((&*expr, ast_ty_to_prim_ty(tcx, ty)))\n+                        Some((&*expr, tcx.ast_ty_to_prim_ty(ty)))\n                     },\n                     _ => None,\n                 },"}, {"sha": "475e1f42559d9fadff12fd9bf80ee39044379f95", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -242,17 +242,14 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     }\n \n     pub fn make_subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n-        match infer::mk_subty(self.infcx, true, TypeOrigin::Misc(DUMMY_SP), a, b) {\n+        match self.infcx.sub_types(true, TypeOrigin::Misc(DUMMY_SP), a, b) {\n             Ok(_) => true,\n             Err(ref e) => panic!(\"Encountered error: {}\", e),\n         }\n     }\n \n     pub fn is_subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n-        match infer::can_mk_subty(self.infcx, a, b) {\n-            Ok(_) => true,\n-            Err(_) => false,\n-        }\n+        self.infcx.can_sub_types(a, b).is_ok()\n     }\n \n     pub fn assert_subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) {"}, {"sha": "b7de78ec912c39776405861929bd71008e318660", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -25,7 +25,6 @@ use middle::cstore::{LOCAL_CRATE, InlinedItemRef, LinkMeta, tls};\n use rustc::hir::def;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use middle::dependency_format::Linkage;\n-use middle::stability;\n use rustc::ty::subst;\n use rustc::traits::specialization_graph;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -283,8 +282,8 @@ fn encode_enum_variant_info<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_attributes(rbml_w, &attrs);\n         encode_repr_attrs(rbml_w, ecx, &attrs);\n \n-        let stab = stability::lookup_stability(ecx.tcx, vid);\n-        let depr = stability::lookup_deprecation(ecx.tcx, vid);\n+        let stab = ecx.tcx.lookup_stability(vid);\n+        let depr = ecx.tcx.lookup_deprecation(vid);\n         encode_stability(rbml_w, stab);\n         encode_deprecation(rbml_w, depr);\n \n@@ -376,8 +375,8 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n \n     encode_visibility(rbml_w, vis);\n \n-    let stab = stability::lookup_stability(ecx.tcx, ecx.tcx.map.local_def_id(id));\n-    let depr = stability::lookup_deprecation(ecx.tcx, ecx.tcx.map.local_def_id(id));\n+    let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(id));\n+    let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(id));\n     encode_stability(rbml_w, stab);\n     encode_deprecation(rbml_w, depr);\n \n@@ -484,8 +483,8 @@ fn encode_field<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_bounds_and_type_for_item(rbml_w, ecx, index, id);\n     encode_def_id_and_key(ecx, rbml_w, field.did);\n \n-    let stab = stability::lookup_stability(ecx.tcx, field.did);\n-    let depr = stability::lookup_deprecation(ecx.tcx, field.did);\n+    let stab = ecx.tcx.lookup_stability(field.did);\n+    let depr = ecx.tcx.lookup_deprecation(field.did);\n     encode_stability(rbml_w, stab);\n     encode_deprecation(rbml_w, depr);\n \n@@ -517,8 +516,8 @@ fn encode_info_for_struct_ctor<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_symbol(ecx, rbml_w, ctor_id);\n     }\n \n-    let stab = stability::lookup_stability(ecx.tcx, ecx.tcx.map.local_def_id(ctor_id));\n-    let depr= stability::lookup_deprecation(ecx.tcx, ecx.tcx.map.local_def_id(ctor_id));\n+    let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(ctor_id));\n+    let depr= ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(ctor_id));\n     encode_stability(rbml_w, stab);\n     encode_deprecation(rbml_w, depr);\n \n@@ -646,8 +645,8 @@ fn encode_info_for_associated_const<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_bounds_and_type_for_item(rbml_w, ecx, index,\n                                     ecx.local_id(associated_const.def_id));\n \n-    let stab = stability::lookup_stability(ecx.tcx, associated_const.def_id);\n-    let depr = stability::lookup_deprecation(ecx.tcx, associated_const.def_id);\n+    let stab = ecx.tcx.lookup_stability(associated_const.def_id);\n+    let depr = ecx.tcx.lookup_deprecation(associated_const.def_id);\n     encode_stability(rbml_w, stab);\n     encode_deprecation(rbml_w, depr);\n \n@@ -681,8 +680,8 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n     encode_item_sort(rbml_w, 'r');\n \n-    let stab = stability::lookup_stability(ecx.tcx, m.def_id);\n-    let depr = stability::lookup_deprecation(ecx.tcx, m.def_id);\n+    let stab = ecx.tcx.lookup_stability(m.def_id);\n+    let depr = ecx.tcx.lookup_deprecation(m.def_id);\n     encode_stability(rbml_w, stab);\n     encode_deprecation(rbml_w, depr);\n \n@@ -736,8 +735,8 @@ fn encode_info_for_associated_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n     encode_item_sort(rbml_w, 't');\n \n-    let stab = stability::lookup_stability(ecx.tcx, associated_type.def_id);\n-    let depr = stability::lookup_deprecation(ecx.tcx, associated_type.def_id);\n+    let stab = ecx.tcx.lookup_stability(associated_type.def_id);\n+    let depr = ecx.tcx.lookup_deprecation(associated_type.def_id);\n     encode_stability(rbml_w, stab);\n     encode_deprecation(rbml_w, depr);\n \n@@ -872,8 +871,8 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n     let vis = &item.vis;\n     let def_id = ecx.tcx.map.local_def_id(item.id);\n-    let stab = stability::lookup_stability(tcx, ecx.tcx.map.local_def_id(item.id));\n-    let depr = stability::lookup_deprecation(tcx, ecx.tcx.map.local_def_id(item.id));\n+    let stab = tcx.lookup_stability(ecx.tcx.map.local_def_id(item.id));\n+    let depr = tcx.lookup_deprecation(ecx.tcx.map.local_def_id(item.id));\n \n     match item.node {\n       hir::ItemStatic(_, m, _) => {\n@@ -1231,8 +1230,8 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n             encode_parent_item(rbml_w, def_id);\n \n-            let stab = stability::lookup_stability(tcx, item_def_id.def_id());\n-            let depr = stability::lookup_deprecation(tcx, item_def_id.def_id());\n+            let stab = tcx.lookup_stability(item_def_id.def_id());\n+            let depr = tcx.lookup_deprecation(item_def_id.def_id());\n             encode_stability(rbml_w, stab);\n             encode_deprecation(rbml_w, depr);\n \n@@ -1358,8 +1357,8 @@ fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n             encode_symbol(ecx, rbml_w, nitem.id);\n         }\n         encode_attributes(rbml_w, &nitem.attrs);\n-        let stab = stability::lookup_stability(ecx.tcx, ecx.tcx.map.local_def_id(nitem.id));\n-        let depr = stability::lookup_deprecation(ecx.tcx, ecx.tcx.map.local_def_id(nitem.id));\n+        let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(nitem.id));\n+        let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(nitem.id));\n         encode_stability(rbml_w, stab);\n         encode_deprecation(rbml_w, depr);\n         encode_method_argument_names(rbml_w, &fndecl);\n@@ -1372,8 +1371,8 @@ fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         }\n         encode_bounds_and_type_for_item(rbml_w, ecx, index, nitem.id);\n         encode_attributes(rbml_w, &nitem.attrs);\n-        let stab = stability::lookup_stability(ecx.tcx, ecx.tcx.map.local_def_id(nitem.id));\n-        let depr = stability::lookup_deprecation(ecx.tcx, ecx.tcx.map.local_def_id(nitem.id));\n+        let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(nitem.id));\n+        let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(nitem.id));\n         encode_stability(rbml_w, stab);\n         encode_deprecation(rbml_w, depr);\n         encode_symbol(ecx, rbml_w, nitem.id);"}, {"sha": "64214c98bf708a90b606f5f5ef7a8ef5e41f2f76", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -202,10 +202,10 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n     }\n }\n \n-fn closure_self_ty<'a, 'tcx>(tcx: &TyCtxt<'tcx>,\n-                             closure_expr_id: ast::NodeId,\n-                             body_id: ast::NodeId)\n-                             -> Ty<'tcx> {\n+fn closure_self_ty<'tcx>(tcx: &TyCtxt<'tcx>,\n+                         closure_expr_id: ast::NodeId,\n+                         body_id: ast::NodeId)\n+                         -> Ty<'tcx> {\n     let closure_ty = tcx.node_id_to_type(closure_expr_id);\n \n     // We're just hard-coding the idea that the signature will be"}, {"sha": "4d07e63dde6414da59ba779bf620d4ea0ee1bed0", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -1023,11 +1023,11 @@ impl<'tcx> MirMapPass<'tcx> for QualifyAndPromoteConstants {\n                 let mut fulfillment_cx = traits::FulfillmentContext::new();\n                 fulfillment_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);\n                 if let Err(err) = fulfillment_cx.select_all_or_error(&infcx) {\n-                    traits::report_fulfillment_errors(&infcx, &err);\n+                    infcx.report_fulfillment_errors(&err);\n                 }\n \n-                if let Err(ref errors) = fulfillment_cx.select_rfc1592_obligations(&infcx) {\n-                   traits::report_fulfillment_errors_as_warnings(&infcx, errors, id);\n+                if let Err(errors) = fulfillment_cx.select_rfc1592_obligations(&infcx) {\n+                    infcx.report_fulfillment_errors_as_warnings(&errors, id);\n                 }\n             }\n         }"}, {"sha": "d8093f10d9612878917cbd4a67be5d1f1c7baefb", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -237,7 +237,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                 let fty = self.sanitize_type(lvalue, fty);\n                 match self.field_ty(lvalue, base, field) {\n                     Ok(ty) => {\n-                        if let Err(terr) = self.cx.mk_eqty(span, ty, fty) {\n+                        if let Err(terr) = self.cx.eq_types(span, ty, fty) {\n                             span_mirbug!(\n                                 self, lvalue, \"bad field access ({:?}: {:?}): {:?}\",\n                                 ty, fty, terr);\n@@ -333,20 +333,18 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         }\n     }\n \n-    fn mk_subty(&self, span: Span, sup: Ty<'tcx>, sub: Ty<'tcx>)\n-                -> infer::UnitResult<'tcx>\n+    fn sub_types(&self, span: Span, sup: Ty<'tcx>, sub: Ty<'tcx>)\n+                 -> infer::UnitResult<'tcx>\n     {\n-        infer::mk_subty(self.infcx, false, infer::TypeOrigin::Misc(span),\n-                        sup, sub)\n+        self.infcx.sub_types(false, infer::TypeOrigin::Misc(span), sup, sub)\n             // FIXME(#32730) propagate obligations\n             .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n     }\n \n-    fn mk_eqty(&self, span: Span, a: Ty<'tcx>, b: Ty<'tcx>)\n+    fn eq_types(&self, span: Span, a: Ty<'tcx>, b: Ty<'tcx>)\n                 -> infer::UnitResult<'tcx>\n     {\n-        infer::mk_eqty(self.infcx, false, infer::TypeOrigin::Misc(span),\n-                       a, b)\n+        self.infcx.eq_types(false, infer::TypeOrigin::Misc(span), a, b)\n             // FIXME(#32730) propagate obligations\n             .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n     }\n@@ -363,7 +361,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 let lv_ty = mir.lvalue_ty(tcx, lv).to_ty(tcx);\n                 let rv_ty = mir.rvalue_ty(tcx, rv);\n                 if let Some(rv_ty) = rv_ty {\n-                    if let Err(terr) = self.mk_subty(self.last_span, rv_ty, lv_ty) {\n+                    if let Err(terr) = self.sub_types(self.last_span, rv_ty, lv_ty) {\n                         span_mirbug!(self, stmt, \"bad assignment ({:?} = {:?}): {:?}\",\n                                      lv_ty, rv_ty, terr);\n                     }\n@@ -399,7 +397,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             }\n             TerminatorKind::SwitchInt { ref discr, switch_ty, .. } => {\n                 let discr_ty = mir.lvalue_ty(tcx, discr).to_ty(tcx);\n-                if let Err(terr) = self.mk_subty(self.last_span, discr_ty, switch_ty) {\n+                if let Err(terr) = self.sub_types(self.last_span, discr_ty, switch_ty) {\n                     span_mirbug!(self, term, \"bad SwitchInt ({:?} on {:?}): {:?}\",\n                                  switch_ty, discr_ty, terr);\n                 }\n@@ -456,7 +454,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             }\n             (&Some((ref dest, _)), ty::FnConverging(ty)) => {\n                 let dest_ty = mir.lvalue_ty(tcx, dest).to_ty(tcx);\n-                if let Err(terr) = self.mk_subty(self.last_span, ty, dest_ty) {\n+                if let Err(terr) = self.sub_types(self.last_span, ty, dest_ty) {\n                     span_mirbug!(self, term,\n                                  \"call dest mismatch ({:?} <- {:?}): {:?}\",\n                                  dest_ty, ty, terr);\n@@ -482,7 +480,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         }\n         for (n, (fn_arg, op_arg)) in sig.inputs.iter().zip(args).enumerate() {\n             let op_arg_ty = mir.operand_ty(self.tcx(), op_arg);\n-            if let Err(terr) = self.mk_subty(self.last_span, op_arg_ty, fn_arg) {\n+            if let Err(terr) = self.sub_types(self.last_span, op_arg_ty, fn_arg) {\n                 span_mirbug!(self, term, \"bad arg #{:?} ({:?} <- {:?}): {:?}\",\n                              n, fn_arg, op_arg_ty, terr);\n             }\n@@ -537,7 +535,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             }\n         };\n \n-        if let Err(terr) = self.mk_subty(self.last_span, arg_ty, pointee_ty) {\n+        if let Err(terr) = self.sub_types(self.last_span, arg_ty, pointee_ty) {\n             span_mirbug!(self, term, \"bad box_free arg ({:?} <- {:?}): {:?}\",\n                          pointee_ty, arg_ty, terr);\n         }"}, {"sha": "6c4a568a70aabd5f876d571fb52e5eee3d41c0d1", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -202,8 +202,7 @@ impl<'tcx> Callee<'tcx> {\n             }\n             traits::VtableObject(ref data) => {\n                 Callee {\n-                    data: Virtual(traits::get_vtable_index_of_object_method(\n-                        tcx, data, def_id)),\n+                    data: Virtual(tcx.get_vtable_index_of_object_method(data, def_id)),\n                     ty: def_ty(tcx, def_id, substs)\n                 }\n             }"}, {"sha": "bab18e1469dd4da5e9c5f44237c3c7b11e34dc87", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -19,7 +19,7 @@ use llvm::{True, False, Bool, OperandBundleDef};\n use rustc::cfg;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n-use rustc::infer::{self, InferCtxt};\n+use rustc::infer::InferCtxt;\n use rustc::util::common::MemoizationMap;\n use middle::lang_items::LangItem;\n use rustc::ty::subst::Substs;\n@@ -1107,9 +1107,7 @@ pub fn fulfill_obligation<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n         let vtable = selection.map(|predicate| {\n             fulfill_cx.register_predicate_obligation(&infcx, predicate);\n         });\n-        let vtable = infer::drain_fulfillment_cx_or_panic(\n-            span, &infcx, &mut fulfill_cx, &vtable\n-        );\n+        let vtable = infcx.drain_fulfillment_cx_or_panic(span, &mut fulfill_cx, &vtable);\n \n         info!(\"Cache miss: {:?} => {:?}\", trait_ref, vtable);\n \n@@ -1142,7 +1140,7 @@ pub fn normalize_and_test_predicates<'tcx>(tcx: &TyCtxt<'tcx>,\n         fulfill_cx.register_predicate_obligation(&infcx, obligation);\n     }\n \n-    infer::drain_fulfillment_cx(&infcx, &mut fulfill_cx, &()).is_ok()\n+    infcx.drain_fulfillment_cx(&mut fulfill_cx, &()).is_ok()\n }\n \n pub fn langcall(bcx: Block,"}, {"sha": "937c6ede6035c3f82c389527a9a6429a78873867", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -256,7 +256,7 @@ pub fn get_vtable_methods<'tcx>(tcx: &TyCtxt<'tcx>,\n             let name = trait_method_type.name;\n \n             // Some methods cannot be called on an object; skip those.\n-            if !traits::is_vtable_safe_method(tcx, trt_id, &trait_method_type) {\n+            if !tcx.is_vtable_safe_method(trt_id, &trait_method_type) {\n                 debug!(\"get_vtable_methods: not vtable safe\");\n                 return None;\n             }"}, {"sha": "0ddbfe3310fe04393600cef964fa3e1bcc8be5db", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -48,7 +48,6 @@\n //! case but `&a` in the second.  Basically, defaults that appear inside\n //! an rptr (`&r.T`) use the region `r` that appears in the rptr.\n \n-use middle::astconv_util::{prim_ty_to_ty, prohibit_type_params, prohibit_projection};\n use middle::const_val::ConstVal;\n use rustc_const_eval::{eval_const_expr_partial, ConstEvalErr};\n use rustc_const_eval::EvalHint::UncheckedExprHint;\n@@ -338,7 +337,7 @@ pub fn ast_path_substs_for_ty<'tcx>(\n         }\n     };\n \n-    assoc_bindings.first().map(|b| prohibit_projection(this.tcx(), b.span));\n+    assoc_bindings.first().map(|b| this.tcx().prohibit_projection(b.span));\n \n     create_substs_for_ast_path(this,\n                                span,\n@@ -825,7 +824,7 @@ fn ast_path_to_mono_trait_ref<'a,'tcx>(this: &AstConv<'tcx>,\n                                         trait_def_id,\n                                         self_ty,\n                                         trait_segment);\n-    assoc_bindings.first().map(|b| prohibit_projection(this.tcx(), b.span));\n+    assoc_bindings.first().map(|b| this.tcx().prohibit_projection(b.span));\n     ty::TraitRef::new(trait_def_id, substs)\n }\n \n@@ -1141,10 +1140,10 @@ fn make_object_type<'tcx>(this: &AstConv<'tcx>,\n     // most importantly, that the supertraits don't contain Self,\n     // to avoid ICE-s.\n     let object_safety_violations =\n-        traits::astconv_object_safety_violations(tcx, principal.def_id());\n+        tcx.astconv_object_safety_violations(principal.def_id());\n     if !object_safety_violations.is_empty() {\n-        traits::report_object_safety_error(\n-            tcx, span, principal.def_id(), None, object_safety_violations)\n+        tcx.report_object_safety_error(\n+            span, principal.def_id(), None, object_safety_violations)\n             .unwrap().emit();\n         return tcx.types.err;\n     }\n@@ -1281,7 +1280,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n \n     debug!(\"associated_path_def_to_ty: {:?}::{}\", ty, assoc_name);\n \n-    prohibit_type_params(tcx, slice::ref_slice(item_segment));\n+    tcx.prohibit_type_params(slice::ref_slice(item_segment));\n \n     // Find the type of the associated item, and the trait where the associated\n     // item is declared.\n@@ -1383,7 +1382,7 @@ fn qpath_to_ty<'tcx>(this: &AstConv<'tcx>,\n {\n     let tcx = this.tcx();\n \n-    prohibit_type_params(tcx, slice::ref_slice(item_segment));\n+    tcx.prohibit_type_params(slice::ref_slice(item_segment));\n \n     let self_ty = if let Some(ty) = opt_self_ty {\n         ty\n@@ -1472,7 +1471,7 @@ fn base_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                                                           base_segments.last().unwrap(),\n                                                           &mut projection_bounds);\n \n-            prohibit_type_params(tcx, base_segments.split_last().unwrap().1);\n+            tcx.prohibit_type_params(base_segments.split_last().unwrap().1);\n             trait_ref_to_object_type(this,\n                                      rscope,\n                                      span,\n@@ -1481,7 +1480,7 @@ fn base_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                                      &[])\n         }\n         Def::Enum(did) | Def::TyAlias(did) | Def::Struct(did) => {\n-            prohibit_type_params(tcx, base_segments.split_last().unwrap().1);\n+            tcx.prohibit_type_params(base_segments.split_last().unwrap().1);\n             ast_path_to_ty(this,\n                            rscope,\n                            span,\n@@ -1490,12 +1489,12 @@ fn base_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                            base_segments.last().unwrap())\n         }\n         Def::TyParam(space, index, _, name) => {\n-            prohibit_type_params(tcx, base_segments);\n+            tcx.prohibit_type_params(base_segments);\n             tcx.mk_param(space, index, name)\n         }\n         Def::SelfTy(_, Some((_, self_ty_id))) => {\n             // Self in impl (we know the concrete type).\n-            prohibit_type_params(tcx, base_segments);\n+            tcx.prohibit_type_params(base_segments);\n             if let Some(&ty) = tcx.ast_ty_to_ty_cache.borrow().get(&self_ty_id) {\n                 if let Some(free_substs) = this.get_free_substs() {\n                     ty.subst(tcx, free_substs)\n@@ -1508,11 +1507,11 @@ fn base_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n         }\n         Def::SelfTy(Some(_), None) => {\n             // Self in trait.\n-            prohibit_type_params(tcx, base_segments);\n+            tcx.prohibit_type_params(base_segments);\n             tcx.mk_self_type()\n         }\n         Def::AssociatedTy(trait_did, _) => {\n-            prohibit_type_params(tcx, &base_segments[..base_segments.len()-2]);\n+            tcx.prohibit_type_params(&base_segments[..base_segments.len()-2]);\n             qpath_to_ty(this,\n                         rscope,\n                         span,\n@@ -1536,7 +1535,7 @@ fn base_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n             opt_self_ty.expect(\"missing T in <T>::a::b::c\")\n         }\n         Def::PrimTy(prim_ty) => {\n-            prim_ty_to_ty(tcx, base_segments, prim_ty)\n+            tcx.prim_ty_to_ty(base_segments, prim_ty)\n         }\n         Def::Err => {\n             this.set_tainted_by_errors();\n@@ -2259,7 +2258,7 @@ impl<'tcx> Bounds<'tcx> {\n         let mut vec = Vec::new();\n \n         for builtin_bound in &self.builtin_bounds {\n-            match traits::trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty) {\n+            match tcx.trait_ref_for_builtin_bound(builtin_bound, param_ty) {\n                 Ok(trait_ref) => { vec.push(trait_ref.to_predicate()); }\n                 Err(ErrorReported) => { }\n             }"}, {"sha": "d414effcda043a95cac44b83b8fd35d7f3c1518a", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -64,7 +64,6 @@ use check::{FnCtxt, UnresolvedTypeAction};\n \n use rustc::infer::{Coercion, InferOk, TypeOrigin, TypeTrace};\n use rustc::traits::{self, ObligationCause};\n-use rustc::traits::{predicate_for_trait_def, report_selection_error};\n use rustc::ty::adjustment::{AutoAdjustment, AutoDerefRef, AdjustDerefRef};\n use rustc::ty::adjustment::{AutoPtr, AutoUnsafe, AdjustReifyFnPointer};\n use rustc::ty::adjustment::{AdjustUnsafeFnPointer, AdjustMutToConstPointer};\n@@ -446,12 +445,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         // Create an obligation for `Source: CoerceUnsized<Target>`.\n         let cause = ObligationCause::misc(self.origin.span(), self.fcx.body_id);\n-        queue.push_back(predicate_for_trait_def(self.tcx(),\n-                                                cause,\n-                                                coerce_unsized_did,\n-                                                0,\n-                                                source,\n-                                                vec![target]));\n+        queue.push_back(self.tcx().predicate_for_trait_def(cause,\n+                                                           coerce_unsized_did,\n+                                                           0,\n+                                                           source,\n+                                                           vec![target]));\n \n         // Keep resolving `CoerceUnsized` and `Unsize` predicates to avoid\n         // emitting a coercion in cases like `Foo<$1>` -> `Foo<$2>`, where\n@@ -477,7 +475,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n                 // Object safety violations or miscellaneous.\n                 Err(err) => {\n-                    report_selection_error(self.fcx.infcx(), &obligation, &err, None);\n+                    self.fcx.infcx().report_selection_error(&obligation, &err, None);\n                     // Treat this like an obligation and follow through\n                     // with the unsizing - the lack of a coercion should\n                     // be silent, as it causes a type mismatch later."}, {"sha": "375ce6941ae9873b5a016be9b0d8baca253f5033", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -325,9 +325,9 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         debug!(\"compare_impl_method: trait_fty={:?}\",\n                trait_fty);\n \n-        infer::mk_subty(&infcx, false, origin, impl_fty, trait_fty)?;\n+        infcx.sub_types(false, origin, impl_fty, trait_fty)?;\n \n-        infcx.leak_check(&skol_map, snapshot)\n+        infcx.leak_check(false, &skol_map, snapshot)\n     });\n \n     match err {\n@@ -347,7 +347,7 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // Check that all obligations are satisfied by the implementation's\n     // version.\n     match fulfillment_cx.select_all_or_error(&infcx) {\n-        Err(ref errors) => { traits::report_fulfillment_errors(&infcx, errors) }\n+        Err(ref errors) => { infcx.report_fulfillment_errors(errors) }\n         Ok(_) => {}\n     }\n \n@@ -361,8 +361,7 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // anyway, so it shouldn't be needed there either. Anyway, we can\n     // always add more relations later (it's backwards compat).\n     let mut free_regions = FreeRegionMap::new();\n-    free_regions.relate_free_regions_from_predicates(tcx,\n-                                                     &infcx.parameter_environment.caller_bounds);\n+    free_regions.relate_free_regions_from_predicates(&infcx.parameter_environment.caller_bounds);\n \n     infcx.resolve_regions_and_report_errors(&free_regions, impl_m_body_id);\n \n@@ -474,7 +473,7 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         debug!(\"compare_const_impl: trait_ty={:?}\",\n                trait_ty);\n \n-        infer::mk_subty(&infcx, false, origin, impl_ty, trait_ty)\n+        infcx.sub_types(false, origin, impl_ty, trait_ty)\n     });\n \n     match err {"}, {"sha": "09a23d283647f705b80a9fd995a395929441898e", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -96,7 +96,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n         infcx.fresh_substs_for_generics(drop_impl_span, drop_impl_generics);\n     let fresh_impl_self_ty = drop_impl_ty.subst(tcx, &fresh_impl_substs);\n \n-    if let Err(_) = infer::mk_eqty(&infcx, true, infer::TypeOrigin::Misc(drop_impl_span),\n+    if let Err(_) = infcx.eq_types(true, infer::TypeOrigin::Misc(drop_impl_span),\n                                    named_type, fresh_impl_self_ty) {\n         let item_span = tcx.map.span(self_type_node_id);\n         struct_span_err!(tcx.sess, drop_impl_span, E0366,\n@@ -110,13 +110,12 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n \n     if let Err(ref errors) = fulfillment_cx.select_all_or_error(&infcx) {\n         // this could be reached when we get lazy normalization\n-        traits::report_fulfillment_errors(&infcx, errors);\n+        infcx.report_fulfillment_errors(errors);\n         return Err(());\n     }\n \n     if let Err(ref errors) = fulfillment_cx.select_rfc1592_obligations(&infcx) {\n-        traits::report_fulfillment_errors_as_warnings(&infcx, errors,\n-                                                      drop_impl_node_id);\n+        infcx.report_fulfillment_errors_as_warnings(errors, drop_impl_node_id);\n     }\n \n     let free_regions = FreeRegionMap::new();"}, {"sha": "0b4dc55fbf71bc4935be928ca1553288bd5c3bb9", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -19,7 +19,7 @@ use rustc::ty::{self, NoPreference, PreferMutLvalue, Ty, TyCtxt};\n use rustc::ty::adjustment::{AdjustDerefRef, AutoDerefRef, AutoPtr};\n use rustc::ty::fold::TypeFoldable;\n use rustc::infer;\n-use rustc::infer::{InferCtxt, TypeOrigin};\n+use rustc::infer::{InferCtxt, InferOk, TypeOrigin};\n use syntax::codemap::Span;\n use rustc::hir;\n \n@@ -369,8 +369,12 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                        self_ty: Ty<'tcx>,\n                        method_self_ty: Ty<'tcx>)\n     {\n-        match self.fcx.mk_subty(false, TypeOrigin::Misc(self.span), self_ty, method_self_ty) {\n-            Ok(_) => {}\n+        match self.fcx.infcx().sub_types(false, TypeOrigin::Misc(self.span),\n+                                         self_ty, method_self_ty) {\n+            Ok(InferOk { obligations, .. }) => {\n+                // FIXME(#32730) propagate obligations\n+                assert!(obligations.is_empty());\n+            }\n             Err(_) => {\n                 span_bug!(\n                     self.span,\n@@ -636,9 +640,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n               target_trait_def_id: DefId)\n               -> ty::PolyTraitRef<'tcx>\n     {\n-        let upcast_trait_refs = traits::upcast(self.tcx(),\n-                                               source_trait_ref.clone(),\n-                                               target_trait_def_id);\n+        let upcast_trait_refs = self.tcx().upcast_choices(source_trait_ref.clone(),\n+                                                          target_trait_def_id);\n \n         // must be exactly one trait ref or we'd get an ambig error etc\n         if upcast_trait_refs.len() != 1 {"}, {"sha": "686d33b5e53bf557f6e45148a7ac181255238b8d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 37, "deletions": 60, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -84,14 +84,13 @@ use astconv::{self, ast_region_to_region, ast_ty_to_ty, AstConv, PathParamMode};\n use check::_match::PatCtxt;\n use dep_graph::DepNode;\n use fmt_macros::{Parser, Piece, Position};\n-use middle::astconv_util::prohibit_type_params;\n use middle::cstore::LOCAL_CRATE;\n use hir::def::{self, Def};\n use hir::def_id::DefId;\n use rustc::infer::{self, InferCtxt, InferOk, TypeOrigin, TypeTrace, type_variable};\n use hir::pat_util::{self, pat_id_map};\n use rustc::ty::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace};\n-use rustc::traits::{self, report_fulfillment_errors, ProjectionMode};\n+use rustc::traits::{self, ProjectionMode};\n use rustc::ty::{GenericPredicates, TypeScheme};\n use rustc::ty::{ParamTy, ParameterEnvironment};\n use rustc::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n@@ -1158,7 +1157,7 @@ pub fn check_representable(tcx: &TyCtxt,\n     match rty.is_representable(tcx, sp) {\n         Representability::SelfRecursive => {\n             let item_def_id = tcx.map.local_def_id(item_id);\n-            traits::recursive_type_with_infinite_size_error(tcx, item_def_id).emit();\n+            tcx.recursive_type_with_infinite_size_error(item_def_id).emit();\n             return false\n         }\n         Representability::Representable | Representability::ContainsRecursive => (),\n@@ -1803,35 +1802,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn mk_subty(&self,\n-                    a_is_expected: bool,\n-                    origin: TypeOrigin,\n-                    sub: Ty<'tcx>,\n-                    sup: Ty<'tcx>)\n-                    -> Result<(), TypeError<'tcx>> {\n-        infer::mk_subty(self.infcx(), a_is_expected, origin, sub, sup)\n-            // FIXME(#32730) propagate obligations\n-            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n-    }\n-\n-    pub fn mk_eqty(&self,\n-                   a_is_expected: bool,\n-                   origin: TypeOrigin,\n-                   sub: Ty<'tcx>,\n-                   sup: Ty<'tcx>)\n-                   -> Result<(), TypeError<'tcx>> {\n-        infer::mk_eqty(self.infcx(), a_is_expected, origin, sub, sup)\n-            // FIXME(#32730) propagate obligations\n-            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n-    }\n-\n-    pub fn mk_subr(&self,\n-                   origin: infer::SubregionOrigin<'tcx>,\n-                   sub: ty::Region,\n-                   sup: ty::Region) {\n-        infer::mk_subr(self.infcx(), origin, sub, sup)\n-    }\n-\n     pub fn type_error_message<M>(&self,\n                                  sp: Span,\n                                  mk_msg: M,\n@@ -2119,9 +2089,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             Neither => {\n                                 if let Some(default) = default_map.get(ty) {\n                                     let default = default.clone();\n-                                    match infer::mk_eqty(self.infcx(), false,\n-                                                         TypeOrigin::Misc(default.origin_span),\n-                                                         ty, default.ty) {\n+                                    match self.infcx().eq_types(false,\n+                                            TypeOrigin::Misc(default.origin_span),\n+                                            ty, default.ty) {\n                                         Ok(InferOk { obligations, .. }) => {\n                                             // FIXME(#32730) propagate obligations\n                                             assert!(obligations.is_empty())\n@@ -2215,9 +2185,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     Neither => {\n                         if let Some(default) = default_map.get(ty) {\n                             let default = default.clone();\n-                            match infer::mk_eqty(self.infcx(), false,\n-                                                 TypeOrigin::Misc(default.origin_span),\n-                                                 ty, default.ty) {\n+                            match self.infcx().eq_types(false,\n+                                    TypeOrigin::Misc(default.origin_span),\n+                                    ty, default.ty) {\n                                 // FIXME(#32730) propagate obligations\n                                 Ok(InferOk { obligations, .. }) => assert!(obligations.is_empty()),\n                                 Err(_) => {\n@@ -2239,18 +2209,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // upvar inference should have ensured that all deferred call\n         // resolutions are handled by now.\n         assert!(self.inh.deferred_call_resolutions.borrow().is_empty());\n-        let infcx = self.infcx();\n \n         self.select_all_obligations_and_apply_defaults();\n \n         let mut fulfillment_cx = self.inh.fulfillment_cx.borrow_mut();\n-        match fulfillment_cx.select_all_or_error(infcx) {\n+        match fulfillment_cx.select_all_or_error(self.infcx()) {\n             Ok(()) => { }\n-            Err(errors) => { report_fulfillment_errors(infcx, &errors); }\n+            Err(errors) => { self.infcx().report_fulfillment_errors(&errors); }\n         }\n \n-        if let Err(ref errors) = fulfillment_cx.select_rfc1592_obligations(infcx) {\n-            traits::report_fulfillment_errors_as_warnings(infcx, errors, self.body_id);\n+        if let Err(ref errors) = fulfillment_cx.select_rfc1592_obligations(self.infcx()) {\n+            self.infcx().report_fulfillment_errors_as_warnings(errors, self.body_id);\n         }\n     }\n \n@@ -2262,7 +2231,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .select_where_possible(self.infcx())\n         {\n             Ok(()) => { }\n-            Err(errors) => { report_fulfillment_errors(self.infcx(), &errors); }\n+            Err(errors) => { self.infcx().report_fulfillment_errors(&errors); }\n         }\n     }\n \n@@ -3570,16 +3539,18 @@ fn check_expr_with_expectation_and_lvalue_pref(&self,\n       hir::ExprRet(ref expr_opt) => {\n         match self.ret_ty {\n             ty::FnConverging(result_type) => {\n-                match *expr_opt {\n-                    None =>\n-                        if let Err(_) = self.mk_eqty(false, TypeOrigin::Misc(expr.span),\n-                                                     result_type, self.tcx().mk_nil()) {\n-                            span_err!(tcx.sess, expr.span, E0069,\n-                                \"`return;` in a function whose return type is \\\n-                                 not `()`\");\n-                        },\n-                    Some(ref e) => {\n-                        self.check_expr_coercable_to_type(&e, result_type);\n+                if let Some(ref e) = *expr_opt {\n+                    self.check_expr_coercable_to_type(&e, result_type);\n+                } else {\n+                    let eq_result = self.infcx().eq_types(false,\n+                                                          TypeOrigin::Misc(expr.span),\n+                                                          result_type,\n+                                                          self.tcx().mk_nil())\n+                        // FIXME(#32730) propagate obligations\n+                        .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()));\n+                    if eq_result.is_err() {\n+                        span_err!(tcx.sess, expr.span, E0069,\n+                                  \"`return;` in a function whose return type is not `()`\");\n                     }\n                 }\n             }\n@@ -4370,7 +4341,7 @@ pub fn instantiate_path(&self,\n                                                                  segment,\n                                                                  &mut substs);\n         } else {\n-            prohibit_type_params(self.tcx(), slice::ref_slice(segment));\n+            self.tcx().prohibit_type_params(slice::ref_slice(segment));\n         }\n     }\n     if let Some(self_ty) = opt_self_ty {\n@@ -4423,11 +4394,17 @@ pub fn instantiate_path(&self,\n                    impl_scheme.generics.regions.len(subst::TypeSpace));\n \n         let impl_ty = self.instantiate_type_scheme(span, &substs, &impl_scheme.ty);\n-        if self.mk_subty(false, TypeOrigin::Misc(span), self_ty, impl_ty).is_err() {\n-            span_bug!(span,\n-                \"instantiate_path: (UFCS) {:?} was a subtype of {:?} but now is not?\",\n-                self_ty,\n-                impl_ty);\n+        match self.infcx().sub_types(false, TypeOrigin::Misc(span), self_ty, impl_ty) {\n+            Ok(InferOk { obligations, .. }) => {\n+                // FIXME(#32730) propagate obligations\n+                assert!(obligations.is_empty());\n+            }\n+            Err(_) => {\n+                span_bug!(span,\n+                    \"instantiate_path: (UFCS) {:?} was a subtype of {:?} but now is not?\",\n+                    self_ty,\n+                    impl_ty);\n+            }\n         }\n     }\n "}, {"sha": "9112c3db575ea9631a1e0f262d02ee6e9989098d", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -131,8 +131,7 @@ pub fn regionck_item(&self,\n                      wf_tys: &[Ty<'tcx>]) {\n     debug!(\"regionck_item(item.id={:?}, wf_tys={:?}\", item_id, wf_tys);\n     let mut rcx = Rcx::new(self, RepeatingScope(item_id), item_id, Subject(item_id));\n-    let tcx = self.tcx();\n-    rcx.free_region_map.relate_free_regions_from_predicates(tcx,\n+    rcx.free_region_map.relate_free_regions_from_predicates(\n         &self.infcx().parameter_environment.caller_bounds);\n     rcx.relate_free_regions(wf_tys, item_id, span);\n     rcx.visit_region_obligations(item_id);\n@@ -152,8 +151,7 @@ pub fn regionck_fn(&self,\n         rcx.visit_fn_body(fn_id, decl, blk, fn_span);\n     }\n \n-    let tcx = self.tcx();\n-    rcx.free_region_map.relate_free_regions_from_predicates(tcx,\n+    rcx.free_region_map.relate_free_regions_from_predicates(\n         &self.infcx().parameter_environment.caller_bounds);\n \n     rcx.resolve_regions_and_report_errors();\n@@ -844,7 +842,7 @@ fn constrain_cast(rcx: &mut Rcx,\n             /*From:*/ (&ty::TyRef(from_r, ref from_mt),\n             /*To:  */  &ty::TyRef(to_r, ref to_mt)) => {\n                 // Target cannot outlive source, naturally.\n-                rcx.fcx.mk_subr(infer::Reborrow(cast_expr.span), *to_r, *from_r);\n+                rcx.fcx.infcx().sub_regions(infer::Reborrow(cast_expr.span), *to_r, *from_r);\n                 walk_cast(rcx, cast_expr, from_mt.ty, to_mt.ty);\n             }\n \n@@ -1038,8 +1036,8 @@ pub fn mk_subregion_due_to_dereference(rcx: &mut Rcx,\n                                        deref_span: Span,\n                                        minimum_lifetime: ty::Region,\n                                        maximum_lifetime: ty::Region) {\n-    rcx.fcx.mk_subr(infer::DerefPointer(deref_span),\n-                    minimum_lifetime, maximum_lifetime)\n+    rcx.fcx.infcx().sub_regions(infer::DerefPointer(deref_span),\n+                                minimum_lifetime, maximum_lifetime)\n }\n \n fn check_safety_of_rvalue_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n@@ -1081,8 +1079,8 @@ fn constrain_index<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n     if let ty::TyRef(r_ptr, mt) = indexed_ty.sty {\n         match mt.ty.sty {\n             ty::TySlice(_) | ty::TyStr => {\n-                rcx.fcx.mk_subr(infer::IndexSlice(index_expr.span),\n-                                r_index_expr, *r_ptr);\n+                rcx.fcx.infcx().sub_regions(infer::IndexSlice(index_expr.span),\n+                                            r_index_expr, *r_ptr);\n             }\n             _ => {}\n         }\n@@ -1410,7 +1408,7 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     debug!(\"link_reborrowed_region: {:?} <= {:?}\",\n            borrow_region,\n            ref_region);\n-    rcx.fcx.mk_subr(cause, *borrow_region, ref_region);\n+    rcx.fcx.infcx().sub_regions(cause, *borrow_region, ref_region);\n \n     // If we end up needing to recurse and establish a region link\n     // with `ref_cmt`, calculate what borrow kind we will end up\n@@ -1492,7 +1490,7 @@ pub fn substs_wf_in_scope<'a,'tcx>(rcx: &mut Rcx<'a,'tcx>,\n     let origin = infer::ParameterInScope(origin, expr_span);\n \n     for &region in &substs.regions {\n-        rcx.fcx.mk_subr(origin.clone(), expr_region, region);\n+        rcx.fcx.infcx().sub_regions(origin.clone(), expr_region, region);\n     }\n \n     for &ty in &substs.types {\n@@ -1518,7 +1516,7 @@ pub fn type_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n \n     assert!(!ty.has_escaping_regions());\n \n-    let components = ty::outlives::components(rcx.infcx(), ty);\n+    let components = rcx.infcx().outlives_components(ty);\n     components_must_outlive(rcx, origin, components, region);\n }\n \n@@ -1531,7 +1529,7 @@ fn components_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n         let origin = origin.clone();\n         match component {\n             ty::outlives::Component::Region(region1) => {\n-                rcx.fcx.mk_subr(origin, region, region1);\n+                rcx.fcx.infcx().sub_regions(origin, region, region1);\n             }\n             ty::outlives::Component::Param(param_ty) => {\n                 param_ty_must_outlive(rcx, origin, region, param_ty);\n@@ -1629,7 +1627,7 @@ fn projection_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n         }\n \n         for &r in &projection_ty.trait_ref.substs.regions {\n-            rcx.fcx.mk_subr(origin.clone(), region, r);\n+            rcx.fcx.infcx().sub_regions(origin.clone(), region, r);\n         }\n \n         return;\n@@ -1650,7 +1648,7 @@ fn projection_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                                          .any(|r| env_bounds.contains(r))\n         {\n             debug!(\"projection_must_outlive: unique declared bound appears in trait ref\");\n-            rcx.fcx.mk_subr(origin.clone(), region, unique_bound);\n+            rcx.fcx.infcx().sub_regions(origin.clone(), region, unique_bound);\n             return;\n         }\n     }\n@@ -1840,7 +1838,7 @@ fn declared_projection_bounds_from_trait<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n                        outlives);\n \n                 // check whether this predicate applies to our current projection\n-                match infer::mk_eqty(infcx, false, TypeOrigin::Misc(span), ty, outlives.0) {\n+                match infcx.eq_types(false, TypeOrigin::Misc(span), ty, outlives.0) {\n                     Ok(InferOk { obligations, .. }) => {\n                         // FIXME(#32730) propagate obligations\n                         assert!(obligations.is_empty());"}, {"sha": "c84707ecbce755a6e27be90dc66f896eb3eb29a5", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -440,28 +440,24 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n             match self.reason {\n                 ResolvingExpr(span) => {\n                     span_err!(self.tcx.sess, span, E0101,\n-                        \"cannot determine a type for this expression: {}\",\n-                        infer::fixup_err_to_string(e));\n+                        \"cannot determine a type for this expression: {}\", e);\n                 }\n \n                 ResolvingLocal(span) => {\n                     span_err!(self.tcx.sess, span, E0102,\n-                        \"cannot determine a type for this local variable: {}\",\n-                        infer::fixup_err_to_string(e));\n+                        \"cannot determine a type for this local variable: {}\", e);\n                 }\n \n                 ResolvingPattern(span) => {\n                     span_err!(self.tcx.sess, span, E0103,\n-                        \"cannot determine a type for this pattern binding: {}\",\n-                        infer::fixup_err_to_string(e));\n+                        \"cannot determine a type for this pattern binding: {}\", e);\n                 }\n \n                 ResolvingUpvar(upvar_id) => {\n                     let span = self.reason.span(self.tcx);\n                     span_err!(self.tcx.sess, span, E0104,\n                         \"cannot resolve lifetime for captured variable `{}`: {}\",\n-                        self.tcx.local_var_name_str(upvar_id.var_id).to_string(),\n-                        infer::fixup_err_to_string(e));\n+                        self.tcx.local_var_name_str(upvar_id.var_id), e);\n                 }\n \n                 ResolvingClosure(_) => {"}, {"sha": "c7e8629cdf993ca92ab28c5bf8b1683ccfe3fd87", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 30, "deletions": 33, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -46,11 +46,28 @@ mod orphan;\n mod overlap;\n mod unsafety;\n \n+struct CoherenceChecker<'a, 'tcx: 'a> {\n+    crate_context: &'a CrateCtxt<'a, 'tcx>,\n+    inference_context: InferCtxt<'a, 'tcx>,\n+    inherent_impls: RefCell<DefIdMap<Rc<RefCell<Vec<DefId>>>>>,\n+}\n+\n+struct CoherenceCheckVisitor<'a, 'tcx: 'a> {\n+    cc: &'a CoherenceChecker<'a, 'tcx>\n+}\n+\n+impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for CoherenceCheckVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &Item) {\n+        if let ItemImpl(..) = item.node {\n+            self.cc.check_implementation(item)\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n+\n // Returns the def ID of the base type, if there is one.\n-fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n-                                  span: Span,\n-                                  ty: Ty<'tcx>)\n-                                  -> Option<DefId> {\n+fn get_base_type_def_id(&self, span: Span, ty: Ty<'tcx>) -> Option<DefId> {\n     match ty.sty {\n         TyEnum(def, _) |\n         TyStruct(def, _) => {\n@@ -62,7 +79,7 @@ fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n         }\n \n         TyBox(_) => {\n-            inference_context.tcx.lang_items.owned_box()\n+            self.inference_context.tcx.lang_items.owned_box()\n         }\n \n         TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n@@ -83,25 +100,6 @@ fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n     }\n }\n \n-struct CoherenceChecker<'a, 'tcx: 'a> {\n-    crate_context: &'a CrateCtxt<'a, 'tcx>,\n-    inference_context: InferCtxt<'a, 'tcx>,\n-    inherent_impls: RefCell<DefIdMap<Rc<RefCell<Vec<DefId>>>>>,\n-}\n-\n-struct CoherenceCheckVisitor<'a, 'tcx: 'a> {\n-    cc: &'a CoherenceChecker<'a, 'tcx>\n-}\n-\n-impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for CoherenceCheckVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &Item) {\n-        if let ItemImpl(..) = item.node {\n-            self.cc.check_implementation(item)\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     fn check(&self) {\n         // Check implementations and traits. This populates the tables\n         // containing the inherent methods and extension methods. It also\n@@ -167,9 +165,8 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             // Add the implementation to the mapping from implementation to base\n             // type def ID, if there is a base type for this implementation and\n             // the implementation does not have any associated traits.\n-            if let Some(base_type_def_id) = get_base_type_def_id(\n-                    &self.inference_context, item.span, self_type.ty) {\n-                self.add_inherent_impl(base_type_def_id, impl_did);\n+            if let Some(base_def_id) = self.get_base_type_def_id(item.span, self_type.ty) {\n+                self.add_inherent_impl(base_def_id, impl_did);\n             }\n         }\n \n@@ -394,7 +391,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                 (&ty::TyBox(a), &ty::TyBox(b)) => (a, b, unsize_trait, None),\n \n                 (&ty::TyRef(r_a, mt_a), &ty::TyRef(r_b, mt_b)) => {\n-                    infer::mk_subr(&infcx, infer::RelateObjectBound(span), *r_b, *r_a);\n+                    infcx.sub_regions(infer::RelateObjectBound(span), *r_b, *r_a);\n                     check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ref(r_b, ty))\n                 }\n \n@@ -466,19 +463,19 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n             // Register an obligation for `A: Trait<B>`.\n             let cause = traits::ObligationCause::misc(span, impl_node_id);\n-            let predicate = traits::predicate_for_trait_def(tcx, cause, trait_def_id,\n-                                                            0, source, vec![target]);\n+            let predicate = tcx.predicate_for_trait_def(cause, trait_def_id, 0,\n+                                                        source, vec![target]);\n             fulfill_cx.register_predicate_obligation(&infcx, predicate);\n \n             // Check that all transitive obligations are satisfied.\n             if let Err(errors) = fulfill_cx.select_all_or_error(&infcx) {\n-                traits::report_fulfillment_errors(&infcx, &errors);\n+                infcx.report_fulfillment_errors(&errors);\n             }\n \n             // Finally, resolve all regions.\n             let mut free_regions = FreeRegionMap::new();\n-            free_regions.relate_free_regions_from_predicates(tcx, &infcx.parameter_environment\n-                                                                        .caller_bounds);\n+            free_regions.relate_free_regions_from_predicates(&infcx.parameter_environment\n+                                                                   .caller_bounds);\n             infcx.resolve_regions_and_report_errors(&free_regions, impl_node_id);\n \n             if let Some(kind) = kind {"}, {"sha": "ea87b87069431bdb2e5f7a96dee92ccf19a0f82a", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -174,7 +174,7 @@ impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                     // This is something like impl Trait1 for Trait2. Illegal\n                     // if Trait1 is a supertrait of Trait2 or Trait2 is not object safe.\n \n-                    if !traits::is_object_safe(self.tcx, data.principal_def_id()) {\n+                    if !self.tcx.is_object_safe(data.principal_def_id()) {\n                         // This is an error, but it will be\n                         // reported by wfcheck.  Ignore it\n                         // here. This is tested by"}, {"sha": "b28a7302d5f899aca961d5021a5705fc75a63776", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -201,10 +201,10 @@ fn require_same_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 -> bool\n {\n     let err = if let Some(infcx) = maybe_infcx {\n-        infer::mk_eqty(infcx, false, TypeOrigin::Misc(span), t1, t2).err()\n+        infcx.eq_types(false, TypeOrigin::Misc(span), t1, t2).err()\n     } else {\n         let infcx = InferCtxt::new(ccx.tcx, &ccx.tcx.tables, None, ProjectionMode::AnyFinal);\n-        infer::mk_eqty(&infcx, false, TypeOrigin::Misc(span), t1, t2).err()\n+        infcx.eq_types(false, TypeOrigin::Misc(span), t1, t2).err()\n     };\n \n     if let Some(ref terr) = err {"}, {"sha": "97a56e5017691acc4b6f00f80e4e91935106d2e0", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -22,7 +22,6 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::print as pprust;\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::subst;\n-use rustc::middle::stability;\n \n use rustc_const_eval::lookup_const_by_id;\n \n@@ -124,8 +123,8 @@ fn try_inline_def(cx: &DocContext, tcx: &TyCtxt,\n         attrs: load_attrs(cx, tcx, did),\n         inner: inner,\n         visibility: Some(clean::Public),\n-        stability: stability::lookup_stability(tcx, did).clean(cx),\n-        deprecation: stability::lookup_deprecation(tcx, did).clean(cx),\n+        stability: tcx.lookup_stability(did).clean(cx),\n+        deprecation: tcx.lookup_deprecation(did).clean(cx),\n         def_id: did,\n     });\n     Some(ret)\n@@ -305,8 +304,8 @@ pub fn build_impl(cx: &DocContext,\n             name: None,\n             attrs: attrs,\n             visibility: Some(clean::Inherited),\n-            stability: stability::lookup_stability(tcx, did).clean(cx),\n-            deprecation: stability::lookup_deprecation(tcx, did).clean(cx),\n+            stability: tcx.lookup_stability(did).clean(cx),\n+            deprecation: tcx.lookup_deprecation(did).clean(cx),\n             def_id: did,\n         });\n     }\n@@ -347,8 +346,8 @@ pub fn build_impl(cx: &DocContext,\n                     source: clean::Span::empty(),\n                     attrs: vec![],\n                     visibility: None,\n-                    stability: stability::lookup_stability(tcx, did).clean(cx),\n-                    deprecation: stability::lookup_deprecation(tcx, did).clean(cx),\n+                    stability: tcx.lookup_stability(did).clean(cx),\n+                    deprecation: tcx.lookup_deprecation(did).clean(cx),\n                     def_id: did\n                 })\n             }\n@@ -396,8 +395,8 @@ pub fn build_impl(cx: &DocContext,\n                     source: clean::Span::empty(),\n                     attrs: vec![],\n                     visibility: None,\n-                    stability: stability::lookup_stability(tcx, did).clean(cx),\n-                    deprecation: stability::lookup_deprecation(tcx, did).clean(cx),\n+                    stability: tcx.lookup_stability(did).clean(cx),\n+                    deprecation: tcx.lookup_deprecation(did).clean(cx),\n                     def_id: did\n                 })\n             }\n@@ -436,8 +435,8 @@ pub fn build_impl(cx: &DocContext,\n         name: None,\n         attrs: attrs,\n         visibility: Some(clean::Inherited),\n-        stability: stability::lookup_stability(tcx, did).clean(cx),\n-        deprecation: stability::lookup_deprecation(tcx, did).clean(cx),\n+        stability: tcx.lookup_stability(did).clean(cx),\n+        deprecation: tcx.lookup_deprecation(did).clean(cx),\n         def_id: did,\n     });\n }"}, {"sha": "7d8ab70a85952b8630cdffe901a7b1706593fdde", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -64,11 +64,11 @@ mod simplify;\n \n // extract the stability index for a node from tcx, if possible\n fn get_stability(cx: &DocContext, def_id: DefId) -> Option<Stability> {\n-    cx.tcx_opt().and_then(|tcx| stability::lookup_stability(tcx, def_id)).clean(cx)\n+    cx.tcx_opt().and_then(|tcx| tcx.lookup_stability(def_id)).clean(cx)\n }\n \n fn get_deprecation(cx: &DocContext, def_id: DefId) -> Option<Deprecation> {\n-    cx.tcx_opt().and_then(|tcx| stability::lookup_deprecation(tcx, def_id)).clean(cx)\n+    cx.tcx_opt().and_then(|tcx| tcx.lookup_deprecation(def_id)).clean(cx)\n }\n \n pub trait Clean<T> {\n@@ -2878,8 +2878,8 @@ impl<'tcx> Clean<Item> for ty::AssociatedType<'tcx> {\n             inner: AssociatedTypeItem(bounds, self.ty.clean(cx)),\n             visibility: self.vis.clean(cx),\n             def_id: self.def_id,\n-            stability: stability::lookup_stability(cx.tcx(), self.def_id).clean(cx),\n-            deprecation: stability::lookup_deprecation(cx.tcx(), self.def_id).clean(cx),\n+            stability: cx.tcx().lookup_stability(self.def_id).clean(cx),\n+            deprecation: cx.tcx().lookup_deprecation(self.def_id).clean(cx),\n         }\n     }\n }"}, {"sha": "d5309d7433449713940a2d1fc97735d90bad001c", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ea24edc8b663c5acbe252936aa375f1d3a944e/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=f8ea24edc8b663c5acbe252936aa375f1d3a944e", "patch": "@@ -22,7 +22,6 @@ use syntax::codemap::Span;\n \n use rustc::hir::map as hir_map;\n use rustc::hir::def::Def;\n-use rustc::middle::stability;\n use rustc::middle::privacy::AccessLevel;\n \n use rustc::hir;\n@@ -64,15 +63,15 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     fn stability(&self, id: ast::NodeId) -> Option<attr::Stability> {\n         self.cx.tcx_opt().and_then(|tcx| {\n             self.cx.map.opt_local_def_id(id)\n-                       .and_then(|def_id| stability::lookup_stability(tcx, def_id))\n+                       .and_then(|def_id| tcx.lookup_stability(def_id))\n                        .cloned()\n         })\n     }\n \n     fn deprecation(&self, id: ast::NodeId) -> Option<attr::Deprecation> {\n         self.cx.tcx_opt().and_then(|tcx| {\n             self.cx.map.opt_local_def_id(id)\n-                       .and_then(|def_id| stability::lookup_deprecation(tcx, def_id))\n+                       .and_then(|def_id| tcx.lookup_deprecation(def_id))\n         })\n     }\n "}]}