{"sha": "8dc8e72c4d68c95ef67e49370129f4b66c493add", "node_id": "C_kwDOAAsO6NoAKDhkYzhlNzJjNGQ2OGM5NWVmNjdlNDkzNzAxMjlmNGI2NmM0OTNhZGQ", "commit": {"author": {"name": "est31", "email": "MTest31@outlook.com", "date": "2021-11-18T16:21:21Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2021-11-18T17:22:19Z"}, "message": "Use more let_else in rustc_mir_build\n\nHelps avoid rightward drift.", "tree": {"sha": "ce6477a172ccac94d5a521092735438f5db07e6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce6477a172ccac94d5a521092735438f5db07e6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8dc8e72c4d68c95ef67e49370129f4b66c493add", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8dc8e72c4d68c95ef67e49370129f4b66c493add", "html_url": "https://github.com/rust-lang/rust/commit/8dc8e72c4d68c95ef67e49370129f4b66c493add", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8dc8e72c4d68c95ef67e49370129f4b66c493add/comments", "author": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6414e0b5b308d3ae27da83c6a25098cc8aadc1a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/6414e0b5b308d3ae27da83c6a25098cc8aadc1a9", "html_url": "https://github.com/rust-lang/rust/commit/6414e0b5b308d3ae27da83c6a25098cc8aadc1a9"}], "stats": {"total": 135, "additions": 66, "deletions": 69}, "files": [{"sha": "e3a05e01ea8f089a0750aa4498fb04d439d50df2", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8dc8e72c4d68c95ef67e49370129f4b66c493add/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dc8e72c4d68c95ef67e49370129f4b66c493add/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=8dc8e72c4d68c95ef67e49370129f4b66c493add", "patch": "@@ -1606,13 +1606,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // encounter a candidate where the test is not relevant; at\n         // that point, we stop sorting.\n         while let Some(candidate) = candidates.first_mut() {\n-            if let Some(idx) = self.sort_candidate(&match_place.clone(), &test, candidate) {\n-                let (candidate, rest) = candidates.split_first_mut().unwrap();\n-                target_candidates[idx].push(candidate);\n-                candidates = rest;\n-            } else {\n+            let Some(idx) = self.sort_candidate(&match_place.clone(), &test, candidate) else {\n                 break;\n-            }\n+            };\n+            let (candidate, rest) = candidates.split_first_mut().unwrap();\n+            target_candidates[idx].push(candidate);\n+            candidates = rest;\n         }\n         // at least the first candidate ought to be tested\n         assert!(total_candidate_count > candidates.len());"}, {"sha": "cb94e759972378899e45da2959035b5b0368ecc3", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 50, "deletions": 51, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/8dc8e72c4d68c95ef67e49370129f4b66c493add/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dc8e72c4d68c95ef67e49370129f4b66c493add/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=8dc8e72c4d68c95ef67e49370129f4b66c493add", "patch": "@@ -966,59 +966,58 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 DropKind::Value,\n             );\n \n-            if let Some(arg) = arg_opt {\n-                let pat = match tcx.hir().get(arg.pat.hir_id) {\n-                    Node::Pat(pat) | Node::Binding(pat) => pat,\n-                    node => bug!(\"pattern became {:?}\", node),\n-                };\n-                let pattern = pat_from_hir(tcx, self.param_env, self.typeck_results, pat);\n-                let original_source_scope = self.source_scope;\n-                let span = pattern.span;\n-                self.set_correct_source_scope_for_arg(arg.hir_id, original_source_scope, span);\n-                match *pattern.kind {\n-                    // Don't introduce extra copies for simple bindings\n-                    PatKind::Binding {\n-                        mutability,\n-                        var,\n-                        mode: BindingMode::ByValue,\n-                        subpattern: None,\n-                        ..\n-                    } => {\n-                        self.local_decls[local].mutability = mutability;\n-                        self.local_decls[local].source_info.scope = self.source_scope;\n-                        self.local_decls[local].local_info = if let Some(kind) = self_binding {\n-                            Some(Box::new(LocalInfo::User(ClearCrossCrate::Set(\n-                                BindingForm::ImplicitSelf(*kind),\n-                            ))))\n-                        } else {\n-                            let binding_mode = ty::BindingMode::BindByValue(mutability);\n-                            Some(Box::new(LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n-                                VarBindingForm {\n-                                    binding_mode,\n-                                    opt_ty_info,\n-                                    opt_match_place: Some((Some(place), span)),\n-                                    pat_span: span,\n-                                },\n-                            )))))\n-                        };\n-                        self.var_indices.insert(var, LocalsForNode::One(local));\n-                    }\n-                    _ => {\n-                        scope = self.declare_bindings(\n-                            scope,\n-                            expr.span,\n-                            &pattern,\n-                            matches::ArmHasGuard(false),\n-                            Some((Some(&place), span)),\n-                        );\n-                        let place_builder = PlaceBuilder::from(local);\n-                        unpack!(\n-                            block = self.place_into_pattern(block, pattern, place_builder, false)\n-                        );\n-                    }\n+            let Some(arg) = arg_opt else {\n+                continue;\n+            };\n+            let pat = match tcx.hir().get(arg.pat.hir_id) {\n+                Node::Pat(pat) | Node::Binding(pat) => pat,\n+                node => bug!(\"pattern became {:?}\", node),\n+            };\n+            let pattern = pat_from_hir(tcx, self.param_env, self.typeck_results, pat);\n+            let original_source_scope = self.source_scope;\n+            let span = pattern.span;\n+            self.set_correct_source_scope_for_arg(arg.hir_id, original_source_scope, span);\n+            match *pattern.kind {\n+                // Don't introduce extra copies for simple bindings\n+                PatKind::Binding {\n+                    mutability,\n+                    var,\n+                    mode: BindingMode::ByValue,\n+                    subpattern: None,\n+                    ..\n+                } => {\n+                    self.local_decls[local].mutability = mutability;\n+                    self.local_decls[local].source_info.scope = self.source_scope;\n+                    self.local_decls[local].local_info = if let Some(kind) = self_binding {\n+                        Some(Box::new(LocalInfo::User(ClearCrossCrate::Set(\n+                            BindingForm::ImplicitSelf(*kind),\n+                        ))))\n+                    } else {\n+                        let binding_mode = ty::BindingMode::BindByValue(mutability);\n+                        Some(Box::new(LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n+                            VarBindingForm {\n+                                binding_mode,\n+                                opt_ty_info,\n+                                opt_match_place: Some((Some(place), span)),\n+                                pat_span: span,\n+                            },\n+                        )))))\n+                    };\n+                    self.var_indices.insert(var, LocalsForNode::One(local));\n+                }\n+                _ => {\n+                    scope = self.declare_bindings(\n+                        scope,\n+                        expr.span,\n+                        &pattern,\n+                        matches::ArmHasGuard(false),\n+                        Some((Some(&place), span)),\n+                    );\n+                    let place_builder = PlaceBuilder::from(local);\n+                    unpack!(block = self.place_into_pattern(block, pattern, place_builder, false));\n                 }\n-                self.source_scope = original_source_scope;\n             }\n+            self.source_scope = original_source_scope;\n         }\n \n         // Enter the argument pattern bindings source scope, if it exists."}, {"sha": "7940bd1f33dc1bb35eacf2459708a02195c6d657", "filename": "compiler/rustc_mir_build/src/check_unsafety.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8dc8e72c4d68c95ef67e49370129f4b66c493add/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dc8e72c4d68c95ef67e49370129f4b66c493add/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs?ref=8dc8e72c4d68c95ef67e49370129f4b66c493add", "patch": "@@ -256,23 +256,22 @@ impl<'a, 'tcx> Visitor<'a, 'tcx> for UnsafetyVisitor<'a, 'tcx> {\n             }\n             PatKind::Binding { mode: BindingMode::ByRef(borrow_kind), ty, .. } => {\n                 if self.inside_adt {\n-                    if let ty::Ref(_, ty, _) = ty.kind() {\n-                        match borrow_kind {\n-                            BorrowKind::Shallow | BorrowKind::Shared | BorrowKind::Unique => {\n-                                if !ty.is_freeze(self.tcx.at(pat.span), self.param_env) {\n-                                    self.requires_unsafe(pat.span, BorrowOfLayoutConstrainedField);\n-                                }\n-                            }\n-                            BorrowKind::Mut { .. } => {\n-                                self.requires_unsafe(pat.span, MutationOfLayoutConstrainedField);\n-                            }\n-                        }\n-                    } else {\n+                    let ty::Ref(_, ty, _) = ty.kind() else {\n                         span_bug!(\n                             pat.span,\n                             \"BindingMode::ByRef in pattern, but found non-reference type {}\",\n                             ty\n                         );\n+                    };\n+                    match borrow_kind {\n+                        BorrowKind::Shallow | BorrowKind::Shared | BorrowKind::Unique => {\n+                            if !ty.is_freeze(self.tcx.at(pat.span), self.param_env) {\n+                                self.requires_unsafe(pat.span, BorrowOfLayoutConstrainedField);\n+                            }\n+                        }\n+                        BorrowKind::Mut { .. } => {\n+                            self.requires_unsafe(pat.span, MutationOfLayoutConstrainedField);\n+                        }\n                     }\n                 }\n                 visit::walk_pat(self, pat);"}]}