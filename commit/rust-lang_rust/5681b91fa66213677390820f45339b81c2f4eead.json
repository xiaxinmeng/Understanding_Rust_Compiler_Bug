{"sha": "5681b91fa66213677390820f45339b81c2f4eead", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2ODFiOTFmYTY2MjEzNjc3MzkwODIwZjQ1MzM5YjgxYzJmNGVlYWQ=", "commit": {"author": {"name": "Pietro Albini", "email": "pietro@pietroalbini.org", "date": "2018-12-08T11:45:13Z"}, "committer": {"name": "Pietro Albini", "email": "pietro@pietroalbini.org", "date": "2019-02-07T15:20:22Z"}, "message": "unused_imports: make the lint machine-applicable", "tree": {"sha": "6359438c3d3691af32e193bc4f86de4f54ae0d27", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6359438c3d3691af32e193bc4f86de4f54ae0d27"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5681b91fa66213677390820f45339b81c2f4eead", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2\n\niQIcBAABCAAGBQJcXEy3AAoJED4Gq+gLqvGcX1AP+wdrM3NOMHex4YlgWQYL8avo\nkwrNp4cY6mE3WROOqqXHOkyyqXHlRTj3mLryi1OgsJKroGE7VA+T30JTS8H9hcXk\nwtJ1K+2/YoWKXwvDDTxoUvZZ/TRIkFTkNSnIeE7K/v/mUChGYCAJFSzwg2tWfruO\ngTzYUEIXdvkUhpsFMuqwWIE/YT5npqOOo6+2FGiWVwKynmDR2MzdeQHhmcTxjdMW\npBlCr3oQELsLK8SuP5Bpl49FDQAsklnYFzDxCEwcS4KGuy5C7otnACbd6pYW0TDj\nGeosN2tCvuxc5P8+4BU/6IAYCiV6/el26kEpmvEF7ScRuhIggBiBQoVhcJ6XMmUL\nYGrsahqbFBgo0qef0jXkKk/uMWqQaPx4//85Y4VUwvq5tMj2v9vn2GyUm63r4PL/\ntUOnn46SuSIQP0OGLL1yLPpnuZWB0Hdkj0fes95f5H0W8LWj5lbjYmKUAlIgLaoL\nyUvc9HzzQsb0De5goSgIpxi+arZ5y4ziseZb7MAZpsW4ixI5sfxOs0LRqswO3P9P\nbr3l4WlyhS4f0PkladAQUrxGZGXzOZjLjPFr2LERMa1Z06BXNR5Dwajwe0Vr98PO\nVdUpDxCJUu5oCQubpWqzsT69xnQXkQ+Hb3yuRPwGU3UJrylTdtJ5JqYE+8P1owjB\nhdQ/yUjqqSW/N7WYEWwq\n=A1eK\n-----END PGP SIGNATURE-----", "payload": "tree 6359438c3d3691af32e193bc4f86de4f54ae0d27\nparent 626e74d5f64cdc820b6c6ac1a5a9a42096cd147a\nauthor Pietro Albini <pietro@pietroalbini.org> 1544269513 +0100\ncommitter Pietro Albini <pietro@pietroalbini.org> 1549552822 +0100\n\nunused_imports: make the lint machine-applicable\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5681b91fa66213677390820f45339b81c2f4eead", "html_url": "https://github.com/rust-lang/rust/commit/5681b91fa66213677390820f45339b81c2f4eead", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5681b91fa66213677390820f45339b81c2f4eead/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "626e74d5f64cdc820b6c6ac1a5a9a42096cd147a", "url": "https://api.github.com/repos/rust-lang/rust/commits/626e74d5f64cdc820b6c6ac1a5a9a42096cd147a", "html_url": "https://github.com/rust-lang/rust/commit/626e74d5f64cdc820b6c6ac1a5a9a42096cd147a"}], "stats": {"total": 213, "additions": 191, "deletions": 22}, "files": [{"sha": "a659f7e9b3440fef4e9bccfd77cbaa3d1a677a90", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5681b91fa66213677390820f45339b81c2f4eead/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5681b91fa66213677390820f45339b81c2f4eead/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=5681b91fa66213677390820f45339b81c2f4eead", "patch": "@@ -467,6 +467,7 @@ pub enum BuiltinLintDiagnostics {\n     MacroExpandedMacroExportsAccessedByAbsolutePaths(Span),\n     ElidedLifetimesInPaths(usize, Span, bool, Span, String),\n     UnknownCrateTypes(Span, String, String),\n+    UnusedImports(String, Vec<(Span, String)>),\n }\n \n impl BuiltinLintDiagnostics {\n@@ -548,6 +549,15 @@ impl BuiltinLintDiagnostics {\n             BuiltinLintDiagnostics::UnknownCrateTypes(span, note, sugg) => {\n                 db.span_suggestion(span, &note, sugg, Applicability::MaybeIncorrect);\n             }\n+            BuiltinLintDiagnostics::UnusedImports(message, replaces) => {\n+                if !replaces.is_empty() {\n+                    db.multipart_suggestion(\n+                        &message,\n+                        replaces,\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n         }\n     }\n }"}, {"sha": "3b6179f78558b1c10b90c2a53108656c869e0208", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 181, "deletions": 22, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/5681b91fa66213677390820f45339b81c2f4eead/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5681b91fa66213677390820f45339b81c2f4eead/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=5681b91fa66213677390820f45339b81c2f4eead", "patch": "@@ -7,23 +7,52 @@\n //\n // Unused trait imports can't be checked until the method resolution. We save\n // candidates here, and do the actual check in librustc_typeck/check_unused.rs.\n+//\n+// Checking for unused imports is split into three steps:\n+//\n+//  - `UnusedImportCheckVisitor` walks the AST to find all the unused imports\n+//    inside of `UseTree`s, recording their `NodeId`s and grouping them by\n+//    the parent `use` item\n+//\n+//  - `calc_unused_spans` then walks over all the `use` items marked in the\n+//    previous step to collect the spans associated with the `NodeId`s and to\n+//    calculate the spans that can be removed by rustfix; This is done in a\n+//    separate step to be able to collapse the adjacent spans that rustfix\n+//    will remove\n+//\n+//  - `check_crate` finally emits the diagnostics based on the data generated\n+//    in the last step\n \n use std::ops::{Deref, DerefMut};\n \n use crate::Resolver;\n use crate::resolve_imports::ImportDirectiveSubclass;\n \n-use rustc::{lint, ty};\n use rustc::util::nodemap::NodeMap;\n+use rustc::{lint, ty};\n+use rustc_data_structures::fx::FxHashSet;\n use syntax::ast;\n use syntax::visit::{self, Visitor};\n use syntax_pos::{Span, MultiSpan, DUMMY_SP};\n \n+struct UnusedImport<'a> {\n+    use_tree: &'a ast::UseTree,\n+    use_tree_id: ast::NodeId,\n+    item_span: Span,\n+    unused: FxHashSet<ast::NodeId>,\n+}\n+\n+impl<'a> UnusedImport<'a> {\n+    fn add(&mut self, id: ast::NodeId) {\n+        self.unused.insert(id);\n+    }\n+}\n \n struct UnusedImportCheckVisitor<'a, 'b: 'a> {\n     resolver: &'a mut Resolver<'b>,\n     /// All the (so far) unused imports, grouped path list\n-    unused_imports: NodeMap<NodeMap<Span>>,\n+    unused_imports: NodeMap<UnusedImport<'a>>,\n+    base_use_tree: Option<&'a ast::UseTree>,\n     base_id: ast::NodeId,\n     item_span: Span,\n }\n@@ -46,24 +75,39 @@ impl<'a, 'b> DerefMut for UnusedImportCheckVisitor<'a, 'b> {\n impl<'a, 'b> UnusedImportCheckVisitor<'a, 'b> {\n     // We have information about whether `use` (import) directives are actually\n     // used now. If an import is not used at all, we signal a lint error.\n-    fn check_import(&mut self, item_id: ast::NodeId, id: ast::NodeId, span: Span) {\n+    fn check_import(&mut self, id: ast::NodeId) {\n         let mut used = false;\n         self.per_ns(|this, ns| used |= this.used_imports.contains(&(id, ns)));\n         if !used {\n             if self.maybe_unused_trait_imports.contains(&id) {\n                 // Check later.\n                 return;\n             }\n-            self.unused_imports.entry(item_id).or_default().insert(id, span);\n+            self.unused_import(self.base_id).add(id);\n         } else {\n             // This trait import is definitely used, in a way other than\n             // method resolution.\n             self.maybe_unused_trait_imports.remove(&id);\n-            if let Some(i) = self.unused_imports.get_mut(&item_id) {\n-                i.remove(&id);\n+            if let Some(i) = self.unused_imports.get_mut(&self.base_id) {\n+                i.unused.remove(&id);\n             }\n         }\n     }\n+\n+    fn unused_import(&mut self, id: ast::NodeId) -> &mut UnusedImport<'a> {\n+        let use_tree_id = self.base_id;\n+        let use_tree = self.base_use_tree.unwrap();\n+        let item_span = self.item_span;\n+\n+        self.unused_imports\n+            .entry(id)\n+            .or_insert_with(|| UnusedImport {\n+                use_tree,\n+                use_tree_id,\n+                item_span,\n+                unused: FxHashSet::default(),\n+            })\n+    }\n }\n \n impl<'a, 'b> Visitor<'a> for UnusedImportCheckVisitor<'a, 'b> {\n@@ -88,31 +132,112 @@ impl<'a, 'b> Visitor<'a> for UnusedImportCheckVisitor<'a, 'b> {\n         // This allows the grouping of all the lints in the same item\n         if !nested {\n             self.base_id = id;\n+            self.base_use_tree = Some(use_tree);\n         }\n \n         if let ast::UseTreeKind::Nested(ref items) = use_tree.kind {\n-            // If it's the parent group, cover the entire use item\n-            let span = if nested {\n-                use_tree.span\n-            } else {\n-                self.item_span\n-            };\n-\n             if items.is_empty() {\n-                self.unused_imports\n-                    .entry(self.base_id)\n-                    .or_default()\n-                    .insert(id, span);\n+                self.unused_import(self.base_id).add(id);\n             }\n         } else {\n-            let base_id = self.base_id;\n-            self.check_import(base_id, id, use_tree.span);\n+            self.check_import(id);\n         }\n \n         visit::walk_use_tree(self, use_tree, id);\n     }\n }\n \n+enum UnusedSpanResult {\n+    Used,\n+    FlatUnused(Span, Span),\n+    NestedFullUnused(Vec<Span>, Span),\n+    NestedPartialUnused(Vec<Span>, Vec<Span>),\n+}\n+\n+fn calc_unused_spans(\n+    unused_import: &UnusedImport<'_>,\n+    use_tree: &ast::UseTree,\n+    use_tree_id: ast::NodeId,\n+) -> UnusedSpanResult {\n+    // The full span is the whole item's span if this current tree is not nested inside another\n+    // This tells rustfix to remove the whole item if all the imports are unused\n+    let full_span = if unused_import.use_tree.span == use_tree.span {\n+        unused_import.item_span\n+    } else {\n+        use_tree.span\n+    };\n+    match use_tree.kind {\n+        ast::UseTreeKind::Simple(..) | ast::UseTreeKind::Glob => {\n+            if unused_import.unused.contains(&use_tree_id) {\n+                UnusedSpanResult::FlatUnused(use_tree.span, full_span)\n+            } else {\n+                UnusedSpanResult::Used\n+            }\n+        }\n+        ast::UseTreeKind::Nested(ref nested) => {\n+            if nested.len() == 0 {\n+                return UnusedSpanResult::FlatUnused(use_tree.span, full_span);\n+            }\n+\n+            let mut unused_spans = Vec::new();\n+            let mut to_remove = Vec::new();\n+            let mut all_nested_unused = true;\n+            let mut previous_unused = false;\n+            for (pos, (use_tree, use_tree_id)) in nested.iter().enumerate() {\n+                let remove = match calc_unused_spans(unused_import, use_tree, *use_tree_id) {\n+                    UnusedSpanResult::Used => {\n+                        all_nested_unused = false;\n+                        None\n+                    }\n+                    UnusedSpanResult::FlatUnused(span, remove) => {\n+                        unused_spans.push(span);\n+                        Some(remove)\n+                    }\n+                    UnusedSpanResult::NestedFullUnused(mut spans, remove) => {\n+                        unused_spans.append(&mut spans);\n+                        Some(remove)\n+                    }\n+                    UnusedSpanResult::NestedPartialUnused(mut spans, mut to_remove_extra) => {\n+                        all_nested_unused = false;\n+                        unused_spans.append(&mut spans);\n+                        to_remove.append(&mut to_remove_extra);\n+                        None\n+                    }\n+                };\n+                if let Some(remove) = remove {\n+                    let remove_span = if nested.len() == 1 {\n+                        remove\n+                    } else if pos == nested.len() - 1 || !all_nested_unused {\n+                        // Delete everything from the end of the last import, to delete the\n+                        // previous comma\n+                        nested[pos - 1].0.span.shrink_to_hi().to(use_tree.span)\n+                    } else {\n+                        // Delete everything until the next import, to delete the trailing commas\n+                        use_tree.span.to(nested[pos + 1].0.span.shrink_to_lo())\n+                    };\n+\n+                    // Try to collapse adjacent spans into a single one. This prevents all cases of\n+                    // overlapping removals, which are not supported by rustfix\n+                    if previous_unused && !to_remove.is_empty() {\n+                        let previous = to_remove.pop().unwrap();\n+                        to_remove.push(previous.to(remove_span));\n+                    } else {\n+                        to_remove.push(remove_span);\n+                    }\n+                }\n+                previous_unused = remove.is_some();\n+            }\n+            if unused_spans.is_empty() {\n+                UnusedSpanResult::Used\n+            } else if all_nested_unused {\n+                UnusedSpanResult::NestedFullUnused(unused_spans, full_span)\n+            } else {\n+                UnusedSpanResult::NestedPartialUnused(unused_spans, to_remove)\n+            }\n+        }\n+    }\n+}\n+\n pub fn check_crate(resolver: &mut Resolver<'_>, krate: &ast::Crate) {\n     for directive in resolver.potentially_unused_imports.iter() {\n         match directive.subclass {\n@@ -152,14 +277,33 @@ pub fn check_crate(resolver: &mut Resolver<'_>, krate: &ast::Crate) {\n     let mut visitor = UnusedImportCheckVisitor {\n         resolver,\n         unused_imports: Default::default(),\n+        base_use_tree: None,\n         base_id: ast::DUMMY_NODE_ID,\n         item_span: DUMMY_SP,\n     };\n     visit::walk_crate(&mut visitor, krate);\n \n-    for (id, spans) in &visitor.unused_imports {\n+    for unused in visitor.unused_imports.values() {\n+        let mut fixes = Vec::new();\n+        let mut spans = match calc_unused_spans(unused, unused.use_tree, unused.use_tree_id) {\n+            UnusedSpanResult::Used => continue,\n+            UnusedSpanResult::FlatUnused(span, remove) => {\n+                fixes.push((remove, String::new()));\n+                vec![span]\n+            }\n+            UnusedSpanResult::NestedFullUnused(spans, remove) => {\n+                fixes.push((remove, String::new()));\n+                spans\n+            }\n+            UnusedSpanResult::NestedPartialUnused(spans, remove) => {\n+                for fix in &remove {\n+                    fixes.push((*fix, String::new()));\n+                }\n+                spans\n+            }\n+        };\n+\n         let len = spans.len();\n-        let mut spans = spans.values().cloned().collect::<Vec<Span>>();\n         spans.sort();\n         let ms = MultiSpan::from_spans(spans.clone());\n         let mut span_snippets = spans.iter()\n@@ -177,6 +321,21 @@ pub fn check_crate(resolver: &mut Resolver<'_>, krate: &ast::Crate) {\n                           } else {\n                               String::new()\n                           });\n-        visitor.session.buffer_lint(lint::builtin::UNUSED_IMPORTS, *id, ms, &msg);\n+\n+        let fix_msg = if fixes.len() == 1 && fixes[0].0 == unused.item_span {\n+            \"remove the whole `use` item\"\n+        } else if spans.len() > 1 {\n+            \"remove the unused imports\"\n+        } else {\n+            \"remove the unused import\"\n+        };\n+\n+        visitor.session.buffer_lint_with_diagnostic(\n+            lint::builtin::UNUSED_IMPORTS,\n+            unused.use_tree_id,\n+            ms,\n+            &msg,\n+            lint::builtin::BuiltinLintDiagnostics::UnusedImports(fix_msg.into(), fixes),\n+        );\n     }\n }"}]}