{"sha": "a44881d892fb4f4a8ed93f8f392bab942fac7a41", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0NDg4MWQ4OTJmYjRmNGE4ZWQ5M2Y4ZjM5MmJhYjk0MmZhYzdhNDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-16T15:35:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-16T15:35:48Z"}, "message": "Auto merge of #64510 - Centril:rollup-m03zsq8, r=Centril\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #63955 (Make sure interned constants are immutable)\n - #64028 (Stabilize `Vec::new` and `String::new` as `const fn`s)\n - #64119 (ci: ensure all tool maintainers are assignable on issues)\n - #64444 (fix building libstd without backtrace feature)\n - #64446 (Fix build script sanitizer check.)\n - #64451 (when Miri tests are not passing, do not add Miri component)\n - #64467 (Hide diagnostics emitted during --cfg parsing)\n - #64497 (Don't print the \"total\" `-Ztime-passes` output if `--prints=...` is also given)\n - #64499 (Use `Symbol` in two more functions.)\n - #64504 (use println!() instead of println!(\"\"))\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "0a4bb12a62fa76fd7946b4efec9a2b3d0cd35cc9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a4bb12a62fa76fd7946b4efec9a2b3d0cd35cc9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a44881d892fb4f4a8ed93f8f392bab942fac7a41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a44881d892fb4f4a8ed93f8f392bab942fac7a41", "html_url": "https://github.com/rust-lang/rust/commit/a44881d892fb4f4a8ed93f8f392bab942fac7a41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a44881d892fb4f4a8ed93f8f392bab942fac7a41/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16c401167366d7c6deb9268058fc5f254f9d9371", "url": "https://api.github.com/repos/rust-lang/rust/commits/16c401167366d7c6deb9268058fc5f254f9d9371", "html_url": "https://github.com/rust-lang/rust/commit/16c401167366d7c6deb9268058fc5f254f9d9371"}, {"sha": "f4ff4189ae01b6c2a775c63f24b51b708b74ec02", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4ff4189ae01b6c2a775c63f24b51b708b74ec02", "html_url": "https://github.com/rust-lang/rust/commit/f4ff4189ae01b6c2a775c63f24b51b708b74ec02"}], "stats": {"total": 725, "additions": 478, "deletions": 247}, "files": [{"sha": "77e2ce07dbc620ed533e0d7e5176a18704484f44", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -201,7 +201,9 @@ dependencies = [\n name = \"build-manifest\"\n version = \"0.1.0\"\n dependencies = [\n+ \"reqwest\",\n  \"serde\",\n+ \"serde_json\",\n  \"toml\",\n ]\n "}, {"sha": "076bcd878df7196a23fa23d0b4c617ba88850d41", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -2000,6 +2000,8 @@ impl Step for HashSign {\n     }\n \n     fn run(self, builder: &Builder<'_>) {\n+        // This gets called by `promote-release`\n+        // (https://github.com/rust-lang/rust-central-station/tree/master/promote-release).\n         let mut cmd = builder.tool_cmd(Tool::BuildManifest);\n         if builder.config.dry_run {\n             return;\n@@ -2010,10 +2012,14 @@ impl Step for HashSign {\n         let addr = builder.config.dist_upload_addr.as_ref().unwrap_or_else(|| {\n             panic!(\"\\n\\nfailed to specify `dist.upload-addr` in `config.toml`\\n\\n\")\n         });\n-        let file = builder.config.dist_gpg_password_file.as_ref().unwrap_or_else(|| {\n-            panic!(\"\\n\\nfailed to specify `dist.gpg-password-file` in `config.toml`\\n\\n\")\n-        });\n-        let pass = t!(fs::read_to_string(&file));\n+        let pass = if env::var(\"BUILD_MANIFEST_DISABLE_SIGNING\").is_err() {\n+            let file = builder.config.dist_gpg_password_file.as_ref().unwrap_or_else(|| {\n+                panic!(\"\\n\\nfailed to specify `dist.gpg-password-file` in `config.toml`\\n\\n\")\n+            });\n+            t!(fs::read_to_string(&file))\n+        } else {\n+            String::new()\n+        };\n \n         let today = output(Command::new(\"date\").arg(\"+%Y-%m-%d\"));\n "}, {"sha": "da0a899ac85ebde298be443157621ef53187244c", "filename": "src/ci/azure-pipelines/steps/run.yml", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -147,8 +147,15 @@ steps:\n     git clone --depth=1 https://github.com/rust-lang-nursery/rust-toolstate.git\n     cd rust-toolstate\n     python2.7 \"$BUILD_SOURCESDIRECTORY/src/tools/publish_toolstate.py\" \"$(git rev-parse HEAD)\" \"$(git log --format=%s -n1 HEAD)\" \"\" \"\"\n+    # Only check maintainers if this build is supposed to publish toolstate.\n+    # Builds that are not supposed to publish don't have the access token.\n+    if [ -n \"${TOOLSTATE_PUBLISH+is_set}\" ]; then\n+      TOOLSTATE_VALIDATE_MAINTAINERS_REPO=rust-lang/rust python2.7 \"${BUILD_SOURCESDIRECTORY}/src/tools/publish_toolstate.py\"\n+    fi\n     cd ..\n     rm -rf rust-toolstate\n+  env:\n+    TOOLSTATE_REPO_ACCESS_TOKEN: $(TOOLSTATE_REPO_ACCESS_TOKEN)\n   condition: and(succeeded(), not(variables.SKIP_JOB), eq(variables['IMAGE'], 'mingw-check'))\n   displayName: Verify the publish_toolstate script works\n "}, {"sha": "9e6ed92ffb567295d9a312f174838ddbcb11c48b", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -117,7 +117,7 @@\n #![feature(allocator_internals)]\n #![feature(on_unimplemented)]\n #![feature(rustc_const_unstable)]\n-#![feature(const_vec_new)]\n+#![cfg_attr(bootstrap, feature(const_vec_new))]\n #![feature(slice_partition_dedup)]\n #![feature(maybe_uninit_extra, maybe_uninit_slice)]\n #![feature(alloc_layout_extra)]"}, {"sha": "ee75fc288fee5b7a380b071944c6affc2825103a", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -113,13 +113,38 @@ impl<T, A: Alloc> RawVec<T, A> {\n }\n \n impl<T> RawVec<T, Global> {\n+    /// HACK(Centril): This exists because `#[unstable]` `const fn`s needn't conform\n+    /// to `min_const_fn` and so they cannot be called in `min_const_fn`s either.\n+    ///\n+    /// If you change `RawVec<T>::new` or dependencies, please take care to not\n+    /// introduce anything that would truly violate `min_const_fn`.\n+    ///\n+    /// NOTE: We could avoid this hack and check conformance with some\n+    /// `#[rustc_force_min_const_fn]` attribute which requires conformance\n+    /// with `min_const_fn` but does not necessarily allow calling it in\n+    /// `stable(...) const fn` / user code not enabling `foo` when\n+    /// `#[rustc_const_unstable(feature = \"foo\", ..)]` is present.\n+    pub const NEW: Self = Self::new();\n+\n     /// Creates the biggest possible `RawVec` (on the system heap)\n     /// without allocating. If `T` has positive size, then this makes a\n     /// `RawVec` with capacity `0`. If `T` is zero-sized, then it makes a\n     /// `RawVec` with capacity `usize::MAX`. Useful for implementing\n     /// delayed allocation.\n     pub const fn new() -> Self {\n-        Self::new_in(Global)\n+        // FIXME(Centril): Reintegrate this with `fn new_in` when we can.\n+\n+        // `!0` is `usize::MAX`. This branch should be stripped at compile time.\n+        // FIXME(mark-i-m): use this line when `if`s are allowed in `const`:\n+        //let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };\n+\n+        // `Unique::empty()` doubles as \"unallocated\" and \"zero-sized allocation\".\n+        RawVec {\n+            ptr: Unique::empty(),\n+            // FIXME(mark-i-m): use `cap` when ifs are allowed in const\n+            cap: [0, !0][(mem::size_of::<T>() == 0) as usize],\n+            a: Global,\n+        }\n     }\n \n     /// Creates a `RawVec` (on the system heap) with exactly the"}, {"sha": "1166e7b5df2959bb3d6d64af27e56b193a898045", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -369,7 +369,7 @@ impl String {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_string_new\")]\n+    #[cfg_attr(bootstrap, rustc_const_unstable(feature = \"const_string_new\"))]\n     pub const fn new() -> String {\n         String { vec: Vec::new() }\n     }"}, {"sha": "405969a550b88121395350ff4d70d9e4a570bfd8", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -314,10 +314,10 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_vec_new\")]\n+    #[cfg_attr(bootstrap, rustc_const_unstable(feature = \"const_vec_new\"))]\n     pub const fn new() -> Vec<T> {\n         Vec {\n-            buf: RawVec::new(),\n+            buf: RawVec::NEW,\n             len: 0,\n         }\n     }"}, {"sha": "723855c7c29cf11b03f572dfef7a99b7b74e95e7", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -7,6 +7,7 @@ use crate::session::{early_error, early_warn, Session};\n use crate::session::search_paths::SearchPath;\n \n use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::sync::Lrc;\n \n use rustc_target::spec::{LinkerFlavor, MergeFunctions, PanicStrategy, RelroLevel};\n use rustc_target::spec::{Target, TargetTriple};\n@@ -19,6 +20,7 @@ use syntax::parse::{ParseSess, new_parser_from_source_str};\n use syntax::parse::token;\n use syntax::symbol::{sym, Symbol};\n use syntax::feature_gate::UnstableFeatures;\n+use syntax::source_map::SourceMap;\n \n use errors::emitter::HumanReadableErrorType;\n use errors::{ColorConfig, FatalError, Handler};\n@@ -1850,11 +1852,20 @@ pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n     opts\n }\n \n+struct NullEmitter;\n+\n+impl errors::emitter::Emitter for NullEmitter {\n+    fn emit_diagnostic(&mut self, _: &errors::DiagnosticBuilder<'_>) {}\n+}\n+\n // Converts strings provided as `--cfg [cfgspec]` into a `crate_cfg`.\n pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> FxHashSet<(String, Option<String>)> {\n     syntax::with_default_globals(move || {\n         let cfg = cfgspecs.into_iter().map(|s| {\n-            let sess = ParseSess::new(FilePathMapping::empty());\n+\n+            let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+            let handler = Handler::with_emitter(false, None, Box::new(NullEmitter));\n+            let sess = ParseSess::with_span_handler(handler, cm);\n             let filename = FileName::cfg_spec_source_code(&s);\n             let mut parser = new_parser_from_source_str(&sess, filename, s.to_string());\n "}, {"sha": "645707ccc03388efebfbee407ef4411cf96ba0fe", "filename": "src/librustc_asan/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Flibrustc_asan%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Flibrustc_asan%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_asan%2Fbuild.rs?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -4,6 +4,7 @@ use build_helper::sanitizer_lib_boilerplate;\n use cmake::Config;\n \n fn main() {\n+    println!(\"cargo:rerun-if-env-changed=RUSTC_BUILD_SANITIZERS\");\n     if env::var(\"RUSTC_BUILD_SANITIZERS\") != Ok(\"1\".to_string()) {\n         return;\n     }"}, {"sha": "34e39af3c39fcda98ca756257ee78f3dfd9ea24f", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -226,21 +226,21 @@ impl CodegenBackend for LlvmCodegenBackend {\n                 for &(name, _) in back::write::RELOC_MODEL_ARGS.iter() {\n                     println!(\"    {}\", name);\n                 }\n-                println!(\"\");\n+                println!();\n             }\n             PrintRequest::CodeModels => {\n                 println!(\"Available code models:\");\n                 for &(name, _) in back::write::CODE_GEN_MODEL_ARGS.iter(){\n                     println!(\"    {}\", name);\n                 }\n-                println!(\"\");\n+                println!();\n             }\n             PrintRequest::TlsModels => {\n                 println!(\"Available TLS models:\");\n                 for &(name, _) in back::write::TLS_MODEL_ARGS.iter(){\n                     println!(\"    {}\", name);\n                 }\n-                println!(\"\");\n+                println!();\n             }\n             req => llvm_util::print(req, sess),\n         }"}, {"sha": "8c5d8536c32fa7bc1ebf2cc732ec22febf635ec5", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -134,8 +134,11 @@ pub struct TimePassesCallbacks {\n \n impl Callbacks for TimePassesCallbacks {\n     fn config(&mut self, config: &mut interface::Config) {\n+        // If a --prints=... option has been given, we don't print the \"total\"\n+        // time because it will mess up the --prints output. See #64339.\n         self.time_passes =\n-            config.opts.debugging_opts.time_passes || config.opts.debugging_opts.time;\n+            config.opts.prints.is_empty() &&\n+            (config.opts.debugging_opts.time_passes || config.opts.debugging_opts.time);\n     }\n }\n "}, {"sha": "73720d8c2d64ec32b65855c84edfc2cbf240a6b7", "filename": "src/librustc_lsan/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Flibrustc_lsan%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Flibrustc_lsan%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lsan%2Fbuild.rs?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -4,6 +4,7 @@ use build_helper::sanitizer_lib_boilerplate;\n use cmake::Config;\n \n fn main() {\n+    println!(\"cargo:rerun-if-env-changed=RUSTC_BUILD_SANITIZERS\");\n     if env::var(\"RUSTC_BUILD_SANITIZERS\") != Ok(\"1\".to_string()) {\n         return;\n     }"}, {"sha": "3f53f842f314f830ead99690074e4cc70873a653", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -134,9 +134,8 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     ecx: &mut CompileTimeEvalContext<'mir, 'tcx>,\n     cid: GlobalId<'tcx>,\n     body: &'mir mir::Body<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n ) -> InterpResult<'tcx, MPlaceTy<'tcx>> {\n-    debug!(\"eval_body_using_ecx: {:?}, {:?}\", cid, param_env);\n+    debug!(\"eval_body_using_ecx: {:?}, {:?}\", cid, ecx.param_env);\n     let tcx = ecx.tcx.tcx;\n     let layout = ecx.layout_of(body.return_ty().subst(tcx, cid.instance.substs))?;\n     assert!(!layout.is_unsized());\n@@ -162,7 +161,6 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n         ecx,\n         cid.instance.def_id(),\n         ret,\n-        param_env,\n     )?;\n \n     debug!(\"eval_body_using_ecx done: {:?}\", *ret);\n@@ -658,7 +656,7 @@ pub fn const_eval_raw_provider<'tcx>(\n \n     let res = ecx.load_mir(cid.instance.def, cid.promoted);\n     res.and_then(\n-        |body| eval_body_using_ecx(&mut ecx, cid, body, key.param_env)\n+        |body| eval_body_using_ecx(&mut ecx, cid, body)\n     ).and_then(|place| {\n         Ok(RawConst {\n             alloc_id: place.ptr.assert_ptr().alloc_id,"}, {"sha": "95647ce642c5b6a5f9ec218da548805849ab1bc5", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 145, "deletions": 116, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -3,40 +3,37 @@\n //! After a const evaluation has computed a value, before we destroy the const evaluator's session\n //! memory, we need to extract all memory allocations to the global memory pool so they stay around.\n \n-use rustc::ty::{Ty, TyCtxt, ParamEnv, self};\n+use rustc::ty::{Ty, self};\n use rustc::mir::interpret::{InterpResult, ErrorHandled};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use super::validity::RefTracking;\n use rustc_data_structures::fx::FxHashSet;\n \n use syntax::ast::Mutability;\n-use syntax_pos::Span;\n \n use super::{\n-    ValueVisitor, MemoryKind, Pointer, AllocId, MPlaceTy, Scalar,\n+    ValueVisitor, MemoryKind, AllocId, MPlaceTy, Scalar,\n };\n use crate::const_eval::{CompileTimeInterpreter, CompileTimeEvalContext};\n \n struct InternVisitor<'rt, 'mir, 'tcx> {\n-    /// previously encountered safe references\n-    ref_tracking: &'rt mut RefTracking<(MPlaceTy<'tcx>, Mutability, InternMode)>,\n+    /// The ectx from which we intern.\n     ecx: &'rt mut CompileTimeEvalContext<'mir, 'tcx>,\n-    param_env: ParamEnv<'tcx>,\n+    /// Previously encountered safe references.\n+    ref_tracking: &'rt mut RefTracking<(MPlaceTy<'tcx>, Mutability, InternMode)>,\n+    /// A list of all encountered allocations. After type-based interning, we traverse this list to\n+    /// also intern allocations that are only referenced by a raw pointer or inside a union.\n+    leftover_allocations: &'rt mut FxHashSet<AllocId>,\n     /// The root node of the value that we're looking at. This field is never mutated and only used\n     /// for sanity assertions that will ICE when `const_qualif` screws up.\n     mode: InternMode,\n     /// This field stores the mutability of the value *currently* being checked.\n-    /// It is set to mutable when an `UnsafeCell` is encountered\n-    /// When recursing across a reference, we don't recurse but store the\n-    /// value to be checked in `ref_tracking` together with the mutability at which we are checking\n-    /// the value.\n-    /// When encountering an immutable reference, we treat everything as immutable that is behind\n-    /// it.\n+    /// When encountering a mutable reference, we determine the pointee mutability\n+    /// taking into account the mutability of the context: `& &mut i32` is entirely immutable,\n+    /// despite the nested mutable reference!\n+    /// The field gets updated when an `UnsafeCell` is encountered.\n     mutability: Mutability,\n-    /// A list of all encountered relocations. After type-based interning, we traverse this list to\n-    /// also intern allocations that are only referenced by a raw pointer or inside a union.\n-    leftover_relocations: &'rt mut FxHashSet<AllocId>,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Hash, Eq)]\n@@ -45,58 +42,111 @@ enum InternMode {\n     /// `static`. In a `static mut` we start out as mutable and thus can also contain further `&mut`\n     /// that will actually be treated as mutable.\n     Static,\n-    /// UnsafeCell is OK in the value of a constant, but not behind references in a constant\n+    /// UnsafeCell is OK in the value of a constant: `const FOO = Cell::new(0)` creates\n+    /// a new cell every time it is used.\n     ConstBase,\n-    /// `UnsafeCell` ICEs\n+    /// `UnsafeCell` ICEs.\n     Const,\n }\n \n /// Signalling data structure to ensure we don't recurse\n /// into the memory of other constants or statics\n struct IsStaticOrFn;\n \n+/// Intern an allocation without looking at its children.\n+/// `mode` is the mode of the environment where we found this pointer.\n+/// `mutablity` is the mutability of the place to be interned; even if that says\n+/// `immutable` things might become mutable if `ty` is not frozen.\n+/// `ty` can be `None` if there is no potential interior mutability\n+/// to account for (e.g. for vtables).\n+fn intern_shallow<'rt, 'mir, 'tcx>(\n+    ecx: &'rt mut CompileTimeEvalContext<'mir, 'tcx>,\n+    leftover_allocations: &'rt mut FxHashSet<AllocId>,\n+    mode: InternMode,\n+    alloc_id: AllocId,\n+    mutability: Mutability,\n+    ty: Option<Ty<'tcx>>,\n+) -> InterpResult<'tcx, Option<IsStaticOrFn>> {\n+    trace!(\n+        \"InternVisitor::intern {:?} with {:?}\",\n+        alloc_id, mutability,\n+    );\n+    // remove allocation\n+    let tcx = ecx.tcx;\n+    let memory = ecx.memory_mut();\n+    let (kind, mut alloc) = match memory.alloc_map.remove(&alloc_id) {\n+        Some(entry) => entry,\n+        None => {\n+            // Pointer not found in local memory map. It is either a pointer to the global\n+            // map, or dangling.\n+            // If the pointer is dangling (neither in local nor global memory), we leave it\n+            // to validation to error. The `delay_span_bug` ensures that we don't forget such\n+            // a check in validation.\n+            if tcx.alloc_map.lock().get(alloc_id).is_none() {\n+                tcx.sess.delay_span_bug(ecx.tcx.span, \"tried to intern dangling pointer\");\n+            }\n+            // treat dangling pointers like other statics\n+            // just to stop trying to recurse into them\n+            return Ok(Some(IsStaticOrFn));\n+        },\n+    };\n+    // This match is just a canary for future changes to `MemoryKind`, which most likely need\n+    // changes in this function.\n+    match kind {\n+        MemoryKind::Stack | MemoryKind::Vtable => {},\n+    }\n+    // Set allocation mutability as appropriate. This is used by LLVM to put things into\n+    // read-only memory, and also by Miri when evluating other constants/statics that\n+    // access this one.\n+    if mode == InternMode::Static {\n+        // When `ty` is `None`, we assume no interior mutability.\n+        let frozen = ty.map_or(true, |ty| ty.is_freeze(\n+            ecx.tcx.tcx,\n+            ecx.param_env,\n+            ecx.tcx.span,\n+        ));\n+        // For statics, allocation mutability is the combination of the place mutability and\n+        // the type mutability.\n+        // The entire allocation needs to be mutable if it contains an `UnsafeCell` anywhere.\n+        if mutability == Mutability::Immutable && frozen {\n+            alloc.mutability = Mutability::Immutable;\n+        } else {\n+            // Just making sure we are not \"upgrading\" an immutable allocation to mutable.\n+            assert_eq!(alloc.mutability, Mutability::Mutable);\n+        }\n+    } else {\n+        // We *could* be non-frozen at `ConstBase`, for constants like `Cell::new(0)`.\n+        // But we still intern that as immutable as the memory cannot be changed once the\n+        // initial value was computed.\n+        // Constants are never mutable.\n+        assert_eq!(\n+            mutability, Mutability::Immutable,\n+            \"Something went very wrong: mutability requested for a constant\"\n+        );\n+        alloc.mutability = Mutability::Immutable;\n+    };\n+    // link the alloc id to the actual allocation\n+    let alloc = tcx.intern_const_alloc(alloc);\n+    leftover_allocations.extend(alloc.relocations().iter().map(|&(_, ((), reloc))| reloc));\n+    tcx.alloc_map.lock().set_alloc_id_memory(alloc_id, alloc);\n+    Ok(None)\n+}\n+\n impl<'rt, 'mir, 'tcx> InternVisitor<'rt, 'mir, 'tcx> {\n-    /// Intern an allocation without looking at its children\n     fn intern_shallow(\n         &mut self,\n-        ptr: Pointer,\n+        alloc_id: AllocId,\n         mutability: Mutability,\n+        ty: Option<Ty<'tcx>>,\n     ) -> InterpResult<'tcx, Option<IsStaticOrFn>> {\n-        trace!(\n-            \"InternVisitor::intern {:?} with {:?}\",\n-            ptr, mutability,\n-        );\n-        // remove allocation\n-        let tcx = self.ecx.tcx;\n-        let memory = self.ecx.memory_mut();\n-        let (kind, mut alloc) = match memory.alloc_map.remove(&ptr.alloc_id) {\n-            Some(entry) => entry,\n-            None => {\n-                // if the pointer is dangling (neither in local nor global memory), we leave it\n-                // to validation to error. The `delay_span_bug` ensures that we don't forget such\n-                // a check in validation.\n-                if tcx.alloc_map.lock().get(ptr.alloc_id).is_none() {\n-                    tcx.sess.delay_span_bug(self.ecx.tcx.span, \"tried to intern dangling pointer\");\n-                }\n-                // treat dangling pointers like other statics\n-                // just to stop trying to recurse into them\n-                return Ok(Some(IsStaticOrFn));\n-            },\n-        };\n-        // This match is just a canary for future changes to `MemoryKind`, which most likely need\n-        // changes in this function.\n-        match kind {\n-            MemoryKind::Stack | MemoryKind::Vtable => {},\n-        }\n-        // Ensure llvm knows to only put this into immutable memory if the value is immutable either\n-        // by being behind a reference or by being part of a static or const without interior\n-        // mutability\n-        alloc.mutability = mutability;\n-        // link the alloc id to the actual allocation\n-        let alloc = tcx.intern_const_alloc(alloc);\n-        self.leftover_relocations.extend(alloc.relocations().iter().map(|&(_, ((), reloc))| reloc));\n-        tcx.alloc_map.lock().set_alloc_id_memory(ptr.alloc_id, alloc);\n-        Ok(None)\n+        intern_shallow(\n+            self.ecx,\n+            self.leftover_allocations,\n+            self.mode,\n+            alloc_id,\n+            mutability,\n+            ty,\n+        )\n     }\n }\n \n@@ -119,14 +169,16 @@ for\n     ) -> InterpResult<'tcx> {\n         if let Some(def) = mplace.layout.ty.ty_adt_def() {\n             if Some(def.did) == self.ecx.tcx.lang_items().unsafe_cell_type() {\n-                // We are crossing over an `UnsafeCell`, we can mutate again\n+                // We are crossing over an `UnsafeCell`, we can mutate again. This means that\n+                // References we encounter inside here are interned as pointing to mutable\n+                // allocations.\n                 let old = std::mem::replace(&mut self.mutability, Mutability::Mutable);\n                 assert_ne!(\n                     self.mode, InternMode::Const,\n                     \"UnsafeCells are not allowed behind references in constants. This should have \\\n                     been prevented statically by const qualification. If this were allowed one \\\n-                    would be able to change a constant at one use site and other use sites may \\\n-                    arbitrarily decide to change, too.\",\n+                    would be able to change a constant at one use site and other use sites could \\\n+                    observe that mutation.\",\n                 );\n                 let walked = self.walk_aggregate(mplace, fields);\n                 self.mutability = old;\n@@ -145,12 +197,13 @@ for\n             // Handle trait object vtables\n             if let Ok(meta) = value.to_meta() {\n                 if let ty::Dynamic(..) =\n-                    self.ecx.tcx.struct_tail_erasing_lifetimes(referenced_ty, self.param_env).sty\n+                    self.ecx.tcx.struct_tail_erasing_lifetimes(\n+                        referenced_ty, self.ecx.param_env).sty\n                 {\n                     if let Ok(vtable) = meta.unwrap().to_ptr() {\n                         // explitly choose `Immutable` here, since vtables are immutable, even\n                         // if the reference of the fat pointer is mutable\n-                        self.intern_shallow(vtable, Mutability::Immutable)?;\n+                        self.intern_shallow(vtable.alloc_id, Mutability::Immutable, None)?;\n                     }\n                 }\n             }\n@@ -177,7 +230,7 @@ for\n                     (InternMode::Const, hir::Mutability::MutMutable) => {\n                         match referenced_ty.sty {\n                             ty::Array(_, n)\n-                                if n.eval_usize(self.ecx.tcx.tcx, self.param_env) == 0 => {}\n+                                if n.eval_usize(self.ecx.tcx.tcx, self.ecx.param_env) == 0 => {}\n                             ty::Slice(_)\n                                 if value.to_meta().unwrap().unwrap().to_usize(self.ecx)? == 0 => {}\n                             _ => bug!(\"const qualif failed to prevent mutable references\"),\n@@ -195,21 +248,13 @@ for\n                     (Mutability::Mutable, hir::Mutability::MutMutable) => Mutability::Mutable,\n                     _ => Mutability::Immutable,\n                 };\n-                // Compute the mutability of the allocation\n-                let intern_mutability = intern_mutability(\n-                    self.ecx.tcx.tcx,\n-                    self.param_env,\n-                    mplace.layout.ty,\n-                    self.ecx.tcx.span,\n-                    mutability,\n-                );\n                 // Recursing behind references changes the intern mode for constants in order to\n                 // cause assertions to trigger if we encounter any `UnsafeCell`s.\n                 let mode = match self.mode {\n                     InternMode::ConstBase => InternMode::Const,\n                     other => other,\n                 };\n-                match self.intern_shallow(ptr, intern_mutability)? {\n+                match self.intern_shallow(ptr.alloc_id, mutability, Some(mplace.layout.ty))? {\n                     // No need to recurse, these are interned already and statics may have\n                     // cycles, so we don't want to recurse there\n                     Some(IsStaticOrFn) => {},\n@@ -224,69 +269,45 @@ for\n     }\n }\n \n-/// Figure out the mutability of the allocation.\n-/// Mutable if it has interior mutability *anywhere* in the type.\n-fn intern_mutability<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ParamEnv<'tcx>,\n-    ty: Ty<'tcx>,\n-    span: Span,\n-    mutability: Mutability,\n-) -> Mutability {\n-    let has_interior_mutability = !ty.is_freeze(tcx, param_env, span);\n-    if has_interior_mutability {\n-        Mutability::Mutable\n-    } else {\n-        mutability\n-    }\n-}\n-\n pub fn intern_const_alloc_recursive(\n     ecx: &mut CompileTimeEvalContext<'mir, 'tcx>,\n     def_id: DefId,\n     ret: MPlaceTy<'tcx>,\n-    // FIXME(oli-obk): can we scrap the param env? I think we can, the final value of a const eval\n-    // must always be monomorphic, right?\n-    param_env: ty::ParamEnv<'tcx>,\n ) -> InterpResult<'tcx> {\n     let tcx = ecx.tcx;\n     // this `mutability` is the mutability of the place, ignoring the type\n-    let (mutability, base_intern_mode) = match tcx.static_mutability(def_id) {\n+    let (base_mutability, base_intern_mode) = match tcx.static_mutability(def_id) {\n         Some(hir::Mutability::MutImmutable) => (Mutability::Immutable, InternMode::Static),\n-        None => (Mutability::Immutable, InternMode::ConstBase),\n         // `static mut` doesn't care about interior mutability, it's mutable anyway\n         Some(hir::Mutability::MutMutable) => (Mutability::Mutable, InternMode::Static),\n+        // consts, promoteds. FIXME: what about array lengths, array initializers?\n+        None => (Mutability::Immutable, InternMode::ConstBase),\n     };\n \n-    // type based interning\n-    let mut ref_tracking = RefTracking::new((ret, mutability, base_intern_mode));\n-    let leftover_relocations = &mut FxHashSet::default();\n-\n-    // This mutability is the combination of the place mutability and the type mutability. If either\n-    // is mutable, `alloc_mutability` is mutable. This exists because the entire allocation needs\n-    // to be mutable if it contains an `UnsafeCell` anywhere. The other `mutability` exists so that\n-    // the visitor does not treat everything outside the `UnsafeCell` as mutable.\n-    let alloc_mutability = intern_mutability(\n-        tcx.tcx, param_env, ret.layout.ty, tcx.span, mutability,\n-    );\n+    // Type based interning.\n+    // `ref_tracking` tracks typed references we have seen and still need to crawl for\n+    // more typed information inside them.\n+    // `leftover_allocations` collects *all* allocations we see, because some might not\n+    // be available in a typed way. They get interned at the end.\n+    let mut ref_tracking = RefTracking::new((ret, base_mutability, base_intern_mode));\n+    let leftover_allocations = &mut FxHashSet::default();\n \n     // start with the outermost allocation\n-    InternVisitor {\n-        ref_tracking: &mut ref_tracking,\n+    intern_shallow(\n         ecx,\n-        mode: base_intern_mode,\n-        leftover_relocations,\n-        param_env,\n-        mutability,\n-    }.intern_shallow(ret.ptr.to_ptr()?, alloc_mutability)?;\n+        leftover_allocations,\n+        base_intern_mode,\n+        ret.ptr.to_ptr()?.alloc_id,\n+        base_mutability,\n+        Some(ret.layout.ty)\n+    )?;\n \n     while let Some(((mplace, mutability, mode), _)) = ref_tracking.todo.pop() {\n         let interned = InternVisitor {\n             ref_tracking: &mut ref_tracking,\n             ecx,\n             mode,\n-            leftover_relocations,\n-            param_env,\n+            leftover_allocations,\n             mutability,\n         }.visit_value(mplace);\n         if let Err(error) = interned {\n@@ -309,15 +330,23 @@ pub fn intern_const_alloc_recursive(\n     // Intern the rest of the allocations as mutable. These might be inside unions, padding, raw\n     // pointers, ... So we can't intern them according to their type rules\n \n-    let mut todo: Vec<_> = leftover_relocations.iter().cloned().collect();\n+    let mut todo: Vec<_> = leftover_allocations.iter().cloned().collect();\n     while let Some(alloc_id) = todo.pop() {\n-        if let Some((_, alloc)) = ecx.memory_mut().alloc_map.remove(&alloc_id) {\n-            // We can't call the `intern` method here, as its logic is tailored to safe references.\n-            // So we hand-roll the interning logic here again\n+        if let Some((_, mut alloc)) = ecx.memory_mut().alloc_map.remove(&alloc_id) {\n+            // We can't call the `intern_shallow` method here, as its logic is tailored to safe\n+            // references and a `leftover_allocations` set (where we only have a todo-list here).\n+            // So we hand-roll the interning logic here again.\n+            if base_intern_mode != InternMode::Static {\n+                // If it's not a static, it *must* be immutable.\n+                // We cannot have mutable memory inside a constant.\n+                // FIXME: ideally we would assert that they already are immutable, to double-\n+                // check our static checks.\n+                alloc.mutability = Mutability::Immutable;\n+            }\n             let alloc = tcx.intern_const_alloc(alloc);\n             tcx.alloc_map.lock().set_alloc_id_memory(alloc_id, alloc);\n             for &(_, ((), reloc)) in alloc.relocations().iter() {\n-                if leftover_relocations.insert(reloc) {\n+                if leftover_allocations.insert(reloc) {\n                     todo.push(reloc);\n                 }\n             }"}, {"sha": "a81786ee36d04e946f486a1d02504d72d1a4ab6d", "filename": "src/librustc_msan/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Flibrustc_msan%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Flibrustc_msan%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_msan%2Fbuild.rs?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -4,6 +4,7 @@ use build_helper::sanitizer_lib_boilerplate;\n use cmake::Config;\n \n fn main() {\n+    println!(\"cargo:rerun-if-env-changed=RUSTC_BUILD_SANITIZERS\");\n     if env::var(\"RUSTC_BUILD_SANITIZERS\") != Ok(\"1\".to_string()) {\n         return;\n     }"}, {"sha": "f9333e15023277832c69de2aa524f2357734a39a", "filename": "src/librustc_tsan/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Flibrustc_tsan%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Flibrustc_tsan%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_tsan%2Fbuild.rs?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -4,6 +4,7 @@ use build_helper::sanitizer_lib_boilerplate;\n use cmake::Config;\n \n fn main() {\n+    println!(\"cargo:rerun-if-env-changed=RUSTC_BUILD_SANITIZERS\");\n     if env::var(\"RUSTC_BUILD_SANITIZERS\") != Ok(\"1\".to_string()) {\n         return;\n     }"}, {"sha": "af1d2402f88e72fafb4924ae09ab3e4fa080e2bb", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -25,17 +25,11 @@ profiler_builtins = { path = \"../libprofiler_builtins\", optional = true }\n unwind = { path = \"../libunwind\" }\n hashbrown = { version = \"0.5.0\", features = ['rustc-dep-of-std'] }\n \n-[dependencies.backtrace]\n+[dependencies.backtrace_rs]\n+package = \"backtrace\"\n version = \"0.3.37\"\n-default-features = false # don't use coresymbolication on OSX\n-features = [\n-  \"rustc-dep-of-std\", # enable build support for integrating into libstd\n-  \"dbghelp\",          # backtrace/symbolize on MSVC\n-  \"libbacktrace\",     # symbolize on most platforms\n-  \"libunwind\",        # backtrace on most platforms\n-  \"dladdr\",           # symbolize on platforms w/o libbacktrace\n-]\n-optional = true\n+default-features = false # without the libstd `backtrace` feature, stub out everything\n+features = [ \"rustc-dep-of-std\" ] # enable build support for integrating into libstd\n \n [dev-dependencies]\n rand = \"0.7\"\n@@ -65,6 +59,13 @@ cc = \"1.0\"\n [features]\n default = [\"std_detect_file_io\", \"std_detect_dlsym_getauxval\"]\n \n+backtrace = [\n+  \"backtrace_rs/dbghelp\",          # backtrace/symbolize on MSVC\n+  \"backtrace_rs/libbacktrace\",     # symbolize on most platforms\n+  \"backtrace_rs/libunwind\",        # backtrace on most platforms\n+  \"backtrace_rs/dladdr\",           # symbolize on platforms w/o libbacktrace\n+]\n+\n panic-unwind = [\"panic_unwind\"]\n profiler = [\"profiler_builtins\"]\n compiler-builtins-c = [\"alloc/compiler-builtins-c\"]"}, {"sha": "61c42a56071e6a277a69ebc262c10e584cccaa5e", "filename": "src/libstd/backtrace.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Flibstd%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Flibstd%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbacktrace.rs?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -97,6 +97,7 @@ use crate::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n use crate::sync::Mutex;\n use crate::sys_common::backtrace::{output_filename, lock};\n use crate::vec::Vec;\n+use backtrace_rs as backtrace;\n use backtrace::BytesOrWideString;\n \n /// A captured OS thread stack backtrace."}, {"sha": "28fb40244043e5aa46e534b9b3a1131060d9b66a", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -17,8 +17,7 @@ use crate::ptr;\n use crate::raw;\n use crate::sys::stdio::panic_output;\n use crate::sys_common::rwlock::RWLock;\n-use crate::sys_common::thread_info;\n-use crate::sys_common::util;\n+use crate::sys_common::{thread_info, util, backtrace};\n use crate::thread;\n \n #[cfg(not(test))]\n@@ -157,20 +156,18 @@ pub fn take_hook() -> Box<dyn Fn(&PanicInfo<'_>) + 'static + Sync + Send> {\n }\n \n fn default_hook(info: &PanicInfo<'_>) {\n-    #[cfg(feature = \"backtrace\")]\n-    use crate::sys_common::{backtrace as backtrace_mod};\n-\n     // If this is a double panic, make sure that we print a backtrace\n     // for this panic. Otherwise only print it if logging is enabled.\n-    #[cfg(feature = \"backtrace\")]\n-    let log_backtrace = {\n+    let log_backtrace = if cfg!(feature = \"backtrace\") {\n         let panics = update_panic_count(0);\n \n         if panics >= 2 {\n-            Some(backtrace::PrintFmt::Full)\n+            Some(backtrace_rs::PrintFmt::Full)\n         } else {\n-            backtrace_mod::log_enabled()\n+            backtrace::log_enabled()\n         }\n+    } else {\n+        None\n     };\n \n     // The current implementation always returns `Some`.\n@@ -190,14 +187,13 @@ fn default_hook(info: &PanicInfo<'_>) {\n         let _ = writeln!(err, \"thread '{}' panicked at '{}', {}\",\n                          name, msg, location);\n \n-        #[cfg(feature = \"backtrace\")]\n-        {\n+        if cfg!(feature = \"backtrace\") {\n             use crate::sync::atomic::{AtomicBool, Ordering};\n \n             static FIRST_PANIC: AtomicBool = AtomicBool::new(true);\n \n             if let Some(format) = log_backtrace {\n-                let _ = backtrace_mod::print(err, format);\n+                let _ = backtrace::print(err, format);\n             } else if FIRST_PANIC.compare_and_swap(true, false, Ordering::SeqCst) {\n                 let _ = writeln!(err, \"note: run with `RUST_BACKTRACE=1` \\\n                                        environment variable to display a backtrace.\");"}, {"sha": "b8d57cfafea0ab2d5edcb81ecf602417ed923ce7", "filename": "src/libstd/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -422,7 +422,7 @@ impl fmt::Debug for ChildStderr {\n /// // Execute `ls` in the current directory of the program.\n /// list_dir.status().expect(\"process failed to execute\");\n ///\n-/// println!(\"\");\n+/// println!();\n ///\n /// // Change `ls` to execute in the root directory.\n /// list_dir.current_dir(\"/\");"}, {"sha": "01711d415d86c28f6655d2f49956bc4685a65eb2", "filename": "src/libstd/sys_common/backtrace.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Flibstd%2Fsys_common%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Flibstd%2Fsys_common%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fbacktrace.rs?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -7,10 +7,9 @@ use crate::io;\n use crate::borrow::Cow;\n use crate::io::prelude::*;\n use crate::path::{self, Path, PathBuf};\n-use crate::sync::atomic::{self, Ordering};\n use crate::sys::mutex::Mutex;\n \n-use backtrace::{BacktraceFmt, BytesOrWideString, PrintFmt};\n+use backtrace_rs::{BacktraceFmt, BytesOrWideString, PrintFmt};\n \n /// Max number of frames to print.\n const MAX_NB_FRAMES: usize = 100;\n@@ -74,14 +73,14 @@ unsafe fn _print_fmt(fmt: &mut fmt::Formatter<'_>, print_fmt: PrintFmt) -> fmt::\n     bt_fmt.add_context()?;\n     let mut idx = 0;\n     let mut res = Ok(());\n-    backtrace::trace_unsynchronized(|frame| {\n+    backtrace_rs::trace_unsynchronized(|frame| {\n         if print_fmt == PrintFmt::Short && idx > MAX_NB_FRAMES {\n             return false;\n         }\n \n         let mut hit = false;\n         let mut stop = false;\n-        backtrace::resolve_frame_unsynchronized(frame, |symbol| {\n+        backtrace_rs::resolve_frame_unsynchronized(frame, |symbol| {\n             hit = true;\n             if print_fmt == PrintFmt::Short {\n                 if let Some(sym) = symbol.name().and_then(|s| s.as_str()) {\n@@ -130,6 +129,8 @@ where\n // For now logging is turned off by default, and this function checks to see\n // whether the magical environment variable is present to see if it's turned on.\n pub fn log_enabled() -> Option<PrintFmt> {\n+    use crate::sync::atomic::{self, Ordering};\n+\n     // Setting environment variables for Fuchsia components isn't a standard\n     // or easily supported workflow. For now, always display backtraces.\n     if cfg!(target_os = \"fuchsia\") {"}, {"sha": "cba3eca53862593a653553f325ec4ed460df83de", "filename": "src/libstd/sys_common/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Flibstd%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Flibstd%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmod.rs?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -41,7 +41,6 @@ macro_rules! rtunwrap {\n \n pub mod alloc;\n pub mod at_exit_imp;\n-#[cfg(feature = \"backtrace\")]\n pub mod backtrace;\n pub mod condvar;\n pub mod io;"}, {"sha": "b27e9c543377ac0845b90605906f1ca505ca20c3", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -877,9 +877,9 @@ fn check_matcher_core(\n         // Now `last` holds the complete set of NT tokens that could\n         // end the sequence before SUFFIX. Check that every one works with `suffix`.\n         'each_last: for token in &last.tokens {\n-            if let TokenTree::MetaVarDecl(_, ref name, ref frag_spec) = *token {\n+            if let TokenTree::MetaVarDecl(_, name, frag_spec) = *token {\n                 for next_token in &suffix_first.tokens {\n-                    match is_in_follow(next_token, &frag_spec.as_str()) {\n+                    match is_in_follow(next_token, frag_spec.name) {\n                         IsInFollow::Invalid(msg, help) => {\n                             sess.span_diagnostic\n                                 .struct_span_err(next_token.span(), &msg)\n@@ -948,7 +948,7 @@ fn check_matcher_core(\n \n fn token_can_be_followed_by_any(tok: &quoted::TokenTree) -> bool {\n     if let quoted::TokenTree::MetaVarDecl(_, _, frag_spec) = *tok {\n-        frag_can_be_followed_by_any(&frag_spec.as_str())\n+        frag_can_be_followed_by_any(frag_spec.name)\n     } else {\n         // (Non NT's can always be followed by anthing in matchers.)\n         true\n@@ -963,15 +963,15 @@ fn token_can_be_followed_by_any(tok: &quoted::TokenTree) -> bool {\n /// specifier which consumes at most one token tree can be followed by\n /// a fragment specifier (indeed, these fragments can be followed by\n /// ANYTHING without fear of future compatibility hazards).\n-fn frag_can_be_followed_by_any(frag: &str) -> bool {\n+fn frag_can_be_followed_by_any(frag: Symbol) -> bool {\n     match frag {\n-        \"item\"     | // always terminated by `}` or `;`\n-        \"block\"    | // exactly one token tree\n-        \"ident\"    | // exactly one token tree\n-        \"literal\"  | // exactly one token tree\n-        \"meta\"     | // exactly one token tree\n-        \"lifetime\" | // exactly one token tree\n-        \"tt\" =>   // exactly one token tree\n+        sym::item     | // always terminated by `}` or `;`\n+        sym::block    | // exactly one token tree\n+        sym::ident    | // exactly one token tree\n+        sym::literal  | // exactly one token tree\n+        sym::meta     | // exactly one token tree\n+        sym::lifetime | // exactly one token tree\n+        sym::tt =>   // exactly one token tree\n             true,\n \n         _ =>\n@@ -993,7 +993,7 @@ enum IsInFollow {\n /// break macros that were relying on that binary operator as a\n /// separator.\n // when changing this do not forget to update doc/book/macros.md!\n-fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> IsInFollow {\n+fn is_in_follow(tok: &quoted::TokenTree, frag: Symbol) -> IsInFollow {\n     use quoted::TokenTree;\n \n     if let TokenTree::Token(Token { kind: token::CloseDelim(_), .. }) = *tok {\n@@ -1002,17 +1002,17 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> IsInFollow {\n         IsInFollow::Yes\n     } else {\n         match frag {\n-            \"item\" => {\n+            sym::item => {\n                 // since items *must* be followed by either a `;` or a `}`, we can\n                 // accept anything after them\n                 IsInFollow::Yes\n             }\n-            \"block\" => {\n+            sym::block => {\n                 // anything can follow block, the braces provide an easy boundary to\n                 // maintain\n                 IsInFollow::Yes\n             }\n-            \"stmt\" | \"expr\" => {\n+            sym::stmt | sym::expr => {\n                 const TOKENS: &[&str] = &[\"`=>`\", \"`,`\", \"`;`\"];\n                 match tok {\n                     TokenTree::Token(token) => match token.kind {\n@@ -1022,7 +1022,7 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> IsInFollow {\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n-            \"pat\" => {\n+            sym::pat => {\n                 const TOKENS: &[&str] = &[\"`=>`\", \"`,`\", \"`=`\", \"`|`\", \"`if`\", \"`in`\"];\n                 match tok {\n                     TokenTree::Token(token) => match token.kind {\n@@ -1033,7 +1033,7 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> IsInFollow {\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n-            \"path\" | \"ty\" => {\n+            sym::path | sym::ty => {\n                 const TOKENS: &[&str] = &[\n                     \"`{`\", \"`[`\", \"`=>`\", \"`,`\", \"`>`\", \"`=`\", \"`:`\", \"`;`\", \"`|`\", \"`as`\",\n                     \"`where`\",\n@@ -1061,20 +1061,20 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> IsInFollow {\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n-            \"ident\" | \"lifetime\" => {\n+            sym::ident | sym::lifetime => {\n                 // being a single token, idents and lifetimes are harmless\n                 IsInFollow::Yes\n             }\n-            \"literal\" => {\n+            sym::literal => {\n                 // literals may be of a single token, or two tokens (negative numbers)\n                 IsInFollow::Yes\n             }\n-            \"meta\" | \"tt\" => {\n+            sym::meta | sym::tt => {\n                 // being either a single token or a delimited sequence, tt is\n                 // harmless\n                 IsInFollow::Yes\n             }\n-            \"vis\" => {\n+            sym::vis => {\n                 // Explicitly disallow `priv`, on the off chance it comes back.\n                 const TOKENS: &[&str] = &[\"`,`\", \"an ident\", \"a type\"];\n                 match tok {\n@@ -1099,7 +1099,7 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> IsInFollow {\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n-            \"\" => IsInFollow::Yes, // kw::Invalid\n+            kw::Invalid => IsInFollow::Yes,\n             _ => IsInFollow::Invalid(\n                 format!(\"invalid fragment specifier `{}`\", frag),\n                 VALID_FRAGMENT_NAMES_MSG,"}, {"sha": "8c86d2cf435b65543d3b0efc2996200385e3b9e9", "filename": "src/test/debuginfo/function-arg-initialization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Ftest%2Fdebuginfo%2Ffunction-arg-initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Ftest%2Fdebuginfo%2Ffunction-arg-initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-arg-initialization.rs?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -242,12 +242,12 @@ fn non_immediate_args(a: BigStruct, b: BigStruct) {\n \n fn binding(a: i64, b: u64, c: f64) {\n     let x = 0; // #break\n-    println!(\"\")\n+    println!()\n }\n \n fn assignment(mut a: u64, b: u64, c: f64) {\n     a = b; // #break\n-    println!(\"\")\n+    println!()\n }\n \n fn function_call(x: u64, y: u64, z: f64) {"}, {"sha": "a93f9a136db23a2a0402a83bd4475e6ffb8a7077", "filename": "src/test/ui/collections-const-new.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Ftest%2Fui%2Fcollections-const-new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Ftest%2Fui%2Fcollections-const-new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcollections-const-new.rs?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -1,15 +1,11 @@\n-// run-pass\n+// check-pass\n \n-#![allow(dead_code)]\n // Test several functions can be used for constants\n // 1. Vec::new()\n // 2. String::new()\n \n-#![feature(const_vec_new)]\n-#![feature(const_string_new)]\n-\n const MY_VEC: Vec<usize> = Vec::new();\n \n const MY_STRING: String = String::new();\n \n-pub fn main() {}\n+fn main() {}"}, {"sha": "9fa726f93e3eada91f18a11e4d3d7a95964e78fd", "filename": "src/test/ui/conditional-compilation/cfg-arg-invalid-6.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-arg-invalid-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-arg-invalid-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-arg-invalid-6.rs?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -0,0 +1,3 @@\n+// compile-flags: --cfg a{\n+// error-pattern: invalid `--cfg` argument: `a{` (expected `key` or `key=\"value\"`)\n+fn main() {}"}, {"sha": "7d2087b4b71f71f91d05f30017635547ebbf896b", "filename": "src/test/ui/conditional-compilation/cfg-arg-invalid-6.stderr", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-arg-invalid-6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-arg-invalid-6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-arg-invalid-6.stderr?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -0,0 +1,2 @@\n+error: invalid `--cfg` argument: `a{` (expected `key` or `key=\"value\"`)\n+"}, {"sha": "8b17f6885ad3ee7e99ff26b1763f05817b839d8a", "filename": "src/test/ui/consts/miri_unleashed/feature-gate-unleash_the_miri_inside_of_you.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Ffeature-gate-unleash_the_miri_inside_of_you.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Ffeature-gate-unleash_the_miri_inside_of_you.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Ffeature-gate-unleash_the_miri_inside_of_you.rs?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -14,8 +14,9 @@ trait Bar<T, U: Foo<T>> {\n impl Foo<u32> for () {\n     const X: u32 = 42;\n }\n+\n impl Foo<Vec<u32>> for String {\n-    const X: Vec<u32> = Vec::new(); //~ ERROR not yet stable as a const fn\n+    const X: Vec<u32> = Vec::new();\n }\n \n impl Bar<u32, ()> for () {}"}, {"sha": "5bc7b70638c80f372c9160de20d3a292dba8a269", "filename": "src/test/ui/consts/miri_unleashed/feature-gate-unleash_the_miri_inside_of_you.stderr", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Ffeature-gate-unleash_the_miri_inside_of_you.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Ffeature-gate-unleash_the_miri_inside_of_you.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Ffeature-gate-unleash_the_miri_inside_of_you.stderr?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -4,13 +4,5 @@ error[E0493]: destructors cannot be evaluated at compile-time\n LL |     const F: u32 = (U::X, 42).1;\n    |                    ^^^^^^^^^^ constants cannot evaluate destructors\n \n-error: `std::vec::Vec::<T>::new` is not yet stable as a const fn\n-  --> $DIR/feature-gate-unleash_the_miri_inside_of_you.rs:18:25\n-   |\n-LL |     const X: Vec<u32> = Vec::new();\n-   |                         ^^^^^^^^^^\n-   |\n-   = help: add `#![feature(const_vec_new)]` to the crate attributes to enable\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "b476e04529a52c86431c41b82b7dddf07b3f5204", "filename": "src/test/ui/consts/miri_unleashed/mutable_const.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.rs?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -0,0 +1,20 @@\n+// compile-flags: -Zunleash-the-miri-inside-of-you\n+\n+#![feature(const_raw_ptr_deref)]\n+#![deny(const_err)]\n+\n+use std::cell::UnsafeCell;\n+\n+// make sure we do not just intern this as mutable\n+const MUTABLE_BEHIND_RAW: *mut i32 = &UnsafeCell::new(42) as *const _ as *mut _;\n+\n+const MUTATING_BEHIND_RAW: () = {\n+    // Test that `MUTABLE_BEHIND_RAW` is actually immutable, by doing this at const time.\n+    unsafe {\n+        *MUTABLE_BEHIND_RAW = 99 //~ WARN skipping const checks\n+        //~^ ERROR any use of this value will cause an error\n+        //~^^ tried to modify constant memory\n+    }\n+};\n+\n+fn main() {}"}, {"sha": "507d4823a111d5876863b82d27d11c8d007d8926", "filename": "src/test/ui/consts/miri_unleashed/mutable_const.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.stderr?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -0,0 +1,27 @@\n+warning: skipping const checks\n+  --> $DIR/mutable_const.rs:14:9\n+   |\n+LL |         *MUTABLE_BEHIND_RAW = 99\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: any use of this value will cause an error\n+  --> $DIR/mutable_const.rs:14:9\n+   |\n+LL | / const MUTATING_BEHIND_RAW: () = {\n+LL | |     // Test that `MUTABLE_BEHIND_RAW` is actually immutable, by doing this at const time.\n+LL | |     unsafe {\n+LL | |         *MUTABLE_BEHIND_RAW = 99\n+   | |         ^^^^^^^^^^^^^^^^^^^^^^^^ tried to modify constant memory\n+...  |\n+LL | |     }\n+LL | | };\n+   | |__-\n+   |\n+note: lint level defined here\n+  --> $DIR/mutable_const.rs:4:9\n+   |\n+LL | #![deny(const_err)]\n+   |         ^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "28cf3537d605a41d005f78f29b5afa6f30980ab3", "filename": "src/test/ui/consts/miri_unleashed/mutable_references_ice.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.stderr?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -6,7 +6,7 @@ LL |         *MUH.x.get() = 99;\n \n thread 'rustc' panicked at 'assertion failed: `(left != right)`\n   left: `Const`,\n- right: `Const`: UnsafeCells are not allowed behind references in constants. This should have been prevented statically by const qualification. If this were allowed one would be able to change a constant at one use site and other use sites may arbitrarily decide to change, too.', src/librustc_mir/interpret/intern.rs:LL:CC\n+ right: `Const`: UnsafeCells are not allowed behind references in constants. This should have been prevented statically by const qualification. If this were allowed one would be able to change a constant at one use site and other use sites could observe that mutation.', src/librustc_mir/interpret/intern.rs:LL:CC\n note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n \n error: internal compiler error: unexpected panic"}, {"sha": "fb13fd764bfaf8369b236abf1d3bbbe6387977f2", "filename": "src/test/ui/drop/dropck_legal_cycles.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Ftest%2Fui%2Fdrop%2Fdropck_legal_cycles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Ftest%2Fui%2Fdrop%2Fdropck_legal_cycles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fdropck_legal_cycles.rs?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -143,7 +143,7 @@ pub fn main() {\n     v[0].descend_into_self(&mut c);\n     assert!(!c.saw_prev_marked); // <-- different from below, b/c acyclic above\n \n-    if PRINT { println!(\"\"); }\n+    if PRINT { println!(); }\n \n     // Cycle 1: { v[0] -> v[1], v[1] -> v[0] };\n     // does not exercise `v` itself\n@@ -158,7 +158,7 @@ pub fn main() {\n     v[0].descend_into_self(&mut c);\n     assert!(c.saw_prev_marked);\n \n-    if PRINT { println!(\"\"); }\n+    if PRINT { println!(); }\n \n     // Cycle 2: { v[0] -> v, v[1] -> v }\n     let v: V = Named::new(\"v\");\n@@ -171,7 +171,7 @@ pub fn main() {\n     v.descend_into_self(&mut c);\n     assert!(c.saw_prev_marked);\n \n-    if PRINT { println!(\"\"); }\n+    if PRINT { println!(); }\n \n     // Cycle 3: { hk0 -> hv0, hv0 -> hk0, hk1 -> hv1, hv1 -> hk1 };\n     // does not exercise `h` itself\n@@ -193,7 +193,7 @@ pub fn main() {\n         assert!(c.saw_prev_marked);\n     }\n \n-    if PRINT { println!(\"\"); }\n+    if PRINT { println!(); }\n \n     // Cycle 4: { h -> (hmk0,hmv0,hmk1,hmv1), {hmk0,hmv0,hmk1,hmv1} -> h }\n \n@@ -216,7 +216,7 @@ pub fn main() {\n         // break;\n     }\n \n-    if PRINT { println!(\"\"); }\n+    if PRINT { println!(); }\n \n     // Cycle 5: { vd[0] -> vd[1], vd[1] -> vd[0] };\n     // does not exercise vd itself\n@@ -232,7 +232,7 @@ pub fn main() {\n     vd[0].descend_into_self(&mut c);\n     assert!(c.saw_prev_marked);\n \n-    if PRINT { println!(\"\"); }\n+    if PRINT { println!(); }\n \n     // Cycle 6: { vd -> (vd0, vd1), {vd0, vd1} -> vd }\n     let mut vd: VecDeque<VD> = VecDeque::new();\n@@ -247,7 +247,7 @@ pub fn main() {\n     vd[0].descend_into_self(&mut c);\n     assert!(c.saw_prev_marked);\n \n-    if PRINT { println!(\"\"); }\n+    if PRINT { println!(); }\n \n     // Cycle 7: { vm -> (vm0, vm1), {vm0, vm1} -> vm }\n     let mut vm: HashMap<usize, VM> = HashMap::new();\n@@ -262,7 +262,7 @@ pub fn main() {\n     vm[&0].descend_into_self(&mut c);\n     assert!(c.saw_prev_marked);\n \n-    if PRINT { println!(\"\"); }\n+    if PRINT { println!(); }\n \n     // Cycle 8: { ll -> (ll0, ll1), {ll0, ll1} -> ll }\n     let mut ll: LinkedList<LL> = LinkedList::new();\n@@ -282,7 +282,7 @@ pub fn main() {\n         // break;\n     }\n \n-    if PRINT { println!(\"\"); }\n+    if PRINT { println!(); }\n \n     // Cycle 9: { bh -> (bh0, bh1), {bh0, bh1} -> bh }\n     let mut bh: BinaryHeap<BH> = BinaryHeap::new();\n@@ -302,7 +302,7 @@ pub fn main() {\n         // break;\n     }\n \n-    if PRINT { println!(\"\"); }\n+    if PRINT { println!(); }\n \n     // Cycle 10: { btm -> (btk0, btv1), {bt0, bt1} -> btm }\n     let mut btm: BTreeMap<BTM, BTM> = BTreeMap::new();\n@@ -323,7 +323,7 @@ pub fn main() {\n         // break;\n     }\n \n-    if PRINT { println!(\"\"); }\n+    if PRINT { println!(); }\n \n     // Cycle 10: { bts -> (bts0, bts1), {bts0, bts1} -> btm }\n     let mut bts: BTreeSet<BTS> = BTreeSet::new();\n@@ -343,7 +343,7 @@ pub fn main() {\n         // break;\n     }\n \n-    if PRINT { println!(\"\"); }\n+    if PRINT { println!(); }\n \n     // Cycle 11: { rc0 -> (rc1, rc2), rc1 -> (), rc2 -> rc0 }\n     let (rc0, rc1, rc2): (RCRC, RCRC, RCRC);\n@@ -361,7 +361,7 @@ pub fn main() {\n     rc0.descend_into_self(&mut c);\n     assert!(c.saw_prev_marked);\n \n-    if PRINT { println!(\"\"); }\n+    if PRINT { println!(); }\n \n     // We want to take the previous Rc case and generalize it to Arc.\n     //\n@@ -395,7 +395,7 @@ pub fn main() {\n     arc0.descend_into_self(&mut c);\n     assert!(c.saw_prev_marked);\n \n-    if PRINT { println!(\"\"); }\n+    if PRINT { println!(); }\n \n     // Cycle 13: { arc0 -> (arc1, arc2), arc1 -> (), arc2 -> arc0 }, rwlocks\n     let (arc0, arc1, arc2): (ARCRW, ARCRW, ARCRW);\n@@ -413,7 +413,7 @@ pub fn main() {\n     arc0.descend_into_self(&mut c);\n     assert!(c.saw_prev_marked);\n \n-    if PRINT { println!(\"\"); }\n+    if PRINT { println!(); }\n \n     // Cycle 14: { arc0 -> (arc1, arc2), arc1 -> (), arc2 -> arc0 }, mutexs\n     let (arc0, arc1, arc2): (ARCM, ARCM, ARCM);"}, {"sha": "0fbc796d7c0d3d18d2c1aa573f4dbf7c4aa7915d", "filename": "src/test/ui/for/for-c-in-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Ftest%2Fui%2Ffor%2Ffor-c-in-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Ftest%2Fui%2Ffor%2Ffor-c-in-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffor%2Ffor-c-in-str.rs?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -6,6 +6,6 @@ fn main() {\n     //~| NOTE `&str` is not an iterator\n     //~| HELP the trait `std::iter::Iterator` is not implemented for `&str`\n     //~| NOTE required by `std::iter::IntoIterator::into_iter`\n-        println!(\"\");\n+        println!();\n     }\n }"}, {"sha": "63ae445f99b6003eb346dfebff7e9c55b6c9eaab", "filename": "src/tools/build-manifest/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Ftools%2Fbuild-manifest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Ftools%2Fbuild-manifest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2FCargo.toml?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -7,3 +7,5 @@ edition = \"2018\"\n [dependencies]\n toml = \"0.5\"\n serde = { version = \"1.0\", features = [\"derive\"] }\n+serde_json = \"1.0\"\n+reqwest = \"0.9\""}, {"sha": "c2d642bb136be9c7a7b9392707fcc5177f7c52c2", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 49, "deletions": 5, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -1,12 +1,19 @@\n+//! Build a dist manifest, hash and sign everything.\n+//! This gets called by `promote-release`\n+//! (https://github.com/rust-lang/rust-central-station/tree/master/promote-release)\n+//! via `x.py dist hash-and-sign`; the cmdline arguments are set up\n+//! by rustbuild (in `src/bootstrap/dist.rs`).\n+\n use toml;\n use serde::Serialize;\n \n use std::collections::BTreeMap;\n use std::env;\n use std::fs;\n-use std::io::{self, Read, Write};\n+use std::io::{self, Read, Write, BufRead, BufReader};\n use std::path::{PathBuf, Path};\n use std::process::{Command, Stdio};\n+use std::collections::HashMap;\n \n static HOSTS: &[&str] = &[\n     \"aarch64-unknown-linux-gnu\",\n@@ -146,6 +153,9 @@ static MINGW: &[&str] = &[\n     \"x86_64-pc-windows-gnu\",\n ];\n \n+static TOOLSTATE: &str =\n+    \"https://raw.githubusercontent.com/rust-lang-nursery/rust-toolstate/master/history/linux.tsv\";\n+\n #[derive(Serialize)]\n #[serde(rename_all = \"kebab-case\")]\n struct Manifest {\n@@ -270,6 +280,7 @@ fn main() {\n     // Do not ask for a passphrase while manually testing\n     let mut passphrase = String::new();\n     if should_sign {\n+        // `x.py` passes the passphrase via stdin.\n         t!(io::stdin().read_to_string(&mut passphrase));\n     }\n \n@@ -353,6 +364,7 @@ impl Builder {\n         self.lldb_git_commit_hash = self.git_commit_hash(\"lldb\", \"x86_64-unknown-linux-gnu\");\n         self.miri_git_commit_hash = self.git_commit_hash(\"miri\", \"x86_64-unknown-linux-gnu\");\n \n+        self.check_toolstate();\n         self.digest_and_sign();\n         let manifest = self.build_manifest();\n         self.write_channel_files(&self.rust_release, &manifest);\n@@ -362,6 +374,37 @@ impl Builder {\n         }\n     }\n \n+    /// If a tool does not pass its tests, don't ship it.\n+    /// Right now, we do this only for Miri.\n+    fn check_toolstate(&mut self) {\n+        // Get the toolstate for this rust revision.\n+        let rev = self.rust_git_commit_hash.as_ref().expect(\"failed to determine rust git hash\");\n+        let toolstates = reqwest::get(TOOLSTATE).expect(\"failed to get toolstates\");\n+        let toolstates = BufReader::new(toolstates);\n+        let toolstate = toolstates.lines()\n+            .find_map(|line| {\n+                let line = line.expect(\"failed to read toolstate lines\");\n+                let mut pieces = line.splitn(2, '\\t');\n+                let commit = pieces.next().expect(\"malformed toolstate line\");\n+                if commit != rev {\n+                    // Not the right commit.\n+                    return None;\n+                }\n+                // Return the 2nd piece, the JSON.\n+                Some(pieces.next().expect(\"malformed toolstate line\").to_owned())\n+            })\n+            .expect(\"failed to find toolstate for rust commit\");\n+        let toolstate: HashMap<String, String> =\n+            serde_json::from_str(&toolstate).expect(\"toolstate is malformed JSON\");\n+        // Mark some tools as missing based on toolstate.\n+        if toolstate.get(\"miri\").map(|s| &*s as &str) != Some(\"test-pass\") {\n+            println!(\"Miri tests are not passing, removing component\");\n+            self.miri_version = None;\n+            self.miri_git_commit_hash = None;\n+        }\n+    }\n+\n+    /// Hash all files, compute their signatures, and collect the hashes in `self.digests`.\n     fn digest_and_sign(&mut self) {\n         for file in t!(self.input.read_dir()).map(|e| t!(e).path()) {\n             let filename = file.file_name().unwrap().to_str().unwrap();\n@@ -532,19 +575,20 @@ impl Builder {\n             .as_ref()\n             .cloned()\n             .map(|version| (version, true))\n-            .unwrap_or_default();\n+            .unwrap_or_default(); // `is_present` defaults to `false` here.\n \n-        // miri needs to build std with xargo, which doesn't allow stable/beta:\n-        // <https://github.com/japaric/xargo/pull/204#issuecomment-374888868>\n+        // Miri is nightly-only; never ship it for other trains.\n         if pkgname == \"miri-preview\" && self.rust_release != \"nightly\" {\n-            is_present = false; // ignore it\n+            is_present = false; // Pretend the component is entirely missing.\n         }\n \n         let targets = targets.iter().map(|name| {\n             if is_present {\n+                // The component generally exists, but it might still be missing for this target.\n                 let filename = self.filename(pkgname, name);\n                 let digest = match self.digests.remove(&filename) {\n                     Some(digest) => digest,\n+                    // This component does not exist for this target -- skip it.\n                     None => return (name.to_string(), Target::unavailable()),\n                 };\n                 let xz_filename = filename.replace(\".tar.gz\", \".tar.xz\");"}, {"sha": "7c51de5df226768395388c350fa04ffad0ca663b", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -253,7 +253,7 @@ pub fn parse_config(args: Vec<String>) -> Config {\n     if args.len() == 1 || args[1] == \"-h\" || args[1] == \"--help\" {\n         let message = format!(\"Usage: {} [OPTIONS] [TESTNAME...]\", argv0);\n         println!(\"{}\", opts.usage(&message));\n-        println!(\"\");\n+        println!();\n         panic!()\n     }\n \n@@ -265,7 +265,7 @@ pub fn parse_config(args: Vec<String>) -> Config {\n     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n         let message = format!(\"Usage: {} [OPTIONS]  [TESTNAME...]\", argv0);\n         println!(\"{}\", opts.usage(&message));\n-        println!(\"\");\n+        println!();\n         panic!()\n     }\n "}, {"sha": "baed27dd15152712c542b841fe16029c3c197cd2", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -2593,7 +2593,7 @@ impl<'test> TestCx<'test> {\n                     \"  actual:   {}\",\n                     codegen_units_to_str(&actual_item.codegen_units)\n                 );\n-                println!(\"\");\n+                println!();\n             }\n         }\n \n@@ -3526,7 +3526,7 @@ impl<'test> TestCx<'test> {\n                             }\n                         }\n                     }\n-                    println!(\"\");\n+                    println!();\n                 }\n             }\n         }"}, {"sha": "4060b90d952bde04f67628e1a06ef1f406e151e9", "filename": "src/tools/publish_toolstate.py", "status": "modified", "additions": 80, "deletions": 19, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Ftools%2Fpublish_toolstate.py", "raw_url": "https://github.com/rust-lang/rust/raw/a44881d892fb4f4a8ed93f8f392bab942fac7a41/src%2Ftools%2Fpublish_toolstate.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fpublish_toolstate.py?ref=a44881d892fb4f4a8ed93f8f392bab942fac7a41", "patch": "@@ -7,6 +7,8 @@\n ## It is set as callback for `src/ci/docker/x86_64-gnu-tools/repo.sh` by the CI scripts\n ## when a new commit lands on `master` (i.e., after it passed all checks on `auto`).\n \n+from __future__ import print_function\n+\n import sys\n import re\n import os\n@@ -20,21 +22,26 @@\n     import urllib.request as urllib2\n \n # List of people to ping when the status of a tool or a book changed.\n+# These should be collaborators of the rust-lang/rust repository (with at least\n+# read privileges on it). CI will fail otherwise.\n MAINTAINERS = {\n-    'miri': '@oli-obk @RalfJung @eddyb',\n-    'clippy-driver': '@Manishearth @llogiq @mcarton @oli-obk @phansch @flip1995 @yaahc',\n-    'rls': '@Xanewok',\n-    'rustfmt': '@topecongiro',\n-    'book': '@carols10cents @steveklabnik',\n-    'nomicon': '@frewsxcv @Gankro',\n-    'reference': '@steveklabnik @Havvy @matthewjasper @ehuss',\n-    'rust-by-example': '@steveklabnik @marioidival @projektir',\n-    'embedded-book': (\n-        '@adamgreig @andre-richter @jamesmunns @korken89 '\n-        '@ryankurte @thejpster @therealprof'\n-    ),\n-    'edition-guide': '@ehuss @Centril @steveklabnik',\n-    'rustc-guide': '@mark-i-m @spastorino @amanjeev'\n+    'miri': {'oli-obk', 'RalfJung', 'eddyb'},\n+    'clippy-driver': {\n+        'Manishearth', 'llogiq', 'mcarton', 'oli-obk', 'phansch', 'flip1995',\n+        'yaahc',\n+    },\n+    'rls': {'Xanewok'},\n+    'rustfmt': {'topecongiro'},\n+    'book': {'carols10cents', 'steveklabnik'},\n+    'nomicon': {'frewsxcv', 'Gankra'},\n+    'reference': {'steveklabnik', 'Havvy', 'matthewjasper', 'ehuss'},\n+    'rust-by-example': {'steveklabnik', 'marioidival'},\n+    'embedded-book': {\n+        'adamgreig', 'andre-richter', 'jamesmunns', 'korken89',\n+        'ryankurte', 'thejpster', 'therealprof',\n+    },\n+    'edition-guide': {'ehuss', 'Centril', 'steveklabnik'},\n+    'rustc-guide': {'mark-i-m', 'spastorino', 'amanjeev'},\n }\n \n REPOS = {\n@@ -52,6 +59,50 @@\n }\n \n \n+def validate_maintainers(repo, github_token):\n+    '''Ensure all maintainers are assignable on a GitHub repo'''\n+    next_link_re = re.compile(r'<([^>]+)>; rel=\"next\"')\n+\n+    # Load the list of assignable people in the GitHub repo\n+    assignable = []\n+    url = 'https://api.github.com/repos/%s/collaborators?per_page=100' % repo\n+    while url is not None:\n+        response = urllib2.urlopen(urllib2.Request(url, headers={\n+            'Authorization': 'token ' + github_token,\n+            # Properly load nested teams.\n+            'Accept': 'application/vnd.github.hellcat-preview+json',\n+        }))\n+        assignable.extend(user['login'] for user in json.load(response))\n+        # Load the next page if available\n+        url = None\n+        link_header = response.headers.get('Link')\n+        if link_header:\n+            matches = next_link_re.match(link_header)\n+            if matches is not None:\n+                url = matches.group(1)\n+\n+    errors = False\n+    for tool, maintainers in MAINTAINERS.items():\n+        for maintainer in maintainers:\n+            if maintainer not in assignable:\n+                errors = True\n+                print(\n+                    \"error: %s maintainer @%s is not assignable in the %s repo\"\n+                    % (tool, maintainer, repo),\n+                )\n+\n+    if errors:\n+        print()\n+        print(\"  To be assignable, a person needs to be explicitly listed as a\")\n+        print(\"  collaborator in the repository settings. The simple way to\")\n+        print(\"  fix this is to ask someone with 'admin' privileges on the repo\")\n+        print(\"  to add the person or whole team as a collaborator with 'read'\")\n+        print(\"  privileges. Those privileges don't grant any extra permissions\")\n+        print(\"  so it's safe to apply them.\")\n+        print()\n+        print(\"The build will fail due to this.\")\n+        exit(1)\n+\n def read_current_status(current_commit, path):\n     '''Reads build status of `current_commit` from content of `history/*.tsv`\n     '''\n@@ -73,13 +124,12 @@ def maybe_delink(message):\n def issue(\n     tool,\n     status,\n-    maintainers,\n+    assignees,\n     relevant_pr_number,\n     relevant_pr_user,\n     pr_reviewer,\n ):\n     # Open an issue about the toolstate failure.\n-    assignees = [x.strip() for x in maintainers.split('@') if x != '']\n     if status == 'test-fail':\n         status_description = 'has failing tests'\n     else:\n@@ -100,7 +150,7 @@ def issue(\n             REPOS.get(tool), relevant_pr_user, pr_reviewer\n         )),\n         'title': '`{}` no longer builds after {}'.format(tool, relevant_pr_number),\n-        'assignees': assignees,\n+        'assignees': list(assignees),\n         'labels': ['T-compiler', 'I-nominated'],\n     })\n     print(\"Creating issue:\\n{}\".format(request))\n@@ -150,18 +200,19 @@ def update_latest(\n                 old = status[os]\n                 new = s.get(tool, old)\n                 status[os] = new\n+                maintainers = ' '.join('@'+name for name in MAINTAINERS[tool])\n                 if new > old: # comparing the strings, but they are ordered appropriately!\n                     # things got fixed or at least the status quo improved\n                     changed = True\n                     message += '\ud83c\udf89 {} on {}: {} \u2192 {} (cc {}, @rust-lang/infra).\\n' \\\n-                        .format(tool, os, old, new, MAINTAINERS.get(tool))\n+                        .format(tool, os, old, new, maintainers)\n                 elif new < old:\n                     # tests or builds are failing and were not failing before\n                     changed = True\n                     title = '\ud83d\udc94 {} on {}: {} \u2192 {}' \\\n                         .format(tool, os, old, new)\n                     message += '{} (cc {}, @rust-lang/infra).\\n' \\\n-                        .format(title, MAINTAINERS.get(tool))\n+                        .format(title, maintainers)\n                     # Most tools only create issues for build failures.\n                     # Other failures can be spurious.\n                     if new == 'build-fail' or (tool == 'miri' and new == 'test-fail'):\n@@ -200,6 +251,16 @@ def update_latest(\n \n \n if __name__ == '__main__':\n+    repo = os.environ.get('TOOLSTATE_VALIDATE_MAINTAINERS_REPO')\n+    if repo:\n+        github_token = os.environ.get('TOOLSTATE_REPO_ACCESS_TOKEN')\n+        if github_token:\n+            validate_maintainers(repo, github_token)\n+        else:\n+            print('skipping toolstate maintainers validation since no GitHub token is present')\n+        # When validating maintainers don't run the full script.\n+        exit(0)\n+\n     cur_commit = sys.argv[1]\n     cur_datetime = datetime.datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ')\n     cur_commit_msg = sys.argv[2]"}]}