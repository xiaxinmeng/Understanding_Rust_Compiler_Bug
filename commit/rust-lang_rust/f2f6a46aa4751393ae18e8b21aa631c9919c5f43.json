{"sha": "f2f6a46aa4751393ae18e8b21aa631c9919c5f43", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyZjZhNDZhYTQ3NTEzOTNhZTE4ZThiMjFhYTYzMWM5OTE5YzVmNDM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-04T08:36:12Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-04T08:41:50Z"}, "message": "Cleanup dot completiont tests", "tree": {"sha": "6c0d0cbde03a3f593256d76e7ab3784349868a3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c0d0cbde03a3f593256d76e7ab3784349868a3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2f6a46aa4751393ae18e8b21aa631c9919c5f43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2f6a46aa4751393ae18e8b21aa631c9919c5f43", "html_url": "https://github.com/rust-lang/rust/commit/f2f6a46aa4751393ae18e8b21aa631c9919c5f43", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2f6a46aa4751393ae18e8b21aa631c9919c5f43/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "caeddff5435d9cf604aac7af7b53cc4ac8bb4a13", "url": "https://api.github.com/repos/rust-lang/rust/commits/caeddff5435d9cf604aac7af7b53cc4ac8bb4a13", "html_url": "https://github.com/rust-lang/rust/commit/caeddff5435d9cf604aac7af7b53cc4ac8bb4a13"}], "stats": {"total": 1127, "additions": 407, "deletions": 720}, "files": [{"sha": "667a8b94993d263527ab4bba1ea269ef1936ef3e", "filename": "crates/ra_ide/src/completion/complete_dot.rs", "status": "modified", "additions": 264, "deletions": 720, "changes": 984, "blob_url": "https://github.com/rust-lang/rust/blob/f2f6a46aa4751393ae18e8b21aa631c9919c5f43/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f6a46aa4751393ae18e8b21aa631c9919c5f43/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=f2f6a46aa4751393ae18e8b21aa631c9919c5f43", "patch": "@@ -2,16 +2,11 @@\n \n use hir::{HasVisibility, Type};\n use rustc_hash::FxHashSet;\n+use test_utils::mark;\n \n-use crate::{\n-    completion::{\n-        completion_context::CompletionContext,\n-        completion_item::{CompletionKind, Completions},\n-    },\n-    CompletionItem,\n-};\n+use crate::completion::{completion_context::CompletionContext, completion_item::Completions};\n \n-/// Complete dot accesses, i.e. fields or methods (and .await syntax).\n+/// Complete dot accesses, i.e. fields or methods.\n pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n     let dot_receiver = match &ctx.dot_receiver {\n         Some(expr) => expr,\n@@ -23,18 +18,12 @@ pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n         _ => return,\n     };\n \n-    if !ctx.is_call {\n+    if ctx.is_call {\n+        mark::hit!(test_no_struct_field_completion_for_method_call);\n+    } else {\n         complete_fields(acc, ctx, &receiver_ty);\n     }\n     complete_methods(acc, ctx, &receiver_ty);\n-\n-    // Suggest .await syntax for types that implement Future trait\n-    if receiver_ty.impls_future(ctx.db) {\n-        CompletionItem::new(CompletionKind::Keyword, ctx.source_range(), \"await\")\n-            .detail(\"expr.await\")\n-            .insert_text(\"await\")\n-            .add_to(acc);\n-    }\n }\n \n fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: &Type) {\n@@ -72,801 +61,356 @@ fn complete_methods(acc: &mut Completions, ctx: &CompletionContext, receiver: &T\n \n #[cfg(test)]\n mod tests {\n-    use crate::completion::{test_utils::do_completion, CompletionItem, CompletionKind};\n-    use insta::assert_debug_snapshot;\n+    use expect::{expect, Expect};\n+    use test_utils::mark;\n+\n+    use crate::completion::{test_utils::completion_list, CompletionKind};\n \n-    fn do_ref_completion(code: &str) -> Vec<CompletionItem> {\n-        do_completion(code, CompletionKind::Reference)\n+    fn check(ra_fixture: &str, expect: Expect) {\n+        let actual = completion_list(ra_fixture, CompletionKind::Reference);\n+        expect.assert_eq(&actual);\n     }\n \n     #[test]\n-    fn test_struct_field_completion() {\n-        assert_debug_snapshot!(\n-        do_ref_completion(\n-                r\"\n-                struct A { the_field: u32 }\n-                fn foo(a: A) {\n-                a.<|>\n-                }\n-                \",\n-        ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: 45..45,\n-                delete: 45..45,\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###\n+    fn test_struct_field_and_method_completion() {\n+        check(\n+            r#\"\n+struct S { foo: u32 }\n+impl S {\n+    fn bar(&self) {}\n+}\n+fn foo(s: S) { s.<|> }\n+\"#,\n+            expect![[r#\"\n+                me bar() fn bar(&self)\n+                fd foo u32\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn test_struct_field_completion_self() {\n-        assert_debug_snapshot!(\n-        do_ref_completion(\n-            r\"\n-            struct A {\n-                /// This is the_field\n-                the_field: (u32,)\n-            }\n-            impl A {\n-                fn foo(self) {\n-                    self.<|>\n-                }\n-            }\n-            \",\n-        ),\n-        @r###\"\n-        [\n-            CompletionItem {\n-                label: \"foo()\",\n-                source_range: 102..102,\n-                delete: 102..102,\n-                insert: \"foo()$0\",\n-                kind: Method,\n-                lookup: \"foo\",\n-                detail: \"fn foo(self)\",\n-            },\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: 102..102,\n-                delete: 102..102,\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"(u32,)\",\n-                documentation: Documentation(\n-                    \"This is the_field\",\n-                ),\n-            },\n-        ]\n-        \"###\n-        );\n+        check(\n+            r#\"\n+struct S { the_field: (u32,) }\n+impl S {\n+    fn foo(self) { self.<|> }\n+}\n+\"#,\n+            expect![[r#\"\n+                me foo() fn foo(self)\n+                fd the_field (u32,)\n+            \"#]],\n+        )\n     }\n \n     #[test]\n     fn test_struct_field_completion_autoderef() {\n-        assert_debug_snapshot!(\n-        do_ref_completion(\n-            r\"\n-            struct A { the_field: (u32, i32) }\n-            impl A {\n-                fn foo(&self) {\n-                    self.<|>\n-                }\n-            }\n-            \",\n-        ),\n-        @r###\"\n-        [\n-            CompletionItem {\n-                label: \"foo()\",\n-                source_range: 77..77,\n-                delete: 77..77,\n-                insert: \"foo()$0\",\n-                kind: Method,\n-                lookup: \"foo\",\n-                detail: \"fn foo(&self)\",\n-            },\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: 77..77,\n-                delete: 77..77,\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"(u32, i32)\",\n-            },\n-        ]\n-        \"###\n-        );\n+        check(\n+            r#\"\n+struct A { the_field: (u32, i32) }\n+impl A {\n+    fn foo(&self) { self.<|> }\n+}\n+\"#,\n+            expect![[r#\"\n+                me foo() fn foo(&self)\n+                fd the_field (u32, i32)\n+            \"#]],\n+        )\n     }\n \n     #[test]\n     fn test_no_struct_field_completion_for_method_call() {\n-        assert_debug_snapshot!(\n-        do_ref_completion(\n-            r\"\n-            struct A { the_field: u32 }\n-            fn foo(a: A) {\n-               a.<|>()\n-            }\n-            \",\n-        ),\n-        @\"[]\"\n+        mark::check!(test_no_struct_field_completion_for_method_call);\n+        check(\n+            r#\"\n+struct A { the_field: u32 }\n+fn foo(a: A) { a.<|>() }\n+\"#,\n+            expect![[\"\"]],\n         );\n     }\n \n     #[test]\n-    fn test_struct_field_visibility_private() {\n-        assert_debug_snapshot!(\n-            do_ref_completion(\n-                r\"\n-            mod inner {\n-                struct A {\n-                    private_field: u32,\n-                    pub pub_field: u32,\n-                    pub(crate) crate_field: u32,\n-                    pub(super) super_field: u32,\n-                }\n-            }\n-            fn foo(a: inner::A) {\n-               a.<|>\n-            }\n-            \",\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"crate_field\",\n-                source_range: 192..192,\n-                delete: 192..192,\n-                insert: \"crate_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-            CompletionItem {\n-                label: \"pub_field\",\n-                source_range: 192..192,\n-                delete: 192..192,\n-                insert: \"pub_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-            CompletionItem {\n-                label: \"super_field\",\n-                source_range: 192..192,\n-                delete: 192..192,\n-                insert: \"super_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###\n-        );\n+    fn test_visibility_filtering() {\n+        check(\n+            r#\"\n+mod inner {\n+    pub struct A {\n+        private_field: u32,\n+        pub pub_field: u32,\n+        pub(crate) crate_field: u32,\n+        pub(super) super_field: u32,\n     }\n-\n-    #[test]\n-    fn test_union_field_completion() {\n-        assert_debug_snapshot!(\n-            do_ref_completion(\n-                r\"\n-            union Un {\n-                field: u8,\n-                other: u16,\n-            }\n-\n-            fn foo(u: Un) {\n-                u.<|>\n-            }\n-            \",\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"field\",\n-                source_range: 67..67,\n-                delete: 67..67,\n-                insert: \"field\",\n-                kind: Field,\n-                detail: \"u8\",\n-            },\n-            CompletionItem {\n-                label: \"other\",\n-                source_range: 67..67,\n-                delete: 67..67,\n-                insert: \"other\",\n-                kind: Field,\n-                detail: \"u16\",\n-            },\n-        ]\n-        \"###\n+}\n+fn foo(a: inner::A) { a.<|> }\n+\"#,\n+            expect![[r#\"\n+                fd crate_field u32\n+                fd pub_field u32\n+                fd super_field u32\n+            \"#]],\n         );\n-    }\n \n-    #[test]\n-    fn test_method_completion() {\n-        assert_debug_snapshot!(\n-        do_ref_completion(\n-            r\"\n-            struct A {}\n-            impl A {\n-                fn the_method(&self) {}\n-            }\n-            fn foo(a: A) {\n-               a.<|>\n-            }\n-            \",\n-        ),\n-        @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_method()\",\n-                source_range: 71..71,\n-                delete: 71..71,\n-                insert: \"the_method()$0\",\n-                kind: Method,\n-                lookup: \"the_method\",\n-                detail: \"fn the_method(&self)\",\n-            },\n-        ]\n-        \"###\n+        check(\n+            r#\"\n+struct A {}\n+mod m {\n+    impl super::A {\n+        fn private_method(&self) {}\n+        pub(super) fn the_method(&self) {}\n+    }\n+}\n+fn foo(a: A) { a.<|> }\n+\"#,\n+            expect![[r#\"\n+                me the_method() pub(super) fn the_method(&self)\n+            \"#]],\n         );\n     }\n \n     #[test]\n-    fn test_method_completion_only_fitting_impls() {\n-        assert_debug_snapshot!(\n-            do_ref_completion(\n-                r\"\n-            struct A<T> {}\n-            impl A<u32> {\n-                fn the_method(&self) {}\n-            }\n-            impl A<i32> {\n-                fn the_other_method(&self) {}\n-            }\n-            fn foo(a: A<u32>) {\n-               a.<|>\n-            }\n-            \",\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_method()\",\n-                source_range: 134..134,\n-                delete: 134..134,\n-                insert: \"the_method()$0\",\n-                kind: Method,\n-                lookup: \"the_method\",\n-                detail: \"fn the_method(&self)\",\n-            },\n-        ]\n-        \"###\n+    fn test_union_field_completion() {\n+        check(\n+            r#\"\n+union U { field: u8, other: u16 }\n+fn foo(u: U) { u.<|> }\n+\"#,\n+            expect![[r#\"\n+                fd field u8\n+                fd other u16\n+            \"#]],\n         );\n     }\n \n     #[test]\n-    fn test_method_completion_private() {\n-        assert_debug_snapshot!(\n-            do_ref_completion(\n-                r\"\n-            struct A {}\n-            mod m {\n-                impl super::A {\n-                    fn private_method(&self) {}\n-                    pub(super) fn the_method(&self) {}\n-                }\n-            }\n-            fn foo(a: A) {\n-               a.<|>\n-            }\n-            \",\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_method()\",\n-                source_range: 147..147,\n-                delete: 147..147,\n-                insert: \"the_method()$0\",\n-                kind: Method,\n-                lookup: \"the_method\",\n-                detail: \"pub(super) fn the_method(&self)\",\n-            },\n-        ]\n-        \"###\n-        );\n+    fn test_method_completion_only_fitting_impls() {\n+        check(\n+            r#\"\n+struct A<T> {}\n+impl A<u32> {\n+    fn the_method(&self) {}\n+}\n+impl A<i32> {\n+    fn the_other_method(&self) {}\n+}\n+fn foo(a: A<u32>) { a.<|> }\n+\"#,\n+            expect![[r#\"\n+                me the_method() fn the_method(&self)\n+            \"#]],\n+        )\n     }\n \n     #[test]\n     fn test_trait_method_completion() {\n-        assert_debug_snapshot!(\n-            do_ref_completion(\n-                r\"\n-            struct A {}\n-            trait Trait { fn the_method(&self); }\n-            impl Trait for A {}\n-            fn foo(a: A) {\n-               a.<|>\n-            }\n-            \",\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_method()\",\n-                source_range: 90..90,\n-                delete: 90..90,\n-                insert: \"the_method()$0\",\n-                kind: Method,\n-                lookup: \"the_method\",\n-                detail: \"fn the_method(&self)\",\n-            },\n-        ]\n-        \"###\n+        check(\n+            r#\"\n+struct A {}\n+trait Trait { fn the_method(&self); }\n+impl Trait for A {}\n+fn foo(a: A) { a.<|> }\n+\"#,\n+            expect![[r#\"\n+                me the_method() fn the_method(&self)\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn test_trait_method_completion_deduplicated() {\n-        assert_debug_snapshot!(\n-            do_ref_completion(\n-                r\"\n-            struct A {}\n-            trait Trait { fn the_method(&self); }\n-            impl<T> Trait for T {}\n-            fn foo(a: &A) {\n-               a.<|>\n-            }\n-            \",\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_method()\",\n-                source_range: 94..94,\n-                delete: 94..94,\n-                insert: \"the_method()$0\",\n-                kind: Method,\n-                lookup: \"the_method\",\n-                detail: \"fn the_method(&self)\",\n-            },\n-        ]\n-        \"###\n+        check(\n+            r\"\n+struct A {}\n+trait Trait { fn the_method(&self); }\n+impl<T> Trait for T {}\n+fn foo(a: &A) { a.<|> }\n+\",\n+            expect![[r#\"\n+                me the_method() fn the_method(&self)\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn completes_trait_method_from_other_module() {\n-        assert_debug_snapshot!(\n-            do_ref_completion(\n-                r\"\n-            struct A {}\n-            mod m {\n-                pub trait Trait { fn the_method(&self); }\n-            }\n-            use m::Trait;\n-            impl Trait for A {}\n-            fn foo(a: A) {\n-               a.<|>\n-            }\n-            \",\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_method()\",\n-                source_range: 122..122,\n-                delete: 122..122,\n-                insert: \"the_method()$0\",\n-                kind: Method,\n-                lookup: \"the_method\",\n-                detail: \"fn the_method(&self)\",\n-            },\n-        ]\n-        \"###\n-        );\n-    }\n-\n-    #[test]\n-    fn test_no_non_self_method() {\n-        assert_debug_snapshot!(\n-        do_ref_completion(\n+        check(\n             r\"\n-            struct A {}\n-            impl A {\n-                fn the_method() {}\n-            }\n-            fn foo(a: A) {\n-               a.<|>\n-            }\n-            \",\n-        ),\n-        @\"[]\"\n+struct A {}\n+mod m {\n+    pub trait Trait { fn the_method(&self); }\n+}\n+use m::Trait;\n+impl Trait for A {}\n+fn foo(a: A) { a.<|> }\n+\",\n+            expect![[r#\"\n+                me the_method() fn the_method(&self)\n+            \"#]],\n         );\n     }\n \n     #[test]\n-    fn test_method_attr_filtering() {\n-        assert_debug_snapshot!(\n-        do_ref_completion(\n-            r\"\n-            struct A {}\n-            impl A {\n-                #[inline]\n-                fn the_method(&self) {\n-                    let x = 1;\n-                    let y = 2;\n-                }\n-            }\n-            fn foo(a: A) {\n-               a.<|>\n-            }\n-            \",\n-        ),\n-        @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_method()\",\n-                source_range: 128..128,\n-                delete: 128..128,\n-                insert: \"the_method()$0\",\n-                kind: Method,\n-                lookup: \"the_method\",\n-                detail: \"fn the_method(&self)\",\n-            },\n-        ]\n-        \"###\n+    fn test_no_non_self_method() {\n+        check(\n+            r#\"\n+struct A {}\n+impl A {\n+    fn the_method() {}\n+}\n+fn foo(a: A) {\n+   a.<|>\n+}\n+\"#,\n+            expect![[\"\"]],\n         );\n     }\n \n     #[test]\n     fn test_tuple_field_completion() {\n-        assert_debug_snapshot!(\n-        do_ref_completion(\n-            r\"\n-            fn foo() {\n-               let b = (0, 3.14);\n-               b.<|>\n-            }\n-            \",\n-        ),\n-        @r###\"\n-        [\n-            CompletionItem {\n-                label: \"0\",\n-                source_range: 38..38,\n-                delete: 38..38,\n-                insert: \"0\",\n-                kind: Field,\n-                detail: \"i32\",\n-            },\n-            CompletionItem {\n-                label: \"1\",\n-                source_range: 38..38,\n-                delete: 38..38,\n-                insert: \"1\",\n-                kind: Field,\n-                detail: \"f64\",\n-            },\n-        ]\n-        \"###\n-        );\n+        check(\n+            r#\"\n+fn foo() {\n+   let b = (0, 3.14);\n+   b.<|>\n+}\n+\"#,\n+            expect![[r#\"\n+                fd 0 i32\n+                fd 1 f64\n+            \"#]],\n+        )\n     }\n \n     #[test]\n     fn test_tuple_field_inference() {\n-        assert_debug_snapshot!(\n-        do_ref_completion(\n-            r\"\n-            pub struct S;\n-            impl S {\n-                pub fn blah(&self) {}\n-            }\n+        check(\n+            r#\"\n+pub struct S;\n+impl S { pub fn blah(&self) {} }\n \n-            struct T(S);\n+struct T(S);\n \n-            impl T {\n-                fn foo(&self) {\n-                    // FIXME: This doesn't work without the trailing `a` as `0.` is a float\n-                    self.0.a<|>\n-                }\n-            }\n-            \",\n-        ),\n-        @r###\"\n-        [\n-            CompletionItem {\n-                label: \"blah()\",\n-                source_range: 190..191,\n-                delete: 190..191,\n-                insert: \"blah()$0\",\n-                kind: Method,\n-                lookup: \"blah\",\n-                detail: \"pub fn blah(&self)\",\n-            },\n-        ]\n-        \"###\n-        );\n+impl T {\n+    fn foo(&self) {\n+        // FIXME: This doesn't work without the trailing `a` as `0.` is a float\n+        self.0.a<|>\n     }\n-\n-    #[test]\n-    fn test_completion_works_in_consts() {\n-        assert_debug_snapshot!(\n-        do_ref_completion(\n-            r\"\n-            struct A { the_field: u32 }\n-            const X: u32 = {\n-                A { the_field: 92 }.<|>\n-            };\n-            \",\n-        ),\n-        @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: 69..69,\n-                delete: 69..69,\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###\n+}\n+\"#,\n+            expect![[r#\"\n+                me blah() pub fn blah(&self)\n+            \"#]],\n         );\n     }\n \n     #[test]\n-    fn test_completion_await_impls_future() {\n-        assert_debug_snapshot!(\n-        do_completion(\n-            r###\"\n-            //- /main.rs\n-            use std::future::*;\n-            struct A {}\n-            impl Future for A {}\n-            fn foo(a: A) {\n-                a.<|>\n-            }\n-\n-            //- /std/lib.rs\n-            pub mod future {\n-                #[lang = \"future_trait\"]\n-                pub trait Future {}\n-            }\n-            \"###, CompletionKind::Keyword),\n-        @r###\"\n-        [\n-            CompletionItem {\n-                label: \"await\",\n-                source_range: 74..74,\n-                delete: 74..74,\n-                insert: \"await\",\n-                detail: \"expr.await\",\n-            },\n-        ]\n-        \"###\n-        )\n-    }\n-\n-    #[test]\n-    fn test_super_super_completion() {\n-        assert_debug_snapshot!(\n-        do_ref_completion(\n-                r\"\n-                mod a {\n-                    const A: usize = 0;\n-\n-                    mod b {\n-                        const B: usize = 0;\n-\n-                        mod c {\n-                            use super::super::<|>\n-                        }\n-                    }\n-                }\n-                \",\n-        ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"A\",\n-                source_range: 120..120,\n-                delete: 120..120,\n-                insert: \"A\",\n-                kind: Const,\n-            },\n-            CompletionItem {\n-                label: \"b\",\n-                source_range: 120..120,\n-                delete: 120..120,\n-                insert: \"b\",\n-                kind: Module,\n-            },\n-        ]\n-        \"###\n+    fn test_completion_works_in_consts() {\n+        check(\n+            r#\"\n+struct A { the_field: u32 }\n+const X: u32 = {\n+    A { the_field: 92 }.<|>\n+};\n+\"#,\n+            expect![[r#\"\n+                fd the_field u32\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn works_in_simple_macro_1() {\n-        assert_debug_snapshot!(\n-            do_ref_completion(\n-                r\"\n-                macro_rules! m { ($e:expr) => { $e } }\n-                struct A { the_field: u32 }\n-                fn foo(a: A) {\n-                    m!(a.x<|>)\n-                }\n-                \",\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: 91..92,\n-                delete: 91..92,\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###\n-        );\n-    }\n-\n-    #[test]\n-    fn works_in_simple_macro_recursive() {\n-        assert_debug_snapshot!(\n-            do_ref_completion(\n-                r\"\n-                macro_rules! m { ($e:expr) => { $e } }\n-                struct A { the_field: u32 }\n-                fn foo(a: A) {\n-                    m!(a.x<|>)\n-                }\n-                \",\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: 91..92,\n-                delete: 91..92,\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###\n+        check(\n+            r#\"\n+macro_rules! m { ($e:expr) => { $e } }\n+struct A { the_field: u32 }\n+fn foo(a: A) {\n+    m!(a.x<|>)\n+}\n+\"#,\n+            expect![[r#\"\n+                fd the_field u32\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn works_in_simple_macro_2() {\n         // this doesn't work yet because the macro doesn't expand without the token -- maybe it can be fixed with better recovery\n-        assert_debug_snapshot!(\n-            do_ref_completion(\n-                r\"\n-                macro_rules! m { ($e:expr) => { $e } }\n-                struct A { the_field: u32 }\n-                fn foo(a: A) {\n-                    m!(a.<|>)\n-                }\n-                \",\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: 91..91,\n-                delete: 91..91,\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###\n+        check(\n+            r#\"\n+macro_rules! m { ($e:expr) => { $e } }\n+struct A { the_field: u32 }\n+fn foo(a: A) {\n+    m!(a.<|>)\n+}\n+\"#,\n+            expect![[r#\"\n+                fd the_field u32\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn works_in_simple_macro_recursive_1() {\n-        assert_debug_snapshot!(\n-            do_ref_completion(\n-                r\"\n-                macro_rules! m { ($e:expr) => { $e } }\n-                struct A { the_field: u32 }\n-                fn foo(a: A) {\n-                    m!(m!(m!(a.x<|>)))\n-                }\n-                \",\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: 97..98,\n-                delete: 97..98,\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###\n+        check(\n+            r#\"\n+macro_rules! m { ($e:expr) => { $e } }\n+struct A { the_field: u32 }\n+fn foo(a: A) {\n+    m!(m!(m!(a.x<|>)))\n+}\n+\"#,\n+            expect![[r#\"\n+                fd the_field u32\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn macro_expansion_resilient() {\n-        assert_debug_snapshot!(\n-            do_ref_completion(\n-                r\"\n-                macro_rules! dbg {\n-                    () => {};\n-                    ($val:expr) => {\n-                        match $val { tmp => { tmp } }\n-                    };\n-                    // Trailing comma with single argument is ignored\n-                    ($val:expr,) => { $crate::dbg!($val) };\n-                    ($($val:expr),+ $(,)?) => {\n-                        ($($crate::dbg!($val)),+,)\n-                    };\n-                }\n-                struct A { the_field: u32 }\n-                fn foo(a: A) {\n-                    dbg!(a.<|>)\n-                }\n-                \",\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: 327..327,\n-                delete: 327..327,\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###\n+        check(\n+            r#\"\n+macro_rules! dbg {\n+    () => {};\n+    ($val:expr) => {\n+        match $val { tmp => { tmp } }\n+    };\n+    // Trailing comma with single argument is ignored\n+    ($val:expr,) => { $crate::dbg!($val) };\n+    ($($val:expr),+ $(,)?) => {\n+        ($($crate::dbg!($val)),+,)\n+    };\n+}\n+struct A { the_field: u32 }\n+fn foo(a: A) {\n+    dbg!(a.<|>)\n+}\n+\"#,\n+            expect![[r#\"\n+                fd the_field u32\n+            \"#]],\n         );\n     }\n \n     #[test]\n-    fn test_method_completion_3547() {\n-        assert_debug_snapshot!(\n-            do_ref_completion(\n-                r\"\n-            struct HashSet<T> {}\n-            impl<T> HashSet<T> {\n-                pub fn the_method(&self) {}\n-            }\n-            fn foo() {\n-                let s: HashSet<_>;\n-                s.<|>\n-            }\n-            \",\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_method()\",\n-                source_range: 116..116,\n-                delete: 116..116,\n-                insert: \"the_method()$0\",\n-                kind: Method,\n-                lookup: \"the_method\",\n-                detail: \"pub fn the_method(&self)\",\n-            },\n-        ]\n-        \"###\n+    fn test_method_completion_issue_3547() {\n+        check(\n+            r#\"\n+struct HashSet<T> {}\n+impl<T> HashSet<T> {\n+    pub fn the_method(&self) {}\n+}\n+fn foo() {\n+    let s: HashSet<_>;\n+    s.<|>\n+}\n+\"#,\n+            expect![[r#\"\n+                me the_method() pub fn the_method(&self)\n+            \"#]],\n         );\n     }\n }"}, {"sha": "340d57a49c605f2b0769749d989bcfb310af06c2", "filename": "crates/ra_ide/src/completion/complete_keyword.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f2f6a46aa4751393ae18e8b21aa631c9919c5f43/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f6a46aa4751393ae18e8b21aa631c9919c5f43/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs?ref=f2f6a46aa4751393ae18e8b21aa631c9919c5f43", "patch": "@@ -35,6 +35,19 @@ pub(super) fn complete_use_tree_keyword(acc: &mut Completions, ctx: &CompletionC\n         }\n         _ => {}\n     }\n+\n+    // Suggest .await syntax for types that implement Future trait\n+    if let Some(receiver) = &ctx.dot_receiver {\n+        if let Some(ty) = ctx.sema.type_of_expr(receiver) {\n+            if ty.impls_future(ctx.db) {\n+                CompletionItem::new(CompletionKind::Keyword, ctx.source_range(), \"await\")\n+                    .kind(CompletionItemKind::Keyword)\n+                    .detail(\"expr.await\")\n+                    .insert_text(\"await\")\n+                    .add_to(acc);\n+            }\n+        };\n+    }\n }\n \n pub(super) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionContext) {\n@@ -490,4 +503,26 @@ Some multi-line comment<|>\n             expect![[\"\"]],\n         );\n     }\n+\n+    #[test]\n+    fn test_completion_await_impls_future() {\n+        check(\n+            r#\"\n+//- /main.rs\n+use std::future::*;\n+struct A {}\n+impl Future for A {}\n+fn foo(a: A) { a.<|> }\n+\n+//- /std/lib.rs\n+pub mod future {\n+    #[lang = \"future_trait\"]\n+    pub trait Future {}\n+}\n+\"#,\n+            expect![[r#\"\n+                kw await expr.await\n+            \"#]],\n+        )\n+    }\n }"}, {"sha": "a16866cd2d4223dfbd1aee054bb3cd3a697c44dd", "filename": "crates/ra_ide/src/completion/complete_qualified_path.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f2f6a46aa4751393ae18e8b21aa631c9919c5f43/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f6a46aa4751393ae18e8b21aa631c9919c5f43/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs?ref=f2f6a46aa4751393ae18e8b21aa631c9919c5f43", "patch": "@@ -1205,6 +1205,45 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn test_super_super_completion() {\n+        assert_debug_snapshot!(\n+            do_reference_completion(\n+                r\"\n+                mod a {\n+                    const A: usize = 0;\n+\n+                    mod b {\n+                        const B: usize = 0;\n+\n+                        mod c {\n+                            use super::super::<|>\n+                        }\n+                    }\n+                }\n+                \",\n+        ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"A\",\n+                source_range: 120..120,\n+                delete: 120..120,\n+                insert: \"A\",\n+                kind: Const,\n+            },\n+            CompletionItem {\n+                label: \"b\",\n+                source_range: 120..120,\n+                delete: 120..120,\n+                insert: \"b\",\n+                kind: Module,\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n     #[test]\n     fn completes_reexported_items_under_correct_name() {\n         assert_debug_snapshot!("}, {"sha": "dc391c46bc1d24c27030100a8da3c70f87eebeb6", "filename": "crates/ra_ide/src/completion/presentation.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/f2f6a46aa4751393ae18e8b21aa631c9919c5f43/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f6a46aa4751393ae18e8b21aa631c9919c5f43/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=f2f6a46aa4751393ae18e8b21aa631c9919c5f43", "patch": "@@ -643,6 +643,75 @@ fn foo() { A { the<|> } }\n         );\n     }\n \n+    #[test]\n+    fn renders_docs() {\n+        check(\n+            r#\"\n+struct S {\n+    /// Field docs\n+    foo:\n+}\n+impl S {\n+    /// Method docs\n+    fn bar(self) { self.<|> }\n+}\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"bar()\",\n+                        source_range: 94..94,\n+                        delete: 94..94,\n+                        insert: \"bar()$0\",\n+                        kind: Method,\n+                        lookup: \"bar\",\n+                        detail: \"fn bar(self)\",\n+                        documentation: Documentation(\n+                            \"Method docs\",\n+                        ),\n+                    },\n+                    CompletionItem {\n+                        label: \"foo\",\n+                        source_range: 94..94,\n+                        delete: 94..94,\n+                        insert: \"foo\",\n+                        kind: Field,\n+                        detail: \"{unknown}\",\n+                        documentation: Documentation(\n+                            \"Field docs\",\n+                        ),\n+                    },\n+                ]\n+            \"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn dont_render_attrs() {\n+        check(\n+            r#\"\n+struct S;\n+impl S {\n+    #[inline]\n+    fn the_method(&self) { }\n+}\n+fn foo(s: S) { s.<|> }\n+\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"the_method()\",\n+                        source_range: 81..81,\n+                        delete: 81..81,\n+                        insert: \"the_method()$0\",\n+                        kind: Method,\n+                        lookup: \"the_method\",\n+                        detail: \"fn the_method(&self)\",\n+                    },\n+                ]\n+            \"#]],\n+        )\n+    }\n+\n     #[test]\n     fn inserts_parens_for_function_calls() {\n         mark::check!(inserts_parens_for_function_calls);"}]}