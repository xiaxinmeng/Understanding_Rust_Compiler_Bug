{"sha": "79a5448f41dcc6ab52663105a6b02fc5af4c503e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5YTU0NDhmNDFkY2M2YWI1MjY2MzEwNWE2YjAyZmM1YWY0YzUwM2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-13T20:36:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-13T20:36:02Z"}, "message": "auto merge of #17188 : thestinger/rust/tvec, r=pcwalton\n\n`Box<[T]>` is created by allocating `Box<[T, ..n]>` and coercing it so\r\nthis code path is never used. It's also broken because it clamps the\r\ncapacity of the memory allocations to 4 elements and that's incompatible\r\nwith sized deallocation. This dates back to when `~[T]` was a growable\r\nvector type implemented as:\r\n\r\n*{ { tydesc, ref_count, prev, next }, { length, capacity, data[] } }\r\n\r\nSince even empty vectors had to allocate, it started off the capacity of\r\nall vectors at 4 as a heuristic. It's not possible to grow `Box<[T]>`\r\nand there is no need for a memory allocation when it's empty, so it\r\nwould be a terrible heuristic today even if it worked.", "tree": {"sha": "3cbc563de1bf23fc598bfe078e24333724bd7f92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3cbc563de1bf23fc598bfe078e24333724bd7f92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79a5448f41dcc6ab52663105a6b02fc5af4c503e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79a5448f41dcc6ab52663105a6b02fc5af4c503e", "html_url": "https://github.com/rust-lang/rust/commit/79a5448f41dcc6ab52663105a6b02fc5af4c503e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79a5448f41dcc6ab52663105a6b02fc5af4c503e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7277fe9ee790a5f2fe2131b62a21537ac04e4cfd", "url": "https://api.github.com/repos/rust-lang/rust/commits/7277fe9ee790a5f2fe2131b62a21537ac04e4cfd", "html_url": "https://github.com/rust-lang/rust/commit/7277fe9ee790a5f2fe2131b62a21537ac04e4cfd"}, {"sha": "0fc06b14c5fcbf6efb26c48c9d396e63dca02946", "url": "https://api.github.com/repos/rust-lang/rust/commits/0fc06b14c5fcbf6efb26c48c9d396e63dca02946", "html_url": "https://github.com/rust-lang/rust/commit/0fc06b14c5fcbf6efb26c48c9d396e63dca02946"}], "stats": {"total": 110, "additions": 1, "deletions": 109}, "files": [{"sha": "54394b8d74169ce9e23b7e135cf5fed6ffd3b0ad", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/79a5448f41dcc6ab52663105a6b02fc5af4c503e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79a5448f41dcc6ab52663105a6b02fc5af4c503e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=79a5448f41dcc6ab52663105a6b02fc5af4c503e", "patch": "@@ -587,25 +587,7 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let contents_ty = expr_ty(bcx, &**contents);\n             match ty::get(box_ty).sty {\n                 ty::ty_uniq(..) => {\n-                    let is_vec = match contents.node {\n-                        ast::ExprRepeat(..) | ast::ExprVec(..) => true,\n-                        ast::ExprLit(lit) => match lit.node {\n-                            ast::LitStr(..) => true,\n-                            _ => false\n-                        },\n-                        _ => false\n-                    };\n-\n-                    if is_vec {\n-                        // Special case for owned vectors.\n-                        fcx.push_ast_cleanup_scope(contents.id);\n-                        let datum = unpack_datum!(\n-                            bcx, tvec::trans_uniq_vec(bcx, expr, &**contents));\n-                        bcx = fcx.pop_and_trans_ast_cleanup_scope(bcx, contents.id);\n-                        DatumBlock::new(bcx, datum)\n-                    } else {\n-                        trans_uniq_expr(bcx, box_ty, &**contents, contents_ty)\n-                    }\n+                    trans_uniq_expr(bcx, box_ty, &**contents, contents_ty)\n                 }\n                 ty::ty_box(..) => {\n                     trans_managed_expr(bcx, box_ty, &**contents, contents_ty)"}, {"sha": "8a915bbfff4548b7bcf6087b9893228add3c1de2", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/79a5448f41dcc6ab52663105a6b02fc5af4c503e/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79a5448f41dcc6ab52663105a6b02fc5af4c503e/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=79a5448f41dcc6ab52663105a6b02fc5af4c503e", "patch": "@@ -13,11 +13,9 @@\n use back::abi;\n use llvm;\n use llvm::{ValueRef};\n-use middle::lang_items::StrDupUniqFnLangItem;\n use middle::trans::base::*;\n use middle::trans::base;\n use middle::trans::build::*;\n-use middle::trans::callee;\n use middle::trans::cleanup;\n use middle::trans::cleanup::CleanupMethods;\n use middle::trans::common::*;\n@@ -241,94 +239,6 @@ pub fn trans_lit_str<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-pub fn trans_uniq_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                  uniq_expr: &ast::Expr,\n-                                  content_expr: &ast::Expr)\n-                                  -> DatumBlock<'blk, 'tcx, Expr> {\n-    /*!\n-     * Box<[...]> and \"...\".to_string() allocate boxes in the exchange heap and write\n-     * the array elements into them.\n-     */\n-\n-    debug!(\"trans_uniq_vec(uniq_expr={})\", bcx.expr_to_string(uniq_expr));\n-    let fcx = bcx.fcx;\n-    let ccx = fcx.ccx;\n-\n-    // Handle \"\".to_string().\n-    match content_expr.node {\n-        ast::ExprLit(lit) => {\n-            match lit.node {\n-                ast::LitStr(ref s, _) => {\n-                    let llptrval = C_cstr(ccx, (*s).clone(), false);\n-                    let llptrval = PointerCast(bcx, llptrval, Type::i8p(ccx));\n-                    let llsizeval = C_uint(ccx, s.get().len());\n-                    let typ = ty::mk_uniq(bcx.tcx(), ty::mk_str(bcx.tcx()));\n-                    let lldestval = rvalue_scratch_datum(bcx,\n-                                                         typ,\n-                                                         \"\");\n-                    let alloc_fn = langcall(bcx,\n-                                            Some(lit.span),\n-                                            \"\",\n-                                            StrDupUniqFnLangItem);\n-                    let bcx = callee::trans_lang_call(\n-                        bcx,\n-                        alloc_fn,\n-                        [ llptrval, llsizeval ],\n-                        Some(expr::SaveIn(lldestval.val))).bcx;\n-                    return DatumBlock::new(bcx, lldestval).to_expr_datumblock();\n-                }\n-                _ => {}\n-            }\n-        }\n-        _ => {}\n-    }\n-\n-    let vt = vec_types_from_expr(bcx, content_expr);\n-    let count = elements_required(bcx, content_expr);\n-    debug!(\"    vt={}, count={:?}\", vt.to_string(ccx), count);\n-    let vec_ty = node_id_type(bcx, uniq_expr.id);\n-\n-    let llty = type_of::type_of(ccx, vt.unit_ty);\n-    let unit_sz = nonzero_llsize_of(ccx, llty);\n-    let llcount = if count < 4u {\n-        C_int(ccx, 4)\n-    } else {\n-        C_uint(ccx, count)\n-    };\n-    let alloc = Mul(bcx, llcount, unit_sz);\n-    let llty_ptr = llty.ptr_to();\n-    let align = C_uint(ccx, machine::llalign_of_min(ccx, llty) as uint);\n-    let Result { bcx: bcx, val: dataptr } = malloc_raw_dyn(bcx,\n-                                                           llty_ptr,\n-                                                           vec_ty,\n-                                                           alloc,\n-                                                           align);\n-\n-    // Create a temporary scope lest execution should fail while\n-    // constructing the vector.\n-    let temp_scope = fcx.push_custom_cleanup_scope();\n-\n-    fcx.schedule_free_slice(cleanup::CustomScope(temp_scope),\n-                            dataptr, alloc, align, cleanup::HeapExchange);\n-\n-    debug!(\"    alloc_uniq_vec() returned dataptr={}, len={}\",\n-           bcx.val_to_string(dataptr), count);\n-\n-    let bcx = write_content(bcx, &vt, uniq_expr,\n-                            content_expr, SaveIn(dataptr));\n-\n-    fcx.pop_custom_cleanup_scope(temp_scope);\n-\n-    if ty::type_is_sized(bcx.tcx(), vec_ty) {\n-        immediate_rvalue_bcx(bcx, dataptr, vec_ty).to_expr_datumblock()\n-    } else {\n-        let scratch = rvalue_scratch_datum(bcx, vec_ty, \"\");\n-        Store(bcx, dataptr, GEPi(bcx, scratch.val, [0u, abi::slice_elt_base]));\n-        Store(bcx, llcount, GEPi(bcx, scratch.val, [0u, abi::slice_elt_len]));\n-        DatumBlock::new(bcx, scratch.to_expr_datum())\n-    }\n-}\n-\n pub fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                  vt: &VecTypes,\n                                  vstore_expr: &ast::Expr,"}]}