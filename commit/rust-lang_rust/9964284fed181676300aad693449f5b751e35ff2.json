{"sha": "9964284fed181676300aad693449f5b751e35ff2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5NjQyODRmZWQxODE2NzYzMDBhYWQ2OTM0NDlmNWI3NTFlMzVmZjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-17T12:15:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-17T12:15:26Z"}, "message": "Auto merge of #84571 - jedel1043:issue-49804-impl, r=petrochenkov\n\nParse unnamed fields of struct and union type\n\nAdded the `unnamed_fields` feature gate.\n\nThis is a prototype of [RFC 2102](https://github.com/rust-lang/rust/issues/49804), so any suggestions are greatly appreciated.\n\nr? `@petrochenkov`", "tree": {"sha": "03eb105fdadb767ef2ab06ddb5c834afb80aa2ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03eb105fdadb767ef2ab06ddb5c834afb80aa2ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9964284fed181676300aad693449f5b751e35ff2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9964284fed181676300aad693449f5b751e35ff2", "html_url": "https://github.com/rust-lang/rust/commit/9964284fed181676300aad693449f5b751e35ff2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9964284fed181676300aad693449f5b751e35ff2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44ec846f4ea68ffa6d06e7d68f078bd3cc59d4ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/44ec846f4ea68ffa6d06e7d68f078bd3cc59d4ec", "html_url": "https://github.com/rust-lang/rust/commit/44ec846f4ea68ffa6d06e7d68f078bd3cc59d4ec"}, {"sha": "64acb7d92135ae722dfce89f0ca9d7cf6576de66", "url": "https://api.github.com/repos/rust-lang/rust/commits/64acb7d92135ae722dfce89f0ca9d7cf6576de66", "html_url": "https://github.com/rust-lang/rust/commit/64acb7d92135ae722dfce89f0ca9d7cf6576de66"}], "stats": {"total": 819, "additions": 707, "deletions": 112}, "files": [{"sha": "b3bac1d7ecdefd1525320faa61b892de9c572c30", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9964284fed181676300aad693449f5b751e35ff2/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9964284fed181676300aad693449f5b751e35ff2/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=9964284fed181676300aad693449f5b751e35ff2", "patch": "@@ -1861,6 +1861,10 @@ pub enum TyKind {\n     Never,\n     /// A tuple (`(A, B, C, D,...)`).\n     Tup(Vec<P<Ty>>),\n+    /// An anonymous struct type i.e. `struct { foo: Type }`\n+    AnonymousStruct(Vec<FieldDef>, bool),\n+    /// An anonymous union type i.e. `union { bar: Type }`\n+    AnonymousUnion(Vec<FieldDef>, bool),\n     /// A path (`module::module::...::Type`), optionally\n     /// \"qualified\", e.g., `<Vec<T> as SomeTrait>::SomeType`.\n     ///"}, {"sha": "071d41ea2b2c7c83718af8fd8b9b65cc307b9d2e", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9964284fed181676300aad693449f5b751e35ff2/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9964284fed181676300aad693449f5b751e35ff2/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=9964284fed181676300aad693449f5b751e35ff2", "patch": "@@ -484,6 +484,9 @@ pub fn noop_visit_ty<T: MutVisitor>(ty: &mut P<Ty>, vis: &mut T) {\n             visit_vec(bounds, |bound| vis.visit_param_bound(bound));\n         }\n         TyKind::MacCall(mac) => vis.visit_mac_call(mac),\n+        TyKind::AnonymousStruct(fields, ..) | TyKind::AnonymousUnion(fields, ..) => {\n+            fields.flat_map_in_place(|field| vis.flat_map_field_def(field));\n+        }\n     }\n     vis.visit_span(span);\n     visit_lazy_tts(tokens, vis);"}, {"sha": "f1a99bc51c96d0eb1c8de4be0d0b83de317104ec", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9964284fed181676300aad693449f5b751e35ff2/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9964284fed181676300aad693449f5b751e35ff2/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=9964284fed181676300aad693449f5b751e35ff2", "patch": "@@ -404,6 +404,9 @@ pub fn walk_ty<'a, V: Visitor<'a>>(visitor: &mut V, typ: &'a Ty) {\n         TyKind::Typeof(ref expression) => visitor.visit_anon_const(expression),\n         TyKind::Infer | TyKind::ImplicitSelf | TyKind::Err => {}\n         TyKind::MacCall(ref mac) => visitor.visit_mac_call(mac),\n+        TyKind::AnonymousStruct(ref fields, ..) | TyKind::AnonymousUnion(ref fields, ..) => {\n+            walk_list!(visitor, visit_field_def, fields)\n+        }\n         TyKind::Never | TyKind::CVarArgs => {}\n     }\n }"}, {"sha": "292643d6d7510821cdbf653455290170dda6bd86", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9964284fed181676300aad693449f5b751e35ff2/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9964284fed181676300aad693449f5b751e35ff2/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=9964284fed181676300aad693449f5b751e35ff2", "patch": "@@ -789,7 +789,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n     }\n \n-    fn lower_field_def(&mut self, (index, f): (usize, &FieldDef)) -> hir::FieldDef<'hir> {\n+    pub(super) fn lower_field_def(\n+        &mut self,\n+        (index, f): (usize, &FieldDef),\n+    ) -> hir::FieldDef<'hir> {\n         let ty = if let TyKind::Path(ref qself, ref path) = f.ty.kind {\n             let t = self.lower_path_ty(\n                 &f.ty,"}, {"sha": "740dfc65df8c5c1e824fe966501730e32bb791e5", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9964284fed181676300aad693449f5b751e35ff2/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9964284fed181676300aad693449f5b751e35ff2/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=9964284fed181676300aad693449f5b751e35ff2", "patch": "@@ -1267,6 +1267,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let kind = match t.kind {\n             TyKind::Infer => hir::TyKind::Infer,\n             TyKind::Err => hir::TyKind::Err,\n+            // FIXME(unnamed_fields): IMPLEMENTATION IN PROGRESS\n+            TyKind::AnonymousStruct(ref _fields, _recovered) => {\n+                self.sess.struct_span_err(t.span, \"anonymous structs are unimplemented\").emit();\n+                hir::TyKind::Err\n+            }\n+            TyKind::AnonymousUnion(ref _fields, _recovered) => {\n+                self.sess.struct_span_err(t.span, \"anonymous unions are unimplemented\").emit();\n+                hir::TyKind::Err\n+            }\n             TyKind::Slice(ref ty) => hir::TyKind::Slice(self.lower_ty(ty, itctx)),\n             TyKind::Ptr(ref mt) => hir::TyKind::Ptr(self.lower_mt(mt, itctx)),\n             TyKind::Rptr(ref region, ref mt) => {"}, {"sha": "ba2da7694978d9791f5326da3eee0b179e38da11", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 184, "deletions": 70, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/9964284fed181676300aad693449f5b751e35ff2/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9964284fed181676300aad693449f5b751e35ff2/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=9964284fed181676300aad693449f5b751e35ff2", "patch": "@@ -175,10 +175,30 @@ impl<'a> AstValidator<'a> {\n                     }\n                 }\n             }\n+            TyKind::AnonymousStruct(ref fields, ..) | TyKind::AnonymousUnion(ref fields, ..) => {\n+                self.with_banned_assoc_ty_bound(|this| {\n+                    walk_list!(this, visit_struct_field_def, fields)\n+                });\n+            }\n             _ => visit::walk_ty(self, t),\n         }\n     }\n \n+    fn visit_struct_field_def(&mut self, field: &'a FieldDef) {\n+        if let Some(ident) = field.ident {\n+            if ident.name == kw::Underscore {\n+                self.check_anonymous_field(field);\n+                self.visit_vis(&field.vis);\n+                self.visit_ident(ident);\n+                self.visit_ty_common(&field.ty);\n+                self.walk_ty(&field.ty);\n+                walk_list!(self, visit_attribute, &field.attrs);\n+                return;\n+            }\n+        }\n+        self.visit_field_def(field);\n+    }\n+\n     fn err_handler(&self) -> &rustc_errors::Handler {\n         &self.session.diagnostic()\n     }\n@@ -213,6 +233,66 @@ impl<'a> AstValidator<'a> {\n         err.emit();\n     }\n \n+    fn check_anonymous_field(&self, field: &FieldDef) {\n+        let FieldDef { ty, .. } = field;\n+        match &ty.kind {\n+            TyKind::AnonymousStruct(..) | TyKind::AnonymousUnion(..) => {\n+                // We already checked for `kw::Underscore` before calling this function,\n+                // so skip the check\n+            }\n+            TyKind::Path(..) => {\n+                // If the anonymous field contains a Path as type, we can't determine\n+                // if the path is a valid struct or union, so skip the check\n+            }\n+            _ => {\n+                let msg = \"unnamed fields can only have struct or union types\";\n+                let label = \"not a struct or union\";\n+                self.err_handler()\n+                    .struct_span_err(field.span, msg)\n+                    .span_label(ty.span, label)\n+                    .emit();\n+            }\n+        }\n+    }\n+\n+    fn deny_anonymous_struct(&self, ty: &Ty) {\n+        match &ty.kind {\n+            TyKind::AnonymousStruct(..) => {\n+                self.err_handler()\n+                    .struct_span_err(\n+                        ty.span,\n+                        \"anonymous structs are not allowed outside of unnamed struct or union fields\",\n+                    )\n+                    .span_label(ty.span, \"anonymous struct declared here\")\n+                    .emit();\n+            }\n+            TyKind::AnonymousUnion(..) => {\n+                self.err_handler()\n+                    .struct_span_err(\n+                        ty.span,\n+                        \"anonymous unions are not allowed outside of unnamed struct or union fields\",\n+                    )\n+                    .span_label(ty.span, \"anonymous union declared here\")\n+                    .emit();\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn deny_anonymous_field(&self, field: &FieldDef) {\n+        if let Some(ident) = field.ident {\n+            if ident.name == kw::Underscore {\n+                self.err_handler()\n+                    .struct_span_err(\n+                        field.span,\n+                        \"anonymous fields are not allowed outside of structs or unions\",\n+                    )\n+                    .span_label(ident.span, \"anonymous field declared here\")\n+                    .emit()\n+            }\n+        }\n+    }\n+\n     fn check_decl_no_pat(decl: &FnDecl, mut report_err: impl FnMut(Span, Option<Ident>, bool)) {\n         for Param { pat, .. } in &decl.inputs {\n             match pat.kind {\n@@ -732,6 +812,71 @@ impl<'a> AstValidator<'a> {\n             )\n             .emit();\n     }\n+\n+    fn visit_ty_common(&mut self, ty: &'a Ty) {\n+        match ty.kind {\n+            TyKind::BareFn(ref bfty) => {\n+                self.check_fn_decl(&bfty.decl, SelfSemantic::No);\n+                Self::check_decl_no_pat(&bfty.decl, |span, _, _| {\n+                    struct_span_err!(\n+                        self.session,\n+                        span,\n+                        E0561,\n+                        \"patterns aren't allowed in function pointer types\"\n+                    )\n+                    .emit();\n+                });\n+                self.check_late_bound_lifetime_defs(&bfty.generic_params);\n+            }\n+            TyKind::TraitObject(ref bounds, ..) => {\n+                let mut any_lifetime_bounds = false;\n+                for bound in bounds {\n+                    if let GenericBound::Outlives(ref lifetime) = *bound {\n+                        if any_lifetime_bounds {\n+                            struct_span_err!(\n+                                self.session,\n+                                lifetime.ident.span,\n+                                E0226,\n+                                \"only a single explicit lifetime bound is permitted\"\n+                            )\n+                            .emit();\n+                            break;\n+                        }\n+                        any_lifetime_bounds = true;\n+                    }\n+                }\n+                self.no_questions_in_bounds(bounds, \"trait object types\", false);\n+            }\n+            TyKind::ImplTrait(_, ref bounds) => {\n+                if self.is_impl_trait_banned {\n+                    struct_span_err!(\n+                        self.session,\n+                        ty.span,\n+                        E0667,\n+                        \"`impl Trait` is not allowed in path parameters\"\n+                    )\n+                    .emit();\n+                }\n+\n+                if let Some(outer_impl_trait_sp) = self.outer_impl_trait {\n+                    struct_span_err!(\n+                        self.session,\n+                        ty.span,\n+                        E0666,\n+                        \"nested `impl Trait` is not allowed\"\n+                    )\n+                    .span_label(outer_impl_trait_sp, \"outer `impl Trait`\")\n+                    .span_label(ty.span, \"nested `impl Trait` here\")\n+                    .emit();\n+                }\n+\n+                if !bounds.iter().any(|b| matches!(b, GenericBound::Trait(..))) {\n+                    self.err_handler().span_err(ty.span, \"at least one trait must be specified\");\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n }\n \n /// Checks that generic parameters are in the correct order,\n@@ -850,72 +995,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_ty(&mut self, ty: &'a Ty) {\n-        match ty.kind {\n-            TyKind::BareFn(ref bfty) => {\n-                self.check_fn_decl(&bfty.decl, SelfSemantic::No);\n-                Self::check_decl_no_pat(&bfty.decl, |span, _, _| {\n-                    struct_span_err!(\n-                        self.session,\n-                        span,\n-                        E0561,\n-                        \"patterns aren't allowed in function pointer types\"\n-                    )\n-                    .emit();\n-                });\n-                self.check_late_bound_lifetime_defs(&bfty.generic_params);\n-            }\n-            TyKind::TraitObject(ref bounds, ..) => {\n-                let mut any_lifetime_bounds = false;\n-                for bound in bounds {\n-                    if let GenericBound::Outlives(ref lifetime) = *bound {\n-                        if any_lifetime_bounds {\n-                            struct_span_err!(\n-                                self.session,\n-                                lifetime.ident.span,\n-                                E0226,\n-                                \"only a single explicit lifetime bound is permitted\"\n-                            )\n-                            .emit();\n-                            break;\n-                        }\n-                        any_lifetime_bounds = true;\n-                    }\n-                }\n-                self.no_questions_in_bounds(bounds, \"trait object types\", false);\n-            }\n-            TyKind::ImplTrait(_, ref bounds) => {\n-                if self.is_impl_trait_banned {\n-                    struct_span_err!(\n-                        self.session,\n-                        ty.span,\n-                        E0667,\n-                        \"`impl Trait` is not allowed in path parameters\"\n-                    )\n-                    .emit();\n-                }\n-\n-                if let Some(outer_impl_trait_sp) = self.outer_impl_trait {\n-                    struct_span_err!(\n-                        self.session,\n-                        ty.span,\n-                        E0666,\n-                        \"nested `impl Trait` is not allowed\"\n-                    )\n-                    .span_label(outer_impl_trait_sp, \"outer `impl Trait`\")\n-                    .span_label(ty.span, \"nested `impl Trait` here\")\n-                    .emit();\n-                }\n-\n-                if !bounds.iter().any(|b| matches!(b, GenericBound::Trait(..))) {\n-                    self.err_handler().span_err(ty.span, \"at least one trait must be specified\");\n-                }\n-\n-                self.walk_ty(ty);\n-                return;\n-            }\n-            _ => {}\n-        }\n-\n+        self.visit_ty_common(ty);\n+        self.deny_anonymous_struct(ty);\n         self.walk_ty(ty)\n     }\n \n@@ -929,6 +1010,11 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         visit::walk_lifetime(self, lifetime);\n     }\n \n+    fn visit_field_def(&mut self, s: &'a FieldDef) {\n+        self.deny_anonymous_field(s);\n+        visit::walk_field_def(self, s)\n+    }\n+\n     fn visit_item(&mut self, item: &'a Item) {\n         if item.attrs.iter().any(|attr| self.session.is_proc_macro_attr(attr)) {\n             self.has_proc_macro_decls = true;\n@@ -1084,14 +1170,42 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     self.check_mod_file_item_asciionly(item.ident);\n                 }\n             }\n-            ItemKind::Union(ref vdata, _) => {\n-                if let VariantData::Tuple(..) | VariantData::Unit(..) = vdata {\n-                    self.err_handler()\n-                        .span_err(item.span, \"tuple and unit unions are not permitted\");\n+            ItemKind::Struct(ref vdata, ref generics) => match vdata {\n+                // Duplicating the `Visitor` logic allows catching all cases\n+                // of `Anonymous(Struct, Union)` outside of a field struct or union.\n+                //\n+                // Inside `visit_ty` the validator catches every `Anonymous(Struct, Union)` it\n+                // encounters, and only on `ItemKind::Struct` and `ItemKind::Union`\n+                // it uses `visit_ty_common`, which doesn't contain that specific check.\n+                VariantData::Struct(ref fields, ..) => {\n+                    self.visit_vis(&item.vis);\n+                    self.visit_ident(item.ident);\n+                    self.visit_generics(generics);\n+                    self.with_banned_assoc_ty_bound(|this| {\n+                        walk_list!(this, visit_struct_field_def, fields);\n+                    });\n+                    walk_list!(self, visit_attribute, &item.attrs);\n+                    return;\n                 }\n+                _ => {}\n+            },\n+            ItemKind::Union(ref vdata, ref generics) => {\n                 if vdata.fields().is_empty() {\n                     self.err_handler().span_err(item.span, \"unions cannot have zero fields\");\n                 }\n+                match vdata {\n+                    VariantData::Struct(ref fields, ..) => {\n+                        self.visit_vis(&item.vis);\n+                        self.visit_ident(item.ident);\n+                        self.visit_generics(generics);\n+                        self.with_banned_assoc_ty_bound(|this| {\n+                            walk_list!(this, visit_struct_field_def, fields);\n+                        });\n+                        walk_list!(self, visit_attribute, &item.attrs);\n+                        return;\n+                    }\n+                    _ => {}\n+                }\n             }\n             ItemKind::Const(def, .., None) => {\n                 self.check_defaultness(item.span, def);"}, {"sha": "4215d5c55a049d9a23620c4b27b769eef1988ed0", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9964284fed181676300aad693449f5b751e35ff2/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9964284fed181676300aad693449f5b751e35ff2/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=9964284fed181676300aad693449f5b751e35ff2", "patch": "@@ -725,6 +725,7 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n         // involved, so we only emit errors where there are no other parsing errors.\n         gate_all!(destructuring_assignment, \"destructuring assignments are unstable\");\n     }\n+    gate_all!(unnamed_fields, \"unnamed fields are not yet fully implemented\");\n \n     // All uses of `gate_all!` below this point were added in #65742,\n     // and subsequently disabled (with the non-early gating readded)."}, {"sha": "da9d89745a824221b7207e2763eb4d86d0584123", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 33, "deletions": 17, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9964284fed181676300aad693449f5b751e35ff2/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9964284fed181676300aad693449f5b751e35ff2/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=9964284fed181676300aad693449f5b751e35ff2", "patch": "@@ -954,6 +954,14 @@ impl<'a> State<'a> {\n                 }\n                 self.pclose();\n             }\n+            ast::TyKind::AnonymousStruct(ref fields, ..) => {\n+                self.s.word(\"struct\");\n+                self.print_record_struct_body(fields, ty.span);\n+            }\n+            ast::TyKind::AnonymousUnion(ref fields, ..) => {\n+                self.s.word(\"union\");\n+                self.print_record_struct_body(fields, ty.span);\n+            }\n             ast::TyKind::Paren(ref typ) => {\n                 self.popen();\n                 self.print_type(typ);\n@@ -1389,6 +1397,29 @@ impl<'a> State<'a> {\n         }\n     }\n \n+    crate fn print_record_struct_body(\n+        &mut self,\n+        fields: &Vec<ast::FieldDef>,\n+        span: rustc_span::Span,\n+    ) {\n+        self.nbsp();\n+        self.bopen();\n+        self.hardbreak_if_not_bol();\n+\n+        for field in fields {\n+            self.hardbreak_if_not_bol();\n+            self.maybe_print_comment(field.span.lo());\n+            self.print_outer_attributes(&field.attrs);\n+            self.print_visibility(&field.vis);\n+            self.print_ident(field.ident.unwrap());\n+            self.word_nbsp(\":\");\n+            self.print_type(&field.ty);\n+            self.s.word(\",\");\n+        }\n+\n+        self.bclose(span)\n+    }\n+\n     crate fn print_struct(\n         &mut self,\n         struct_def: &ast::VariantData,\n@@ -1418,24 +1449,9 @@ impl<'a> State<'a> {\n                 self.end();\n                 self.end(); // Close the outer-box.\n             }\n-            ast::VariantData::Struct(..) => {\n+            ast::VariantData::Struct(ref fields, ..) => {\n                 self.print_where_clause(&generics.where_clause);\n-                self.nbsp();\n-                self.bopen();\n-                self.hardbreak_if_not_bol();\n-\n-                for field in struct_def.fields() {\n-                    self.hardbreak_if_not_bol();\n-                    self.maybe_print_comment(field.span.lo());\n-                    self.print_outer_attributes(&field.attrs);\n-                    self.print_visibility(&field.vis);\n-                    self.print_ident(field.ident.unwrap());\n-                    self.word_nbsp(\":\");\n-                    self.print_type(&field.ty);\n-                    self.s.word(\",\");\n-                }\n-\n-                self.bclose(span)\n+                self.print_record_struct_body(fields, span);\n             }\n         }\n     }"}, {"sha": "80fe5bafc6ee6018dfdc563c6b35800c94345685", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9964284fed181676300aad693449f5b751e35ff2/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9964284fed181676300aad693449f5b751e35ff2/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=9964284fed181676300aad693449f5b751e35ff2", "patch": "@@ -671,6 +671,9 @@ declare_features! (\n     /// Allows specifying the as-needed link modifier\n     (active, native_link_modifiers_as_needed, \"1.53.0\", Some(81490), None),\n \n+    /// Allows unnamed fields of struct and union type\n+    (active, unnamed_fields, \"1.53.0\", Some(49804), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------\n@@ -704,6 +707,7 @@ pub const INCOMPLETE_FEATURES: &[Symbol] = &[\n     sym::native_link_modifiers_whole_archive,\n     sym::native_link_modifiers_as_needed,\n     sym::rustc_insignificant_dtor,\n+    sym::unnamed_fields,\n ];\n \n /// Some features are not allowed to be used together at the same time, if"}, {"sha": "c64fab0507c942636824149d7d5a6ea6e4c5e5c8", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9964284fed181676300aad693449f5b751e35ff2/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9964284fed181676300aad693449f5b751e35ff2/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=9964284fed181676300aad693449f5b751e35ff2", "patch": "@@ -1236,7 +1236,7 @@ impl<'a> Parser<'a> {\n         Ok((class_name, ItemKind::Union(vdata, generics)))\n     }\n \n-    fn parse_record_struct_body(\n+    pub(super) fn parse_record_struct_body(\n         &mut self,\n         adt_ty: &str,\n     ) -> PResult<'a, (Vec<FieldDef>, /* recovered */ bool)> {\n@@ -1470,19 +1470,25 @@ impl<'a> Parser<'a> {\n     fn parse_field_ident(&mut self, adt_ty: &str, lo: Span) -> PResult<'a, Ident> {\n         let (ident, is_raw) = self.ident_or_err()?;\n         if !is_raw && ident.is_reserved() {\n-            let err = if self.check_fn_front_matter(false) {\n-                let _ = self.parse_fn(&mut Vec::new(), |_| true, lo);\n-                let mut err = self.struct_span_err(\n-                    lo.to(self.prev_token.span),\n-                    &format!(\"functions are not allowed in {} definitions\", adt_ty),\n-                );\n-                err.help(\"unlike in C++, Java, and C#, functions are declared in `impl` blocks\");\n-                err.help(\"see https://doc.rust-lang.org/book/ch05-03-method-syntax.html for more information\");\n-                err\n+            if ident.name == kw::Underscore {\n+                self.sess.gated_spans.gate(sym::unnamed_fields, lo);\n             } else {\n-                self.expected_ident_found()\n-            };\n-            return Err(err);\n+                let err = if self.check_fn_front_matter(false) {\n+                    let _ = self.parse_fn(&mut Vec::new(), |_| true, lo);\n+                    let mut err = self.struct_span_err(\n+                        lo.to(self.prev_token.span),\n+                        &format!(\"functions are not allowed in {} definitions\", adt_ty),\n+                    );\n+                    err.help(\n+                        \"unlike in C++, Java, and C#, functions are declared in `impl` blocks\",\n+                    );\n+                    err.help(\"see https://doc.rust-lang.org/book/ch05-03-method-syntax.html for more information\");\n+                    err\n+                } else {\n+                    self.expected_ident_found()\n+                };\n+                return Err(err);\n+            }\n         }\n         self.bump();\n         Ok(ident)"}, {"sha": "89cf2d7876e1d9d523935bb3d9505f2425e7bc5e", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9964284fed181676300aad693449f5b751e35ff2/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9964284fed181676300aad693449f5b751e35ff2/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=9964284fed181676300aad693449f5b751e35ff2", "patch": "@@ -226,6 +226,19 @@ impl<'a> Parser<'a> {\n             }\n         } else if self.eat_keyword(kw::Impl) {\n             self.parse_impl_ty(&mut impl_dyn_multi)?\n+        } else if self.token.is_keyword(kw::Union)\n+            && self.look_ahead(1, |t| t == &token::OpenDelim(token::Brace))\n+        {\n+            self.bump();\n+            let (fields, recovered) = self.parse_record_struct_body(\"union\")?;\n+            let span = lo.to(self.prev_token.span);\n+            self.sess.gated_spans.gate(sym::unnamed_fields, span);\n+            TyKind::AnonymousUnion(fields, recovered)\n+        } else if self.eat_keyword(kw::Struct) {\n+            let (fields, recovered) = self.parse_record_struct_body(\"struct\")?;\n+            let span = lo.to(self.prev_token.span);\n+            self.sess.gated_spans.gate(sym::unnamed_fields, span);\n+            TyKind::AnonymousStruct(fields, recovered)\n         } else if self.is_explicit_dyn_type() {\n             self.parse_dyn_ty(&mut impl_dyn_multi)?\n         } else if self.eat_lt() {"}, {"sha": "03a8f2be1561c59d866a72ef786b3f0e475d8d30", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9964284fed181676300aad693449f5b751e35ff2/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9964284fed181676300aad693449f5b751e35ff2/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=9964284fed181676300aad693449f5b751e35ff2", "patch": "@@ -1270,6 +1270,7 @@ symbols! {\n         unix,\n         unlikely,\n         unmarked_api,\n+        unnamed_fields,\n         unpin,\n         unreachable,\n         unreachable_code,"}, {"sha": "bd815dbcc92424274e1cff1f4a7438247549a909", "filename": "src/test/ui/feature-gates/feature-gate-unnamed_fields.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9964284fed181676300aad693449f5b751e35ff2/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unnamed_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9964284fed181676300aad693449f5b751e35ff2/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unnamed_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unnamed_fields.rs?ref=9964284fed181676300aad693449f5b751e35ff2", "patch": "@@ -0,0 +1,27 @@\n+struct Foo {\n+    foo: u8,\n+    _: union { //~ ERROR unnamed fields are not yet fully implemented [E0658]\n+    //~^ ERROR unnamed fields are not yet fully implemented [E0658]\n+    //~| ERROR anonymous unions are unimplemented\n+        bar: u8,\n+        baz: u16\n+    }\n+}\n+\n+union Bar {\n+    foobar: u8,\n+    _: struct { //~ ERROR unnamed fields are not yet fully implemented [E0658]\n+    //~^ ERROR unnamed fields are not yet fully implemented [E0658]\n+    //~| ERROR anonymous structs are unimplemented\n+    //~| ERROR unions may not contain fields that need dropping [E0740]\n+        foobaz: u8,\n+        barbaz: u16\n+    }\n+}\n+\n+struct S;\n+struct Baz {\n+    _: S //~ ERROR unnamed fields are not yet fully implemented [E0658]\n+}\n+\n+fn main(){}"}, {"sha": "4f3ab85c987926247d167c1540fd64f883803586", "filename": "src/test/ui/feature-gates/feature-gate-unnamed_fields.stderr", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/9964284fed181676300aad693449f5b751e35ff2/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unnamed_fields.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9964284fed181676300aad693449f5b751e35ff2/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unnamed_fields.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unnamed_fields.stderr?ref=9964284fed181676300aad693449f5b751e35ff2", "patch": "@@ -0,0 +1,111 @@\n+error[E0658]: unnamed fields are not yet fully implemented\n+  --> $DIR/feature-gate-unnamed_fields.rs:3:5\n+   |\n+LL |     _: union {\n+   |     ^\n+   |\n+   = note: see issue #49804 <https://github.com/rust-lang/rust/issues/49804> for more information\n+   = help: add `#![feature(unnamed_fields)]` to the crate attributes to enable\n+\n+error[E0658]: unnamed fields are not yet fully implemented\n+  --> $DIR/feature-gate-unnamed_fields.rs:3:8\n+   |\n+LL |       _: union {\n+   |  ________^\n+LL | |\n+LL | |\n+LL | |         bar: u8,\n+LL | |         baz: u16\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: see issue #49804 <https://github.com/rust-lang/rust/issues/49804> for more information\n+   = help: add `#![feature(unnamed_fields)]` to the crate attributes to enable\n+\n+error[E0658]: unnamed fields are not yet fully implemented\n+  --> $DIR/feature-gate-unnamed_fields.rs:13:5\n+   |\n+LL |     _: struct {\n+   |     ^\n+   |\n+   = note: see issue #49804 <https://github.com/rust-lang/rust/issues/49804> for more information\n+   = help: add `#![feature(unnamed_fields)]` to the crate attributes to enable\n+\n+error[E0658]: unnamed fields are not yet fully implemented\n+  --> $DIR/feature-gate-unnamed_fields.rs:13:8\n+   |\n+LL |       _: struct {\n+   |  ________^\n+LL | |\n+LL | |\n+LL | |\n+LL | |         foobaz: u8,\n+LL | |         barbaz: u16\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: see issue #49804 <https://github.com/rust-lang/rust/issues/49804> for more information\n+   = help: add `#![feature(unnamed_fields)]` to the crate attributes to enable\n+\n+error[E0658]: unnamed fields are not yet fully implemented\n+  --> $DIR/feature-gate-unnamed_fields.rs:24:5\n+   |\n+LL |     _: S\n+   |     ^\n+   |\n+   = note: see issue #49804 <https://github.com/rust-lang/rust/issues/49804> for more information\n+   = help: add `#![feature(unnamed_fields)]` to the crate attributes to enable\n+\n+error: anonymous unions are unimplemented\n+  --> $DIR/feature-gate-unnamed_fields.rs:3:8\n+   |\n+LL |       _: union {\n+   |  ________^\n+LL | |\n+LL | |\n+LL | |         bar: u8,\n+LL | |         baz: u16\n+LL | |     }\n+   | |_____^\n+\n+error: anonymous structs are unimplemented\n+  --> $DIR/feature-gate-unnamed_fields.rs:13:8\n+   |\n+LL |       _: struct {\n+   |  ________^\n+LL | |\n+LL | |\n+LL | |\n+LL | |         foobaz: u8,\n+LL | |         barbaz: u16\n+LL | |     }\n+   | |_____^\n+\n+error[E0740]: unions may not contain fields that need dropping\n+  --> $DIR/feature-gate-unnamed_fields.rs:13:5\n+   |\n+LL | /     _: struct {\n+LL | |\n+LL | |\n+LL | |\n+LL | |         foobaz: u8,\n+LL | |         barbaz: u16\n+LL | |     }\n+   | |_____^\n+   |\n+note: `std::mem::ManuallyDrop` can be used to wrap the type\n+  --> $DIR/feature-gate-unnamed_fields.rs:13:5\n+   |\n+LL | /     _: struct {\n+LL | |\n+LL | |\n+LL | |\n+LL | |         foobaz: u8,\n+LL | |         barbaz: u16\n+LL | |     }\n+   | |_____^\n+\n+error: aborting due to 8 previous errors\n+\n+Some errors have detailed explanations: E0658, E0740.\n+For more information about an error, try `rustc --explain E0658`."}, {"sha": "99637d1105301e6e34ce6097da15157d2d1ad88a", "filename": "src/test/ui/unnamed_fields/restrict_anonymous.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9964284fed181676300aad693449f5b751e35ff2/src%2Ftest%2Fui%2Funnamed_fields%2Frestrict_anonymous.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9964284fed181676300aad693449f5b751e35ff2/src%2Ftest%2Fui%2Funnamed_fields%2Frestrict_anonymous.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funnamed_fields%2Frestrict_anonymous.rs?ref=9964284fed181676300aad693449f5b751e35ff2", "patch": "@@ -0,0 +1,52 @@\n+#![allow(incomplete_features)]\n+#![feature(unnamed_fields)]\n+\n+fn f() -> struct { field: u8 } {} //~ ERROR anonymous structs are not allowed outside of unnamed struct or union fields\n+//~^ ERROR anonymous structs are unimplemented\n+\n+fn f2(a: struct { field: u8 } ) {} //~ ERROR anonymous structs are not allowed outside of unnamed struct or union fields\n+//~^ ERROR anonymous structs are unimplemented\n+\n+union G {\n+    field: struct { field: u8 } //~ ERROR anonymous structs are not allowed outside of unnamed struct or union fields\n+    //~^ ERROR anonymous structs are unimplemented\n+}\n+//~| ERROR unions may not contain fields that need dropping [E0740]\n+\n+struct H { _: u8 } // Should error after hir checks\n+\n+struct I(struct { field: u8 }, u8); //~ ERROR anonymous structs are not allowed outside of unnamed struct or union fields\n+//~^ ERROR anonymous structs are unimplemented\n+\n+enum J {\n+    K(struct { field: u8 }), //~ ERROR anonymous structs are not allowed outside of unnamed struct or union fields\n+    //~^ ERROR anonymous structs are unimplemented\n+    L {\n+        _ : struct { field: u8 } //~ ERROR anonymous structs are not allowed outside of unnamed struct or union fields\n+        //~^ ERROR anonymous fields are not allowed outside of structs or unions\n+        //~| ERROR anonymous structs are unimplemented\n+    },\n+    M {\n+        _ : u8 //~ ERROR anonymous fields are not allowed outside of structs or unions\n+    }\n+}\n+\n+static M: union { field: u8 } = 0; //~ ERROR anonymous unions are not allowed outside of unnamed struct or union fields\n+//~^ ERROR anonymous unions are unimplemented\n+\n+type N = union { field: u8 }; //~ ERROR anonymous unions are not allowed outside of unnamed struct or union fields\n+//~^ ERROR anonymous unions are unimplemented\n+\n+fn main() {\n+    const O: struct { field: u8 } = 0; //~ ERROR anonymous structs are not allowed outside of unnamed struct or union fields\n+    //~^ ERROR anonymous structs are unimplemented\n+\n+    let p: [struct { field: u8 }; 1]; //~ ERROR anonymous structs are not allowed outside of unnamed struct or union fields\n+    //~^ ERROR anonymous structs are unimplemented\n+\n+    let q: (struct { field: u8 }, u8); //~ ERROR anonymous structs are not allowed outside of unnamed struct or union fields\n+    //~^ ERROR anonymous structs are unimplemented\n+\n+    let cl = || -> struct { field: u8 } {}; //~ ERROR anonymous structs are not allowed outside of unnamed struct or union fields\n+    //~^ ERROR anonymous structs are unimplemented\n+}"}, {"sha": "efcf544fde4dcc5662b20e51b91cf84c19ffc0cd", "filename": "src/test/ui/unnamed_fields/restrict_anonymous.stderr", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/9964284fed181676300aad693449f5b751e35ff2/src%2Ftest%2Fui%2Funnamed_fields%2Frestrict_anonymous.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9964284fed181676300aad693449f5b751e35ff2/src%2Ftest%2Fui%2Funnamed_fields%2Frestrict_anonymous.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funnamed_fields%2Frestrict_anonymous.stderr?ref=9964284fed181676300aad693449f5b751e35ff2", "patch": "@@ -0,0 +1,175 @@\n+error: anonymous structs are not allowed outside of unnamed struct or union fields\n+  --> $DIR/restrict_anonymous.rs:4:11\n+   |\n+LL | fn f() -> struct { field: u8 } {}\n+   |           ^^^^^^^^^^^^^^^^^^^^ anonymous struct declared here\n+\n+error: anonymous structs are not allowed outside of unnamed struct or union fields\n+  --> $DIR/restrict_anonymous.rs:7:10\n+   |\n+LL | fn f2(a: struct { field: u8 } ) {}\n+   |          ^^^^^^^^^^^^^^^^^^^^ anonymous struct declared here\n+\n+error: anonymous structs are not allowed outside of unnamed struct or union fields\n+  --> $DIR/restrict_anonymous.rs:11:12\n+   |\n+LL |     field: struct { field: u8 }\n+   |            ^^^^^^^^^^^^^^^^^^^^ anonymous struct declared here\n+\n+error: anonymous structs are not allowed outside of unnamed struct or union fields\n+  --> $DIR/restrict_anonymous.rs:18:10\n+   |\n+LL | struct I(struct { field: u8 }, u8);\n+   |          ^^^^^^^^^^^^^^^^^^^^ anonymous struct declared here\n+\n+error: anonymous structs are not allowed outside of unnamed struct or union fields\n+  --> $DIR/restrict_anonymous.rs:22:7\n+   |\n+LL |     K(struct { field: u8 }),\n+   |       ^^^^^^^^^^^^^^^^^^^^ anonymous struct declared here\n+\n+error: anonymous fields are not allowed outside of structs or unions\n+  --> $DIR/restrict_anonymous.rs:25:9\n+   |\n+LL |         _ : struct { field: u8 }\n+   |         -^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         anonymous field declared here\n+\n+error: anonymous structs are not allowed outside of unnamed struct or union fields\n+  --> $DIR/restrict_anonymous.rs:25:13\n+   |\n+LL |         _ : struct { field: u8 }\n+   |             ^^^^^^^^^^^^^^^^^^^^ anonymous struct declared here\n+\n+error: anonymous fields are not allowed outside of structs or unions\n+  --> $DIR/restrict_anonymous.rs:30:9\n+   |\n+LL |         _ : u8\n+   |         -^^^^^\n+   |         |\n+   |         anonymous field declared here\n+\n+error: anonymous unions are not allowed outside of unnamed struct or union fields\n+  --> $DIR/restrict_anonymous.rs:34:11\n+   |\n+LL | static M: union { field: u8 } = 0;\n+   |           ^^^^^^^^^^^^^^^^^^^ anonymous union declared here\n+\n+error: anonymous unions are not allowed outside of unnamed struct or union fields\n+  --> $DIR/restrict_anonymous.rs:37:10\n+   |\n+LL | type N = union { field: u8 };\n+   |          ^^^^^^^^^^^^^^^^^^^ anonymous union declared here\n+\n+error: anonymous structs are not allowed outside of unnamed struct or union fields\n+  --> $DIR/restrict_anonymous.rs:41:14\n+   |\n+LL |     const O: struct { field: u8 } = 0;\n+   |              ^^^^^^^^^^^^^^^^^^^^ anonymous struct declared here\n+\n+error: anonymous structs are not allowed outside of unnamed struct or union fields\n+  --> $DIR/restrict_anonymous.rs:44:13\n+   |\n+LL |     let p: [struct { field: u8 }; 1];\n+   |             ^^^^^^^^^^^^^^^^^^^^ anonymous struct declared here\n+\n+error: anonymous structs are not allowed outside of unnamed struct or union fields\n+  --> $DIR/restrict_anonymous.rs:47:13\n+   |\n+LL |     let q: (struct { field: u8 }, u8);\n+   |             ^^^^^^^^^^^^^^^^^^^^ anonymous struct declared here\n+\n+error: anonymous structs are not allowed outside of unnamed struct or union fields\n+  --> $DIR/restrict_anonymous.rs:50:20\n+   |\n+LL |     let cl = || -> struct { field: u8 } {};\n+   |                    ^^^^^^^^^^^^^^^^^^^^ anonymous struct declared here\n+\n+error: anonymous structs are unimplemented\n+  --> $DIR/restrict_anonymous.rs:4:11\n+   |\n+LL | fn f() -> struct { field: u8 } {}\n+   |           ^^^^^^^^^^^^^^^^^^^^\n+\n+error: anonymous structs are unimplemented\n+  --> $DIR/restrict_anonymous.rs:7:10\n+   |\n+LL | fn f2(a: struct { field: u8 } ) {}\n+   |          ^^^^^^^^^^^^^^^^^^^^\n+\n+error: anonymous structs are unimplemented\n+  --> $DIR/restrict_anonymous.rs:11:12\n+   |\n+LL |     field: struct { field: u8 }\n+   |            ^^^^^^^^^^^^^^^^^^^^\n+\n+error: anonymous structs are unimplemented\n+  --> $DIR/restrict_anonymous.rs:18:10\n+   |\n+LL | struct I(struct { field: u8 }, u8);\n+   |          ^^^^^^^^^^^^^^^^^^^^\n+\n+error: anonymous structs are unimplemented\n+  --> $DIR/restrict_anonymous.rs:22:7\n+   |\n+LL |     K(struct { field: u8 }),\n+   |       ^^^^^^^^^^^^^^^^^^^^\n+\n+error: anonymous structs are unimplemented\n+  --> $DIR/restrict_anonymous.rs:25:13\n+   |\n+LL |         _ : struct { field: u8 }\n+   |             ^^^^^^^^^^^^^^^^^^^^\n+\n+error: anonymous unions are unimplemented\n+  --> $DIR/restrict_anonymous.rs:34:11\n+   |\n+LL | static M: union { field: u8 } = 0;\n+   |           ^^^^^^^^^^^^^^^^^^^\n+\n+error: anonymous unions are unimplemented\n+  --> $DIR/restrict_anonymous.rs:37:10\n+   |\n+LL | type N = union { field: u8 };\n+   |          ^^^^^^^^^^^^^^^^^^^\n+\n+error: anonymous structs are unimplemented\n+  --> $DIR/restrict_anonymous.rs:44:13\n+   |\n+LL |     let p: [struct { field: u8 }; 1];\n+   |             ^^^^^^^^^^^^^^^^^^^^\n+\n+error: anonymous structs are unimplemented\n+  --> $DIR/restrict_anonymous.rs:47:13\n+   |\n+LL |     let q: (struct { field: u8 }, u8);\n+   |             ^^^^^^^^^^^^^^^^^^^^\n+\n+error: anonymous structs are unimplemented\n+  --> $DIR/restrict_anonymous.rs:50:20\n+   |\n+LL |     let cl = || -> struct { field: u8 } {};\n+   |                    ^^^^^^^^^^^^^^^^^^^^\n+\n+error: anonymous structs are unimplemented\n+  --> $DIR/restrict_anonymous.rs:41:14\n+   |\n+LL |     const O: struct { field: u8 } = 0;\n+   |              ^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0740]: unions may not contain fields that need dropping\n+  --> $DIR/restrict_anonymous.rs:11:5\n+   |\n+LL |     field: struct { field: u8 }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: `std::mem::ManuallyDrop` can be used to wrap the type\n+  --> $DIR/restrict_anonymous.rs:11:5\n+   |\n+LL |     field: struct { field: u8 }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 27 previous errors\n+\n+For more information about this error, try `rustc --explain E0740`."}, {"sha": "420484c0ba11e50e5529cdc4ffbd13ea6fa752f0", "filename": "src/tools/rustfmt/src/items.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9964284fed181676300aad693449f5b751e35ff2/src%2Ftools%2Frustfmt%2Fsrc%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9964284fed181676300aad693449f5b751e35ff2/src%2Ftools%2Frustfmt%2Fsrc%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fitems.rs?ref=9964284fed181676300aad693449f5b751e35ff2", "patch": "@@ -6,7 +6,7 @@ use std::cmp::{max, min, Ordering};\n use regex::Regex;\n use rustc_ast::visit;\n use rustc_ast::{ast, ptr};\n-use rustc_span::{symbol, BytePos, Span, DUMMY_SP};\n+use rustc_span::{symbol, BytePos, Span};\n \n use crate::attr::filter_inline_attrs;\n use crate::comment::{\n@@ -31,12 +31,7 @@ use crate::stmt::Stmt;\n use crate::utils::*;\n use crate::vertical::rewrite_with_alignment;\n use crate::visitor::FmtVisitor;\n-\n-const DEFAULT_VISIBILITY: ast::Visibility = ast::Visibility {\n-    kind: ast::VisibilityKind::Inherited,\n-    span: DUMMY_SP,\n-    tokens: None,\n-};\n+use crate::DEFAULT_VISIBILITY;\n \n fn type_annotation_separator(config: &Config) -> &str {\n     colon_spaces(config)\n@@ -976,7 +971,7 @@ impl<'a> StructParts<'a> {\n         format_header(context, self.prefix, self.ident, self.vis, offset)\n     }\n \n-    fn from_variant(variant: &'a ast::Variant) -> Self {\n+    pub(crate) fn from_variant(variant: &'a ast::Variant) -> Self {\n         StructParts {\n             prefix: \"\",\n             ident: variant.ident,"}, {"sha": "cde5d390cf259ed5e2947a85f2ec83c19898a763", "filename": "src/tools/rustfmt/src/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9964284fed181676300aad693449f5b751e35ff2/src%2Ftools%2Frustfmt%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9964284fed181676300aad693449f5b751e35ff2/src%2Ftools%2Frustfmt%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Flib.rs?ref=9964284fed181676300aad693449f5b751e35ff2", "patch": "@@ -31,7 +31,7 @@ use std::rc::Rc;\n \n use ignore;\n use rustc_ast::ast;\n-use rustc_span::symbol;\n+use rustc_span::{symbol, DUMMY_SP};\n use thiserror::Error;\n \n use crate::comment::LineClasses;\n@@ -95,6 +95,11 @@ mod types;\n mod vertical;\n pub(crate) mod visitor;\n \n+const DEFAULT_VISIBILITY: ast::Visibility = ast::Visibility {\n+    kind: ast::VisibilityKind::Inherited,\n+    span: DUMMY_SP,\n+    tokens: None,\n+};\n /// The various errors that can occur during formatting. Note that not all of\n /// these can currently be propagated to clients.\n #[derive(Error, Debug)]"}, {"sha": "5597af9ee320cbe67ec82f37d6bb9a01ce073b3c", "filename": "src/tools/rustfmt/src/types.rs", "status": "modified", "additions": 55, "deletions": 2, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/9964284fed181676300aad693449f5b751e35ff2/src%2Ftools%2Frustfmt%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9964284fed181676300aad693449f5b751e35ff2/src%2Ftools%2Frustfmt%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Ftypes.rs?ref=9964284fed181676300aad693449f5b751e35ff2", "patch": "@@ -2,14 +2,14 @@ use std::iter::ExactSizeIterator;\n use std::ops::Deref;\n \n use rustc_ast::ast::{self, FnRetTy, Mutability};\n-use rustc_span::{symbol::kw, BytePos, Pos, Span};\n+use rustc_span::{symbol::kw, symbol::Ident, BytePos, Pos, Span};\n \n-use crate::comment::{combine_strs_with_missing_comments, contains_comment};\n use crate::config::lists::*;\n use crate::config::{IndentStyle, TypeDensity, Version};\n use crate::expr::{\n     format_expr, rewrite_assign_rhs, rewrite_call, rewrite_tuple, rewrite_unary_prefix, ExprType,\n };\n+use crate::items::StructParts;\n use crate::lists::{\n     definitive_tactic, itemize_list, write_list, ListFormatting, ListItem, Separator,\n };\n@@ -24,6 +24,11 @@ use crate::utils::{\n     colon_spaces, extra_offset, first_line_width, format_extern, format_mutability,\n     last_line_extendable, last_line_width, mk_sp, rewrite_ident,\n };\n+use crate::DEFAULT_VISIBILITY;\n+use crate::{\n+    comment::{combine_strs_with_missing_comments, contains_comment},\n+    items::format_struct_struct,\n+};\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub(crate) enum PathContext {\n@@ -764,6 +769,54 @@ impl Rewrite for ast::Ty {\n             ast::TyKind::Tup(ref items) => {\n                 rewrite_tuple(context, items.iter(), self.span, shape, items.len() == 1)\n             }\n+            ast::TyKind::AnonymousStruct(ref fields, recovered) => {\n+                let ident = Ident::new(\n+                    kw::Struct,\n+                    mk_sp(self.span.lo(), self.span.lo() + BytePos(6)),\n+                );\n+                let data = ast::VariantData::Struct(fields.clone(), recovered);\n+                let variant = ast::Variant {\n+                    attrs: vec![],\n+                    id: self.id,\n+                    span: self.span,\n+                    vis: DEFAULT_VISIBILITY,\n+                    ident,\n+                    data,\n+                    disr_expr: None,\n+                    is_placeholder: false,\n+                };\n+                format_struct_struct(\n+                    &context,\n+                    &StructParts::from_variant(&variant),\n+                    fields,\n+                    shape.indent,\n+                    None,\n+                )\n+            }\n+            ast::TyKind::AnonymousUnion(ref fields, recovered) => {\n+                let ident = Ident::new(\n+                    kw::Union,\n+                    mk_sp(self.span.lo(), self.span.lo() + BytePos(5)),\n+                );\n+                let data = ast::VariantData::Struct(fields.clone(), recovered);\n+                let variant = ast::Variant {\n+                    attrs: vec![],\n+                    id: self.id,\n+                    span: self.span,\n+                    vis: DEFAULT_VISIBILITY,\n+                    ident,\n+                    data,\n+                    disr_expr: None,\n+                    is_placeholder: false,\n+                };\n+                format_struct_struct(\n+                    &context,\n+                    &StructParts::from_variant(&variant),\n+                    fields,\n+                    shape.indent,\n+                    None,\n+                )\n+            }\n             ast::TyKind::Path(ref q_self, ref path) => {\n                 rewrite_path(context, PathContext::Type, q_self.as_ref(), path, shape)\n             }"}]}