{"sha": "52ba3b6414fe91cf92222581cb24e06894267c49", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyYmEzYjY0MTRmZTkxY2Y5MjIyMjU4MWNiMjRlMDY4OTQyNjdjNDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-23T06:01:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-23T06:01:40Z"}, "message": "auto merge of #11611 : SiegeLord/rust/exp_printing, r=alexcrichton\n\nFixes #6593\r\n\r\nCurrently, Rust provides no way to print very large or very small floating point values which come up routinely in scientific and modeling work. The classical solution to this is to use the scientific/exponential notation, which not-coincidentally, corresponds to how floating point values are encoded in memory. Given this, there are two solutions to the problem. One is what, as far as I understand it, Python does. I.e. for floating point numbers in a certain range it does what we do today with the `'f'` formatting flag, otherwise it switches to exponential notation. The other way is to provide a set of formatting flags to explicitly choose the exponential notation, like it is done in C. I've chosen the second way as I think its important to provide that kind of control to the user.\r\n\r\nThis pull request changes the `std::num::strconv::float_to_str_common` function to optionally format floating point numbers using the exponential (scientific) notation. The base of the significant can be varied between 2 and 25, while the base of the exponent can be 2 or 10.\r\n\r\nAdditionally this adds two new formatting specifiers to `format!` and friends: `'e'` and `'E'` which switch between outputs like `1.0e5` and `1.0E5`. Mostly parroting C stdlib in this sense, although I wasn't going for an exact output match.", "tree": {"sha": "d624c574cfff628ef329092a44c00e294c5bd946", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d624c574cfff628ef329092a44c00e294c5bd946"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52ba3b6414fe91cf92222581cb24e06894267c49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52ba3b6414fe91cf92222581cb24e06894267c49", "html_url": "https://github.com/rust-lang/rust/commit/52ba3b6414fe91cf92222581cb24e06894267c49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52ba3b6414fe91cf92222581cb24e06894267c49/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ea063ea0f9a28920fafbbf21064f20eb7ca02a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ea063ea0f9a28920fafbbf21064f20eb7ca02a8", "html_url": "https://github.com/rust-lang/rust/commit/7ea063ea0f9a28920fafbbf21064f20eb7ca02a8"}, {"sha": "acd718b3785afcb5cd91b991f3d942e8cfd1df4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/acd718b3785afcb5cd91b991f3d942e8cfd1df4f", "html_url": "https://github.com/rust-lang/rust/commit/acd718b3785afcb5cd91b991f3d942e8cfd1df4f"}], "stats": {"total": 302, "additions": 212, "deletions": 90}, "files": [{"sha": "5b2a792a05b1099c06d64a51cd0ef969977eb6a8", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/52ba3b6414fe91cf92222581cb24e06894267c49/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ba3b6414fe91cf92222581cb24e06894267c49/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=52ba3b6414fe91cf92222581cb24e06894267c49", "patch": "@@ -147,6 +147,8 @@ The current mapping of types to traits is:\n * `p` \u21d2 `Pointer`\n * `t` \u21d2 `Binary`\n * `f` \u21d2 `Float`\n+* `e` \u21d2 `LowerExp`\n+* `E` \u21d2 `UpperExp`\n * *nothing* \u21d2 `Default`\n \n What this means is that any type of argument which implements the\n@@ -578,6 +580,12 @@ pub trait Pointer { fn fmt(&Self, &mut Formatter); }\n /// Format trait for the `f` character\n #[allow(missing_doc)]\n pub trait Float { fn fmt(&Self, &mut Formatter); }\n+/// Format trait for the `e` character\n+#[allow(missing_doc)]\n+pub trait LowerExp { fn fmt(&Self, &mut Formatter); }\n+/// Format trait for the `E` character\n+#[allow(missing_doc)]\n+pub trait UpperExp { fn fmt(&Self, &mut Formatter); }\n \n /// The `write` function takes an output stream, a precompiled format string,\n /// and a list of arguments. The arguments will be formatted according to the\n@@ -1085,6 +1093,28 @@ macro_rules! floating(($ty:ident) => {\n             fmt.pad_integral(s.as_bytes(), \"\", *f >= 0.0);\n         }\n     }\n+\n+    impl LowerExp for $ty {\n+        fn fmt(f: &$ty, fmt: &mut Formatter) {\n+            // XXX: this shouldn't perform an allocation\n+            let s = match fmt.precision {\n+                Some(i) => ::$ty::to_str_exp_exact(f.abs(), i, false),\n+                None => ::$ty::to_str_exp_digits(f.abs(), 6, false)\n+            };\n+            fmt.pad_integral(s.as_bytes(), \"\", *f >= 0.0);\n+        }\n+    }\n+\n+    impl UpperExp for $ty {\n+        fn fmt(f: &$ty, fmt: &mut Formatter) {\n+            // XXX: this shouldn't perform an allocation\n+            let s = match fmt.precision {\n+                Some(i) => ::$ty::to_str_exp_exact(f.abs(), i, true),\n+                None => ::$ty::to_str_exp_digits(f.abs(), 6, true)\n+            };\n+            fmt.pad_integral(s.as_bytes(), \"\", *f >= 0.0);\n+        }\n+    }\n })\n floating!(f32)\n floating!(f64)"}, {"sha": "0af8f155c68782102c594dc75205595293f34ff9", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 36, "deletions": 42, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/52ba3b6414fe91cf92222581cb24e06894267c49/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ba3b6414fe91cf92222581cb24e06894267c49/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=52ba3b6414fe91cf92222581cb24e06894267c49", "patch": "@@ -285,20 +285,16 @@ impl Signed for f32 {\n     #[inline]\n     fn abs(&self) -> f32 { abs(*self) }\n \n-    ///\n     /// The positive difference of two numbers. Returns `0.0` if the number is less than or\n     /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n-    ///\n     #[inline]\n     fn abs_sub(&self, other: &f32) -> f32 { abs_sub(*self, *other) }\n \n-    ///\n     /// # Returns\n     ///\n     /// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n     /// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n     /// - `NAN` if the number is NaN\n-    ///\n     #[inline]\n     fn signum(&self) -> f32 {\n         if self.is_nan() { NAN } else { copysign(1.0, *self) }\n@@ -330,14 +326,12 @@ impl Round for f32 {\n     #[inline]\n     fn trunc(&self) -> f32 { trunc(*self) }\n \n-    ///\n     /// The fractional part of the number, satisfying:\n     ///\n     /// ```rust\n     /// let x = 1.65f32;\n     /// assert!(x == x.trunc() + x.fract())\n     /// ```\n-    ///\n     #[inline]\n     fn fract(&self) -> f32 { *self - self.trunc() }\n }\n@@ -490,15 +484,13 @@ impl Real for f32 {\n     #[inline]\n     fn tanh(&self) -> f32 { tanh(*self) }\n \n-    ///\n     /// Inverse hyperbolic sine\n     ///\n     /// # Returns\n     ///\n     /// - on success, the inverse hyperbolic sine of `self` will be returned\n     /// - `self` if `self` is `0.0`, `-0.0`, `INFINITY`, or `NEG_INFINITY`\n     /// - `NAN` if `self` is `NAN`\n-    ///\n     #[inline]\n     fn asinh(&self) -> f32 {\n         match *self {\n@@ -507,15 +499,13 @@ impl Real for f32 {\n         }\n     }\n \n-    ///\n     /// Inverse hyperbolic cosine\n     ///\n     /// # Returns\n     ///\n     /// - on success, the inverse hyperbolic cosine of `self` will be returned\n     /// - `INFINITY` if `self` is `INFINITY`\n     /// - `NAN` if `self` is `NAN` or `self < 1.0` (including `NEG_INFINITY`)\n-    ///\n     #[inline]\n     fn acosh(&self) -> f32 {\n         match *self {\n@@ -524,7 +514,6 @@ impl Real for f32 {\n         }\n     }\n \n-    ///\n     /// Inverse hyperbolic tangent\n     ///\n     /// # Returns\n@@ -535,7 +524,6 @@ impl Real for f32 {\n     /// - `NEG_INFINITY` if `self` is `-1.0`\n     /// - `NAN` if the `self` is `NAN` or outside the domain of `-1.0 <= self <= 1.0`\n     ///   (including `INFINITY` and `NEG_INFINITY`)\n-    ///\n     #[inline]\n     fn atanh(&self) -> f32 {\n         0.5 * ((2.0 * *self) / (1.0 - *self)).ln_1p()\n@@ -643,38 +631,30 @@ impl Float for f32 {\n         ldexp(x, exp as c_int)\n     }\n \n-    ///\n     /// Breaks the number into a normalized fraction and a base-2 exponent, satisfying:\n     ///\n     /// - `self = x * pow(2, exp)`\n     /// - `0.5 <= abs(x) < 1.0`\n-    ///\n     #[inline]\n     fn frexp(&self) -> (f32, int) {\n         let mut exp = 0;\n         let x = frexp(*self, &mut exp);\n         (x, exp as int)\n     }\n \n-    ///\n     /// Returns the exponential of the number, minus `1`, in a way that is accurate\n     /// even if the number is close to zero\n-    ///\n     #[inline]\n     fn exp_m1(&self) -> f32 { exp_m1(*self) }\n \n-    ///\n     /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more accurately\n     /// than if the operations were performed separately\n-    ///\n     #[inline]\n     fn ln_1p(&self) -> f32 { ln_1p(*self) }\n \n-    ///\n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This\n     /// produces a more accurate result with better performance than a separate multiplication\n     /// operation followed by an add.\n-    ///\n     #[inline]\n     fn mul_add(&self, a: f32, b: f32) -> f32 {\n         mul_add(*self, a, b)\n@@ -708,78 +688,98 @@ impl Float for f32 {\n // Section: String Conversions\n //\n \n-///\n /// Converts a float to a string\n ///\n /// # Arguments\n ///\n /// * num - The float value\n-///\n #[inline]\n pub fn to_str(num: f32) -> ~str {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, strconv::SignNeg, strconv::DigAll);\n+        num, 10u, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n     r\n }\n \n-///\n /// Converts a float to a string in hexadecimal format\n ///\n /// # Arguments\n ///\n /// * num - The float value\n-///\n #[inline]\n pub fn to_str_hex(num: f32) -> ~str {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 16u, true, strconv::SignNeg, strconv::DigAll);\n+        num, 16u, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n     r\n }\n \n-///\n /// Converts a float to a string in a given radix, and a flag indicating\n /// whether it's a special value\n ///\n /// # Arguments\n ///\n /// * num - The float value\n /// * radix - The base to use\n-///\n #[inline]\n pub fn to_str_radix_special(num: f32, rdx: uint) -> (~str, bool) {\n     strconv::float_to_str_common(num, rdx, true,\n-                           strconv::SignNeg, strconv::DigAll)\n+                           strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false)\n }\n \n-///\n /// Converts a float to a string with exactly the number of\n /// provided significant digits\n ///\n /// # Arguments\n ///\n /// * num - The float value\n /// * digits - The number of significant digits\n-///\n #[inline]\n pub fn to_str_exact(num: f32, dig: uint) -> ~str {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, strconv::SignNeg, strconv::DigExact(dig));\n+        num, 10u, true, strconv::SignNeg, strconv::DigExact(dig), strconv::ExpNone, false);\n     r\n }\n \n-///\n /// Converts a float to a string with a maximum number of\n /// significant digits\n ///\n /// # Arguments\n ///\n /// * num - The float value\n /// * digits - The number of significant digits\n-///\n #[inline]\n pub fn to_str_digits(num: f32, dig: uint) -> ~str {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, strconv::SignNeg, strconv::DigMax(dig));\n+        num, 10u, true, strconv::SignNeg, strconv::DigMax(dig), strconv::ExpNone, false);\n+    r\n+}\n+\n+/// Converts a float to a string using the exponential notation with exactly the number of\n+/// provided digits after the decimal point in the significand\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+/// * digits - The number of digits after the decimal point\n+/// * upper - Use `E` instead of `e` for the exponent sign\n+#[inline]\n+pub fn to_str_exp_exact(num: f32, dig: uint, upper: bool) -> ~str {\n+    let (r, _) = strconv::float_to_str_common(\n+        num, 10u, true, strconv::SignNeg, strconv::DigExact(dig), strconv::ExpDec, upper);\n+    r\n+}\n+\n+/// Converts a float to a string using the exponential notation with the maximum number of\n+/// digits after the decimal point in the significand\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+/// * digits - The number of digits after the decimal point\n+/// * upper - Use `E` instead of `e` for the exponent sign\n+#[inline]\n+pub fn to_str_exp_digits(num: f32, dig: uint, upper: bool) -> ~str {\n+    let (r, _) = strconv::float_to_str_common(\n+        num, 10u, true, strconv::SignNeg, strconv::DigMax(dig), strconv::ExpDec, upper);\n     r\n }\n \n@@ -804,14 +804,13 @@ impl num::ToStrRadix for f32 {\n     #[inline]\n     fn to_str_radix(&self, rdx: uint) -> ~str {\n         let (r, special) = strconv::float_to_str_common(\n-            *self, rdx, true, strconv::SignNeg, strconv::DigAll);\n+            *self, rdx, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n         if special { fail!(\"number has a special value, \\\n                             try to_str_radix_special() if those are expected\") }\n         r\n     }\n }\n \n-///\n /// Convert a string in base 16 to a float.\n /// Accepts a optional binary exponent.\n ///\n@@ -837,15 +836,13 @@ impl num::ToStrRadix for f32 {\n ///\n /// `None` if the string did not represent a valid number.  Otherwise,\n /// `Some(n)` where `n` is the floating-point number represented by `[num]`.\n-///\n #[inline]\n pub fn from_str_hex(num: &str) -> Option<f32> {\n     strconv::from_str_common(num, 16u, true, true, true,\n                              strconv::ExpBin, false, false)\n }\n \n impl FromStr for f32 {\n-    ///\n     /// Convert a string in base 10 to a float.\n     /// Accepts a optional decimal exponent.\n     ///\n@@ -871,7 +868,6 @@ impl FromStr for f32 {\n     ///\n     /// `None` if the string did not represent a valid number.  Otherwise,\n     /// `Some(n)` where `n` is the floating-point number represented by `num`.\n-    ///\n     #[inline]\n     fn from_str(val: &str) -> Option<f32> {\n         strconv::from_str_common(val, 10u, true, true, true,\n@@ -880,7 +876,6 @@ impl FromStr for f32 {\n }\n \n impl num::FromStrRadix for f32 {\n-    ///\n     /// Convert a string in an given base to a float.\n     ///\n     /// Due to possible conflicts, this function does **not** accept\n@@ -898,7 +893,6 @@ impl num::FromStrRadix for f32 {\n     ///\n     /// `None` if the string did not represent a valid number. Otherwise,\n     /// `Some(n)` where `n` is the floating-point number represented by `num`.\n-    ///\n     #[inline]\n     fn from_str_radix(val: &str, rdx: uint) -> Option<f32> {\n         strconv::from_str_common(val, rdx, true, true, false,"}, {"sha": "1155a89876e5a23ef6dcb38a9ab2d9ae14f880e1", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 36, "deletions": 42, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/52ba3b6414fe91cf92222581cb24e06894267c49/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ba3b6414fe91cf92222581cb24e06894267c49/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=52ba3b6414fe91cf92222581cb24e06894267c49", "patch": "@@ -287,20 +287,16 @@ impl Signed for f64 {\n     #[inline]\n     fn abs(&self) -> f64 { abs(*self) }\n \n-    ///\n     /// The positive difference of two numbers. Returns `0.0` if the number is less than or\n     /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n-    ///\n     #[inline]\n     fn abs_sub(&self, other: &f64) -> f64 { abs_sub(*self, *other) }\n \n-    ///\n     /// # Returns\n     ///\n     /// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n     /// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n     /// - `NAN` if the number is NaN\n-    ///\n     #[inline]\n     fn signum(&self) -> f64 {\n         if self.is_nan() { NAN } else { copysign(1.0, *self) }\n@@ -332,14 +328,12 @@ impl Round for f64 {\n     #[inline]\n     fn trunc(&self) -> f64 { trunc(*self) }\n \n-    ///\n     /// The fractional part of the number, satisfying:\n     ///\n     /// ```rust\n     /// let x = 1.65f64;\n     /// assert!(x == x.trunc() + x.fract())\n     /// ```\n-    ///\n     #[inline]\n     fn fract(&self) -> f64 { *self - self.trunc() }\n }\n@@ -492,15 +486,13 @@ impl Real for f64 {\n     #[inline]\n     fn tanh(&self) -> f64 { tanh(*self) }\n \n-    ///\n     /// Inverse hyperbolic sine\n     ///\n     /// # Returns\n     ///\n     /// - on success, the inverse hyperbolic sine of `self` will be returned\n     /// - `self` if `self` is `0.0`, `-0.0`, `INFINITY`, or `NEG_INFINITY`\n     /// - `NAN` if `self` is `NAN`\n-    ///\n     #[inline]\n     fn asinh(&self) -> f64 {\n         match *self {\n@@ -509,15 +501,13 @@ impl Real for f64 {\n         }\n     }\n \n-    ///\n     /// Inverse hyperbolic cosine\n     ///\n     /// # Returns\n     ///\n     /// - on success, the inverse hyperbolic cosine of `self` will be returned\n     /// - `INFINITY` if `self` is `INFINITY`\n     /// - `NAN` if `self` is `NAN` or `self < 1.0` (including `NEG_INFINITY`)\n-    ///\n     #[inline]\n     fn acosh(&self) -> f64 {\n         match *self {\n@@ -526,7 +516,6 @@ impl Real for f64 {\n         }\n     }\n \n-    ///\n     /// Inverse hyperbolic tangent\n     ///\n     /// # Returns\n@@ -537,7 +526,6 @@ impl Real for f64 {\n     /// - `NEG_INFINITY` if `self` is `-1.0`\n     /// - `NAN` if the `self` is `NAN` or outside the domain of `-1.0 <= self <= 1.0`\n     ///   (including `INFINITY` and `NEG_INFINITY`)\n-    ///\n     #[inline]\n     fn atanh(&self) -> f64 {\n         0.5 * ((2.0 * *self) / (1.0 - *self)).ln_1p()\n@@ -645,38 +633,30 @@ impl Float for f64 {\n         ldexp(x, exp as c_int)\n     }\n \n-    ///\n     /// Breaks the number into a normalized fraction and a base-2 exponent, satisfying:\n     ///\n     /// - `self = x * pow(2, exp)`\n     /// - `0.5 <= abs(x) < 1.0`\n-    ///\n     #[inline]\n     fn frexp(&self) -> (f64, int) {\n         let mut exp = 0;\n         let x = frexp(*self, &mut exp);\n         (x, exp as int)\n     }\n \n-    ///\n     /// Returns the exponential of the number, minus `1`, in a way that is accurate\n     /// even if the number is close to zero\n-    ///\n     #[inline]\n     fn exp_m1(&self) -> f64 { exp_m1(*self) }\n \n-    ///\n     /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more accurately\n     /// than if the operations were performed separately\n-    ///\n     #[inline]\n     fn ln_1p(&self) -> f64 { ln_1p(*self) }\n \n-    ///\n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This\n     /// produces a more accurate result with better performance than a separate multiplication\n     /// operation followed by an add.\n-    ///\n     #[inline]\n     fn mul_add(&self, a: f64, b: f64) -> f64 {\n         mul_add(*self, a, b)\n@@ -710,78 +690,98 @@ impl Float for f64 {\n // Section: String Conversions\n //\n \n-///\n /// Converts a float to a string\n ///\n /// # Arguments\n ///\n /// * num - The float value\n-///\n #[inline]\n pub fn to_str(num: f64) -> ~str {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, strconv::SignNeg, strconv::DigAll);\n+        num, 10u, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n     r\n }\n \n-///\n /// Converts a float to a string in hexadecimal format\n ///\n /// # Arguments\n ///\n /// * num - The float value\n-///\n #[inline]\n pub fn to_str_hex(num: f64) -> ~str {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 16u, true, strconv::SignNeg, strconv::DigAll);\n+        num, 16u, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n     r\n }\n \n-///\n /// Converts a float to a string in a given radix, and a flag indicating\n /// whether it's a special value\n ///\n /// # Arguments\n ///\n /// * num - The float value\n /// * radix - The base to use\n-///\n #[inline]\n pub fn to_str_radix_special(num: f64, rdx: uint) -> (~str, bool) {\n     strconv::float_to_str_common(num, rdx, true,\n-                           strconv::SignNeg, strconv::DigAll)\n+                           strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false)\n }\n \n-///\n /// Converts a float to a string with exactly the number of\n /// provided significant digits\n ///\n /// # Arguments\n ///\n /// * num - The float value\n /// * digits - The number of significant digits\n-///\n #[inline]\n pub fn to_str_exact(num: f64, dig: uint) -> ~str {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, strconv::SignNeg, strconv::DigExact(dig));\n+        num, 10u, true, strconv::SignNeg, strconv::DigExact(dig), strconv::ExpNone, false);\n     r\n }\n \n-///\n /// Converts a float to a string with a maximum number of\n /// significant digits\n ///\n /// # Arguments\n ///\n /// * num - The float value\n /// * digits - The number of significant digits\n-///\n #[inline]\n pub fn to_str_digits(num: f64, dig: uint) -> ~str {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, strconv::SignNeg, strconv::DigMax(dig));\n+        num, 10u, true, strconv::SignNeg, strconv::DigMax(dig), strconv::ExpNone, false);\n+    r\n+}\n+\n+/// Converts a float to a string using the exponential notation with exactly the number of\n+/// provided digits after the decimal point in the significand\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+/// * digits - The number of digits after the decimal point\n+/// * upper - Use `E` instead of `e` for the exponent sign\n+#[inline]\n+pub fn to_str_exp_exact(num: f64, dig: uint, upper: bool) -> ~str {\n+    let (r, _) = strconv::float_to_str_common(\n+        num, 10u, true, strconv::SignNeg, strconv::DigExact(dig), strconv::ExpDec, upper);\n+    r\n+}\n+\n+/// Converts a float to a string using the exponential notation with the maximum number of\n+/// digits after the decimal point in the significand\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+/// * digits - The number of digits after the decimal point\n+/// * upper - Use `E` instead of `e` for the exponent sign\n+#[inline]\n+pub fn to_str_exp_digits(num: f64, dig: uint, upper: bool) -> ~str {\n+    let (r, _) = strconv::float_to_str_common(\n+        num, 10u, true, strconv::SignNeg, strconv::DigMax(dig), strconv::ExpDec, upper);\n     r\n }\n \n@@ -806,14 +806,13 @@ impl num::ToStrRadix for f64 {\n     #[inline]\n     fn to_str_radix(&self, rdx: uint) -> ~str {\n         let (r, special) = strconv::float_to_str_common(\n-            *self, rdx, true, strconv::SignNeg, strconv::DigAll);\n+            *self, rdx, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n         if special { fail!(\"number has a special value, \\\n                              try to_str_radix_special() if those are expected\") }\n         r\n     }\n }\n \n-///\n /// Convert a string in base 16 to a float.\n /// Accepts a optional binary exponent.\n ///\n@@ -839,15 +838,13 @@ impl num::ToStrRadix for f64 {\n ///\n /// `None` if the string did not represent a valid number.  Otherwise,\n /// `Some(n)` where `n` is the floating-point number represented by `[num]`.\n-///\n #[inline]\n pub fn from_str_hex(num: &str) -> Option<f64> {\n     strconv::from_str_common(num, 16u, true, true, true,\n                              strconv::ExpBin, false, false)\n }\n \n impl FromStr for f64 {\n-    ///\n     /// Convert a string in base 10 to a float.\n     /// Accepts a optional decimal exponent.\n     ///\n@@ -873,7 +870,6 @@ impl FromStr for f64 {\n     ///\n     /// `none` if the string did not represent a valid number.  Otherwise,\n     /// `Some(n)` where `n` is the floating-point number represented by `num`.\n-    ///\n     #[inline]\n     fn from_str(val: &str) -> Option<f64> {\n         strconv::from_str_common(val, 10u, true, true, true,\n@@ -882,7 +878,6 @@ impl FromStr for f64 {\n }\n \n impl num::FromStrRadix for f64 {\n-    ///\n     /// Convert a string in an given base to a float.\n     ///\n     /// Due to possible conflicts, this function does **not** accept\n@@ -900,7 +895,6 @@ impl num::FromStrRadix for f64 {\n     ///\n     /// `None` if the string did not represent a valid number. Otherwise,\n     /// `Some(n)` where `n` is the floating-point number represented by `num`.\n-    ///\n     #[inline]\n     fn from_str_radix(val: &str, rdx: uint) -> Option<f64> {\n         strconv::from_str_common(val, rdx, true, true, false,"}, {"sha": "30abe86866e220b526089c26588ff0a9919c625d", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 65, "deletions": 5, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/52ba3b6414fe91cf92222581cb24e06894267c49/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ba3b6414fe91cf92222581cb24e06894267c49/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=52ba3b6414fe91cf92222581cb24e06894267c49", "patch": "@@ -207,11 +207,13 @@ pub fn int_to_str_bytes_common<T:NumCast\n  * # Arguments\n  * - `num`           - The number to convert. Accepts any number that\n  *                     implements the numeric traits.\n- * - `radix`         - Base to use. Accepts only the values 2-36.\n+ * - `radix`         - Base to use. Accepts only the values 2-36. If the exponential notation\n+ *                     is used, then this base is only used for the significand. The exponent\n+ *                     itself always printed using a base of 10.\n  * - `negative_zero` - Whether to treat the special value `-0` as\n  *                     `-0` or as `+0`.\n  * - `sign`          - How to emit the sign. Options are:\n- *     - `SignNone`: No sign at all. Basically emits `abs(num)`.\n+ *     - `SignNone`: No sign at all. The exponent sign is also omitted.\n  *     - `SignNeg`:  Only `-` on negative values.\n  *     - `SignAll`:  Both `+` on positive, and `-` on negative numbers.\n  * - `digits`        - The amount of digits to use for emitting the\n@@ -220,6 +222,17 @@ pub fn int_to_str_bytes_common<T:NumCast\n  *                         fractions!\n  *     - `DigMax(uint)`:   Maximum N digits, truncating any trailing zeros.\n  *     - `DigExact(uint)`: Exactly N digits.\n+ * - `exp_format`   - Whether or not to use the exponential (scientific) notation.\n+ *                    Options are:\n+ *     - `ExpNone`: Do not use the exponential notation.\n+ *     - `ExpDec`:  Use the exponential notation with the exponent having a base of 10,\n+ *                  and exponent sign being `'e'` or `'E'` depending on the value of\n+ *                  the `exp_upper` argument. E.g. the number 1000 would be printed as 1e3.\n+ *     - `ExpBin`:  Use the exponential notation with the exponent having a base of 2,\n+ *                  and exponent sign being `'p'` or `'P'` depending on the value of\n+ *                  the `exp_upper` argument. E.g. the number 8 would be printed as 1p3.\n+ * - `exp_capital`   - Whether or not to use a capital letter for the exponent sign, if\n+ *                     exponential notation is desired.\n  *\n  * # Return value\n  * A tuple containing the byte vector, and a boolean flag indicating\n@@ -229,12 +242,26 @@ pub fn int_to_str_bytes_common<T:NumCast\n  *\n  * # Failure\n  * - Fails if `radix` < 2 or `radix` > 36.\n+ * - Fails if `radix` > 14 and `exp_format` is `ExpDec` due to conflict\n+ *   between digit and exponent sign `'e'`.\n+ * - Fails if `radix` > 25 and `exp_format` is `ExpBin` due to conflict\n+ *   between digit and exponent sign `'p'`.\n  */\n pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+Round+\n                                   Div<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n         num: T, radix: uint, negative_zero: bool,\n-        sign: SignFormat, digits: SignificantDigits) -> (~[u8], bool) {\n+        sign: SignFormat, digits: SignificantDigits, exp_format: ExponentFormat, exp_upper: bool\n+        ) -> (~[u8], bool) {\n     assert!(2 <= radix && radix <= 36);\n+    match exp_format {\n+        ExpDec if radix >= DIGIT_E_RADIX       // decimal exponent 'e'\n+          => fail!(\"float_to_str_bytes_common: radix {} incompatible with \\\n+                    use of 'e' as decimal exponent\", radix),\n+        ExpBin if radix >= DIGIT_P_RADIX       // binary exponent 'p'\n+          => fail!(\"float_to_str_bytes_common: radix {} incompatible with \\\n+                    use of 'p' as binary exponent\", radix),\n+        _ => ()\n+    }\n \n     let _0: T = Zero::zero();\n     let _1: T = One::one();\n@@ -260,6 +287,23 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+Round+\n     let mut buf: ~[u8] = ~[];\n     let radix_gen: T   = cast(radix as int).unwrap();\n \n+    let (num, exp) = match exp_format {\n+        ExpNone => (num, 0i32),\n+        ExpDec | ExpBin => {\n+            if num == _0 {\n+                (num, 0i32)\n+            } else {\n+                let (exp, exp_base) = match exp_format {\n+                    ExpDec => (num.abs().log10().floor(), cast::<f64, T>(10.0f64).unwrap()),\n+                    ExpBin => (num.abs().log2().floor(), cast::<f64, T>(2.0f64).unwrap()),\n+                    ExpNone => unreachable!()\n+                };\n+\n+                (num / exp_base.powf(&exp), cast::<T, i32>(exp).unwrap())\n+            }\n+        }\n+    };\n+\n     // First emit the non-fractional part, looping at least once to make\n     // sure at least a `0` gets emitted.\n     let mut deccum = num.trunc();\n@@ -413,6 +457,21 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+Round+\n         }\n     }\n \n+    match exp_format {\n+        ExpNone => (),\n+        _ => {\n+            buf.push(match exp_format {\n+                ExpDec if exp_upper => 'E',\n+                ExpDec if !exp_upper => 'e',\n+                ExpBin if exp_upper => 'P',\n+                ExpBin if !exp_upper => 'p',\n+                _ => unreachable!()\n+            } as u8);\n+\n+            int_to_str_bytes_common(exp, 10, sign, |c| buf.push(c));\n+        }\n+    }\n+\n     (buf, false)\n }\n \n@@ -424,9 +483,10 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+Round+\n pub fn float_to_str_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Float+Round+\n                              Div<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n         num: T, radix: uint, negative_zero: bool,\n-        sign: SignFormat, digits: SignificantDigits) -> (~str, bool) {\n+        sign: SignFormat, digits: SignificantDigits, exp_format: ExponentFormat, exp_capital: bool\n+        ) -> (~str, bool) {\n     let (bytes, special) = float_to_str_bytes_common(num, radix,\n-                               negative_zero, sign, digits);\n+                               negative_zero, sign, digits, exp_format, exp_capital);\n     (str::from_utf8_owned(bytes).unwrap(), special)\n }\n "}, {"sha": "bbf6f7fff7f9e274d46f0ab9956cd51951d6cc9b", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52ba3b6414fe91cf92222581cb24e06894267c49/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ba3b6414fe91cf92222581cb24e06894267c49/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=52ba3b6414fe91cf92222581cb24e06894267c49", "patch": "@@ -687,6 +687,8 @@ impl<'a> Context<'a> {\n                     \"b\" => \"Bool\",\n                     \"c\" => \"Char\",\n                     \"d\" | \"i\" => \"Signed\",\n+                    \"e\" => \"LowerExp\",\n+                    \"E\" => \"UpperExp\",\n                     \"f\" => \"Float\",\n                     \"o\" => \"Octal\",\n                     \"p\" => \"Pointer\","}, {"sha": "254c093e703a38767d03c984b09e8d8a6fe5ab33", "filename": "src/test/run-pass/exponential-notation.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/52ba3b6414fe91cf92222581cb24e06894267c49/src%2Ftest%2Frun-pass%2Fexponential-notation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ba3b6414fe91cf92222581cb24e06894267c49/src%2Ftest%2Frun-pass%2Fexponential-notation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexponential-notation.rs?ref=52ba3b6414fe91cf92222581cb24e06894267c49", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[feature(macro_rules)];\n+\n+use s = std::num::strconv;\n+use to_str = std::num::strconv::float_to_str_common;\n+\n+macro_rules! t(($a:expr, $b:expr) => { { let (r, _) = $a; assert_eq!(r, $b.to_owned()) } })\n+\n+pub fn main() {\n+    // Basic usage\n+    t!(to_str(1.2345678e-5, 10u, true, s::SignNeg, s::DigMax(6), s::ExpDec, false),\n+             \"1.234568e-5\")\n+\n+    // Hexadecimal output\n+    t!(to_str(7.281738281250e+01, 16u, true, s::SignAll, s::DigMax(6), s::ExpBin, false),\n+              \"+1.2345p+6\")\n+    t!(to_str(-1.777768135071e-02, 16u, true, s::SignAll, s::DigMax(6), s::ExpBin, false),\n+             \"-1.2345p-6\")\n+\n+    // Some denormals\n+    t!(to_str(4.9406564584124654e-324, 10u, true, s::SignNeg, s::DigMax(6), s::ExpBin, false),\n+             \"1p-1074\")\n+    t!(to_str(2.2250738585072009e-308, 10u, true, s::SignNeg, s::DigMax(6), s::ExpBin, false),\n+             \"1p-1022\")\n+}"}, {"sha": "610cba1eb1fa63389d08456db5165331c7cc84c7", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/52ba3b6414fe91cf92222581cb24e06894267c49/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ba3b6414fe91cf92222581cb24e06894267c49/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=52ba3b6414fe91cf92222581cb24e06894267c49", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -219,6 +219,14 @@ pub fn main() {\n     t!(format!(\"{:+10.3f}\", 1.0f64),  \"    +1.000\");\n     t!(format!(\"{:+10.3f}\", -1.0f64), \"    -1.000\");\n \n+    t!(format!(\"{:e}\", 1.2345e6f32), \"1.2345e6\");\n+    t!(format!(\"{:e}\", 1.2345e6f64), \"1.2345e6\");\n+    t!(format!(\"{:E}\", 1.2345e6f64), \"1.2345E6\");\n+    t!(format!(\"{:.3e}\", 1.2345e6f64), \"1.234e6\");\n+    t!(format!(\"{:10.3e}\", 1.2345e6f64),   \"   1.234e6\");\n+    t!(format!(\"{:+10.3e}\", 1.2345e6f64),  \"  +1.234e6\");\n+    t!(format!(\"{:+10.3e}\", -1.2345e6f64), \"  -1.234e6\");\n+\n     // Escaping\n     t!(format!(\"\\\\{\"), \"{\");\n     t!(format!(\"\\\\}\"), \"}\");"}]}