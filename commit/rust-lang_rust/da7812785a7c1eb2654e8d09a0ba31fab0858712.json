{"sha": "da7812785a7c1eb2654e8d09a0ba31fab0858712", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhNzgxMjc4NWE3YzFlYjI2NTRlOGQwOWEwYmEzMWZhYjA4NTg3MTI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-25T14:26:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-25T14:26:18Z"}, "message": "Rollup merge of #64508 - Centril:or-pat-hir, r=matthewjasper\n\nor-patterns: Push `PatKind/PatternKind::Or` at top level to HIR & HAIR\n\nFollowing up on work in https://github.com/rust-lang/rust/pull/64111, https://github.com/rust-lang/rust/pull/63693, and https://github.com/rust-lang/rust/pull/61708, in this PR:\n\n- We change `hair::Arm.patterns: Vec<Pattern<'_>>` into `hir::Arm.pattern: Pattern<'_>`.\n\n   - `fn hair::Arm::top_pats_hack` is introduced as a temporary crutch in MIR building to avoid more changes.\n\n- We change `hir::Arm.pats: HirVec<P<Pat>>` into `hir::Arm.pat: P<Pat>`.\n\n   - The hacks in `rustc::hir::lowering` are removed since the representation hack is no longer necessary.\n\n   - In some places, `fn hir::Arm::top_pats_hack` is introduced to leave some things as future work.\n\n   - Misc changes: HIR pretty printing is adjusted to behave uniformly wrt. top/inner levels, rvalue promotion is adjusted, regionck, and dead_code is also.\n\n   - Type checking is adjusted to uniformly handle or-patterns at top/inner levels.\n      To make things compile, `p_0 | ... | p_n` is redefined as a \"reference pattern\" in [`fn is_non_ref_pat`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_typeck/check/struct.FnCtxt.html#method.is_non_ref_pat) for now. This is done so that reference types are not eagerly stripped from the `expected: Ty<'tcx>`.\n\n    - Liveness is adjusted wrt. the `unused_variables` and `unused_assignments` lints to handle top/inner levels uniformly and the handling of `fn` parameters, `let` locals, and `match` arms are unified in this respect. This is not tested for now as exhaustiveness checks are reachable and will ICE.\n\n    - In `check_match`, checking `@` and by-move bindings is adjusted. However, exhaustiveness checking is not adjusted the moment and is handled by @dlrobertson in https://github.com/rust-lang/rust/pull/63688.\n\n    - AST borrowck (`construct.rs`) is not adjusted as AST borrowck will be removed soon.\n\nr? @matthewjasper\ncc @dlrobertson @varkor @oli-obk", "tree": {"sha": "4a4affcccc7dd47d85cf09d4ea5daa278d153e00", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a4affcccc7dd47d85cf09d4ea5daa278d153e00"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da7812785a7c1eb2654e8d09a0ba31fab0858712", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdi3kKCRBK7hj4Ov3rIwAAdHIIAHQQNzsWgilVBRFHoVsRisub\nhcSikduxgbTuVyrEnHZpQtkJ70qcF6gNmyL/r4yB4K/DM4ktGAMYbD6RW9ZKE4e2\nwPLVPjNZmfWxDPaUqTGpw1SifkWVtHe5vFLx6f2zBqMC+n/WLm0TkzKx00tLyx/w\nLq/M3RwKYXQv8TGxsOY0rbLxFII+3lQUlBQZ6Kf3eyIl/CV3ESfrb5YdVuGJ7N5/\nneGnpE+n9fGaMspqBBYQV6oA8ccDmi0xpL2MA12XxvAXY1O1159rxSF8lMeMmaj1\nMtWw354f6arAL/HeYcj/yRQhGgrjINXZEi4xubfUosgU/UPaMj/4XgqOWY1HwBU=\n=K9dk\n-----END PGP SIGNATURE-----\n", "payload": "tree 4a4affcccc7dd47d85cf09d4ea5daa278d153e00\nparent b30238e3125a6c1ebf95cf47e58566efc75ad2f1\nparent 0918dc4e5990592c28484d1d64bec41cb9a4a301\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1569421578 +0200\ncommitter GitHub <noreply@github.com> 1569421578 +0200\n\nRollup merge of #64508 - Centril:or-pat-hir, r=matthewjasper\n\nor-patterns: Push `PatKind/PatternKind::Or` at top level to HIR & HAIR\n\nFollowing up on work in https://github.com/rust-lang/rust/pull/64111, https://github.com/rust-lang/rust/pull/63693, and https://github.com/rust-lang/rust/pull/61708, in this PR:\n\n- We change `hair::Arm.patterns: Vec<Pattern<'_>>` into `hir::Arm.pattern: Pattern<'_>`.\n\n   - `fn hair::Arm::top_pats_hack` is introduced as a temporary crutch in MIR building to avoid more changes.\n\n- We change `hir::Arm.pats: HirVec<P<Pat>>` into `hir::Arm.pat: P<Pat>`.\n\n   - The hacks in `rustc::hir::lowering` are removed since the representation hack is no longer necessary.\n\n   - In some places, `fn hir::Arm::top_pats_hack` is introduced to leave some things as future work.\n\n   - Misc changes: HIR pretty printing is adjusted to behave uniformly wrt. top/inner levels, rvalue promotion is adjusted, regionck, and dead_code is also.\n\n   - Type checking is adjusted to uniformly handle or-patterns at top/inner levels.\n      To make things compile, `p_0 | ... | p_n` is redefined as a \"reference pattern\" in [`fn is_non_ref_pat`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_typeck/check/struct.FnCtxt.html#method.is_non_ref_pat) for now. This is done so that reference types are not eagerly stripped from the `expected: Ty<'tcx>`.\n\n    - Liveness is adjusted wrt. the `unused_variables` and `unused_assignments` lints to handle top/inner levels uniformly and the handling of `fn` parameters, `let` locals, and `match` arms are unified in this respect. This is not tested for now as exhaustiveness checks are reachable and will ICE.\n\n    - In `check_match`, checking `@` and by-move bindings is adjusted. However, exhaustiveness checking is not adjusted the moment and is handled by @dlrobertson in https://github.com/rust-lang/rust/pull/63688.\n\n    - AST borrowck (`construct.rs`) is not adjusted as AST borrowck will be removed soon.\n\nr? @matthewjasper\ncc @dlrobertson @varkor @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da7812785a7c1eb2654e8d09a0ba31fab0858712", "html_url": "https://github.com/rust-lang/rust/commit/da7812785a7c1eb2654e8d09a0ba31fab0858712", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da7812785a7c1eb2654e8d09a0ba31fab0858712/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b30238e3125a6c1ebf95cf47e58566efc75ad2f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/b30238e3125a6c1ebf95cf47e58566efc75ad2f1", "html_url": "https://github.com/rust-lang/rust/commit/b30238e3125a6c1ebf95cf47e58566efc75ad2f1"}, {"sha": "0918dc4e5990592c28484d1d64bec41cb9a4a301", "url": "https://api.github.com/repos/rust-lang/rust/commits/0918dc4e5990592c28484d1d64bec41cb9a4a301", "html_url": "https://github.com/rust-lang/rust/commit/0918dc4e5990592c28484d1d64bec41cb9a4a301"}], "stats": {"total": 858, "additions": 373, "deletions": 485}, "files": [{"sha": "91fc004b893bae3b421219803829ca6d30f7e273", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=da7812785a7c1eb2654e8d09a0ba31fab0858712", "patch": "@@ -1103,7 +1103,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n \n pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm) {\n     visitor.visit_id(arm.hir_id);\n-    walk_list!(visitor, visit_pat, &arm.pats);\n+    visitor.visit_pat(&arm.pat);\n     if let Some(ref g) = arm.guard {\n         match g {\n             Guard::If(ref e) => visitor.visit_expr(e),"}, {"sha": "f861499cfe4180a0b40be157d1eea20d2aae66bf", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=da7812785a7c1eb2654e8d09a0ba31fab0858712", "patch": "@@ -434,35 +434,6 @@ impl<'a> LoweringContext<'a> {\n                 visit::walk_pat(self, p)\n             }\n \n-            // HACK(or_patterns; Centril | dlrobertson): Avoid creating\n-            // HIR  nodes for `PatKind::Or` for the top level of a `ast::Arm`.\n-            // This is a temporary hack that should go away once we push down\n-            // `arm.pats: HirVec<P<Pat>>` -> `arm.pat: P<Pat>` to HIR. // Centril\n-            fn visit_arm(&mut self, arm: &'tcx Arm) {\n-                match &arm.pat.node {\n-                    PatKind::Or(pats) => pats.iter().for_each(|p| self.visit_pat(p)),\n-                    _ => self.visit_pat(&arm.pat),\n-                }\n-                walk_list!(self, visit_expr, &arm.guard);\n-                self.visit_expr(&arm.body);\n-                walk_list!(self, visit_attribute, &arm.attrs);\n-            }\n-\n-            // HACK(or_patterns; Centril | dlrobertson): Same as above. // Centril\n-            fn visit_expr(&mut self, e: &'tcx Expr) {\n-                if let ExprKind::Let(pat, scrutinee) = &e.node {\n-                    walk_list!(self, visit_attribute, e.attrs.iter());\n-                    match &pat.node {\n-                        PatKind::Or(pats) => pats.iter().for_each(|p| self.visit_pat(p)),\n-                        _ => self.visit_pat(&pat),\n-                    }\n-                    self.visit_expr(scrutinee);\n-                    self.visit_expr_post(e);\n-                    return;\n-                }\n-                visit::walk_expr(self, e)\n-            }\n-\n             fn visit_item(&mut self, item: &'tcx Item) {\n                 let hir_id = self.lctx.allocate_hir_id_counter(item.id);\n "}, {"sha": "90b6c9474acb02e0a6d3de017200ec71edad6556", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 19, "deletions": 32, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=da7812785a7c1eb2654e8d09a0ba31fab0858712", "patch": "@@ -247,14 +247,14 @@ impl LoweringContext<'_> {\n         // 4. The return type of the block is `bool` which seems like what the user wanted.\n         let scrutinee = self.lower_expr(scrutinee);\n         let then_arm = {\n-            let pat = self.lower_pat_top_hack(pat);\n+            let pat = self.lower_pat(pat);\n             let expr = self.expr_bool(span, true);\n             self.arm(pat, P(expr))\n         };\n         let else_arm = {\n             let pat = self.pat_wild(span);\n             let expr = self.expr_bool(span, false);\n-            self.arm(hir_vec![pat], P(expr))\n+            self.arm(pat, P(expr))\n         };\n         hir::ExprKind::Match(\n             P(scrutinee),\n@@ -278,15 +278,15 @@ impl LoweringContext<'_> {\n             None => (self.expr_block_empty(span), false),\n             Some(els) => (self.lower_expr(els), true),\n         };\n-        let else_arm = self.arm(hir_vec![else_pat], P(else_expr));\n+        let else_arm = self.arm(else_pat, P(else_expr));\n \n         // Handle then + scrutinee:\n         let then_expr = self.lower_block_expr(then);\n         let (then_pat, scrutinee, desugar) = match cond.node {\n             // `<pat> => <then>`:\n             ExprKind::Let(ref pat, ref scrutinee) => {\n                 let scrutinee = self.lower_expr(scrutinee);\n-                let pat = self.lower_pat_top_hack(pat);\n+                let pat = self.lower_pat(pat);\n                 (pat, scrutinee, hir::MatchSource::IfLetDesugar { contains_else_clause })\n             }\n             // `true => <then>`:\n@@ -303,7 +303,7 @@ impl LoweringContext<'_> {\n                 // let temporaries live outside of `cond`.\n                 let cond = self.expr_drop_temps(span_block, P(cond), ThinVec::new());\n                 let pat = self.pat_bool(span, true);\n-                (hir_vec![pat], cond, hir::MatchSource::IfDesugar { contains_else_clause })\n+                (pat, cond, hir::MatchSource::IfDesugar { contains_else_clause })\n             }\n         };\n         let then_arm = self.arm(then_pat, P(then_expr));\n@@ -327,7 +327,7 @@ impl LoweringContext<'_> {\n         let else_arm = {\n             let else_pat = self.pat_wild(span);\n             let else_expr = self.expr_break(span, ThinVec::new());\n-            self.arm(hir_vec![else_pat], else_expr)\n+            self.arm(else_pat, else_expr)\n         };\n \n         // Handle then + scrutinee:\n@@ -343,7 +343,7 @@ impl LoweringContext<'_> {\n                 //     }\n                 //   }\n                 let scrutinee = self.with_loop_condition_scope(|t| t.lower_expr(scrutinee));\n-                let pat = self.lower_pat_top_hack(pat);\n+                let pat = self.lower_pat(pat);\n                 (pat, scrutinee, hir::MatchSource::WhileLetDesugar, hir::LoopSource::WhileLet)\n             }\n             _ => {\n@@ -371,7 +371,7 @@ impl LoweringContext<'_> {\n                 let cond = self.expr_drop_temps(span_block, P(cond), ThinVec::new());\n                 // `true => <then>`:\n                 let pat = self.pat_bool(span, true);\n-                (hir_vec![pat], cond, hir::MatchSource::WhileDesugar, hir::LoopSource::While)\n+                (pat, cond, hir::MatchSource::WhileDesugar, hir::LoopSource::While)\n             }\n         };\n         let then_arm = self.arm(then_pat, P(then_expr));\n@@ -424,7 +424,7 @@ impl LoweringContext<'_> {\n         hir::Arm {\n             hir_id: self.next_id(),\n             attrs: self.lower_attrs(&arm.attrs),\n-            pats: self.lower_pat_top_hack(&arm.pat),\n+            pat: self.lower_pat(&arm.pat),\n             guard: match arm.guard {\n                 Some(ref x) => Some(hir::Guard::If(P(self.lower_expr(x)))),\n                 _ => None,\n@@ -434,16 +434,6 @@ impl LoweringContext<'_> {\n         }\n     }\n \n-    /// HACK(or_patterns; Centril | dlrobertson): For now we don't push down top level or-patterns\n-    /// `p | q` into `hir::PatKind::Or(...)` as post-lowering bits of the compiler are not ready\n-    /// to deal with it. This should by fixed by pushing it down to HIR and then HAIR.\n-    fn lower_pat_top_hack(&mut self, pat: &Pat) -> HirVec<P<hir::Pat>> {\n-        match pat.node {\n-            PatKind::Or(ref ps) => ps.iter().map(|x| self.lower_pat(x)).collect(),\n-            _ => hir_vec![self.lower_pat(pat)],\n-        }\n-    }\n-\n     pub(super) fn make_async_expr(\n         &mut self,\n         capture_clause: CaptureBy,\n@@ -592,7 +582,7 @@ impl LoweringContext<'_> {\n                 );\n                 P(this.expr(await_span, expr_break, ThinVec::new()))\n             });\n-            self.arm(hir_vec![ready_pat], break_x)\n+            self.arm(ready_pat, break_x)\n         };\n \n         // `::std::task::Poll::Pending => {}`\n@@ -603,7 +593,7 @@ impl LoweringContext<'_> {\n                 hir_vec![],\n             );\n             let empty_block = P(self.expr_block_empty(span));\n-            self.arm(hir_vec![pending_pat], empty_block)\n+            self.arm(pending_pat, empty_block)\n         };\n \n         let inner_match_stmt = {\n@@ -645,7 +635,7 @@ impl LoweringContext<'_> {\n         });\n \n         // mut pinned => loop { ... }\n-        let pinned_arm = self.arm(hir_vec![pinned_pat], loop_expr);\n+        let pinned_arm = self.arm(pinned_pat, loop_expr);\n \n         // match <expr> {\n         //     mut pinned => loop { .. }\n@@ -1079,15 +1069,15 @@ impl LoweringContext<'_> {\n                 ThinVec::new(),\n             ));\n             let some_pat = self.pat_some(pat.span, val_pat);\n-            self.arm(hir_vec![some_pat], assign)\n+            self.arm(some_pat, assign)\n         };\n \n         // `::std::option::Option::None => break`\n         let break_arm = {\n             let break_expr =\n                 self.with_loop_scope(e.id, |this| this.expr_break(e.span, ThinVec::new()));\n             let pat = self.pat_none(e.span);\n-            self.arm(hir_vec![pat], break_expr)\n+            self.arm(pat, break_expr)\n         };\n \n         // `mut iter`\n@@ -1158,7 +1148,7 @@ impl LoweringContext<'_> {\n         });\n \n         // `mut iter => { ... }`\n-        let iter_arm = self.arm(hir_vec![iter_pat], loop_expr);\n+        let iter_arm = self.arm(iter_pat, loop_expr);\n \n         // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n         let into_iter_expr = {\n@@ -1244,7 +1234,7 @@ impl LoweringContext<'_> {\n                 ThinVec::from(attrs.clone()),\n             ));\n             let ok_pat = self.pat_ok(span, val_pat);\n-            self.arm(hir_vec![ok_pat], val_expr)\n+            self.arm(ok_pat, val_expr)\n         };\n \n         // `Err(err) => #[allow(unreachable_code)]\n@@ -1279,7 +1269,7 @@ impl LoweringContext<'_> {\n             };\n \n             let err_pat = self.pat_err(try_span, err_local);\n-            self.arm(hir_vec![err_pat], ret_expr)\n+            self.arm(err_pat, ret_expr)\n         };\n \n         hir::ExprKind::Match(\n@@ -1474,14 +1464,11 @@ impl LoweringContext<'_> {\n         }\n     }\n \n-    /// HACK(or_patterns; Centril | dlrobertson): For now we don't push down top level or-patterns\n-    /// `p | q` into `hir::PatKind::Or(...)` as post-lowering bits of the compiler are not ready\n-    /// to deal with it. This should by fixed by pushing it down to HIR and then HAIR.\n-    fn arm(&mut self, pats: HirVec<P<hir::Pat>>, expr: P<hir::Expr>) -> hir::Arm {\n+    fn arm(&mut self, pat: P<hir::Pat>, expr: P<hir::Expr>) -> hir::Arm {\n         hir::Arm {\n             hir_id: self.next_id(),\n             attrs: hir_vec![],\n-            pats,\n+            pat,\n             guard: None,\n             span: expr.span,\n             body: expr,"}, {"sha": "6fdc126e216aa2d7f1ae0411b00b6c87e31a4d25", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 57, "deletions": 29, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=da7812785a7c1eb2654e8d09a0ba31fab0858712", "patch": "@@ -882,44 +882,61 @@ impl fmt::Debug for Pat {\n \n impl Pat {\n     // FIXME(#19596) this is a workaround, but there should be a better way\n-    fn walk_<G>(&self, it: &mut G) -> bool\n-        where G: FnMut(&Pat) -> bool\n-    {\n+    fn walk_short_(&self, it: &mut impl FnMut(&Pat) -> bool) -> bool {\n         if !it(self) {\n             return false;\n         }\n \n-        match self.node {\n-            PatKind::Binding(.., Some(ref p)) => p.walk_(it),\n-            PatKind::Struct(_, ref fields, _) => {\n-                fields.iter().all(|field| field.pat.walk_(it))\n-            }\n-            PatKind::TupleStruct(_, ref s, _) | PatKind::Tuple(ref s, _) => {\n-                s.iter().all(|p| p.walk_(it))\n-            }\n-            PatKind::Or(ref pats) => pats.iter().all(|p| p.walk_(it)),\n-            PatKind::Box(ref s) | PatKind::Ref(ref s, _) => {\n-                s.walk_(it)\n-            }\n-            PatKind::Slice(ref before, ref slice, ref after) => {\n+        use PatKind::*;\n+        match &self.node {\n+            Wild | Lit(_) | Range(..) | Binding(.., None) | Path(_) => true,\n+            Box(s) | Ref(s, _) | Binding(.., Some(s)) => s.walk_short_(it),\n+            Struct(_, fields, _) => fields.iter().all(|field| field.pat.walk_short_(it)),\n+            TupleStruct(_, s, _) | Tuple(s, _) | Or(s) => s.iter().all(|p| p.walk_short_(it)),\n+            Slice(before, slice, after) => {\n                 before.iter()\n                       .chain(slice.iter())\n                       .chain(after.iter())\n-                      .all(|p| p.walk_(it))\n+                      .all(|p| p.walk_short_(it))\n             }\n-            PatKind::Wild |\n-            PatKind::Lit(_) |\n-            PatKind::Range(..) |\n-            PatKind::Binding(..) |\n-            PatKind::Path(_) => {\n-                true\n+        }\n+    }\n+\n+    /// Walk the pattern in left-to-right order,\n+    /// short circuiting (with `.all(..)`) if `false` is returned.\n+    ///\n+    /// Note that when visiting e.g. `Tuple(ps)`,\n+    /// if visiting `ps[0]` returns `false`,\n+    /// then `ps[1]` will not be visited.\n+    pub fn walk_short(&self, mut it: impl FnMut(&Pat) -> bool) -> bool {\n+        self.walk_short_(&mut it)\n+    }\n+\n+    // FIXME(#19596) this is a workaround, but there should be a better way\n+    fn walk_(&self, it: &mut impl FnMut(&Pat) -> bool) {\n+        if !it(self) {\n+            return;\n+        }\n+\n+        use PatKind::*;\n+        match &self.node {\n+            Wild | Lit(_) | Range(..) | Binding(.., None) | Path(_) => {},\n+            Box(s) | Ref(s, _) | Binding(.., Some(s)) => s.walk_(it),\n+            Struct(_, fields, _) => fields.iter().for_each(|field| field.pat.walk_(it)),\n+            TupleStruct(_, s, _) | Tuple(s, _) | Or(s) => s.iter().for_each(|p| p.walk_(it)),\n+            Slice(before, slice, after) => {\n+                before.iter()\n+                      .chain(slice.iter())\n+                      .chain(after.iter())\n+                      .for_each(|p| p.walk_(it))\n             }\n         }\n     }\n \n-    pub fn walk<F>(&self, mut it: F) -> bool\n-        where F: FnMut(&Pat) -> bool\n-    {\n+    /// Walk the pattern in left-to-right order.\n+    ///\n+    /// If `it(pat)` returns `false`, the children are not visited.\n+    pub fn walk(&self, mut it: impl FnMut(&Pat) -> bool) {\n         self.walk_(&mut it)\n     }\n }\n@@ -1259,21 +1276,32 @@ pub struct Local {\n }\n \n /// Represents a single arm of a `match` expression, e.g.\n-/// `<pats> (if <guard>) => <body>`.\n+/// `<pat> (if <guard>) => <body>`.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct Arm {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n     pub span: Span,\n     pub attrs: HirVec<Attribute>,\n-    /// Multiple patterns can be combined with `|`\n-    pub pats: HirVec<P<Pat>>,\n+    /// If this pattern and the optional guard matches, then `body` is evaluated.\n+    pub pat: P<Pat>,\n     /// Optional guard clause.\n     pub guard: Option<Guard>,\n     /// The expression the arm evaluates to if this arm matches.\n     pub body: P<Expr>,\n }\n \n+impl Arm {\n+    // HACK(or_patterns; Centril | dlrobertson): Remove this and\n+    // correctly handle each case in which this method is used.\n+    pub fn top_pats_hack(&self) -> &[P<Pat>] {\n+        match &self.pat.node {\n+            PatKind::Or(pats) => pats,\n+            _ => std::slice::from_ref(&self.pat),\n+        }\n+    }\n+}\n+\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum Guard {\n     If(P<Expr>),"}, {"sha": "118e168f877678eb519d6f5b380429f2809c7a28", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 58, "deletions": 57, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=da7812785a7c1eb2654e8d09a0ba31fab0858712", "patch": "@@ -66,9 +66,7 @@ impl hir::Pat {\n \n     /// Call `f` on every \"binding\" in a pattern, e.g., on `a` in\n     /// `match foo() { Some(a) => (), None => () }`\n-    pub fn each_binding<F>(&self, mut f: F)\n-        where F: FnMut(hir::BindingAnnotation, HirId, Span, ast::Ident),\n-    {\n+    pub fn each_binding(&self, mut f: impl FnMut(hir::BindingAnnotation, HirId, Span, ast::Ident)) {\n         self.walk(|p| {\n             if let PatKind::Binding(binding_mode, _, ident, _) = p.node {\n                 f(binding_mode, p.hir_id, p.span, ident);\n@@ -77,35 +75,57 @@ impl hir::Pat {\n         });\n     }\n \n+    /// Call `f` on every \"binding\" in a pattern, e.g., on `a` in\n+    /// `match foo() { Some(a) => (), None => () }`.\n+    ///\n+    /// When encountering an or-pattern `p_0 | ... | p_n` only `p_0` will be visited.\n+    pub fn each_binding_or_first(\n+        &self,\n+        f: &mut impl FnMut(hir::BindingAnnotation, HirId, Span, ast::Ident),\n+    ) {\n+        self.walk(|p| match &p.node {\n+            PatKind::Or(ps) => {\n+                ps[0].each_binding_or_first(f);\n+                false\n+            },\n+            PatKind::Binding(bm,  _, ident, _) => {\n+                f(*bm, p.hir_id, p.span, *ident);\n+                true\n+            }\n+            _ => true,\n+        })\n+    }\n+\n     /// Checks if the pattern contains any patterns that bind something to\n     /// an ident, e.g., `foo`, or `Foo(foo)` or `foo @ Bar(..)`.\n     pub fn contains_bindings(&self) -> bool {\n-        let mut contains_bindings = false;\n-        self.walk(|p| {\n-            if let PatKind::Binding(..) = p.node {\n-                contains_bindings = true;\n-                false // there's at least one binding, can short circuit now.\n-            } else {\n-                true\n-            }\n-        });\n-        contains_bindings\n+        self.satisfies(|p| match p.node {\n+            PatKind::Binding(..) => true,\n+            _ => false,\n+        })\n     }\n \n     /// Checks if the pattern contains any patterns that bind something to\n     /// an ident or wildcard, e.g., `foo`, or `Foo(_)`, `foo @ Bar(..)`,\n     pub fn contains_bindings_or_wild(&self) -> bool {\n-        let mut contains_bindings = false;\n-        self.walk(|p| {\n-            match p.node {\n-                PatKind::Binding(..) | PatKind::Wild => {\n-                    contains_bindings = true;\n-                    false // there's at least one binding/wildcard, can short circuit now.\n-                }\n-                _ => true\n+        self.satisfies(|p| match p.node {\n+            PatKind::Binding(..) | PatKind::Wild => true,\n+            _ => false,\n+        })\n+    }\n+\n+    /// Checks if the pattern satisfies the given predicate on some sub-pattern.\n+    fn satisfies(&self, pred: impl Fn(&Self) -> bool) -> bool {\n+        let mut satisfies = false;\n+        self.walk_short(|p| {\n+            if pred(p) {\n+                satisfies = true;\n+                false // Found one, can short circuit now.\n+            } else {\n+                true\n             }\n         });\n-        contains_bindings\n+        satisfies\n     }\n \n     pub fn simple_ident(&self) -> Option<ast::Ident> {\n@@ -119,20 +139,20 @@ impl hir::Pat {\n     /// Returns variants that are necessary to exist for the pattern to match.\n     pub fn necessary_variants(&self) -> Vec<DefId> {\n         let mut variants = vec![];\n-        self.walk(|p| {\n-            match p.node {\n-                PatKind::Path(hir::QPath::Resolved(_, ref path)) |\n-                PatKind::TupleStruct(hir::QPath::Resolved(_, ref path), ..) |\n-                PatKind::Struct(hir::QPath::Resolved(_, ref path), ..) => {\n-                    match path.res {\n-                        Res::Def(DefKind::Variant, id) => variants.push(id),\n-                        Res::Def(DefKind::Ctor(CtorOf::Variant, ..), id) => variants.push(id),\n-                        _ => ()\n-                    }\n+        self.walk(|p| match &p.node {\n+            PatKind::Or(_) => false,\n+            PatKind::Path(hir::QPath::Resolved(_, path)) |\n+            PatKind::TupleStruct(hir::QPath::Resolved(_, path), ..) |\n+            PatKind::Struct(hir::QPath::Resolved(_, path), ..) => {\n+                if let Res::Def(DefKind::Variant, id)\n+                    | Res::Def(DefKind::Ctor(CtorOf::Variant, ..), id)\n+                    = path.res\n+                {\n+                    variants.push(id);\n                 }\n-                _ => ()\n+                true\n             }\n-            true\n+            _ => true,\n         });\n         variants.sort();\n         variants.dedup();\n@@ -148,33 +168,14 @@ impl hir::Pat {\n         let mut result = None;\n         self.each_binding(|annotation, _, _, _| {\n             match annotation {\n-                hir::BindingAnnotation::Ref => {\n-                    match result {\n-                        None | Some(hir::MutImmutable) => result = Some(hir::MutImmutable),\n-                        _ => (),\n-                    }\n+                hir::BindingAnnotation::Ref => match result {\n+                    None | Some(hir::MutImmutable) => result = Some(hir::MutImmutable),\n+                    _ => {}\n                 }\n                 hir::BindingAnnotation::RefMut => result = Some(hir::MutMutable),\n-                _ => (),\n+                _ => {}\n             }\n         });\n         result\n     }\n }\n-\n-impl hir::Arm {\n-    /// Checks if the patterns for this arm contain any `ref` or `ref mut`\n-    /// bindings, and if yes whether its containing mutable ones or just immutables ones.\n-    pub fn contains_explicit_ref_binding(&self) -> Option<hir::Mutability> {\n-        // FIXME(tschottdorf): contains_explicit_ref_binding() must be removed\n-        // for #42640 (default match binding modes).\n-        //\n-        // See #44848.\n-        self.pats.iter()\n-                 .filter_map(|pat| pat.contains_explicit_ref_binding())\n-                 .max_by_key(|m| match *m {\n-                    hir::MutMutable => 1,\n-                    hir::MutImmutable => 0,\n-                 })\n-    }\n-}"}, {"sha": "3cbc9ebec0ad8c10de64894a26e5c2430fb799a7", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=da7812785a7c1eb2654e8d09a0ba31fab0858712", "patch": "@@ -1790,16 +1790,7 @@ impl<'a> State<'a> {\n         self.ann.pre(self, AnnNode::Arm(arm));\n         self.ibox(0);\n         self.print_outer_attributes(&arm.attrs);\n-        let mut first = true;\n-        for p in &arm.pats {\n-            if first {\n-                first = false;\n-            } else {\n-                self.s.space();\n-                self.word_space(\"|\");\n-            }\n-            self.print_pat(&p);\n-        }\n+        self.print_pat(&arm.pat);\n         self.s.space();\n         if let Some(ref g) = arm.guard {\n             match g {"}, {"sha": "2746794e2a2c1f78508e58ef275d1b3e63e8c185", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=da7812785a7c1eb2654e8d09a0ba31fab0858712", "patch": "@@ -259,19 +259,13 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn visit_arm(&mut self, arm: &'tcx hir::Arm) {\n-        if arm.pats.len() == 1 {\n-            let variants = arm.pats[0].necessary_variants();\n-\n-            // Inside the body, ignore constructions of variants\n-            // necessary for the pattern to match. Those construction sites\n-            // can't be reached unless the variant is constructed elsewhere.\n-            let len = self.ignore_variant_stack.len();\n-            self.ignore_variant_stack.extend_from_slice(&variants);\n-            intravisit::walk_arm(self, arm);\n-            self.ignore_variant_stack.truncate(len);\n-        } else {\n-            intravisit::walk_arm(self, arm);\n-        }\n+        // Inside the body, ignore constructions of variants\n+        // necessary for the pattern to match. Those construction sites\n+        // can't be reached unless the variant is constructed elsewhere.\n+        let len = self.ignore_variant_stack.len();\n+        self.ignore_variant_stack.extend(arm.pat.necessary_variants());\n+        intravisit::walk_arm(self, arm);\n+        self.ignore_variant_stack.truncate(len);\n     }\n \n     fn visit_pat(&mut self, pat: &'tcx hir::Pat) {"}, {"sha": "a3110c000fb2223de06fc2c2aca4668157e36d46", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=da7812785a7c1eb2654e8d09a0ba31fab0858712", "patch": "@@ -779,16 +779,12 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n \n     fn arm_move_mode(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &hir::Arm) -> TrackMatchMode {\n         let mut mode = Unknown;\n-        for pat in &arm.pats {\n-            self.determine_pat_move_mode(discr_cmt.clone(), &pat, &mut mode);\n-        }\n+        self.determine_pat_move_mode(discr_cmt.clone(), &arm.pat, &mut mode);\n         mode\n     }\n \n     fn walk_arm(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &hir::Arm, mode: MatchMode) {\n-        for pat in &arm.pats {\n-            self.walk_pat(discr_cmt.clone(), &pat, mode);\n-        }\n+        self.walk_pat(discr_cmt.clone(), &arm.pat, mode);\n \n         if let Some(hir::Guard::If(ref e)) = arm.guard {\n             self.consume_expr(e)"}, {"sha": "9f6611712a8aa9328b31d4ffd1ee8dc0c8bc7ef6", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 125, "deletions": 194, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=da7812785a7c1eb2654e8d09a0ba31fab0858712", "patch": "@@ -96,7 +96,11 @@\n use self::LiveNodeKind::*;\n use self::VarKind::*;\n \n+use crate::hir;\n+use crate::hir::{Expr, HirId};\n use crate::hir::def::*;\n+use crate::hir::def_id::DefId;\n+use crate::hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n use crate::hir::Node;\n use crate::hir::ptr::P;\n use crate::ty::{self, TyCtxt};\n@@ -105,20 +109,16 @@ use crate::lint;\n use crate::util::nodemap::{HirIdMap, HirIdSet};\n \n use errors::Applicability;\n-use std::collections::{BTreeMap, VecDeque};\n+use rustc_data_structures::fx::FxIndexMap;\n+use std::collections::VecDeque;\n use std::{fmt, u32};\n use std::io::prelude::*;\n use std::io;\n use std::rc::Rc;\n use syntax::ast;\n-use syntax::symbol::{kw, sym};\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n \n-use crate::hir;\n-use crate::hir::{Expr, HirId};\n-use crate::hir::def_id::DefId;\n-use crate::hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n-\n #[derive(Copy, Clone, PartialEq)]\n struct Variable(u32);\n \n@@ -404,34 +404,29 @@ fn visit_fn<'tcx>(\n     lsets.warn_about_unused_args(body, entry_ln);\n }\n \n-fn add_from_pat<'tcx>(ir: &mut IrMaps<'tcx>, pat: &P<hir::Pat>) {\n+fn add_from_pat(ir: &mut IrMaps<'_>, pat: &P<hir::Pat>) {\n     // For struct patterns, take note of which fields used shorthand\n     // (`x` rather than `x: x`).\n     let mut shorthand_field_ids = HirIdSet::default();\n     let mut pats = VecDeque::new();\n     pats.push_back(pat);\n     while let Some(pat) = pats.pop_front() {\n         use crate::hir::PatKind::*;\n-        match pat.node {\n-            Binding(_, _, _, ref inner_pat) => {\n+        match &pat.node {\n+            Binding(.., inner_pat) => {\n                 pats.extend(inner_pat.iter());\n             }\n-            Struct(_, ref fields, _) => {\n-                for field in fields {\n-                    if field.is_shorthand {\n-                        shorthand_field_ids.insert(field.pat.hir_id);\n-                    }\n-                }\n+            Struct(_, fields, _) => {\n+                let ids = fields.iter().filter(|f| f.is_shorthand).map(|f| f.pat.hir_id);\n+                shorthand_field_ids.extend(ids);\n             }\n-            Ref(ref inner_pat, _) |\n-            Box(ref inner_pat) => {\n+            Ref(inner_pat, _) | Box(inner_pat) => {\n                 pats.push_back(inner_pat);\n             }\n-            TupleStruct(_, ref inner_pats, _) |\n-            Tuple(ref inner_pats, _) => {\n+            TupleStruct(_, inner_pats, _) | Tuple(inner_pats, _) | Or(inner_pats) => {\n                 pats.extend(inner_pats.iter());\n             }\n-            Slice(ref pre_pats, ref inner_pat, ref post_pats) => {\n+            Slice(pre_pats, inner_pat, post_pats) => {\n                 pats.extend(pre_pats.iter());\n                 pats.extend(inner_pat.iter());\n                 pats.extend(post_pats.iter());\n@@ -440,7 +435,7 @@ fn add_from_pat<'tcx>(ir: &mut IrMaps<'tcx>, pat: &P<hir::Pat>) {\n         }\n     }\n \n-    pat.each_binding(|_bm, hir_id, _sp, ident| {\n+    pat.each_binding(|_, hir_id, _, ident| {\n         ir.add_live_node_for_node(hir_id, VarDefNode(ident.span));\n         ir.add_variable(Local(LocalInfo {\n             id: hir_id,\n@@ -456,9 +451,7 @@ fn visit_local<'tcx>(ir: &mut IrMaps<'tcx>, local: &'tcx hir::Local) {\n }\n \n fn visit_arm<'tcx>(ir: &mut IrMaps<'tcx>, arm: &'tcx hir::Arm) {\n-    for pat in &arm.pats {\n-        add_from_pat(ir, pat);\n-    }\n+    add_from_pat(ir, &arm.pat);\n     intravisit::walk_arm(ir, arm);\n }\n \n@@ -734,35 +727,15 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         self.ir.variable(hir_id, span)\n     }\n \n-    fn pat_bindings<F>(&mut self, pat: &hir::Pat, mut f: F) where\n-        F: FnMut(&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, HirId),\n-    {\n-        pat.each_binding(|_bm, hir_id, sp, n| {\n-            let ln = self.live_node(hir_id, sp);\n-            let var = self.variable(hir_id, n.span);\n-            f(self, ln, var, n.span, hir_id);\n-        })\n-    }\n-\n-    fn arm_pats_bindings<F>(&mut self, pat: Option<&hir::Pat>, f: F) where\n-        F: FnMut(&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, HirId),\n-    {\n-        if let Some(pat) = pat {\n-            self.pat_bindings(pat, f);\n-        }\n-    }\n-\n-    fn define_bindings_in_pat(&mut self, pat: &hir::Pat, succ: LiveNode)\n-                              -> LiveNode {\n-        self.define_bindings_in_arm_pats(Some(pat), succ)\n-    }\n-\n-    fn define_bindings_in_arm_pats(&mut self, pat: Option<&hir::Pat>, succ: LiveNode)\n-                                   -> LiveNode {\n-        let mut succ = succ;\n-        self.arm_pats_bindings(pat, |this, ln, var, _sp, _id| {\n-            this.init_from_succ(ln, succ);\n-            this.define(ln, var);\n+    fn define_bindings_in_pat(&mut self, pat: &hir::Pat, mut succ: LiveNode) -> LiveNode {\n+        // In an or-pattern, only consider the first pattern; any later patterns\n+        // must have the same bindings, and we also consider the first pattern\n+        // to be the \"authoritative\" set of ids.\n+        pat.each_binding_or_first(&mut |_, hir_id, pat_sp, ident| {\n+            let ln = self.live_node(hir_id, pat_sp);\n+            let var = self.variable(hir_id, ident.span);\n+            self.init_from_succ(ln, succ);\n+            self.define(ln, var);\n             succ = ln;\n         });\n         succ\n@@ -1076,12 +1049,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                         arm.guard.as_ref().map(|hir::Guard::If(e)| &**e),\n                         body_succ\n                     );\n-                    // only consider the first pattern; any later patterns must have\n-                    // the same bindings, and we also consider the first pattern to be\n-                    // the \"authoritative\" set of ids\n-                    let arm_succ =\n-                        self.define_bindings_in_arm_pats(arm.pats.first().map(|p| &**p),\n-                                                         guard_succ);\n+                    let arm_succ = self.define_bindings_in_pat(&arm.pat, guard_succ);\n                     self.merge_from_succ(ln, arm_succ, first_merge);\n                     first_merge = false;\n                 };\n@@ -1388,74 +1356,36 @@ impl<'a, 'tcx> Visitor<'tcx> for Liveness<'a, 'tcx> {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_local(&mut self, l: &'tcx hir::Local) {\n-        check_local(self, l);\n-    }\n-    fn visit_expr(&mut self, ex: &'tcx Expr) {\n-        check_expr(self, ex);\n-    }\n-    fn visit_arm(&mut self, a: &'tcx hir::Arm) {\n-        check_arm(self, a);\n-    }\n-}\n+    fn visit_local(&mut self, local: &'tcx hir::Local) {\n+        self.check_unused_vars_in_pat(&local.pat, None, |spans, hir_id, ln, var| {\n+            if local.init.is_some() {\n+                self.warn_about_dead_assign(spans, hir_id, ln, var);\n+            }\n+        });\n \n-fn check_local<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, local: &'tcx hir::Local) {\n-    match local.init {\n-        Some(_) => {\n-            this.warn_about_unused_or_dead_vars_in_pat(&local.pat);\n-        },\n-        None => {\n-            this.pat_bindings(&local.pat, |this, ln, var, sp, id| {\n-                let span = local.pat.simple_ident().map_or(sp, |ident| ident.span);\n-                this.warn_about_unused(vec![span], id, ln, var);\n-            })\n-        }\n+        intravisit::walk_local(self, local);\n     }\n \n-    intravisit::walk_local(this, local);\n-}\n-\n-fn check_arm<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, arm: &'tcx hir::Arm) {\n-    // Only consider the variable from the first pattern; any later patterns must have\n-    // the same bindings, and we also consider the first pattern to be the \"authoritative\" set of\n-    // ids. However, we should take the spans of variables with the same name from the later\n-    // patterns so the suggestions to prefix with underscores will apply to those too.\n-    let mut vars: BTreeMap<String, (LiveNode, Variable, HirId, Vec<Span>)> = Default::default();\n-\n-    for pat in &arm.pats {\n-        this.arm_pats_bindings(Some(&*pat), |this, ln, var, sp, id| {\n-            let name = this.ir.variable_name(var);\n-            vars.entry(name)\n-                .and_modify(|(.., spans)| {\n-                    spans.push(sp);\n-                })\n-                .or_insert_with(|| {\n-                    (ln, var, id, vec![sp])\n-                });\n-        });\n+    fn visit_expr(&mut self, ex: &'tcx Expr) {\n+        check_expr(self, ex);\n     }\n \n-    for (_, (ln, var, id, spans)) in vars {\n-        this.warn_about_unused(spans, id, ln, var);\n+    fn visit_arm(&mut self, arm: &'tcx hir::Arm) {\n+        self.check_unused_vars_in_pat(&arm.pat, None, |_, _, _, _| {});\n+        intravisit::walk_arm(self, arm);\n     }\n-\n-    intravisit::walk_arm(this, arm);\n }\n \n-fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n+fn check_expr<'tcx>(this: &mut Liveness<'_, 'tcx>, expr: &'tcx Expr) {\n     match expr.node {\n         hir::ExprKind::Assign(ref l, _) => {\n             this.check_place(&l);\n-\n-            intravisit::walk_expr(this, expr);\n         }\n \n         hir::ExprKind::AssignOp(_, ref l, _) => {\n             if !this.tables.is_method_call(expr) {\n                 this.check_place(&l);\n             }\n-\n-            intravisit::walk_expr(this, expr);\n         }\n \n         hir::ExprKind::InlineAsm(ref ia, ref outputs, ref inputs) => {\n@@ -1470,8 +1400,6 @@ fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n                 }\n                 this.visit_expr(output);\n             }\n-\n-            intravisit::walk_expr(this, expr);\n         }\n \n         // no correctness conditions related to liveness\n@@ -1484,13 +1412,13 @@ fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n         hir::ExprKind::Lit(_) | hir::ExprKind::Block(..) | hir::ExprKind::AddrOf(..) |\n         hir::ExprKind::Struct(..) | hir::ExprKind::Repeat(..) |\n         hir::ExprKind::Closure(..) | hir::ExprKind::Path(_) | hir::ExprKind::Yield(..) |\n-        hir::ExprKind::Box(..) | hir::ExprKind::Type(..) | hir::ExprKind::Err => {\n-            intravisit::walk_expr(this, expr);\n-        }\n+        hir::ExprKind::Box(..) | hir::ExprKind::Type(..) | hir::ExprKind::Err => {}\n     }\n+\n+    intravisit::walk_expr(this, expr);\n }\n \n-impl<'a, 'tcx> Liveness<'a, 'tcx> {\n+impl<'tcx> Liveness<'_, 'tcx> {\n     fn check_place(&mut self, expr: &'tcx Expr) {\n         match expr.node {\n             hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n@@ -1503,7 +1431,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                         // as being used.\n                         let ln = self.live_node(expr.hir_id, expr.span);\n                         let var = self.variable(var_hid, expr.span);\n-                        self.warn_about_dead_assign(expr.span, expr.hir_id, ln, var);\n+                        self.warn_about_dead_assign(vec![expr.span], expr.hir_id, ln, var);\n                     }\n                 }\n             }\n@@ -1525,109 +1453,112 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn warn_about_unused_args(&self, body: &hir::Body, entry_ln: LiveNode) {\n-        for param in &body.params {\n-            param.pat.each_binding(|_bm, hir_id, _, ident| {\n-                let sp = ident.span;\n-                let var = self.variable(hir_id, sp);\n-                // Ignore unused self.\n-                if ident.name != kw::SelfLower {\n-                    if !self.warn_about_unused(vec![sp], hir_id, entry_ln, var) {\n-                        if self.live_on_entry(entry_ln, var).is_none() {\n-                            self.report_dead_assign(hir_id, sp, var, true);\n-                        }\n-                    }\n+        for p in &body.params {\n+            self.check_unused_vars_in_pat(&p.pat, Some(entry_ln), |spans, hir_id, ln, var| {\n+                if self.live_on_entry(ln, var).is_none() {\n+                    self.report_dead_assign(hir_id, spans, var, true);\n                 }\n-            })\n+            });\n         }\n     }\n \n-    fn warn_about_unused_or_dead_vars_in_pat(&mut self, pat: &hir::Pat) {\n-        self.pat_bindings(pat, |this, ln, var, sp, id| {\n-            if !this.warn_about_unused(vec![sp], id, ln, var) {\n-                this.warn_about_dead_assign(sp, id, ln, var);\n+    fn check_unused_vars_in_pat(\n+        &self,\n+        pat: &hir::Pat,\n+        entry_ln: Option<LiveNode>,\n+        on_used_on_entry: impl Fn(Vec<Span>, HirId, LiveNode, Variable),\n+    ) {\n+        // In an or-pattern, only consider the variable; any later patterns must have the same\n+        // bindings, and we also consider the first pattern to be the \"authoritative\" set of ids.\n+        // However, we should take the spans of variables with the same name from the later\n+        // patterns so the suggestions to prefix with underscores will apply to those too.\n+        let mut vars: FxIndexMap<String, (LiveNode, Variable, HirId, Vec<Span>)> = <_>::default();\n+\n+        pat.each_binding(|_, hir_id, pat_sp, ident| {\n+            let ln = entry_ln.unwrap_or_else(|| self.live_node(hir_id, pat_sp));\n+            let var = self.variable(hir_id, ident.span);\n+            vars.entry(self.ir.variable_name(var))\n+                .and_modify(|(.., spans)| spans.push(ident.span))\n+                .or_insert_with(|| (ln, var, hir_id, vec![ident.span]));\n+        });\n+\n+        for (_, (ln, var, id, spans)) in vars {\n+            if self.used_on_entry(ln, var) {\n+                on_used_on_entry(spans, id, ln, var);\n+            } else {\n+                self.report_unused(spans, id, ln, var);\n             }\n-        })\n+        }\n     }\n \n-    fn warn_about_unused(&self,\n-                         spans: Vec<Span>,\n-                         hir_id: HirId,\n-                         ln: LiveNode,\n-                         var: Variable)\n-                         -> bool {\n-        if !self.used_on_entry(ln, var) {\n-            let r = self.should_warn(var);\n-            if let Some(name) = r {\n-                // annoying: for parameters in funcs like `fn(x: i32)\n-                // {ret}`, there is only one node, so asking about\n-                // assigned_on_exit() is not meaningful.\n-                let is_assigned = if ln == self.s.exit_ln {\n-                    false\n-                } else {\n-                    self.assigned_on_exit(ln, var).is_some()\n-                };\n+    fn report_unused(&self, spans: Vec<Span>, hir_id: HirId, ln: LiveNode, var: Variable) {\n+        if let Some(name) = self.should_warn(var).filter(|name| name != \"self\") {\n+            // annoying: for parameters in funcs like `fn(x: i32)\n+            // {ret}`, there is only one node, so asking about\n+            // assigned_on_exit() is not meaningful.\n+            let is_assigned = if ln == self.s.exit_ln {\n+                false\n+            } else {\n+                self.assigned_on_exit(ln, var).is_some()\n+            };\n \n-                if is_assigned {\n-                    self.ir.tcx.lint_hir_note(\n-                        lint::builtin::UNUSED_VARIABLES,\n-                        hir_id,\n-                        spans,\n-                        &format!(\"variable `{}` is assigned to, but never used\", name),\n-                        &format!(\"consider using `_{}` instead\", name),\n-                    );\n-                } else if name != \"self\" {\n-                    let mut err = self.ir.tcx.struct_span_lint_hir(\n-                        lint::builtin::UNUSED_VARIABLES,\n-                        hir_id,\n-                        spans.clone(),\n-                        &format!(\"unused variable: `{}`\", name),\n-                    );\n+            if is_assigned {\n+                self.ir.tcx.lint_hir_note(\n+                    lint::builtin::UNUSED_VARIABLES,\n+                    hir_id,\n+                    spans,\n+                    &format!(\"variable `{}` is assigned to, but never used\", name),\n+                    &format!(\"consider using `_{}` instead\", name),\n+                );\n+            } else {\n+                let mut err = self.ir.tcx.struct_span_lint_hir(\n+                    lint::builtin::UNUSED_VARIABLES,\n+                    hir_id,\n+                    spans.clone(),\n+                    &format!(\"unused variable: `{}`\", name),\n+                );\n+\n+                if self.ir.variable_is_shorthand(var) {\n+                    if let Node::Binding(pat) = self.ir.tcx.hir().get(hir_id) {\n+                        // Handle `ref` and `ref mut`.\n+                        let spans = spans.iter()\n+                            .map(|_span| (pat.span, format!(\"{}: _\", name)))\n+                            .collect();\n \n-                    if self.ir.variable_is_shorthand(var) {\n-                        if let Node::Binding(pat) = self.ir.tcx.hir().get(hir_id) {\n-                            // Handle `ref` and `ref mut`.\n-                            let spans = spans.iter()\n-                                .map(|_span| (pat.span, format!(\"{}: _\", name)))\n-                                .collect();\n-\n-                            err.multipart_suggestion(\n-                                \"try ignoring the field\",\n-                                spans,\n-                                Applicability::MachineApplicable,\n-                            );\n-                        }\n-                    } else {\n                         err.multipart_suggestion(\n-                            \"consider prefixing with an underscore\",\n-                            spans.iter().map(|span| (*span, format!(\"_{}\", name))).collect(),\n+                            \"try ignoring the field\",\n+                            spans,\n                             Applicability::MachineApplicable,\n                         );\n                     }\n-\n-                    err.emit()\n+                } else {\n+                    err.multipart_suggestion(\n+                        \"consider prefixing with an underscore\",\n+                        spans.iter().map(|span| (*span, format!(\"_{}\", name))).collect(),\n+                        Applicability::MachineApplicable,\n+                    );\n                 }\n+\n+                err.emit()\n             }\n-            true\n-        } else {\n-            false\n         }\n     }\n \n-    fn warn_about_dead_assign(&self, sp: Span, hir_id: HirId, ln: LiveNode, var: Variable) {\n+    fn warn_about_dead_assign(&self, spans: Vec<Span>, hir_id: HirId, ln: LiveNode, var: Variable) {\n         if self.live_on_exit(ln, var).is_none() {\n-            self.report_dead_assign(hir_id, sp, var, false);\n+            self.report_dead_assign(hir_id, spans, var, false);\n         }\n     }\n \n-    fn report_dead_assign(&self, hir_id: HirId, sp: Span, var: Variable, is_argument: bool) {\n+    fn report_dead_assign(&self, hir_id: HirId, spans: Vec<Span>, var: Variable, is_param: bool) {\n         if let Some(name) = self.should_warn(var) {\n-            if is_argument {\n-                self.ir.tcx.struct_span_lint_hir(lint::builtin::UNUSED_ASSIGNMENTS, hir_id, sp,\n+            if is_param {\n+                self.ir.tcx.struct_span_lint_hir(lint::builtin::UNUSED_ASSIGNMENTS, hir_id, spans,\n                 &format!(\"value passed to `{}` is never read\", name))\n                 .help(\"maybe it is overwritten before being read?\")\n                 .emit();\n             } else {\n-                self.ir.tcx.struct_span_lint_hir(lint::builtin::UNUSED_ASSIGNMENTS, hir_id, sp,\n+                self.ir.tcx.struct_span_lint_hir(lint::builtin::UNUSED_ASSIGNMENTS, hir_id, spans,\n                 &format!(\"value assigned to `{}` is never read\", name))\n                 .help(\"maybe it is overwritten before being read?\")\n                 .emit();"}, {"sha": "e2c5de648a2766f93b63e2716aae7244b5848481", "filename": "src/librustc_ast_borrowck/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc_ast_borrowck%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc_ast_borrowck%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fcfg%2Fconstruct.rs?ref=da7812785a7c1eb2654e8d09a0ba31fab0858712", "patch": "@@ -390,7 +390,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             // patterns and the guard (if there is one) in the arm.\n             let bindings_exit = self.add_dummy_node(&[]);\n \n-            for pat in &arm.pats {\n+            for pat in arm.top_pats_hack() {\n                 // Visit the pattern, coming from the discriminant exit\n                 let mut pat_exit = self.pat(&pat, discr_exit);\n "}, {"sha": "5f1bd3e9115ca5c05cb201e8c8b807dad377fb56", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=da7812785a7c1eb2654e8d09a0ba31fab0858712", "patch": "@@ -142,7 +142,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // Step 2. Create the otherwise and prebinding blocks.\n \n         // create binding start block for link them by false edges\n-        let candidate_count = arms.iter().map(|c| c.patterns.len()).sum::<usize>();\n+        let candidate_count = arms.iter().map(|c| c.top_pats_hack().len()).sum::<usize>();\n         let pre_binding_blocks: Vec<_> = (0..candidate_count)\n             .map(|_| self.cfg.start_new_block())\n             .collect();\n@@ -159,7 +159,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             .map(|arm| {\n                 let arm_has_guard = arm.guard.is_some();\n                 match_has_guard |= arm_has_guard;\n-                let arm_candidates: Vec<_> = arm.patterns\n+                let arm_candidates: Vec<_> = arm.top_pats_hack()\n                     .iter()\n                     .zip(candidate_pre_binding_blocks.by_ref())\n                     .map(\n@@ -238,7 +238,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let scope = this.declare_bindings(\n                     None,\n                     arm.span,\n-                    &arm.patterns[0],\n+                    &arm.top_pats_hack()[0],\n                     ArmHasGuard(arm.guard.is_some()),\n                     Some((Some(&scrutinee_place), scrutinee_span)),\n                 );"}, {"sha": "bdfcacd0f462921b033f8817fbab7da2933767a4", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=da7812785a7c1eb2654e8d09a0ba31fab0858712", "patch": "@@ -860,9 +860,9 @@ impl ToBorrowKind for hir::Mutability {\n     }\n }\n \n-fn convert_arm<'a, 'tcx>(cx: &mut Cx<'a, 'tcx>, arm: &'tcx hir::Arm) -> Arm<'tcx> {\n+fn convert_arm<'tcx>(cx: &mut Cx<'_, 'tcx>, arm: &'tcx hir::Arm) -> Arm<'tcx> {\n     Arm {\n-        patterns: arm.pats.iter().map(|p| cx.pattern_from_hir(p)).collect(),\n+        pattern: cx.pattern_from_hir(&arm.pat),\n         guard: match arm.guard {\n                 Some(hir::Guard::If(ref e)) => Some(Guard::If(e.to_ref())),\n                 _ => None,"}, {"sha": "63a9a83154b4f6c5fb029f096ab24b790f9312f6", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=da7812785a7c1eb2654e8d09a0ba31fab0858712", "patch": "@@ -293,14 +293,25 @@ pub struct FruInfo<'tcx> {\n \n #[derive(Clone, Debug)]\n pub struct Arm<'tcx> {\n-    pub patterns: Vec<Pattern<'tcx>>,\n+    pub pattern: Pattern<'tcx>,\n     pub guard: Option<Guard<'tcx>>,\n     pub body: ExprRef<'tcx>,\n     pub lint_level: LintLevel,\n     pub scope: region::Scope,\n     pub span: Span,\n }\n \n+impl Arm<'tcx> {\n+    // HACK(or_patterns; Centril | dlrobertson): Remove this and\n+    // correctly handle each case in which this method is used.\n+    pub fn top_pats_hack(&self) -> &[Pattern<'tcx>] {\n+        match &*self.pattern.kind {\n+            PatternKind::Or { pats } => pats,\n+            _ => std::slice::from_ref(&self.pattern),\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug)]\n pub enum Guard<'tcx> {\n     If(ExprRef<'tcx>),"}, {"sha": "6301d9c390b028c9c910b08a67d0b6b820c4f222", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 43, "deletions": 66, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=da7812785a7c1eb2654e8d09a0ba31fab0858712", "patch": "@@ -14,7 +14,6 @@ use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc::hir::def::*;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use rustc::hir::ptr::P;\n use rustc::hir::{self, Pat, PatKind};\n \n use smallvec::smallvec;\n@@ -76,15 +75,15 @@ impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, 'tcx> {\n         });\n \n         // Check legality of move bindings and `@` patterns.\n-        self.check_patterns(false, slice::from_ref(&loc.pat));\n+        self.check_patterns(false, &loc.pat);\n     }\n \n     fn visit_body(&mut self, body: &'tcx hir::Body) {\n         intravisit::walk_body(self, body);\n \n         for param in &body.params {\n             self.check_irrefutable(&param.pat, \"function argument\");\n-            self.check_patterns(false, slice::from_ref(&param.pat));\n+            self.check_patterns(false, &param.pat);\n         }\n     }\n }\n@@ -122,11 +121,9 @@ impl PatternContext<'_, '_> {\n }\n \n impl<'tcx> MatchVisitor<'_, 'tcx> {\n-    fn check_patterns(&mut self, has_guard: bool, pats: &[P<Pat>]) {\n-        check_legality_of_move_bindings(self, has_guard, pats);\n-        for pat in pats {\n-            check_legality_of_bindings_in_at_patterns(self, pat);\n-        }\n+    fn check_patterns(&mut self, has_guard: bool, pat: &Pat) {\n+        check_legality_of_move_bindings(self, has_guard, pat);\n+        check_legality_of_bindings_in_at_patterns(self, pat);\n     }\n \n     fn check_match(\n@@ -137,7 +134,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n     ) {\n         for arm in arms {\n             // First, check legality of move bindings.\n-            self.check_patterns(arm.guard.is_some(), &arm.pats);\n+            self.check_patterns(arm.guard.is_some(), &arm.pat);\n \n             // Second, if there is a guard on each arm, make sure it isn't\n             // assigning or borrowing anything mutably.\n@@ -146,17 +143,15 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n             }\n \n             // Third, perform some lints.\n-            for pat in &arm.pats {\n-                check_for_bindings_named_same_as_variants(self, pat);\n-            }\n+            check_for_bindings_named_same_as_variants(self, &arm.pat);\n         }\n \n         let module = self.tcx.hir().get_module_parent(scrut.hir_id);\n         MatchCheckCtxt::create_and_enter(self.tcx, self.param_env, module, |ref mut cx| {\n             let mut have_errors = false;\n \n             let inlined_arms : Vec<(Vec<_>, _)> = arms.iter().map(|arm| (\n-                arm.pats.iter().map(|pat| {\n+                arm.top_pats_hack().iter().map(|pat| {\n                     let mut patcx = PatternContext::new(self.tcx,\n                                                         self.param_env.and(self.identity_substs),\n                                                         self.tables);\n@@ -545,78 +540,60 @@ fn maybe_point_at_variant(ty: Ty<'_>, patterns: &[Pattern<'_>]) -> Vec<Span> {\n     covered\n }\n \n-// Legality of move bindings checking\n-fn check_legality_of_move_bindings(\n-    cx: &mut MatchVisitor<'_, '_>,\n-    has_guard: bool,\n-    pats: &[P<Pat>],\n-) {\n+// Check the legality of legality of by-move bindings.\n+fn check_legality_of_move_bindings(cx: &mut MatchVisitor<'_, '_>, has_guard: bool, pat: &Pat) {\n     let mut by_ref_span = None;\n-    for pat in pats {\n-        pat.each_binding(|_, hir_id, span, _path| {\n-            if let Some(&bm) = cx.tables.pat_binding_modes().get(hir_id) {\n-                if let ty::BindByReference(..) = bm {\n-                    by_ref_span = Some(span);\n-                }\n-            } else {\n-                cx.tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n+    pat.each_binding(|_, hir_id, span, _| {\n+        if let Some(&bm) = cx.tables.pat_binding_modes().get(hir_id) {\n+            if let ty::BindByReference(..) = bm {\n+                by_ref_span = Some(span);\n             }\n-        })\n-    }\n+        } else {\n+            cx.tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n+        }\n+    });\n+\n     let span_vec = &mut Vec::new();\n-    let check_move = |\n-        cx: &mut MatchVisitor<'_, '_>,\n-        p: &Pat,\n-        sub: Option<&Pat>,\n-        span_vec: &mut Vec<Span>,\n-    | {\n-        // check legality of moving out of the enum\n-\n-        // x @ Foo(..) is legal, but x @ Foo(y) isn't.\n+    let mut check_move = |p: &Pat, sub: Option<&Pat>| {\n+        // Check legality of moving out of the enum.\n+        //\n+        // `x @ Foo(..)` is legal, but `x @ Foo(y)` isn't.\n         if sub.map_or(false, |p| p.contains_bindings()) {\n-            struct_span_err!(cx.tcx.sess, p.span, E0007,\n-                             \"cannot bind by-move with sub-bindings\")\n+            struct_span_err!(cx.tcx.sess, p.span, E0007, \"cannot bind by-move with sub-bindings\")\n                 .span_label(p.span, \"binds an already bound by-move value by moving it\")\n                 .emit();\n-        } else if !has_guard {\n-            if let Some(_by_ref_span) = by_ref_span {\n-                span_vec.push(p.span);\n-            }\n+        } else if !has_guard && by_ref_span.is_some() {\n+            span_vec.push(p.span);\n         }\n     };\n \n-    for pat in pats {\n-        pat.walk(|p| {\n-            if let PatKind::Binding(_, _, _, ref sub) = p.node {\n-                if let Some(&bm) = cx.tables.pat_binding_modes().get(p.hir_id) {\n-                    match bm {\n-                        ty::BindByValue(..) => {\n-                            let pat_ty = cx.tables.node_type(p.hir_id);\n-                            if !pat_ty.is_copy_modulo_regions(cx.tcx, cx.param_env, pat.span) {\n-                                check_move(cx, p, sub.as_ref().map(|p| &**p), span_vec);\n-                            }\n-                        }\n-                        _ => {}\n+    pat.walk(|p| {\n+        if let PatKind::Binding(.., sub) = &p.node {\n+            if let Some(&bm) = cx.tables.pat_binding_modes().get(p.hir_id) {\n+                if let ty::BindByValue(..) = bm {\n+                    let pat_ty = cx.tables.node_type(p.hir_id);\n+                    if !pat_ty.is_copy_modulo_regions(cx.tcx, cx.param_env, pat.span) {\n+                        check_move(p, sub.as_deref());\n                     }\n-                } else {\n-                    cx.tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n                 }\n+            } else {\n+                cx.tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n             }\n-            true\n-        });\n-    }\n-    if !span_vec.is_empty(){\n-        let span = MultiSpan::from_spans(span_vec.clone());\n+        }\n+        true\n+    });\n+\n+    if !span_vec.is_empty() {\n         let mut err = struct_span_err!(\n             cx.tcx.sess,\n-            span,\n+            MultiSpan::from_spans(span_vec.clone()),\n             E0009,\n             \"cannot bind by-move and by-ref in the same pattern\",\n         );\n         if let Some(by_ref_span) = by_ref_span {\n             err.span_label(by_ref_span, \"both by-ref and by-move used\");\n         }\n-        for span in span_vec.iter(){\n+        for span in span_vec.iter() {\n             err.span_label(*span, \"by-move pattern here\");\n         }\n         err.emit();\n@@ -627,7 +604,7 @@ fn check_legality_of_move_bindings(\n /// because of the way rvalues are handled in the borrow check. (See issue\n /// #14587.)\n fn check_legality_of_bindings_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pat) {\n-    AtBindingPatternVisitor { cx: cx, bindings_allowed: true }.visit_pat(pat);\n+    AtBindingPatternVisitor { cx, bindings_allowed: true }.visit_pat(pat);\n }\n \n struct AtBindingPatternVisitor<'a, 'b, 'tcx> {"}, {"sha": "938dab57181d676903c4f45ccca9d22545546dff", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=da7812785a7c1eb2654e8d09a0ba31fab0858712", "patch": "@@ -6,6 +6,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n \n #![feature(nll)]\n #![feature(in_band_lifetimes)]\n+#![feature(inner_deref)]\n #![feature(slice_patterns)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]"}, {"sha": "12978cd117b52a49e8209b19229adf33dc7bcddb", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=da7812785a7c1eb2654e8d09a0ba31fab0858712", "patch": "@@ -499,19 +499,15 @@ fn check_expr_kind<'a, 'tcx>(\n         }\n \n         // Conditional control flow (possible to implement).\n-        hir::ExprKind::Match(ref expr, ref hirvec_arm, ref _match_source) => {\n+        hir::ExprKind::Match(ref expr, ref arms, ref _match_source) => {\n             // Compute the most demanding borrow from all the arms'\n             // patterns and set that on the discriminator.\n-            let mut mut_borrow = false;\n-            for pat in hirvec_arm.iter().flat_map(|arm| &arm.pats) {\n-                mut_borrow = v.remove_mut_rvalue_borrow(pat);\n-            }\n-            if mut_borrow {\n+            if arms.iter().fold(false, |_, arm| v.remove_mut_rvalue_borrow(&arm.pat)) {\n                 v.mut_rvalue_borrows.insert(expr.hir_id);\n             }\n \n             let _ = v.check_expr(expr);\n-            for index in hirvec_arm.iter() {\n+            for index in arms.iter() {\n                 let _ = v.check_expr(&*index.body);\n                 if let Some(hir::Guard::If(ref expr)) = index.guard {\n                     let _ = v.check_expr(&expr);"}, {"sha": "14a07c8c9c7e289aaa272c19738f11cc9d925e7f", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=da7812785a7c1eb2654e8d09a0ba31fab0858712", "patch": "@@ -58,11 +58,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // collection into `Vec`), so we get types for all bindings.\n         let all_arm_pats_diverge: Vec<_> = arms.iter().map(|arm| {\n             let mut all_pats_diverge = Diverges::WarnedAlways;\n-            for p in &arm.pats {\n-                self.diverges.set(Diverges::Maybe);\n-                self.check_pat_top(&p, discrim_ty, Some(discrim.span));\n-                all_pats_diverge &= self.diverges.get();\n-            }\n+            self.diverges.set(Diverges::Maybe);\n+            self.check_pat_top(&arm.pat, discrim_ty, Some(discrim.span));\n+            all_pats_diverge &= self.diverges.get();\n \n             // As discussed with @eddyb, this is for disabling unreachable_code\n             // warnings on patterns (they're now subsumed by unreachable_patterns\n@@ -428,11 +426,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         //\n         // See #44848.\n         let contains_ref_bindings = arms.iter()\n-                                        .filter_map(|a| a.contains_explicit_ref_binding())\n-                                        .max_by_key(|m| match *m {\n-                                            hir::MutMutable => 1,\n-                                            hir::MutImmutable => 0,\n-                                        });\n+            .filter_map(|a| a.pat.contains_explicit_ref_binding())\n+            .max_by_key(|m| match *m {\n+                hir::MutMutable => 1,\n+                hir::MutImmutable => 0,\n+            });\n \n         if let Some(m) = contains_ref_bindings {\n             self.check_expr_with_needs(discrim, Needs::maybe_mut_place(m))"}, {"sha": "a2f7a8fe4febcbbae6f65981441f72794907c2de", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=da7812785a7c1eb2654e8d09a0ba31fab0858712", "patch": "@@ -97,11 +97,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.check_pat_struct(pat, qpath, fields, *etc, expected, def_bm, discrim_span)\n             }\n             PatKind::Or(pats) => {\n-                let expected_ty = self.structurally_resolved_type(pat.span, expected);\n                 for pat in pats {\n                     self.check_pat(pat, expected, def_bm, discrim_span);\n                 }\n-                expected_ty\n+                expected\n             }\n             PatKind::Tuple(elements, ddpos) => {\n                 self.check_pat_tuple(pat.span, elements, *ddpos, expected, def_bm, discrim_span)\n@@ -208,7 +207,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match pat.node {\n             PatKind::Struct(..) |\n             PatKind::TupleStruct(..) |\n-            PatKind::Or(_) |\n             PatKind::Tuple(..) |\n             PatKind::Box(_) |\n             PatKind::Range(..) |\n@@ -226,6 +224,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     _ => true,\n                 }\n             }\n+            // FIXME(or_patterns; Centril | dlrobertson): To keep things compiling\n+            // for or-patterns at the top level, we need to make `p_0 | ... | p_n`\n+            // a \"non reference pattern\". For example the following currently compiles:\n+            // ```\n+            // match &1 {\n+            //     e @ &(1...2) | e @ &(3...4) => {}\n+            //     _ => {}\n+            // }\n+            // ```\n+            //\n+            // We should consider whether we should do something special in nested or-patterns.\n+            PatKind::Or(_) |\n             PatKind::Wild |\n             PatKind::Binding(..) |\n             PatKind::Ref(..) => false,\n@@ -426,12 +436,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // If the binding is like `ref x | ref const x | ref mut x`\n                 // then `x` is assigned a value of type `&M T` where M is the\n                 // mutability and T is the expected type.\n-                let region_ty = self.new_ref_ty(pat.span, mutbl, expected);\n-\n+                //\n                 // `x` is assigned a value of type `&M T`, hence `&M T <: typeof(x)`\n                 // is required. However, we use equality, which is stronger.\n                 // See (note_1) for an explanation.\n-                region_ty\n+                self.new_ref_ty(pat.span, mutbl, expected)\n             }\n             // Otherwise, the type of x is the expected type `T`.\n             ty::BindByValue(_) => {"}, {"sha": "6fa8a016b54588231b8283a9b1e1c38d6bbdeb9d", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=da7812785a7c1eb2654e8d09a0ba31fab0858712", "patch": "@@ -488,9 +488,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n \n     fn visit_arm(&mut self, arm: &'tcx hir::Arm) {\n         // see above\n-        for p in &arm.pats {\n-            self.constrain_bindings_in_pat(p);\n-        }\n+        self.constrain_bindings_in_pat(&arm.pat);\n         intravisit::walk_arm(self, arm);\n     }\n \n@@ -1069,9 +1067,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         let discr_cmt = Rc::new(ignore_err!(self.with_mc(|mc| mc.cat_expr(discr))));\n         debug!(\"discr_cmt={:?}\", discr_cmt);\n         for arm in arms {\n-            for root_pat in &arm.pats {\n-                self.link_pattern(discr_cmt.clone(), &root_pat);\n-            }\n+            self.link_pattern(discr_cmt.clone(), &arm.pat);\n         }\n     }\n "}, {"sha": "4fc29d70540fd25e904b0ceb44710458e9d9d271", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=da7812785a7c1eb2654e8d09a0ba31fab0858712", "patch": "@@ -834,8 +834,6 @@ pub fn walk_param<'a, V: Visitor<'a>>(visitor: &mut V, param: &'a Param) {\n \n pub fn walk_arm<'a, V: Visitor<'a>>(visitor: &mut V, arm: &'a Arm) {\n     visitor.visit_pat(&arm.pat);\n-    // NOTE(or_patterns; Centril | dlrobertson):\n-    // If you change this, also change the hack in `lowering.rs`.\n     walk_list!(visitor, visit_expr, &arm.guard);\n     visitor.visit_expr(&arm.body);\n     walk_list!(visitor, visit_attribute, &arm.attrs);"}, {"sha": "7870d394c8bfbd52696de62ce9939a1c19decb22", "filename": "src/test/ui/lint/issue-47390-unused-variable-in-struct-pattern.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Ftest%2Fui%2Flint%2Fissue-47390-unused-variable-in-struct-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Ftest%2Fui%2Flint%2Fissue-47390-unused-variable-in-struct-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-47390-unused-variable-in-struct-pattern.rs?ref=da7812785a7c1eb2654e8d09a0ba31fab0858712", "patch": "@@ -33,6 +33,9 @@ fn main() {\n     let mut mut_unused_var = 1;\n \n     let (mut var, unused_var) = (1, 2);\n+    // NOTE: `var` comes after `unused_var` lexicographically yet the warning\n+    // for `var` will be emitted before the one for `unused_var`. We use an\n+    // `IndexMap` to ensure this is the case instead of a `BTreeMap`.\n \n     if let SoulHistory { corridors_of_light,\n                          mut hours_are_suns,"}, {"sha": "74bbef8adad0539bd604f76dc883e3bf85b2a8c3", "filename": "src/test/ui/lint/issue-47390-unused-variable-in-struct-pattern.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Ftest%2Fui%2Flint%2Fissue-47390-unused-variable-in-struct-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da7812785a7c1eb2654e8d09a0ba31fab0858712/src%2Ftest%2Fui%2Flint%2Fissue-47390-unused-variable-in-struct-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-47390-unused-variable-in-struct-pattern.stderr?ref=da7812785a7c1eb2654e8d09a0ba31fab0858712", "patch": "@@ -30,21 +30,21 @@ LL |     let (mut var, unused_var) = (1, 2);\n    |                   ^^^^^^^^^^ help: consider prefixing with an underscore: `_unused_var`\n \n warning: unused variable: `corridors_of_light`\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:37:26\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:40:26\n    |\n LL |     if let SoulHistory { corridors_of_light,\n    |                          ^^^^^^^^^^^^^^^^^^ help: try ignoring the field: `corridors_of_light: _`\n \n warning: variable `hours_are_suns` is assigned to, but never used\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:38:30\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:41:30\n    |\n LL |                          mut hours_are_suns,\n    |                              ^^^^^^^^^^^^^^\n    |\n    = note: consider using `_hours_are_suns` instead\n \n warning: value assigned to `hours_are_suns` is never read\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:40:9\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:43:9\n    |\n LL |         hours_are_suns = false;\n    |         ^^^^^^^^^^^^^^\n@@ -58,43 +58,43 @@ LL | #![warn(unused)] // UI tests pass `-A unused` (#43896)\n    = help: maybe it is overwritten before being read?\n \n warning: unused variable: `fire`\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:44:32\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:47:32\n    |\n LL |     let LovelyAmbition { lips, fire } = the_spirit;\n    |                                ^^^^ help: try ignoring the field: `fire: _`\n \n warning: unused variable: `case`\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:53:23\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:56:23\n    |\n LL |         Large::Suit { case } => {}\n    |                       ^^^^ help: try ignoring the field: `case: _`\n \n warning: unused variable: `case`\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:58:24\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:61:24\n    |\n LL |         &Large::Suit { case } => {}\n    |                        ^^^^ help: try ignoring the field: `case: _`\n \n warning: unused variable: `case`\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:63:27\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:66:27\n    |\n LL |         box Large::Suit { case } => {}\n    |                           ^^^^ help: try ignoring the field: `case: _`\n \n warning: unused variable: `case`\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:68:24\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:71:24\n    |\n LL |         (Large::Suit { case },) => {}\n    |                        ^^^^ help: try ignoring the field: `case: _`\n \n warning: unused variable: `case`\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:73:24\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:76:24\n    |\n LL |         [Large::Suit { case }] => {}\n    |                        ^^^^ help: try ignoring the field: `case: _`\n \n warning: unused variable: `case`\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:78:29\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:81:29\n    |\n LL |         Tuple(Large::Suit { case }, ()) => {}\n    |                             ^^^^ help: try ignoring the field: `case: _`"}]}