{"sha": "386fa1d818f341004e511af24da9f257d35cdbd2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4NmZhMWQ4MThmMzQxMDA0ZTUxMWFmMjRkYTlmMjU3ZDM1Y2RiZDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-17T08:36:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-17T08:36:33Z"}, "message": "auto merge of #9897 : thestinger/rust/rusti, r=alexcrichton\n\nCloses #9818\r\nCloses #9567\r\nCloses #8924\r\nCloses #8910\r\nCloses #8392\r\nCloses #7692\r\nCloses #7499\r\nCloses #7220\r\nCloses #5038", "tree": {"sha": "dac671bfbf44c2bc48308b91a9140191cbf0cf0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dac671bfbf44c2bc48308b91a9140191cbf0cf0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/386fa1d818f341004e511af24da9f257d35cdbd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/386fa1d818f341004e511af24da9f257d35cdbd2", "html_url": "https://github.com/rust-lang/rust/commit/386fa1d818f341004e511af24da9f257d35cdbd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/386fa1d818f341004e511af24da9f257d35cdbd2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00adcf0bdd9376046859b7bc0d79097b621844c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/00adcf0bdd9376046859b7bc0d79097b621844c5", "html_url": "https://github.com/rust-lang/rust/commit/00adcf0bdd9376046859b7bc0d79097b621844c5"}, {"sha": "f766acad62cd5cf7ed701a9521db2f2a96039778", "url": "https://api.github.com/repos/rust-lang/rust/commits/f766acad62cd5cf7ed701a9521db2f2a96039778", "html_url": "https://github.com/rust-lang/rust/commit/f766acad62cd5cf7ed701a9521db2f2a96039778"}], "stats": {"total": 3659, "additions": 18, "deletions": 3641}, "files": [{"sha": "3e368ce70e92883acc94aaac012fdbe35b858ed2", "filename": ".gitattributes", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/386fa1d818f341004e511af24da9f257d35cdbd2/.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/386fa1d818f341004e511af24da9f257d35cdbd2/.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitattributes?ref=386fa1d818f341004e511af24da9f257d35cdbd2", "patch": "@@ -7,5 +7,4 @@\n src/etc/pkg/rust-logo.ico binary\n src/rt/msvc/* -whitespace\n src/rt/vg/* -whitespace\n-src/rt/linenoise/* -whitespace\n src/rt/jemalloc/**/* -whitespace"}, {"sha": "7e77f6fd6787b8d1e999c1b567fbac992ddb63d7", "filename": "Makefile.in", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/386fa1d818f341004e511af24da9f257d35cdbd2/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/386fa1d818f341004e511af24da9f257d35cdbd2/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=386fa1d818f341004e511af24da9f257d35cdbd2", "patch": "@@ -221,22 +221,19 @@ CFG_LIBRUSTC_$(1) :=$(call CFG_LIB_NAME_$(1),rustc)\n CFG_LIBSYNTAX_$(1) :=$(call CFG_LIB_NAME_$(1),syntax)\n CFG_LIBRUSTPKG_$(1) :=$(call CFG_LIB_NAME_$(1),rustpkg)\n CFG_LIBRUSTDOC_$(1) :=$(call CFG_LIB_NAME_$(1),rustdoc)\n-CFG_LIBRUSTI_$(1) :=$(call CFG_LIB_NAME_$(1),rusti)\n \n EXTRALIB_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),extra)\n STDLIB_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),std)\n LIBRUSTC_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rustc)\n LIBSYNTAX_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),syntax)\n LIBRUSTPKG_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rustpkg)\n LIBRUSTDOC_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rustdoc)\n-LIBRUSTI_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rusti)\n EXTRALIB_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),extra)\n STDLIB_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),std)\n LIBRUSTC_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rustc)\n LIBSYNTAX_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),syntax)\n LIBRUSTPKG_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rustpkg)\n LIBRUSTDOC_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rustdoc)\n-LIBRUSTI_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rusti)\n \n endef\n \n@@ -446,14 +443,12 @@ CSREQ$(1)_T_$(2)_H_$(3) = \\\n \t$$(HBIN$(1)_H_$(3))/rusti$$(X_$(3)) \\\n \t$$(HLIB$(1)_H_$(3))/$(CFG_LIBRUSTPKG_$(3)) \\\n \t$$(HLIB$(1)_H_$(3))/$(CFG_LIBRUSTDOC_$(3)) \\\n-\t$$(HLIB$(1)_H_$(3))/$(CFG_LIBRUSTI_$(3)) \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_STDLIB_$(2)) \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_EXTRALIB_$(2))  \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBSYNTAX_$(2))  \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTC_$(2)) \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTPKG_$(2)) \\\n-\t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTDOC_$(2)) \\\n-\t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTI_$(2)) \\\n+\t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTDOC_$(2))\n \n ifeq ($(1),0)\n # Don't run the the stage0 compiler under valgrind - that ship has sailed"}, {"sha": "e2dfa32032713ec573720ab4658fe4096dcd172b", "filename": "RELEASES.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/386fa1d818f341004e511af24da9f257d35cdbd2/RELEASES.txt", "raw_url": "https://github.com/rust-lang/rust/raw/386fa1d818f341004e511af24da9f257d35cdbd2/RELEASES.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.txt?ref=386fa1d818f341004e511af24da9f257d35cdbd2", "patch": "@@ -1,3 +1,11 @@\n+Version 0.9 (XXX 2013)\n+--------------------------\n+\n+   * ~XXX changes, numerous bugfixes\n+\n+   * Tooling\n+      * The `rust` and `rusti` commands have been removed, due to lack of maintenance.\n+\n Version 0.8 (September 2013)\n --------------------------\n "}, {"sha": "eb934c1807ff0c3cf1301d8b1e75a0ee27b09fdd", "filename": "configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/386fa1d818f341004e511af24da9f257d35cdbd2/configure", "raw_url": "https://github.com/rust-lang/rust/raw/386fa1d818f341004e511af24da9f257d35cdbd2/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=386fa1d818f341004e511af24da9f257d35cdbd2", "patch": "@@ -686,7 +686,7 @@ do\n     make_dir $t/rt/libuv/src/ev\n     make_dir $t/rt/jemalloc\n     for i in                                          \\\n-      isaac linenoise sync test \\\n+      isaac sync test \\\n       arch/i386 arch/x86_64 arch/arm arch/mips  \\\n       sundown/src sundown/html\n     do"}, {"sha": "241e0367fefa421a45cd9624693c4002d91254b2", "filename": "doc/tutorial.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/386fa1d818f341004e511af24da9f257d35cdbd2/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/386fa1d818f341004e511af24da9f257d35cdbd2/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=386fa1d818f341004e511af24da9f257d35cdbd2", "patch": "@@ -113,9 +113,7 @@ for more information on them.\n \n When complete, `make install` will place several programs into\n `/usr/local/bin`: `rustc`, the Rust compiler; `rustdoc`, the\n-API-documentation tool; `rustpkg`, the Rust package manager;\n-`rusti`, the Rust REPL; and `rust`, a tool which acts both as a unified\n-interface for them, and for a few common command line scenarios.\n+API-documentation tool; and `rustpkg`, the Rust package manager.\n \n [tarball]: http://static.rust-lang.org/dist/rust-0.8.tar.gz\n [win-exe]: http://static.rust-lang.org/dist/rust-0.8-install.exe"}, {"sha": "e4cfab7747f504cc61c72dc6666c52a77a21a4ce", "filename": "man/rustc.1", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/386fa1d818f341004e511af24da9f257d35cdbd2/man%2Frustc.1", "raw_url": "https://github.com/rust-lang/rust/raw/386fa1d818f341004e511af24da9f257d35cdbd2/man%2Frustc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/man%2Frustc.1?ref=386fa1d818f341004e511af24da9f257d35cdbd2", "patch": "@@ -130,7 +130,7 @@ To build an executable with debug info (experimental):\n \n .SH \"SEE ALSO\"\n \n-rust, rustdoc, rustpkg, rusti\n+rustdoc, rustpkg\n \n .SH \"BUGS\"\n See <\\fBhttps://github.com/mozilla/rust/issues\\fR> for issues."}, {"sha": "78340984f9679cba4dc2b0addccb11c414dcae9a", "filename": "man/rustdoc.1", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/386fa1d818f341004e511af24da9f257d35cdbd2/man%2Frustdoc.1", "raw_url": "https://github.com/rust-lang/rust/raw/386fa1d818f341004e511af24da9f257d35cdbd2/man%2Frustdoc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/man%2Frustdoc.1?ref=386fa1d818f341004e511af24da9f257d35cdbd2", "patch": "@@ -84,7 +84,7 @@ The generated HTML can be viewed with any standard web browser.\n \n .SH \"SEE ALSO\"\n \n-rust, rustc, rustpkg, rusti\n+rustc, rustpkg\n \n .SH \"BUGS\"\n See <\\fBhttps://github.com/mozilla/rust/issues\\fR> for issues."}, {"sha": "9f7d1733c6514a070d129a4a7a2e23400da35736", "filename": "man/rusti.1", "status": "removed", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/00adcf0bdd9376046859b7bc0d79097b621844c5/man%2Frusti.1", "raw_url": "https://github.com/rust-lang/rust/raw/00adcf0bdd9376046859b7bc0d79097b621844c5/man%2Frusti.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/man%2Frusti.1?ref=00adcf0bdd9376046859b7bc0d79097b621844c5", "patch": "@@ -1,82 +0,0 @@\n-.TH RUSTI \"1\" \"July 2013\" \"rusti 0.7\" \"User Commands\"\n-\\\" Macros\n-..\n-.de Vb \\\" Begin verbatim text                                                   \n-.ft CW\n-.nf\n-.ne \\\\$1\n-..\n-.de Ve \\\" End verbatim text                                                     \n-.ft R\n-.fi\n-..\n-.SH NAME\n-rusti \\- Rust interactive shell\n-\n-.SH SYNOPSIS\n-.B rusti\n-\n-.SH DESCRIPTION\n-\n-This program is a REPL (Read-Eval-Print Loop) for the Rust language, available\n-at <\\fBhttps://www.rust-lang.org\\fR>. It provides an interactive shell to\n-evaluate Rust expressions, functions and code snippets, and to experiment with\n-Rust code.\n-\n-.B WARNING:\n-The Rust REPL is experimental and may be unstable. If you encounter problems,\n-please use the compiler instead.\n-\n-.SH OPTIONS\n-\n-Currently none.\n-\n-.SH SPECIAL COMMANDS\n-\n-The interactive shell evaluates all input as a sequence of Rust expressions,\n-except for a set of special commands prefixed by a colon ':'. These special\n-commands are described below:\n-\n-.TP\n-\\fB:help\\fR\n-Display a summary of available commands.\n-.TP\n-\\fB:{\\\\n ..lines.. \\\\n:}\\\\n\\fR\n-execute multiline command\n-.TP\n-\\fB:load <crate> ...\\fR\n-loads given crates as dynamic libraries\n-.TP\n-\\fB:clear\\fR\n-clear the bindings\n-.TP\n-\\fB:exit\\fR\n-exit from the repl\n-\n-.SH \"EXAMPLES\"\n-\n-A simple example session, declaring a variable, defining a function,\n-evaluating an expression and printing the result:\n-\n-.PP\n-.Vb\n-\\&\t\\fBrusti>\\fR let x = 42;\n-\\&\t\\fBrusti>\\fR fn square(n: int) -> int { n*n }\n-\\&\t\\fBrusti>\\fR println(fmt!(\"%d squared is %d\", x, square(x)));\n-\\&\t42 squared is 1764\n-.Ve\n-\n-.SH \"SEE ALSO\"\n-\n-rust, rustc, rustdoc, rustpkg\n-\n-.SH \"BUGS\"\n-See <\\fBhttps://github.com/mozilla/rust/issues\\fR> for issues.\n-\n-.SH \"AUTHOR\"\n-See \\fBAUTHORS.txt\\fR in the rust source distribution. Graydon Hoare\n-<\\fIgraydon@mozilla.com\\fR> is the project leader.\n-\n-.SH \"COPYRIGHT\"\n-This work is dual-licensed under Apache 2.0 and MIT terms.  See \\fBCOPYRIGHT\\fR\n-file in the rust source distribution."}, {"sha": "856f90228137c03b430061d7daf4fed3e42f946a", "filename": "man/rustpkg.1", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/386fa1d818f341004e511af24da9f257d35cdbd2/man%2Frustpkg.1", "raw_url": "https://github.com/rust-lang/rust/raw/386fa1d818f341004e511af24da9f257d35cdbd2/man%2Frustpkg.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/man%2Frustpkg.1?ref=386fa1d818f341004e511af24da9f257d35cdbd2", "patch": "@@ -181,7 +181,7 @@ custom build logic.\n \n .SH \"SEE ALSO\"\n \n-rust, rustc, rustdoc, rusti\n+rustc, rustdoc\n \n .SH \"BUGS\"\n See <\\fBhttps://github.com/mozilla/rust/issues\\fR> for issues."}, {"sha": "09a80c5507bca854451a508923b6ff5e9d70e3d3", "filename": "mk/clean.mk", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/386fa1d818f341004e511af24da9f257d35cdbd2/mk%2Fclean.mk", "raw_url": "https://github.com/rust-lang/rust/raw/386fa1d818f341004e511af24da9f257d35cdbd2/mk%2Fclean.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fclean.mk?ref=386fa1d818f341004e511af24da9f257d35cdbd2", "patch": "@@ -67,7 +67,6 @@ clean$(1)_H_$(2):\n \t$(Q)rm -f $$(HBIN$(1)_H_$(2))/rustpkg$(X_$(2))\n \t$(Q)rm -f $$(HBIN$(1)_H_$(2))/serializer$(X_$(2))\n \t$(Q)rm -f $$(HBIN$(1)_H_$(2))/rustdoc$(X_$(2))\n-\t$(Q)rm -f $$(HBIN$(1)_H_$(2))/rusti$(X_$(2))\n \t$(Q)rm -f $$(HBIN$(1)_H_$(2))/rust$(X_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_LIBRUSTPKG_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_LIBRUSTDOC_$(2))\n@@ -76,14 +75,12 @@ clean$(1)_H_$(2):\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_EXTRALIB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_LIBRUSTC_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_LIBSYNTAX_$(2))\n-\t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_LIBRUSTI_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(STDLIB_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(EXTRALIB_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBRUSTC_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBSYNTAX_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBRUSTPKG_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBRUSTDOC_GLOB_$(2))\n-\t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBRUSTI_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_RUSTLLVM_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/libstd.rlib\n \n@@ -100,7 +97,6 @@ clean$(1)_T_$(2)_H_$(3):\n \t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/rustpkg$(X_$(2))\n \t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/serializer$(X_$(2))\n \t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/rustdoc$(X_$(2))\n-\t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/rusti$(X_$(2))\n \t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/rust$(X_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTPKG_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTDOC_$(2))\n@@ -109,14 +105,12 @@ clean$(1)_T_$(2)_H_$(3):\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_EXTRALIB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTC_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBSYNTAX_$(2))\n-\t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTI_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(STDLIB_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(EXTRALIB_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTC_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBSYNTAX_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTPKG_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTDOC_GLOB_$(2))\n-\t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTI_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_RUSTLLVM_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/libstd.rlib\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/libmorestack.a"}, {"sha": "13b9509e66705f9400b6042458eec800920bdcf1", "filename": "mk/dist.mk", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/386fa1d818f341004e511af24da9f257d35cdbd2/mk%2Fdist.mk", "raw_url": "https://github.com/rust-lang/rust/raw/386fa1d818f341004e511af24da9f257d35cdbd2/mk%2Fdist.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdist.mk?ref=386fa1d818f341004e511af24da9f257d35cdbd2", "patch": "@@ -29,7 +29,6 @@ PKG_FILES := \\\n       README.txt                               \\\n       driver                                   \\\n       librustpkg                               \\\n-      librusti                                 \\\n       librustc                                 \\\n       compiletest                              \\\n       etc                                      \\"}, {"sha": "942600563864a797894f8e7475026650edbed97a", "filename": "mk/install.mk", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/386fa1d818f341004e511af24da9f257d35cdbd2/mk%2Finstall.mk", "raw_url": "https://github.com/rust-lang/rust/raw/386fa1d818f341004e511af24da9f257d35cdbd2/mk%2Finstall.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Finstall.mk?ref=386fa1d818f341004e511af24da9f257d35cdbd2", "patch": "@@ -104,7 +104,6 @@ install-target-$(1)-host-$(2): $$(CSREQ$$(ISTAGE)_T_$(1)_H_$(2))\n \t$$(Q)$$(call INSTALL_LIB,$$(LIBSYNTAX_GLOB_$(1)))\n \t$$(Q)$$(call INSTALL_LIB,$$(LIBRUSTPKG_GLOB_$(1)))\n \t$$(Q)$$(call INSTALL_LIB,$$(LIBRUSTDOC_GLOB_$(1)))\n-\t$$(Q)$$(call INSTALL_LIB,$$(LIBRUSTI_GLOB_$(1)))\n \t$$(Q)$$(call INSTALL_LIB,libmorestack.a)\n \n endef\n@@ -138,19 +137,16 @@ install-host: $(CSREQ$(ISTAGE)_T_$(CFG_BUILD_TRIPLE)_H_$(CFG_BUILD_TRIPLE))\n \t$(Q)$(call INSTALL,$(HB2),$(PHB),rustc$(X_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL,$(HB2),$(PHB),rustpkg$(X_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL,$(HB2),$(PHB),rustdoc$(X_$(CFG_BUILD_TRIPLE)))\n-\t$(Q)$(call INSTALL,$(HB2),$(PHB),rusti$(X_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL_LIB,$(STDLIB_GLOB_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL_LIB,$(EXTRALIB_GLOB_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL_LIB,$(LIBRUSTC_GLOB_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL_LIB,$(LIBSYNTAX_GLOB_$(CFG_BUILD_TRIPLE)))\n-\t$(Q)$(call INSTALL_LIB,$(LIBRUSTI_GLOB_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL_LIB,$(LIBRUSTPKG_GLOB_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL_LIB,$(LIBRUSTDOC_GLOB_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL,$(HL),$(PHL),$(CFG_RUNTIME_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL,$(HL),$(PHL),$(CFG_RUSTLLVM_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL,$(S)/man, $(PREFIX_ROOT)/share/man/man1,rustc.1)\n \t$(Q)$(call INSTALL,$(S)/man, $(PREFIX_ROOT)/share/man/man1,rustdoc.1)\n-\t$(Q)$(call INSTALL,$(S)/man, $(PREFIX_ROOT)/share/man/man1,rusti.1)\n \t$(Q)$(call INSTALL,$(S)/man, $(PREFIX_ROOT)/share/man/man1,rustpkg.1)\n \n install-targets: $(INSTALL_TARGET_RULES)\n@@ -162,7 +158,6 @@ HOST_LIB_FROM_HL_GLOB = \\\n uninstall:\n \t$(Q)rm -f $(PHB)/rustc$(X_$(CFG_BUILD_TRIPLE))\n \t$(Q)rm -f $(PHB)/rustpkg$(X_$(CFG_BUILD_TRIPLE))\n-\t$(Q)rm -f $(PHB)/rusti$(X_$(CFG_BUILD_TRIPLE))\n \t$(Q)rm -f $(PHB)/rustdoc$(X_$(CFG_BUILD_TRIPLE))\n \t$(Q)rm -f $(PHL)/$(CFG_RUSTLLVM_$(CFG_BUILD_TRIPLE))\n \t$(Q)rm -f $(PHL)/$(CFG_RUNTIME_$(CFG_BUILD_TRIPLE))\n@@ -173,14 +168,12 @@ uninstall:\n           $(call HOST_LIB_FROM_HL_GLOB,$(LIBSYNTAX_GLOB_$(CFG_BUILD_TRIPLE))) \\\n           $(call HOST_LIB_FROM_HL_GLOB,$(LIBRUSTPKG_GLOB_$(CFG_BUILD_TRIPLE))) \\\n           $(call HOST_LIB_FROM_HL_GLOB,$(LIBRUSTDOC_GLOB_$(CFG_BUILD_TRIPLE))) \\\n-          $(call HOST_LIB_FROM_HL_GLOB,$(LIBRUSTI_GLOB_$(CFG_BUILD_TRIPLE))) \\\n         ; \\\n         do rm -f $$i ; \\\n         done\n \t$(Q)rm -Rf $(PHL)/rustc\n \t$(Q)rm -f $(PREFIX_ROOT)/share/man/man1/rustc.1\n \t$(Q)rm -f $(PREFIX_ROOT)/share/man/man1/rustdoc.1\n-\t$(Q)rm -f $(PREFIX_ROOT)/share/man/man1/rusti.1\n \t$(Q)rm -f $(PREFIX_ROOT)/share/man/man1/rustpkg.1\n \n # target platform specific variables"}, {"sha": "8f9714e62d5b0ac77999be5c7fa0a5bf6757a747", "filename": "mk/platform.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/386fa1d818f341004e511af24da9f257d35cdbd2/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/386fa1d818f341004e511af24da9f257d35cdbd2/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=386fa1d818f341004e511af24da9f257d35cdbd2", "patch": "@@ -29,7 +29,7 @@ $(foreach t,$(CFG_TARGET_TRIPLES),$(info cfg: os for $(t) is $(OSTYPE_$(t))))\n # FIXME: no-omit-frame-pointer is just so that task_start_wrapper\n # has a frame pointer and the stack walker can understand it. Turning off\n # frame pointers everywhere is overkill\n-CFG_GCCISH_CFLAGS += -fno-omit-frame-pointer -DUSE_UTF8\n+CFG_GCCISH_CFLAGS += -fno-omit-frame-pointer\n \n # On Darwin, we need to run dsymutil so the debugging information ends\n # up in the right place.  On other platforms, it automatically gets"}, {"sha": "347c32f17206eb2cb50c7a76d577dc6760074558", "filename": "mk/rt.mk", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/386fa1d818f341004e511af24da9f257d35cdbd2/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/386fa1d818f341004e511af24da9f257d35cdbd2/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=386fa1d818f341004e511af24da9f257d35cdbd2", "patch": "@@ -96,9 +96,7 @@ RUNTIME_CXXS_$(1)_$(2) := \\\n               rt/rust_android_dummy.cpp \\\n               rt/rust_test_helpers.cpp\n \n-RUNTIME_CS_$(1)_$(2) := rt/linenoise/linenoise.c \\\n-\t\t\trt/linenoise/utf8.c \\\n-\t\t\trt/sundown/src/autolink.c \\\n+RUNTIME_CS_$(1)_$(2) := rt/sundown/src/autolink.c \\\n \t\t\trt/sundown/src/buffer.c \\\n \t\t\trt/sundown/src/stack.c \\\n \t\t\trt/sundown/src/markdown.c \\\n@@ -116,7 +114,6 @@ RT_BUILD_DIR_$(1)_$(2) := $$(RT_OUTPUT_DIR_$(1))/stage$(2)\n RUNTIME_DEF_$(1)_$(2) := $$(RT_OUTPUT_DIR_$(1))/rustrt$$(CFG_DEF_SUFFIX_$(1))\n RUNTIME_INCS_$(1)_$(2) := -I $$(S)src/rt -I $$(S)src/rt/isaac -I $$(S)src/rt/uthash \\\n                      -I $$(S)src/rt/arch/$$(HOST_$(1)) \\\n-                     -I $$(S)src/rt/linenoise \\\n                      -I $$(S)src/rt/sundown/src \\\n                      -I $$(S)src/rt/sundown/html \\\n                      -I $$(S)src/libuv/include"}, {"sha": "9991aacc949bf8a6f769aeee929573bfa921a4ba", "filename": "mk/tests.mk", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/386fa1d818f341004e511af24da9f257d35cdbd2/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/386fa1d818f341004e511af24da9f257d35cdbd2/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=386fa1d818f341004e511af24da9f257d35cdbd2", "patch": "@@ -15,7 +15,7 @@\n \n # The names of crates that must be tested\n TEST_TARGET_CRATES = std extra\n-TEST_HOST_CRATES = rusti rustpkg rustc rustdoc syntax\n+TEST_HOST_CRATES = rustpkg rustc rustdoc syntax\n TEST_CRATES = $(TEST_TARGET_CRATES) $(TEST_HOST_CRATES)\n \n # Markdown files under doc/ that should have their code extracted and run\n@@ -189,7 +189,7 @@ check-test: cleantestlibs cleantmptestlogs all check-stage2-rfail\n \n check-lite: cleantestlibs cleantmptestlogs \\\n \tcheck-stage2-std check-stage2-extra check-stage2-rpass \\\n-\tcheck-stage2-rustpkg check-stage2-rusti \\\n+\tcheck-stage2-rustpkg \\\n \tcheck-stage2-rfail check-stage2-cfail\n \t$(Q)$(CFG_PYTHON) $(S)src/etc/check-summary.py tmp/*.log\n \n@@ -227,7 +227,6 @@ ALL_CS := $(wildcard $(S)src/rt/*.cpp \\\n                      $(S)src/rt/*/*/*.cpp \\\n                      $(S)src/rustllvm/*.cpp)\n ALL_CS := $(filter-out $(S)src/rt/miniz.cpp \\\n-\t\t       $(wildcard $(S)src/rt/linenoise/*.c) \\\n \t\t       $(wildcard $(S)src/rt/sundown/src/*.c) \\\n \t\t       $(wildcard $(S)src/rt/sundown/html/*.c) \\\n \t,$(ALL_CS))\n@@ -240,8 +239,6 @@ ALL_HS := $(filter-out $(S)src/rt/vg/valgrind.h \\\n                        $(S)src/rt/msvc/typeof.h \\\n                        $(S)src/rt/msvc/stdint.h \\\n                        $(S)src/rt/msvc/inttypes.h \\\n-                       $(S)src/rt/linenoise/linenoise.h \\\n-                       $(S)src/rt/linenoise/utf8.h \\\n \t\t       $(wildcard $(S)src/rt/sundown/src/*.h) \\\n \t\t       $(wildcard $(S)src/rt/sundown/html/*.h) \\\n \t,$(ALL_HS))\n@@ -379,14 +376,6 @@ $(3)/stage$(1)/test/rustpkgtest-$(2)$$(X_$(2)):\t\t\t\t\t\\\n \t@$$(call E, compile_and_link: $$@)\n \t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< --test\n \n-$(3)/stage$(1)/test/rustitest-$(2)$$(X_$(2)):\t\t\t\t\t\\\n-\t\t$$(RUSTI_LIB) $$(RUSTI_INPUTS)\t\t\\\n-\t\t$$(SREQ$(1)_T_$(2)_H_$(3)) \\\n-\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBSYNTAX_$(2)) \\\n-\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBRUSTC_$(2))\n-\t@$$(call E, compile_and_link: $$@)\n-\t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< --test\n-\n $(3)/stage$(1)/test/rustdoctest-$(2)$$(X_$(2)):\t\t\t\t\t\\\n \t\t$$(RUSTDOC_LIB) $$(RUSTDOC_INPUTS)\t\t\\\n \t\t$$(SREQ$(1)_T_$(2)_H_$(3)) \\"}, {"sha": "a9ea12b5b24edcc2a306928ea4e662c81ad481c0", "filename": "mk/tools.mk", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/386fa1d818f341004e511af24da9f257d35cdbd2/mk%2Ftools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/386fa1d818f341004e511af24da9f257d35cdbd2/mk%2Ftools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftools.mk?ref=386fa1d818f341004e511af24da9f257d35cdbd2", "patch": "@@ -24,10 +24,6 @@ RUSTDOC_LIB := $(S)src/librustdoc/rustdoc.rs\n RUSTDOC_INPUTS := $(wildcard $(addprefix $(S)src/librustdoc/,        \\\n                                            *.rs */*.rs */*/*.rs))\n \n-# Rusti, the JIT REPL\n-RUSTI_LIB := $(S)src/librusti/rusti.rs\n-RUSTI_INPUTS := $(wildcard $(S)src/librusti/*.rs)\n-\n # FIXME: These are only built for the host arch. Eventually we'll\n # have tools that need to built for other targets.\n define TOOLS_STAGE_N_TARGET\n@@ -75,24 +71,6 @@ $$(TBIN$(1)_T_$(4)_H_$(3))/rustdoc$$(X_$(4)):\t\t\t\\\n \t@$$(call E, compile_and_link: $$@)\n \t$$(STAGE$(1)_T_$(4)_H_$(3)) --cfg rustdoc -o $$@ $$<\n \n-$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBRUSTI_$(4)):\t\t\\\n-\t\t$$(RUSTI_LIB) $$(RUSTI_INPUTS)\t\t\t\\\n-\t\t$$(SREQ$(1)_T_$(4)_H_$(3))\t\t\t\\\n-\t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBRUSTC_$(4))\t\\\n-\t\t| $$(TLIB$(1)_T_$(4)_H_$(3))/\n-\t@$$(call E, compile_and_link: $$@)\n-\t$$(call REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTI_GLOB_$(4)),$$(notdir $$@))\n-\t$$(STAGE$(1)_T_$(4)_H_$(3)) $$(WFLAGS_ST$(1)) --out-dir $$(@D) $$< && touch $$@\n-\t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTI_GLOB_$(4)),$$(notdir $$@))\n-\n-$$(TBIN$(1)_T_$(4)_H_$(3))/rusti$$(X_$(4)):\t\t\t\\\n-\t\t$$(DRIVER_CRATE) \t\t\t\t\t\t\t\\\n-\t\t$$(TSREQ$(1)_T_$(4)_H_$(3))\t\t\t\\\n-\t\t$$(TLIB$(1)_T_$(4)_H_$(4))/$(CFG_LIBRUSTI_$(4)) \\\n-\t\t| $$(TBIN$(1)_T_$(4)_H_$(3))/\n-\t@$$(call E, compile_and_link: $$@)\n-\t$$(STAGE$(1)_T_$(4)_H_$(3)) --cfg rusti -o $$@ $$<\n-\n endef\n \n define TOOLS_STAGE_N_HOST\n@@ -147,27 +125,6 @@ $$(HBIN$(2)_H_$(4))/rustdoc$$(X_$(4)):\t\t\t\t\\\n \t@$$(call E, cp: $$@)\n \t$$(Q)cp $$< $$@\n \n-$$(HLIB$(2)_H_$(4))/$(CFG_LIBRUSTI_$(4)):\t\t\t\t\t\\\n-\t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBRUSTI_$(4))\t\\\n-\t\t$$(HLIB$(2)_H_$(4))/$(CFG_LIBRUSTC_$(4))\t\t\t\\\n-\t\t$$(HSREQ$(2)_H_$(4)) \\\n-\t\t| $$(HLIB$(2)_H_$(4))/\n-\t@$$(call E, cp: $$@)\n-\t$$(call REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTI_GLOB_$(4)),$$(notdir $$@))\n-\t$$(Q)cp $$< $$@\n-\t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTI_GLOB_$(4)),$$(notdir $$@))\n-\t$$(Q)cp -R $$(TLIB$(1)_T_$(4)_H_$(3))/$(LIBRUSTI_GLOB_$(4)) \\\n-\t\t$$(wildcard $$(TLIB$(1)_T_$(4)_H_$(3))/$(LIBRUSTI_DSYM_GLOB_$(4))) \\\n-\t        $$(HLIB$(2)_H_$(4))\n-\n-$$(HBIN$(2)_H_$(4))/rusti$$(X_$(4)):\t\t\t\t\\\n-\t\t$$(TBIN$(1)_T_$(4)_H_$(3))/rusti$$(X_$(4))\t\\\n-\t\t$$(HLIB$(2)_H_$(4))/$(CFG_LIBRUSTI_$(4))\t\\\n-\t\t$$(HSREQ$(2)_H_$(4))\t\t\t\t\\\n-\t\t| $$(HBIN$(2)_H_$(4))/\n-\t@$$(call E, cp: $$@)\n-\t$$(Q)cp $$< $$@\n-\n endef\n \n $(foreach host,$(CFG_HOST_TRIPLES),\t\t\t\t\\"}, {"sha": "1ee08247c7353b51a898b00ca052dc5c41d30554", "filename": "src/README.txt", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/386fa1d818f341004e511af24da9f257d35cdbd2/src%2FREADME.txt", "raw_url": "https://github.com/rust-lang/rust/raw/386fa1d818f341004e511af24da9f257d35cdbd2/src%2FREADME.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FREADME.txt?ref=386fa1d818f341004e511af24da9f257d35cdbd2", "patch": "@@ -17,7 +17,6 @@ rt/sync            - Concurrency utils\n rt/util            - Small utility classes for the runtime.\n rt/vg              - Valgrind headers\n rt/msvc            - MSVC support\n-rt/linenoise       - a readline-like line editing library\n \n test/              Testsuite\n test/compile-fail  - Tests that should fail to compile\n@@ -31,8 +30,6 @@ compiletest/       The test runner\n \n librustpkg/        The package manager and build system\n \n-librusti/          The JIT REPL\n-\n librustdoc/        The Rust API documentation tool\n \n llvm/              The LLVM submodule"}, {"sha": "4b29709895e63502efac319c60bf7d2f4996dad4", "filename": "src/libextra/extra.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/386fa1d818f341004e511af24da9f257d35cdbd2/src%2Flibextra%2Fextra.rs", "raw_url": "https://github.com/rust-lang/rust/raw/386fa1d818f341004e511af24da9f257d35cdbd2/src%2Flibextra%2Fextra.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fextra.rs?ref=386fa1d818f341004e511af24da9f257d35cdbd2", "patch": "@@ -94,7 +94,6 @@ pub mod term;\n pub mod time;\n pub mod arena;\n pub mod base64;\n-pub mod rl;\n pub mod workcache;\n pub mod enum_set;\n #[path=\"num/bigint.rs\"]"}, {"sha": "c8a17451a705197cae4a141e48490903b960b98c", "filename": "src/libextra/rl.rs", "status": "removed", "additions": 0, "deletions": 143, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/00adcf0bdd9376046859b7bc0d79097b621844c5/src%2Flibextra%2Frl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00adcf0bdd9376046859b7bc0d79097b621844c5/src%2Flibextra%2Frl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frl.rs?ref=00adcf0bdd9376046859b7bc0d79097b621844c5", "patch": "@@ -1,143 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Bindings for the ability to read lines of input from the console\n-\n-use std::c_str::ToCStr;\n-use std::libc::{c_char, c_int};\n-use std::{local_data, str, rt};\n-use std::unstable::finally::Finally;\n-\n-mod rustrt {\n-    use std::libc::{c_char, c_int};\n-\n-    externfn!(fn linenoise(prompt: *c_char) -> *c_char)\n-    externfn!(fn linenoiseHistoryAdd(line: *c_char) -> c_int)\n-    externfn!(fn linenoiseHistorySetMaxLen(len: c_int) -> c_int)\n-    externfn!(fn linenoiseHistorySave(file: *c_char) -> c_int)\n-    externfn!(fn linenoiseHistoryLoad(file: *c_char) -> c_int)\n-    externfn!(fn linenoiseSetCompletionCallback(callback: extern \"C\" fn(*i8, *())))\n-    externfn!(fn linenoiseAddCompletion(completions: *(), line: *c_char))\n-\n-    externfn!(fn rust_take_linenoise_lock())\n-    externfn!(fn rust_drop_linenoise_lock())\n-}\n-\n-macro_rules! locked {\n-    ($expr:expr) => {\n-        {\n-            // FIXME #9105: can't use a static mutex in pure Rust yet.\n-            rustrt::rust_take_linenoise_lock();\n-            let x = $expr;\n-            rustrt::rust_drop_linenoise_lock();\n-            x\n-        }\n-    }\n-}\n-\n-/// Add a line to history\n-pub fn add_history(line: &str) -> bool {\n-    do line.with_c_str |buf| {\n-        unsafe {\n-            (locked!(rustrt::linenoiseHistoryAdd(buf))) == 1 as c_int\n-        }\n-    }\n-}\n-\n-/// Set the maximum amount of lines stored\n-pub fn set_history_max_len(len: int) -> bool {\n-    unsafe {\n-        (locked!(rustrt::linenoiseHistorySetMaxLen(len as c_int))) == 1\n-            as c_int\n-    }\n-}\n-\n-/// Save line history to a file\n-pub fn save_history(file: &str) -> bool {\n-    do file.with_c_str |buf| {\n-        // 0 on success, -1 on failure\n-        unsafe {\n-            (locked!(rustrt::linenoiseHistorySave(buf))) == 0 as c_int\n-        }\n-    }\n-}\n-\n-/// Load line history from a file\n-pub fn load_history(file: &str) -> bool {\n-    do file.with_c_str |buf| {\n-        // 0 on success, -1 on failure\n-        unsafe {\n-            (locked!(rustrt::linenoiseHistoryLoad(buf))) == 0 as c_int\n-        }\n-    }\n-}\n-\n-/// Print out a prompt and then wait for input and return it\n-pub fn read(prompt: &str) -> Option<~str> {\n-    do prompt.with_c_str |buf| {\n-        let line = unsafe {\n-            locked!(rustrt::linenoise(buf))\n-        };\n-\n-        if line.is_null() { None }\n-        else {\n-            unsafe {\n-                do (|| {\n-                    Some(str::raw::from_c_str(line))\n-                }).finally {\n-                    // linenoise's return value is from strdup, so we\n-                    // better not leak it.\n-                    rt::global_heap::exchange_free(line);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-/// The callback used to perform completions.\n-pub trait CompletionCb {\n-    /// Performs a completion.\n-    fn complete(&self, line: ~str, suggestion: &fn(~str));\n-}\n-\n-local_data_key!(complete_key: @CompletionCb)\n-\n-/// Bind to the main completion callback in the current task.\n-///\n-/// The completion callback should not call any `extra::rl` functions\n-/// other than the closure that it receives as its second\n-/// argument. Calling such a function will deadlock on the mutex used\n-/// to ensure that the calls are thread-safe.\n-pub unsafe fn complete(cb: @CompletionCb) {\n-    local_data::set(complete_key, cb);\n-\n-    extern fn callback(line: *c_char, completions: *()) {\n-        do local_data::get(complete_key) |opt_cb| {\n-            // only fetch completions if a completion handler has been\n-            // registered in the current task.\n-            match opt_cb {\n-                None => {}\n-                Some(cb) => {\n-                    unsafe {\n-                        do cb.complete(str::raw::from_c_str(line))\n-                                |suggestion| {\n-                            do suggestion.with_c_str |buf| {\n-                                rustrt::linenoiseAddCompletion(completions,\n-                                                               buf);\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    locked!(rustrt::linenoiseSetCompletionCallback(callback));\n-}"}, {"sha": "4ab9ac4aef5f362717aad896b30f35e1cad0cf62", "filename": "src/librusti/program.rs", "status": "removed", "additions": 0, "deletions": 416, "changes": 416, "blob_url": "https://github.com/rust-lang/rust/blob/00adcf0bdd9376046859b7bc0d79097b621844c5/src%2Flibrusti%2Fprogram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00adcf0bdd9376046859b7bc0d79097b621844c5/src%2Flibrusti%2Fprogram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Fprogram.rs?ref=00adcf0bdd9376046859b7bc0d79097b621844c5", "patch": "@@ -1,416 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::cast;\n-use std::util;\n-use std::hashmap::HashMap;\n-use std::local_data;\n-\n-use syntax::ast;\n-use syntax::parse::token;\n-use syntax::print::pprust;\n-use rustc::middle::ty;\n-use rustc::util::ppaux;\n-\n-use utils::*;\n-\n-/// This structure keeps track of the state of the world for the code being\n-/// executed in rusti.\n-#[deriving(Clone)]\n-pub struct Program {\n-    /// All known local variables\n-    local_vars: HashMap<~str, LocalVariable>,\n-    /// New variables which will be present (learned from typechecking)\n-    newvars: HashMap<~str, LocalVariable>,\n-    /// All known view items (use statements), distinct because these must\n-    /// follow extern mods\n-    view_items: ~str,\n-    /// All known 'extern mod' statements (must always come first)\n-    externs: ~str,\n-    /// All known structs defined. These need to have\n-    /// #[deriving(Encodable,Decodable)] to be at all useful in rusti\n-    structs: HashMap<~str, ~str>,\n-    /// All other items, can all be intermingled. Duplicate definitions of the\n-    /// same name have the previous one overwritten.\n-    items: HashMap<~str, ~str>,\n-}\n-\n-/// Represents a local variable that the program is currently using.\n-#[deriving(Clone)]\n-struct LocalVariable {\n-    /// Should this variable be locally declared as mutable?\n-    mutable: bool,\n-    /// This is the type of the serialized data below\n-    ty: ~str,\n-    /// This is the serialized version of the variable\n-    data: ~[u8],\n-    /// When taking borrowed pointers or slices, care must be taken to ensure\n-    /// that the deserialization produces what we'd expect. If some magic is in\n-    /// order, the first element of this pair is the actual type of the local\n-    /// variable (which can be different from the deserialized type), and the\n-    /// second element are the '&'s which need to be prepended.\n-    alterations: Option<(~str, ~str)>,\n-}\n-\n-type LocalCache = @mut HashMap<~str, @~[u8]>;\n-local_data_key!(tls_key: LocalCache)\n-\n-impl Program {\n-    pub fn new() -> Program {\n-        Program {\n-            local_vars: HashMap::new(),\n-            newvars: HashMap::new(),\n-            view_items: ~\"\",\n-            externs: ~\"\",\n-            structs: HashMap::new(),\n-            items: HashMap::new(),\n-        }\n-    }\n-\n-    /// Clears all local bindings about variables, items, externs, etc.\n-    pub fn clear(&mut self) {\n-        *self = Program::new();\n-    }\n-\n-    /// Creates a block of code to be fed to rustc. This code is not meant to\n-    /// run, but rather it is meant to learn about the input given. This will\n-    /// assert that the types of all bound local variables are encodable,\n-    /// along with checking syntax and other rust-related things. The reason\n-    /// that we only check for encodability is that some super-common types\n-    /// (like &'static str) are not decodable, but are encodable. By doing some\n-    /// mild approximation when decoding, we can emulate at least &str and &[T].\n-    ///\n-    /// Once this code has been fed to rustc, it is intended that the code()\n-    /// function is used to actually generate code to fully compile and run.\n-    pub fn test_code(&self, user_input: &str, to_print: &Option<~str>,\n-                     new_locals: &[(~str, bool)]) -> ~str {\n-        let mut code = self.program_header();\n-        code.push_str(\"\n-    fn assert_encodable<T: Encodable<::extra::ebml::writer::Encoder>>(t: &T) {}\n-        \");\n-\n-        code.push_str(\"fn main() {\\n\");\n-        // It's easy to initialize things if we don't run things...\n-        for (name, var) in self.local_vars.iter() {\n-            let mt = var.mt();\n-            code.push_str(format!(\"let{} {}: {} = fail!();\\n\", mt, *name, var.ty));\n-            var.alter(*name, &mut code);\n-        }\n-        code.push_str(\"{\\n\");\n-        code.push_str(user_input);\n-        code.push_char('\\n');\n-        match *to_print {\n-            Some(ref s) => {\n-                code.push_str(*s);\n-                code.push_str(\";\\n\");\n-            }\n-            None => {}\n-        }\n-\n-        for p in new_locals.iter() {\n-            code.push_str(format!(\"assert_encodable(&{});\\n\", *p.first_ref()));\n-        }\n-        code.push_str(\"};}\");\n-        return code;\n-    }\n-\n-    /// Creates a program to be fed into rustc. This program is structured to\n-    /// deserialize all bindings into local variables, run the code input, and\n-    /// then reserialize all the variables back out.\n-    ///\n-    /// This program (unlike test_code) is meant to run to actually execute the\n-    /// user's input\n-    pub fn code(&mut self, user_input: &str, to_print: &Option<~str>) -> ~str {\n-        let mut code = self.program_header();\n-        code.push_str(\"\n-            fn main() {\n-        \");\n-\n-        let key: uint= unsafe { cast::transmute(tls_key) };\n-        // First, get a handle to the tls map which stores all the local\n-        // variables. This works by totally legitimately using the 'code'\n-        // pointer of the 'tls_key' function as a uint, and then casting it back\n-        // up to a function\n-        code.push_str(format!(\"\n-            let __tls_map: @mut ::std::hashmap::HashMap<~str, @~[u8]> = unsafe \\\\{\n-                let key = ::std::cast::transmute({});\n-                ::std::local_data::get(key, |k| k.map(|&x| *x)).unwrap()\n-            \\\\};\\n\", key));\n-\n-        // Using this __tls_map handle, deserialize each variable binding that\n-        // we know about\n-        for (name, var) in self.local_vars.iter() {\n-            let mt = var.mt();\n-            code.push_str(format!(\"let{} {}: {} = \\\\{\n-                let data = __tls_map.get_copy(&~\\\"{}\\\");\n-                let doc = ::extra::ebml::reader::Doc(data);\n-                let mut decoder = ::extra::ebml::reader::Decoder(doc);\n-                ::extra::serialize::Decodable::decode(&mut decoder)\n-            \\\\};\\n\", mt, *name, var.ty, *name));\n-            var.alter(*name, &mut code);\n-        }\n-\n-        // After all that, actually run the user's code.\n-        code.push_str(user_input);\n-        code.push_char('\\n');\n-\n-        match *to_print {\n-            Some(ref s) => { code.push_str(format!(\"pp(\\\\{\\n{}\\n\\\\});\", *s)); }\n-            None => {}\n-        }\n-\n-        let newvars = util::replace(&mut self.newvars, HashMap::new());\n-        for (name, var) in newvars.move_iter() {\n-            self.local_vars.insert(name, var);\n-        }\n-\n-        // After the input code is run, we can re-serialize everything back out\n-        // into tls map (to be read later on by this task)\n-        for (name, var) in self.local_vars.iter() {\n-            code.push_str(format!(\"\\\\{\n-                let local: {} = {};\n-                let bytes = do ::std::io::with_bytes_writer |io| \\\\{\n-                    let mut enc = ::extra::ebml::writer::Encoder(io);\n-                    local.encode(&mut enc);\n-                \\\\};\n-                __tls_map.insert(~\\\"{}\\\", @bytes);\n-            \\\\}\\n\", var.real_ty(), *name, *name));\n-        }\n-\n-        // Close things up, and we're done.\n-        code.push_str(\"}\");\n-        return code;\n-    }\n-\n-    /// Creates the header of the programs which are generated to send to rustc\n-    fn program_header(&self) -> ~str {\n-        // up front, disable lots of annoying lints, then include all global\n-        // state such as items, view items, and extern mods.\n-        let mut code = format!(\"\n-            \\\\#[allow(warnings)];\n-\n-            extern mod extra;\n-            {} // extern mods\n-\n-            use extra::serialize::*;\n-            {} // view items\n-        \", self.externs, self.view_items);\n-        for (_, s) in self.structs.iter() {\n-            // The structs aren't really useful unless they're encodable\n-            code.push_str(\"#[deriving(Encodable, Decodable)]\");\n-            code.push_str(*s);\n-            code.push_str(\"\\n\");\n-        }\n-        for (_, s) in self.items.iter() {\n-            code.push_str(*s);\n-            code.push_str(\"\\n\");\n-        }\n-        code.push_str(\"fn pp<T>(t: T) { println(fmt!(\\\"%?\\\", t)); }\\n\");\n-        return code;\n-    }\n-\n-    /// Initializes the task-local cache of all local variables known to the\n-    /// program. This will be used to read local variables out of once the\n-    /// program starts\n-    pub fn set_cache(&self) {\n-        let map = @mut HashMap::new();\n-        for (name, value) in self.local_vars.iter() {\n-            map.insert((*name).clone(), @(value.data).clone());\n-        }\n-        local_data::set(tls_key, map);\n-    }\n-\n-    /// Once the program has finished running, this function will consume the\n-    /// task-local cache of local variables. After the program finishes running,\n-    /// it updates this cache with the new values of each local variable.\n-    pub fn consume_cache(&mut self) {\n-        let map = local_data::pop(tls_key).expect(\"tls is empty\");\n-        let cons_map = util::replace(map, HashMap::new());\n-        for (name, value) in cons_map.move_iter() {\n-            match self.local_vars.find_mut(&name) {\n-                Some(v) => { v.data = (*value).clone(); }\n-                None => { fail2!(\"unknown variable {}\", name) }\n-            }\n-        }\n-    }\n-\n-    // Simple functions to record various global things (as strings)\n-\n-    pub fn record_view_item(&mut self, vi: &str) {\n-        self.view_items.push_str(vi);\n-        self.view_items.push_char('\\n');\n-    }\n-\n-    pub fn record_struct(&mut self, name: &str, s: ~str) {\n-        let name = name.to_owned();\n-        self.items.remove(&name);\n-        self.structs.insert(name, s);\n-    }\n-\n-    pub fn record_item(&mut self, name: &str, it: ~str) {\n-        let name = name.to_owned();\n-        self.structs.remove(&name);\n-        self.items.insert(name, it);\n-    }\n-\n-    pub fn record_extern(&mut self, name: &str) {\n-        self.externs.push_str(name);\n-        self.externs.push_char('\\n');\n-    }\n-\n-    /// This monster function is responsible for reading the main function\n-    /// generated by test_code() to determine the type of each local binding\n-    /// created by the user's input.\n-    ///\n-    /// Once the types are known, they are inserted into the local_vars map in\n-    /// this Program (to be deserialized later on\n-    pub fn register_new_vars(&mut self, blk: &ast::Block, tcx: ty::ctxt) {\n-        debug2!(\"looking for new variables\");\n-        let newvars = @mut HashMap::new();\n-        do each_user_local(blk) |local| {\n-            let mutable = local.is_mutbl;\n-            do each_binding(local) |path, id| {\n-                let name = do with_pp(token::get_ident_interner()) |pp, _| {\n-                    pprust::print_path(pp, path, false);\n-                };\n-                let mut t = ty::node_id_to_type(tcx, id);\n-                let mut tystr = ~\"\";\n-                let mut lvar = LocalVariable {\n-                    ty: ~\"\",\n-                    data: ~[],\n-                    mutable: mutable,\n-                    alterations: None,\n-                };\n-                // This loop is responsible for figuring out what \"alterations\"\n-                // are necessary for this local variable.\n-                loop {\n-                    match ty::get(t).sty {\n-                        // &T encoded will decode to T, so we need to be sure to\n-                        // re-take a loan after decoding\n-                        ty::ty_rptr(_, mt) => {\n-                            if mt.mutbl == ast::MutMutable {\n-                                tystr.push_str(\"&mut \");\n-                            } else {\n-                                tystr.push_str(\"&\");\n-                            }\n-                            t = mt.ty;\n-                        }\n-                        // Literals like [1, 2, 3] and (~[0]).slice() will both\n-                        // be serialized to ~[T], whereas it's requested to be a\n-                        // &[T] instead.\n-                        ty::ty_evec(mt, ty::vstore_slice(*)) |\n-                        ty::ty_evec(mt, ty::vstore_fixed(*)) => {\n-                            let vty = ppaux::ty_to_str(tcx, mt.ty);\n-                            let derefs = tystr.clone();\n-                            lvar.ty = tystr + \"~[\" + vty + \"]\";\n-                            lvar.alterations = Some((tystr + \"&[\" + vty + \"]\",\n-                                                     derefs));\n-                            break;\n-                        }\n-                        // Similar to vectors, &str serializes to ~str, so a\n-                        // borrow must be taken\n-                        ty::ty_estr(ty::vstore_slice(*)) => {\n-                            let derefs = tystr.clone();\n-                            lvar.ty = tystr + \"~str\";\n-                            lvar.alterations = Some((tystr + \"&str\", derefs));\n-                            break;\n-                        }\n-                        // Don't generate extra stuff if there's no borrowing\n-                        // going on here\n-                        _ if \"\" == tystr => {\n-                            lvar.ty = ppaux::ty_to_str(tcx, t);\n-                            break;\n-                        }\n-                        // If we're just borrowing (no vectors or strings), then\n-                        // we just need to record how many borrows there were.\n-                        _ => {\n-                            let derefs = tystr.clone();\n-                            let tmptystr = ppaux::ty_to_str(tcx, t);\n-                            lvar.alterations = Some((tystr + tmptystr, derefs));\n-                            lvar.ty = tmptystr;\n-                            break;\n-                        }\n-                    }\n-                }\n-                newvars.insert(name, lvar);\n-            }\n-        }\n-\n-        // I'm not an @ pointer, so this has to be done outside.\n-        let cons_newvars = util::replace(newvars, HashMap::new());\n-        for (k, v) in cons_newvars.move_iter() {\n-            self.newvars.insert(k, v);\n-        }\n-\n-        // helper functions to perform ast iteration\n-        fn each_user_local(blk: &ast::Block, f: &fn(@ast::Local)) {\n-            do find_user_block(blk) |blk| {\n-                for stmt in blk.stmts.iter() {\n-                    match stmt.node {\n-                        ast::StmtDecl(d, _) => {\n-                            match d.node {\n-                                ast::DeclLocal(l) => { f(l); }\n-                                _ => {}\n-                            }\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-            }\n-        }\n-\n-        fn find_user_block(blk: &ast::Block, f: &fn(&ast::Block)) {\n-            for stmt in blk.stmts.iter() {\n-                match stmt.node {\n-                    ast::StmtSemi(e, _) => {\n-                        match e.node {\n-                            ast::ExprBlock(ref blk) => { return f(blk); }\n-                            _ => {}\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            fail2!(\"couldn't find user block\");\n-        }\n-    }\n-}\n-\n-impl LocalVariable {\n-    /// Performs alterations to the code provided, given the name of this\n-    /// variable.\n-    fn alter(&self, name: &str, code: &mut ~str) {\n-        match self.alterations {\n-            Some((ref real_ty, ref prefix)) => {\n-                code.push_str(format!(\"let{} {}: {} = {}{};\\n\",\n-                                      self.mt(), name,\n-                                      *real_ty, *prefix, name));\n-            }\n-            None => {}\n-        }\n-    }\n-\n-    fn real_ty<'a>(&'a self) -> &'a str {\n-        match self.alterations {\n-            Some((ref real_ty, _)) => {\n-                let ret: &'a str = *real_ty;\n-                return ret;\n-            }\n-            None => {\n-                let ret: &'a str = self.ty;\n-                return ret;\n-            }\n-        }\n-    }\n-\n-    fn mt(&self) -> &'static str {\n-        if self.mutable {\" mut\"} else {\"\"}\n-    }\n-}"}, {"sha": "c025d9b10dd0421fb5d6bd675baba28539bb2a7d", "filename": "src/librusti/rusti.rs", "status": "removed", "additions": 0, "deletions": 786, "changes": 786, "blob_url": "https://github.com/rust-lang/rust/blob/00adcf0bdd9376046859b7bc0d79097b621844c5/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00adcf0bdd9376046859b7bc0d79097b621844c5/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=00adcf0bdd9376046859b7bc0d79097b621844c5", "patch": "@@ -1,786 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n- * rusti - A REPL using the JIT backend\n- *\n- * Rusti works by serializing state between lines of input. This means that each\n- * line can be run in a separate task, and the only limiting factor is that all\n- * local bound variables are encodable.\n- *\n- * This is accomplished by feeding in generated input to rustc for execution in\n- * the JIT compiler. Currently input actually gets fed in three times to get\n- * information about the program.\n- *\n- * - Pass #1\n- *   In this pass, the input is simply thrown at the parser and the input comes\n- *   back. This validates the structure of the program, and at this stage the\n- *   global items (fns, structs, impls, traits, etc.) are filtered from the\n- *   input into the \"global namespace\". These declarations shadow all previous\n- *   declarations of an item by the same name.\n- *\n- * - Pass #2\n- *   After items have been stripped, the remaining input is passed to rustc\n- *   along with all local variables declared (initialized to nothing). This pass\n- *   runs up to typechecking. From this, we can learn about the types of each\n- *   bound variable, what variables are bound, and also ensure that all the\n- *   types are encodable (the input can actually be run).\n- *\n- * - Pass #3\n- *   Finally, a program is generated to deserialize the local variable state,\n- *   run the code input, and then reserialize all bindings back into a local\n- *   hash map. This code is then run in the JIT engine provided by the rust\n- *   compiler.\n- *\n- * - Pass #4\n- *   Once this code runs, the input has fully been run and the hash map of local\n- *   variables from TLS is read back into the local store of variables. This is\n- *   then used later to pass back along to the parent rusti task and then begin\n- *   waiting for input again.\n- *\n- * - Pass #5\n- *   When running rusti code, it's important to consume ownership of the LLVM\n- *   jit contextual information to prevent code from being deallocated too soon\n- *   (before drop glue runs, see #7732). For this reason, the jit context is\n- *   consumed and also passed along to the parent task. The parent task then\n- *   keeps around all contexts while rusti is running. This must be done because\n- *   tasks could in theory be spawned off and running in the background (still\n- *   using the code).\n- *\n- * Encoding/decoding is done with EBML, and there is simply a map of ~str ->\n- * ~[u8] maintaining the values of each local binding (by name).\n- */\n-\n-#[link(name = \"rusti\",\n-       vers = \"0.9-pre\",\n-       uuid = \"7fb5bf52-7d45-4fee-8325-5ad3311149fc\",\n-       url = \"https://github.com/mozilla/rust/tree/master/src/rusti\")];\n-\n-#[license = \"MIT/ASL2\"];\n-#[crate_type = \"lib\"];\n-\n-#[feature(globs)];\n-\n-extern mod extra;\n-extern mod rustc;\n-extern mod syntax;\n-\n-use std::{libc, io, os, task};\n-use std::cell::Cell;\n-use extra::rl::CompletionCb;\n-use extra::rl;\n-\n-use rustc::driver::{driver, session};\n-use rustc::back::link::jit;\n-use syntax::{ast, codemap, diagnostic};\n-use syntax::ast_util::*;\n-use syntax::diagnostic::Emitter;\n-use syntax::parse::token;\n-use syntax::print::pprust;\n-\n-use program::Program;\n-use utils::*;\n-\n-mod program;\n-pub mod utils;\n-\n-/**\n- * A structure shared across REPL instances for storing history\n- * such as statements and view items. I wish the AST was sendable.\n- */\n-pub struct Repl {\n-    prompt: ~str,\n-    binary: ~str,\n-    running: bool,\n-    lib_search_paths: ~[~str],\n-    engines: ~[~jit::Engine],\n-\n-    program: ~Program,\n-}\n-\n-// Action to do after reading a :command\n-enum CmdAction {\n-    action_none,\n-    action_run_line(~str),\n-}\n-\n-struct EncodableWarningEmitter;\n-\n-impl diagnostic::Emitter for EncodableWarningEmitter {\n-    fn emit(&self,\n-            cm: Option<(@codemap::CodeMap, codemap::Span)>,\n-            msg: &str,\n-            lvl: diagnostic::level) {\n-        diagnostic::DefaultEmitter.emit(cm, msg, lvl);\n-        if msg.contains(\"failed to find an implementation of trait\") &&\n-           msg.contains(\"extra::serialize::Encodable\") {\n-            diagnostic::DefaultEmitter.emit(cm,\n-                                            \"Currrently rusti serializes \\\n-                                             bound locals between different \\\n-                                             lines of input. This means that \\\n-                                             all values of local variables \\\n-                                             need to be encodable, and this \\\n-                                             type isn't encodable\",\n-                                            diagnostic::note);\n-        }\n-    }\n-}\n-\n-/// Run an input string in a Repl, returning the new Repl.\n-fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n-       input: ~str) -> (~Program, Option<~jit::Engine>)\n-{\n-    // Build some necessary rustc boilerplate for compiling things\n-    let binary = binary.to_managed();\n-    let options = @session::options {\n-        crate_type: session::unknown_crate,\n-        binary: binary,\n-        addl_lib_search_paths: @mut lib_search_paths.map(|p| Path::new(p.as_slice())),\n-        jit: true,\n-        .. (*session::basic_options()).clone()\n-    };\n-    // Because we assume that everything is encodable (and assert so), add some\n-    // extra helpful information if the error crops up. Otherwise people are\n-    // bound to be very confused when they find out code is running that they\n-    // never typed in...\n-    let sess = driver::build_session(options,\n-                                     @EncodableWarningEmitter as\n-                                        @diagnostic::Emitter);\n-    let intr = token::get_ident_interner();\n-\n-    //\n-    // Stage 1: parse the input and filter it into the program (as necessary)\n-    //\n-    debug2!(\"parsing: {}\", input);\n-    let crate = parse_input(sess, input);\n-    let mut to_run = ~[];       // statements to run (emitted back into code)\n-    let new_locals = @mut ~[];  // new locals being defined\n-    let mut result = None;      // resultant expression (to print via pp)\n-    do find_main(&crate, sess) |blk| {\n-        // Fish out all the view items, be sure to record 'extern mod' items\n-        // differently beause they must appear before all 'use' statements\n-        for vi in blk.view_items.iter() {\n-            let s = do with_pp(intr) |pp, _| {\n-                pprust::print_view_item(pp, vi);\n-            };\n-            match vi.node {\n-                ast::view_item_extern_mod(*) => {\n-                    program.record_extern(s);\n-                }\n-                ast::view_item_use(*) => { program.record_view_item(s); }\n-            }\n-        }\n-\n-        // Iterate through all of the block's statements, inserting them into\n-        // the correct portions of the program\n-        for stmt in blk.stmts.iter() {\n-            let s = do with_pp(intr) |pp, _| { pprust::print_stmt(pp, *stmt); };\n-            match stmt.node {\n-                ast::StmtDecl(d, _) => {\n-                    match d.node {\n-                        ast::DeclItem(it) => {\n-                            let name = sess.str_of(it.ident);\n-                            match it.node {\n-                                // Structs are treated specially because to make\n-                                // them at all usable they need to be decorated\n-                                // with #[deriving(Encoable, Decodable)]\n-                                ast::item_struct(*) => {\n-                                    program.record_struct(name, s);\n-                                }\n-                                // Item declarations are hoisted out of main()\n-                                _ => { program.record_item(name, s); }\n-                            }\n-                        }\n-\n-                        // Local declarations must be specially dealt with,\n-                        // record all local declarations for use later on\n-                        ast::DeclLocal(l) => {\n-                            let mutbl = l.is_mutbl;\n-                            do each_binding(l) |path, _| {\n-                                let s = do with_pp(intr) |pp, _| {\n-                                    pprust::print_path(pp, path, false);\n-                                };\n-                                new_locals.push((s, mutbl));\n-                            }\n-                            to_run.push(s);\n-                        }\n-                    }\n-                }\n-\n-                // run statements with expressions (they have effects)\n-                ast::StmtMac(*) | ast::StmtSemi(*) | ast::StmtExpr(*) => {\n-                    to_run.push(s);\n-                }\n-            }\n-        }\n-        result = do blk.expr.map |e| {\n-            do with_pp(intr) |pp, _| { pprust::print_expr(pp, e); }\n-        };\n-    }\n-    // return fast for empty inputs\n-    if to_run.len() == 0 && result.is_none() {\n-        return (program, None);\n-    }\n-\n-    //\n-    // Stage 2: run everything up to typeck to learn the types of the new\n-    //          variables introduced into the program\n-    //\n-    info2!(\"Learning about the new types in the program\");\n-    program.set_cache(); // before register_new_vars (which changes them)\n-    let input = to_run.connect(\"\\n\");\n-    let test = program.test_code(input, &result, *new_locals);\n-    debug2!(\"testing with ^^^^^^ {:?}\", (||{ println(test) })());\n-    let dinput = driver::str_input(test.to_managed());\n-    let cfg = driver::build_configuration(sess);\n-\n-    let crate = driver::phase_1_parse_input(sess, cfg.clone(), &dinput);\n-    let expanded_crate = driver::phase_2_configure_and_expand(sess, cfg, crate);\n-    let analysis = driver::phase_3_run_analysis_passes(sess, &expanded_crate);\n-\n-    // Once we're typechecked, record the types of all local variables defined\n-    // in this input\n-    do find_main(&expanded_crate, sess) |blk| {\n-        program.register_new_vars(blk, analysis.ty_cx);\n-    }\n-\n-    //\n-    // Stage 3: Actually run the code in the JIT\n-    //\n-    info2!(\"actually running code\");\n-    let code = program.code(input, &result);\n-    debug2!(\"actually running ^^^^^^ {:?}\", (||{ println(code) })());\n-    let input = driver::str_input(code.to_managed());\n-    let cfg = driver::build_configuration(sess);\n-    let outputs = driver::build_output_filenames(&input, &None, &None, [], sess);\n-    let sess = driver::build_session(options,\n-                                     @diagnostic::DefaultEmitter as\n-                                        @diagnostic::Emitter);\n-\n-    let crate = driver::phase_1_parse_input(sess, cfg.clone(), &input);\n-    let expanded_crate = driver::phase_2_configure_and_expand(sess, cfg, crate);\n-    let analysis = driver::phase_3_run_analysis_passes(sess, &expanded_crate);\n-    let trans = driver::phase_4_translate_to_llvm(sess, expanded_crate, &analysis, outputs);\n-    driver::phase_5_run_llvm_passes(sess, &trans, outputs);\n-\n-    //\n-    // Stage 4: Inform the program that computation is done so it can update all\n-    //          local variable bindings.\n-    //\n-    info2!(\"cleaning up after code\");\n-    program.consume_cache();\n-\n-    //\n-    // Stage 5: Extract the LLVM execution engine to take ownership of the\n-    //          generated JIT code. This means that rusti can spawn parallel\n-    //          tasks and we won't deallocate the code emitted until rusti\n-    //          itself is destroyed.\n-    //\n-    return (program, jit::consume_engine());\n-\n-    fn parse_input(sess: session::Session, input: &str) -> ast::Crate {\n-        let code = format!(\"fn main() \\\\{\\n {} \\n\\\\}\", input);\n-        let input = driver::str_input(code.to_managed());\n-        let cfg = driver::build_configuration(sess);\n-        driver::phase_1_parse_input(sess, cfg.clone(), &input)\n-    }\n-\n-    fn find_main(crate: &ast::Crate, sess: session::Session,\n-                 f: &fn(&ast::Block)) {\n-        for item in crate.module.items.iter() {\n-            match item.node {\n-                ast::item_fn(_, _, _, _, ref blk) => {\n-                    if item.ident == sess.ident_of(\"main\") {\n-                        return f(blk);\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n-        fail2!(\"main function was expected somewhere...\");\n-    }\n-}\n-\n-// Compiles a crate given by the filename as a library if the compiled\n-// version doesn't exist or is older than the source file. Binary is\n-// the name of the compiling executable. Returns Some(true) if it\n-// successfully compiled, Some(false) if the crate wasn't compiled\n-// because it already exists and is newer than the source file, or\n-// None if there were compile errors.\n-fn compile_crate(src_filename: ~str, binary: ~str) -> Option<bool> {\n-    fn has_prefix(v: &[u8], pref: &[u8]) -> bool {\n-        v.len() >= pref.len() && v.slice_to(pref.len()) == pref\n-    }\n-    fn has_extension(v: &[u8], ext: Option<&[u8]>) -> bool {\n-        match ext {\n-            None => true,\n-            Some(ext) => {\n-                v.len() > ext.len() && v[v.len()-ext.len()-1] == '.' as u8 &&\n-                    v.slice_from(v.len()-ext.len()) == ext\n-            }\n-        }\n-    }\n-    match do task::try {\n-        let src_path = Path::new(src_filename.as_slice());\n-        let binary = binary.to_managed();\n-        let options = @session::options {\n-            binary: binary,\n-            addl_lib_search_paths: @mut ~[os::getcwd()],\n-            .. (*session::basic_options()).clone()\n-        };\n-        let input = driver::file_input(src_path.clone());\n-        let sess = driver::build_session(options,\n-                                         @diagnostic::DefaultEmitter as\n-                                            @diagnostic::Emitter);\n-        *sess.building_library = true;\n-        let cfg = driver::build_configuration(sess);\n-        let outputs = driver::build_output_filenames(\n-            &input, &None, &None, [], sess);\n-        // If the library already exists and is newer than the source\n-        // file, skip compilation and return None.\n-        let mut should_compile = true;\n-        let dir = os::list_dir_path(&outputs.out_filename.dir_path());\n-        let maybe_lib_path = do dir.iter().find |file| {\n-            // The actual file's name has a hash value and version\n-            // number in it which is unknown at this time, so looking\n-            // for a file that matches out_filename won't work,\n-            // instead we guess which file is the library by matching\n-            // the prefix and suffix of out_filename to files in the\n-            // directory.\n-            let file_vec = file.filename().unwrap();\n-            has_prefix(file_vec, outputs.out_filename.filestem().unwrap()) &&\n-                has_extension(file_vec, outputs.out_filename.extension())\n-        };\n-        match maybe_lib_path {\n-            Some(lib_path) => {\n-                let (src_mtime, _) = src_path.get_mtime().unwrap();\n-                let (lib_mtime, _) = lib_path.get_mtime().unwrap();\n-                if lib_mtime >= src_mtime {\n-                    should_compile = false;\n-                }\n-            },\n-            None => { },\n-        }\n-        if (should_compile) {\n-            println(format!(\"compiling {}...\", src_filename));\n-            let crate = driver::phase_1_parse_input(sess, cfg.clone(), &input);\n-            let expanded_crate = driver::phase_2_configure_and_expand(sess, cfg, crate);\n-            let analysis = driver::phase_3_run_analysis_passes(sess, &expanded_crate);\n-            let trans = driver::phase_4_translate_to_llvm(sess, expanded_crate, &analysis, outputs);\n-            driver::phase_5_run_llvm_passes(sess, &trans, outputs);\n-            true\n-        } else { false }\n-    } {\n-        Ok(true) => Some(true),\n-        Ok(false) => Some(false),\n-        Err(_) => None,\n-    }\n-}\n-\n-/// Tries to get a line from rl after outputting a prompt. Returns\n-/// None if no input was read (e.g. EOF was reached).\n-fn get_line(use_rl: bool, prompt: &str) -> Option<~str> {\n-    if use_rl {\n-        let result = rl::read(prompt);\n-\n-        match result {\n-            None => None,\n-            Some(line) => {\n-                rl::add_history(line);\n-                Some(line)\n-            }\n-        }\n-    } else {\n-        if io::stdin().eof() {\n-            None\n-        } else {\n-            Some(io::stdin().read_line())\n-        }\n-    }\n-}\n-\n-/// Run a command, e.g. :clear, :exit, etc.\n-fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n-           cmd: ~str, args: ~[~str], use_rl: bool) -> CmdAction {\n-    let mut action = action_none;\n-    match cmd {\n-        ~\"exit\" => repl.running = false,\n-        ~\"clear\" => {\n-            repl.program.clear();\n-\n-            // XXX: Win32 version of linenoise can't do this\n-            //rl::clear();\n-        }\n-        ~\"help\" => {\n-            println(\n-                \":{\\\\n ..lines.. \\\\n:}\\\\n - execute multiline command\\n\\\n-                 :load <crate> ... - loads given crates as dynamic libraries\\n\\\n-                 :clear - clear the bindings\\n\\\n-                 :exit - exit from the repl\\n\\\n-                 :help - show this message\");\n-        }\n-        ~\"load\" => {\n-            let mut loaded_crates: ~[~str] = ~[];\n-            for arg in args.iter() {\n-                let (crate, filename) =\n-                    if arg.ends_with(\".rs\") || arg.ends_with(\".rc\") {\n-                    (arg.slice_to(arg.len() - 3).to_owned(), (*arg).clone())\n-                } else {\n-                    ((*arg).clone(), *arg + \".rs\")\n-                };\n-                match compile_crate(filename, repl.binary.clone()) {\n-                    Some(_) => loaded_crates.push(crate),\n-                    None => { }\n-                }\n-            }\n-            for crate in loaded_crates.iter() {\n-                let crate_path = Path::new(crate.as_slice());\n-                // FIXME (#9639): This needs to handle non-utf8 paths\n-                let crate_dir = crate_path.dirname_str().unwrap();\n-                repl.program.record_extern(format!(\"extern mod {};\", *crate));\n-                if !repl.lib_search_paths.iter().any(|x| crate_dir == *x) {\n-                    repl.lib_search_paths.push(crate_dir.to_owned());\n-                }\n-            }\n-            if loaded_crates.is_empty() {\n-                println(\"no crates loaded\");\n-            } else {\n-                println!(\"crates loaded: {}\", loaded_crates.connect(\", \"));\n-            }\n-        }\n-        ~\"{\" => {\n-            let mut multiline_cmd = ~\"\";\n-            let mut end_multiline = false;\n-            while (!end_multiline) {\n-                match get_line(use_rl, \"rusti| \") {\n-                    None => fail2!(\"unterminated multiline command :\\\\{ .. :\\\\}\"),\n-                    Some(line) => {\n-                        if line.trim() == \":}\" {\n-                            end_multiline = true;\n-                        } else {\n-                            multiline_cmd.push_str(line);\n-                            multiline_cmd.push_char('\\n');\n-                        }\n-                    }\n-                }\n-            }\n-            action = action_run_line(multiline_cmd);\n-        }\n-        _ => println(~\"unknown cmd: \" + cmd)\n-    }\n-    return action;\n-}\n-\n-/// Executes a line of input, which may either be rust code or a\n-/// :command. Returns a new Repl if it has changed.\n-pub fn run_line(repl: &mut Repl, input: @io::Reader, out: @io::Writer, line: ~str,\n-                use_rl: bool) -> bool\n-{\n-    if line.starts_with(\":\") {\n-        // drop the : and the \\n (one byte each)\n-        let full = line.slice(1, line.len());\n-        let split: ~[~str] = full.word_iter().map(|s| s.to_owned()).collect();\n-        let len = split.len();\n-\n-        if len > 0 {\n-            let cmd = split[0].clone();\n-\n-            if !cmd.is_empty() {\n-                let args = if len > 1 {\n-                    split.slice(1, len).to_owned()\n-                } else { ~[] };\n-\n-                match run_cmd(repl, input, out, cmd, args, use_rl) {\n-                    action_none => { }\n-                    action_run_line(multiline_cmd) => {\n-                        if !multiline_cmd.is_empty() {\n-                            return run_line(repl, input, out, multiline_cmd, use_rl);\n-                        }\n-                    }\n-                }\n-                return true;\n-            }\n-        }\n-    }\n-\n-    let line = Cell::new(line);\n-    let program = Cell::new(repl.program.clone());\n-    let lib_search_paths = Cell::new(repl.lib_search_paths.clone());\n-    let binary = Cell::new(repl.binary.clone());\n-    let result = do task::try {\n-        run(program.take(), binary.take(), lib_search_paths.take(), line.take())\n-    };\n-\n-    match result {\n-        Ok((program, engine)) => {\n-            repl.program = program;\n-            match engine {\n-                Some(e) => { repl.engines.push(e); }\n-                None => {}\n-            }\n-            return true;\n-        }\n-        Err(*) => { return false; }\n-    }\n-}\n-\n-pub fn main() {\n-    os::set_exit_status(main_args(os::args()));\n-}\n-\n-struct Completer;\n-\n-impl CompletionCb for Completer {\n-    fn complete(&self, line: ~str, suggest: &fn(~str)) {\n-        if line.starts_with(\":\") {\n-            suggest(~\":clear\");\n-            suggest(~\":exit\");\n-            suggest(~\":help\");\n-            suggest(~\":load\");\n-        }\n-    }\n-}\n-\n-pub fn main_args(args: &[~str]) -> int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    let input = io::stdin();\n-    let out = io::stdout();\n-    let mut repl = Repl {\n-        prompt: ~\"rusti> \",\n-        binary: args[0].clone(),\n-        running: true,\n-        lib_search_paths: ~[],\n-        engines: ~[],\n-\n-        program: ~Program::new(),\n-    };\n-\n-    let istty = unsafe { libc::isatty(libc::STDIN_FILENO as i32) } != 0;\n-\n-    // only print this stuff if the user is actually typing into rusti\n-    if istty {\n-        println(\"WARNING: The Rust REPL is experimental and may be\");\n-        println(\"unstable. If you encounter problems, please use the\");\n-        println(\"compiler instead. Type :help for help.\");\n-\n-        unsafe {\n-            rl::complete(@Completer as @CompletionCb)\n-        }\n-    }\n-\n-    while repl.running {\n-        match get_line(istty, repl.prompt) {\n-            None => break,\n-            Some(line) => {\n-                if line.is_empty() {\n-                    if istty {\n-                        println(\"()\");\n-                    }\n-                    continue;\n-                }\n-                run_line(&mut repl, input, out, line, istty);\n-            }\n-        }\n-    }\n-\n-    return 0;\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use std::io;\n-    use program::Program;\n-    use super::*;\n-\n-    fn repl() -> Repl {\n-        Repl {\n-            prompt: ~\"rusti> \",\n-            binary: ~\"rusti\",\n-            running: true,\n-            lib_search_paths: ~[],\n-            engines: ~[],\n-            program: ~Program::new(),\n-        }\n-    }\n-\n-    // FIXME: #7220 rusti on 32bit mac doesn't work.\n-    // FIXME: #7641 rusti on 32bit linux cross compile doesn't work\n-    // FIXME: #7115 re-enable once LLVM has been upgraded\n-    #[cfg(thiswillneverbeacfgflag)]\n-    fn run_program(prog: &str) {\n-        let mut r = repl();\n-        for cmd in prog.split_iter('\\n') {\n-            assert!(run_line(&mut r, io::stdin(), io::stdout(),\n-                             cmd.to_owned(), false),\n-                    \"the command '%s' failed\", cmd);\n-        }\n-    }\n-    fn run_program(_: &str) {}\n-\n-    #[ignore]\n-    #[test]\n-    fn super_basic() {\n-        run_program(\"\");\n-    }\n-\n-    #[ignore]\n-    #[test]\n-    fn regression_5937() {\n-        run_program(\"use std::hashmap;\");\n-    }\n-\n-    #[ignore]\n-    #[test]\n-    fn regression_5784() {\n-        run_program(\"let a = 3;\");\n-    }\n-\n-    #[test] #[ignore]\n-    fn new_tasks() {\n-        // XXX: can't spawn new tasks because the JIT code is cleaned up\n-        //      after the main function is done.\n-        run_program(\"\n-            spawn( || println(\\\"Please don't segfault\\\") );\n-            do spawn { println(\\\"Please?\\\"); }\n-        \");\n-    }\n-\n-    #[ignore]\n-    #[test]\n-    fn inferred_integers_usable() {\n-        run_program(\"let a = 2;\\n()\\n\");\n-        run_program(\"\n-            let a = 3;\n-            let b = 4u;\n-            assert!((a as uint) + b == 7)\n-        \");\n-    }\n-\n-    #[ignore]\n-    #[test]\n-    fn local_variables_allow_shadowing() {\n-        run_program(\"\n-            let a = 3;\n-            let a = 5;\n-            assert!(a == 5)\n-        \");\n-    }\n-\n-    #[ignore]\n-    #[test]\n-    fn string_usable() {\n-        run_program(\"\n-            let a = ~\\\"\\\";\n-            let b = \\\"\\\";\n-            let c = @\\\"\\\";\n-            let d = a + b + c;\n-            assert!(d.len() == 0);\n-        \");\n-    }\n-\n-    #[ignore]\n-    #[test]\n-    fn vectors_usable() {\n-        run_program(\"\n-            let a = ~[1, 2, 3];\n-            let b = &[1, 2, 3];\n-            let c = @[1, 2, 3];\n-            let d = a + b + c;\n-            assert!(d.len() == 9);\n-            let e: &[int] = [];\n-        \");\n-    }\n-\n-    #[ignore]\n-    #[test]\n-    fn structs_usable() {\n-        run_program(\"\n-            struct A{ a: int }\n-            let b = A{ a: 3 };\n-            assert!(b.a == 3)\n-        \");\n-    }\n-\n-    #[ignore]\n-    #[test]\n-    fn mutable_variables_work() {\n-        run_program(\"\n-            let mut a = 3;\n-            a = 5;\n-            let mut b = std::hashmap::HashSet::new::<int>();\n-            b.insert(a);\n-            assert!(b.contains(&5))\n-            assert!(b.len() == 1)\n-        \");\n-    }\n-\n-    #[ignore]\n-    #[test]\n-    fn functions_saved() {\n-        run_program(\"\n-            fn fib(x: int) -> int { if x < 2 {x} else { fib(x - 1) + fib(x - 2) } }\n-            let a = fib(3);\n-            let a = a + fib(4);\n-            assert!(a == 5)\n-        \");\n-    }\n-\n-    #[ignore]\n-    #[test]\n-    fn modules_saved() {\n-        run_program(\"\n-            mod b { pub fn foo() -> uint { 3 } }\n-            assert!(b::foo() == 3)\n-        \");\n-    }\n-\n-    #[ignore]\n-    #[test]\n-    fn multiple_functions() {\n-        run_program(\"\n-            fn f() {}\n-            fn f() {}\n-            f()\n-        \");\n-    }\n-\n-    #[ignore]\n-    #[test]\n-    fn multiple_items_same_name() {\n-        run_program(\"\n-            fn f() {}\n-            mod f {}\n-            struct f;\n-            enum f {}\n-            fn f() {}\n-            f()\n-        \");\n-    }\n-\n-    #[ignore]\n-    #[test]\n-    fn simultaneous_definition_and_expression() {\n-        run_program(\"\n-            let a = 3; a as u8\n-        \");\n-    }\n-\n-    #[ignore]\n-    #[test]\n-    fn exit_quits() {\n-        let mut r = repl();\n-        assert!(r.running);\n-        let result = run_line(&mut r, io::stdin(), io::stdout(),\n-                              ~\":exit\", false);\n-        assert!(result);\n-        assert!(!r.running);\n-    }\n-}"}, {"sha": "904594fdfb8f5a94f27de907997660ae4c79c233", "filename": "src/librusti/utils.rs", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/00adcf0bdd9376046859b7bc0d79097b621844c5/src%2Flibrusti%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00adcf0bdd9376046859b7bc0d79097b621844c5/src%2Flibrusti%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Futils.rs?ref=00adcf0bdd9376046859b7bc0d79097b621844c5", "patch": "@@ -1,52 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::io;\n-use syntax::ast;\n-use syntax::print::pp;\n-use syntax::print::pprust;\n-use syntax::parse::token;\n-use syntax::visit;\n-\n-struct EachBindingVisitor<'self> {\n-    f: &'self fn(&ast::Path, ast::NodeId)\n-}\n-\n-impl<'self> visit::Visitor<()> for EachBindingVisitor<'self> {\n-    fn visit_pat(&mut self, pat:@ast::Pat, _:()) {\n-                match pat.node {\n-                    ast::PatIdent(_, ref path, _) => {\n-                        (self.f)(path, pat.id);\n-                    }\n-                    _ => {}\n-                }\n-\n-                visit::walk_pat(self, pat, ());\n-    }\n-}\n-\n-pub fn each_binding(l: @ast::Local, f: &fn(&ast::Path, ast::NodeId)) {\n-    use syntax::visit::Visitor;\n-\n-    let mut vt = EachBindingVisitor{ f: f };\n-\n-    vt.visit_pat(l.pat, ());\n-}\n-\n-/// A utility function that hands off a pretty printer to a callback.\n-pub fn with_pp(intr: @token::ident_interner,\n-               cb: &fn(@pprust::ps, @io::Writer)) -> ~str {\n-    do io::with_str_writer |writer| {\n-        let pp = pprust::rust_printer(writer, intr);\n-\n-        cb(pp, writer);\n-        pp::eof(pp.s);\n-    }\n-}"}, {"sha": "f008d2d3d5e38f6c4c29f6a767ca39c62853ce38", "filename": "src/rt/linenoise/README.markdown", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/00adcf0bdd9376046859b7bc0d79097b621844c5/src%2Frt%2Flinenoise%2FREADME.markdown", "raw_url": "https://github.com/rust-lang/rust/raw/00adcf0bdd9376046859b7bc0d79097b621844c5/src%2Frt%2Flinenoise%2FREADME.markdown", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flinenoise%2FREADME.markdown?ref=00adcf0bdd9376046859b7bc0d79097b621844c5", "patch": "@@ -1,47 +0,0 @@\n-# Linenoise\n-\n-A minimal, zero-config, BSD licensed, readline replacement.\n-\n-News: linenoise now includes minimal completion support, thanks to Pieter Noordhuis (@pnoordhuis).\n-\n-News: linenoise is now part of [Android](http://android.git.kernel.org/?p=platform/system/core.git;a=tree;f=liblinenoise;h=56450eaed7f783760e5e6a5993ef75cde2e29dea;hb=HEAD Android)!\n-\n-## Can a line editing library be 20k lines of code?\n-\n-Line editing with some support for history is a really important feature for command line utilities. Instead of retyping almost the same stuff again and again it's just much better to hit the up arrow and edit on syntax errors, or in order to try a slightly different command. But apparently code dealing with terminals is some sort of Black Magic: readline is 30k lines of code, libedit 20k. Is it reasonable to link small utilities to huge libraries just to get a minimal support for line editing?\n-\n-So what usually happens is either:\n-\n- * Large programs with configure scripts disabling line editing if readline is not present in the system, or not supporting it at all since readline is GPL licensed and libedit (the BSD clone) is not as known and available as readline is (Real world example of this problem: Tclsh).\n- * Smaller programs not using a configure script not supporting line editing at all (A problem we had with Redis-cli for instance).\n- \n-The result is a pollution of binaries without line editing support.\n-\n-So I spent more or less two hours doing a reality check resulting in this little library: is it *really* needed for a line editing library to be 20k lines of code? Apparently not, it is possibe to get a very small, zero configuration, trivial to embed library, that solves the problem. Smaller programs will just include this, supporing line editing out of the box. Larger programs may use this little library or just checking with configure if readline/libedit is available and resorting to linenoise if not.\n-\n-## Terminals, in 2010.\n-\n-Apparently almost every terminal you can happen to use today has some kind of support for VT100 alike escape sequences. So I tried to write a lib using just very basic VT100 features. The resulting library appears to work everywhere I tried to use it.\n-\n-Since it's so young I guess there are a few bugs, or the lib may not compile or work with some operating system, but it's a matter of a few weeks and eventually we'll get it right, and there will be no excuses for not shipping command line tools without built-in line editing support.\n-\n-The library is currently less than 400 lines of code. In order to use it in your project just look at the *example.c* file in the source distribution, it is trivial. Linenoise is BSD code, so you can use both in free software and commercial software.\n-\n-## Tested with...\n-\n- * Linux text only console ($TERM = linux)\n- * Linux KDE terminal application ($TERM = xterm)\n- * Linux xterm ($TERM = xterm)\n- * Mac OS X iTerm ($TERM = xterm)\n- * Mac OS X default Terminal.app ($TERM = xterm)\n- * OpenBSD 4.5 through an OSX Terminal.app ($TERM = screen)\n- * IBM AIX 6.1\n- * FreeBSD xterm ($TERM = xterm)\n-\n-Please test it everywhere you can and report back!\n-\n-## Let's push this forward!\n-\n-Please fork it and add something interesting and send me a pull request. What's especially interesting are fixes, new key bindings, completion.\n-\n-Send feedbacks to antirez at gmail"}, {"sha": "cb51a0af8f9259eca7504261e63bb35627f3cc5c", "filename": "src/rt/linenoise/example.c", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/00adcf0bdd9376046859b7bc0d79097b621844c5/src%2Frt%2Flinenoise%2Fexample.c", "raw_url": "https://github.com/rust-lang/rust/raw/00adcf0bdd9376046859b7bc0d79097b621844c5/src%2Frt%2Flinenoise%2Fexample.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flinenoise%2Fexample.c?ref=00adcf0bdd9376046859b7bc0d79097b621844c5", "patch": "@@ -1,30 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include \"linenoise.h\"\n-\n-#ifndef NO_COMPLETION\n-void completion(const char *buf, linenoiseCompletions *lc) {\n-    if (buf[0] == 'h') {\n-        linenoiseAddCompletion(lc,\"hello\");\n-        linenoiseAddCompletion(lc,\"hello there\");\n-    }\n-}\n-#endif\n-\n-int main(void) {\n-    char *line;\n-\n-#ifndef NO_COMPLETION\n-    linenoiseSetCompletionCallback(completion);\n-#endif\n-    linenoiseHistoryLoad(\"history.txt\"); /* Load the history at startup */\n-    while((line = linenoise(\"hello> \")) != NULL) {\n-        if (line[0] != '\\0') {\n-            printf(\"echo: '%s'\\n\", line);\n-            linenoiseHistoryAdd(line);\n-            linenoiseHistorySave(\"history.txt\"); /* Save every new entry */\n-        }\n-        free(line);\n-    }\n-    return 0;\n-}"}, {"sha": "0ce4d559bed99619894735c9ee7c8aee07b0e4ca", "filename": "src/rt/linenoise/linenoise.c", "status": "removed", "additions": 0, "deletions": 1581, "changes": 1581, "blob_url": "https://github.com/rust-lang/rust/blob/00adcf0bdd9376046859b7bc0d79097b621844c5/src%2Frt%2Flinenoise%2Flinenoise.c", "raw_url": "https://github.com/rust-lang/rust/raw/00adcf0bdd9376046859b7bc0d79097b621844c5/src%2Frt%2Flinenoise%2Flinenoise.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flinenoise%2Flinenoise.c?ref=00adcf0bdd9376046859b7bc0d79097b621844c5", "patch": "@@ -1,1581 +0,0 @@\n-/* linenoise.c -- guerrilla line editing library against the idea that a\n- * line editing lib needs to be 20,000 lines of C code.\n- *\n- * You can find the latest source code at:\n- *\n- *   http://github.com/msteveb/linenoise\n- *   (forked from http://github.com/antirez/linenoise)\n- *\n- * Does a number of crazy assumptions that happen to be true in 99.9999% of\n- * the 2010 UNIX computers around.\n- *\n- * ------------------------------------------------------------------------\n- *\n- * Copyright (c) 2010, Salvatore Sanfilippo <antirez at gmail dot com>\n- * Copyright (c) 2010, Pieter Noordhuis <pcnoordhuis at gmail dot com>\n- * Copyright (c) 2011, Steve Bennett <steveb at workware dot net dot au>\n- *\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions are\n- * met:\n- *\n- *  *  Redistributions of source code must retain the above copyright\n- *     notice, this list of conditions and the following disclaimer.\n- *\n- *  *  Redistributions in binary form must reproduce the above copyright\n- *     notice, this list of conditions and the following disclaimer in the\n- *     documentation and/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n- * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\n- * ------------------------------------------------------------------------\n- *\n- * References:\n- * - http://invisible-island.net/xterm/ctlseqs/ctlseqs.html\n- * - http://www.3waylabs.com/nw/WWW/products/wizcon/vt220.html\n- *\n- * Bloat:\n- * - Completion?\n- *\n- * Unix/termios\n- * ------------\n- * List of escape sequences used by this program, we do everything just\n- * a few sequences. In order to be so cheap we may have some\n- * flickering effect with some slow terminal, but the lesser sequences\n- * the more compatible.\n- *\n- * EL (Erase Line)\n- *    Sequence: ESC [ n K\n- *    Effect: if n is 0 or missing, clear from cursor to end of line\n- *    Effect: if n is 1, clear from beginning of line to cursor\n- *    Effect: if n is 2, clear entire line\n- *\n- * CUF (CUrsor Forward)\n- *    Sequence: ESC [ n C\n- *    Effect: moves cursor forward of n chars\n- *\n- * CR (Carriage Return)\n- *    Sequence: \\r\n- *    Effect: moves cursor to column 1\n- *\n- * The following are used to clear the screen: ESC [ H ESC [ 2 J\n- * This is actually composed of two sequences:\n- *\n- * cursorhome\n- *    Sequence: ESC [ H\n- *    Effect: moves the cursor to upper left corner\n- *\n- * ED2 (Clear entire screen)\n- *    Sequence: ESC [ 2 J\n- *    Effect: clear the whole screen\n- *\n- * == For highlighting control characters, we also use the following two ==\n- * SO (enter StandOut)\n- *    Sequence: ESC [ 7 m\n- *    Effect: Uses some standout mode such as reverse video\n- *\n- * SE (Standout End)\n- *    Sequence: ESC [ 0 m\n- *    Effect: Exit standout mode\n- *\n- * == Only used if TIOCGWINSZ fails ==\n- * DSR/CPR (Report cursor position)\n- *    Sequence: ESC [ 6 n\n- *    Effect: reports current cursor position as ESC [ NNN ; MMM R\n- *\n- * win32/console\n- * -------------\n- * If __MINGW32__ is defined, the win32 console API is used.\n- * This could probably be made to work for the msvc compiler too.\n- * This support based in part on work by Jon Griffiths.\n- */\n-\n-#ifdef _WIN32 /* Windows platform, either MinGW or Visual Studio (MSVC) */\n-#include <windows.h>\n-#include <fcntl.h>\n-#define USE_WINCONSOLE\n-#ifdef __MINGW32__\n-#define HAVE_UNISTD_H\n-#else\n-/* Microsoft headers don't like old POSIX names */\n-#define strdup _strdup\n-#define snprintf _snprintf\n-#endif\n-#else\n-#include <termios.h>\n-#include <sys/ioctl.h>\n-#include <sys/poll.h>\n-#define USE_TERMIOS\n-#define HAVE_UNISTD_H\n-#endif\n-\n-#ifdef HAVE_UNISTD_H\n-#include <unistd.h>\n-#endif\n-#include <stdlib.h>\n-#include <stdarg.h>\n-#include <stdio.h>\n-#include <errno.h>\n-#include <string.h>\n-#include <stdlib.h>\n-#include <sys/types.h>\n-\n-#include \"linenoise.h\"\n-#include \"utf8.h\"\n-\n-#define LINENOISE_DEFAULT_HISTORY_MAX_LEN 100\n-#define LINENOISE_MAX_LINE 4096\n-\n-#define ctrl(C) ((C) - '@')\n-\n-/* Use -ve numbers here to co-exist with normal unicode chars */\n-enum {\n-    SPECIAL_NONE,\n-    SPECIAL_UP = -20,\n-    SPECIAL_DOWN = -21,\n-    SPECIAL_LEFT = -22,\n-    SPECIAL_RIGHT = -23,\n-    SPECIAL_DELETE = -24,\n-    SPECIAL_HOME = -25,\n-    SPECIAL_END = -26,\n-    SPECIAL_INSERT = -27,\n-    SPECIAL_PAGE_UP = -28,\n-    SPECIAL_PAGE_DOWN = -29\n-};\n-\n-static int history_max_len = LINENOISE_DEFAULT_HISTORY_MAX_LEN;\n-static int history_len = 0;\n-static char **history = NULL;\n-\n-/* Structure to contain the status of the current (being edited) line */\n-struct current {\n-    char *buf;  /* Current buffer. Always null terminated */\n-    int bufmax; /* Size of the buffer, including space for the null termination */\n-    int len;    /* Number of bytes in 'buf' */\n-    int chars;  /* Number of chars in 'buf' (utf-8 chars) */\n-    int pos;    /* Cursor position, measured in chars */\n-    int cols;   /* Size of the window, in chars */\n-    const char *prompt;\n-    char *capture; /* Allocated capture buffer, or NULL for none. Always null terminated */\n-#if defined(USE_TERMIOS)\n-    int fd;     /* Terminal fd */\n-#elif defined(USE_WINCONSOLE)\n-    HANDLE outh; /* Console output handle */\n-    HANDLE inh; /* Console input handle */\n-    int rows;   /* Screen rows */\n-    int x;      /* Current column during output */\n-    int y;      /* Current row */\n-#endif\n-};\n-\n-static int fd_read(struct current *current);\n-static int getWindowSize(struct current *current);\n-\n-void linenoiseHistoryFree(void) {\n-    if (history) {\n-        int j;\n-\n-        for (j = 0; j < history_len; j++)\n-            free(history[j]);\n-        free(history);\n-        history = NULL;\n-        history_len = 0;\n-    }\n-}\n-\n-#if defined(USE_TERMIOS)\n-static void linenoiseAtExit(void);\n-static struct termios orig_termios; /* in order to restore at exit */\n-static int rawmode = 0; /* for atexit() function to check if restore is needed*/\n-static int atexit_registered = 0; /* register atexit just 1 time */\n-\n-static const char *unsupported_term[] = {\"dumb\",\"cons25\",NULL};\n-\n-static int isUnsupportedTerm(void) {\n-    char *term = getenv(\"TERM\");\n-\n-    if (term) {\n-        int j;\n-        for (j = 0; unsupported_term[j]; j++) {\n-            if (strcasecmp(term, unsupported_term[j]) == 0) {\n-                return 1;\n-            }\n-        }\n-    }\n-    return 0;\n-}\n-\n-static int enableRawMode(struct current *current) {\n-    struct termios raw;\n-\n-    current->fd = STDIN_FILENO;\n-\n-    if (!isatty(current->fd) || isUnsupportedTerm() ||\n-        tcgetattr(current->fd, &orig_termios) == -1) {\n-fatal:\n-        errno = ENOTTY;\n-        return -1;\n-    }\n-\n-    if (!atexit_registered) {\n-        atexit(linenoiseAtExit);\n-        atexit_registered = 1;\n-    }\n-\n-    raw = orig_termios;  /* modify the original mode */\n-    /* input modes: no break, no CR to NL, no parity check, no strip char,\n-     * no start/stop output control. */\n-    raw.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);\n-    /* output modes - disable post processing */\n-    raw.c_oflag &= ~(OPOST);\n-    /* control modes - set 8 bit chars */\n-    raw.c_cflag |= (CS8);\n-    /* local modes - choing off, canonical off, no extended functions,\n-     * no signal chars (^Z,^C) */\n-    raw.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);\n-    /* control chars - set return condition: min number of bytes and timer.\n-     * We want read to return every single byte, without timeout. */\n-    raw.c_cc[VMIN] = 1; raw.c_cc[VTIME] = 0; /* 1 byte, no timer */\n-\n-    /* put terminal in raw mode after flushing */\n-    if (tcsetattr(current->fd,TCSADRAIN,&raw) < 0) {\n-        goto fatal;\n-    }\n-    rawmode = 1;\n-\n-    current->cols = 0;\n-    return 0;\n-}\n-\n-static void disableRawMode(struct current *current) {\n-    /* Don't even check the return value as it's too late. */\n-    if (rawmode && tcsetattr(current->fd,TCSADRAIN,&orig_termios) != -1)\n-        rawmode = 0;\n-}\n-\n-/* At exit we'll try to fix the terminal to the initial conditions. */\n-static void linenoiseAtExit(void) {\n-    if (rawmode) {\n-        tcsetattr(STDIN_FILENO, TCSADRAIN, &orig_termios);\n-    }\n-    linenoiseHistoryFree();\n-}\n-\n-/* gcc/glibc insists that we care about the return code of write!\n- * Clarification: This means that a void-cast like \"(void) (EXPR)\"\n- * does not work.\n- */\n-#define IGNORE_RC(EXPR) if (EXPR) {}\n-\n-/* This is fdprintf() on some systems, but use a different\n- * name to avoid conflicts\n- */\n-static void fd_printf(int fd, const char *format, ...)\n-{\n-    va_list args;\n-    char buf[64];\n-    int n;\n-\n-    va_start(args, format);\n-    n = vsnprintf(buf, sizeof(buf), format, args);\n-    va_end(args);\n-    IGNORE_RC(write(fd, buf, n));\n-}\n-\n-static void clearScreen(struct current *current)\n-{\n-    fd_printf(current->fd, \"\\x1b[H\\x1b[2J\");\n-}\n-\n-static void cursorToLeft(struct current *current)\n-{\n-    fd_printf(current->fd, \"\\r\");\n-}\n-\n-static int outputChars(struct current *current, const char *buf, int len)\n-{\n-    return write(current->fd, buf, len);\n-}\n-\n-static void outputControlChar(struct current *current, char ch)\n-{\n-    fd_printf(current->fd, \"\\x1b[7m^%c\\x1b[0m\", ch);\n-}\n-\n-static void eraseEol(struct current *current)\n-{\n-    fd_printf(current->fd, \"\\x1b[0K\");\n-}\n-\n-static void setCursorPos(struct current *current, int x)\n-{\n-    fd_printf(current->fd, \"\\r\\x1b[%dC\", x);\n-}\n-\n-/**\n- * Reads a char from 'fd', waiting at most 'timeout' milliseconds.\n- *\n- * A timeout of -1 means to wait forever.\n- *\n- * Returns -1 if no char is received within the time or an error occurs.\n- */\n-static int fd_read_char(int fd, int timeout)\n-{\n-    struct pollfd p;\n-    unsigned char c;\n-\n-    p.fd = fd;\n-    p.events = POLLIN;\n-\n-    if (poll(&p, 1, timeout) == 0) {\n-        /* timeout */\n-        return -1;\n-    }\n-    if (read(fd, &c, 1) != 1) {\n-        return -1;\n-    }\n-    return c;\n-}\n-\n-/**\n- * Reads a complete utf-8 character\n- * and returns the unicode value, or -1 on error.\n- */\n-static int fd_read(struct current *current)\n-{\n-#ifdef USE_UTF8\n-    char buf[4];\n-    int n;\n-    int i;\n-    int c;\n-\n-    if (read(current->fd, &buf[0], 1) != 1) {\n-        return -1;\n-    }\n-    n = utf8_charlen(buf[0]);\n-    if (n < 1 || n > 3) {\n-        return -1;\n-    }\n-    for (i = 1; i < n; i++) {\n-        if (read(current->fd, &buf[i], 1) != 1) {\n-            return -1;\n-        }\n-    }\n-    buf[n] = 0;\n-    /* decode and return the character */\n-    utf8_tounicode(buf, &c);\n-    return c;\n-#else\n-    return fd_read_char(current->fd, -1);\n-#endif\n-}\n-\n-static int countColorControlChars(const char* prompt, int plen)\n-{\n-    /* ANSI color control sequences have the form:\n-     * \"\\x1b\" \"[\" [0-9;]+ \"m\"\n-     * We parse them with a simple state machine.\n-     */\n-\n-    enum {\n-        search_esc,\n-        expect_bracket,\n-        expect_inner,\n-        expect_trail\n-    } state = search_esc;\n-    int len = 0, found = 0;\n-    char ch;\n-\n-    /* XXX: Strictly we should be checking utf8 chars rather than\n-     *      bytes in case of the extremely unlikely scenario where\n-     *      an ANSI sequence is part of a utf8 sequence.\n-     */\n-    for (; plen ; plen--, prompt++) {\n-        ch = *prompt;\n-\n-        switch (state) {\n-        case search_esc:\n-            len = 0;\n-            if (ch == '\\x1b') {\n-                state = expect_bracket;\n-                len++;\n-            }\n-            break;\n-        case expect_bracket:\n-            if (ch == '[') {\n-                state = expect_inner;\n-                len++;\n-            } else {\n-                state = search_esc;\n-            }\n-            break;\n-        case expect_inner:\n-            if (ch >= '0' && ch <= '9') {\n-                len++;\n-                state = expect_trail;\n-            } else {\n-                state = search_esc;\n-            }\n-            break;\n-        case expect_trail:\n-            if (ch == 'm') {\n-                len++;\n-                found += len;\n-                state = search_esc;\n-            } else if ((ch != ';') && ((ch < '0') || (ch > '9'))) {\n-                state = search_esc;\n-            }\n-            /* 0-9, or semicolon */\n-            len++;\n-            break;\n-        }\n-    }\n-\n-    return found;\n-}\n-\n-static int getWindowSize(struct current *current)\n-{\n-    struct winsize ws;\n-\n-    if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) == 0 && ws.ws_col != 0) {\n-        current->cols = ws.ws_col;\n-        return 0;\n-    }\n-\n-    /* Failed to query the window size. Perhaps we are on a serial terminal.\n-     * Try to query the width by sending the cursor as far to the right\n-     * and reading back the cursor position.\n-     * Note that this is only done once per call to linenoise rather than\n-     * every time the line is refreshed for efficiency reasons.\n-     */\n-    if (current->cols == 0) {\n-        current->cols = 80;\n-\n-        /* Move cursor far right and report cursor position, then back to the left */\n-        fd_printf(current->fd, \"\\x1b[999C\" \"\\x1b[6n\");\n-\n-        /* Parse the response: ESC [ rows ; cols R */\n-        if (fd_read_char(current->fd, 100) == 0x1b && fd_read_char(current->fd, 100) == '[') {\n-            int n = 0;\n-            while (1) {\n-                int ch = fd_read_char(current->fd, 100);\n-                if (ch == ';') {\n-                    /* Ignore rows */\n-                    n = 0;\n-                }\n-                else if (ch == 'R') {\n-                    /* Got cols */\n-                    if (n != 0 && n < 1000) {\n-                        current->cols = n;\n-                    }\n-                    break;\n-                }\n-                else if (ch >= 0 && ch <= '9') {\n-                    n = n * 10 + ch - '0';\n-                }\n-                else {\n-                    break;\n-                }\n-            }\n-        }\n-    }\n-    return 0;\n-}\n-\n-/**\n- * If escape (27) was received, reads subsequent\n- * chars to determine if this is a known special key.\n- *\n- * Returns SPECIAL_NONE if unrecognised, or -1 if EOF.\n- *\n- * If no additional char is received within a short time,\n- * 27 is returned.\n- */\n-static int check_special(int fd)\n-{\n-    int c = fd_read_char(fd, 50);\n-    int c2;\n-\n-    if (c < 0) {\n-        return 27;\n-    }\n-\n-    c2 = fd_read_char(fd, 50);\n-    if (c2 < 0) {\n-        return c2;\n-    }\n-    if (c == '[' || c == 'O') {\n-        /* Potential arrow key */\n-        switch (c2) {\n-            case 'A':\n-                return SPECIAL_UP;\n-            case 'B':\n-                return SPECIAL_DOWN;\n-            case 'C':\n-                return SPECIAL_RIGHT;\n-            case 'D':\n-                return SPECIAL_LEFT;\n-            case 'F':\n-                return SPECIAL_END;\n-            case 'H':\n-                return SPECIAL_HOME;\n-        }\n-    }\n-    if (c == '[' && c2 >= '1' && c2 <= '8') {\n-        /* extended escape */\n-        c = fd_read_char(fd, 50);\n-        if (c == '~') {\n-            switch (c2) {\n-                case '2':\n-                    return SPECIAL_INSERT;\n-                case '3':\n-                    return SPECIAL_DELETE;\n-                case '5':\n-                    return SPECIAL_PAGE_UP;\n-                case '6':\n-                    return SPECIAL_PAGE_DOWN;\n-                case '7':\n-                    return SPECIAL_HOME;\n-                case '8':\n-                    return SPECIAL_END;\n-            }\n-        }\n-        while (c != -1 && c != '~') {\n-            /* .e.g \\e[12~ or '\\e[11;2~   discard the complete sequence */\n-            c = fd_read_char(fd, 50);\n-        }\n-    }\n-\n-    return SPECIAL_NONE;\n-}\n-#elif defined(USE_WINCONSOLE)\n-\n-static DWORD orig_consolemode = 0;\n-\n-static int enableRawMode(struct current *current) {\n-    DWORD n;\n-    INPUT_RECORD irec;\n-\n-    current->outh = GetStdHandle(STD_OUTPUT_HANDLE);\n-    current->inh = GetStdHandle(STD_INPUT_HANDLE);\n-\n-    if (!PeekConsoleInput(current->inh, &irec, 1, &n)) {\n-        return -1;\n-    }\n-    if (getWindowSize(current) != 0) {\n-        return -1;\n-    }\n-    if (GetConsoleMode(current->inh, &orig_consolemode)) {\n-        SetConsoleMode(current->inh, ENABLE_PROCESSED_INPUT);\n-    }\n-    return 0;\n-}\n-\n-static void disableRawMode(struct current *current)\n-{\n-    SetConsoleMode(current->inh, orig_consolemode);\n-}\n-\n-static void clearScreen(struct current *current)\n-{\n-    COORD topleft = { 0, 0 };\n-    DWORD n;\n-\n-    FillConsoleOutputCharacter(current->outh, ' ',\n-        current->cols * current->rows, topleft, &n);\n-    FillConsoleOutputAttribute(current->outh,\n-        FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_GREEN,\n-        current->cols * current->rows, topleft, &n);\n-    SetConsoleCursorPosition(current->outh, topleft);\n-}\n-\n-static void cursorToLeft(struct current *current)\n-{\n-    COORD pos = { 0, (SHORT)current->y };\n-    DWORD n;\n-\n-    FillConsoleOutputAttribute(current->outh,\n-        FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_GREEN, current->cols, pos, &n);\n-    current->x = 0;\n-}\n-\n-static int outputChars(struct current *current, const char *buf, int len)\n-{\n-    COORD pos = { (SHORT)current->x, (SHORT)current->y };\n-    DWORD n;\n-\n-    WriteConsoleOutputCharacter(current->outh, buf, len, pos, &n);\n-    current->x += len;\n-    return 0;\n-}\n-\n-static void outputControlChar(struct current *current, char ch)\n-{\n-    COORD pos = { (SHORT)current->x, (SHORT)current->y };\n-    DWORD n;\n-\n-    FillConsoleOutputAttribute(current->outh, BACKGROUND_INTENSITY, 2, pos, &n);\n-    outputChars(current, \"^\", 1);\n-    outputChars(current, &ch, 1);\n-}\n-\n-static void eraseEol(struct current *current)\n-{\n-    COORD pos = { (SHORT)current->x, (SHORT)current->y };\n-    DWORD n;\n-\n-    FillConsoleOutputCharacter(current->outh, ' ', current->cols - current->x, pos, &n);\n-}\n-\n-static void setCursorPos(struct current *current, int x)\n-{\n-    COORD pos = { (SHORT)x, (SHORT)current->y };\n-\n-    SetConsoleCursorPosition(current->outh, pos);\n-    current->x = x;\n-}\n-\n-static int fd_read(struct current *current)\n-{\n-    while (1) {\n-        INPUT_RECORD irec;\n-        DWORD n;\n-        if (WaitForSingleObject(current->inh, INFINITE) != WAIT_OBJECT_0) {\n-            break;\n-        }\n-        if (!ReadConsoleInput (current->inh, &irec, 1, &n)) {\n-            break;\n-        }\n-        if (irec.EventType == KEY_EVENT && irec.Event.KeyEvent.bKeyDown) {\n-            KEY_EVENT_RECORD *k = &irec.Event.KeyEvent;\n-            if (k->dwControlKeyState & ENHANCED_KEY) {\n-                switch (k->wVirtualKeyCode) {\n-                 case VK_LEFT:\n-                    return SPECIAL_LEFT;\n-                 case VK_RIGHT:\n-                    return SPECIAL_RIGHT;\n-                 case VK_UP:\n-                    return SPECIAL_UP;\n-                 case VK_DOWN:\n-                    return SPECIAL_DOWN;\n-                 case VK_INSERT:\n-                    return SPECIAL_INSERT;\n-                 case VK_DELETE:\n-                    return SPECIAL_DELETE;\n-                 case VK_HOME:\n-                    return SPECIAL_HOME;\n-                 case VK_END:\n-                    return SPECIAL_END;\n-                 case VK_PRIOR:\n-                    return SPECIAL_PAGE_UP;\n-                 case VK_NEXT:\n-                    return SPECIAL_PAGE_DOWN;\n-                }\n-            }\n-            /* Note that control characters are already translated in AsciiChar */\n-            else {\n-#ifdef USE_UTF8\n-                return k->uChar.UnicodeChar;\n-#else\n-                return k->uChar.AsciiChar;\n-#endif\n-            }\n-        }\n-    }\n-    return -1;\n-}\n-\n-static int countColorControlChars(const char* prompt, int plen)\n-{\n-    /* For windows we assume that there are no embedded ansi color\n-     * control sequences.\n-     */\n-    return 0;\n-}\n-\n-static int getWindowSize(struct current *current)\n-{\n-    CONSOLE_SCREEN_BUFFER_INFO info;\n-    if (!GetConsoleScreenBufferInfo(current->outh, &info)) {\n-        return -1;\n-    }\n-    current->cols = info.dwSize.X;\n-    current->rows = info.dwSize.Y;\n-    if (current->cols <= 0 || current->rows <= 0) {\n-        current->cols = 80;\n-        return -1;\n-    }\n-    current->y = info.dwCursorPosition.Y;\n-    current->x = info.dwCursorPosition.X;\n-    return 0;\n-}\n-#endif\n-\n-static int utf8_getchars(char *buf, int c)\n-{\n-#ifdef USE_UTF8\n-    return utf8_fromunicode(buf, c);\n-#else\n-    *buf = c;\n-    return 1;\n-#endif\n-}\n-\n-/**\n- * Returns the unicode character at the given offset,\n- * or -1 if none.\n- */\n-static int get_char(struct current *current, int pos)\n-{\n-    if (pos >= 0 && pos < current->chars) {\n-        int c;\n-        int i = utf8_index(current->buf, pos);\n-        (void)utf8_tounicode(current->buf + i, &c);\n-        return c;\n-    }\n-    return -1;\n-}\n-\n-static void refreshLine(const char *prompt, struct current *current)\n-{\n-    int plen;\n-    int pchars;\n-    int backup = 0;\n-    int i;\n-    const char *buf = current->buf;\n-    int chars = current->chars;\n-    int pos = current->pos;\n-    int b;\n-    int ch;\n-    int n;\n-\n-    /* Should intercept SIGWINCH. For now, just get the size every time */\n-    getWindowSize(current);\n-\n-    plen = strlen(prompt);\n-    pchars = utf8_strlen(prompt, plen);\n-\n-    /* Scan the prompt for embedded ansi color control sequences and\n-     * discount them as characters/columns.\n-     */\n-    pchars -= countColorControlChars(prompt, plen);\n-\n-    /* Account for a line which is too long to fit in the window.\n-     * Note that control chars require an extra column\n-     */\n-\n-    /* How many cols are required to the left of 'pos'?\n-     * The prompt, plus one extra for each control char\n-     */\n-    n = pchars + utf8_strlen(buf, current->len);\n-    b = 0;\n-    for (i = 0; i < pos; i++) {\n-        b += utf8_tounicode(buf + b, &ch);\n-        if (ch < ' ') {\n-            n++;\n-        }\n-    }\n-\n-    /* If too many are needed, strip chars off the front of 'buf'\n-     * until it fits. Note that if the current char is a control character,\n-     * we need one extra col.\n-     */\n-    if (current->pos < current->chars && get_char(current, current->pos) < ' ') {\n-        n++;\n-    }\n-\n-    while (n >= current->cols && pos > 0) {\n-        b = utf8_tounicode(buf, &ch);\n-        if (ch < ' ') {\n-            n--;\n-        }\n-        n--;\n-        buf += b;\n-        pos--;\n-        chars--;\n-    }\n-\n-    /* Cursor to left edge, then the prompt */\n-    cursorToLeft(current);\n-    outputChars(current, prompt, plen);\n-\n-    /* Now the current buffer content */\n-\n-    /* Need special handling for control characters.\n-     * If we hit 'cols', stop.\n-     */\n-    b = 0; /* unwritted bytes */\n-    n = 0; /* How many control chars were written */\n-    for (i = 0; i < chars; i++) {\n-        int ch;\n-        int w = utf8_tounicode(buf + b, &ch);\n-        if (ch < ' ') {\n-            n++;\n-        }\n-        if (pchars + i + n >= current->cols) {\n-            break;\n-        }\n-        if (ch < ' ') {\n-            /* A control character, so write the buffer so far */\n-            outputChars(current, buf, b);\n-            buf += b + w;\n-            b = 0;\n-            outputControlChar(current, ch + '@');\n-            if (i < pos) {\n-                backup++;\n-            }\n-        }\n-        else {\n-            b += w;\n-        }\n-    }\n-    outputChars(current, buf, b);\n-\n-    /* Erase to right, move cursor to original position */\n-    eraseEol(current);\n-    setCursorPos(current, pos + pchars + backup);\n-}\n-\n-static void set_current(struct current *current, const char *str)\n-{\n-    strncpy(current->buf, str, current->bufmax);\n-    current->buf[current->bufmax - 1] = 0;\n-    current->len = strlen(current->buf);\n-    current->pos = current->chars = utf8_strlen(current->buf, current->len);\n-}\n-\n-static int has_room(struct current *current, int bytes)\n-{\n-    return current->len + bytes < current->bufmax - 1;\n-}\n-\n-/**\n- * Removes the char at 'pos'.\n- *\n- * Returns 1 if the line needs to be refreshed, 2 if not\n- * and 0 if nothing was removed\n- */\n-static int remove_char(struct current *current, int pos)\n-{\n-    if (pos >= 0 && pos < current->chars) {\n-        int p1, p2;\n-        int ret = 1;\n-        p1 = utf8_index(current->buf, pos);\n-        p2 = p1 + utf8_index(current->buf + p1, 1);\n-\n-#ifdef USE_TERMIOS\n-        /* optimise remove char in the case of removing the last char */\n-        if (current->pos == pos + 1 && current->pos == current->chars) {\n-            if (current->buf[pos] >= ' ' && utf8_strlen(current->prompt, -1) + utf8_strlen(current->buf, current->len) < current->cols - 1) {\n-                ret = 2;\n-                fd_printf(current->fd, \"\\b \\b\");\n-            }\n-        }\n-#endif\n-\n-        /* Move the null char too */\n-        memmove(current->buf + p1, current->buf + p2, current->len - p2 + 1);\n-        current->len -= (p2 - p1);\n-        current->chars--;\n-\n-        if (current->pos > pos) {\n-            current->pos--;\n-        }\n-        return ret;\n-    }\n-    return 0;\n-}\n-\n-/**\n- * Insert 'ch' at position 'pos'\n- *\n- * Returns 1 if the line needs to be refreshed, 2 if not\n- * and 0 if nothing was inserted (no room)\n- */\n-static int insert_char(struct current *current, int pos, int ch)\n-{\n-    char buf[3];\n-    int n = utf8_getchars(buf, ch);\n-\n-    if (has_room(current, n) && pos >= 0 && pos <= current->chars) {\n-        int p1, p2;\n-        int ret = 1;\n-        p1 = utf8_index(current->buf, pos);\n-        p2 = p1 + n;\n-\n-#ifdef USE_TERMIOS\n-        /* optimise the case where adding a single char to the end and no scrolling is needed */\n-        if (current->pos == pos && current->chars == pos) {\n-            if (ch >= ' ' && utf8_strlen(current->prompt, -1) + utf8_strlen(current->buf, current->len) < current->cols - 1) {\n-                IGNORE_RC(write(current->fd, buf, n));\n-                ret = 2;\n-            }\n-        }\n-#endif\n-\n-        memmove(current->buf + p2, current->buf + p1, current->len - p1);\n-        memcpy(current->buf + p1, buf, n);\n-        current->len += n;\n-\n-        current->chars++;\n-        if (current->pos >= pos) {\n-            current->pos++;\n-        }\n-        return ret;\n-    }\n-    return 0;\n-}\n-\n-/**\n- * Captures up to 'n' characters starting at 'pos' for the cut buffer.\n- *\n- * This replaces any existing characters in the cut buffer.\n- */\n-static void capture_chars(struct current *current, int pos, int n)\n-{\n-    if (pos >= 0 && (pos + n - 1) < current->chars) {\n-        int p1 = utf8_index(current->buf, pos);\n-        int nbytes = utf8_index(current->buf + p1, n);\n-\n-        if (nbytes) {\n-            free(current->capture);\n-            /* Include space for the null terminator */\n-            current->capture = (char *)malloc(nbytes + 1);\n-            memcpy(current->capture, current->buf + p1, nbytes);\n-            current->capture[nbytes] = '\\0';\n-        }\n-    }\n-}\n-\n-/**\n- * Removes up to 'n' characters at cursor position 'pos'.\n- *\n- * Returns 0 if no chars were removed or non-zero otherwise.\n- */\n-static int remove_chars(struct current *current, int pos, int n)\n-{\n-    int removed = 0;\n-\n-    /* First save any chars which will be removed */\n-    capture_chars(current, pos, n);\n-\n-    while (n-- && remove_char(current, pos)) {\n-        removed++;\n-    }\n-    return removed;\n-}\n-/**\n- * Inserts the characters (string) 'chars' at the cursor position 'pos'.\n- *\n- * Returns 0 if no chars were inserted or non-zero otherwise.\n- */\n-static int insert_chars(struct current *current, int pos, const char *chars)\n-{\n-    int inserted = 0;\n-\n-    while (*chars) {\n-        int ch;\n-        int n = utf8_tounicode(chars, &ch);\n-        if (insert_char(current, pos, ch) == 0) {\n-            break;\n-        }\n-        inserted++;\n-        pos++;\n-        chars += n;\n-    }\n-    return inserted;\n-}\n-\n-#ifndef NO_COMPLETION\n-static linenoiseCompletionCallback *completionCallback = NULL;\n-\n-static void beep() {\n-#ifdef USE_TERMIOS\n-    fprintf(stderr, \"\\x7\");\n-    fflush(stderr);\n-#endif\n-}\n-\n-static void freeCompletions(linenoiseCompletions *lc) {\n-    size_t i;\n-    for (i = 0; i < lc->len; i++)\n-        free(lc->cvec[i]);\n-    free(lc->cvec);\n-}\n-\n-static int completeLine(struct current *current) {\n-    linenoiseCompletions lc = { 0, NULL };\n-    int c = 0;\n-\n-    completionCallback(current->buf,&lc);\n-    if (lc.len == 0) {\n-        beep();\n-    } else {\n-        size_t stop = 0, i = 0;\n-\n-        while(!stop) {\n-            /* Show completion or original buffer */\n-            if (i < lc.len) {\n-                struct current tmp = *current;\n-                tmp.buf = lc.cvec[i];\n-                tmp.pos = tmp.len = strlen(tmp.buf);\n-                tmp.chars = utf8_strlen(tmp.buf, tmp.len);\n-                refreshLine(current->prompt, &tmp);\n-            } else {\n-                refreshLine(current->prompt, current);\n-            }\n-\n-            c = fd_read(current);\n-            if (c == -1) {\n-                break;\n-            }\n-\n-            switch(c) {\n-                case '\\t': /* tab */\n-                    i = (i+1) % (lc.len+1);\n-                    if (i == lc.len) beep();\n-                    break;\n-                case 27: /* escape */\n-                    /* Re-show original buffer */\n-                    if (i < lc.len) {\n-                        refreshLine(current->prompt, current);\n-                    }\n-                    stop = 1;\n-                    break;\n-                default:\n-                    /* Update buffer and return */\n-                    if (i < lc.len) {\n-                        set_current(current,lc.cvec[i]);\n-                    }\n-                    stop = 1;\n-                    break;\n-            }\n-        }\n-    }\n-\n-    freeCompletions(&lc);\n-    return c; /* Return last read character */\n-}\n-\n-/* Register a callback function to be called for tab-completion. */\n-void linenoiseSetCompletionCallback(linenoiseCompletionCallback *fn) {\n-    completionCallback = fn;\n-}\n-\n-void linenoiseAddCompletion(linenoiseCompletions *lc, const char *str) {\n-    lc->cvec = (char **)realloc(lc->cvec,sizeof(char*)*(lc->len+1));\n-    lc->cvec[lc->len++] = strdup(str);\n-}\n-\n-#endif\n-\n-static int linenoiseEdit(struct current *current) {\n-    int history_index = 0;\n-\n-    /* The latest history entry is always our current buffer, that\n-     * initially is just an empty string. */\n-    linenoiseHistoryAdd(\"\");\n-\n-    set_current(current, \"\");\n-    refreshLine(current->prompt, current);\n-\n-    while(1) {\n-        int dir = -1;\n-        int c = fd_read(current);\n-\n-#ifndef NO_COMPLETION\n-        /* Only autocomplete when the callback is set. It returns < 0 when\n-         * there was an error reading from fd. Otherwise it will return the\n-         * character that should be handled next. */\n-        if (c == '\\t' && current->pos == current->chars && completionCallback != NULL) {\n-            c = completeLine(current);\n-            /* Return on errors */\n-            if (c < 0) return current->len;\n-            /* Read next character when 0 */\n-            if (c == 0) continue;\n-        }\n-#endif\n-\n-process_char:\n-        if (c == -1) return current->len;\n-#ifdef USE_TERMIOS\n-        if (c == 27) {   /* escape sequence */\n-            c = check_special(current->fd);\n-        }\n-#endif\n-        switch(c) {\n-        case '\\r':    /* enter */\n-            history_len--;\n-            free(history[history_len]);\n-            return current->len;\n-        case ctrl('C'):     /* ctrl-c */\n-            errno = EAGAIN;\n-            return -1;\n-        case 127:   /* backspace */\n-        case ctrl('H'):\n-            if (remove_char(current, current->pos - 1) == 1) {\n-                refreshLine(current->prompt, current);\n-            }\n-            break;\n-        case ctrl('D'):     /* ctrl-d */\n-            if (current->len == 0) {\n-                /* Empty line, so EOF */\n-                history_len--;\n-                free(history[history_len]);\n-                return -1;\n-            }\n-            /* Otherwise fall through to delete char to right of cursor */\n-        case SPECIAL_DELETE:\n-            if (remove_char(current, current->pos) == 1) {\n-                refreshLine(current->prompt, current);\n-            }\n-            break;\n-        case SPECIAL_INSERT:\n-            /* Ignore. Expansion Hook.\n-             * Future possibility: Toggle Insert/Overwrite Modes\n-             */\n-            break;\n-        case ctrl('W'):    /* ctrl-w, delete word at left. save deleted chars */\n-            /* eat any spaces on the left */\n-            {\n-                int pos = current->pos;\n-                while (pos > 0 && get_char(current, pos - 1) == ' ') {\n-                    pos--;\n-                }\n-\n-                /* now eat any non-spaces on the left */\n-                while (pos > 0 && get_char(current, pos - 1) != ' ') {\n-                    pos--;\n-                }\n-\n-                if (remove_chars(current, pos, current->pos - pos)) {\n-                    refreshLine(current->prompt, current);\n-                }\n-            }\n-            break;\n-        case ctrl('R'):    /* ctrl-r */\n-            {\n-                /* Display the reverse-i-search prompt and process chars */\n-                char rbuf[50];\n-                char rprompt[80];\n-                int rchars = 0;\n-                int rlen = 0;\n-                int searchpos = history_len - 1;\n-\n-                rbuf[0] = 0;\n-                while (1) {\n-                    int n = 0;\n-                    const char *p = NULL;\n-                    int skipsame = 0;\n-                    int searchdir = -1;\n-\n-                    snprintf(rprompt, sizeof(rprompt), \"(reverse-i-search)'%s': \", rbuf);\n-                    refreshLine(rprompt, current);\n-                    c = fd_read(current);\n-                    if (c == ctrl('H') || c == 127) {\n-                        if (rchars) {\n-                            int p = utf8_index(rbuf, --rchars);\n-                            rbuf[p] = 0;\n-                            rlen = strlen(rbuf);\n-                        }\n-                        continue;\n-                    }\n-#ifdef USE_TERMIOS\n-                    if (c == 27) {\n-                        c = check_special(current->fd);\n-                    }\n-#endif\n-                    if (c == ctrl('P') || c == SPECIAL_UP) {\n-                        /* Search for the previous (earlier) match */\n-                        if (searchpos > 0) {\n-                            searchpos--;\n-                        }\n-                        skipsame = 1;\n-                    }\n-                    else if (c == ctrl('N') || c == SPECIAL_DOWN) {\n-                        /* Search for the next (later) match */\n-                        if (searchpos < history_len) {\n-                            searchpos++;\n-                        }\n-                        searchdir = 1;\n-                        skipsame = 1;\n-                    }\n-                    else if (c >= ' ') {\n-                        if (rlen >= (int)sizeof(rbuf) + 3) {\n-                            continue;\n-                        }\n-\n-                        n = utf8_getchars(rbuf + rlen, c);\n-                        rlen += n;\n-                        rchars++;\n-                        rbuf[rlen] = 0;\n-\n-                        /* Adding a new char resets the search location */\n-                        searchpos = history_len - 1;\n-                    }\n-                    else {\n-                        /* Exit from incremental search mode */\n-                        break;\n-                    }\n-\n-                    /* Now search through the history for a match */\n-                    for (; searchpos >= 0 && searchpos < history_len; searchpos += searchdir) {\n-                        p = strstr(history[searchpos], rbuf);\n-                        if (p) {\n-                            /* Found a match */\n-                            if (skipsame && strcmp(history[searchpos], current->buf) == 0) {\n-                                /* But it is identical, so skip it */\n-                                continue;\n-                            }\n-                            /* Copy the matching line and set the cursor position */\n-                            set_current(current,history[searchpos]);\n-                            current->pos = utf8_strlen(history[searchpos], p - history[searchpos]);\n-                            break;\n-                        }\n-                    }\n-                    if (!p && n) {\n-                        /* No match, so don't add it */\n-                        rchars--;\n-                        rlen -= n;\n-                        rbuf[rlen] = 0;\n-                    }\n-                }\n-                if (c == ctrl('G') || c == ctrl('C')) {\n-                    /* ctrl-g terminates the search with no effect */\n-                    set_current(current, \"\");\n-                    c = 0;\n-                }\n-                else if (c == ctrl('J')) {\n-                    /* ctrl-j terminates the search leaving the buffer in place */\n-                    c = 0;\n-                }\n-                /* Go process the char normally */\n-                refreshLine(current->prompt, current);\n-                goto process_char;\n-            }\n-            break;\n-        case ctrl('T'):    /* ctrl-t */\n-            if (current->pos > 0 && current->pos <= current->chars) {\n-                /* If cursor is at end, transpose the previous two chars */\n-                int fixer = (current->pos == current->chars);\n-                c = get_char(current, current->pos - fixer);\n-                remove_char(current, current->pos - fixer);\n-                insert_char(current, current->pos - 1, c);\n-                refreshLine(current->prompt, current);\n-            }\n-            break;\n-        case ctrl('V'):    /* ctrl-v */\n-            if (has_room(current, 3)) {\n-                /* Insert the ^V first */\n-                if (insert_char(current, current->pos, c)) {\n-                    refreshLine(current->prompt, current);\n-                    /* Now wait for the next char. Can insert anything except \\0 */\n-                    c = fd_read(current);\n-\n-                    /* Remove the ^V first */\n-                    remove_char(current, current->pos - 1);\n-                    if (c != -1) {\n-                        /* Insert the actual char */\n-                        insert_char(current, current->pos, c);\n-                    }\n-                    refreshLine(current->prompt, current);\n-                }\n-            }\n-            break;\n-        case ctrl('B'):\n-        case SPECIAL_LEFT:\n-            if (current->pos > 0) {\n-                current->pos--;\n-                refreshLine(current->prompt, current);\n-            }\n-            break;\n-        case ctrl('F'):\n-        case SPECIAL_RIGHT:\n-            if (current->pos < current->chars) {\n-                current->pos++;\n-                refreshLine(current->prompt, current);\n-            }\n-            break;\n-        case SPECIAL_PAGE_UP:\n-          dir = history_len - history_index - 1; /* move to start of history */\n-          goto history_navigation;\n-        case SPECIAL_PAGE_DOWN:\n-          dir = -history_index; /* move to 0 == end of history, i.e. current */\n-          goto history_navigation;\n-        case ctrl('P'):\n-        case SPECIAL_UP:\n-            dir = 1;\n-          goto history_navigation;\n-        case ctrl('N'):\n-        case SPECIAL_DOWN:\n-history_navigation:\n-            if (history_len > 1) {\n-                /* Update the current history entry before to\n-                 * overwrite it with tne next one. */\n-                free(history[history_len - 1 - history_index]);\n-                history[history_len - 1 - history_index] = strdup(current->buf);\n-                /* Show the new entry */\n-                history_index += dir;\n-                if (history_index < 0) {\n-                    history_index = 0;\n-                    break;\n-                } else if (history_index >= history_len) {\n-                    history_index = history_len - 1;\n-                    break;\n-                }\n-                set_current(current, history[history_len - 1 - history_index]);\n-                refreshLine(current->prompt, current);\n-            }\n-            break;\n-        case ctrl('A'): /* Ctrl+a, go to the start of the line */\n-        case SPECIAL_HOME:\n-            current->pos = 0;\n-            refreshLine(current->prompt, current);\n-            break;\n-        case ctrl('E'): /* ctrl+e, go to the end of the line */\n-        case SPECIAL_END:\n-            current->pos = current->chars;\n-            refreshLine(current->prompt, current);\n-            break;\n-        case ctrl('U'): /* Ctrl+u, delete to beginning of line, save deleted chars. */\n-            if (remove_chars(current, 0, current->pos)) {\n-                refreshLine(current->prompt, current);\n-            }\n-            break;\n-        case ctrl('K'): /* Ctrl+k, delete from current to end of line, save deleted chars. */\n-            if (remove_chars(current, current->pos, current->chars - current->pos)) {\n-                refreshLine(current->prompt, current);\n-            }\n-            break;\n-        case ctrl('Y'): /* Ctrl+y, insert saved chars at current position */\n-            if (current->capture && insert_chars(current, current->pos, current->capture)) {\n-                refreshLine(current->prompt, current);\n-            }\n-            break;\n-        case ctrl('L'): /* Ctrl+L, clear screen */\n-            clearScreen(current);\n-            /* Force recalc of window size for serial terminals */\n-            current->cols = 0;\n-            refreshLine(current->prompt, current);\n-            break;\n-        default:\n-            /* Only tab is allowed without ^V */\n-            if (c == '\\t' || c >= ' ') {\n-                if (insert_char(current, current->pos, c) == 1) {\n-                    refreshLine(current->prompt, current);\n-                }\n-            }\n-            break;\n-        }\n-    }\n-    return current->len;\n-}\n-\n-int linenoiseColumns(void)\n-{\n-    struct current current;\n-    enableRawMode (&current);\n-    getWindowSize (&current);\n-    disableRawMode (&current);\n-    return current.cols;\n-}\n-\n-char *linenoise(const char *prompt)\n-{\n-    int count;\n-    struct current current;\n-    char buf[LINENOISE_MAX_LINE];\n-\n-    if (enableRawMode(&current) == -1) {\n-        printf(\"%s\", prompt);\n-        fflush(stdout);\n-        if (fgets(buf, sizeof(buf), stdin) == NULL) {\n-            return NULL;\n-        }\n-        count = strlen(buf);\n-        if (count && buf[count-1] == '\\n') {\n-            count--;\n-            buf[count] = '\\0';\n-        }\n-    }\n-    else\n-    {\n-        current.buf = buf;\n-        current.bufmax = sizeof(buf);\n-        current.len = 0;\n-        current.chars = 0;\n-        current.pos = 0;\n-        current.prompt = prompt;\n-        current.capture = NULL;\n-\n-        count = linenoiseEdit(&current);\n-\n-        disableRawMode(&current);\n-        printf(\"\\n\");\n-\n-        free(current.capture);\n-        if (count == -1) {\n-            return NULL;\n-        }\n-    }\n-    return strdup(buf);\n-}\n-\n-/* Using a circular buffer is smarter, but a bit more complex to handle. */\n-int linenoiseHistoryAdd(const char *line) {\n-    char *linecopy;\n-\n-    if (history_max_len == 0) return 0;\n-    if (history == NULL) {\n-        history = (char **)malloc(sizeof(char*)*history_max_len);\n-        if (history == NULL) return 0;\n-        memset(history,0,(sizeof(char*)*history_max_len));\n-    }\n-\n-    /* do not insert duplicate lines into history */\n-    if (history_len > 0 && strcmp(line, history[history_len - 1]) == 0) {\n-        return 0;\n-    }\n-\n-    linecopy = strdup(line);\n-    if (!linecopy) return 0;\n-    if (history_len == history_max_len) {\n-        free(history[0]);\n-        memmove(history,history+1,sizeof(char*)*(history_max_len-1));\n-        history_len--;\n-    }\n-    history[history_len] = linecopy;\n-    history_len++;\n-    return 1;\n-}\n-\n-int linenoiseHistoryGetMaxLen(void) {\n-    return history_max_len;\n-}\n-\n-int linenoiseHistorySetMaxLen(int len) {\n-    char **newHistory;\n-\n-    if (len < 1) return 0;\n-    if (history) {\n-        int tocopy = history_len;\n-\n-        newHistory = (char **)malloc(sizeof(char*)*len);\n-        if (newHistory == NULL) return 0;\n-\n-        /* If we can't copy everything, free the elements we'll not use. */\n-        if (len < tocopy) {\n-            int j;\n-\n-            for (j = 0; j < tocopy-len; j++) free(history[j]);\n-            tocopy = len;\n-        }\n-        memset(newHistory,0,sizeof(char*)*len);\n-        memcpy(newHistory,history+(history_len-tocopy), sizeof(char*)*tocopy);\n-        free(history);\n-        history = newHistory;\n-    }\n-    history_max_len = len;\n-    if (history_len > history_max_len)\n-        history_len = history_max_len;\n-    return 1;\n-}\n-\n-/* Save the history in the specified file. On success 0 is returned\n- * otherwise -1 is returned. */\n-int linenoiseHistorySave(const char *filename) {\n-    FILE *fp = fopen(filename,\"w\");\n-    int j;\n-\n-    if (fp == NULL) return -1;\n-    for (j = 0; j < history_len; j++) {\n-        const char *str = history[j];\n-        /* Need to encode backslash, nl and cr */\n-        while (*str) {\n-            if (*str == '\\\\') {\n-                fputs(\"\\\\\\\\\", fp);\n-            }\n-            else if (*str == '\\n') {\n-                fputs(\"\\\\n\", fp);\n-            }\n-            else if (*str == '\\r') {\n-                fputs(\"\\\\r\", fp);\n-            }\n-            else {\n-                fputc(*str, fp);\n-            }\n-            str++;\n-        }\n-        fputc('\\n', fp);\n-    }\n-\n-    fclose(fp);\n-    return 0;\n-}\n-\n-/* Load the history from the specified file. If the file does not exist\n- * zero is returned and no operation is performed.\n- *\n- * If the file exists and the operation succeeded 0 is returned, otherwise\n- * on error -1 is returned. */\n-int linenoiseHistoryLoad(const char *filename) {\n-    FILE *fp = fopen(filename,\"r\");\n-    char buf[LINENOISE_MAX_LINE];\n-\n-    if (fp == NULL) return -1;\n-\n-    while (fgets(buf,LINENOISE_MAX_LINE,fp) != NULL) {\n-        char *src, *dest;\n-\n-        /* Decode backslash escaped values */\n-        for (src = dest = buf; *src; src++) {\n-            char ch = *src;\n-\n-            if (ch == '\\\\') {\n-                src++;\n-                if (*src == 'n') {\n-                    ch = '\\n';\n-                }\n-                else if (*src == 'r') {\n-                    ch = '\\r';\n-                } else {\n-                    ch = *src;\n-                }\n-            }\n-            *dest++ = ch;\n-        }\n-        /* Remove trailing newline */\n-        if (dest != buf && (dest[-1] == '\\n' || dest[-1] == '\\r')) {\n-            dest--;\n-        }\n-        *dest = 0;\n-\n-        linenoiseHistoryAdd(buf);\n-    }\n-    fclose(fp);\n-    return 0;\n-}\n-\n-/* Provide access to the history buffer.\n- *\n- * If 'len' is not NULL, the length is stored in *len.\n- */\n-char **linenoiseHistory(int *len) {\n-    if (len) {\n-        *len = history_len;\n-    }\n-    return history;\n-}"}, {"sha": "7ebf244ee80e7f0bd92a551f3bb29de43ae7835a", "filename": "src/rt/linenoise/linenoise.h", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/00adcf0bdd9376046859b7bc0d79097b621844c5/src%2Frt%2Flinenoise%2Flinenoise.h", "raw_url": "https://github.com/rust-lang/rust/raw/00adcf0bdd9376046859b7bc0d79097b621844c5/src%2Frt%2Flinenoise%2Flinenoise.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flinenoise%2Flinenoise.h?ref=00adcf0bdd9376046859b7bc0d79097b621844c5", "patch": "@@ -1,61 +0,0 @@\n-/* linenoise.h -- guerrilla line editing library against the idea that a\n- * line editing lib needs to be 20,000 lines of C code.\n- *\n- * See linenoise.c for more information.\n- *\n- * ------------------------------------------------------------------------\n- *\n- * Copyright (c) 2010, Salvatore Sanfilippo <antirez at gmail dot com>\n- * Copyright (c) 2010, Pieter Noordhuis <pcnoordhuis at gmail dot com>\n- *\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions are\n- * met:\n- *\n- *  *  Redistributions of source code must retain the above copyright\n- *     notice, this list of conditions and the following disclaimer.\n- *\n- *  *  Redistributions in binary form must reproduce the above copyright\n- *     notice, this list of conditions and the following disclaimer in the\n- *     documentation and/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n- * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- */\n-\n-#ifndef __LINENOISE_H\n-#define __LINENOISE_H\n-\n-#ifndef NO_COMPLETION\n-typedef struct linenoiseCompletions {\n-  size_t len;\n-  char **cvec;\n-} linenoiseCompletions;\n-\n-typedef void(linenoiseCompletionCallback)(const char *, linenoiseCompletions *);\n-void linenoiseSetCompletionCallback(linenoiseCompletionCallback *);\n-void linenoiseAddCompletion(linenoiseCompletions *, const char *);\n-#endif\n-\n-char *linenoise(const char *prompt);\n-int linenoiseHistoryAdd(const char *line);\n-int linenoiseHistorySetMaxLen(int len);\n-int linenoiseHistoryGetMaxLen(void);\n-int linenoiseHistorySave(const char *filename);\n-int linenoiseHistoryLoad(const char *filename);\n-void linenoiseHistoryFree(void);\n-char **linenoiseHistory(int *len);\n-int linenoiseColumns(void);\n-\n-#endif /* __LINENOISE_H */"}, {"sha": "26924b46c19154755c904038c949a98b033e3c50", "filename": "src/rt/linenoise/utf8.c", "status": "removed", "additions": 0, "deletions": 115, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/00adcf0bdd9376046859b7bc0d79097b621844c5/src%2Frt%2Flinenoise%2Futf8.c", "raw_url": "https://github.com/rust-lang/rust/raw/00adcf0bdd9376046859b7bc0d79097b621844c5/src%2Frt%2Flinenoise%2Futf8.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flinenoise%2Futf8.c?ref=00adcf0bdd9376046859b7bc0d79097b621844c5", "patch": "@@ -1,115 +0,0 @@\n-/**\n- * UTF-8 utility functions\n- *\n- * (c) 2010 Steve Bennett <steveb@workware.net.au>\n- *\n- * See LICENCE for licence details.\n- */\n-\n-#include <ctype.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#include <stdio.h>\n-#include \"utf8.h\"\n-\n-#ifdef USE_UTF8\n-int utf8_fromunicode(char *p, unsigned short uc)\n-{\n-    if (uc <= 0x7f) {\n-        *p = uc;\n-        return 1;\n-    }\n-    else if (uc <= 0x7ff) {\n-        *p++ = 0xc0 | ((uc & 0x7c0) >> 6);\n-        *p = 0x80 | (uc & 0x3f);\n-        return 2;\n-    }\n-    else {\n-        *p++ = 0xe0 | ((uc & 0xf000) >> 12);\n-        *p++ = 0x80 | ((uc & 0xfc0) >> 6);\n-        *p = 0x80 | (uc & 0x3f);\n-        return 3;\n-    }\n-}\n-\n-int utf8_charlen(int c)\n-{\n-    if ((c & 0x80) == 0) {\n-        return 1;\n-    }\n-    if ((c & 0xe0) == 0xc0) {\n-        return 2;\n-    }\n-    if ((c & 0xf0) == 0xe0) {\n-        return 3;\n-    }\n-    if ((c & 0xf8) == 0xf0) {\n-        return 4;\n-    }\n-    /* Invalid sequence */\n-    return -1;\n-}\n-\n-int utf8_strlen(const char *str, int bytelen)\n-{\n-    int charlen = 0;\n-    if (bytelen < 0) {\n-        bytelen = strlen(str);\n-    }\n-    while (bytelen) {\n-        int c;\n-        int l = utf8_tounicode(str, &c);\n-        charlen++;\n-        str += l;\n-        bytelen -= l;\n-    }\n-    return charlen;\n-}\n-\n-int utf8_index(const char *str, int index)\n-{\n-    const char *s = str;\n-    while (index--) {\n-        int c;\n-        s += utf8_tounicode(s, &c);\n-    }\n-    return s - str;\n-}\n-\n-int utf8_charequal(const char *s1, const char *s2)\n-{\n-    int c1, c2;\n-\n-    utf8_tounicode(s1, &c1);\n-    utf8_tounicode(s2, &c2);\n-\n-    return c1 == c2;\n-}\n-\n-int utf8_tounicode(const char *str, int *uc)\n-{\n-    unsigned const char *s = (unsigned const char *)str;\n-\n-    if (s[0] < 0xc0) {\n-        *uc = s[0];\n-        return 1;\n-    }\n-    if (s[0] < 0xe0) {\n-        if ((s[1] & 0xc0) == 0x80) {\n-            *uc = ((s[0] & ~0xc0) << 6) | (s[1] & ~0x80);\n-            return 2;\n-        }\n-    }\n-    else if (s[0] < 0xf0) {\n-        if (((str[1] & 0xc0) == 0x80) && ((str[2] & 0xc0) == 0x80)) {\n-            *uc = ((s[0] & ~0xe0) << 12) | ((s[1] & ~0x80) << 6) | (s[2] & ~0x80);\n-            return 3;\n-        }\n-    }\n-\n-    /* Invalid sequence, so just return the byte */\n-    *uc = *s;\n-    return 1;\n-}\n-\n-#endif"}, {"sha": "9537939876ae091451500330b488485f740361f7", "filename": "src/rt/linenoise/utf8.h", "status": "removed", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/00adcf0bdd9376046859b7bc0d79097b621844c5/src%2Frt%2Flinenoise%2Futf8.h", "raw_url": "https://github.com/rust-lang/rust/raw/00adcf0bdd9376046859b7bc0d79097b621844c5/src%2Frt%2Flinenoise%2Futf8.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flinenoise%2Futf8.h?ref=00adcf0bdd9376046859b7bc0d79097b621844c5", "patch": "@@ -1,79 +0,0 @@\n-#ifndef UTF8_UTIL_H\n-#define UTF8_UTIL_H\n-/**\n- * UTF-8 utility functions\n- *\n- * (c) 2010 Steve Bennett <steveb@workware.net.au>\n- *\n- * See LICENCE for licence details.\n- */\n-\n-#ifndef USE_UTF8\n-#include <ctype.h>\n-\n-/* No utf-8 support. 1 byte = 1 char */\n-#define utf8_strlen(S, B) ((B) < 0 ? (int)strlen(S) : (B))\n-#define utf8_tounicode(S, CP) (*(CP) = (unsigned char)*(S), 1)\n-#define utf8_index(C, I) (I)\n-#define utf8_charlen(C) 1\n-\n-#else\n-/**\n- * Converts the given unicode codepoint (0 - 0xffff) to utf-8\n- * and stores the result at 'p'.\n- * \n- * Returns the number of utf-8 characters (1-3).\n- */\n-int utf8_fromunicode(char *p, unsigned short uc);\n-\n-/**\n- * Returns the length of the utf-8 sequence starting with 'c'.\n- * \n- * Returns 1-4, or -1 if this is not a valid start byte.\n- *\n- * Note that charlen=4 is not supported by the rest of the API.\n- */\n-int utf8_charlen(int c);\n-\n-/**\n- * Returns the number of characters in the utf-8 \n- * string of the given byte length.\n- *\n- * Any bytes which are not part of an valid utf-8\n- * sequence are treated as individual characters.\n- *\n- * The string *must* be null terminated.\n- *\n- * Does not support unicode code points > \\uffff\n- */\n-int utf8_strlen(const char *str, int bytelen);\n-\n-/**\n- * Returns the byte index of the given character in the utf-8 string.\n- * \n- * The string *must* be null terminated.\n- *\n- * This will return the byte length of a utf-8 string\n- * if given the char length.\n- */\n-int utf8_index(const char *str, int charindex);\n-\n-/**\n- * Returns the unicode codepoint corresponding to the\n- * utf-8 sequence 'str'.\n- * \n- * Stores the result in *uc and returns the number of bytes\n- * consumed.\n- *\n- * If 'str' is null terminated, then an invalid utf-8 sequence\n- * at the end of the string will be returned as individual bytes.\n- *\n- * If it is not null terminated, the length *must* be checked first.\n- *\n- * Does not support unicode code points > \\uffff\n- */\n-int utf8_tounicode(const char *str, int *uc);\n-\n-#endif\n-\n-#endif"}, {"sha": "9750e22e9453b685a3896e26ddbe506ae6aefa81", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/386fa1d818f341004e511af24da9f257d35cdbd2/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/386fa1d818f341004e511af24da9f257d35cdbd2/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=386fa1d818f341004e511af24da9f257d35cdbd2", "patch": "@@ -570,18 +570,6 @@ rust_drop_env_lock() {\n     env_lock.unlock();\n }\n \n-static lock_and_signal linenoise_lock;\n-\n-extern \"C\" CDECL void\n-rust_take_linenoise_lock() {\n-    linenoise_lock.lock();\n-}\n-\n-extern \"C\" CDECL void\n-rust_drop_linenoise_lock() {\n-    linenoise_lock.unlock();\n-}\n-\n static lock_and_signal dlerror_lock;\n \n extern \"C\" CDECL void"}, {"sha": "fb9934c76011dcf3295dd438e2165cc59248d9d2", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/386fa1d818f341004e511af24da9f257d35cdbd2/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/386fa1d818f341004e511af24da9f257d35cdbd2/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=386fa1d818f341004e511af24da9f257d35cdbd2", "patch": "@@ -133,13 +133,6 @@ tinfl_decompress_mem_to_heap\n rust_uv_ip4_port\n rust_uv_ip6_port\n rust_uv_tcp_getpeername\n-linenoise\n-linenoiseSetCompletionCallback\n-linenoiseAddCompletion\n-linenoiseHistoryAdd\n-linenoiseHistorySetMaxLen\n-linenoiseHistorySave\n-linenoiseHistoryLoad\n rust_raw_thread_start\n rust_raw_thread_join\n rust_raw_thread_delete\n@@ -187,8 +180,6 @@ rust_get_num_cpus\n rust_get_global_args_ptr\n rust_take_global_args_lock\n rust_drop_global_args_lock\n-rust_take_linenoise_lock\n-rust_drop_linenoise_lock\n rust_get_test_int\n rust_get_task\n rust_uv_get_loop_from_getaddrinfo_req"}, {"sha": "f6124088c9bdd4dc960970008667c9668b120fe0", "filename": "src/test/auxiliary/issue_3882.rc", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/00adcf0bdd9376046859b7bc0d79097b621844c5/src%2Ftest%2Fauxiliary%2Fissue_3882.rc", "raw_url": "https://github.com/rust-lang/rust/raw/00adcf0bdd9376046859b7bc0d79097b621844c5/src%2Ftest%2Fauxiliary%2Fissue_3882.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_3882.rc?ref=00adcf0bdd9376046859b7bc0d79097b621844c5", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[link(name = \"linenoise\",\n-       vers = \"0.1\")];\n-#[crate_type = \"lib\"];\n-\n-pub mod issue_3882;"}, {"sha": "bb75758c741e98d0b7de6a4c22d6c6e9a2a05ce4", "filename": "src/test/auxiliary/issue_3882.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/00adcf0bdd9376046859b7bc0d79097b621844c5/src%2Ftest%2Fauxiliary%2Fissue_3882.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00adcf0bdd9376046859b7bc0d79097b621844c5/src%2Ftest%2Fauxiliary%2Fissue_3882.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_3882.rs?ref=00adcf0bdd9376046859b7bc0d79097b621844c5", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-mod issue_3882 {\n-    struct Completions {\n-        len: libc::size_t,\n-    }\n-\n-    mod c {\n-        extern {\n-            fn linenoiseAddCompletion(lc: *mut Completions);\n-        }\n-    }\n-}"}, {"sha": "202385681ce6234c4661c9fa2a7cf80610855121", "filename": "src/test/run-pass/issue_3882.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/00adcf0bdd9376046859b7bc0d79097b621844c5/src%2Ftest%2Frun-pass%2Fissue_3882.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00adcf0bdd9376046859b7bc0d79097b621844c5/src%2Ftest%2Frun-pass%2Fissue_3882.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue_3882.rs?ref=00adcf0bdd9376046859b7bc0d79097b621844c5", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-test\n-// aux-build:issue_3882.rc\n-extern mod linenoise;\n-use linenoise::issue_3882::*;\n-\n-pub fn main() {}"}, {"sha": "6a87a6502d211f37b90d32201f5410dd476442d0", "filename": "src/test/run-pass/rl-human-test.rs", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/00adcf0bdd9376046859b7bc0d79097b621844c5/src%2Ftest%2Frun-pass%2Frl-human-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00adcf0bdd9376046859b7bc0d79097b621844c5/src%2Ftest%2Frun-pass%2Frl-human-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frl-human-test.rs?ref=00adcf0bdd9376046859b7bc0d79097b621844c5", "patch": "@@ -1,83 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-fast no compile flags for check-fast\n-\n-// we want this to be compiled to avoid bitrot, but the actual test\n-//has to be conducted by a human, i.e. someone (you?) compiling this\n-//file with a plain rustc invocation and running it and checking it\n-//works.\n-\n-// compile-flags: --cfg robot_mode\n-\n-extern mod extra;\n-use extra::rl;\n-\n-static HISTORY_FILE: &'static str = \"rl-human-test-history.txt\";\n-\n-struct TestCompleter;\n-\n-impl rl::CompletionCb for TestCompleter {\n-    fn complete(&self, line: ~str, suggest: &fn(~str)) {\n-        if line.is_empty() {\n-            suggest(~\"empty\")\n-        } else {\n-            for c in line.rev_iter().take(3) {\n-                suggest(format!(\"{0}{1}{1}{1}\", line, c))\n-            }\n-        }\n-    }\n-}\n-\n-fn main() {\n-    // don't run this in robot mode, but still typecheck it.\n-    if !cfg!(robot_mode) {\n-        println(\"~~ Welcome to the rl test \\\"suite\\\". ~~\");\n-        println!(\"Operations:\n- - restrict the history to 2 lines,\n- - set the tab-completion to suggest three copies of each of the last 3 letters (or 'empty'),\n- - add 'one' and 'two' to the history,\n- - save it to `{0}`,\n- - add 'three',\n- - prompt & save input (check the history & completion work and contains only 'two', 'three'),\n- - load from `{0}`\n- - prompt & save input (history should be 'one', 'two' again),\n- - prompt once more.\n-\n-The bool return values of each step are printed.\",\n-                 HISTORY_FILE);\n-\n-        println!(\"restricting history length: {}\", rl::set_history_max_len(3));\n-\n-        unsafe {\n-            rl::complete(@TestCompleter as @rl::CompletionCb);\n-        }\n-\n-        println!(\"adding 'one': {}\", rl::add_history(\"one\"));\n-        println!(\"adding 'two': {}\", rl::add_history(\"two\"));\n-\n-        println!(\"saving history: {}\", rl::save_history(HISTORY_FILE));\n-\n-        println!(\"adding 'three': {}\", rl::add_history(\"three\"));\n-\n-        match rl::read(\"> \") {\n-            Some(s) => println!(\"saving input: {}\", rl::add_history(s)),\n-            None => return\n-        }\n-        println!(\"loading history: {}\", rl::load_history(HISTORY_FILE));\n-\n-        match rl::read(\"> \") {\n-            Some(s) => println!(\"saving input: {}\", rl::add_history(s)),\n-            None => return\n-        }\n-\n-        rl::read(\"> \");\n-    }\n-}"}]}