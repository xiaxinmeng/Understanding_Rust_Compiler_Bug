{"sha": "228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyOGEwZWQ3YjBjZWYyZmJmZWI3ODFhY2Y2YzIzMDE1Y2NjNDBiYTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-21T02:20:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-21T02:20:07Z"}, "message": "Auto merge of #70946 - jumbatm:clashing-extern-decl, r=nagisa\n\nAdd a lint to catch clashing `extern` fn declarations.\n\nCloses #69390.\n\nAdds lint `clashing_extern_decl` to detect when, within a single crate, an extern function of the same name is declared with different types. Because two symbols of the same name cannot be resolved to two different functions at link time, and one function cannot possibly have two types, a clashing extern declaration is almost certainly a mistake.\n\nThis lint does not run between crates because a project may have dependencies which both rely on the same extern function, but declare it in a different (but valid) way. For example, they may both declare an opaque type for one or more of the arguments (which would end up distinct types), or use types that are valid conversions in the language the extern fn is defined in. In these cases, we can't say that the clashing declaration is incorrect.\n\nr? @eddyb", "tree": {"sha": "cf060cf92c6f6b8c9ca560cc62f1a78e618c58fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf060cf92c6f6b8c9ca560cc62f1a78e618c58fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2", "html_url": "https://github.com/rust-lang/rust/commit/228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7058471adec80a2a1e6092443e08546768c9c894", "url": "https://api.github.com/repos/rust-lang/rust/commits/7058471adec80a2a1e6092443e08546768c9c894", "html_url": "https://github.com/rust-lang/rust/commit/7058471adec80a2a1e6092443e08546768c9c894"}, {"sha": "556b7baca2cd45a78b1a9a762b4bf66b69747e53", "url": "https://api.github.com/repos/rust-lang/rust/commits/556b7baca2cd45a78b1a9a762b4bf66b69747e53", "html_url": "https://github.com/rust-lang/rust/commit/556b7baca2cd45a78b1a9a762b4bf66b69747e53"}], "stats": {"total": 579, "additions": 568, "deletions": 11}, "files": [{"sha": "0115c4df2fd3e9901b0fa9f4e738681ddadb2910", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2", "patch": "@@ -277,6 +277,9 @@ pub mod primitive;\n // crate uses the this crate as its libcore.\n #[path = \"../stdarch/crates/core_arch/src/mod.rs\"]\n #[allow(missing_docs, missing_debug_implementations, dead_code, unused_imports)]\n+// FIXME: This annotation should be moved into rust-lang/stdarch after clashing_extern_decl is\n+// merged. It currently cannot because bootstrap fails as the lint hasn't been defined yet.\n+#[cfg_attr(not(bootstrap), allow(clashing_extern_decl))]\n #[unstable(feature = \"stdsimd\", issue = \"48556\")]\n mod core_arch;\n "}, {"sha": "b7f728ec60cfdab9b0b8aa2641c3f24de4ae3d23", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 226, "deletions": 5, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2", "patch": "@@ -26,15 +26,15 @@ use rustc_ast::attr::{self, HasAttrs};\n use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_ast::visit::{FnCtxt, FnKind};\n use rustc_ast_pretty::pprust::{self, expr_to_string};\n-use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString};\n use rustc_feature::{deprecated_attributes, AttributeGate, AttributeTemplate, AttributeType};\n use rustc_feature::{GateIssue, Stability};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n-use rustc_hir::{GenericParamKind, PatKind};\n-use rustc_hir::{HirIdSet, Node};\n+use rustc_hir::{ForeignItemKind, GenericParamKind, PatKind};\n+use rustc_hir::{HirId, HirIdSet, Node};\n use rustc_middle::lint::LintDiagnosticBuilder;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -48,7 +48,7 @@ use rustc_trait_selection::traits::misc::can_type_implement_copy;\n \n use crate::nonstandard_style::{method_context, MethodLateContext};\n \n-use log::debug;\n+use log::{debug, trace};\n use std::fmt::Write;\n \n // hardwired lints from librustc_middle\n@@ -2053,3 +2053,224 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n         }\n     }\n }\n+\n+declare_lint! {\n+    pub CLASHING_EXTERN_DECL,\n+    Warn,\n+    \"detects when an extern fn has been declared with the same name but different types\"\n+}\n+\n+pub struct ClashingExternDecl {\n+    seen_decls: FxHashMap<Symbol, HirId>,\n+}\n+\n+/// Differentiate between whether the name for an extern decl came from the link_name attribute or\n+/// just from declaration itself. This is important because we don't want to report clashes on\n+/// symbol name if they don't actually clash because one or the other links against a symbol with a\n+/// different name.\n+enum SymbolName {\n+    /// The name of the symbol + the span of the annotation which introduced the link name.\n+    Link(Symbol, Span),\n+    /// No link name, so just the name of the symbol.\n+    Normal(Symbol),\n+}\n+\n+impl SymbolName {\n+    fn get_name(&self) -> Symbol {\n+        match self {\n+            SymbolName::Link(s, _) | SymbolName::Normal(s) => *s,\n+        }\n+    }\n+}\n+\n+impl ClashingExternDecl {\n+    crate fn new() -> Self {\n+        ClashingExternDecl { seen_decls: FxHashMap::default() }\n+    }\n+    /// Insert a new foreign item into the seen set. If a symbol with the same name already exists\n+    /// for the item, return its HirId without updating the set.\n+    fn insert(&mut self, tcx: TyCtxt<'_>, fi: &hir::ForeignItem<'_>) -> Option<HirId> {\n+        let hid = fi.hir_id;\n+\n+        let name =\n+            &tcx.codegen_fn_attrs(tcx.hir().local_def_id(hid)).link_name.unwrap_or(fi.ident.name);\n+\n+        if self.seen_decls.contains_key(name) {\n+            // Avoid updating the map with the new entry when we do find a collision. We want to\n+            // make sure we're always pointing to the first definition as the previous declaration.\n+            // This lets us avoid emitting \"knock-on\" diagnostics.\n+            Some(*self.seen_decls.get(name).unwrap())\n+        } else {\n+            self.seen_decls.insert(*name, hid)\n+        }\n+    }\n+\n+    /// Get the name of the symbol that's linked against for a given extern declaration. That is,\n+    /// the name specified in a #[link_name = ...] attribute if one was specified, else, just the\n+    /// symbol's name.\n+    fn name_of_extern_decl(tcx: TyCtxt<'_>, fi: &hir::ForeignItem<'_>) -> SymbolName {\n+        let did = tcx.hir().local_def_id(fi.hir_id);\n+        if let Some((overridden_link_name, overridden_link_name_span)) =\n+            tcx.codegen_fn_attrs(did).link_name.map(|overridden_link_name| {\n+                // FIXME: Instead of searching through the attributes again to get span\n+                // information, we could have codegen_fn_attrs also give span information back for\n+                // where the attribute was defined. However, until this is found to be a\n+                // bottleneck, this does just fine.\n+                (\n+                    overridden_link_name,\n+                    tcx.get_attrs(did.to_def_id())\n+                        .iter()\n+                        .find(|at| at.check_name(sym::link_name))\n+                        .unwrap()\n+                        .span,\n+                )\n+            })\n+        {\n+            SymbolName::Link(overridden_link_name, overridden_link_name_span)\n+        } else {\n+            SymbolName::Normal(fi.ident.name)\n+        }\n+    }\n+\n+    /// Checks whether two types are structurally the same enough that the declarations shouldn't\n+    /// clash. We need this so we don't emit a lint when two modules both declare an extern struct,\n+    /// with the same members (as the declarations shouldn't clash).\n+    fn structurally_same_type<'a, 'tcx>(\n+        cx: &LateContext<'a, 'tcx>,\n+        a: Ty<'tcx>,\n+        b: Ty<'tcx>,\n+    ) -> bool {\n+        let tcx = cx.tcx;\n+        if a == b || rustc_middle::ty::TyS::same_type(a, b) {\n+            // All nominally-same types are structurally same, too.\n+            true\n+        } else {\n+            // Do a full, depth-first comparison between the two.\n+            use rustc_middle::ty::TyKind::*;\n+            let a_kind = &a.kind;\n+            let b_kind = &b.kind;\n+\n+            match (a_kind, b_kind) {\n+                (Adt(..), Adt(..)) => {\n+                    // Adts are pretty straightforward: just compare the layouts.\n+                    use rustc_target::abi::LayoutOf;\n+                    let a_layout = cx.layout_of(a).unwrap().layout;\n+                    let b_layout = cx.layout_of(b).unwrap().layout;\n+                    a_layout == b_layout\n+                }\n+                (Array(a_ty, a_const), Array(b_ty, b_const)) => {\n+                    // For arrays, we also check the constness of the type.\n+                    a_const.val == b_const.val\n+                        && Self::structurally_same_type(cx, a_const.ty, b_const.ty)\n+                        && Self::structurally_same_type(cx, a_ty, b_ty)\n+                }\n+                (Slice(a_ty), Slice(b_ty)) => Self::structurally_same_type(cx, a_ty, b_ty),\n+                (RawPtr(a_tymut), RawPtr(b_tymut)) => {\n+                    a_tymut.mutbl == a_tymut.mutbl\n+                        && Self::structurally_same_type(cx, &a_tymut.ty, &b_tymut.ty)\n+                }\n+                (Ref(_a_region, a_ty, a_mut), Ref(_b_region, b_ty, b_mut)) => {\n+                    // For structural sameness, we don't need the region to be same.\n+                    a_mut == b_mut && Self::structurally_same_type(cx, a_ty, b_ty)\n+                }\n+                (FnDef(..), FnDef(..)) => {\n+                    // As we don't compare regions, skip_binder is fine.\n+                    let a_poly_sig = a.fn_sig(tcx);\n+                    let b_poly_sig = b.fn_sig(tcx);\n+\n+                    let a_sig = a_poly_sig.skip_binder();\n+                    let b_sig = b_poly_sig.skip_binder();\n+\n+                    (a_sig.abi, a_sig.unsafety, a_sig.c_variadic)\n+                        == (b_sig.abi, b_sig.unsafety, b_sig.c_variadic)\n+                        && a_sig.inputs().iter().eq_by(b_sig.inputs().iter(), |a, b| {\n+                            Self::structurally_same_type(cx, a, b)\n+                        })\n+                        && Self::structurally_same_type(cx, a_sig.output(), b_sig.output())\n+                }\n+                (Tuple(a_substs), Tuple(b_substs)) => {\n+                    a_substs.types().eq_by(b_substs.types(), |a_ty, b_ty| {\n+                        Self::structurally_same_type(cx, a_ty, b_ty)\n+                    })\n+                }\n+                // For these, it's not quite as easy to define structural-sameness quite so easily.\n+                // For the purposes of this lint, take the conservative approach and mark them as\n+                // not structurally same.\n+                (Dynamic(..), Dynamic(..))\n+                | (Error(..), Error(..))\n+                | (Closure(..), Closure(..))\n+                | (Generator(..), Generator(..))\n+                | (GeneratorWitness(..), GeneratorWitness(..))\n+                | (Projection(..), Projection(..))\n+                | (Opaque(..), Opaque(..)) => false,\n+                // These definitely should have been caught above.\n+                (Bool, Bool) | (Char, Char) | (Never, Never) | (Str, Str) => unreachable!(),\n+                _ => false,\n+            }\n+        }\n+    }\n+}\n+\n+impl_lint_pass!(ClashingExternDecl => [CLASHING_EXTERN_DECL]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ClashingExternDecl {\n+    fn check_foreign_item(&mut self, cx: &LateContext<'a, 'tcx>, this_fi: &hir::ForeignItem<'_>) {\n+        trace!(\"ClashingExternDecl: check_foreign_item: {:?}\", this_fi);\n+        if let ForeignItemKind::Fn(..) = this_fi.kind {\n+            let tcx = *&cx.tcx;\n+            if let Some(existing_hid) = self.insert(tcx, this_fi) {\n+                let existing_decl_ty = tcx.type_of(tcx.hir().local_def_id(existing_hid));\n+                let this_decl_ty = tcx.type_of(tcx.hir().local_def_id(this_fi.hir_id));\n+                debug!(\n+                    \"ClashingExternDecl: Comparing existing {:?}: {:?} to this {:?}: {:?}\",\n+                    existing_hid, existing_decl_ty, this_fi.hir_id, this_decl_ty\n+                );\n+                // Check that the declarations match.\n+                if !Self::structurally_same_type(cx, existing_decl_ty, this_decl_ty) {\n+                    let orig_fi = tcx.hir().expect_foreign_item(existing_hid);\n+                    let orig = Self::name_of_extern_decl(tcx, orig_fi);\n+\n+                    // We want to ensure that we use spans for both decls that include where the\n+                    // name was defined, whether that was from the link_name attribute or not.\n+                    let get_relevant_span =\n+                        |fi: &hir::ForeignItem<'_>| match Self::name_of_extern_decl(tcx, fi) {\n+                            SymbolName::Normal(_) => fi.span,\n+                            SymbolName::Link(_, annot_span) => fi.span.to(annot_span),\n+                        };\n+                    // Finally, emit the diagnostic.\n+                    tcx.struct_span_lint_hir(\n+                        CLASHING_EXTERN_DECL,\n+                        this_fi.hir_id,\n+                        get_relevant_span(this_fi),\n+                        |lint| {\n+                            let mut expected_str = DiagnosticStyledString::new();\n+                            expected_str.push(existing_decl_ty.fn_sig(tcx).to_string(), false);\n+                            let mut found_str = DiagnosticStyledString::new();\n+                            found_str.push(this_decl_ty.fn_sig(tcx).to_string(), true);\n+\n+                            lint.build(&format!(\n+                                \"`{}` redeclare{} with a different signature\",\n+                                this_fi.ident.name,\n+                                if orig.get_name() == this_fi.ident.name {\n+                                    \"d\".to_string()\n+                                } else {\n+                                    format!(\"s `{}`\", orig.get_name())\n+                                }\n+                            ))\n+                            .span_label(\n+                                get_relevant_span(orig_fi),\n+                                &format!(\"`{}` previously declared here\", orig.get_name()),\n+                            )\n+                            .span_label(\n+                                get_relevant_span(this_fi),\n+                                \"this signature doesn't match the previous declaration\",\n+                            )\n+                            .note_expected_found(&\"\", expected_str, &\"\", found_str)\n+                            .emit()\n+                        },\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "ca2ca3145abc8180391a527980dd8e8ddcc4cafe", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2", "patch": "@@ -30,6 +30,7 @@\n #![feature(bool_to_option)]\n #![feature(box_syntax)]\n #![feature(crate_visibility_modifier)]\n+#![feature(iter_order_by)]\n #![feature(never_type)]\n #![feature(nll)]\n #![feature(or_patterns)]\n@@ -154,6 +155,7 @@ macro_rules! late_lint_passes {\n                 // and change this to a module lint pass\n                 MissingDebugImplementations: MissingDebugImplementations::default(),\n                 ArrayIntoIter: ArrayIntoIter,\n+                ClashingExternDecl: ClashingExternDecl::new(),\n             ]\n         );\n     };"}, {"sha": "1d1cdda1257aa5c67e82f14b21f54b160ab88684", "filename": "src/libstd/sys/unix/args.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2/src%2Flibstd%2Fsys%2Funix%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2/src%2Flibstd%2Fsys%2Funix%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fargs.rs?ref=228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2", "patch": "@@ -205,13 +205,15 @@ mod imp {\n         #[cfg(target_arch = \"aarch64\")]\n         extern \"C\" {\n             fn objc_msgSend(obj: NsId, sel: Sel) -> NsId;\n+            #[cfg_attr(not(bootstrap), allow(clashing_extern_decl))]\n             #[link_name = \"objc_msgSend\"]\n             fn objc_msgSend_ul(obj: NsId, sel: Sel, i: libc::c_ulong) -> NsId;\n         }\n \n         #[cfg(not(target_arch = \"aarch64\"))]\n         extern \"C\" {\n             fn objc_msgSend(obj: NsId, sel: Sel, ...) -> NsId;\n+            #[cfg_attr(not(bootstrap), allow(clashing_extern_decl))]\n             #[link_name = \"objc_msgSend\"]\n             fn objc_msgSend_ul(obj: NsId, sel: Sel, ...) -> NsId;\n         }"}, {"sha": "668baefa5e4adbfe173f2a6c69e0b0d302713b24", "filename": "src/test/ui/issues/issue-1866.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2/src%2Ftest%2Fui%2Fissues%2Fissue-1866.rs", "raw_url": "https://github.com/rust-lang/rust/raw/228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2/src%2Ftest%2Fui%2Fissues%2Fissue-1866.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-1866.rs?ref=228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2", "patch": "@@ -1,6 +1,7 @@\n // build-pass\n #![allow(dead_code)]\n #![allow(non_camel_case_types)]\n+#![warn(clashing_extern_decl)]\n \n // pretty-expanded FIXME #23616\n \n@@ -20,6 +21,7 @@ mod b {\n         use super::rust_task;\n         extern {\n             pub fn rust_task_is_unwinding(rt: *const rust_task) -> bool;\n+            //~^ WARN `rust_task_is_unwinding` redeclared with a different signature\n         }\n     }\n }"}, {"sha": "13c08ebd373edf4d425eb694dd82f673ac538976", "filename": "src/test/ui/issues/issue-1866.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2/src%2Ftest%2Fui%2Fissues%2Fissue-1866.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2/src%2Ftest%2Fui%2Fissues%2Fissue-1866.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-1866.stderr?ref=228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2", "patch": "@@ -0,0 +1,19 @@\n+warning: `rust_task_is_unwinding` redeclared with a different signature\n+  --> $DIR/issue-1866.rs:23:13\n+   |\n+LL |             pub fn rust_task_is_unwinding(rt: *const rust_task) -> bool;\n+   |             ------------------------------------------------------------ `rust_task_is_unwinding` previously declared here\n+...\n+LL |             pub fn rust_task_is_unwinding(rt: *const rust_task) -> bool;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this signature doesn't match the previous declaration\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-1866.rs:4:9\n+   |\n+LL | #![warn(clashing_extern_decl)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+   = note: expected `unsafe extern \"C\" fn(*const usize) -> bool`\n+              found `unsafe extern \"C\" fn(*const bool) -> bool`\n+\n+warning: 1 warning emitted\n+"}, {"sha": "fda72a1b20e4a1c7627d4f7a75d72723541576ff", "filename": "src/test/ui/issues/issue-5791.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2/src%2Ftest%2Fui%2Fissues%2Fissue-5791.rs", "raw_url": "https://github.com/rust-lang/rust/raw/228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2/src%2Ftest%2Fui%2Fissues%2Fissue-5791.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5791.rs?ref=228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2", "patch": "@@ -1,11 +1,13 @@\n // run-pass\n #![allow(dead_code)]\n+#![warn(clashing_extern_decl)]\n // pretty-expanded FIXME #23616\n \n extern {\n     #[link_name = \"malloc\"]\n     fn malloc1(len: i32) -> *const u8;\n     #[link_name = \"malloc\"]\n+    //~^ WARN `malloc2` redeclares `malloc` with a different signature\n     fn malloc2(len: i32, foo: i32) -> *const u8;\n }\n "}, {"sha": "7ae83c43f13394141faa366fa1c6a7dbf3f8509b", "filename": "src/test/ui/issues/issue-5791.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2/src%2Ftest%2Fui%2Fissues%2Fissue-5791.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2/src%2Ftest%2Fui%2Fissues%2Fissue-5791.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5791.stderr?ref=228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2", "patch": "@@ -0,0 +1,21 @@\n+warning: `malloc2` redeclares `malloc` with a different signature\n+  --> $DIR/issue-5791.rs:9:5\n+   |\n+LL | /     #[link_name = \"malloc\"]\n+LL | |     fn malloc1(len: i32) -> *const u8;\n+   | |______________________________________- `malloc` previously declared here\n+LL | /     #[link_name = \"malloc\"]\n+LL | |\n+LL | |     fn malloc2(len: i32, foo: i32) -> *const u8;\n+   | |________________________________________________^ this signature doesn't match the previous declaration\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-5791.rs:3:9\n+   |\n+LL | #![warn(clashing_extern_decl)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+   = note: expected `unsafe extern \"C\" fn(i32) -> *const u8`\n+              found `unsafe extern \"C\" fn(i32, i32) -> *const u8`\n+\n+warning: 1 warning emitted\n+"}, {"sha": "b2caebc6fee0e7c697f68e2897611c194fd693e5", "filename": "src/test/ui/lint/auxiliary/external_extern_fn.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2/src%2Ftest%2Fui%2Flint%2Fauxiliary%2Fexternal_extern_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2/src%2Ftest%2Fui%2Flint%2Fauxiliary%2Fexternal_extern_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fauxiliary%2Fexternal_extern_fn.rs?ref=228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2", "patch": "@@ -0,0 +1,3 @@\n+extern {\n+    pub fn extern_fn(x: u8);\n+}"}, {"sha": "32f3a78f4e98001f420b01b274594dfae6386d2d", "filename": "src/test/ui/lint/clashing-extern-fn.rs", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn.rs?ref=228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2", "patch": "@@ -0,0 +1,159 @@\n+// check-pass\n+// aux-build:external_extern_fn.rs\n+#![crate_type = \"lib\"]\n+#![warn(clashing_extern_decl)]\n+\n+extern crate external_extern_fn;\n+\n+extern {\n+    fn clash(x: u8);\n+    fn no_clash(x: u8);\n+}\n+\n+fn redeclared_different_signature() {\n+    extern {\n+        fn clash(x: u64); //~ WARN `clash` redeclared with a different signature\n+    }\n+\n+    unsafe {\n+        clash(123);\n+        no_clash(123);\n+    }\n+}\n+\n+fn redeclared_same_signature() {\n+    extern {\n+        fn no_clash(x: u8);\n+    }\n+    unsafe {\n+        no_clash(123);\n+    }\n+}\n+\n+extern {\n+    fn extern_fn(x: u64);\n+}\n+\n+fn extern_clash() {\n+    extern {\n+        fn extern_fn(x: u32); //~ WARN `extern_fn` redeclared with a different signature\n+    }\n+    unsafe {\n+        extern_fn(123);\n+    }\n+}\n+\n+fn extern_no_clash() {\n+    unsafe {\n+        external_extern_fn::extern_fn(123);\n+        crate::extern_fn(123);\n+    }\n+}\n+extern {\n+    fn some_other_new_name(x: i16);\n+\n+    #[link_name = \"extern_link_name\"]\n+    fn some_new_name(x: i16);\n+\n+    #[link_name = \"link_name_same\"]\n+    fn both_names_different(x: i16);\n+}\n+\n+fn link_name_clash() {\n+    extern {\n+        fn extern_link_name(x: u32);\n+        //~^ WARN `extern_link_name` redeclared with a different signature\n+\n+        #[link_name = \"some_other_new_name\"]\n+        //~^ WARN `some_other_extern_link_name` redeclares `some_other_new_name` with a different\n+        fn some_other_extern_link_name(x: u32);\n+\n+        #[link_name = \"link_name_same\"]\n+        //~^ WARN `other_both_names_different` redeclares `link_name_same` with a different\n+        fn other_both_names_different(x: u32);\n+    }\n+}\n+\n+mod a {\n+    extern {\n+        fn different_mod(x: u8);\n+    }\n+}\n+mod b {\n+    extern {\n+        fn different_mod(x: u64); //~ WARN `different_mod` redeclared with a different signature\n+    }\n+}\n+\n+extern {\n+    fn variadic_decl(x: u8, ...);\n+}\n+\n+fn variadic_clash() {\n+    extern {\n+        fn variadic_decl(x: u8); //~ WARN `variadic_decl` redeclared with a different signature\n+    }\n+}\n+\n+#[no_mangle]\n+fn no_mangle_name(x: u8) { }\n+\n+extern {\n+    #[link_name = \"unique_link_name\"]\n+    fn link_name_specified(x: u8);\n+}\n+\n+fn tricky_no_clash() {\n+    extern {\n+        // Shouldn't warn, because the declaration above actually declares a different symbol (and\n+        // Rust's name resolution rules around shadowing will handle this gracefully).\n+        fn link_name_specified() -> u32;\n+\n+        // The case of a no_mangle name colliding with an extern decl (see #28179) is related but\n+        // shouldn't be reported by ClashingExternDecl, because this is an example of unmangled\n+        // name clash causing bad behaviour in functions with a defined body.\n+        fn no_mangle_name() -> u32;\n+    }\n+}\n+\n+mod banana {\n+    mod one {\n+        #[repr(C)] struct Banana { weight: u32, length: u16 }\n+        extern \"C\" { fn weigh_banana(count: *const Banana) -> u64; }\n+    }\n+\n+    mod two {\n+        #[repr(C)] struct Banana { weight: u32, length: u16 } // note: distinct type\n+        // This should not trigger the lint because two::Banana is structurally equivalent to\n+        // one::Banana.\n+        extern \"C\" { fn weigh_banana(count: *const Banana) -> u64; }\n+    }\n+\n+    mod three {\n+        // This _should_ trigger the lint, because repr(packed) should generate a struct that has a\n+        // different layout.\n+        #[repr(packed)] struct Banana { weight: u32, length: u16 }\n+        #[allow(improper_ctypes)]\n+        extern \"C\" { fn weigh_banana(count: *const Banana) -> u64; }\n+        //~^ WARN `weigh_banana` redeclared with a different signature\n+    }\n+}\n+\n+mod sameish_members {\n+    mod a {\n+        #[repr(C)]\n+        struct Point { x: i16, y: i16 }\n+\n+        extern \"C\" { fn draw_point(p: Point); }\n+    }\n+    mod b {\n+        #[repr(C)]\n+        struct Point { coordinates: [i16; 2] }\n+\n+        // It's possible we are overconservative for this case, as accessing the elements of the\n+        // coordinates array might end up correctly accessing `.x` and `.y`. However, this may not\n+        // always be the case, for every architecture and situation. This is also a really odd\n+        // thing to do anyway.\n+        extern \"C\" { fn draw_point(p: Point); } //~ WARN `draw_point` redeclared with a different\n+    }\n+}"}, {"sha": "fb7bf135f538c701f5449ada947d215cf8aa6f62", "filename": "src/test/ui/lint/clashing-extern-fn.stderr", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn.stderr?ref=228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2", "patch": "@@ -0,0 +1,121 @@\n+warning: `clash` redeclared with a different signature\n+  --> $DIR/clashing-extern-fn.rs:15:9\n+   |\n+LL |     fn clash(x: u8);\n+   |     ---------------- `clash` previously declared here\n+...\n+LL |         fn clash(x: u64);\n+   |         ^^^^^^^^^^^^^^^^^ this signature doesn't match the previous declaration\n+   |\n+note: the lint level is defined here\n+  --> $DIR/clashing-extern-fn.rs:4:9\n+   |\n+LL | #![warn(clashing_extern_decl)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+   = note: expected `unsafe extern \"C\" fn(u8)`\n+              found `unsafe extern \"C\" fn(u64)`\n+\n+warning: `extern_fn` redeclared with a different signature\n+  --> $DIR/clashing-extern-fn.rs:39:9\n+   |\n+LL |     fn extern_fn(x: u64);\n+   |     --------------------- `extern_fn` previously declared here\n+...\n+LL |         fn extern_fn(x: u32);\n+   |         ^^^^^^^^^^^^^^^^^^^^^ this signature doesn't match the previous declaration\n+   |\n+   = note: expected `unsafe extern \"C\" fn(u64)`\n+              found `unsafe extern \"C\" fn(u32)`\n+\n+warning: `extern_link_name` redeclared with a different signature\n+  --> $DIR/clashing-extern-fn.rs:64:9\n+   |\n+LL | /     #[link_name = \"extern_link_name\"]\n+LL | |     fn some_new_name(x: i16);\n+   | |_____________________________- `extern_link_name` previously declared here\n+...\n+LL |           fn extern_link_name(x: u32);\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this signature doesn't match the previous declaration\n+   |\n+   = note: expected `unsafe extern \"C\" fn(i16)`\n+              found `unsafe extern \"C\" fn(u32)`\n+\n+warning: `some_other_extern_link_name` redeclares `some_other_new_name` with a different signature\n+  --> $DIR/clashing-extern-fn.rs:67:9\n+   |\n+LL |       fn some_other_new_name(x: i16);\n+   |       ------------------------------- `some_other_new_name` previously declared here\n+...\n+LL | /         #[link_name = \"some_other_new_name\"]\n+LL | |\n+LL | |         fn some_other_extern_link_name(x: u32);\n+   | |_______________________________________________^ this signature doesn't match the previous declaration\n+   |\n+   = note: expected `unsafe extern \"C\" fn(i16)`\n+              found `unsafe extern \"C\" fn(u32)`\n+\n+warning: `other_both_names_different` redeclares `link_name_same` with a different signature\n+  --> $DIR/clashing-extern-fn.rs:71:9\n+   |\n+LL | /     #[link_name = \"link_name_same\"]\n+LL | |     fn both_names_different(x: i16);\n+   | |____________________________________- `link_name_same` previously declared here\n+...\n+LL | /         #[link_name = \"link_name_same\"]\n+LL | |\n+LL | |         fn other_both_names_different(x: u32);\n+   | |______________________________________________^ this signature doesn't match the previous declaration\n+   |\n+   = note: expected `unsafe extern \"C\" fn(i16)`\n+              found `unsafe extern \"C\" fn(u32)`\n+\n+warning: `different_mod` redeclared with a different signature\n+  --> $DIR/clashing-extern-fn.rs:84:9\n+   |\n+LL |         fn different_mod(x: u8);\n+   |         ------------------------ `different_mod` previously declared here\n+...\n+LL |         fn different_mod(x: u64);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^ this signature doesn't match the previous declaration\n+   |\n+   = note: expected `unsafe extern \"C\" fn(u8)`\n+              found `unsafe extern \"C\" fn(u64)`\n+\n+warning: `variadic_decl` redeclared with a different signature\n+  --> $DIR/clashing-extern-fn.rs:94:9\n+   |\n+LL |     fn variadic_decl(x: u8, ...);\n+   |     ----------------------------- `variadic_decl` previously declared here\n+...\n+LL |         fn variadic_decl(x: u8);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^ this signature doesn't match the previous declaration\n+   |\n+   = note: expected `unsafe extern \"C\" fn(u8, ...)`\n+              found `unsafe extern \"C\" fn(u8)`\n+\n+warning: `weigh_banana` redeclared with a different signature\n+  --> $DIR/clashing-extern-fn.rs:137:22\n+   |\n+LL |         extern \"C\" { fn weigh_banana(count: *const Banana) -> u64; }\n+   |                      --------------------------------------------- `weigh_banana` previously declared here\n+...\n+LL |         extern \"C\" { fn weigh_banana(count: *const Banana) -> u64; }\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this signature doesn't match the previous declaration\n+   |\n+   = note: expected `unsafe extern \"C\" fn(*const banana::one::Banana) -> u64`\n+              found `unsafe extern \"C\" fn(*const banana::three::Banana) -> u64`\n+\n+warning: `draw_point` redeclared with a different signature\n+  --> $DIR/clashing-extern-fn.rs:157:22\n+   |\n+LL |         extern \"C\" { fn draw_point(p: Point); }\n+   |                      ------------------------ `draw_point` previously declared here\n+...\n+LL |         extern \"C\" { fn draw_point(p: Point); }\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^ this signature doesn't match the previous declaration\n+   |\n+   = note: expected `unsafe extern \"C\" fn(sameish_members::a::Point)`\n+              found `unsafe extern \"C\" fn(sameish_members::b::Point)`\n+\n+warning: 9 warnings emitted\n+"}, {"sha": "ff33abfa64586356a1caec0ad316193404a4075a", "filename": "src/test/ui/lint/dead-code/lint-dead-code-3.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2/src%2Ftest%2Fui%2Flint%2Fdead-code%2Flint-dead-code-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2/src%2Ftest%2Fui%2Flint%2Fdead-code%2Flint-dead-code-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fdead-code%2Flint-dead-code-3.rs?ref=228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2", "patch": "@@ -1,5 +1,6 @@\n #![allow(unused_variables)]\n #![allow(non_camel_case_types)]\n+#![allow(clashing_extern_decl)]\n #![deny(dead_code)]\n \n #![crate_type=\"lib\"]"}, {"sha": "cf8f01ea19f0cd1409fc79570895589967209a9a", "filename": "src/test/ui/lint/dead-code/lint-dead-code-3.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2/src%2Ftest%2Fui%2Flint%2Fdead-code%2Flint-dead-code-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2/src%2Ftest%2Fui%2Flint%2Fdead-code%2Flint-dead-code-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fdead-code%2Flint-dead-code-3.stderr?ref=228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2", "patch": "@@ -1,35 +1,35 @@\n error: struct is never constructed: `Foo`\n-  --> $DIR/lint-dead-code-3.rs:13:8\n+  --> $DIR/lint-dead-code-3.rs:14:8\n    |\n LL | struct Foo;\n    |        ^^^\n    |\n note: the lint level is defined here\n-  --> $DIR/lint-dead-code-3.rs:3:9\n+  --> $DIR/lint-dead-code-3.rs:4:9\n    |\n LL | #![deny(dead_code)]\n    |         ^^^^^^^^^\n \n error: associated function is never used: `foo`\n-  --> $DIR/lint-dead-code-3.rs:15:8\n+  --> $DIR/lint-dead-code-3.rs:16:8\n    |\n LL |     fn foo(&self) {\n    |        ^^^\n \n error: function is never used: `bar`\n-  --> $DIR/lint-dead-code-3.rs:20:4\n+  --> $DIR/lint-dead-code-3.rs:21:4\n    |\n LL | fn bar() {\n    |    ^^^\n \n error: enum is never used: `c_void`\n-  --> $DIR/lint-dead-code-3.rs:59:6\n+  --> $DIR/lint-dead-code-3.rs:60:6\n    |\n LL | enum c_void {}\n    |      ^^^^^^\n \n error: function is never used: `free`\n-  --> $DIR/lint-dead-code-3.rs:61:5\n+  --> $DIR/lint-dead-code-3.rs:62:5\n    |\n LL |     fn free(p: *const c_void);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "a516aa44c657637732155b57ff57efac74ad3674", "filename": "src/test/ui/parser/extern-abi-from-mac-literal-frag.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2/src%2Ftest%2Fui%2Fparser%2Fextern-abi-from-mac-literal-frag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2/src%2Ftest%2Fui%2Fparser%2Fextern-abi-from-mac-literal-frag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fextern-abi-from-mac-literal-frag.rs?ref=228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2", "patch": "@@ -1,3 +1,4 @@\n+#![allow(clashing_extern_decl)]\n // check-pass\n \n // In this test we check that the parser accepts an ABI string when it"}]}