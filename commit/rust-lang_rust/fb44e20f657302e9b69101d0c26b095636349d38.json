{"sha": "fb44e20f657302e9b69101d0c26b095636349d38", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiNDRlMjBmNjU3MzAyZTliNjkxMDFkMGMyNmIwOTU2MzYzNDlkMzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-09T11:51:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-09T11:51:27Z"}, "message": "auto merge of #11394 : alexcrichton/rust/no-decorator, r=cmr\n\nThis is just an unnecessary trait that no one's ever going to parameterize over\r\nand it's more useful to just define the methods directly on the types\r\nthemselves. The implementors of this type almost always don't want\r\ninner_mut_ref() but they're forced to define it as well.", "tree": {"sha": "42d33246c2e96cae456673eb854f000ea5b02c52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42d33246c2e96cae456673eb854f000ea5b02c52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb44e20f657302e9b69101d0c26b095636349d38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb44e20f657302e9b69101d0c26b095636349d38", "html_url": "https://github.com/rust-lang/rust/commit/fb44e20f657302e9b69101d0c26b095636349d38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb44e20f657302e9b69101d0c26b095636349d38/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c34fc5e33b9e7839fb887790959bde64999bf745", "url": "https://api.github.com/repos/rust-lang/rust/commits/c34fc5e33b9e7839fb887790959bde64999bf745", "html_url": "https://github.com/rust-lang/rust/commit/c34fc5e33b9e7839fb887790959bde64999bf745"}, {"sha": "6df57ec2e2cf4dc956b43c05fe7c6d6006f0a80a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6df57ec2e2cf4dc956b43c05fe7c6d6006f0a80a", "html_url": "https://github.com/rust-lang/rust/commit/6df57ec2e2cf4dc956b43c05fe7c6d6006f0a80a"}], "stats": {"total": 392, "additions": 145, "deletions": 247}, "files": [{"sha": "3798ed8617e4bff11caeb55863b778a1f5fcf951", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=fb44e20f657302e9b69101d0c26b095636349d38", "patch": "@@ -935,7 +935,6 @@ mod tests {\n     use serialize::Encodable;\n     use serialize;\n \n-    use std::io::Decorator;\n     use std::io::mem::MemWriter;\n     use std::option::{None, Option, Some};\n \n@@ -948,7 +947,7 @@ mod tests {\n                 let mut ebml_w = writer::Encoder(&mut wr);\n                 v.encode(&mut ebml_w);\n             }\n-            let ebml_doc = reader::Doc(*wr.inner_ref());\n+            let ebml_doc = reader::Doc(wr.get_ref());\n             let mut deser = reader::Decoder(ebml_doc);\n             let v1 = serialize::Decodable::decode(&mut deser);\n             debug!(\"v1 == {:?}\", v1);"}, {"sha": "68eb4e1e5aca91b6e04673064789761e96269ee6", "filename": "src/libextra/json.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=fb44e20f657302e9b69101d0c26b095636349d38", "patch": "@@ -21,7 +21,6 @@ use std::cast::transmute;\n use std::f64;\n use std::hashmap::HashMap;\n use std::io;\n-use std::io::Decorator;\n use std::io::mem::MemWriter;\n use std::num;\n use std::str;\n@@ -464,7 +463,7 @@ impl Json{\n     pub fn to_pretty_str(&self) -> ~str {\n         let mut s = MemWriter::new();\n         self.to_pretty_writer(&mut s as &mut io::Writer);\n-        str::from_utf8_owned(s.inner())\n+        str::from_utf8_owned(s.unwrap())\n     }\n }\n \n@@ -1321,7 +1320,7 @@ impl to_str::ToStr for Json {\n     fn to_str(&self) -> ~str {\n         let mut s = MemWriter::new();\n         self.to_writer(&mut s as &mut io::Writer);\n-        str::from_utf8_owned(s.inner())\n+        str::from_utf8_owned(s.unwrap())\n     }\n }\n \n@@ -1508,12 +1507,11 @@ mod tests {\n \n     fn with_str_writer(f: |&mut io::Writer|) -> ~str {\n         use std::io::mem::MemWriter;\n-        use std::io::Decorator;\n         use std::str;\n \n         let mut m = MemWriter::new();\n         f(&mut m as &mut io::Writer);\n-        str::from_utf8_owned(m.inner())\n+        str::from_utf8_owned(m.unwrap())\n     }\n \n     #[test]"}, {"sha": "7e715c82f9f87741326657bc4c5b0b94a304140c", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=fb44e20f657302e9b69101d0c26b095636349d38", "patch": "@@ -991,10 +991,9 @@ mod tests {\n     fn test_boxplot_nonpositive() {\n         fn t(s: &Summary, expected: ~str) {\n             use std::io::mem::MemWriter;\n-            use std::io::Decorator;\n             let mut m = MemWriter::new();\n             write_boxplot(&mut m as &mut io::Writer, s, 30);\n-            let out = str::from_utf8_owned(m.inner());\n+            let out = str::from_utf8_owned(m.unwrap());\n             assert_eq!(out, expected);\n         }\n "}, {"sha": "ca5c4cfa85bfb3e353e8f8d1ba957ae02490da5c", "filename": "src/libextra/term.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibextra%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibextra%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterm.rs?ref=fb44e20f657302e9b69101d0c26b095636349d38", "patch": "@@ -13,8 +13,6 @@\n #[allow(missing_doc)];\n \n \n-use std::io::{Decorator, Writer};\n-\n use std::os;\n use terminfo::*;\n use terminfo::searcher::open;\n@@ -234,20 +232,12 @@ impl<T: Writer> Terminal<T> {\n             color-8\n         } else { color }\n     }\n-}\n \n-impl<T: Writer> Decorator<T> for Terminal<T> {\n-    fn inner(self) -> T {\n-        self.out\n-    }\n+    pub fn unwrap(self) -> T { self.out }\n \n-    fn inner_ref<'a>(&'a self) -> &'a T {\n-        &self.out\n-    }\n+    pub fn get_ref<'a>(&'a self) -> &'a T { &self.out }\n \n-    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut T {\n-        &mut self.out\n-    }\n+    pub fn get_mut<'a>(&'a mut self) -> &'a mut T { &mut self.out }\n }\n \n impl<T: Writer> Writer for Terminal<T> {"}, {"sha": "6881d1044428978e5249d487fbe10a6f05750ed7", "filename": "src/libextra/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=fb44e20f657302e9b69101d0c26b095636349d38", "patch": "@@ -673,7 +673,6 @@ pub fn run_tests_console(opts: &TestOpts,\n \n #[test]\n fn should_sort_failures_before_printing_them() {\n-    use std::io::Decorator;\n     use std::io::mem::MemWriter;\n     use std::str;\n \n@@ -705,7 +704,7 @@ fn should_sort_failures_before_printing_them() {\n \n     st.write_failures();\n     let s = match st.out {\n-        Raw(ref m) => str::from_utf8(*m.inner_ref()),\n+        Raw(ref m) => str::from_utf8(m.get_ref()),\n         Pretty(_) => unreachable!()\n     };\n "}, {"sha": "5a5b3814b742c774ed062868f54bafd9663124c8", "filename": "src/libextra/uuid.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibextra%2Fuuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibextra%2Fuuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuuid.rs?ref=fb44e20f657302e9b69101d0c26b095636349d38", "patch": "@@ -522,7 +522,6 @@ mod test {\n     use std::str;\n     use std::rand;\n     use std::num::Zero;\n-    use std::io::Decorator;\n     use std::io::mem::MemWriter;\n \n     #[test]\n@@ -798,7 +797,7 @@ mod test {\n         let u = Uuid::new_v4();\n         let mut wr = MemWriter::new();\n         u.encode(&mut ebml::writer::Encoder(&mut wr));\n-        let doc = ebml::reader::Doc(wr.inner_ref().as_slice());\n+        let doc = ebml::reader::Doc(wr.get_ref());\n         let u2 = Decodable::decode(&mut ebml::reader::Decoder(doc));\n         assert_eq!(u, u2);\n     }"}, {"sha": "31f5091dd5fec99a90d8305c7c35d97814fb7e3f", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=fb44e20f657302e9b69101d0c26b095636349d38", "patch": "@@ -17,7 +17,7 @@ use arc::{Arc,RWArc};\n use treemap::TreeMap;\n use std::str;\n use std::io;\n-use std::io::{File, Decorator};\n+use std::io::File;\n use std::io::mem::MemWriter;\n \n /**\n@@ -261,7 +261,7 @@ fn json_encode<'a, T:Encodable<json::Encoder<'a>>>(t: &T) -> ~str {\n     let mut writer = MemWriter::new();\n     let mut encoder = json::Encoder::new(&mut writer as &mut io::Writer);\n     t.encode(&mut encoder);\n-    str::from_utf8_owned(writer.inner())\n+    str::from_utf8_owned(writer.unwrap())\n }\n \n // FIXME(#5121)"}, {"sha": "0f5d5d293d6791014e3e24d4243a01f4f39876b5", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=fb44e20f657302e9b69101d0c26b095636349d38", "patch": "@@ -25,7 +25,6 @@ use std::cast;\n use std::cell::{Cell, RefCell};\n use std::hashmap::{HashMap, HashSet};\n use std::io::mem::MemWriter;\n-use std::io::{Writer, Seek, Decorator};\n use std::str;\n use std::vec;\n \n@@ -1807,7 +1806,7 @@ pub static metadata_encoding_version : &'static [u8] =\n pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n     let mut wr = MemWriter::new();\n     encode_metadata_inner(&mut wr, parms, crate);\n-    wr.inner()\n+    wr.unwrap()\n }\n \n fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, crate: &Crate) {\n@@ -1900,7 +1899,7 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, crate: &Crate)\n     ecx.stats.total_bytes.set(ebml_w.writer.tell());\n \n     if (tcx.sess.meta_stats()) {\n-        for e in ebml_w.writer.inner_ref().iter() {\n+        for e in ebml_w.writer.get_ref().iter() {\n             if *e == 0 {\n                 ecx.stats.zero_bytes.set(ecx.stats.zero_bytes.get() + 1);\n             }\n@@ -1930,5 +1929,5 @@ pub fn encoded_ty(tcx: ty::ctxt, t: ty::t) -> ~str {\n         abbrevs: tyencode::ac_no_abbrevs};\n     let mut wr = MemWriter::new();\n     tyencode::enc_ty(&mut wr, cx, t);\n-    str::from_utf8_owned(wr.inner_ref().to_owned())\n+    str::from_utf8_owned(wr.get_ref().to_owned())\n }"}, {"sha": "448e15352ca20b277bdda2bfc74c70d929af796c", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=fb44e20f657302e9b69101d0c26b095636349d38", "patch": "@@ -13,7 +13,6 @@\n use std::cell::RefCell;\n use std::hashmap::HashMap;\n use std::io;\n-use std::io::{Decorator, Writer, Seek};\n use std::io::mem::MemWriter;\n use std::str;\n use std::fmt;\n@@ -73,7 +72,7 @@ pub fn enc_ty(w: &mut MemWriter, cx: @ctxt, t: ty::t) {\n             None => {\n                 let wr = &mut MemWriter::new();\n                 enc_sty(wr, cx, &ty::get(t).sty);\n-                let s = str::from_utf8(*wr.inner_ref()).to_managed();\n+                let s = str::from_utf8(wr.get_ref()).to_managed();\n                 let mut short_names_cache = cx.tcx\n                                               .short_names_cache\n                                               .borrow_mut();"}, {"sha": "b0f0c71e91d90abb2144a2d5de78055fe092a2c3", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=fb44e20f657302e9b69101d0c26b095636349d38", "patch": "@@ -1465,7 +1465,6 @@ fn mk_ctxt() -> @fake_ext_ctxt {\n \n #[cfg(test)]\n fn roundtrip(in_item: Option<@ast::item>) {\n-    use std::io::Decorator;\n     use std::io::mem::MemWriter;\n \n     let in_item = in_item.unwrap();\n@@ -1474,7 +1473,7 @@ fn roundtrip(in_item: Option<@ast::item>) {\n         let mut ebml_w = writer::Encoder(&mut wr);\n         encode_item_ast(&mut ebml_w, in_item);\n     }\n-    let ebml_doc = reader::Doc(wr.inner_ref().as_slice());\n+    let ebml_doc = reader::Doc(wr.get_ref());\n     let out_item = decode_item_ast(ebml_doc);\n \n     assert_eq!(in_item, out_item);"}, {"sha": "28c4d721c84099c6366edabf35e00e4518472220", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=fb44e20f657302e9b69101d0c26b095636349d38", "patch": "@@ -23,7 +23,6 @@ use std::local_data;\n use std::io;\n use std::io::File;\n use std::io::mem::MemWriter;\n-use std::io::Decorator;\n use std::str;\n use extra::getopts;\n use extra::getopts::groups;\n@@ -322,7 +321,7 @@ fn json_output(crate: clean::Crate, res: ~[plugins::PluginJson], dst: Path) {\n             let mut encoder = json::Encoder::new(&mut w as &mut io::Writer);\n             crate.encode(&mut encoder);\n         }\n-        str::from_utf8_owned(w.inner())\n+        str::from_utf8_owned(w.unwrap())\n     };\n     let crate_json = match json::from_str(crate_json_str) {\n         Ok(j) => j,"}, {"sha": "8de406f306f4ee400825355713b668f9e71fa186", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=fb44e20f657302e9b69101d0c26b095636349d38", "patch": "@@ -470,7 +470,6 @@ use prelude::*;\n \n use cast;\n use char::Char;\n-use io::Decorator;\n use io::mem::MemWriter;\n use io;\n use str;\n@@ -692,7 +691,7 @@ pub fn format(args: &Arguments) -> ~str {\n pub unsafe fn format_unsafe(fmt: &[rt::Piece], args: &[Argument]) -> ~str {\n     let mut output = MemWriter::new();\n     write_unsafe(&mut output as &mut io::Writer, fmt, args);\n-    return str::from_utf8_owned(output.inner());\n+    return str::from_utf8_owned(output.unwrap());\n }\n \n impl<'a> Formatter<'a> {"}, {"sha": "96cb59ce77828d7cadd859189856846d9c73b7a9", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 80, "deletions": 64, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=fb44e20f657302e9b69101d0c26b095636349d38", "patch": "@@ -55,7 +55,7 @@ use prelude::*;\n \n use num;\n use vec;\n-use super::{Stream, Decorator};\n+use super::Stream;\n \n // libuv recommends 64k buffers to maximize throughput\n // https://groups.google.com/forum/#!topic/libuv/oQO1HJAIDdA\n@@ -92,6 +92,17 @@ impl<R: Reader> BufferedReader<R> {\n     pub fn new(inner: R) -> BufferedReader<R> {\n         BufferedReader::with_capacity(DEFAULT_CAPACITY, inner)\n     }\n+\n+    /// Gets a reference to the underlying reader.\n+    ///\n+    /// This type does not expose the ability to get a mutable reference to the\n+    /// underlying reader because that could possibly corrupt the buffer.\n+    pub fn get_ref<'a>(&'a self) -> &'a R { &self.inner }\n+\n+    /// Unwraps this buffer, returning the underlying reader.\n+    ///\n+    /// Note that any leftover data in the internal buffer is lost.\n+    pub fn unwrap(self) -> R { self.inner }\n }\n \n impl<R: Reader> Buffer for BufferedReader<R> {\n@@ -134,12 +145,6 @@ impl<R: Reader> Reader for BufferedReader<R> {\n     }\n }\n \n-impl<R: Reader> Decorator<R> for BufferedReader<R> {\n-    fn inner(self) -> R { self.inner }\n-    fn inner_ref<'a>(&'a self) -> &'a R { &self.inner }\n-    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut R { &mut self.inner }\n-}\n-\n /// Wraps a Writer and buffers output to it\n ///\n /// Note that `BufferedWriter` will NOT flush its buffer when dropped.\n@@ -173,6 +178,20 @@ impl<W: Writer> BufferedWriter<W> {\n             self.pos = 0;\n         }\n     }\n+\n+    /// Gets a reference to the underlying writer.\n+    ///\n+    /// This type does not expose the ability to get a mutable reference to the\n+    /// underlying reader because that could possibly corrupt the buffer.\n+    pub fn get_ref<'a>(&'a self) -> &'a W { &self.inner }\n+\n+    /// Unwraps this buffer, returning the underlying writer.\n+    ///\n+    /// The buffer is flushed before returning the writer.\n+    pub fn unwrap(mut self) -> W {\n+        self.flush_buf();\n+        self.inner\n+    }\n }\n \n impl<W: Writer> Writer for BufferedWriter<W> {\n@@ -196,12 +215,6 @@ impl<W: Writer> Writer for BufferedWriter<W> {\n     }\n }\n \n-impl<W: Writer> Decorator<W> for BufferedWriter<W> {\n-    fn inner(mut self) -> W { self.flush_buf(); self.inner }\n-    fn inner_ref<'a>(&'a self) -> &'a W { &self.inner }\n-    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut W { &mut self.inner }\n-}\n-\n /// Wraps a Writer and buffers output to it, flushing whenever a newline (`0x0a`,\n /// `'\\n'`) is detected.\n ///\n@@ -218,6 +231,17 @@ impl<W: Writer> LineBufferedWriter<W> {\n             inner: BufferedWriter::with_capacity(1024, inner)\n         }\n     }\n+\n+    /// Gets a reference to the underlying writer.\n+    ///\n+    /// This type does not expose the ability to get a mutable reference to the\n+    /// underlying reader because that could possibly corrupt the buffer.\n+    pub fn get_ref<'a>(&'a self) -> &'a W { self.inner.get_ref() }\n+\n+    /// Unwraps this buffer, returning the underlying writer.\n+    ///\n+    /// The internal buffer is flushed before returning the writer.\n+    pub fn unwrap(mut self) -> W { self.inner.unwrap() }\n }\n \n impl<W: Writer> Writer for LineBufferedWriter<W> {\n@@ -235,12 +259,6 @@ impl<W: Writer> Writer for LineBufferedWriter<W> {\n     fn flush(&mut self) { self.inner.flush() }\n }\n \n-impl<W: Writer> Decorator<W> for LineBufferedWriter<W> {\n-    fn inner(self) -> W { self.inner.inner() }\n-    fn inner_ref<'a>(&'a self) -> &'a W { self.inner.inner_ref() }\n-    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut W { self.inner.inner_mut_ref() }\n-}\n-\n struct InternalBufferedWriter<W>(BufferedWriter<W>);\n \n impl<W> InternalBufferedWriter<W> {\n@@ -250,21 +268,6 @@ impl<W> InternalBufferedWriter<W> {\n     }\n }\n \n-impl<W: Writer> Decorator<W> for InternalBufferedWriter<W> {\n-    fn inner(self) -> W {\n-        let InternalBufferedWriter(s) = self;\n-        s.inner()\n-    }\n-    fn inner_ref<'a>(&'a self) -> &'a W {\n-        let InternalBufferedWriter(ref s) = *self;\n-        s.inner_ref()\n-    }\n-    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut W {\n-        let InternalBufferedWriter(ref mut s) = *self;\n-        s.inner_mut_ref()\n-    }\n-}\n-\n impl<W: Reader> Reader for InternalBufferedWriter<W> {\n     fn read(&mut self, buf: &mut [u8]) -> Option<uint> { self.get_mut_ref().inner.read(buf) }\n     fn eof(&mut self) -> bool { self.get_mut_ref().inner.eof() }\n@@ -278,6 +281,8 @@ pub struct BufferedStream<S> {\n }\n \n impl<S: Stream> BufferedStream<S> {\n+    /// Creates a new buffered stream with explicitly listed capacities for the\n+    /// reader/writer buffer.\n     pub fn with_capacities(reader_cap: uint, writer_cap: uint, inner: S)\n                            -> BufferedStream<S> {\n         let writer = BufferedWriter::with_capacity(writer_cap, inner);\n@@ -287,10 +292,30 @@ impl<S: Stream> BufferedStream<S> {\n         BufferedStream { inner: reader }\n     }\n \n+    /// Creates a new buffered stream with the default reader/writer buffer\n+    /// capacities.\n     pub fn new(inner: S) -> BufferedStream<S> {\n         BufferedStream::with_capacities(DEFAULT_CAPACITY, DEFAULT_CAPACITY,\n                                         inner)\n     }\n+\n+    /// Gets a reference to the underlying stream.\n+    ///\n+    /// This type does not expose the ability to get a mutable reference to the\n+    /// underlying reader because that could possibly corrupt the buffer.\n+    pub fn get_ref<'a>(&'a self) -> &'a S {\n+        let InternalBufferedWriter(ref w) = self.inner.inner;\n+        w.get_ref()\n+    }\n+\n+    /// Unwraps this buffer, returning the underlying stream.\n+    ///\n+    /// The internal buffer is flushed before returning the stream. Any leftover\n+    /// data in the read buffer is lost.\n+    pub fn unwrap(self) -> S {\n+        let InternalBufferedWriter(w) = self.inner.inner;\n+        w.unwrap()\n+    }\n }\n \n impl<S: Stream> Buffer for BufferedStream<S> {\n@@ -308,17 +333,8 @@ impl<S: Stream> Writer for BufferedStream<S> {\n     fn flush(&mut self) { self.inner.inner.get_mut_ref().flush() }\n }\n \n-impl<S: Stream> Decorator<S> for BufferedStream<S> {\n-    fn inner(self) -> S { self.inner.inner.inner() }\n-    fn inner_ref<'a>(&'a self) -> &'a S { self.inner.inner.inner_ref() }\n-    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut S {\n-        self.inner.inner.get_mut_ref().inner_mut_ref()\n-    }\n-}\n-\n #[cfg(test)]\n mod test {\n-    use io::Decorator;\n     use io;\n     use prelude::*;\n     use super::*;\n@@ -397,45 +413,45 @@ mod test {\n         let mut writer = BufferedWriter::with_capacity(2, inner);\n \n         writer.write([0, 1]);\n-        assert_eq!([], writer.inner_ref().inner_ref().as_slice());\n+        assert_eq!([], writer.get_ref().get_ref());\n \n         writer.write([2]);\n-        assert_eq!([0, 1], writer.inner_ref().inner_ref().as_slice());\n+        assert_eq!([0, 1], writer.get_ref().get_ref());\n \n         writer.write([3]);\n-        assert_eq!([0, 1], writer.inner_ref().inner_ref().as_slice());\n+        assert_eq!([0, 1], writer.get_ref().get_ref());\n \n         writer.flush();\n-        assert_eq!([0, 1, 2, 3], writer.inner_ref().inner_ref().as_slice());\n+        assert_eq!([0, 1, 2, 3], writer.get_ref().get_ref());\n \n         writer.write([4]);\n         writer.write([5]);\n-        assert_eq!([0, 1, 2, 3], writer.inner_ref().inner_ref().as_slice());\n+        assert_eq!([0, 1, 2, 3], writer.get_ref().get_ref());\n \n         writer.write([6]);\n         assert_eq!([0, 1, 2, 3, 4, 5],\n-                   writer.inner_ref().inner_ref().as_slice());\n+                   writer.get_ref().get_ref());\n \n         writer.write([7, 8]);\n         assert_eq!([0, 1, 2, 3, 4, 5, 6],\n-                   writer.inner_ref().inner_ref().as_slice());\n+                   writer.get_ref().get_ref());\n \n         writer.write([9, 10, 11]);\n         assert_eq!([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n-                   writer.inner_ref().inner_ref().as_slice());\n+                   writer.get_ref().get_ref());\n \n         writer.flush();\n         assert_eq!([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n-                   writer.inner_ref().inner_ref().as_slice());\n+                   writer.get_ref().get_ref());\n     }\n \n     #[test]\n     fn test_buffered_writer_inner_flushes() {\n         let mut w = BufferedWriter::with_capacity(3, MemWriter::new());\n         w.write([0, 1]);\n-        assert_eq!([], w.inner_ref().inner_ref().as_slice());\n-        let w = w.inner();\n-        assert_eq!([0, 1], w.inner_ref().as_slice());\n+        assert_eq!([], w.get_ref().get_ref());\n+        let w = w.unwrap();\n+        assert_eq!([0, 1], w.get_ref());\n     }\n \n     // This is just here to make sure that we don't infinite loop in the\n@@ -476,20 +492,20 @@ mod test {\n     fn test_line_buffer() {\n         let mut writer = LineBufferedWriter::new(MemWriter::new());\n         writer.write([0]);\n-        assert_eq!(*writer.inner_ref().inner_ref(), ~[]);\n+        assert_eq!(writer.get_ref().get_ref(), []);\n         writer.write([1]);\n-        assert_eq!(*writer.inner_ref().inner_ref(), ~[]);\n+        assert_eq!(writer.get_ref().get_ref(), []);\n         writer.flush();\n-        assert_eq!(*writer.inner_ref().inner_ref(), ~[0, 1]);\n+        assert_eq!(writer.get_ref().get_ref(), [0, 1]);\n         writer.write([0, '\\n' as u8, 1, '\\n' as u8, 2]);\n-        assert_eq!(*writer.inner_ref().inner_ref(),\n-            ~[0, 1, 0, '\\n' as u8, 1, '\\n' as u8]);\n+        assert_eq!(writer.get_ref().get_ref(),\n+            [0, 1, 0, '\\n' as u8, 1, '\\n' as u8]);\n         writer.flush();\n-        assert_eq!(*writer.inner_ref().inner_ref(),\n-            ~[0, 1, 0, '\\n' as u8, 1, '\\n' as u8, 2]);\n+        assert_eq!(writer.get_ref().get_ref(),\n+            [0, 1, 0, '\\n' as u8, 1, '\\n' as u8, 2]);\n         writer.write([3, '\\n' as u8]);\n-        assert_eq!(*writer.inner_ref().inner_ref(),\n-            ~[0, 1, 0, '\\n' as u8, 1, '\\n' as u8, 2, 3, '\\n' as u8]);\n+        assert_eq!(writer.get_ref().get_ref(),\n+            [0, 1, 0, '\\n' as u8, 1, '\\n' as u8, 2, 3, '\\n' as u8]);\n     }\n \n     #[test]"}, {"sha": "3ad05348960cc2f5e4ec75a2a43b77ace80646ab", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=fb44e20f657302e9b69101d0c26b095636349d38", "patch": "@@ -132,7 +132,6 @@ pub fn u64_from_be_bytes(data: &[u8],\n #[cfg(test)]\n mod test {\n     use unstable::finally::Finally;\n-    use io::Decorator;\n     use prelude::*;\n     use io::mem::{MemReader, MemWriter};\n     use io::{io_error, placeholder_error};\n@@ -419,7 +418,7 @@ mod test {\n             writer.write_le_u64(*i);\n         }\n \n-        let mut reader = MemReader::new(writer.inner());\n+        let mut reader = MemReader::new(writer.unwrap());\n         for i in uints.iter() {\n             assert!(reader.read_le_u64() == *i);\n         }\n@@ -435,7 +434,7 @@ mod test {\n             writer.write_be_u64(*i);\n         }\n \n-        let mut reader = MemReader::new(writer.inner());\n+        let mut reader = MemReader::new(writer.unwrap());\n         for i in uints.iter() {\n             assert!(reader.read_be_u64() == *i);\n         }\n@@ -450,7 +449,7 @@ mod test {\n             writer.write_be_i32(*i);\n         }\n \n-        let mut reader = MemReader::new(writer.inner());\n+        let mut reader = MemReader::new(writer.unwrap());\n         for i in ints.iter() {\n             // this tests that the sign extension is working\n             // (comparing the values as i32 would not test this)\n@@ -466,7 +465,7 @@ mod test {\n         let mut writer = MemWriter::new();\n         writer.write(buf);\n \n-        let mut reader = MemReader::new(writer.inner());\n+        let mut reader = MemReader::new(writer.unwrap());\n         let f = reader.read_be_f32();\n         assert!(f == 8.1250);\n     }\n@@ -479,7 +478,7 @@ mod test {\n         writer.write_be_f32(f);\n         writer.write_le_f32(f);\n \n-        let mut reader = MemReader::new(writer.inner());\n+        let mut reader = MemReader::new(writer.unwrap());\n         assert!(reader.read_be_f32() == 8.1250);\n         assert!(reader.read_le_f32() == 8.1250);\n     }"}, {"sha": "c56bdf5bec8f3c60a565f37cbdc97fa2bad20f94", "filename": "src/libstd/io/flate.rs", "status": "modified", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibstd%2Fio%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibstd%2Fio%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fflate.rs?ref=fb44e20f657302e9b69101d0c26b095636349d38", "patch": "@@ -34,26 +34,6 @@ impl<W: Writer> Writer for DeflateWriter<W> {\n     fn flush(&mut self) { fail!() }\n }\n \n-impl<W: Writer> Decorator<W> for DeflateWriter<W> {\n-    fn inner(self) -> W {\n-        match self {\n-            DeflateWriter { inner_writer: w } => w\n-        }\n-    }\n-\n-    fn inner_ref<'a>(&'a self) -> &'a W {\n-        match *self {\n-            DeflateWriter { inner_writer: ref w } => w\n-        }\n-    }\n-\n-    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut W {\n-        match *self {\n-            DeflateWriter { inner_writer: ref mut w } => w\n-        }\n-    }\n-}\n-\n /// A Reader decorator that decompresses using the 'deflate' scheme\n pub struct InflateReader<R> {\n     priv inner_reader: R\n@@ -72,52 +52,3 @@ impl<R: Reader> Reader for InflateReader<R> {\n \n     fn eof(&mut self) -> bool { fail!() }\n }\n-\n-impl<R: Reader> Decorator<R> for InflateReader<R> {\n-    fn inner(self) -> R {\n-        match self {\n-            InflateReader { inner_reader: r } => r\n-        }\n-    }\n-\n-    fn inner_ref<'a>(&'a self) -> &'a R {\n-        match *self {\n-            InflateReader { inner_reader: ref r } => r\n-        }\n-    }\n-\n-    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut R {\n-        match *self {\n-            InflateReader { inner_reader: ref mut r } => r\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use prelude::*;\n-    use super::*;\n-    use super::super::mem::*;\n-    use super::super::Decorator;\n-\n-    use str;\n-\n-    #[test]\n-    #[ignore]\n-    fn smoke_test() {\n-        let mem_writer = MemWriter::new();\n-        let mut deflate_writer = DeflateWriter::new(mem_writer);\n-        let in_msg: &str = \"test\";\n-        let in_bytes = in_msg.as_bytes();\n-        deflate_writer.write(in_bytes);\n-        deflate_writer.flush();\n-        let buf = deflate_writer.inner().inner();\n-        let mem_reader = MemReader::new(buf);\n-        let mut inflate_reader = InflateReader::new(mem_reader);\n-        let mut out_bytes = [0, .. 100];\n-        let bytes_read = inflate_reader.read(out_bytes).unwrap();\n-        assert_eq!(bytes_read, in_bytes.len());\n-        let out_msg = str::from_utf8(out_bytes);\n-        assert_eq!(in_msg, out_msg);\n-    }\n-}"}, {"sha": "95cf7ab40781a7c8a1a910245dc5c2c999a7fba9", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 30, "deletions": 21, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=fb44e20f657302e9b69101d0c26b095636349d38", "patch": "@@ -36,6 +36,16 @@ impl MemWriter {\n     pub fn with_capacity(n: uint) -> MemWriter {\n         MemWriter { buf: vec::with_capacity(n), pos: 0 }\n     }\n+\n+    /// Acquires an immutable reference to the underlying buffer of this\n+    /// `MemWriter`.\n+    ///\n+    /// No method is exposed for acquiring a mutable reference to the buffer\n+    /// because it could corrupt the state of this `MemWriter`.\n+    pub fn get_ref<'a>(&'a self) -> &'a [u8] { self.buf.as_slice() }\n+\n+    /// Unwraps this `MemWriter`, returning the underlying buffer\n+    pub fn unwrap(self) -> ~[u8] { self.buf }\n }\n \n impl Writer for MemWriter {\n@@ -85,25 +95,31 @@ impl Seek for MemWriter {\n     }\n }\n \n-impl Decorator<~[u8]> for MemWriter {\n-    fn inner(self) -> ~[u8] { self.buf }\n-    fn inner_ref<'a>(&'a self) -> &'a ~[u8] { &self.buf }\n-    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut ~[u8] { &mut self.buf }\n-}\n-\n /// Reads from an owned byte vector\n pub struct MemReader {\n     priv buf: ~[u8],\n     priv pos: uint\n }\n \n impl MemReader {\n+    /// Creates a new `MemReader` which will read the buffer given. The buffer\n+    /// can be re-acquired through `unwrap`\n     pub fn new(buf: ~[u8]) -> MemReader {\n         MemReader {\n             buf: buf,\n             pos: 0\n         }\n     }\n+\n+    /// Acquires an immutable reference to the underlying buffer of this\n+    /// `MemReader`.\n+    ///\n+    /// No method is exposed for acquiring a mutable reference to the buffer\n+    /// because it could corrupt the state of this `MemReader`.\n+    pub fn get_ref<'a>(&'a self) -> &'a [u8] { self.buf.as_slice() }\n+\n+    /// Unwraps this `MemReader`, returning the underlying buffer\n+    pub fn unwrap(self) -> ~[u8] { self.buf }\n }\n \n impl Reader for MemReader {\n@@ -136,13 +152,6 @@ impl Buffer for MemReader {\n     fn consume(&mut self, amt: uint) { self.pos += amt; }\n }\n \n-impl Decorator<~[u8]> for MemReader {\n-    fn inner(self) -> ~[u8] { self.buf }\n-    fn inner_ref<'a>(&'a self) -> &'a ~[u8] { &self.buf }\n-    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut ~[u8] { &mut self.buf }\n-}\n-\n-\n /// Writes to a fixed-size byte slice\n ///\n /// If a write will not fit in the buffer, it raises the `io_error`\n@@ -247,7 +256,7 @@ impl<'a> Buffer for BufReader<'a> {\n pub fn with_mem_writer(writeFn: |&mut MemWriter|) -> ~[u8] {\n     let mut writer = MemWriter::new();\n     writeFn(&mut writer);\n-    writer.inner()\n+    writer.unwrap()\n }\n \n #[cfg(test)]\n@@ -265,24 +274,24 @@ mod test {\n         writer.write([1, 2, 3]);\n         writer.write([4, 5, 6, 7]);\n         assert_eq!(writer.tell(), 8);\n-        assert_eq!(*writer.inner_ref(), ~[0, 1, 2, 3, 4, 5, 6, 7]);\n+        assert_eq!(writer.get_ref(), [0, 1, 2, 3, 4, 5, 6, 7]);\n \n         writer.seek(0, SeekSet);\n         assert_eq!(writer.tell(), 0);\n         writer.write([3, 4]);\n-        assert_eq!(*writer.inner_ref(), ~[3, 4, 2, 3, 4, 5, 6, 7]);\n+        assert_eq!(writer.get_ref(), [3, 4, 2, 3, 4, 5, 6, 7]);\n \n         writer.seek(1, SeekCur);\n         writer.write([0, 1]);\n-        assert_eq!(*writer.inner_ref(), ~[3, 4, 2, 0, 1, 5, 6, 7]);\n+        assert_eq!(writer.get_ref(), [3, 4, 2, 0, 1, 5, 6, 7]);\n \n         writer.seek(-1, SeekEnd);\n         writer.write([1, 2]);\n-        assert_eq!(*writer.inner_ref(), ~[3, 4, 2, 0, 1, 5, 6, 1, 2]);\n+        assert_eq!(writer.get_ref(), [3, 4, 2, 0, 1, 5, 6, 1, 2]);\n \n         writer.seek(1, SeekEnd);\n         writer.write([1]);\n-        assert_eq!(*writer.inner_ref(), ~[3, 4, 2, 0, 1, 5, 6, 1, 2, 0, 1]);\n+        assert_eq!(writer.get_ref(), [3, 4, 2, 0, 1, 5, 6, 1, 2, 0, 1]);\n     }\n \n     #[test]\n@@ -415,7 +424,7 @@ mod test {\n         writer.write_str(\"testing\");\n         writer.write_line(\"testing\");\n         writer.write_str(\"testing\");\n-        let mut r = BufReader::new(*writer.inner_ref());\n+        let mut r = BufReader::new(writer.get_ref());\n         assert_eq!(r.read_to_str(), ~\"testingtesting\\ntesting\");\n     }\n \n@@ -425,7 +434,7 @@ mod test {\n         writer.write_char('a');\n         writer.write_char('\\n');\n         writer.write_char('\u1ec7');\n-        let mut r = BufReader::new(*writer.inner_ref());\n+        let mut r = BufReader::new(writer.get_ref());\n         assert_eq!(r.read_to_str(), ~\"a\\n\u1ec7\");\n     }\n "}, {"sha": "a40999a80421dcfa9d32fe4e7f71b7d2d161129e", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=fb44e20f657302e9b69101d0c26b095636349d38", "patch": "@@ -113,7 +113,6 @@ Some examples of obvious things you might want to do\n * Writer - An I/O sink, writes bytes from a buffer\n * Stream - Typical I/O sources like files and sockets are both Readers and Writers,\n   and are collectively referred to a `streams`.\n-* Decorator - A Reader or Writer that composes with others to add additional capabilities\n   such as encoding or decoding\n \n # Blocking and synchrony\n@@ -1298,32 +1297,6 @@ impl<'a, T, A: Acceptor<T>> Iterator<Option<T>> for IncomingIterator<'a, A> {\n     }\n }\n \n-/// Common trait for decorator types.\n-///\n-/// Provides accessors to get the inner, 'decorated' values. The I/O library\n-/// uses decorators to add functionality like compression and encryption to I/O\n-/// streams.\n-///\n-/// # XXX\n-///\n-/// Is this worth having a trait for? May be overkill\n-pub trait Decorator<T> {\n-    /// Destroy the decorator and extract the decorated value\n-    ///\n-    /// # XXX\n-    ///\n-    /// Because this takes `self' one could never 'undecorate' a Reader/Writer\n-    /// that has been boxed. Is that ok? This feature is mostly useful for\n-    /// extracting the buffer from MemWriter\n-    fn inner(self) -> T;\n-\n-    /// Take an immutable reference to the decorated value\n-    fn inner_ref<'a>(&'a self) -> &'a T;\n-\n-    /// Take a mutable reference to the decorated value\n-    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut T;\n-}\n-\n pub fn standard_error(kind: IoErrorKind) -> IoError {\n     let desc = match kind {\n         PreviousIoError => \"failing due to previous I/O error\","}, {"sha": "65fa71dd4159445a2d73ca8d4529f29abbe403be", "filename": "src/libstd/io/option.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibstd%2Fio%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibstd%2Fio%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Foption.rs?ref=fb44e20f657302e9b69101d0c26b095636349d38", "patch": "@@ -106,15 +106,14 @@ impl<T, A: Acceptor<T>> Acceptor<T> for Option<A> {\n mod test {\n     use prelude::*;\n     use super::super::mem::*;\n-    use io::Decorator;\n     use super::super::{PreviousIoError, io_error};\n \n     #[test]\n     fn test_option_writer() {\n         let mut writer: Option<MemWriter> = Some(MemWriter::new());\n         writer.write([0, 1, 2]);\n         writer.flush();\n-        assert_eq!(writer.unwrap().inner(), ~[0, 1, 2]);\n+        assert_eq!(writer.unwrap().unwrap(), ~[0, 1, 2]);\n     }\n \n     #[test]"}, {"sha": "0f64e9f874bc5d4dbb09608a5789f3ac8b2705e4", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=fb44e20f657302e9b69101d0c26b095636349d38", "patch": "@@ -193,7 +193,6 @@ pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) {\n \n #[cfg(test)]\n mod test {\n-    use io::Decorator;\n     use io::mem::{MemReader, MemWriter};\n     use super::*;\n     use prelude::*;\n@@ -282,7 +281,7 @@ mod test {\n                                    MemWriter::new());\n         assert_eq!(~[0, 1, 2], r.read_to_end());\n         let (_, w) = r.unwrap();\n-        assert_eq!(~[0, 1, 2], w.inner());\n+        assert_eq!(~[0, 1, 2], w.unwrap());\n     }\n \n     #[test]\n@@ -291,6 +290,6 @@ mod test {\n         let mut w = MemWriter::new();\n         copy(&mut r, &mut w);\n         assert!(r.eof());\n-        assert_eq!(~[0, 1, 2, 3, 4], w.inner());\n+        assert_eq!(~[0, 1, 2, 3, 4], w.unwrap());\n     }\n }"}, {"sha": "888eed0e7623cdab689a91895c44ed034ff7747c", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=fb44e20f657302e9b69101d0c26b095636349d38", "patch": "@@ -620,11 +620,10 @@ pub fn write_repr<T>(writer: &mut io::Writer, object: &T) {\n pub fn repr_to_str<T>(t: &T) -> ~str {\n     use str;\n     use io;\n-    use io::Decorator;\n \n     let mut result = io::mem::MemWriter::new();\n     write_repr(&mut result as &mut io::Writer, t);\n-    str::from_utf8_owned(result.inner())\n+    str::from_utf8_owned(result.unwrap())\n }\n \n #[cfg(test)]\n@@ -635,14 +634,13 @@ fn test_repr() {\n     use prelude::*;\n     use str;\n     use str::Str;\n-    use io::Decorator;\n     use util::swap;\n     use char::is_alphabetic;\n \n     fn exact_test<T>(t: &T, e:&str) {\n         let mut m = io::mem::MemWriter::new();\n         write_repr(&mut m as &mut io::Writer, t);\n-        let s = str::from_utf8_owned(m.inner());\n+        let s = str::from_utf8_owned(m.unwrap());\n         assert_eq!(s.as_slice(), e);\n     }\n "}, {"sha": "b64f16aff59b72cef1645292229ef90746407f6f", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=fb44e20f657302e9b69101d0c26b095636349d38", "patch": "@@ -338,7 +338,6 @@ mod test {\n     use extra::serialize::Encodable;\n     use extra;\n     use std::io;\n-    use std::io::Decorator;\n     use std::io::mem::MemWriter;\n     use std::str;\n     use codemap::{Span, BytePos, Spanned};\n@@ -356,7 +355,7 @@ mod test {\n         let mut writer = MemWriter::new();\n         let mut encoder = extra::json::Encoder::new(&mut writer as &mut io::Writer);\n         val.encode(&mut encoder);\n-        str::from_utf8_owned(writer.inner())\n+        str::from_utf8_owned(writer.unwrap())\n     }\n \n     // produce a codemap::span"}, {"sha": "82a7d550f6403666e33babf3f6db568b04ddb246", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44e20f657302e9b69101d0c26b095636349d38/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=fb44e20f657302e9b69101d0c26b095636349d38", "patch": "@@ -32,7 +32,6 @@ use std::cell::RefCell;\n use std::char;\n use std::str;\n use std::io;\n-use std::io::Decorator;\n use std::io::mem::MemWriter;\n \n // The &mut ps is stored here to prevent recursive type.\n@@ -2322,7 +2321,7 @@ pub fn print_string(s: &mut ps, st: &str, style: ast::StrStyle) {\n // downcasts.\n unsafe fn get_mem_writer(writer: &mut ~io::Writer) -> ~str {\n     let (_, wr): (uint, ~MemWriter) = cast::transmute_copy(writer);\n-    let result = str::from_utf8_owned(wr.inner_ref().to_owned());\n+    let result = str::from_utf8_owned(wr.get_ref().to_owned());\n     cast::forget(wr);\n     result\n }"}, {"sha": "35e171704ac305a414756610c8071561747064a8", "filename": "src/test/run-pass/auto-encode.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb44e20f657302e9b69101d0c26b095636349d38/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44e20f657302e9b69101d0c26b095636349d38/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-encode.rs?ref=fb44e20f657302e9b69101d0c26b095636349d38", "patch": "@@ -20,7 +20,6 @@ extern mod extra;\n // the common code.\n \n use std::hashmap::{HashMap, HashSet};\n-use std::io::Decorator;\n \n use EBReader = extra::ebml::reader;\n use EBWriter = extra::ebml::writer;\n@@ -38,7 +37,7 @@ fn test_ebml<'a, A:\n     let mut wr = std::io::mem::MemWriter::new();\n     let mut ebml_w = EBWriter::Encoder(&mut wr);\n     a1.encode(&mut ebml_w);\n-    let bytes = wr.inner_ref().as_slice();\n+    let bytes = wr.get_ref();\n \n     let d: extra::ebml::Doc<'a> = EBReader::Doc(bytes);\n     let mut decoder: EBReader::Decoder<'a> = EBReader::Decoder(d);"}, {"sha": "e22f0a8f8c7806731158ea04a1a278381d758f2c", "filename": "src/test/run-pass/deriving-encodable-decodable.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb44e20f657302e9b69101d0c26b095636349d38/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44e20f657302e9b69101d0c26b095636349d38/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs?ref=fb44e20f657302e9b69101d0c26b095636349d38", "patch": "@@ -19,7 +19,6 @@\n extern mod extra;\n \n use std::io::mem::MemWriter;\n-use std::io::Decorator;\n use std::rand::{random, Rand};\n use extra::serialize::{Encodable, Decodable};\n use extra::ebml;\n@@ -61,7 +60,7 @@ fn roundtrip<'a, T: Rand + Eq + Encodable<Encoder> +\n     let mut w = MemWriter::new();\n     let mut e = Encoder(&mut w);\n     obj.encode(&mut e);\n-    let doc = ebml::reader::Doc(@w.inner_ref().to_owned());\n+    let doc = ebml::reader::Doc(@w.get_ref());\n     let mut dec = Decoder(doc);\n     let obj2 = Decodable::decode(&mut dec);\n     assert!(obj == obj2);"}, {"sha": "837adfce048d9fa0d382af1c300e324d0da0b3c0", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb44e20f657302e9b69101d0c26b095636349d38/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44e20f657302e9b69101d0c26b095636349d38/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=fb44e20f657302e9b69101d0c26b095636349d38", "patch": "@@ -14,7 +14,6 @@\n #[deny(warnings)];\n \n use std::fmt;\n-use std::io::Decorator;\n use std::io::mem::MemWriter;\n use std::io;\n use std::io::Writer;\n@@ -262,7 +261,7 @@ fn test_write() {\n         writeln!(w, \"{foo}\", foo=\"bar\");\n     }\n \n-    let s = str::from_utf8_owned(buf.inner());\n+    let s = str::from_utf8_owned(buf.unwrap());\n     t!(s, \"34helloline\\nbar\\n\");\n }\n \n@@ -286,7 +285,7 @@ fn test_format_args() {\n         format_args!(|args| { fmt::write(w, args) }, \"test\");\n         format_args!(|args| { fmt::write(w, args) }, \"{test}\", test=3);\n     }\n-    let s = str::from_utf8_owned(buf.inner());\n+    let s = str::from_utf8_owned(buf.unwrap());\n     t!(s, \"1test3\");\n \n     let s = format_args!(fmt::format, \"hello {}\", \"world\");"}]}