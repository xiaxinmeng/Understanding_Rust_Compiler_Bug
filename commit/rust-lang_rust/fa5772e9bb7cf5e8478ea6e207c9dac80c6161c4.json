{"sha": "fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhNTc3MmU5YmI3Y2Y1ZTg0NzhlYTZlMjA3YzlkYWM4MGM2MTYxYzQ=", "commit": {"author": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2015-09-18T20:37:09Z"}, "committer": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2015-09-18T20:37:09Z"}, "message": "Merge pull request #326 from marcusklaas/interface-refactor\n\nRefactor rustfmt's interface and test code", "tree": {"sha": "b934bbd7eb4ced4594afbb58ac10ab1e899eb969", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b934bbd7eb4ced4594afbb58ac10ab1e899eb969"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4", "html_url": "https://github.com/rust-lang/rust/commit/fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c5dc294160bfd5edfa532295bf8cf0befb16b78", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c5dc294160bfd5edfa532295bf8cf0befb16b78", "html_url": "https://github.com/rust-lang/rust/commit/9c5dc294160bfd5edfa532295bf8cf0befb16b78"}, {"sha": "e72d4882819d8d747746199ade3adcf06292e3a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/e72d4882819d8d747746199ade3adcf06292e3a3", "html_url": "https://github.com/rust-lang/rust/commit/e72d4882819d8d747746199ade3adcf06292e3a3"}], "stats": {"total": 378, "additions": 212, "deletions": 166}, "files": [{"sha": "af83cf13f85360232eb8ae2de446783c63dae7d7", "filename": "src/bin/rustfmt.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4/src%2Fbin%2Frustfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4/src%2Fbin%2Frustfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Frustfmt.rs?ref=fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4", "patch": "@@ -65,7 +65,7 @@ fn execute() -> i32 {\n         Err(_) => Default::default(),\n     };\n \n-    run(args, write_mode, Box::new(config));\n+    run(args, write_mode, &config);\n     0\n }\n \n@@ -87,7 +87,10 @@ fn print_usage<S: Into<String>>(reason: S) {\n              reason.into());\n \n     for option in Config::get_docs() {\n-        println!(\"{}, {}, Possible values: {}\", option.option_name(), option.doc_string(), option.variant_names());\n+        println!(\"{}, {}, Possible values: {}\",\n+                 option.option_name(),\n+                 option.doc_string(),\n+                 option.variant_names());\n     }\n }\n "}, {"sha": "05117a7cb76fe794b4dbbc168228d41fde4e5063", "filename": "src/comment.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4", "patch": "@@ -288,8 +288,9 @@ impl<T> Iterator for CharClasses<T> where T: Iterator, T::Item: RichChar {\n mod test {\n     use super::{CharClasses, CodeCharKind, contains_comment, rewrite_comment, FindUncommented};\n \n-    // TODO(#217): prevent string literal from going over the limit.\n+    // FIXME(#217): prevent string literal from going over the limit.\n     #[test]\n+    #[rustfmt_skip]\n     fn format_comments() {\n         assert_eq!(\"/* test */\", rewrite_comment(\" //test\", true, 100, 100));\n         assert_eq!(\"// comment\\n// on a\", rewrite_comment(\"// comment on a\", false, 10, 0));\n@@ -301,9 +302,10 @@ mod test {\n                                    12));\n \n         let input = \"// comment\";\n-        let expected = \"/* com\\n                                                                      \\\n-                        * men\\n                                                                      \\\n-                        * t */\";\n+        let expected =\n+            \"/* com\\n                                                                      \\\n+             * men\\n                                                                      \\\n+             * t */\";\n         assert_eq!(expected, rewrite_comment(input, true, 9, 69));\n \n         assert_eq!(\"/* trimmed */\", rewrite_comment(\"/*   trimmed    */\", true, 100, 100));"}, {"sha": "2ecee9f98fe26fe17cbaca3890c9765660e6befb", "filename": "src/config.rs", "status": "modified", "additions": 51, "deletions": 6, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4", "patch": "@@ -10,9 +10,51 @@\n \n extern crate toml;\n \n-use {NewlineStyle, BraceStyle, ReturnIndent, StructLitStyle};\n use lists::{SeparatorTactic, ListTactic};\n-use issues::ReportTactic;\n+pub use issues::ReportTactic;\n+\n+#[derive(Copy, Clone, Eq, PartialEq, Debug)]\n+pub enum NewlineStyle {\n+    Windows, // \\r\\n\n+    Unix, // \\n\n+}\n+\n+impl_enum_decodable!(NewlineStyle, Windows, Unix);\n+\n+#[derive(Copy, Clone, Eq, PartialEq, Debug)]\n+pub enum BraceStyle {\n+    AlwaysNextLine,\n+    PreferSameLine,\n+    // Prefer same line except where there is a where clause, in which case force\n+    // the brace to the next line.\n+    SameLineWhere,\n+}\n+\n+impl_enum_decodable!(BraceStyle, AlwaysNextLine, PreferSameLine, SameLineWhere);\n+\n+// How to indent a function's return type.\n+#[derive(Copy, Clone, Eq, PartialEq, Debug)]\n+pub enum ReturnIndent {\n+    // Aligned with the arguments\n+    WithArgs,\n+    // Aligned with the where clause\n+    WithWhereClause,\n+}\n+\n+impl_enum_decodable!(ReturnIndent, WithArgs, WithWhereClause);\n+\n+// How to stle a struct literal.\n+#[derive(Copy, Clone, Eq, PartialEq, Debug)]\n+pub enum StructLitStyle {\n+    // First line on the same line as the opening brace, all lines aligned with\n+    // the first line.\n+    Visual,\n+    // First line is on a new line and all lines align with block indent.\n+    Block,\n+    // FIXME Maybe we should also have an option to align types.\n+}\n+\n+impl_enum_decodable!(StructLitStyle, Visual, Block);\n \n #[derive(Copy, Clone, Eq, PartialEq, Debug)]\n pub enum BlockIndentStyle {\n@@ -183,9 +225,11 @@ create_config! {\n     fn_args_density: Density, \"Argument density in functions\",\n     fn_args_layout: StructLitStyle, \"Layout of function arguments\",\n     fn_arg_indent: BlockIndentStyle, \"Indent on function arguments\",\n-    where_density: Density, \"Density of a where clause\", // Should we at least try to put the where clause on the same line as\n-                                                         // the rest of the function decl?\n-    where_indent: BlockIndentStyle, \"Indentation of a where clause\", // Visual will be treated like Tabbed\n+    // Should we at least try to put the where clause on the same line as the rest of the\n+    // function decl?\n+    where_density: Density, \"Density of a where clause\",\n+    // Visual will be treated like Tabbed\n+    where_indent: BlockIndentStyle, \"Indentation of a where clause\",\n     where_layout: ListTactic, \"Element layout inside a where clause\",\n     where_pred_indent: BlockIndentStyle, \"Indentation style of a where predicate\",\n     generics_indent: BlockIndentStyle, \"Indentation of generics\",\n@@ -196,7 +240,8 @@ create_config! {\n     enum_trailing_comma: bool, \"Put a trailing comma on enum declarations\",\n     report_todo: ReportTactic, \"Report all occurences of TODO in source file comments\",\n     report_fixme: ReportTactic, \"Report all occurences of FIXME in source file comments\",\n-    reorder_imports: bool, \"Reorder import statements alphabetically\", // Alphabetically, case sensitive.\n+    // Alphabetically, case sensitive.\n+    reorder_imports: bool, \"Reorder import statements alphabetically\",\n     single_line_if_else: bool, \"Put else on same line as closing brace for if statements\",\n     format_strings: bool, \"Format string literals, or leave as is\",\n     chains_overflow_last: bool, \"Allow last call in method chain to break the line\","}, {"sha": "a91c6c38572e2b7eedd6e5607208031eed9cdfe5", "filename": "src/expr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4", "patch": "@@ -14,11 +14,10 @@ use std::borrow::Borrow;\n use rewrite::{Rewrite, RewriteContext};\n use lists::{write_list, itemize_list, ListFormatting, SeparatorTactic, ListTactic};\n use string::{StringFormat, rewrite_string};\n-use StructLitStyle;\n use utils::{span_after, make_indent, extra_offset, first_line_width, last_line_width, wrap_str,\n             binary_search};\n use visitor::FmtVisitor;\n-use config::MultilineStyle;\n+use config::{StructLitStyle, MultilineStyle};\n use comment::{FindUncommented, rewrite_comment, contains_comment};\n use types::rewrite_path;\n use items::{span_lo_for_arg, span_hi_for_arg};"}, {"sha": "d94c1501734517d5eca0f7f59d71ff27496b5471", "filename": "src/filemap.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4/src%2Ffilemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4/src%2Ffilemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffilemap.rs?ref=fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4", "patch": "@@ -9,15 +9,16 @@\n // except according to those terms.\n \n \n-// TODO tests\n+// TODO: add tests\n \n use strings::string_buffer::StringBuffer;\n+\n use std::collections::HashMap;\n use std::fs::{self, File};\n use std::io::{self, Write, Read, stdout};\n+\n use WriteMode;\n-use NewlineStyle;\n-use config::Config;\n+use config::{NewlineStyle, Config};\n use rustfmt_diff::{make_diff, print_diff};\n \n // A map of the files of a crate, with their new content\n@@ -116,7 +117,7 @@ fn write_file(text: &StringBuffer,\n             let diff = make_diff(&ori_text, &fmt_text, 3);\n             print_diff(diff, |line_num| format!(\"\\nDiff at line {}:\", line_num));\n         }\n-        WriteMode::Return(_) => {\n+        WriteMode::Return => {\n             // io::Write is not implemented for String, working around with\n             // Vec<u8>\n             let mut v = Vec::new();"}, {"sha": "2b470e03f95f51b536aae86300abe6e6ea17bd26", "filename": "src/items.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4", "patch": "@@ -10,15 +10,14 @@\n \n // Formatting top-level items - functions, structs, enums, traits, impls.\n \n-use {ReturnIndent, BraceStyle, StructLitStyle};\n use utils::{format_mutability, format_visibility, make_indent, contains_skip, span_after,\n             end_typaram, wrap_str};\n use lists::{write_list, itemize_list, ListItem, ListFormatting, SeparatorTactic, ListTactic};\n use expr::rewrite_assign_rhs;\n use comment::FindUncommented;\n use visitor::FmtVisitor;\n use rewrite::{Rewrite, RewriteContext};\n-use config::{Config, BlockIndentStyle, Density};\n+use config::{Config, BlockIndentStyle, Density, ReturnIndent, BraceStyle, StructLitStyle};\n \n use syntax::{ast, abi};\n use syntax::codemap::{self, Span, BytePos};\n@@ -35,7 +34,7 @@ impl<'a> FmtVisitor<'a> {\n \n             if let Some(ref ty) = local.ty {\n                 infix.push_str(\": \");\n-                // FIXME silly width, indent\n+                // FIXME: silly width, indent\n                 infix.push_str(&ty.rewrite(&self.get_context(), 1000, 0).unwrap());\n             }\n \n@@ -271,9 +270,9 @@ impl<'a> FmtVisitor<'a> {\n                self.config.fn_args_layout != StructLitStyle::Block {\n                 let indent = match self.config.fn_return_indent {\n                     ReturnIndent::WithWhereClause => indent + 4,\n-                    // TODO we might want to check that using the arg indent doesn't\n-                    // blow our budget, and if it does, then fallback to the where\n-                    // clause indent.\n+                    // TODO: we might want to check that using the arg indent\n+                    // doesn't blow our budget, and if it does, then fallback to\n+                    // the where clause indent.\n                     _ => arg_indent,\n                 };\n \n@@ -356,9 +355,10 @@ impl<'a> FmtVisitor<'a> {\n             arg_items.push(ListItem::from_str(\"\"));\n         }\n \n-        // TODO if there are no args, there might still be a comment, but without\n-        // spans for the comment or parens, there is no chance of getting it right.\n-        // You also don't get to put a comment on self, unless it is explicit.\n+        // TODO(#21): if there are no args, there might still be a comment, but\n+        // without spans for the comment or parens, there is no chance of\n+        // getting it right. You also don't get to put a comment on self, unless\n+        // it is explicit.\n         if args.len() >= min_args {\n             let comment_span_start = if min_args == 2 {\n                 span_after(span, \",\", self.codemap)\n@@ -444,7 +444,7 @@ impl<'a> FmtVisitor<'a> {\n             let max_space = self.config.ideal_width + self.config.leeway;\n             if used_space > max_space {\n                 // Whoops! bankrupt.\n-                // TODO take evasive action, perhaps kill the indent or something.\n+                // TODO: take evasive action, perhaps kill the indent or something.\n             } else {\n                 budgets = Some((0, max_space - used_space, new_indent));\n             }\n@@ -574,7 +574,7 @@ impl<'a> FmtVisitor<'a> {\n                 result\n             }\n             ast::VariantKind::StructVariantKind(ref struct_def) => {\n-                // TODO Should limit the width, as we have a trailing comma\n+                // TODO: Should limit the width, as we have a trailing comma\n                 let struct_rewrite = self.format_struct(\"\",\n                                                         field.node.name,\n                                                         field.node.vis,\n@@ -795,7 +795,7 @@ impl<'a> FmtVisitor<'a> {\n                         generics_offset: usize,\n                         span: Span)\n                         -> Option<String> {\n-        // FIXME convert bounds to where clauses where they get too big or if\n+        // FIXME: convert bounds to where clauses where they get too big or if\n         // there is a where clause at all.\n         let lifetimes: &[_] = &generics.lifetimes;\n         let tys: &[_] = &generics.ty_params;\n@@ -811,7 +811,7 @@ impl<'a> FmtVisitor<'a> {\n         };\n \n         let h_budget = self.config.max_width - generics_offset - 2;\n-        // TODO might need to insert a newline if the generics are really long\n+        // TODO: might need to insert a newline if the generics are really long.\n \n         // Strings for the generics.\n         let context = self.get_context();"}, {"sha": "7b6adeba2c854ad076ac1f5d82f95cf9122998e2", "filename": "src/lib.rs", "status": "modified", "additions": 46, "deletions": 75, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4", "patch": "@@ -47,8 +47,9 @@ use syntax::diagnostics;\n use std::path::PathBuf;\n use std::collections::HashMap;\n use std::fmt;\n-use std::mem::swap;\n use std::str::FromStr;\n+use std::rc::Rc;\n+use std::cell::RefCell;\n \n use issues::{BadIssueSeeker, Issue};\n use filemap::FileMap;\n@@ -58,7 +59,7 @@ use config::Config;\n #[macro_use]\n mod utils;\n pub mod config;\n-mod filemap;\n+pub mod filemap;\n mod visitor;\n mod items;\n mod missed_spans;\n@@ -92,7 +93,7 @@ pub enum WriteMode {\n     // Write the diff to stdout.\n     Diff,\n     // Return the result as a mapping from filenames to Strings.\n-    Return(&'static Fn(HashMap<String, String>)),\n+    Return,\n }\n \n impl FromStr for WriteMode {\n@@ -109,50 +110,7 @@ impl FromStr for WriteMode {\n     }\n }\n \n-#[derive(Copy, Clone, Eq, PartialEq, Debug)]\n-pub enum NewlineStyle {\n-    Windows, // \\r\\n\n-    Unix, // \\n\n-}\n-\n-impl_enum_decodable!(NewlineStyle, Windows, Unix);\n-\n-#[derive(Copy, Clone, Eq, PartialEq, Debug)]\n-pub enum BraceStyle {\n-    AlwaysNextLine,\n-    PreferSameLine,\n-    // Prefer same line except where there is a where clause, in which case force\n-    // the brace to the next line.\n-    SameLineWhere,\n-}\n-\n-impl_enum_decodable!(BraceStyle, AlwaysNextLine, PreferSameLine, SameLineWhere);\n-\n-// How to indent a function's return type.\n-#[derive(Copy, Clone, Eq, PartialEq, Debug)]\n-pub enum ReturnIndent {\n-    // Aligned with the arguments\n-    WithArgs,\n-    // Aligned with the where clause\n-    WithWhereClause,\n-}\n-\n-impl_enum_decodable!(ReturnIndent, WithArgs, WithWhereClause);\n-\n-// How to stle a struct literal.\n-#[derive(Copy, Clone, Eq, PartialEq, Debug)]\n-pub enum StructLitStyle {\n-    // First line on the same line as the opening brace, all lines aligned with\n-    // the first line.\n-    Visual,\n-    // First line is on a new line and all lines align with block indent.\n-    Block,\n-    // FIXME Maybe we should also have an option to align types.\n-}\n-\n-impl_enum_decodable!(StructLitStyle, Visual, Block);\n-\n-enum ErrorKind {\n+pub enum ErrorKind {\n     // Line has exceeded character limit\n     LineOverflow,\n     // Line ends in whitespace\n@@ -177,8 +135,8 @@ impl fmt::Display for ErrorKind {\n     }\n }\n \n-// Formatting errors that are identified *after* rustfmt has run\n-struct FormattingError {\n+// Formatting errors that are identified *after* rustfmt has run.\n+pub struct FormattingError {\n     line: u32,\n     kind: ErrorKind,\n }\n@@ -201,11 +159,17 @@ impl FormattingError {\n     }\n }\n \n-struct FormatReport {\n-    // Maps stringified file paths to their associated formatting errors\n+pub struct FormatReport {\n+    // Maps stringified file paths to their associated formatting errors.\n     file_error_map: HashMap<String, Vec<FormattingError>>,\n }\n \n+impl FormatReport {\n+    pub fn warning_count(&self) -> usize {\n+        self.file_error_map.iter().map(|(_, ref errors)| errors.len()).fold(0, |acc, x| acc + x)\n+    }\n+}\n+\n impl fmt::Display for FormatReport {\n     // Prints all the formatting errors.\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n@@ -237,9 +201,9 @@ fn fmt_ast(krate: &ast::Crate, codemap: &CodeMap, config: &Config) -> FileMap {\n }\n \n // Formatting done on a char by char or line by line basis.\n-// TODO warn on bad license\n-// TODO other stuff for parity with make tidy\n-fn fmt_lines(file_map: &mut FileMap, config: &Config) -> FormatReport {\n+// TODO(#209) warn on bad license\n+// TODO(#20) other stuff for parity with make tidy\n+pub fn fmt_lines(file_map: &mut FileMap, config: &Config) -> FormatReport {\n     let mut truncate_todo = Vec::new();\n     let mut report = FormatReport { file_error_map: HashMap::new() };\n \n@@ -310,8 +274,8 @@ fn fmt_lines(file_map: &mut FileMap, config: &Config) -> FormatReport {\n }\n \n struct RustFmtCalls {\n-    write_mode: WriteMode,\n-    config: Option<Box<config::Config>>,\n+    config: Rc<Config>,\n+    result: Rc<RefCell<Option<FileMap>>>,\n }\n \n impl<'a> CompilerCalls<'a> for RustFmtCalls {\n@@ -326,11 +290,8 @@ impl<'a> CompilerCalls<'a> for RustFmtCalls {\n     }\n \n     fn build_controller(&mut self, _: &Session) -> driver::CompileController<'a> {\n-        let write_mode = self.write_mode;\n-\n-        let mut config_option = None;\n-        swap(&mut self.config, &mut config_option);\n-        let config = config_option.unwrap();\n+        let result = self.result.clone();\n+        let config = self.config.clone();\n \n         let mut control = driver::CompileController::basic();\n         control.after_parse.stop = Compilation::Stop;\n@@ -341,29 +302,39 @@ impl<'a> CompilerCalls<'a> for RustFmtCalls {\n             // For some reason, the codemap does not include terminating\n             // newlines so we must add one on for each file. This is sad.\n             filemap::append_newlines(&mut file_map);\n-            println!(\"{}\", fmt_lines(&mut file_map, &*config));\n-\n-            let result = filemap::write_all_files(&file_map, write_mode, &*config);\n \n-            match result {\n-                Err(msg) => println!(\"Error writing files: {}\", msg),\n-                Ok(result) => {\n-                    if let WriteMode::Return(callback) = write_mode {\n-                        callback(result);\n-                    }\n-                }\n-            }\n+            *result.borrow_mut() = Some(file_map);\n         });\n \n         control\n     }\n }\n \n+pub fn format(args: Vec<String>, config: &Config) -> FileMap {\n+    let result = Rc::new(RefCell::new(None));\n+\n+    {\n+        let config = Rc::new(config.clone());\n+        let mut call_ctxt = RustFmtCalls { config: config, result: result.clone() };\n+        rustc_driver::run_compiler(&args, &mut call_ctxt);\n+    }\n+\n+    // Peel the union.\n+    Rc::try_unwrap(result).ok().unwrap().into_inner().unwrap()\n+}\n+\n // args are the arguments passed on the command line, generally passed through\n // to the compiler.\n // write_mode determines what happens to the result of running rustfmt, see\n // WriteMode.\n-pub fn run(args: Vec<String>, write_mode: WriteMode, config: Box<Config>) {\n-    let mut call_ctxt = RustFmtCalls { write_mode: write_mode, config: Some(config) };\n-    rustc_driver::run_compiler(&args, &mut call_ctxt);\n+pub fn run(args: Vec<String>, write_mode: WriteMode, config: &Config) {\n+    let mut result = format(args, config);\n+\n+    println!(\"{}\", fmt_lines(&mut result, config));\n+\n+    let write_result = filemap::write_all_files(&result, write_mode, config);\n+\n+    if let Err(msg) = write_result {\n+        println!(\"Error writing files: {}\", msg);\n+    }\n }"}, {"sha": "e52909b0d5c8f23fe9ee69452fd1e61f1c4c2f9b", "filename": "src/types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4", "patch": "@@ -127,7 +127,7 @@ impl<'a> SegmentParam<'a> {\n }\n \n impl<'a> Rewrite for SegmentParam<'a> {\n-    // FIXME doesn't always use width, offset\n+    // FIXME: doesn't always use width, offset.\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n         Some(match *self {\n             SegmentParam::LifeTime(ref lt) => {\n@@ -270,8 +270,8 @@ fn rewrite_segment(segment: &ast::PathSegment,\n \n impl Rewrite for ast::WherePredicate {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n-        // TODO dead spans?\n-        // TODO assumes we'll always fit on one line...\n+        // TODO: dead spans?\n+        // TODO: don't assume we'll always fit on one line...\n         Some(match *self {\n             ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate { ref bound_lifetimes,\n                                                                            ref bounded_ty,"}, {"sha": "1e3ebf71cef1c36cdc4910b2a3127604fd4ad46b", "filename": "src/visitor.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4", "patch": "@@ -24,7 +24,7 @@ pub struct FmtVisitor<'a> {\n     pub codemap: &'a CodeMap,\n     pub buffer: StringBuffer,\n     pub last_pos: BytePos,\n-    // TODO RAII util for indenting\n+    // TODO: RAII util for indenting\n     pub block_indent: usize,\n     pub config: &'a Config,\n }\n@@ -112,7 +112,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n         }\n \n         self.block_indent -= self.config.tab_spaces;\n-        // TODO we should compress any newlines here to just one\n+        // TODO: we should compress any newlines here to just one.\n         self.format_missing_with_indent(b.span.hi - brace_compensation);\n         self.buffer.push_str(\"}\");\n         self.last_pos = b.span.hi;\n@@ -237,13 +237,12 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n             let indent = self.block_indent;\n             let new_fn = self.rewrite_required_fn(indent, ti.ident, sig, ti.span);\n \n-\n             if let Some(fn_str) = new_fn {\n                 self.buffer.push_str(&fn_str);\n                 self.last_pos = ti.span.hi;\n             }\n         }\n-        // TODO format trait types\n+        // TODO: format trait types.\n \n         visit::walk_trait_item(self, ti)\n     }\n@@ -320,7 +319,7 @@ impl<'a> FmtVisitor<'a> {\n         let local_file_name = self.codemap.span_to_filename(s);\n         let is_internal = local_file_name == self.codemap.span_to_filename(m.inner);\n \n-        // TODO Should rewrite properly `mod X;`\n+        // TODO: Should rewrite properly `mod X;`\n \n         if is_internal {\n             debug!(\"FmtVisitor::format_mod: internal mod\");"}, {"sha": "4e7ec958c180f13e434e5dc1bbff237e95f68728", "filename": "tests/system.rs", "status": "modified", "additions": 78, "deletions": 52, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4/tests%2Fsystem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4/tests%2Fsystem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsystem.rs?ref=fa5772e9bb7cf5e8478ea6e207c9dac80c6161c4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(catch_panic)]\n-\n extern crate rustfmt;\n extern crate diff;\n extern crate regex;\n@@ -18,9 +16,9 @@ extern crate term;\n use std::collections::HashMap;\n use std::fs;\n use std::io::{self, Read, BufRead, BufReader};\n-use std::thread;\n+\n use rustfmt::*;\n-use rustfmt::config::Config;\n+use rustfmt::config::{Config, ReportTactic};\n use rustfmt::rustfmt_diff::*;\n \n static DIFF_CONTEXT_SIZE: usize = 3;\n@@ -39,14 +37,14 @@ fn get_path_string(dir_entry: io::Result<fs::DirEntry>) -> String {\n // least report.\n #[test]\n fn system_tests() {\n-    // Get all files in the tests/source directory\n+    // Get all files in the tests/source directory.\n     let files = fs::read_dir(\"tests/source\").ok().expect(\"Couldn't read source dir.\");\n-    // turn a DirEntry into a String that represents the relative path to the file\n+    // Turn a DirEntry into a String that represents the relative path to the\n+    // file.\n     let files = files.map(get_path_string);\n+    let (_reports, count, fails) = check_files(files);\n \n-    let (count, fails) = check_files(files);\n-\n-    // Display results\n+    // Display results.\n     println!(\"Ran {} system tests.\", count);\n     assert!(fails == 0, \"{} system tests failed\", fails);\n }\n@@ -55,40 +53,69 @@ fn system_tests() {\n // rustfmt.\n #[test]\n fn idempotence_tests() {\n-    // Get all files in the tests/target directory\n-    let files = fs::read_dir(\"tests/target\").ok().expect(\"Couldn't read target dir.\");\n-    let files = files.chain(fs::read_dir(\"tests\").ok().expect(\"Couldn't read tests dir.\"));\n-    let files = files.chain(fs::read_dir(\"src/bin\").ok().expect(\"Couldn't read src dir.\"));\n-    // turn a DirEntry into a String that represents the relative path to the file\n-    let files = files.map(get_path_string);\n-    // hack because there's no `IntoIterator` impl for `[T; N]`\n+    // Get all files in the tests/target directory.\n+    let files = fs::read_dir(\"tests/target\")\n+                    .ok()\n+                    .expect(\"Couldn't read target dir.\")\n+                    .map(get_path_string);\n+    let (_reports, count, fails) = check_files(files);\n+\n+    // Display results.\n+    println!(\"Ran {} idempotent tests.\", count);\n+    assert!(fails == 0, \"{} idempotent tests failed\", fails);\n+}\n+\n+// Run rustfmt on itself. This operation must be idempotent. We also check that\n+// no warnings are emitted.\n+#[test]\n+fn self_tests() {\n+    let files = fs::read_dir(\"src/bin\")\n+                    .ok()\n+                    .expect(\"Couldn't read src dir.\")\n+                    .chain(fs::read_dir(\"tests\").ok().expect(\"Couldn't read tests dir.\"))\n+                    .map(get_path_string);\n+    // Hack because there's no `IntoIterator` impl for `[T; N]`.\n     let files = files.chain(Some(\"src/lib.rs\".to_owned()).into_iter());\n \n-    let (count, fails) = check_files(files);\n+    let (reports, count, fails) = check_files(files);\n+    let mut warnings = 0;\n \n-    // Display results\n-    println!(\"Ran {} idempotent tests.\", count);\n-    assert!(fails == 0, \"{} idempotent tests failed\", fails);\n+    // Display results.\n+    println!(\"Ran {} self tests.\", count);\n+    assert!(fails == 0, \"{} self tests failed\", fails);\n+\n+    for format_report in reports {\n+        println!(\"{}\", format_report);\n+        warnings += format_report.warning_count();\n+    }\n+\n+    assert!(warnings == 0, \"Rustfmt's code generated {} warnings\", warnings);\n }\n \n // For each file, run rustfmt and collect the output.\n // Returns the number of files checked and the number of failures.\n-fn check_files<I>(files: I) -> (u32, u32)\n+fn check_files<I>(files: I) -> (Vec<FormatReport>, u32, u32)\n     where I: Iterator<Item = String>\n {\n     let mut count = 0;\n     let mut fails = 0;\n+    let mut reports = vec![];\n \n     for file_name in files.filter(|f| f.ends_with(\".rs\")) {\n         println!(\"Testing '{}'...\", file_name);\n-        if let Err(msg) = idempotent_check(file_name) {\n-            print_mismatches(msg);\n-            fails += 1;\n+\n+        match idempotent_check(file_name) {\n+            Ok(report) => reports.push(report),\n+            Err(msg) => {\n+                print_mismatches(msg);\n+                fails += 1;\n+            }\n         }\n+\n         count += 1;\n     }\n \n-    (count, fails)\n+    (reports, count, fails)\n }\n \n fn print_mismatches(result: HashMap<String, Vec<Mismatch>>) {\n@@ -101,35 +128,34 @@ fn print_mismatches(result: HashMap<String, Vec<Mismatch>>) {\n     assert!(t.reset().unwrap());\n }\n \n-// Ick, just needed to get a &'static to handle_result.\n-static HANDLE_RESULT: &'static Fn(HashMap<String, String>) = &handle_result;\n-\n-pub fn idempotent_check(filename: String) -> Result<(), HashMap<String, Vec<Mismatch>>> {\n+pub fn idempotent_check(filename: String) -> Result<FormatReport, HashMap<String, Vec<Mismatch>>> {\n     let sig_comments = read_significant_comments(&filename);\n     let mut config = get_config(sig_comments.get(\"config\").map(|x| &(*x)[..]));\n     let args = vec![\"rustfmt\".to_owned(), filename];\n \n-    for (key, val) in sig_comments {\n+    for (key, val) in &sig_comments {\n         if key != \"target\" && key != \"config\" {\n-            config.override_value(&key, &val);\n+            config.override_value(key, val);\n         }\n     }\n \n-    // this thread is not used for concurrency, but rather to workaround the issue that the passed\n-    // function handle needs to have static lifetime. Instead of using a global RefCell, we use\n-    // panic to return a result in case of failure. This has the advantage of smoothing the road to\n-    // multithreaded rustfmt\n-    thread::catch_panic(move || {\n-        run(args, WriteMode::Return(HANDLE_RESULT), config);\n-    })\n-        .map_err(|any| *any.downcast().ok().expect(\"Downcast failed.\"))\n-}\n+    // Don't generate warnings for to-do items.\n+    config.report_todo = ReportTactic::Never;\n \n+    let mut file_map = format(args, &config);\n+    let format_report = fmt_lines(&mut file_map, &config);\n+\n+    // Won't panic, as we're not doing any IO.\n+    let write_result = filemap::write_all_files(&file_map, WriteMode::Return, &config).unwrap();\n+    let target = sig_comments.get(\"target\").map(|x| &(*x)[..]);\n+\n+    handle_result(write_result, target).map(|_| format_report)\n+}\n \n // Reads test config file from comments and reads its contents.\n-fn get_config(config_file: Option<&str>) -> Box<Config> {\n+fn get_config(config_file: Option<&str>) -> Config {\n     let config_file_name = match config_file {\n-        None => return Box::new(Default::default()),\n+        None => return Default::default(),\n         Some(file_name) => {\n             let mut full_path = \"tests/config/\".to_owned();\n             full_path.push_str(&file_name);\n@@ -143,7 +169,7 @@ fn get_config(config_file: Option<&str>) -> Box<Config> {\n     let mut def_config = String::new();\n     def_config_file.read_to_string(&mut def_config).ok().expect(\"Couldn't read config.\");\n \n-    Box::new(Config::from_toml(&def_config))\n+    Config::from_toml(&def_config)\n }\n \n // Reads significant comments of the form: // rustfmt-key: value\n@@ -175,29 +201,29 @@ fn read_significant_comments(file_name: &str) -> HashMap<String, String> {\n \n // Compare output to input.\n // TODO: needs a better name, more explanation.\n-fn handle_result(result: HashMap<String, String>) {\n+fn handle_result(result: HashMap<String, String>,\n+                 target: Option<&str>)\n+                 -> Result<(), HashMap<String, Vec<Mismatch>>> {\n     let mut failures = HashMap::new();\n \n     for (file_name, fmt_text) in result {\n-        // FIXME: reading significant comments again. Is there a way we can just\n-        // pass the target to this function?\n-        let sig_comments = read_significant_comments(&file_name);\n-\n         // If file is in tests/source, compare to file with same name in tests/target.\n-        let target = get_target(&file_name, sig_comments.get(\"target\").map(|x| &(*x)[..]));\n+        let target = get_target(&file_name, target);\n         let mut f = fs::File::open(&target).ok().expect(\"Couldn't open target.\");\n \n         let mut text = String::new();\n-        // TODO: speedup by running through bytes iterator\n         f.read_to_string(&mut text).ok().expect(\"Failed reading target.\");\n+\n         if fmt_text != text {\n             let diff = make_diff(&text, &fmt_text, DIFF_CONTEXT_SIZE);\n             failures.insert(file_name, diff);\n         }\n     }\n \n-    if !failures.is_empty() {\n-        panic!(failures);\n+    if failures.is_empty() {\n+        Ok(())\n+    } else {\n+        Err(failures)\n     }\n }\n "}]}