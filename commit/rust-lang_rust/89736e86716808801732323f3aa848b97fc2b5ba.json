{"sha": "89736e86716808801732323f3aa848b97fc2b5ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5NzM2ZTg2NzE2ODA4ODAxNzMyMzIzZjNhYTg0OGI5N2ZjMmI1YmE=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-05T07:54:38Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-20T17:08:03Z"}, "message": "rustc: remove ImplOrTraitItemId and TraitDef's associated_type_names.", "tree": {"sha": "e1cbd4ba9d57a91e16056bd9b7a769717bea9f96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1cbd4ba9d57a91e16056bd9b7a769717bea9f96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89736e86716808801732323f3aa848b97fc2b5ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89736e86716808801732323f3aa848b97fc2b5ba", "html_url": "https://github.com/rust-lang/rust/commit/89736e86716808801732323f3aa848b97fc2b5ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89736e86716808801732323f3aa848b97fc2b5ba/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8734aaa33ed745a09b983bea9a89b6278b1b082c", "url": "https://api.github.com/repos/rust-lang/rust/commits/8734aaa33ed745a09b983bea9a89b6278b1b082c", "html_url": "https://github.com/rust-lang/rust/commit/8734aaa33ed745a09b983bea9a89b6278b1b082c"}], "stats": {"total": 363, "additions": 130, "deletions": 233}, "files": [{"sha": "269f0ebb813ca091f6028b60395552790492ab8c", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=89736e86716808801732323f3aa848b97fc2b5ba", "patch": "@@ -108,7 +108,7 @@ pub enum DepNode<D: Clone + Debug> {\n     ItemSignature(D),\n     FieldTy(D),\n     SizedConstraint(D),\n-    ImplOrTraitItemIds(D),\n+    ImplOrTraitItemDefIds(D),\n     InherentImpls(D),\n \n     // The set of impls for a given trait. Ultimately, it would be\n@@ -157,7 +157,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             ImplOrTraitItems,\n             ItemSignature,\n             FieldTy,\n-            ImplOrTraitItemIds,\n+            ImplOrTraitItemDefIds,\n             InherentImpls,\n             TraitImpls,\n             ReprHints,\n@@ -225,7 +225,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             ItemSignature(ref d) => op(d).map(ItemSignature),\n             FieldTy(ref d) => op(d).map(FieldTy),\n             SizedConstraint(ref d) => op(d).map(SizedConstraint),\n-            ImplOrTraitItemIds(ref d) => op(d).map(ImplOrTraitItemIds),\n+            ImplOrTraitItemDefIds(ref d) => op(d).map(ImplOrTraitItemDefIds),\n             InherentImpls(ref d) => op(d).map(InherentImpls),\n             TraitImpls(ref d) => op(d).map(TraitImpls),\n             TraitItems(ref d) => op(d).map(TraitItems),"}, {"sha": "e844ec37dc7cd671168ab3cc35f5d26310f50768", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=89736e86716808801732323f3aa848b97fc2b5ba", "patch": "@@ -157,7 +157,7 @@ pub trait CrateStore<'tcx> {\n     fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId>;\n \n     // impl info\n-    fn impl_or_trait_items(&self, def_id: DefId) -> Vec<ty::ImplOrTraitItemId>;\n+    fn impl_or_trait_items(&self, def_id: DefId) -> Vec<DefId>;\n     fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                           -> Option<ty::TraitRef<'tcx>>;\n     fn impl_polarity(&self, def: DefId) -> hir::ImplPolarity;\n@@ -329,7 +329,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     }\n \n     // impl info\n-    fn impl_or_trait_items(&self, def_id: DefId) -> Vec<ty::ImplOrTraitItemId>\n+    fn impl_or_trait_items(&self, def_id: DefId) -> Vec<DefId>\n         { bug!(\"impl_or_trait_items\") }\n     fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                           -> Option<ty::TraitRef<'tcx>> { bug!(\"impl_trait_ref\") }"}, {"sha": "70232d4f01e95e8e41e450c85ecd229d32b46996", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=89736e86716808801732323f3aa848b97fc2b5ba", "patch": "@@ -470,13 +470,12 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n         // This is done to handle the case where, for example, the static\n         // method of a private type is used, but the type itself is never\n         // called directly.\n-        let impl_items = self.tcx.impl_or_trait_item_ids.borrow();\n+        let impl_items = self.tcx.impl_or_trait_item_def_ids.borrow();\n         if let Some(impl_list) =\n                 self.tcx.inherent_impls.borrow().get(&self.tcx.map.local_def_id(id)) {\n             for impl_did in impl_list.iter() {\n-                for item_did in impl_items.get(impl_did).unwrap().iter() {\n-                    if let Some(item_node_id) =\n-                            self.tcx.map.as_local_node_id(item_did.def_id()) {\n+                for &item_did in &impl_items[impl_did][..] {\n+                    if let Some(item_node_id) = self.tcx.map.as_local_node_id(item_did) {\n                         if self.live_symbols.contains(&item_node_id) {\n                             return true;\n                         }"}, {"sha": "2c768db47f11a94661c000b9c99ae6167443fc3b", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=89736e86716808801732323f3aa848b97fc2b5ba", "patch": "@@ -695,10 +695,9 @@ fn is_internal<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span) -> bool {\n \n fn is_staged_api<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> bool {\n     match tcx.trait_item_of_item(id) {\n-        Some(ty::MethodTraitItemId(trait_method_id))\n-            if trait_method_id != id => {\n-                is_staged_api(tcx, trait_method_id)\n-            }\n+        Some(trait_method_id) if trait_method_id != id => {\n+            is_staged_api(tcx, trait_method_id)\n+        }\n         _ => {\n             *tcx.stability.borrow_mut().staged_api.entry(id.krate).or_insert_with(\n                 || tcx.sess.cstore.is_staged_api(id.krate))"}, {"sha": "1374719ef49c4875bd7eafe97a4fdd348a414a35", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=89736e86716808801732323f3aa848b97fc2b5ba", "patch": "@@ -304,15 +304,15 @@ impl<'a, 'gcx, 'tcx> Node {\n /// An iterator over the items defined within a trait or impl.\n pub struct NodeItems<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    items: Rc<Vec<ty::ImplOrTraitItemId>>,\n+    items: Rc<Vec<DefId>>,\n     idx: usize\n }\n \n impl<'a, 'tcx> Iterator for NodeItems<'a, 'tcx> {\n     type Item = ImplOrTraitItem<'tcx>;\n     fn next(&mut self) -> Option<ImplOrTraitItem<'tcx>> {\n         if self.idx < self.items.len() {\n-            let item_def_id = self.items[self.idx].def_id();\n+            let item_def_id = self.items[self.idx];\n             let items_table = self.tcx.impl_or_trait_items.borrow();\n             let item = items_table[&item_def_id].clone();\n             self.idx += 1;"}, {"sha": "1c9238646df297de31c49d8dc60c7eeb651717c6", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=89736e86716808801732323f3aa848b97fc2b5ba", "patch": "@@ -331,7 +331,7 @@ pub struct GlobalCtxt<'tcx> {\n     pub impl_or_trait_items: RefCell<DepTrackingMap<maps::ImplOrTraitItems<'tcx>>>,\n \n     /// Maps from an impl/trait def-id to a list of the def-ids of its items\n-    pub impl_or_trait_item_ids: RefCell<DepTrackingMap<maps::ImplOrTraitItemIds<'tcx>>>,\n+    pub impl_or_trait_item_def_ids: RefCell<DepTrackingMap<maps::ImplOrTraitItemDefIds<'tcx>>>,\n \n     /// A cache for the trait_items() routine; note that the routine\n     /// itself pushes the `TraitItems` dependency node.\n@@ -728,7 +728,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             rcache: RefCell::new(FnvHashMap()),\n             tc_cache: RefCell::new(FnvHashMap()),\n             impl_or_trait_items: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            impl_or_trait_item_ids: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            impl_or_trait_item_def_ids: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             trait_items_cache: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             ty_param_defs: RefCell::new(NodeMap()),\n             normalized_cache: RefCell::new(FnvHashMap()),\n@@ -1396,7 +1396,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.trait_items_cache.memoize(trait_did, || {\n             let def_ids = self.impl_or_trait_items(trait_did);\n             Rc::new(def_ids.iter()\n-                           .map(|d| self.impl_or_trait_item(d.def_id()))\n+                           .map(|&def_id| self.impl_or_trait_item(def_id))\n                            .collect())\n         })\n     }"}, {"sha": "3a552a8b437d3aba15ba54929a17f4a48e95c05d", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=89736e86716808801732323f3aa848b97fc2b5ba", "patch": "@@ -34,8 +34,7 @@ dep_map_ty! { Tcache: ItemSignature(DefId) -> Ty<'tcx> }\n dep_map_ty! { Generics: ItemSignature(DefId) -> &'tcx ty::Generics<'tcx> }\n dep_map_ty! { Predicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n dep_map_ty! { SuperPredicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n-dep_map_ty! { ImplOrTraitItemIds: ImplOrTraitItemIds(DefId)\n-                                    -> Rc<Vec<ty::ImplOrTraitItemId>> }\n+dep_map_ty! { ImplOrTraitItemDefIds: ImplOrTraitItemDefIds(DefId) -> Rc<Vec<DefId>> }\n dep_map_ty! { ImplTraitRefs: ItemSignature(DefId) -> Option<ty::TraitRef<'tcx>> }\n dep_map_ty! { TraitDefs: ItemSignature(DefId) -> &'tcx ty::TraitDef<'tcx> }\n dep_map_ty! { AdtDefs: ItemSignature(DefId) -> ty::AdtDefMaster<'tcx> }"}, {"sha": "8aba6329b090badffc6852e4a8b369e190108f1a", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 12, "deletions": 43, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=89736e86716808801732323f3aa848b97fc2b5ba", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::ImplOrTraitItemId::*;\n pub use self::Variance::*;\n pub use self::DtorKind::*;\n pub use self::ImplOrTraitItemContainer::*;\n@@ -190,18 +189,6 @@ pub enum ImplOrTraitItem<'tcx> {\n }\n \n impl<'tcx> ImplOrTraitItem<'tcx> {\n-    fn id(&self) -> ImplOrTraitItemId {\n-        match *self {\n-            ConstTraitItem(ref associated_const) => {\n-                ConstTraitItemId(associated_const.def_id)\n-            }\n-            MethodTraitItem(ref method) => MethodTraitItemId(method.def_id),\n-            TypeTraitItem(ref associated_type) => {\n-                TypeTraitItemId(associated_type.def_id)\n-            }\n-        }\n-    }\n-\n     pub fn def(&self) -> Def {\n         match *self {\n             ConstTraitItem(ref associated_const) => Def::AssociatedConst(associated_const.def_id),\n@@ -250,23 +237,6 @@ impl<'tcx> ImplOrTraitItem<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, Debug, RustcEncodable, RustcDecodable)]\n-pub enum ImplOrTraitItemId {\n-    ConstTraitItemId(DefId),\n-    MethodTraitItemId(DefId),\n-    TypeTraitItemId(DefId),\n-}\n-\n-impl ImplOrTraitItemId {\n-    pub fn def_id(&self) -> DefId {\n-        match *self {\n-            ConstTraitItemId(def_id) => def_id,\n-            MethodTraitItemId(def_id) => def_id,\n-            TypeTraitItemId(def_id) => def_id,\n-        }\n-    }\n-}\n-\n #[derive(Clone, Debug, PartialEq, Eq, Copy, RustcEncodable, RustcDecodable)]\n pub enum Visibility {\n     /// Visible everywhere (including in other crates).\n@@ -2276,8 +2246,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn provided_trait_methods(self, id: DefId) -> Vec<Rc<Method<'gcx>>> {\n-        self.impl_or_trait_items(id).iter().filter_map(|id| {\n-            match self.impl_or_trait_item(id.def_id()) {\n+        self.impl_or_trait_items(id).iter().filter_map(|&def_id| {\n+            match self.impl_or_trait_item(def_id) {\n                 MethodTraitItem(ref m) if m.has_body => Some(m.clone()),\n                 _ => None\n             }\n@@ -2321,9 +2291,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                    .expect(\"missing ImplOrTraitItem in metadata\"))\n     }\n \n-    pub fn impl_or_trait_items(self, id: DefId) -> Rc<Vec<ImplOrTraitItemId>> {\n+    pub fn impl_or_trait_items(self, id: DefId) -> Rc<Vec<DefId>> {\n         lookup_locally_or_in_crate_store(\n-            \"impl_or_trait_items\", id, &self.impl_or_trait_item_ids,\n+            \"impl_or_trait_items\", id, &self.impl_or_trait_item_def_ids,\n             || Rc::new(self.sess.cstore.impl_or_trait_items(id)))\n     }\n \n@@ -2600,7 +2570,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let impl_items = self.sess.cstore.impl_or_trait_items(primitive_def_id);\n \n         // Store the implementation info.\n-        self.impl_or_trait_item_ids.borrow_mut().insert(primitive_def_id, Rc::new(impl_items));\n+        self.impl_or_trait_item_def_ids.borrow_mut().insert(primitive_def_id, Rc::new(impl_items));\n         self.populated_external_primitive_impls.borrow_mut().insert(primitive_def_id);\n     }\n \n@@ -2627,7 +2597,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         for &impl_def_id in &inherent_impls {\n             // Store the implementation info.\n             let impl_items = self.sess.cstore.impl_or_trait_items(impl_def_id);\n-            self.impl_or_trait_item_ids.borrow_mut().insert(impl_def_id, Rc::new(impl_items));\n+            self.impl_or_trait_item_def_ids.borrow_mut().insert(impl_def_id, Rc::new(impl_items));\n         }\n \n         self.inherent_impls.borrow_mut().insert(type_id, inherent_impls);\n@@ -2669,15 +2639,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n             // For any methods that use a default implementation, add them to\n             // the map. This is a bit unfortunate.\n-            for impl_item_def_id in &impl_items {\n-                let method_def_id = impl_item_def_id.def_id();\n+            for &impl_item_def_id in &impl_items {\n                 // load impl items eagerly for convenience\n                 // FIXME: we may want to load these lazily\n-                self.impl_or_trait_item(method_def_id);\n+                self.impl_or_trait_item(impl_item_def_id);\n             }\n \n             // Store the implementation info.\n-            self.impl_or_trait_item_ids.borrow_mut().insert(impl_def_id, Rc::new(impl_items));\n+            self.impl_or_trait_item_def_ids.borrow_mut().insert(impl_def_id, Rc::new(impl_items));\n         }\n \n         def.flags.set(def.flags.get() | TraitFlags::IMPLS_VALID);\n@@ -2766,19 +2735,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// is already that of the original trait method, then the return value is\n     /// the same).\n     /// Otherwise, return `None`.\n-    pub fn trait_item_of_item(self, def_id: DefId) -> Option<ImplOrTraitItemId> {\n+    pub fn trait_item_of_item(self, def_id: DefId) -> Option<DefId> {\n         let impl_or_trait_item = match self.impl_or_trait_items.borrow().get(&def_id) {\n             Some(m) => m.clone(),\n             None => return None,\n         };\n         match impl_or_trait_item.container() {\n-            TraitContainer(_) => Some(impl_or_trait_item.id()),\n+            TraitContainer(_) => Some(impl_or_trait_item.def_id()),\n             ImplContainer(def_id) => {\n                 self.trait_id_of_impl(def_id).and_then(|trait_did| {\n                     let name = impl_or_trait_item.name();\n                     self.trait_items(trait_did).iter()\n                         .find(|item| item.name() == name)\n-                        .map(|item| item.id())\n+                        .map(|item| item.def_id())\n                 })\n             }\n         }"}, {"sha": "3ff2ed76e571e3a8b308657186d9a069331e57cf", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=89736e86716808801732323f3aa848b97fc2b5ba", "patch": "@@ -15,7 +15,6 @@ use ty;\n use ty::fast_reject;\n use ty::{Ty, TyCtxt, TraitRef};\n use std::cell::{Cell, RefCell};\n-use syntax::ast::Name;\n use hir;\n use util::nodemap::FnvHashMap;\n \n@@ -38,10 +37,6 @@ pub struct TraitDef<'tcx> {\n \n     pub trait_ref: ty::TraitRef<'tcx>,\n \n-    /// A list of the associated types defined in this trait. Useful\n-    /// for resolving `X::Foo` type markers.\n-    pub associated_type_names: Vec<Name>,\n-\n     // Impls of a trait. To allow for quicker lookup, the impls are indexed by a\n     // simplified version of their `Self` type: impls with a simplifiable `Self`\n     // are stored in `nonblanket_impls` keyed by it, while all other impls are\n@@ -82,15 +77,13 @@ impl<'a, 'gcx, 'tcx> TraitDef<'tcx> {\n                paren_sugar: bool,\n                generics: &'tcx ty::Generics<'tcx>,\n                trait_ref: ty::TraitRef<'tcx>,\n-               associated_type_names: Vec<Name>,\n                def_path_hash: u64)\n                -> TraitDef<'tcx> {\n         TraitDef {\n             paren_sugar: paren_sugar,\n             unsafety: unsafety,\n             generics: generics,\n             trait_ref: trait_ref,\n-            associated_type_names: associated_type_names,\n             nonblanket_impls: RefCell::new(FnvHashMap()),\n             blanket_impls: RefCell::new(vec![]),\n             flags: Cell::new(ty::TraitFlags::NO_TRAIT_FLAGS),"}, {"sha": "aa53fdd6e7e27f75429bfc6a2829d9f34da86150", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=89736e86716808801732323f3aa848b97fc2b5ba", "patch": "@@ -1081,16 +1081,14 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         match selection {\n             traits::VtableImpl(ref impl_data) => {\n                 let ac = tcx.impl_or_trait_items(impl_data.impl_def_id)\n-                    .iter().filter_map(|id| {\n-                        match *id {\n-                            ty::ConstTraitItemId(def_id) => {\n-                                Some(tcx.impl_or_trait_item(def_id))\n-                            }\n+                    .iter().filter_map(|&def_id| {\n+                        match tcx.impl_or_trait_item(def_id) {\n+                            ty::ConstTraitItem(ic) => Some(ic),\n                             _ => None\n                         }\n-                    }).find(|ic| ic.name() == ti.name);\n+                    }).find(|ic| ic.name == ti.name);\n                 match ac {\n-                    Some(ic) => lookup_const_by_id(tcx, ic.def_id(), None),\n+                    Some(ic) => lookup_const_by_id(tcx, ic.def_id, None),\n                     None => match ti.node {\n                         hir::ConstTraitItem(ref ty, Some(ref expr)) => {\n                             Some((&*expr, tcx.ast_ty_to_prim_ty(ty)))"}, {"sha": "6df8c7de415a0c91c3afecdd6ab2dbd809873d62", "filename": "src/librustc_metadata/common.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=89736e86716808801732323f3aa848b97fc2b5ba", "patch": "@@ -166,9 +166,6 @@ pub const tag_item_predicates: usize = 0x95;\n \n pub const tag_unsafety: usize = 0x9a;\n \n-pub const tag_associated_type_names: usize = 0x9b;\n-pub const tag_associated_type_name: usize = 0x9c;\n-\n pub const tag_polarity: usize = 0x9d;\n \n pub const tag_macro_defs: usize = 0x10e; // top-level only"}, {"sha": "c4ce7af269daabb6878db36cbdd4a8d4b8d1fa04", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=89736e86716808801732323f3aa848b97fc2b5ba", "patch": "@@ -179,10 +179,15 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         result\n     }\n \n-    fn impl_or_trait_items(&self, def_id: DefId) -> Vec<ty::ImplOrTraitItemId> {\n+    fn impl_or_trait_items(&self, def_id: DefId) -> Vec<DefId> {\n         self.dep_graph.read(DepNode::MetaData(def_id));\n-        let cdata = self.get_crate_data(def_id.krate);\n-        decoder::get_impl_or_trait_items(&cdata, def_id.index)\n+        let mut result = vec![];\n+        let crate_data = self.get_crate_data(def_id.krate);\n+        let get_crate_data = |cnum| self.get_crate_data(cnum);\n+        decoder::each_child_of_item(&crate_data, def_id.index, get_crate_data, |def, _, _| {\n+            result.push(def.def_id());\n+        });\n+        result\n     }\n \n     fn impl_polarity(&self, def: DefId) -> hir::ImplPolarity"}, {"sha": "8b87f0e718fb2dcbeb27470a64508d9810c88ae5", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=89736e86716808801732323f3aa848b97fc2b5ba", "patch": "@@ -453,27 +453,18 @@ fn item_to_def(cdata: Cmd, item: rbml::Doc, did: DefId) -> Option<Def> {\n     })\n }\n \n-fn parse_associated_type_names(item_doc: rbml::Doc) -> Vec<ast::Name> {\n-    item_doc.get(tag_associated_type_names).decoder().decode()\n-}\n-\n pub fn get_trait_def<'a, 'tcx>(cdata: Cmd,\n                                item_id: DefIndex,\n                                tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ty::TraitDef<'tcx>\n {\n     let item_doc = cdata.lookup_item(item_id);\n     let generics = doc_generics(item_doc, tcx, cdata);\n     let unsafety = item_doc.get(tag_unsafety).decoder().decode();\n-    let associated_type_names = parse_associated_type_names(item_doc);\n     let paren_sugar = item_doc.get(tag_paren_sugar).decoder().decode();\n     let trait_ref = doc_trait_ref(item_doc.get(tag_item_trait_ref), tcx, cdata);\n     let def_path = def_path(cdata, item_id).unwrap();\n \n-    ty::TraitDef::new(unsafety,\n-                      paren_sugar,\n-                      generics,\n-                      trait_ref,\n-                      associated_type_names,\n+    ty::TraitDef::new(unsafety, paren_sugar, generics, trait_ref,\n                       def_path.deterministic_hash(tcx))\n }\n \n@@ -855,22 +846,6 @@ fn get_explicit_self<'a, 'tcx>(cdata: Cmd, item: rbml::Doc, tcx: TyCtxt<'a, 'tcx\n     dcx.decode()\n }\n \n-/// Returns the def IDs of all the items in the given implementation.\n-pub fn get_impl_or_trait_items(cdata: Cmd, impl_id: DefIndex)\n-                               -> Vec<ty::ImplOrTraitItemId> {\n-    let item = cdata.lookup_item(impl_id);\n-    let mut dcx = item.get(tag_mod_children).decoder();\n-    dcx.cdata = Some(cdata);\n-    dcx.seq().map(|def_id: DefId| {\n-        match item_to_def(cdata, cdata.lookup_item(def_id.index), def_id) {\n-            Some(Def::AssociatedConst(def_id)) => ty::ConstTraitItemId(def_id),\n-            Some(Def::Method(def_id)) => ty::MethodTraitItemId(def_id),\n-            Some(Def::AssociatedTy(_, def_id)) => ty::TypeTraitItemId(def_id),\n-            def => bug!(\"get_impl_or_trait_items: invalid def {:?}\", def)\n-        }\n-    }).collect()\n-}\n-\n pub fn get_trait_name(cdata: Cmd, id: DefIndex) -> ast::Name {\n     let doc = cdata.lookup_item(id);\n     item_name(doc)"}, {"sha": "326eb0fe9a3ab7cff13870aba728b072545c9cd1", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=89736e86716808801732323f3aa848b97fc2b5ba", "patch": "@@ -993,8 +993,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 }\n \n                 self.start_tag(tag_mod_children);\n-                let items = tcx.impl_or_trait_items(def_id);\n-                self.seq(&items[..], |_, id| id.def_id());\n+                tcx.impl_or_trait_items(def_id).encode(self).unwrap();\n                 <[def::Export]>::encode(&[], self).unwrap();\n                 self.end_tag();\n \n@@ -1039,7 +1038,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 tcx.trait_has_default_impl(def_id).encode(self).unwrap();\n                 self.end_tag();\n \n-                encode_associated_type_names(self, &trait_def.associated_type_names);\n                 self.encode_generics(&trait_def.generics, &trait_predicates);\n                 self.encode_predicates(&tcx.lookup_super_predicates(def_id),\n                                        tag_item_super_predicates);\n@@ -1051,8 +1049,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 encode_deprecation(self, depr);\n \n                 self.start_tag(tag_mod_children);\n-                let items = tcx.impl_or_trait_items(def_id);\n-                self.seq(&items[..], |_, id| id.def_id());\n+                tcx.impl_or_trait_items(def_id).encode(self).unwrap();\n                 <[def::Export]>::encode(&[], self).unwrap();\n                 self.end_tag();\n \n@@ -1151,7 +1148,6 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n                 None\n             };\n \n-            let trait_item_def_id = trait_item_def_id.def_id();\n             self.record(trait_item_def_id,\n                         EncodeContext::encode_info_for_impl_item,\n                         (impl_id, trait_item_def_id, ast_item));\n@@ -1163,8 +1159,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n                               trait_items: &[hir::TraitItem]) {\n         // Now output the trait item info for each trait item.\n         let r = self.tcx.impl_or_trait_items(def_id);\n-        for (item_def_id, trait_item) in r.iter().zip(trait_items) {\n-            let item_def_id = item_def_id.def_id();\n+        for (&item_def_id, trait_item) in r.iter().zip(trait_items) {\n             assert!(item_def_id.is_local());\n             self.record(item_def_id,\n                         EncodeContext::encode_info_for_trait_item,\n@@ -1331,12 +1326,6 @@ fn encode_attributes(ecx: &mut EncodeContext, attrs: &[ast::Attribute]) {\n     ecx.end_tag();\n }\n \n-fn encode_associated_type_names(ecx: &mut EncodeContext, names: &[Name]) {\n-    ecx.start_tag(tag_associated_type_names);\n-    names.encode(ecx).unwrap();\n-    ecx.end_tag();\n-}\n-\n fn encode_crate_deps(ecx: &mut EncodeContext, cstore: &cstore::CStore) {\n     fn get_ordered_deps(cstore: &cstore::CStore)\n                         -> Vec<(CrateNum, Rc<cstore::CrateMetadata>)> {"}, {"sha": "7264dcea9553e75c8816123aa50d9120870ad691", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=89736e86716808801732323f3aa848b97fc2b5ba", "patch": "@@ -432,9 +432,9 @@ impl<'b> Resolver<'b> {\n                 // info.\n \n                 let trait_item_def_ids = self.session.cstore.impl_or_trait_items(def_id);\n-                for trait_item_def in &trait_item_def_ids {\n+                for &trait_item_def in &trait_item_def_ids {\n                     let trait_item_name =\n-                        self.session.cstore.item_name(trait_item_def.def_id());\n+                        self.session.cstore.item_name(trait_item_def);\n \n                     debug!(\"(building reduced graph for external crate) ... adding trait item \\\n                             '{}'\","}, {"sha": "aa68a873120ec8670db7ed78c17699c0ad84e02f", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=89736e86716808801732323f3aa848b97fc2b5ba", "patch": "@@ -374,8 +374,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         let qualname = format!(\"{}::{}\", qualname, name);\n \n         let def_id = self.tcx.map.local_def_id(id);\n-        let decl_id = self.tcx.trait_item_of_item(def_id).and_then(|new_id| {\n-            let new_def_id = new_id.def_id();\n+        let decl_id = self.tcx.trait_item_of_item(def_id).and_then(|new_def_id| {\n             if new_def_id != def_id {\n                 Some(new_def_id)\n             } else {\n@@ -543,14 +542,9 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                                 .map(|mr| mr.def_id())\n                         }\n                         ty::ImplContainer(def_id) => {\n-                            let impl_items = self.tcx.impl_or_trait_items(def_id);\n-                            Some(impl_items.iter()\n-                                           .find(|mr| {\n-                                               self.tcx.impl_or_trait_item(mr.def_id()).name() ==\n-                                               ti.name()\n-                                           })\n-                                           .unwrap()\n-                                           .def_id())\n+                            Some(*self.tcx.impl_or_trait_items(def_id).iter().find(|&&mr| {\n+                                self.tcx.impl_or_trait_item(mr).name() == ti.name()\n+                            }).unwrap())\n                         }\n                     }\n                 } else {"}, {"sha": "8540c7a99db15a466c9102091fb3a15d6ac0a94a", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=89736e86716808801732323f3aa848b97fc2b5ba", "patch": "@@ -235,24 +235,20 @@ pub fn get_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         .iter()\n \n         // Filter out non-method items.\n-        .filter_map(|item_def_id| {\n-            match *item_def_id {\n-                ty::MethodTraitItemId(def_id) => Some(def_id),\n-                _ => None,\n+        .filter_map(|&item_def_id| {\n+            match tcx.impl_or_trait_item(item_def_id) {\n+                ty::MethodTraitItem(m) => Some(m),\n+                _ => None\n             }\n         })\n \n         // Now produce pointers for each remaining method. If the\n         // method could never be called from this object, just supply\n         // null.\n-        .map(|trait_method_def_id| {\n+        .map(|trait_method_type| {\n             debug!(\"get_vtable_methods: trait_method_def_id={:?}\",\n-                   trait_method_def_id);\n+                   trait_method_type.def_id);\n \n-            let trait_method_type = match tcx.impl_or_trait_item(trait_method_def_id) {\n-                ty::MethodTraitItem(m) => m,\n-                _ => bug!(\"should be a method, not other assoc item\"),\n-            };\n             let name = trait_method_type.name;\n \n             // Some methods cannot be called on an object; skip those.\n@@ -266,7 +262,7 @@ pub fn get_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             // the method may have some early-bound lifetimes, add\n             // regions for those\n-            let method_substs = Substs::for_item(tcx, trait_method_def_id,\n+            let method_substs = Substs::for_item(tcx, trait_method_type.def_id,\n                                                  |_, _| tcx.mk_region(ty::ReErased),\n                                                  |_, _| tcx.types.err);\n "}, {"sha": "cad5ed4f2e651e1363d463c2c695a2a11c12adf8", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=89736e86716808801732323f3aa848b97fc2b5ba", "patch": "@@ -248,16 +248,14 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n             if let traits::VtableImpl(vtable_impl) = vtable {\n                 let name = ccx.tcx().item_name(instance.def);\n                 let ac = ccx.tcx().impl_or_trait_items(vtable_impl.impl_def_id)\n-                    .iter().filter_map(|id| {\n-                        match *id {\n-                            ty::ConstTraitItemId(def_id) => {\n-                                Some(ccx.tcx().impl_or_trait_item(def_id))\n-                            }\n+                    .iter().filter_map(|&def_id| {\n+                        match ccx.tcx().impl_or_trait_item(def_id) {\n+                            ty::ConstTraitItem(ac) => Some(ac),\n                             _ => None\n                         }\n-                    }).find(|ic| ic.name() == name);\n+                    }).find(|ic| ic.name == name);\n                 if let Some(ac) = ac {\n-                    instance = Instance::new(ac.def_id(), vtable_impl.substs);\n+                    instance = Instance::new(ac.def_id, vtable_impl.substs);\n                 }\n             }\n         }"}, {"sha": "00c9ea3af182e2aaa2d089bf26e58ac633d804ec", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=89736e86716808801732323f3aa848b97fc2b5ba", "patch": "@@ -1134,16 +1134,23 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             return tcx.types.err;\n         }\n \n-        let mut associated_types: FnvHashSet<(DefId, ast::Name)> =\n-            traits::supertraits(tcx, principal)\n-            .flat_map(|tr| {\n-                let trait_def = tcx.lookup_trait_def(tr.def_id());\n-                trait_def.associated_type_names\n-                    .clone()\n-                    .into_iter()\n-                    .map(move |associated_type_name| (tr.def_id(), associated_type_name))\n-            })\n-            .collect();\n+        let mut associated_types = FnvHashSet::default();\n+        for tr in traits::supertraits(tcx, principal) {\n+            if let Some(trait_id) = tcx.map.as_local_node_id(tr.def_id()) {\n+                use collect::trait_associated_type_names;\n+\n+                associated_types.extend(trait_associated_type_names(tcx, trait_id)\n+                    .map(|name| (tr.def_id(), name)))\n+            } else {\n+                let trait_items = tcx.impl_or_trait_items(tr.def_id());\n+                associated_types.extend(trait_items.iter().filter_map(|&def_id| {\n+                    match tcx.impl_or_trait_item(def_id) {\n+                        ty::TypeTraitItem(ref item) => Some(item.name),\n+                        _ => None\n+                    }\n+                }).map(|name| (tr.def_id(), name)));\n+            }\n+        }\n \n         for projection_bound in &projection_bounds {\n             let pair = (projection_bound.0.projection_ty.trait_ref.def_id,"}, {"sha": "73caf79c9f8d1b345c92870a239cad79fa0dd141", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=89736e86716808801732323f3aa848b97fc2b5ba", "patch": "@@ -368,7 +368,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     {\n         self.tcx.impl_or_trait_items(def_id)\n             .iter()\n-            .map(|&did| self.tcx.impl_or_trait_item(did.def_id()))\n+            .map(|&did| self.tcx.impl_or_trait_item(did))\n             .find(|m| m.name() == item_name)\n     }\n }"}, {"sha": "3a854da1d48022e9e42372d32c1d5f72a9dec091", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=89736e86716808801732323f3aa848b97fc2b5ba", "patch": "@@ -1348,8 +1348,12 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n                                            assoc_name: ast::Name)\n                                            -> bool\n     {\n-        let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n-        trait_def.associated_type_names.contains(&assoc_name)\n+        self.tcx().impl_or_trait_items(trait_def_id).iter().any(|&def_id| {\n+            match self.tcx().impl_or_trait_item(def_id) {\n+                ty::TypeTraitItem(ref item) => item.name == assoc_name,\n+                _ => false\n+            }\n+        })\n     }\n \n     fn ty_infer(&self, _span: Span) -> Ty<'tcx> {"}, {"sha": "3b4c98fc71e4451246ff6286df5a3ea82ba6ed35", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=89736e86716808801732323f3aa848b97fc2b5ba", "patch": "@@ -20,8 +20,7 @@ use middle::lang_items::UnsizeTraitLangItem;\n use rustc::ty::subst::Subst;\n use rustc::ty::{self, TyCtxt, TypeFoldable};\n use rustc::traits::{self, Reveal};\n-use rustc::ty::{ImplOrTraitItemId, ConstTraitItemId};\n-use rustc::ty::{MethodTraitItemId, TypeTraitItemId, ParameterEnvironment};\n+use rustc::ty::{ParameterEnvironment};\n use rustc::ty::{Ty, TyBool, TyChar, TyError};\n use rustc::ty::{TyParam, TyRawPtr};\n use rustc::ty::{TyRef, TyAdt, TyTrait, TyNever, TyTuple};\n@@ -158,7 +157,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        tcx.impl_or_trait_item_ids.borrow_mut().insert(impl_did, Rc::new(impl_items));\n+        tcx.impl_or_trait_item_def_ids.borrow_mut().insert(impl_did, Rc::new(impl_items));\n     }\n \n     fn add_inherent_impl(&self, base_def_id: DefId, impl_def_id: DefId) {\n@@ -174,22 +173,11 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n     }\n \n     // Converts an implementation in the AST to a vector of items.\n-    fn create_impl_from_item(&self, item: &Item) -> Vec<ImplOrTraitItemId> {\n+    fn create_impl_from_item(&self, item: &Item) -> Vec<DefId> {\n         match item.node {\n             ItemImpl(.., ref impl_items) => {\n                 impl_items.iter().map(|impl_item| {\n-                    let impl_def_id = self.crate_context.tcx.map.local_def_id(impl_item.id);\n-                    match impl_item.node {\n-                        hir::ImplItemKind::Const(..) => {\n-                            ConstTraitItemId(impl_def_id)\n-                        }\n-                        hir::ImplItemKind::Method(..) => {\n-                            MethodTraitItemId(impl_def_id)\n-                        }\n-                        hir::ImplItemKind::Type(_) => {\n-                            TypeTraitItemId(impl_def_id)\n-                        }\n-                    }\n+                    self.crate_context.tcx.map.local_def_id(impl_item.id)\n                 }).collect()\n             }\n             _ => {\n@@ -210,7 +198,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n         tcx.populate_implementations_for_trait_if_necessary(drop_trait);\n         let drop_trait = tcx.lookup_trait_def(drop_trait);\n \n-        let impl_items = tcx.impl_or_trait_item_ids.borrow();\n+        let impl_items = tcx.impl_or_trait_item_def_ids.borrow();\n \n         drop_trait.for_each_impl(tcx, |impl_did| {\n             let items = impl_items.get(&impl_did).unwrap();\n@@ -223,7 +211,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n             let self_type = tcx.lookup_item_type(impl_did);\n             match self_type.ty.sty {\n                 ty::TyAdt(type_def, _) => {\n-                    type_def.set_destructor(method_def_id.def_id());\n+                    type_def.set_destructor(method_def_id);\n                 }\n                 _ => {\n                     // Destructors only work on nominal types."}, {"sha": "c42b8f8840028afecb8fdc41764c3dff85899744", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=89736e86716808801732323f3aa848b97fc2b5ba", "patch": "@@ -44,29 +44,29 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n         enum Namespace { Type, Value }\n \n         fn name_and_namespace<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                        item: &ty::ImplOrTraitItemId)\n+                                        def_id: DefId)\n                                         -> (ast::Name, Namespace)\n         {\n-            let name = tcx.impl_or_trait_item(item.def_id()).name();\n-            (name, match *item {\n-                ty::TypeTraitItemId(..) => Namespace::Type,\n-                ty::ConstTraitItemId(..) => Namespace::Value,\n-                ty::MethodTraitItemId(..) => Namespace::Value,\n+            let item = tcx.impl_or_trait_item(def_id);\n+            (item.name(), match item {\n+                ty::TypeTraitItem(..) => Namespace::Type,\n+                ty::ConstTraitItem(..) => Namespace::Value,\n+                ty::MethodTraitItem(..) => Namespace::Value,\n             })\n         }\n \n-        let impl_items = self.tcx.impl_or_trait_item_ids.borrow();\n+        let impl_items = self.tcx.impl_or_trait_item_def_ids.borrow();\n \n-        for item1 in &impl_items[&impl1][..] {\n+        for &item1 in &impl_items[&impl1][..] {\n             let (name, namespace) = name_and_namespace(self.tcx, item1);\n \n-            for item2 in &impl_items[&impl2][..] {\n+            for &item2 in &impl_items[&impl2][..] {\n                 if (name, namespace) == name_and_namespace(self.tcx, item2) {\n                     let msg = format!(\"duplicate definitions with name `{}`\", name);\n-                    let node_id = self.tcx.map.as_local_node_id(item1.def_id()).unwrap();\n+                    let node_id = self.tcx.map.as_local_node_id(item1).unwrap();\n                     self.tcx.sess.add_lint(lint::builtin::OVERLAPPING_INHERENT_IMPLS,\n                                            node_id,\n-                                           self.tcx.span_of_impl(item1.def_id()).unwrap(),\n+                                           self.tcx.span_of_impl(item1).unwrap(),\n                                            msg);\n                 }\n             }"}, {"sha": "d67dcbb4baf0d48e90651531e951d58ed1c289e8", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 22, "deletions": 34, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=89736e86716808801732323f3aa848b97fc2b5ba", "patch": "@@ -361,10 +361,15 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n                                            -> bool\n     {\n         if let Some(trait_id) = self.tcx().map.as_local_node_id(trait_def_id) {\n-            trait_defines_associated_type_named(self.ccx, trait_id, assoc_name)\n+            trait_associated_type_names(self.tcx(), trait_id)\n+                .any(|name| name == assoc_name)\n         } else {\n-            let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n-            trait_def.associated_type_names.contains(&assoc_name)\n+            self.tcx().impl_or_trait_items(trait_def_id).iter().any(|&def_id| {\n+                match self.tcx().impl_or_trait_item(def_id) {\n+                    ty::TypeTraitItem(ref item) => item.name == assoc_name,\n+                    _ => false\n+                }\n+            })\n         }\n     }\n \n@@ -926,15 +931,10 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n             // Add an entry mapping\n             let trait_item_def_ids = Rc::new(trait_items.iter().map(|trait_item| {\n-                let def_id = ccx.tcx.map.local_def_id(trait_item.id);\n-                match trait_item.node {\n-                    hir::ConstTraitItem(..) => ty::ConstTraitItemId(def_id),\n-                    hir::MethodTraitItem(..) => ty::MethodTraitItemId(def_id),\n-                    hir::TypeTraitItem(..) => ty::TypeTraitItemId(def_id)\n-                }\n+                ccx.tcx.map.local_def_id(trait_item.id)\n             }).collect());\n-            tcx.impl_or_trait_item_ids.borrow_mut().insert(ccx.tcx.map.local_def_id(it.id),\n-                                                           trait_item_def_ids);\n+            tcx.impl_or_trait_item_def_ids.borrow_mut().insert(ccx.tcx.map.local_def_id(it.id),\n+                                                               trait_item_def_ids);\n         },\n         hir::ItemStruct(ref struct_def, _) |\n         hir::ItemUnion(ref struct_def, _) => {\n@@ -1266,9 +1266,9 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         return def.clone();\n     }\n \n-    let (unsafety, generics, items) = match it.node {\n-        hir::ItemTrait(unsafety, ref generics, _, ref items) => {\n-            (unsafety, generics, items)\n+    let (unsafety, generics) = match it.node {\n+        hir::ItemTrait(unsafety, ref generics, _, _) => {\n+            (unsafety, generics)\n         }\n         _ => span_bug!(it.span, \"trait_def_of_item invoked on non-trait\"),\n     };\n@@ -1288,32 +1288,20 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let ty_generics = generics_of_def_id(ccx, def_id);\n     let substs = mk_item_substs(&ccx.icx(generics), it.span, def_id);\n \n-    let associated_type_names: Vec<_> = items.iter().filter_map(|trait_item| {\n-        match trait_item.node {\n-            hir::TypeTraitItem(..) => Some(trait_item.name),\n-            _ => None,\n-        }\n-    }).collect();\n-\n     let def_path_hash = tcx.def_path(def_id).deterministic_hash(tcx);\n \n     let trait_ref = ty::TraitRef::new(def_id, substs);\n-    let trait_def = ty::TraitDef::new(unsafety,\n-                                      paren_sugar,\n-                                      ty_generics,\n-                                      trait_ref,\n-                                      associated_type_names,\n+    let trait_def = ty::TraitDef::new(unsafety, paren_sugar, ty_generics, trait_ref,\n                                       def_path_hash);\n \n     tcx.intern_trait_def(trait_def)\n }\n \n-fn trait_defines_associated_type_named(ccx: &CrateCtxt,\n-                                       trait_node_id: ast::NodeId,\n-                                       assoc_name: ast::Name)\n-                                       -> bool\n+pub fn trait_associated_type_names<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                                   trait_node_id: ast::NodeId)\n+                                                   -> impl Iterator<Item=ast::Name> + 'a\n {\n-    let item = match ccx.tcx.map.get(trait_node_id) {\n+    let item = match tcx.map.get(trait_node_id) {\n         hir_map::NodeItem(item) => item,\n         _ => bug!(\"trait_node_id {} is not an item\", trait_node_id)\n     };\n@@ -1323,10 +1311,10 @@ fn trait_defines_associated_type_named(ccx: &CrateCtxt,\n         _ => bug!(\"trait_node_id {} is not a trait\", trait_node_id)\n     };\n \n-    trait_items.iter().any(|trait_item| {\n+    trait_items.iter().filter_map(|trait_item| {\n         match trait_item.node {\n-            hir::TypeTraitItem(..) => trait_item.name == assoc_name,\n-            _ => false,\n+            hir::TypeTraitItem(..) => Some(trait_item.name),\n+            _ => None,\n         }\n     })\n }"}, {"sha": "1f34cee5143c61e9e147bd4584efbaa3bfb121f1", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=89736e86716808801732323f3aa848b97fc2b5ba", "patch": "@@ -76,6 +76,7 @@ This API is completely unstable and subject to change.\n \n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(conservative_impl_trait)]\n #![feature(dotdot_in_tuple_patterns)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]"}, {"sha": "e72ea60072e0892f06071d08ac73d91005629c6c", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89736e86716808801732323f3aa848b97fc2b5ba/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=89736e86716808801732323f3aa848b97fc2b5ba", "patch": "@@ -368,10 +368,8 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n     let predicates = tcx.lookup_predicates(did);\n     let trait_items = tcx.sess.cstore.impl_or_trait_items(did)\n             .iter()\n-            .filter_map(|did| {\n-        let did = did.def_id();\n-        let impl_item = tcx.impl_or_trait_item(did);\n-        match impl_item {\n+            .filter_map(|&did| {\n+        match tcx.impl_or_trait_item(did) {\n             ty::ConstTraitItem(ref assoc_const) => {\n                 let did = assoc_const.def_id;\n                 let type_scheme = tcx.lookup_item_type(did);"}]}