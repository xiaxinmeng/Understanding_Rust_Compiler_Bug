{"sha": "5e8cb3819bf62527947634ad4d5e44b4b69daecd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlOGNiMzgxOWJmNjI1Mjc5NDc2MzRhZDRkNWU0NGI0YjY5ZGFlY2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-04T18:37:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-04T18:37:21Z"}, "message": "Auto merge of #30523 - ubsan:wrapping_op_assign, r=eddyb\n\nAdd OpAssign to Wrapping<T>, plus fix some problems in core::num::wrapping\n\nincluding, but not limited to:\n\n* Testing Wrapping<T>\n* Pull out a lot of broken code that doesn't need to be there with the new stage0 compiler\n* Adding Rem and RemAssign to Wrapping<T>\n* Removed 3 (assumed accidental) re-exports, which is a minor [breaking-change].\n* Change shl and shr to take all integer types, instead of a usize; this is a more major [breaking-change], because of values that were inferred before, but brings us in line with the integer shifts.\n\nFixes #30524 and #30523", "tree": {"sha": "1b388e4d9d2e65699bc1949a4ef216524a419600", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b388e4d9d2e65699bc1949a4ef216524a419600"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e8cb3819bf62527947634ad4d5e44b4b69daecd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e8cb3819bf62527947634ad4d5e44b4b69daecd", "html_url": "https://github.com/rust-lang/rust/commit/5e8cb3819bf62527947634ad4d5e44b4b69daecd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e8cb3819bf62527947634ad4d5e44b4b69daecd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b62289153cd94dc60e142e169816bbec68514906", "url": "https://api.github.com/repos/rust-lang/rust/commits/b62289153cd94dc60e142e169816bbec68514906", "html_url": "https://github.com/rust-lang/rust/commit/b62289153cd94dc60e142e169816bbec68514906"}, {"sha": "402259da38adee9c5a1dca67489e022c4628dfa8", "url": "https://api.github.com/repos/rust-lang/rust/commits/402259da38adee9c5a1dca67489e022c4628dfa8", "html_url": "https://github.com/rust-lang/rust/commit/402259da38adee9c5a1dca67489e022c4628dfa8"}], "stats": {"total": 805, "additions": 591, "deletions": 214}, "files": [{"sha": "72f0d77f68baca3ebe4bac936860d8be404ded5a", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 173, "deletions": 208, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/5e8cb3819bf62527947634ad4d5e44b4b69daecd/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8cb3819bf62527947634ad4d5e44b4b69daecd/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=5e8cb3819bf62527947634ad4d5e44b4b69daecd", "patch": "@@ -12,13 +12,13 @@\n #![unstable(feature = \"wrapping\", reason = \"may be removed or relocated\",\n             issue = \"27755\")]\n \n-pub use intrinsics::{add_with_overflow, sub_with_overflow, mul_with_overflow};\n+use intrinsics::{add_with_overflow, sub_with_overflow, mul_with_overflow};\n \n use super::Wrapping;\n \n use ops::*;\n \n-use ::{i8,i16,i32,i64};\n+use ::{i8, i16, i32, i64, isize};\n \n pub trait OverflowingOps {\n     fn overflowing_add(self, rhs: Self) -> (Self, bool);\n@@ -33,15 +33,71 @@ pub trait OverflowingOps {\n     fn overflowing_shr(self, rhs: u32) -> (Self, bool);\n }\n \n-macro_rules! sh_impl {\n-    ($t:ty, $f:ty) => (\n+macro_rules! sh_impl_signed {\n+    ($t:ident, $f:ident) => (\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Shl<$f> for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n             #[inline(always)]\n             fn shl(self, other: $f) -> Wrapping<$t> {\n-                Wrapping(self.0 << other)\n+                if other < 0 {\n+                    Wrapping(self.0 >> (-other & self::shift_max::$t as $f))\n+                } else {\n+                    Wrapping(self.0 << (other & self::shift_max::$t as $f))\n+                }\n+            }\n+        }\n+\n+        #[unstable(feature = \"wrapping_impls\", reason = \"recently added\", issue = \"30524\")]\n+        impl ShlAssign<$f> for Wrapping<$t> {\n+            #[inline(always)]\n+            fn shl_assign(&mut self, other: $f) {\n+                *self = *self << other;\n+            }\n+        }\n+\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Shr<$f> for Wrapping<$t> {\n+            type Output = Wrapping<$t>;\n+\n+            #[inline(always)]\n+            fn shr(self, other: $f) -> Wrapping<$t> {\n+                if other < 0 {\n+                    Wrapping(self.0 << (-other & self::shift_max::$t as $f))\n+                } else {\n+                    Wrapping(self.0 >> (other & self::shift_max::$t as $f))\n+                }\n+            }\n+        }\n+\n+        #[unstable(feature = \"wrapping_impls\", reason = \"recently added\", issue = \"30524\")]\n+        impl ShrAssign<$f> for Wrapping<$t> {\n+            #[inline(always)]\n+            fn shr_assign(&mut self, other: $f) {\n+                *self = *self >> other;\n+            }\n+        }\n+    )\n+}\n+\n+macro_rules! sh_impl_unsigned {\n+    ($t:ident, $f:ident) => (\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Shl<$f> for Wrapping<$t> {\n+            type Output = Wrapping<$t>;\n+\n+            #[inline(always)]\n+            fn shl(self, other: $f) -> Wrapping<$t> {\n+                Wrapping(self.0 << (other & self::shift_max::$t as $f))\n+            }\n+        }\n+\n+        #[unstable(feature = \"wrapping_impls\", reason = \"recently added\", issue = \"30524\")]\n+        impl ShlAssign<$f> for Wrapping<$t> {\n+            #[inline(always)]\n+            fn shl_assign(&mut self, other: $f) {\n+                *self = *self << other;\n             }\n         }\n \n@@ -51,31 +107,40 @@ macro_rules! sh_impl {\n \n             #[inline(always)]\n             fn shr(self, other: $f) -> Wrapping<$t> {\n-                Wrapping(self.0 >> other)\n+                Wrapping(self.0 >> (other & self::shift_max::$t as $f))\n+            }\n+        }\n+\n+        #[unstable(feature = \"wrapping_impls\", reason = \"recently added\", issue = \"30524\")]\n+        impl ShrAssign<$f> for Wrapping<$t> {\n+            #[inline(always)]\n+            fn shr_assign(&mut self, other: $f) {\n+                *self = *self >> other;\n             }\n         }\n     )\n }\n \n // FIXME (#23545): uncomment the remaining impls\n macro_rules! sh_impl_all {\n-    ($($t:ty)*) => ($(\n-        // sh_impl! { $t, u8 }\n-        // sh_impl! { $t, u16 }\n-        // sh_impl! { $t, u32 }\n-        // sh_impl! { $t, u64 }\n-        sh_impl! { $t, usize }\n-\n-        // sh_impl! { $t, i8 }\n-        // sh_impl! { $t, i16 }\n-        // sh_impl! { $t, i32 }\n-        // sh_impl! { $t, i64 }\n-        // sh_impl! { $t, isize }\n+    ($($t:ident)*) => ($(\n+        sh_impl_unsigned! { $t, u8 }\n+        sh_impl_unsigned! { $t, u16 }\n+        sh_impl_unsigned! { $t, u32 }\n+        sh_impl_unsigned! { $t, u64 }\n+        sh_impl_unsigned! { $t, usize }\n+\n+        sh_impl_signed! { $t, i8 }\n+        sh_impl_signed! { $t, i16 }\n+        sh_impl_signed! { $t, i32 }\n+        sh_impl_signed! { $t, i64 }\n+        sh_impl_signed! { $t, isize }\n     )*)\n }\n \n sh_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n \n+// FIXME(30524): impl Op<T> for Wrapping<T>, impl OpAssign<T> for Wrapping<T>\n macro_rules! wrapping_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -88,6 +153,14 @@ macro_rules! wrapping_impl {\n             }\n         }\n \n+        #[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+        impl AddAssign for Wrapping<$t> {\n+            #[inline(always)]\n+            fn add_assign(&mut self, other: Wrapping<$t>) {\n+                *self = *self + other;\n+            }\n+        }\n+\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Sub for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n@@ -98,6 +171,14 @@ macro_rules! wrapping_impl {\n             }\n         }\n \n+        #[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+        impl SubAssign for Wrapping<$t> {\n+            #[inline(always)]\n+            fn sub_assign(&mut self, other: Wrapping<$t>) {\n+                *self = *self - other;\n+            }\n+        }\n+\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Mul for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n@@ -108,6 +189,14 @@ macro_rules! wrapping_impl {\n             }\n         }\n \n+        #[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+        impl MulAssign for Wrapping<$t> {\n+            #[inline(always)]\n+            fn mul_assign(&mut self, other: Wrapping<$t>) {\n+                *self = *self * other;\n+            }\n+        }\n+\n         #[stable(feature = \"wrapping_div\", since = \"1.3.0\")]\n         impl Div for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n@@ -118,6 +207,32 @@ macro_rules! wrapping_impl {\n             }\n         }\n \n+        #[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+        impl DivAssign for Wrapping<$t> {\n+            #[inline(always)]\n+            fn div_assign(&mut self, other: Wrapping<$t>) {\n+                *self = *self / other;\n+            }\n+        }\n+\n+        #[unstable(feature = \"wrapping_impls\", reason = \"recently added\", issue = \"30524\")]\n+        impl Rem for Wrapping<$t> {\n+            type Output = Wrapping<$t>;\n+\n+            #[inline(always)]\n+            fn rem(self, other: Wrapping<$t>) -> Wrapping<$t> {\n+                Wrapping(self.0.wrapping_rem(other.0))\n+            }\n+        }\n+\n+        #[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+        impl RemAssign for Wrapping<$t> {\n+            #[inline(always)]\n+            fn rem_assign(&mut self, other: Wrapping<$t>) {\n+                *self = *self % other;\n+            }\n+        }\n+\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Not for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n@@ -138,6 +253,14 @@ macro_rules! wrapping_impl {\n             }\n         }\n \n+        #[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+        impl BitXorAssign for Wrapping<$t> {\n+            #[inline(always)]\n+            fn bitxor_assign(&mut self, other: Wrapping<$t>) {\n+                *self = *self ^ other;\n+            }\n+        }\n+\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl BitOr for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n@@ -148,6 +271,14 @@ macro_rules! wrapping_impl {\n             }\n         }\n \n+        #[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+        impl BitOrAssign for Wrapping<$t> {\n+            #[inline(always)]\n+            fn bitor_assign(&mut self, other: Wrapping<$t>) {\n+                *self = *self | other;\n+            }\n+        }\n+\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl BitAnd for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n@@ -157,6 +288,14 @@ macro_rules! wrapping_impl {\n                 Wrapping(self.0 & other.0)\n             }\n         }\n+\n+        #[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+        impl BitAndAssign for Wrapping<$t> {\n+            #[inline(always)]\n+            fn bitand_assign(&mut self, other: Wrapping<$t>) {\n+                *self = *self & other;\n+            }\n+        }\n     )*)\n }\n \n@@ -165,15 +304,29 @@ wrapping_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n mod shift_max {\n     #![allow(non_upper_case_globals)]\n \n+    #[cfg(target_pointer_width = \"32\")]\n+    mod platform {\n+        pub const usize: u32 = super::u32;\n+        pub const isize: u32 = super::i32;\n+    }\n+\n+    #[cfg(target_pointer_width = \"64\")]\n+    mod platform {\n+        pub const usize: u32 = super::u64;\n+        pub const isize: u32 = super::i64;\n+    }\n+\n     pub const  i8: u32 = (1 << 3) - 1;\n     pub const i16: u32 = (1 << 4) - 1;\n     pub const i32: u32 = (1 << 5) - 1;\n     pub const i64: u32 = (1 << 6) - 1;\n+    pub use self::platform::isize;\n \n     pub const  u8: u32 = i8;\n     pub const u16: u32 = i16;\n     pub const u32: u32 = i32;\n     pub const u64: u32 = i64;\n+    pub use self::platform::usize;\n }\n \n macro_rules! signed_overflowing_impl {\n@@ -288,193 +441,5 @@ macro_rules! unsigned_overflowing_impl {\n     )*)\n }\n \n-signed_overflowing_impl! { i8 i16 i32 i64 }\n-unsigned_overflowing_impl! { u8 u16 u32 u64 }\n-\n-#[cfg(target_pointer_width = \"64\")]\n-impl OverflowingOps for usize {\n-    #[inline(always)]\n-    fn overflowing_add(self, rhs: usize) -> (usize, bool) {\n-        unsafe {\n-            add_with_overflow(self, rhs)\n-        }\n-    }\n-    #[inline(always)]\n-    fn overflowing_sub(self, rhs: usize) -> (usize, bool) {\n-        unsafe {\n-            sub_with_overflow(self, rhs)\n-        }\n-    }\n-    #[inline(always)]\n-    fn overflowing_mul(self, rhs: usize) -> (usize, bool) {\n-        unsafe {\n-            mul_with_overflow(self, rhs)\n-        }\n-    }\n-    #[inline(always)]\n-    fn overflowing_div(self, rhs: usize) -> (usize, bool) {\n-        let (r, f) = (self as u64).overflowing_div(rhs as u64);\n-        (r as usize, f)\n-    }\n-    #[inline(always)]\n-    fn overflowing_rem(self, rhs: usize) -> (usize, bool) {\n-        let (r, f) = (self as u64).overflowing_rem(rhs as u64);\n-        (r as usize, f)\n-    }\n-    #[inline(always)]\n-    fn overflowing_neg(self) -> (usize, bool) {\n-        let (r, f) = (self as u64).overflowing_neg();\n-        (r as usize, f)\n-    }\n-    #[inline(always)]\n-    fn overflowing_shl(self, rhs: u32) -> (usize, bool) {\n-        let (r, f) = (self as u64).overflowing_shl(rhs);\n-        (r as usize, f)\n-    }\n-    #[inline(always)]\n-    fn overflowing_shr(self, rhs: u32) -> (usize, bool) {\n-        let (r, f) = (self as u64).overflowing_shr(rhs);\n-        (r as usize, f)\n-    }\n-}\n-\n-#[cfg(target_pointer_width = \"32\")]\n-impl OverflowingOps for usize {\n-    #[inline(always)]\n-    fn overflowing_add(self, rhs: usize) -> (usize, bool) {\n-        unsafe {\n-            add_with_overflow(self, rhs)\n-        }\n-    }\n-    #[inline(always)]\n-    fn overflowing_sub(self, rhs: usize) -> (usize, bool) {\n-        unsafe {\n-            sub_with_overflow(self, rhs)\n-        }\n-    }\n-    #[inline(always)]\n-    fn overflowing_mul(self, rhs: usize) -> (usize, bool) {\n-        unsafe {\n-            mul_with_overflow(self, rhs)\n-        }\n-    }\n-    #[inline(always)]\n-    fn overflowing_div(self, rhs: usize) -> (usize, bool) {\n-        let (r, f) = (self as u32).overflowing_div(rhs as u32);\n-        (r as usize, f)\n-    }\n-    #[inline(always)]\n-    fn overflowing_rem(self, rhs: usize) -> (usize, bool) {\n-        let (r, f) = (self as u32).overflowing_rem(rhs as u32);\n-        (r as usize, f)\n-    }\n-    #[inline(always)]\n-    fn overflowing_neg(self) -> (usize, bool) {\n-        let (r, f) = (self as u32).overflowing_neg();\n-        (r as usize, f)\n-    }\n-    #[inline(always)]\n-    fn overflowing_shl(self, rhs: u32) -> (usize, bool) {\n-        let (r, f) = (self as u32).overflowing_shl(rhs);\n-        (r as usize, f)\n-    }\n-    #[inline(always)]\n-    fn overflowing_shr(self, rhs: u32) -> (usize, bool) {\n-        let (r, f) = (self as u32).overflowing_shr(rhs);\n-        (r as usize, f)\n-    }\n-}\n-\n-#[cfg(target_pointer_width = \"64\")]\n-impl OverflowingOps for isize {\n-    #[inline(always)]\n-    fn overflowing_add(self, rhs: isize) -> (isize, bool) {\n-        unsafe {\n-            add_with_overflow(self, rhs)\n-        }\n-    }\n-    #[inline(always)]\n-    fn overflowing_sub(self, rhs: isize) -> (isize, bool) {\n-        unsafe {\n-            sub_with_overflow(self, rhs)\n-        }\n-    }\n-    #[inline(always)]\n-    fn overflowing_mul(self, rhs: isize) -> (isize, bool) {\n-        unsafe {\n-            mul_with_overflow(self, rhs)\n-        }\n-    }\n-    #[inline(always)]\n-    fn overflowing_div(self, rhs: isize) -> (isize, bool) {\n-        let (r, f) = (self as i64).overflowing_div(rhs as i64);\n-        (r as isize, f)\n-    }\n-    #[inline(always)]\n-    fn overflowing_rem(self, rhs: isize) -> (isize, bool) {\n-        let (r, f) = (self as i64).overflowing_rem(rhs as i64);\n-        (r as isize, f)\n-    }\n-    #[inline(always)]\n-    fn overflowing_neg(self) -> (isize, bool) {\n-        let (r, f) = (self as i64).overflowing_neg();\n-        (r as isize, f)\n-    }\n-    #[inline(always)]\n-    fn overflowing_shl(self, rhs: u32) -> (isize, bool) {\n-        let (r, f) = (self as i64).overflowing_shl(rhs);\n-        (r as isize, f)\n-    }\n-    #[inline(always)]\n-    fn overflowing_shr(self, rhs: u32) -> (isize, bool) {\n-        let (r, f) = (self as i64).overflowing_shr(rhs);\n-        (r as isize, f)\n-    }\n-}\n-\n-#[cfg(target_pointer_width = \"32\")]\n-impl OverflowingOps for isize {\n-    #[inline(always)]\n-    fn overflowing_add(self, rhs: isize) -> (isize, bool) {\n-        unsafe {\n-            add_with_overflow(self, rhs)\n-        }\n-    }\n-    #[inline(always)]\n-    fn overflowing_sub(self, rhs: isize) -> (isize, bool) {\n-        unsafe {\n-            sub_with_overflow(self, rhs)\n-        }\n-    }\n-    #[inline(always)]\n-    fn overflowing_mul(self, rhs: isize) -> (isize, bool) {\n-        unsafe {\n-            mul_with_overflow(self, rhs)\n-        }\n-    }\n-    #[inline(always)]\n-    fn overflowing_div(self, rhs: isize) -> (isize, bool) {\n-        let (r, f) = (self as i32).overflowing_div(rhs as i32);\n-        (r as isize, f)\n-    }\n-    #[inline(always)]\n-    fn overflowing_rem(self, rhs: isize) -> (isize, bool) {\n-        let (r, f) = (self as i32).overflowing_rem(rhs as i32);\n-        (r as isize, f)\n-    }\n-    #[inline(always)]\n-    fn overflowing_neg(self) -> (isize, bool) {\n-        let (r, f) = (self as i32).overflowing_neg();\n-        (r as isize, f)\n-    }\n-    #[inline(always)]\n-    fn overflowing_shl(self, rhs: u32) -> (isize, bool) {\n-        let (r, f) = (self as i32).overflowing_shl(rhs);\n-        (r as isize, f)\n-    }\n-    #[inline(always)]\n-    fn overflowing_shr(self, rhs: u32) -> (isize, bool) {\n-        let (r, f) = (self as i32).overflowing_shr(rhs);\n-        (r as isize, f)\n-    }\n-}\n+signed_overflowing_impl! { i8 i16 i32 i64 isize }\n+unsigned_overflowing_impl! { u8 u16 u32 u64 usize }"}, {"sha": "545fd22cc592960517e1ec0242b2010d048fedeb", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5e8cb3819bf62527947634ad4d5e44b4b69daecd/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8cb3819bf62527947634ad4d5e44b4b69daecd/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=5e8cb3819bf62527947634ad4d5e44b4b69daecd", "patch": "@@ -170,7 +170,7 @@ impl IsaacRng {\n         const MIDPOINT: usize = RAND_SIZE_USIZE / 2;\n \n         macro_rules! ind {\n-            ($x:expr) => (self.mem[($x >> 2).0 as usize & (RAND_SIZE_USIZE - 1)] )\n+            ($x:expr) => (self.mem[($x >> 2u32).0 as usize & (RAND_SIZE_USIZE - 1)] )\n         }\n \n         let r = [(0, MIDPOINT), (MIDPOINT, 0)];\n@@ -452,7 +452,7 @@ impl Isaac64Rng {\n         const MP_VEC: [(usize, usize); 2] = [(0, MIDPOINT), (MIDPOINT, 0)];\n         macro_rules! ind {\n             ($x:expr) => {\n-                *self.mem.get_unchecked((($x >> 3).0 as usize) & (RAND_SIZE_64 - 1))\n+                *self.mem.get_unchecked((($x >> 3u32).0 as usize) & (RAND_SIZE_64 - 1))\n             }\n         }\n \n@@ -495,10 +495,10 @@ impl Isaac64Rng {\n                     }}\n                 }\n \n-                rngstepp!(0, 21);\n-                rngstepn!(1, 5);\n-                rngstepp!(2, 12);\n-                rngstepn!(3, 33);\n+                rngstepp!(0, 21u32);\n+                rngstepn!(1, 5u32);\n+                rngstepp!(2, 12u32);\n+                rngstepn!(3, 33u32);\n             }\n         }\n "}, {"sha": "228f4cdd1aa377e46182269cba4e7924d774a798", "filename": "src/test/run-pass/num-wrapping.rs", "status": "added", "additions": 412, "deletions": 0, "changes": 412, "blob_url": "https://github.com/rust-lang/rust/blob/5e8cb3819bf62527947634ad4d5e44b4b69daecd/src%2Ftest%2Frun-pass%2Fnum-wrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8cb3819bf62527947634ad4d5e44b4b69daecd/src%2Ftest%2Frun-pass%2Fnum-wrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnum-wrapping.rs?ref=5e8cb3819bf62527947634ad4d5e44b4b69daecd", "patch": "@@ -0,0 +1,412 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// compile-flags: -C debug-assertions\n+//\n+// Test std::num::Wrapping<T> for {uN, iN, usize, isize}\n+\n+#![feature(op_assign_traits, num_bits_bytes, test)]\n+\n+extern crate test;\n+\n+use std::num::Wrapping;\n+use std::ops::{\n+    Add, Sub, Mul, Div, Rem, BitXor, BitOr, BitAnd,\n+    AddAssign, SubAssign, MulAssign, DivAssign, RemAssign, BitXorAssign, BitOrAssign, BitAndAssign,\n+    Shl, Shr, ShlAssign, ShrAssign\n+};\n+use std::{i8, i16, i32, i64, isize, u8, u16, u32, u64, usize};\n+use test::black_box;\n+\n+fn main() {\n+    test_ops();\n+    test_op_assigns();\n+    test_sh_ops();\n+    test_sh_op_assigns();\n+}\n+\n+fn test_ops() {\n+    macro_rules! op_test {\n+        ($op:ident ($lhs:expr, $rhs:expr) == $ans:expr) => {\n+            assert_eq!(black_box(Wrapping($lhs).$op(Wrapping($rhs))), Wrapping($ans));\n+            // FIXME(30524): uncomment this test when it's implemented\n+            // assert_eq!(black_box(Wrapping($lhs).$op($rhs)), Wrapping($ans));\n+        }\n+    }\n+\n+    op_test!(add(i8::MAX, 1) == i8::MIN);\n+    op_test!(add(i16::MAX, 1) == i16::MIN);\n+    op_test!(add(i32::MAX, 1) == i32::MIN);\n+    op_test!(add(i64::MAX, 1) == i64::MIN);\n+    op_test!(add(isize::MAX, 1) == isize::MIN);\n+\n+    op_test!(add(u8::MAX, 1) == 0);\n+    op_test!(add(u16::MAX, 1) == 0);\n+    op_test!(add(u32::MAX, 1) == 0);\n+    op_test!(add(u64::MAX, 1) == 0);\n+    op_test!(add(usize::MAX, 1) == 0);\n+\n+\n+    op_test!(sub(i8::MIN, 1) == i8::MAX);\n+    op_test!(sub(i16::MIN, 1) == i16::MAX);\n+    op_test!(sub(i32::MIN, 1) == i32::MAX);\n+    op_test!(sub(i64::MIN, 1) == i64::MAX);\n+    op_test!(sub(isize::MIN, 1) == isize::MAX);\n+\n+    op_test!(sub(0u8, 1) == u8::MAX);\n+    op_test!(sub(0u16, 1) == u16::MAX);\n+    op_test!(sub(0u32, 1) == u32::MAX);\n+    op_test!(sub(0u64, 1) == u64::MAX);\n+    op_test!(sub(0usize, 1) == usize::MAX);\n+\n+\n+    op_test!(mul(i8::MAX, 2) == -2);\n+    op_test!(mul(i16::MAX, 2) == -2);\n+    op_test!(mul(i32::MAX, 2) == -2);\n+    op_test!(mul(i64::MAX, 2) == -2);\n+    op_test!(mul(isize::MAX, 2) == -2);\n+\n+    op_test!(mul(u8::MAX, 2) == u8::MAX - 1);\n+    op_test!(mul(u16::MAX, 2) == u16::MAX - 1);\n+    op_test!(mul(u32::MAX, 2) == u32::MAX - 1);\n+    op_test!(mul(u64::MAX, 2) == u64::MAX - 1);\n+    op_test!(mul(usize::MAX, 2) == usize::MAX - 1);\n+\n+\n+    op_test!(div(i8::MIN, -1) == i8::MIN);\n+    op_test!(div(i16::MIN, -1) == i16::MIN);\n+    op_test!(div(i32::MIN, -1) == i32::MIN);\n+    op_test!(div(i64::MIN, -1) == i64::MIN);\n+    op_test!(div(isize::MIN, -1) == isize::MIN);\n+\n+\n+    op_test!(rem(i8::MIN, -1) == 0);\n+    op_test!(rem(i16::MIN, -1) == 0);\n+    op_test!(rem(i32::MIN, -1) == 0);\n+    op_test!(rem(i64::MIN, -1) == 0);\n+    op_test!(rem(isize::MIN, -1) == 0);\n+\n+    // these are not that interesting, just testing to make sure they are implemented correctly\n+    op_test!(bitxor(0b101010i8, 0b100110) == 0b001100);\n+    op_test!(bitxor(0b101010i16, 0b100110) == 0b001100);\n+    op_test!(bitxor(0b101010i32, 0b100110) == 0b001100);\n+    op_test!(bitxor(0b101010i64, 0b100110) == 0b001100);\n+    op_test!(bitxor(0b101010isize, 0b100110) == 0b001100);\n+\n+    op_test!(bitxor(0b101010u8, 0b100110) == 0b001100);\n+    op_test!(bitxor(0b101010u16, 0b100110) == 0b001100);\n+    op_test!(bitxor(0b101010u32, 0b100110) == 0b001100);\n+    op_test!(bitxor(0b101010u64, 0b100110) == 0b001100);\n+    op_test!(bitxor(0b101010usize, 0b100110) == 0b001100);\n+\n+\n+    op_test!(bitor(0b101010i8, 0b100110) == 0b101110);\n+    op_test!(bitor(0b101010i16, 0b100110) == 0b101110);\n+    op_test!(bitor(0b101010i32, 0b100110) == 0b101110);\n+    op_test!(bitor(0b101010i64, 0b100110) == 0b101110);\n+    op_test!(bitor(0b101010isize, 0b100110) == 0b101110);\n+\n+    op_test!(bitor(0b101010u8, 0b100110) == 0b101110);\n+    op_test!(bitor(0b101010u16, 0b100110) == 0b101110);\n+    op_test!(bitor(0b101010u32, 0b100110) == 0b101110);\n+    op_test!(bitor(0b101010u64, 0b100110) == 0b101110);\n+    op_test!(bitor(0b101010usize, 0b100110) == 0b101110);\n+\n+\n+    op_test!(bitand(0b101010i8, 0b100110) == 0b100010);\n+    op_test!(bitand(0b101010i16, 0b100110) == 0b100010);\n+    op_test!(bitand(0b101010i32, 0b100110) == 0b100010);\n+    op_test!(bitand(0b101010i64, 0b100110) == 0b100010);\n+    op_test!(bitand(0b101010isize, 0b100110) == 0b100010);\n+\n+    op_test!(bitand(0b101010u8, 0b100110) == 0b100010);\n+    op_test!(bitand(0b101010u16, 0b100110) == 0b100010);\n+    op_test!(bitand(0b101010u32, 0b100110) == 0b100010);\n+    op_test!(bitand(0b101010u64, 0b100110) == 0b100010);\n+    op_test!(bitand(0b101010usize, 0b100110) == 0b100010);\n+}\n+\n+fn test_op_assigns() {\n+    macro_rules! op_assign_test {\n+        ($op:ident ($initial:expr, $rhs:expr) == $ans:expr) => {\n+            {\n+                let mut tmp = Wrapping($initial);\n+                tmp = black_box(tmp);\n+                tmp.$op(Wrapping($rhs));\n+                assert_eq!(black_box(tmp), Wrapping($ans));\n+            }\n+            // FIXME(30524): Uncomment this test\n+            /*\n+            {\n+                let mut tmp = Wrapping($initial);\n+                tmp = black_box(tmp);\n+                tmp.$op($rhs);\n+                assert_eq!(black_box(tmp), Wrapping($ans));\n+            }\n+            */\n+        }\n+    }\n+    op_assign_test!(add_assign(i8::MAX, 1) == i8::MIN);\n+    op_assign_test!(add_assign(i16::MAX, 1) == i16::MIN);\n+    op_assign_test!(add_assign(i32::MAX, 1) == i32::MIN);\n+    op_assign_test!(add_assign(i64::MAX, 1) == i64::MIN);\n+    op_assign_test!(add_assign(isize::MAX, 1) == isize::MIN);\n+\n+    op_assign_test!(add_assign(u8::MAX, 1) == u8::MIN);\n+    op_assign_test!(add_assign(u16::MAX, 1) == u16::MIN);\n+    op_assign_test!(add_assign(u32::MAX, 1) == u32::MIN);\n+    op_assign_test!(add_assign(u64::MAX, 1) == u64::MIN);\n+    op_assign_test!(add_assign(usize::MAX, 1) == usize::MIN);\n+\n+\n+    op_assign_test!(sub_assign(i8::MIN, 1) == i8::MAX);\n+    op_assign_test!(sub_assign(i16::MIN, 1) == i16::MAX);\n+    op_assign_test!(sub_assign(i32::MIN, 1) == i32::MAX);\n+    op_assign_test!(sub_assign(i64::MIN, 1) == i64::MAX);\n+    op_assign_test!(sub_assign(isize::MIN, 1) == isize::MAX);\n+\n+    op_assign_test!(sub_assign(u8::MIN, 1) == u8::MAX);\n+    op_assign_test!(sub_assign(u16::MIN, 1) == u16::MAX);\n+    op_assign_test!(sub_assign(u32::MIN, 1) == u32::MAX);\n+    op_assign_test!(sub_assign(u64::MIN, 1) == u64::MAX);\n+    op_assign_test!(sub_assign(usize::MIN, 1) == usize::MAX);\n+\n+\n+    op_assign_test!(mul_assign(i8::MAX, 2) == -2);\n+    op_assign_test!(mul_assign(i16::MAX, 2) == -2);\n+    op_assign_test!(mul_assign(i32::MAX, 2) == -2);\n+    op_assign_test!(mul_assign(i64::MAX, 2) == -2);\n+    op_assign_test!(mul_assign(isize::MAX, 2) == -2);\n+\n+    op_assign_test!(mul_assign(u8::MAX, 2) == u8::MAX - 1);\n+    op_assign_test!(mul_assign(u16::MAX, 2) == u16::MAX - 1);\n+    op_assign_test!(mul_assign(u32::MAX, 2) == u32::MAX - 1);\n+    op_assign_test!(mul_assign(u64::MAX, 2) == u64::MAX - 1);\n+    op_assign_test!(mul_assign(usize::MAX, 2) == usize::MAX - 1);\n+\n+\n+    op_assign_test!(div_assign(i8::MIN, -1) == i8::MIN);\n+    op_assign_test!(div_assign(i16::MIN, -1) == i16::MIN);\n+    op_assign_test!(div_assign(i32::MIN, -1) == i32::MIN);\n+    op_assign_test!(div_assign(i64::MIN, -1) == i64::MIN);\n+    op_assign_test!(div_assign(isize::MIN, -1) == isize::MIN);\n+\n+\n+    op_assign_test!(rem_assign(i8::MIN, -1) == 0);\n+    op_assign_test!(rem_assign(i16::MIN, -1) == 0);\n+    op_assign_test!(rem_assign(i32::MIN, -1) == 0);\n+    op_assign_test!(rem_assign(i64::MIN, -1) == 0);\n+    op_assign_test!(rem_assign(isize::MIN, -1) == 0);\n+\n+\n+    // these are not that interesting, just testing to make sure they are implemented correctly\n+    op_assign_test!(bitxor_assign(0b101010i8, 0b100110) == 0b001100);\n+    op_assign_test!(bitxor_assign(0b101010i16, 0b100110) == 0b001100);\n+    op_assign_test!(bitxor_assign(0b101010i32, 0b100110) == 0b001100);\n+    op_assign_test!(bitxor_assign(0b101010i64, 0b100110) == 0b001100);\n+    op_assign_test!(bitxor_assign(0b101010isize, 0b100110) == 0b001100);\n+\n+    op_assign_test!(bitxor_assign(0b101010u8, 0b100110) == 0b001100);\n+    op_assign_test!(bitxor_assign(0b101010u16, 0b100110) == 0b001100);\n+    op_assign_test!(bitxor_assign(0b101010u32, 0b100110) == 0b001100);\n+    op_assign_test!(bitxor_assign(0b101010u64, 0b100110) == 0b001100);\n+    op_assign_test!(bitxor_assign(0b101010usize, 0b100110) == 0b001100);\n+\n+\n+    op_assign_test!(bitor_assign(0b101010i8, 0b100110) == 0b101110);\n+    op_assign_test!(bitor_assign(0b101010i16, 0b100110) == 0b101110);\n+    op_assign_test!(bitor_assign(0b101010i32, 0b100110) == 0b101110);\n+    op_assign_test!(bitor_assign(0b101010i64, 0b100110) == 0b101110);\n+    op_assign_test!(bitor_assign(0b101010isize, 0b100110) == 0b101110);\n+\n+    op_assign_test!(bitor_assign(0b101010u8, 0b100110) == 0b101110);\n+    op_assign_test!(bitor_assign(0b101010u16, 0b100110) == 0b101110);\n+    op_assign_test!(bitor_assign(0b101010u32, 0b100110) == 0b101110);\n+    op_assign_test!(bitor_assign(0b101010u64, 0b100110) == 0b101110);\n+    op_assign_test!(bitor_assign(0b101010usize, 0b100110) == 0b101110);\n+\n+\n+    op_assign_test!(bitand_assign(0b101010i8, 0b100110) == 0b100010);\n+    op_assign_test!(bitand_assign(0b101010i16, 0b100110) == 0b100010);\n+    op_assign_test!(bitand_assign(0b101010i32, 0b100110) == 0b100010);\n+    op_assign_test!(bitand_assign(0b101010i64, 0b100110) == 0b100010);\n+    op_assign_test!(bitand_assign(0b101010isize, 0b100110) == 0b100010);\n+\n+    op_assign_test!(bitand_assign(0b101010u8, 0b100110) == 0b100010);\n+    op_assign_test!(bitand_assign(0b101010u16, 0b100110) == 0b100010);\n+    op_assign_test!(bitand_assign(0b101010u32, 0b100110) == 0b100010);\n+    op_assign_test!(bitand_assign(0b101010u64, 0b100110) == 0b100010);\n+    op_assign_test!(bitand_assign(0b101010usize, 0b100110) == 0b100010);\n+}\n+\n+fn test_sh_ops() {\n+    macro_rules! sh_test {\n+        ($op:ident ($lhs:expr, $rhs:expr) == $ans:expr) => {\n+            assert_eq!(black_box(Wrapping($lhs).$op($rhs)), Wrapping($ans));\n+        }\n+    }\n+    // NOTE: This will break for i8 if we ever get i/u128\n+    macro_rules! sh_test_all {\n+        ($t:ty) => {\n+            sh_test!(shl(i8::MAX, (i8::BITS + 1) as $t) == -2);\n+            sh_test!(shl(i16::MAX, (i16::BITS + 1) as $t) == -2);\n+            sh_test!(shl(i32::MAX, (i32::BITS + 1) as $t) == -2);\n+            sh_test!(shl(i64::MAX, (i64::BITS + 1) as $t) == -2);\n+            sh_test!(shl(isize::MAX, (isize::BITS + 1) as $t) == -2);\n+\n+            sh_test!(shl(u8::MAX, (u8::BITS + 1) as $t) == u8::MAX - 1);\n+            sh_test!(shl(u16::MAX, (u16::BITS + 1) as $t) == u16::MAX - 1);\n+            sh_test!(shl(u32::MAX, (u32::BITS + 1) as $t) == u32::MAX - 1);\n+            sh_test!(shl(u64::MAX, (u64::BITS + 1) as $t) == u64::MAX - 1);\n+            sh_test!(shl(usize::MAX, (usize::BITS + 1) as $t) == usize::MAX - 1);\n+\n+\n+            sh_test!(shr(i8::MAX, (i8::BITS + 1) as $t) == i8::MAX / 2);\n+            sh_test!(shr(i16::MAX, (i16::BITS + 1) as $t) == i16::MAX / 2);\n+            sh_test!(shr(i32::MAX, (i32::BITS + 1) as $t) == i32::MAX / 2);\n+            sh_test!(shr(i64::MAX, (i64::BITS + 1) as $t) == i64::MAX / 2);\n+            sh_test!(shr(isize::MAX, (isize::BITS + 1) as $t) == isize::MAX / 2);\n+\n+            sh_test!(shr(u8::MAX, (u8::BITS + 1) as $t) == u8::MAX / 2);\n+            sh_test!(shr(u16::MAX, (u16::BITS + 1) as $t) == u16::MAX / 2);\n+            sh_test!(shr(u32::MAX, (u32::BITS + 1) as $t) == u32::MAX / 2);\n+            sh_test!(shr(u64::MAX, (u64::BITS + 1) as $t) == u64::MAX / 2);\n+            sh_test!(shr(usize::MAX, (usize::BITS + 1) as $t) == usize::MAX / 2);\n+        }\n+    }\n+    macro_rules! sh_test_negative_all {\n+        ($t:ty) => {\n+            sh_test!(shr(i8::MAX, -((i8::BITS + 1) as $t)) == -2);\n+            sh_test!(shr(i16::MAX, -((i16::BITS + 1) as $t)) == -2);\n+            sh_test!(shr(i32::MAX, -((i32::BITS + 1) as $t)) == -2);\n+            sh_test!(shr(i64::MAX, -((i64::BITS + 1) as $t)) == -2);\n+            sh_test!(shr(isize::MAX, -((isize::BITS + 1) as $t)) == -2);\n+\n+            sh_test!(shr(u8::MAX, -((u8::BITS + 1) as $t)) == u8::MAX - 1);\n+            sh_test!(shr(u16::MAX, -((u16::BITS + 1) as $t)) == u16::MAX - 1);\n+            sh_test!(shr(u32::MAX, -((u32::BITS + 1) as $t)) == u32::MAX - 1);\n+            sh_test!(shr(u64::MAX, -((u64::BITS + 1) as $t)) == u64::MAX - 1);\n+            sh_test!(shr(usize::MAX, -((usize::BITS + 1) as $t)) == usize::MAX - 1);\n+\n+\n+            sh_test!(shl(i8::MAX, -((i8::BITS + 1) as $t)) == i8::MAX / 2);\n+            sh_test!(shl(i16::MAX, -((i16::BITS + 1) as $t)) == i16::MAX / 2);\n+            sh_test!(shl(i32::MAX, -((i32::BITS + 1) as $t)) == i32::MAX / 2);\n+            sh_test!(shl(i64::MAX, -((i64::BITS + 1) as $t)) == i64::MAX / 2);\n+            sh_test!(shl(isize::MAX, -((isize::BITS + 1) as $t)) == isize::MAX / 2);\n+\n+            sh_test!(shl(u8::MAX, -((u8::BITS + 1) as $t)) == u8::MAX / 2);\n+            sh_test!(shl(u16::MAX, -((u16::BITS + 1) as $t)) == u16::MAX / 2);\n+            sh_test!(shl(u32::MAX, -((u32::BITS + 1) as $t)) == u32::MAX / 2);\n+            sh_test!(shl(u64::MAX, -((u64::BITS + 1) as $t)) == u64::MAX / 2);\n+            sh_test!(shl(usize::MAX, -((usize::BITS + 1) as $t)) == usize::MAX / 2);\n+        }\n+    }\n+    sh_test_all!(i8);\n+    sh_test_all!(u8);\n+    sh_test_all!(i16);\n+    sh_test_all!(u16);\n+    sh_test_all!(i32);\n+    sh_test_all!(u32);\n+    sh_test_all!(i64);\n+    sh_test_all!(u64);\n+    sh_test_all!(isize);\n+    sh_test_all!(usize);\n+\n+    sh_test_negative_all!(i8);\n+    sh_test_negative_all!(i16);\n+    sh_test_negative_all!(i32);\n+    sh_test_negative_all!(i64);\n+    sh_test_negative_all!(isize);\n+}\n+\n+fn test_sh_op_assigns() {\n+    macro_rules! sh_assign_test {\n+        ($op:ident ($initial:expr, $rhs:expr) == $ans:expr) => {{\n+            let mut tmp = Wrapping($initial);\n+            tmp = black_box(tmp);\n+            tmp.$op($rhs);\n+            assert_eq!(black_box(tmp), Wrapping($ans));\n+        }}\n+    }\n+    macro_rules! sh_assign_test_all {\n+        ($t:ty) => {\n+            sh_assign_test!(shl_assign(i8::MAX, (i8::BITS + 1) as $t) == -2);\n+            sh_assign_test!(shl_assign(i16::MAX, (i16::BITS + 1) as $t) == -2);\n+            sh_assign_test!(shl_assign(i32::MAX, (i32::BITS + 1) as $t) == -2);\n+            sh_assign_test!(shl_assign(i64::MAX, (i64::BITS + 1) as $t) == -2);\n+            sh_assign_test!(shl_assign(isize::MAX, (isize::BITS + 1) as $t) == -2);\n+\n+            sh_assign_test!(shl_assign(u8::MAX, (u8::BITS + 1) as $t) == u8::MAX - 1);\n+            sh_assign_test!(shl_assign(u16::MAX, (u16::BITS + 1) as $t) == u16::MAX - 1);\n+            sh_assign_test!(shl_assign(u32::MAX, (u32::BITS + 1) as $t) == u32::MAX - 1);\n+            sh_assign_test!(shl_assign(u64::MAX, (u64::BITS + 1) as $t) == u64::MAX - 1);\n+            sh_assign_test!(shl_assign(usize::MAX, (usize::BITS + 1) as $t) == usize::MAX - 1);\n+\n+\n+            sh_assign_test!(shr_assign(i8::MAX, (i8::BITS + 1) as $t) == i8::MAX / 2);\n+            sh_assign_test!(shr_assign(i16::MAX, (i16::BITS + 1) as $t) == i16::MAX / 2);\n+            sh_assign_test!(shr_assign(i32::MAX, (i32::BITS + 1) as $t) == i32::MAX / 2);\n+            sh_assign_test!(shr_assign(i64::MAX, (i64::BITS + 1) as $t) == i64::MAX / 2);\n+            sh_assign_test!(shr_assign(isize::MAX, (isize::BITS + 1) as $t) == isize::MAX / 2);\n+\n+            sh_assign_test!(shr_assign(u8::MAX, (u8::BITS + 1) as $t) == u8::MAX / 2);\n+            sh_assign_test!(shr_assign(u16::MAX, (u16::BITS + 1) as $t) == u16::MAX / 2);\n+            sh_assign_test!(shr_assign(u32::MAX, (u32::BITS + 1) as $t) == u32::MAX / 2);\n+            sh_assign_test!(shr_assign(u64::MAX, (u64::BITS + 1) as $t) == u64::MAX / 2);\n+            sh_assign_test!(shr_assign(usize::MAX, (usize::BITS + 1) as $t) == usize::MAX / 2);\n+        }\n+    }\n+    macro_rules! sh_assign_test_negative_all {\n+        ($t:ty) => {\n+            sh_assign_test!(shr_assign(i8::MAX, -((i8::BITS + 1) as $t)) == -2);\n+            sh_assign_test!(shr_assign(i16::MAX, -((i16::BITS + 1) as $t)) == -2);\n+            sh_assign_test!(shr_assign(i32::MAX, -((i32::BITS + 1) as $t)) == -2);\n+            sh_assign_test!(shr_assign(i64::MAX, -((i64::BITS + 1) as $t)) == -2);\n+            sh_assign_test!(shr_assign(isize::MAX, -((isize::BITS + 1) as $t)) == -2);\n+\n+            sh_assign_test!(shr_assign(u8::MAX, -((u8::BITS + 1) as $t)) == u8::MAX - 1);\n+            sh_assign_test!(shr_assign(u16::MAX, -((u16::BITS + 1) as $t)) == u16::MAX - 1);\n+            sh_assign_test!(shr_assign(u32::MAX, -((u32::BITS + 1) as $t)) == u32::MAX - 1);\n+            sh_assign_test!(shr_assign(u64::MAX, -((u64::BITS + 1) as $t)) == u64::MAX - 1);\n+            sh_assign_test!(shr_assign(usize::MAX, -((usize::BITS + 1) as $t)) == usize::MAX - 1);\n+\n+\n+            sh_assign_test!(shl_assign(i8::MAX, -((i8::BITS + 1) as $t)) == i8::MAX / 2);\n+            sh_assign_test!(shl_assign(i16::MAX, -((i16::BITS + 1) as $t)) == i16::MAX / 2);\n+            sh_assign_test!(shl_assign(i32::MAX, -((i32::BITS + 1) as $t)) == i32::MAX / 2);\n+            sh_assign_test!(shl_assign(i64::MAX, -((i64::BITS + 1) as $t)) == i64::MAX / 2);\n+            sh_assign_test!(shl_assign(isize::MAX, -((isize::BITS + 1) as $t)) == isize::MAX / 2);\n+\n+            sh_assign_test!(shl_assign(u8::MAX, -((u8::BITS + 1) as $t)) == u8::MAX / 2);\n+            sh_assign_test!(shl_assign(u16::MAX, -((u16::BITS + 1) as $t)) == u16::MAX / 2);\n+            sh_assign_test!(shl_assign(u32::MAX, -((u32::BITS + 1) as $t)) == u32::MAX / 2);\n+            sh_assign_test!(shl_assign(u64::MAX, -((u64::BITS + 1) as $t)) == u64::MAX / 2);\n+            sh_assign_test!(shl_assign(usize::MAX, -((usize::BITS + 1) as $t)) == usize::MAX / 2);\n+        }\n+    }\n+\n+    sh_assign_test_all!(i8);\n+    sh_assign_test_all!(u8);\n+    sh_assign_test_all!(i16);\n+    sh_assign_test_all!(u16);\n+    sh_assign_test_all!(i32);\n+    sh_assign_test_all!(u32);\n+    sh_assign_test_all!(i64);\n+    sh_assign_test_all!(u64);\n+    sh_assign_test_all!(isize);\n+    sh_assign_test_all!(usize);\n+\n+    sh_assign_test_negative_all!(i8);\n+    sh_assign_test_negative_all!(i16);\n+    sh_assign_test_negative_all!(i32);\n+    sh_assign_test_negative_all!(i64);\n+    sh_assign_test_negative_all!(isize);\n+}"}]}