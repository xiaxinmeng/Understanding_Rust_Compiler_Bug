{"sha": "9a99f5bbe26da8174c6eddc086274486eeabcb29", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhOTlmNWJiZTI2ZGE4MTc0YzZlZGRjMDg2Mjc0NDg2ZWVhYmNiMjk=", "commit": {"author": {"name": "Steven Stewart-Gallus", "email": "sstewartgallus00@mylangara.bc.ca", "date": "2013-07-18T03:04:37Z"}, "committer": {"name": "Steven Stewart-Gallus", "email": "sstewartgallus00@mylangara.bc.ca", "date": "2013-07-22T03:13:25Z"}, "message": "Cleanup libsyntax a bit", "tree": {"sha": "706625b1f215866baeb528299515daf599e0e400", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/706625b1f215866baeb528299515daf599e0e400"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a99f5bbe26da8174c6eddc086274486eeabcb29", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a99f5bbe26da8174c6eddc086274486eeabcb29", "html_url": "https://github.com/rust-lang/rust/commit/9a99f5bbe26da8174c6eddc086274486eeabcb29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a99f5bbe26da8174c6eddc086274486eeabcb29/comments", "author": {"login": "mstewartgallus", "id": 4070335, "node_id": "MDQ6VXNlcjQwNzAzMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4070335?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mstewartgallus", "html_url": "https://github.com/mstewartgallus", "followers_url": "https://api.github.com/users/mstewartgallus/followers", "following_url": "https://api.github.com/users/mstewartgallus/following{/other_user}", "gists_url": "https://api.github.com/users/mstewartgallus/gists{/gist_id}", "starred_url": "https://api.github.com/users/mstewartgallus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mstewartgallus/subscriptions", "organizations_url": "https://api.github.com/users/mstewartgallus/orgs", "repos_url": "https://api.github.com/users/mstewartgallus/repos", "events_url": "https://api.github.com/users/mstewartgallus/events{/privacy}", "received_events_url": "https://api.github.com/users/mstewartgallus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mstewartgallus", "id": 4070335, "node_id": "MDQ6VXNlcjQwNzAzMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4070335?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mstewartgallus", "html_url": "https://github.com/mstewartgallus", "followers_url": "https://api.github.com/users/mstewartgallus/followers", "following_url": "https://api.github.com/users/mstewartgallus/following{/other_user}", "gists_url": "https://api.github.com/users/mstewartgallus/gists{/gist_id}", "starred_url": "https://api.github.com/users/mstewartgallus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mstewartgallus/subscriptions", "organizations_url": "https://api.github.com/users/mstewartgallus/orgs", "repos_url": "https://api.github.com/users/mstewartgallus/repos", "events_url": "https://api.github.com/users/mstewartgallus/events{/privacy}", "received_events_url": "https://api.github.com/users/mstewartgallus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc058191818e4440d36e5ed4ef61bc0a9711be11", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc058191818e4440d36e5ed4ef61bc0a9711be11", "html_url": "https://github.com/rust-lang/rust/commit/fc058191818e4440d36e5ed4ef61bc0a9711be11"}], "stats": {"total": 200, "additions": 100, "deletions": 100}, "files": [{"sha": "7c801cd6135e637e0e4fdbad2954a19b57ca2549", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 100, "deletions": 100, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/9a99f5bbe26da8174c6eddc086274486eeabcb29/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a99f5bbe26da8174c6eddc086274486eeabcb29/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9a99f5bbe26da8174c6eddc086274486eeabcb29", "patch": "@@ -406,7 +406,9 @@ impl Parser {\n     // consume token 'tok' if it exists. Returns true if the given\n     // token was present, false otherwise.\n     pub fn eat(&self, tok: &token::Token) -> bool {\n-        return if *self.token == *tok { self.bump(); true } else { false };\n+        let is_present = *self.token == *tok;\n+        if is_present { self.bump() }\n+        is_present\n     }\n \n     pub fn is_keyword(&self, kw: keywords::Keyword) -> bool {\n@@ -458,21 +460,16 @@ impl Parser {\n     // with a single > and continue. If a GT is not seen,\n     // signal an error.\n     pub fn expect_gt(&self) {\n-        if *self.token == token::GT {\n-            self.bump();\n-        } else if *self.token == token::BINOP(token::SHR) {\n-            self.replace_token(\n+        match *self.token {\n+            token::GT => self.bump(),\n+            token::BINOP(token::SHR) => self.replace_token(\n                 token::GT,\n                 self.span.lo + BytePos(1u),\n                 self.span.hi\n-            );\n-        } else {\n-            let mut s: ~str = ~\"expected `\";\n-            s.push_str(self.token_to_str(&token::GT));\n-            s.push_str(\"`, found `\");\n-            s.push_str(self.this_token_to_str());\n-            s.push_str(\"`\");\n-            self.fatal(s);\n+            ),\n+            _ => self.fatal(fmt!(\"expected `%s`, found `%s`\",\n+                                 self.token_to_str(&token::GT),\n+                                 self.this_token_to_str()))\n         }\n     }\n \n@@ -1114,19 +1111,20 @@ impl Parser {\n     }\n \n     pub fn is_named_argument(&self) -> bool {\n-        let offset = if *self.token == token::BINOP(token::AND) {\n-            1\n-        } else if *self.token == token::BINOP(token::MINUS) {\n-            1\n-        } else if *self.token == token::ANDAND {\n-            1\n-        } else if *self.token == token::BINOP(token::PLUS) {\n-            if self.look_ahead(1, |t| *t == token::BINOP(token::PLUS)) {\n-                2\n-            } else {\n-                1\n-            }\n-        } else { 0 };\n+        let offset = match *self.token {\n+            token::BINOP(token::AND) => 1,\n+            token::BINOP(token::MINUS) => 1,\n+            token::ANDAND => 1,\n+            token::BINOP(token::PLUS) => {\n+                if self.look_ahead(1, |t| *t == token::BINOP(token::PLUS)) {\n+                    2\n+                } else {\n+                    1\n+                }\n+            },\n+            _ => 0\n+        };\n+\n         if offset == 0 {\n             is_plain_ident(&*self.token)\n                 && self.look_ahead(1, |t| *t == token::COLON)\n@@ -1868,21 +1866,26 @@ impl Parser {\n     // parse an optional separator followed by a kleene-style\n     // repetition token (+ or *).\n     pub fn parse_sep_and_zerok(&self) -> (Option<token::Token>, bool) {\n-        if *self.token == token::BINOP(token::STAR)\n-            || *self.token == token::BINOP(token::PLUS) {\n-            let zerok = *self.token == token::BINOP(token::STAR);\n-            self.bump();\n-            (None, zerok)\n-        } else {\n-            let sep = self.bump_and_get();\n-            if *self.token == token::BINOP(token::STAR)\n-                || *self.token == token::BINOP(token::PLUS) {\n-                let zerok = *self.token == token::BINOP(token::STAR);\n-                self.bump();\n-                (Some(sep), zerok)\n-            } else {\n-                self.fatal(\"expected `*` or `+`\");\n+        fn parse_zerok(parser: &Parser) -> Option<bool> {\n+            match *parser.token {\n+                token::BINOP(token::STAR) | token::BINOP(token::PLUS) => {\n+                    let zerok = *parser.token == token::BINOP(token::STAR);\n+                    parser.bump();\n+                    Some(zerok)\n+                },\n+                _ => None\n             }\n+        };\n+\n+        match parse_zerok(self) {\n+            Some(zerok) => return (None, zerok),\n+            None => {}\n+        }\n+\n+        let separator = self.bump_and_get();\n+        match parse_zerok(self) {\n+            Some(zerok) => (Some(separator), zerok),\n+            None => self.fatal(\"expected `*` or `+`\")\n         }\n     }\n \n@@ -2144,39 +2147,45 @@ impl Parser {\n     // parse an expression of binops of at least min_prec precedence\n     pub fn parse_more_binops(&self, lhs: @expr, min_prec: uint) -> @expr {\n         if self.expr_is_complete(lhs) { return lhs; }\n-        if token::BINOP(token::OR) == *self.token &&\n-            (*self.restriction == RESTRICT_NO_BAR_OP ||\n-             *self.restriction == RESTRICT_NO_BAR_OR_DOUBLEBAR_OP) {\n-            lhs\n-        } else if token::OROR == *self.token &&\n-            *self.restriction == RESTRICT_NO_BAR_OR_DOUBLEBAR_OP {\n-            lhs\n-        } else {\n-            let cur_opt = token_to_binop(self.token);\n-            match cur_opt {\n-                Some(cur_op) => {\n-                    let cur_prec = operator_prec(cur_op);\n-                    if cur_prec > min_prec {\n-                        self.bump();\n-                        let expr = self.parse_prefix_expr();\n-                        let rhs = self.parse_more_binops(expr, cur_prec);\n-                        let bin = self.mk_expr(lhs.span.lo, rhs.span.hi,\n-                                               self.mk_binary(cur_op, lhs, rhs));\n-                        self.parse_more_binops(bin, min_prec)\n-                    } else {\n-                        lhs\n-                    }\n+\n+        // Prevent dynamic borrow errors later on by limiting the\n+        // scope of the borrows.\n+        {\n+            let token: &token::Token = self.token;\n+            let restriction: &restriction = self.restriction;\n+            match (token, restriction) {\n+                (&token::BINOP(token::OR), &RESTRICT_NO_BAR_OP) => return lhs,\n+                (&token::BINOP(token::OR),\n+                 &RESTRICT_NO_BAR_OR_DOUBLEBAR_OP) => return lhs,\n+                (&token::OROR, &RESTRICT_NO_BAR_OR_DOUBLEBAR_OP) => return lhs,\n+                _ => { }\n+            }\n+        }\n+\n+        let cur_opt = token_to_binop(self.token);\n+        match cur_opt {\n+            Some(cur_op) => {\n+                let cur_prec = operator_prec(cur_op);\n+                if cur_prec > min_prec {\n+                    self.bump();\n+                    let expr = self.parse_prefix_expr();\n+                    let rhs = self.parse_more_binops(expr, cur_prec);\n+                    let bin = self.mk_expr(lhs.span.lo, rhs.span.hi,\n+                                           self.mk_binary(cur_op, lhs, rhs));\n+                    self.parse_more_binops(bin, min_prec)\n+                } else {\n+                    lhs\n                 }\n-                None => {\n-                    if as_prec > min_prec && self.eat_keyword(keywords::As) {\n-                        let rhs = self.parse_ty(true);\n-                        let _as = self.mk_expr(lhs.span.lo,\n-                                               rhs.span.hi,\n-                                               expr_cast(lhs, rhs));\n-                        self.parse_more_binops(_as, min_prec)\n-                    } else {\n-                        lhs\n-                    }\n+            }\n+            None => {\n+                if as_prec > min_prec && self.eat_keyword(keywords::As) {\n+                    let rhs = self.parse_ty(true);\n+                    let _as = self.mk_expr(lhs.span.lo,\n+                                           rhs.span.hi,\n+                                           expr_cast(lhs, rhs));\n+                    self.parse_more_binops(_as, min_prec)\n+                } else {\n+                    lhs\n                 }\n             }\n         }\n@@ -2197,19 +2206,18 @@ impl Parser {\n           token::BINOPEQ(op) => {\n               self.bump();\n               let rhs = self.parse_expr();\n-              let aop;\n-              match op {\n-                  token::PLUS => aop = add,\n-                  token::MINUS => aop = subtract,\n-                  token::STAR => aop = mul,\n-                  token::SLASH => aop = div,\n-                  token::PERCENT => aop = rem,\n-                  token::CARET => aop = bitxor,\n-                  token::AND => aop = bitand,\n-                  token::OR => aop = bitor,\n-                  token::SHL => aop = shl,\n-                  token::SHR => aop = shr\n-              }\n+              let aop = match op {\n+                  token::PLUS =>    add,\n+                  token::MINUS =>   subtract,\n+                  token::STAR =>    mul,\n+                  token::SLASH =>   div,\n+                  token::PERCENT => rem,\n+                  token::CARET =>   bitxor,\n+                  token::AND =>     bitand,\n+                  token::OR =>      bitor,\n+                  token::SHL =>     shl,\n+                  token::SHR =>     shr\n+              };\n               self.mk_expr(lo, rhs.span.hi,\n                            self.mk_assign_op(aop, lhs, rhs))\n           }\n@@ -2758,6 +2766,7 @@ impl Parser {\n             self.bump();\n             let (before, slice, after) =\n                 self.parse_pat_vec_elements();\n+\n             self.expect(&token::RBRACKET);\n             pat = ast::pat_vec(before, slice, after);\n             hi = self.last_span.hi;\n@@ -3349,19 +3358,15 @@ impl Parser {\n     }\n \n     // parse a generic use site\n-    fn parse_generic_values(\n-        &self) -> (OptVec<ast::Lifetime>, ~[Ty])\n-    {\n+    fn parse_generic_values(&self) -> (OptVec<ast::Lifetime>, ~[Ty]) {\n         if !self.eat(&token::LT) {\n             (opt_vec::Empty, ~[])\n         } else {\n             self.parse_generic_values_after_lt()\n         }\n     }\n \n-    fn parse_generic_values_after_lt(\n-        &self) -> (OptVec<ast::Lifetime>, ~[Ty])\n-    {\n+    fn parse_generic_values_after_lt(&self) -> (OptVec<ast::Lifetime>, ~[Ty]) {\n         let lifetimes = self.parse_lifetimes();\n         let result = self.parse_seq_to_gt(\n             Some(token::COMMA),\n@@ -3390,11 +3395,7 @@ impl Parser {\n     }\n \n     fn is_self_ident(&self) -> bool {\n-        match *self.token {\n-          token::IDENT(id, false) if id == special_idents::self_\n-            => true,\n-          _ => false\n-        }\n+        *self.token == token::IDENT(special_idents::self_, false)\n     }\n \n     fn expect_self_ident(&self) {\n@@ -4649,14 +4650,12 @@ impl Parser {\n \n     pub fn parse_item(&self, attrs: ~[Attribute]) -> Option<@ast::item> {\n         match self.parse_item_or_view_item(attrs, true) {\n-            iovi_none(_) =>\n-                None,\n+            iovi_none(_) => None,\n             iovi_view_item(_) =>\n                 self.fatal(\"view items are not allowed here\"),\n             iovi_foreign_item(_) =>\n                 self.fatal(\"foreign items are not allowed here\"),\n-            iovi_item(item) =>\n-                Some(item)\n+            iovi_item(item) => Some(item)\n         }\n     }\n \n@@ -4819,6 +4818,7 @@ impl Parser {\n         // First, parse view items.\n         let mut view_items : ~[ast::view_item] = ~[];\n         let mut items = ~[];\n+\n         // I think this code would probably read better as a single\n         // loop with a mutable three-state-variable (for extern mods,\n         // view items, and regular items) ... except that because"}]}