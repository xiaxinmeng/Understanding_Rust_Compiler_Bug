{"sha": "96ae0ee382a32d8218da454dc4fd2b2a6fa37c4a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2YWUwZWUzODJhMzJkODIxOGRhNDU0ZGM0ZmQyYjJhNmZhMzdjNGE=", "commit": {"author": {"name": "bobtwinkles", "email": "srkoser+GitHub@gmail.com", "date": "2018-03-28T03:48:50Z"}, "committer": {"name": "bobtwinkles", "email": "srkoser+GitHub@gmail.com", "date": "2018-03-28T03:48:50Z"}, "message": "Use a new type to track if two-phase borrows are allowed\n\nBecause more type safe is more better, and random boolean parameters everywhere\nwere not the greatest thing.", "tree": {"sha": "fd434ddb84ab134238d9c50faac72197a4034f82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd434ddb84ab134238d9c50faac72197a4034f82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96ae0ee382a32d8218da454dc4fd2b2a6fa37c4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96ae0ee382a32d8218da454dc4fd2b2a6fa37c4a", "html_url": "https://github.com/rust-lang/rust/commit/96ae0ee382a32d8218da454dc4fd2b2a6fa37c4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96ae0ee382a32d8218da454dc4fd2b2a6fa37c4a/comments", "author": {"login": "bobtwinkles", "id": 1514748, "node_id": "MDQ6VXNlcjE1MTQ3NDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1514748?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobtwinkles", "html_url": "https://github.com/bobtwinkles", "followers_url": "https://api.github.com/users/bobtwinkles/followers", "following_url": "https://api.github.com/users/bobtwinkles/following{/other_user}", "gists_url": "https://api.github.com/users/bobtwinkles/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobtwinkles/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobtwinkles/subscriptions", "organizations_url": "https://api.github.com/users/bobtwinkles/orgs", "repos_url": "https://api.github.com/users/bobtwinkles/repos", "events_url": "https://api.github.com/users/bobtwinkles/events{/privacy}", "received_events_url": "https://api.github.com/users/bobtwinkles/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bobtwinkles", "id": 1514748, "node_id": "MDQ6VXNlcjE1MTQ3NDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1514748?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobtwinkles", "html_url": "https://github.com/bobtwinkles", "followers_url": "https://api.github.com/users/bobtwinkles/followers", "following_url": "https://api.github.com/users/bobtwinkles/following{/other_user}", "gists_url": "https://api.github.com/users/bobtwinkles/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobtwinkles/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobtwinkles/subscriptions", "organizations_url": "https://api.github.com/users/bobtwinkles/orgs", "repos_url": "https://api.github.com/users/bobtwinkles/repos", "events_url": "https://api.github.com/users/bobtwinkles/events{/privacy}", "received_events_url": "https://api.github.com/users/bobtwinkles/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d37a7ab32b4f4f1a0b944abaa3ca104978aecb12", "url": "https://api.github.com/repos/rust-lang/rust/commits/d37a7ab32b4f4f1a0b944abaa3ca104978aecb12", "html_url": "https://github.com/rust-lang/rust/commit/d37a7ab32b4f4f1a0b944abaa3ca104978aecb12"}], "stats": {"total": 57, "additions": 41, "deletions": 16}, "files": [{"sha": "edd6d56759d94da65412c98d106761609dab1ad5", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/96ae0ee382a32d8218da454dc4fd2b2a6fa37c4a/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96ae0ee382a32d8218da454dc4fd2b2a6fa37c4a/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=96ae0ee382a32d8218da454dc4fd2b2a6fa37c4a", "patch": "@@ -119,6 +119,23 @@ impl<'a, 'gcx, 'tcx> OverloadedDeref<'tcx> {\n     }\n }\n \n+/// At least for initial deployment, we want to limit two-phase borrows to\n+/// only a few specific cases. Right now, those mostly \"things that desugar\"\n+/// into method calls\n+///     - using x.some_method() syntax, where some_method takes &mut self\n+///     - using Foo::some_method(&mut x, ...) syntax\n+///     - binary assignment operators (+=, -=, *=, etc.)\n+/// Anything else should be rejected until generalized two phase borrow support\n+/// is implemented. Right now, dataflow can't handle the general case where there\n+/// is more than one use of a mutable borrow, and we don't want to accept too much\n+/// new code via two-phase borrows, so we try to limit where we create two-phase\n+/// capable mutable borrows.\n+/// See #49434 for tracking.\n+pub enum AllowTwoPhase {\n+    Yes,\n+    No\n+}\n+\n #[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n pub enum AutoBorrowMutability {\n     Mutable { allow_two_phase_borrow: bool },"}, {"sha": "8db8e52b10d4ab4dc048f64e6bb356663163673d", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/96ae0ee382a32d8218da454dc4fd2b2a6fa37c4a/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96ae0ee382a32d8218da454dc4fd2b2a6fa37c4a/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=96ae0ee382a32d8218da454dc4fd2b2a6fa37c4a", "patch": "@@ -47,6 +47,7 @@ use rustc::hir;\n use rustc::session::Session;\n use rustc::traits;\n use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::adjustment::AllowTwoPhase;\n use rustc::ty::cast::{CastKind, CastTy};\n use rustc::ty::subst::Substs;\n use rustc::middle::lang_items;\n@@ -435,7 +436,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                     let res = fcx.try_coerce(self.expr,\n                                              self.expr_ty,\n                                              fcx.tcx.mk_fn_ptr(f),\n-                                             false);\n+                                             AllowTwoPhase::No);\n                     if !res.is_ok() {\n                         return Err(CastError::NonScalar);\n                     }\n@@ -617,7 +618,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n     }\n \n     fn try_coercion_cast(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> bool {\n-        fcx.try_coerce(self.expr, self.expr_ty, self.cast_ty, false).is_ok()\n+        fcx.try_coerce(self.expr, self.expr_ty, self.cast_ty, AllowTwoPhase::No).is_ok()\n     }\n }\n "}, {"sha": "8b4b4bab7c41095f271b84d272810dfd29cbbd63", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/96ae0ee382a32d8218da454dc4fd2b2a6fa37c4a/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96ae0ee382a32d8218da454dc4fd2b2a6fa37c4a/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=96ae0ee382a32d8218da454dc4fd2b2a6fa37c4a", "patch": "@@ -67,7 +67,7 @@ use rustc::hir::def_id::DefId;\n use rustc::infer::{Coercion, InferResult, InferOk};\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n-use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, AutoBorrowMutability};\n+use rustc::ty::adjustment::{Adjustment, Adjust, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::{self, TypeAndMut, Ty, ClosureSubsts};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::error::TypeError;\n@@ -89,7 +89,8 @@ struct Coerce<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     /// allow deref coercions to create two-phase borrows, at least initially,\n     /// but we do need two-phase borrows for function argument reborrows.\n     /// See #47489 and #48598\n-    allow_two_phase: bool,\n+    /// See docs on the \"AllowTwoPhase\" type for a more detailed discussion\n+    allow_two_phase: AllowTwoPhase,\n }\n \n impl<'a, 'gcx, 'tcx> Deref for Coerce<'a, 'gcx, 'tcx> {\n@@ -131,7 +132,7 @@ fn success<'tcx>(adj: Vec<Adjustment<'tcx>>,\n impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n     fn new(fcx: &'f FnCtxt<'f, 'gcx, 'tcx>,\n            cause: ObligationCause<'tcx>,\n-           allow_two_phase: bool) -> Self {\n+           allow_two_phase: AllowTwoPhase) -> Self {\n         Coerce {\n             fcx,\n             cause,\n@@ -433,7 +434,10 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         let mutbl = match mt_b.mutbl {\n             hir::MutImmutable => AutoBorrowMutability::Immutable,\n             hir::MutMutable => AutoBorrowMutability::Mutable {\n-                allow_two_phase_borrow: self.allow_two_phase,\n+                allow_two_phase_borrow: match self.allow_two_phase {\n+                    AllowTwoPhase::Yes => true,\n+                    AllowTwoPhase::No => false\n+                },\n             }\n         };\n         adjustments.push(Adjustment {\n@@ -761,7 +765,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                       expr: &hir::Expr,\n                       expr_ty: Ty<'tcx>,\n                       target: Ty<'tcx>,\n-                      allow_two_phase: bool)\n+                      allow_two_phase: AllowTwoPhase)\n                       -> RelateResult<'tcx, Ty<'tcx>> {\n         let source = self.resolve_type_vars_with_obligations(expr_ty);\n         debug!(\"coercion::try({:?}: {:?} -> {:?})\", expr, source, target);\n@@ -782,7 +786,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let cause = self.cause(syntax_pos::DUMMY_SP, ObligationCauseCode::ExprAssignable);\n         // We don't ever need two-phase here since we throw out the result of the coercion\n-        let coerce = Coerce::new(self, cause, false);\n+        let coerce = Coerce::new(self, cause, AllowTwoPhase::No);\n         self.probe(|_| coerce.coerce(source, target)).is_ok()\n     }\n \n@@ -856,7 +860,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // probably aren't processing function arguments here and even if we were,\n         // they're going to get autorefed again anyway and we can apply 2-phase borrows\n         // at that time.\n-        let mut coerce = Coerce::new(self, cause.clone(), false);\n+        let mut coerce = Coerce::new(self, cause.clone(), AllowTwoPhase::No);\n         coerce.use_lub = true;\n \n         // First try to coerce the new expression to the type of the previous ones,\n@@ -1123,7 +1127,7 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                 // Special-case the first expression we are coercing.\n                 // To be honest, I'm not entirely sure why we do this.\n                 // We don't allow two-phase borrows, see comment in try_find_coercion_lub for why\n-                fcx.try_coerce(expression, expression_ty, self.expected_ty, false)\n+                fcx.try_coerce(expression, expression_ty, self.expected_ty, AllowTwoPhase::No)\n             } else {\n                 match self.expressions {\n                     Expressions::Dynamic(ref exprs) =>"}, {"sha": "36445e7100150777fbfee25d466f4115b9c3aa07", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/96ae0ee382a32d8218da454dc4fd2b2a6fa37c4a/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96ae0ee382a32d8218da454dc4fd2b2a6fa37c4a/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=96ae0ee382a32d8218da454dc4fd2b2a6fa37c4a", "patch": "@@ -21,6 +21,7 @@ use rustc::hir;\n use rustc::hir::print;\n use rustc::hir::def::Def;\n use rustc::ty::{self, Ty, AssociatedItem};\n+use rustc::ty::adjustment::AllowTwoPhase;\n use errors::{DiagnosticBuilder, CodeMapper};\n \n use super::method::probe;\n@@ -80,7 +81,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                          expr: &hir::Expr,\n                          checked_ty: Ty<'tcx>,\n                          expected: Ty<'tcx>,\n-                         allow_two_phase: bool)\n+                         allow_two_phase: AllowTwoPhase)\n                          -> Ty<'tcx> {\n         let (ty, err) = self.demand_coerce_diag(expr, checked_ty, expected, allow_two_phase);\n         if let Some(mut err) = err {\n@@ -98,7 +99,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               expr: &hir::Expr,\n                               checked_ty: Ty<'tcx>,\n                               expected: Ty<'tcx>,\n-                              allow_two_phase: bool)\n+                              allow_two_phase: AllowTwoPhase)\n                               -> (Ty<'tcx>, Option<DiagnosticBuilder<'tcx>>) {\n         let expected = self.resolve_type_vars_with_obligations(expected);\n "}, {"sha": "0e1d3fdbb9767c5bcddb66836f4401dd176cb06d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/96ae0ee382a32d8218da454dc4fd2b2a6fa37c4a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96ae0ee382a32d8218da454dc4fd2b2a6fa37c4a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=96ae0ee382a32d8218da454dc4fd2b2a6fa37c4a", "patch": "@@ -97,7 +97,7 @@ use rustc::mir::interpret::{GlobalId};\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits::{self, FulfillmentContext, ObligationCause, ObligationCauseCode};\n use rustc::ty::{self, Ty, TyCtxt, Visibility, ToPredicate};\n-use rustc::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n+use rustc::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::maps::Providers;\n use rustc::ty::util::{Representability, IntTypeExt, Discr};\n@@ -2649,7 +2649,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 //    to, which is `expected_ty` if `rvalue_hint` returns an\n                 //    `ExpectHasType(expected_ty)`, or the `formal_ty` otherwise.\n                 let coerce_ty = expected.and_then(|e| e.only_has_type(self));\n-                self.demand_coerce(&arg, checked_ty, coerce_ty.unwrap_or(formal_ty), true);\n+                // We're processing function arguments so we definitely want to use two-phase borrows.\n+                self.demand_coerce(&arg, checked_ty, coerce_ty.unwrap_or(formal_ty), AllowTwoPhase::Yes);\n \n                 // 3. Relate the expected type and the formal one,\n                 //    if the expected type was used for the coercion.\n@@ -2812,7 +2813,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             expr,\n             ExpectHasType(expected),\n             needs);\n-        self.demand_coerce(expr, ty, expected, false)\n+        // checks don't need two phase\n+        self.demand_coerce(expr, ty, expected, AllowTwoPhase::No)\n     }\n \n     fn check_expr_with_hint(&self, expr: &'gcx hir::Expr,\n@@ -4113,7 +4115,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                   match self.lookup_indexing(expr, base, base_t, idx_t, needs) {\n                       Some((index_ty, element_ty)) => {\n                           // two-phase not needed because index_ty is never mutable\n-                          self.demand_coerce(idx, idx_t, index_ty, false);\n+                          self.demand_coerce(idx, idx_t, index_ty, AllowTwoPhase::No);\n                           element_ty\n                       }\n                       None => {"}]}