{"sha": "5ae06ae9dea2f1dac157193b702f640e2216a5a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhZTA2YWU5ZGVhMmYxZGFjMTU3MTkzYjcwMmY2NDBlMjIxNmE1YTk=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-03-03T15:22:40Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-03-06T03:37:04Z"}, "message": "core: convert vec::{tail,tailn} to return references", "tree": {"sha": "a45c10888cbe96393cf51db2439de0fcd8cceb5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a45c10888cbe96393cf51db2439de0fcd8cceb5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ae06ae9dea2f1dac157193b702f640e2216a5a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ae06ae9dea2f1dac157193b702f640e2216a5a9", "html_url": "https://github.com/rust-lang/rust/commit/5ae06ae9dea2f1dac157193b702f640e2216a5a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ae06ae9dea2f1dac157193b702f640e2216a5a9/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "359bb3e10bb022aabc5bfc60e48d3dfffc2ee62c", "url": "https://api.github.com/repos/rust-lang/rust/commits/359bb3e10bb022aabc5bfc60e48d3dfffc2ee62c", "html_url": "https://github.com/rust-lang/rust/commit/359bb3e10bb022aabc5bfc60e48d3dfffc2ee62c"}], "stats": {"total": 132, "additions": 84, "deletions": 48}, "files": [{"sha": "98316066fd176f83fb4aca9be2d755a1c7811da2", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 39, "deletions": 18, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/5ae06ae9dea2f1dac157193b702f640e2216a5a9/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ae06ae9dea2f1dac157193b702f640e2216a5a9/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=5ae06ae9dea2f1dac157193b702f640e2216a5a9", "patch": "@@ -223,17 +223,10 @@ pub pure fn head_opt<T>(v: &r/[T]) -> Option<&r/T> {\n }\n \n /// Returns a vector containing all but the first element of a slice\n-pub pure fn tail<T:Copy>(v: &[const T]) -> ~[T] {\n-    slice(v, 1u, len(v)).to_vec()\n-}\n+pub pure fn tail<T>(v: &r/[T]) -> &r/[T] { slice(v, 1, v.len()) }\n \n-/**\n- * Returns a vector containing all but the first `n` \\\n- * elements of a slice\n- */\n-pub pure fn tailn<T:Copy>(v: &[const T], n: uint) -> ~[T] {\n-    slice(v, n, len(v)).to_vec()\n-}\n+/// Returns a vector containing all but the first `n` elements of a slice\n+pub pure fn tailn<T>(v: &r/[T], n: uint) -> &r/[T] { slice(v, n, v.len()) }\n \n /// Returns a vector containing all but the last element of a slice\n pub pure fn init<T:Copy>(v: &[const T]) -> ~[T] {\n@@ -1704,7 +1697,6 @@ pub trait CopyableVector<T> {\n     pure fn init(&self) -> ~[T];\n     pure fn last(&self) -> T;\n     pure fn slice(&self, start: uint, end: uint) -> ~[T];\n-    pure fn tail(&self) -> ~[T];\n }\n \n /// Extension methods for vectors\n@@ -1722,16 +1714,14 @@ impl<T:Copy> CopyableVector<T> for &[const T] {\n     pure fn slice(&self, start: uint, end: uint) -> ~[T] {\n         slice(*self, start, end).to_vec()\n     }\n-\n-    /// Returns all but the first element of a vector\n-    #[inline]\n-    pure fn tail(&self) -> ~[T] { tail(*self) }\n }\n \n pub trait ImmutableVector<T> {\n     pure fn view(&self, start: uint, end: uint) -> &self/[T];\n     pure fn head(&self) -> &self/T;\n     pure fn head_opt(&self) -> Option<&self/T>;\n+    pure fn tail(&self) -> &self/[T];\n+    pure fn tailn(&self, n: uint) -> &self/[T];\n     pure fn foldr<U: Copy>(&self, z: U, p: fn(t: &T, u: U) -> U) -> U;\n     pure fn map<U>(&self, f: fn(t: &T) -> U) -> ~[U];\n     pure fn mapi<U>(&self, f: fn(uint, t: &T) -> U) -> ~[U];\n@@ -1757,6 +1747,14 @@ impl<T> ImmutableVector<T> for &[T] {\n     #[inline]\n     pure fn head_opt(&self) -> Option<&self/T> { head_opt(*self) }\n \n+    /// Returns all but the first element of a vector\n+    #[inline]\n+    pure fn tail(&self) -> &self/[T] { tail(*self) }\n+\n+    /// Returns all but the first `n' elements of a vector\n+    #[inline]\n+    pure fn tailn(&self, n: uint) -> &self/[T] { tailn(*self, n) }\n+\n     /// Reduce a vector from right to left\n     #[inline]\n     pure fn foldr<U:Copy>(&self, z: U, p: fn(t: &T, u: U) -> U) -> U {\n@@ -2611,10 +2609,33 @@ mod tests {\n     #[test]\n     fn test_tail() {\n         let mut a = ~[11];\n-        assert (tail(a) == ~[]);\n-\n+        assert a.tail() == &[];\n         a = ~[11, 12];\n-        assert (tail(a) == ~[12]);\n+        assert a.tail() == &[12];\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    fn test_tail_empty() {\n+        let a: ~[int] = ~[];\n+        a.tail();\n+    }\n+\n+    #[test]\n+    fn test_tailn() {\n+        let mut a = ~[11, 12, 13];\n+        assert a.tailn(0) == &[11, 12, 13];\n+        a = ~[11, 12, 13];\n+        assert a.tailn(2) == &[13];\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    fn test_tailn_empty() {\n+        let a: ~[int] = ~[];\n+        a.tailn(2);\n     }\n \n     #[test]"}, {"sha": "7dd31374fc677d4004b20f4d01dc60379412d96a", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 40, "deletions": 25, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/5ae06ae9dea2f1dac157193b702f640e2216a5a9/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ae06ae9dea2f1dac157193b702f640e2216a5a9/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=5ae06ae9dea2f1dac157193b702f640e2216a5a9", "patch": "@@ -265,7 +265,7 @@ pub fn is_useful(cx: @MatchCheckCtxt, +m: matrix, +v: &[@pat]) -> useful {\n           Some(ref ctor) => {\n             match is_useful(cx,\n                             vec::filter_map(m, |r| default(cx, r)),\n-                            vec::tail(v)) {\n+                            v.tail()) {\n               useful_ => useful(left_ty, (/*bad*/copy *ctor)),\n               ref u => (/*bad*/copy *u)\n             }\n@@ -281,7 +281,7 @@ pub fn is_useful(cx: @MatchCheckCtxt, +m: matrix, +v: &[@pat]) -> useful {\n \n pub fn is_useful_specialized(cx: @MatchCheckCtxt,\n                              m: matrix,\n-                             +v: &[@pat],\n+                             v: &[@pat],\n                              +ctor: ctor,\n                              arity: uint,\n                              lty: ty::t)\n@@ -475,7 +475,7 @@ pub fn wild() -> @pat {\n }\n \n pub fn specialize(cx: @MatchCheckCtxt,\n-                  +r: &[@pat],\n+                  r: &[@pat],\n                   ctor_id: ctor,\n                   arity: uint,\n                   left_ty: ty::t)\n@@ -485,13 +485,17 @@ pub fn specialize(cx: @MatchCheckCtxt,\n     match r0 {\n         pat{id: pat_id, node: n, span: pat_span} =>\n             match n {\n-            pat_wild => Some(vec::append(vec::from_elem(arity, wild()),\n-                                         vec::tail(r))),\n+            pat_wild => {\n+                Some(vec::append(vec::from_elem(arity, wild()), r.tail()))\n+            }\n             pat_ident(_, _, _) => {\n                 match cx.tcx.def_map.find(&pat_id) {\n                     Some(def_variant(_, id)) => {\n-                        if variant(id) == ctor_id { Some(vec::tail(r)) }\n-                        else { None }\n+                        if variant(id) == ctor_id {\n+                            Some(vec::from_slice(r.tail()))\n+                        } else {\n+                            None\n+                        }\n                     }\n                     Some(def_const(did)) => {\n                         let const_expr =\n@@ -506,10 +510,20 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                             single => true,\n                             _ => fail!(~\"type error\")\n                         };\n-                        if match_ { Some(vec::tail(r)) } else { None }\n+                        if match_ {\n+                            Some(vec::from_slice(r.tail()))\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                    _ => {\n+                        Some(\n+                            vec::append(\n+                                vec::from_elem(arity, wild()),\n+                                r.tail()\n+                            )\n+                        )\n                     }\n-                    _ => Some(vec::append(vec::from_elem(arity, wild()),\n-                                          vec::tail(r)))\n                 }\n             }\n             pat_enum(_, args) => {\n@@ -519,7 +533,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                             Some(args) => args,\n                             None => vec::from_elem(arity, wild())\n                         };\n-                        Some(vec::append(args, vec::tail(r)))\n+                        Some(vec::append(args, vec::from_slice(r.tail())))\n                     }\n                     def_variant(_, _) => None,\n                     def_struct(*) => {\n@@ -529,7 +543,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                             Some(args) => new_args = args,\n                             None => new_args = vec::from_elem(arity, wild())\n                         }\n-                        Some(vec::append(new_args, vec::tail(r)))\n+                        Some(vec::append(new_args, vec::from_slice(r.tail())))\n                     }\n                     _ => None\n                 }\n@@ -545,7 +559,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                         _ => wild()\n                     }\n                 });\n-                Some(vec::append(args, vec::tail(r)))\n+                Some(vec::append(args, vec::from_slice(r.tail())))\n             }\n             pat_struct(_, ref flds, _) => {\n                 // Is this a struct or an enum variant?\n@@ -560,7 +574,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                                     _ => wild()\n                                 }\n                             });\n-                            Some(vec::append(args, vec::tail(r)))\n+                            Some(vec::append(args, vec::from_slice(r.tail())))\n                         } else {\n                             None\n                         }\n@@ -587,13 +601,14 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                                 _ => wild()\n                             }\n                         });\n-                        Some(vec::append(args, vec::tail(r)))\n+                        Some(vec::append(args, vec::from_slice(r.tail())))\n                     }\n                 }\n             }\n-            pat_tup(args) => Some(vec::append(args, vec::tail(r))),\n-            pat_box(a) | pat_uniq(a) | pat_region(a) =>\n-                Some(vec::append(~[a], vec::tail(r))),\n+            pat_tup(args) => Some(vec::append(args, r.tail())),\n+            pat_box(a) | pat_uniq(a) | pat_region(a) => {\n+                Some(vec::append(~[a], r.tail()))\n+            }\n             pat_lit(expr) => {\n                 let e_v = eval_const_expr(cx.tcx, expr);\n                 let match_ = match ctor_id {\n@@ -605,21 +620,21 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                     single => true,\n                     _ => fail!(~\"type error\")\n                 };\n-                if match_ { Some(vec::tail(r)) } else { None }\n+                if match_ { Some(vec::from_slice(r.tail())) } else { None }\n             }\n             pat_range(lo, hi) => {\n                 let (c_lo, c_hi) = match ctor_id {\n                     val(ref v) => ((/*bad*/copy *v), (/*bad*/copy *v)),\n                     range(ref lo, ref hi) =>\n                         ((/*bad*/copy *lo), (/*bad*/copy *hi)),\n-                    single => return Some(vec::tail(r)),\n+                    single => return Some(vec::from_slice(r.tail())),\n                     _ => fail!(~\"type error\")\n                 };\n                 let v_lo = eval_const_expr(cx.tcx, lo),\n                 v_hi = eval_const_expr(cx.tcx, hi);\n                 let match_ = compare_const_vals(c_lo, v_lo) >= 0 &&\n                     compare_const_vals(c_hi, v_hi) <= 0;\n-          if match_ { Some(vec::tail(r)) } else { None }\n+          if match_ { Some(vec::from_slice(r.tail())) } else { None }\n       }\n             pat_vec(elems, tail) => {\n                 match ctor_id {\n@@ -630,10 +645,10 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                                 vec::append(elems, vec::from_elem(\n                                     arity - num_elements, wild()\n                                 )),\n-                                vec::tail(r)\n+                                vec::from_slice(r.tail())\n                             ))\n                         } else if num_elements == arity {\n-                            Some(vec::append(elems, vec::tail(r)))\n+                            Some(vec::append(elems, r.tail()))\n                         } else {\n                             None\n                         }\n@@ -645,8 +660,8 @@ pub fn specialize(cx: @MatchCheckCtxt,\n     }\n }\n \n-pub fn default(cx: @MatchCheckCtxt, r: ~[@pat]) -> Option<~[@pat]> {\n-    if is_wild(cx, r[0]) { Some(vec::tail(r)) }\n+pub fn default(cx: @MatchCheckCtxt, r: &[@pat]) -> Option<~[@pat]> {\n+    if is_wild(cx, r[0]) { Some(vec::from_slice(r.tail())) }\n     else { None }\n }\n "}, {"sha": "1d7314f751870e17e98700bb669f32fe422f7b3b", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5ae06ae9dea2f1dac157193b702f640e2216a5a9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ae06ae9dea2f1dac157193b702f640e2216a5a9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=5ae06ae9dea2f1dac157193b702f640e2216a5a9", "patch": "@@ -71,8 +71,8 @@ pub impl FnType {\n             let llretptr = GEPi(bcx, llargbundle, [0u, n]);\n             let llretloc = Load(bcx, llretptr);\n                 llargvals = ~[llretloc];\n-                atys = vec::tail(atys);\n-                attrs = vec::tail(attrs);\n+                atys = vec::from_slice(atys.tail());\n+                attrs = vec::from_slice(attrs.tail());\n         }\n \n         while i < n {\n@@ -131,8 +131,8 @@ pub impl FnType {\n         let mut attrs = /*bad*/copy self.attrs;\n         let mut j = 0u;\n         let llretptr = if self.sret {\n-            atys = vec::tail(atys);\n-            attrs = vec::tail(attrs);\n+            atys = vec::from_slice(atys.tail());\n+            attrs = vec::from_slice(attrs.tail());\n             j = 1u;\n             get_param(llwrapfn, 0u)\n         } else if self.ret_ty.cast {"}, {"sha": "06595a23d9612bafc10ef5bdcd893d5b1d1e584a", "filename": "src/librustdoc/unindent_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ae06ae9dea2f1dac157193b702f640e2216a5a9/src%2Flibrustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ae06ae9dea2f1dac157193b702f640e2216a5a9/src%2Flibrustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Funindent_pass.rs?ref=5ae06ae9dea2f1dac157193b702f640e2216a5a9", "patch": "@@ -79,7 +79,7 @@ fn unindent(s: &str) -> ~str {\n \n     if !lines.is_empty() {\n         let unindented = ~[lines.head().trim()]\n-            + do vec::tail(lines).map |line| {\n+            + do lines.tail().map |line| {\n             if str::is_whitespace(*line) {\n                 copy *line\n             } else {"}]}