{"sha": "2ccaeed50efc2d55ea05ad4c1178b6ce38bf9aca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjY2FlZWQ1MGVmYzJkNTVlYTA1YWQ0YzExNzhiNmNlMzhiZjlhY2E=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-04-26T07:58:58Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-04-27T01:13:21Z"}, "message": "Refactor away `FallbackChecks` and remove dead code", "tree": {"sha": "05e59d6b46df01d023ec7d73a753c42ce2ddf7f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05e59d6b46df01d023ec7d73a753c42ce2ddf7f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ccaeed50efc2d55ea05ad4c1178b6ce38bf9aca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ccaeed50efc2d55ea05ad4c1178b6ce38bf9aca", "html_url": "https://github.com/rust-lang/rust/commit/2ccaeed50efc2d55ea05ad4c1178b6ce38bf9aca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ccaeed50efc2d55ea05ad4c1178b6ce38bf9aca/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9d8e1493c840a9901f7caecda26de1a8a48f754", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9d8e1493c840a9901f7caecda26de1a8a48f754", "html_url": "https://github.com/rust-lang/rust/commit/c9d8e1493c840a9901f7caecda26de1a8a48f754"}], "stats": {"total": 69, "additions": 6, "deletions": 63}, "files": [{"sha": "e9bbd686a3f60811928ebfbf885f45b339cb2d7a", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 6, "deletions": 63, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/2ccaeed50efc2d55ea05ad4c1178b6ce38bf9aca/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccaeed50efc2d55ea05ad4c1178b6ce38bf9aca/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=2ccaeed50efc2d55ea05ad4c1178b6ce38bf9aca", "patch": "@@ -42,7 +42,6 @@ use self::ModulePrefixResult::*;\n use self::AssocItemResolveResult::*;\n use self::BareIdentifierPatternResolution::*;\n use self::ParentLink::*;\n-use self::FallbackChecks::*;\n \n use rustc::dep_graph::DepNode;\n use rustc::hir::map as hir_map;\n@@ -81,7 +80,7 @@ use rustc::hir::{Pat, PatKind, Path, PrimTy};\n use rustc::hir::{PathSegment, PathParameters};\n use rustc::hir::HirVec;\n use rustc::hir::{TraitRef, Ty, TyBool, TyChar, TyFloat, TyInt};\n-use rustc::hir::{TyRptr, TyStr, TyUint, TyPath, TyPtr};\n+use rustc::hir::{TyRptr, TyStr, TyUint, TyPath};\n \n use std::collections::{HashMap, HashSet};\n use std::cell::{Cell, RefCell};\n@@ -676,9 +675,7 @@ impl<T> ResolveResult<T> {\n enum FallbackSuggestion {\n     NoSuggestion,\n     Field,\n-    Method,\n     TraitItem,\n-    StaticMethod(String),\n     TraitMethod(String),\n }\n \n@@ -1124,12 +1121,6 @@ impl<'a> ResolverArenas<'a> {\n     }\n }\n \n-#[derive(PartialEq)]\n-enum FallbackChecks {\n-    Everything,\n-    OnlyTraitAndStatics,\n-}\n-\n impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn new(session: &'a Session,\n            ast_map: &'a hir_map::Map<'tcx>,\n@@ -2821,37 +2812,17 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     fn find_fallback_in_self_type(&mut self, name: Name) -> FallbackSuggestion {\n-        fn extract_path_and_node_id(t: &Ty,\n-                                    allow: FallbackChecks)\n-                                    -> Option<(Path, NodeId, FallbackChecks)> {\n+        fn extract_node_id(t: &Ty) -> Option<NodeId> {\n             match t.node {\n-                TyPath(None, ref path) => Some((path.clone(), t.id, allow)),\n-                TyPtr(ref mut_ty) => extract_path_and_node_id(&mut_ty.ty, OnlyTraitAndStatics),\n-                TyRptr(_, ref mut_ty) => extract_path_and_node_id(&mut_ty.ty, allow),\n+                TyPath(None, _) => Some(t.id),\n+                TyRptr(_, ref mut_ty) => extract_node_id(&mut_ty.ty),\n                 // This doesn't handle the remaining `Ty` variants as they are not\n                 // that commonly the self_type, it might be interesting to provide\n                 // support for those in future.\n                 _ => None,\n             }\n         }\n \n-        fn get_module<'a, 'tcx>(this: &mut Resolver<'a, 'tcx>,\n-                                span: Span,\n-                                name_path: &[ast::Name])\n-                                -> Option<Module<'a>> {\n-            let last_name = name_path.last().unwrap();\n-\n-            if name_path.len() == 1 {\n-                match this.primitive_type_table.primitive_types.get(last_name) {\n-                    Some(_) => None,\n-                    None => this.current_module.resolve_name_in_lexical_scope(*last_name, TypeNS)\n-                                               .and_then(NameBinding::module)\n-                }\n-            } else {\n-                this.resolve_module_path(&name_path, UseLexicalScope, span).success()\n-            }\n-        }\n-\n         fn is_static_method(this: &Resolver, did: DefId) -> bool {\n             if let Some(node_id) = this.ast_map.as_local_node_id(did) {\n                 let sig = match this.ast_map.get(node_id) {\n@@ -2871,15 +2842,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n \n-        let (path, node_id, allowed) = match self.current_self_type {\n-            Some(ref ty) => match extract_path_and_node_id(ty, Everything) {\n-                Some(x) => x,\n-                None => return NoSuggestion,\n-            },\n-            None => return NoSuggestion,\n-        };\n-\n-        if allowed == Everything {\n+        if let Some(node_id) = self.current_self_type.as_ref().and_then(extract_node_id) {\n             // Look for a field with the same name in the current self_type.\n             match self.def_map.borrow().get(&node_id).map(|d| d.full_def()) {\n                 Some(Def::Enum(did)) |\n@@ -2897,24 +2860,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n \n-        let name_path = path.segments.iter().map(|seg| seg.identifier.name).collect::<Vec<_>>();\n-\n-        // Look for a method in the current self type's impl module.\n-        if let Some(module) = get_module(self, path.span, &name_path) {\n-            if let Some(binding) = module.resolve_name_in_lexical_scope(name, ValueNS) {\n-                if let Some(Def::Method(did)) = binding.def() {\n-                    if is_static_method(self, did) {\n-                        return StaticMethod(path_names_to_string(&path, 0));\n-                    }\n-                    if self.current_trait_ref.is_some() {\n-                        return TraitItem;\n-                    } else if allowed == Everything {\n-                        return Method;\n-                    }\n-                }\n-            }\n-        }\n-\n         // Look for a method in the current trait.\n         if let Some((trait_did, ref trait_ref)) = self.current_trait_ref {\n             if let Some(&did) = self.trait_item_map.get(&(name, trait_did)) {\n@@ -3073,10 +3018,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                         }\n                                     }\n                                     Field => format!(\"`self.{}`\", path_name),\n-                                    Method |\n                                     TraitItem => format!(\"to call `self.{}`\", path_name),\n-                                    TraitMethod(path_str) |\n-                                    StaticMethod(path_str) =>\n+                                    TraitMethod(path_str) =>\n                                         format!(\"to call `{}::{}`\", path_str, path_name),\n                                 };\n "}]}