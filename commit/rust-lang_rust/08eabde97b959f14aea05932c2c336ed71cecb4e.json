{"sha": "08eabde97b959f14aea05932c2c336ed71cecb4e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4ZWFiZGU5N2I5NTlmMTRhZWEwNTkzMmMyYzMzNmVkNzFjZWNiNGU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-19T00:42:29Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-19T00:43:24Z"}, "message": "rustc: First stab at implementing interior vector concat in the DPS engine", "tree": {"sha": "5ca3bd2f0d67aea2f5fb80f673135463ccfc9644", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ca3bd2f0d67aea2f5fb80f673135463ccfc9644"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08eabde97b959f14aea05932c2c336ed71cecb4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08eabde97b959f14aea05932c2c336ed71cecb4e", "html_url": "https://github.com/rust-lang/rust/commit/08eabde97b959f14aea05932c2c336ed71cecb4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08eabde97b959f14aea05932c2c336ed71cecb4e/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d4903544e6c2452abcfafb1c251c193e907681c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d4903544e6c2452abcfafb1c251c193e907681c", "html_url": "https://github.com/rust-lang/rust/commit/7d4903544e6c2452abcfafb1c251c193e907681c"}], "stats": {"total": 294, "additions": 267, "deletions": 27}, "files": [{"sha": "8c5743096ec3c96a3a39ebd94362f5fe967c503a", "filename": "src/comp/middle/trans_dps.rs", "status": "modified", "additions": 49, "deletions": 27, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/08eabde97b959f14aea05932c2c336ed71cecb4e/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08eabde97b959f14aea05932c2c336ed71cecb4e/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs?ref=08eabde97b959f14aea05932c2c336ed71cecb4e", "patch": "@@ -62,6 +62,17 @@ fn mk_const(&@crate_ctxt ccx, &str name, bool exported, ValueRef llval)\n }\n \n \n+// Type utilities\n+\n+fn size_of(&@crate_ctxt ccx, &span sp, ty::t t) -> uint {\n+    if ty::type_has_dynamic_size(ccx.tcx, t) {\n+        ccx.sess.bug(\"trans_dps::size_of() called on a type with dynamic \" +\n+                     \"size\");\n+    }\n+    ret llsize_of(ccx, trans::type_of_inner(ccx, sp, t));\n+}\n+\n+\n // Destination utilities\n \n tag dest {\n@@ -93,7 +104,12 @@ fn dest_ptr(&dest dest) -> ValueRef {\n     alt (dest) {\n       dst_nil { fail \"nil dest in dest_ptr\" }\n       dst_imm(_) { fail \"immediate dest in dest_ptr\" }\n-      dst_alias(_) { fail \"alias dest in dest_ptr\" }\n+      dst_alias(?box) {\n+        alt (*box) {\n+          none { fail \"alias wasn't filled in prior to dest_ptr\" }\n+          some(?llval) { llval }\n+        }\n+      }\n       dst_copy(?llptr) { llptr }\n       dst_move(?llptr) { llptr }\n     }\n@@ -137,6 +153,22 @@ fn ccx_tcx(&@crate_ctxt ccx) -> ty::ctxt { ret ccx.tcx; }\n \n // Common operations\n \n+fn memmove(&@block_ctxt bcx, ValueRef lldestptr, ValueRef llsrcptr,\n+           ValueRef llsz) {\n+    auto lldestty = llelement_type(trans::val_ty(lldestptr));\n+    auto llsrcty = llelement_type(trans::val_ty(llsrcptr));\n+    auto dest_align = llalign_of(bcx_ccx(bcx), lldestty);\n+    auto src_align = llalign_of(bcx_ccx(bcx), llsrcty);\n+    auto align = uint::min(dest_align, src_align);\n+    auto llfn = bcx_ccx(bcx).intrinsics.get(\"llvm.memmove.p0i8.p0i8.i32\");\n+    auto lldestptr_i8 = bcx.build.PointerCast(lldestptr,\n+                                              tc::T_ptr(tc::T_i8()));\n+    auto llsrcptr_i8 = bcx.build.PointerCast(llsrcptr,\n+                                             tc::T_ptr(tc::T_i8()));\n+    bcx.build.Call(llfn, ~[lldestptr_i8, llsrcptr_i8, llsz, tc::C_uint(align),\n+                           tc::C_bool(false)]);\n+}\n+\n // If \"cast\" is true, casts dest appropriately before the store.\n fn store_imm(&@block_ctxt bcx, &dest dest, ValueRef llsrc, bool cast)\n         -> @block_ctxt {\n@@ -170,22 +202,9 @@ fn store_ptr(&@block_ctxt bcx, &dest dest, ValueRef llsrcptr) -> @block_ctxt {\n         *box = some(llsrcptr);\n       }\n       dst_copy(?lldestptr) | dst_move(?lldestptr) {\n-        auto lldestty = llelement_type(trans::val_ty(llsrcptr));\n         auto llsrcty = llelement_type(trans::val_ty(llsrcptr));\n-        auto dest_align = llalign_of(bcx_ccx(bcx), lldestty);\n-        auto src_align = llalign_of(bcx_ccx(bcx), llsrcty);\n-        auto align = uint::min(dest_align, src_align);\n-        auto llfn = bcx_ccx(bcx).intrinsics.get(\"llvm.memmove.p0i8.p0i8.i32\");\n-        auto lldestptr_i8 = bcx.build.PointerCast(lldestptr,\n-                                                  tc::T_ptr(tc::T_i8()));\n-        auto llsrcptr_i8 = bcx.build.PointerCast(llsrcptr,\n-                                                 tc::T_ptr(tc::T_i8()));\n-        bcx.build.Call(llfn,\n-                       ~[lldestptr_i8,\n-                         llsrcptr_i8,\n-                         tc::C_uint(llsize_of(bcx_ccx(bcx), llsrcty)),\n-                         tc::C_uint(align),\n-                         tc::C_bool(false)]);\n+        auto llsz = tc::C_uint(llsize_of(bcx_ccx(bcx), llsrcty));\n+        memmove(bcx, lldestptr, llsrcptr, llsz);\n         ret bcx;\n       }\n     }\n@@ -194,6 +213,9 @@ fn store_ptr(&@block_ctxt bcx, &dest dest, ValueRef llsrcptr) -> @block_ctxt {\n \n // Allocates a value of the given LLVM size on either the task heap or the\n // shared heap.\n+//\n+// TODO: This should *not* use destination-passing style, because doing so\n+// makes callers incur an extra load.\n tag heap { hp_task; hp_shared; }\n fn malloc(&@block_ctxt bcx, ValueRef lldest, heap heap,\n           option[ValueRef] llcustom_size_opt) -> @block_ctxt {\n@@ -287,18 +309,18 @@ fn trans_lit(&@block_ctxt cx, &dest dest, &ast::lit lit) -> @block_ctxt {\n     ret bcx;\n }\n \n-fn trans_binary(&@block_ctxt cx, &dest in_dest, ast::binop op,\n+fn trans_binary(&@block_ctxt cx, &dest dest, &span sp, ast::binop op,\n                 &@ast::expr lhs, &@ast::expr rhs) -> @block_ctxt {\n     auto bcx = cx;\n-    auto r = spill_alias(bcx, in_dest, ty::expr_ty(bcx_tcx(bcx), lhs));\n-    bcx = r._0; auto dest = r._1;\n-    bcx = trans_expr(bcx, dest, lhs);\n-\n-    r = mk_temp(bcx, ty::expr_ty(bcx_tcx(bcx), rhs));\n-    bcx = r._0; auto rhs_tmp = r._1;\n-    bcx = trans_expr(bcx, rhs_tmp, rhs);\n-\n-    ret bcx;    // TODO\n+    alt (op) {\n+      ast::add {\n+        bcx = trans_vec::trans_concat(bcx, dest, sp,\n+                                      ty::expr_ty(bcx_tcx(bcx), rhs), lhs,\n+                                      rhs);\n+      }\n+      // TODO: Many more to add here.\n+    }\n+    ret bcx;\n }\n \n fn trans_log(&@block_ctxt cx, &span sp, int level, &@ast::expr expr)\n@@ -408,7 +430,7 @@ fn trans_expr(&@block_ctxt bcx, &dest dest, &@ast::expr expr) -> @block_ctxt {\n         ret trans_log(bcx, expr.span, level, operand);\n       }\n       ast::expr_binary(?op, ?lhs, ?rhs) {\n-        ret trans_binary(bcx, dest, op, lhs, rhs);\n+        ret trans_binary(bcx, dest, expr.span, op, lhs, rhs);\n       }\n       _ { fail \"unhandled expr type in trans_expr\"; }\n     }"}, {"sha": "682e4eefad44069366e434378cefb60d390c89bf", "filename": "src/comp/middle/trans_vec.rs", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/08eabde97b959f14aea05932c2c336ed71cecb4e/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08eabde97b959f14aea05932c2c336ed71cecb4e/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs?ref=08eabde97b959f14aea05932c2c336ed71cecb4e", "patch": "@@ -0,0 +1,217 @@\n+// Translation of vector operations to LLVM IR, in destination-passing style.\n+\n+import back::abi;\n+import lib::llvm::llvm;\n+import llvm::ValueRef;\n+import middle::trans;\n+import middle::trans_common;\n+import middle::trans_dps;\n+import middle::ty;\n+import syntax::ast;\n+import syntax::codemap::span;\n+import trans::alloca;\n+import trans::block_ctxt;\n+import trans::load_inbounds;\n+import trans::new_sub_block_ctxt;\n+import trans::struct_elt;\n+import trans::type_of_or_i8;\n+import trans_common::C_int;\n+import trans_common::C_null;\n+import trans_common::C_uint;\n+import trans_common::T_int;\n+import trans_common::T_ivec_heap;\n+import trans_common::T_ivec_heap_part;\n+import trans_common::T_opaque_ivec;\n+import trans_common::T_ptr;\n+import trans_dps::bcx_ccx;\n+import trans_dps::bcx_tcx;\n+import trans_dps::dest;\n+import trans_dps::llsize_of;\n+import trans_dps::mk_temp;\n+\n+import std::option::none;\n+import std::option::some;\n+import tc = middle::trans_common;\n+\n+// Returns the length of an interior vector and a pointer to its first\n+// element, in that order.\n+//\n+// TODO: We can optimize this in the cases in which we statically know the\n+// vector must be on the stack.\n+fn get_len_and_data(&@block_ctxt cx, ty::t t, ValueRef llvecptr)\n+        -> tup(@block_ctxt, ValueRef, ValueRef) {\n+    auto bcx = cx;\n+\n+    // If this interior vector has dynamic size, we can't assume anything\n+    // about the LLVM type of the value passed in, so we cast it to an\n+    // opaque vector type.\n+    auto unit_ty = ty::sequence_element_type(bcx_tcx(bcx), t);\n+    auto v;\n+    if (ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty)) {\n+        v = bcx.build.PointerCast(llvecptr, T_ptr(T_opaque_ivec()));\n+    } else {\n+        v = llvecptr;\n+    }\n+\n+    auto llunitty = type_of_or_i8(bcx, unit_ty);\n+    auto stack_len = load_inbounds(bcx, v, ~[C_int(0),\n+                                             C_uint(abi::ivec_elt_len)]);\n+    auto stack_elem =\n+        bcx.build.InBoundsGEP(v,\n+                              ~[C_int(0), C_uint(abi::ivec_elt_elems),\n+                                C_int(0)]);\n+    auto on_heap =\n+        bcx.build.ICmp(lib::llvm::LLVMIntEQ, stack_len, C_int(0));\n+    auto on_heap_cx = new_sub_block_ctxt(bcx, \"on_heap\");\n+    auto next_cx = new_sub_block_ctxt(bcx, \"next\");\n+    bcx.build.CondBr(on_heap, on_heap_cx.llbb, next_cx.llbb);\n+    auto heap_stub =\n+        on_heap_cx.build.PointerCast(v, T_ptr(T_ivec_heap(llunitty)));\n+    auto heap_ptr = load_inbounds(on_heap_cx, heap_stub,\n+                                  ~[C_int(0),\n+                                    C_uint(abi::ivec_heap_stub_elt_ptr)]);\n+\n+    // Check whether the heap pointer is null. If it is, the vector length\n+    // is truly zero.\n+\n+    auto llstubty = T_ivec_heap(llunitty);\n+    auto llheapptrty = struct_elt(llstubty, abi::ivec_heap_stub_elt_ptr);\n+    auto heap_ptr_is_null =\n+        on_heap_cx.build.ICmp(lib::llvm::LLVMIntEQ, heap_ptr,\n+                              C_null(T_ptr(llheapptrty)));\n+    auto zero_len_cx = new_sub_block_ctxt(bcx, \"zero_len\");\n+    auto nonzero_len_cx = new_sub_block_ctxt(bcx, \"nonzero_len\");\n+    on_heap_cx.build.CondBr(heap_ptr_is_null, zero_len_cx.llbb,\n+                            nonzero_len_cx.llbb);\n+    // Technically this context is unnecessary, but it makes this function\n+    // clearer.\n+\n+    auto zero_len = C_int(0);\n+    auto zero_elem = C_null(T_ptr(llunitty));\n+    zero_len_cx.build.Br(next_cx.llbb);\n+    // If we're here, then we actually have a heapified vector.\n+\n+    auto heap_len = load_inbounds(nonzero_len_cx, heap_ptr,\n+                                  ~[C_int(0),\n+                                    C_uint(abi::ivec_heap_elt_len)]);\n+    auto heap_elem =\n+        {\n+            auto v = ~[C_int(0), C_uint(abi::ivec_heap_elt_elems),\n+                       C_int(0)];\n+            nonzero_len_cx.build.InBoundsGEP(heap_ptr,v)\n+        };\n+\n+    nonzero_len_cx.build.Br(next_cx.llbb);\n+\n+    // Now we can figure out the length of |v| and get a pointer to its\n+    // first element.\n+\n+    auto len =\n+        next_cx.build.Phi(T_int(), ~[stack_len, zero_len, heap_len],\n+                          ~[bcx.llbb, zero_len_cx.llbb,\n+                            nonzero_len_cx.llbb]);\n+    auto elem =\n+        next_cx.build.Phi(T_ptr(llunitty),\n+                          ~[stack_elem, zero_elem, heap_elem],\n+                          ~[bcx.llbb, zero_len_cx.llbb,\n+                            nonzero_len_cx.llbb]);\n+    ret tup(next_cx, len, elem);\n+}\n+\n+fn trans_concat(&@block_ctxt cx, &dest in_dest, &span sp, ty::t t,\n+                &@ast::expr lhs, &@ast::expr rhs) -> @block_ctxt {\n+    auto bcx = cx;\n+\n+    // TODO: Skip null if copying strings.\n+    // TODO: Detect \"a = a + b\" and promote to trans_append.\n+    // TODO: Detect \"a + [ literal ]\" and optimize to copying the literal\n+    //       elements in directly.\n+\n+    // Translate the LHS and RHS. Pull out their length and data.\n+    auto t = ty::expr_ty(bcx_tcx(bcx), lhs);\n+    auto lhs_tmp = trans_dps::dest_alias(bcx_tcx(bcx), t);\n+    bcx = trans_dps::trans_expr(bcx, lhs_tmp, lhs);\n+    auto lllhsptr = trans_dps::dest_ptr(lhs_tmp);\n+\n+    auto rhs_tmp = trans_dps::dest_alias(bcx_tcx(bcx), t);\n+    bcx = trans_dps::trans_expr(bcx, rhs_tmp, rhs);\n+    auto llrhsptr = trans_dps::dest_ptr(rhs_tmp);\n+\n+    auto r0 = get_len_and_data(bcx, t, lllhsptr);\n+    bcx = r0._0; auto lllhslen = r0._1; auto lllhsdata = r0._2;\n+    r0 = get_len_and_data(bcx, t, llrhsptr);\n+    bcx = r0._0; auto llrhslen = r0._1; auto llrhsdata = r0._2;\n+\n+    // Allocate the destination.\n+    auto r1 = trans_dps::spill_alias(bcx, in_dest, t);\n+    bcx = r1._0; auto dest = r1._1;\n+\n+    auto unit_t = ty::sequence_element_type(bcx_tcx(bcx), t);\n+    auto unit_sz = trans_dps::size_of(bcx_ccx(bcx), sp, unit_t);\n+\n+    auto stack_elems_sz = unit_sz * abi::ivec_default_length;\n+    auto lldestptr = trans_dps::dest_ptr(dest);\n+    auto llunitty = trans::type_of(bcx_ccx(bcx), sp, unit_t);\n+\n+    // Decide whether to allocate the result on the stack or on the heap.\n+    auto llnewlen = bcx.build.Add(lllhslen, llrhslen);\n+    auto llonstack = bcx.build.ICmp(lib::llvm::LLVMIntULE, llnewlen,\n+                                    C_uint(stack_elems_sz));\n+    auto on_stack_bcx = new_sub_block_ctxt(bcx, \"on_stack\");\n+    auto on_heap_bcx = new_sub_block_ctxt(bcx, \"on_heap\");\n+    bcx.build.CondBr(llonstack, on_stack_bcx.llbb, on_heap_bcx.llbb);\n+\n+    // On-stack case.\n+    auto next_bcx = new_sub_block_ctxt(bcx, \"next\");\n+    trans::store_inbounds(on_stack_bcx, llnewlen, lldestptr,\n+                          ~[C_int(0), C_uint(abi::ivec_elt_len)]);\n+    trans::store_inbounds(on_stack_bcx, C_uint(stack_elems_sz), lldestptr,\n+                          ~[C_int(0), C_uint(abi::ivec_elt_alen)]);\n+    auto llonstackdataptr =\n+        on_stack_bcx.build.InBoundsGEP(lldestptr,\n+                                       ~[C_int(0),\n+                                         C_uint(abi::ivec_elt_elems),\n+                                         C_int(0)]);\n+    on_stack_bcx.build.Br(next_bcx.llbb);\n+\n+    // On-heap case.\n+    auto llheappartty = tc::T_ivec_heap(llunitty);\n+    auto lldeststubptr =\n+        on_heap_bcx.build.PointerCast(lldestptr, tc::T_ptr(llheappartty));\n+    trans::store_inbounds(on_heap_bcx, C_int(0), lldeststubptr,\n+                          ~[C_int(0), C_uint(abi::ivec_elt_len)]);\n+    trans::store_inbounds(on_heap_bcx, llnewlen, lldeststubptr,\n+                          ~[C_int(0), C_uint(abi::ivec_elt_alen)]);\n+\n+    auto llheappartptrptr =\n+        on_heap_bcx.build.InBoundsGEP(lldeststubptr,\n+                                      ~[C_int(0),\n+                                        C_uint(abi::ivec_elt_elems)]);\n+    auto llsizeofint = C_uint(llsize_of(bcx_ccx(bcx), tc::T_int()));\n+    on_heap_bcx = trans_dps::malloc(on_heap_bcx, llheappartptrptr,\n+                                    trans_dps::hp_shared,\n+                                    some(on_heap_bcx.build.Add(llnewlen,\n+                                                               llsizeofint)));\n+    auto llheappartptr = on_heap_bcx.build.Load(llheappartptrptr);\n+    trans::store_inbounds(on_heap_bcx, llnewlen, llheappartptr,\n+                          ~[C_int(0), C_uint(abi::ivec_heap_elt_len)]);\n+    auto llheapdataptr =\n+        on_heap_bcx.build.InBoundsGEP(llheappartptr,\n+                                      ~[C_int(0),\n+                                        C_uint(abi::ivec_heap_elt_elems),\n+                                        C_int(0)]);\n+    on_heap_bcx.build.Br(next_bcx.llbb);\n+\n+    // Perform the memmove.\n+    auto lldataptr =\n+        next_bcx.build.Phi(T_ptr(llunitty),\n+                           ~[llonstackdataptr, llheapdataptr],\n+                           ~[on_stack_bcx.llbb, on_heap_bcx.llbb]);\n+    trans_dps::memmove(next_bcx, lldataptr, lllhsdata, lllhslen);\n+    trans_dps::memmove(next_bcx,\n+                       next_bcx.build.InBoundsGEP(lldataptr, ~[lllhslen]),\n+                       llrhsdata, llrhslen);\n+\n+    ret next_bcx;\n+}\n+"}, {"sha": "10e9cb801937c46f4020df2c7b15dec374234d5e", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08eabde97b959f14aea05932c2c336ed71cecb4e/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/08eabde97b959f14aea05932c2c336ed71cecb4e/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=08eabde97b959f14aea05932c2c336ed71cecb4e", "patch": "@@ -20,6 +20,7 @@ mod middle {\n     mod trans_alt;\n     mod trans_comm;\n     mod trans_dps;\n+    mod trans_vec;\n     mod ty;\n     mod ast_map;\n     mod resolve;"}]}