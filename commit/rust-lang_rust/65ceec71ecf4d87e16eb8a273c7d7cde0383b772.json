{"sha": "65ceec71ecf4d87e16eb8a273c7d7cde0383b772", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1Y2VlYzcxZWNmNGQ4N2UxNmViOGEyNzNjN2Q3Y2RlMDM4M2I3NzI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-07T08:57:18Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-26T14:31:49Z"}, "message": "make `TypeOutlives` parameterized over a delegate\n\nIt was only using the `infcx` to \"accumulate\" constraints anyhow.", "tree": {"sha": "b9ebc77abdff1bb73234900a2dc42b28575d5af4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9ebc77abdff1bb73234900a2dc42b28575d5af4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65ceec71ecf4d87e16eb8a273c7d7cde0383b772", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65ceec71ecf4d87e16eb8a273c7d7cde0383b772", "html_url": "https://github.com/rust-lang/rust/commit/65ceec71ecf4d87e16eb8a273c7d7cde0383b772", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65ceec71ecf4d87e16eb8a273c7d7cde0383b772/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b858ed5919f689c0451609fa8bed62d4ee2e1ef1", "url": "https://api.github.com/repos/rust-lang/rust/commits/b858ed5919f689c0451609fa8bed62d4ee2e1ef1", "html_url": "https://github.com/rust-lang/rust/commit/b858ed5919f689c0451609fa8bed62d4ee2e1ef1"}], "stats": {"total": 121, "additions": 90, "deletions": 31}, "files": [{"sha": "c0d530618eca149507acb0bbd2e700380357bee6", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 90, "deletions": 31, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/65ceec71ecf4d87e16eb8a273c7d7cde0383b772/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65ceec71ecf4d87e16eb8a273c7d7cde0383b772/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=65ceec71ecf4d87e16eb8a273c7d7cde0383b772", "patch": "@@ -159,8 +159,13 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n             }\n         }\n \n-        let outlives =\n-            TypeOutlives::new(self, region_bound_pairs, implicit_region_bound, param_env);\n+        let outlives = &mut TypeOutlives::new(\n+            self,\n+            self.tcx,\n+            region_bound_pairs,\n+            implicit_region_bound,\n+            param_env,\n+        );\n \n         for RegionObligation {\n             sup_type,\n@@ -193,32 +198,68 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         ty: Ty<'tcx>,\n         region: ty::Region<'tcx>,\n     ) {\n-        let outlives =\n-            TypeOutlives::new(self, region_bound_pairs, implicit_region_bound, param_env);\n+        let outlives = &mut TypeOutlives::new(\n+            self,\n+            self.tcx,\n+            region_bound_pairs,\n+            implicit_region_bound,\n+            param_env,\n+        );\n         let ty = self.resolve_type_vars_if_possible(&ty);\n         outlives.type_must_outlive(origin, ty, region);\n     }\n }\n \n-#[must_use] // you ought to invoke `into_accrued_obligations` when you are done =)\n-struct TypeOutlives<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+/// The `TypeOutlives` struct has the job of \"lowering\" a `T: 'a`\n+/// obligation into a series of `'a: 'b` constraints and \"verifys\", as\n+/// described on the module comment. The final constraints are emitted\n+/// via a \"delegate\" of type `D` -- this is usually the `infcx`, which\n+/// accrues them into the `region_obligations` code, but for NLL we\n+/// use something else.\n+pub struct TypeOutlives<'cx, 'gcx: 'tcx, 'tcx: 'cx, D>\n+where\n+    D: TypeOutlivesDelegate<'tcx>,\n+{\n     // See the comments on `process_registered_region_obligations` for the meaning\n     // of these fields.\n-    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+    delegate: D,\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     region_bound_pairs: &'cx [(ty::Region<'tcx>, GenericKind<'tcx>)],\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n }\n \n-impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n+pub trait TypeOutlivesDelegate<'tcx> {\n+    fn push_sub_region_constraint(\n+        &mut self,\n+        origin: SubregionOrigin<'tcx>,\n+        a: ty::Region<'tcx>,\n+        b: ty::Region<'tcx>,\n+    );\n+\n+    fn push_verify(\n+        &mut self,\n+        origin: SubregionOrigin<'tcx>,\n+        kind: GenericKind<'tcx>,\n+        a: ty::Region<'tcx>,\n+        bound: VerifyBound<'tcx>,\n+    );\n+}\n+\n+impl<'cx, 'gcx, 'tcx, D> TypeOutlives<'cx, 'gcx, 'tcx, D>\n+where\n+    D: TypeOutlivesDelegate<'tcx>,\n+{\n     fn new(\n-        infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+        delegate: D,\n+        tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n         region_bound_pairs: &'cx [(ty::Region<'tcx>, GenericKind<'tcx>)],\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Self {\n         Self {\n-            infcx,\n+            delegate,\n+            tcx,\n             region_bound_pairs,\n             implicit_region_bound,\n             param_env,\n@@ -234,7 +275,7 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n     /// - `ty`, the type `T`\n     /// - `region`, the region `'a`\n     fn type_must_outlive(\n-        &self,\n+        &mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n         ty: Ty<'tcx>,\n         region: ty::Region<'tcx>,\n@@ -246,16 +287,12 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n \n         assert!(!ty.has_escaping_regions());\n \n-        let components = self.tcx().outlives_components(ty);\n+        let components = self.tcx.outlives_components(ty);\n         self.components_must_outlive(origin, components, region);\n     }\n \n-    fn tcx(&self) -> TyCtxt<'cx, 'gcx, 'tcx> {\n-        self.infcx.tcx\n-    }\n-\n     fn components_must_outlive(\n-        &self,\n+        &mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n         components: Vec<Component<'tcx>>,\n         region: ty::Region<'tcx>,\n@@ -264,7 +301,7 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n             let origin = origin.clone();\n             match component {\n                 Component::Region(region1) => {\n-                    self.infcx.sub_regions(origin, region, region1);\n+                    self.delegate.push_sub_region_constraint(origin, region, region1);\n                 }\n                 Component::Param(param_ty) => {\n                     self.param_ty_must_outlive(origin, region, param_ty);\n@@ -279,7 +316,7 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n                     // ignore this, we presume it will yield an error\n                     // later, since if a type variable is not resolved by\n                     // this point it never will be\n-                    self.infcx.tcx.sess.delay_span_bug(\n+                    self.tcx.sess.delay_span_bug(\n                         origin.span(),\n                         &format!(\"unresolved inference variable in outlives: {:?}\", v),\n                     );\n@@ -289,7 +326,7 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n     }\n \n     fn param_ty_must_outlive(\n-        &self,\n+        &mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n         region: ty::Region<'tcx>,\n         param_ty: ty::ParamTy,\n@@ -301,12 +338,12 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n \n         let verify_bound = self.param_bound(param_ty);\n         let generic = GenericKind::Param(param_ty);\n-        self.infcx\n-            .verify_generic_bound(origin, generic, region, verify_bound);\n+        self.delegate\n+            .push_verify(origin, generic, region, verify_bound);\n     }\n \n     fn projection_must_outlive(\n-        &self,\n+        &mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n         region: ty::Region<'tcx>,\n         projection_ty: ty::ProjectionTy<'tcx>,\n@@ -367,7 +404,7 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n             }\n \n             for r in projection_ty.substs.regions() {\n-                self.infcx.sub_regions(origin.clone(), region, r);\n+                self.delegate.push_sub_region_constraint(origin.clone(), region, r);\n             }\n \n             return;\n@@ -393,7 +430,8 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n                 .any(|r| env_bounds.contains(&r))\n             {\n                 debug!(\"projection_must_outlive: unique declared bound appears in trait ref\");\n-                self.infcx.sub_regions(origin.clone(), region, unique_bound);\n+                self.delegate\n+                    .push_sub_region_constraint(origin.clone(), region, unique_bound);\n                 return;\n             }\n         }\n@@ -405,8 +443,8 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n         // even though a satisfactory solution exists.\n         let verify_bound = self.projection_bound(env_bounds, projection_ty);\n         let generic = GenericKind::Projection(projection_ty);\n-        self.infcx\n-            .verify_generic_bound(origin, generic.clone(), region, verify_bound);\n+        self.delegate\n+            .push_verify(origin, generic.clone(), region, verify_bound);\n     }\n \n     fn type_bound(&self, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n@@ -459,7 +497,6 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n \n         // see the extensive comment in projection_must_outlive\n         let ty = self\n-            .infcx\n             .tcx\n             .mk_projection(projection_ty.item_def_id, projection_ty.substs);\n         let recursive_bound = self.recursive_type_bound(ty);\n@@ -492,7 +529,7 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n         &self,\n         generic: GenericKind<'tcx>,\n     ) -> Vec<ty::Region<'tcx>> {\n-        let tcx = self.tcx();\n+        let tcx = self.tcx;\n \n         // To start, collect bounds from user environment. Note that\n         // parameter environments are already elaborated, so we don't\n@@ -544,7 +581,7 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n         debug!(\"projection_bounds(projection_ty={:?})\", projection_ty);\n         let mut bounds = self.region_bounds_declared_on_associated_item(projection_ty.item_def_id);\n         for r in &mut bounds {\n-            *r = r.subst(self.tcx(), projection_ty.substs);\n+            *r = r.subst(self.tcx, projection_ty.substs);\n         }\n         bounds\n     }\n@@ -583,7 +620,7 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n         &self,\n         assoc_item_def_id: DefId,\n     ) -> Vec<ty::Region<'tcx>> {\n-        let tcx = self.tcx();\n+        let tcx = self.tcx;\n         let assoc_item = tcx.associated_item(assoc_item_def_id);\n         let trait_def_id = assoc_item.container.assert_trait();\n         let trait_predicates = tcx.predicates_of(trait_def_id);\n@@ -619,3 +656,25 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n             .collect()\n     }\n }\n+\n+impl<'cx, 'gcx, 'tcx> TypeOutlivesDelegate<'tcx> for &'cx InferCtxt<'cx, 'gcx, 'tcx> {\n+    fn push_sub_region_constraint(\n+        &mut self,\n+        origin: SubregionOrigin<'tcx>,\n+        a: ty::Region<'tcx>,\n+        b: ty::Region<'tcx>,\n+    ) {\n+        self.sub_regions(origin, a, b)\n+    }\n+\n+    fn push_verify(\n+        &mut self,\n+        origin: SubregionOrigin<'tcx>,\n+        kind: GenericKind<'tcx>,\n+        a: ty::Region<'tcx>,\n+        bound: VerifyBound<'tcx>,\n+    ) {\n+        self.verify_generic_bound(origin, kind, a, bound)\n+    }\n+}\n+"}]}