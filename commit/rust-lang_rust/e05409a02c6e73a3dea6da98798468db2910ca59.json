{"sha": "e05409a02c6e73a3dea6da98798468db2910ca59", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwNTQwOWEwMmM2ZTczYTNkZWE2ZGE5ODc5ODQ2OGRiMjkxMGNhNTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-20T04:10:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-20T04:10:36Z"}, "message": "Auto merge of #81063 - CraftSpider:jsondocck, r=jyn514\n\nAdd JsonDocCk Tool for rustdoc-json\n\nImplements a new test system for rustdoc JSON output, jsondocck. Modeled after htmldocck, this tool reads directives in the test file and checks them against the output. These directives use JSONPath, a pair to XPath for json. This obsoletes the old strict subset tool, allowing both finer-grained control of what is tested and better errors on failure.\n\nNot sure on the changes to Cargo.lock, I can back that out if needed.\n\nr? `@jyn514`", "tree": {"sha": "4c849cdc74529ddc0c66658320e92de9161e38c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c849cdc74529ddc0c66658320e92de9161e38c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e05409a02c6e73a3dea6da98798468db2910ca59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e05409a02c6e73a3dea6da98798468db2910ca59", "html_url": "https://github.com/rust-lang/rust/commit/e05409a02c6e73a3dea6da98798468db2910ca59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e05409a02c6e73a3dea6da98798468db2910ca59/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14265f9c5558e599ba8908cffc717f26389420e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/14265f9c5558e599ba8908cffc717f26389420e1", "html_url": "https://github.com/rust-lang/rust/commit/14265f9c5558e599ba8908cffc717f26389420e1"}, {"sha": "ba6803e6b4f397c6e13e58595b6f1f7ef7c4a00a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba6803e6b4f397c6e13e58595b6f1f7ef7c4a00a", "html_url": "https://github.com/rust-lang/rust/commit/ba6803e6b4f397c6e13e58595b6f1f7ef7c4a00a"}], "stats": {"total": 1320, "additions": 504, "deletions": 816}, "files": [{"sha": "b2ae22b6abd9b8762b5ab4603cfc1d8271a5c949", "filename": "Cargo.lock", "status": "modified", "additions": 37, "deletions": 4, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e05409a02c6e73a3dea6da98798468db2910ca59/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e05409a02c6e73a3dea6da98798468db2910ca59/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e05409a02c6e73a3dea6da98798468db2910ca59", "patch": "@@ -101,6 +101,12 @@ version = \"0.4.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"4d25d88fd6b8041580a654f9d0c581a047baee2b3efee13275f2fc392fc75034\"\n \n+[[package]]\n+name = \"array_tool\"\n+version = \"1.0.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8f8cb5d814eb646a863c4f24978cff2880c4be96ad8cde2c0f0678732902e271\"\n+\n [[package]]\n name = \"arrayref\"\n version = \"0.3.6\"\n@@ -1630,6 +1636,32 @@ version = \"0.11.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"92c245af8786f6ac35f95ca14feca9119e71339aaab41e878e7cdd655c97e9e5\"\n \n+[[package]]\n+name = \"jsondocck\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"getopts\",\n+ \"jsonpath_lib\",\n+ \"lazy_static\",\n+ \"regex\",\n+ \"serde\",\n+ \"serde_json\",\n+ \"shlex\",\n+]\n+\n+[[package]]\n+name = \"jsonpath_lib\"\n+version = \"0.2.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"61352ec23883402b7d30b3313c16cbabefb8907361c4eb669d990cbb87ceee5a\"\n+dependencies = [\n+ \"array_tool\",\n+ \"env_logger 0.7.1\",\n+ \"log\",\n+ \"serde\",\n+ \"serde_json\",\n+]\n+\n [[package]]\n name = \"jsonrpc-client-transports\"\n version = \"14.2.1\"\n@@ -2854,9 +2886,9 @@ dependencies = [\n \n [[package]]\n name = \"regex\"\n-version = \"1.3.9\"\n+version = \"1.4.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9c3780fcf44b193bc4d09f36d2a3c87b251da4a046c87795a0d35f4f927ad8e6\"\n+checksum = \"d9251239e129e16308e70d853559389de218ac275b515068abc96829d05b948a\"\n dependencies = [\n  \"aho-corasick\",\n  \"memchr\",\n@@ -2876,9 +2908,9 @@ dependencies = [\n \n [[package]]\n name = \"regex-syntax\"\n-version = \"0.6.18\"\n+version = \"0.6.22\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"26412eb97c6b088a6997e05f69403a802a92d520de2f8e63c2b65f9e0f47c4e8\"\n+checksum = \"b5eb417147ba9860a96cfe72a0b93bf88fee1744b5636ec99ab20c1aa9376581\"\n \n [[package]]\n name = \"remote-test-client\"\n@@ -4578,6 +4610,7 @@ version = \"1.0.59\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"dcac07dbffa1c65e7f816ab9eba78eb142c6d44410f4eeba1e26e4f5dfa56b95\"\n dependencies = [\n+ \"indexmap\",\n  \"itoa\",\n  \"ryu\",\n  \"serde\","}, {"sha": "5bd1147cad55425b693b4118e5326cb210e8ab29", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e05409a02c6e73a3dea6da98798468db2910ca59/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e05409a02c6e73a3dea6da98798468db2910ca59/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=e05409a02c6e73a3dea6da98798468db2910ca59", "patch": "@@ -31,6 +31,7 @@ members = [\n   \"src/tools/rustdoc-themes\",\n   \"src/tools/unicode-table-generator\",\n   \"src/tools/expand-yaml-anchors\",\n+  \"src/tools/jsondocck\",\n ]\n \n exclude = ["}, {"sha": "335a173100290f45306b5d5edad7dab95cb17ea1", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=e05409a02c6e73a3dea6da98798468db2910ca59", "patch": "@@ -1011,6 +1011,13 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n             cmd.arg(\"--rustdoc-path\").arg(builder.rustdoc(compiler));\n         }\n \n+        if mode == \"rustdoc-json\" {\n+            // Use the beta compiler for jsondocck\n+            let json_compiler = compiler.with_stage(0);\n+            cmd.arg(\"--jsondocck-path\")\n+                .arg(builder.ensure(tool::JsonDocCk { compiler: json_compiler, target }));\n+        }\n+\n         if mode == \"run-make\" && suite.ends_with(\"fulldeps\") {\n             cmd.arg(\"--rust-demangler-path\").arg(builder.tool_exe(Tool::RustDemangler));\n         }"}, {"sha": "835b8beb0e7dfea464d65724283d91858b45d120", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=e05409a02c6e73a3dea6da98798468db2910ca59", "patch": "@@ -367,6 +367,7 @@ bootstrap_tool!(\n     RustdocTheme, \"src/tools/rustdoc-themes\", \"rustdoc-themes\";\n     ExpandYamlAnchors, \"src/tools/expand-yaml-anchors\", \"expand-yaml-anchors\";\n     LintDocs, \"src/tools/lint-docs\", \"lint-docs\";\n+    JsonDocCk, \"src/tools/jsondocck\", \"jsondocck\";\n );\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, Ord, PartialOrd)]"}, {"sha": "c7ca0134f9ce16de61fa622dd347a2342d5fdffa", "filename": "src/etc/check_missing_items.py", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Fetc%2Fcheck_missing_items.py", "raw_url": "https://github.com/rust-lang/rust/raw/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Fetc%2Fcheck_missing_items.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcheck_missing_items.py?ref=e05409a02c6e73a3dea6da98798468db2910ca59", "patch": "@@ -4,6 +4,8 @@\n # `index` or `paths`. It DOES NOT check that the structure of the produced json is actually in\n # any way correct, for example an empty map would pass.\n \n+# FIXME: Better error output\n+\n import sys\n import json\n ", "previous_filename": "src/test/rustdoc-json/check_missing_items.py"}, {"sha": "6a921266336e0add8cd8604af5058d8e8530c3ba", "filename": "src/test/rustdoc-json/compare.py", "status": "removed", "additions": 0, "deletions": 132, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/14265f9c5558e599ba8908cffc717f26389420e1/src%2Ftest%2Frustdoc-json%2Fcompare.py", "raw_url": "https://github.com/rust-lang/rust/raw/14265f9c5558e599ba8908cffc717f26389420e1/src%2Ftest%2Frustdoc-json%2Fcompare.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fcompare.py?ref=14265f9c5558e599ba8908cffc717f26389420e1", "patch": "@@ -1,132 +0,0 @@\n-#!/usr/bin/env python\n-\n-# This script can check that an expected json blob is a subset of what actually gets produced.\n-# The comparison is independent of the value of IDs (which are unstable) and instead uses their\n-# relative ordering to check them against eachother by looking them up in their respective blob's\n-# `index` or `paths` mappings. To add a new test run `rustdoc --output-format json -o . yourtest.rs`\n-# and then create `yourtest.expected` by stripping unnecessary details from `yourtest.json`. If\n-# you're on windows, replace `\\` with `/`.\n-\n-# WARNING: The error messages produced by this may be misleading, in the case of list re-ordering\n-#          it may point to apparently unrelated keys.\n-\n-import copy\n-import sys\n-import json\n-import types\n-\n-# Used instead of the string ids when used as references.\n-# Not used as keys in `index` or `paths`\n-class ID(str):\n-    pass\n-\n-\n-class SubsetException(Exception):\n-    def __init__(self, msg, trace):\n-        self.msg = msg\n-        self.trace = msg\n-        super().__init__(\"{}: {}\".format(trace, msg))\n-\n-\n-def check_subset(expected_main, actual_main, base_dir):\n-    expected_index = expected_main[\"index\"]\n-    expected_paths = expected_main[\"paths\"]\n-    actual_index = actual_main[\"index\"]\n-    actual_paths = actual_main[\"paths\"]\n-    already_checked = set()\n-\n-    def _check_subset(expected, actual, trace):\n-        expected_type = type(expected)\n-        actual_type = type(actual)\n-\n-        if actual_type is str:\n-            actual = normalize(actual).replace(base_dir, \"$TEST_BASE_DIR\")\n-\n-        if expected_type is not actual_type:\n-            raise SubsetException(\n-                \"expected type `{}`, got `{}`\".format(expected_type, actual_type), trace\n-            )\n-\n-\n-        if expected_type in (int, bool, str) and expected != actual:\n-            raise SubsetException(\"expected `{}`, got: `{}`\".format(expected, actual), trace)\n-        if expected_type is dict:\n-            for key in expected:\n-                if key not in actual:\n-                    raise SubsetException(\n-                        \"Key `{}` not found in output\".format(key), trace\n-                    )\n-                new_trace = copy.deepcopy(trace)\n-                new_trace.append(key)\n-                _check_subset(expected[key], actual[key], new_trace)\n-        elif expected_type is list:\n-            expected_elements = len(expected)\n-            actual_elements = len(actual)\n-            if expected_elements != actual_elements:\n-                raise SubsetException(\n-                    \"Found {} items, expected {}\".format(\n-                        expected_elements, actual_elements\n-                    ),\n-                    trace,\n-                )\n-            for expected, actual in zip(expected, actual):\n-                new_trace = copy.deepcopy(trace)\n-                new_trace.append(expected)\n-                _check_subset(expected, actual, new_trace)\n-        elif expected_type is ID and expected not in already_checked:\n-            already_checked.add(expected)\n-            _check_subset(\n-                expected_index.get(expected, {}), actual_index.get(actual, {}), trace\n-            )\n-            _check_subset(\n-                expected_paths.get(expected, {}), actual_paths.get(actual, {}), trace\n-            )\n-\n-    _check_subset(expected_main[\"root\"], actual_main[\"root\"], [])\n-\n-\n-def rustdoc_object_hook(obj):\n-    # No need to convert paths, index and external_crates keys to ids, since\n-    # they are the target of resolution, and never a source itself.\n-    if \"id\" in obj and obj[\"id\"]:\n-        obj[\"id\"] = ID(obj[\"id\"])\n-    if \"root\" in obj:\n-        obj[\"root\"] = ID(obj[\"root\"])\n-    if \"items\" in obj:\n-        obj[\"items\"] = [ID(id) for id in obj[\"items\"]]\n-    if \"variants\" in obj:\n-        obj[\"variants\"] = [ID(id) for id in obj[\"variants\"]]\n-    if \"fields\" in obj:\n-        obj[\"fields\"] = [ID(id) for id in obj[\"fields\"]]\n-    if \"impls\" in obj:\n-        obj[\"impls\"] = [ID(id) for id in obj[\"impls\"]]\n-    if \"implementors\" in obj:\n-        obj[\"implementors\"] = [ID(id) for id in obj[\"implementors\"]]\n-    if \"links\" in obj:\n-        obj[\"links\"] = {s: ID(id) for s, id in obj[\"links\"]}\n-    if \"variant_kind\" in obj and obj[\"variant_kind\"] == \"struct\":\n-        obj[\"variant_inner\"] = [ID(id) for id in obj[\"variant_inner\"]]\n-    return obj\n-\n-\n-def main(expected_fpath, actual_fpath, base_dir):\n-    print(\n-        \"checking that {} is a logical subset of {}\".format(\n-            expected_fpath, actual_fpath\n-        )\n-    )\n-    with open(expected_fpath) as expected_file:\n-        expected_main = json.load(expected_file, object_hook=rustdoc_object_hook)\n-    with open(actual_fpath) as actual_file:\n-        actual_main = json.load(actual_file, object_hook=rustdoc_object_hook)\n-    check_subset(expected_main, actual_main, base_dir)\n-    print(\"all checks passed\")\n-\n-def normalize(s):\n-    return s.replace('\\\\', '/')\n-\n-if __name__ == \"__main__\":\n-    if len(sys.argv) < 4:\n-        print(\"Usage: `compare.py expected.json actual.json test-dir`\")\n-    else:\n-        main(sys.argv[1], sys.argv[2], normalize(sys.argv[3]))"}, {"sha": "80070e75f1e5eae657ae68a5a33495d93bc67abe", "filename": "src/test/rustdoc-json/nested.expected", "status": "removed", "additions": 0, "deletions": 196, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/14265f9c5558e599ba8908cffc717f26389420e1/src%2Ftest%2Frustdoc-json%2Fnested.expected", "raw_url": "https://github.com/rust-lang/rust/raw/14265f9c5558e599ba8908cffc717f26389420e1/src%2Ftest%2Frustdoc-json%2Fnested.expected", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fnested.expected?ref=14265f9c5558e599ba8908cffc717f26389420e1", "patch": "@@ -1,196 +0,0 @@\n-{\n-  \"crate_version\": null,\n-  \"external_crates\": {},\n-  \"format_version\": 1,\n-  \"includes_private\": false,\n-  \"index\": {\n-    \"0:0\": {\n-      \"attrs\": [],\n-      \"crate_id\": 0,\n-      \"deprecation\": null,\n-      \"docs\": \"\",\n-      \"id\": \"0:0\",\n-      \"inner\": {\n-        \"is_crate\": true,\n-        \"items\": [\n-          \"0:3\"\n-        ]\n-      },\n-      \"kind\": \"module\",\n-      \"links\": {},\n-      \"name\": \"nested\",\n-      \"source\": {\n-        \"begin\": [\n-          2,\n-          0\n-        ],\n-        \"end\": [\n-          7,\n-          1\n-        ],\n-        \"filename\": \"$TEST_BASE_DIR/nested.rs\"\n-      },\n-      \"visibility\": \"public\"\n-    },\n-    \"0:3\": {\n-      \"attrs\": [],\n-      \"crate_id\": 0,\n-      \"deprecation\": null,\n-      \"docs\": \"\",\n-      \"id\": \"0:3\",\n-      \"inner\": {\n-        \"is_crate\": false,\n-        \"items\": [\n-          \"0:4\",\n-          \"0:7\"\n-        ]\n-      },\n-      \"kind\": \"module\",\n-      \"links\": {},\n-      \"name\": \"l1\",\n-      \"source\": {\n-        \"begin\": [\n-          2,\n-          0\n-        ],\n-        \"end\": [\n-          7,\n-          1\n-        ],\n-        \"filename\": \"$TEST_BASE_DIR/nested.rs\"\n-      },\n-      \"visibility\": \"public\"\n-    },\n-    \"0:4\": {\n-      \"attrs\": [],\n-      \"crate_id\": 0,\n-      \"deprecation\": null,\n-      \"docs\": \"\",\n-      \"id\": \"0:4\",\n-      \"inner\": {\n-        \"is_crate\": false,\n-        \"items\": [\n-          \"0:5\"\n-        ]\n-      },\n-      \"kind\": \"module\",\n-      \"links\": {},\n-      \"name\": \"l3\",\n-      \"source\": {\n-        \"begin\": [\n-          3,\n-          4\n-        ],\n-        \"end\": [\n-          5,\n-          5\n-        ],\n-        \"filename\": \"$TEST_BASE_DIR/nested.rs\"\n-      },\n-      \"visibility\": \"public\"\n-    },\n-    \"0:5\": {\n-      \"attrs\": [],\n-      \"crate_id\": 0,\n-      \"deprecation\": null,\n-      \"docs\": \"\",\n-      \"id\": \"0:5\",\n-      \"inner\": {\n-        \"fields\": [],\n-        \"fields_stripped\": false,\n-        \"generics\": {\n-          \"params\": [],\n-          \"where_predicates\": []\n-        },\n-        \"impls\": [\n-          \"0:10\",\n-          \"0:11\",\n-          \"0:12\",\n-          \"0:14\",\n-          \"0:15\"\n-        ],\n-        \"struct_type\": \"unit\"\n-      },\n-      \"kind\": \"struct\",\n-      \"links\": {},\n-      \"name\": \"L4\",\n-      \"source\": {\n-        \"begin\": [\n-          4,\n-          8\n-        ],\n-        \"end\": [\n-          4,\n-          22\n-        ],\n-        \"filename\": \"$TEST_BASE_DIR/nested.rs\"\n-      },\n-      \"visibility\": \"public\"\n-    },\n-    \"0:7\": {\n-      \"attrs\": [],\n-      \"crate_id\": 0,\n-      \"deprecation\": null,\n-      \"docs\": \"\",\n-      \"id\": \"0:7\",\n-      \"inner\": {\n-        \"glob\": false,\n-        \"id\": \"0:5\",\n-        \"name\": \"L4\",\n-        \"span\": \"l3::L4\"\n-      },\n-      \"kind\": \"import\",\n-      \"links\": {},\n-      \"name\": null,\n-      \"source\": {\n-        \"begin\": [\n-          6,\n-          4\n-        ],\n-        \"end\": [\n-          6,\n-          19\n-        ],\n-        \"filename\": \"$TEST_BASE_DIR/nested.rs\"\n-      },\n-      \"visibility\": \"public\"\n-    }\n-  },\n-  \"paths\": {\n-    \"0:0\": {\n-      \"crate_id\": 0,\n-      \"kind\": \"module\",\n-      \"path\": [\n-        \"nested\"\n-      ]\n-    },\n-    \"0:3\": {\n-      \"crate_id\": 0,\n-      \"kind\": \"module\",\n-      \"path\": [\n-        \"nested\",\n-        \"l1\"\n-      ]\n-    },\n-    \"0:4\": {\n-      \"crate_id\": 0,\n-      \"kind\": \"module\",\n-      \"path\": [\n-        \"nested\",\n-        \"l1\",\n-        \"l3\"\n-      ]\n-    },\n-    \"0:5\": {\n-      \"crate_id\": 0,\n-      \"kind\": \"struct\",\n-      \"path\": [\n-        \"nested\",\n-        \"l1\",\n-        \"l3\",\n-        \"L4\"\n-      ]\n-    }\n-  },\n-  \"root\": \"0:0\"\n-}\n\\ No newline at end of file"}, {"sha": "7e705255d983d0289606bd55ad3a84798b426404", "filename": "src/test/rustdoc-json/nested.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Ftest%2Frustdoc-json%2Fnested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Ftest%2Frustdoc-json%2Fnested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fnested.rs?ref=e05409a02c6e73a3dea6da98798468db2910ca59", "patch": "@@ -1,7 +1,24 @@\n // edition:2018\n+\n+// @has nested.json \"$.index[*][?(@.name=='nested')].kind\" \\\"module\\\"\n+// @has - \"$.index[*][?(@.name=='nested')].inner.is_crate\" true\n+// @count - \"$.index[*][?(@.name=='nested')].inner.items[*]\" 1\n+\n+// @has nested.json \"$.index[*][?(@.name=='l1')].kind\" \\\"module\\\"\n+// @has - \"$.index[*][?(@.name=='l1')].inner.is_crate\" false\n+// @count - \"$.index[*][?(@.name=='l1')].inner.items[*]\" 2\n pub mod l1 {\n+\n+    // @has nested.json \"$.index[*][?(@.name=='l3')].kind\" \\\"module\\\"\n+    // @has - \"$.index[*][?(@.name=='l3')].inner.is_crate\" false\n+    // @count - \"$.index[*][?(@.name=='l3')].inner.items[*]\" 1\n     pub mod l3 {\n+\n+        // @has nested.json \"$.index[*][?(@.name=='L4')].kind\" \\\"struct\\\"\n+        // @has - \"$.index[*][?(@.name=='L4')].inner.struct_type\" \\\"unit\\\"\n         pub struct L4;\n     }\n+    // @has nested.json \"$.index[*][?(@.inner.span=='l3::L4')].kind\" \\\"import\\\"\n+    // @has - \"$.index[*][?(@.inner.span=='l3::L4')].inner.glob\" false\n     pub use l3::L4;\n }"}, {"sha": "799829de3fd6c9a6a29d52e6a8d90e9b30d24ea4", "filename": "src/test/rustdoc-json/structs.expected", "status": "removed", "additions": 0, "deletions": 456, "changes": 456, "blob_url": "https://github.com/rust-lang/rust/blob/14265f9c5558e599ba8908cffc717f26389420e1/src%2Ftest%2Frustdoc-json%2Fstructs.expected", "raw_url": "https://github.com/rust-lang/rust/raw/14265f9c5558e599ba8908cffc717f26389420e1/src%2Ftest%2Frustdoc-json%2Fstructs.expected", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fstructs.expected?ref=14265f9c5558e599ba8908cffc717f26389420e1", "patch": "@@ -1,456 +0,0 @@\n-{\n-  \"root\": \"0:0\",\n-  \"version\": null,\n-  \"includes_private\": false,\n-  \"index\": {\n-    \"0:9\": {\n-      \"crate_id\": 0,\n-      \"name\": \"Unit\",\n-      \"source\": {\n-        \"filename\": \"$TEST_BASE_DIR/structs.rs\",\n-        \"begin\": [\n-          7,\n-          0\n-        ],\n-        \"end\": [\n-          7,\n-          16\n-        ]\n-      },\n-      \"visibility\": \"public\",\n-      \"docs\": \"\",\n-      \"links\": {},\n-      \"attrs\": [],\n-      \"deprecation\": null,\n-      \"kind\": \"struct\",\n-      \"inner\": {\n-        \"struct_type\": \"unit\",\n-        \"generics\": {\n-          \"params\": [],\n-          \"where_predicates\": []\n-        },\n-        \"fields_stripped\": false,\n-        \"fields\": []\n-      }\n-    },\n-    \"0:8\": {\n-      \"crate_id\": 0,\n-      \"name\": \"1\",\n-      \"source\": {\n-        \"filename\": \"$TEST_BASE_DIR/structs.rs\",\n-        \"begin\": [\n-          5,\n-          22\n-        ],\n-        \"end\": [\n-          5,\n-          28\n-        ]\n-      },\n-      \"visibility\": \"default\",\n-      \"docs\": \"\",\n-      \"links\": {},\n-      \"attrs\": [],\n-      \"deprecation\": null,\n-      \"kind\": \"struct_field\",\n-      \"inner\": {\n-        \"kind\": \"resolved_path\",\n-        \"inner\": {\n-          \"name\": \"String\",\n-          \"id\": \"5:5035\",\n-          \"args\": {\n-            \"angle_bracketed\": {\n-              \"args\": [],\n-              \"bindings\": []\n-            }\n-          },\n-          \"param_names\": []\n-        }\n-      }\n-    },\n-    \"0:18\": {\n-      \"crate_id\": 0,\n-      \"name\": \"stuff\",\n-      \"source\": {\n-        \"filename\": \"$TEST_BASE_DIR/structs.rs\",\n-        \"begin\": [\n-          15,\n-          4\n-        ],\n-        \"end\": [\n-          15,\n-          17\n-        ]\n-      },\n-      \"visibility\": \"default\",\n-      \"docs\": \"\",\n-      \"links\": {},\n-      \"attrs\": [],\n-      \"deprecation\": null,\n-      \"kind\": \"struct_field\",\n-      \"inner\": {\n-        \"kind\": \"resolved_path\",\n-        \"inner\": {\n-          \"name\": \"Vec\",\n-          \"id\": \"5:4322\",\n-          \"args\": {\n-            \"angle_bracketed\": {\n-              \"args\": [\n-                {\n-                  \"type\": {\n-                    \"kind\": \"generic\",\n-                    \"inner\": \"T\"\n-                  }\n-                }\n-              ],\n-              \"bindings\": []\n-            }\n-          },\n-          \"param_names\": []\n-        }\n-      }\n-    },\n-    \"0:11\": {\n-      \"crate_id\": 0,\n-      \"name\": \"WithPrimitives\",\n-      \"source\": {\n-        \"filename\": \"$TEST_BASE_DIR/structs.rs\",\n-        \"begin\": [\n-          9,\n-          0\n-        ],\n-        \"end\": [\n-          12,\n-          1\n-        ]\n-      },\n-      \"visibility\": \"public\",\n-      \"docs\": \"\",\n-      \"links\": {},\n-      \"attrs\": [],\n-      \"deprecation\": null,\n-      \"kind\": \"struct\",\n-      \"inner\": {\n-        \"struct_type\": \"plain\",\n-        \"generics\": {\n-          \"params\": [\n-            {\n-              \"name\": \"'a\",\n-              \"kind\": \"lifetime\"\n-            }\n-          ],\n-          \"where_predicates\": []\n-        },\n-        \"fields_stripped\": true\n-      }\n-    },\n-    \"0:14\": {\n-      \"crate_id\": 0,\n-      \"name\": \"s\",\n-      \"source\": {\n-        \"filename\": \"$TEST_BASE_DIR/structs.rs\",\n-        \"begin\": [\n-          11,\n-          4\n-        ],\n-        \"end\": [\n-          11,\n-          14\n-        ]\n-      },\n-      \"visibility\": \"default\",\n-      \"docs\": \"\",\n-      \"links\": {},\n-      \"attrs\": [],\n-      \"deprecation\": null,\n-      \"kind\": \"struct_field\",\n-      \"inner\": {\n-        \"kind\": \"borrowed_ref\",\n-        \"inner\": {\n-          \"lifetime\": \"'a\",\n-          \"mutable\": false,\n-          \"type\": {\n-            \"kind\": \"primitive\",\n-            \"inner\": \"str\"\n-          }\n-        }\n-      }\n-    },\n-    \"0:19\": {\n-      \"crate_id\": 0,\n-      \"name\": \"things\",\n-      \"source\": {\n-        \"filename\": \"$TEST_BASE_DIR/structs.rs\",\n-        \"begin\": [\n-          16,\n-          4\n-        ],\n-        \"end\": [\n-          16,\n-          25\n-        ]\n-      },\n-      \"visibility\": \"default\",\n-      \"docs\": \"\",\n-      \"links\": {},\n-      \"attrs\": [],\n-      \"deprecation\": null,\n-      \"kind\": \"struct_field\",\n-      \"inner\": {\n-        \"kind\": \"resolved_path\",\n-        \"inner\": {\n-          \"name\": \"HashMap\",\n-          \"id\": \"1:6600\",\n-          \"args\": {\n-            \"angle_bracketed\": {\n-              \"args\": [\n-                {\n-                  \"type\": {\n-                    \"kind\": \"generic\",\n-                    \"inner\": \"U\"\n-                  }\n-                },\n-                {\n-                  \"type\": {\n-                    \"kind\": \"generic\",\n-                    \"inner\": \"U\"\n-                  }\n-                }\n-              ],\n-              \"bindings\": []\n-            }\n-          },\n-          \"param_names\": []\n-        }\n-      }\n-    },\n-    \"0:15\": {\n-      \"crate_id\": 0,\n-      \"name\": \"WithGenerics\",\n-      \"source\": {\n-        \"filename\": \"$TEST_BASE_DIR/structs.rs\",\n-        \"begin\": [\n-          14,\n-          0\n-        ],\n-        \"end\": [\n-          17,\n-          1\n-        ]\n-      },\n-      \"visibility\": \"public\",\n-      \"docs\": \"\",\n-      \"links\": {},\n-      \"attrs\": [],\n-      \"deprecation\": null,\n-      \"kind\": \"struct\",\n-      \"inner\": {\n-        \"struct_type\": \"plain\",\n-        \"generics\": {\n-          \"params\": [\n-            {\n-              \"name\": \"T\",\n-              \"kind\": {\n-                \"type\": {\n-                  \"bounds\": [],\n-                  \"default\": null\n-                }\n-              }\n-            },\n-            {\n-              \"name\": \"U\",\n-              \"kind\": {\n-                \"type\": {\n-                  \"bounds\": [],\n-                  \"default\": null\n-                }\n-              }\n-            }\n-          ],\n-          \"where_predicates\": []\n-        },\n-        \"fields_stripped\": true\n-      }\n-    },\n-    \"0:0\": {\n-      \"crate_id\": 0,\n-      \"name\": \"structs\",\n-      \"source\": {\n-        \"filename\": \"$TEST_BASE_DIR/structs.rs\",\n-        \"begin\": [\n-          1,\n-          0\n-        ],\n-        \"end\": [\n-          17,\n-          1\n-        ]\n-      },\n-      \"visibility\": \"public\",\n-      \"docs\": \"\",\n-      \"links\": {},\n-      \"attrs\": [],\n-      \"deprecation\": null,\n-      \"kind\": \"module\",\n-      \"inner\": {\n-        \"is_crate\": true,\n-        \"items\": [\n-          \"0:4\",\n-          \"0:5\",\n-          \"0:9\",\n-          \"0:11\",\n-          \"0:15\"\n-        ]\n-      }\n-    },\n-    \"0:13\": {\n-      \"crate_id\": 0,\n-      \"name\": \"num\",\n-      \"source\": {\n-        \"filename\": \"$TEST_BASE_DIR/structs.rs\",\n-        \"begin\": [\n-          10,\n-          4\n-        ],\n-        \"end\": [\n-          10,\n-          12\n-        ]\n-      },\n-      \"visibility\": \"default\",\n-      \"docs\": \"\",\n-      \"links\": {},\n-      \"attrs\": [],\n-      \"deprecation\": null,\n-      \"kind\": \"struct_field\",\n-      \"inner\": {\n-        \"kind\": \"primitive\",\n-        \"inner\": \"u32\"\n-      }\n-    },\n-    \"0:5\": {\n-      \"crate_id\": 0,\n-      \"name\": \"Tuple\",\n-      \"source\": {\n-        \"filename\": \"$TEST_BASE_DIR/structs.rs\",\n-        \"begin\": [\n-          5,\n-          0\n-        ],\n-        \"end\": [\n-          5,\n-          30\n-        ]\n-      },\n-      \"visibility\": \"public\",\n-      \"docs\": \"\",\n-      \"links\": {},\n-      \"attrs\": [],\n-      \"deprecation\": null,\n-      \"kind\": \"struct\",\n-      \"inner\": {\n-        \"struct_type\": \"tuple\",\n-        \"generics\": {\n-          \"params\": [],\n-          \"where_predicates\": []\n-        },\n-        \"fields_stripped\": true\n-      }\n-    },\n-    \"0:4\": {\n-      \"crate_id\": 0,\n-      \"name\": \"PlainEmpty\",\n-      \"source\": {\n-        \"filename\": \"$TEST_BASE_DIR/structs.rs\",\n-        \"begin\": [\n-          3,\n-          0\n-        ],\n-        \"end\": [\n-          3,\n-          24\n-        ]\n-      },\n-      \"visibility\": \"public\",\n-      \"docs\": \"\",\n-      \"links\": {},\n-      \"attrs\": [],\n-      \"deprecation\": null,\n-      \"kind\": \"struct\",\n-      \"inner\": {\n-        \"struct_type\": \"plain\",\n-        \"generics\": {\n-          \"params\": [],\n-          \"where_predicates\": []\n-        },\n-        \"fields_stripped\": false,\n-        \"fields\": []\n-      }\n-    },\n-    \"0:7\": {\n-      \"crate_id\": 0,\n-      \"name\": \"0\",\n-      \"source\": {\n-        \"filename\": \"$TEST_BASE_DIR/structs.rs\",\n-        \"begin\": [\n-          5,\n-          17\n-        ],\n-        \"end\": [\n-          5,\n-          20\n-        ]\n-      },\n-      \"visibility\": \"default\",\n-      \"docs\": \"\",\n-      \"links\": {},\n-      \"attrs\": [],\n-      \"deprecation\": null,\n-      \"kind\": \"struct_field\",\n-      \"inner\": {\n-        \"kind\": \"primitive\",\n-        \"inner\": \"u32\"\n-      }\n-    }\n-  },\n-  \"paths\": {\n-    \"5:4322\": {\n-      \"crate_id\": 5,\n-      \"path\": [\n-        \"alloc\",\n-        \"vec\",\n-        \"Vec\"\n-      ],\n-      \"kind\": \"struct\"\n-    },\n-    \"5:5035\": {\n-      \"crate_id\": 5,\n-      \"path\": [\n-        \"alloc\",\n-        \"string\",\n-        \"String\"\n-      ],\n-      \"kind\": \"struct\"\n-    },\n-    \"1:6600\": {\n-      \"crate_id\": 1,\n-      \"path\": [\n-        \"std\",\n-        \"collections\",\n-        \"hash\",\n-        \"map\",\n-        \"HashMap\"\n-      ],\n-      \"kind\": \"struct\"\n-    }\n-  },\n-  \"external_crates\": {\n-    \"1\": {\n-      \"name\": \"std\"\n-    },\n-    \"5\": {\n-      \"name\": \"alloc\"\n-    }\n-  },\n-  \"format_version\": 1\n-}"}, {"sha": "43fc4743503aa5348f02b06a042ae7de7fc91200", "filename": "src/test/rustdoc-json/structs.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/14265f9c5558e599ba8908cffc717f26389420e1/src%2Ftest%2Frustdoc-json%2Fstructs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14265f9c5558e599ba8908cffc717f26389420e1/src%2Ftest%2Frustdoc-json%2Fstructs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fstructs.rs?ref=14265f9c5558e599ba8908cffc717f26389420e1", "patch": "@@ -1,17 +0,0 @@\n-use std::collections::HashMap;\n-\n-pub struct PlainEmpty {}\n-\n-pub struct Tuple(u32, String);\n-\n-pub struct Unit;\n-\n-pub struct WithPrimitives<'a> {\n-    num: u32,\n-    s: &'a str,\n-}\n-\n-pub struct WithGenerics<T, U> {\n-    stuff: Vec<T>,\n-    things: HashMap<U, U>,\n-}"}, {"sha": "a251caf4ba93388a7aa1e24bd43ebdbd838eb25a", "filename": "src/test/rustdoc-json/structs/plain_empty.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Ftest%2Frustdoc-json%2Fstructs%2Fplain_empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Ftest%2Frustdoc-json%2Fstructs%2Fplain_empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fstructs%2Fplain_empty.rs?ref=e05409a02c6e73a3dea6da98798468db2910ca59", "patch": "@@ -0,0 +1,6 @@\n+// @has plain_empty.json \"$.index[*][?(@.name=='PlainEmpty')].visibility\" \\\"public\\\"\n+// @has - \"$.index[*][?(@.name=='PlainEmpty')].kind\" \\\"struct\\\"\n+// @has - \"$.index[*][?(@.name=='PlainEmpty')].inner.struct_type\" \\\"plain\\\"\n+// @has - \"$.index[*][?(@.name=='PlainEmpty')].inner.fields_stripped\" false\n+// @has - \"$.index[*][?(@.name=='PlainEmpty')].inner.fields\" []\n+pub struct PlainEmpty {}"}, {"sha": "4e510b3982507f5cdbe4c4e2f7110fd8e8da25d7", "filename": "src/test/rustdoc-json/structs/tuple.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Ftest%2Frustdoc-json%2Fstructs%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Ftest%2Frustdoc-json%2Fstructs%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fstructs%2Ftuple.rs?ref=e05409a02c6e73a3dea6da98798468db2910ca59", "patch": "@@ -0,0 +1,5 @@\n+// @has tuple.json \"$.index[*][?(@.name=='Tuple')].visibility\" \\\"public\\\"\n+// @has - \"$.index[*][?(@.name=='Tuple')].kind\" \\\"struct\\\"\n+// @has - \"$.index[*][?(@.name=='Tuple')].inner.struct_type\" \\\"tuple\\\"\n+// @has - \"$.index[*][?(@.name=='Tuple')].inner.fields_stripped\" true\n+pub struct Tuple(u32, String);"}, {"sha": "559d3068de6e4e3a0b72e83e9f82dfbca47bd4d2", "filename": "src/test/rustdoc-json/structs/unit.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Ftest%2Frustdoc-json%2Fstructs%2Funit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Ftest%2Frustdoc-json%2Fstructs%2Funit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fstructs%2Funit.rs?ref=e05409a02c6e73a3dea6da98798468db2910ca59", "patch": "@@ -0,0 +1,5 @@\n+// @has unit.json \"$.index[*][?(@.name=='Unit')].visibility\" \\\"public\\\"\n+// @has - \"$.index[*][?(@.name=='Unit')].kind\" \\\"struct\\\"\n+// @has - \"$.index[*][?(@.name=='Unit')].inner.struct_type\" \\\"unit\\\"\n+// @has - \"$.index[*][?(@.name=='Unit')].inner.fields\" []\n+pub struct Unit;"}, {"sha": "65cfe7effa5f1f6e2c8ba328cfcc9c5a74d43b1a", "filename": "src/test/rustdoc-json/structs/with_generics.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Ftest%2Frustdoc-json%2Fstructs%2Fwith_generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Ftest%2Frustdoc-json%2Fstructs%2Fwith_generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fstructs%2Fwith_generics.rs?ref=e05409a02c6e73a3dea6da98798468db2910ca59", "patch": "@@ -0,0 +1,14 @@\n+use std::collections::HashMap;\n+\n+// @has with_generics.json \"$.index[*][?(@.name=='WithGenerics')].visibility\" \\\"public\\\"\n+// @has - \"$.index[*][?(@.name=='WithGenerics')].kind\" \\\"struct\\\"\n+// @has - \"$.index[*][?(@.name=='WithGenerics')].inner.generics.params[0].name\" \\\"T\\\"\n+// @has - \"$.index[*][?(@.name=='WithGenerics')].inner.generics.params[0].kind.type\"\n+// @has - \"$.index[*][?(@.name=='WithGenerics')].inner.generics.params[1].name\" \\\"U\\\"\n+// @has - \"$.index[*][?(@.name=='WithGenerics')].inner.generics.params[1].kind.type\"\n+// @has - \"$.index[*][?(@.name=='WithGenerics')].inner.struct_type\" \\\"plain\\\"\n+// @has - \"$.index[*][?(@.name=='WithGenerics')].inner.fields_stripped\" true\n+pub struct WithGenerics<T, U> {\n+    stuff: Vec<T>,\n+    things: HashMap<U, U>,\n+}"}, {"sha": "ea98676863b5eed119ef38cd56561bb9950b02ea", "filename": "src/test/rustdoc-json/structs/with_primitives.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Ftest%2Frustdoc-json%2Fstructs%2Fwith_primitives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Ftest%2Frustdoc-json%2Fstructs%2Fwith_primitives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fstructs%2Fwith_primitives.rs?ref=e05409a02c6e73a3dea6da98798468db2910ca59", "patch": "@@ -0,0 +1,10 @@\n+// @has with_primitives.json \"$.index[*][?(@.name=='WithPrimitives')].visibility\" \\\"public\\\"\n+// @has - \"$.index[*][?(@.name=='WithPrimitives')].kind\" \\\"struct\\\"\n+// @has - \"$.index[*][?(@.name=='WithPrimitives')].inner.generics.params[0].name\" \\\"\\'a\\\"\n+// @has - \"$.index[*][?(@.name=='WithPrimitives')].inner.generics.params[0].kind\" \\\"lifetime\\\"\n+// @has - \"$.index[*][?(@.name=='WithPrimitives')].inner.struct_type\" \\\"plain\\\"\n+// @has - \"$.index[*][?(@.name=='WithPrimitives')].inner.fields_stripped\" true\n+pub struct WithPrimitives<'a> {\n+    num: u32,\n+    s: &'a str,\n+}"}, {"sha": "5424889a8388bf4cacbf82e046f81608aa89c0cb", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=e05409a02c6e73a3dea6da98798468db2910ca59", "patch": "@@ -198,6 +198,9 @@ pub struct Config {\n     /// The Python executable to use for htmldocck.\n     pub docck_python: String,\n \n+    /// The jsondocck executable.\n+    pub jsondocck_path: Option<String>,\n+\n     /// The LLVM `FileCheck` binary path.\n     pub llvm_filecheck: Option<PathBuf>,\n "}, {"sha": "ec99fde0df9c2f03e3f2955bb03d9375cf05a8c4", "filename": "src/tools/compiletest/src/header/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Ftests.rs?ref=e05409a02c6e73a3dea6da98798468db2910ca59", "patch": "@@ -45,6 +45,7 @@ fn config() -> Config {\n         \"--rustc-path=\",\n         \"--lldb-python=\",\n         \"--docck-python=\",\n+        \"--jsondocck-path=\",\n         \"--src-base=\",\n         \"--build-base=\",\n         \"--stage-id=stage2\","}, {"sha": "688cf930033ef6a8d132e3c4b3ad6bf3a6603e38", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=e05409a02c6e73a3dea6da98798468db2910ca59", "patch": "@@ -60,6 +60,7 @@ pub fn parse_config(args: Vec<String>) -> Config {\n         .optopt(\"\", \"rust-demangler-path\", \"path to rust-demangler to use in tests\", \"PATH\")\n         .reqopt(\"\", \"lldb-python\", \"path to python to use for doc tests\", \"PATH\")\n         .reqopt(\"\", \"docck-python\", \"path to python to use for doc tests\", \"PATH\")\n+        .optopt(\"\", \"jsondocck-path\", \"path to jsondocck to use for doc tests\", \"PATH\")\n         .optopt(\"\", \"valgrind-path\", \"path to Valgrind executable for Valgrind tests\", \"PROGRAM\")\n         .optflag(\"\", \"force-valgrind\", \"fail if Valgrind tests cannot be run under Valgrind\")\n         .optopt(\"\", \"run-clang-based-tests-with\", \"path to Clang executable\", \"PATH\")\n@@ -207,6 +208,7 @@ pub fn parse_config(args: Vec<String>) -> Config {\n         rust_demangler_path: matches.opt_str(\"rust-demangler-path\").map(PathBuf::from),\n         lldb_python: matches.opt_str(\"lldb-python\").unwrap(),\n         docck_python: matches.opt_str(\"docck-python\").unwrap(),\n+        jsondocck_path: matches.opt_str(\"jsondocck-path\"),\n         valgrind_path: matches.opt_str(\"valgrind-path\"),\n         force_valgrind: matches.opt_present(\"force-valgrind\"),\n         run_clang_based_tests_with: matches.opt_str(\"run-clang-based-tests-with\"),"}, {"sha": "5608ff98417cdca847c1e1e04432f87de862fc41", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=e05409a02c6e73a3dea6da98798468db2910ca59", "patch": "@@ -2490,27 +2490,27 @@ impl<'test> TestCx<'test> {\n         let mut json_out = out_dir.join(self.testpaths.file.file_stem().unwrap());\n         json_out.set_extension(\"json\");\n         let res = self.cmd2procres(\n-            Command::new(&self.config.docck_python)\n-                .arg(root.join(\"src/test/rustdoc-json/check_missing_items.py\"))\n-                .arg(&json_out),\n+            Command::new(self.config.jsondocck_path.as_ref().unwrap())\n+                .arg(\"--doc-dir\")\n+                .arg(root.join(&out_dir))\n+                .arg(\"--template\")\n+                .arg(&self.testpaths.file),\n         );\n \n         if !res.status.success() {\n-            self.fatal_proc_rec(\"check_missing_items failed!\", &res);\n+            self.fatal_proc_rec(\"jsondocck failed!\", &res)\n         }\n \n-        let mut expected = self.testpaths.file.clone();\n-        expected.set_extension(\"expected\");\n+        let mut json_out = out_dir.join(self.testpaths.file.file_stem().unwrap());\n+        json_out.set_extension(\"json\");\n         let res = self.cmd2procres(\n             Command::new(&self.config.docck_python)\n-                .arg(root.join(\"src/test/rustdoc-json/compare.py\"))\n-                .arg(&expected)\n-                .arg(&json_out)\n-                .arg(&expected.parent().unwrap()),\n+                .arg(root.join(\"src/etc/check_missing_items.py\"))\n+                .arg(&json_out),\n         );\n \n         if !res.status.success() {\n-            self.fatal_proc_rec(\"compare failed!\", &res);\n+            self.fatal_proc_rec(\"check_missing_items failed!\", &res);\n         }\n     }\n "}, {"sha": "97052ef58d6f2d0e7d876bacd375947595ab9540", "filename": "src/tools/jsondocck/Cargo.toml", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Ftools%2Fjsondocck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Ftools%2Fjsondocck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondocck%2FCargo.toml?ref=e05409a02c6e73a3dea6da98798468db2910ca59", "patch": "@@ -0,0 +1,14 @@\n+[package]\n+name = \"jsondocck\"\n+version = \"0.1.0\"\n+authors = [\"Rune Tynan <runetynan@gmail.com>\"]\n+edition = \"2018\"\n+\n+[dependencies]\n+jsonpath_lib = \"0.2\"\n+getopts = \"0.2\"\n+regex = \"1.4\"\n+lazy_static = \"1.4\"\n+shlex = \"0.1\"\n+serde = \"1.0\"\n+serde_json = \"1.0\""}, {"sha": "b742f0eb3ee55c145b3fa482c7db237b6ca0b4a2", "filename": "src/tools/jsondocck/src/cache.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Ftools%2Fjsondocck%2Fsrc%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Ftools%2Fjsondocck%2Fsrc%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondocck%2Fsrc%2Fcache.rs?ref=e05409a02c6e73a3dea6da98798468db2910ca59", "patch": "@@ -0,0 +1,69 @@\n+use crate::error::CkError;\n+use serde_json::Value;\n+use std::collections::HashMap;\n+use std::path::{Path, PathBuf};\n+use std::{fs, io};\n+\n+#[derive(Debug)]\n+pub struct Cache {\n+    root: PathBuf,\n+    files: HashMap<PathBuf, String>,\n+    values: HashMap<PathBuf, Value>,\n+    last_path: Option<PathBuf>,\n+}\n+\n+impl Cache {\n+    /// Create a new cache, used to read files only once and otherwise store their contents.\n+    pub fn new(doc_dir: &str) -> Cache {\n+        Cache {\n+            root: Path::new(doc_dir).to_owned(),\n+            files: HashMap::new(),\n+            values: HashMap::new(),\n+            last_path: None,\n+        }\n+    }\n+\n+    fn resolve_path(&mut self, path: &String) -> PathBuf {\n+        if path != \"-\" {\n+            let resolve = self.root.join(path);\n+            self.last_path = Some(resolve.clone());\n+            resolve\n+        } else {\n+            self.last_path.as_ref().unwrap().clone()\n+        }\n+    }\n+\n+    fn read_file(&mut self, path: PathBuf) -> Result<String, io::Error> {\n+        if let Some(f) = self.files.get(&path) {\n+            return Ok(f.clone());\n+        }\n+\n+        let file = fs::read_to_string(&path)?;\n+\n+        self.files.insert(path, file.clone());\n+\n+        Ok(file)\n+    }\n+\n+    /// Get the text from a file. If called multiple times, the file will only be read once\n+    pub fn get_file(&mut self, path: &String) -> Result<String, io::Error> {\n+        let path = self.resolve_path(path);\n+        self.read_file(path)\n+    }\n+\n+    /// Parse the JSON from a file. If called multiple times, the file will only be read once.\n+    pub fn get_value(&mut self, path: &String) -> Result<Value, CkError> {\n+        let path = self.resolve_path(path);\n+\n+        if let Some(v) = self.values.get(&path) {\n+            return Ok(v.clone());\n+        }\n+\n+        let content = self.read_file(path.clone())?;\n+        let val = serde_json::from_str::<Value>(&content)?;\n+\n+        self.values.insert(path, val.clone());\n+\n+        Ok(val)\n+    }\n+}"}, {"sha": "9b3ba3f3fbe39edc9c1c485a76a901767b6f2f24", "filename": "src/tools/jsondocck/src/config.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Ftools%2Fjsondocck%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Ftools%2Fjsondocck%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondocck%2Fsrc%2Fconfig.rs?ref=e05409a02c6e73a3dea6da98798468db2910ca59", "patch": "@@ -0,0 +1,37 @@\n+use getopts::Options;\n+\n+#[derive(Debug)]\n+pub struct Config {\n+    /// The directory documentation output was generated in\n+    pub doc_dir: String,\n+    /// The file documentation was generated for, with docck commands to check\n+    pub template: String,\n+}\n+\n+/// Create a Config from a vector of command-line arguments\n+pub fn parse_config(args: Vec<String>) -> Config {\n+    let mut opts = Options::new();\n+    opts.reqopt(\"\", \"doc-dir\", \"Path to the documentation directory\", \"PATH\")\n+        .reqopt(\"\", \"template\", \"Path to the template file\", \"PATH\")\n+        .optflag(\"h\", \"help\", \"show this message\");\n+\n+    let (argv0, args_) = args.split_first().unwrap();\n+    if args.len() == 1 {\n+        let message = format!(\"Usage: {} <doc-dir> <template>\", argv0);\n+        println!(\"{}\", opts.usage(&message));\n+        std::process::exit(1);\n+    }\n+\n+    let matches = opts.parse(args_).unwrap();\n+\n+    if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n+        let message = format!(\"Usage: {} <doc-dir> <template>\", argv0);\n+        println!(\"{}\", opts.usage(&message));\n+        std::process::exit(1);\n+    }\n+\n+    Config {\n+        doc_dir: matches.opt_str(\"doc-dir\").unwrap(),\n+        template: matches.opt_str(\"template\").unwrap(),\n+    }\n+}"}, {"sha": "53b9af2874b8a253ad12df2dc6ca98a48c297441", "filename": "src/tools/jsondocck/src/error.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Ftools%2Fjsondocck%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Ftools%2Fjsondocck%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondocck%2Fsrc%2Ferror.rs?ref=e05409a02c6e73a3dea6da98798468db2910ca59", "patch": "@@ -0,0 +1,28 @@\n+use crate::Command;\n+use std::error::Error;\n+use std::fmt;\n+\n+#[derive(Debug)]\n+pub enum CkError {\n+    /// A check failed. File didn't exist or failed to match the command\n+    FailedCheck(String, Command),\n+    /// An error triggered by some other error\n+    Induced(Box<dyn Error>),\n+}\n+\n+impl fmt::Display for CkError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            CkError::FailedCheck(msg, cmd) => {\n+                write!(f, \"Failed check: {} on line {}\", msg, cmd.lineno)\n+            }\n+            CkError::Induced(err) => write!(f, \"Check failed: {}\", err),\n+        }\n+    }\n+}\n+\n+impl<T: Error + 'static> From<T> for CkError {\n+    fn from(err: T) -> CkError {\n+        CkError::Induced(Box::new(err))\n+    }\n+}"}, {"sha": "29131f686a9dc331f7bf2f6e8052993ed48d7cfb", "filename": "src/tools/jsondocck/src/main.rs", "status": "added", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Ftools%2Fjsondocck%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e05409a02c6e73a3dea6da98798468db2910ca59/src%2Ftools%2Fjsondocck%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondocck%2Fsrc%2Fmain.rs?ref=e05409a02c6e73a3dea6da98798468db2910ca59", "patch": "@@ -0,0 +1,234 @@\n+use jsonpath_lib::select;\n+use lazy_static::lazy_static;\n+use regex::{Regex, RegexBuilder};\n+use serde_json::Value;\n+use std::{env, fmt, fs};\n+\n+mod cache;\n+mod config;\n+mod error;\n+\n+use cache::Cache;\n+use config::parse_config;\n+use error::CkError;\n+\n+fn main() -> Result<(), String> {\n+    let config = parse_config(env::args().collect());\n+\n+    let mut failed = Vec::new();\n+    let mut cache = Cache::new(&config.doc_dir);\n+    let commands = get_commands(&config.template)\n+        .map_err(|_| format!(\"Jsondocck failed for {}\", &config.template))?;\n+\n+    for command in commands {\n+        if let Err(e) = check_command(command, &mut cache) {\n+            failed.push(e);\n+        }\n+    }\n+\n+    if failed.is_empty() {\n+        Ok(())\n+    } else {\n+        for i in failed {\n+            eprintln!(\"{}\", i);\n+        }\n+        Err(format!(\"Jsondocck failed for {}\", &config.template))\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct Command {\n+    negated: bool,\n+    kind: CommandKind,\n+    args: Vec<String>,\n+    lineno: usize,\n+}\n+\n+#[derive(Debug)]\n+pub enum CommandKind {\n+    Has,\n+    Count,\n+}\n+\n+impl CommandKind {\n+    fn validate(&self, args: &[String], command_num: usize, lineno: usize) -> bool {\n+        let count = match self {\n+            CommandKind::Has => (1..=3).contains(&args.len()),\n+            CommandKind::Count => 3 == args.len(),\n+        };\n+\n+        if !count {\n+            print_err(&format!(\"Incorrect number of arguments to `@{}`\", self), lineno);\n+            return false;\n+        }\n+\n+        if args[0] == \"-\" && command_num == 0 {\n+            print_err(&format!(\"Tried to use the previous path in the first command\"), lineno);\n+            return false;\n+        }\n+\n+        if let CommandKind::Count = self {\n+            if args[2].parse::<usize>().is_err() {\n+                print_err(&format!(\"Third argument to @count must be a valid usize\"), lineno);\n+                return false;\n+            }\n+        }\n+\n+        true\n+    }\n+}\n+\n+impl fmt::Display for CommandKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let text = match self {\n+            CommandKind::Has => \"has\",\n+            CommandKind::Count => \"count\",\n+        };\n+        write!(f, \"{}\", text)\n+    }\n+}\n+\n+lazy_static! {\n+    static ref LINE_PATTERN: Regex = RegexBuilder::new(\n+        r#\"\n+        \\s(?P<invalid>!?)@(?P<negated>!?)\n+        (?P<cmd>[A-Za-z]+(?:-[A-Za-z]+)*)\n+        (?P<args>.*)$\n+    \"#\n+    )\n+    .ignore_whitespace(true)\n+    .unicode(true)\n+    .build()\n+    .unwrap();\n+}\n+\n+fn print_err(msg: &str, lineno: usize) {\n+    eprintln!(\"Invalid command: {} on line {}\", msg, lineno)\n+}\n+\n+/// Get a list of commands from a file. Does the work of ensuring the commands\n+/// are syntactically valid.\n+fn get_commands(template: &str) -> Result<Vec<Command>, ()> {\n+    let mut commands = Vec::new();\n+    let mut errors = false;\n+    let file = fs::read_to_string(template).unwrap();\n+\n+    for (lineno, line) in file.split('\\n').enumerate() {\n+        let lineno = lineno + 1;\n+\n+        let cap = match LINE_PATTERN.captures(line) {\n+            Some(c) => c,\n+            None => continue,\n+        };\n+\n+        let negated = cap.name(\"negated\").unwrap().as_str() == \"!\";\n+        let cmd = cap.name(\"cmd\").unwrap().as_str();\n+\n+        let cmd = match cmd {\n+            \"has\" => CommandKind::Has,\n+            \"count\" => CommandKind::Count,\n+            _ => {\n+                print_err(&format!(\"Unrecognized command name `@{}`\", cmd), lineno);\n+                errors = true;\n+                continue;\n+            }\n+        };\n+\n+        if let Some(m) = cap.name(\"invalid\") {\n+            if m.as_str() == \"!\" {\n+                print_err(\n+                    &format!(\n+                        \"`!@{0}{1}`, (help: try with `@!{1}`)\",\n+                        if negated { \"!\" } else { \"\" },\n+                        cmd,\n+                    ),\n+                    lineno,\n+                );\n+                errors = true;\n+                continue;\n+            }\n+        }\n+\n+        let args = cap.name(\"args\").map_or(vec![], |m| shlex::split(m.as_str()).unwrap());\n+\n+        if !cmd.validate(&args, commands.len(), lineno) {\n+            errors = true;\n+            continue;\n+        }\n+\n+        commands.push(Command { negated, kind: cmd, args, lineno })\n+    }\n+\n+    if !errors { Ok(commands) } else { Err(()) }\n+}\n+\n+/// Performs the actual work of ensuring a command passes. Generally assumes the command\n+/// is syntactically valid.\n+fn check_command(command: Command, cache: &mut Cache) -> Result<(), CkError> {\n+    let result = match command.kind {\n+        CommandKind::Has => {\n+            match command.args.len() {\n+                // @has <path> = file existence\n+                1 => cache.get_file(&command.args[0]).is_ok(),\n+                // @has <path> <jsonpath> = check path exists\n+                2 => {\n+                    let val = cache.get_value(&command.args[0])?;\n+\n+                    match select(&val, &command.args[1]) {\n+                        Ok(results) => !results.is_empty(),\n+                        Err(_) => false,\n+                    }\n+                }\n+                // @has <path> <jsonpath> <value> = check *any* item matched by path equals value\n+                3 => {\n+                    let val = cache.get_value(&command.args[0])?;\n+                    match select(&val, &command.args[1]) {\n+                        Ok(results) => {\n+                            let pat: Value = serde_json::from_str(&command.args[2]).unwrap();\n+\n+                            !results.is_empty() && results.into_iter().any(|val| *val == pat)\n+                        }\n+                        Err(_) => false,\n+                    }\n+                }\n+                _ => unreachable!(),\n+            }\n+        }\n+        CommandKind::Count => {\n+            // @count <path> <jsonpath> <count> = Check that the jsonpath matches exactly [count] times\n+            assert_eq!(command.args.len(), 3);\n+            let expected: usize = command.args[2].parse().unwrap();\n+\n+            let val = cache.get_value(&command.args[0])?;\n+            match select(&val, &command.args[1]) {\n+                Ok(results) => results.len() == expected,\n+                Err(_) => false,\n+            }\n+        }\n+    };\n+\n+    if result == command.negated {\n+        if command.negated {\n+            Err(CkError::FailedCheck(\n+                format!(\n+                    \"`@!{} {}` matched when it shouldn't\",\n+                    command.kind,\n+                    command.args.join(\" \")\n+                ),\n+                command,\n+            ))\n+        } else {\n+            // FIXME: In the future, try 'peeling back' each step, and see at what level the match failed\n+            Err(CkError::FailedCheck(\n+                format!(\n+                    \"`@{} {}` didn't match when it should\",\n+                    command.kind,\n+                    command.args.join(\" \")\n+                ),\n+                command,\n+            ))\n+        }\n+    } else {\n+        Ok(())\n+    }\n+}"}]}