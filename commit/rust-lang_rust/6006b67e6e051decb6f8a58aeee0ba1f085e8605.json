{"sha": "6006b67e6e051decb6f8a58aeee0ba1f085e8605", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwMDZiNjdlNmUwNTFkZWNiNmY4YTU4YWVlZTBiYTFmMDg1ZTg2MDU=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2018-01-25T18:41:01Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2018-01-25T18:49:28Z"}, "message": "Fix regression: account for impl methods in arg count mismatch error", "tree": {"sha": "c2bb70f25812d52339ed702be596749a1f048ecf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2bb70f25812d52339ed702be596749a1f048ecf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6006b67e6e051decb6f8a58aeee0ba1f085e8605", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6006b67e6e051decb6f8a58aeee0ba1f085e8605", "html_url": "https://github.com/rust-lang/rust/commit/6006b67e6e051decb6f8a58aeee0ba1f085e8605", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6006b67e6e051decb6f8a58aeee0ba1f085e8605/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4cf26f8a133039bfeb5b9f684df9f547278db206", "url": "https://api.github.com/repos/rust-lang/rust/commits/4cf26f8a133039bfeb5b9f684df9f547278db206", "html_url": "https://github.com/rust-lang/rust/commit/4cf26f8a133039bfeb5b9f684df9f547278db206"}], "stats": {"total": 127, "additions": 86, "deletions": 41}, "files": [{"sha": "42200a3a44728335967a229640ddbb4501e33953", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 49, "deletions": 41, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/6006b67e6e051decb6f8a58aeee0ba1f085e8605/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6006b67e6e051decb6f8a58aeee0ba1f085e8605/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=6006b67e6e051decb6f8a58aeee0ba1f085e8605", "patch": "@@ -794,48 +794,56 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn get_fn_like_arguments(&self, node: hir::map::Node) -> (Span, Vec<ArgKind>) {\n-        if let hir::map::NodeExpr(&hir::Expr {\n-            node: hir::ExprClosure(_, ref _decl, id, span, _),\n-            ..\n-        }) = node {\n-            (self.tcx.sess.codemap().def_span(span), self.tcx.hir.body(id).arguments.iter()\n-                .map(|arg| {\n-                    if let hir::Pat {\n-                        node: hir::PatKind::Tuple(args, _),\n-                        span,\n-                        ..\n-                    } = arg.pat.clone().into_inner() {\n-                        ArgKind::Tuple(\n+        match node {\n+            hir::map::NodeExpr(&hir::Expr {\n+                node: hir::ExprClosure(_, ref _decl, id, span, _),\n+                ..\n+            }) => {\n+                (self.tcx.sess.codemap().def_span(span), self.tcx.hir.body(id).arguments.iter()\n+                    .map(|arg| {\n+                        if let hir::Pat {\n+                            node: hir::PatKind::Tuple(args, _),\n                             span,\n-                            args.iter().map(|pat| {\n-                                let snippet = self.tcx.sess.codemap()\n-                                    .span_to_snippet(pat.span).unwrap();\n-                                (snippet, \"_\".to_owned())\n-                            }).collect::<Vec<_>>(),\n-                        )\n-                    } else {\n-                        let name = self.tcx.sess.codemap().span_to_snippet(arg.pat.span).unwrap();\n-                        ArgKind::Arg(name, \"_\".to_owned())\n-                    }\n-                })\n-                .collect::<Vec<ArgKind>>())\n-        } else if let hir::map::NodeItem(&hir::Item {\n-            span,\n-            node: hir::ItemFn(ref decl, ..),\n-            ..\n-        }) = node {\n-            (self.tcx.sess.codemap().def_span(span), decl.inputs.iter()\n-                    .map(|arg| match arg.clone().into_inner().node {\n-                hir::TyTup(ref tys) => ArgKind::Tuple(\n-                    arg.span,\n-                    tys.iter()\n-                        .map(|_| (\"_\".to_owned(), \"_\".to_owned()))\n-                        .collect::<Vec<_>>(),\n-                ),\n-                _ => ArgKind::Arg(\"_\".to_owned(), \"_\".to_owned())\n-            }).collect::<Vec<ArgKind>>())\n-        } else {\n-            panic!(\"non-FnLike node found: {:?}\", node);\n+                            ..\n+                        } = arg.pat.clone().into_inner() {\n+                            ArgKind::Tuple(\n+                                span,\n+                                args.iter().map(|pat| {\n+                                    let snippet = self.tcx.sess.codemap()\n+                                        .span_to_snippet(pat.span).unwrap();\n+                                    (snippet, \"_\".to_owned())\n+                                }).collect::<Vec<_>>(),\n+                            )\n+                        } else {\n+                            let name = self.tcx.sess.codemap()\n+                                .span_to_snippet(arg.pat.span).unwrap();\n+                            ArgKind::Arg(name, \"_\".to_owned())\n+                        }\n+                    })\n+                    .collect::<Vec<ArgKind>>())\n+            }\n+            hir::map::NodeItem(&hir::Item {\n+                span,\n+                node: hir::ItemFn(ref decl, ..),\n+                ..\n+            }) |\n+            hir::map::NodeImplItem(&hir::ImplItem {\n+                span,\n+                node: hir::ImplItemKind::Method(hir::MethodSig { ref decl, .. }, _),\n+                ..\n+            }) => {\n+                (self.tcx.sess.codemap().def_span(span), decl.inputs.iter()\n+                        .map(|arg| match arg.clone().into_inner().node {\n+                    hir::TyTup(ref tys) => ArgKind::Tuple(\n+                        arg.span,\n+                        tys.iter()\n+                            .map(|_| (\"_\".to_owned(), \"_\".to_owned()))\n+                            .collect::<Vec<_>>(),\n+                    ),\n+                    _ => ArgKind::Arg(\"_\".to_owned(), \"_\".to_owned())\n+                }).collect::<Vec<ArgKind>>())\n+            }\n+            _ => panic!(\"non-FnLike node found: {:?}\", node),\n         }\n     }\n "}, {"sha": "24a0f66f5b1c445514c09fc4605cb2baa445b032", "filename": "src/test/ui/issue-47706.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6006b67e6e051decb6f8a58aeee0ba1f085e8605/src%2Ftest%2Fui%2Fissue-47706.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6006b67e6e051decb6f8a58aeee0ba1f085e8605/src%2Ftest%2Fui%2Fissue-47706.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-47706.rs?ref=6006b67e6e051decb6f8a58aeee0ba1f085e8605", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct Foo {\n+    foo: Option<i32>,\n+}\n+\n+impl Foo {\n+    pub fn new(foo: Option<i32>, _: ()) -> Foo {\n+        Foo { foo }\n+    }\n+\n+    pub fn map(self) -> Option<Foo> {\n+        self.foo.map(Foo::new)\n+    }\n+    //~^^ ERROR function is expected to take 1 argument, but it takes 2 arguments [E0593]\n+}"}, {"sha": "0916dc64292e3ae0c2b370dbb68ffdae0518661a", "filename": "src/test/ui/issue-47706.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6006b67e6e051decb6f8a58aeee0ba1f085e8605/src%2Ftest%2Fui%2Fissue-47706.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6006b67e6e051decb6f8a58aeee0ba1f085e8605/src%2Ftest%2Fui%2Fissue-47706.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-47706.stderr?ref=6006b67e6e051decb6f8a58aeee0ba1f085e8605", "patch": "@@ -0,0 +1,13 @@\n+error[E0601]: main function not found\n+\n+error[E0593]: function is expected to take 1 argument, but it takes 2 arguments\n+  --> $DIR/issue-47706.rs:21:18\n+   |\n+16 |     pub fn new(foo: Option<i32>, _: ()) -> Foo {\n+   |     ------------------------------------------ takes 2 arguments\n+...\n+21 |         self.foo.map(Foo::new)\n+   |                  ^^^ expected function that takes 1 argument\n+\n+error: aborting due to 2 previous errors\n+"}]}