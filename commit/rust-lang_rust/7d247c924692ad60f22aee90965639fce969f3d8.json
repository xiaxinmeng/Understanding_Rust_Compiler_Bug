{"sha": "7d247c924692ad60f22aee90965639fce969f3d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkMjQ3YzkyNDY5MmFkNjBmMjJhZWU5MDk2NTYzOWZjZTk2OWYzZDg=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-12-31T21:20:49Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-12-31T21:20:49Z"}, "message": "Rollup merge of #80368 - camelid:rustdoc-succinct-vis, r=jyn514\n\nrustdoc: Render visibilities succinctly\n\nFixes #79139.\n\nr? `@jyn514`", "tree": {"sha": "c04232d35977a526790382d5ef4a58d4513c5f97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c04232d35977a526790382d5ef4a58d4513c5f97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d247c924692ad60f22aee90965639fce969f3d8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJf7kCyCRBK7hj4Ov3rIwAAdHIIAK6I8axE5OoSNRIL+pn0NCjM\n1LXBNMMgfy8eUE4NSlyBsXBIJKEXU5CMNiuuH1SQLFWtHssqLgfJXeIVfoycoSG1\nfYAcbj5dB3q+oQRFckBFkqDEGB1UKzD4K0bxNpWaXhuQzx7PLLnjHYxPqL3CCs75\nSdpu/hWxevkkKuvjFS5VJa2+2e/pYBP/yKkbG1xwIo4VhsL9fc81JBTeFW/rm2SH\ncfLVXaGmh44m3tabOaHY2Yn6ticBUUn83+2Xq0eRoT9M3sOJ7dc5EKvFxaCd5pPd\nCkmcrXTTvywTwQXEP7CJQbAh7D6aocv1by9T9CVI/PVJWvQKeTkPJJrdTvjj5bw=\n=TzRQ\n-----END PGP SIGNATURE-----\n", "payload": "tree c04232d35977a526790382d5ef4a58d4513c5f97\nparent 55cfcd596fabf4758f31e098a14542a52c36f7ad\nparent 5604a18a60fc99a4a7feb82a280546971adda52d\nauthor Dylan DPC <dylan.dpc@gmail.com> 1609449649 +0100\ncommitter GitHub <noreply@github.com> 1609449649 +0100\n\nRollup merge of #80368 - camelid:rustdoc-succinct-vis, r=jyn514\n\nrustdoc: Render visibilities succinctly\n\nFixes #79139.\n\nr? `@jyn514`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d247c924692ad60f22aee90965639fce969f3d8", "html_url": "https://github.com/rust-lang/rust/commit/7d247c924692ad60f22aee90965639fce969f3d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d247c924692ad60f22aee90965639fce969f3d8/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55cfcd596fabf4758f31e098a14542a52c36f7ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/55cfcd596fabf4758f31e098a14542a52c36f7ad", "html_url": "https://github.com/rust-lang/rust/commit/55cfcd596fabf4758f31e098a14542a52c36f7ad"}, {"sha": "5604a18a60fc99a4a7feb82a280546971adda52d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5604a18a60fc99a4a7feb82a280546971adda52d", "html_url": "https://github.com/rust-lang/rust/commit/5604a18a60fc99a4a7feb82a280546971adda52d"}], "stats": {"total": 233, "additions": 136, "deletions": 97}, "files": [{"sha": "f4eb1924e6f7eee811f6acaa10968e3142789dc8", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7d247c924692ad60f22aee90965639fce969f3d8/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d247c924692ad60f22aee90965639fce969f3d8/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7d247c924692ad60f22aee90965639fce969f3d8", "patch": "@@ -2325,18 +2325,19 @@ impl Clean<Item> for (&hir::MacroDef<'_>, Option<Symbol>) {\n             )\n         } else {\n             let vis = item.vis.clean(cx);\n+            let def_id = cx.tcx.hir().local_def_id(item.hir_id).to_def_id();\n \n             if matchers.len() <= 1 {\n                 format!(\n                     \"{}macro {}{} {{\\n    ...\\n}}\",\n-                    vis.print_with_space(cx.tcx),\n+                    vis.print_with_space(cx.tcx, def_id),\n                     name,\n                     matchers.iter().map(|span| span.to_src(cx)).collect::<String>(),\n                 )\n             } else {\n                 format!(\n                     \"{}macro {} {{\\n{}}}\",\n-                    vis.print_with_space(cx.tcx),\n+                    vis.print_with_space(cx.tcx, def_id),\n                     name,\n                     matchers\n                         .iter()"}, {"sha": "d4482d6fa9015b9b5e4d2db986f4f2cf67e2f0d9", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7d247c924692ad60f22aee90965639fce969f3d8/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d247c924692ad60f22aee90965639fce969f3d8/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=7d247c924692ad60f22aee90965639fce969f3d8", "patch": "@@ -14,7 +14,7 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n-use rustc_middle::ty::{self, DefIdTree, Ty};\n+use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt};\n use rustc_span::symbol::{kw, sym, Symbol};\n use std::mem;\n \n@@ -623,3 +623,24 @@ where\n     *cx.impl_trait_bounds.borrow_mut() = old_bounds;\n     r\n }\n+\n+/// Find the nearest parent module of a [`DefId`].\n+///\n+/// **Panics if the item it belongs to [is fake][Item::is_fake].**\n+crate fn find_nearest_parent_module(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n+    if def_id.is_top_level_module() {\n+        // The crate root has no parent. Use it as the root instead.\n+        Some(def_id)\n+    } else {\n+        let mut current = def_id;\n+        // The immediate parent might not always be a module.\n+        // Find the first parent which is.\n+        while let Some(parent) = tcx.parent(current) {\n+            if tcx.def_kind(parent) == DefKind::Mod {\n+                return Some(parent);\n+            }\n+            current = parent;\n+        }\n+        None\n+    }\n+}"}, {"sha": "9b2fb8582f54f678606b64bc3f247b7fc150e49c", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 42, "deletions": 20, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/7d247c924692ad60f22aee90965639fce969f3d8/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d247c924692ad60f22aee90965639fce969f3d8/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=7d247c924692ad60f22aee90965639fce969f3d8", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc_target::spec::abi::Abi;\n \n-use crate::clean::{self, PrimitiveType};\n+use crate::clean::{self, utils::find_nearest_parent_module, PrimitiveType};\n use crate::formats::cache::cache;\n use crate::formats::item_type::ItemType;\n use crate::html::escape::Escape;\n@@ -1085,32 +1085,54 @@ impl Function<'_> {\n }\n \n impl clean::Visibility {\n-    crate fn print_with_space<'tcx>(self, tcx: TyCtxt<'tcx>) -> impl fmt::Display + 'tcx {\n+    crate fn print_with_space<'tcx>(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        item_did: DefId,\n+    ) -> impl fmt::Display + 'tcx {\n         use rustc_span::symbol::kw;\n \n         display_fn(move |f| match self {\n             clean::Public => f.write_str(\"pub \"),\n             clean::Inherited => Ok(()),\n-            clean::Visibility::Restricted(did) if did.index == CRATE_DEF_INDEX => {\n-                write!(f, \"pub(crate) \")\n-            }\n-            clean::Visibility::Restricted(did) => {\n-                f.write_str(\"pub(\")?;\n-                let path = tcx.def_path(did);\n-                debug!(\"path={:?}\", path);\n-                let first_name =\n-                    path.data[0].data.get_opt_name().expect(\"modules are always named\");\n-                if path.data.len() != 1 || (first_name != kw::SelfLower && first_name != kw::Super)\n+\n+            clean::Visibility::Restricted(vis_did) => {\n+                // FIXME(camelid): This may not work correctly if `item_did` is a module.\n+                //                 However, rustdoc currently never displays a module's\n+                //                 visibility, so it shouldn't matter.\n+                let parent_module = find_nearest_parent_module(tcx, item_did);\n+\n+                if vis_did.index == CRATE_DEF_INDEX {\n+                    write!(f, \"pub(crate) \")\n+                } else if parent_module == Some(vis_did) {\n+                    // `pub(in foo)` where `foo` is the parent module\n+                    // is the same as no visibility modifier\n+                    Ok(())\n+                } else if parent_module\n+                    .map(|parent| find_nearest_parent_module(tcx, parent))\n+                    .flatten()\n+                    == Some(vis_did)\n                 {\n-                    f.write_str(\"in \")?;\n-                }\n-                // modified from `resolved_path()` to work with `DefPathData`\n-                let last_name = path.data.last().unwrap().data.get_opt_name().unwrap();\n-                for seg in &path.data[..path.data.len() - 1] {\n-                    write!(f, \"{}::\", seg.data.get_opt_name().unwrap())?;\n+                    write!(f, \"pub(super) \")\n+                } else {\n+                    f.write_str(\"pub(\")?;\n+                    let path = tcx.def_path(vis_did);\n+                    debug!(\"path={:?}\", path);\n+                    let first_name =\n+                        path.data[0].data.get_opt_name().expect(\"modules are always named\");\n+                    if path.data.len() != 1\n+                        || (first_name != kw::SelfLower && first_name != kw::Super)\n+                    {\n+                        f.write_str(\"in \")?;\n+                    }\n+                    // modified from `resolved_path()` to work with `DefPathData`\n+                    let last_name = path.data.last().unwrap().data.get_opt_name().unwrap();\n+                    for seg in &path.data[..path.data.len() - 1] {\n+                        write!(f, \"{}::\", seg.data.get_opt_name().unwrap())?;\n+                    }\n+                    let path = anchor(vis_did, &last_name.as_str()).to_string();\n+                    write!(f, \"{}) \", path)\n                 }\n-                let path = anchor(did, &last_name.as_str()).to_string();\n-                write!(f, \"{}) \", path)\n             }\n         })\n     }"}, {"sha": "c19262b72cf72a3a7fe4523c2eda30c325f79b01", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7d247c924692ad60f22aee90965639fce969f3d8/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d247c924692ad60f22aee90965639fce969f3d8/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=7d247c924692ad60f22aee90965639fce969f3d8", "patch": "@@ -2157,14 +2157,14 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                     Some(ref src) => write!(\n                         w,\n                         \"<tr><td><code>{}extern crate {} as {};\",\n-                        myitem.visibility.print_with_space(cx.tcx()),\n+                        myitem.visibility.print_with_space(cx.tcx(), myitem.def_id),\n                         anchor(myitem.def_id, &*src.as_str()),\n                         name\n                     ),\n                     None => write!(\n                         w,\n                         \"<tr><td><code>{}extern crate {};\",\n-                        myitem.visibility.print_with_space(cx.tcx()),\n+                        myitem.visibility.print_with_space(cx.tcx(), myitem.def_id),\n                         anchor(myitem.def_id, &*name.as_str())\n                     ),\n                 }\n@@ -2175,7 +2175,7 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                 write!(\n                     w,\n                     \"<tr><td><code>{}{}</code></td></tr>\",\n-                    myitem.visibility.print_with_space(cx.tcx()),\n+                    myitem.visibility.print_with_space(cx.tcx(), myitem.def_id),\n                     import.print()\n                 );\n             }\n@@ -2392,7 +2392,7 @@ fn item_constant(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, c: &clean::\n     write!(\n         w,\n         \"{vis}const {name}: {typ}\",\n-        vis = it.visibility.print_with_space(cx.tcx()),\n+        vis = it.visibility.print_with_space(cx.tcx(), it.def_id),\n         name = it.name.as_ref().unwrap(),\n         typ = c.type_.print(),\n     );\n@@ -2426,7 +2426,7 @@ fn item_static(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::St\n     write!(\n         w,\n         \"{vis}static {mutability}{name}: {typ}</pre>\",\n-        vis = it.visibility.print_with_space(cx.tcx()),\n+        vis = it.visibility.print_with_space(cx.tcx(), it.def_id),\n         mutability = s.mutability.print_with_space(),\n         name = it.name.as_ref().unwrap(),\n         typ = s.type_.print()\n@@ -2437,7 +2437,7 @@ fn item_static(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::St\n fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::Function) {\n     let header_len = format!(\n         \"{}{}{}{}{:#}fn {}{:#}\",\n-        it.visibility.print_with_space(cx.tcx()),\n+        it.visibility.print_with_space(cx.tcx(), it.def_id),\n         f.header.constness.print_with_space(),\n         f.header.asyncness.print_with_space(),\n         f.header.unsafety.print_with_space(),\n@@ -2452,7 +2452,7 @@ fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::\n         w,\n         \"{vis}{constness}{asyncness}{unsafety}{abi}fn \\\n          {name}{generics}{decl}{spotlight}{where_clause}</pre>\",\n-        vis = it.visibility.print_with_space(cx.tcx()),\n+        vis = it.visibility.print_with_space(cx.tcx(), it.def_id),\n         constness = f.header.constness.print_with_space(),\n         asyncness = f.header.asyncness.print_with_space(),\n         unsafety = f.header.unsafety.print_with_space(),\n@@ -2578,7 +2578,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         write!(\n             w,\n             \"{}{}{}trait {}{}{}\",\n-            it.visibility.print_with_space(cx.tcx()),\n+            it.visibility.print_with_space(cx.tcx(), it.def_id),\n             t.unsafety.print_with_space(),\n             if t.is_auto { \"auto \" } else { \"\" },\n             it.name.as_ref().unwrap(),\n@@ -2896,7 +2896,7 @@ fn assoc_const(\n         w,\n         \"{}{}const <a href=\\\"{}\\\" class=\\\"constant\\\"><b>{}</b></a>: {}\",\n         extra,\n-        it.visibility.print_with_space(cx.tcx()),\n+        it.visibility.print_with_space(cx.tcx(), it.def_id),\n         naive_assoc_href(it, link),\n         it.name.as_ref().unwrap(),\n         ty.print()\n@@ -3015,7 +3015,7 @@ fn render_assoc_item(\n         };\n         let mut header_len = format!(\n             \"{}{}{}{}{}{:#}fn {}{:#}\",\n-            meth.visibility.print_with_space(cx.tcx()),\n+            meth.visibility.print_with_space(cx.tcx(), meth.def_id),\n             header.constness.print_with_space(),\n             header.asyncness.print_with_space(),\n             header.unsafety.print_with_space(),\n@@ -3037,7 +3037,7 @@ fn render_assoc_item(\n             \"{}{}{}{}{}{}{}fn <a href=\\\"{href}\\\" class=\\\"fnname\\\">{name}</a>\\\n              {generics}{decl}{spotlight}{where_clause}\",\n             if parent == ItemType::Trait { \"    \" } else { \"\" },\n-            meth.visibility.print_with_space(cx.tcx()),\n+            meth.visibility.print_with_space(cx.tcx(), meth.def_id),\n             header.constness.print_with_space(),\n             header.asyncness.print_with_space(),\n             header.unsafety.print_with_space(),\n@@ -3189,7 +3189,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n         write!(\n             w,\n             \"{}enum {}{}{}\",\n-            it.visibility.print_with_space(cx.tcx()),\n+            it.visibility.print_with_space(cx.tcx(), it.def_id),\n             it.name.as_ref().unwrap(),\n             e.generics.print(),\n             WhereClause { gens: &e.generics, indent: 0, end_newline: true }\n@@ -3365,7 +3365,7 @@ fn render_struct(\n     write!(\n         w,\n         \"{}{}{}\",\n-        it.visibility.print_with_space(cx.tcx()),\n+        it.visibility.print_with_space(cx.tcx(), it.def_id),\n         if structhead { \"struct \" } else { \"\" },\n         it.name.as_ref().unwrap()\n     );\n@@ -3385,7 +3385,7 @@ fn render_struct(\n                         w,\n                         \"\\n{}    {}{}: {},\",\n                         tab,\n-                        field.visibility.print_with_space(cx.tcx()),\n+                        field.visibility.print_with_space(cx.tcx(), field.def_id),\n                         field.name.as_ref().unwrap(),\n                         ty.print()\n                     );\n@@ -3414,7 +3414,12 @@ fn render_struct(\n                 match *field.kind {\n                     clean::StrippedItem(box clean::StructFieldItem(..)) => write!(w, \"_\"),\n                     clean::StructFieldItem(ref ty) => {\n-                        write!(w, \"{}{}\", field.visibility.print_with_space(cx.tcx()), ty.print())\n+                        write!(\n+                            w,\n+                            \"{}{}\",\n+                            field.visibility.print_with_space(cx.tcx(), field.def_id),\n+                            ty.print()\n+                        )\n                     }\n                     _ => unreachable!(),\n                 }\n@@ -3447,7 +3452,7 @@ fn render_union(\n     write!(\n         w,\n         \"{}{}{}\",\n-        it.visibility.print_with_space(cx.tcx()),\n+        it.visibility.print_with_space(cx.tcx(), it.def_id),\n         if structhead { \"union \" } else { \"\" },\n         it.name.as_ref().unwrap()\n     );\n@@ -3462,7 +3467,7 @@ fn render_union(\n             write!(\n                 w,\n                 \"    {}{}: {},\\n{}\",\n-                field.visibility.print_with_space(cx.tcx()),\n+                field.visibility.print_with_space(cx.tcx(), field.def_id),\n                 field.name.as_ref().unwrap(),\n                 ty.print(),\n                 tab\n@@ -4101,7 +4106,7 @@ fn item_foreign_type(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, cache:\n     write!(\n         w,\n         \"    {}type {};\\n}}</pre>\",\n-        it.visibility.print_with_space(cx.tcx()),\n+        it.visibility.print_with_space(cx.tcx(), it.def_id),\n         it.name.as_ref().unwrap(),\n     );\n "}, {"sha": "9f15038a353b51cee52d9f3ae108707437359d1a", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7d247c924692ad60f22aee90965639fce969f3d8/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d247c924692ad60f22aee90965639fce969f3d8/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=7d247c924692ad60f22aee90965639fce969f3d8", "patch": "@@ -31,7 +31,7 @@ use std::convert::{TryFrom, TryInto};\n use std::mem;\n use std::ops::Range;\n \n-use crate::clean::{self, Crate, Item, ItemLink, PrimitiveType};\n+use crate::clean::{self, utils::find_nearest_parent_module, Crate, Item, ItemLink, PrimitiveType};\n use crate::core::DocContext;\n use crate::fold::DocFolder;\n use crate::html::markdown::markdown_links;\n@@ -830,31 +830,9 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n         use rustc_middle::ty::DefIdTree;\n \n         let parent_node = if item.is_fake() {\n-            // FIXME: is this correct?\n             None\n-        // If we're documenting the crate root itself, it has no parent. Use the root instead.\n-        } else if item.def_id.is_top_level_module() {\n-            Some(item.def_id)\n         } else {\n-            let mut current = item.def_id;\n-            // The immediate parent might not always be a module.\n-            // Find the first parent which is.\n-            loop {\n-                if let Some(parent) = self.cx.tcx.parent(current) {\n-                    if self.cx.tcx.def_kind(parent) == DefKind::Mod {\n-                        break Some(parent);\n-                    }\n-                    current = parent;\n-                } else {\n-                    debug!(\n-                        \"{:?} has no parent (kind={:?}, original was {:?})\",\n-                        current,\n-                        self.cx.tcx.def_kind(current),\n-                        item.def_id\n-                    );\n-                    break None;\n-                }\n-            }\n+            find_nearest_parent_module(self.cx.tcx, item.def_id)\n         };\n \n         if parent_node.is_some() {"}, {"sha": "6720d848ac3b59e50947fa087a3a8b15a54aa475", "filename": "src/test/rustdoc/pub-restricted.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/55cfcd596fabf4758f31e098a14542a52c36f7ad/src%2Ftest%2Frustdoc%2Fpub-restricted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55cfcd596fabf4758f31e098a14542a52c36f7ad/src%2Ftest%2Frustdoc%2Fpub-restricted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fpub-restricted.rs?ref=55cfcd596fabf4758f31e098a14542a52c36f7ad", "patch": "@@ -1,32 +0,0 @@\n-// compile-flags: --document-private-items\n-\n-#![feature(crate_visibility_modifier)]\n-\n-#![crate_name = \"foo\"]\n-\n-// @has 'foo/struct.FooPublic.html' '//pre' 'pub struct FooPublic'\n-pub struct FooPublic;\n-// @has 'foo/struct.FooJustCrate.html' '//pre' 'pub(crate) struct FooJustCrate'\n-crate struct FooJustCrate;\n-// @has 'foo/struct.FooPubCrate.html' '//pre' 'pub(crate) struct FooPubCrate'\n-pub(crate) struct FooPubCrate;\n-// @has 'foo/struct.FooSelf.html' '//pre' 'pub(crate) struct FooSelf'\n-pub(self) struct FooSelf;\n-// @has 'foo/struct.FooInSelf.html' '//pre' 'pub(crate) struct FooInSelf'\n-pub(in self) struct FooInSelf;\n-mod a {\n-    // @has 'foo/a/struct.FooSuper.html' '//pre' 'pub(crate) struct FooSuper'\n-    pub(super) struct FooSuper;\n-    // @has 'foo/a/struct.FooInSuper.html' '//pre' 'pub(crate) struct FooInSuper'\n-    pub(in super) struct FooInSuper;\n-    // @has 'foo/a/struct.FooInA.html' '//pre' 'pub(in a) struct FooInA'\n-    pub(in a) struct FooInA;\n-    mod b {\n-        // @has 'foo/a/b/struct.FooInSelfSuperB.html' '//pre' 'pub(in a::b) struct FooInSelfSuperB'\n-        pub(in a::b) struct FooInSelfSuperB;\n-        // @has 'foo/a/b/struct.FooInSuperSuper.html' '//pre' 'pub(crate) struct FooInSuperSuper'\n-        pub(in super::super) struct FooInSuperSuper;\n-        // @has 'foo/a/b/struct.FooInAB.html' '//pre' 'pub(in a::b) struct FooInAB'\n-        pub(in a::b) struct FooInAB;\n-    }\n-}"}, {"sha": "59427693c5a5d3c61fef6eaed72e9c87e9e99cbe", "filename": "src/test/rustdoc/visibility.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7d247c924692ad60f22aee90965639fce969f3d8/src%2Ftest%2Frustdoc%2Fvisibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d247c924692ad60f22aee90965639fce969f3d8/src%2Ftest%2Frustdoc%2Fvisibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fvisibility.rs?ref=7d247c924692ad60f22aee90965639fce969f3d8", "patch": "@@ -0,0 +1,44 @@\n+// compile-flags: --document-private-items\n+\n+#![feature(crate_visibility_modifier)]\n+\n+#![crate_name = \"foo\"]\n+\n+// @has 'foo/struct.FooPublic.html' '//pre' 'pub struct FooPublic'\n+pub struct FooPublic;\n+// @has 'foo/struct.FooJustCrate.html' '//pre' 'pub(crate) struct FooJustCrate'\n+crate struct FooJustCrate;\n+// @has 'foo/struct.FooPubCrate.html' '//pre' 'pub(crate) struct FooPubCrate'\n+pub(crate) struct FooPubCrate;\n+// @has 'foo/struct.FooSelf.html' '//pre' 'pub(crate) struct FooSelf'\n+pub(self) struct FooSelf;\n+// @has 'foo/struct.FooInSelf.html' '//pre' 'pub(crate) struct FooInSelf'\n+pub(in self) struct FooInSelf;\n+// @has 'foo/struct.FooPriv.html' '//pre' 'pub(crate) struct FooPriv'\n+struct FooPriv;\n+\n+mod a {\n+    // @has 'foo/a/struct.FooASuper.html' '//pre' 'pub(crate) struct FooASuper'\n+    pub(super) struct FooASuper;\n+    // @has 'foo/a/struct.FooAInSuper.html' '//pre' 'pub(crate) struct FooAInSuper'\n+    pub(in super) struct FooAInSuper;\n+    // @has 'foo/a/struct.FooAInA.html' '//pre' 'struct FooAInA'\n+    // @!has 'foo/a/struct.FooAInA.html' '//pre' 'pub'\n+    pub(in a) struct FooAInA;\n+    // @has 'foo/a/struct.FooAPriv.html' '//pre' 'struct FooAPriv'\n+    // @!has 'foo/a/struct.FooAPriv.html' '//pre' 'pub'\n+    struct FooAPriv;\n+\n+    mod b {\n+        // @has 'foo/a/b/struct.FooBSuper.html' '//pre' 'pub(super) struct FooBSuper'\n+        pub(super) struct FooBSuper;\n+        // @has 'foo/a/b/struct.FooBInSuperSuper.html' '//pre' 'pub(crate) struct FooBInSuperSuper'\n+        pub(in super::super) struct FooBInSuperSuper;\n+        // @has 'foo/a/b/struct.FooBInAB.html' '//pre' 'struct FooBInAB'\n+        // @!has 'foo/a/b/struct.FooBInAB.html' '//pre' 'pub'\n+        pub(in a::b) struct FooBInAB;\n+        // @has 'foo/a/b/struct.FooBPriv.html' '//pre' 'struct FooBPriv'\n+        // @!has 'foo/a/b/struct.FooBPriv.html' '//pre' 'pub'\n+        struct FooBPriv;\n+    }\n+}"}]}