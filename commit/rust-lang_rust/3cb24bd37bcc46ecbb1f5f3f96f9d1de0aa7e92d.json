{"sha": "3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjYjI0YmQzN2JjYzQ2ZWNiYjFmNWYzZjk2ZjlkMWRlMGFhN2U5MmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-12T04:14:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-12T04:14:07Z"}, "message": "Auto merge of #44275 - eddyb:deferred-ctfe, r=nikomatsakis\n\nEvaluate fixed-length array length expressions lazily.\n\nThis is in preparation for polymorphic array lengths (aka `[T; T::A]`) and const generics.\nWe need deferred const-evaluation to break cycles when array types show up in positions which require knowing the array type to typeck the array length, e.g. the array type is in a `where` clause.\n\nThe final step - actually passing bounds in scope to array length expressions from the parent - is not done because it still produces cycles when *normalizing* `ParamEnv`s, and @nikomatsakis' in-progress lazy normalization work is needed to deal with that uniformly.\n\nHowever, the changes here are still useful to unlock work on const generics, which @EpicatSupercell manifested interest in, and I might be mentoring them for that, but we need this baseline first.\n\nr? @nikomatsakis cc @oli-obk", "tree": {"sha": "0b6b7342122257fbe0d5f38ca38142776cef7542", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b6b7342122257fbe0d5f38ca38142776cef7542"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "html_url": "https://github.com/rust-lang/rust/commit/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11f64d8f881a8bd994210efc1d3ff1982abf9df3", "url": "https://api.github.com/repos/rust-lang/rust/commits/11f64d8f881a8bd994210efc1d3ff1982abf9df3", "html_url": "https://github.com/rust-lang/rust/commit/11f64d8f881a8bd994210efc1d3ff1982abf9df3"}, {"sha": "57ebd28fdb69d7cc4df3de343664e6698a4b55f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/57ebd28fdb69d7cc4df3de343664e6698a4b55f0", "html_url": "https://github.com/rust-lang/rust/commit/57ebd28fdb69d7cc4df3de343664e6698a4b55f0"}], "stats": {"total": 2390, "additions": 1605, "deletions": 785}, "files": [{"sha": "dd2a3978d884405a18972f8dc6d1e4cc494251cc", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -611,7 +611,7 @@ pub enum BindingAnnotation {\n   RefMut,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum RangeEnd {\n     Included,\n     Excluded,"}, {"sha": "dce1639b375b781587fb1be335e0d94045312478", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -493,10 +493,6 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::L\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n-            mir::Literal::Item { def_id, substs } => {\n-                def_id.hash_stable(hcx, hasher);\n-                substs.hash_stable(hcx, hasher);\n-            }\n             mir::Literal::Value { ref value } => {\n                 value.hash_stable(hcx, hasher);\n             }"}, {"sha": "e933ca4c2b551db0fc395c68bf66acfaaab4e50b", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 32, "deletions": 19, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -16,7 +16,6 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n use std::hash as std_hash;\n use std::mem;\n-use syntax_pos::symbol::InternedString;\n use middle::region;\n use ty;\n \n@@ -236,6 +235,10 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::Pr\n                 def_id.hash_stable(hcx, hasher);\n                 closure_kind.hash_stable(hcx, hasher);\n             }\n+            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+                def_id.hash_stable(hcx, hasher);\n+                substs.hash_stable(hcx, hasher);\n+            }\n         }\n     }\n }\n@@ -272,59 +275,69 @@ for ::middle::const_val::ConstVal<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n-        use middle::const_val::ConstVal;\n+        use middle::const_val::ConstVal::*;\n+        use middle::const_val::ConstAggregate::*;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n         match *self {\n-            ConstVal::Float(ref value) => {\n+            Integral(ref value) => {\n                 value.hash_stable(hcx, hasher);\n             }\n-            ConstVal::Integral(ref value) => {\n+            Float(ref value) => {\n                 value.hash_stable(hcx, hasher);\n             }\n-            ConstVal::Str(ref value) => {\n+            Str(ref value) => {\n                 value.hash_stable(hcx, hasher);\n             }\n-            ConstVal::ByteStr(ref value) => {\n+            ByteStr(ref value) => {\n                 value.hash_stable(hcx, hasher);\n             }\n-            ConstVal::Bool(value) => {\n+            Bool(value) => {\n                 value.hash_stable(hcx, hasher);\n             }\n-            ConstVal::Char(value) => {\n+            Char(value) => {\n                 value.hash_stable(hcx, hasher);\n             }\n-            ConstVal::Variant(def_id) => {\n+            Variant(def_id) => {\n                 def_id.hash_stable(hcx, hasher);\n             }\n-            ConstVal::Function(def_id, substs) => {\n+            Function(def_id, substs) => {\n                 def_id.hash_stable(hcx, hasher);\n                 substs.hash_stable(hcx, hasher);\n             }\n-            ConstVal::Struct(ref name_value_map) => {\n-                let mut values: Vec<(InternedString, &ConstVal)> =\n-                    name_value_map.iter()\n-                                  .map(|(name, val)| (name.as_str(), val))\n-                                  .collect();\n-\n+            Aggregate(Struct(ref name_values)) => {\n+                let mut values = name_values.to_vec();\n                 values.sort_unstable_by_key(|&(ref name, _)| name.clone());\n                 values.hash_stable(hcx, hasher);\n             }\n-            ConstVal::Tuple(ref value) => {\n+            Aggregate(Tuple(ref value)) => {\n                 value.hash_stable(hcx, hasher);\n             }\n-            ConstVal::Array(ref value) => {\n+            Aggregate(Array(ref value)) => {\n                 value.hash_stable(hcx, hasher);\n             }\n-            ConstVal::Repeat(ref value, times) => {\n+            Aggregate(Repeat(ref value, times)) => {\n                 value.hash_stable(hcx, hasher);\n                 times.hash_stable(hcx, hasher);\n             }\n+            Unevaluated(def_id, substs) => {\n+                def_id.hash_stable(hcx, hasher);\n+                substs.hash_stable(hcx, hasher);\n+            }\n         }\n     }\n }\n \n+impl_stable_hash_for!(struct ::middle::const_val::ByteArray<'tcx> {\n+    data\n+});\n+\n+impl_stable_hash_for!(struct ty::Const<'tcx> {\n+    ty,\n+    val\n+});\n+\n impl_stable_hash_for!(struct ty::ClosureSubsts<'tcx> { substs });\n \n impl_stable_hash_for!(struct ty::GeneratorInterior<'tcx> { witness });"}, {"sha": "6ccf7e42fd5fd7fba6e73e0f3e89344bad8e04ad", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -442,6 +442,7 @@ macro_rules! impl_trans_normalize {\n \n impl_trans_normalize!('gcx,\n     Ty<'gcx>,\n+    &'gcx ty::Const<'gcx>,\n     &'gcx Substs<'gcx>,\n     ty::FnSig<'gcx>,\n     ty::PolyFnSig<'gcx>,\n@@ -493,7 +494,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         let param_env = ty::ParamEnv::empty(Reveal::All);\n         let value = self.erase_regions(value);\n \n-        if !value.has_projection_types() {\n+        if !value.has_projections() {\n             return value;\n         }\n \n@@ -515,7 +516,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n \n         let value = self.erase_regions(value);\n \n-        if !value.has_projection_types() {\n+        if !value.has_projections() {\n             return value;\n         }\n "}, {"sha": "7b239980467303ff9720e1eb7e788a5781dd3ba3", "filename": "src/librustc/middle/const_val.rs", "status": "modified", "additions": 33, "deletions": 70, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -8,64 +8,66 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use self::ConstVal::*;\n pub use rustc_const_math::ConstInt;\n \n-use hir;\n-use hir::def::Def;\n use hir::def_id::DefId;\n-use traits::Reveal;\n use ty::{self, TyCtxt, layout};\n use ty::subst::Substs;\n-use util::common::ErrorReported;\n use rustc_const_math::*;\n \n use graphviz::IntoCow;\n use errors::DiagnosticBuilder;\n+use serialize::{self, Encodable, Encoder, Decodable, Decoder};\n use syntax::symbol::InternedString;\n use syntax::ast;\n use syntax_pos::Span;\n \n use std::borrow::Cow;\n-use std::collections::BTreeMap;\n-use std::rc::Rc;\n \n-pub type EvalResult<'tcx> = Result<ConstVal<'tcx>, ConstEvalErr<'tcx>>;\n+pub type EvalResult<'tcx> = Result<&'tcx ty::Const<'tcx>, ConstEvalErr<'tcx>>;\n \n-#[derive(Clone, Debug, Hash, RustcEncodable, RustcDecodable, Eq, PartialEq)]\n+#[derive(Copy, Clone, Debug, Hash, RustcEncodable, RustcDecodable, Eq, PartialEq)]\n pub enum ConstVal<'tcx> {\n-    Float(ConstFloat),\n     Integral(ConstInt),\n+    Float(ConstFloat),\n     Str(InternedString),\n-    ByteStr(Rc<Vec<u8>>),\n+    ByteStr(ByteArray<'tcx>),\n     Bool(bool),\n     Char(char),\n     Variant(DefId),\n     Function(DefId, &'tcx Substs<'tcx>),\n-    Struct(BTreeMap<ast::Name, ConstVal<'tcx>>),\n-    Tuple(Vec<ConstVal<'tcx>>),\n-    Array(Vec<ConstVal<'tcx>>),\n-    Repeat(Box<ConstVal<'tcx>>, u64),\n+    Aggregate(ConstAggregate<'tcx>),\n+    Unevaluated(DefId, &'tcx Substs<'tcx>),\n }\n \n-impl<'tcx> ConstVal<'tcx> {\n-    pub fn description(&self) -> &'static str {\n-        match *self {\n-            Float(f) => f.description(),\n-            Integral(i) => i.description(),\n-            Str(_) => \"string literal\",\n-            ByteStr(_) => \"byte string literal\",\n-            Bool(_) => \"boolean\",\n-            Char(..) => \"char\",\n-            Variant(_) => \"enum variant\",\n-            Struct(_) => \"struct\",\n-            Tuple(_) => \"tuple\",\n-            Function(..) => \"function definition\",\n-            Array(..) => \"array\",\n-            Repeat(..) => \"repeat\",\n-        }\n+#[derive(Copy, Clone, Debug, Hash, RustcEncodable, Eq, PartialEq)]\n+pub struct ByteArray<'tcx> {\n+    pub data: &'tcx [u8],\n+}\n+\n+impl<'tcx> serialize::UseSpecializedDecodable for ByteArray<'tcx> {}\n+\n+#[derive(Copy, Clone, Debug, Hash, Eq, PartialEq)]\n+pub enum ConstAggregate<'tcx> {\n+    Struct(&'tcx [(ast::Name, &'tcx ty::Const<'tcx>)]),\n+    Tuple(&'tcx [&'tcx ty::Const<'tcx>]),\n+    Array(&'tcx [&'tcx ty::Const<'tcx>]),\n+    Repeat(&'tcx ty::Const<'tcx>, u64),\n+}\n+\n+impl<'tcx> Encodable for ConstAggregate<'tcx> {\n+    fn encode<S: Encoder>(&self, _: &mut S) -> Result<(), S::Error> {\n+        bug!(\"should never encode ConstAggregate::{:?}\", self)\n+    }\n+}\n+\n+impl<'tcx> Decodable for ConstAggregate<'tcx> {\n+    fn decode<D: Decoder>(_: &mut D) -> Result<Self, D::Error> {\n+        bug!(\"should never decode ConstAggregate\")\n     }\n+}\n \n+impl<'tcx> ConstVal<'tcx> {\n     pub fn to_const_int(&self) -> Option<ConstInt> {\n         match *self {\n             ConstVal::Integral(i) => Some(i),\n@@ -86,8 +88,6 @@ pub struct ConstEvalErr<'tcx> {\n pub enum ErrKind<'tcx> {\n     CannotCast,\n     MissingStructField,\n-    NegateOn(ConstVal<'tcx>),\n-    NotOn(ConstVal<'tcx>),\n \n     NonConstPath,\n     UnimplementedConstVal(&'static str),\n@@ -146,9 +146,6 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n \n         match self.kind {\n             CannotCast => simple!(\"can't cast this type\"),\n-            NegateOn(ref const_val) => simple!(\"negate on {}\", const_val.description()),\n-            NotOn(ref const_val) => simple!(\"not on {}\", const_val.description()),\n-\n             MissingStructField  => simple!(\"nonexistent struct field\"),\n             NonConstPath        => simple!(\"non-constant path in constant expression\"),\n             UnimplementedConstVal(what) =>\n@@ -221,37 +218,3 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n         self.struct_error(tcx, primary_span, primary_kind).emit();\n     }\n }\n-\n-/// Returns the value of the length-valued expression\n-pub fn eval_length(tcx: TyCtxt,\n-                   count: hir::BodyId,\n-                   reason: &str)\n-                   -> Result<usize, ErrorReported>\n-{\n-    let count_expr = &tcx.hir.body(count).value;\n-    let count_def_id = tcx.hir.body_owner_def_id(count);\n-    let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n-    let substs = Substs::identity_for_item(tcx.global_tcx(), count_def_id);\n-    match tcx.at(count_expr.span).const_eval(param_env.and((count_def_id, substs))) {\n-        Ok(Integral(Usize(count))) => {\n-            let val = count.as_u64(tcx.sess.target.uint_type);\n-            assert_eq!(val as usize as u64, val);\n-            Ok(val as usize)\n-        },\n-        Ok(_) |\n-        Err(ConstEvalErr { kind: ErrKind::TypeckError, .. }) => Err(ErrorReported),\n-        Err(err) => {\n-            let mut diag = err.struct_error(tcx, count_expr.span, reason);\n-\n-            if let hir::ExprPath(hir::QPath::Resolved(None, ref path)) = count_expr.node {\n-                if let Def::Local(..) = path.def {\n-                    diag.note(&format!(\"`{}` is a variable\",\n-                                       tcx.hir.node_to_pretty_string(count_expr.id)));\n-                }\n-            }\n-\n-            diag.emit();\n-            Err(ErrorReported)\n-        }\n-    }\n-}"}, {"sha": "4de86b669160eb03736d17c98f3b2cc6bb2163ec", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -147,7 +147,8 @@ impl<'tcx> FreeRegionMap<'tcx> {\n                 ty::Predicate::WellFormed(..) |\n                 ty::Predicate::ObjectSafe(..) |\n                 ty::Predicate::ClosureKind(..) |\n-                ty::Predicate::TypeOutlives(..) => {\n+                ty::Predicate::TypeOutlives(..) |\n+                ty::Predicate::ConstEvaluatable(..) => {\n                     // No region bounds here\n                 }\n                 ty::Predicate::RegionOutlives(ty::Binder(ty::OutlivesPredicate(r_a, r_b))) => {"}, {"sha": "5102b41598d6fcd6ee6ace871efbe8fb98e870a5", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -876,7 +876,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         // Always promote `[T; 0]` (even when e.g. borrowed mutably).\n         let promotable = match expr_ty.sty {\n-            ty::TyArray(_, 0) => true,\n+            ty::TyArray(_, len) if\n+                len.val.to_const_int().and_then(|i| i.to_u64()) == Some(0) => true,\n             _ => promotable,\n         };\n "}, {"sha": "38dfe010c153cc14af61ca38ad7cbc07c2e6f829", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -1187,10 +1187,16 @@ impl<'tcx> Operand<'tcx> {\n         substs: &'tcx Substs<'tcx>,\n         span: Span,\n     ) -> Self {\n+        let ty = tcx.type_of(def_id).subst(tcx, substs);\n         Operand::Constant(box Constant {\n             span,\n-            ty: tcx.type_of(def_id).subst(tcx, substs),\n-            literal: Literal::Value { value: ConstVal::Function(def_id, substs) },\n+            ty,\n+            literal: Literal::Value {\n+                value: tcx.mk_const(ty::Const {\n+                    val: ConstVal::Function(def_id, substs),\n+                    ty\n+                })\n+            },\n         })\n     }\n \n@@ -1473,12 +1479,8 @@ newtype_index!(Promoted, \"promoted\");\n \n #[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum Literal<'tcx> {\n-    Item {\n-        def_id: DefId,\n-        substs: &'tcx Substs<'tcx>,\n-    },\n     Value {\n-        value: ConstVal<'tcx>,\n+        value: &'tcx ty::Const<'tcx>,\n     },\n     Promoted {\n         // Index into the `promoted` vector of `Mir`.\n@@ -1496,12 +1498,9 @@ impl<'tcx> Debug for Literal<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n         use self::Literal::*;\n         match *self {\n-            Item { def_id, substs } => {\n-                ppaux::parameterized(fmt, substs, def_id, &[])\n-            }\n-            Value { ref value } => {\n+            Value { value } => {\n                 write!(fmt, \"const \")?;\n-                fmt_const_val(fmt, value)\n+                fmt_const_val(fmt, &value.val)\n             }\n             Promoted { index } => {\n                 write!(fmt, \"{:?}\", index)\n@@ -1516,9 +1515,9 @@ fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ConstVal) -> fmt::Result {\n     match *const_val {\n         Float(f) => write!(fmt, \"{:?}\", f),\n         Integral(n) => write!(fmt, \"{}\", n),\n-        Str(ref s) => write!(fmt, \"{:?}\", s),\n-        ByteStr(ref bytes) => {\n-            let escaped: String = bytes\n+        Str(s) => write!(fmt, \"{:?}\", s),\n+        ByteStr(bytes) => {\n+            let escaped: String = bytes.data\n                 .iter()\n                 .flat_map(|&ch| ascii::escape_default(ch).map(|c| c as char))\n                 .collect();\n@@ -1528,8 +1527,8 @@ fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ConstVal) -> fmt::Result {\n         Char(c) => write!(fmt, \"{:?}\", c),\n         Variant(def_id) |\n         Function(def_id, _) => write!(fmt, \"{}\", item_path_str(def_id)),\n-        Struct(_) | Tuple(_) | Array(_) | Repeat(..) =>\n-            bug!(\"ConstVal `{:?}` should not be in MIR\", const_val),\n+        Aggregate(_) => bug!(\"`ConstVal::{:?}` should not be in MIR\", const_val),\n+        Unevaluated(..) => write!(fmt, \"{:?}\", const_val)\n     }\n }\n \n@@ -1996,17 +1995,16 @@ impl<'tcx> TypeFoldable<'tcx> for Constant<'tcx> {\n impl<'tcx> TypeFoldable<'tcx> for Literal<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n-            Literal::Item { def_id, substs } => Literal::Item {\n-                def_id,\n-                substs: substs.fold_with(folder)\n+            Literal::Value { value } => Literal::Value {\n+                value: value.fold_with(folder)\n             },\n-            _ => self.clone()\n+            Literal::Promoted { index } => Literal::Promoted { index }\n         }\n     }\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         match *self {\n-            Literal::Item { substs, .. } => substs.visit_with(visitor),\n-            _ => false\n+            Literal::Value { value } => value.visit_with(visitor),\n+            Literal::Promoted { .. } => false\n         }\n     }\n }"}, {"sha": "d645a00e15781a3436c9bdbeb696d4e184c9ab42", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -70,7 +70,9 @@ impl<'a, 'gcx, 'tcx> LvalueTy<'tcx> {\n                 LvalueTy::Ty {\n                     ty: match ty.sty {\n                         ty::TyArray(inner, size) => {\n-                            tcx.mk_array(inner, size-(from as usize)-(to as usize))\n+                            let size = size.val.to_const_int().unwrap().to_u64().unwrap();\n+                            let len = size - (from as u64) - (to as u64);\n+                            tcx.mk_array(inner, len)\n                         }\n                         ty::TySlice(..) => ty,\n                         _ => {\n@@ -146,11 +148,8 @@ impl<'tcx> Rvalue<'tcx> {\n     {\n         match *self {\n             Rvalue::Use(ref operand) => operand.ty(local_decls, tcx),\n-            Rvalue::Repeat(ref operand, ref count) => {\n-                let op_ty = operand.ty(local_decls, tcx);\n-                let count = count.as_u64(tcx.sess.target.uint_type);\n-                assert_eq!(count as usize as u64, count);\n-                tcx.mk_array(op_ty, count as usize)\n+            Rvalue::Repeat(ref operand, count) => {\n+                tcx.mk_array_const_usize(operand.ty(local_decls, tcx), count)\n             }\n             Rvalue::Ref(reg, bk, ref lv) => {\n                 let lv_ty = lv.ty(local_decls, tcx).to_ty(tcx);\n@@ -193,7 +192,7 @@ impl<'tcx> Rvalue<'tcx> {\n             Rvalue::Aggregate(ref ak, ref ops) => {\n                 match **ak {\n                     AggregateKind::Array(ty) => {\n-                        tcx.mk_array(ty, ops.len())\n+                        tcx.mk_array(ty, ops.len() as u64)\n                     }\n                     AggregateKind::Tuple => {\n                         tcx.mk_tup("}, {"sha": "37c97ad3dad9058aa763e8f15c84ef0bb485705f", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::const_val::ConstVal;\n use hir::def_id::DefId;\n use ty::subst::Substs;\n use ty::{ClosureSubsts, Region, Ty, GeneratorInterior};\n@@ -214,6 +213,18 @@ macro_rules! make_mir_visitor {\n                 self.super_ty(ty);\n             }\n \n+            fn visit_region(&mut self,\n+                            region: & $($mutability)* ty::Region<'tcx>,\n+                            _: Location) {\n+                self.super_region(region);\n+            }\n+\n+            fn visit_const(&mut self,\n+                           constant: & $($mutability)* &'tcx ty::Const<'tcx>,\n+                           _: Location) {\n+                self.super_const(constant);\n+            }\n+\n             fn visit_substs(&mut self,\n                             substs: & $($mutability)* &'tcx Substs<'tcx>,\n                             _: Location) {\n@@ -232,12 +243,6 @@ macro_rules! make_mir_visitor {\n                 self.super_generator_interior(interior);\n             }\n \n-            fn visit_const_val(&mut self,\n-                               const_val: & $($mutability)* ConstVal,\n-                               _: Location) {\n-                self.super_const_val(const_val);\n-            }\n-\n             fn visit_const_int(&mut self,\n                                const_int: &ConstInt,\n                                _: Location) {\n@@ -517,9 +522,10 @@ macro_rules! make_mir_visitor {\n                         self.visit_const_usize(length, location);\n                     }\n \n-                    Rvalue::Ref(r, bk, ref $($mutability)* path) => {\n+                    Rvalue::Ref(ref $($mutability)* r, bk, ref $($mutability)* path) => {\n+                        self.visit_region(r, location);\n                         self.visit_lvalue(path, LvalueContext::Borrow {\n-                            region: r,\n+                            region: *r,\n                             kind: bk\n                         }, location);\n                     }\n@@ -718,13 +724,8 @@ macro_rules! make_mir_visitor {\n                              literal: & $($mutability)* Literal<'tcx>,\n                              location: Location) {\n                 match *literal {\n-                    Literal::Item { ref $($mutability)* def_id,\n-                                    ref $($mutability)* substs } => {\n-                        self.visit_def_id(def_id, location);\n-                        self.visit_substs(substs, location);\n-                    }\n                     Literal::Value { ref $($mutability)* value } => {\n-                        self.visit_const_val(value, location);\n+                        self.visit_const(value, location);\n                     }\n                     Literal::Promoted { index: _ } => {}\n                 }\n@@ -749,6 +750,12 @@ macro_rules! make_mir_visitor {\n             fn super_ty(&mut self, _ty: & $($mutability)* Ty<'tcx>) {\n             }\n \n+            fn super_region(&mut self, _region: & $($mutability)* ty::Region<'tcx>) {\n+            }\n+\n+            fn super_const(&mut self, _const: & $($mutability)* &'tcx ty::Const<'tcx>) {\n+            }\n+\n             fn super_substs(&mut self, _substs: & $($mutability)* &'tcx Substs<'tcx>) {\n             }\n \n@@ -760,9 +767,6 @@ macro_rules! make_mir_visitor {\n                                     _substs: & $($mutability)* ClosureSubsts<'tcx>) {\n             }\n \n-            fn super_const_val(&mut self, _const_val: & $($mutability)* ConstVal) {\n-            }\n-\n             fn super_const_int(&mut self, _const_int: &ConstInt) {\n             }\n "}, {"sha": "b7e07f94f3df14b3ca57ae850146322da403ba97", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -48,8 +48,8 @@ use std::path::PathBuf;\n \n pub struct Config {\n     pub target: Target,\n-    pub int_type: IntTy,\n-    pub uint_type: UintTy,\n+    pub isize_ty: IntTy,\n+    pub usize_ty: UintTy,\n }\n \n #[derive(Clone, Hash, Debug)]\n@@ -1149,7 +1149,7 @@ pub fn build_target_config(opts: &Options, sp: &Handler) -> Config {\n         }\n     };\n \n-    let (int_type, uint_type) = match &target.target_pointer_width[..] {\n+    let (isize_ty, usize_ty) = match &target.target_pointer_width[..] {\n         \"16\" => (ast::IntTy::I16, ast::UintTy::U16),\n         \"32\" => (ast::IntTy::I32, ast::UintTy::U32),\n         \"64\" => (ast::IntTy::I64, ast::UintTy::U64),\n@@ -1159,8 +1159,8 @@ pub fn build_target_config(opts: &Options, sp: &Handler) -> Config {\n \n     Config {\n         target,\n-        int_type,\n-        uint_type,\n+        isize_ty,\n+        usize_ty,\n     }\n }\n "}, {"sha": "b491baadd7c2bc7a888509d2c46c927a49b90bb4", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -19,6 +19,7 @@ use super::{\n     OnUnimplementedNote,\n     OutputTypeParameterMismatch,\n     TraitNotObjectSafe,\n+    ConstEvalFailure,\n     PredicateObligation,\n     Reveal,\n     SelectionContext,\n@@ -31,6 +32,7 @@ use hir;\n use hir::def_id::DefId;\n use infer::{self, InferCtxt};\n use infer::type_variable::TypeVariableOrigin;\n+use middle::const_val;\n use rustc::lint::builtin::EXTRA_REQUIREMENT_IN_IMPL;\n use std::fmt;\n use syntax::ast;\n@@ -698,6 +700,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         // (which may fail).\n                         span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n                     }\n+\n+                    ty::Predicate::ConstEvaluatable(..) => {\n+                        // Errors for `ConstEvaluatable` predicates show up as\n+                        // `SelectionError::ConstEvalFailure`,\n+                        // not `Unimplemented`.\n+                        span_bug!(span,\n+                            \"const-evaluatable requirement gave wrong error: `{:?}`\", obligation)\n+                    }\n                 }\n             }\n \n@@ -762,6 +772,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 self.tcx.report_object_safety_error(span, did,\n                                                     violations)\n             }\n+\n+            ConstEvalFailure(ref err) => {\n+                if let const_val::ErrKind::TypeckError = err.kind {\n+                    return;\n+                }\n+                err.struct_error(self.tcx, span, \"constant expression\")\n+            }\n         };\n         self.note_obligation_cause(&mut err, obligation);\n         err.emit();"}, {"sha": "cc2506d1afc505c7f6d2553fafc160becf80c410", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -25,7 +25,7 @@ use super::{FulfillmentError, FulfillmentErrorCode};\n use super::{ObligationCause, PredicateObligation, Obligation};\n use super::project;\n use super::select::SelectionContext;\n-use super::Unimplemented;\n+use super::{Unimplemented, ConstEvalFailure};\n \n impl<'tcx> ForestObligation for PendingPredicateObligation<'tcx> {\n     type Predicate = ty::Predicate<'tcx>;\n@@ -540,6 +540,29 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n                 }\n             }\n         }\n+\n+        ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+            match selcx.tcx().lift_to_global(&obligation.param_env) {\n+                None => {\n+                    Ok(None)\n+                }\n+                Some(param_env) => {\n+                    match selcx.tcx().lift_to_global(&substs) {\n+                        None => {\n+                            pending_obligation.stalled_on = substs.types().collect();\n+                            Ok(None)\n+                        }\n+                        Some(substs) => {\n+                            match selcx.tcx().at(obligation.cause.span)\n+                                             .const_eval(param_env.and((def_id, substs))) {\n+                                Ok(_) => Ok(Some(vec![])),\n+                                Err(e) => Err(CodeSelectionError(ConstEvalFailure(e)))\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n     }\n }\n "}, {"sha": "fb71d9cc49b9e1efe1b0585bfcb17cb6b907d24a", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -17,6 +17,7 @@ pub use self::ObligationCauseCode::*;\n \n use hir;\n use hir::def_id::DefId;\n+use middle::const_val::ConstEvalErr;\n use middle::region;\n use middle::free_region::FreeRegionMap;\n use ty::subst::Substs;\n@@ -218,6 +219,7 @@ pub enum SelectionError<'tcx> {\n                                 ty::PolyTraitRef<'tcx>,\n                                 ty::error::TypeError<'tcx>),\n     TraitNotObjectSafe(DefId),\n+    ConstEvalFailure(ConstEvalErr<'tcx>),\n }\n \n pub struct FulfillmentError<'tcx> {"}, {"sha": "1e9816095ea2ec419330dc3b154f20ee5080b869", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -169,7 +169,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     ty::Predicate::RegionOutlives(..) |\n                     ty::Predicate::ClosureKind(..) |\n                     ty::Predicate::Subtype(..) |\n-                    ty::Predicate::Equate(..) => {\n+                    ty::Predicate::Equate(..) |\n+                    ty::Predicate::ConstEvaluatable(..) => {\n                         false\n                     }\n                 }\n@@ -203,7 +204,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     ty::Predicate::WellFormed(..) |\n                     ty::Predicate::ObjectSafe(..) |\n                     ty::Predicate::ClosureKind(..) |\n-                    ty::Predicate::TypeOutlives(..) => {\n+                    ty::Predicate::TypeOutlives(..) |\n+                    ty::Predicate::ConstEvaluatable(..) => {\n                         false\n                     }\n                 }"}, {"sha": "54e31aed272a31389a2271906dc096b53d1747a2", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -27,10 +27,11 @@ use super::util;\n use hir::def_id::DefId;\n use infer::{InferCtxt, InferOk};\n use infer::type_variable::TypeVariableOrigin;\n+use middle::const_val::ConstVal;\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n use syntax::ast;\n use syntax::symbol::Symbol;\n-use ty::subst::Subst;\n+use ty::subst::{Subst, Substs};\n use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder};\n use util::common::FN_OUTPUT_NAME;\n@@ -260,7 +261,7 @@ impl<'a, 'b, 'gcx, 'tcx> AssociatedTypeNormalizer<'a, 'b, 'gcx, 'tcx> {\n     fn fold<T:TypeFoldable<'tcx>>(&mut self, value: &T) -> T {\n         let value = self.selcx.infcx().resolve_type_vars_if_possible(value);\n \n-        if !value.has_projection_types() {\n+        if !value.has_projections() {\n             value.clone()\n         } else {\n             value.fold_with(self)\n@@ -332,6 +333,39 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n             }\n         }\n     }\n+\n+    fn fold_const(&mut self, constant: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        if let ConstVal::Unevaluated(def_id, substs) = constant.val {\n+            if substs.needs_infer() {\n+                let identity_substs = Substs::identity_for_item(self.tcx(), def_id);\n+                let data = self.param_env.and((def_id, identity_substs));\n+                match self.tcx().lift_to_global(&data) {\n+                    Some(data) => {\n+                        match self.tcx().const_eval(data) {\n+                            Ok(evaluated) => {\n+                                let evaluated = evaluated.subst(self.tcx(), substs);\n+                                return self.fold_const(evaluated);\n+                            }\n+                            Err(_) => {}\n+                        }\n+                    }\n+                    None => {}\n+                }\n+            } else {\n+                let data = self.param_env.and((def_id, substs));\n+                match self.tcx().lift_to_global(&data) {\n+                    Some(data) => {\n+                        match self.tcx().const_eval(data) {\n+                            Ok(evaluated) => return self.fold_const(evaluated),\n+                            Err(_) => {}\n+                        }\n+                    }\n+                    None => {}\n+                }\n+            }\n+        }\n+        constant\n+    }\n }\n \n #[derive(Clone)]\n@@ -520,7 +554,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                    depth,\n                    obligations);\n \n-            let result = if projected_ty.has_projection_types() {\n+            let result = if projected_ty.has_projections() {\n                 let mut normalizer = AssociatedTypeNormalizer::new(selcx,\n                                                                    param_env,\n                                                                    cause,"}, {"sha": "f5f69ad0a7cec124372e076141136b2873e1b951", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -732,6 +732,21 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n+\n+            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+                match self.tcx().lift_to_global(&(obligation.param_env, substs)) {\n+                    Some((param_env, substs)) => {\n+                        match self.tcx().const_eval(param_env.and((def_id, substs))) {\n+                            Ok(_) => EvaluatedToOk,\n+                            Err(_) => EvaluatedToErr\n+                        }\n+                    }\n+                    None => {\n+                        // Inference variables still left in param_env or substs.\n+                        EvaluatedToAmbig\n+                    }\n+                }\n+            }\n         }\n     }\n "}, {"sha": "19ed03aa14917b8e67e5b77c0e49d7e89471e663", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -173,6 +173,9 @@ impl<'a, 'tcx> Lift<'tcx> for traits::SelectionError<'a> {\n             super::TraitNotObjectSafe(def_id) => {\n                 Some(super::TraitNotObjectSafe(def_id))\n             }\n+            super::ConstEvalFailure(ref err) => {\n+                tcx.lift(err).map(super::ConstEvalFailure)\n+            }\n         }\n     }\n }"}, {"sha": "9c4a260b35d49a03cc213eb98f0e3928ca40a6eb", "filename": "src/librustc/traits/trans/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -120,7 +120,7 @@ impl<'a, 'gcx> AssociatedTypeNormalizer<'a, 'gcx> {\n     }\n \n     fn fold<T:TypeFoldable<'gcx>>(&mut self, value: &T) -> T {\n-        if !value.has_projection_types() {\n+        if !value.has_projections() {\n             value.clone()\n         } else {\n             value.fold_with(self)\n@@ -134,7 +134,7 @@ impl<'a, 'gcx> TypeFolder<'gcx, 'gcx> for AssociatedTypeNormalizer<'a, 'gcx> {\n     }\n \n     fn fold_ty(&mut self, ty: Ty<'gcx>) -> Ty<'gcx> {\n-        if !ty.has_projection_types() {\n+        if !ty.has_projections() {\n             ty\n         } else {\n             self.tcx.trans_trait_caches.project_cache.memoize(ty, || {"}, {"sha": "42e0834e8e43b1498e260125fe42d9fe9bc49aec", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -48,6 +48,9 @@ fn anonymize_predicate<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n         ty::Predicate::Subtype(ref data) =>\n             ty::Predicate::Subtype(tcx.anonymize_late_bound_regions(data)),\n+\n+        ty::Predicate::ConstEvaluatable(def_id, substs) =>\n+            ty::Predicate::ConstEvaluatable(def_id, substs),\n     }\n }\n \n@@ -175,6 +178,10 @@ impl<'cx, 'gcx, 'tcx> Elaborator<'cx, 'gcx, 'tcx> {\n             ty::Predicate::ClosureKind(..) => {\n                 // Nothing to elaborate when waiting for a closure's kind to be inferred.\n             }\n+            ty::Predicate::ConstEvaluatable(..) => {\n+                // Currently, we do not elaborate const-evaluatable\n+                // predicates.\n+            }\n \n             ty::Predicate::RegionOutlives(..) => {\n                 // Nothing to elaborate from `'a: 'b`."}, {"sha": "b6b602c0a4dc6536c6d4e916b5c9e3965ea97ace", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 74, "deletions": 26, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -21,6 +21,7 @@ use hir::map as hir_map;\n use hir::map::DefPathHash;\n use lint::{self, Lint};\n use ich::{self, StableHashingContext, NodeIdHashingMode};\n+use middle::const_val::ConstVal;\n use middle::free_region::FreeRegionMap;\n use middle::lang_items;\n use middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n@@ -32,7 +33,7 @@ use ty::ReprOptions;\n use traits;\n use ty::{self, Ty, TypeAndMut};\n use ty::{TyS, TypeVariants, Slice};\n-use ty::{AdtKind, AdtDef, ClosureSubsts, GeneratorInterior, Region};\n+use ty::{AdtKind, AdtDef, ClosureSubsts, GeneratorInterior, Region, Const};\n use ty::{PolyFnSig, InferTy, ParamTy, ProjectionTy, ExistentialPredicate, Predicate};\n use ty::RegionKind;\n use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n@@ -49,6 +50,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n \n use arena::{TypedArena, DroplessArena};\n+use rustc_const_math::{ConstInt, ConstUsize};\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::borrow::Borrow;\n use std::cell::{Cell, RefCell};\n@@ -108,6 +110,7 @@ pub struct CtxtInterners<'tcx> {\n     region: RefCell<FxHashSet<Interned<'tcx, RegionKind>>>,\n     existential_predicates: RefCell<FxHashSet<Interned<'tcx, Slice<ExistentialPredicate<'tcx>>>>>,\n     predicates: RefCell<FxHashSet<Interned<'tcx, Slice<Predicate<'tcx>>>>>,\n+    const_: RefCell<FxHashSet<Interned<'tcx, Const<'tcx>>>>,\n }\n \n impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n@@ -120,6 +123,7 @@ impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n             region: RefCell::new(FxHashSet()),\n             existential_predicates: RefCell::new(FxHashSet()),\n             predicates: RefCell::new(FxHashSet()),\n+            const_: RefCell::new(FxHashSet()),\n         }\n     }\n \n@@ -934,6 +938,32 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.global_arenas.adt_def.alloc(def)\n     }\n \n+    pub fn alloc_byte_array(self, bytes: &[u8]) -> &'gcx [u8] {\n+        if bytes.is_empty() {\n+            &[]\n+        } else {\n+            self.global_interners.arena.alloc_slice(bytes)\n+        }\n+    }\n+\n+    pub fn alloc_const_slice(self, values: &[&'tcx ty::Const<'tcx>])\n+                             -> &'tcx [&'tcx ty::Const<'tcx>] {\n+        if values.is_empty() {\n+            &[]\n+        } else {\n+            self.interners.arena.alloc_slice(values)\n+        }\n+    }\n+\n+    pub fn alloc_name_const_slice(self, values: &[(ast::Name, &'tcx ty::Const<'tcx>)])\n+                                  -> &'tcx [(ast::Name, &'tcx ty::Const<'tcx>)] {\n+        if values.is_empty() {\n+            &[]\n+        } else {\n+            self.interners.arena.alloc_slice(values)\n+        }\n+    }\n+\n     pub fn intern_stability(self, stab: attr::Stability) -> &'gcx attr::Stability {\n         if let Some(st) = self.stability_interner.borrow().get(&stab) {\n             return st;\n@@ -1175,18 +1205,6 @@ pub trait Lift<'tcx> {\n     fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted>;\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for ty::ParamEnv<'a> {\n-    type Lifted = ty::ParamEnv<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<ty::ParamEnv<'tcx>> {\n-        self.caller_bounds.lift_to_tcx(tcx).and_then(|caller_bounds| {\n-            Some(ty::ParamEnv {\n-                reveal: self.reveal,\n-                caller_bounds,\n-            })\n-        })\n-    }\n-}\n-\n impl<'a, 'tcx> Lift<'tcx> for Ty<'a> {\n     type Lifted = Ty<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Ty<'tcx>> {\n@@ -1202,13 +1220,10 @@ impl<'a, 'tcx> Lift<'tcx> for Ty<'a> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n-    type Lifted = &'tcx Substs<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx Substs<'tcx>> {\n-        if self.len() == 0 {\n-            return Some(Slice::empty());\n-        }\n-        if tcx.interners.arena.in_arena(&self[..] as *const _) {\n+impl<'a, 'tcx> Lift<'tcx> for Region<'a> {\n+    type Lifted = Region<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Region<'tcx>> {\n+        if tcx.interners.arena.in_arena(*self as *const _) {\n             return Some(unsafe { mem::transmute(*self) });\n         }\n         // Also try in the global tcx if we're not that.\n@@ -1220,9 +1235,9 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for Region<'a> {\n-    type Lifted = Region<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Region<'tcx>> {\n+impl<'a, 'tcx> Lift<'tcx> for &'a Const<'a> {\n+    type Lifted = &'tcx Const<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx Const<'tcx>> {\n         if tcx.interners.arena.in_arena(*self as *const _) {\n             return Some(unsafe { mem::transmute(*self) });\n         }\n@@ -1235,6 +1250,24 @@ impl<'a, 'tcx> Lift<'tcx> for Region<'a> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n+    type Lifted = &'tcx Substs<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx Substs<'tcx>> {\n+        if self.len() == 0 {\n+            return Some(Slice::empty());\n+        }\n+        if tcx.interners.arena.in_arena(&self[..] as *const _) {\n+            return Some(unsafe { mem::transmute(*self) });\n+        }\n+        // Also try in the global tcx if we're not that.\n+        if !tcx.is_global() {\n+            self.lift_to_tcx(tcx.global_tcx())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx> Lift<'tcx> for &'a Slice<Ty<'a>> {\n     type Lifted = &'tcx Slice<Ty<'tcx>>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n@@ -1522,6 +1555,12 @@ impl<'tcx: 'lcx, 'lcx> Borrow<[Predicate<'lcx>]>\n     }\n }\n \n+impl<'tcx: 'lcx, 'lcx> Borrow<Const<'lcx>> for Interned<'tcx, Const<'tcx>> {\n+    fn borrow<'a>(&'a self) -> &'a Const<'lcx> {\n+        &self.0\n+    }\n+}\n+\n macro_rules! intern_method {\n     ($lt_tcx:tt, $name:ident: $method:ident($alloc:ty,\n                                             $alloc_method:ident,\n@@ -1602,7 +1641,8 @@ direct_interners!('tcx,\n             &ty::ReVar(_) | &ty::ReSkolemized(..) => true,\n             _ => false\n         }\n-    }) -> RegionKind\n+    }) -> RegionKind,\n+    const_: mk_const(|c: &Const| keep_local(&c.ty) || keep_local(&c.val)) -> Const<'tcx>\n );\n \n macro_rules! slice_interners {\n@@ -1719,8 +1759,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_imm_ptr(self.mk_nil())\n     }\n \n-    pub fn mk_array(self, ty: Ty<'tcx>, n: usize) -> Ty<'tcx> {\n-        self.mk_ty(TyArray(ty, n))\n+    pub fn mk_array(self, ty: Ty<'tcx>, n: u64) -> Ty<'tcx> {\n+        let n = ConstUsize::new(n, self.sess.target.usize_ty).unwrap();\n+        self.mk_array_const_usize(ty, n)\n+    }\n+\n+    pub fn mk_array_const_usize(self, ty: Ty<'tcx>, n: ConstUsize) -> Ty<'tcx> {\n+        self.mk_ty(TyArray(ty, self.mk_const(ty::Const {\n+            val: ConstVal::Integral(ConstInt::Usize(n)),\n+            ty: self.types.usize\n+        })))\n     }\n \n     pub fn mk_slice(self, ty: Ty<'tcx>) -> Ty<'tcx> {"}, {"sha": "52a8389bd8f5fcebb63921f425f466310ba6df99", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -10,6 +10,7 @@\n \n use hir::def_id::DefId;\n use infer::type_variable;\n+use middle::const_val::ConstVal;\n use ty::{self, BoundRegion, DefIdTree, Region, Ty, TyCtxt};\n \n use std::fmt;\n@@ -18,6 +19,8 @@ use syntax::ast;\n use errors::DiagnosticBuilder;\n use syntax_pos::Span;\n \n+use rustc_const_math::ConstInt;\n+\n use hir;\n \n #[derive(Clone, Copy, Debug)]\n@@ -34,7 +37,7 @@ pub enum TypeError<'tcx> {\n     AbiMismatch(ExpectedFound<abi::Abi>),\n     Mutability,\n     TupleSize(ExpectedFound<usize>),\n-    FixedArraySize(ExpectedFound<usize>),\n+    FixedArraySize(ExpectedFound<u64>),\n     ArgCount,\n \n     RegionsDoesNotOutlive(Region<'tcx>, Region<'tcx>),\n@@ -179,7 +182,13 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n             ty::TyTuple(ref tys, _) if tys.is_empty() => self.to_string(),\n \n             ty::TyAdt(def, _) => format!(\"{} `{}`\", def.descr(), tcx.item_path_str(def.did)),\n-            ty::TyArray(_, n) => format!(\"array of {} elements\", n),\n+            ty::TyArray(_, n) => {\n+                if let ConstVal::Integral(ConstInt::Usize(n)) = n.val {\n+                    format!(\"array of {} elements\", n)\n+                } else {\n+                    \"array\".to_string()\n+                }\n+            }\n             ty::TySlice(_) => \"slice\".to_string(),\n             ty::TyRawPtr(_) => \"*-ptr\".to_string(),\n             ty::TyRef(region, tymut) => {"}, {"sha": "9ece719c764704b5dc41815f7ade8c1dab3a74cb", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use middle::const_val::{ConstVal, ConstAggregate};\n use ty::subst::Substs;\n use ty::{self, Ty, TypeFlags, TypeFoldable};\n \n@@ -145,7 +146,12 @@ impl FlagComputation {\n                 self.add_region(r);\n             }\n \n-            &ty::TyArray(tt, _) | &ty::TySlice(tt) => {\n+            &ty::TyArray(tt, len) => {\n+                self.add_ty(tt);\n+                self.add_const(len);\n+            }\n+\n+            &ty::TySlice(tt) => {\n                 self.add_ty(tt)\n             }\n \n@@ -202,6 +208,40 @@ impl FlagComputation {\n         }\n     }\n \n+    fn add_const(&mut self, constant: &ty::Const) {\n+        self.add_ty(constant.ty);\n+        match constant.val {\n+            ConstVal::Integral(_) |\n+            ConstVal::Float(_) |\n+            ConstVal::Str(_) |\n+            ConstVal::ByteStr(_) |\n+            ConstVal::Bool(_) |\n+            ConstVal::Char(_) |\n+            ConstVal::Variant(_) => {}\n+            ConstVal::Function(_, substs) => {\n+                self.add_substs(substs);\n+            }\n+            ConstVal::Aggregate(ConstAggregate::Struct(fields)) => {\n+                for &(_, v) in fields {\n+                    self.add_const(v);\n+                }\n+            }\n+            ConstVal::Aggregate(ConstAggregate::Tuple(fields)) |\n+            ConstVal::Aggregate(ConstAggregate::Array(fields)) => {\n+                for v in fields {\n+                    self.add_const(v);\n+                }\n+            }\n+            ConstVal::Aggregate(ConstAggregate::Repeat(v, _)) => {\n+                self.add_const(v);\n+            }\n+            ConstVal::Unevaluated(_, substs) => {\n+                self.add_flags(TypeFlags::HAS_PROJECTION);\n+                self.add_substs(substs);\n+            }\n+        }\n+    }\n+\n     fn add_existential_projection(&mut self, projection: &ty::ExistentialProjection) {\n         self.add_substs(projection.substs);\n         self.add_ty(projection.ty);"}, {"sha": "543e8f3e2f04d9511cbce9a1e1c68eefa9bb306f", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -39,6 +39,7 @@\n //! These methods return true to indicate that the visitor has found what it is looking for\n //! and does not need to visit anything else.\n \n+use middle::const_val::ConstVal;\n use ty::{self, Binder, Ty, TyCtxt, TypeFlags};\n \n use std::fmt;\n@@ -67,7 +68,7 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     fn has_type_flags(&self, flags: TypeFlags) -> bool {\n         self.visit_with(&mut HasTypeFlagsVisitor { flags: flags })\n     }\n-    fn has_projection_types(&self) -> bool {\n+    fn has_projections(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_PROJECTION)\n     }\n     fn references_error(&self) -> bool {\n@@ -139,6 +140,10 @@ pub trait TypeFolder<'gcx: 'tcx, 'tcx> : Sized {\n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         r.super_fold_with(self)\n     }\n+\n+    fn fold_const(&mut self, c: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        c.super_fold_with(self)\n+    }\n }\n \n pub trait TypeVisitor<'tcx> : Sized {\n@@ -153,6 +158,10 @@ pub trait TypeVisitor<'tcx> : Sized {\n     fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n         r.super_visit_with(self)\n     }\n+\n+    fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n+        c.super_visit_with(self)\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -603,6 +612,17 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n         debug!(\"HasTypeFlagsVisitor: r={:?} r.flags={:?} self.flags={:?}\", r, flags, self.flags);\n         flags.intersects(self.flags)\n     }\n+\n+    fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n+        if let ConstVal::Unevaluated(..) = c.val {\n+            let projection_flags = TypeFlags::HAS_NORMALIZABLE_PROJECTION |\n+                TypeFlags::HAS_PROJECTION;\n+            if projection_flags.intersects(self.flags) {\n+                return true;\n+            }\n+        }\n+        c.super_visit_with(self)\n+    }\n }\n \n /// Collects all the late-bound regions it finds into a hash set."}, {"sha": "a829814e0905ba2b9d1c51baf4df34149ec20359", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -205,7 +205,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n                 }))\n             },\n             TyArray(ty, len) => {\n-                if len == 0 {\n+                if len.val.to_const_int().and_then(|i| i.to_u64()) == Some(0) {\n                     DefIdForest::empty()\n                 } else {\n                     ty.uninhabited_from(visited, tcx)"}, {"sha": "0106d98b64130e1938929322e0eb03e1ff007bac", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -837,12 +837,22 @@ impl<'a, 'tcx> Struct {\n \n             // Is this a fixed-size array of something non-zero\n             // with at least one element?\n-            (_, &ty::TyArray(ety, d)) if d > 0 => {\n-                Struct::non_zero_field_paths(\n-                    tcx,\n-                    param_env,\n-                    Some(ety).into_iter(),\n-                    None)\n+            (_, &ty::TyArray(ety, mut count)) => {\n+                if count.has_projections() {\n+                    count = tcx.normalize_associated_type_in_env(&count, param_env);\n+                    if count.has_projections() {\n+                        return Err(LayoutError::Unknown(ty));\n+                    }\n+                }\n+                if count.val.to_const_int().unwrap().to_u64().unwrap() != 0 {\n+                    Struct::non_zero_field_paths(\n+                        tcx,\n+                        param_env,\n+                        Some(ety).into_iter(),\n+                        None)\n+                } else {\n+                    Ok(None)\n+                }\n             }\n \n             (_, &ty::TyProjection(_)) | (_, &ty::TyAnon(..)) => {\n@@ -1174,12 +1184,17 @@ impl<'a, 'tcx> Layout {\n             }\n \n             // Arrays and slices.\n-            ty::TyArray(element, count) => {\n+            ty::TyArray(element, mut count) => {\n+                if count.has_projections() {\n+                    count = tcx.normalize_associated_type_in_env(&count, param_env);\n+                    if count.has_projections() {\n+                        return Err(LayoutError::Unknown(ty));\n+                    }\n+                }\n+\n                 let element = element.layout(tcx, param_env)?;\n                 let element_size = element.size(dl);\n-                // FIXME(eddyb) Don't use host `usize` for array lengths.\n-                let usize_count: usize = count;\n-                let count = usize_count as u64;\n+                let count = count.val.to_const_int().unwrap().to_u64().unwrap();\n                 if element_size.checked_mul(count, dl).is_none() {\n                     return Err(LayoutError::SizeOverflow(ty));\n                 }"}, {"sha": "18c59d405a2014c6f5ea5963794679d7a3b6d738", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -159,7 +159,7 @@ impl Key for (MirSuite, MirPassIndex, DefId) {\n     }\n }\n \n-impl<'tcx, T: Clone + Hash + Eq + Debug> Key for ty::ParamEnvAnd<'tcx, T> {\n+impl<'tcx> Key for Ty<'tcx> {\n     fn map_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -168,6 +168,15 @@ impl<'tcx, T: Clone + Hash + Eq + Debug> Key for ty::ParamEnvAnd<'tcx, T> {\n     }\n }\n \n+impl<'tcx, T: Key> Key for ty::ParamEnvAnd<'tcx, T> {\n+    fn map_crate(&self) -> CrateNum {\n+        self.value.map_crate()\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        self.value.default_span(tcx)\n+    }\n+}\n+\n trait Value<'tcx>: Sized {\n     fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self;\n }"}, {"sha": "586d8607e89a195683d1377283658a44fb76b22f", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -64,7 +64,7 @@ pub use self::sty::{InferTy, ParamTy, ProjectionTy, ExistentialPredicate};\n pub use self::sty::{ClosureSubsts, GeneratorInterior, TypeAndMut};\n pub use self::sty::{TraitRef, TypeVariants, PolyTraitRef};\n pub use self::sty::{ExistentialTraitRef, PolyExistentialTraitRef};\n-pub use self::sty::{ExistentialProjection, PolyExistentialProjection};\n+pub use self::sty::{ExistentialProjection, PolyExistentialProjection, Const};\n pub use self::sty::{BoundRegion, EarlyBoundRegion, FreeRegion, Region};\n pub use self::sty::RegionKind;\n pub use self::sty::{TyVid, IntVid, FloatVid, RegionVid, SkolemizedRegionVid};\n@@ -846,6 +846,9 @@ pub enum Predicate<'tcx> {\n \n     /// `T1 <: T2`\n     Subtype(PolySubtypePredicate<'tcx>),\n+\n+    /// Constant initializer must evaluate successfully.\n+    ConstEvaluatable(DefId, &'tcx Substs<'tcx>),\n }\n \n impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n@@ -938,6 +941,8 @@ impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n                 Predicate::ObjectSafe(trait_def_id),\n             Predicate::ClosureKind(closure_def_id, kind) =>\n                 Predicate::ClosureKind(closure_def_id, kind),\n+            Predicate::ConstEvaluatable(def_id, const_substs) =>\n+                Predicate::ConstEvaluatable(def_id, const_substs.subst(tcx, substs)),\n         }\n     }\n }\n@@ -1120,6 +1125,9 @@ impl<'tcx> Predicate<'tcx> {\n             ty::Predicate::ClosureKind(_closure_def_id, _kind) => {\n                 vec![]\n             }\n+            ty::Predicate::ConstEvaluatable(_, substs) => {\n+                substs.types().collect()\n+            }\n         };\n \n         // The only reason to collect into a vector here is that I was\n@@ -1142,7 +1150,8 @@ impl<'tcx> Predicate<'tcx> {\n             Predicate::WellFormed(..) |\n             Predicate::ObjectSafe(..) |\n             Predicate::ClosureKind(..) |\n-            Predicate::TypeOutlives(..) => {\n+            Predicate::TypeOutlives(..) |\n+            Predicate::ConstEvaluatable(..) => {\n                 None\n             }\n         }\n@@ -1601,7 +1610,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n             if let VariantDiscr::Explicit(expr_did) = v.discr {\n                 let substs = Substs::identity_for_item(tcx.global_tcx(), expr_did);\n                 match tcx.const_eval(param_env.and((expr_did, substs))) {\n-                    Ok(ConstVal::Integral(v)) => {\n+                    Ok(&ty::Const { val: ConstVal::Integral(v), .. }) => {\n                         discr = v;\n                     }\n                     err => {\n@@ -1641,7 +1650,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                 ty::VariantDiscr::Explicit(expr_did) => {\n                     let substs = Substs::identity_for_item(tcx.global_tcx(), expr_did);\n                     match tcx.const_eval(param_env.and((expr_did, substs))) {\n-                        Ok(ConstVal::Integral(v)) => {\n+                        Ok(&ty::Const { val: ConstVal::Integral(v), .. }) => {\n                             explicit_value = v;\n                             break;\n                         }\n@@ -1665,11 +1674,11 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         match repr_type {\n             attr::UnsignedInt(ty) => {\n                 ConstInt::new_unsigned_truncating(discr, ty,\n-                                                  tcx.sess.target.uint_type)\n+                                                  tcx.sess.target.usize_ty)\n             }\n             attr::SignedInt(ty) => {\n                 ConstInt::new_signed_truncating(discr as i128, ty,\n-                                                tcx.sess.target.int_type)\n+                                                tcx.sess.target.isize_ty)\n             }\n         }\n     }"}, {"sha": "309880ba06333174b6dc6b4197f9b90cc9f9ffa5", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 42, "deletions": 4, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -14,9 +14,12 @@\n //! type equality, etc.\n \n use hir::def_id::DefId;\n+use middle::const_val::ConstVal;\n+use traits::Reveal;\n use ty::subst::{Kind, Substs};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::error::{ExpectedFound, TypeError};\n+use util::common::ErrorReported;\n use std::rc::Rc;\n use std::iter;\n use syntax::abi;\n@@ -428,10 +431,45 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n         (&ty::TyArray(a_t, sz_a), &ty::TyArray(b_t, sz_b)) =>\n         {\n             let t = relation.relate(&a_t, &b_t)?;\n-            if sz_a == sz_b {\n-                Ok(tcx.mk_array(t, sz_a))\n-            } else {\n-                Err(TypeError::FixedArraySize(expected_found(relation, &sz_a, &sz_b)))\n+            assert_eq!(sz_a.ty, tcx.types.usize);\n+            assert_eq!(sz_b.ty, tcx.types.usize);\n+            let to_u64 = |x: &'tcx ty::Const<'tcx>| -> Result<u64, ErrorReported> {\n+                match x.val {\n+                    ConstVal::Integral(x) => Ok(x.to_u64().unwrap()),\n+                    ConstVal::Unevaluated(def_id, substs) => {\n+                        // FIXME(eddyb) get the right param_env.\n+                        let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n+                        match tcx.lift_to_global(&substs) {\n+                            Some(substs) => {\n+                                match tcx.const_eval(param_env.and((def_id, substs))) {\n+                                    Ok(&ty::Const { val: ConstVal::Integral(x), .. }) => {\n+                                        return Ok(x.to_u64().unwrap());\n+                                    }\n+                                    _ => {}\n+                                }\n+                            }\n+                            None => {}\n+                        }\n+                        tcx.sess.delay_span_bug(tcx.def_span(def_id),\n+                            \"array length could not be evaluated\");\n+                        Err(ErrorReported)\n+                    }\n+                    _ => bug!(\"arrays should not have {:?} as length\", x)\n+                }\n+            };\n+            match (to_u64(sz_a), to_u64(sz_b)) {\n+                (Ok(sz_a_u64), Ok(sz_b_u64)) => {\n+                    if sz_a_u64 == sz_b_u64 {\n+                        Ok(tcx.mk_ty(ty::TyArray(t, sz_a)))\n+                    } else {\n+                        Err(TypeError::FixedArraySize(\n+                            expected_found(relation, &sz_a_u64, &sz_b_u64)))\n+                    }\n+                }\n+                // We reported an error or will ICE, so we can return TyError.\n+                (Err(ErrorReported), _) | (_, Err(ErrorReported)) => {\n+                    Ok(tcx.types.err)\n+                }\n             }\n         }\n "}, {"sha": "54d55748c8e3a2e5e5179621a01ab3116befcd52", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 213, "deletions": 2, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use infer::type_variable;\n+use middle::const_val::{self, ConstVal, ConstAggregate, ConstEvalErr};\n use ty::{self, Lift, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n@@ -58,6 +59,13 @@ impl<'tcx, T: Lift<'tcx>, E: Lift<'tcx>> Lift<'tcx> for Result<T, E> {\n     }\n }\n \n+impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Box<T> {\n+    type Lifted = Box<T::Lifted>;\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&**self).map(Box::new)\n+    }\n+}\n+\n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for [T] {\n     type Lifted = Vec<T::Lifted>;\n     fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n@@ -209,6 +217,11 @@ impl<'a, 'tcx> Lift<'tcx> for ty::Predicate<'a> {\n             ty::Predicate::ObjectSafe(trait_def_id) => {\n                 Some(ty::Predicate::ObjectSafe(trait_def_id))\n             }\n+            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+                tcx.lift(&substs).map(|substs| {\n+                    ty::Predicate::ConstEvaluatable(def_id, substs)\n+                })\n+            }\n         }\n     }\n }\n@@ -220,6 +233,32 @@ impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::Binder<T> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for ty::ParamEnv<'a> {\n+    type Lifted = ty::ParamEnv<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.caller_bounds).map(|caller_bounds| {\n+            ty::ParamEnv {\n+                reveal: self.reveal,\n+                caller_bounds,\n+            }\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::ParamEnvAnd<'a, T> {\n+    type Lifted = ty::ParamEnvAnd<'tcx, T::Lifted>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.param_env).and_then(|param_env| {\n+            tcx.lift(&self.value).map(|value| {\n+                ty::ParamEnvAnd {\n+                    param_env,\n+                    value,\n+                }\n+            })\n+        })\n+    }\n+}\n+\n impl<'a, 'tcx> Lift<'tcx> for ty::ClosureSubsts<'a> {\n     type Lifted = ty::ClosureSubsts<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n@@ -394,6 +433,64 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for ConstEvalErr<'a> {\n+    type Lifted = ConstEvalErr<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.kind).map(|kind| {\n+            ConstEvalErr {\n+                span: self.span,\n+                kind,\n+            }\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for const_val::ErrKind<'a> {\n+    type Lifted = const_val::ErrKind<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        use middle::const_val::ErrKind::*;\n+\n+        Some(match *self {\n+            CannotCast => CannotCast,\n+            MissingStructField => MissingStructField,\n+            NonConstPath => NonConstPath,\n+            UnimplementedConstVal(s) => UnimplementedConstVal(s),\n+            ExpectedConstTuple => ExpectedConstTuple,\n+            ExpectedConstStruct => ExpectedConstStruct,\n+            IndexedNonVec => IndexedNonVec,\n+            IndexNotUsize => IndexNotUsize,\n+            IndexOutOfBounds { len, index } => IndexOutOfBounds { len, index },\n+            MiscBinaryOp => MiscBinaryOp,\n+            MiscCatchAll => MiscCatchAll,\n+            IndexOpFeatureGated => IndexOpFeatureGated,\n+            Math(ref e) => Math(e.clone()),\n+\n+            LayoutError(ref e) => {\n+                return tcx.lift(e).map(LayoutError)\n+            }\n+            ErroneousReferencedConstant(ref e) => {\n+                return tcx.lift(e).map(ErroneousReferencedConstant)\n+            }\n+\n+            TypeckError => TypeckError,\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for ty::layout::LayoutError<'a> {\n+    type Lifted = ty::layout::LayoutError<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        match *self {\n+            ty::layout::LayoutError::Unknown(ref ty) => {\n+                tcx.lift(ty).map(ty::layout::LayoutError::Unknown)\n+            }\n+            ty::layout::LayoutError::SizeOverflow(ref ty) => {\n+                tcx.lift(ty).map(ty::layout::LayoutError::SizeOverflow)\n+            }\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // TypeFoldable implementations.\n //\n@@ -408,6 +505,13 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n macro_rules! CopyImpls {\n     ($($ty:ty),+) => {\n         $(\n+            impl<'tcx> Lift<'tcx> for $ty {\n+                type Lifted = Self;\n+                fn lift_to_tcx<'a, 'gcx>(&self, _: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self> {\n+                    Some(*self)\n+                }\n+            }\n+\n             impl<'tcx> TypeFoldable<'tcx> for $ty {\n                 fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _: &mut F) -> $ty {\n                     *self\n@@ -551,7 +655,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let sty = match self.sty {\n             ty::TyRawPtr(tm) => ty::TyRawPtr(tm.fold_with(folder)),\n-            ty::TyArray(typ, sz) => ty::TyArray(typ.fold_with(folder), sz),\n+            ty::TyArray(typ, sz) => ty::TyArray(typ.fold_with(folder), sz.fold_with(folder)),\n             ty::TySlice(typ) => ty::TySlice(typ.fold_with(folder)),\n             ty::TyAdt(tid, substs) => ty::TyAdt(tid, substs.fold_with(folder)),\n             ty::TyDynamic(ref trait_ty, ref region) =>\n@@ -589,7 +693,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         match self.sty {\n             ty::TyRawPtr(ref tm) => tm.visit_with(visitor),\n-            ty::TyArray(typ, _sz) => typ.visit_with(visitor),\n+            ty::TyArray(typ, sz) => typ.visit_with(visitor) || sz.visit_with(visitor),\n             ty::TySlice(typ) => typ.visit_with(visitor),\n             ty::TyAdt(_, substs) => substs.visit_with(visitor),\n             ty::TyDynamic(ref trait_ty, ref reg) =>\n@@ -865,6 +969,8 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n                 ty::Predicate::ClosureKind(closure_def_id, kind),\n             ty::Predicate::ObjectSafe(trait_def_id) =>\n                 ty::Predicate::ObjectSafe(trait_def_id),\n+            ty::Predicate::ConstEvaluatable(def_id, substs) =>\n+                ty::Predicate::ConstEvaluatable(def_id, substs.fold_with(folder)),\n         }\n     }\n \n@@ -879,6 +985,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n             ty::Predicate::WellFormed(data) => data.visit_with(visitor),\n             ty::Predicate::ClosureKind(_closure_def_id, _kind) => false,\n             ty::Predicate::ObjectSafe(_trait_def_id) => false,\n+            ty::Predicate::ConstEvaluatable(_def_id, substs) => substs.visit_with(visitor),\n         }\n     }\n }\n@@ -1101,3 +1208,107 @@ impl<'tcx> TypeFoldable<'tcx> for ty::error::TypeError<'tcx> {\n         }\n     }\n }\n+\n+impl<'tcx> TypeFoldable<'tcx> for ConstVal<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        match *self {\n+            ConstVal::Integral(i) => ConstVal::Integral(i),\n+            ConstVal::Float(f) => ConstVal::Float(f),\n+            ConstVal::Str(s) => ConstVal::Str(s),\n+            ConstVal::ByteStr(b) => ConstVal::ByteStr(b),\n+            ConstVal::Bool(b) => ConstVal::Bool(b),\n+            ConstVal::Char(c) => ConstVal::Char(c),\n+            ConstVal::Variant(def_id) => ConstVal::Variant(def_id),\n+            ConstVal::Function(def_id, substs) => {\n+                ConstVal::Function(def_id, substs.fold_with(folder))\n+            }\n+            ConstVal::Aggregate(ConstAggregate::Struct(fields)) => {\n+                let new_fields: Vec<_> = fields.iter().map(|&(name, v)| {\n+                    (name, v.fold_with(folder))\n+                }).collect();\n+                let fields = if new_fields == fields {\n+                    fields\n+                } else {\n+                    folder.tcx().alloc_name_const_slice(&new_fields)\n+                };\n+                ConstVal::Aggregate(ConstAggregate::Struct(fields))\n+            }\n+            ConstVal::Aggregate(ConstAggregate::Tuple(fields)) => {\n+                let new_fields: Vec<_> = fields.iter().map(|v| {\n+                    v.fold_with(folder)\n+                }).collect();\n+                let fields = if new_fields == fields {\n+                    fields\n+                } else {\n+                    folder.tcx().alloc_const_slice(&new_fields)\n+                };\n+                ConstVal::Aggregate(ConstAggregate::Tuple(fields))\n+            }\n+            ConstVal::Aggregate(ConstAggregate::Array(fields)) => {\n+                let new_fields: Vec<_> = fields.iter().map(|v| {\n+                    v.fold_with(folder)\n+                }).collect();\n+                let fields = if new_fields == fields {\n+                    fields\n+                } else {\n+                    folder.tcx().alloc_const_slice(&new_fields)\n+                };\n+                ConstVal::Aggregate(ConstAggregate::Array(fields))\n+            }\n+            ConstVal::Aggregate(ConstAggregate::Repeat(v, count)) => {\n+                let v = v.fold_with(folder);\n+                ConstVal::Aggregate(ConstAggregate::Repeat(v, count))\n+            }\n+            ConstVal::Unevaluated(def_id, substs) => {\n+                ConstVal::Unevaluated(def_id, substs.fold_with(folder))\n+            }\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        match *self {\n+            ConstVal::Integral(_) |\n+            ConstVal::Float(_) |\n+            ConstVal::Str(_) |\n+            ConstVal::ByteStr(_) |\n+            ConstVal::Bool(_) |\n+            ConstVal::Char(_) |\n+            ConstVal::Variant(_) => false,\n+            ConstVal::Function(_, substs) => substs.visit_with(visitor),\n+            ConstVal::Aggregate(ConstAggregate::Struct(fields)) => {\n+                fields.iter().any(|&(_, v)| v.visit_with(visitor))\n+            }\n+            ConstVal::Aggregate(ConstAggregate::Tuple(fields)) |\n+            ConstVal::Aggregate(ConstAggregate::Array(fields)) => {\n+                fields.iter().any(|v| v.visit_with(visitor))\n+            }\n+            ConstVal::Aggregate(ConstAggregate::Repeat(v, _)) => {\n+                v.visit_with(visitor)\n+            }\n+            ConstVal::Unevaluated(_, substs) => substs.visit_with(visitor),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Const<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        let ty = self.ty.fold_with(folder);\n+        let val = self.val.fold_with(folder);\n+        folder.tcx().mk_const(ty::Const {\n+            ty,\n+            val\n+        })\n+    }\n+\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        folder.fold_const(*self)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.ty.visit_with(visitor) || self.val.visit_with(visitor)\n+    }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        visitor.visit_const(self)\n+    }\n+}"}, {"sha": "f17f81ca06bea5bbc2534887b003bdee9dd0d544", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -12,6 +12,7 @@\n \n use hir::def_id::DefId;\n \n+use middle::const_val::ConstVal;\n use middle::region;\n use ty::subst::{Substs, Subst};\n use ty::{self, AdtDef, TypeFlags, Ty, TyCtxt, TypeFoldable};\n@@ -109,7 +110,7 @@ pub enum TypeVariants<'tcx> {\n     TyStr,\n \n     /// An array with the given length. Written as `[T; n]`.\n-    TyArray(Ty<'tcx>, usize),\n+    TyArray(Ty<'tcx>, &'tcx ty::Const<'tcx>),\n \n     /// The pointee of an array slice.  Written as `[T]`.\n     TySlice(Ty<'tcx>),\n@@ -1458,3 +1459,14 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n }\n+\n+/// Typed constant value.\n+#[derive(Copy, Clone, Debug, Hash, RustcEncodable, RustcDecodable, Eq, PartialEq)]\n+pub struct Const<'tcx> {\n+    pub ty: Ty<'tcx>,\n+\n+    // FIXME(eddyb) Replace this with a miri value.\n+    pub val: ConstVal<'tcx>,\n+}\n+\n+impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Const<'tcx> {}"}, {"sha": "16ae3cdbf1796964dd217da36a7324725a43fdd6", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -13,6 +13,7 @@\n use hir::def_id::{DefId, LOCAL_CRATE};\n use hir::map::DefPathData;\n use ich::{StableHashingContext, NodeIdHashingMode};\n+use middle::const_val::ConstVal;\n use traits::{self, Reveal};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::fold::TypeVisitor;\n@@ -53,7 +54,7 @@ macro_rules! typed_literal {\n             SignedInt(ast::IntTy::I32)   => ConstInt::I32($lit),\n             SignedInt(ast::IntTy::I64)   => ConstInt::I64($lit),\n             SignedInt(ast::IntTy::I128)   => ConstInt::I128($lit),\n-            SignedInt(ast::IntTy::Is) => match $tcx.sess.target.int_type {\n+            SignedInt(ast::IntTy::Is) => match $tcx.sess.target.isize_ty {\n                 ast::IntTy::I16 => ConstInt::Isize(ConstIsize::Is16($lit)),\n                 ast::IntTy::I32 => ConstInt::Isize(ConstIsize::Is32($lit)),\n                 ast::IntTy::I64 => ConstInt::Isize(ConstIsize::Is64($lit)),\n@@ -64,7 +65,7 @@ macro_rules! typed_literal {\n             UnsignedInt(ast::UintTy::U32) => ConstInt::U32($lit),\n             UnsignedInt(ast::UintTy::U64) => ConstInt::U64($lit),\n             UnsignedInt(ast::UintTy::U128) => ConstInt::U128($lit),\n-            UnsignedInt(ast::UintTy::Us) => match $tcx.sess.target.uint_type {\n+            UnsignedInt(ast::UintTy::Us) => match $tcx.sess.target.usize_ty {\n                 ast::UintTy::U16 => ConstInt::Usize(ConstUsize::Us16($lit)),\n                 ast::UintTy::U32 => ConstInt::Usize(ConstUsize::Us32($lit)),\n                 ast::UintTy::U64 => ConstInt::Usize(ConstUsize::Us64($lit)),\n@@ -388,7 +389,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     ty::Predicate::WellFormed(..) |\n                     ty::Predicate::ObjectSafe(..) |\n                     ty::Predicate::ClosureKind(..) |\n-                    ty::Predicate::RegionOutlives(..) => {\n+                    ty::Predicate::RegionOutlives(..) |\n+                    ty::Predicate::ConstEvaluatable(..) => {\n                         None\n                     }\n                     ty::Predicate::TypeOutlives(ty::Binder(ty::OutlivesPredicate(t, r))) => {\n@@ -638,7 +640,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn const_usize(&self, val: u16) -> ConstInt {\n-        match self.sess.target.uint_type {\n+        match self.sess.target.usize_ty {\n             ast::UintTy::U16 => ConstInt::Usize(ConstUsize::Us16(val as u16)),\n             ast::UintTy::U32 => ConstInt::Usize(ConstUsize::Us32(val as u32)),\n             ast::UintTy::U64 => ConstInt::Usize(ConstUsize::Us64(val as u64)),\n@@ -697,7 +699,14 @@ impl<'a, 'gcx, 'tcx, W> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, W>\n             TyInt(i) => self.hash(i),\n             TyUint(u) => self.hash(u),\n             TyFloat(f) => self.hash(f),\n-            TyArray(_, n) => self.hash(n),\n+            TyArray(_, n) => {\n+                self.hash_discriminant_u8(&n.val);\n+                match n.val {\n+                    ConstVal::Integral(x) => self.hash(x.to_u64().unwrap()),\n+                    ConstVal::Unevaluated(def_id, _) => self.def_id(def_id),\n+                    _ => bug!(\"arrays should not have {:?} as length\", n)\n+                }\n+            }\n             TyRawPtr(m) |\n             TyRef(_, m) => self.hash(m.mutbl),\n             TyClosure(def_id, _) |"}, {"sha": "df07844ccebaf040be2661872903aee9f3c1e823", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 40, "deletions": 6, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -11,6 +11,7 @@\n //! An iterator over the type substructure.\n //! WARNING: this does not keep track of the region depth.\n \n+use middle::const_val::{ConstVal, ConstAggregate};\n use ty::{self, Ty};\n use rustc_data_structures::small_vec::SmallVec;\n use rustc_data_structures::accumulate_vec::IntoIter as AccIntoIter;\n@@ -83,7 +84,11 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n         ty::TyBool | ty::TyChar | ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) |\n         ty::TyStr | ty::TyInfer(_) | ty::TyParam(_) | ty::TyNever | ty::TyError => {\n         }\n-        ty::TyArray(ty, _) | ty::TySlice(ty) => {\n+        ty::TyArray(ty, len) => {\n+            push_const(stack, len);\n+            stack.push(ty);\n+        }\n+        ty::TySlice(ty) => {\n             stack.push(ty);\n         }\n         ty::TyRawPtr(ref mt) | ty::TyRef(_, ref mt) => {\n@@ -122,13 +127,42 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n         ty::TyFnDef(_, substs) => {\n             stack.extend(substs.types().rev());\n         }\n-        ty::TyFnPtr(ft) => {\n-            push_sig_subtypes(stack, ft);\n+        ty::TyFnPtr(sig) => {\n+            stack.push(sig.skip_binder().output());\n+            stack.extend(sig.skip_binder().inputs().iter().cloned().rev());\n         }\n     }\n }\n \n-fn push_sig_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, sig: ty::PolyFnSig<'tcx>) {\n-    stack.push(sig.skip_binder().output());\n-    stack.extend(sig.skip_binder().inputs().iter().cloned().rev());\n+fn push_const<'tcx>(stack: &mut TypeWalkerStack<'tcx>, constant: &'tcx ty::Const<'tcx>) {\n+    match constant.val {\n+        ConstVal::Integral(_) |\n+        ConstVal::Float(_) |\n+        ConstVal::Str(_) |\n+        ConstVal::ByteStr(_) |\n+        ConstVal::Bool(_) |\n+        ConstVal::Char(_) |\n+        ConstVal::Variant(_) => {}\n+        ConstVal::Function(_, substs) => {\n+            stack.extend(substs.types().rev());\n+        }\n+        ConstVal::Aggregate(ConstAggregate::Struct(fields)) => {\n+            for &(_, v) in fields.iter().rev() {\n+                push_const(stack, v);\n+            }\n+        }\n+        ConstVal::Aggregate(ConstAggregate::Tuple(fields)) |\n+        ConstVal::Aggregate(ConstAggregate::Array(fields)) => {\n+            for v in fields.iter().rev() {\n+                push_const(stack, v);\n+            }\n+        }\n+        ConstVal::Aggregate(ConstAggregate::Repeat(v, _)) => {\n+            push_const(stack, v);\n+        }\n+        ConstVal::Unevaluated(_, substs) => {\n+            stack.extend(substs.types().rev());\n+        }\n+    }\n+    stack.push(constant.ty);\n }"}, {"sha": "41e27fca3f320ce0c43738808ce0f310199add97", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 56, "deletions": 2, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use hir::def_id::DefId;\n+use middle::const_val::{ConstVal, ConstAggregate};\n use infer::InferCtxt;\n use ty::subst::Substs;\n use traits;\n@@ -101,6 +102,14 @@ pub fn predicate_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n             wf.compute(data.skip_binder().a); // (*)\n             wf.compute(data.skip_binder().b); // (*)\n         }\n+        ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+            let obligations = wf.nominal_obligations(def_id, substs);\n+            wf.out.extend(obligations);\n+\n+            for ty in substs.types() {\n+                wf.compute(ty);\n+            }\n+        }\n     }\n \n     wf.normalize()\n@@ -207,6 +216,46 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// Pushes the obligations required for a constant value to be WF\n+    /// into `self.out`.\n+    fn compute_const(&mut self, constant: &'tcx ty::Const<'tcx>) {\n+        self.require_sized(constant.ty, traits::ConstSized);\n+        match constant.val {\n+            ConstVal::Integral(_) |\n+            ConstVal::Float(_) |\n+            ConstVal::Str(_) |\n+            ConstVal::ByteStr(_) |\n+            ConstVal::Bool(_) |\n+            ConstVal::Char(_) |\n+            ConstVal::Variant(_) |\n+            ConstVal::Function(..) => {}\n+            ConstVal::Aggregate(ConstAggregate::Struct(fields)) => {\n+                for &(_, v) in fields {\n+                    self.compute_const(v);\n+                }\n+            }\n+            ConstVal::Aggregate(ConstAggregate::Tuple(fields)) |\n+            ConstVal::Aggregate(ConstAggregate::Array(fields)) => {\n+                for v in fields {\n+                    self.compute_const(v);\n+                }\n+            }\n+            ConstVal::Aggregate(ConstAggregate::Repeat(v, _)) => {\n+                self.compute_const(v);\n+            }\n+            ConstVal::Unevaluated(def_id, substs) => {\n+                let obligations = self.nominal_obligations(def_id, substs);\n+                self.out.extend(obligations);\n+\n+                let predicate = ty::Predicate::ConstEvaluatable(def_id, substs);\n+                let cause = self.cause(traits::MiscObligation);\n+                self.out.push(traits::Obligation::new(cause,\n+                                                      self.param_env,\n+                                                      predicate));\n+            }\n+        }\n+    }\n+\n     fn require_sized(&mut self, subty: Ty<'tcx>, cause: traits::ObligationCauseCode<'tcx>) {\n         if !subty.has_escaping_regions() {\n             let cause = self.cause(cause);\n@@ -239,9 +288,14 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     // WfScalar, WfParameter, etc\n                 }\n \n-                ty::TySlice(subty) |\n-                ty::TyArray(subty, _) => {\n+                ty::TySlice(subty) => {\n+                    self.require_sized(subty, traits::SliceOrArrayElem);\n+                }\n+\n+                ty::TyArray(subty, len) => {\n                     self.require_sized(subty, traits::SliceOrArrayElem);\n+                    assert_eq!(len.ty, self.infcx.tcx.types.usize);\n+                    self.compute_const(len);\n                 }\n \n                 ty::TyTuple(ref tys, _) => {"}, {"sha": "cf7a29d2845ac8c58c57c7537f6fbb9c77945a42", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -10,6 +10,7 @@\n \n use hir::def_id::DefId;\n use hir::map::definitions::DefPathData;\n+use middle::const_val::ConstVal;\n use middle::region::{self, BlockRemainder};\n use ty::subst::{self, Subst};\n use ty::{BrAnon, BrEnv, BrFresh, BrNamed};\n@@ -24,6 +25,7 @@ use std::cell::Cell;\n use std::fmt;\n use std::usize;\n \n+use rustc_const_math::ConstInt;\n use syntax::abi::Abi;\n use syntax::ast::CRATE_NODE_ID;\n use syntax::symbol::Symbol;\n@@ -428,6 +430,9 @@ impl<'tcx> fmt::Debug for ty::Predicate<'tcx> {\n             ty::Predicate::ClosureKind(closure_def_id, kind) => {\n                 write!(f, \"ClosureKind({:?}, {:?})\", closure_def_id, kind)\n             }\n+            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+                write!(f, \"ConstEvaluatable({:?}, {:?})\", def_id, substs)\n+            }\n         }\n     }\n }\n@@ -886,7 +891,21 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n \n                 write!(f, \"]\")\n             }),\n-            TyArray(ty, sz) => write!(f, \"[{}; {}]\",  ty, sz),\n+            TyArray(ty, sz) => {\n+                write!(f, \"[{}; \", ty)?;\n+                match sz.val {\n+                    ConstVal::Integral(ConstInt::Usize(sz)) => {\n+                        write!(f, \"{}\", sz)?;\n+                    }\n+                    ConstVal::Unevaluated(_def_id, substs) => {\n+                        write!(f, \"<unevaluated{:?}>\", &substs[..])?;\n+                    }\n+                    _ => {\n+                        write!(f, \"{:?}\", sz)?;\n+                    }\n+                }\n+                write!(f, \"]\")\n+            }\n             TySlice(ty) => write!(f, \"[{}]\",  ty)\n         }\n     }\n@@ -1035,6 +1054,11 @@ impl<'tcx> fmt::Display for ty::Predicate<'tcx> {\n                     write!(f, \"the closure `{}` implements the trait `{}`\",\n                            tcx.item_path_str(closure_def_id), kind)\n                 }),\n+            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+                write!(f, \"the constant `\")?;\n+                parameterized(f, substs, def_id, &[])?;\n+                write!(f, \"` can be evaluated\")\n+            }\n         }\n     }\n }"}, {"sha": "b836b71e74bf65227e8ef9c3d2b2b8e45262299d", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 67, "deletions": 53, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -182,13 +182,16 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n         self.byte_array_map.entry(pat).or_insert_with(|| {\n             match pat.kind {\n                 box PatternKind::Constant {\n-                    value: ConstVal::ByteStr(ref data)\n+                    value: &ty::Const { val: ConstVal::ByteStr(b), .. }\n                 } => {\n-                    data.iter().map(|c| &*pattern_arena.alloc(Pattern {\n+                    b.data.iter().map(|&b| &*pattern_arena.alloc(Pattern {\n                         ty: tcx.types.u8,\n                         span: pat.span,\n                         kind: box PatternKind::Constant {\n-                            value: ConstVal::Integral(ConstInt::U8(*c))\n+                            value: tcx.mk_const(ty::Const {\n+                                val: ConstVal::Integral(ConstInt::U8(b)),\n+                                ty: tcx.types.u8\n+                            })\n                         }\n                     })).collect()\n                 }\n@@ -228,11 +231,11 @@ pub enum Constructor<'tcx> {\n     /// Enum variants.\n     Variant(DefId),\n     /// Literal values.\n-    ConstantValue(ConstVal<'tcx>),\n+    ConstantValue(&'tcx ty::Const<'tcx>),\n     /// Ranges of literal values (`2...5` and `2..5`).\n-    ConstantRange(ConstVal<'tcx>, ConstVal<'tcx>, RangeEnd),\n+    ConstantRange(&'tcx ty::Const<'tcx>, &'tcx ty::Const<'tcx>, RangeEnd),\n     /// Array patterns of length n.\n-    Slice(usize),\n+    Slice(u64),\n }\n \n impl<'tcx> Constructor<'tcx> {\n@@ -273,7 +276,7 @@ pub enum WitnessPreference {\n #[derive(Copy, Clone, Debug)]\n struct PatternContext<'tcx> {\n     ty: Ty<'tcx>,\n-    max_slice_length: usize,\n+    max_slice_length: u64,\n }\n \n /// A stack of patterns in reverse order of construction\n@@ -327,8 +330,8 @@ impl<'tcx> Witness<'tcx> {\n     {\n         let arity = constructor_arity(cx, ctor, ty);\n         let pat = {\n-            let len = self.0.len();\n-            let mut pats = self.0.drain(len-arity..).rev();\n+            let len = self.0.len() as u64;\n+            let mut pats = self.0.drain((len-arity) as usize..).rev();\n \n             match ty.sty {\n                 ty::TyAdt(..) |\n@@ -370,7 +373,7 @@ impl<'tcx> Witness<'tcx> {\n \n                 _ => {\n                     match *ctor {\n-                        ConstantValue(ref v) => PatternKind::Constant { value: v.clone() },\n+                        ConstantValue(value) => PatternKind::Constant { value },\n                         _ => PatternKind::Wild,\n                     }\n                 }\n@@ -404,22 +407,31 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n {\n     debug!(\"all_constructors({:?})\", pcx.ty);\n     match pcx.ty.sty {\n-        ty::TyBool =>\n-            [true, false].iter().map(|b| ConstantValue(ConstVal::Bool(*b))).collect(),\n+        ty::TyBool => {\n+            [true, false].iter().map(|&b| {\n+                ConstantValue(cx.tcx.mk_const(ty::Const {\n+                    val: ConstVal::Bool(b),\n+                    ty: cx.tcx.types.bool\n+                }))\n+            }).collect()\n+        }\n+        ty::TyArray(ref sub_ty, len) if len.val.to_const_int().is_some() => {\n+            let len = len.val.to_const_int().unwrap().to_u64().unwrap();\n+            if len != 0 && cx.is_uninhabited(sub_ty) {\n+                vec![]\n+            } else {\n+                vec![Slice(len)]\n+            }\n+        }\n+        // Treat arrays of a constant but unknown length like slices.\n+        ty::TyArray(ref sub_ty, _) |\n         ty::TySlice(ref sub_ty) => {\n             if cx.is_uninhabited(sub_ty) {\n                 vec![Slice(0)]\n             } else {\n                 (0..pcx.max_slice_length+1).map(|length| Slice(length)).collect()\n             }\n         }\n-        ty::TyArray(ref sub_ty, length) => {\n-            if length > 0 && cx.is_uninhabited(sub_ty) {\n-                vec![]\n-            } else {\n-                vec![Slice(length)]\n-            }\n-        }\n         ty::TyAdt(def, substs) if def.is_enum() && def.variants.len() != 1 => {\n             def.variants.iter()\n                 .filter(|v| !cx.is_variant_uninhabited(v, substs))\n@@ -438,7 +450,7 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n \n fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n     _cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-    patterns: I) -> usize\n+    patterns: I) -> u64\n     where I: Iterator<Item=&'p Pattern<'tcx>>\n {\n     // The exhaustiveness-checking paper does not include any details on\n@@ -511,16 +523,16 @@ fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n \n     for row in patterns {\n         match *row.kind {\n-            PatternKind::Constant { value: ConstVal::ByteStr(ref data) } => {\n-                max_fixed_len = cmp::max(max_fixed_len, data.len());\n+            PatternKind::Constant { value: &ty::Const { val: ConstVal::ByteStr(b), .. } } => {\n+                max_fixed_len = cmp::max(max_fixed_len, b.data.len() as u64);\n             }\n             PatternKind::Slice { ref prefix, slice: None, ref suffix } => {\n-                let fixed_len = prefix.len() + suffix.len();\n+                let fixed_len = prefix.len() as u64 + suffix.len() as u64;\n                 max_fixed_len = cmp::max(max_fixed_len, fixed_len);\n             }\n             PatternKind::Slice { ref prefix, slice: Some(_), ref suffix } => {\n-                max_prefix_len = cmp::max(max_prefix_len, prefix.len());\n-                max_suffix_len = cmp::max(max_suffix_len, suffix.len());\n+                max_prefix_len = cmp::max(max_prefix_len, prefix.len() as u64);\n+                max_suffix_len = cmp::max(max_suffix_len, suffix.len() as u64);\n             }\n             _ => {}\n         }\n@@ -715,16 +727,18 @@ fn pat_constructors<'tcx>(_cx: &mut MatchCheckCtxt,\n             Some(vec![Single]),\n         PatternKind::Variant { adt_def, variant_index, .. } =>\n             Some(vec![Variant(adt_def.variants[variant_index].did)]),\n-        PatternKind::Constant { ref value } =>\n-            Some(vec![ConstantValue(value.clone())]),\n-        PatternKind::Range { ref lo, ref hi, ref end } =>\n-            Some(vec![ConstantRange(lo.clone(), hi.clone(), end.clone())]),\n+        PatternKind::Constant { value } =>\n+            Some(vec![ConstantValue(value)]),\n+        PatternKind::Range { lo, hi, end } =>\n+            Some(vec![ConstantRange(lo, hi, end)]),\n         PatternKind::Array { .. } => match pcx.ty.sty {\n-            ty::TyArray(_, length) => Some(vec![Slice(length)]),\n+            ty::TyArray(_, length) => Some(vec![\n+                Slice(length.val.to_const_int().unwrap().to_u64().unwrap())\n+            ]),\n             _ => span_bug!(pat.span, \"bad ty {:?} for array pattern\", pcx.ty)\n         },\n         PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n-            let pat_len = prefix.len() + suffix.len();\n+            let pat_len = prefix.len() as u64 + suffix.len() as u64;\n             if slice.is_some() {\n                 Some((pat_len..pcx.max_slice_length+1).map(Slice).collect())\n             } else {\n@@ -739,18 +753,18 @@ fn pat_constructors<'tcx>(_cx: &mut MatchCheckCtxt,\n ///\n /// For instance, a tuple pattern (_, 42, Some([])) has the arity of 3.\n /// A struct pattern's arity is the number of fields it contains, etc.\n-fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usize {\n+fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> u64 {\n     debug!(\"constructor_arity({:?}, {:?})\", ctor, ty);\n     match ty.sty {\n-        ty::TyTuple(ref fs, _) => fs.len(),\n+        ty::TyTuple(ref fs, _) => fs.len() as u64,\n         ty::TySlice(..) | ty::TyArray(..) => match *ctor {\n             Slice(length) => length,\n             ConstantValue(_) => 0,\n             _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty)\n         },\n         ty::TyRef(..) => 1,\n         ty::TyAdt(adt, _) => {\n-            adt.variants[ctor.variant_index_for_adt(adt)].fields.len()\n+            adt.variants[ctor.variant_index_for_adt(adt)].fields.len() as u64\n         }\n         _ => 0\n     }\n@@ -768,7 +782,7 @@ fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n     match ty.sty {\n         ty::TyTuple(ref fs, _) => fs.into_iter().map(|t| *t).collect(),\n         ty::TySlice(ty) | ty::TyArray(ty, _) => match *ctor {\n-            Slice(length) => repeat(ty).take(length).collect(),\n+            Slice(length) => (0..length).map(|_| ty).collect(),\n             ConstantValue(_) => vec![],\n             _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty)\n         },\n@@ -806,7 +820,7 @@ fn slice_pat_covered_by_constructor(_tcx: TyCtxt, _span: Span,\n                                     suffix: &[Pattern])\n                                     -> Result<bool, ErrorReported> {\n     let data = match *ctor {\n-        ConstantValue(ConstVal::ByteStr(ref data)) => data,\n+        ConstantValue(&ty::Const { val: ConstVal::ByteStr(b), .. }) => b.data,\n         _ => bug!()\n     };\n \n@@ -820,7 +834,7 @@ fn slice_pat_covered_by_constructor(_tcx: TyCtxt, _span: Span,\n             data[data.len()-suffix.len()..].iter().zip(suffix))\n     {\n         match pat.kind {\n-            box PatternKind::Constant { ref value } => match *value {\n+            box PatternKind::Constant { value } => match value.val {\n                 ConstVal::Integral(ConstInt::U8(u)) => {\n                     if u != *ch {\n                         return Ok(false);\n@@ -843,23 +857,23 @@ fn constructor_covered_by_range(tcx: TyCtxt, span: Span,\n     let cmp_from = |c_from| Ok(compare_const_vals(tcx, span, c_from, from)? != Ordering::Less);\n     let cmp_to = |c_to| compare_const_vals(tcx, span, c_to, to);\n     match *ctor {\n-        ConstantValue(ref value) => {\n-            let to = cmp_to(value)?;\n+        ConstantValue(value) => {\n+            let to = cmp_to(&value.val)?;\n             let end = (to == Ordering::Less) ||\n                       (end == RangeEnd::Included && to == Ordering::Equal);\n-            Ok(cmp_from(value)? && end)\n+            Ok(cmp_from(&value.val)? && end)\n         },\n-        ConstantRange(ref from, ref to, RangeEnd::Included) => {\n-            let to = cmp_to(to)?;\n+        ConstantRange(from, to, RangeEnd::Included) => {\n+            let to = cmp_to(&to.val)?;\n             let end = (to == Ordering::Less) ||\n                       (end == RangeEnd::Included && to == Ordering::Equal);\n-            Ok(cmp_from(from)? && end)\n+            Ok(cmp_from(&from.val)? && end)\n         },\n-        ConstantRange(ref from, ref to, RangeEnd::Excluded) => {\n-            let to = cmp_to(to)?;\n+        ConstantRange(from, to, RangeEnd::Excluded) => {\n+            let to = cmp_to(&to.val)?;\n             let end = (to == Ordering::Less) ||\n                       (end == RangeEnd::Excluded && to == Ordering::Equal);\n-            Ok(cmp_from(from)? && end)\n+            Ok(cmp_from(&from.val)? && end)\n         }\n         Single => Ok(true),\n         _ => bug!(),\n@@ -919,11 +933,11 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n             Some(vec![subpattern])\n         }\n \n-        PatternKind::Constant { ref value } => {\n+        PatternKind::Constant { value } => {\n             match *constructor {\n-                Slice(..) => match *value {\n-                    ConstVal::ByteStr(ref data) => {\n-                        if wild_patterns.len() == data.len() {\n+                Slice(..) => match value.val {\n+                    ConstVal::ByteStr(b) => {\n+                        if wild_patterns.len() == b.data.len() {\n                             Some(cx.lower_byte_str_pattern(pat))\n                         } else {\n                             None\n@@ -934,7 +948,7 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                 },\n                 _ => {\n                     match constructor_covered_by_range(\n-                        cx.tcx, pat.span, constructor, value, value, RangeEnd::Included\n+                        cx.tcx, pat.span, constructor, &value.val, &value.val, RangeEnd::Included\n                             ) {\n                         Ok(true) => Some(vec![]),\n                         Ok(false) => None,\n@@ -944,9 +958,9 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n             }\n         }\n \n-        PatternKind::Range { ref lo, ref hi, ref end } => {\n+        PatternKind::Range { lo, hi, ref end } => {\n             match constructor_covered_by_range(\n-                cx.tcx, pat.span, constructor, lo, hi, end.clone()\n+                cx.tcx, pat.span, constructor, &lo.val, &hi.val, end.clone()\n             ) {\n                 Ok(true) => Some(vec![]),\n                 Ok(false) => None,"}, {"sha": "0339969f2b45adf21fc79436d94b08806e618f6c", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -140,7 +140,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n     fn check_match(\n         &self,\n         scrut: &hir::Expr,\n-        arms: &[hir::Arm],\n+        arms: &'tcx [hir::Arm],\n         source: hir::MatchSource)\n     {\n         for arm in arms {\n@@ -231,7 +231,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn check_irrefutable(&self, pat: &Pat, origin: &str) {\n+    fn check_irrefutable(&self, pat: &'tcx Pat, origin: &str) {\n         let module = self.tcx.hir.get_module_parent(pat.id);\n         MatchCheckCtxt::create_and_enter(self.tcx, module, |ref mut cx| {\n             let mut patcx = PatternContext::new(self.tcx,"}, {"sha": "d01b3c45f7fd1642603e3402008addf6085d6c5f", "filename": "src/librustc_const_eval/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fdiagnostics.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -565,7 +565,7 @@ See also https://github.com/rust-lang/rust/issues/14587\n \n \n register_diagnostics! {\n-    E0298, // cannot compare constants\n+//  E0298, // cannot compare constants\n //  E0299, // mismatched types between arms\n //  E0471, // constant evaluation error (in pattern)\n }"}, {"sha": "61eb5dfd18b9c15537edac5e250f5da7ae48d015", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 102, "deletions": 86, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -9,8 +9,9 @@\n // except according to those terms.\n \n use rustc::middle::const_val::ConstVal::*;\n+use rustc::middle::const_val::ConstAggregate::*;\n use rustc::middle::const_val::ErrKind::*;\n-use rustc::middle::const_val::{ConstVal, ConstEvalErr, EvalResult, ErrKind};\n+use rustc::middle::const_val::{ByteArray, ConstVal, ConstEvalErr, EvalResult, ErrKind};\n \n use rustc::hir::map as hir_map;\n use rustc::hir::map::blocks::FnLikeNode;\n@@ -88,7 +89,7 @@ pub struct ConstContext<'a, 'tcx: 'a> {\n     tables: &'a ty::TypeckTables<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     substs: &'tcx Substs<'tcx>,\n-    fn_args: Option<NodeMap<ConstVal<'tcx>>>\n+    fn_args: Option<NodeMap<&'tcx ty::Const<'tcx>>>\n }\n \n impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n@@ -107,7 +108,7 @@ impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n \n     /// Evaluate a constant expression in a context where the expression isn't\n     /// guaranteed to be evaluable.\n-    pub fn eval(&self, e: &Expr) -> EvalResult<'tcx> {\n+    pub fn eval(&self, e: &'tcx Expr) -> EvalResult<'tcx> {\n         if self.tables.tainted_by_errors {\n             signal!(e, TypeckError);\n         }\n@@ -118,9 +119,10 @@ impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n type CastResult<'tcx> = Result<ConstVal<'tcx>, ErrKind<'tcx>>;\n \n fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n-                                     e: &Expr) -> EvalResult<'tcx> {\n+                                     e: &'tcx Expr) -> EvalResult<'tcx> {\n     let tcx = cx.tcx;\n-    let ety = cx.tables.expr_ty(e).subst(tcx, cx.substs);\n+    let ty = cx.tables.expr_ty(e).subst(tcx, cx.substs);\n+    let mk_const = |val| tcx.mk_const(ty::Const { val, ty });\n \n     let result = match e.node {\n       hir::ExprUnary(hir::UnNeg, ref inner) => {\n@@ -133,65 +135,74 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n             const I32_OVERFLOW: u128 = i32::min_value() as u32 as u128;\n             const I64_OVERFLOW: u128 = i64::min_value() as u64 as u128;\n             const I128_OVERFLOW: u128 = i128::min_value() as u128;\n-            match (&lit.node, &ety.sty) {\n+            let negated = match (&lit.node, &ty.sty) {\n                 (&LitKind::Int(I8_OVERFLOW, _), &ty::TyInt(IntTy::I8)) |\n                 (&LitKind::Int(I8_OVERFLOW, Signed(IntTy::I8)), _) => {\n-                    return Ok(Integral(I8(i8::min_value())))\n+                    Some(I8(i8::min_value()))\n                 },\n                 (&LitKind::Int(I16_OVERFLOW, _), &ty::TyInt(IntTy::I16)) |\n                 (&LitKind::Int(I16_OVERFLOW, Signed(IntTy::I16)), _) => {\n-                    return Ok(Integral(I16(i16::min_value())))\n+                    Some(I16(i16::min_value()))\n                 },\n                 (&LitKind::Int(I32_OVERFLOW, _), &ty::TyInt(IntTy::I32)) |\n                 (&LitKind::Int(I32_OVERFLOW, Signed(IntTy::I32)), _) => {\n-                    return Ok(Integral(I32(i32::min_value())))\n+                    Some(I32(i32::min_value()))\n                 },\n                 (&LitKind::Int(I64_OVERFLOW, _), &ty::TyInt(IntTy::I64)) |\n                 (&LitKind::Int(I64_OVERFLOW, Signed(IntTy::I64)), _) => {\n-                    return Ok(Integral(I64(i64::min_value())))\n+                    Some(I64(i64::min_value()))\n                 },\n                 (&LitKind::Int(I128_OVERFLOW, _), &ty::TyInt(IntTy::I128)) |\n                 (&LitKind::Int(I128_OVERFLOW, Signed(IntTy::I128)), _) => {\n-                    return Ok(Integral(I128(i128::min_value())))\n+                    Some(I128(i128::min_value()))\n                 },\n                 (&LitKind::Int(n, _), &ty::TyInt(IntTy::Is)) |\n                 (&LitKind::Int(n, Signed(IntTy::Is)), _) => {\n-                    match tcx.sess.target.int_type {\n+                    match tcx.sess.target.isize_ty {\n                         IntTy::I16 => if n == I16_OVERFLOW {\n-                            return Ok(Integral(Isize(Is16(i16::min_value()))));\n+                            Some(Isize(Is16(i16::min_value())))\n+                        } else {\n+                            None\n                         },\n                         IntTy::I32 => if n == I32_OVERFLOW {\n-                            return Ok(Integral(Isize(Is32(i32::min_value()))));\n+                            Some(Isize(Is32(i32::min_value())))\n+                        } else {\n+                            None\n                         },\n                         IntTy::I64 => if n == I64_OVERFLOW {\n-                            return Ok(Integral(Isize(Is64(i64::min_value()))));\n+                            Some(Isize(Is64(i64::min_value())))\n+                        } else {\n+                            None\n                         },\n                         _ => span_bug!(e.span, \"typeck error\")\n                     }\n                 },\n-                _ => {},\n+                _ => None\n+            };\n+            if let Some(i) = negated {\n+                return Ok(mk_const(Integral(i)));\n             }\n         }\n-        match cx.eval(inner)? {\n+        mk_const(match cx.eval(inner)?.val {\n           Float(f) => Float(-f),\n           Integral(i) => Integral(math!(e, -i)),\n-          const_val => signal!(e, NegateOn(const_val)),\n-        }\n+          _ => signal!(e, TypeckError)\n+        })\n       }\n       hir::ExprUnary(hir::UnNot, ref inner) => {\n-        match cx.eval(inner)? {\n+        mk_const(match cx.eval(inner)?.val {\n           Integral(i) => Integral(math!(e, !i)),\n           Bool(b) => Bool(!b),\n-          const_val => signal!(e, NotOn(const_val)),\n-        }\n+          _ => signal!(e, TypeckError)\n+        })\n       }\n       hir::ExprUnary(hir::UnDeref, _) => signal!(e, UnimplementedConstVal(\"deref operation\")),\n       hir::ExprBinary(op, ref a, ref b) => {\n         // technically, if we don't have type hints, but integral eval\n         // gives us a type through a type-suffix, cast or const def type\n         // we need to re-eval the other value of the BinOp if it was\n         // not inferred\n-        match (cx.eval(a)?, cx.eval(b)?) {\n+        mk_const(match (cx.eval(a)?.val, cx.eval(b)?.val) {\n           (Float(a), Float(b)) => {\n             use std::cmp::Ordering::*;\n             match op.node {\n@@ -260,16 +271,16 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n           }\n \n           _ => signal!(e, MiscBinaryOp),\n-        }\n+        })\n       }\n       hir::ExprCast(ref base, _) => {\n         let base_val = cx.eval(base)?;\n         let base_ty = cx.tables.expr_ty(base).subst(tcx, cx.substs);\n-        if ety == base_ty {\n+        if ty == base_ty {\n             base_val\n         } else {\n-            match cast_const(tcx, base_val, ety) {\n-                Ok(val) => val,\n+            match cast_const(tcx, base_val.val, ty) {\n+                Ok(val) => mk_const(val),\n                 Err(kind) => signal!(e, kind),\n             }\n         }\n@@ -291,52 +302,53 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n                     }\n               },\n               Def::VariantCtor(variant_def, CtorKind::Const) => {\n-                Variant(variant_def)\n+                mk_const(Variant(variant_def))\n               }\n               Def::VariantCtor(_, CtorKind::Fn) => {\n                   signal!(e, UnimplementedConstVal(\"enum variants\"));\n               }\n               Def::StructCtor(_, CtorKind::Const) => {\n-                  ConstVal::Struct(Default::default())\n+                  mk_const(Aggregate(Struct(&[])))\n               }\n               Def::StructCtor(_, CtorKind::Fn) => {\n                   signal!(e, UnimplementedConstVal(\"tuple struct constructors\"))\n               }\n               Def::Local(id) => {\n                   debug!(\"Def::Local({:?}): {:?}\", id, cx.fn_args);\n-                  if let Some(val) = cx.fn_args.as_ref().and_then(|args| args.get(&id)) {\n-                      val.clone()\n+                  if let Some(&val) = cx.fn_args.as_ref().and_then(|args| args.get(&id)) {\n+                      val\n                   } else {\n                       signal!(e, NonConstPath);\n                   }\n               },\n-              Def::Method(id) | Def::Fn(id) => Function(id, substs),\n+              Def::Method(id) | Def::Fn(id) => mk_const(Function(id, substs)),\n               Def::Err => span_bug!(e.span, \"typeck error\"),\n               _ => signal!(e, NonConstPath),\n           }\n       }\n       hir::ExprCall(ref callee, ref args) => {\n-          let (def_id, substs) = match cx.eval(callee)? {\n+          let (def_id, substs) = match cx.eval(callee)?.val {\n               Function(def_id, substs) => (def_id, substs),\n               _ => signal!(e, TypeckError),\n           };\n \n           if tcx.fn_sig(def_id).abi() == Abi::RustIntrinsic {\n             let layout_of = |ty: Ty<'tcx>| {\n-                ty.layout(tcx, cx.param_env).map_err(|err| {\n+                let ty = tcx.erase_regions(&ty);\n+                tcx.at(e.span).layout_raw(cx.param_env.reveal_all().and(ty)).map_err(|err| {\n                     ConstEvalErr { span: e.span, kind: LayoutError(err) }\n                 })\n             };\n             match &tcx.item_name(def_id)[..] {\n                 \"size_of\" => {\n-                    let size = layout_of(substs.type_at(0))?.size(tcx);\n-                    return Ok(Integral(Usize(ConstUsize::new(size.bytes(),\n-                        tcx.sess.target.uint_type).unwrap())));\n+                    let size = layout_of(substs.type_at(0))?.size(tcx).bytes();\n+                    return Ok(mk_const(Integral(Usize(ConstUsize::new(size,\n+                        tcx.sess.target.usize_ty).unwrap()))));\n                 }\n                 \"min_align_of\" => {\n-                    let align = layout_of(substs.type_at(0))?.align(tcx);\n-                    return Ok(Integral(Usize(ConstUsize::new(align.abi(),\n-                        tcx.sess.target.uint_type).unwrap())));\n+                    let align = layout_of(substs.type_at(0))?.align(tcx).abi();\n+                    return Ok(mk_const(Integral(Usize(ConstUsize::new(align,\n+                        tcx.sess.target.usize_ty).unwrap()))));\n                 }\n                 _ => signal!(e, TypeckError)\n             }\n@@ -384,84 +396,83 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n           };\n           callee_cx.eval(&body.value)?\n       },\n-      hir::ExprLit(ref lit) => match lit_to_const(&lit.node, tcx, ety) {\n-          Ok(val) => val,\n+      hir::ExprLit(ref lit) => match lit_to_const(&lit.node, tcx, ty) {\n+          Ok(val) => mk_const(val),\n           Err(err) => signal!(e, err),\n       },\n       hir::ExprBlock(ref block) => {\n         match block.expr {\n             Some(ref expr) => cx.eval(expr)?,\n-            None => Tuple(vec![]),\n+            None => mk_const(Aggregate(Tuple(&[]))),\n         }\n       }\n       hir::ExprType(ref e, _) => cx.eval(e)?,\n       hir::ExprTup(ref fields) => {\n-        Tuple(fields.iter().map(|e| cx.eval(e)).collect::<Result<_, _>>()?)\n+        let values = fields.iter().map(|e| cx.eval(e)).collect::<Result<Vec<_>, _>>()?;\n+        mk_const(Aggregate(Tuple(tcx.alloc_const_slice(&values))))\n       }\n       hir::ExprStruct(_, ref fields, _) => {\n-        Struct(fields.iter().map(|f| {\n+        mk_const(Aggregate(Struct(tcx.alloc_name_const_slice(&fields.iter().map(|f| {\n             cx.eval(&f.expr).map(|v| (f.name.node, v))\n-        }).collect::<Result<_, _>>()?)\n+        }).collect::<Result<Vec<_>, _>>()?))))\n       }\n       hir::ExprIndex(ref arr, ref idx) => {\n         if !tcx.sess.features.borrow().const_indexing {\n             signal!(e, IndexOpFeatureGated);\n         }\n         let arr = cx.eval(arr)?;\n-        let idx = match cx.eval(idx)? {\n-            Integral(Usize(i)) => i.as_u64(tcx.sess.target.uint_type),\n+        let idx = match cx.eval(idx)?.val {\n+            Integral(Usize(i)) => i.as_u64(),\n             _ => signal!(idx, IndexNotUsize),\n         };\n         assert_eq!(idx as usize as u64, idx);\n-        match arr {\n-            Array(ref v) => {\n-                if let Some(elem) = v.get(idx as usize) {\n-                    elem.clone()\n+        match arr.val {\n+            Aggregate(Array(v)) => {\n+                if let Some(&elem) = v.get(idx as usize) {\n+                    elem\n                 } else {\n                     let n = v.len() as u64;\n-                    assert_eq!(n as usize as u64, n);\n                     signal!(e, IndexOutOfBounds { len: n, index: idx })\n                 }\n             }\n \n-            Repeat(.., n) if idx >= n => {\n+            Aggregate(Repeat(.., n)) if idx >= n => {\n                 signal!(e, IndexOutOfBounds { len: n, index: idx })\n             }\n-            Repeat(ref elem, _) => (**elem).clone(),\n+            Aggregate(Repeat(elem, _)) => elem,\n \n-            ByteStr(ref data) if idx >= data.len() as u64 => {\n-                signal!(e, IndexOutOfBounds { len: data.len() as u64, index: idx })\n+            ByteStr(b) if idx >= b.data.len() as u64 => {\n+                signal!(e, IndexOutOfBounds { len: b.data.len() as u64, index: idx })\n             }\n-            ByteStr(data) => {\n-                Integral(U8(data[idx as usize]))\n+            ByteStr(b) => {\n+                mk_const(Integral(U8(b.data[idx as usize])))\n             },\n \n             _ => signal!(e, IndexedNonVec),\n         }\n       }\n       hir::ExprArray(ref v) => {\n-        Array(v.iter().map(|e| cx.eval(e)).collect::<Result<_, _>>()?)\n+        let values = v.iter().map(|e| cx.eval(e)).collect::<Result<Vec<_>, _>>()?;\n+        mk_const(Aggregate(Array(tcx.alloc_const_slice(&values))))\n       }\n       hir::ExprRepeat(ref elem, _) => {\n-          let n = match ety.sty {\n-            ty::TyArray(_, n) => n as u64,\n+          let n = match ty.sty {\n+            ty::TyArray(_, n) => n.val.to_const_int().unwrap().to_u64().unwrap(),\n             _ => span_bug!(e.span, \"typeck error\")\n           };\n-          Repeat(Box::new(cx.eval(elem)?), n)\n+          mk_const(Aggregate(Repeat(cx.eval(elem)?, n)))\n       },\n       hir::ExprTupField(ref base, index) => {\n-        let c = cx.eval(base)?;\n-        if let Tuple(ref fields) = c {\n-            fields[index.node].clone()\n+        if let Aggregate(Tuple(fields)) = cx.eval(base)?.val {\n+            fields[index.node]\n         } else {\n             signal!(base, ExpectedConstTuple);\n         }\n       }\n       hir::ExprField(ref base, field_name) => {\n-        let c = cx.eval(base)?;\n-        if let Struct(ref fields) = c {\n-            if let Some(f) = fields.get(&field_name.node) {\n-                f.clone()\n+        if let Aggregate(Struct(fields)) = cx.eval(base)?.val {\n+            if let Some(&(_, f)) = fields.iter().find(|&&(name, _)| name == field_name.node) {\n+                f\n             } else {\n                 signal!(e, MissingStructField);\n             }\n@@ -551,15 +562,15 @@ fn cast_const_int<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ty::TyInt(ast::IntTy::I64) => Ok(Integral(I64(v as i128 as i64))),\n         ty::TyInt(ast::IntTy::I128) => Ok(Integral(I128(v as i128))),\n         ty::TyInt(ast::IntTy::Is) => {\n-            Ok(Integral(Isize(ConstIsize::new_truncating(v as i128, tcx.sess.target.int_type))))\n+            Ok(Integral(Isize(ConstIsize::new_truncating(v as i128, tcx.sess.target.isize_ty))))\n         },\n         ty::TyUint(ast::UintTy::U8) => Ok(Integral(U8(v as u8))),\n         ty::TyUint(ast::UintTy::U16) => Ok(Integral(U16(v as u16))),\n         ty::TyUint(ast::UintTy::U32) => Ok(Integral(U32(v as u32))),\n         ty::TyUint(ast::UintTy::U64) => Ok(Integral(U64(v as u64))),\n         ty::TyUint(ast::UintTy::U128) => Ok(Integral(U128(v as u128))),\n         ty::TyUint(ast::UintTy::Us) => {\n-            Ok(Integral(Usize(ConstUsize::new_truncating(v, tcx.sess.target.uint_type))))\n+            Ok(Integral(Usize(ConstUsize::new_truncating(v, tcx.sess.target.usize_ty))))\n         },\n         ty::TyFloat(fty) => {\n             if let Some(i) = val.to_u128() {\n@@ -625,7 +636,14 @@ fn cast_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 Err(ErrKind::UnimplementedConstVal(\"casting a bytestr to a raw ptr\"))\n             },\n             ty::TyRef(_, ty::TypeAndMut { ref ty, mutbl: hir::MutImmutable }) => match ty.sty {\n-                ty::TyArray(ty, n) if ty == tcx.types.u8 && n == b.len() => Ok(ByteStr(b)),\n+                ty::TyArray(ty, n) => {\n+                    let n = n.val.to_const_int().unwrap().to_u64().unwrap();\n+                    if ty == tcx.types.u8 && n == b.data.len() as u64 {\n+                        Ok(val)\n+                    } else {\n+                        Err(CannotCast)\n+                    }\n+                }\n                 ty::TySlice(_) => {\n                     Err(ErrKind::UnimplementedConstVal(\"casting a bytestr to slice\"))\n                 },\n@@ -645,7 +663,7 @@ fn cast_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn lit_to_const<'a, 'tcx>(lit: &ast::LitKind,\n+fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           mut ty: Ty<'tcx>)\n                           -> Result<ConstVal<'tcx>, ErrKind<'tcx>> {\n@@ -660,19 +678,19 @@ fn lit_to_const<'a, 'tcx>(lit: &ast::LitKind,\n \n     match *lit {\n         LitKind::Str(ref s, _) => Ok(Str(s.as_str())),\n-        LitKind::ByteStr(ref data) => Ok(ByteStr(data.clone())),\n+        LitKind::ByteStr(ref data) => Ok(ByteStr(ByteArray { data })),\n         LitKind::Byte(n) => Ok(Integral(U8(n))),\n         LitKind::Int(n, hint) => {\n             match (&ty.sty, hint) {\n                 (&ty::TyInt(ity), _) |\n                 (_, Signed(ity)) => {\n                     Ok(Integral(ConstInt::new_signed_truncating(n as i128,\n-                        ity, tcx.sess.target.int_type)))\n+                        ity, tcx.sess.target.isize_ty)))\n                 }\n                 (&ty::TyUint(uty), _) |\n                 (_, Unsigned(uty)) => {\n                     Ok(Integral(ConstInt::new_unsigned_truncating(n as u128,\n-                        uty, tcx.sess.target.uint_type)))\n+                        uty, tcx.sess.target.usize_ty)))\n                 }\n                 _ => bug!()\n             }\n@@ -708,19 +726,17 @@ pub fn compare_const_vals(tcx: TyCtxt, span: Span, a: &ConstVal, b: &ConstVal)\n         (&Float(a), &Float(b)) => a.try_cmp(b).ok(),\n         (&Str(ref a), &Str(ref b)) => Some(a.cmp(b)),\n         (&Bool(a), &Bool(b)) => Some(a.cmp(&b)),\n-        (&ByteStr(ref a), &ByteStr(ref b)) => Some(a.cmp(b)),\n-        (&Char(a), &Char(ref b)) => Some(a.cmp(b)),\n+        (&ByteStr(a), &ByteStr(b)) => Some(a.data.cmp(b.data)),\n+        (&Char(a), &Char(b)) => Some(a.cmp(&b)),\n         _ => None,\n     };\n \n     match result {\n         Some(result) => Ok(result),\n         None => {\n             // FIXME: can this ever be reached?\n-            span_err!(tcx.sess, span, E0298,\n-                      \"type mismatch comparing {} and {}\",\n-                      a.description(),\n-                      b.description());\n+            tcx.sess.delay_span_bug(span,\n+                &format!(\"type mismatch comparing {:?} and {:?}\", a, b));\n             Err(ErrorReported)\n         }\n     }\n@@ -729,8 +745,8 @@ pub fn compare_const_vals(tcx: TyCtxt, span: Span, a: &ConstVal, b: &ConstVal)\n impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n     pub fn compare_lit_exprs(&self,\n                              span: Span,\n-                             a: &Expr,\n-                             b: &Expr) -> Result<Ordering, ErrorReported> {\n+                             a: &'tcx Expr,\n+                             b: &'tcx Expr) -> Result<Ordering, ErrorReported> {\n         let tcx = self.tcx;\n         let a = match self.eval(a) {\n             Ok(a) => a,\n@@ -746,7 +762,7 @@ impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n                 return Err(ErrorReported);\n             }\n         };\n-        compare_const_vals(tcx, span, &a, &b)\n+        compare_const_vals(tcx, span, &a.val, &b.val)\n     }\n }\n "}, {"sha": "a87fa0c2746a3d3b413aa4ee8add356f8ffabce2", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 34, "deletions": 35, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -83,12 +83,12 @@ pub enum PatternKind<'tcx> {\n     },\n \n     Constant {\n-        value: ConstVal<'tcx>,\n+        value: &'tcx ty::Const<'tcx>,\n     },\n \n     Range {\n-        lo: ConstVal<'tcx>,\n-        hi: ConstVal<'tcx>,\n+        lo: &'tcx ty::Const<'tcx>,\n+        hi: &'tcx ty::Const<'tcx>,\n         end: RangeEnd,\n     },\n \n@@ -112,15 +112,13 @@ fn print_const_val(value: &ConstVal, f: &mut fmt::Formatter) -> fmt::Result {\n         ConstVal::Float(ref x) => write!(f, \"{}\", x),\n         ConstVal::Integral(ref i) => write!(f, \"{}\", i),\n         ConstVal::Str(ref s) => write!(f, \"{:?}\", &s[..]),\n-        ConstVal::ByteStr(ref b) => write!(f, \"{:?}\", &b[..]),\n+        ConstVal::ByteStr(b) => write!(f, \"{:?}\", b.data),\n         ConstVal::Bool(b) => write!(f, \"{:?}\", b),\n         ConstVal::Char(c) => write!(f, \"{:?}\", c),\n         ConstVal::Variant(_) |\n-        ConstVal::Struct(_) |\n-        ConstVal::Tuple(_) |\n         ConstVal::Function(..) |\n-        ConstVal::Array(..) |\n-        ConstVal::Repeat(..) => bug!(\"{:?} not printable in a pattern\", value)\n+        ConstVal::Aggregate(_) |\n+        ConstVal::Unevaluated(..) => bug!(\"{:?} not printable in a pattern\", value)\n     }\n }\n \n@@ -230,16 +228,16 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n                 }\n                 write!(f, \"{}\", subpattern)\n             }\n-            PatternKind::Constant { ref value } => {\n-                print_const_val(value, f)\n+            PatternKind::Constant { value } => {\n+                print_const_val(&value.val, f)\n             }\n-            PatternKind::Range { ref lo, ref hi, ref end } => {\n-                print_const_val(lo, f)?;\n-                match *end {\n+            PatternKind::Range { lo, hi, end } => {\n+                print_const_val(&lo.val, f)?;\n+                match end {\n                     RangeEnd::Included => write!(f, \"...\")?,\n                     RangeEnd::Excluded => write!(f, \"..\")?,\n                 }\n-                print_const_val(hi, f)\n+                print_const_val(&hi.val, f)\n             }\n             PatternKind::Slice { ref prefix, ref slice, ref suffix } |\n             PatternKind::Array { ref prefix, ref slice, ref suffix } => {\n@@ -278,7 +276,7 @@ impl<'a, 'tcx> Pattern<'tcx> {\n     pub fn from_hir(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     param_env_and_substs: ty::ParamEnvAnd<'tcx, &'tcx Substs<'tcx>>,\n                     tables: &'a ty::TypeckTables<'tcx>,\n-                    pat: &hir::Pat) -> Self {\n+                    pat: &'tcx hir::Pat) -> Self {\n         let mut pcx = PatternContext::new(tcx, param_env_and_substs, tables);\n         let result = pcx.lower_pattern(pat);\n         if !pcx.errors.is_empty() {\n@@ -302,19 +300,19 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         }\n     }\n \n-    pub fn lower_pattern(&mut self, pat: &hir::Pat) -> Pattern<'tcx> {\n+    pub fn lower_pattern(&mut self, pat: &'tcx hir::Pat) -> Pattern<'tcx> {\n         let mut ty = self.tables.node_id_to_type(pat.hir_id);\n \n         let kind = match pat.node {\n             PatKind::Wild => PatternKind::Wild,\n \n             PatKind::Lit(ref value) => self.lower_lit(value),\n \n-            PatKind::Range(ref lo, ref hi, ref end) => {\n+            PatKind::Range(ref lo, ref hi, end) => {\n                 match (self.lower_lit(lo), self.lower_lit(hi)) {\n                     (PatternKind::Constant { value: lo },\n                      PatternKind::Constant { value: hi }) => {\n-                        PatternKind::Range { lo: lo, hi: hi, end: end.clone() }\n+                        PatternKind::Range { lo, hi, end }\n                     }\n                     _ => PatternKind::Wild\n                 }\n@@ -474,11 +472,11 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         }\n     }\n \n-    fn lower_patterns(&mut self, pats: &[P<hir::Pat>]) -> Vec<Pattern<'tcx>> {\n+    fn lower_patterns(&mut self, pats: &'tcx [P<hir::Pat>]) -> Vec<Pattern<'tcx>> {\n         pats.iter().map(|p| self.lower_pattern(p)).collect()\n     }\n \n-    fn lower_opt_pattern(&mut self, pat: &Option<P<hir::Pat>>) -> Option<Pattern<'tcx>>\n+    fn lower_opt_pattern(&mut self, pat: &'tcx Option<P<hir::Pat>>) -> Option<Pattern<'tcx>>\n     {\n         pat.as_ref().map(|p| self.lower_pattern(p))\n     }\n@@ -521,9 +519,9 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         &mut self,\n         span: Span,\n         ty: Ty<'tcx>,\n-        prefix: &[P<hir::Pat>],\n-        slice: &Option<P<hir::Pat>>,\n-        suffix: &[P<hir::Pat>])\n+        prefix: &'tcx [P<hir::Pat>],\n+        slice: &'tcx Option<P<hir::Pat>>,\n+        suffix: &'tcx [P<hir::Pat>])\n         -> PatternKind<'tcx>\n     {\n         let prefix = self.lower_patterns(prefix);\n@@ -540,7 +538,8 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n             ty::TyArray(_, len) => {\n                 // fixed-length array\n-                assert!(len >= prefix.len() + suffix.len());\n+                let len = len.val.to_const_int().unwrap().to_u64().unwrap();\n+                assert!(len >= prefix.len() as u64 + suffix.len() as u64);\n                 PatternKind::Array { prefix: prefix, slice: slice, suffix: suffix }\n             }\n \n@@ -631,17 +630,17 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         }\n     }\n \n-    fn lower_lit(&mut self, expr: &hir::Expr) -> PatternKind<'tcx> {\n+    fn lower_lit(&mut self, expr: &'tcx hir::Expr) -> PatternKind<'tcx> {\n         let const_cx = eval::ConstContext::new(self.tcx,\n                                                self.param_env.and(self.substs),\n                                                self.tables);\n         match const_cx.eval(expr) {\n             Ok(value) => {\n-                if let ConstVal::Variant(def_id) = value {\n+                if let ConstVal::Variant(def_id) = value.val {\n                     let ty = self.tables.expr_ty(expr);\n                     self.lower_variant_or_leaf(Def::Variant(def_id), ty, vec![])\n                 } else {\n-                    PatternKind::Constant { value: value }\n+                    PatternKind::Constant { value }\n                 }\n             }\n             Err(e) => {\n@@ -652,7 +651,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n     }\n \n     fn lower_const_expr(&mut self,\n-                        expr: &hir::Expr,\n+                        expr: &'tcx hir::Expr,\n                         pat_id: ast::NodeId,\n                         span: Span)\n                         -> Pattern<'tcx> {\n@@ -819,8 +818,8 @@ macro_rules! CloneImpls {\n }\n \n CloneImpls!{ <'tcx>\n-    Span, Field, Mutability, ast::Name, ast::NodeId, usize, ConstVal<'tcx>, Region<'tcx>,\n-    Ty<'tcx>, BindingMode<'tcx>, &'tcx AdtDef,\n+    Span, Field, Mutability, ast::Name, ast::NodeId, usize, &'tcx ty::Const<'tcx>,\n+    Region<'tcx>, Ty<'tcx>, BindingMode<'tcx>, &'tcx AdtDef,\n     &'tcx Substs<'tcx>, &'tcx Kind<'tcx>\n }\n \n@@ -892,18 +891,18 @@ impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n                 subpattern: subpattern.fold_with(folder),\n             },\n             PatternKind::Constant {\n-                ref value\n+                value\n             } => PatternKind::Constant {\n                 value: value.fold_with(folder)\n             },\n             PatternKind::Range {\n-                ref lo,\n-                ref hi,\n-                ref end,\n+                lo,\n+                hi,\n+                end,\n             } => PatternKind::Range {\n                 lo: lo.fold_with(folder),\n                 hi: hi.fold_with(folder),\n-                end: end.clone(),\n+                end,\n             },\n             PatternKind::Slice {\n                 ref prefix,"}, {"sha": "08473d729e4e5a24877696659e3a323750423cb5", "filename": "src/librustc_const_math/int.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_const_math%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_const_math%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fint.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -311,17 +311,13 @@ impl ::std::fmt::Display for ConstInt {\n             I32(i) => write!(fmt, \"{}i32\", i),\n             I64(i) => write!(fmt, \"{}i64\", i),\n             I128(i) => write!(fmt, \"{}i128\", i),\n-            Isize(ConstIsize::Is64(i)) => write!(fmt, \"{}isize\", i),\n-            Isize(ConstIsize::Is32(i)) => write!(fmt, \"{}isize\", i),\n-            Isize(ConstIsize::Is16(i)) => write!(fmt, \"{}isize\", i),\n+            Isize(i) => write!(fmt, \"{}isize\", i),\n             U8(i) => write!(fmt, \"{}u8\", i),\n             U16(i) => write!(fmt, \"{}u16\", i),\n             U32(i) => write!(fmt, \"{}u32\", i),\n             U64(i) => write!(fmt, \"{}u64\", i),\n             U128(i) => write!(fmt, \"{}u128\", i),\n-            Usize(ConstUsize::Us64(i)) => write!(fmt, \"{}usize\", i),\n-            Usize(ConstUsize::Us32(i)) => write!(fmt, \"{}usize\", i),\n-            Usize(ConstUsize::Us16(i)) => write!(fmt, \"{}usize\", i),\n+            Usize(i) => write!(fmt, \"{}usize\", i),\n         }\n     }\n }"}, {"sha": "50dfb60112991aa98fbe83b8182ca1dfb6129537", "filename": "src/librustc_const_math/is.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_const_math%2Fis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_const_math%2Fis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fis.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -21,18 +21,22 @@ pub enum ConstIsize {\n }\n pub use self::ConstIsize::*;\n \n+impl ::std::fmt::Display for ConstIsize {\n+    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n+        write!(fmt, \"{}\", self.as_i64())\n+    }\n+}\n+\n impl ConstIsize {\n-    pub fn as_i64(self, target_int_ty: ast::IntTy) -> i64 {\n-        match (self, target_int_ty) {\n-            (Is16(i), ast::IntTy::I16) => i as i64,\n-            (Is32(i), ast::IntTy::I32) => i as i64,\n-            (Is64(i), ast::IntTy::I64) => i,\n-            _ => panic!(\"unable to convert self ({:?}) to target isize ({:?})\",\n-                        self, target_int_ty),\n+    pub fn as_i64(self) -> i64 {\n+        match self {\n+            Is16(i) => i as i64,\n+            Is32(i) => i as i64,\n+            Is64(i) => i,\n         }\n     }\n-    pub fn new(i: i64, target_int_ty: ast::IntTy) -> Result<Self, ConstMathErr> {\n-        match target_int_ty {\n+    pub fn new(i: i64, isize_ty: ast::IntTy) -> Result<Self, ConstMathErr> {\n+        match isize_ty {\n             ast::IntTy::I16 if i as i16 as i64 == i => Ok(Is16(i as i16)),\n             ast::IntTy::I16 => Err(LitOutOfRange(ast::IntTy::Is)),\n             ast::IntTy::I32 if i as i32 as i64 == i => Ok(Is32(i as i32)),\n@@ -41,8 +45,8 @@ impl ConstIsize {\n             _ => unreachable!(),\n         }\n     }\n-    pub fn new_truncating(i: i128, target_int_ty: ast::IntTy) -> Self {\n-        match target_int_ty {\n+    pub fn new_truncating(i: i128, isize_ty: ast::IntTy) -> Self {\n+        match isize_ty {\n             ast::IntTy::I16 => Is16(i as i16),\n             ast::IntTy::I32 => Is32(i as i32),\n             ast::IntTy::I64 => Is64(i as i64),"}, {"sha": "9876bc4d779a0cc1914547963fa9e0720ada0f0c", "filename": "src/librustc_const_math/us.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_const_math%2Fus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_const_math%2Fus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fus.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -21,18 +21,22 @@ pub enum ConstUsize {\n }\n pub use self::ConstUsize::*;\n \n+impl ::std::fmt::Display for ConstUsize {\n+    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n+        write!(fmt, \"{}\", self.as_u64())\n+    }\n+}\n+\n impl ConstUsize {\n-    pub fn as_u64(self, target_uint_ty: ast::UintTy) -> u64 {\n-        match (self, target_uint_ty) {\n-            (Us16(i), ast::UintTy::U16) => i as u64,\n-            (Us32(i), ast::UintTy::U32) => i as u64,\n-            (Us64(i), ast::UintTy::U64) => i,\n-            _ => panic!(\"unable to convert self ({:?}) to target usize ({:?})\",\n-                        self, target_uint_ty),\n+    pub fn as_u64(self) -> u64 {\n+        match self {\n+            Us16(i) => i as u64,\n+            Us32(i) => i as u64,\n+            Us64(i) => i,\n         }\n     }\n-    pub fn new(i: u64, target_uint_ty: ast::UintTy) -> Result<Self, ConstMathErr> {\n-        match target_uint_ty {\n+    pub fn new(i: u64, usize_ty: ast::UintTy) -> Result<Self, ConstMathErr> {\n+        match usize_ty {\n             ast::UintTy::U16 if i as u16 as u64 == i => Ok(Us16(i as u16)),\n             ast::UintTy::U16 => Err(ULitOutOfRange(ast::UintTy::Us)),\n             ast::UintTy::U32 if i as u32 as u64 == i => Ok(Us32(i as u32)),\n@@ -41,8 +45,8 @@ impl ConstUsize {\n             _ => unreachable!(),\n         }\n     }\n-    pub fn new_truncating(i: u128, target_uint_ty: ast::UintTy) -> Self {\n-        match target_uint_ty {\n+    pub fn new_truncating(i: u128, usize_ty: ast::UintTy) -> Self {\n+        match usize_ty {\n             ast::UintTy::U16 => Us16(i as u16),\n             ast::UintTy::U32 => Us32(i as u32),\n             ast::UintTy::U64 => Us64(i as u64),"}, {"sha": "9259474ee27c47752c37aa04013bd35835585c5b", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -801,13 +801,13 @@ fn walk_ty() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let tcx = env.infcx.tcx;\n         let int_ty = tcx.types.isize;\n-        let uint_ty = tcx.types.usize;\n-        let tup1_ty = tcx.intern_tup(&[int_ty, uint_ty, int_ty, uint_ty], false);\n-        let tup2_ty = tcx.intern_tup(&[tup1_ty, tup1_ty, uint_ty], false);\n+        let usize_ty = tcx.types.usize;\n+        let tup1_ty = tcx.intern_tup(&[int_ty, usize_ty, int_ty, usize_ty], false);\n+        let tup2_ty = tcx.intern_tup(&[tup1_ty, tup1_ty, usize_ty], false);\n         let walked: Vec<_> = tup2_ty.walk().collect();\n         assert_eq!(walked,\n-                   [tup2_ty, tup1_ty, int_ty, uint_ty, int_ty, uint_ty, tup1_ty, int_ty,\n-                    uint_ty, int_ty, uint_ty, uint_ty]);\n+                   [tup2_ty, tup1_ty, int_ty, usize_ty, int_ty, usize_ty, tup1_ty, int_ty,\n+                    usize_ty, int_ty, usize_ty, usize_ty]);\n     })\n }\n \n@@ -816,20 +816,20 @@ fn walk_ty_skip_subtree() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let tcx = env.infcx.tcx;\n         let int_ty = tcx.types.isize;\n-        let uint_ty = tcx.types.usize;\n-        let tup1_ty = tcx.intern_tup(&[int_ty, uint_ty, int_ty, uint_ty], false);\n-        let tup2_ty = tcx.intern_tup(&[tup1_ty, tup1_ty, uint_ty], false);\n+        let usize_ty = tcx.types.usize;\n+        let tup1_ty = tcx.intern_tup(&[int_ty, usize_ty, int_ty, usize_ty], false);\n+        let tup2_ty = tcx.intern_tup(&[tup1_ty, tup1_ty, usize_ty], false);\n \n         // types we expect to see (in order), plus a boolean saying\n         // whether to skip the subtree.\n         let mut expected = vec![(tup2_ty, false),\n                                 (tup1_ty, false),\n                                 (int_ty, false),\n-                                (uint_ty, false),\n+                                (usize_ty, false),\n                                 (int_ty, false),\n-                                (uint_ty, false),\n+                                (usize_ty, false),\n                                 (tup1_ty, true), // skip the isize/usize/isize/usize\n-                                (uint_ty, false)];\n+                                (usize_ty, false)];\n         expected.reverse();\n \n         let mut walker = tup2_ty.walk();"}, {"sha": "d3a5d52b295afa54938281d317249855537beed6", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -76,7 +76,7 @@ impl LintPass for TypeLimits {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n-    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx hir::Expr) {\n         match e.node {\n             hir::ExprUnary(hir::UnNeg, ref expr) => {\n                 // propagate negation, if the negation itself isn't negated\n@@ -93,8 +93,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n \n                 if binop.node.is_shift() {\n                     let opt_ty_bits = match cx.tables.node_id_to_type(l.hir_id).sty {\n-                        ty::TyInt(t) => Some(int_ty_bits(t, cx.sess().target.int_type)),\n-                        ty::TyUint(t) => Some(uint_ty_bits(t, cx.sess().target.uint_type)),\n+                        ty::TyInt(t) => Some(int_ty_bits(t, cx.sess().target.isize_ty)),\n+                        ty::TyUint(t) => Some(uint_ty_bits(t, cx.sess().target.usize_ty)),\n                         _ => None,\n                     };\n \n@@ -117,7 +117,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                                                              cx.param_env.and(substs),\n                                                              cx.tables);\n                             match const_cx.eval(&r) {\n-                                Ok(ConstVal::Integral(i)) => {\n+                                Ok(&ty::Const { val: ConstVal::Integral(i), .. }) => {\n                                     i.is_negative() ||\n                                     i.to_u64()\n                                         .map(|i| i >= bits)\n@@ -141,7 +141,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                             ast::LitKind::Int(v, ast::LitIntType::Signed(_)) |\n                             ast::LitKind::Int(v, ast::LitIntType::Unsuffixed) => {\n                                 let int_type = if let ast::IntTy::Is = t {\n-                                    cx.sess().target.int_type\n+                                    cx.sess().target.isize_ty\n                                 } else {\n                                     t\n                                 };\n@@ -164,7 +164,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                     }\n                     ty::TyUint(t) => {\n                         let uint_type = if let ast::UintTy::Us = t {\n-                            cx.sess().target.uint_type\n+                            cx.sess().target.usize_ty\n                         } else {\n                             t\n                         };\n@@ -250,9 +250,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n             }\n         }\n \n-        fn int_ty_bits(int_ty: ast::IntTy, target_int_ty: ast::IntTy) -> u64 {\n+        fn int_ty_bits(int_ty: ast::IntTy, isize_ty: ast::IntTy) -> u64 {\n             match int_ty {\n-                ast::IntTy::Is => int_ty_bits(target_int_ty, target_int_ty),\n+                ast::IntTy::Is => int_ty_bits(isize_ty, isize_ty),\n                 ast::IntTy::I8 => 8,\n                 ast::IntTy::I16 => 16 as u64,\n                 ast::IntTy::I32 => 32,\n@@ -261,9 +261,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n             }\n         }\n \n-        fn uint_ty_bits(uint_ty: ast::UintTy, target_uint_ty: ast::UintTy) -> u64 {\n+        fn uint_ty_bits(uint_ty: ast::UintTy, usize_ty: ast::UintTy) -> u64 {\n             match uint_ty {\n-                ast::UintTy::Us => uint_ty_bits(target_uint_ty, target_uint_ty),\n+                ast::UintTy::Us => uint_ty_bits(usize_ty, usize_ty),\n                 ast::UintTy::U8 => 8,\n                 ast::UintTy::U16 => 16,\n                 ast::UintTy::U32 => 32,"}, {"sha": "689f9f5b244304b6a133a9055613747906dcbd64", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -16,6 +16,7 @@ use schema::*;\n use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash};\n use rustc::hir;\n \n+use rustc::middle::const_val::ByteArray;\n use rustc::middle::cstore::LinkagePreference;\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -377,6 +378,20 @@ impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>\n     }\n }\n \n+impl<'a, 'tcx> SpecializedDecoder<ByteArray<'tcx>> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<ByteArray<'tcx>, Self::Error> {\n+        Ok(ByteArray {\n+            data: self.tcx().alloc_byte_array(&Vec::decode(self)?)\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::Const<'tcx>> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n+        Ok(self.tcx().mk_const(Decodable::decode(self)?))\n+    }\n+}\n+\n impl<'a, 'tcx> MetadataBlob {\n     pub fn is_compatible(&self) -> bool {\n         self.raw_bytes().starts_with(METADATA_HEADER)"}, {"sha": "6b49be3e12192a9757b857cc41305af15006c4a7", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -1520,9 +1520,16 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_info_for_ty(&mut self, ty: &hir::Ty) {\n-        if let hir::TyImplTrait(_) = ty.node {\n-            let def_id = self.tcx.hir.local_def_id(ty.id);\n-            self.record(def_id, IsolatedEncoder::encode_info_for_anon_ty, def_id);\n+        match ty.node {\n+            hir::TyImplTrait(_) => {\n+                let def_id = self.tcx.hir.local_def_id(ty.id);\n+                self.record(def_id, IsolatedEncoder::encode_info_for_anon_ty, def_id);\n+            }\n+            hir::TyArray(_, len) => {\n+                let def_id = self.tcx.hir.body_owner_def_id(len);\n+                self.record(def_id, IsolatedEncoder::encode_info_for_embedded_const, def_id);\n+            }\n+            _ => {}\n         }\n     }\n "}, {"sha": "eeae4bce335ca692680d7e7496b9d0711da17ff6", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -197,7 +197,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         span: expr_span,\n                         ty: this.hir.tcx().types.u32,\n                         literal: Literal::Value {\n-                            value: ConstVal::Integral(ConstInt::U32(0)),\n+                            value: this.hir.tcx().mk_const(ty::Const {\n+                                val: ConstVal::Integral(ConstInt::U32(0)),\n+                                ty: this.hir.tcx().types.u32\n+                            }),\n                         },\n                     }));\n                     box AggregateKind::Generator(closure_id, substs, interior)\n@@ -385,13 +388,18 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     ast::IntTy::I64 => ConstInt::I64(-1),\n                     ast::IntTy::I128 => ConstInt::I128(-1),\n                     ast::IntTy::Is => {\n-                        let int_ty = self.hir.tcx().sess.target.int_type;\n+                        let int_ty = self.hir.tcx().sess.target.isize_ty;\n                         let val = ConstIsize::new(-1, int_ty).unwrap();\n                         ConstInt::Isize(val)\n                     }\n                 };\n \n-                Literal::Value { value: ConstVal::Integral(val) }\n+                Literal::Value {\n+                    value: self.hir.tcx().mk_const(ty::Const {\n+                        val: ConstVal::Integral(val),\n+                        ty\n+                    })\n+                }\n             }\n             _ => {\n                 span_bug!(span, \"Invalid type for neg_1_literal: `{:?}`\", ty)\n@@ -412,7 +420,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     ast::IntTy::I64 => ConstInt::I64(i64::min_value()),\n                     ast::IntTy::I128 => ConstInt::I128(i128::min_value()),\n                     ast::IntTy::Is => {\n-                        let int_ty = self.hir.tcx().sess.target.int_type;\n+                        let int_ty = self.hir.tcx().sess.target.isize_ty;\n                         let min = match int_ty {\n                             ast::IntTy::I16 => std::i16::MIN as i64,\n                             ast::IntTy::I32 => std::i32::MIN as i64,\n@@ -424,7 +432,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     }\n                 };\n \n-                Literal::Value { value: ConstVal::Integral(val) }\n+                Literal::Value {\n+                    value: self.hir.tcx().mk_const(ty::Const {\n+                        val: ConstVal::Integral(val),\n+                        ty\n+                    })\n+                }\n             }\n             _ => {\n                 span_bug!(span, \"Invalid type for minval_literal: `{:?}`\", ty)"}, {"sha": "f560fa426e22e2e380ff80ed0fd5ad2ddfba10d9", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -16,8 +16,7 @@\n use build::{BlockAnd, BlockAndExtension, Builder};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::bitvec::BitVector;\n-use rustc::middle::const_val::ConstVal;\n-use rustc::ty::{AdtDef, Ty};\n+use rustc::ty::{self, Ty};\n use rustc::mir::*;\n use rustc::hir;\n use hair::*;\n@@ -294,20 +293,20 @@ pub struct MatchPair<'pat, 'tcx:'pat> {\n enum TestKind<'tcx> {\n     // test the branches of enum\n     Switch {\n-        adt_def: &'tcx AdtDef,\n+        adt_def: &'tcx ty::AdtDef,\n         variants: BitVector,\n     },\n \n     // test the branches of enum\n     SwitchInt {\n         switch_ty: Ty<'tcx>,\n-        options: Vec<ConstVal<'tcx>>,\n-        indices: FxHashMap<ConstVal<'tcx>, usize>,\n+        options: Vec<&'tcx ty::Const<'tcx>>,\n+        indices: FxHashMap<&'tcx ty::Const<'tcx>, usize>,\n     },\n \n     // test for equality\n     Eq {\n-        value: ConstVal<'tcx>,\n+        value: &'tcx ty::Const<'tcx>,\n         ty: Ty<'tcx>,\n     },\n "}, {"sha": "7b91c43aa37222dbeaf0a8f1c255d2fe0a6eb861", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -61,24 +61,24 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            PatternKind::Constant { ref value } => {\n+            PatternKind::Constant { value } => {\n                 Test {\n                     span: match_pair.pattern.span,\n                     kind: TestKind::Eq {\n-                        value: value.clone(),\n+                        value,\n                         ty: match_pair.pattern.ty.clone()\n                     }\n                 }\n             }\n \n-            PatternKind::Range { ref lo, ref hi, ref end } => {\n+            PatternKind::Range { lo, hi, end } => {\n                 Test {\n                     span: match_pair.pattern.span,\n                     kind: TestKind::Range {\n-                        lo: Literal::Value { value: lo.clone() },\n-                        hi: Literal::Value { value: hi.clone() },\n+                        lo: Literal::Value { value: lo },\n+                        hi: Literal::Value { value: hi },\n                         ty: match_pair.pattern.ty.clone(),\n-                        end: end.clone(),\n+                        end,\n                     },\n                 }\n             }\n@@ -112,8 +112,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                      test_lvalue: &Lvalue<'tcx>,\n                                      candidate: &Candidate<'pat, 'tcx>,\n                                      switch_ty: Ty<'tcx>,\n-                                     options: &mut Vec<ConstVal<'tcx>>,\n-                                     indices: &mut FxHashMap<ConstVal<'tcx>, usize>)\n+                                     options: &mut Vec<&'tcx ty::Const<'tcx>>,\n+                                     indices: &mut FxHashMap<&'tcx ty::Const<'tcx>, usize>)\n                                      -> bool\n     {\n         let match_pair = match candidate.match_pairs.iter().find(|mp| mp.lvalue == *test_lvalue) {\n@@ -122,13 +122,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         };\n \n         match *match_pair.pattern.kind {\n-            PatternKind::Constant { ref value } => {\n+            PatternKind::Constant { value } => {\n                 // if the lvalues match, the type should match\n                 assert_eq!(match_pair.pattern.ty, switch_ty);\n \n-                indices.entry(value.clone())\n+                indices.entry(value)\n                        .or_insert_with(|| {\n-                           options.push(value.clone());\n+                           options.push(value);\n                            options.len() - 1\n                        });\n                 true\n@@ -228,9 +228,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     assert!(options.len() > 0 && options.len() <= 2);\n                     let (true_bb, false_bb) = (self.cfg.start_new_block(),\n                                                self.cfg.start_new_block());\n-                    let ret = match &options[0] {\n-                        &ConstVal::Bool(true) => vec![true_bb, false_bb],\n-                        &ConstVal::Bool(false) => vec![false_bb, true_bb],\n+                    let ret = match options[0].val {\n+                        ConstVal::Bool(true) => vec![true_bb, false_bb],\n+                        ConstVal::Bool(false) => vec![false_bb, true_bb],\n                         v => span_bug!(test.span, \"expected boolean value but got {:?}\", v)\n                     };\n                     (ret, TerminatorKind::if_(self.hir.tcx(), Operand::Consume(lvalue.clone()),\n@@ -245,7 +245,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                .chain(Some(otherwise))\n                                .collect();\n                     let values: Vec<_> = options.iter().map(|v|\n-                        v.to_const_int().expect(\"switching on integral\")\n+                        v.val.to_const_int().expect(\"switching on integral\")\n                     ).collect();\n                     (targets.clone(), TerminatorKind::SwitchInt {\n                         discr: Operand::Consume(lvalue.clone()),\n@@ -258,12 +258,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 ret\n             }\n \n-            TestKind::Eq { ref value, mut ty } => {\n+            TestKind::Eq { value, mut ty } => {\n                 let mut val = Operand::Consume(lvalue.clone());\n \n                 // If we're using b\"...\" as a pattern, we need to insert an\n                 // unsizing coercion, as the byte string has the type &[u8; N].\n-                let expect = if let ConstVal::ByteStr(ref bytes) = *value {\n+                let expect = if let ConstVal::ByteStr(bytes) = value.val {\n                     let tcx = self.hir.tcx();\n \n                     // Unsize the lvalue to &[u8], too, if necessary.\n@@ -279,10 +279,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                     assert!(ty.is_slice());\n \n-                    let array_ty = tcx.mk_array(tcx.types.u8, bytes.len());\n+                    let array_ty = tcx.mk_array(tcx.types.u8, bytes.data.len() as u64);\n                     let array_ref = tcx.mk_imm_ref(tcx.types.re_static, array_ty);\n                     let array = self.literal_operand(test.span, array_ref, Literal::Value {\n-                        value: value.clone()\n+                        value\n                     });\n \n                     let slice = self.temp(ty, test.span);\n@@ -291,7 +291,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     Operand::Consume(slice)\n                 } else {\n                     self.literal_operand(test.span, ty, Literal::Value {\n-                        value: value.clone()\n+                        value\n                     })\n                 };\n "}, {"sha": "1976b70ac0a2367c98f5c556a065518fe75418bb", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -59,7 +59,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ty::TyBool => {\n                 self.hir.false_literal()\n             }\n-            ty::TyChar => Literal::Value { value: ConstVal::Char('\\0') },\n+            ty::TyChar => {\n+                Literal::Value {\n+                    value: self.hir.tcx().mk_const(ty::Const {\n+                        val: ConstVal::Char('\\0'),\n+                        ty\n+                    })\n+                }\n+            }\n             ty::TyUint(ity) => {\n                 let val = match ity {\n                     ast::UintTy::U8  => ConstInt::U8(0),\n@@ -68,13 +75,18 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     ast::UintTy::U64 => ConstInt::U64(0),\n                     ast::UintTy::U128 => ConstInt::U128(0),\n                     ast::UintTy::Us => {\n-                        let uint_ty = self.hir.tcx().sess.target.uint_type;\n+                        let uint_ty = self.hir.tcx().sess.target.usize_ty;\n                         let val = ConstUsize::new(0, uint_ty).unwrap();\n                         ConstInt::Usize(val)\n                     }\n                 };\n \n-                Literal::Value { value: ConstVal::Integral(val) }\n+                Literal::Value {\n+                    value: self.hir.tcx().mk_const(ty::Const {\n+                        val: ConstVal::Integral(val),\n+                        ty\n+                    })\n+                }\n             }\n             ty::TyInt(ity) => {\n                 let val = match ity {\n@@ -84,13 +96,18 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     ast::IntTy::I64 => ConstInt::I64(0),\n                     ast::IntTy::I128 => ConstInt::I128(0),\n                     ast::IntTy::Is => {\n-                        let int_ty = self.hir.tcx().sess.target.int_type;\n+                        let int_ty = self.hir.tcx().sess.target.isize_ty;\n                         let val = ConstIsize::new(0, int_ty).unwrap();\n                         ConstInt::Isize(val)\n                     }\n                 };\n \n-                Literal::Value { value: ConstVal::Integral(val) }\n+                Literal::Value {\n+                    value: self.hir.tcx().mk_const(ty::Const {\n+                        val: ConstVal::Integral(val),\n+                        ty\n+                    })\n+                }\n             }\n             _ => {\n                 span_bug!(span, \"Invalid type for zero_literal: `{:?}`\", ty)"}, {"sha": "be6f8c9e56c40b7a67db94bdf3a8b008440ef240", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -11,7 +11,6 @@\n \n use build;\n use hair::cx::Cx;\n-use hair::Pattern;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::middle::region;\n@@ -167,6 +166,26 @@ impl<'a, 'gcx: 'tcx, 'tcx> MutVisitor<'tcx> for GlobalizeMir<'a, 'gcx> {\n         }\n     }\n \n+    fn visit_region(&mut self, region: &mut ty::Region<'tcx>, _: Location) {\n+        if let Some(lifted) = self.tcx.lift(region) {\n+            *region = lifted;\n+        } else {\n+            span_bug!(self.span,\n+                      \"found region `{:?}` with inference types/regions in MIR\",\n+                      region);\n+        }\n+    }\n+\n+    fn visit_const(&mut self, constant: &mut &'tcx ty::Const<'tcx>, _: Location) {\n+        if let Some(lifted) = self.tcx.lift(constant) {\n+            *constant = lifted;\n+        } else {\n+            span_bug!(self.span,\n+                      \"found constant `{:?}` with inference types/regions in MIR\",\n+                      constant);\n+        }\n+    }\n+\n     fn visit_substs(&mut self, substs: &mut &'tcx Substs<'tcx>, _: Location) {\n         if let Some(lifted) = self.tcx.lift(substs) {\n             *substs = lifted;\n@@ -537,10 +556,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             let lvalue = Lvalue::Local(Local::new(index + 1));\n \n             if let Some(pattern) = pattern {\n-                let pattern = Pattern::from_hir(self.hir.tcx().global_tcx(),\n-                                                self.hir.param_env.and(self.hir.identity_substs),\n-                                                self.hir.tables(),\n-                                                pattern);\n+                let pattern = self.hir.pattern_from_hir(pattern);\n                 scope = self.declare_bindings(scope, ast_body.span, &pattern);\n                 unpack!(block = self.lvalue_into_pattern(block, pattern, &lvalue));\n             }"}, {"sha": "f6b847d6d6de55a7778ca6a550547d0f1943b0d1", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -64,10 +64,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                             first_statement_index: index as u32,\n                         });\n \n-                        let pattern = Pattern::from_hir(cx.tcx.global_tcx(),\n-                                                        cx.param_env.and(cx.identity_substs),\n-                                                        cx.tables(),\n-                                                        &local.pat);\n+                        let pattern = cx.pattern_from_hir(&local.pat);\n                         result.push(StmtRef::Mirror(Box::new(Stmt {\n                             kind: StmtKind::Let {\n                                 remainder_scope: remainder_scope,"}, {"sha": "45449103c8083fde0b139e22f1b5e2450dbf3c97", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -473,7 +473,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             let def_id = cx.tcx.hir.body_owner_def_id(count);\n             let substs = Substs::identity_for_item(cx.tcx.global_tcx(), def_id);\n             let count = match cx.tcx.at(c.span).const_eval(cx.param_env.and((def_id, substs))) {\n-                Ok(ConstVal::Integral(ConstInt::Usize(u))) => u,\n+                Ok(&ty::Const { val: ConstVal::Integral(ConstInt::Usize(u)), .. }) => u,\n                 Ok(other) => bug!(\"constant evaluation of repeat count yielded {:?}\", other),\n                 Err(s) => cx.fatal_const_eval_err(&s, c.span, \"expression\")\n             };\n@@ -591,13 +591,17 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         (cx.tables().type_dependent_defs()[expr.hir_id].def_id(),\n          cx.tables().node_substs(expr.hir_id))\n     });\n+    let ty = cx.tcx().mk_fn_def(def_id, substs);\n     Expr {\n         temp_lifetime,\n-        ty: cx.tcx().mk_fn_def(def_id, substs),\n+        ty,\n         span: expr.span,\n         kind: ExprKind::Literal {\n             literal: Literal::Value {\n-                value: ConstVal::Function(def_id, substs),\n+                value: cx.tcx.mk_const(ty::Const {\n+                    val: ConstVal::Function(def_id, substs),\n+                    ty\n+                }),\n             },\n         },\n     }\n@@ -612,12 +616,7 @@ fn to_borrow_kind(m: hir::Mutability) -> BorrowKind {\n \n fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>, arm: &'tcx hir::Arm) -> Arm<'tcx> {\n     Arm {\n-        patterns: arm.pats.iter().map(|p| {\n-            Pattern::from_hir(cx.tcx.global_tcx(),\n-                              cx.param_env.and(cx.identity_substs),\n-                              cx.tables(),\n-                              p)\n-        }).collect(),\n+        patterns: arm.pats.iter().map(|p| cx.pattern_from_hir(p)).collect(),\n         guard: arm.guard.to_ref(),\n         body: arm.body.to_ref(),\n     }\n@@ -635,15 +634,20 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         Def::StructCtor(def_id, CtorKind::Fn) |\n         Def::VariantCtor(def_id, CtorKind::Fn) => ExprKind::Literal {\n             literal: Literal::Value {\n-                value: ConstVal::Function(def_id, substs),\n+                value: cx.tcx.mk_const(ty::Const {\n+                    val: ConstVal::Function(def_id, substs),\n+                    ty: cx.tables().node_id_to_type(expr.hir_id)\n+                }),\n             },\n         },\n \n         Def::Const(def_id) |\n         Def::AssociatedConst(def_id) => ExprKind::Literal {\n-            literal: Literal::Item {\n-                def_id,\n-                substs,\n+            literal: Literal::Value {\n+                value: cx.tcx.mk_const(ty::Const {\n+                    val: ConstVal::Unevaluated(def_id, substs),\n+                    ty: cx.tables().node_id_to_type(expr.hir_id)\n+                }),\n             },\n         },\n "}, {"sha": "f5e15979006af50f96569e30238fcd282d3cc540", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 39, "deletions": 7, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -112,8 +112,15 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn usize_literal(&mut self, value: u64) -> Literal<'tcx> {\n-        match ConstUsize::new(value, self.tcx.sess.target.uint_type) {\n-            Ok(val) => Literal::Value { value: ConstVal::Integral(ConstInt::Usize(val)) },\n+        match ConstUsize::new(value, self.tcx.sess.target.usize_ty) {\n+            Ok(val) => {\n+                Literal::Value {\n+                    value: self.tcx.mk_const(ty::Const {\n+                        val: ConstVal::Integral(ConstInt::Usize(val)),\n+                        ty: self.tcx.types.usize\n+                    })\n+                }\n+            }\n             Err(_) => bug!(\"usize literal out of range for target\"),\n         }\n     }\n@@ -127,24 +134,46 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn true_literal(&mut self) -> Literal<'tcx> {\n-        Literal::Value { value: ConstVal::Bool(true) }\n+        Literal::Value {\n+            value: self.tcx.mk_const(ty::Const {\n+                val: ConstVal::Bool(true),\n+                ty: self.tcx.types.bool\n+            })\n+        }\n     }\n \n     pub fn false_literal(&mut self) -> Literal<'tcx> {\n-        Literal::Value { value: ConstVal::Bool(false) }\n+        Literal::Value {\n+            value: self.tcx.mk_const(ty::Const {\n+                val: ConstVal::Bool(false),\n+                ty: self.tcx.types.bool\n+            })\n+        }\n     }\n \n     pub fn const_eval_literal(&mut self, e: &hir::Expr) -> Literal<'tcx> {\n         let tcx = self.tcx.global_tcx();\n         let const_cx = ConstContext::new(tcx,\n                                          self.param_env.and(self.identity_substs),\n                                          self.tables());\n-        match const_cx.eval(e) {\n-            Ok(value) => Literal::Value { value: value },\n+        match const_cx.eval(tcx.hir.expect_expr(e.id)) {\n+            Ok(value) => Literal::Value { value },\n             Err(s) => self.fatal_const_eval_err(&s, e.span, \"expression\")\n         }\n     }\n \n+    pub fn pattern_from_hir(&mut self, p: &hir::Pat) -> Pattern<'tcx> {\n+        let tcx = self.tcx.global_tcx();\n+        let p = match tcx.hir.get(p.id) {\n+            hir::map::NodePat(p) | hir::map::NodeBinding(p) => p,\n+            node => bug!(\"pattern became {:?}\", node)\n+        };\n+        Pattern::from_hir(tcx,\n+                          self.param_env.and(self.identity_substs),\n+                          self.tables(),\n+                          p)\n+    }\n+\n     pub fn fatal_const_eval_err(&mut self,\n         err: &ConstEvalErr<'tcx>,\n         primary_span: Span,\n@@ -170,7 +199,10 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                 let method_ty = method_ty.subst(self.tcx, substs);\n                 return (method_ty,\n                         Literal::Value {\n-                            value: ConstVal::Function(item.def_id, substs),\n+                            value: self.tcx.mk_const(ty::Const {\n+                                val: ConstVal::Function(item.def_id, substs),\n+                                ty: method_ty\n+                            }),\n                         });\n             }\n         }"}, {"sha": "00ee417e02b5534ab984e243da49c1c86891aff5", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -292,7 +292,10 @@ fn build_clone_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n \n     match self_ty.sty {\n         _ if is_copy => builder.copy_shim(),\n-        ty::TyArray(ty, len) => builder.array_shim(ty, len),\n+        ty::TyArray(ty, len) => {\n+            let len = len.val.to_const_int().unwrap().to_u64().unwrap();\n+            builder.array_shim(ty, len)\n+        }\n         ty::TyTuple(tys, _) => builder.tuple_shim(tys),\n         _ => {\n             bug!(\"clone shim for `{:?}` which is not `Copy` and is not an aggregate\", self_ty);\n@@ -403,11 +406,15 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         );\n \n         // `func == Clone::clone(&ty) -> ty`\n+        let func_ty = tcx.mk_fn_def(self.def_id, substs);\n         let func = Operand::Constant(box Constant {\n             span: self.span,\n-            ty: tcx.mk_fn_def(self.def_id, substs),\n+            ty: func_ty,\n             literal: Literal::Value {\n-                value: ConstVal::Function(self.def_id, substs),\n+                value: tcx.mk_const(ty::Const {\n+                    val: ConstVal::Function(self.def_id, substs),\n+                    ty: func_ty\n+                }),\n             },\n         });\n \n@@ -466,18 +473,21 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         );\n     }\n \n-    fn make_usize(&self, value: usize) -> Box<Constant<'tcx>> {\n-        let value = ConstUsize::new(value as u64, self.tcx.sess.target.uint_type).unwrap();\n+    fn make_usize(&self, value: u64) -> Box<Constant<'tcx>> {\n+        let value = ConstUsize::new(value, self.tcx.sess.target.usize_ty).unwrap();\n         box Constant {\n             span: self.span,\n             ty: self.tcx.types.usize,\n             literal: Literal::Value {\n-                value: ConstVal::Integral(ConstInt::Usize(value))\n+                value: self.tcx.mk_const(ty::Const {\n+                    val: ConstVal::Integral(ConstInt::Usize(value)),\n+                    ty: self.tcx.types.usize,\n+                })\n             }\n         }\n     }\n \n-    fn array_shim(&mut self, ty: ty::Ty<'tcx>, len: usize) {\n+    fn array_shim(&mut self, ty: ty::Ty<'tcx>, len: u64) {\n         let tcx = self.tcx;\n         let span = self.span;\n         let rcvr = Lvalue::Local(Local::new(1+0)).deref();\n@@ -706,17 +716,21 @@ fn build_call_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n \n     let (callee, mut args) = match call_kind {\n         CallKind::Indirect => (rcvr, vec![]),\n-        CallKind::Direct(def_id) => (\n-            Operand::Constant(box Constant {\n+        CallKind::Direct(def_id) => {\n+            let ty = tcx.type_of(def_id);\n+            (Operand::Constant(box Constant {\n                 span,\n-                ty: tcx.type_of(def_id),\n+                ty,\n                 literal: Literal::Value {\n-                    value: ConstVal::Function(def_id,\n-                        Substs::identity_for_item(tcx, def_id)),\n+                    value: tcx.mk_const(ty::Const {\n+                        val: ConstVal::Function(def_id,\n+                            Substs::identity_for_item(tcx, def_id)),\n+                        ty\n+                    }),\n                 },\n-            }),\n-            vec![rcvr]\n-        )\n+             }),\n+             vec![rcvr])\n+        }\n     };\n \n     if let Some(untuple_args) = untuple_args {"}, {"sha": "1077f3b0146168ccd48e1a0e166324306a8bbcdc", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -520,7 +520,12 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         Rvalue::Use(Operand::Constant(Box::new(Constant {\n             span,\n             ty: self.tcx.types.bool,\n-            literal: Literal::Value { value: ConstVal::Bool(val) }\n+            literal: Literal::Value {\n+                value: self.tcx.mk_const(ty::Const {\n+                    val: ConstVal::Bool(val),\n+                    ty: self.tcx.types.bool\n+                })\n+            }\n         })))\n     }\n "}, {"sha": "dc18cdd8f0dd6006e2270974f8cae06240319d0e", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 11, "deletions": 24, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -15,7 +15,7 @@\n //! \"types-as-contracts\"-validation, namely, AcquireValid, ReleaseValid, and EndRegion.\n \n use rustc::ty::subst::Substs;\n-use rustc::ty::{Ty, TyCtxt, ClosureSubsts};\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::mir::*;\n use rustc::mir::visit::{MutVisitor, Lookup};\n use rustc::mir::transform::{MirPass, MirSource};\n@@ -37,38 +37,25 @@ impl<'a, 'tcx> EraseRegionsVisitor<'a, 'tcx> {\n impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &mut Ty<'tcx>, _: Lookup) {\n         if !self.in_validation_statement {\n-            *ty = self.tcx.erase_regions(&{*ty});\n+            *ty = self.tcx.erase_regions(ty);\n         }\n         self.super_ty(ty);\n     }\n \n-    fn visit_substs(&mut self, substs: &mut &'tcx Substs<'tcx>, _: Location) {\n-        *substs = self.tcx.erase_regions(&{*substs});\n+    fn visit_region(&mut self, region: &mut ty::Region<'tcx>, _: Location) {\n+        *region = self.tcx.types.re_erased;\n     }\n \n-    fn visit_rvalue(&mut self, rvalue: &mut Rvalue<'tcx>, location: Location) {\n-        match *rvalue {\n-            Rvalue::Ref(ref mut r, _, _) => {\n-                *r = self.tcx.types.re_erased;\n-            }\n-            Rvalue::Use(..) |\n-            Rvalue::Repeat(..) |\n-            Rvalue::Len(..) |\n-            Rvalue::Cast(..) |\n-            Rvalue::BinaryOp(..) |\n-            Rvalue::CheckedBinaryOp(..) |\n-            Rvalue::UnaryOp(..) |\n-            Rvalue::Discriminant(..) |\n-            Rvalue::NullaryOp(..) |\n-            Rvalue::Aggregate(..) => {\n-                // These variants don't contain regions.\n-            }\n-        }\n-        self.super_rvalue(rvalue, location);\n+    fn visit_const(&mut self, constant: &mut &'tcx ty::Const<'tcx>, _: Location) {\n+        *constant = self.tcx.erase_regions(constant);\n+    }\n+\n+    fn visit_substs(&mut self, substs: &mut &'tcx Substs<'tcx>, _: Location) {\n+        *substs = self.tcx.erase_regions(substs);\n     }\n \n     fn visit_closure_substs(&mut self,\n-                            substs: &mut ClosureSubsts<'tcx>,\n+                            substs: &mut ty::ClosureSubsts<'tcx>,\n                             _: Location) {\n         *substs = self.tcx.erase_regions(substs);\n     }"}, {"sha": "a52656becd74534190b114501df7e4bff8d6be39", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -175,7 +175,10 @@ impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n             span: source_info.span,\n             ty: self.tcx.types.u32,\n             literal: Literal::Value {\n-                value: ConstVal::Integral(ConstInt::U32(state_disc)),\n+                value: self.tcx.mk_const(ty::Const {\n+                    val: ConstVal::Integral(ConstInt::U32(state_disc)),\n+                    ty: self.tcx.types.u32\n+                }),\n             },\n         });\n         Statement {\n@@ -553,7 +556,10 @@ fn insert_panic_on_resume_after_return<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             span: mir.span,\n             ty: tcx.types.bool,\n             literal: Literal::Value {\n-                value: ConstVal::Bool(false),\n+                value: tcx.mk_const(ty::Const {\n+                    val: ConstVal::Bool(false),\n+                    ty: tcx.types.bool\n+                }),\n             },\n         }),\n         expected: true,\n@@ -603,7 +609,10 @@ fn create_generator_resume_function<'a, 'tcx>(\n             span: mir.span,\n             ty: tcx.types.bool,\n             literal: Literal::Value {\n-                value: ConstVal::Bool(false),\n+                value: tcx.mk_const(ty::Const {\n+                    val: ConstVal::Bool(false),\n+                    ty: tcx.types.bool\n+                }),\n             },\n         }),\n         expected: true,"}, {"sha": "5550fb2788eaf088dfe1e564489d2630ee7db6c4", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -20,6 +20,7 @@ use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc::hir;\n use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n+use rustc::middle::const_val::ConstVal;\n use rustc::traits::{self, Reveal};\n use rustc::ty::{self, TyCtxt, Ty, TypeFoldable};\n use rustc::ty::cast::CastTy;\n@@ -622,10 +623,12 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 }\n             }\n             Operand::Constant(ref constant) => {\n-                if let Literal::Item { def_id, substs: _ } = constant.literal {\n+                if let Literal::Value {\n+                    value: &ty::Const { val: ConstVal::Unevaluated(def_id, _), ty }\n+                } = constant.literal {\n                     // Don't peek inside trait associated constants.\n                     if self.tcx.trait_of_item(def_id).is_some() {\n-                        self.add_type(constant.ty);\n+                        self.add_type(ty);\n                     } else {\n                         let (bits, _) = self.tcx.at(constant.span).mir_const_qualif(def_id);\n \n@@ -635,7 +638,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                         // Just in case the type is more specific than\n                         // the definition, e.g. impl associated const\n                         // with type parameters, take it into account.\n-                        self.qualif.restrict(constant.ty, self.tcx, self.param_env);\n+                        self.qualif.restrict(ty, self.tcx, self.param_env);\n                     }\n \n                     // Let `const fn` transitively have destructors,\n@@ -695,8 +698,9 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                             }\n                             _ => false\n                         }\n-                    } else if let ty::TyArray(_, 0) = ty.sty {\n-                        self.mode == Mode::Fn\n+                    } else if let ty::TyArray(_, len) = ty.sty {\n+                        len.val.to_const_int().unwrap().to_u64().unwrap() == 0 &&\n+                            self.mode == Mode::Fn\n                     } else {\n                         false\n                     };"}, {"sha": "0dff145ecbce94c547568b7651b91529fcf4079f", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -10,7 +10,7 @@\n \n //! A pass that simplifies branches when their condition is known.\n \n-use rustc::ty::TyCtxt;\n+use rustc::ty::{self, TyCtxt};\n use rustc::middle::const_val::ConstVal;\n use rustc::mir::transform::{MirPass, MirSource};\n use rustc::mir::*;\n@@ -40,7 +40,7 @@ impl MirPass for SimplifyBranches {\n                 TerminatorKind::SwitchInt { discr: Operand::Constant(box Constant {\n                     literal: Literal::Value { ref value }, ..\n                 }), ref values, ref targets, .. } => {\n-                    if let Some(ref constint) = value.to_const_int() {\n+                    if let Some(ref constint) = value.val.to_const_int() {\n                         let (otherwise, targets) = targets.split_last().unwrap();\n                         let mut ret = TerminatorKind::Goto { target: *otherwise };\n                         for (v, t) in values.iter().zip(targets.iter()) {\n@@ -56,7 +56,7 @@ impl MirPass for SimplifyBranches {\n                 },\n                 TerminatorKind::Assert { target, cond: Operand::Constant(box Constant {\n                     literal: Literal::Value {\n-                        value: ConstVal::Bool(cond)\n+                        value: &ty::Const { val: ConstVal::Bool(cond), .. }\n                     }, ..\n                 }), expected, .. } if cond == expected => {\n                     TerminatorKind::Goto { target: target }"}, {"sha": "ab5998a34805b085f930fbd444799b5e8c9b4d88", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -209,7 +209,8 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 LvalueTy::Ty {\n                     ty: match base_ty.sty {\n                         ty::TyArray(inner, size) => {\n-                            let min_size = (from as usize) + (to as usize);\n+                            let size = size.val.to_const_int().unwrap().to_u64().unwrap();\n+                            let min_size = (from as u64) + (to as u64);\n                             if let Some(rest_size) = size.checked_sub(min_size) {\n                                 tcx.mk_array(inner, rest_size)\n                             } else {\n@@ -572,7 +573,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         match operand {\n             &Operand::Constant(box Constant {\n                 literal: Literal::Value {\n-                    value: ConstVal::Function(def_id, _), ..\n+                    value: &ty::Const { val: ConstVal::Function(def_id, _), .. }, ..\n                 }, ..\n             }) => {\n                 Some(def_id) == self.tcx().lang_items().box_free_fn()"}, {"sha": "4a11ac11680906c076346e0728e1e5ee06e1b819", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -922,7 +922,12 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         Operand::Constant(box Constant {\n             span: self.source_info.span,\n             ty: self.tcx().types.usize,\n-            literal: Literal::Value { value: ConstVal::Integral(self.tcx().const_usize(val)) }\n+            literal: Literal::Value {\n+                value: self.tcx().mk_const(ty::Const {\n+                    val: ConstVal::Integral(self.tcx().const_usize(val)),\n+                    ty: self.tcx().types.usize\n+                })\n+            }\n         })\n     }\n "}, {"sha": "1fa49614580a3a19b091faf077d6361062a0e75a", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -13,15 +13,14 @@\n // completely accurate (some things might be counted twice, others missed).\n \n use rustc_const_math::{ConstUsize};\n-use rustc::middle::const_val::{ConstVal};\n use rustc::mir::{AggregateKind, AssertMessage, BasicBlock, BasicBlockData};\n use rustc::mir::{Constant, Literal, Location, LocalDecl};\n use rustc::mir::{Lvalue, LvalueElem, LvalueProjection};\n use rustc::mir::{Mir, Operand, ProjectionElem};\n use rustc::mir::{Rvalue, SourceInfo, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind, VisibilityScope, VisibilityScopeData};\n use rustc::mir::visit as mir_visit;\n-use rustc::ty::{ClosureSubsts, TyCtxt};\n+use rustc::ty::{self, ClosureSubsts, TyCtxt};\n use rustc::util::nodemap::{FxHashMap};\n \n struct NodeData {\n@@ -236,7 +235,6 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n                      location: Location) {\n         self.record(\"Literal\", literal);\n         self.record(match *literal {\n-            Literal::Item { .. } => \"Literal::Item\",\n             Literal::Value { .. } => \"Literal::Value\",\n             Literal::Promoted { .. } => \"Literal::Promoted\",\n         }, literal);\n@@ -256,11 +254,11 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n         self.super_closure_substs(substs);\n     }\n \n-    fn visit_const_val(&mut self,\n-                       const_val: &ConstVal,\n-                       _: Location) {\n-        self.record(\"ConstVal\", const_val);\n-        self.super_const_val(const_val);\n+    fn visit_const(&mut self,\n+                   constant: &&'tcx ty::Const<'tcx>,\n+                   _: Location) {\n+        self.record(\"Const\", constant);\n+        self.super_const(constant);\n     }\n \n     fn visit_const_usize(&mut self,"}, {"sha": "4211c8df5ca0385dd8ae27112ec42bc442cc65fb", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -11,7 +11,7 @@\n use llvm::{self, ValueRef, AttributePlace};\n use base;\n use builder::Builder;\n-use common::{instance_ty, ty_fn_sig, type_is_fat_ptr, C_uint};\n+use common::{instance_ty, ty_fn_sig, type_is_fat_ptr, C_usize};\n use context::CrateContext;\n use cabi_x86;\n use cabi_x86_64;\n@@ -527,7 +527,7 @@ impl<'a, 'tcx> ArgType<'tcx> {\n         }\n         let ccx = bcx.ccx;\n         if self.is_indirect() {\n-            let llsz = C_uint(ccx, self.layout.size(ccx).bytes());\n+            let llsz = C_usize(ccx, self.layout.size(ccx).bytes());\n             let llalign = self.layout.align(ccx).abi();\n             base::call_memcpy(bcx, dst, val, llsz, llalign as u32);\n         } else if let Some(ty) = self.cast {\n@@ -564,7 +564,7 @@ impl<'a, 'tcx> ArgType<'tcx> {\n                 base::call_memcpy(bcx,\n                                   bcx.pointercast(dst, Type::i8p(ccx)),\n                                   bcx.pointercast(llscratch, Type::i8p(ccx)),\n-                                  C_uint(ccx, self.layout.size(ccx).bytes()),\n+                                  C_usize(ccx, self.layout.size(ccx).bytes()),\n                                   cmp::min(self.layout.align(ccx).abi() as u32,\n                                            llalign_of_min(ccx, ty)));\n "}, {"sha": "23a45a7962abfacf6c5cbffa7ddce260d0eaa1ee", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -397,11 +397,11 @@ pub fn trans_set_discr<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, val: Valu\n     match *l {\n         layout::CEnum{ discr, min, max, .. } => {\n             assert_discr_in_range(min, max, to);\n-            bcx.store(C_integral(Type::from_integer(bcx.ccx, discr), to, true),\n+            bcx.store(C_int(Type::from_integer(bcx.ccx, discr), to as i64),\n                   val, None);\n         }\n         layout::General{ discr, .. } => {\n-            bcx.store(C_integral(Type::from_integer(bcx.ccx, discr), to, true),\n+            bcx.store(C_int(Type::from_integer(bcx.ccx, discr), to as i64),\n                   bcx.struct_gep(val, 0), None);\n         }\n         layout::Univariant { .. }\n@@ -423,7 +423,7 @@ pub fn trans_set_discr<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, val: Valu\n                     // than storing null to single target field.\n                     let llptr = bcx.pointercast(val, Type::i8(bcx.ccx).ptr_to());\n                     let fill_byte = C_u8(bcx.ccx, 0);\n-                    let size = C_uint(bcx.ccx, nonnull.stride().bytes());\n+                    let size = C_usize(bcx.ccx, nonnull.stride().bytes());\n                     let align = C_i32(bcx.ccx, nonnull.align.abi() as i32);\n                     base::call_memset(bcx, llptr, fill_byte, size, align, false);\n                 } else {"}, {"sha": "73209affe994b4462f51e08c2c079203ea054f7e", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -53,7 +53,7 @@ use mir::lvalue::LvalueRef;\n use attributes;\n use builder::Builder;\n use callee;\n-use common::{C_bool, C_bytes_in_context, C_i32, C_uint};\n+use common::{C_bool, C_bytes_in_context, C_i32, C_usize};\n use collector::{self, TransItemCollectionMode};\n use common::{C_struct_in_context, C_u64, C_undef, C_array};\n use common::CrateContext;\n@@ -201,7 +201,9 @@ pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n                                 -> ValueRef {\n     let (source, target) = ccx.tcx().struct_lockstep_tails(source, target);\n     match (&source.sty, &target.sty) {\n-        (&ty::TyArray(_, len), &ty::TySlice(_)) => C_uint(ccx, len),\n+        (&ty::TyArray(_, len), &ty::TySlice(_)) => {\n+            C_usize(ccx, len.val.to_const_int().unwrap().to_u64().unwrap())\n+        }\n         (&ty::TyDynamic(..), &ty::TyDynamic(..)) => {\n             // For now, upcasts are limited to changes in marker\n             // traits, and hence never actually require an actual\n@@ -524,7 +526,7 @@ pub fn call_memcpy<'a, 'tcx>(b: &Builder<'a, 'tcx>,\n     let memcpy = ccx.get_intrinsic(&key);\n     let src_ptr = b.pointercast(src, Type::i8p(ccx));\n     let dst_ptr = b.pointercast(dst, Type::i8p(ccx));\n-    let size = b.intcast(n_bytes, ccx.int_type(), false);\n+    let size = b.intcast(n_bytes, ccx.isize_ty(), false);\n     let align = C_i32(ccx, align as i32);\n     let volatile = C_bool(ccx, false);\n     b.call(memcpy, &[dst_ptr, src_ptr, size, align, volatile], None);\n@@ -545,7 +547,7 @@ pub fn memcpy_ty<'a, 'tcx>(\n     }\n \n     let align = align.unwrap_or_else(|| ccx.align_of(t));\n-    call_memcpy(bcx, dst, src, C_uint(ccx, size), align);\n+    call_memcpy(bcx, dst, src, C_usize(ccx, size), align);\n }\n \n pub fn call_memset<'a, 'tcx>(b: &Builder<'a, 'tcx>,\n@@ -696,7 +698,7 @@ fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n                        sp: Span,\n                        rust_main: ValueRef,\n                        use_start_lang_item: bool) {\n-        let llfty = Type::func(&[ccx.int_type(), Type::i8p(ccx).ptr_to()], &ccx.int_type());\n+        let llfty = Type::func(&[ccx.isize_ty(), Type::i8p(ccx).ptr_to()], &ccx.isize_ty());\n \n         if declare::get_defined_value(ccx, \"main\").is_some() {\n             // FIXME: We should be smart and show a better diagnostic here."}, {"sha": "3bf709ff7ba9d227fa679e3d2edc7fa022c5754e", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -193,6 +193,7 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n \n use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n+use rustc::middle::const_val::ConstVal;\n use rustc::middle::lang_items::{ExchangeMallocFnLangItem};\n use rustc::traits;\n use rustc::ty::subst::Substs;\n@@ -564,24 +565,17 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         self.super_rvalue(rvalue, location);\n     }\n \n-    fn visit_constant(&mut self, constant: &mir::Constant<'tcx>, location: Location) {\n-        debug!(\"visiting constant {:?} @ {:?}\", *constant, location);\n+    fn visit_const(&mut self, constant: &&'tcx ty::Const<'tcx>, location: Location) {\n+        debug!(\"visiting const {:?} @ {:?}\", *constant, location);\n \n-        if let ty::TyFnDef(..) = constant.ty.sty {\n-            // function definitions are zero-sized, and only generate\n-            // IR when they are called/reified.\n-            self.super_constant(constant, location);\n-            return\n-        }\n-\n-        if let mir::Literal::Item { def_id, substs } = constant.literal {\n+        if let ConstVal::Unevaluated(def_id, substs) = constant.val {\n             let substs = self.scx.tcx().trans_apply_param_substs(self.param_substs,\n                                                                  &substs);\n             let instance = monomorphize::resolve(self.scx, def_id, substs);\n             collect_neighbours(self.scx, instance, true, self.output);\n         }\n \n-        self.super_constant(constant, location);\n+        self.super_const(constant);\n     }\n \n     fn visit_terminator_kind(&mut self,"}, {"sha": "67c95b92e523b6adc4924defe6d6732575e61e37", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 20, "deletions": 29, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -221,9 +221,15 @@ pub fn C_undef(t: Type) -> ValueRef {\n     }\n }\n \n-pub fn C_integral(t: Type, u: u64, sign_extend: bool) -> ValueRef {\n+pub fn C_int(t: Type, i: i64) -> ValueRef {\n     unsafe {\n-        llvm::LLVMConstInt(t.to_ref(), u, sign_extend as Bool)\n+        llvm::LLVMConstInt(t.to_ref(), i as u64, True)\n+    }\n+}\n+\n+pub fn C_uint(t: Type, i: u64) -> ValueRef {\n+    unsafe {\n+        llvm::LLVMConstInt(t.to_ref(), i, False)\n     }\n }\n \n@@ -239,49 +245,34 @@ pub fn C_nil(ccx: &CrateContext) -> ValueRef {\n }\n \n pub fn C_bool(ccx: &CrateContext, val: bool) -> ValueRef {\n-    C_integral(Type::i1(ccx), val as u64, false)\n+    C_uint(Type::i1(ccx), val as u64)\n }\n \n pub fn C_i32(ccx: &CrateContext, i: i32) -> ValueRef {\n-    C_integral(Type::i32(ccx), i as u64, true)\n+    C_int(Type::i32(ccx), i as i64)\n }\n \n pub fn C_u32(ccx: &CrateContext, i: u32) -> ValueRef {\n-    C_integral(Type::i32(ccx), i as u64, false)\n+    C_uint(Type::i32(ccx), i as u64)\n }\n \n pub fn C_u64(ccx: &CrateContext, i: u64) -> ValueRef {\n-    C_integral(Type::i64(ccx), i, false)\n+    C_uint(Type::i64(ccx), i)\n }\n \n-pub fn C_uint<I: AsU64>(ccx: &CrateContext, i: I) -> ValueRef {\n-    let v = i.as_u64();\n-\n-    let bit_size = machine::llbitsize_of_real(ccx, ccx.int_type());\n+pub fn C_usize(ccx: &CrateContext, i: u64) -> ValueRef {\n+    let bit_size = machine::llbitsize_of_real(ccx, ccx.isize_ty());\n \n     if bit_size < 64 {\n         // make sure it doesn't overflow\n-        assert!(v < (1<<bit_size));\n+        assert!(i < (1<<bit_size));\n     }\n \n-    C_integral(ccx.int_type(), v, false)\n+    C_uint(ccx.isize_ty(), i)\n }\n \n-pub trait AsI64 { fn as_i64(self) -> i64; }\n-pub trait AsU64 { fn as_u64(self) -> u64; }\n-\n-// FIXME: remove the intptr conversions, because they\n-// are host-architecture-dependent\n-impl AsI64 for i64 { fn as_i64(self) -> i64 { self as i64 }}\n-impl AsI64 for i32 { fn as_i64(self) -> i64 { self as i64 }}\n-impl AsI64 for isize { fn as_i64(self) -> i64 { self as i64 }}\n-\n-impl AsU64 for u64  { fn as_u64(self) -> u64 { self as u64 }}\n-impl AsU64 for u32  { fn as_u64(self) -> u64 { self as u64 }}\n-impl AsU64 for usize { fn as_u64(self) -> u64 { self as u64 }}\n-\n pub fn C_u8(ccx: &CrateContext, i: u8) -> ValueRef {\n-    C_integral(Type::i8(ccx), i as u64, false)\n+    C_uint(Type::i8(ccx), i as u64)\n }\n \n \n@@ -315,7 +306,7 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n pub fn C_str_slice(cx: &CrateContext, s: InternedString) -> ValueRef {\n     let len = s.len();\n     let cs = consts::ptrcast(C_cstr(cx, s, false), Type::i8p(cx));\n-    C_named_struct(cx.str_slice_type(), &[cs, C_uint(cx, len)])\n+    C_named_struct(cx.str_slice_type(), &[cs, C_usize(cx, len as u64)])\n }\n \n pub fn C_struct(cx: &CrateContext, elts: &[ValueRef], packed: bool) -> ValueRef {\n@@ -482,9 +473,9 @@ pub fn shift_mask_val<'a, 'tcx>(\n             // i8/u8 can shift by at most 7, i16/u16 by at most 15, etc.\n             let val = llty.int_width() - 1;\n             if invert {\n-                C_integral(mask_llty, !val, true)\n+                C_int(mask_llty, !val as i64)\n             } else {\n-                C_integral(mask_llty, val, false)\n+                C_uint(mask_llty, val)\n             }\n         },\n         TypeKind::Vector => {"}, {"sha": "77bddc7731b5bee0a3a65203102f9bc7f2e2dee6", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -136,7 +136,7 @@ pub struct LocalCrateContext<'a, 'tcx: 'a> {\n     used_statics: RefCell<Vec<ValueRef>>,\n \n     lltypes: RefCell<FxHashMap<Ty<'tcx>, Type>>,\n-    int_type: Type,\n+    isize_ty: Type,\n     opaque_vec_type: Type,\n     str_slice_type: Type,\n \n@@ -398,7 +398,7 @@ impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n                 statics_to_rauw: RefCell::new(Vec::new()),\n                 used_statics: RefCell::new(Vec::new()),\n                 lltypes: RefCell::new(FxHashMap()),\n-                int_type: Type::from_ref(ptr::null_mut()),\n+                isize_ty: Type::from_ref(ptr::null_mut()),\n                 opaque_vec_type: Type::from_ref(ptr::null_mut()),\n                 str_slice_type: Type::from_ref(ptr::null_mut()),\n                 dbg_cx,\n@@ -410,23 +410,23 @@ impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n                 placeholder: PhantomData,\n             };\n \n-            let (int_type, opaque_vec_type, str_slice_ty, mut local_ccx) = {\n+            let (isize_ty, opaque_vec_type, str_slice_ty, mut local_ccx) = {\n                 // Do a little dance to create a dummy CrateContext, so we can\n                 // create some things in the LLVM module of this codegen unit\n                 let mut local_ccxs = vec![local_ccx];\n-                let (int_type, opaque_vec_type, str_slice_ty) = {\n+                let (isize_ty, opaque_vec_type, str_slice_ty) = {\n                     let dummy_ccx = LocalCrateContext::dummy_ccx(shared,\n                                                                  local_ccxs.as_mut_slice());\n                     let mut str_slice_ty = Type::named_struct(&dummy_ccx, \"str_slice\");\n                     str_slice_ty.set_struct_body(&[Type::i8p(&dummy_ccx),\n-                                                   Type::int(&dummy_ccx)],\n+                                                   Type::isize(&dummy_ccx)],\n                                                  false);\n-                    (Type::int(&dummy_ccx), Type::opaque_vec(&dummy_ccx), str_slice_ty)\n+                    (Type::isize(&dummy_ccx), Type::opaque_vec(&dummy_ccx), str_slice_ty)\n                 };\n-                (int_type, opaque_vec_type, str_slice_ty, local_ccxs.pop().unwrap())\n+                (isize_ty, opaque_vec_type, str_slice_ty, local_ccxs.pop().unwrap())\n             };\n \n-            local_ccx.int_type = int_type;\n+            local_ccx.isize_ty = isize_ty;\n             local_ccx.opaque_vec_type = opaque_vec_type;\n             local_ccx.str_slice_type = str_slice_ty;\n \n@@ -549,8 +549,8 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().stats\n     }\n \n-    pub fn int_type(&self) -> Type {\n-        self.local().int_type\n+    pub fn isize_ty(&self) -> Type {\n+        self.local().isize_ty\n     }\n \n     pub fn str_slice_type(&self) -> Type {"}, {"sha": "3c87bc293b5b58cc67faf14f7127025e780d3614", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -366,7 +366,7 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                          -> bool {\n         member_llvm_types.len() == 2 &&\n         member_llvm_types[0] == type_of::type_of(cx, element_type).ptr_to() &&\n-        member_llvm_types[1] == cx.int_type()\n+        member_llvm_types[1] == cx.isize_ty()\n     }\n }\n \n@@ -530,7 +530,8 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n         }\n         ty::TyArray(typ, len) => {\n-            fixed_vec_metadata(cx, unique_type_id, typ, Some(len as u64), usage_site_span)\n+            let len = len.val.to_const_int().unwrap().to_u64().unwrap();\n+            fixed_vec_metadata(cx, unique_type_id, typ, Some(len), usage_site_span)\n         }\n         ty::TySlice(typ) => {\n             fixed_vec_metadata(cx, unique_type_id, typ, None, usage_site_span)"}, {"sha": "7bf9d39ea2f252bdee9f0704c3c0e97369464e64", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -96,7 +96,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyArray(inner_type, len) => {\n             output.push('[');\n             push_debuginfo_type_name(cx, inner_type, true, output);\n-            output.push_str(&format!(\"; {}\", len));\n+            output.push_str(&format!(\"; {}\", len.val.to_const_int().unwrap().to_u64().unwrap()));\n             output.push(']');\n         },\n         ty::TySlice(inner_type) => {"}, {"sha": "8dd0b4e466ce491bedcb291c963218b64317aaf6", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -70,8 +70,8 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n         let align = bcx.ccx.align_of(t);\n         debug!(\"size_and_align_of_dst t={} info={:?} size: {} align: {}\",\n                t, Value(info), size, align);\n-        let size = C_uint(bcx.ccx, size);\n-        let align = C_uint(bcx.ccx, align);\n+        let size = C_usize(bcx.ccx, size);\n+        let align = C_usize(bcx.ccx, align as u64);\n         return (size, align);\n     }\n     assert!(!info.is_null());\n@@ -96,8 +96,8 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n             };\n             debug!(\"DST {} statically sized prefix size: {} align: {}\",\n                    t, sized_size, sized_align);\n-            let sized_size = C_uint(ccx, sized_size);\n-            let sized_align = C_uint(ccx, sized_align);\n+            let sized_size = C_usize(ccx, sized_size);\n+            let sized_align = C_usize(ccx, sized_align);\n \n             // Recurse to get the size of the dynamically sized field (must be\n             // the last field).\n@@ -128,7 +128,7 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n                 (Some(sized_align), Some(unsized_align)) => {\n                     // If both alignments are constant, (the sized_align should always be), then\n                     // pick the correct alignment statically.\n-                    C_uint(ccx, std::cmp::max(sized_align, unsized_align) as u64)\n+                    C_usize(ccx, std::cmp::max(sized_align, unsized_align) as u64)\n                 }\n                 _ => bcx.select(bcx.icmp(llvm::IntUGT, sized_align, unsized_align),\n                                 sized_align,\n@@ -146,7 +146,7 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n             //\n             //   `(size + (align-1)) & -align`\n \n-            let addend = bcx.sub(align, C_uint(bcx.ccx, 1_u64));\n+            let addend = bcx.sub(align, C_usize(bcx.ccx, 1));\n             let size = bcx.and(bcx.add(size, addend), bcx.neg(align));\n \n             (size, align)\n@@ -159,8 +159,8 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n             let unit = t.sequence_element_type(bcx.tcx());\n             // The info in this case is the length of the str, so the size is that\n             // times the unit size.\n-            (bcx.mul(info, C_uint(bcx.ccx, bcx.ccx.size_of(unit))),\n-             C_uint(bcx.ccx, bcx.ccx.align_of(unit)))\n+            (bcx.mul(info, C_usize(bcx.ccx, bcx.ccx.size_of(unit))),\n+             C_usize(bcx.ccx, bcx.ccx.align_of(unit) as u64))\n         }\n         _ => bug!(\"Unexpected unsized type, found {}\", t)\n     }"}, {"sha": "f78d80a197ca9a68ffa84c6c60bd46f227bdd8cb", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -135,7 +135,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         \"size_of\" => {\n             let tp_ty = substs.type_at(0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            C_uint(ccx, machine::llsize_of_alloc(ccx, lltp_ty))\n+            C_usize(ccx, machine::llsize_of_alloc(ccx, lltp_ty))\n         }\n         \"size_of_val\" => {\n             let tp_ty = substs.type_at(0);\n@@ -145,12 +145,12 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 llsize\n             } else {\n                 let lltp_ty = type_of::type_of(ccx, tp_ty);\n-                C_uint(ccx, machine::llsize_of_alloc(ccx, lltp_ty))\n+                C_usize(ccx, machine::llsize_of_alloc(ccx, lltp_ty))\n             }\n         }\n         \"min_align_of\" => {\n             let tp_ty = substs.type_at(0);\n-            C_uint(ccx, ccx.align_of(tp_ty))\n+            C_usize(ccx, ccx.align_of(tp_ty) as u64)\n         }\n         \"min_align_of_val\" => {\n             let tp_ty = substs.type_at(0);\n@@ -159,13 +159,13 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                     glue::size_and_align_of_dst(bcx, tp_ty, llargs[1]);\n                 llalign\n             } else {\n-                C_uint(ccx, ccx.align_of(tp_ty))\n+                C_usize(ccx, ccx.align_of(tp_ty) as u64)\n             }\n         }\n         \"pref_align_of\" => {\n             let tp_ty = substs.type_at(0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            C_uint(ccx, machine::llalign_of_pref(ccx, lltp_ty))\n+            C_usize(ccx, machine::llalign_of_pref(ccx, lltp_ty) as u64)\n         }\n         \"type_name\" => {\n             let tp_ty = substs.type_at(0);\n@@ -182,7 +182,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 // If we store a zero constant, LLVM will drown in vreg allocation for large data\n                 // structures, and the generated code will be awful. (A telltale sign of this is\n                 // large quantities of `mov [byte ptr foo],0` in the generated code.)\n-                memset_intrinsic(bcx, false, ty, llresult, C_u8(ccx, 0), C_uint(ccx, 1usize));\n+                memset_intrinsic(bcx, false, ty, llresult, C_u8(ccx, 0), C_usize(ccx, 1));\n             }\n             C_nil(ccx)\n         }\n@@ -386,10 +386,10 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n         \"align_offset\" => {\n             // `ptr as usize`\n-            let ptr_val = bcx.ptrtoint(llargs[0], bcx.ccx.int_type());\n+            let ptr_val = bcx.ptrtoint(llargs[0], bcx.ccx.isize_ty());\n             // `ptr_val % align`\n             let offset = bcx.urem(ptr_val, llargs[1]);\n-            let zero = C_null(bcx.ccx.int_type());\n+            let zero = C_null(bcx.ccx.isize_ty());\n             // `offset == 0`\n             let is_zero = bcx.icmp(llvm::IntPredicate::IntEQ, offset, zero);\n             // `if offset == 0 { 0 } else { offset - align }`\n@@ -688,7 +688,7 @@ fn copy_intrinsic<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n     let lltp_ty = type_of::type_of(ccx, tp_ty);\n     let align = C_i32(ccx, ccx.align_of(tp_ty) as i32);\n     let size = machine::llsize_of(ccx, lltp_ty);\n-    let int_size = machine::llbitsize_of_real(ccx, ccx.int_type());\n+    let int_size = machine::llbitsize_of_real(ccx, ccx.isize_ty());\n \n     let operation = if allow_overlap {\n         \"memmove\""}, {"sha": "bc383abc7e0ecc96aeb18ead69c13991aaa3d55f", "filename": "src/librustc_trans/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmachine.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -48,7 +48,7 @@ pub fn llsize_of(cx: &CrateContext, ty: Type) -> ValueRef {\n     // there's no need for that contrivance.  The instruction\n     // selection DAG generator would flatten that GEP(1) node into a\n     // constant of the type's alloc size, so let's save it some work.\n-    return C_uint(cx, llsize_of_alloc(cx, ty));\n+    return C_usize(cx, llsize_of_alloc(cx, ty));\n }\n \n // Returns the preferred alignment of the given type for the current target."}, {"sha": "6eedd53974e70482a76cca732d4c90ea6c2a6719", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -46,7 +46,7 @@ impl<'a, 'tcx> VirtualIndex {\n         // Load the data pointer from the object.\n         debug!(\"get_int({:?}, {:?})\", Value(llvtable), self);\n \n-        let llvtable = bcx.pointercast(llvtable, Type::int(bcx.ccx).ptr_to());\n+        let llvtable = bcx.pointercast(llvtable, Type::isize(bcx.ccx).ptr_to());\n         let ptr = bcx.load(bcx.gepi(llvtable, &[self.0]), None);\n         // Vtable loads are invariant\n         bcx.set_invariant_load(ptr);\n@@ -81,8 +81,8 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let mut components: Vec<_> = [\n         callee::get_fn(ccx, monomorphize::resolve_drop_in_place(ccx.shared(), ty)),\n-        C_uint(ccx, ccx.size_of(ty)),\n-        C_uint(ccx, ccx.align_of(ty))\n+        C_usize(ccx, ccx.size_of(ty)),\n+        C_usize(ccx, ccx.align_of(ty) as u64)\n     ].iter().cloned().collect();\n \n     if let Some(trait_ref) = trait_ref {"}, {"sha": "1017ec6b3c3f85608e33a553e916e39d4fe25988", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -17,6 +17,7 @@ use rustc::middle::const_val::ConstVal;\n use rustc::mir::{self, Location, TerminatorKind, Literal};\n use rustc::mir::visit::{Visitor, LvalueContext};\n use rustc::mir::traversal;\n+use rustc::ty;\n use common;\n use super::MirContext;\n \n@@ -110,7 +111,7 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n             mir::TerminatorKind::Call {\n                 func: mir::Operand::Constant(box mir::Constant {\n                     literal: Literal::Value {\n-                        value: ConstVal::Function(def_id, _), ..\n+                        value: &ty::Const { val: ConstVal::Function(def_id, _), .. }, ..\n                     }, ..\n                 }),\n                 ref args, .."}, {"sha": "4c3326a466d3a4f919ecebd1789fada6c78b1619", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 44, "deletions": 45, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -26,8 +26,8 @@ use abi::{self, Abi};\n use callee;\n use builder::Builder;\n use common::{self, CrateContext, const_get_elt, val_ty};\n-use common::{C_array, C_bool, C_bytes, C_integral, C_big_integral, C_u32, C_u64};\n-use common::{C_null, C_struct, C_str_slice, C_undef, C_uint, C_vector, is_undef};\n+use common::{C_array, C_bool, C_bytes, C_int, C_uint, C_big_integral, C_u32, C_u64};\n+use common::{C_null, C_struct, C_str_slice, C_undef, C_usize, C_vector, is_undef};\n use common::const_to_opt_u128;\n use consts;\n use monomorphize;\n@@ -66,35 +66,29 @@ impl<'tcx> Const<'tcx> {\n     -> Const<'tcx> {\n         let tcx = ccx.tcx();\n         let (llval, ty) = match *ci {\n-            I8(v) => (C_integral(Type::i8(ccx), v as u64, true), tcx.types.i8),\n-            I16(v) => (C_integral(Type::i16(ccx), v as u64, true), tcx.types.i16),\n-            I32(v) => (C_integral(Type::i32(ccx), v as u64, true), tcx.types.i32),\n-            I64(v) => (C_integral(Type::i64(ccx), v as u64, true), tcx.types.i64),\n+            I8(v) => (C_int(Type::i8(ccx), v as i64), tcx.types.i8),\n+            I16(v) => (C_int(Type::i16(ccx), v as i64), tcx.types.i16),\n+            I32(v) => (C_int(Type::i32(ccx), v as i64), tcx.types.i32),\n+            I64(v) => (C_int(Type::i64(ccx), v as i64), tcx.types.i64),\n             I128(v) => (C_big_integral(Type::i128(ccx), v as u128), tcx.types.i128),\n-            Isize(v) => {\n-                let i = v.as_i64(ccx.tcx().sess.target.int_type);\n-                (C_integral(Type::int(ccx), i as u64, true), tcx.types.isize)\n-            },\n-            U8(v) => (C_integral(Type::i8(ccx), v as u64, false), tcx.types.u8),\n-            U16(v) => (C_integral(Type::i16(ccx), v as u64, false), tcx.types.u16),\n-            U32(v) => (C_integral(Type::i32(ccx), v as u64, false), tcx.types.u32),\n-            U64(v) => (C_integral(Type::i64(ccx), v, false), tcx.types.u64),\n+            Isize(v) => (C_int(Type::isize(ccx), v.as_i64()), tcx.types.isize),\n+            U8(v) => (C_uint(Type::i8(ccx), v as u64), tcx.types.u8),\n+            U16(v) => (C_uint(Type::i16(ccx), v as u64), tcx.types.u16),\n+            U32(v) => (C_uint(Type::i32(ccx), v as u64), tcx.types.u32),\n+            U64(v) => (C_uint(Type::i64(ccx), v), tcx.types.u64),\n             U128(v) => (C_big_integral(Type::i128(ccx), v), tcx.types.u128),\n-            Usize(v) => {\n-                let u = v.as_u64(ccx.tcx().sess.target.uint_type);\n-                (C_integral(Type::int(ccx), u, false), tcx.types.usize)\n-            },\n+            Usize(v) => (C_uint(Type::isize(ccx), v.as_u64()), tcx.types.usize),\n         };\n         Const { llval: llval, ty: ty }\n     }\n \n     /// Translate ConstVal into a LLVM constant value.\n     pub fn from_constval<'a>(ccx: &CrateContext<'a, 'tcx>,\n-                             cv: ConstVal,\n+                             cv: &ConstVal,\n                              ty: Ty<'tcx>)\n                              -> Const<'tcx> {\n         let llty = type_of::type_of(ccx, ty);\n-        let val = match cv {\n+        let val = match *cv {\n             ConstVal::Float(v) => {\n                 let bits = match v.ty {\n                     ast::FloatTy::F32 => C_u32(ccx, v.bits as u32),\n@@ -105,12 +99,12 @@ impl<'tcx> Const<'tcx> {\n             ConstVal::Bool(v) => C_bool(ccx, v),\n             ConstVal::Integral(ref i) => return Const::from_constint(ccx, i),\n             ConstVal::Str(ref v) => C_str_slice(ccx, v.clone()),\n-            ConstVal::ByteStr(ref v) => consts::addr_of(ccx, C_bytes(ccx, v), 1, \"byte_str\"),\n-            ConstVal::Char(c) => C_integral(Type::char(ccx), c as u64, false),\n+            ConstVal::ByteStr(v) => consts::addr_of(ccx, C_bytes(ccx, v.data), 1, \"byte_str\"),\n+            ConstVal::Char(c) => C_uint(Type::char(ccx), c as u64),\n             ConstVal::Function(..) => C_null(type_of::type_of(ccx, ty)),\n             ConstVal::Variant(_) |\n-            ConstVal::Struct(_) | ConstVal::Tuple(_) |\n-            ConstVal::Array(..) | ConstVal::Repeat(..) => {\n+            ConstVal::Aggregate(..) |\n+            ConstVal::Unevaluated(..) => {\n                 bug!(\"MIR must not use `{:?}` (aggregates are expanded to MIR rvalues)\", cv)\n             }\n         };\n@@ -207,7 +201,9 @@ impl<'tcx> ConstLvalue<'tcx> {\n \n     pub fn len<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n         match self.ty.sty {\n-            ty::TyArray(_, n) => C_uint(ccx, n),\n+            ty::TyArray(_, n) => {\n+                C_usize(ccx, n.val.to_const_int().unwrap().to_u64().unwrap())\n+            }\n             ty::TySlice(_) | ty::TyStr => {\n                 assert!(self.llextra != ptr::null_mut());\n                 self.llextra\n@@ -367,13 +363,13 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         let result = if fn_ty.fn_sig(tcx).abi() == Abi::RustIntrinsic {\n                             match &tcx.item_name(def_id)[..] {\n                                 \"size_of\" => {\n-                                    let llval = C_uint(self.ccx,\n+                                    let llval = C_usize(self.ccx,\n                                         self.ccx.size_of(substs.type_at(0)));\n                                     Ok(Const::new(llval, tcx.types.usize))\n                                 }\n                                 \"min_align_of\" => {\n-                                    let llval = C_uint(self.ccx,\n-                                        self.ccx.align_of(substs.type_at(0)));\n+                                    let llval = C_usize(self.ccx,\n+                                        self.ccx.align_of(substs.type_at(0)) as u64);\n                                     Ok(Const::new(llval, tcx.types.usize))\n                                 }\n                                 _ => span_bug!(span, \"{:?} in constant\", terminator.kind)\n@@ -514,16 +510,17 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n             mir::Operand::Constant(ref constant) => {\n                 let ty = self.monomorphize(&constant.ty);\n                 match constant.literal.clone() {\n-                    mir::Literal::Item { def_id, substs } => {\n-                        let substs = self.monomorphize(&substs);\n-                        MirConstContext::trans_def(self.ccx, def_id, substs, IndexVec::new())\n-                    }\n                     mir::Literal::Promoted { index } => {\n                         let mir = &self.mir.promoted[index];\n                         MirConstContext::new(self.ccx, mir, self.substs, IndexVec::new()).trans()\n                     }\n                     mir::Literal::Value { value } => {\n-                        Ok(Const::from_constval(self.ccx, value, ty))\n+                        if let ConstVal::Unevaluated(def_id, substs) = value.val {\n+                            let substs = self.monomorphize(&substs);\n+                            MirConstContext::trans_def(self.ccx, def_id, substs, IndexVec::new())\n+                        } else {\n+                            Ok(Const::from_constval(self.ccx, &value.val, ty))\n+                        }\n                     }\n                 }\n             }\n@@ -557,9 +554,10 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n         let val = match *rvalue {\n             mir::Rvalue::Use(ref operand) => self.const_operand(operand, span)?,\n \n-            mir::Rvalue::Repeat(ref elem, ref count) => {\n+            mir::Rvalue::Repeat(ref elem, count) => {\n                 let elem = self.const_operand(elem, span)?;\n-                let size = count.as_u64(tcx.sess.target.uint_type);\n+                let size = count.as_u64();\n+                assert_eq!(size as usize as u64, size);\n                 let fields = vec![elem.llval; size as usize];\n                 self.const_array(dest_ty, &fields)\n             }\n@@ -836,7 +834,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n             mir::Rvalue::NullaryOp(mir::NullOp::SizeOf, ty) => {\n                 assert!(self.ccx.shared().type_is_sized(ty));\n-                let llval = C_uint(self.ccx, self.ccx.size_of(ty));\n+                let llval = C_usize(self.ccx, self.ccx.size_of(ty));\n                 Const::new(llval, tcx.types.usize)\n             }\n \n@@ -854,10 +852,10 @@ fn to_const_int(value: ValueRef, t: Ty, tcx: TyCtxt) -> Option<ConstInt> {\n     match t.sty {\n         ty::TyInt(int_type) => const_to_opt_u128(value, true)\n             .and_then(|input| ConstInt::new_signed(input as i128, int_type,\n-                                                   tcx.sess.target.int_type)),\n+                                                   tcx.sess.target.isize_ty)),\n         ty::TyUint(uint_type) => const_to_opt_u128(value, false)\n             .and_then(|input| ConstInt::new_unsigned(input, uint_type,\n-                                                     tcx.sess.target.uint_type)),\n+                                                     tcx.sess.target.usize_ty)),\n         _ => None\n \n     }\n@@ -963,16 +961,17 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         debug!(\"trans_constant({:?})\", constant);\n         let ty = self.monomorphize(&constant.ty);\n         let result = match constant.literal.clone() {\n-            mir::Literal::Item { def_id, substs } => {\n-                let substs = self.monomorphize(&substs);\n-                MirConstContext::trans_def(bcx.ccx, def_id, substs, IndexVec::new())\n-            }\n             mir::Literal::Promoted { index } => {\n                 let mir = &self.mir.promoted[index];\n                 MirConstContext::new(bcx.ccx, mir, self.param_substs, IndexVec::new()).trans()\n             }\n             mir::Literal::Value { value } => {\n-                Ok(Const::from_constval(bcx.ccx, value, ty))\n+                if let ConstVal::Unevaluated(def_id, substs) = value.val {\n+                    let substs = self.monomorphize(&substs);\n+                    MirConstContext::trans_def(bcx.ccx, def_id, substs, IndexVec::new())\n+                } else {\n+                    Ok(Const::from_constval(bcx.ccx, &value.val, ty))\n+                }\n             }\n         };\n \n@@ -1038,11 +1037,11 @@ fn trans_const<'a, 'tcx>(\n             };\n             assert_eq!(vals.len(), 0);\n             adt::assert_discr_in_range(min, max, discr);\n-            C_integral(Type::from_integer(ccx, d), discr, true)\n+            C_int(Type::from_integer(ccx, d), discr as i64)\n         }\n         layout::General { discr: d, ref variants, .. } => {\n             let variant = &variants[variant_index];\n-            let lldiscr = C_integral(Type::from_integer(ccx, d), variant_index as u64, true);\n+            let lldiscr = C_int(Type::from_integer(ccx, d), variant_index as i64);\n             let mut vals_with_discr = vec![lldiscr];\n             vals_with_discr.extend_from_slice(vals);\n             let mut contents = build_const_struct(ccx, &variant, &vals_with_discr[..]);"}, {"sha": "6799e52904d3432f6c27d943d9d0a9ea4e588ab4", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -16,7 +16,7 @@ use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;\n use adt;\n use builder::Builder;\n-use common::{self, CrateContext, C_uint};\n+use common::{self, CrateContext, C_usize};\n use consts;\n use machine;\n use type_of;\n@@ -106,7 +106,9 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n     pub fn len(&self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n         let ty = self.ty.to_ty(ccx.tcx());\n         match ty.sty {\n-            ty::TyArray(_, n) => common::C_uint(ccx, n),\n+            ty::TyArray(_, n) => {\n+                common::C_usize(ccx, n.val.to_const_int().unwrap().to_u64().unwrap())\n+            }\n             ty::TySlice(_) | ty::TyStr => {\n                 assert!(self.llextra != ptr::null_mut());\n                 self.llextra\n@@ -186,7 +188,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n \n \n         let offset = st.offsets[ix].bytes();\n-        let unaligned_offset = C_uint(bcx.ccx, offset);\n+        let unaligned_offset = C_usize(bcx.ccx, offset);\n \n         // Get the alignment of the field\n         let (_, align) = glue::size_and_align_of_dst(bcx, fty, meta);\n@@ -197,7 +199,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         //   (unaligned offset + (align - 1)) & -align\n \n         // Calculate offset\n-        let align_sub_1 = bcx.sub(align, C_uint(bcx.ccx, 1u64));\n+        let align_sub_1 = bcx.sub(align, C_usize(bcx.ccx, 1));\n         let offset = bcx.and(bcx.add(unaligned_offset, align_sub_1),\n         bcx.neg(align));\n \n@@ -276,7 +278,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             // Slices already point to the array element type.\n             bcx.inbounds_gep(self.llval, &[llindex])\n         } else {\n-            let zero = common::C_uint(bcx.ccx, 0u64);\n+            let zero = common::C_usize(bcx.ccx, 0);\n             bcx.inbounds_gep(self.llval, &[zero, llindex])\n         }\n     }\n@@ -342,19 +344,19 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: false,\n                                                          min_length: _ } => {\n-                        let lloffset = C_uint(bcx.ccx, offset);\n+                        let lloffset = C_usize(bcx.ccx, offset as u64);\n                         ((tr_base.project_index(bcx, lloffset), align), ptr::null_mut())\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: true,\n                                                          min_length: _ } => {\n-                        let lloffset = C_uint(bcx.ccx, offset);\n+                        let lloffset = C_usize(bcx.ccx, offset as u64);\n                         let lllen = tr_base.len(bcx.ccx);\n                         let llindex = bcx.sub(lllen, lloffset);\n                         ((tr_base.project_index(bcx, llindex), align), ptr::null_mut())\n                     }\n                     mir::ProjectionElem::Subslice { from, to } => {\n-                        let llbase = tr_base.project_index(bcx, C_uint(bcx.ccx, from));\n+                        let llbase = tr_base.project_index(bcx, C_usize(bcx.ccx, from as u64));\n \n                         let base_ty = tr_base.ty.to_ty(bcx.tcx());\n                         match base_ty.sty {\n@@ -369,7 +371,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             ty::TySlice(..) => {\n                                 assert!(tr_base.llextra != ptr::null_mut());\n                                 let lllen = bcx.sub(tr_base.llextra,\n-                                                    C_uint(bcx.ccx, from+to));\n+                                                    C_usize(bcx.ccx, (from as u64)+(to as u64)));\n                                 ((llbase, align), lllen)\n                             }\n                             _ => bug!(\"unexpected type {:?} in Subslice\", base_ty)\n@@ -397,11 +399,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     /// nmatsakis: is this still necessary? Not sure.\n     fn prepare_index(&mut self, bcx: &Builder<'a, 'tcx>, llindex: ValueRef) -> ValueRef {\n         let index_size = machine::llbitsize_of_real(bcx.ccx, common::val_ty(llindex));\n-        let int_size = machine::llbitsize_of_real(bcx.ccx, bcx.ccx.int_type());\n+        let int_size = machine::llbitsize_of_real(bcx.ccx, bcx.ccx.isize_ty());\n         if index_size < int_size {\n-            bcx.zext(llindex, bcx.ccx.int_type())\n+            bcx.zext(llindex, bcx.ccx.isize_ty())\n         } else if index_size > int_size {\n-            bcx.trunc(llindex, bcx.ccx.int_type())\n+            bcx.trunc(llindex, bcx.ccx.isize_ty())\n         } else {\n             llindex\n         }"}, {"sha": "20ed4ab50a00f136065345fa903640923359048b", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -19,8 +19,7 @@ use rustc::middle::lang_items::ExchangeMallocFnLangItem;\n use base;\n use builder::Builder;\n use callee;\n-use common::{self, val_ty, C_bool, C_null, C_uint};\n-use common::{C_integral, C_i32};\n+use common::{self, val_ty, C_bool, C_i32, C_null, C_usize, C_uint};\n use adt;\n use machine;\n use monomorphize;\n@@ -92,7 +91,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 bcx\n             }\n \n-            mir::Rvalue::Repeat(ref elem, ref count) => {\n+            mir::Rvalue::Repeat(ref elem, count) => {\n                 let dest_ty = dest.ty.to_ty(bcx.tcx());\n \n                 // No need to inizialize memory of a zero-sized slice\n@@ -101,8 +100,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 }\n \n                 let tr_elem = self.trans_operand(&bcx, elem);\n-                let size = count.as_u64(bcx.tcx().sess.target.uint_type);\n-                let size = C_uint(bcx.ccx, size);\n+                let size = count.as_u64();\n+                let size = C_usize(bcx.ccx, size);\n                 let base = base::get_dataptr(&bcx, dest.llval);\n                 let align = dest.alignment.to_align();\n \n@@ -113,7 +112,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         let align = C_i32(bcx.ccx, align as i32);\n                         let ty = type_of::type_of(bcx.ccx, dest_ty);\n                         let size = machine::llsize_of(bcx.ccx, ty);\n-                        let fill = C_integral(Type::i8(bcx.ccx), 0, false);\n+                        let fill = C_uint(Type::i8(bcx.ccx), 0);\n                         base::call_memset(&bcx, base, fill, size, align, false);\n                         return bcx;\n                     }\n@@ -301,7 +300,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 base::call_assume(&bcx, bcx.icmp(\n                                     llvm::IntULE,\n                                     llval,\n-                                    C_integral(common::val_ty(llval), max, false)\n+                                    C_uint(common::val_ty(llval), max)\n                                 ));\n                             }\n \n@@ -464,7 +463,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n             mir::Rvalue::NullaryOp(mir::NullOp::SizeOf, ty) => {\n                 assert!(bcx.ccx.shared().type_is_sized(ty));\n-                let val = C_uint(bcx.ccx, bcx.ccx.size_of(ty));\n+                let val = C_usize(bcx.ccx, bcx.ccx.size_of(ty));\n                 let tcx = bcx.tcx();\n                 (bcx, OperandRef {\n                     val: OperandValue::Immediate(val),\n@@ -477,7 +476,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let llty = type_of::type_of(bcx.ccx, content_ty);\n                 let llsize = machine::llsize_of(bcx.ccx, llty);\n                 let align = bcx.ccx.align_of(content_ty);\n-                let llalign = C_uint(bcx.ccx, align);\n+                let llalign = C_usize(bcx.ccx, align as u64);\n                 let llty_ptr = llty.ptr_to();\n                 let box_ty = bcx.tcx().mk_box(content_ty);\n \n@@ -522,7 +521,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             if let LocalRef::Operand(Some(op)) = self.locals[index] {\n                 if common::type_is_zero_size(bcx.ccx, op.ty) {\n                     if let ty::TyArray(_, n) = op.ty.sty {\n-                        return common::C_uint(bcx.ccx, n);\n+                        let n = n.val.to_const_int().unwrap().to_u64().unwrap();\n+                        return common::C_usize(bcx.ccx, n);\n                     }\n                 }\n             }"}, {"sha": "1f27eb9fcb3095af2079e8ce2dd4101c84d6c18c", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -446,7 +446,8 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n             ty::TyArray(inner_type, len) => {\n                 output.push('[');\n                 self.push_type_name(inner_type, output);\n-                write!(output, \"; {}\", len).unwrap();\n+                write!(output, \"; {}\",\n+                    len.val.to_const_int().unwrap().to_u64().unwrap()).unwrap();\n                 output.push(']');\n             },\n             ty::TySlice(inner_type) => {"}, {"sha": "da4a4e55a67f4819356305a7b692979f8006b1af", "filename": "src/librustc_trans/tvec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftvec.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -34,7 +34,7 @@ pub fn slice_for_each<'a, 'tcx, F>(\n     let next_bcx = bcx.build_sibling_block(\"slice_loop_next\");\n \n     let start = if zst {\n-        C_uint(bcx.ccx, 0usize)\n+        C_usize(bcx.ccx, 1)\n     } else {\n         data_ptr\n     };\n@@ -46,7 +46,7 @@ pub fn slice_for_each<'a, 'tcx, F>(\n     let keep_going = header_bcx.icmp(llvm::IntNE, current, end);\n     header_bcx.cond_br(keep_going, body_bcx.llbb(), next_bcx.llbb());\n \n-    let next = add(&body_bcx, current, C_uint(bcx.ccx, 1usize));\n+    let next = add(&body_bcx, current, C_usize(bcx.ccx, 1));\n     f(&body_bcx, if zst { data_ptr } else { current }, header_bcx.llbb());\n     header_bcx.add_incoming_to_phi(current, next, body_bcx.llbb());\n     next_bcx"}, {"sha": "e5e532703d7d002ecf3a245ec6c6cd2bdb0b0a62", "filename": "src/librustc_trans/type_.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -131,7 +131,7 @@ impl Type {\n         Type::i8_llcx(llcx).ptr_to()\n     }\n \n-    pub fn int(ccx: &CrateContext) -> Type {\n+    pub fn isize(ccx: &CrateContext) -> Type {\n         match &ccx.tcx().sess.target.target.target_pointer_width[..] {\n             \"16\" => Type::i16(ccx),\n             \"32\" => Type::i32(ccx),\n@@ -142,7 +142,7 @@ impl Type {\n \n     pub fn int_from_ty(ccx: &CrateContext, t: ast::IntTy) -> Type {\n         match t {\n-            ast::IntTy::Is => ccx.int_type(),\n+            ast::IntTy::Is => ccx.isize_ty(),\n             ast::IntTy::I8 => Type::i8(ccx),\n             ast::IntTy::I16 => Type::i16(ccx),\n             ast::IntTy::I32 => Type::i32(ccx),\n@@ -153,7 +153,7 @@ impl Type {\n \n     pub fn uint_from_ty(ccx: &CrateContext, t: ast::UintTy) -> Type {\n         match t {\n-            ast::UintTy::Us => ccx.int_type(),\n+            ast::UintTy::Us => ccx.isize_ty(),\n             ast::UintTy::U8 => Type::i8(ccx),\n             ast::UintTy::U16 => Type::i16(ccx),\n             ast::UintTy::U32 => Type::i32(ccx),\n@@ -207,7 +207,7 @@ impl Type {\n \n     pub fn vec(ccx: &CrateContext, ty: &Type) -> Type {\n         Type::struct_(ccx,\n-            &[Type::array(ty, 0), Type::int(ccx)],\n+            &[Type::array(ty, 0), Type::isize(ccx)],\n         false)\n     }\n "}, {"sha": "992c74b9020c314eddd516664cb693fc6c1279e0", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -148,8 +148,8 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n       }\n \n       ty::TyArray(ty, size) => {\n-          let size = size as u64;\n           let llty = in_memory_type_of(cx, ty);\n+          let size = size.val.to_const_int().unwrap().to_u64().unwrap();\n           Type::array(&llty, size)\n       }\n "}, {"sha": "8f8663385b02001e1de8a7f479670e664cade831", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -12,7 +12,7 @@\n //! representation.  The main routine here is `ast_ty_to_ty()`: each use\n //! is parameterized by an instance of `AstConv`.\n \n-use rustc::middle::const_val::eval_length;\n+use rustc::middle::const_val::ConstVal;\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n use hir;\n use hir::def::Def;\n@@ -1082,11 +1082,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 self.associated_path_def_to_ty(ast_ty.id, ast_ty.span, ty, def, segment).0\n             }\n             hir::TyArray(ref ty, length) => {\n-                if let Ok(length) = eval_length(tcx, length, \"array length\") {\n-                    tcx.mk_array(self.ast_ty_to_ty(&ty), length)\n-                } else {\n-                    self.tcx().types.err\n-                }\n+                let length_def_id = tcx.hir.body_owner_def_id(length);\n+                let substs = Substs::identity_for_item(tcx, length_def_id);\n+                let length = tcx.mk_const(ty::Const {\n+                    val: ConstVal::Unevaluated(length_def_id, substs),\n+                    ty: tcx.types.usize\n+                });\n+                let array_ty = tcx.mk_ty(ty::TyArray(self.ast_ty_to_ty(&ty), length));\n+                self.normalize_ty(ast_ty.span, array_ty)\n             }\n             hir::TyTypeof(ref _e) => {\n                 struct_span_err!(tcx.sess, ast_ty.span, E0516,"}, {"sha": "cbf58209d056aea6ed16e91be89041610f4f55a3", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -264,7 +264,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let expected_ty = self.structurally_resolved_type(pat.span, expected);\n                 let (inner_ty, slice_ty) = match expected_ty.sty {\n                     ty::TyArray(inner_ty, size) => {\n-                        let min_len = before.len() + after.len();\n+                        let size = size.val.to_const_int().unwrap().to_u64().unwrap();\n+                        let min_len = before.len() as u64 + after.len() as u64;\n                         if slice.is_none() {\n                             if min_len != size {\n                                 struct_span_err!("}, {"sha": "07159770d5ba2a15766553e188692c9fed78f434", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -192,6 +192,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     ty::Predicate::TypeOutlives(..) => None,\n                     ty::Predicate::WellFormed(..) => None,\n                     ty::Predicate::ObjectSafe(..) => None,\n+                    ty::Predicate::ConstEvaluatable(..) => None,\n \n                     // NB: This predicate is created by breaking down a\n                     // `ClosureType: FnFoo()` predicate, where"}, {"sha": "fa8d3b9bcc1cb41cc2eb5df9f32285a90d9c9b96", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -360,7 +360,7 @@ pub fn check_platform_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             match name[\"simd_shuffle\".len()..].parse() {\n                 Ok(n) => {\n                     let params = vec![param(0), param(0),\n-                                      tcx.mk_ty(ty::TyArray(tcx.types.u32, n))];\n+                                      tcx.mk_array(tcx.types.u32, n)];\n                     (2, params, param(1))\n                 }\n                 Err(_) => {"}, {"sha": "7b94781832512da2fecc36399fcecdee1e84d4a9", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -590,7 +590,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                     ty::Predicate::WellFormed(..) |\n                     ty::Predicate::ObjectSafe(..) |\n                     ty::Predicate::ClosureKind(..) |\n-                    ty::Predicate::TypeOutlives(..) => None,\n+                    ty::Predicate::TypeOutlives(..) |\n+                    ty::Predicate::ConstEvaluatable(..) => None,\n                 }\n             })\n             .collect();"}, {"sha": "ae2430990ba5794d008b7a83d10809325eba0a12", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -128,7 +128,6 @@ use rustc::hir::map::Node;\n use rustc::hir::{self, PatKind};\n use rustc::middle::lang_items;\n use rustc_back::slice;\n-use rustc::middle::const_val::eval_length;\n use rustc_const_math::ConstInt;\n \n mod autoderef;\n@@ -2636,7 +2635,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             ast::LitKind::Str(..) => tcx.mk_static_str(),\n             ast::LitKind::ByteStr(ref v) => {\n                 tcx.mk_imm_ref(tcx.types.re_static,\n-                                tcx.mk_array(tcx.types.u8, v.len()))\n+                                tcx.mk_array(tcx.types.u8, v.len() as u64))\n             }\n             ast::LitKind::Byte(_) => tcx.types.u8,\n             ast::LitKind::Char(_) => tcx.types.char,\n@@ -3895,11 +3894,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n               } else {\n                   self.next_ty_var(TypeVariableOrigin::TypeInference(expr.span))\n               };\n-              tcx.mk_array(element_ty, args.len())\n+              tcx.mk_array(element_ty, args.len() as u64)\n           }\n           hir::ExprRepeat(ref element, count) => {\n-            let count = eval_length(self.tcx, count, \"repeat count\")\n-                  .unwrap_or(0);\n+            let count_def_id = tcx.hir.body_owner_def_id(count);\n+            let param_env = ty::ParamEnv::empty(traits::Reveal::UserFacing);\n+            let substs = Substs::identity_for_item(tcx.global_tcx(), count_def_id);\n+            let count = tcx.const_eval(param_env.and((count_def_id, substs)));\n+\n+            if let Err(ref err) = count {\n+               err.report(tcx, tcx.def_span(count_def_id), \"constant expression\");\n+            }\n \n             let uty = match expected {\n                 ExpectHasType(uty) => {\n@@ -3923,17 +3928,24 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             };\n \n-            if count > 1 {\n-                // For [foo, ..n] where n > 1, `foo` must have\n-                // Copy type:\n-                let lang_item = self.tcx.require_lang_item(lang_items::CopyTraitLangItem);\n-                self.require_type_meets(t, expr.span, traits::RepeatVec, lang_item);\n+            if let Ok(count) = count {\n+                let zero_or_one = count.val.to_const_int().and_then(|count| {\n+                    count.to_u64().map(|count| count <= 1)\n+                }).unwrap_or(false);\n+                if !zero_or_one {\n+                    // For [foo, ..n] where n > 1, `foo` must have\n+                    // Copy type:\n+                    let lang_item = self.tcx.require_lang_item(lang_items::CopyTraitLangItem);\n+                    self.require_type_meets(t, expr.span, traits::RepeatVec, lang_item);\n+                }\n             }\n \n             if element_ty.references_error() {\n                 tcx.types.err\n+            } else if let Ok(count) = count {\n+                tcx.mk_ty(ty::TyArray(t, count))\n             } else {\n-                tcx.mk_array(t, count)\n+                tcx.types.err\n             }\n           }\n           hir::ExprTup(ref elts) => {"}, {"sha": "609af638e97c65476968fc3300fd81db87284bac", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -511,7 +511,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                             ty::Predicate::Subtype(..) |\n                             ty::Predicate::Projection(..) |\n                             ty::Predicate::ClosureKind(..) |\n-                            ty::Predicate::ObjectSafe(..) =>\n+                            ty::Predicate::ObjectSafe(..) |\n+                            ty::Predicate::ConstEvaluatable(..) =>\n                                 vec![],\n \n                             ty::Predicate::WellFormed(subty) => {"}, {"sha": "1735ec7cc698c29788d0cdc51a0aa3de97536420", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -572,7 +572,7 @@ fn convert_enum_variant_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n \n             match result {\n-                Ok(ConstVal::Integral(x)) => Some(x),\n+                Ok(&ty::Const { val: ConstVal::Integral(x), .. }) => Some(x),\n                 _ => None\n             }\n         } else if let Some(discr) = repr_type.disr_incr(tcx, prev_discr) {"}, {"sha": "ce3bf896256eca3efbcd73d11d5534bc929711e6", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -27,11 +27,13 @@ use syntax::ptr::P;\n use syntax::symbol::keywords;\n use syntax_pos::{self, DUMMY_SP, Pos};\n \n+use rustc::middle::const_val::ConstVal;\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::resolve_lifetime as rl;\n use rustc::middle::lang_items;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc::traits::Reveal;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, AdtKind};\n use rustc::middle::stability;\n@@ -40,6 +42,7 @@ use rustc_typeck::hir_ty_to_ty;\n \n use rustc::hir;\n \n+use rustc_const_math::ConstInt;\n use std::{mem, slice, vec};\n use std::path::PathBuf;\n use std::rc::Rc;\n@@ -934,6 +937,7 @@ impl<'a> Clean<WherePredicate> for ty::Predicate<'a> {\n             Predicate::WellFormed(_) => panic!(\"not user writable\"),\n             Predicate::ObjectSafe(_) => panic!(\"not user writable\"),\n             Predicate::ClosureKind(..) => panic!(\"not user writable\"),\n+            Predicate::ConstEvaluatable(..) => panic!(\"not user writable\"),\n         }\n     }\n }\n@@ -1555,7 +1559,7 @@ pub enum Type {\n     BareFunction(Box<BareFunctionDecl>),\n     Tuple(Vec<Type>),\n     Slice(Box<Type>),\n-    Array(Box<Type>, usize),\n+    Array(Box<Type>, String),\n     Never,\n     Unique(Box<Type>),\n     RawPointer(Mutability, Box<Type>),\n@@ -1782,9 +1786,16 @@ impl Clean<Type> for hir::Ty {\n                              type_: box m.ty.clean(cx)}\n             }\n             TySlice(ref ty) => Slice(box ty.clean(cx)),\n-            TyArray(ref ty, length) => {\n-                use rustc::middle::const_val::eval_length;\n-                let n = eval_length(cx.tcx, length, \"array length\").unwrap();\n+            TyArray(ref ty, n) => {\n+                let def_id = cx.tcx.hir.body_owner_def_id(n);\n+                let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n+                let substs = Substs::identity_for_item(cx.tcx, def_id);\n+                let n = cx.tcx.const_eval(param_env.and((def_id, substs))).unwrap();\n+                let n = if let ConstVal::Integral(ConstInt::Usize(n)) = n.val {\n+                    n.to_string()\n+                } else {\n+                    format!(\"{:?}\", n)\n+                };\n                 Array(box ty.clean(cx), n)\n             },\n             TyTup(ref tys) => Tuple(tys.clean(cx)),\n@@ -1895,7 +1906,14 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n             ty::TyFloat(float_ty) => Primitive(float_ty.into()),\n             ty::TyStr => Primitive(PrimitiveType::Str),\n             ty::TySlice(ty) => Slice(box ty.clean(cx)),\n-            ty::TyArray(ty, n) => Array(box ty.clean(cx), n),\n+            ty::TyArray(ty, n) => {\n+                let n = if let ConstVal::Integral(ConstInt::Usize(n)) = n.val {\n+                    n.to_string()\n+                } else {\n+                    format!(\"{:?}\", n)\n+                };\n+                Array(box ty.clean(cx), n)\n+            }\n             ty::TyRawPtr(mt) => RawPointer(mt.mutbl.clean(cx), box mt.ty.clean(cx)),\n             ty::TyRef(r, mt) => BorrowedRef {\n                 lifetime: r.clean(cx),"}, {"sha": "6303fd662bf2b02871540c151be9e507422bbdd9", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -633,7 +633,7 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt:\n             fmt::Display::fmt(t, f)?;\n             primitive_link(f, PrimitiveType::Slice, \"]\")\n         }\n-        clean::Array(ref t, n) => {\n+        clean::Array(ref t, ref n) => {\n             primitive_link(f, PrimitiveType::Array, \"[\")?;\n             fmt::Display::fmt(t, f)?;\n             primitive_link(f, PrimitiveType::Array, &format!(\"; {}]\", n))"}, {"sha": "9563ccfcc65fd9e9617a4c29e2226ccb82e0eb72", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -32,6 +32,7 @@ extern crate html_diff;\n extern crate libc;\n extern crate rustc;\n extern crate rustc_data_structures;\n+extern crate rustc_const_math;\n extern crate rustc_trans;\n extern crate rustc_driver;\n extern crate rustc_resolve;"}, {"sha": "707037911015cc50bc7ee0759f3f46471fc481f2", "filename": "src/test/compile-fail/const-block-non-item-statement-3.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement-3.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+type Array = [u32; {  let x = 2; 5 }];\n+//~^ ERROR: blocks in constants are limited to items and tail expressions\n+//~^^ ERROR: blocks in constants are limited to items and tail expressions\n+\n+pub fn main() {}"}, {"sha": "802e660b9048db4a68133b9849b254add584d278", "filename": "src/test/compile-fail/const-block-non-item-statement.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -14,8 +14,4 @@ enum Foo {\n     //~^^ ERROR: blocks in constants are limited to items and tail expressions\n }\n \n-type Array = [u32; {  let x = 2; 5 }];\n-//~^ ERROR: blocks in constants are limited to items and tail expressions\n-//~^^ ERROR: blocks in constants are limited to items and tail expressions\n-\n pub fn main() {}"}, {"sha": "385daef44dfe54a27db729d344af2ae20ff51f3a", "filename": "src/test/compile-fail/const-fn-error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Ftest%2Fcompile-fail%2Fconst-fn-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Ftest%2Fcompile-fail%2Fconst-fn-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-fn-error.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -23,5 +23,5 @@ const fn f(x: usize) -> usize {\n \n #[allow(unused_variables)]\n fn main() {\n-    let a : [i32; f(X)]; //~ NOTE for array length here\n+    let a : [i32; f(X)]; //~ NOTE for constant expression here\n }"}, {"sha": "3c84810554214c4fa9b548cfc8188b822a3bc09a", "filename": "src/test/compile-fail/const-len-underflow-separate-spans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-separate-spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-separate-spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-separate-spans.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -20,5 +20,5 @@ const LEN: usize = ONE - TWO;\n \n fn main() {\n     let a: [i8; LEN] = unimplemented!();\n-    //~^ NOTE for array length here\n+    //~^ NOTE for constant expression here\n }"}, {"sha": "cbeafdfe6acc97eeb74a2b337920af6c177299bf", "filename": "src/test/compile-fail/const-size_of-cycle.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Ftest%2Fcompile-fail%2Fconst-size_of-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Ftest%2Fcompile-fail%2Fconst-size_of-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-size_of-cycle.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -8,11 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// error-pattern: unsupported cyclic reference between types/traits detected\n+\n #![feature(const_fn)]\n \n struct Foo {\n     bytes: [u8; std::mem::size_of::<Foo>()]\n-    //~^ ERROR unsupported cyclic reference between types/traits detected\n }\n \n fn main() {}"}, {"sha": "97456c2da87fec29571e500861ce315c0d653e24", "filename": "src/test/compile-fail/issue-22933-2.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Ftest%2Fcompile-fail%2Fissue-22933-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Ftest%2Fcompile-fail%2Fissue-22933-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22933-2.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -15,7 +15,4 @@ enum Delicious {\n     //~^ ERROR no associated item named `PIE` found for type `Delicious`\n }\n \n-const FOO: [u32; u8::MIN as usize] = [];\n-//~^ ERROR no associated item named `MIN` found for type `u8`\n-\n fn main() {}"}, {"sha": "62adae41adfc8ae283858981aaefd6f18f1dd2ea", "filename": "src/test/compile-fail/issue-22933-3.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Ftest%2Fcompile-fail%2Fissue-22933-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Ftest%2Fcompile-fail%2Fissue-22933-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22933-3.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const FOO: [u32; u8::MIN as usize] = [];\n+//~^ ERROR no associated item named `MIN` found for type `u8`\n+\n+fn main() {}"}, {"sha": "2da21fb14bd3c483314f6d6edec946643d5ea54f", "filename": "src/test/compile-fail/issue-39559.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Ftest%2Fcompile-fail%2Fissue-39559.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Ftest%2Fcompile-fail%2Fissue-39559.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-39559.rs?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -21,8 +21,9 @@ impl Dim for Dim3 {\n }\n \n pub struct Vector<T, D: Dim> {\n-    entries: [T; D::dim()]\n+    entries: [T; D::dim()],\n     //~^ ERROR no function or associated item named `dim` found for type `D` in the current scope\n+    _dummy: D,\n }\n \n fn main() {}"}, {"sha": "d49741f25b9f5c61bc8452406d9fb7fe37ad10b6", "filename": "src/test/ui/issue-38875/issue_38875.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Ftest%2Fui%2Fissue-38875%2Fissue_38875.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d/src%2Ftest%2Fui%2Fissue-38875%2Fissue_38875.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-38875%2Fissue_38875.stderr?ref=3cb24bd37bcc46ecbb1f5f3f96f9d1de0aa7e92d", "patch": "@@ -4,7 +4,7 @@ error[E0080]: constant evaluation error\n 11 | pub const FOO: usize = *&0;\n    |                        ^^^ unimplemented constant expression: deref operation\n    |\n-note: for repeat count here\n+note: for constant expression here\n   --> $DIR/issue_38875.rs:16:22\n    |\n 16 |     let test_x = [0; issue_38875_b::FOO];"}]}