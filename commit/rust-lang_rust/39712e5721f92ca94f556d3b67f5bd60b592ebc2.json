{"sha": "39712e5721f92ca94f556d3b67f5bd60b592ebc2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5NzEyZTU3MjFmOTJjYTk0ZjU1NmQzYjY3ZjViZDYwYjU5MmViYzI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-03-22T16:22:55Z"}, "committer": {"name": "csmoe", "email": "35686186+csmoe@users.noreply.github.com", "date": "2018-03-23T01:22:08Z"}, "message": "rename `'tcx` and `tcx` to `'gcx` and `gcx`\n\nThis helps to make clear where *global* lifetimes are needed\nin `coerce_unsized_info`", "tree": {"sha": "e4d374c18b84ac5b1c59ee4017a8264b1174633f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4d374c18b84ac5b1c59ee4017a8264b1174633f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39712e5721f92ca94f556d3b67f5bd60b592ebc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39712e5721f92ca94f556d3b67f5bd60b592ebc2", "html_url": "https://github.com/rust-lang/rust/commit/39712e5721f92ca94f556d3b67f5bd60b592ebc2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39712e5721f92ca94f556d3b67f5bd60b592ebc2/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "csmoe", "id": 35686186, "node_id": "MDQ6VXNlcjM1Njg2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/35686186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csmoe", "html_url": "https://github.com/csmoe", "followers_url": "https://api.github.com/users/csmoe/followers", "following_url": "https://api.github.com/users/csmoe/following{/other_user}", "gists_url": "https://api.github.com/users/csmoe/gists{/gist_id}", "starred_url": "https://api.github.com/users/csmoe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csmoe/subscriptions", "organizations_url": "https://api.github.com/users/csmoe/orgs", "repos_url": "https://api.github.com/users/csmoe/repos", "events_url": "https://api.github.com/users/csmoe/events{/privacy}", "received_events_url": "https://api.github.com/users/csmoe/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8179a4be8aa2aeff32d1e8aca1bb58aee4271533", "url": "https://api.github.com/repos/rust-lang/rust/commits/8179a4be8aa2aeff32d1e8aca1bb58aee4271533", "html_url": "https://github.com/rust-lang/rust/commit/8179a4be8aa2aeff32d1e8aca1bb58aee4271533"}], "stats": {"total": 52, "additions": 26, "deletions": 26}, "files": [{"sha": "aa4322783c606741805d835572e949208cc3cb79", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/39712e5721f92ca94f556d3b67f5bd60b592ebc2/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39712e5721f92ca94f556d3b67f5bd60b592ebc2/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=39712e5721f92ca94f556d3b67f5bd60b592ebc2", "patch": "@@ -172,34 +172,34 @@ fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n                                      impl_did: DefId)\n                                      -> CoerceUnsizedInfo {\n     debug!(\"compute_coerce_unsized_info(impl_did={:?})\", impl_did);\n-    let coerce_unsized_trait = tcx.lang_items().coerce_unsized_trait().unwrap();\n+    let coerce_unsized_trait = gcx.lang_items().coerce_unsized_trait().unwrap();\n \n-    let unsize_trait = match tcx.lang_items().require(UnsizeTraitLangItem) {\n+    let unsize_trait = match gcx.lang_items().require(UnsizeTraitLangItem) {\n         Ok(id) => id,\n         Err(err) => {\n-            tcx.sess.fatal(&format!(\"`CoerceUnsized` implementation {}\", err));\n+            gcx.sess.fatal(&format!(\"`CoerceUnsized` implementation {}\", err));\n         }\n     };\n \n     // this provider should only get invoked for local def-ids\n-    let impl_node_id = tcx.hir.as_local_node_id(impl_did).unwrap_or_else(|| {\n+    let impl_node_id = gcx.hir.as_local_node_id(impl_did).unwrap_or_else(|| {\n         bug!(\"coerce_unsized_info: invoked for non-local def-id {:?}\", impl_did)\n     });\n \n-    let source = tcx.type_of(impl_did);\n-    let trait_ref = tcx.impl_trait_ref(impl_did).unwrap();\n+    let source = gcx.type_of(impl_did);\n+    let trait_ref = gcx.impl_trait_ref(impl_did).unwrap();\n     assert_eq!(trait_ref.def_id, coerce_unsized_trait);\n     let target = trait_ref.substs.type_at(1);\n     debug!(\"visit_implementation_of_coerce_unsized: {:?} -> {:?} (bound)\",\n            source,\n            target);\n \n-    let span = tcx.hir.span(impl_node_id);\n-    let param_env = tcx.param_env(impl_did);\n+    let span = gcx.hir.span(impl_node_id);\n+    let param_env = gcx.param_env(impl_did);\n     assert!(!source.has_escaping_regions());\n \n     let err_info = CoerceUnsizedInfo { custom_kind: None };\n@@ -208,11 +208,11 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            source,\n            target);\n \n-    tcx.infer_ctxt().enter(|infcx| {\n+    gcx.infer_ctxt().enter(|infcx| {\n         let cause = ObligationCause::misc(span, impl_node_id);\n-        let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>,\n-                           mt_b: ty::TypeAndMut<'tcx>,\n-                           mk_ptr: &Fn(Ty<'tcx>) -> Ty<'tcx>| {\n+        let check_mutbl = |mt_a: ty::TypeAndMut<'gcx>,\n+                           mt_b: ty::TypeAndMut<'gcx>,\n+                           mk_ptr: &Fn(Ty<'gcx>) -> Ty<'gcx>| {\n             if (mt_a.mutbl, mt_b.mutbl) == (hir::MutImmutable, hir::MutMutable) {\n                 infcx.report_mismatched_types(&cause,\n                                              mk_ptr(mt_b.ty),\n@@ -225,20 +225,20 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let (source, target, trait_def_id, kind) = match (&source.sty, &target.sty) {\n             (&ty::TyRef(r_a, mt_a), &ty::TyRef(r_b, mt_b)) => {\n                 infcx.sub_regions(infer::RelateObjectBound(span), r_b, r_a);\n-                check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ref(r_b, ty))\n+                check_mutbl(mt_a, mt_b, &|ty| gcx.mk_imm_ref(r_b, ty))\n             }\n \n             (&ty::TyRef(_, mt_a), &ty::TyRawPtr(mt_b)) |\n             (&ty::TyRawPtr(mt_a), &ty::TyRawPtr(mt_b)) => {\n-                check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ptr(ty))\n+                check_mutbl(mt_a, mt_b, &|ty| gcx.mk_imm_ptr(ty))\n             }\n \n             (&ty::TyAdt(def_a, substs_a), &ty::TyAdt(def_b, substs_b)) if def_a.is_struct() &&\n                                                                           def_b.is_struct() => {\n                 if def_a != def_b {\n-                    let source_path = tcx.item_path_str(def_a.did);\n-                    let target_path = tcx.item_path_str(def_b.did);\n-                    span_err!(tcx.sess,\n+                    let source_path = gcx.item_path_str(def_a.did);\n+                    let target_path = gcx.item_path_str(def_b.did);\n+                    span_err!(gcx.sess,\n                               span,\n                               E0377,\n                               \"the trait `CoerceUnsized` may only be implemented \\\n@@ -292,9 +292,9 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 let diff_fields = fields.iter()\n                     .enumerate()\n                     .filter_map(|(i, f)| {\n-                        let (a, b) = (f.ty(tcx, substs_a), f.ty(tcx, substs_b));\n+                        let (a, b) = (f.ty(gcx, substs_a), f.ty(gcx, substs_b));\n \n-                        if tcx.type_of(f.did).is_phantom_data() {\n+                        if gcx.type_of(f.did).is_phantom_data() {\n                             // Ignore PhantomData fields\n                             return None;\n                         }\n@@ -321,22 +321,22 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     .collect::<Vec<_>>();\n \n                 if diff_fields.is_empty() {\n-                    span_err!(tcx.sess,\n+                    span_err!(gcx.sess,\n                               span,\n                               E0374,\n                               \"the trait `CoerceUnsized` may only be implemented \\\n                                for a coercion between structures with one field \\\n                                being coerced, none found\");\n                     return err_info;\n                 } else if diff_fields.len() > 1 {\n-                    let item = tcx.hir.expect_item(impl_node_id);\n+                    let item = gcx.hir.expect_item(impl_node_id);\n                     let span = if let ItemImpl(.., Some(ref t), _, _) = item.node {\n                         t.path.span\n                     } else {\n-                        tcx.hir.span(impl_node_id)\n+                        gcx.hir.span(impl_node_id)\n                     };\n \n-                    let mut err = struct_span_err!(tcx.sess,\n+                    let mut err = struct_span_err!(gcx.sess,\n                                                    span,\n                                                    E0375,\n                                                    \"implementing the trait \\\n@@ -363,7 +363,7 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n \n             _ => {\n-                span_err!(tcx.sess,\n+                span_err!(gcx.sess,\n                           span,\n                           E0376,\n                           \"the trait `CoerceUnsized` may only be implemented \\\n@@ -376,7 +376,7 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         // Register an obligation for `A: Trait<B>`.\n         let cause = traits::ObligationCause::misc(span, impl_node_id);\n-        let predicate = tcx.predicate_for_trait_def(param_env,\n+        let predicate = gcx.predicate_for_trait_def(param_env,\n                                                     cause,\n                                                     trait_def_id,\n                                                     0,"}]}