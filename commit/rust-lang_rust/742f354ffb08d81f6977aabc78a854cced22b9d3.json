{"sha": "742f354ffb08d81f6977aabc78a854cced22b9d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0MmYzNTRmZmIwOGQ4MWY2OTc3YWFiYzc4YTg1NGNjZWQyMmI5ZDM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-12T01:03:22Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-14T00:14:28Z"}, "message": "std: Convert records to structs in getopts", "tree": {"sha": "c5b72ab5c7c014004bbc2d8ac3204c8b566dbea6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5b72ab5c7c014004bbc2d8ac3204c8b566dbea6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/742f354ffb08d81f6977aabc78a854cced22b9d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/742f354ffb08d81f6977aabc78a854cced22b9d3", "html_url": "https://github.com/rust-lang/rust/commit/742f354ffb08d81f6977aabc78a854cced22b9d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/742f354ffb08d81f6977aabc78a854cced22b9d3/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa4fbd51f6f8248e4308e079cbf2fc5588e08955", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa4fbd51f6f8248e4308e079cbf2fc5588e08955", "html_url": "https://github.com/rust-lang/rust/commit/fa4fbd51f6f8248e4308e079cbf2fc5588e08955"}], "stats": {"total": 75, "additions": 42, "deletions": 33}, "files": [{"sha": "e7851b3ecb97e1eb97f6c915192bf28889c82006", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 42, "deletions": 33, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/742f354ffb08d81f6977aabc78a854cced22b9d3/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/742f354ffb08d81f6977aabc78a854cced22b9d3/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=742f354ffb08d81f6977aabc78a854cced22b9d3", "patch": "@@ -89,7 +89,11 @@ enum HasArg { Yes, No, Maybe, }\n enum Occur { Req, Optional, Multi, }\n \n /// A description of a possible option\n-pub type Opt = {name: Name, hasarg: HasArg, occur: Occur};\n+pub struct Opt {\n+    name: Name,\n+    hasarg: HasArg,\n+    occur: Occur\n+}\n \n fn mkname(nm: &str) -> Name {\n     let unm = str::from_slice(nm);\n@@ -143,35 +147,35 @@ impl Opt : Eq {\n \n /// Create an option that is required and takes an argument\n pub fn reqopt(name: &str) -> Opt {\n-    return {name: mkname(name), hasarg: Yes, occur: Req};\n+    return Opt {name: mkname(name), hasarg: Yes, occur: Req};\n }\n \n /// Create an option that is optional and takes an argument\n pub fn optopt(name: &str) -> Opt {\n-    return {name: mkname(name), hasarg: Yes, occur: Optional};\n+    return Opt {name: mkname(name), hasarg: Yes, occur: Optional};\n }\n \n /// Create an option that is optional and does not take an argument\n pub fn optflag(name: &str) -> Opt {\n-    return {name: mkname(name), hasarg: No, occur: Optional};\n+    return Opt {name: mkname(name), hasarg: No, occur: Optional};\n }\n \n /// Create an option that is optional and does not take an argument\n pub fn optflagmulti(name: &str) -> Opt {\n-    return {name: mkname(name), hasarg: No, occur: Multi};\n+    return Opt {name: mkname(name), hasarg: No, occur: Multi};\n }\n \n /// Create an option that is optional and takes an optional argument\n pub fn optflagopt(name: &str) -> Opt {\n-    return {name: mkname(name), hasarg: Maybe, occur: Optional};\n+    return Opt {name: mkname(name), hasarg: Maybe, occur: Optional};\n }\n \n /**\n  * Create an option that is optional, takes an argument, and may occur\n  * multiple times\n  */\n pub fn optmulti(name: &str) -> Opt {\n-    return {name: mkname(name), hasarg: Yes, occur: Multi};\n+    return Opt {name: mkname(name), hasarg: Yes, occur: Multi};\n }\n \n enum Optval { Val(~str), Given, }\n@@ -180,7 +184,11 @@ enum Optval { Val(~str), Given, }\n  * The result of checking command line arguments. Contains a vector\n  * of matches and a vector of free strings.\n  */\n-pub type Matches = {opts: ~[Opt], vals: ~[~[Optval]], free: ~[~str]};\n+pub struct Matches {\n+    opts: ~[Opt],\n+    vals: ~[~[Optval]],\n+    free: ~[~str]\n+}\n \n impl Optval : Eq {\n     pure fn eq(&self, other: &Optval) -> bool {\n@@ -410,7 +418,7 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result unsafe {\n         }\n         i += 1;\n     }\n-    return Ok({opts: vec::from_slice(opts),\n+    return Ok(Matches {opts: vec::from_slice(opts),\n                vals: vec::from_mut(move vals),\n                free: free});\n }\n@@ -538,14 +546,14 @@ pub mod groups {\n     /** one group of options, e.g., both -h and --help, along with\n      * their shared description and properties\n      */\n-    pub type OptGroup = {\n+    pub struct OptGroup {\n         short_name: ~str,\n         long_name: ~str,\n         hint: ~str,\n         desc: ~str,\n         hasarg: HasArg,\n         occur: Occur\n-    };\n+    }\n \n     impl OptGroup : Eq {\n         pure fn eq(&self, other: &OptGroup) -> bool {\n@@ -566,7 +574,7 @@ pub mod groups {\n                   desc: &str, hint: &str) -> OptGroup {\n         let len = short_name.len();\n         assert len == 1 || len == 0;\n-        return {short_name: str::from_slice(short_name),\n+        return OptGroup { short_name: str::from_slice(short_name),\n                 long_name: str::from_slice(long_name),\n                 hint: str::from_slice(hint),\n                 desc: str::from_slice(desc),\n@@ -579,7 +587,7 @@ pub mod groups {\n                   desc: &str, hint: &str) -> OptGroup {\n         let len = short_name.len();\n         assert len == 1 || len == 0;\n-        return {short_name: str::from_slice(short_name),\n+        return OptGroup {short_name: str::from_slice(short_name),\n                 long_name: str::from_slice(long_name),\n                 hint: str::from_slice(hint),\n                 desc: str::from_slice(desc),\n@@ -592,7 +600,7 @@ pub mod groups {\n                    desc: &str) -> OptGroup {\n         let len = short_name.len();\n         assert len == 1 || len == 0;\n-        return {short_name: str::from_slice(short_name),\n+        return OptGroup {short_name: str::from_slice(short_name),\n                 long_name: str::from_slice(long_name),\n                 hint: ~\"\",\n                 desc: str::from_slice(desc),\n@@ -605,7 +613,7 @@ pub mod groups {\n                       desc: &str, hint: &str) -> OptGroup {\n         let len = short_name.len();\n         assert len == 1 || len == 0;\n-        return {short_name: str::from_slice(short_name),\n+        return OptGroup {short_name: str::from_slice(short_name),\n                 long_name: str::from_slice(long_name),\n                 hint: str::from_slice(hint),\n                 desc: str::from_slice(desc),\n@@ -621,7 +629,7 @@ pub mod groups {\n                     desc: &str, hint: &str) -> OptGroup {\n         let len = short_name.len();\n         assert len == 1 || len == 0;\n-        return {short_name: str::from_slice(short_name),\n+        return OptGroup {short_name: str::from_slice(short_name),\n                 long_name: str::from_slice(long_name),\n                 hint: str::from_slice(hint),\n                 desc: str::from_slice(desc),\n@@ -637,20 +645,20 @@ pub mod groups {\n \n            (0,0) => fail ~\"this long-format option was given no name\",\n \n-           (0,_) => ~[{name:   Long(((*lopt).long_name)),\n-                       hasarg: (*lopt).hasarg,\n-                       occur:  (*lopt).occur}],\n+           (0,_) => ~[Opt {name:   Long(((*lopt).long_name)),\n+                           hasarg: (*lopt).hasarg,\n+                           occur:  (*lopt).occur}],\n \n-           (1,0) => ~[{name:  Short(str::char_at((*lopt).short_name, 0)),\n-                       hasarg: (*lopt).hasarg,\n-                       occur:  (*lopt).occur}],\n+           (1,0) => ~[Opt {name: Short(str::char_at((*lopt).short_name, 0)),\n+                           hasarg: (*lopt).hasarg,\n+                           occur:  (*lopt).occur}],\n \n-           (1,_) => ~[{name:   Short(str::char_at((*lopt).short_name, 0)),\n-                       hasarg: (*lopt).hasarg,\n-                       occur:  (*lopt).occur},\n-                      {name:   Long(((*lopt).long_name)),\n-                       hasarg: (*lopt).hasarg,\n-                       occur:  (*lopt).occur}],\n+           (1,_) => ~[Opt {name: Short(str::char_at((*lopt).short_name, 0)),\n+                           hasarg: (*lopt).hasarg,\n+                           occur:  (*lopt).occur},\n+                      Opt {name:   Long(((*lopt).long_name)),\n+                           hasarg: (*lopt).hasarg,\n+                           occur:  (*lopt).occur}],\n \n            (_,_) => fail ~\"something is wrong with the long-form opt\"\n         }\n@@ -725,6 +733,7 @@ mod tests {\n     #[legacy_exports];\n     use opt = getopts;\n     use result::{Err, Ok};\n+    use opt::groups::OptGroup;\n \n     fn check_fail_type(f: Fail_, ft: FailType) {\n         match f {\n@@ -1291,7 +1300,7 @@ mod tests {\n     #[test]\n     fn test_groups_reqopt() {\n         let opt = groups::reqopt(~\"b\", ~\"banana\", ~\"some bananas\", ~\"VAL\");\n-        assert opt == { short_name: ~\"b\",\n+        assert opt == OptGroup { short_name: ~\"b\",\n                         long_name: ~\"banana\",\n                         hint: ~\"VAL\",\n                         desc: ~\"some bananas\",\n@@ -1302,7 +1311,7 @@ mod tests {\n     #[test]\n     fn test_groups_optopt() {\n         let opt = groups::optopt(~\"a\", ~\"apple\", ~\"some apples\", ~\"VAL\");\n-        assert opt == { short_name: ~\"a\",\n+        assert opt == OptGroup { short_name: ~\"a\",\n                         long_name: ~\"apple\",\n                         hint: ~\"VAL\",\n                         desc: ~\"some apples\",\n@@ -1313,7 +1322,7 @@ mod tests {\n     #[test]\n     fn test_groups_optflag() {\n         let opt = groups::optflag(~\"k\", ~\"kiwi\", ~\"some kiwis\");\n-        assert opt == { short_name: ~\"k\",\n+        assert opt == OptGroup { short_name: ~\"k\",\n                         long_name: ~\"kiwi\",\n                         hint: ~\"\",\n                         desc: ~\"some kiwis\",\n@@ -1325,7 +1334,7 @@ mod tests {\n     fn test_groups_optflagopt() {\n         let opt = groups::optflagopt(~\"p\", ~\"pineapple\",\n                                        ~\"some pineapples\", ~\"VAL\");\n-        assert opt == { short_name: ~\"p\",\n+        assert opt == OptGroup { short_name: ~\"p\",\n                         long_name: ~\"pineapple\",\n                         hint: ~\"VAL\",\n                         desc: ~\"some pineapples\",\n@@ -1337,7 +1346,7 @@ mod tests {\n     fn test_groups_optmulti() {\n         let opt = groups::optmulti(~\"l\", ~\"lime\",\n                                      ~\"some limes\", ~\"VAL\");\n-        assert opt == { short_name: ~\"l\",\n+        assert opt == OptGroup { short_name: ~\"l\",\n                         long_name: ~\"lime\",\n                         hint: ~\"VAL\",\n                         desc: ~\"some limes\","}]}