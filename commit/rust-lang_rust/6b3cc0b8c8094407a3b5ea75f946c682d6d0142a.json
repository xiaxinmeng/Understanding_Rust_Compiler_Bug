{"sha": "6b3cc0b8c8094407a3b5ea75f946c682d6d0142a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiM2NjMGI4YzgwOTQ0MDdhM2I1ZWE3NWY5NDZjNjgyZDZkMDE0MmE=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-10-25T23:28:20Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-09T23:44:53Z"}, "message": "rustc_typeck: correctly track \"always-diverges\" and \"has-type-errors\".", "tree": {"sha": "3d20a8543875e9ebc867a9281fd6d3d6bf411c53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d20a8543875e9ebc867a9281fd6d3d6bf411c53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a", "html_url": "https://github.com/rust-lang/rust/commit/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff0830d74985246c2e2bbd28e7d8c0ef072e2458", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff0830d74985246c2e2bbd28e7d8c0ef072e2458", "html_url": "https://github.com/rust-lang/rust/commit/ff0830d74985246c2e2bbd28e7d8c0ef072e2458"}], "stats": {"total": 557, "additions": 345, "deletions": 212}, "files": [{"sha": "853f81ceaa9b8746ddf9a9df54414671d7e07c4c", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=6b3cc0b8c8094407a3b5ea75f946c682d6d0142a", "patch": "@@ -53,7 +53,7 @@ pub unsafe extern fn __rust_maybe_catch_panic(f: fn(*mut u8),\n // now hopefully.\n #[no_mangle]\n pub unsafe extern fn __rust_start_panic(_data: usize, _vtable: usize) -> u32 {\n-    return abort();\n+    abort();\n \n     #[cfg(unix)]\n     unsafe fn abort() -> ! {"}, {"sha": "7e60c40220f84eed8acb55dac747dc42f71be9c6", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=6b3cc0b8c8094407a3b5ea75f946c682d6d0142a", "patch": "@@ -455,8 +455,6 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n             1 => panic!(\"make_input should have provided valid inputs\"),\n             _ => early_error(sopts.error_format, \"multiple input filenames provided\"),\n         }\n-\n-        None\n     }\n \n     fn late_callback(&mut self,"}, {"sha": "ca630624cdb3889aafc18b40fce0b4e1b2ccc8af", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=6b3cc0b8c8094407a3b5ea75f946c682d6d0142a", "patch": "@@ -13,7 +13,7 @@ use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::infer::{self, InferOk, TypeOrigin};\n use rustc::ty::{self, Ty, TypeFoldable, LvaluePreference};\n-use check::{FnCtxt, Expectation};\n+use check::{FnCtxt, Expectation, Diverges};\n use util::nodemap::FxHashMap;\n \n use std::collections::hash_map::Entry::{Occupied, Vacant};\n@@ -360,9 +360,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n         true\n     }\n-}\n \n-impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn check_match(&self,\n                        expr: &'gcx hir::Expr,\n                        discrim: &'gcx hir::Expr,\n@@ -390,14 +388,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             discrim_ty = self.next_ty_var();\n             self.check_expr_has_type(discrim, discrim_ty);\n         };\n+        let discrim_diverges = self.diverges.get();\n+        self.diverges.set(Diverges::Maybe);\n \n         // Typecheck the patterns first, so that we get types for all the\n         // bindings.\n-        for arm in arms {\n+        let all_arm_pats_diverge: Vec<_> = arms.iter().map(|arm| {\n+            let mut all_pats_diverge = Diverges::WarnedAlways;\n             for p in &arm.pats {\n+                self.diverges.set(Diverges::Maybe);\n                 self.check_pat(&p, discrim_ty);\n+                all_pats_diverge &= self.diverges.get();\n             }\n-        }\n+            all_pats_diverge\n+        }).collect();\n \n         // Now typecheck the blocks.\n         //\n@@ -410,6 +414,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // type in that case)\n         let expected = expected.adjust_for_branches(self);\n         let mut result_ty = self.next_diverging_ty_var();\n+        let mut all_arms_diverge = Diverges::WarnedAlways;\n         let coerce_first = match expected {\n             // We don't coerce to `()` so that if the match expression is a\n             // statement it's branches can have any consistent type. That allows\n@@ -422,11 +427,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             _ => result_ty\n         };\n \n-        for (i, arm) in arms.iter().enumerate() {\n+        for (i, (arm, pats_diverge)) in arms.iter().zip(all_arm_pats_diverge).enumerate() {\n             if let Some(ref e) = arm.guard {\n+                self.diverges.set(pats_diverge);\n                 self.check_expr_has_type(e, tcx.types.bool);\n             }\n+\n+            self.diverges.set(pats_diverge);\n             let arm_ty = self.check_expr_with_expectation(&arm.body, expected);\n+            all_arms_diverge &= self.diverges.get();\n \n             if result_ty.references_error() || arm_ty.references_error() {\n                 result_ty = tcx.types.err;\n@@ -476,11 +485,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n         }\n \n+        // We won't diverge unless the discriminant or all arms diverge.\n+        self.diverges.set(discrim_diverges | all_arms_diverge);\n+\n         result_ty\n     }\n-}\n \n-impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn check_pat_struct(&self,\n                         pat: &'gcx hir::Pat,\n                         path: &hir::Path,"}, {"sha": "f6f585eb05f5f254b03f3c23bb04f5a83cc8a147", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 291, "deletions": 166, "changes": 457, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6b3cc0b8c8094407a3b5ea75f946c682d6d0142a", "patch": "@@ -106,17 +106,18 @@ use util::common::{block_query, ErrorReported, indenter, loop_query};\n use util::nodemap::{DefIdMap, FxHashMap, FxHashSet, NodeMap};\n \n use std::cell::{Cell, Ref, RefCell};\n+use std::cmp;\n use std::mem::replace;\n-use std::ops::Deref;\n+use std::ops::{self, Deref};\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n-use syntax::codemap::{self, Spanned};\n+use syntax::codemap::{self, original_sp, Spanned};\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::parse::token::{self, InternedString, keywords};\n use syntax::ptr::P;\n use syntax::util::lev_distance::find_best_match_for_name;\n-use syntax_pos::{self, Span};\n+use syntax_pos::{self, BytePos, Span};\n \n use rustc::hir::intravisit::{self, Visitor};\n use rustc::hir::{self, PatKind};\n@@ -351,6 +352,59 @@ impl UnsafetyState {\n     }\n }\n \n+/// Whether a node ever exits normally or not.\n+/// Tracked semi-automatically (through type variables\n+/// marked as diverging), with some manual adjustments\n+/// for control-flow primitives (approximating a CFG).\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n+enum Diverges {\n+    /// Potentially unknown, some cases converge,\n+    /// others require a CFG to determine them.\n+    Maybe,\n+\n+    /// Definitely known to diverge and therefore\n+    /// not reach the next sibling or its parent.\n+    Always,\n+\n+    /// Same as `Always` but with a reachability\n+    /// warning already emitted\n+    WarnedAlways\n+}\n+\n+// Convenience impls for combinig `Diverges`.\n+\n+impl ops::BitAnd for Diverges {\n+    type Output = Self;\n+    fn bitand(self, other: Self) -> Self {\n+        cmp::min(self, other)\n+    }\n+}\n+\n+impl ops::BitOr for Diverges {\n+    type Output = Self;\n+    fn bitor(self, other: Self) -> Self {\n+        cmp::max(self, other)\n+    }\n+}\n+\n+impl ops::BitAndAssign for Diverges {\n+    fn bitand_assign(&mut self, other: Self) {\n+        *self = *self & other;\n+    }\n+}\n+\n+impl ops::BitOrAssign for Diverges {\n+    fn bitor_assign(&mut self, other: Self) {\n+        *self = *self | other;\n+    }\n+}\n+\n+impl Diverges {\n+    fn always(self) -> bool {\n+        self >= Diverges::Always\n+    }\n+}\n+\n #[derive(Clone)]\n pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     ast_ty_to_ty_cache: RefCell<NodeMap<Ty<'tcx>>>,\n@@ -371,6 +425,12 @@ pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     ps: RefCell<UnsafetyState>,\n \n+    /// Whether the last checked node can ever exit.\n+    diverges: Cell<Diverges>,\n+\n+    /// Whether any child nodes have any type errors.\n+    has_errors: Cell<bool>,\n+\n     inh: &'a Inherited<'a, 'gcx, 'tcx>,\n }\n \n@@ -1491,6 +1551,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             ret_ty: rty,\n             ps: RefCell::new(UnsafetyState::function(hir::Unsafety::Normal,\n                                                      ast::CRATE_NODE_ID)),\n+            diverges: Cell::new(Diverges::Maybe),\n+            has_errors: Cell::new(false),\n             inh: inh,\n         }\n     }\n@@ -1507,6 +1569,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.tcx.sess.err_count() - self.err_count_on_creation\n     }\n \n+    /// Produce warning on the given node, if the current point in the\n+    /// function is unreachable, and there hasn't been another warning.\n+    fn warn_if_unreachable(&self, id: ast::NodeId, span: Span, kind: &str) {\n+        if self.diverges.get() == Diverges::Always {\n+            self.diverges.set(Diverges::WarnedAlways);\n+\n+            self.tcx.sess.add_lint(lint::builtin::UNREACHABLE_CODE,\n+                                   id, span,\n+                                   format!(\"unreachable {}\", kind));\n+        }\n+    }\n+\n     /// Resolves type variables in `ty` if possible. Unlike the infcx\n     /// version (resolve_type_vars_if_possible), this version will\n     /// also select obligations if it seems useful, in an effort\n@@ -1577,6 +1651,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"write_ty({}, {:?}) in fcx {}\",\n                node_id, ty, self.tag());\n         self.tables.borrow_mut().node_types.insert(node_id, ty);\n+\n+        if ty.references_error() {\n+            self.has_errors.set(true);\n+        }\n+\n+        // FIXME(canndrew): This is_never should probably be an is_uninhabited\n+        if ty.is_never() || self.type_var_diverges(ty) {\n+            self.diverges.set(self.diverges.get() | Diverges::Always);\n+        }\n     }\n \n     pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::ItemSubsts<'tcx>) {\n@@ -2512,21 +2595,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Check the arguments.\n         // We do this in a pretty awful way: first we typecheck any arguments\n-        // that are not anonymous functions, then we typecheck the anonymous\n-        // functions. This is so that we have more information about the types\n-        // of arguments when we typecheck the functions. This isn't really the\n-        // right way to do this.\n-        let xs = [false, true];\n-        let mut any_diverges = false; // has any of the arguments diverged?\n-        let mut warned = false; // have we already warned about unreachable code?\n-        for check_blocks in &xs {\n-            let check_blocks = *check_blocks;\n-            debug!(\"check_blocks={}\", check_blocks);\n+        // that are not closures, then we typecheck the closures. This is so\n+        // that we have more information about the types of arguments when we\n+        // typecheck the functions. This isn't really the right way to do this.\n+        for &check_closures in &[false, true] {\n+            debug!(\"check_closures={}\", check_closures);\n \n             // More awful hacks: before we check argument types, try to do\n             // an \"opportunistic\" vtable resolution of any trait bounds on\n             // the call. This helps coercions.\n-            if check_blocks {\n+            if check_closures {\n                 self.select_obligations_where_possible();\n             }\n \n@@ -2541,61 +2619,43 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 supplied_arg_count\n             };\n             for (i, arg) in args.iter().take(t).enumerate() {\n-                if any_diverges && !warned {\n-                    self.tcx\n-                        .sess\n-                        .add_lint(lint::builtin::UNREACHABLE_CODE,\n-                                  arg.id,\n-                                  arg.span,\n-                                  \"unreachable expression\".to_string());\n-                    warned = true;\n+                // Warn only for the first loop (the \"no closures\" one).\n+                // Closure arguments themselves can't be diverging, but\n+                // a previous argument can, e.g. `foo(panic!(), || {})`.\n+                if !check_closures {\n+                    self.warn_if_unreachable(arg.id, arg.span, \"expression\");\n                 }\n-                let is_block = match arg.node {\n+\n+                let is_closure = match arg.node {\n                     hir::ExprClosure(..) => true,\n                     _ => false\n                 };\n \n-                if is_block == check_blocks {\n-                    debug!(\"checking the argument\");\n-                    let formal_ty = formal_tys[i];\n+                if is_closure != check_closures {\n+                    continue;\n+                }\n \n-                    // The special-cased logic below has three functions:\n-                    // 1. Provide as good of an expected type as possible.\n-                    let expected = expected_arg_tys.get(i).map(|&ty| {\n-                        Expectation::rvalue_hint(self, ty)\n-                    });\n+                debug!(\"checking the argument\");\n+                let formal_ty = formal_tys[i];\n \n-                    let checked_ty = self.check_expr_with_expectation(&arg,\n-                                            expected.unwrap_or(ExpectHasType(formal_ty)));\n-                    // 2. Coerce to the most detailed type that could be coerced\n-                    //    to, which is `expected_ty` if `rvalue_hint` returns an\n-                    //    `ExpectHasType(expected_ty)`, or the `formal_ty` otherwise.\n-                    let coerce_ty = expected.and_then(|e| e.only_has_type(self));\n-                    self.demand_coerce(&arg, checked_ty, coerce_ty.unwrap_or(formal_ty));\n-\n-                    // 3. Relate the expected type and the formal one,\n-                    //    if the expected type was used for the coercion.\n-                    coerce_ty.map(|ty| self.demand_suptype(arg.span, formal_ty, ty));\n-                }\n+                // The special-cased logic below has three functions:\n+                // 1. Provide as good of an expected type as possible.\n+                let expected = expected_arg_tys.get(i).map(|&ty| {\n+                    Expectation::rvalue_hint(self, ty)\n+                });\n \n-                if let Some(&arg_ty) = self.tables.borrow().node_types.get(&arg.id) {\n-                    // FIXME(canndrew): This is_never should probably be an is_uninhabited\n-                    any_diverges = any_diverges ||\n-                                   self.type_var_diverges(arg_ty) ||\n-                                   arg_ty.is_never();\n-                }\n-            }\n-            if any_diverges && !warned {\n-                let parent = self.tcx.map.get_parent_node(args[0].id);\n-                self.tcx\n-                    .sess\n-                    .add_lint(lint::builtin::UNREACHABLE_CODE,\n-                              parent,\n-                              sp,\n-                              \"unreachable call\".to_string());\n-                warned = true;\n+                let checked_ty = self.check_expr_with_expectation(&arg,\n+                                        expected.unwrap_or(ExpectHasType(formal_ty)));\n+                // 2. Coerce to the most detailed type that could be coerced\n+                //    to, which is `expected_ty` if `rvalue_hint` returns an\n+                //    `ExpectHasType(expected_ty)`, or the `formal_ty` otherwise.\n+                let coerce_ty = expected.and_then(|e| e.only_has_type(self));\n+                self.demand_coerce(&arg, checked_ty, coerce_ty.unwrap_or(formal_ty));\n+\n+                // 3. Relate the expected type and the formal one,\n+                //    if the expected type was used for the coercion.\n+                coerce_ty.map(|ty| self.demand_suptype(arg.span, formal_ty, ty));\n             }\n-\n         }\n \n         // We also need to make sure we at least write the ty of the other\n@@ -2846,18 +2906,23 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                        sp: Span,\n                        expected: Expectation<'tcx>) -> Ty<'tcx> {\n         let cond_ty = self.check_expr_has_type(cond_expr, self.tcx.types.bool);\n+        let cond_diverges = self.diverges.get();\n+        self.diverges.set(Diverges::Maybe);\n \n         let expected = expected.adjust_for_branches(self);\n         let then_ty = self.check_block_with_expected(then_blk, expected);\n+        let then_diverges = self.diverges.get();\n+        self.diverges.set(Diverges::Maybe);\n \n         let unit = self.tcx.mk_nil();\n         let (origin, expected, found, result) =\n         if let Some(else_expr) = opt_else_expr {\n             let else_ty = self.check_expr_with_expectation(else_expr, expected);\n-            let origin = TypeOrigin::IfExpression(sp);\n+            let else_diverges = self.diverges.get();\n \n             // Only try to coerce-unify if we have a then expression\n             // to assign coercions to, otherwise it's () or diverging.\n+            let origin = TypeOrigin::IfExpression(sp);\n             let result = if let Some(ref then) = then_blk.expr {\n                 let res = self.try_find_coercion_lub(origin, || Some(&**then),\n                                                      then_ty, else_expr, else_ty);\n@@ -2883,8 +2948,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         })\n                 })\n             };\n+\n+            // We won't diverge unless both branches do (or the condition does).\n+            self.diverges.set(cond_diverges | then_diverges & else_diverges);\n+\n             (origin, then_ty, else_ty, result)\n         } else {\n+            // If the condition is false we can't diverge.\n+            self.diverges.set(cond_diverges);\n+\n             let origin = TypeOrigin::IfExpressionWithNoElse(sp);\n             (origin, unit, then_ty,\n              self.eq_types(true, origin, unit, then_ty)\n@@ -3346,10 +3418,36 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                    lvalue_pref: LvaluePreference) -> Ty<'tcx> {\n         debug!(\">> typechecking: expr={:?} expected={:?}\",\n                expr, expected);\n+\n+        // Warn for expressions after diverging siblings.\n+        self.warn_if_unreachable(expr.id, expr.span, \"expression\");\n+\n+        // Hide the outer diverging and has_errors flags.\n+        let old_diverges = self.diverges.get();\n+        let old_has_errors = self.has_errors.get();\n+        self.diverges.set(Diverges::Maybe);\n+        self.has_errors.set(false);\n+\n         let ty = self.check_expr_kind(expr, expected, lvalue_pref);\n \n+        // Warn for non-block expressions with diverging children.\n+        match expr.node {\n+            hir::ExprBlock(_) |\n+            hir::ExprLoop(..) | hir::ExprWhile(..) |\n+            hir::ExprIf(..) | hir::ExprMatch(..) => {}\n+\n+            _ => self.warn_if_unreachable(expr.id, expr.span, \"expression\")\n+        }\n+\n+        // Record the type, which applies it effects.\n+        // We need to do this after the warning above, so that\n+        // we don't warn for the diverging expression itself.\n         self.write_ty(expr.id, ty);\n \n+        // Combine the diverging and has_error flags.\n+        self.diverges.set(self.diverges.get() | old_diverges);\n+        self.has_errors.set(self.has_errors.get() | old_has_errors);\n+\n         debug!(\"type of expr({}) {} is...\", expr.id,\n                pprust::expr_to_string(expr));\n         debug!(\"... {:?}, expected is {:?}\",\n@@ -3574,22 +3672,29 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                  expr.span, expected)\n           }\n           hir::ExprWhile(ref cond, ref body, _) => {\n-            let cond_ty = self.check_expr_has_type(&cond, tcx.types.bool);\n+            self.check_expr_has_type(&cond, tcx.types.bool);\n+            let cond_diverging = self.diverges.get();\n             self.check_block_no_value(&body);\n-            let body_ty = self.node_ty(body.id);\n-            if cond_ty.references_error() || body_ty.references_error() {\n+\n+            // We may never reach the body so it diverging means nothing.\n+            self.diverges.set(cond_diverging);\n+\n+            if self.has_errors.get() {\n                 tcx.types.err\n-            }\n-            else {\n+            } else {\n                 tcx.mk_nil()\n             }\n           }\n           hir::ExprLoop(ref body, _) => {\n             self.check_block_no_value(&body);\n-            if !may_break(tcx, expr.id, &body) {\n-                tcx.types.never\n-            } else {\n+            if may_break(tcx, expr.id, &body) {\n+                // No way to know whether it's diverging because\n+                // of a `break` or an outer `break` or `return.\n+                self.diverges.set(Diverges::Maybe);\n+\n                 tcx.mk_nil()\n+            } else {\n+                tcx.types.never\n             }\n           }\n           hir::ExprMatch(ref discrim, ref arms, match_src) => {\n@@ -3922,55 +4027,66 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn check_stmt(&self, stmt: &'gcx hir::Stmt) {\n-        let node_id;\n-        let mut saw_bot = false;\n-        let mut saw_err = false;\n+        // Don't do all the complex logic below for DeclItem.\n         match stmt.node {\n-          hir::StmtDecl(ref decl, id) => {\n-            node_id = id;\n-            match decl.node {\n-              hir::DeclLocal(ref l) => {\n-                  self.check_decl_local(&l);\n-                  let l_t = self.node_ty(l.id);\n-                  saw_bot = saw_bot || self.type_var_diverges(l_t);\n-                  saw_err = saw_err || l_t.references_error();\n-              }\n-              hir::DeclItem(_) => {/* ignore for now */ }\n+            hir::StmtDecl(ref decl, id) => {\n+                match decl.node {\n+                    hir::DeclLocal(_) => {}\n+                    hir::DeclItem(_) => {\n+                        self.write_nil(id);\n+                        return;\n+                    }\n+                }\n             }\n-          }\n-          hir::StmtExpr(ref expr, id) => {\n-            node_id = id;\n-            // Check with expected type of ()\n-            let ty = self.check_expr_has_type(&expr, self.tcx.mk_nil());\n-            saw_bot = saw_bot || self.type_var_diverges(ty);\n-            saw_err = saw_err || ty.references_error();\n-          }\n-          hir::StmtSemi(ref expr, id) => {\n-            node_id = id;\n-            let ty = self.check_expr(&expr);\n-            saw_bot |= self.type_var_diverges(ty);\n-            saw_err |= ty.references_error();\n-          }\n+            hir::StmtExpr(..) | hir::StmtSemi(..) => {}\n         }\n-        if saw_bot {\n-            self.write_ty(node_id, self.next_diverging_ty_var());\n-        }\n-        else if saw_err {\n+\n+        self.warn_if_unreachable(stmt.node.id(), stmt.span, \"statement\");\n+\n+        // Hide the outer diverging and has_errors flags.\n+        let old_diverges = self.diverges.get();\n+        let old_has_errors = self.has_errors.get();\n+        self.diverges.set(Diverges::Maybe);\n+        self.has_errors.set(false);\n+\n+        let node_id = match stmt.node {\n+            hir::StmtDecl(ref decl, id) => {\n+                match decl.node {\n+                    hir::DeclLocal(ref l) => {\n+                        self.check_decl_local(&l);\n+                    }\n+                    hir::DeclItem(_) => {/* ignore for now */ }\n+                }\n+                id\n+            }\n+            hir::StmtExpr(ref expr, id) => {\n+                // Check with expected type of ()\n+                self.check_expr_has_type(&expr, self.tcx.mk_nil());\n+                id\n+            }\n+            hir::StmtSemi(ref expr, id) => {\n+                self.check_expr(&expr);\n+                id\n+            }\n+        };\n+\n+        if self.has_errors.get() {\n             self.write_error(node_id);\n-        }\n-        else {\n+        } else if self.diverges.get().always() {\n+            self.write_ty(node_id, self.next_diverging_ty_var());\n+        } else {\n             self.write_nil(node_id);\n         }\n+\n+        // Combine the diverging and has_error flags.\n+        self.diverges.set(self.diverges.get() | old_diverges);\n+        self.has_errors.set(self.has_errors.get() | old_has_errors);\n     }\n \n     pub fn check_block_no_value(&self, blk: &'gcx hir::Block)  {\n-        let blkty = self.check_block_with_expected(blk, ExpectHasType(self.tcx.mk_nil()));\n-        if blkty.references_error() {\n-            self.write_error(blk.id);\n-        } else {\n-            let nilty = self.tcx.mk_nil();\n-            self.demand_suptype(blk.span, nilty, blkty);\n-        }\n+        let unit = self.tcx.mk_nil();\n+        let ty = self.check_block_with_expected(blk, ExpectHasType(unit));\n+        self.demand_suptype(blk.span, unit, ty);\n     }\n \n     fn check_block_with_expected(&self,\n@@ -3982,72 +4098,81 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             replace(&mut *fcx_ps, unsafety_state)\n         };\n \n-        let mut warned = false;\n-        let mut any_diverges = false;\n-        let mut any_err = false;\n         for s in &blk.stmts {\n             self.check_stmt(s);\n-            let s_id = s.node.id();\n-            let s_ty = self.node_ty(s_id);\n-            if any_diverges && !warned && match s.node {\n-                hir::StmtDecl(ref decl, _) => {\n-                    match decl.node {\n-                        hir::DeclLocal(_) => true,\n-                        _ => false,\n+        }\n+\n+        let mut ty = match blk.expr {\n+            Some(ref e) => self.check_expr_with_expectation(e, expected),\n+            None => self.tcx.mk_nil()\n+        };\n+\n+        if self.diverges.get().always() {\n+            if let ExpectHasType(ety) = expected {\n+                // Avoid forcing a type (only `!` for now) in unreachable code.\n+                // FIXME(aburka) do we need this special case? and should it be is_uninhabited?\n+                if !ety.is_never() {\n+                    if let Some(ref e) = blk.expr {\n+                        // Coerce the tail expression to the right type.\n+                        self.demand_coerce(e, ty, ety);\n                     }\n                 }\n-                hir::StmtExpr(..) | hir::StmtSemi(..) => true,\n-            } {\n-                self.tcx\n-                    .sess\n-                    .add_lint(lint::builtin::UNREACHABLE_CODE,\n-                              s_id,\n-                              s.span,\n-                              \"unreachable statement\".to_string());\n-                warned = true;\n             }\n-            // FIXME(canndrew): This is_never should probably be an is_uninhabited\n-            any_diverges = any_diverges ||\n-                           self.type_var_diverges(s_ty) ||\n-                           s_ty.is_never();\n-            any_err = any_err || s_ty.references_error();\n-        }\n-        let ty = match blk.expr {\n-            None => if any_err {\n-                self.tcx.types.err\n-            } else if any_diverges {\n-                self.next_diverging_ty_var()\n+\n+            ty = self.next_diverging_ty_var();\n+        } else if let ExpectHasType(ety) = expected {\n+            if let Some(ref e) = blk.expr {\n+                // Coerce the tail expression to the right type.\n+                self.demand_coerce(e, ty, ety);\n             } else {\n-                self.tcx.mk_nil()\n-            },\n-            Some(ref e) => {\n-                if any_diverges && !warned {\n-                    self.tcx\n-                        .sess\n-                        .add_lint(lint::builtin::UNREACHABLE_CODE,\n-                                  e.id,\n-                                  e.span,\n-                                  \"unreachable expression\".to_string());\n-                }\n-                let ety = match expected {\n-                    ExpectHasType(ety) => {\n-                        self.check_expr_coercable_to_type(&e, ety);\n-                        ety\n-                    }\n-                    _ => {\n-                        self.check_expr_with_expectation(&e, expected)\n-                    }\n-                };\n+                // We're not diverging and there's an expected type, which,\n+                // in case it's not `()`, could result in an error higher-up.\n+                // We have a chance to error here early and be more helpful.\n+                let origin = TypeOrigin::Misc(blk.span);\n+                let trace = TypeTrace::types(origin, false, ty, ety);\n+                match self.sub_types(false, origin, ty, ety) {\n+                    Ok(InferOk { obligations, .. }) => {\n+                        // FIXME(#32730) propagate obligations\n+                        assert!(obligations.is_empty());\n+                    },\n+                    Err(err) => {\n+                        let mut err = self.report_and_explain_type_error(trace, &err);\n+\n+                        // Be helpful when the user wrote `{... expr;}` and\n+                        // taking the `;` off is enough to fix the error.\n+                        let mut extra_semi = None;\n+                        if let Some(stmt) = blk.stmts.last() {\n+                            if let hir::StmtSemi(ref e, _) = stmt.node {\n+                                if self.can_sub_types(self.node_ty(e.id), ety).is_ok() {\n+                                    extra_semi = Some(stmt);\n+                                }\n+                            }\n+                        }\n+                        if let Some(last_stmt) = extra_semi {\n+                            let original_span = original_sp(self.tcx.sess.codemap(),\n+                                                            last_stmt.span, blk.span);\n+                            let span_semi = Span {\n+                                lo: original_span.hi - BytePos(1),\n+                                hi: original_span.hi,\n+                                expn_id: original_span.expn_id\n+                            };\n+                            err.span_help(span_semi, \"consider removing this semicolon:\");\n+                        }\n \n-                if any_err {\n-                    self.tcx.types.err\n-                } else if any_diverges {\n-                    self.next_diverging_ty_var()\n-                } else {\n-                    ety\n+                        err.emit();\n+                    }\n                 }\n             }\n-        };\n+\n+            // We already applied the type (and potentially errored),\n+            // use the expected type to avoid further errors out.\n+            ty = ety;\n+        }\n+\n+        if self.has_errors.get() || ty.references_error() {\n+            ty = self.tcx.types.err\n+        }\n+\n         self.write_ty(blk.id, ty);\n \n         *self.ps.borrow_mut() = prev;"}, {"sha": "8b4975b7e3a2f723331219af60397986596beed3", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=6b3cc0b8c8094407a3b5ea75f946c682d6d0142a", "patch": "@@ -75,8 +75,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         match BinOpCategory::from(op) {\n             BinOpCategory::Shortcircuit => {\n                 // && and || are a simple case.\n+                let lhs_diverges = self.diverges.get();\n                 self.demand_suptype(lhs_expr.span, tcx.mk_bool(), lhs_ty);\n                 self.check_expr_coercable_to_type(rhs_expr, tcx.mk_bool());\n+\n+                // Depending on the LHS' value, the RHS can never execute.\n+                self.diverges.set(lhs_diverges);\n+\n                 tcx.mk_bool()\n             }\n             _ => {"}, {"sha": "11d90658ab26a710394018faf64437376534dab4", "filename": "src/test/compile-fail/E0138.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2FE0138.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2FE0138.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0138.rs?ref=6b3cc0b8c8094407a3b5ea75f946c682d6d0142a", "patch": "@@ -11,10 +11,10 @@\n #![feature(start)]\n \n #[start]\n-fn foo(argc: isize, argv: *const *const u8) -> isize {}\n+fn foo(argc: isize, argv: *const *const u8) -> isize { 0 }\n //~^ NOTE previous `start` function here\n \n #[start]\n-fn f(argc: isize, argv: *const *const u8) -> isize {}\n+fn f(argc: isize, argv: *const *const u8) -> isize { 0 }\n //~^ ERROR E0138\n //~| NOTE multiple `start` functions"}, {"sha": "530a0e415622815150b4d26221f1bbf95ea9561c", "filename": "src/test/compile-fail/consider-removing-last-semi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fconsider-removing-last-semi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fconsider-removing-last-semi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconsider-removing-last-semi.rs?ref=6b3cc0b8c8094407a3b5ea75f946c682d6d0142a", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn f() -> String {  //~ ERROR E0269\n+fn f() -> String {  //~ ERROR mismatched types\n     0u8;\n     \"bla\".to_string();  //~ HELP consider removing this semicolon\n }\n \n-fn g() -> String {  //~ ERROR E0269\n+fn g() -> String {  //~ ERROR mismatched types\n     \"this won't work\".to_string();\n     \"removeme\".to_string(); //~ HELP consider removing this semicolon\n }"}, {"sha": "3a27c084133283775744cedb465c7c06446523b3", "filename": "src/test/compile-fail/diverging-fn-tail-35849.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fdiverging-fn-tail-35849.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fdiverging-fn-tail-35849.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdiverging-fn-tail-35849.rs?ref=6b3cc0b8c8094407a3b5ea75f946c682d6d0142a", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn _converge() -> ! { //~ ERROR computation may converge\n-    42\n+fn _converge() -> ! {\n+    42 //~ ERROR mismatched types\n }\n \n fn main() { }"}, {"sha": "192f78e41cb43cdf23d71c231f4661fc63ac3870", "filename": "src/test/compile-fail/issue-11714.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fissue-11714.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fissue-11714.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11714.rs?ref=6b3cc0b8c8094407a3b5ea75f946c682d6d0142a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn blah() -> i32 { //~ ERROR not all control paths return a value\n+fn blah() -> i32 { //~ ERROR mismatched types\n     1\n \n     ; //~ HELP consider removing this semicolon:"}, {"sha": "9406199afc231904e58df233178c4f6c544673eb", "filename": "src/test/compile-fail/issue-13428.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fissue-13428.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fissue-13428.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13428.rs?ref=6b3cc0b8c8094407a3b5ea75f946c682d6d0142a", "patch": "@@ -10,15 +10,15 @@\n \n // Regression test for #13428\n \n-fn foo() -> String {  //~ ERROR not all control paths return a value\n+fn foo() -> String {  //~ ERROR mismatched types\n     format!(\"Hello {}\",\n             \"world\")\n     // Put the trailing semicolon on its own line to test that the\n     // note message gets the offending semicolon exactly\n     ;   //~ HELP consider removing this semicolon\n }\n \n-fn bar() -> String {  //~ ERROR not all control paths return a value\n+fn bar() -> String {  //~ ERROR mismatched types\n     \"foobar\".to_string()\n     ;   //~ HELP consider removing this semicolon\n }"}, {"sha": "81f66e3e2cfeeb855648c2ae8b1d4af4a89a2674", "filename": "src/test/compile-fail/issue-22645.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fissue-22645.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fissue-22645.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22645.rs?ref=6b3cc0b8c8094407a3b5ea75f946c682d6d0142a", "patch": "@@ -17,7 +17,7 @@ struct Bob;\n \n impl<RHS: Scalar> Add <RHS> for Bob {\n   type Output = Bob;\n-  fn add(self, rhs : RHS) -> Bob {}\n+  fn add(self, rhs : RHS) -> Bob { Bob }\n }\n \n fn main() {"}, {"sha": "a791758ad1763c630ae2fb9e3ae7454c81da4a57", "filename": "src/test/compile-fail/issue-22684.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fissue-22684.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fissue-22684.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22684.rs?ref=6b3cc0b8c8094407a3b5ea75f946c682d6d0142a", "patch": "@@ -15,7 +15,7 @@ mod foo {\n     }\n \n     pub trait Baz {\n-        fn bar(&self) -> bool {}\n+        fn bar(&self) -> bool { true }\n     }\n     impl Baz for Foo {}\n }"}, {"sha": "97ba222fe45f08204f48595e3a7a21356c302fb3", "filename": "src/test/compile-fail/issue-29161.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fissue-29161.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fissue-29161.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-29161.rs?ref=6b3cc0b8c8094407a3b5ea75f946c682d6d0142a", "patch": "@@ -13,7 +13,7 @@ mod a {\n \n     impl Default for A {\n         pub fn default() -> A { //~ ERROR unnecessary visibility qualifier\n-            A;\n+            A\n         }\n     }\n }"}, {"sha": "e5cb81303277112c6617c62b0ebe70d72c4319a0", "filename": "src/test/compile-fail/issue-32323.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fissue-32323.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fissue-32323.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32323.rs?ref=6b3cc0b8c8094407a3b5ea75f946c682d6d0142a", "patch": "@@ -13,6 +13,6 @@ pub trait Tr<'a> {\n }\n \n pub fn f<'a, T: Tr<'a>>() -> <T as Tr<'a>>::Out {}\n-//~^ ERROR not all control paths return a value\n+//~^ ERROR mismatched types\n \n pub fn main() {}"}, {"sha": "a77b27150d7978e917a44d64b0e45d30dbc0664b", "filename": "src/test/compile-fail/issue-5239-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fissue-5239-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fissue-5239-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5239-1.rs?ref=6b3cc0b8c8094407a3b5ea75f946c682d6d0142a", "patch": "@@ -11,7 +11,7 @@\n // Regression test for issue #5239\n \n fn main() {\n-    let x = |ref x: isize| -> isize { x += 1; };\n+    let x = |ref x: isize| { x += 1; };\n     //~^ ERROR E0368\n     //~| NOTE cannot use `+=` on type `&isize`\n }"}, {"sha": "a078cdea4ac4d70be1c1ee2eb0fc6c1ff04690c7", "filename": "src/test/compile-fail/issue-6458-4.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fissue-6458-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fissue-6458-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6458-4.rs?ref=6b3cc0b8c8094407a3b5ea75f946c682d6d0142a", "patch": "@@ -8,11 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn foo(b: bool) -> Result<bool,String> {\n-    Err(\"bar\".to_string());\n-    //~^ ERROR unable to infer enough type information about `_` [E0282]\n-    //~| NOTE cannot infer type for `_`\n-    //~| NOTE type annotations or generic parameter binding\n+fn foo(b: bool) -> Result<bool,String> { //~ ERROR mismatched types\n+    Err(\"bar\".to_string()); //~ HELP consider removing this semicolon\n }\n \n fn main() {"}, {"sha": "1ee4be08a1c5096e78af89ec9c3d13c39c2b3b87", "filename": "src/test/compile-fail/liveness-forgot-ret.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fliveness-forgot-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fliveness-forgot-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-forgot-ret.rs?ref=6b3cc0b8c8094407a3b5ea75f946c682d6d0142a", "patch": "@@ -8,10 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: not all control paths return a value\n-\n fn god_exists(a: isize) -> bool { return god_exists(a); }\n \n fn f(a: isize) -> isize { if god_exists(a) { return 5; }; }\n+//~^ ERROR mismatched types\n \n fn main() { f(12); }"}, {"sha": "69bceec8c3225ee70366326b172d6b09edbb226a", "filename": "src/test/compile-fail/liveness-issue-2163.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs?ref=6b3cc0b8c8094407a3b5ea75f946c682d6d0142a", "patch": "@@ -13,6 +13,6 @@ use std::vec::Vec;\n fn main() {\n     let a: Vec<isize> = Vec::new();\n     a.iter().all(|_| -> bool {\n-        //~^ ERROR not all control paths return a value\n+        //~^ ERROR mismatched types\n     });\n }"}, {"sha": "a35eb1af4f336ea6019909e9e7518146ed2446da", "filename": "src/test/compile-fail/liveness-missing-ret2.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fliveness-missing-ret2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fliveness-missing-ret2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-missing-ret2.rs?ref=6b3cc0b8c8094407a3b5ea75f946c682d6d0142a", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: not all control paths return a value\n-\n-fn f() -> isize {\n+fn f() -> isize { //~ ERROR mismatched types\n     // Make sure typestate doesn't interpret this match expression as\n     // the function result\n    match true { true => { } _ => {} };"}, {"sha": "ada91c38d48c3fd77b5e19d8b5aa697eb07adff4", "filename": "src/test/compile-fail/liveness-return-last-stmt-semi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fliveness-return-last-stmt-semi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fliveness-return-last-stmt-semi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-return-last-stmt-semi.rs?ref=6b3cc0b8c8094407a3b5ea75f946c682d6d0142a", "patch": "@@ -11,16 +11,16 @@\n // regression test for #8005\n \n macro_rules! test { () => { fn foo() -> i32 { 1; } } }\n-                                           //~^ ERROR not all control paths return a value\n+                                           //~^ ERROR mismatched types\n                                            //~| HELP consider removing this semicolon\n \n-fn no_return() -> i32 {} //~ ERROR  not all control paths return a value\n+fn no_return() -> i32 {} //~ ERROR mismatched types\n \n-fn bar(x: u32) -> u32 { //~ ERROR  not all control paths return a value\n+fn bar(x: u32) -> u32 { //~ ERROR mismatched types\n     x * 2; //~ HELP consider removing this semicolon\n }\n \n-fn baz(x: u64) -> u32 { //~ ERROR  not all control paths return a value\n+fn baz(x: u64) -> u32 { //~ ERROR mismatched types\n     x * 2;\n }\n "}, {"sha": "2878cbc7fc15488d6fcfb865390be929d419f7c9", "filename": "src/test/compile-fail/main-wrong-type-2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type-2.rs?ref=6b3cc0b8c8094407a3b5ea75f946c682d6d0142a", "patch": "@@ -10,4 +10,5 @@\n \n fn main() -> char {\n //~^ ERROR: main function has wrong type\n+    ' '\n }"}, {"sha": "0f4b0919b6500842c7566ceefa0f099fb0a05bf5", "filename": "src/test/compile-fail/on-unimplemented/on-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fon-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fon-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fon-trait.rs?ref=6b3cc0b8c8094407a3b5ea75f946c682d6d0142a", "patch": "@@ -16,7 +16,7 @@ trait Foo<Bar, Baz, Quux>\n {}\n \n fn foobar<U: Clone, T: Foo<u8, U, u32>>() -> T {\n-\n+    panic!()\n }\n \n #[rustc_on_unimplemented=\"a collection of type `{Self}` cannot be built from an iterator over elements of type `{A}`\"]"}, {"sha": "4796548112d9e0ae4b201cda345f95c4b93ec344", "filename": "src/test/compile-fail/private-in-public-lint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-lint.rs?ref=6b3cc0b8c8094407a3b5ea75f946c682d6d0142a", "patch": "@@ -13,7 +13,7 @@ mod m1 {\n     struct Priv;\n \n     impl Pub {\n-        pub fn f() -> Priv {} //~ ERROR private type in public interface\n+        pub fn f() -> Priv {Priv} //~ ERROR private type in public interface\n     }\n }\n \n@@ -24,7 +24,7 @@ mod m2 {\n     struct Priv;\n \n     impl Pub {\n-        pub fn f() -> Priv {} //~ ERROR private type in public interface\n+        pub fn f() -> Priv {Priv} //~ ERROR private type in public interface\n     }\n }\n "}, {"sha": "ce40702b3dc2adff68a339c812cfa578a7c5de1d", "filename": "src/test/compile-fail/required-lang-item.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Frequired-lang-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Frequired-lang-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frequired-lang-item.rs?ref=6b3cc0b8c8094407a3b5ea75f946c682d6d0142a", "patch": "@@ -11,6 +11,7 @@\n #![feature(lang_items, no_core)]\n #![no_core]\n \n+#[lang=\"copy\"] pub trait Copy { }\n #[lang=\"sized\"] pub trait Sized { }\n \n // error-pattern:requires `start` lang_item"}, {"sha": "72462468432d9aedb4a6b49a68d0421f48c119ff", "filename": "src/test/compile-fail/unreachable-in-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Funreachable-in-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Funreachable-in-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funreachable-in-call.rs?ref=6b3cc0b8c8094407a3b5ea75f946c682d6d0142a", "patch": "@@ -24,7 +24,7 @@ fn diverge_first() {\n          get_u8()); //~ ERROR unreachable expression\n }\n fn diverge_second() {\n-    call( //~ ERROR unreachable call\n+    call( //~ ERROR unreachable expression\n         get_u8(),\n         diverge());\n }"}, {"sha": "ffc39008c4e5a1b7ff16274fd63e1c5c485efcaf", "filename": "src/test/compile-fail/where-clauses-unsatisfied.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-unsatisfied.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cc0b8c8094407a3b5ea75f946c682d6d0142a/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-unsatisfied.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-unsatisfied.rs?ref=6b3cc0b8c8094407a3b5ea75f946c682d6d0142a", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn equal<T>(_: &T, _: &T) -> bool where T : Eq {\n-}\n+fn equal<T>(a: &T, b: &T) -> bool where T : Eq { a == b }\n \n struct Struct;\n "}]}